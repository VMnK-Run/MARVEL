{"project": "qemu", "commit_id": "35c5a52d1d016c632aed6137549754ca53446c92", "target": 0, "func": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n", "idx": 24100, "substitutes": {"state": ["seed", "scope", "port", "driver", "id", "rule", "count", "patch", "cache", "type", "states", "new", "instance", "inner", "core", "address", "match", "comment", "old", "art", "user", "name", "post", "context", "key", "parent", "connection", "tag", "info", "conn", "style", "service", "parse", "node", "start", "stat", "use", "grade", "o", "runner", "status", "j", "message", "self", "ace", "update", "session", "master", "resource", "slice", "config", "cfg", "admin", "output", "data", "source", "os", "private", "STATE", "size", "State", "work", "estate", "part", "manager", "area", "local", "public", "settings", "component", "list"], "io": ["ie", "iw", "os", "connection", "timeout", "iol", "lib", "ia", "zip", "ou", "info", "storage", "flow", "IO", "reader", "resource", "uri", "ini", "service", "area", "input", "library", "admin", "i", "f", "cli", "api", "ui", "rio", "co", "o", "client", "ro", "ri"], "fw_cfg": ["wallappcfg", "fwappcfg", "fwappconfig", "wallappregion", "wallappconfig", "fw_config", "wall_region", "wall_config", "fwappregion", "FW_cfg", "fw_region", "fw_gd", "fw2config", "fw_fg", "FW_fg", "wall_cfg", "fw2fg", "wallappfg", "FW_config", "wall_fg", "fw2cfg", "fwappfg", "FW_gd", "fw2gd"], "owner": ["ro", "owned", "parent", "driver", "mode", "own", "ace", "ow", "property", "writer", " ownership", "loader", "creator", "row", "r", "owners", "host", "root", "reader", "Owner", "fork", "instance", "rew", "manager", "container", "ee", "access", "unknown", "head", "mac", "node", "created", "cow", "builder", "org", "name", "slave"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 24103, "substitutes": {"bs": ["js", "b", "pb", "bl", "details", "css", "base", "vs", "bc", "outs", "http", "gs", "bh", "bits", "rs", "os", "bb", "sb", "bos", "fs", "ros", "obs", "ts", "bi", "bing", "las", "ins", "ras", "gb", "cs", "rss", "iss", "lbs", "obj", "ms", "bas", "ns", "oss", "bes", "eb", "BS", "sys", "sync", "ss", "ls", "ds", "cb", "ris", "org", "ses", "ob", "bis", "fb"], "res": ["js", "reset", "remote", "Res", "results", "css", "rx", "rel", "gr", "resolution", "conf", "err", "rows", "proc", "rs", "rem", "req", "os", "resh", "response", "pres", "ros", "r", "resources", "RS", "result", "RES", "resp", "resource", "ver", "rev", "rez", "mr", "ras", "ress", "cs", "rh", "rss", "rc", "details", "bis", "spec", "serv", "rr", "rus", "ris", "reg", "ry", "us", "re", "sys"], "fix": [" prefix", " patch", " sett", " build", " confirm", " reporter", "Fix", " test", " reject", " conf", " error", " _", " update", " debug", " def", " reply", " clear", " spec", " priv", " defaults", " repair", " init", " upgrade", " fixes"], "rebuild": ["reupdate", "reconstruct", " reupdate", "REconstruct", " reconstruct", "reinstall", " reinupdate", " reinstall", "REbuild", "REinstall", "REupdate", " reininstall", " reinconstruct", " reinbuild"], "refcount_table": ["refstart_directory", "refcountingsource", "refcountPquery", "refcountingdirectory", "refcountJtable", "refcountertable", "refcountpcontainer", "refload_tree", "refcountingtab", "refcountPcontainer", "refcount_container", "refcountingTable", "refsum_TABLE", "refcountstotal", "refcountTtable", "refcount_integer", "refsum_table", "refcountJquery", "refcountedwindow", "refcounterservice", "refCountstotal", "refcountingservice", "refcountabledb", "refcountPsequence", "refload_error", "refmatch_container", "refcount_TABLE", "refcount2tree", "refcount_machine", "refcountingwindow", "refcount2table", "refcount64error", "refcount_service", "refcount64TABLE", "refcountpsource", "refcountabletree", "refload_db", "refCount_interface", "refount_queue", "refstart_window", "refcountingtable", "refcountedtable", "refcount_sequence", "refnamePsequence", "refcountTrule", "refcountptable", "refcount_Table", "refmatchptable", "refcount2integer", "refount_table", "refmatch_table", "refcountingerror", "refcountJrule", "refcount_rule", "refcount_error", "refnamePrule", "refcount_tab", "refcount_count", "refname_rule", "refcount2db", "refcountPsource", "refcountinginterface", "refstart_table", "refcounterTABLE", "refload_integer", "refCount_total", "refstartedtab", "refcount_tree", "refload2tree", "refcountPrule", "refcountingTABLE", "refsumingtable", "refstartedwindow", "refcount64table", "refount_database", "refcountedtab", "refcount_window", "refcount_server", "refname_sequence", "refcount64service", "refcountPtable", "refcountJsequence", "refcountTquery", "refcountererror", "refload2table", "refcount_interface", "refmatch_source", "refCount_count", "refsumingTABLE", "refCount_table", "refnamePquery", "refcountstable", "refcounteddirectory", "refcountabletable", "refcount_source", "refstarteddirectory", "refmatchpsource", "refCount_Table", "refcountableinteger", "refount_TABLE", "refcountingcontainer", "refcountscount", "refsumingservice", "refmatchpserver", "refname_query", "refload_interface", "refcountPserver", "refname_table", "refcount_queue", "refload_table", "refcountingserver", "refcountpserver", "refCountstable", "refcount_total", "refcountSerror", "refmatch_server", "refCount_TABLE", "refnamePtable", "refsum_service", "refCountscount", "refload2db", "refsum_error", "refcount_directory", "refstartedtable", "refcountSinterface", "refcountTsequence", "refcount_query", "refmatchpcontainer", "refload_machine", "refsumingerror", "refload2integer", "refstart_tab", "refcountSmachine", "refcountStable", "refcount_database", "refcount_db"], "nb_clusters": ["nb_blusters", "nb_bluster", "nbOfsplusters", "nb_klresses", "nb_clances", "nb_CLorders", "nb_scambers", "nbOfspluster", "nb_laborders", "nb_scusters", "nb_plusters", "nbOfsplros", "nb_helunks", "nb_kluster", "nb_slicas", "nb_lluster", "nb_slances", "nb_slocations", "nb_CLicas", "nb_licicas", "nb_sluster", "nb_splroups", "nb_zusters", "nb_CLroups", "nb_CLuster", "nb_helosures", "nb_clicas", "nb_toprs", "nb_compusters", "nb_clocks", "nb_clros", "nbOfsplroups", "nb_CLrs", "nb_zresses", "nb_clocations", "nb_CLots", "nb_CLusters", "nb_plicas", "nb_pluster", "nbOfcluster", "nb_closures", "nb_slambers", "nb_labocks", "nb_topusters", "nb_slosures", "nb_blots", "nbOfclusters", "nb_licusters", "nb_scunks", "nb_slust", "nb_zuster", "nb_llances", "nbOfclros", "nb_llappers", "nb_cluster", "nb_spluster", "nb_blicas", "nb_slusters", "nb_llusters", "nb_compances", "nb_licots", "nb_topresses", "nb_CLappers", "nb_topuster", "nb_CLresses", "nb_llresses", "nbOfclroups", "nb_compresses", "nb_helambers", "nb_scosures", "nb_clresses", "nb_splusters", "nb_clappers", "nb_klusters", "nb_licuster", "nb_clroups", "nb_labuster", "nb_slresses", "nb_clrs", "nb_CLros", "nb_clunks", "nb_splros", "nb_clambers", "nb_clust", "nb_klrs", "nb_clots", "nb_slunks", "nb_compust", "nb_clorders", "nb_CLocks", "nb_plocations", "nb_llust", "nb_helusters", "nb_zappers", "nb_labusters", "nb_CLocations"], "s": ["js", "b", "S", "rs", "sb", "ssl", "fs", "g", "states", "h", "p", "ess", "args", "sets", "si", "sync", "xs", "a", "n", "qs", "secondary", "conf", "state", "gs", "ubs", "params", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "stats", "site", "its", "details", "css", "self", "ops", "full", "rates", "session", "ts", "sa", "is", "m", "sym", "rss", "sg", "f", "ds", "ses", "bis", "sys", "sl", "results", "http", "os", "r", "ps", "v", "ins", "iss", "ns", "settings", "d", "ls", "services", "comments", "sum"], "i": [" fi", "li", " j", "ie", " error", "id", " r", "iu", "ti", "h", " pri", "ini", "p", "I", " rec", "u", "si", "eni", "ami", "phi", "ci", " rep", "ni", "ji", "mi", "x", "n", " bit", " len", " sup", " li", "gi", "l", " bi", " ti", "qi", "zi", "ii", " resp", "e", "uli", "c", " fin", " err", "ui", " pi", "ri", " fid", "index", " si", "z", "j", " cont", "ix", "fi", "uri", "di", " ii", " response", " rest", "ki", "ai", "mini", "pi", " sig", "yi", " reply", "ip", "bi", "v", "io", "xi", "multi", "chi", " mi", "d", "vi"], "sn": ["span", "sd", "n", "sl", "sr", "sc", "nb", "sv", "sid", "sb", "sh", "ssl", "sp", "ne", "syn", "bn", "dn", "sa", "Sn", "sam", "sk", "cl", "SN", "sm", "cn", "ski", "nn", "ii", "su", "ns", "si", "na", "sync", "fn", "eni", "ls", "sq", "sw", "kn", "ni", "scl", "nr", "fl"], "ret": ["reset", "run", "id", "RET", "req", "final", "result", "url", "ref", "rets", "complete", "match", "hard", "att", "re", "usr", "rep", "art", "en", "repl", "post", "num", "pret", "key", "reply", "mt", "err", "std", "debug", "format", "valid", "let", "gt", "red", "nt", "info", "job", "ber", "conn", "rev", "pre", "arr", "t", "ft", "obj", "rc", "feat", "arg", "pt", "msg", "bf", "val", "pet", "cat", "out", "bit", "opt", "fit", "ext", "rf", "status", "error", "len", "group", "br", "pass", "def", "rt", "f", "str", "data", "back", "Ret", "reg", "flag", "ut", "r", "alt", "det", "part", "fail", "it", "fun", "db", "sec", "lit", "lt", "success", "bad"], "check_errors": [" check_error", " check_success", "checklogerrors", "check_error", "checkNerrors", "check_success", " check_length", "checklogsuccess", "checkNerror", "checkNsuccess", "checkNlength", "checklogerror", "checkloglength", "check_length"]}}
{"project": "qemu", "commit_id": "025b168ca674e42896c573fdbddf3090c6dc0d8f", "target": 1, "func": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n", "idx": 24123, "substitutes": {"q": ["x", "iq", "port", "dq", "Q", "que", "qs", "quad", "quick", "req", "qq", "r", "ip", "g", "cache", "qt", "work", "h", "query", "queue", "p", "qi", "m", "t", "u", "w", "k", "e", "c", "d", "pc", "f", "sq", "back", "qa", "o", "pad"], "addr": ["x", "port", "alias", "base", "ace", "ack", "ptr", "host", "ip", "pkg", "amd", "asm", " address", "work", "conn", "url", "au", "oa", "config", "kt", "address", "ada", "args", "mac", "md", "ar", "amp", "node", "seq", "bridge", "pc", "eni", "data", "ad", "Address", "ord", "adr", "pad", "nr", "pointer", "offset"], "qtd": ["qTD", "qulf", "Qtd", "reqdt", "qdl", "pgdt", "qcd", "Qcd", "pgld", "qld", "quickdt", "reqTD", "reqtd", "questtd", "hdd", "kTD", "ztd", "quicktd", "viewdt", "Qdt", "kdd", "ktd", "htd", "qutd", "questtm", "sqTD", "Qod", "qlf", "zod", "quds", "Qlf", "Qfd", "ktw", "sqdt", "kdt", "Qtm", "querytw", " qld", " qdd", "Qld", " qcd", "qds", "sqtd", "qfd", "sqdd", "questdd", "queryTD", "quickTD", "qupd", "Qdd", "sqlf", "questfd", "querydt", "sqpd", "Qpd", "qudt", " qod", "viewtm", "qpd", "qdt", "qtw", "qtm", "pgtd", "questdl", "questTD", "hdt", "zdd", "Qdl", " qdl", "quickdd", "hcd", "reqdd", "questdt", "viewtd", "qudd", "querytd", "qod", " qdt", "Qds", "sqdl", "viewdd", "QTD", "zdt", " qTD", " qfd", "pgdd", "qdd"]}}
{"project": "qemu", "commit_id": "afea4e1410654154018587dd35c1b250ba4d8ec4", "target": 1, "func": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n", "idx": 24141, "substitutes": {"d": ["b", "sd", "dc", "dos", "ed", "dt", "D", "du", "z", "id", "dh", "dad", "fd", "done", "dom", "dds", "l", "gd", "ded", "did", "bd", "dB", "p", "m", "dm", "t", "ld", "dx", "md", "db", "e", "dd", "c", "ind", "i", "pd", "td", "ds", "dl", "data", "ad", "nd", "dat", "cd"], "s": ["js", "b", "sd", "sf", "sl", "a", "ed", "conf", "z", "sv", "S", "state", "gs", "rs", "er", "os", "ops", "sb", "fs", "g", "session", "ps", "es", "is", "l", "ks", "service", "p", "m", "cs", "t", "sym", "args", "south", "w", "u", "ns", "db", "si", "an", "e", "settings", "c", "sync", "dd", "f", "ss", "i", "ls", "ds", "data", "services", "sq", "o", "se", "ses"]}}
{"project": "FFmpeg", "commit_id": "70f9661542a581dfe93b636b1c55b5558e4a4e3c", "target": 0, "func": "static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame, AVPacket *avpkt)\n\n{\n\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n\n    ThreadFrame frame = { .f = data };\n\n    AVFrame *picture = data;\n\n    int tileno, ret;\n\n\n\n    s->avctx     = avctx;\n\n    s->buf       = s->buf_start = avpkt->data;\n\n    s->buf_end   = s->buf_start + avpkt->size;\n\n    s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles\n\n\n\n    // reduction factor, i.e number of resolution levels to skip\n\n    s->reduction_factor = s->lowres;\n\n\n\n    ff_jpeg2000_init_tier1_luts();\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    // check if the image is in jp2 format\n\n    if ((AV_RB32(s->buf) == 12) &&\n\n        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&\n\n        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {\n\n        if (!jp2_find_codestream(s)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't find jpeg2k codestream atom\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {\n\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n\n        return -1;\n\n    }\n\n    if (ret = jpeg2000_read_main_headers(s))\n\n        goto end;\n\n\n\n    /* get picture buffer */\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"ff_thread_get_buffer() failed.\\n\");\n\n        goto end;\n\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n\n    picture->key_frame = 1;\n\n\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n\n            goto end;\n\n\n\n    *got_frame = 1;\n\n\n\nend:\n\n    jpeg2000_dec_cleanup(s);\n\n    return ret ? ret : s->buf - s->buf_start;\n\n}\n", "idx": 24148, "substitutes": {"avctx": ["afwcs", "avxc", "akcci", "akcontext", "avcci", "evconn", "ovpkg", "afpkg", "AVlc", "avecf", "akcf", "cvcontext", "avpkg", "abctx", " avcontext", "avectx", "afcontext", "cvctl", " avloc", "avecontext", "akconn", "avecci", "abcontext", "afloc", "evcci", "ovcontext", "afkb", "ajcontext", "afxc", "ovcor", "ajcmp", "avcor", "abctl", "afcf", "avctl", "afconfig", "avepkg", "navkb", "avekb", "afcor", "evcontext", "avcf", "abconfig", "afctx", "afconn", "avconn", "ajxc", "akctx", "cvctx", "akxc", "AVcontext", "navcci", "afctl", "AVcf", "evctx", "aveloc", "avcmp", "avconfig", "afcci", "ajctx", "aflc", "avlc", "ajwcs", "navctx", "avecor", "ovctx", "afcmp", "avcontext", "AVcmp", " avpkg", "ajcf", "navcontext", "avkb", "avloc", "AVwcs", "avwcs", "cvconfig", "avelc", "AVctx"], "data": ["buf", "port", "database", "a", "alpha", "da", "base", "mode", "id", "shift", "body", "xxx", "response", "none", "DATA", "header", "len", "current", "function", "window", "done", "image", "cache", "size", "jpg", "result", "open", "reader", "raw", "name", "frame", "empty", "batch", "area", "p", "m", "one", "def", "Data", "init", "input", "buffer", "first", "head", "missing", "feed", "sample", "media", "pad", "file", "block", "d", "start", "f", "i", "img", "gap", "next", "load", "content", "o", "dat", "video"], "got_frame": ["get_image", "got___frame", "get_Frame", "got_Frame", "got__frames", "get_layer", "got___frames", "got__image", "got_layer", "get_figure", "got___layer", "got__frame", "get_frames", "got_figure", "got_image", "got_frames", "get_frame", "got__figure", "got___Frame"], "avpkt": ["avPet", "avjpkt", "avvpkt", "avepkg", "avejpct", "avwacket", "avPct", "avckg", "avwkt", "avvpeth", "avpct", "avbkg", "avfacket", "avpaeth", "avepet", "avvpct", "avbkt", "avpacket", "avepkt", "avpkh", "avepeth", "abpke", "avpakh", "abfkt", "avspkg", "avbct", "abpkg", "avPkg", "avbet", "avPkt", "avfkg", "avjpeth", "avpeth", "avepct", "avpakt", "abpkt", "avwke", "avpke", "avpact", "avejpkt", "avebkt", "avspke", "avvpkh", "avwkg", "avpkg", "abfke", "abfkg", "avfkt", "avcct", "abpacket", "avfke", "avepkh", "avcet", "avckt", "avejpkh", "abfacket", "avebet", "avspacket", "avejpeth", "avjpct", "avspkt", "avebct", "avpet", "avebkg", "avjpkh"], "s": ["js", "b", "sc", "S", "rs", "ssl", "sb", "fs", "g", "new", "h", "hs", "p", "features", "u", "si", "sync", "xs", "sq", "parts", "a", "as", "n", "qs", "conf", "gs", "er", "aws", "es", "l", "service", "cs", "su", "e", "c", "ss", "spec", "o", "site", "its", "sf", "details", "your", "j", "self", "ops", "or", "full", "session", "ts", "sa", "is", "y", "m", "sym", "side", "sg", "f", "ds", "server", "plugins", "ses", "bis", "sys", "sl", "sv", "http", "ions", "os", "ctx", "r", "storage", "ps", "v", "ns", "settings", "an", "d", "i", "ls", "services", "us", "se"], "picture": ["general", "details", "big", "png", "shadow", "summary", "gif", "audio", "xxx", "info", "photo", "avi", "image", "feature", "cache", "game", "jpg", "storage", "pict", "sa", "fi", "slice", "style", "large", "Picture", "frame", "parse", "photos", "p", "util", "m", "profile", "obj", "buffer", "feat", "si", "file", "bank", "fn", "movie", "i", "img", "stat", "meta", "fine", "pic", "guide", "detail", "video", "gallery"], "tileno": ["tifname", "tilono", "tilzi", "milogo", "livasso", "linzi", "livendo", "tilasso", "tilendo", "theleno", "illzi", "talendo", "tifica", "talenos", "tiloa", "miloa", " tiloa", "phalendo", "theloa", "tinzi", "linaxy", "taleno", "miloni", "tilname", "phaleno", "siloni", "tiloni", "phalenos", "tilica", "linono", "tinono", "thelogo", "illeno", "tifeno", "salendo", "salasso", "taloni", "tinoa", "tinname", " tilname", "silasso", "saleno", "phaloni", "theloni", "illono", "illaxy", "iloa", "tilaxy", "iloni", "silno", "silenos", "ilogo", "tinica", "silendo", "tilenos", "sileno", "lineno", "tineno", "tilogo", "mileno", "ileno", "tifoa", "tilno", "tinaxy", "liveno", " tilica", "livno", "salno"], "ret": ["ut", "reply", "mt", "RET", "slot", "let", "sid", "len", "sel", "nt", "fin", "session", "result", "alt", "get", "det", "mem", "url", "ref", "rev", "rets", "pass", "code", "arr", "def", "ft", "match", "rc", "fun", "att", "feat", "arg", "rt", "usr", "bot", "af", "lit", "val", "pet", "cat", "back", "reg", "Ret", "res", "flag", "en", "success", "re", "mi"]}}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162, "substitutes": {"vbasedev": ["vbuiltiv", "svasedev", "vakedev", "vadedesc", "vbasedown", "verldown", "verbasedown", "vbasedesc", " vakedef", "vbuiltev", "vbackeddev", " vbaseiv", "verbasediv", "vbackedev", "vasedell", "verldee", "vakeddev", "vbuiltef", "vmadiv", "svasedell", "vbackedef", "vldee", "vadedell", "svbasedown", "vbasedee", "svbasedell", " vbaseddev", "vmadown", "verldev", "vldev", "vldiv", "vfedell", "vmadev", "vldown", "svbasedesc", "svasedown", "vbackedom", " vbasedef", " vbasedom", "verbasedev", "verldiv", "vbackediv", "vasedown", " vakedev", " vbaseef", "verbasedee", " vbasediv", "svbasedev", "vbaseev", "vbasediv", "vbasedef", "vbaseddev", "vbuiltdev", "vakedef", "vbaseef", "vbaseiv", "vmadee", " vakeddev", "vfediv", " vakedom", "vfedev", "vakedom", "vfedee", "vbasedom", "vadedown", "vfedown", "vasedev", "vasedesc", "svasedesc", "vfedesc", "vbasedell", "vadedev", " vbaseev"], "intp": ["inpr", "indq", " intpa", "inde", "bitc", "ntpa", "structp", "intq", "inp", "structc", "intsc", "structq", "Intc", "xte", "bitpoint", "idv", "ortp", "intv", "uintd", "INTpc", "intpc", "genp", "ipe", "xtpc", "pointp", "Intp", "intpe", "ipc", " intd", "INTu", "intd", "intspc", "structpr", "idp", "interu", "Intl", "indf", "ippr", "indpc", "INTp", "bitP", "xtps", "interc", "incpc", "idpe", "intpr", "intpa", "ntp", " intc", "ortf", "incpa", "genP", "indp", "indc", "idP", "interl", "indP", "incp", "intsl", "intpoint", "orte", " intP", "ine", " intps", "incP", "ortpoint", "uintP", "IntP", "intf", "uintp", "ntf", "ortps", "ortpc", " intq", "ntpoint", "indpr", "incps", "bitp", "indd", "inte", "ntc", "intc", "interpc", "Intv", "uintpc", "intsp", "indpe", "uintpr", "ntP", "intl", "incv", "INTc", "indpoint", "uintq", "Intpoint", "xtp", "ortc", "interp", "genpe", "indps", "Intpc", "intP", "intu", "pointu", "inc", "pointc", "intps", "uintc", "genv", "indv", "ntps", "uintv", "ipp", "pointpc"], "vdev": ["ovdev", "Vmod", "qdiff", "vdevice", "vmod", "vvdev", "Vdef", "Vdev", "vverror", "vdc", "tvrad", "Vdiv", "vdiv", "Vconf", "Vvalid", "Vdc", "tvdev", "varvalid", "verror", "vardev", "ldev", "ovvalid", "Vconn", "ovdef", "pdc", "svconn", "Vdem", " vdem", "vardef", "varrad", "svdem", "Vdevice", "Vrad", "vrad", "vdevelopment", "vdiff", "qconf", "svdiv", "ndev", "vdef", "svdev", " vdef", "vconn", "svdevice", "nmod", "ldef", "pdevice", "qconn", "ldevelopment", "Vdevelopment", "ldiff", "tvvalid", "wdevice", "qdevelopment", "qdevice", "ndc", "tvdef", "qdev", "ovdevice", "vvalid", "vconf", "Vdiff", "pmod", " vdiv", "vvconf", "vvdevice", "Verror", "qerror", "qdef", "svdef", "wdev", "ndevice", "wdef", "qdiv", "pdev", "vdem", "wvalid"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164, "substitutes": {"s": ["js", "b", "context", "sf", "a", "conf", "sv", "S", "rs", "ops", "ssl", "sb", "ctx", "fs", "g", "session", "ps", "ts", "es", "v", "h", "src", "p", "m", "cs", "sym", "t", "u", "w", "sets", "su", "ns", "sg", "txt", "e", "sync", "c", "d", "ses", "f", "i", "xs", "ds", "services", "temp", "support", "sys"], "rlow": ["rlo", "srlow", "rcmin", "rmid", "srlo", "prange", " rmid", "rclow", "pmin", "srmin", "rcLow", "pLow", "plow", "rcrange", "rrlo", "rmin", " rlo", "srLow", "rrmid", "rrmin", "rrlow", "rrange", " rmin", "rLow", "srmid", "srrange"], "rhigh": ["prhigh", "frfill", "rarmid", "rlimit", " rfill", "irhigh", "rarfill", "rmid", "irlimit", " rmid", " rlimit", "irtop", "prtop", "prhi", "rpeak", "rtop", "rarpeak", "frhigh", " rhi", " rtop", " rpeak", "rarhigh", "prlimit", "frpeak", "rfill", "irhi", "rhi", "frmid"], "val": ["x", "b", "prop", "bl", "pb", "sl", "value", "base", "split", "j", "slot", "func", "valid", "eval", "lib", "test", "pot", "ffff", "ctx", "len", "sel", "vt", "alt", "v", "ref", "part", "al", "py", "VAL", "pre", "p", "vals", "grad", "gb", "t", "obj", "var", "elt", "db", "rt", "loc", "pt", "ind", "f", "data", "Val", "pos", "reg", "pm", "temp", "fl"], "tmp": ["b", "buf", "pb", "mp", "vm", "nb", "cmp", "j", "TB", "proc", "cp", "property", "stuff", "etc", "test", "sb", "ctx", "vt", "ptr", "tt", "rb", "storage", "cache", "result", "attr", "emp", "v", "fp", "part", "src", "py", "beta", "config", "app", "pre", "p", "m", "tc", "t", "obj", "jp", "rt", "txt", "c", "pt", "bp", "Temp", "output", "copy", "cb", "tab", "tv", "data", "kk", "np", "tp", "temp", "vv", "fb"]}}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179, "substitutes": {"obj": ["js", "b", "adj", "bl", "Obj", "ie", "id", "bh", "eff", "orb", "xxx", "sb", "g", "ocr", "type", "ref", "oa", "p", "args", "Object", "el", "co", "art", "so", "x", "obo", "coll", "bm", "oi", "pg", "pl", "n", "oh", "nt", "rb", "conn", "off", "obb", "tmp", "oid", "oss", "node", "pt", "img", "otype", "val", "api", "o", "ext", "aj", "nb", "j", "office", "lib", "bb", "objects", "bo", "op", "pkg", "attr", "dr", "boot", "bj", "code", "po", "jp", "fn", "str", "data", "org", "ot", "ut", "os", "ctx", "bs", "alt", "io", "act", "ns", "cb", "object", "pos", "ob"], "qint": ["qaint", "sqinteg", "shid", "queryint", "dqINT", "dqinc", "queryfloat", "tfloat", "shinc", "eqinteger", "sqnt", "qqint", "qualnit", "qainner", "quinteger", "eqinst", " qobject", "dqinteger", " qinteg", "qnt", "sqobject", "quind", "dqfloat", "qin", "quinteg", "qobject", "qqinteg", "queryINT", "qinst", "shint", "tint", "quinc", " qconfig", "eqinc", "qnit", "quinner", "dqint", "quint", "sqinit", "qid", "qain", "quickint", "qind", "qinteger", "quinst", "sqint", "qinner", "qqconfig", "eqint", "quicit", "shind", " qinner", "qicit", "quinit", "quin", "qunt", "sqicit", "qualint", "qualin", "queryinteger", "qunit", "qinc", "tINT", "qanit", "qconfig", "sqinteger", "dqnt", "dqicit", "quickinst", "dqid", "tinteger", "qinteg", "qqinner", "qualinner", "quconfig", "quickinteger", "dqind", " qinit", "quickinc", "qINT", "quobject", "quid", "qinit"], "qfloat": ["Qdouble", "qinteger", "querystring", "qustring", "sqflat", "hflo", "iqflat", "qstring", "gfloat", "iqfloat", "queryfat", "ginteger", "quflo", "qudouble", "Qfloat", "hdouble", " qfinal", "qpart", "quflat", "qfinal", "hflat", "Qinteger", "qflat", "iqflo", "gfat", " qinteger", "gflat", "gfinal", "Qfinal", "queryfloat", "querypart", "qdouble", " qflat", "sqfloat", "qufloat", "querydouble", "qfat", "qflo", " qstring", "iqdouble", " qdouble", "hfloat", "queryflat", "sqpart", "gdouble", "gpart", "sqfat"]}}
{"project": "qemu", "commit_id": "95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb", "target": 0, "func": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n\n{\n\n    struct ohci_ed ed;\n\n    uint32_t next_ed;\n\n    uint32_t cur;\n\n    int active;\n\n\n\n    active = 0;\n\n\n\n    if (head == 0)\n\n        return 0;\n\n\n\n    for (cur = head; cur; cur = next_ed) {\n\n        if (ohci_read_ed(ohci, cur, &ed)) {\n\n            trace_usb_ohci_ed_read_error(cur);\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n", "idx": 24200, "substitutes": {"ohci": ["ihcit", "ohc", "hovc", "ehcci", "hci", "ouc", "ahc", "ohcit", "hcin", "ohsci", "ihc", "ehco", "ihcci", "ohco", "hovii", "ovc", "hc", "ahci", "ohcci", "ehii", "ahcit", "ophcit", "ehcin", "ahdi", "hovci", "ihci", "ohdi", "ohcu", "ophcin", "ovlc", "ovcin", "ohcin", "ahii", " ohcci", "ovcci", "ehcu", "ophc", "hdi", "ahcu", "hsci", "ahcci", "ehc", "ophcci", "ahco", "ohii", "ihco", " ohsci", "ovcit", "ehci", "oulc", "oucin", " ohcin", "ahcin", "ehcit", " ohcu", "hcu", "ovci", "ophci", " ohdi", "ahlc", "ouci", "ophcu", " ohcit", "ophsci", "ohlc", "hovcci", " ohc"], "head": ["depth", "index", "last", "port", "front", "run", "mid", "key", "set", "anch", "parent", "headers", "forward", "id", "state", "flags", "HEAD", "count", "self", "end", "body", "send", "brand", "ack", "tag", "header", "pull", "heads", "current", "row", "total", "host", "patch", "group", "ck", "tail", "size", "max", "open", "h", "cost", "src", "name", "before", "stream", "origin", "code", "gate", "Head", "subject", "rc", "commit", "first", "input", "clean", "link", "target", "foot", "start", "bound", "ind", "gap", "next", "load", "lead", "pos", "back", "flag", "client", "sign", "length", "post"], "completion": ["committed", "comple", " commented", "calpletion", "calple", "calmented", "calmitted", "ocompletion", "ocommented", " committed", "ocomple", "ocommitted", " comple", "commented"], "ed": ["edited", "ended", "temp", "aed", "led", "ned", "id", "pred", "based", "oved", "ted", "wed", "ached", "ited", "ing", "named", "line", "med", "iced", "read", "ev", "ged", "oned", "sent", "dd", "aged", "aid", "rod", "en", "edd", "set", "itted", "er", "red", "made", "ced", "es", "fed", "ipped", "ied", "ee", "eb", "eded", "e", "ordered", "ind", "Ed", "ad", "ared", "ated", " sent", "ED", "z", "added", "ined", "or", "aned", "ded", " extended", "sed", "aled", "acked", "ex", "needed", "written", "rated", "eds", "et", "started", "ped", "linked", "done", "mented", "hed", "one", "ld", "d", "wired", "se", "reed"], "next_ed": ["next_eds", "currentJedited", "nextjed", "next_sent", "currentJeds", "nextJed", "current_eds", "currentJed", " next_eds", "current_ed", "current_edited", " next_ped", "nextJedited", "nextJeds", "next_led", "next_edited", " next_red", "currentJded", "current_ded", "nextjeds", "next_ded", "nextjped", "nextjred", "nextJded", "next_red", "next_ped", " next_sent", " next_led"], "cur": ["orig", "Cur", "arch", "sr", "mid", "rog", "ch", "inter", "child", "prev", "id", "der", " curs", "req", "sth", "end", "ctr", "ait", "sel", " cursor", "ptr", "current", "row", "enter", "r", "cer", "dr", "iter", "open", "cor", "sur", "src", "tr", "ver", "rev", "rest", "cr", "ser", "pub", "car", "per", "rc", "input", "ur", "var", "feat", "ah", "desc", "feed", "fer", "loc", "usr", "c", "uc", "start", "ind", "cher", " prev", "cli", "next", "pr", "back", "client", "focus", "length"], "active": ["loop", " pending", "ended", "run", " running", "ac", "lic", "Active", "g", "activ", "complete", "att", "connected", "aid", "play", "x", "live", "parent", "ait", "add", "cycle", "open", "rev", "running", "feed", "cli", "le", "client", "circ", "_", "enable", "proc", "ace", "current", "total", "all", "pass", "exec", "seq", "stable", "activity", "progress", "r", " act", "act", "acs", "sec", "confirmed", " reactive", "pos", " inactive"], "addr": ["cap", "afi", "mid", "rx", "align", "mt", "id", "state", "nc", "ack", "sid", "ptr", "host", "ip", "pkg", "dr", "attr", "amd", "xp", "url", "conn", "ref", "src", "anne", "name", "config", "sta", "cmd", "address", "vr", "nn", "obj", "mac", "md", "rc", "hop", "node", "doc", "loc", "amp", "seq", "rt", "layer", "data", "ad", "pos", "ord", "adr", "pad", "nr", "offset"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201, "substitutes": {"pbdev": ["fbdevice", "reftest", "pcadv", "pcdata", "PBadv", "PBconf", "labver", "pcdevice", "sbdef", "sbdevice", "pbadv", "cbdev", "pbtest", "bbdev", "pbver", "pcconf", "PBdef", "refdev", "pbdiv", "bbdevice", "labdevice", "PBdevice", "cbdevice", "pbapp", "sbdev", "pconf", "pbconf", "sbapp", "pdevice", "bbconf", "pbdevice", "pdef", "pbdata", "labdiv", "pcver", "PBdev", "refdevice", "bbadv", "fbapp", "pctest", "PBapp", "cbver", "fbdev", "pcdiv", "pcdev", "refdata", "cbdata", "pbdef", "pdev", "cbtest", "labdev", "cbdiv", "sbconf"]}}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_connect(URLContext *uc, AVDictionary **options)\n\n{\n\n    int err =\n\n        uc->prot->url_open2 ? uc->prot->url_open2(uc,\n\n                                                  uc->filename,\n\n                                                  uc->flags,\n\n                                                  options) :\n\n        uc->prot->url_open(uc, uc->filename, uc->flags);\n\n    if (err)\n\n        return err;\n\n    uc->is_connected = 1;\n\n    /* We must be careful here as ffurl_seek() could be slow,\n\n     * for example for http */\n\n    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, \"file\"))\n\n        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)\n\n            uc->is_streamed = 1;\n\n    return 0;\n\n}\n", "idx": 24205, "substitutes": {"uc": ["context", "fc", "unc", "BC", "uca", "ucc", "soc", "sc", "bc", "anc", "ca", "ac", "cc", "connection", "ack", "sub", "ctx", "aut", "asc", "cus", "mc", "up", "ocr", "uu", "cv", "cas", "auc", "url", "acc", "cci", "con", "config", "instance", "roc", "oc", "uci", "ub", "util", "tc", "cur", "pub", "u", "rc", "mac", "input", "su", "plug", "um", "cca", "c", "exec", "ec", "pc", "lc", "ul", "ru", "cli", "aux", "uf", "co", "cu", "ui", "usc", "UC", "client", "RC", "us", "class", "userc"], "options": ["context", "array", "path", "flags", "self", "os", "text", "lib", "ops", "opens", "or", "fee", "option", "cache", "optional", "six", "params", "url", "null", "con", "config", "oci", "other", "times", "args", "Options", "mac", "public", "this", "settings", "e", "exec", "ec", "object", "aux", "data", "co", "pos", "o", "opt"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206, "substitutes": {"sd": ["sc", "sem", "zh", "sb", "sh", "fd", "ud", "gd", "sam", "SD", "ini", "sm", "gb", "ic", "ess", "dis", "si", "dd", "sn", "ci", "yd", "ln", "ed", "std", "wd", "service", "sta", "vd", "su", "ind", "ss", "sim", "lc", "dl", "ad", "st", "sch", "nd", "cd", "dist", "sf", "z", "od", "hd", "sth", "eddy", "lib", "isi", "sy", "sa", "sk", "sed", "di", "des", "sg", "pd", "ds", "data", "dat", "sl", "dt", "sci", "df", "sv", "tf", "dk", "bd", "dev", "dm", "ld", "md", "d", "td", "se"], "ret": ["ut", "reply", "mt", "id", "RET", "success", "let", "len", "gt", "nt", "fin", "result", "alt", "resp", "get", "det", "mem", "all", "ref", "url", "rev", "rets", "arr", "ft", "match", "def", "rc", "fun", "att", "feat", "arg", "rt", "pt", "lit", "str", "val", "data", "pet", "Ret", "reg", "res", "art", "pat", "bit", "opt", "re"], "io_len": ["cgi_base", "data_bin", " io_field", " io_den", "ioamlen", "net_del", "feed_limit", "io32field", "ioxwidth", "control_width", "ioxlen", "io67offset", "io_off", "ioflen", "inputacstart", "io32offset", "io_ln", "feed_len", "io_den", "cgiamcount", "cgiamlen", "data_length", "inputacln", "ioacln", "iofden", "control00len", "inputaclim", "io_del", "io00lif", "input_ln", "iocclen", "io00width", "input_start", "ioacstart", "io_length", " io_fin", "io_min", "io_lim", "ioccbase", "ioaclen", "net_len", "io32ln", "io_offset", "io67Len", "data_count", "ioxlan", "cgi_count", "ioqlimit", "control_len", "io00len", "ioqlim", "control00lan", "io67width", "input_lim", "iokbase", "io_lan", "iokoff", "feed_den", "cgiamoff", "feed_lim", "cgi_len", "inputaclen", " io_ln", "ioklen", "iocccount", "data_len", " ioffin", "io_fin", "input_len", "io00lan", "io_width", "ioambase", "ioccoff", "iokcount", "ioaclim", "io_lif", "io67len", "ioffin", " io_Len", "ioamoff", "cgi_off", "control00width", "cgiambase", "io32len", "io_limit", "control00lif", "io_start", "ioamcount", " io_width", "ioqden", "io_base", " io_off", "ioxlif", "net_limit", "io_field", "control_lan", " iofoff", "net_min", "io_count", " iofden", "ioqlen", " ioflen", "io_Len", " io_offset", "io_bin", "iofoff", "control_lif"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212, "substitutes": {"data": ["database", "parser", "parent", "value", "da", "id", "state", "self", "writer", "xxx", "test", "ctx", "DATA", "window", "info", "cache", "session", "result", "record", "type", "reader", "style", "config", "p", "code", "arr", "m", "di", "match", "Data", "args", "input", "buffer", "this", "exec", "d", "object", "call", "val", "api", "ad", "qa", "o", "client", "dat", "a"], "unused": [" unuse", " unchecked", "unalbiased", "Unuse", "unalchecked", "unuse", " unbiased", "unaluse", "Unused", "unchecked", "unbiased", "Unbiased", "Unchecked", "unalused"], "obj": ["x", "js", "adj", "coll", "oi", "n", "Obj", "ie", "parent", "value", "nb", "j", "eff", "os", "xxx", "test", "ctx", "bo", "nt", "op", "alt", "attr", "v", "fi", "ref", "oa", "py", "instance", "bj", "p", "code", "tmp", "act", "args", "inst", "ex", "init", "Object", "po", "elt", "jp", "bot", "pt", "ind", "img", "cb", "object", "val", "api", "pos", "o", "art", "ob"]}}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213, "substitutes": {"mon": ["mini", "bm", "mun", "ban", "mic", "un", "mt", "mn", "MON", "mer", "monitor", "mut", "tun", "nan", "bo", "mat", "mc", "dom", "mons", "mot", "mu", "tom", "con", "mr", "config", "mo", "mont", "plan", "wan", "m", "mos", "man", "atom", "amon", "blue", "lin", "mand", "Mon", "uno", "an", "meter", "block", "mas", "module", "mor", "mm", "ann", "am", "bean", "mag", "bin"], "src_str": ["src_arr", "src2Str", "source_str", "src_br", "src2str", "rc_char", " src_string", "src2br", " src_list", "rc_Str", "src_list", "src_char", "src_Str", "src2string", "rc_str", "rc_arr", " src_br", "source_string", "src_string", "source_br", "source_Str", "rc_br"], "host_port": ["host_length", "hostalport", "hostaladdress", "hostaltype", "node_port", "host_point", "host_addr", "host_type", "host_address", "host_host", "port_port", "host_PORT", "node_PORT", "node_addr", "server_type", "hostalpoint", "port_host", "server_address", "server_port", "server_point", "port_length"], "buf": ["b", "cap", "context", "port", "pb", "box", "prop", "path", "grab", "home", "bc", "vec", "cmp", "bh", "func", "fab", "text", "bytes", "bb", "ctx", "padding", "agg", "fd", "ba", "rb", "pkg", "wb", "cv", "br", "cas", "la", "h", "raw", "cf", "brace", "src", "bd", "enc", "batch", "queue", "bu", "received", "exc", "conv", "ab", "cmd", "cur", "rc", "buffer", "bed", "feed", "loc", "uc", "bag", "seq", "bound", "bags", "f", "cb", "bf", "c", "str", "uf", "data", "cat", "bus", "ff", "pad", "fb", "buff"], "p": ["x", "b", "port", "pb", "wp", "j", "cp", "vp", "ctx", "sp", "r", "ip", "ps", "pp", "l", "fp", "v", "h", "y", "part", "m", "ap", "s", "t", "prefix", "u", "w", "P", "jp", "e", "point", "c", "pt", "d", "bp", "i", "pc", "f", "padding", "q", "api", "np", "pr", "o", "tp", "pipe", "pointer", "pa"], "n": ["b", "num", "nl", "nat", "nb", "z", "j", "nc", "N", "nor", "none", "len", "ne", "nt", "g", "number", "en", "dn", "l", "v", "y", "m", "t", "cn", "nn", "pn", "ns", "k", "na", "node", "e", "fn", "c", "d", "ind", "i", " N", "nu", "ng", "min", "sn", "o", "ni", "name", "nr"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222, "substitutes": {"bs": ["js", "b", "banks", "bm", "bl", "pb", "css", "base", "vs", "bc", "outs", "http", "gs", "bh", "bits", "os", "bb", "ubs", "sb", "bid", "bos", "fs", "ros", "obs", "bi", "sa", "bps", "bing", "ks", "ins", "bu", "gb", "cs", "lbs", "iss", "ab", "bas", "ns", "eb", "bes", "db", "BS", "sys", "ss", "ls", "ds", "lb", "us", "ses", "bis", "fb"], "sector_num": ["sectorpsum", "sectorpoffset", "shadowIDnum", "sectorpnum", "shadowIDdiv", "sector_no", "region_size", "sector_div", " sector_un", "shadow_div", "region_sum", "sectorpname", "sector0size", "sectorIDdiv", "section_num", " sector_number", "sector_tun", "sector_length", "sector_sum", " sector_sum", " sector_length", " sector_name", "shadowIDtun", "sector_count", "sectorIDtun", "section_offset", "shadowIDname", "sector_size", "shadow_num", " sector_offset", "sector0count", "region_num", "region_count", "shadow_name", "shadow_tun", "sectorIDname", "sector_number", "sectorIDnum", "sector_name", "sector0sum", "section_number", "section_no", "sector_offset", "sector0num", "sector_un"], "remaining_sectors": ["remaining_psector", "remaining_pectors", "remaining_peces", "remaining_teces", "remaining_pegments", "remaining_pellers", "remaining_serctor", "remaining_psectors", "remaining_sections", "remaining_segments", "remaining_vegments", "remaining_seapters", "remaining_tegments", "remaining_bellers", "remaining_sellers", "remaining_bectors", "remaining_teapters", "remaining_secces", "remaining_secgments", "remaining_secs", "remaining_serctions", "remaining_vectors", "remaining_sergments", "remaining_tectors", "remaining_pecs", "remaining_begments", "remaining_secctors", "remaining_serctors", "remaining_psegments", "remaining_vellers", "remaining_sector", "remaining_psections", "remaining_becs", "remaining_vections", "remaining_peapters", "remaining_seces", "remaining_vecs", "remaining_vector", "remaining_secapters"], "qiov": ["qoyer", "requveh", "quveh", "quoby", "requiov", "quiov", " qiris", "quiop", "qiop", "qrolet", "qoren", "quroxy", " qroxy", "sqoren", "quoren", " qrolet", "questroxy", " qoren", "qroxy", "sqiov", " qoby", "qiris", "questoby", " qoyer", "quoyer", "sqiris", "questiop", "quiris", "qurolet", " qveh", "requoyer", " qiop", "requrolet", "questiov", "qoby", "sqrolet", "qveh"], "s": ["js", "b", "site", "sl", "secondary", "conf", "state", "S", "gs", "self", "os", "rs", "ops", "ssl", "sb", "fs", "r", "g", "storage", "session", "states", "aws", "ps", "ts", "is", "sa", "l", "v", "service", "sis", "p", "cs", "ess", "sym", "t", "args", "sets", "su", "ns", "sg", "si", "utils", "settings", "sie", "sync", "c", "e", "d", "ss", "f", "spec", "ls", "ds", "stat", "services", "sq", "server", "parts", "o", "ses", "sys", "stats"], "index_in_cluster": ["index_in_hellusters", "index_in_CLayer", "index_in_ecructure", "index_in_hellayer", "index_in_CLuration", "index_in_Cluster", "index_in_ecryption", "index_in_secryption", "index_in_secusters", "index_in_secructure", "index_in_clayer", "index_in_cluration", "index_in_ecusters", "index_in_secuster", "index_in_clusters", "index_in_helluration", "index_in_CLuster", "index_in_ecuster", "index_in_Cluration", "index_in_clryption", "index_in_helluster", "index_in_clructure", "index_in_Clayer", "index_in_Clusters", "index_in_Clructure", "index_in_CLusters", "index_in_Clryption"], "n1": ["N9", "p1", "p3", "nnone", "sn8", "n9", "nn1", "sn9", "p2", "N0", "c9", "none", "unOnce", "ln2", "ln91", "N2", "sn0", "n0", "sn1", "N3", "unone", " n2", "un8", "nnOnce", "sn2", " n91", "un1", "n91", "N91", "n3", "N1", "nOnce", "n2", "c0", "snone", "nn8", " n3", "snOnce", "c1", "n8", "c2", "ln1"], "ret": ["ext", "opt", "ut", "mt", "RET", "j", "end", "test", "let", "len", "info", "gt", "nt", "rb", "fin", "result", "alt", "iter", "job", "det", "url", "ref", "part", "rev", "rets", "ft", "match", "fail", "def", "rc", "fun", "sat", "ct", "att", "arg", "rt", " Ret", "seq", "lit", "val", "data", "rep", "cat", "pet", "Ret", "reg", "res", "art", "flag", "bit", "success", "re", "fit"], "cur_nr_sectors": ["cur_nr_vegments", "cur_nr_lectors", "cur_nr_cegments", "cur_nr_pegments", "cur_nr_pecs", "cur_nr_secctions", "cur_nr_selivers", "cur_nr_perets", "cur_nr_tegments", "cur_nr_peivers", "cur_nr_secbits", "cur_nr_vecs", "cur_nr_vevers", "cur_nr_tections", "cur_nr_curctor", "cur_nr_speitors", "cur_nr_sector", "cur_nr_seurities", "cur_nr_psections", "cur_nr_sections", "cur_nr_pectors", "cur_nr_cectors", "cur_nr_secctor", "cur_nr_vectors", "cur_nr_pector", "cur_nr_psectors", "cur_nr_legments", "cur_nr_leivers", "cur_nr_curgments", "cur_nr_semgments", "cur_nr_spectors", "cur_nr_secs", "cur_nr_peators", "cur_nr_segments", "cur_nr_securities", "cur_nr_seivers", "cur_nr_SEcs", "cur_nr_serets", "cur_nr_seitors", "cur_nr_teurities", "cur_nr_veitors", "cur_nr_specs", "cur_nr_curbits", "cur_nr_pexes", "cur_nr_pebits", "cur_nr_selctors", "cur_nr_selgments", "cur_nr_curctors", "cur_nr_psecs", "cur_nr_severs", "cur_nr_peitors", "cur_nr_leators", "cur_nr_sebits", "cur_nr_cexes", "cur_nr_cerets", "cur_nr_psegments", "cur_nr_peurities", "cur_nr_seators", "cur_nr_semcs", "cur_nr_pevers", "cur_nr_SEgments", "cur_nr_secgments", "cur_nr_SEctions", "cur_nr_semvers", "cur_nr_SEctors", "cur_nr_spegments", "cur_nr_semctors", "cur_nr_secctors", "cur_nr_selators", "cur_nr_pections", "cur_nr_tectors", "cur_nr_sexes"], "hd_qiov": ["hd_chiov", "hd_qqiov", "hd_qiev", "hd_qqilo", "hd_mirin", "hd_qliv", "hd_sqilo", "hd_clicho", "hd_qoyer", "hd_quiev", "hd_qrolet", "hd_pliv", "hd_grolet", "hd_sqrolet", "hd_cliov", "hd_qilo", "hd_qurolet", "hd_qaliv", "hd_sqiov", "hd_milo", "hd_ceiov", "hd_sqoyer", "hd_sqiop", "hd_gliv", "hd_qaiov", "hd_giov", "hd_piov", "hd_sqirin", "hd_choyer", "hd_chiris", "hd_miop", "hd_qailo", "hd_quoyer", "hd_ceiop", "hd_qaicho", "hd_qnr", "hd_quiov", "hd_miov", "hd_shilo", "hd_qiop", "hd_qairin", "hd_prolet", "hd_chilo", "hd_quilo", "hd_qanr", "hd_ceiev", "hd_qaoyer", "hd_Qiris", "hd_Qiov", "hd_qarolet", "hd_clnr", "hd_shiris", "hd_qaiop", "hd_quicho", "hd_qqiev", "hd_clliv", "hd_qirin", "hd_poyer", "hd_Qilo", "hd_qqiop", "hd_qiris", "hd_goyer", "hd_shiov", "hd_quliv", "hd_qicho", "hd_ceilo", "hd_shoyer", "hd_Qoyer", "hd_qunr", "hd_quiop"], "cluster_data": ["cluster_offset", "clusteringentry", "cluster_size", "cluster_entry", "clusteringoffset", "clusteringdata", "clusters_offset", "clusters_entry", "clusters_size", "clusters_data", "clusteringsize"]}}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230, "substitutes": {"s": ["js", "b", "sf", "sr", "sl", "sc", "sv", "S", "gs", "self", "ions", "space", "os", "rs", "less", "ops", "ssl", "sb", "fs", "r", "sts", "bs", "g", "xs", "session", "ps", "aws", "ts", "sa", "l", "is", "v", "ks", "service", "sed", "p", "cs", "t", "south", "su", "ns", "sg", "lines", "si", "sys", "sie", "e", "sync", "c", "an", "ss", "f", "spec", "ls", "ds", "sim", "i", "sing", "services", "sq", "sign", "us", "ses", "bis"], "size": ["count", "send", "fee", "g", "cache", "type", "p", "core", "iz", "complete", "address", "args", "page", "scale", "si", "any", "sized", "sn", "en", "name", "num", "n", "shape", "six", "enc", "large", "SIZE", "speed", "buffer", "capacity", "small", "c", "second", "use", "offset", "ize", "shift", "timeout", "len", "max", "empty", "code", "now", "data", "form", "body", "storage", "number", "v", "handle", "time", "loc", "i", "sec", "content", "Size", "length", "sum"], "pb": ["b", "prop", "platform", "bm", "pg", "fc", "pl", "plugin", "wp", "parser", "bc", "rob", "bh", "proc", "cp", "summary", "fab", "bb", "vp", "sb", "ctx", "PB", "prot", "bs", "rb", "pkg", "pm", "wb", "cv", "lab", "fp", "bps", "hub", "ib", "py", "alist", "pa", "ppa", "p", "xb", "ub", "tmp", "gb", "dp", "ab", "db", "eb", "jp", "txt", "loc", "uc", "bot", "bp", "pd", "pc", "lc", "cb", "cli", "lb", "typ", "uf", "cpp", "api", "bf", "tp", "lp", "fb"], "st": ["sd", "sf", "ist", "sl", "ut", "ost", "sc", "mt", "std", "stop", "stack", "sth", "end", "sb", "rd", "sp", "nt", "sts", "St", "ust", "ts", "sa", "put", "sam", "sta", "rest", "est", "kt", "fr", "stage", "ste", "ft", "inst", "ld", "t", "ast", "ct", "pt", "start", "ss", "td", "ST", "str", "typ", "sw", "sn", "fe", "dest", "lt", "art", "client", "sign", "nd", "se", "post"], "strt": ["srs", "srd", "trT", "drT", "Strt", " strte", "STRtt", "frd", "Strts", "charT", "strts", "trt", " strT", "STRt", "frt", "trtt", "frs", "drts", "STRte", "drt", " strs", "srts", "trte", "strd", "frts", "strte", " strts", "srt", " strtt", "chart", " strd", "strs", "strtt", "strT", "StrT", "drtt", "STRT", "Strtt", "charts", "chartt"], "skip": ["index", "loop", "hide", "run", "n", "allow", "keep", "wait", "stop", "write", "success", "ignore", "op", "ip", "type", "need", "nic", "item", "miss", "jump", "sleep", "slice", "zero", "scan", "parse", "blank", "pass", "speed", "read", "unit", "fail", "access", "scroll", "link", "scale", "missing", "hop", "sync", "limit", "Skip", "start", "eat", "delay", "spec", "gap", "call", "min", "pos", "use", "name", "ipp", "step", "offset"], "atom": ["prop", "abb", "array", "plane", " atoms", "tm", "base", "com", "kat", "orb", "fam", "mom", "info", " Atom", "op", "type", "attr", "article", "item", "tom", "acc", "atomic", "app", "p", "tmp", "at", "m", "om", "ab", "channel", "rss", "cm", "node", "spec", "component", "tab", "typ", "data", "term", "map", "am", "np", "abc", "list", "xml", "class", "mag", "oms"], "preamble": ["parsble", "parmbled", " parenle", "parsBLE", " preaml", " parmble", "parsbling", "parenBLE", "parenble", " parenble", "parenle", "prambled", "pairBLE", "pREAMbled", "preaml", "pramBLE", "pramle", " parmle", "pREAMble", "pairble", " pREAMle", "prambe", "preambe", " pREAMbled", "pREAMl", " parmBLE", "pREAMle", "preambled", "parenbling", " pREAMble", "pairle", " parmbe", "preamle", "prawBLE", " preamBLE", " preambling", "prawble", "preambling", "pairbling", " pREAMl", "parmble", "prawle", " preamle", " preambled", "parsle", "parmbe", "pramble", "preamBLE", " parenbling", "parmBLE", " parenBLE", "prawbe", "parmle", "parml", "praml", " preambe"]}}
{"project": "qemu", "commit_id": "728470bea15b11ba7b3e3db54f0d9939908e0e65", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231, "substitutes": {"rdma": ["rwmma", "rdda", "rbmp", "rtmma", "ldda", "rrfa", "rnmma", "rxda", "rwma", "rnha", "rtda", "ldfa", "ldma", "ldmp", "rdmma", "rdha", "ldmas", "rdmas", "rbma", "ldmma", "rrmp", "rnda", "rdmp", "rrma", "rbfa", "rwmas", "rxma", "rrmas", "rxmma", "rnma", "ldha", "rwda", "rtmas", "rdfa", "rtma", "rbmas", "rxha"], "mode": ["ward", "ode", "mod", "key", "path", "id", "direction", "mission", "perm", "op", "dim", "size", "type", "move", "command", "style", "role", "range", "code", "m", "route", "password", "stage", "MODE", "access", "de", "device", "md", "mac", "language", "scale", "kind", "module", "phrase", "data", "mm", "lane", "grade", "Mode", "method", "name"], "r": ["b", "sr", "n", "rx", "gr", "err", "lr", "rs", "er", "g", "rb", "result", "dr", "br", "root", "l", "reader", "v", "h", "rg", "mr", "R", "p", "arr", "m", "fr", "cr", "t", "rh", "u", "w", "ar", "rc", "k", "rt", "this", "e", "usr", "c", "d", "f", "i", "kr", "hr", "str", "rr", "pr", "o", "nr", "re"]}}
{"project": "FFmpeg", "commit_id": "ddfa3751c092feaf1e080f66587024689dfe603c", "target": 1, "func": "static int decode_codestream(J2kDecoderContext *s)\n\n{\n\n    J2kCodingStyle *codsty = s->codsty;\n\n    J2kQuantStyle  *qntsty = s->qntsty;\n\n    uint8_t *properties = s->properties;\n\n\n\n    for (;;){\n\n        int marker, len, ret = 0;\n\n        const uint8_t *oldbuf;\n\n        if (s->buf_end - s->buf < 2){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n\n            break;\n\n        }\n\n\n\n        marker = bytestream_get_be16(&s->buf);\n\n        if(s->avctx->debug & FF_DEBUG_STARTCODE)\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n        oldbuf = s->buf;\n\n\n\n        if (marker == J2K_SOD){\n\n            J2kTile *tile = s->tile + s->curtileno;\n\n            if (ret = init_tile(s, s->curtileno))\n\n                return ret;\n\n            if (ret = decode_packets(s, tile))\n\n                return ret;\n\n            continue;\n\n        }\n\n        if (marker == J2K_EOC)\n\n            break;\n\n\n\n        if (s->buf_end - s->buf < 2)\n\n            return AVERROR(EINVAL);\n\n        len = bytestream_get_be16(&s->buf);\n\n        switch(marker){\n\n            case J2K_SIZ:\n\n                ret = get_siz(s); break;\n\n            case J2K_COC:\n\n                ret = get_coc(s, codsty, properties); break;\n\n            case J2K_COD:\n\n                ret = get_cod(s, codsty, properties); break;\n\n            case J2K_QCC:\n\n                ret = get_qcc(s, len, qntsty, properties); break;\n\n            case J2K_QCD:\n\n                ret = get_qcd(s, len, qntsty, properties); break;\n\n            case J2K_SOT:\n\n                if (!(ret = get_sot(s))){\n\n                    codsty = s->tile[s->curtileno].codsty;\n\n                    qntsty = s->tile[s->curtileno].qntsty;\n\n                    properties = s->tile[s->curtileno].properties;\n\n                }\n\n                break;\n\n            case J2K_COM:\n\n                // the comment is ignored\n\n                s->buf += len - 2; break;\n\n            default:\n\n                av_log(s->avctx, AV_LOG_ERROR, \"unsupported marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n                s->buf += len - 2; break;\n\n        }\n\n        if (s->buf - oldbuf != len || ret){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"error during processing marker segment %.4x\\n\", marker);\n\n            return ret ? ret : -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 24244, "substitutes": {"s": ["js", "b", "in", "S", "rs", "ssl", "sb", "fs", "g", "ing", "states", "new", "request", "h", "single", "hs", "tests", "p", "features", "args", "u", "sets", "lines", "si", "sync", "xs", "sq", "parts", "en", "a", "as", "n", "qs", "conf", "gs", "aws", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "stats", "site", "its", "sf", "details", "your", "sites", "self", "ops", "full", "session", "ts", "is", "y", "m", "styles", "sym", "w", "side", "sg", "f", "ds", "plugins", "ses", "sys", "sv", "http", "ions", "os", "r", "ps", "v", "ins", "ns", "d", "i", "ls", "services", "us", "se", "support"], "codsty": ["cmdty", " codety", "cmdsty", " codstyle", "codgy", "callsty", "labsty", "odsty", "cdsy", "odstyle", " codgy", "cmdsym", "labgy", "odsta", "labsy", "labty", "codty", "odty", "codesy", "codesta", "codsta", "codety", "cdestyle", "codsym", "cdsty", "odety", "codesty", "calltyp", " codsym", " codsy", "codegy", "cdgy", "cbsy", "codestyle", "cbsta", "cdsta", "codeety", " codestyle", "codetyp", "codstyle", "cdty", "cbty", "odsy", "callgy", "cmdsy", "codeestyle", " codtyp", " codsta", " codty", "codsy", "cbsty", "codtyp", "callsta", "odestyle", "cdsym"], "qntsty": ["wrtpty", "qantety", "kntety", "kntpty", "qentsty", "qndwy", "Qncsty", "qndty", "Qrtsty", "qncwy", "qntsy", "wrtrt", "wntstyle", "qrtsty", "qntsta", "krtty", "qontsty", "qentpty", "Qntstyle", "qtpty", "qentstyle", "qtety", "Qntsty", "wntsty", "qncsy", "qndstyle", "krtpty", "qontstyle", "qNTsty", "qrtty", "kntsty", "qktpty", "qtty", "wntsy", "qktstyle", "qNTsy", "qktrt", "qantpty", "qntty", "qNTsta", "qontty", "qndsta", "Qntsta", "qrtety", "qrtsta", "kntty", "Qncwy", "qndsty", "qncsty", "qentrt", "Qntsy", "wntrt", "wrtsy", "qncstyle", "wrtstyle", "qntwy", "qrtstyle", "qtsty", "qNTty", "Qntwy", "Qntty", "qktsty", "krtsty", "qntrt", "qntety", "qncty", "Qncty", "krtety", "Qrtsta", "qntstyle", "wrtsty", "qontwy", "wntpty", "qrtpty", "wrtty", "Qrtsy", "qrtsy", "qrtrt", "qndsy", "Qrtty", "Qncstyle", "wntty", "qantsty", "qntpty", "qantty"], "properties": ["prop", "items", "ties", "ips", "pb", "details", "results", "status", "ie", "sites", "nb", "fo", "flags", "description", "les", "progress", "bits", "requires", "property", "metadata", "fits", "products", "bytes", "ops", "objects", "effects", "resources", "reports", "params", "fields", "phones", "keys", "options", "strings", "gb", "tmp", "perties", "styles", "json", "features", "ports", "pro", "charges", "notes", "definition", "ms", "lines", "utils", "settings", "limits", "asts", "rules", "types", "ds", "values", "ui", "classes", "xml", "nice", "phy", "stats"], "marker": ["marksER", "markr", "Markoser", " markger", "metener", "markner", " Markier", "metER", "pling", " Marking", "markER", "Marketer", " MarkER", "masketer", "maskener", "pler", "masker", " markner", "MarkER", "Markiner", "Markr", "Markeri", " markER", "markers", "markiner", " Markr", " marking", "linkeri", "markeri", " markier", " markeri", "maskER", "markger", "Markener", "markser", " Marker", " markr", "marketer", "Marker", "markseri", "markener", "plger", "marking", " Markner", "markier", "marksers", "Markers", " Markiner", "linkier", " Markger", "maskers", "maskoser", "marksoser", "meter", " Markeri", " markiner", "linker", "meteter", "linkER", "plner", "markoser"], "len": ["num", "bl", "li", "n", "sl", "lan", "ret", "split", "vec", "err", "Len", "net", "id", "count", "fat", "sid", "lis", "fin", "size", "l", "mem", "part", "rev", "il", "lon", "lf", "ln", "ld", "lin", "fun", "el", "elt", "ll", "loc", "fn", "seq", "lit", "lc", "ls", "str", "val", "dl", "lt", "pos", "sil", "lp", "en", "length", "bin", "fl"], "oldbuf": [" oldqueue", "Oldcb", "olderbuff", "oldbu", "newcb", "oldqueue", "oldcb", "oldbuff", "newbuff", " oldbuff", "Oldbuff", "olderbuf", "olderbu", "newqueue", " oldcb", "newbu", "Oldqueue", "Oldbuf", "oldercb", "newbuf", " oldbu"], "tile": ["port", "late", "Tile", "ie", "texture", "rule", "ico", "fil", "ele", "task", "vt", "mat", "prot", "sheet", "ti", "cube", "table", "scale", "txt", "transfer", "co", "mask", "tu", "tif", "chip", "depth", "buf", "live", "tri", "phone", "tel", "tun", "sid", "tag", "suit", "feature", "mobile", "theme", "kt", "tmp", "t", "profile", "xy", "tle", "tele", "cli", "ugi", "tty", "phy", "fit", "dist", "kid", "project", "thin", "ptr", "grid", "slice", "route", "ski", "hop", "module", "layer", "plate", " tiles", "skin", "plane", "sl", "chrome", "tf", "zip", "surface", "pod", "image", "coord", "flat", "file", "component", "tab"]}}
{"project": "FFmpeg", "commit_id": "9745f19ffc9031ce480e43d7cf1053b58100d70f", "target": 0, "func": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n\n    avctx->subtitle_header_size = avctx->extradata_size;\n\n    return 0;\n\n}\n", "idx": 24269, "substitutes": {"avctx": ["aycmp", "avconnection", "avalcor", "avalconnection", "evcms", "afpkg", "aycontext", "afcu", "avecf", "afci", "avpkg", " avconn", "aveconn", "varcn", " avcontext", "avectx", " avcf", "avalcontext", "afcontext", " avcu", " avloc", "avecontext", "afloc", "avalctx", " avconnection", "avca", "afcn", "navcu", "afcca", "avesync", "varci", "avecca", "avcor", "aycms", "afcf", "navconn", "avci", "verctx", "avepkg", "varctx", "afca", "vercn", "afcor", "avcu", "evcontext", "avcf", "aveca", "afctx", "afconnection", "avecmp", "afconn", "avconn", "avsync", "aupkg", "afsync", "ayctx", "avcms", "aucontext", " avca", "evctx", "varcontext", "avcmp", "afcms", "evcmp", "navctx", "vercontext", "avecor", " avsync", "aucmp", "avcn", "afcmp", "avcontext", "avalcca", "avecu", "avcca", "navcontext", "verci", "avloc", "avalloc", "auctx"]}}
{"project": "qemu", "commit_id": "f2b58c43758efc61e2a49b899f5e58848489d0dc", "target": 1, "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n\n{\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n    int rc = 1;\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n        s->pdus[i].s = s;\n\n        s->pdus[i].idx = i;\n\n    }\n\n\n\n    v9fs_path_init(&path);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n\n                   \"id = %s\",\n\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n\n                   s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n", "idx": 24280, "substitutes": {"s": ["js", "b", "scope", "in", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "h", "hs", "tests", "p", "args", "u", "sets", "ms", "si", "sync", "xs", "sq", "uses", "a", "as", "native", "n", "qs", "set", "secondary", "conf", "state", "gs", "aws", "es", "l", "ims", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "out", "o", "stats", "site", "its", "your", "status", "self", "full", "session", "ts", "is", "m", "sym", "w", "side", "sg", "this", "f", "ds", "data", "server", "ses", "sys", "sl", "sv", "os", "uns", "r", "bs", "storage", "ps", "v", "ins", "ns", "settings", "d", "ls", "services", "us", "se", "temp", "sum"], "errp": ["aerping", "strP", "errf", "err", " errP", "finderfp", "finderping", "strp", "errping", "errorfp", "erpre", "strr", "docpe", "errorpre", "errfp", "aerpre", "erp", "erf", "interp", "interpre", "finderp", "errorpi", "errorp", "interpi", "errpi", "errpre", "rrp", "aerp", "erfp", "docping", "rrfp", "aerfp", " errr", "errP", "finderpe", "docfp", "errpe", "arrping", "errr", "rrping", "strf", "erpi", "interfp", "arrp", "arrpre", "erpe", "erping", "docp", "rrpre", "arrfp", " errf", "erP"], "i": ["index", "x", "ai", "b", "oi", "li", "pi", "n", "ie", "z", "id", "j", "count", "end", "info", "hi", "ip", "iu", "ix", "type", "gi", "bi", "l", "ti", "y", "fi", "io", "uri", "xi", "ini", "multi", "p", "qi", "zi", "m", "di", "I", "t", "u", "init", "ii", "si", "e", "c", "limit", "d", "ind", "f", "eni", "start", "next", "ui", "ci", "iv", "ni", "ri", "ki", "mi"], "len": ["span", "bl", "li", "pl", "n", "sl", "lan", "z", "err", "lim", "count", "dy", "non", "nt", "fin", "ren", "en", "alt", "mem", "l", "la", "rev", "il", "pre", "lon", "lf", "fail", "ld", "lin", "el", "elt", "loc", "fn", "seq", "ind", "limit", "gen", "lc", "lit", "val", "dl", "min", "lt", "pos", "le", "ni", "Len", "length", "ln", "fl", "lang"], "stat": ["Stat", "dir", "x", "num", "un", "cpu", "status", "net", "proc", "lib", "task", "info", "fs", "nt", "g", "cache", "size", "open", "mem", "fi", "all", "p", "dev", "m", "lock", "def", "link", "block", "c", "sync", "exec", " Stat", "gen", "sec", "data", "call", "cat", "str", "reg", "list", "name", "stats"], "fse": [" fso", " fsle", "fcso", "vte", " fpe", "cfpse", "vze", "vke", "Fte", "dpe", "fsso", "fpe", "cfze", "fsSE", "fge", "rke", " fsu", "fxse", " fce", "fce", "vpse", "fsce", "fsle", "Fse", "Fpe", "fxso", "fze", "lfsle", "dsu", "fske", "cfte", "fte", "fsu", "lfse", "vge", "fsge", "fpse", "lfte", "dte", "fxce", "fke", "vse", " fke", "rse", "rsle", " fze", " fte", " fpse", "Fsu", "fspe", "fxte", "fcte", " fge", "fcse", "lfke", "fso", "cfse", "fste", "vSE", " fSE", "fsse", "fcpe", "fSE", "rte", "dse"], "path": ["depth", "dir", " prefix", "context", "port", " PATH", "alias", "n", " child", "key", "parent", "sc", " node", " method", "id", " name", "source", "ath", "er", " inner", "th", "text", " paths", "tag", "info", "r", "host", "image", " call", "root", "location", "pid", "url", "conn", "ref", "uri", "name", "pass", "p", "code", " location", "route", " priv", "prefix", "Path", "w", "device", " provider", " info", " config", "target", "node", "file", "str", "next", "data", "mount", "dest", " pass", " parent", "user", "PATH", " text", " prog", " pointer", "temp", "pointer", "ext"]}}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int wsd_read_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    int version;\n\n    uint32_t text_offset, data_offset, channel_assign;\n\n    char playback_time[AV_TIMECODE_STR_SIZE];\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avio_skip(pb, 8);\n\n    version = avio_r8(pb);\n\n    av_log(s, AV_LOG_DEBUG, \"version: %i.%i\\n\", version >> 4, version & 0xF);\n\n    avio_skip(pb, 11);\n\n\n\n    if (version < 0x10) {\n\n        text_offset = 0x80;\n\n        data_offset = 0x800;\n\n        avio_skip(pb, 8);\n\n    } else {\n\n        text_offset = avio_rb32(pb);\n\n        data_offset = avio_rb32(pb);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);\n\n    av_dict_set(&s->metadata, \"playback_time\", playback_time, 0);\n\n\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->codec_id    = s->iformat->raw_codec_id;\n\n    st->codecpar->sample_rate = avio_rb32(pb) / 8;\n\n    avio_skip(pb, 4);\n\n    st->codecpar->channels    = avio_r8(pb) & 0xF;\n\n    st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;\n\n    if (!st->codecpar->channels)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avio_skip(pb, 3);\n\n    channel_assign         = avio_rb32(pb);\n\n    if (!(channel_assign & 1)) {\n\n        int i;\n\n        for (i = 1; i < 32; i++)\n\n            if (channel_assign & (1 << i))\n\n                st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);\n\n    }\n\n\n\n    avio_skip(pb, 16);\n\n    if (avio_rb32(pb))\n\n       avpriv_request_sample(s, \"emphasis\");\n\n\n\n    if (avio_seek(pb, text_offset, SEEK_SET) >= 0) {\n\n        get_metadata(s, \"title\",       128);\n\n        get_metadata(s, \"composer\",    128);\n\n        get_metadata(s, \"song_writer\", 128);\n\n        get_metadata(s, \"artist\",      128);\n\n        get_metadata(s, \"album\",       128);\n\n        get_metadata(s, \"genre\",        32);\n\n        get_metadata(s, \"date\",         32);\n\n        get_metadata(s, \"location\",     32);\n\n        get_metadata(s, \"comment\",     512);\n\n        get_metadata(s, \"user\",        512);\n\n    }\n\n\n\n    return avio_seek(pb, data_offset, SEEK_SET);\n\n}\n", "idx": 24283, "substitutes": {"s": ["js", "b", "sf", "sl", "qs", "parser", "sc", "sv", "S", "gs", "os", "rs", "ops", "ssl", "sb", "sp", "fs", "r", "g", "sts", "ps", "aws", "ts", "sa", "v", "ks", "src", "service", "sis", "p", "cs", "sym", "t", "args", "m", "south", "su", "ns", "sg", "si", "sie", "e", "settings", "c", "d", "f", "ss", "spec", "ls", "ds", "sim", "services", "sq", "o", "se", "ses", "sys", "stats"], "pb": ["b", "prop", "platform", "bm", "pg", "fc", "pl", "mp", "plugin", "wp", "parser", "nb", "bc", "rob", "dll", "bh", "cp", "summary", "vp", "sb", "ctx", "PB", "prot", "pkg", "bs", "rb", "pm", "wb", "pp", "lab", "fp", "bps", "pid", "hub", "ib", "py", "pa", "ppa", "p", "gb", "xb", "tc", "dp", "ab", "ld", "mb", "db", "eb", "jp", "um", "bot", "pt", "bp", "pd", "pc", "lc", "cb", "bf", "lb", "typ", "cpp", "uf", "dl", "api", "phrase", "tp", "lp", "fb"], "st": ["sd", "ist", "bl", "sl", "ut", "et", "dt", "ost", "set", "sc", "mt", "std", "stop", "stand", "sth", "end", "www", "sb", "sp", "nt", "sts", "tt", "St", "stab", "ust", "ts", "sa", "put", "bt", "sam", "src", "sta", "rest", "est", "kt", "fr", "ess", "stage", "ste", "ft", "inst", "ld", "irst", "ast", "t", "ct", "elt", "rt", "pt", "start", "ss", "trans", "td", "ST", "str", "sn", "sw", "lt", "fe", "art", "nd", "se"], "version": ["depth", "date", "video", "plugin", "translation", " Version", "ception", "release", "parent", "alpha", "value", " versions", "step", "vers", "format", "Version", "connection", "python", "tag", "final", "current", "option", "patch", "feature", "position", "update", "model", "number", "type", "result", "cv", "serial", "v", "beta", "ver", "vision", "stage", "channel", "vert", "package", "bug", "scale", "latest", "support", " ver", " VERS", "f", "versions", "event", "server", "section", "name", "class", "length", "VERSION", "VER"], "text_offset": ["text_shift", "textxOffset", " text_size", "output_offset", "attribute_slot", " text_usage", "text_slot", "attribute_shift", "textxskip", "textxoffs", "text_usage", "textxoffset", "text_limit", "text_size", "text_skip", "output_Offset", " text_limit", "attribute_skip", "output_offs", "attribute_offset", "text_offs", "output_skip", "text_Offset"], "data_offset": ["data\u00b7limit", "data_size", "audio_off", "body_entry", "body_offset", "data___notation", "data___entry", "data___offset", "data_limit", "data\u00b7offset", "image_size", "image_offset", "data_index", "data_off", "data_entry", "data___limit", "body___notation", "body___offset", "data\u00b7off", "image_limit", "body_limit", "image_off", "body___entry", "audio_skip", "body___limit", "data_notation", "body_notation", "audio_offset", "data\u00b7size", "data_skip", "audio_index"], "channel_assign": ["channel_AssIGN", "channel_isalignment", "channel_ASSigning", "channel_isallate", "channel_assIGN", "channel_ignignment", "channel_Assign", "channel_isalign", "channel_allignment", "channel_Assigning", "channel_isaligned", "channel_ignigned", "channel_ignign", "channel_ASSignment", "channel_alligned", "channel_attlate", "channel_attignment", "channel_affign", "channel_affignment", "channel_attign", "channel_ASSign", "channel_Assignment", "channel_alllate", "channel_allIGN", "channel_attigned", "channel_assigning", "channel_attIGN", "channel_attigning", "channel_affigning", "channel_assignment", "channel_ignigning", "channel_allign", "channel_assigned", "channel_asslate", "channel_Assigned"], "playback_time": ["playbackJoffset", "playboard_rate", "playback24info", "playBack_time", "playboard24times", "playback_info", "playBack_name", "playBack_times", "playboard24info", "playback2times", "playback24time", "playBack_info", "playback24times", "playback_rate", "playback_times", "playback_name", "playback2rate", "playboard24rate", "playback2time", "playbackJtimes", "playboard_time", "playBack_offset", "playBack_rate", "playback24rate", "playbackJtime", "playbackJinfo", "playback2name", "playboard_info", "playboard_times", "playback_offset", "playboard24time"], "i": ["index", "x", "ai", "num", "b", "li", "pi", "n", "value", "z", "split", "j", "count", "abi", "yi", "info", "hi", "ip", "gi", "ri", "bi", "l", "v", "mu", "io", "slice", "fi", "ti", "xi", "ini", "multi", "p", "qi", "m", "zi", "di", "I", "chi", "u", "ii", "k", "si", "e", "c", "block", "uli", "eni", "f", "ui", "phi", "ci", "o", "ni", "ji", "a", "mi"]}}
{"project": "FFmpeg", "commit_id": "16c6795465fd7663792fe535256c760560714863", "target": 0, "func": "x11grab_read_header(AVFormatContext *s1)\n\n{\n\n    struct x11grab *x11grab = s1->priv_data;\n\n    Display *dpy;\n\n    AVStream *st = NULL;\n\n    enum AVPixelFormat input_pixfmt;\n\n    XImage *image;\n\n    int x_off = 0;\n\n    int y_off = 0;\n\n    int screen;\n\n    int use_shm;\n\n    char *dpyname, *offset;\n\n    int ret = 0;\n\n    Colormap color_map;\n\n    XColor color[256];\n\n    int i;\n\n\n\n    dpyname = av_strdup(s1->filename);\n\n    if (!dpyname)\n\n        goto out;\n\n\n\n    offset = strchr(dpyname, '+');\n\n    if (offset) {\n\n        sscanf(offset, \"%d,%d\", &x_off, &y_off);\n\n        if (strstr(offset, \"nomouse\")) {\n\n            av_log(s1, AV_LOG_WARNING,\n\n                   \"'nomouse' specification in argument is deprecated: \"\n\n                   \"use 'draw_mouse' option with value 0 instead\\n\");\n\n            x11grab->draw_mouse = 0;\n\n        }\n\n        *offset= 0;\n\n    }\n\n\n\n    av_log(s1, AV_LOG_INFO, \"device: %s -> display: %s x: %d y: %d width: %d height: %d\\n\",\n\n           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);\n\n\n\n    dpy = XOpenDisplay(dpyname);\n\n    av_freep(&dpyname);\n\n    if(!dpy) {\n\n        av_log(s1, AV_LOG_ERROR, \"Could not open X display.\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto out;\n\n    }\n\n\n\n    st = avformat_new_stream(s1, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto out;\n\n    }\n\n    avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */\n\n\n\n    screen = DefaultScreen(dpy);\n\n\n\n    if (x11grab->follow_mouse) {\n\n        int screen_w, screen_h;\n\n        Window w;\n\n\n\n        screen_w = DisplayWidth(dpy, screen);\n\n        screen_h = DisplayHeight(dpy, screen);\n\n        XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);\n\n        x_off -= x11grab->width / 2;\n\n        y_off -= x11grab->height / 2;\n\n        x_off = FFMIN(FFMAX(x_off, 0), screen_w - x11grab->width);\n\n        y_off = FFMIN(FFMAX(y_off, 0), screen_h - x11grab->height);\n\n        av_log(s1, AV_LOG_INFO, \"followmouse is enabled, resetting grabbing region to x: %d y: %d\\n\", x_off, y_off);\n\n    }\n\n\n\n    use_shm = XShmQueryExtension(dpy);\n\n    av_log(s1, AV_LOG_INFO, \"shared memory extension%s found\\n\", use_shm ? \"\" : \" not\");\n\n\n\n    if(use_shm) {\n\n        int scr = XDefaultScreen(dpy);\n\n        image = XShmCreateImage(dpy,\n\n                                DefaultVisual(dpy, scr),\n\n                                DefaultDepth(dpy, scr),\n\n                                ZPixmap,\n\n                                NULL,\n\n                                &x11grab->shminfo,\n\n                                x11grab->width, x11grab->height);\n\n        x11grab->shminfo.shmid = shmget(IPC_PRIVATE,\n\n                                        image->bytes_per_line * image->height,\n\n                                        IPC_CREAT|0777);\n\n        if (x11grab->shminfo.shmid == -1) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Can't get shared memory!\\n\");\n\n            ret = AVERROR(ENOMEM);\n\n            goto out;\n\n        }\n\n        x11grab->shminfo.shmaddr = image->data = shmat(x11grab->shminfo.shmid, 0, 0);\n\n        x11grab->shminfo.readOnly = False;\n\n\n\n        if (!XShmAttach(dpy, &x11grab->shminfo)) {\n\n            av_log(s1, AV_LOG_ERROR, \"Fatal: Failed to attach shared memory!\\n\");\n\n            /* needs some better error subroutine :) */\n\n            ret = AVERROR(EIO);\n\n            goto out;\n\n        }\n\n    } else {\n\n        image = XGetImage(dpy, RootWindow(dpy, screen),\n\n                          x_off,y_off,\n\n                          x11grab->width, x11grab->height,\n\n                          AllPlanes, ZPixmap);\n\n    }\n\n\n\n    switch (image->bits_per_pixel) {\n\n    case 8:\n\n        av_log (s1, AV_LOG_DEBUG, \"8 bit palette\\n\");\n\n        input_pixfmt = AV_PIX_FMT_PAL8;\n\n        color_map = DefaultColormap(dpy, screen);\n\n        for (i = 0; i < 256; ++i)\n\n            color[i].pixel = i;\n\n        XQueryColors(dpy, color_map, color, 256);\n\n        for (i = 0; i < 256; ++i)\n\n            x11grab->palette[i] = (color[i].red   & 0xFF00) << 8 |\n\n                                  (color[i].green & 0xFF00)      |\n\n                                  (color[i].blue  & 0xFF00) >> 8;\n\n        x11grab->palette_changed = 1;\n\n        break;\n\n    case 16:\n\n        if (       image->red_mask   == 0xf800 &&\n\n                   image->green_mask == 0x07e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log (s1, AV_LOG_DEBUG, \"16 bit RGB565\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB565;\n\n        } else if (image->red_mask   == 0x7c00 &&\n\n                   image->green_mask == 0x03e0 &&\n\n                   image->blue_mask  == 0x001f ) {\n\n            av_log(s1, AV_LOG_DEBUG, \"16 bit RGB555\\n\");\n\n            input_pixfmt = AV_PIX_FMT_RGB555;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR, \"RGB ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 24:\n\n        if (        image->red_mask   == 0xff0000 &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0x0000ff ) {\n\n            input_pixfmt = AV_PIX_FMT_BGR24;\n\n        } else if ( image->red_mask   == 0x0000ff &&\n\n                    image->green_mask == 0x00ff00 &&\n\n                    image->blue_mask  == 0xff0000 ) {\n\n            input_pixfmt = AV_PIX_FMT_RGB24;\n\n        } else {\n\n            av_log(s1, AV_LOG_ERROR,\"rgb ordering at image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 32:\n\n        input_pixfmt = AV_PIX_FMT_0RGB32;\n\n        break;\n\n    default:\n\n        av_log(s1, AV_LOG_ERROR, \"image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n        ret = AVERROR_PATCHWELCOME;\n\n        goto out;\n\n    }\n\n\n\n    x11grab->frame_size = x11grab->width * x11grab->height * image->bits_per_pixel/8;\n\n    x11grab->dpy = dpy;\n\n    x11grab->time_base  = av_inv_q(x11grab->framerate);\n\n    x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);\n\n    x11grab->x_off = x_off;\n\n    x11grab->y_off = y_off;\n\n    x11grab->image = image;\n\n    x11grab->use_shm = use_shm;\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width  = x11grab->width;\n\n    st->codec->height = x11grab->height;\n\n    st->codec->pix_fmt = input_pixfmt;\n\n    st->codec->time_base = x11grab->time_base;\n\n    st->codec->bit_rate = x11grab->frame_size * 1/av_q2d(x11grab->time_base) * 8;\n\n\n\nout:\n\n    av_free(dpyname);\n\n    return ret;\n\n}\n", "idx": 24289, "substitutes": {"x11grab": ["x10rob", "x11focus", "x10fab", "y11rob", "xi11fab", "sex110grab", "xi15grab", "x15crop", "y13tab", "x110rob", "x12grab", " x100crop", "X11rob", " x100hide", "x14focus", "x15rob", "x101grab", "X14transfer", "y13rob", "x12crop", "x18crop", "x110crop", "x86save", "X11grab", "X11transfer", "x100Grab", "x86stab", " x11crop", "x1rob", " x100grab", "x10grab", "y13grab", "x14rob", "X12crop", "sex11stab", "x18Grab", "x11hide", "xi15Grab", "x86rob", "x110save", "x18rob", "x13tab", "sex110stab", "X14Grab", "x110Grab", "X14rob", "x14transfer", "x11crop", "x11Grab", "x100transfer", "X12grab", " x11transfer", "x11storage", "x18stab", "x12fab", "xi11Grab", "sex11rob", "x511storage", "x15grab", "sex110rob", "x11pop", "x1hide", "x10Grab", "x100grab", "x110grab", "x15Grab", " x100rob", "sex11save", " x14focus", "X11crop", "x100rob", " x11focus", "x18save", "x12Grab", "x86grab", "x10storage", "X12Grab", "x11save", "x101crop", " x11storage", "x11stab", " x11rob", "x15tab", "X11pop", "sex11grab", "x1tab", "xi11grab", "y11hide", "x11rob", " x14transfer", "x511transfer", " x14storage", "x101rob", "x101hide", "x100crop", "X12pop", "x15fab", " x14grab", "x12pop", "x10focus", "x18grab", "x110pop", "x18pop", "x511grab", "x11transfer", "xi15rob", "xi11rob", "x14Grab", "x13hide", "x14storage", " x11hide", "y13hide", "x110stab", "xi15fab", "x11tab", "X11Grab", "X14grab", "sex110save", "y11tab", "x13grab", "x100hide", "x15hide", "x11fab", "x1grab", "y11grab", "x13rob", "x10transfer", "x511focus", "x14grab", "x12rob"], "dpy": ["lply", " dpie", "inply", " dmi", "dpi", "sdmy", "eph", " dpty", "vdPy", "ppy", "dspsy", "Dpi", "dspy", "dsync", "ppi", "pdpy", "Dpty", "cdpy", "cdpe", "ndph", "dp", "sdpy", "bdsync", "dpty", "ndpy", "lpe", "dsmy", "Dpe", "adply", "vdpe", "dply", "cdPy", "dmi", "dhapy", "sdpsy", "pdply", "Dp", "dpe", "ppe", "vdsync", " dp", "Dmi", "dpsy", "dPy", "inpe", "ppty", "bdPy", "adpe", "pdpe", "ldply", "ldpi", " dcp", "dhpsy", "adpy", "bdpy", "dhmy", "epy", "bdpe", "cdsync", " dply", "dapy", " dpi", "pcp", "pdpie", "dpie", "lpie", " dpsy", "dmy", "dhpy", "dsapy", "vdpy", "ndpsy", "ndpi", "ldp", "inpie", "inpy", "adpie", "epi", "epsy", "ldpie", "Dcp", "pp", "ldpe", "dph", "lpy", " dpe", "dcp", "pmi", "ldpy", "Dpy", "sdapy", " dph"], "st": ["bl", "ist", "sr", "sl", "ut", "ost", "sc", "std", "stack", "sth", "sb", "rd", "sh", "sp", "nt", "sts", "tt", "St", "ust", "sa", "put", "stim", "src", "stream", "sta", "rest", "est", "tmp", "fr", "cr", "t", "ste", "ft", "inst", "ld", "obj", "ast", "ct", "rt", "sty", "start", "td", "ST", "str", "sn", "sw", "art", "nd"], "image": ["x", "pg", "png", "icon", "crop", "picture", "gif", "photo", "jpg", "Image", "original", "mage", "large", "frame", "ii", "cm", "view", "file", "media", "amp", "img", "ng", "document", "xml", "im", "video"], "screen": ["network", "isc", "scope", "port", "remote", "chrome", "win", "sc", "resolution", "png", "score", "net", "count", "scene", "timeout", "resh", " sc", "sp", "window", "widget", "game", "gc", "size", "six", "close", " scr", "Screen", "style", "con", "scan", "script", "code", "draw", "speed", "password", "core", "stage", "channel", "glass", "profile", "clear", "page", " Screen", "scroll", "console", "twitter", "process", "display", "pen", "sec", "sw", "creen", "use", "esc", "en", "video", "play"], "use_shm": ["use2shmi", "use_whmi", "use_thmi", "use2thm", "use2shm", "use_shcm", "use_shmi", "use_whw", "use_whcm", "use_frmi", "use_thm", "use_shw", "use_frw", "use2shcm", "use2thw", "use2thmi", "use2shw", "use_whm", "use_thw", "use_thcm", "use_frm", "use2thcm", "use_frcm"], "dpyname": ["dpignaming", "copennoe", "dpennoe", "dpname", "dpypAME", "dcylame", "dpinname", "dpynname", "copyname", "dpydaming", "dpynamel", "dpynames", "dcyname", "tpyname", "dpYName", "dcypAME", "dpylename", "dpypames", "dpypase", "dpYNename", "dpylaming", "dpyanase", "vpynames", "dpylode", "dpinnename", "copynamel", "dcypame", "copennamel", "dpignAME", "dpYNamed", "dpignode", "vpynAME", "dpynaming", "dpinnamed", "dpydode", "dpylames", "dpnamel", "tpylename", "dpydame", "dcynaming", "copynamed", "dpynamed", "dpyanamed", "dpyanoe", "tpennename", "pYNamed", "dcynename", "vpyname", "tpylames", "dpynAME", "dpennename", "dpnamed", "dpyanamel", "dcynames", "dpynode", "dpinnames", "dpennamel", "dpysAME", "vpypame", "dpennase", "copenname", "dpYNAME", "tpenname", "dpynename", "dpennamed", "vpynename", "dpnoe", "dpYNname", "vpypAME", "dcynode", "dpysame", "dpydAME", "dpypename", "dpenname", "dcynAME", "tpynames", "dpysename", "pYNname", "dcypename", "vpypename", "dpYNames", "dpysames", "copynoe", "dcylaming", "dpylame", "tpynase", "dpennAME", "pYNename", "vpypames", "dpynoe", "tpylame", "tpennAME", "copennamed", "dpynase", "dcylode", "dpylAME", "tpennase", "pyname", "tpynAME", "pynamed", "dpyaname", "dpyanename", "dpyanAME", "dpinnAME", "dpigname", "dcypames", "dpypame", "tpylAME", "pynename", "tpynename", "dpinnname", "dcylAME", "pynname", "pYName", "dpyanname"], "offset": ["index", "reset", "alias", "array", "et", "alpha", "align", "slot", "ace", "shift", "end", "timeout", "connection", "Offset", "reference", "function", "info", "option", "layout", "position", "optional", "operation", "type", "axis", "size", "no", "location", "fp", "slice", "ref", "part", "off", "skip", "range", "origin", "p", "initial", "annot", "address", "prefix", "page", "attribute", "online", "scroll", "comment", "missing", "addr", "append", "loc", "start", "padding", "f", "output", "layer", "data", "pos", "o", "pad", "order", "length", "pointer"], "color_map": ["gray_maps", "gray_map", "color_code", "gray_code", "color_maps", "gray_set", "color_set"], "color": ["cap", "array", "Color", "base", "pair", "gray", "byte", "format", "space", "col", "window", "number", "type", "colour", "black", "white", "block", "object", "data", "map", "mask", "list", "COLOR"], "i": ["index", "b", "reset", "pi", "n", "align", "id", "info", "is", "inner", "on", "p", "line", "s", "I", "it", "ii", "si", "cut", "e", "pixel", "start", "f", "data", "ui"], "screen_w": ["screenNh", " screen_off", "screenNW", "disk_width", "screen_width", "screen_won", "disk_w", "screen_off", "screenNw", "disk_won", "screen_W", "disk_y", "screen_y", "screenNoff", " screen_W"], "screen_h": ["screen_v", "screen_sh", "screen25v", "screen25h", " screen_hh", " screen_ha", "screen25ha", " screen_v", "screen_ha", "screen_hh", "screen25w", " screen_sh"], "w": ["x", "fw", "weight", "n", "win", "aw", "wt", "z", "wid", "ow", "ew", "W", "wa", "row", "window", "r", "widget", "g", "wb", "max", "l", "y", "v", "h", "wx", "p", "m", " W", "t", "wall", "u", "web", "we", "e", "c", "wh", "d", "f", "sw", "rw"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++)\n\n        if (simple_limit(dst+i*stride, 1, flim))\n\n            filter_common(dst+i*stride, 1, 1);\n\n}\n", "idx": 24291, "substitutes": {"dst": ["Ddr", "idsc", "idld", "sdST", "sdst", "dsc", "godset", "pddr", " dST", "sdsc", "pdst", "ddr", "godst", "dsts", "idset", "sdsts", "Dost", "pdld", "dset", "Dst", "dost", "idst", "godsc", "dld", "godost", "pdost", "dST", "dssts", "dsST", " dsts", "iddr", " dset", "Dld", "dsst", " dost", "dssc", "idost", " dsc"], "stride": ["charided", "strride", "stIDE", "strided", " strine", "Strider", " strided", "stode", "charIDE", "strider", "strIDE", "STRide", "stider", "Stride", "charide", "Strade", "yrider", "STRride", "yrided", "strine", "Strided", "stided", " strode", " strIDE", "yride", "charode", "stade", "STRine", "stide", " strride", "yrade", "strode", "stine", "STRided", "strade"], "flim": [" flic", "sflimited", "rflic", "fmi", "flimited", "rflimited", "dlog", " fmem", "dmem", " flimit", "flimit", "fmem", "dlimit", " fmi", " flimited", "sfmi", "dlim", "clim", "sflim", "sflic", "rfmi", "rflim", "cmem", "flic", "climit", "flog", " flog"], "i": ["x", "b", "index", "ai", "mini", "oi", "li", "pi", "in", "iii", "id", "j", "count", "abi", "strength", "info", "hi", "iu", "ip", "ix", "ei", "attr", "gi", "ri", "bi", "l", "v", "h", "io", "ti", "mu", "fi", "uri", "xi", "slice", "ini", "uni", "multi", "p", "qi", "zi", "m", "di", "I", "u", "it", "ii", "si", "e", "sup", "d", "eni", "f", "ami", "adi", "api", "ui", "ci", "phi", "o", "ni", "ji", "mi"]}}
{"project": "qemu", "commit_id": "a77fd4bb2988c05953fdc9f1524085870ec1c939", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292, "substitutes": {"bs": ["js", "b", "banks", "ubis", "pb", "css", "base", "vs", "bc", "blocks", "gs", "bits", "os", "rs", "nas", "ubs", "bb", "sb", "bid", "bos", "fs", "fps", "states", "bps", "ks", "las", "ras", "boxes", "gb", "cs", "lbs", "iss", "bas", "ns", "db", "bes", "BS", "ss", "ls", "ds", "lb", "bus", "us", "ses", "bis", "fb"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n", "idx": 24294, "substitutes": {"nonblocking": ["notblock", "notblocking", "nonblock", "nonblocks", "nonlocking", "Nonblocks", "noblock", "Nonblock", "notlocking", "notblocks", " nonlocking", "noblocks", " nonblocks", "Nonlocking", "nolocking", " nonblock", "Nonblocking", "noblocking"], "last_io": [" last_ios", " last_timeout", "last_ios", "last_exec", "last_iol", "last_ori", " last_exec", " last_lo", "last_lo", " last_iol", " last_ori", "last_timeout"], "ti": ["ai", "li", "pi", "ita", "ie", "tm", "tta", "abi", "ta", " vi", "wa", "iu", "hi", "isi", "bi", "iot", "ati", "tti", "fi", "xi", "ini", "iti", "zi", "di", "tim", "ski", "ii", "si", "rt", "TI", " i", "timer", "eni", "i", "cli", "ori", "ui", "obi", "vi", "ci", "tw", "tu", "trace", "ni", "ri", "ki", "tis", "mi"], "r": ["b", "ra", "n", "rf", "rx", "err", "lr", "rs", "er", "nor", "or", "rb", "br", "attr", "root", "l", "v", "h", "resource", "rg", "race", "range", "rw", "R", "p", "m", "runner", "rl", "cr", "t", "u", "w", "rc", "runs", "rt", "e", "c", "d", "f", "kr", "hr", "ru", "q", "rr", "trace", "o", "rar", "ro", "ry", "ri", "nr", "a", "re"]}}
{"project": "qemu", "commit_id": "0928a95ffe91862938cee997c9e30602fa7884ab", "target": 0, "func": "static void bootp_reply(const struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc = NULL;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    const struct in_addr *preq_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\", bp->bp_op, dhcp_msg_type);\n\n    if (preq_addr)\n\n        dprintf(\" req_addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n    else\n\n        dprintf(\"\\n\");\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        if (preq_addr) {\n\n            bc = request_addr(preq_addr, client_ethaddr);\n\n            if (bc) {\n\n                daddr.sin_addr = *preq_addr;\n\n            }\n\n        }\n\n        if (!bc) {\n\n         new_addr:\n\n            bc = get_new_addr(&daddr.sin_addr);\n\n            if (!bc) {\n\n                dprintf(\"no address left\\n\");\n\n                return;\n\n            }\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else if (preq_addr) {\n\n        bc = request_addr(preq_addr, client_ethaddr);\n\n        if (bc) {\n\n            daddr.sin_addr = *preq_addr;\n\n            memcpy(bc->macaddr, client_ethaddr, 6);\n\n        } else {\n\n            daddr.sin_addr.s_addr = 0;\n\n        }\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (bc) {\n\n        dprintf(\"%s addr=%08x\\n\",\n\n                (dhcp_msg_type == DHCPDISCOVER) ? \"offered\" : \"ack'ed\",\n\n                ntohl(daddr.sin_addr.s_addr));\n\n\n\n        if (dhcp_msg_type == DHCPDISCOVER) {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPOFFER;\n\n        } else /* DHCPREQUEST */ {\n\n            *q++ = RFC2132_MSG_TYPE;\n\n            *q++ = 1;\n\n            *q++ = DHCPACK;\n\n        }\n\n\n\n        if (bootp_filename)\n\n            snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                     bootp_filename);\n\n\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 24311, "substitutes": {"bp": ["b", "bm", "pg", "pb", "gp", "wp", "bh", "cp", "bb", "sb", "sp", "pkg", "rb", "arp", "bn", "pp", "bitcoin", "fp", "bps", "bt", "conn", "kb", "py", "p", "gb", "ap", "BP", "db", "jp", "hp", "pc", "pd", "cb", "bf", "lb", "cpp", "np", "tp", "lp", "fb"], "bc": ["b", "loop", "fc", "bl", "BC", "dc", "comm", "xc", "sc", "com", "ca", "nc", "ac", "cc", "cms", "abi", "func", "lib", "lic", "bb", "sb", "bo", "fb", "mc", "gc", "bs", "g", "bn", "wb", "bitcoin", "bi", "ref", "cf", "BBC", "bd", "config", "oc", "vc", "cl", "ic", "tc", "cn", "rc", "cm", "acl", "web", "ctrl", "db", "MC", "cca", "mac", "loc", "uc", "c", "sync", "exec", "pc", "ec", "lc", "cb", "bf", "sec", "lb", "ml", "abc", "bg", "cur"], "m": ["b", "gm", "bm", "n", "vm", "mad", "tm", "mt", "mn", "me", "message", "mx", "r", "g", "mc", "l", "v", "mu", "h", "y", "mr", "hm", "manager", "M", "sm", "p", "man", "dm", "t", "fm", "u", "md", "cm", "ms", "um", "wm", "e", "media", "c", "rm", "d", "module", "f", "i", "msg", "mm", "ml", "am", "o", "em", "im", "mi"], "rbp": ["lrp", "lrtp", "rlpc", "rdp", "lbP", "wbpc", "rtp", "rdpr", "rbpr", "rbpi", "rlc", "bbp", "RBpc", "RBP", "rbpc", "rbtp", "wbc", "wbp", "wbpr", "lbtp", "lbp", "rbc", "rtv", "rlpr", "rdc", "lrP", "vrpi", "vrv", "rlp", "bbv", "lrpc", "bbpc", "lbpc", "rtpi", "RBtp", "rbP", "bbpi", "vrpc", "rtpc", "vrp", "RBp", "rdpc", "rbv"], "saddr": ["_addr", "shop", "saddress", " saddress", "sysaddress", "_hop", " shop", "syshop", "sysaddr", "_address"], "daddr": ["larr", "dalias", " daddress", "pacl", "poder", "paddr", "adarr", " dalias", "darr", "dnode", " darr", "baddress", "parr", "doder", " dacl", "adnode", "adaddr", "roder", "Darr", "dynode", "daddress", "laddr", "laddress", "barr", "raddress", " doder", "Daddr", "Daddress", " dattr", "baddr", " dnode", "raddr", "pattr", "adalias", "dacl", "racl", "paddress", "dattr", "dyarr", "dyaddr", "battr", "Dattr", "lattr", "dyalias"], "dns_addr": ["dnsamname", "dnsamurl", "dns_name", "dns_url", "dnet_name", "dns_address", "dnet_url", "dnet_addr", "dnsamaddr", "dnet_address", "dnsamaddress"], "preq_addr": ["preq_offer", "prereq_addr", "preq2address", "preqMtype", "preq_hop", "preq__addr", "preq2nr", "prequest_hop", "preqMnode", "preq67offer", "prev_address", "prequest__addr", "preq_orig", "preqingaddress", "prequest_type", "preq67error", "preq2host", "preq_arm", "preqMaddr", "preq67url", "prece_host", "preqinghl", "prev_addr", "prev_data", "preq2addr", "preq__ord", "preque_loc", "preq2add", "preque_url", "preq__dr", "prereq_ord", "preq2hop", "preq_dist", "preq__type", "prereq_rx", "preq_ord", "preqdaddress", "prequest_node", "preq__add", "preqddr", "preque67arm", "preq_address", "prequest__type", "prece_addr", "prec_error", "preqkaddr", "prereq_dist", "preqdnode", "preq_host", "prequest_nr", "preq_offset", "preque_arm", "preq_name", "preq_loc", "preque_addr", "preqdtype", "preq__host", "prequest__node", "preqdaddr", "preq_error", "preqingaddr", "preqkhop", "preq_hl", "preqMaddress", "prequest_hl", "preq__address", "preq_add", "preq2dr", "prequest_addr", "prequest__address", "prequest_orig", "prereq_address", "preqingorig", "prec_addr", "prece_add", "prereq_name", "preq_dr", "preque67url", "prece_dr", "prev_hop", "prequest_address", "preq__name", "preq67loc", "preqkdata", "preq_nr", "preq_node", "prec_offer", "preq__node", "preqdoffset", "preq67addr", "preq_type", "prequest_offset", "preq_data", "preq67arm", "prequest_dr", "preq_rx", "preq__offset", "preq_url", "preqkaddress", "preque67addr", "preque67loc"], "dhcp_msg_type": ["dhcp_message_types", "dhcp_msgbid", "dhcp_msg_num", "dhcp_msg_id", "dhcp_message_info", "dhcp_msg_format", "dhcp_msg_name", "dhcp_msg_data", "dhcp_msg__id", "dhcp_msg__type", "dhcp_msgbname", "dhcp_message_code", "dhcp_msgbformat", "dhcp_msg_types", "dhcp_message_num", "dhcp_message_id", "dhcp_msg_class", "dhcp_message_data", "dhcp_message_key", "dhcp_msg__num", "dhcp_msgbtype", "dhcp_msg_info", "dhcp_msg__block", "dhcp_msg_key", "dhcp_message_block", "dhcp_message_name", "dhcp_message_type", "dhcp_msg_code", "dhcp_message_class", "dhcp_msg_block", "dhcp_msg_no", "dhcp_message_format", "dhcp_message_no"], "val": ["x", "num", "key", "ret", "value", "valid", "eval", "aud", "len", "sel", "fee", "ne", "r", "g", "v", "all", "ref", "al", "enc", "vals", "def", "w", "seq", "f", "sec", "msg", "data"], "q": ["x", "iq", "eq", "dq", "Q", "z", "id", "req", "qq", "r", "g", "qt", "v", "h", "query", "config", "cl", "s", "w", "k", "c", "seq", "d", "f", "sq", "qa", "o"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n", "idx": 24312, "substitutes": {"f": ["x", "b", "fc", "sf", "n", "rf", "filename", "func", "inf", "full", "fd", "function", "fs", "r", "g", "framework", "l", "v", "h", "fi", "fp", "ref", "p", "m", "fr", "t", "F", "s", "w", "font", "feed", "file", "e", "c", "fn", "d", "fold", "fore", "fa", "fx", "fen", "o", "ff", "form", "fff", "fb", "buff"], "cpu_fprintf": ["cpu_frwrite", "cpu_fmt", "cpu_forprintln", "cpu_formt", "cpu_Fprintln", "cpu_rfprintf", "cpu_fwrite", "cpu_frprintf", "cpu_rfwrite", "cpu_rfmt", "cpu_Fwrite", "cpu_rfprintln", "cpu_forformat", "cpu_fprintln", "cpu_Fprint", "cpu_Fprintf", "cpu_friter", "cpu_forprint", "cpu_forwrite", "cpu_fformat", "cpu_forprintf", "cpu_fprint", "cpu_forriter", "cpu_frprintln", "cpu_rfprint", "cpu_rfformat", "cpu_frriter"], "features": ["span", "ips", "lists", "details", "tops", "flags", "ributes", "bits", "format", "requires", "faces", "info", "feature", "forms", "fixes", "fields", "fts", "files", "tests", "strings", "ints", "prints", "properties", "names", "feat", "pieces", "ns", "settings", "ATURES", " Features", "types", "includes", "eatures", "frames", "pages", "Features", "versions", "modules", "pins", "classes", "plugins", "ants"], "prefix": ["reset", "border", "path", "parent", "base", "repeat", "flags", "filename", "progress", "format", "text", "reference", "info", "patch", "feature", "cache", "prot", "ix", "type", "master", "fixes", "fix", "fp", "mix", "ref", "uri", "before", "pre", "p", "primary", "radius", "buffer", "scale", "support", "pad", "bp", "padding", "phrase", "pattern", "foo", "name", "length", "pointer", "offset"], "i": ["index", "x", "ai", "b", "oi", "isin", "in", "pi", "n", "li", "ie", "key", "z", "id", "j", "abi", "yi", "iu", "ix", "gi", "ri", "bi", "l", "v", "ti", "io", "fi", "h", "mu", "y", "xi", "ini", "name", "uri", "multi", "p", "qi", "m", "zi", "di", "I", "t", "u", "it", "ii", "k", "si", "e", "c", "d", "ind", "lc", "start", "ui", "ci", "o", "ni", "ji"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315, "substitutes": {"gen_code_buf": ["gen_code2end", "gen_code2len", "gen_codes_len", "gen_code36uf", "gen_code24buff", "gen_code_len", "gen_codes_uf", "gen_call_ptr", "gen_code_uf", "gen_codes_end", "gen_code36buf", "gen_code24end", "gen_code2buf", "gen_call_buf", "gen_call_end", "gen_codes2uf", "gen_code36end", "gen_code_offset", "gen_code24ptr", "gen_call_buff", "gen_codes_buf", "gen_code1len", "gen_code1uf", "gen_code36len", "gen_code_ptr", "gen_codes2end", "gen_code_buffer", "gen_code1end", "gen_code_buff", "gen_code_pad", "gen_code24buf", "gen_code1buf", "gen_codes2len", "gen_call_pad", "gen_codes2buf", "gen_code2uf", "gen_call_buffer", "gen_call_offset"], "max_code_size": ["max_code_max", "max_codes_len", "max_cache_SIZE", "max_code2size", "max_cache_size", "max_code_len", "max_code2SIZE", "max_code2max", "max_code_SIZE", "max_codes_size", "max_codes_capacity", "max_cache_max", "max_code_capacity"], "gen_code_size_ptr": ["gen_code_size_pt", "gen_code_size_inter", "gen_code_address_tr", "gen_code_size_pointer", "gen_code_address_pt", "gen_code_address_ptr", "gen_code_address_pointer", "gen_code_size_tr"], "pc_start": ["pc2ptr", "pc67scale", "pc67start", "pc_offset", "pc_len", "pc_end", "fc_start", "fc_end", "pc67end", "pc2start", "PC_ptr", "pc67offset", "pc_scale", "pc2end", "pc2len", "PC_start", "fc_offset", "fc_scale", "PC_end", "PC_len"], "flags": ["lag", "details", "days", "blocks", "cards", "bits", "func", "ops", "opens", "bytes", "Flags", "len", "heads", "fee", "fs", "ags", "packs", "fields", "fts", "options", "windows", " Flags", "atts", "files", "tests", "rets", "strings", "vals", "ints", "codes", "features", "s", "args", "lf", "alls", "fun", "lins", "feat", "lines", "utils", "limits", "seq", "rules", "f", "types", "checks", "pages", "xs", "pins", "words", "mask", "planes", "flag", "plugins", "comments", "groups", "FLAG", "stats", "ants", "mods"], "dc1": ["nc1", "dc0", "dc2", " dc2", "rc1", "DC1", "DC0", " dc0", "rc0", "c0", "nc0", "c1", "DC2", "c2"], "dc": ["dir", "fc", "dd", "dt", "xc", "da", "df", "bc", "sc", "input", "nc", "ac", "cc", "disc", "ctl", "fd", "gui", "enter", "mc", "gc", "dim", "dra", "dr", "dk", "director", "auc", "conn", "cf", "enc", "vc", "draw", "tc", "dm", "di", "cmd", "cr", "dp", "rc", " DC", "ctrl", "ct", "db", "design", "device", "jc", "desc", "cca", "doc", "loc", "c", "inc", "d", "uc", "ec", "lc", "td", "ds", "ea", "DC", "diff", "vd", "cdn", "abc", "dat", "ga", "cd"], "gen_code_end": ["gen_codeenlength", "gen_codepreoffset", "gen_codeprepend", "gen_code_pend", "gen_codes_start", "gen_codeenstart", "gen_codes_end", "gen_call_END", "gen_call_end", "gen_code67pend", "gen_code_offset", "gen_codes_offset", "gen_call_start", "gen_codeprestart", "gen_codes_pend", "gen_codeenend", "gen_code_END", "gen_code67start", "gen_code_length", "gen_code67end", "gen_codeenmax", "gen_code67offset", "gen_code_max", "gen_code_start", "gen_codepreend"], "pc_ptr": ["fc_code", "pc67pad", "fc_pad", "pc_end", "bc_pointer", "dc_end", "fc_ptr", "PC_enter", "bc_ptr", "pc_enter", "dc_addr", "PC_start", "pc_ref", "pc67ref", "fc_desc", "pc_desc", "pc_pointer", "bc_pad", "PC_ptr", "fc_tip", "pc_addr", "dc_pointer", "pc_tip", "dc_ptr", "bc_ref", "pc67pointer", "fc_offset", "pc67ptr", "pc_code", "pc_offset", "fc_end", "fc_pointer", "dc_size", "pc_size", "PC_pointer", "pc_pad"], "ret": ["last", "num", "lag", "status", "reply", "mt", "id", "RET", "xt", "let", "len", "red", "r", " RET", "nt", "gc", "fin", "result", "alt", "job", "det", "no", "ry", "ref", "part", "al", "rev", "rets", "code", "repl", "rl", "match", "ft", "obj", "rc", "fun", "buffer", "ct", "att", "comment", "arg", "desc", "rt", " Ret", "bot", "lit", "bf", "val", "rep", "data", "back", "Ret", "reg", "res", "flag", "eth", "pat", "bit", "success", "re", "ext"], "disasm_info": ["disast_info", "disast_error", "disasmamoffset", "disasmaminf", "dispackaminformation", "disasmaminfo", "disasmamhelp", "disassembly_info", "dispack_information", "disast_offset", "disjam_Info", "disasmCstate", "disast_help", "disam_info", "disasm2help", "disast2info", "disasmamerror", "disast2help", "disasm_offset", "dispack_alias", "disasm_conf", "disasm_help", "disassembly_state", "disasm_state", "disasm2info", "disam_error", "disasm_id", "disasm_alias", "disast2error", "disasmamalias", "disassembly_spec", "disjam_info", "disasmaminformation", "disasm_inf", "disast2offset", "disasm_information", "disjam_conf", "dispack_info", "dispackamalias", "disasm2offset", "disasmCspec", "disjam_id", "disasm_spec", "disasm_error", "dispackaminfo", "disam_inf", "disasmCinfo", "dispackaminf", "dispack_inf", "disam_now", "disasm_now", "disasm2error", "disasm_Info"], "pc": ["fc", "pb", "cpu", "xc", "sc", "bc", "anc", "nc", "proc", "ac", "cc", "arc", "mc", "pid", "enc", "con", "tc", "toc", "rc", "mac", "amp", "uc", "c", "lc", "td", "PC", "pointer", "sys"], "count": ["depth", "num", "found", "parent", "base", "child", "id", "Count", "proc", "cc", "func", "col", "len", "total", "nt", "cache", "type", "ref", "con", "code", "toc", "counter", "c", "seq", "cb", "call", "length", "offset"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328, "substitutes": {"qiv": ["quih", "qterv", "qih", "questiv", "querv", "qiva", "questerv", "qaih", "reqivist", "qtiv", "questistor", "quiver", "quivist", "quivable", "qtivable", "qivable", "qistor", "questiva", "reqiv", "quistor", "qiver", "qaiv", "qtiver", "qivist", "qaiva", "quiva", "questih", "qerv", "questivist", "reqivable", "qtivist", "quiv", "questiver", "qaistor", "reqiver"], "name": ["x", "alias", "n", "key", "path", "parent", "search", "value", "base", "id", "self", "property", "none", "create", "image", "word", "size", "ix", "type", "attr", "new", "part", "named", "large", "on", "change", "pass", "prefix", "names", "ame", "var", "comment", "Name", "old", "time", "param", "start", "object", "data", "call", "am", "NAME", "ext"], "errp": ["errcp", "asterr", " errcp", " errP", "err", " errpre", " erp", "errpr", "astersp", " errpc", "erpre", "asterp", " erpr", "errsp", "erp", "rrr", "rrp", "errpre", "rrcp", "erpc", "errP", " errr", "errpc", "asterpr", " ersp", "errr", " errpr", "rrP", "rrpre", " err", " errsp", "ercp", "rrpc", "erP"], "qobj": ["kobj", "cstr", "eqstr", "querypos", "eqobject", "cobject", "wbr", "wbo", "qbo", "qobject", "queryobject", "querybo", "queryobj", "wpos", "kbo", "qubo", "qucode", "eqcode", "kstr", "qupos", "pobject", "qcode", "pobj", "qpos", "kbr", "querystr", "quobj", "cobj", "qubr", "pstr", "pcode", "eqobj", "cbo", "wobj", "kobject", "wobject", "quobject", "qbr", "wstr", "qustr"], "qstr": ["qarr", "questname", "queststr", "questarr", "qint", "sqint", "eqstr", "quinst", "dqhr", "sqbytes", "qpass", "qustring", "qstring", "dqinst", "quhr", "quname", "qname", "dqpass", " qarr", "qubytes", "questhr", "qinst", "queststring", "qusl", "eqinst", "qhr", " qint", "questsl", " qsl", " qhr", "qutr", "dqstr", "eqpass", "sqstr", "sqtr", " qname", "quarr", "qupass", "qbytes", " qstring", "quint", "eqhr", "qsl", "qtr", " qtr", " qbytes", "qustr"]}}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331, "substitutes": {"obj": ["buf", "Obj", "parent", "j", "self", "os", "orb", "ops", "objects", "ctx", "sb", "nt", "ob", "ock", "conn", "io", "src", "obb", "enc", "bj", "oc", "arr", "tmp", "cn", "ex", "init", "Object", "po", "jp", "node", "pt", "cb", "object", "data", "pos", "o", "so", "org", "opt", "pointer"], "ioc": ["iiroc", "xioc", "ioocl", "ioco", "ioca", "riocl", "iitoc", "ioroc", "proc", "iob", "iirc", "pioc", "diroc", "iooc", "dioca", "rioc", "iiOC", "diocl", "iioc", "gioco", "piroc", "rioca", "dioc", " iirc", "riroc", "pOC", "xiocl", "iooco", " itoc", "giocl", "gioc", "riirc", "iroc", "iocl", "itocl", "iOC", "itroc", "ptoc", "poc", "xiob", " iob", " iocl", "piocl", "giroc", " iroc", "xioco", "piob", "xiroc", "itirc", "gioca", "itoc", " iOC"]}}
{"project": "qemu", "commit_id": "c9add6219514b20223f024584f0464b8842b1ec0", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351, "substitutes": {"mount_point": [" mount_patch", "mountvepath", " mount_pointer", "mount_center", "mount00point", "mount_points", "downloadplepoint", "downloadpleline", "mountplelocation", "mount_location", "match_path", "mountingpath", " mount_path", " mount_size", "download_line", "download_center", "mountvepoint", "mount00patch", "mountEndpath", "mountingpoints", "mount_patch", "download_location", "mount_path", " mount_points", "mountEndpoints", "match_pointer", "download_point", "mountvesize", "downloadplecenter", "mount00pointer", "mount24location", "downloadplelocation", "mount24line", "mountplecenter", "mountvepointer", "match_points", "mountingpointer", "mount24center", "mount00points", "mountEndpointer", "mount24point", "match_point", "mountplepoint", "mountEndpoint", "mountingpoint", "mount_pointer", "mount_size", "mount_line", "mountpleline"], "path": ["dir", "platform", "port", "context", "key", "parent", "error", "home", "entry", "thin", "progress", "cp", "ath", "text", "test", "patch", "image", "cache", "size", "type", "open", "root", "close", "walk", "url", "conn", "enc", "stream", "config", "wd", "level", "p", "code", "lock", "runner", "rh", "match", "Path", "bug", "clean", "time", "file", "process", "point", "c", "object", "pattern", "mount", "dest", "trace", "method", "PATH", "user", "name", "temp", "pointer"], "debugfs_found": ["debugfsallfound", "debugFS_found", "debugfsalllen", "debugf_len", "debugf_Found", "debugFS_err", "debugfsallFound", "debugfs_find", "debugfs_err", "debugFS_find", "debugfs_mounted", "debugFS_Found", "debugf_err", "debugfs_Found", "debugfs_len", "debugf_mounted", "debugf_found"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A1 = 0xffff<<14, A2= 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A1 = 0xffff<<14, A2 = 0xffff<<14;\n\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n            int Y1 = (buf0[i * 2]    ) >> 2;\n\n            int Y2 = (buf0[i * 2 + 1]) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y1 -= c->yuv2rgb_y_offset;\n\n            Y2 -= c->yuv2rgb_y_offset;\n\n            Y1 *= c->yuv2rgb_y_coeff;\n\n            Y2 *= c->yuv2rgb_y_coeff;\n\n            Y1 += 1 << 13;\n\n            Y2 += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] << 11;\n\n                A2 = abuf0[i * 2 + 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24356, "substitutes": {"ubuf0": ["ubbufk", "ubbuff8", "abbuf0", "ubuf8", "ubbuf6", "ubuf6", "ubf2", "ubbuf2", "ubbuff1", "ubbuffk", "ubufk", "ubf0", "ubuffer6", "abuf8", "abbufk", "abbuf1", "abbuf2", "ubufferk", "ubf1", "ubuffer1", "ubbuff2", "ubbuf8", "ubuffer0", "abbuf8", "ubbuff0", "ubf8", "abuf6", "abuf2", "ubuf2", "ubbuf1", "abufk", "abbuf6", "abuf0", "abuf1", "ubbuf0", "ubbuff6"], "vbuf0": ["vuf0", "vbuffk", "Vbuff0", "vbuff50", "vbuff0", "Vbuff2", "fbuff0", "vbufferk", "vbufk", "vcv50", "fbuf2", "vbuff1", "fbuf1", "vuf2", "fbuff2", "vbuff2", "fbuff1", "vbuf50", "vbuffer0", "Vbuf2", "Vbuf0", "fbuf0", "vbuffer1", "Vbuf50", "vbuffer2", "vufk", "fbufk", "vcv0", "fbuffk", "Vbuff50", "vuf1", "vcv2", "vbuf2"], "i": ["x", "b", "ai", "mini", "index", "oi", "li", "pi", "n", "ie", "id", "j", "me", "yi", "info", "iu", "ip", "hi", "image", "ix", "gi", "bi", "l", "is", "v", "ti", "y", "fi", "io", "mu", "uri", "xi", "ini", "slice", "inner", "part", "multi", "p", "qi", "m", "zi", "di", "I", "chi", "u", "it", "page", "ii", "my", "si", "e", "c", "d", "eni", "f", "cli", "api", "ui", "phi", "ci", "o", "ni", "ri", "mi"], "R": ["E", "V", "Q", "Y", "DR", "D", "A", "S", "N", "RR", "W", "X", "r", "L", "U", "M", "K", "O", "I", "GR", "P", "F", "C", "UR", "NR", "ER", "H", "Re", "RP", "RC", "RA", "J"], "G": ["GN", "E", "Ge", "V", "Q", "Y", "D", "A", "S", "N", "LG", "W", "X", "GH", "g", "AG", "Gs", "L", "U", "M", "Gu", "GB", "Gr", "O", "I", "F", "P", "GR", "C", "H", "MG", "J"], "B": ["b", "AB", "V", "Q", "Y", "OB", "Bs", "D", "A", "N", "NB", "W", "PB", "WB", "L", "MB", "U", "M", "GB", "O", "I", "P", "C", "IB", "BL", "LB", "BS", "BO", "UB", "FB", "Ub", "HB", "T", "EB", "Bi", "J", "DB"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364, "substitutes": {"v": ["b", "V", "vm", "GV", "value", "vs", "sv", "ve", "j", "self", "lv", "vp", "vt", "g", "inv", "cv", "vim", "l", "vic", "h", "vc", "p", "m", "conv", "t", "u", "ev", "w", "vv", "k", "view", "e", "gu", "c", "f", "i", "tv", "val", "vis", "iv", "o", "client", "uv"], "obj": ["js", "b", "adj", "Obj", "base", "value", "j", "self", "func", "objects", "ctx", "emb", "type", "attr", "ref", "src", "oa", "py", "arr", "code", "args", "inst", "prefix", "Object", "po", "node", "fn", "cb", "object", "api", "data", "val", "o", "class", "ob"], "name": ["alias", "n", "key", "path", "parent", "error", "base", "member", "id", "anc", "self", "len", "info", "word", "size", "type", "attr", "new", "part", "named", "inner", "label", "code", "nam", "prefix", "names", "Name", "comment", "desc", "time", "object", "data", "sn", "nm", "o", "NAME", "ni", "nice"], "errp": ["erlp", "acerP", "derlp", "ferpi", "derP", "err", " errP", "erc", "incp", "ferpa", "ferp", "ferP", " errlp", "derc", "acerr", "errc", "derp", "errpa", "erp", " errc", "incP", "errlp", "errpi", "erpa", "incpi", "acerp", " errr", "errP", "errr", "acerlp", "erpi", "incpa", "erP"]}}
{"project": "FFmpeg", "commit_id": "e549933a270dd2cfc36f2cf9bb6b29acf3dc6d08", "target": 0, "func": "static void avc_luma_mid_8w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3;\n\n    v16u8 out0, out1;\n\n\n\n    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    hz_out0 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n    hz_out1 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n    hz_out3 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n\n\n        hz_out5 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);\n\n        hz_out6 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n        hz_out7 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n        hz_out8 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst1 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst3 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n        out0 = PCKEV_XORI128_UB(dst0, dst1);\n\n        out1 = PCKEV_XORI128_UB(dst2, dst3);\n\n        ST8x4_UB(out0, out1, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out3 = hz_out7;\n\n        hz_out1 = hz_out5;\n\n        hz_out5 = hz_out4;\n\n        hz_out4 = hz_out8;\n\n        hz_out2 = hz_out6;\n\n        hz_out0 = hz_out5;\n\n    }\n\n}\n", "idx": 24368, "substitutes": {"src": ["dist", "rect", "fc", "sr", "sl", "sc", "rib", "rob", "source", "filename", "rs", "lib", "sub", "ctr", "sb", "ssl", "sel", "ctx", "rb", "gn", "cont", "url", "slice", "sur", "stream", "config", "low", "gb", "tmp", "inst", "rc", "comp", "desc", "loc", "sup", "uc", "seq", "sync", "img", "sec", "cb", "sq", "dest", "iv", "sil", "st", "RC", "scl", "bg", "cur"], "src_stride": ["src_Strided", "src_arride", "src_striide", "src_STRides", "src_STRided", "src_arrride", "src_STRride", "src_Strride", "src_strider", "src_arrided", "src_striides", "src_striider", "src_brided", "src_striided", "src_brides", "src_drider", "src_Stride", "src_drided", "src_Strides", "src_striride", "src_dride", "src_strride", "src_STRide", "src_bride", "src_strides", "src_arrider", "src_drides", "src_strided", "src_brride", "src_brider"], "dst": ["bst", "Ddest", "dsts", "sdest", "sst", "bsp", "Dsp", "Dst", "ssts", "bsts", "bdest", "dsp", "Dsts", "ssp", "ddest"], "dst_stride": ["dst_strid", "dst_arrride", "dst_trid", "dst_trride", "dst_tride", "dst_trided", "dst64stride", "dst_arride", "dst_arrided", "dst64strided", "dst_brid", "dst64arrid", "dst_brided", "dst64strride", "dst_bride", "dst64strid", "dst_brride", "dst_strride", "dst_strided", "dst64arrided", "dst64arride", "dst64arrride", "dst_arrid"], "height": ["depth", "index", "top", "dc", "resolution", "id", "shape", "gh", "count", "thin", "hd", "th", "timeout", "dy", "Height", "window", "build", "dim", "h", "y", "gpu", "style", "lvl", "level", "rh", "density", "mac", "buffer", "input", "deep", "block", "high", "padding", "img", "gap", "diff", "data", "bottom", "length"], "loop_cnt": ["loop_CNT", "loop_fnc", "loop_ncnn", "loop_Cnt", "loop_lcount", "loop_Cnn", "loop_fount", "loop_lcnn", "loop_lcNT", "loop_Count", "loop_cNT", "loop_acount", "loop_rcNT", "loop_acnc", "loop_lcnd", "loop_lcnt", "loop_cnn", "loop_rcnc", "loop_lcnc", "loop_acnd", "loop_Cnc", "loop_fnd", "loop_Cnd", "loop_ncnt", "loop_ncNT", "loop_fnt", "loop_rcnt", "loop_ncount", "loop_acnt", "loop_cnd", "loop_acNT", "loop_cnc", "loop_count", "loop_rcnd"], "src0": ["source4", "rc2", "loc1", "rc6", "source1", "loc2", "dist4", "loc0", "rc00", "dest0", "loc3", "loc4", "source0", "src6", "src00", " src6", "img0", "src5", "rc1", "dest4", "dist00", "dest1", "rc3", " src00", "rc0", " src5", "rc4", "loc6", "img1", "rc5", "img2", "img6", "dist1", "dist5", "dist0", "dist2", "source2", "dest2"], "src1": ["img8", "source01", "rc2", "source4", "loc1", " src8", "source1", "sc4", "loc2", "loc0", "rc8", "loc3", "loc4", "sc2", "source0", "sc3", "sc0", "rc1", "loc01", "rc3", "rc0", "rc4", "img01", "src01", "img1", " src01", "img2", "src8", "rc01", "source2", "sc1"], "src2": ["rc2", "loc1", " src8", "loc2", "loc0", "dist3", "rc8", "loc3", "loc4", "src5", "rc1", "dest4", "rc3", "rc0", " src5", "rc4", "dest8", "rc5", "dest3", "src8", "dist5", "dist0", "dist2", "dest2"], "src3": ["source4", "rc2", "loc1", "rc6", "source1", "dist6", "loc03", "loc2", "src03", "source5", "dist3", "loc3", "src6", "source6", " src6", "src5", "rc1", "source03", "rc3", " src5", "rc4", "dist03", "rc5", "dist1", " src03", "source3", "source2", "rc03"], "src4": ["seq4", "source4", "rc2", " src40", "source1", "dist4", "source5", "rc24", "rc40", "src40", "seq14", "src5", "img24", "rc1", "seq24", "src14", "rc3", " src5", "rc4", "seq2", "img4", "rc14", "img1", "rc5", "img2", "dist1", "img14", "dist5", "img40", "dist2", "source3", "src24", "source2"], "mask0": ["Mask0", "pay0", "mask4", "massi", "Mask4", " mask4", "ask90", "mass1", "mark8", "mark2", "aski", "mask50", " mask000", "maski", " mask50", "pay1", " mask90", " maskg", "ask4", "ask000", " maski", " mask8", "mask000", "maskg", "ask50", "black000", "pay000", "ask1", "pay2", "black2", "Mask50", "askg", "mark0", "mask8", "ask0", "black1", "ask2", "Mask1", "mark1", "ask8", "mask90", "mass0", "black0", "blackg", "mass90"], "mask1": ["Mask0", "weight2", "mask4", "Mask4", " mask4", "mark8", "mark2", "weight3", "weight1", "ask4", " mask8", "ask3", "Mask2", "ask1", "weight0", "mark0", "mask8", "ask0", " mask3", "ask2", "Mask1", "mask3", "mark1", "ask8", "mark4", "weight4"], "mask2": ["miss0", "weight2", " maskless", "mask4", "miss3", " mask4", "miss2", "mark2", "ask6", "weight3", "weightless", "miss6", "weight1", "maskless", "ask4", "askless", "mark3", " mask8", "ask3", "miss4", "ask1", "miss8", "mask8", " mask6", "weight6", "ask0", "mask6", "weight8", " mask3", "ask2", "mask3", "mark1", "ask8", "mark4", "weight4"], "hz_out0": ["hz_opt6", "hz_mask1", "hz_opt0", "hz_in2", "hz_in1", "hz_in6", "hz_opt1", "hz_mask4", "hz_mask0", "hz_opt4", "hz_in4", "hz_mask2", "hz_mask6", "hz_in0"], "hz_out1": ["hz_OUT2", "hz_OUT3", "hz_in2", "hz_OUT1", "hz_index2", "hz_in11", "hz_in3", "hz_index1", "hz_out11", "hz_outOne", "hz_Out3", "hz_in1", "hz_Out1", "hz_Out2", "hz_indexOne", "hz_inOne", "hz_index11"], "hz_out2": ["hz_conn2", "hz_in2", "hz_Out4", "hz_conn1", "hz_nin2", "hz_in1", "hz_in6", "hz_nin6", "hz_in8", "hz_Out1", "hz_conn6", "hz_Out2", "hz_nin8", "hz_int2", "hz_Out6", "hz_nin1", "hz_int8", "hz_in4", "hz_conn4", "hz_int1", "hz_int6"], "hz_out3": ["hz_nin0", "hz_out03", "hz_off2", "hz_in2", "hz_in3", "hz_off3", "hz_nin2", "hz_off03", "hz_nin3", "hz_off1", "hz_Out3", "hz_in1", "hz_Out03", "hz_in8", "hz_Out1", "hz_nin8", "hz_Out2", "hz_in03", "hz_off0", "hz_off8", "hz_in0"], "hz_out4": ["hz_again4", "hz_in2", "hz_sum5", "hz_match4", "hz_again5", "hz_loss4", "hz_matchfour", "hz_again7", "hz_again2", "hz_sum4", "hz_in7", "hz_loss7", "hz_outfour", "hz_in4", "hz_loss2", "hz_in5", "hz_infour", "hz_sum2", "hz_sum7", "hz_lossfour", "hz_match7", "hz_match2"], "hz_out5": ["hz_off2", "hz_in2", "hz_inFive", "hz_pass8", "hz_in8", "hz_pass2", "hz_passFive", "hz_outFive", "hz_offFive", "hz_off5", "hz_in5", "hz_off8", "hz_pass5"], "hz_out6": ["hz_inN", "hz_in2", "hz_scan256", "hz_name6", "hz_name2", "hz_in256", "hz_in6", "hz_scan6", "hz_nameN", "hz_name256", "hz_scanN", "hz_outN", "hz_out256", "hz_scan2"], "hz_out7": ["hz_Out9", "hz_out9", "hz_Out87", "hz_out07", "hz_ex9", "hz_Out7", "hz_ex07", "hz_ex7", "hz_ex87", "hz_nin7", "hz_nin87", "hz_Out07", "hz_nin07", "hz_nin9", "hz_out87"], "hz_out8": ["hz_output8", "hz_output4", "hz_again4", "hz_again8", "hz_again6", "hz_again5", "hz_index5", "hz_index6", "hz_output6", "hz_index4", "hz_output5", "hz_index8"], "dst0": ["dsc2", "dsta3", "sst0", "ssc3", "dsta0", "dsta1", "ssc2", "dest0", "dsc3", "dsc1", "ssc1", "sst2", "sst1", "dest1", "ssc0", "dsc0", "dest3", "dsta2", "dest2", "sst3"], "dst1": ["dost4", "dost1", "dost2", " dest0", "dest0", "dost0", "dsp4", " dest4", " dest2", "dst4", " dst4", "dest4", "dsp2", "dest1", "dsp0", " dest1", "dsp1", "dest2"], "dst2": ["adrc4", "dsc2", "dest0", "adrc0", "drc4", "drc0", "dsc1", "adst0", "adrc2", "drc1", "dst4", "adst2", "dest4", "adrc1", "dest1", "adst4", "drc2", "dsc0", "dsc4", "dest2", "adst1"], "dst3": ["drc6", "frc1", "dsc3", "dstage6", "dsc1", "dstage5", "fst3", "frc3", "fst5", "drc1", "dsc6", "dstage1", "dstage3", "dst5", "frc6", "dst6", "drc5", "fst6", "drc3", "dsc5", "frc5", "fst1"], "out0": [" out2", "in0", "Out1", "in2", "Out0", "in1", "Out2", "out2"], "out1": ["Out4", " out2", "OUT2", "OutOne", "OUTOne", "outOne", "Out1", "OUT4", "OUT1", " out4", " outOne", "Out2", "out4", "out2"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int pam_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 24371, "substitutes": {"avctx": ["aversync", "AVctrl", "avalcf", "avcf", " avsync", "avalctx", "afctx", " avconfig", "avsync", "avcontext", "averctx", "afsync", "averconfig", "AVcontext", "avercontext", "avctrl", "AVcf", " avcontext", "afcf", "afctrl", "avconfig", "avalctrl", "avalcontext", "afcontext", "afconfig", "AVctx"]}}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)\n\n{\n\n    OggVorbisContext *context = avccontext->priv_data;\n\n    double cfreq;\n\n\n\n    if (avccontext->flags & CODEC_FLAG_QSCALE) {\n\n        /* variable bitrate */\n\n        if (vorbis_encode_setup_vbr(vi, avccontext->channels,\n\n                                    avccontext->sample_rate,\n\n                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))\n\n            return -1;\n\n    } else {\n\n        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;\n\n        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;\n\n\n\n        /* constant bitrate */\n\n        if (vorbis_encode_setup_managed(vi, avccontext->channels,\n\n                                        avccontext->sample_rate, minrate,\n\n                                        avccontext->bit_rate, maxrate))\n\n            return -1;\n\n\n\n        /* variable bitrate by estimate, disable slow rate management */\n\n        if (minrate == -1 && maxrate == -1)\n\n            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))\n\n                return -1;\n\n    }\n\n\n\n    /* cutoff frequency */\n\n    if (avccontext->cutoff > 0) {\n\n        cfreq = avccontext->cutoff / 1000.0;\n\n        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))\n\n            return -1;\n\n    }\n\n\n\n    if (context->iblock) {\n\n        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);\n\n    }\n\n\n\n    return vorbis_encode_setup_init(vi);\n\n}\n", "idx": 24375, "substitutes": {"vi": ["ai", "li", "pi", "vm", "ji", "liv", "voc", "vt", "avi", "vid", "isi", "medi", "vim", "bi", "ku", "v", "ati", "fi", "audi", "xi", "ini", "ili", "vision", "vc", "qi", "oci", "iti", "zi", "di", "ski", "rc", "ii", "edi", "si", "ani", "eni", "i", "ami", "iri", "adi", "cli", "ori", "ui", "ci", "iv", "ni", "umi", "ri", "VI", "ki", "mi"], "avccontext": ["avccontex", "avnconcontract", "avdcontext", "avcconytext", "avccaconct", "avbconacil", "avdcortext", "avcchenct", "avnconct", "avaccoptex", "avcconconfig", "avcconaversion", "avcenvert", "avcconyst", "avccondversion", "avcONtext", "avccaomptext", "avccaconcontract", "avccoconect", "avccointext", "avbconastruct", "avscontext", "avnconcontext", "avaccontext", "avctontext", "avccONtext", "avecONect", "avrcopycontract", "avcONnect", "avccanonstruct", "avaccoptext", "avcconste", "avccaconvert", "avccompst", "avcconenter", "avcconct", "avdcorobject", "avcconect", "avcconscontext", "avcconestruct", "avcconcontract", "avccaompstruct", "avccanonvert", "avdconcil", "avcontex", "avacconconnection", "avccondtext", "avccopystruct", "avccopTEXT", "avcconerect", "avccoconvert", "avcconertext", "avccortext", "avccondct", "avecONterm", "avcconsnect", "avccompstruct", "avcconastruct", "avccONnect", "avcchencontext", "avbconner", "avsconsvert", "avsconvert", "avccoconstruct", "avecontext", "avccoinct", "avbconaner", "avcONtex", "avccondstr", "avccONconnection", "avccopytext", "avbconcil", "avcconttext", "avcONvert", "avccolontext", "aveconect", "avctonvert", "avccopynect", "avcconstruct", "avccompversion", "avcconter", "avccarontext", "avecONconfig", "avcconsst", "avccorobject", "avccaconect", "avccondconnection", "avccynvert", "avcconenvert", "avccONterm", "avcenpath", "avccONner", "avdcorcil", "avcconpath", "avccynect", "avcconentext", "avccaonstruct", "avecONtext", "avcONect", "avacconvert", "avccoconner", "avncacontext", "avctanonte", "avccyncontract", "avccacontext", "avconvert", "avccaompversion", "avcconerterm", "avcconystatic", "avcONstruct", "avctanontext", "avccanonTEXT", "avccONter", "avccomptext", "avcconscontract", "avccontTEXT", "avccynterm", "avcconstatic", "avaccondconnection", "avconpath", "avncaconcontext", "avccONvert", "avcconner", "avccONect", "avccONTEXT", "avccanonnect", "avcconevert", "avaccondtext", "avcentext", "avcconenstruct", "avsconsstatic", "avccoptext", "avcONTEXT", "avccanonte", "avbeconastr", "avdcorstruct", "avbeconct", "avbcontext", "avcenstruct", "avccONstruct", "avbconstruct", "avcconnect", "avsconsst", "avccenTEXT", "avncaconcontract", "avrcopynect", "avccopyconnection", "avsconst", "avrconcontract", "avconect", "avcconacil", "avccynst", "avccolonvert", "avccONcil", "avccopvert", "avbeconstr", "avncontext", "avccopyst", "avdconstruct", "avcconTEXT", "avcconvert", "avcconcil", "avcconente", "avrconnect", "avccynconnection", "avcconact", "avccocontext", "avccaronstruct", "avccynnect", "avcconstext", "avacconstruct", "avconnect", "avccaonversion", "avcconte", "avccentext", "avccaconcontext", "avconTEXT", "avcconttex", "avcconterm", "avccaconstruct", "avccetcontract", "avccolonstruct", "avccorcil", "avsconstatic", "avctanonvert", "avccoretex", "avcconsstatic", "avccaroncil", "avcchentext", "avccynstatic", "avrcopyconnection", "avbeconaversion", "avccolonpath", "avccyntext", "avcconetext", "avbecontext", "avctonnect", "avaccondstruct", "avccONconfig", "avcconcontext", "avccONobject", "avccoptex", "avccentex", "avccorestruct", "avaccopvert", "avconstruct", "avccorenect", "avaccondter", "avbconatext", "avcconennect", "avccONtex", "avccorstruct", "avcconepath", "avccaontext", "avccONversion", "avccondstruct", "avncaconct", "avccetconnection", "avaccopTEXT", "avacconter", "avccoinstr", "avcconenconnection", "avccoretext", "avcconerconfig", "avdconobject", "avbeconversion", "avcconaner", "avsconstext", "avcontext", "avccaompst", "avcchencontract", "avrcontext", "avccaonst", "avctonte", "avccynconfig", "avbeconatext", "avcconatext", "avccontvert", "aveconterm", "avccanontext", "avccenstruct", "avccondter", "avrconconnection", "avrcopytext", "avcconsvert", "avccopycontract", "avccenvert", "avccopyversion", "avcconversion", "avccettext", "avcconst", "avccetnect", "avacconTEXT", "avaccontex", "avcconastr", "avcconstr", "avccoconcil", "avcconyvert", "avccoinversion", "avctanonnect", "avbeconact", "avccONst", "avcconsct", "avcconobject", "aveconconfig", "avccaronobject", "avcconconnection", "avcconsstruct", "avcconstex", "avccenpath"], "context": ["engine", "general", "path", "parent", "filter", "driver", "kernel", "project", "anc", "source", "environment", "text", "connection", "interface", "ctx", "private", "current", "function", "info", "mc", "cache", "contact", "result", "reader", "command", "resource", "slice", "Context", "stream", "config", "cel", "package", "buffer", "definition", "input", "tx", "center", "public", "cca", "loc", "component", "object", "document", "data", "event", "qa", "concept", "temp", "support"], "cfreq": ["casrequest", "casneed", "afneed", "CFrt", " cfload", "casreq", "CFneed", "ctrequ", "CFrequ", "cfneed", " covreq", "CFrequest", "cfrequ", " covrequ", " coverr", " cfrequ", "CFerr", "ctreq", "afrt", "CFreq", " cferr", "afrequ", "CFload", "afrequest", "ctrt", "cferr", "cfrt", "ctrequest", "cfrequest", " covload", "afreq", "casrequ", "cfload"]}}
{"project": "FFmpeg", "commit_id": "439c3d5bcc4a4560eaf5fd43c6e156e3d9bc42f2", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                        const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    NellyMoserEncodeContext *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n\n\n    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));\n\n    if (frame) {\n\n        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],\n\n               frame->nb_samples * sizeof(*s->buf));\n\n        if (frame->nb_samples < NELLY_SAMPLES) {\n\n            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,\n\n                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));\n\n            if (frame->nb_samples >= NELLY_BUF_LEN)\n\n                s->last_frame = 1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))\n\n            return ret;\n\n    } else {\n\n        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));\n\n        s->last_frame = 1;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n    encode_block(s, avpkt->data, avpkt->size);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 24400, "substitutes": {"avctx": ["afcm", "afcmd", "awcontext", " avkb", " avcmp", "ufctx", "apcmp", "afctx", " avconfig", " avcmd", "avcn", "afkb", " avcm", "ufctl", "ufcm", "avcm", "afcmp", "avcontext", "ufcontext", "afcn", "apconfig", "AVcn", "awctx", "AVctl", " avctl", "AVcontext", "avkb", "avcmd", "afctl", " avcn", "apcontext", " avcontext", "ufconfig", "avctl", "awkb", "AVconfig", "avconfig", "apctx", "avcmp", "ufcmd", "afcontext", "awctl", "afconfig", "AVctx"], "avpkt": ["AVPkt", "avcelt", "avcpkt", "avfnt", "avfacket", "affnt", "AVpke", "avfet", "avfck", "avppqt", "afcck", "avfut", "appacket", "avpacket", "avppke", "afcacket", "avPetsk", "avnacket", "afpnt", "afpdt", "avcpnt", "affft", "avPqt", "apcelt", "avckt", "avvpacket", "avcck", "afpqt", "avpdt", "avjpacket", "avcqt", "avcput", "avPet", "avvpkt", "abfetsk", "avnpetsk", "AVpqt", "AVpkt", "avppkt", "afpft", "affacket", "affkt", "avcft", "AVPacket", "affut", "abpet", "avpreelt", "avpnt", "AVPqt", "avcpacket", "afput", "avfkt", "abfet", "avnpkt", "apckt", "appelt", "afckt", "avcacket", "avcdt", "abpetsk", "affdt", "avprekt", "AVPke", "avpelt", "avfqt", "avpft", "avpke", "avfdt", "avnelt", "abpacket", "afpck", "avPacket", "afpkt", "avpreqt", "avjpdt", "avpet", "avfft", "avpqt", "avjpkt", "apcacket", "apcdt", "avnpet", "avcpke", "avpreacket", "avcpqt", "avpreck", "avvput", "avpetsk", "abfkt", "avjpft", "avPkt", "abpkt", "avPke", "appkt", "afcqt", "avpck", "avnkt", "afpacket", "avndt", "AVpacket", "avnpacket", "abfacket", "avvpnt", "avppacket", "appdt", "avpredt", "avfetsk", "avput"], "frame": ["state", "j", "body", "dy", "rame", "none", "zip", "header", "za", "function", "window", "game", "image", "flow", "feature", "position", "update", "session", "fake", "series", "up", "sequence", "close", "request", "fi", "iframe", "slice", "part", "style", "cf", "ce", "range", "motion", "code", "fr", "m", "line", "ze", "callback", "buffer", "el", "feat", "scale", "Frame", "setup", "time", "e", "block", "node", "seq", "element", "sample", "f", "file", "module", "cb", "frames", "object", "data", "document", "call", "event", "layer", "pse", "fe", "se", "video", "fram", "fb"], "got_packet_ptr": ["got_packacket_addr", "got_packet_str", "got_packacket_pointer", "got_packacket_ptr", "got_packet_addr", "got_packacket_str", "got_packacket_tr", "got_packet2ptr", "got_packet_pointer", "got_packet2addr", "got_packet2str", "got_packet_tr", "got_packet2pointer"], "s": ["js", "b", "sc", "S", "rs", "ssl", "sb", "fs", "g", "states", "h", "p", "args", "u", "ms", "k", "si", "sup", "sync", "xs", "sq", "parts", "a", "as", "n", "qs", "conf", "gs", "aws", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "stat", "o", "site", "its", "your", "vs", "j", "self", "full", "session", "ts", "is", "y", "sk", "m", "sym", "w", "side", "sg", "f", "ds", "ses", "sys", "bis", "http", "os", "ctx", "r", "ps", "ins", "ns", "an", "d", "ls", "services", "us", "se"], "ret": ["reset", "last", "num", "run", "ut", "error", "reply", "bc", "mt", "value", "RET", "id", "valid", "let", "len", "red", "r", "nt", " RET", "fin", "gt", "info", "result", "alt", "resp", "mem", "det", "no", "ref", "part", "rets", "code", "bad", "ft", "match", "cur", "def", "rc", "fun", "obj", "att", "db", "feat", "arg", "rt", "usr", " Ret", "bot", "lit", "rep", "val", "cat", "back", "Ret", "reg", "res", "flag", "pat", "bit", "en", "success", "re", "fit"]}}
{"project": "FFmpeg", "commit_id": "7167bc94cb695a3027aea6aac34a1b040848c7dc", "target": 1, "func": "static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n\n{\n\n    IndividualChannelStream *ics = &sce->ics;\n\n    float *in    = sce->coeffs;\n\n    float *out   = sce->ret;\n\n    float *saved = sce->saved;\n\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    float *buf  = ac->buf_mdct;\n\n    float *temp = ac->temp;\n\n    int i;\n\n\n\n    // imdct\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)\n\n            av_log(ac->avctx, AV_LOG_WARNING,\n\n                   \"Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. \"\n\n                   \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\");\n\n        for (i = 0; i < 1024; i += 128)\n\n            ff_imdct_half(&ac->mdct_small, buf + i, in + i);\n\n    } else\n\n        ff_imdct_half(&ac->mdct, buf, in);\n\n\n\n    /* window overlapping\n\n     * NOTE: To simplify the overlapping code, all 'meaningless' short to long\n\n     * and long to short transitions are considered to be short to short\n\n     * transitions. This leaves just two cases (long to long and short to short)\n\n     * with a little special sauce for EIGHT_SHORT_SEQUENCE.\n\n     */\n\n    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&\n\n            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {\n\n        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n\n    } else {\n\n        for (i = 0; i < 448; i++)\n\n            out[i] = saved[i] + bias;\n\n\n\n        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n\n        } else {\n\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n\n            for (i = 576; i < 1024; i++)\n\n                out[i] = buf[i-512] + bias;\n\n        }\n\n    }\n\n\n\n    // buffer update\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        for (i = 0; i < 64; i++)\n\n            saved[i] = temp[64 + i] - bias;\n\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else { // LONG_STOP or ONLY_LONG\n\n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n\n    }\n\n}\n", "idx": 24424, "substitutes": {"ac": ["mic", "dc", "pac", "AC", "bc", "ca", "anc", "http", "cc", "ace", "aic", "ack", "ax", "aut", "Ac", "rac", "cus", "arc", "mc", "gc", "fac", "auc", "acc", "enc", "roc", "cam", "jac", "oc", "vc", "con", "cs", "ic", "iac", "act", "tc", "acs", "mac", "sac", "acl", "k", "uc", "c", "pc", "ec", "am", "ad", "as"], "sce": ["sne", " sne", "Scle", " sces", " sface", "scel", "sque", "Sse", "sces", "openske", "pscel", "dscel", "psce", "dsce", "Sque", "sface", "Ske", "SCE", "openscel", "psCE", "sse", "opensface", "sCE", " sse", " sCE", "scle", " scel", "Sne", " scle", "Sces", "dsCE", "ske", " sque", "pske", "dske", " ske", "opensce", "Sce"], "bias": ["bius", "Bake", " unbias", " unbius", "fait", "fias", "base", " bax", "lbax", "lax", " bius", "bases", "bax", "lias", "fake", "lai", "lbai", " bake", "Base", " unbase", "lbias", " bai", "bai", " bases", "Bias", "Bius", "fius", "Bases", "bake", " bait", " base", " unbases", "Bait", "bait"], "ics": ["isc", "IC", "ents", "bc", "voc", "ico", "rs", "fs", "fps", "cache", "nic", "ic", "ik", "args", "sync", "acks", "cons", "xs", "ris", "uses", "xml", "icks", "qs", "bits", "cms", "ks", "cs", "iac", "wcs", "ats", "pc", "spec", "pic", "stats", "tis", "its", "fc", "css", "self", "aic", "nas", "facts", "rates", "inas", "ix", "ts", "osi", "cats", "icc", "ras", "config", "wic", "s", "ex", "exec", "ICS", "ec", "abc", "icons", "sys", "ips", "mic", "http", "fits", "ctx", "cus", "mc", "bs", "atts", "ins", "oc", "act", "iss", "acs", "ums", "ns", "inc", "ig", "ls", "iris", "ants"], "in": ["orig", "index", "x", "isin", "rec", "nin", "n", "win", "source", "inn", "bits", "pin", "gin", "In", "image", "IN", "new", "slice", "ini", "con", "ins", "inner", "config", "pass", "ints", "again", "into", "init", "input", "buffer", "uc", "inc", "c", "vin", "img", "ul", "f", "str", "data", "login", "ci", "qa", "min", "a", "bin"], "out": ["parent", "sum", "ret", "child", "outs", "err", "source", "window", "op", "Out", "image", "cache", "result", "new", "work", "io", "wx", "OUT", "pool", "inner", "config", "batch", "pass", "again", "cmd", "obj", "ex", "prefix", "init", "input", "buffer", "arg", "exec", "inc", "fn", "sync", "extra", "output", "copy", "buff", "str", "data", "call", "val", "o", "client", "bit", "bin", "at", "ext"], "saved": ["psaving", "Saving", "setsave", "unsaged", "served", "psave", "save", "unsave", " save", "setsaved", " sitched", "Saved", "psaved", "paving", "setsaving", "sitched", "saving", " saves", "paved", "Saves", "setsaged", " saving", "setsitched", "Sitched", " saged", "unsaves", "setsaves", "Sorted", "perved", "sorted", "saves", "Served", "setsorted", " sorted", "Save", "unsaved", "unsaving", "saged", "pserved", "psaves", "pave"], "swindow": ["swinnows", "Swindow", "swINDowed", "swillow", "swillo", "swillowed", "swinno", "swinnow", "swinnowed", "swINDo", "swindows", "swindo", "swINDow", "Swindo", "SwINDo", "SwINDow", "swINDows", "SwINDows", "swillows", "Swindows", "SwINDowed", "Swindowed", "swindowed"], "lwindow_prev": ["lwindows_cur", "lwindow1upper", "lview_prev", "lwindow1orig", "lwindows_last", "lwindow_pre", "lwindow_cur", "lview_upper", "lwindow_upper", "lwindows_pre", "lwindow1prev", "lwindow_first", "lview_first", "lview_orig", "lwindow_last", "lwindow1first", "lwindows_prev", "lwindow_orig"], "swindow_prev": ["swindOW_prev", "swindOW_last", "swindOW_pre", "swindow_orig", "swindow_last", "swindow_pre", "swindOW_orig"], "buf": ["b", "num", "port", "fw", "box", "home", "bc", "vec", "margin", "text", "gin", "ctx", "fd", "window", "rb", "cache", "bn", "wb", "cv", "result", "br", "cas", "auc", "fi", "fp", "cf", "pool", "batch", "queue", "tmp", "conv", "cur", "prefix", "rc", "buffer", "input", "block", "bag", "uc", "seq", "output", "xff", "cb", "img", "aux", "data", "uf", "bus", "ru", "ff", "fb", "buff"], "temp": ["num", "weight", "win", "keep", "wave", "margin", "timeout", "ctr", "wa", "current", "ptr", "window", "cache", "wrap", "alt", "cv", "iter", "tem", "tr", "frac", "tmp", "tc", "conv", "prefix", "table", "w", "local", "buffer", "input", "clean", "flat", "txt", "c", "pt", "stable", "Temp", "output", "dest", "opt", "buff"], "i": ["b", "isin", "li", "child", "id", "iu", "ti", "mu", "ini", "inner", "p", "I", "u", "k", "si", "eni", "ami", "adi", "phi", "ci", "ni", "ji", "a", "mi", "x", "num", "oi", "n", "key", "info", "hi", "gi", "l", "qi", "zi", "ii", "e", "c", "uli", "start", "cli", "ui", "o", "ri", "index", "z", "iw", "j", "ix", "iter", "y", "fi", "slice", "uri", "di", "my", "f", "ki", "ai", "mini", "pi", "yi", "ip", "axis", "bi", "v", "io", "xi", "multi", "chi", "it", "init", "d"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->avg_pixels_tab[0][0] = avg_pixels16_axp;\n\n    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;\n\n    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;\n\n    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;\n\n    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->put_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_pixels_tab[1][1] = put_pixels_x2_axp;\n\n    c->put_pixels_tab[1][2] = put_pixels_y2_axp;\n\n    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;\n\n\n\n    c->avg_pixels_tab[1][0] = avg_pixels_axp;\n\n    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;\n\n    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;\n\n    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;\n\n    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;\n\n\n\n    c->clear_blocks = clear_blocks_axp;\n\n    }\n\n\n\n    /* amask clears all bits that correspond to present features.  */\n\n    if (amask(AMASK_MVI) == 0) {\n\n        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;\n\n        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;\n\n\n\n        if (!high_bit_depth)\n\n            c->get_pixels   = get_pixels_mvi;\n\n        c->diff_pixels      = diff_pixels_mvi;\n\n        c->sad[0]           = pix_abs16x16_mvi_asm;\n\n        c->sad[1]           = pix_abs8x8_mvi;\n\n        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;\n\n        c->pix_abs[1][0]    = pix_abs8x8_mvi;\n\n        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;\n\n        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;\n\n        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;\n\n    }\n\n\n\n    put_pixels_clamped_axp_p = c->put_pixels_clamped;\n\n    add_pixels_clamped_axp_p = c->add_pixels_clamped;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {\n\n        c->idct_put = ff_simple_idct_put_axp;\n\n        c->idct_add = ff_simple_idct_add_axp;\n\n        c->idct =     ff_simple_idct_axp;\n\n    }\n\n}\n", "idx": 24426, "substitutes": {"c": ["context", "fc", "dc", "n", "ch", "xc", "sc", "conf", "bc", "ca", "nc", "ac", "cc", "cp", "cy", "ctx", "r", "arc", "mc", "gc", "cache", "g", "l", "conn", "ce", "cf", "con", "icc", "config", "oc", "vc", "p", "cl", "cs", "ic", "tc", "s", "t", "cr", "cit", "u", "C", "rc", "cm", "ctrl", "ct", "k", "this", "e", "uc", "d", "ec", "pc", "lc", "f", "q", "co", "cu", "ci", "cur"], "avctx": ["afca", "avecontext", "AVca", "abcontext", "afctx", "Avcontext", "avesci", "afcmp", "avcontext", "Avsci", "avca", "AVcmp", "AVctl", "abcmp", "AVcontext", "AVsci", "avsci", "abctx", "Avctx", "abca", "Avctl", "avctl", "avectl", "avectx", "avcmp", "afcontext", "AVctx"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "static char *check_nan_suffix(char *s)\n\n{\n\n    char *start = s;\n\n\n\n    if (*s++ != '(')\n\n        return start;\n\n\n\n    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\n           (*s >= '0' && *s <= '9') ||  *s == '_')\n\n        s++;\n\n\n\n    return *s == ')' ? s + 1 : start;\n\n}\n", "idx": 24433, "substitutes": {"s": ["js", "b", "blocks", "S", "rs", "sb", "g", "states", "h", "hs", "p", "times", "args", "u", "sets", "ms", "si", "parts", "a", "as", "x", "span", "seconds", "n", "gs", "space", "sid", "sound", "es", "l", "ims", "has", "strings", "cs", "t", "ats", "e", "c", "ss", "o", "its", "ops", "sp", "ix", "ans", "ts", "sy", "is", "y", "m", "sym", "w", "side", "f", "ds", "ses", "sl", "sv", "source", "os", "r", "ps", "v", "ins", "south", "ns", "an", "d", "i", "ls", "se", "us", "steps"], "start": ["index", "x", "span", "in", "n", "set", "started", "error", "id", "source", "stop", "shift", "space", "end", "Start", "none", "starting", "sp", "r", "type", "new", "v", "star", "y", "part", "skip", "p", "init", "first", "scale", "k", " Start", "si", "e", "c", "ind", "i", "d", "ss", "from", "next", "data", "str", "pos", "use", "st", "name", "step", "offset"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\n\n    long i;\n\n#if !HAVE_FAST_UNALIGNED\n\n    if((long)src2 & (sizeof(long)-1)){\n\n        for(i=0; i+7<w; i+=8){\n\n            dst[i+0] = src1[i+0]-src2[i+0];\n\n            dst[i+1] = src1[i+1]-src2[i+1];\n\n            dst[i+2] = src1[i+2]-src2[i+2];\n\n            dst[i+3] = src1[i+3]-src2[i+3];\n\n            dst[i+4] = src1[i+4]-src2[i+4];\n\n            dst[i+5] = src1[i+5]-src2[i+5];\n\n            dst[i+6] = src1[i+6]-src2[i+6];\n\n            dst[i+7] = src1[i+7]-src2[i+7];\n\n        }\n\n    }else\n\n#endif\n\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n\n        long a = *(long*)(src1+i);\n\n        long b = *(long*)(src2+i);\n\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n\n    }\n\n    for(; i<w; i++)\n\n        dst[i+0] = src1[i+0]-src2[i+0];\n\n}\n", "idx": 24472, "substitutes": {"dst": [" dast", "fost", "psp", "didstep", "dsc", "ldste", "ddconst", "dsp", "dput", "drest", "ldost", " dste", "adste", "odput", "sdost", "fest", " dest", "fdst", "adast", "Dsts", "hdsc", "dsdest", "dsst", "hdsts", "cdsc", "odst", "past", "fput", " drest", "dsput", "didst", "adst", "sdest", "dconst", "hdst", "dost", "Dst", "ldest", "cdsts", "dST", "dssts", "fst", "fdput", " dput", "cdst", "didsc", "ddsts", "cdest", "psts", "ddsc", "dste", " dconst", "sST", "fdost", "Dost", "dset", "cdost", "ldsts", "fdsts", " ddest", "adost", "ddset", "ldst", "nset", " dsts", "dstep", "ddrest", "hdrest", " dset", "Dsc", "ssts", "odsts", " dost", "nconst", " dsc", "sst", "sdst", "dsost", " dST", "ddest", " dsp", "pst", "dsts", "sdsts", "nsts", "ddst", "fsts", "adsp", "dast", "dsST", "odost", "Dstep", "didost", "nst", "adsts", "dest", " dstep"], "src1": ["source01", "rc2", "rc11", "loc1", "source1", "loc2", "srcStart", "inst1", "src11", " src11", "inst01", "locOne", "destOne", "inst3", "rcone", "sourceOne", "support2", "rc1", "dest01", "dest1", "rc3", " srcOne", "srcOne", "inst2", "instone", "src01", "rcOne", "source11", "rcStart", "support1", " src01", "srcone", "dest3", "supportOne", " srcStart", "src3", "rc01", "supportStart", " srcone", "source3", "source2", " src3", "dest2"], "src2": ["loc0", "source5", "srcTwo", "srctwo", "rc62", "source42", "src0", "obl1", "struct5", "structTwo", "dest1", " src5", "rc4", "obltwo", "rcTwo", "src8", "dest62", "struct1", "rc2", "rctwo", "obl2", " src4", "oblsecond", "source62", "st2", " src02", "src5", "rc0", "stsecond", "sc5", "source2", "sttwo", "obl2015", "src62", "destTwo", "src4", "struct2", "src42", "rc2015", "rc8", " srctwo", "srcsecond", "source02", "sc8", "supTwo", "img0", "src02", "rc1", "struct42", "sourceTwo", "source8", "config1", "config5", "img1", "rc5", "img2", "obl62", "dest2", "source4", "sup1", "imgtwo", "source1", "src2015", "loc2", "dest0", "source2015", "rcsecond", "locTwo", "loc4", "sup2", "sc2", "config0", " srcTwo", " src0", "config2", "rc02", "rc42", "st1", "sup0", "sc1"], "w": ["x", "fw", "weight", "n", "wp", "win", "aw", "wt", "z", "ow", "wave", "end", "ew", "hw", "W", "wa", "window", "r", "ww", "g", "wei", "wb", "max", "l", "kw", "v", "h", "wx", "y", "wal", "p", "m", " W", "t", "u", "we", "k", "nw", "c", "wh", "d", "f", "q", "tw", "sw", "o"], "i": ["b", "isin", "li", "in", "ie", "id", "iu", "g", "ti", "mu", "ini", "inner", "p", "ic", "I", "u", "k", "si", "ami", "phi", "ci", "ni", "name", "a", "mi", "x", "oi", "n", "key", "the", "info", "hi", "gi", "l", "qi", "zi", "ii", "e", "c", "uli", "start", "cli", "api", "ui", "o", "ri", "at", "index", "site", "z", "j", "anti", "isi", "ix", "iter", "is", "y", "fi", "slice", "uri", "m", "di", "s", "my", "f", "iv", "ki", "ai", "mini", "pi", "idi", "yi", "ip", "image", "bi", "v", "io", "xi", "multi", "chi", "it", "init", "d", "us"]}}
{"project": "FFmpeg", "commit_id": "cb85779d459c6486acbbf060b3f169779424583e", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    DPXContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr[AV_NUM_DATA_POINTERS];\n\n\n\n    unsigned int offset;\n\n    int magic_num, endian;\n\n    int x, y, i, ret;\n\n    int w, h, bits_per_color, descriptor, elements, packing, total_size;\n\n\n\n    unsigned int rgbBuffer = 0;\n\n    int n_datum = 0;\n\n\n\n    if (avpkt->size <= 1634) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small for DPX header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_num = AV_RB32(buf);\n\n    buf += 4;\n\n\n\n    /* Check if the files \"magic number\" is \"SDPX\" which means it uses\n\n     * big-endian or XPDS which is for little-endian files */\n\n    if (magic_num == AV_RL32(\"SDPX\")) {\n\n        endian = 0;\n\n    } else if (magic_num == AV_RB32(\"SDPX\")) {\n\n        endian = 1;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"DPX marker not found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    offset = read32(&buf, endian);\n\n    if (avpkt->size <= offset) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid data start offset\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    // Need to end in 0x304 offset from start of file\n\n    buf = avpkt->data + 0x304;\n\n    w = read32(&buf, endian);\n\n    h = read32(&buf, endian);\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    // Need to end in 0x320 to read the descriptor\n\n    buf += 20;\n\n    descriptor = buf[0];\n\n\n\n    // Need to end in 0x323 to read the bits per color\n\n    buf += 3;\n\n    avctx->bits_per_raw_sample =\n\n    bits_per_color = buf[0];\n\n    buf++;\n\n    packing = *((uint16_t*)buf);\n\n\n\n    buf += 824;\n\n    avctx->sample_aspect_ratio.num = read32(&buf, endian);\n\n    avctx->sample_aspect_ratio.den = read32(&buf, endian);\n\n    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)\n\n        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,\n\n                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,\n\n                  0x10000);\n\n    else\n\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n\n\n    switch (descriptor) {\n\n        case 51: // RGBA\n\n            elements = 4;\n\n            break;\n\n        case 50: // RGB\n\n            elements = 3;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported descriptor %d\\n\", descriptor);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (bits_per_color) {\n\n        case 8:\n\n            if (elements == 4) {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            }\n\n            total_size = avctx->width * avctx->height * elements;\n\n            break;\n\n        case 10:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 32bit required\\n\");\n\n                return -1;\n\n            }\n\n            avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n\n            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;\n\n            break;\n\n        case 12:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 16bit required\\n\");\n\n                return -1;\n\n            }\n\n            if (endian) {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        case 16:\n\n            if (endian) {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;\n\n            } else {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported color depth : %d\\n\", bits_per_color);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n    if ((ret = ff_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    // Move pointer to offset from start of file\n\n    buf =  avpkt->data + offset;\n\n\n\n    for (i=0; i<AV_NUM_DATA_POINTERS; i++)\n\n        ptr[i] = p->data[i];\n\n\n\n    if (total_size > avpkt->size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Overread buffer. Invalid header?\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (bits_per_color) {\n\n    case 10:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[0]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[1]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                // For 10 bit, ignore alpha\n\n                if (elements == 4)\n\n                    read10in32(&buf, &rgbBuffer,\n\n                               &n_datum, endian);\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 12:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2] = *((uint16_t*)buf);\n\n                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);\n\n                dst[2]++;\n\n                buf += 2;\n\n                *dst[0] = *((uint16_t*)buf);\n\n                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);\n\n                dst[0]++;\n\n                buf += 2;\n\n                *dst[1] = *((uint16_t*)buf);\n\n                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);\n\n                dst[1]++;\n\n                buf += 2;\n\n                // For 12 bit, ignore alpha\n\n                if (elements == 4)\n\n                    buf += 2;\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 16:\n\n        elements *= 2;\n\n    case 8:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            memcpy(ptr[0], buf, elements*avctx->width);\n\n            ptr[0] += p->linesize[0];\n\n            buf += elements*avctx->width;\n\n        }\n\n        break;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 24478, "substitutes": {"avctx": ["avcb", "akcontext", "ajctrl", "afcb", "afpkg", "ajpkg", "afcu", "ajcca", "navcv", "afcoll", "alctx", "avalcms", "avecms", "avpkg", "avsci", " avconn", "aveconn", "apcontext", " avsci", " avcontext", "vercb", "afctrl", "avectx", "apctx", "avalcontext", "afcontext", "avefw", " avloc", "avecontext", "akconn", "afloc", "avalctx", "avecv", "avesci", "AVfw", "afkb", "ajcontext", "afsci", "afcca", "ajcms", "apcu", "avesync", "avecca", "verconn", "navsync", "AVconn", "afconfig", "verctx", "avepkg", "avfw", "alcontext", "aveconfig", "avekb", "avcu", "avcv", "avectrl", "afctx", "avecmp", "afconn", "avconn", "avalobj", "avsync", "akctx", "afsync", "avcms", "AVcontext", "avctrl", "affw", "alconn", "avcoll", "alcb", "avcmp", "afcms", "avconfig", "ajctx", "avecoll", "navctx", "aveobj", "avalcmp", "vercontext", "apcms", "avobj", " avconfig", "avalcu", "afcv", "afcmp", "avcontext", "avcca", "navcontext", "avkb", "akloc", "afobj", "avloc", "ajkb", "ajcoll", "AVctx"], "data": ["context", "database", "a", "parent", "da", "base", "value", "mode", "id", "message", "connection", "body", "bytes", "response", "DATA", "header", "window", "image", "cache", "size", "result", "open", "reader", "command", "original", "name", "config", "frame", "batch", "queue", "code", "read", "package", "Data", "channel", "buffer", "input", "device", "feed", "sample", "media", "doc", "pad", "d", "start", "padding", "length", "download", "next", "content", "meta", "pos", "client", "memory", "dat", "video"], "got_frame": ["num_trace", "numgchannel", "numgtime", "numacframe", "numgtrace", "get_channel", "numactrace", "get_trace", "numacchannel", "numactime", "num_time", "get_time", "numgframe", "num_frame", "get_frame", "num_channel"], "avpkt": ["AVPkt", "avcpft", "avcpkt", "avPct", "avfacket", "AVpke", "AVPpt", "avpbct", "avpacket", "abcacket", "avPcf", "avpbke", "affct", "afpdt", "avcpct", "aveput", "AVPcf", "avckt", "AVPct", "avpdt", "avjpct", "avgft", "avjpacket", "avpcf", "avgkn", "AVpkt", "avopct", "avpeke", "avepkn", "affacket", "AVpft", "affkt", "avcft", "AVPacket", "avpkat", "avgkat", "avegut", "avfkt", "avfct", "avparkat", "AVpcf", "avcacket", "avperkat", "avpct", "avcdt", "affdt", "avopdt", "avpkn", "avpett", "avbpft", "AVPke", "AVpct", "avperkt", "AVPft", "avcpett", "avbpct", "abpct", "avperkn", "avgct", "avpekt", "avpft", "avpke", "avpbpt", "avperut", "avfdt", "avbpett", "AVPett", "abpacket", "abpft", "avepkat", "abcct", "avPacket", "avegkat", "afpkt", "avbpkt", "avparut", "avgacket", "avgkt", "avfft", "avPpt", "AVppt", "abcft", "avjpkt", "avopkt", "afpct", "AVpett", "avPft", "avppt", "avpept", "avepkt", "avparkt", "avPkt", "abpkt", "avparkn", "avpbkt", "avPke", "avopacket", "avpect", "afpacket", "AVpacket", "abckt", "avegkn", "avgut", "avfcf", "avegkt", "avcct", "avjpcf", "avPett", "avput"], "buf": ["b", "port", "loop", "box", "home", "bc", "header", "fd", "cache", "result", "brace", "alloc", "socket", "font", "ha", "block", "usr", "usb", "ff", "fb", "cur", "fw", "context", "aka", "vec", "text", "wa", "begin", "window", "rb", "fp", "raw", "pool", "tmp", "exc", "conv", "rc", "buffer", "feat", "feed", "c", "img", "msg", "rw", "_", "prop", "proc", "shift", "pkg", "utf", "br", "Buffer", "fi", "all", "cf", "src", "config", "queue", "cmd", "seq", "uint", "xff", "uf", "bus", "Buff", "buff", "cap", "func", "ctx", "r", "uu", "wb", "cv", "cas", "batch", "pack", "tc", "fun", "loc", "uc", "bag", "d", "cb", "aux", "pad", "length"], "s": ["sf", "sc", "conf", "sv", "S", "space", "sb", "ssl", "fs", "r", "g", "session", "ps", "es", "v", "share", "service", "cs", "m", "sym", "sac", "sg", "si", "bis", "an", "e", "sup", "c", "sync", "d", "ss", "f", "sec", "ds", "stat", "q", "services", "sq", "a", "sys", "as"], "picture": ["plugin", "details", "brush", "png", "slot", "space", "piece", "summary", "gif", "ctx", "room", "info", "photo", "image", "feature", "cache", "pict", "fi", "slice", "uri", "share", "config", "Picture", "frame", "cam", "conference", "package", "profile", "obj", "buffer", "definition", "camera", "media", "family", "library", "movie", "img", "meta", "pic", "guide", "detail", "video"], "p": ["b", "pi", "mp", "n", "proc", "vp", "r", "g", "ps", "l", "fp", "v", "py", "m", "P", "u", "jp", "e", "c", "d", "pd", "f", "pc", "np", "a"], "ptr": ["ch", "vec", "proc", "ctr", "nt", "br", "dr", "cv", "mem", "fi", "tr", "src", "arr", "alloc", "inst", "obj", "buffer", "ef", "addr", "pt", "seq", "transfer", "Ptr", "str", "pad", "pointer"], "AV_NUM_DATA_POINTERS": ["AV_NUM_DATA_POATCHINGS", "AV_NUM_DATA_PROTS", "AV_NUM_DATA_POOTS", "AV_NUM_DATA_POILER", "AV_NUM_DATA_POINTER", "AV_NUM_DATA_POILS", "AV_NUM_DATA_POILERS", "AV_NUM_DATA_PROTERS", "AV_NUM_DATA_POINTS", "AV_NUM_DATA_PRINTERS", "AV_NUM_DATA_POINTINGS", "AV_NUM_DATA_PRINTER", "AV_NUM_DATA_PRINTS", "AV_NUM_DATA_POOTERS", "AV_NUM_DATA_POATCHERS", "AV_NUM_DATA_POOTINGS", "AV_NUM_DATA_POILINGS", "AV_NUM_DATA_POATCHS", "AV_NUM_DATA_PROTER", "AV_NUM_DATA_POOTER", "AV_NUM_DATA_POATCHER", "AV_NUM_DATA_PROTINGS", "AV_NUM_DATA_PRINTINGS"], "offset": ["index", "num", "et", "unc", "set", "parent", "align", "error", "nb", "aw", "base", " error", "slot", "shift", "end", "timeout", "ffff", "Offset", "len", "info", "nt", "image", "position", "size", "no", "fp", " offsets", "ref", "part", "off", "skip", "lace", "origin", "now", "loc", "limit", "start", "padding", "f", "from", "pos", "o", "ff", "fff"], "magic_num": ["magic67num", " magic_number", "magic2bin", " magic_common", "magic_fun", "magic2num", "magicialsum", "magic2fun", "magic__nom", "magic_number", "magic_bin", "magic67no", " magic_bin", " magic_nom", " magic_sum", "magic_type", "magic_sum", "magic_no", "magic__num", "magic67bin", "magicialtype", " magic_nu", " magic_no", " magic_type", "magicialnum", "magic67common", "magic__number", "magic_common", "magic_nu", " magic_fun", "magicialnumber", "magic__nu", "magic2no", "magic_nom"], "endian": ["angio", "enderman", " endien", "endedrian", "endior", "angians", "endig", "endederman", "endsiar", "angiana", "endserman", "endednet", "endsian", "endedian", "endien", "endedior", "endedio", "ENDiet", "appendio", "endio", "endsnet", " endig", " endiar", "endediana", "endiet", " endio", " endior", "ENDien", "ENDio", "endnet", "endiana", "endrian", "appendien", " endrian", "angian", "endsig", " endians", "endsrian", " endiet", " endiana", "ENDian", "endsians", "endediar", "appendian", "endians", " endnet", "appendiet", "endedians", " enderman", "endiar", "endsior", "endedig"], "x": ["index", "num", "n", "win", "z", " index", "X", " image", "r", "g", "image", "ix", "l", "v", " X", "ex", "dx", "c", "d", "f", "o"], "y": ["b", "vy", "Y", "n", "z", "dy", "r", "hi", "g", "l", "v", "m", "t", "u", "e", "c", "d", "f", "q", "phi", "o", "height", "a"], "i": ["index", "b", "ai", "pi", "j", "hi", "ip", "ix", "l", "v", "io", "xi", "ini", "m", "I", "u", "it", "ii", "si", "c", "f", "phi", "ci", "ni", "mi"], "ret": ["status", "error", "entry", "reply", "value", "id", "RET", "success", "count", "timeout", "len", "info", "r", "nt", "utf", "result", "alt", "resp", "get", "mem", "no", "det", "ref", "part", "rets", "code", "tmp", "bad", "def", "match", "ft", "fail", "rc", "fun", "att", "feat", "rt", "lit", "val", "back", "Ret", "reg", "flag", "res", "bit", "out", "temp", "re", "used"], "w": ["b", "fw", "weight", "n", "win", "aw", "wt", "z", "wid", "ow", "end", "ew", "hw", "sh", "W", "wa", "r", "ww", "g", "size", "wl", "max", "wb", "l", "work", "wx", "v", "wal", "kw", "wo", "wd", "m", " W", "t", "u", "wi", "we", "k", "c", "d", "wh", "f", "q", "sw", "height"], "h": ["b", "n", "oh", "ih", "z", "gh", "bh", "hd", "end", "sh", "r", "hi", "g", "size", "l", "v", "hs", "hm", "m", "rh", "u", "ah", "e", "ha", "c", "ph", "d", "padding", "f", "hr", "uh", "hp", "ul", "q", "H", "ht", "o", "height"], "bits_per_color": ["bits_per_texture", "bits_per_pixel", "bits_per_colour", "bits_per_channel", "bits_perfsize", "bits_perfcolor", "bits_perftexture", "bits_perfpixel", "bits_per_size"], "descriptor": ["descructor", "desccriptors", "descstruction", "desccription", "decriptOR", "escription", "description", "decributOR", "describution", "descructors", "desccriptor", "decription", "descpectcer", "decributoring", "escriptor", "descriptoring", "descruction", "descriptcer", "esccriptors", "descriptOR", "descributoring", "descributor", "decributor", "descpection", "descributOR", "descstructoring", "descstructOR", "descpectOR", "decribution", "esccriptcer", "desccriptcer", "escriptors", "esccriptor", "escriptcer", "decriptoring", "descpectoring", "decriptor", "descriptors", "descructcer", "esccription", "descpectors", "descstructor", "descpector"], "elements": ["Eles", "Elements", "element", "eodes", " eodes", "pelements", "pelement", "eles", " element", "peodes", " eles", "peles", "Element", "Eodes"], "packing": ["ipping", "rows", "including", "space", "stuff", "xxx", "writing", "pkg", "storage", "packs", "reading", "loading", "kw", "sequence", "working", "secret", "slice", "checking", "power", "ending", "running", "queue", "pack", "tracking", "counter", "leading", "buffer", "capacity", "missing", "aging", "processing", "padding", "extra", "spec", "packed", "using", "checks", "xff", "mask", "adding", "setting", "icing", "ping"], "total_size": ["total67count", "total_sum", "total67len", "total_len", " total_sum", "total_count", " total_len", "total67sum", " total_count", "total67size"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n\n{\n\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n\n    int rs = mmreg(ctx->opcode & 0x7);\n\n    int opc;\n\n\n\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n\n    case NOT16 + 0:\n\n    case NOT16 + 1:\n\n    case NOT16 + 2:\n\n    case NOT16 + 3:\n\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n\n        break;\n\n    case XOR16 + 0:\n\n    case XOR16 + 1:\n\n    case XOR16 + 2:\n\n    case XOR16 + 3:\n\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n\n        break;\n\n    case AND16 + 0:\n\n    case AND16 + 1:\n\n    case AND16 + 2:\n\n    case AND16 + 3:\n\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n\n        break;\n\n    case OR16 + 0:\n\n    case OR16 + 1:\n\n    case OR16 + 2:\n\n    case OR16 + 3:\n\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n\n        break;\n\n    case LWM16 + 0:\n\n    case LWM16 + 1:\n\n    case LWM16 + 2:\n\n    case LWM16 + 3:\n\n        {\n\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case SWM16 + 0:\n\n    case SWM16 + 1:\n\n    case SWM16 + 2:\n\n    case SWM16 + 3:\n\n        {\n\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n\n            int offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n\n                              29, offset << 2);\n\n        }\n\n        break;\n\n    case JR16 + 0:\n\n    case JR16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case JRC16 + 0:\n\n    case JRC16 + 1:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    case JALR16 + 0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 24483, "substitutes": {"ctx": ["context", "scope", "sci", "xc", "sc", "bc", "cmp", "anc", "nc", "ca", "cc", "cp", "cms", "connection", "hw", "cus", "pkg", "gc", "ck", "qt", "ocr", "cv", "cas", "kw", "la", "conn", "wx", "cf", "Context", "hs", "config", "cam", "parse", "vc", "kt", "cl", "grad", "cs", "tc", "cmd", "conv", "cn", "wcs", "rc", "cm", "tx", "ct", "ctrl", "mac", "jp", "na", "cca", "txt", "loc", "exec", "c", "sync", "linux", "utils", "lc", "cli", "cb", "cpp", "ann", "sq", "cu", "ci", "np", "qa", "client", "kb", "ga"], "is_branch": ["is_brix", "is_franc", "is_refix", "is_refanches", "is_refanch", "is_branches", "is_branc", "is_banches", "is_bix", "is_banch", "is_frix", "is_refanc", "is_banc", "is_franches", "is_franch"], "opc": ["opcode", " opcode", " copc", "opn", " copcode", " copci", "OPci", "OPc", " copn", "OPcode", "opci", " opci", "OPn", " opn"], "lwm_convert": ["lwm_perverts", "lwm_canverted", "lwm_pervert", "lwm_canvert", "lwm_unversion", "lwm_perverted", "lwm_Convert", "lwm_Converts", "lwm_unverted", "lwm_canverts", "lwm_perversion", "lwm_Conversion", "lwm_Converted", "lwm_unverts", "lwm_canversion", "lwm_converted", "lwm_converts", "lwm_conversion", "lwm_unvert"], "swm_convert": ["swm_perver", "swm_genver", "swm_invert", "swm_helverted", "swm_genverted", "swm_inver", "swm_unvert", "swm_converts", "swm_helvert", "swm_genverts", "swm_unverted", "swm_inverted", "swm_unverts", "swm_helverts", "swm_pervert", "swm_converted", "swm_perverts", "swm_conver", "swm_perverted", "swm_inverts", "swm_unver", "swm_helver", "swm_genvert"]}}
{"project": "FFmpeg", "commit_id": "abb5e37f64c48bba8bd0fde2bada0f7544defa24", "target": 1, "func": "int ff_filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFrame *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFrame *out;\n\n\n\n    FF_DPRINTF_START(NULL, filter_frame);\n\n    ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    /* copy the frame if needed */\n\n    if (dst->needs_writable && !av_frame_is_writable(frame)) {\n\n        av_log(link->dst, AV_LOG_DEBUG, \"Copying data in avfilter.\\n\");\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, frame->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        av_frame_copy_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->width, frame->height);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        av_frame_free(&frame);\n\n    } else\n\n        out = frame;\n\n\n\n    return filter_frame(link, out);\n\n}\n", "idx": 24484, "substitutes": {"link": ["loop", "li", "type", "url", "lock", "line", "match", "sync", "block", "bridge", "co", "ci", "ln", "network", "key", "path", "edge", "cp", "connection", "tag", "info", "add", "flow", "l", "style", "parse", "mail", "plug", "arg", "feed", "flash", "ind", "lc", "plugin", "leg", "Link", "ace", "loader", "or", "ck", "model", "light", "slice", "config", "label", "route", "di", "channel", "bug", "head", "module", "ink", "call", "mm", "base", "source", "zip", "linked", "image", "ip", "band", "pack", "ld", "local", "machine", "db", "file", "loc", "links", "load"], "frame": ["in", "run", "cell", "framework", "new", "figure", "lock", "line", "ze", "match", "force", "view", "block", "movie", "user", "name", "post", "play", "fram", "fb", "parent", "connection", "feature", "flow", "iframe", "style", "definition", "point", "fe", "plugin", "scene", "interface", "full", "rame", "up", "position", "model", "boot", "fi", "slice", "cf", "motion", "code", "draw", "channel", " Frame", "now", "player", "module", "f", "frames", "layer", "data", "call", "back", "video", "ground", "mini", "plane", "base", "zip", "layout", "game", "image", "fake", "panel", "part", "version", "Frame", "setup", "file", "time", "element", "component", "object", "load", "zone"], "filter_frame": ["filter_position", "filter___fram", "filter_element", "filteraldef", "filter___element", "filterenfram", "filterenproperty", "filtervalframe", "filter_fram", " filter_component", "filteracchannel", "filtervallink", "filtervaldef", "filter___position", "sort_point", "filteraycomponent", "sort_frame", "filterencomponent", "filterensetup", "filteroutpoint", "filterayfram", " filter_sequence", "filter_link", "filter_setup", "sort_fram", "filterayproperty", "filterallink", " filter_node", "filterennode", "filterersequence", "filter_property", " filter_element", "filtervalfram", " filter_def", " filter_setup", "filteroutfram", "filterayframe", "filteracfram", "filter_style", "filteralframe", " filter_property", "filteralfram", "filteracpoint", " filter_channel", "filteroutframe", "filteracsetup", "filtererchannel", "filteracnode", " filter_fram", "filter_component", "filteracsequence", "filteracframe", "sort_style", "filtererframe", "filteracstyle", "filter_channel", "filteroutstyle", " filter_link", "filter___frame", " filter_position", "filter_point", "filter_def", "filterenframe", "filter_sequence", "filter_node"], "dst": ["ndsts", "tdst", "dbl", "sdST", "sdst", "dsc", "bdsc", "bdsts", "tdput", " dST", "dput", "dsts", "ndST", " dbl", "ndst", "sdsts", "fnt", "bdst", "odbl", "odsc", "Dst", "tdft", "dnt", "dST", "DST", "ndbl", "bdST", " dsts", "fst", "tdsc", "Dft", "odnt", "fsc", "Dput", "Dsts", "dft", " dput", "sdbl", "Dsc", " dnt", "fbl", " dft", "odst", " dsc"], "out": ["in", "run", "child", "outs", "got", "ne", "result", "new", "url", "ref", "inner", "blank", "instance", "lock", "line", "match", "page", "old", "block", "sync", "and", "co", "user", "name", "post", "n", "parent", "err", "end", "connection", "window", "flow", "conn", "check", "off", "style", "obj", "point", "img", "copy", " in", "o", "client", "bin", "at", "ext", "orig", "error", "or", "full", "op", "group", "update", "up", "no", "all", "wx", "OUT", "empty", "on", "code", "m", "again", "channel", "of", "extra", "module", "output", "f", "data", "call", "base", "source", "to", "Out", "image", "io", "part", "init", "file", "object", "diff", "outer", "load"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24485, "substitutes": {"transport": ["ransp", "transp", "transporter", "ransPORT", " transporter", " transp", "ransports", "transort", "Transp", "transPORT", "Transports", " transports", "Transort", "transports", "ransort", " transPORT", " transort", "Transport", "ransporter", "Transporter", "TransPORT", "ransport"], "data": ["buf", "base", "da", "message", "write", "body", "bytes", "response", "DATA", "window", "cache", "size", "result", "zero", "style", "batch", "queue", "address", "read", "Data", "buffer", "input", "pad", "addr", "block", "dd", "d", "start", "next", "val", "api", "ui", "client", "dat", "a", "pointer"], "len": ["n", "lan", "base", "split", "vec", "err", "Len", "valid", "lib", "nt", "fin", "size", "en", "alt", "l", "mem", "conn", "all", "line", "lf", "ld", "fun", "el", "ll", "block", "limit", "seq", " length", "start", "fn", "delay", "lit", "f", "str", "val", "load", "pos", "name", "length", "ln", "offset"], "vs": ["vm", "vers", "flags", "gs", "sv", "os", "rs", "ops", "vp", "VS", "vt", "fs", "bs", "ps", "ts", "es", "v", "ks", "sk", "rev", "vals", "cs", "ports", "vr", "iss", "args", "ms", "ns", "forces", "ils", "utils", "eps", "ss", "ls", "ds", "Vs", "stats"], "ret": ["num", "sr", "rf", "error", "reply", "base", "err", "id", "RET", "count", "req", "try", "nt", "fin", "type", "result", "alt", "resp", "det", "url", "ref", "rev", "rets", "code", "rl", "t", "ft", "rc", "fun", "att", "arg", "rt", " Ret", "f", "lit", "bf", "val", "pet", "Ret", "reg", "flag", "art", "ry", "success", "re", "ext"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486, "substitutes": {"obj": ["x", "b", "buf", "js", "pb", "Obj", "parent", "env", "j", "self", "func", "xxx", "objects", "ctx", "emb", "bo", "op", "rb", "attr", "fi", "src", "rev", "p", "tmp", "inst", "Object", "po", "node", "f", "object", "val", "api", "data", "iv", "o", "opt", "foo", "ob"], "v": ["b", "V", "vm", "vs", "env", "sv", "j", "lv", "vp", "vt", "op", "g", "l", "p", "m", "conv", "u", "vu", "ev", "vv", "w", "e", "c", "d", "f", "tv", "object", "val", "iv", "o", "uv"], "opaque": ["iopacity", "paqu", "spaque", "opaqu", "opachy", "iopac", "obacity", "opac", " opacity", "spachy", "obaqu", "obaque", " opac", "paque", "iopachy", "opacity", "spac", " opachy", "spacity", "pacity", " opaqu", "iopaque"], "name": ["cap", "alias", "n", "key", "error", "member", "anc", "property", "none", "word", "size", "type", "field", "new", "no", "named", "null", "label", "code", "prefix", "unknown", "names", "var", "clean", "comment", "Name", "missing", "desc", "data", "val", "nm", "NAME", "foo", "nice"], "errp": ["rarlp", "reqpc", "rrps", "errcp", "errps", "rrpi", "irps", " ercp", " errcp", "nerpi", "ircp", " erp", "nerp", " errlp", "reqcp", "irlp", " erlp", "rrp", "irpc", "errl", "rrcp", "errlp", "errpi", "errpc", "nerpc", "reqps", "irp", "rrlp", "nerlp", "rarp", " erl", "irpi", " errl", "rrpc", "rarcp", "reqp", "rarl"], "prop": ["b", "plugin", "pb", "mp", "parent", "Prop", "cmp", "j", "proc", "cp", "property", "pred", "ptr", "info", "option", "op", "prot", "pkg", "type", "field", "attr", "fi", "ref", "priv", "part", "p", "tmp", "pro", "properties", "po", "jp", "f", "lit", "val", "api", "typ", "np", "pr", "opt", "pointer", "fb"], "value": ["index", "array", "key", "parent", "id", "message", "write", "format", "property", "valid", "reference", "create", "VALUE", "image", "number", "size", "type", "field", "result", "ref", "null", "instance", "version", "p", "example", "protected", "target", "Value", "object", "data", "values", "val", "content", "foo", "class", "length"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,\n\n                            int mb_x, int mb_y, uint8_t *img_y,\n\n                            uint8_t *img_cb, uint8_t *img_cr,\n\n                            unsigned int linesize, unsigned int uvlinesize)\n\n{\n\n    assert(!FRAME_MBAFF(h));\n\n    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {\n\n        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n\n        return;\n\n    }\n\n\n\n#if CONFIG_SMALL\n\n    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);\n\n#else\n\n    if(h->pixel_shift){\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);\n\n    }else{\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);\n\n    }\n\n#endif\n\n}\n", "idx": 24488, "substitutes": {"h": ["x", "b", "context", "pl", "n", "oh", "ch", "ih", "z", "http", "gh", "self", "bh", "dh", "zh", "hw", "he", "sh", "ctx", "r", "host", "g", "hl", "ahi", "eh", "hi", "image", "l", "work", "v", "hh", "y", "hs", "hm", "ssh", "p", "m", "history", "s", "t", "rh", "u", "w", "ah", "e", "ha", "c", "ph", "hp", "d", "f", "img", "hr", "uh", "ul", "q", "H", "ht", "o", "auth"], "sl": ["b", "coll", "sf", "pl", "ch", "sc", "lr", "shell", "lib", "ssl", "sh", "sel", "ctx", "kl", "sb", "hl", "l", "sa", "la", "SL", "src", "sk", "enc", "il", "cl", "spot", "p", "m", "rl", "s", "el", "su", "hel", "si", "loc", "c", "ph", "f", "lc", "ls", "spec", "Sl", "serv", "sn", "sw", "sil", "sch", "se", "fl", "cur"], "mb_x": ["url_xi", "mbamexi", "mbamex", "mb44yx", "url_yx", "mbameyx", "mb_dy", "urlamex", "mp_x", "mb_yx", "mb_xi", "mb_wy", "mp_n", "bf_x", "urlameyx", "bf_wy", "urlamexi", "mbametx", "mb44x", "mb_tx", "mn_dy", "mp_y", "mn_y", "bf_y", "mb_width", "url_tx", "mb_n", "mn_width", "bf_w", "mb_w", "mb44xi", "mn_x", "url_x", "mb_z", "urlametx", "mb44tx", "mp_z"], "mb_y": ["mb_yo", "mb_py", "mp_yy", "img_zy", "mb_dy", "mb_oy", "mp_x", "mp_ey", "mp_py", "mb68yo", "mb_Y", "mb_cy", "mb_ey", "mb68oy", "mbingy", "mb68y", "img_x", "mp_y", "mp_dy", "mb_zy", "mp_vy", "mp_yo", "mb68x", "mp_cy", "mb_yy", "img_Y", "mbingx", "mb_vy", "mp_oy", "mbingcy", "mbingvy"], "img_y": ["img_bar", "imag_bar", "mbJy", "img_iy", "mbJyk", "img__ye", "img_ey", "img__iy", "mb_ies", "mb_ya", "image_ies", "imgJy", " img_ny", "imgKbar", " imgJy", "img_ya", "img9y", "utm_ye", "img__y", "img_cy", " imgJny", "imgJcy", "utm9x", "img_ny", "imgJyk", "utm_y", "utm_x", "img_ies", "image_ey", " img_cy", "img_ye", "utm9y", "imag_y", "img_yk", "img9x", "imagKy", "img_x", "imgJny", "image_y", "imagKyy", "imagKx", "utm_iy", "img9iy", "utm9iy", "imgJya", "img__x", "imgJies", "imagKbar", " imgJyk", "mb_yk", "mbJies", "mbJya", "imgKyy", "imgKy", "img9ye", "img_yy", "imgKx", " imgJcy", " img_yk", "imag_x", "utm9ye", "image_ya", "imag_yy"], "img_cb": ["im_cb", "imag_cmd", "img_c", "bg_bb", "imgLcmd", "img_cmd", "imgaccb", "img_cp", "img_src", "imgJy", "imag_cp", "bg_cb", "imgLcp", "imgIPrc", "imp_bb", "im_rc", "imagLy", "imagLcmd", "img_cf", "bg_cr", "imgIPc", "img_bb", " img_src", "imagLcp", "imag_y", " img_cf", "imgJcb", "imgLcb", "im_cr", "imp_cb", "img_b", "imgaccr", "imgIPcb", "imgacsrc", "imgaccf", "imgJcmd", "img_rc", "img_home", "imgJcp", "img24cr", "img24home", "im_c", "bg_b", "imp_cr", "imagLcb", "imgLy", "imgIPcr", "img24cb", "imp_home", "imag_cb", "img24bb"], "img_cr": ["im_cb", "img__ocr", "img__cr", "imag_cr", "bg_bre", "img__cb", "img_ocr", "img_cd", "bg_cb", " img_cd", "imgAcr", "img_CR", "image_cr", "im_cm", "bg_CR", "img_ctr", "bg_cr", "img_car", "img_rb", "imgAcur", " img_cre", "img_cm", "imag_car", "imag_ocr", "img__car", "img_bre", "im_cr", "imgAcm", "image_ctr", "image_rb", "img_cur", " img_CR", "image_cb", "img_cre", "im_cur", "imgAcb", "imag_cb"], "linesize": ["linize", "roomsizing", "vsiz", "topsize", "linssize", "inesize", "linksization", "vsizing", "linesizer", "linesiz", "roomsiz", " linesiz", "linksizing", "linsize", "linesization", " linesization", " linesizer", "linksize", "inesizer", "linsization", "worksizing", "topsization", "linizer", "cellsiz", "topsizer", "linessize", "worksiz", "inesization", "cellsization", " linessize", "inesiz", "cellsizer", "vsize", "liniz", "linization", "linsiz", "vsization", "topsiz", "linkssize", "linksiz", "worksizer", "linesizing", "cellsize", " linesizing", "worksize", "roomsize", "roomsizer"], "uvlinesize": ["uvbandsization", "imglinersense", "uvpagesizer", "uvlinksizer", "uvlinersense", "imglinesiz", "uvlinssize", "uzlinesize", "uvlinersite", "uvliningizable", "uvcellsization", "uvpagesize", "uvcellsiz", "uumliningize", "upplinesize", "uzlinessize", "uumliningiz", "imglinesense", "ovlinesizable", "imglinersize", "uvcodesize", "uvcodesiz", "uvlinersiz", "uvpagesizable", "uvlinsize", "uvlinersizable", "uvliningization", "uvliningparse", "uvlinersize", "uvpagesite", "uvcodesizer", "upplineiz", "uvlinksiz", "upplineization", "uvbandsize", "imglinersiz", "uzlinksize", "uzlinesizer", "upplinesization", "uvlinesite", "uvlineize", "uvcellsize", "uzlinkssize", "imglinersizer", "uumliningization", "uvlinsiz", "ovlinersizer", "uvlineizable", "uvlinesense", "ovlinesite", "ovlinersize", "uvcellsizable", "upplinesiz", "uumlinesiz", "uvlinsizer", "uvbandsparse", "ovlinesize", "ovlinersizable", "uvcodesense", "upplineize", "uumlinesize", "uvbandsiz", "uvlinesiz", "uvlinesization", "uvliningiz", "uvliningize", "uzlinksizer", "uvlinesizable", "imglinesizer", "uvlinksize", "uvlinesparse", "uvlinesizer", "uvlinkssize", "upplineizable", "upplinesizable", "uzlinksiz", "uvlinersizer", "uvlineization", "ovlinesizer", "uumlinesization", "uvlineite", "uvlinessize", "imglinesize", "uvlineiz", "uvlineizer", "uvlineparse", "uumlinesparse", "ovlinersite", "uzlinesiz", "uumliningparse"]}}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n", "idx": 24501, "substitutes": {"device": ["prop", "port", "product", "disk", "remote", "path", "parent", "driver", "mode", "project", "message", "connection", "hw", "task", "tag", "ip", "feature", "model", "Device", "result", "serial", "gpu", "draw", "p", "dev", "password", "cmd", "address", "package", "devices", "channel", "unit", "machine", "buffer", "mac", "attribute", "link", "target", "handle", "node", "phy", "block", "module", "component", "object", "data", "mount", "user", "name", "tty"], "has_force": ["Has_force", " has_Force", "has_forcing", " has_forcing", "Has_forced", "Has_write", "Has_Force", "has_Force", "has_write", "has_forced"], "force": ["x", "ant", "orce", "fw", "dist", "weight", "front", "base", "driver", "allow", "cing", "ride", "source", "secure", "ignore", "forcing", "pull", "r", "cache", "dr", "forced", "l", "Force", "ce", "uri", "service", "require", "weak", "fr", "act", "push", "hard", "dirty", "forces", "flat", "sync", "like", "f", "q", "load", "use", "flag", " forced", "form", "ff", " Force", "support", "fl"], "errp": ["rrps", "errps", " errb", " errP", "err", "erc", "errback", "errb", " errfp", " erp", " erpc", " errpc", "errc", "erback", "errfp", "erp", "erb", " erback", " errc", "rrr", "resultp", "errorp", "rrp", "resultP", "erfp", "rrfp", "erpc", " errps", "errP", " errr", "errpc", " errback", "errorr", "errr", "resultps", "errorb", "rrP", " err", "resultc", "rrc"], "local_err": ["localablenr", "localifout", " local_rc", " local_er", " local_error", " local_nr", "localapperr", " local_out", "localapprc", " local_rr", "local_rc", "localiferror", "local_nr", "localableerror", "localiferr", "localableerr", "local_rr", "localifrr", "localapper", "localableer", "local_er", "local_error", "localapperror", "local_out"], "rc": ["fc", "rec", "dc", "rog", "error", "sc", "bc", "err", "nc", "ac", "cc", " sc", "arc", "rb", "ck", "result", "cv", "ry", " RC", "src", "roc", "oc", "vc", "code", "cs", "cr", "rh", "rl", " src", "irc", "ct", "ok", "loc", "uc", "c", "inc", "pc", "ec", "lc", "cb", "rr", "co", "ci", " cc", "RC", "cur"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508, "substitutes": {"prot": ["reset", "prop", "rect", "port", "platform", "pb", "het", "rog", "rin", "php", "inet", "pred", "tf", "test", "python", "ptr", "type", "fp", "config", "pre", "p", "primary", "termin", "ocol", "pro", "t", "prefix", "att", "flat", "addr", "txt", "bot", "rot", "pt", "transfer", "cot", "typ", "api", "Prot", "np", "server", "ht", "sil", "pat", "eth", "tp", "repl", "pointer", "ext"], "rw": ["fw", "worker", "rf", "wp", "rog", "rx", "wit", "iw", "wer", "hw", "wa", "r", "ww", "rb", "wrap", "wl", "wb", "work", "wx", "wo", "wal", "rew", "rou", "rn", "rh", "rss", "wr", "w", "rc", "nw", "usr", "wh", "ru", "rack", "tw", "sw", "rus", "RW", "ro"], "access_type": ["access__name", "accesstypetype", " access_style", "access_policy", "access__type", "accessingname", "access__policy", "accesstypestyle", "access_style", " access_resource", " access_key", "accessingtype", "access_key", "access_name", " access_types", "accessingkey", "accesstypetypes", "access__key", "access_types", "accesstyperesource", "accessingpolicy", "access_resource", " access_policy", " access_name"], "ret": ["ext", "num", "error", "reply", "base", "mt", "id", "RET", "std", "req", "let", "len", "final", "gt", "nt", "alt", "result", "resp", "mem", "det", "ref", "part", "al", "rev", "rets", "pass", "code", "grad", "t", "match", "ft", "def", "fun", "hard", "feat", "arg", "rt", "lit", "str", "val", "data", "cat", "back", "Ret", "reg", "res", "art", "pat", "opt", "flag", "success", "re", "fit"]}}
{"project": "qemu", "commit_id": "4545d4f4af8b29ba3b38dfb74d6f45342e15a62d", "target": 1, "func": "static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,\n\n                            int64_t offset_in_cluster, QEMUIOVector *qiov,\n\n                            uint64_t qiov_offset, uint64_t n_bytes,\n\n                            uint64_t offset)\n\n{\n\n    int ret;\n\n    VmdkGrainMarker *data = NULL;\n\n    uLongf buf_len;\n\n    QEMUIOVector local_qiov;\n\n    struct iovec iov;\n\n    int64_t write_offset;\n\n    int64_t write_end_sector;\n\n\n\n    if (extent->compressed) {\n\n        void *compressed_data;\n\n\n\n        if (!extent->has_marker) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24540, "substitutes": {"extent": [" extente", "contract", "xtient", "exension", "extency", "decient", "descent", "xtent", "contension", "decent", "indenter", "lexente", "extient", "extract", "expent", "expension", "extension", "indend", "contient", "silend", "contend", "indente", "defension", "indract", "contractor", "extant", "lexent", "silractor", "silract", "defenter", "defent", "extenter", "indractor", " extency", "defant", "descient", "indent", "indency", "contenter", " extenter", "lexency", "exant", "decant", "expient", "extente", "exent", "lexenter", "content", "exient", "xtant", "descension", "contant", "descant", "decension", "expant", "extractor", "extend", "xtension", "expenter", "silent"], "cluster_offset": ["clressoralsize", "cluster__no", "clressoralbound", "clusteralbound", "cluster_no", "clressor_bound", "cluster_size", "cluster_bound", "cluster_Offset", "cluster__slot", "clusteralsize", "clusters_offset", "clressoraladdress", "cluster_slot", "clressor_size", "clusters_slot", "clusteraladdress", "clusters_Offset", "clressor_address", "clusters_no", "cluster__Offset", "clusteraloffset", "cluster_address", "clressoraloffset", "cluster__offset", "clressor_offset"], "offset_in_cluster": ["offset_in_Clusters", "offset_in_clancer", "offset_in_CLarc", "offset_in_gluster", "offset_in_blancer", "offset_in_splarc", "offset_in_bluster", "offset_in_CLusters", "offset_in_CLructure", "offset_in_glarc", "offset_in_blusters", "offset_in_glructure", "offset_in_CLuster", "offset_in_clusters", "offset_in_clarc", "offset_in_Clancer", "offset_in_sclancer", "offset_in_splructure", "offset_in_glusters", "offset_in_sclructure", "offset_in_spluster", "offset_in_scluster", "offset_in_blructure", "offset_in_Clructure", "offset_in_clructure", "offset_in_sclusters", "offset_in_splusters", "offset_in_Cluster"], "qiov": ["Qiov", "qoyer", "qqiov", "quiov", "quliv", "quiro", "quiop", "qiop", "sqiop", "reqiop", "qliv", "qiosity", "qrolet", "qqliv", "qoren", "quiosity", "quilo", "Qnox", "qqimedia", "chiov", "quoren", " qrolet", " qoren", "qilo", " qnox", "chilo", "sqiov", "qiro", "reqiosity", "sqiosity", " qimedia", " qoyer", "quimedia", " qliv", "quoyer", " qilo", " qiro", "Qoyer", "qunox", "qimedia", "qurolet", "chiro", "reqiov", "chiop", " qiop", "sqimedia", "qqrolet", "Qoren", "reqimedia", "qnox"], "qiov_offset": ["qarrison_off", "qiop_position", "qiop_len", "qarrison__off", "qiov_len", "qiov__position", "qarrison__start", "qiov_off", "qiop_offset", "qiov_pos", "qarrison__offset", "qarrison_position", "qiop_off", "qarrison_start", "qarrison__position", "qiov__offset", "qiov_position", "qiov__off", "qiov__start", "qarrison_offset", "qiop_pos", "qiov_start"], "n_bytes": ["N_lines", " n_bits", "id", " n_resources", "n_seconds", "g", "n2bytes", "ln67pages", "nNbytes", "n_byte", "block", "N_pieces", "n_clips", "n96rows", "n67bits", "n96files", "ln_pages", "n67files", " n_pieces", "n2byte", "n_units", "n__pieces", "n96zip", "ln67bits", "n2bits", "nb_byte", "m_zip", "n_lines", "nNpages", "n2units", " n_clips", "nb_units", "ln_devices", "_", "n_rows", "n_files", "nb_bits", "n67resources", "nb_bytes", "all", "n__bytes", "n67devices", "s", "n_pages", "m_bytes", "ln67devices", "n_bits", "N_seconds", "N_bytes", "n__seconds", "n_zip", "n_pieces", "n_devices", " n_lines", "nNbits", "n_resources", "m_rows", "n67bytes", "n__lines", " n_files", "r", " n_seconds", "ln67bytes", "n67pages", "n96bytes", "d", "ln_bytes", "ln_bits", "pos", "nNdevices", "m_files"], "offset": ["index", "ipping", "afi", "num", "key", "set", "align", "phase", "id", "slot", "shift", "format", "end", "Offset", "len", "ptr", "op", "position", "size", "axis", "attr", "location", "fp", "off", "abyte", "origin", "address", "prefix", "buffer", "acl", "addr", "seq", "start", "padding", "transfer", "meta", "pos", "o", "oton", "length"], "ret": ["num", "sr", "ut", "status", "reply", "mt", "id", "RET", "count", "valid", "let", "len", "final", "info", "r", "nt", " RET", "gt", "fin", "red", "rb", "result", "alt", "resp", "no", "det", "ref", "rev", "rets", "code", "arr", "rl", "ft", "match", "rc", "fun", "att", "feat", "db", "arg", "rt", " Ret", "lit", "val", "rep", "cat", "back", "Ret", "reg", "res", "flag", "bit", "art", "success", "re", "ext"], "data": ["gz", "database", "temp", "byte", "write", "xxx", "send", "header", "binary", "function", "cache", "result", "reader", "mu", "zero", "p", "complete", "json", "device", "media", "dd", "partial", "buf", "aa", "parent", "da", "writer", "wa", "window", "info", "record", "open", "xy", "buffer", "img", "o", "value", "shift", "bytes", "response", "attr", "slice", "config", "empty", "draw", "code", "di", "Data", "input", "output", "str", "dat", "results", "align", "base", "progress", "body", "DATA", "actions", "done", "layout", "image", "storage", "size", "ata", "uni", "version", "batch", "initial", "init", "sample", "d", "i", "next", "load", "content", "memory", "length"], "buf_len": ["buf_l", "cb_length", "buf1lif", "buf64len", "block_den", "buffer2len", "buffer_len", "buf_den", "buffer_length", "buf1len", "buffer_val", "uf_len", "buff_len", "buf64base", "buf2lif", "buff1len", "uf_length", "buf00len", "buf2size", "buff_size", "buff1size", "buffer_pos", "buffer2length", "buf_lin", "buf6length", "buf_ln", "buf6pos", "buf_lif", "buf_count", "buf64val", "buffer_base", "cb_size", "buffer2val", "buf2length", "buf1pos", "block_ln", "buf6len", "buf_size", "buf1size", "buf_length", "buf2lin", "uf_l", "block_len", " buf_l", " buf_lf", "buf2l", "buff1pos", "buf2base", "buffer2base", "buf_pos", "cb_len", "buf00den", "uf_lin", "buf2lf", "buf2len", "buf2val", "buf2pos", "buffer_count", "buf64length", "buf_log", "buf00log", " buf_length", "buff_lif", "buf6count", "buf00ln", "buf_base", "buff_pos", "buf_lf", "buff1lif", "block_log", "buf_val"], "local_qiov": ["local_requiov", "local_qumus", "local_qrolet", "local_Qiop", "local_qovi", "local_qliv", "local_qiop", "local_quimedia", "local_dqrolet", "local_qimedia", "local_quiris", "local_pilib", "local_dqiop", "local_qurolet", "local_quoyer", "local_idiov", "local_quiop", "local_vilib", "local_giov", "local_idliv", "local_qiris", "local_idmus", "local_dqiov", "local_dqominium", "local_goyer", "local_idominium", "local_qilib", "local_dqimedia", "local_piov", "local_qmus", "local_viris", "local_Qimedia", "local_quominium", "local_dqmus", "local_govi", "local_piris", "local_quiov", "local_requrolet", "local_quovi", "local_Qrolet", "local_requovi", "local_quliv", "local_dqliv", "local_qoyer", "local_grolet", "local_quilib", "local_piop", "local_viov", "local_viop", "local_requoyer", "local_qominium", "local_Qiov"], "iov": ["obo", " modem", "ilib", "nih", "imi", "dq", "iii", " bio", "gra", "ione", " nucleus", "kov", " ensemble", "liv", "iw", "rolet", " module", " gru", " eth", " cla", "iol", "ilo", "odi", "imedia", "dyl", " sensor", " misc", "ahi", " mech", " reservoir", "\u00ef", "ibl", " continuity", "mu", "drm", "io", "igroup", "iago", "wav", "audi", "ij", "roxy", "lov", " gif", " destro", " combo", " io", " lib", " chic", " codec", "mus", "oyer", " multimedia", "nox", "iro", "uno", " compressor", " cluster", "eni", "yout", "imoto", "iev", "iris", " virt", " alloc", "oren", "iop", "gru", "iola", " gateway", "club", " hive", "ijah"], "write_offset": ["write_size", "write_len", "write___off", "writePlen", "write67off", "writeingsize", "write67operation", "write_pos", "write___operation", "write_operation", "writePsize", " write_error", "write_length", "write___offset", "network_pos", "write_option", "writeCoffset", " write_operation", "write_error", "writePpos", "network_size", "writeingoffset", "write67offset", " write_off", "write___length", "network_len", " write_option", " write_length", "write_off", "writeinglen", "writeingpos", "writeCoption", "network_offset", "write67length", "writeCerror", "writePoffset"], "write_end_sector": ["write_start_unit", "write_endenorder", "write_end_unit", "write_start_sector", "write_start_order", "write_end_section", "write_start_section", "write_endensection", "write_end_order", "write_endensector", "write_endenunit"], "compressed_data": ["compressededsize", "compressed_key", "compressed_body", "compressed_results", "compressededdata", "compressed_text", "compulated_results", "compresseddkey", "compressed67data", "compression_Data", "compressed_next", "compressed___data", "compressed67value", "compression_results", "compulated_data", "compresseddvalue", "compressioneddata", "compulated_message", "compressed_message", "composed_text", "compressed_value", "compresseddmemory", "compressedddata", "compression_next", "composed_dat", "compared_value", "compressededvalue", "compression_size", "compressionedresults", "compressed67text", "compressionedsize", "compressededkey", "composed_data", "compressed67dat", "compressed_dat", "compared_key", "compression_data", "compressededmemory", "compared_memory", "compressed___dat", "compressed_memory", "compressionednext", "compared_data", "compressed___value", "compressed_Data", "compressed___text", "compressed_size", "compulated_body", "compressededresults", "composed_value", "compressedednext"]}}
{"project": "FFmpeg", "commit_id": "8bc80f8b24cb6f03ad209ce546ae594904c8b353", "target": 1, "func": "static int http_server(void)\n\n{\n\n    int server_fd, ret, rtsp_server_fd, delay, delay1;\n\n    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 2], *poll_entry;\n\n    HTTPContext *c, *c_next;\n\n\n\n    server_fd = socket_open_listen(&my_http_addr);\n\n    if (server_fd < 0)\n\n        return -1;\n\n\n\n    rtsp_server_fd = socket_open_listen(&my_rtsp_addr);\n\n    if (rtsp_server_fd < 0)\n\n        return -1;\n\n    \n\n    http_log(\"ffserver started.\\n\");\n\n\n\n    start_children(first_feed);\n\n\n\n    first_http_ctx = NULL;\n\n    nb_connections = 0;\n\n    first_http_ctx = NULL;\n\n\n\n    start_multicast();\n\n\n\n    for(;;) {\n\n        poll_entry = poll_table;\n\n        poll_entry->fd = server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        poll_entry->fd = rtsp_server_fd;\n\n        poll_entry->events = POLLIN;\n\n        poll_entry++;\n\n\n\n        /* wait for events on each HTTP handle */\n\n        c = first_http_ctx;\n\n        delay = 1000;\n\n        while (c != NULL) {\n\n            int fd;\n\n            fd = c->fd;\n\n            switch(c->state) {\n\n            case HTTPSTATE_SEND_HEADER:\n\n            case RTSPSTATE_SEND_REPLY:\n\n            case RTSPSTATE_SEND_PACKET:\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLOUT;\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_SEND_DATA_HEADER:\n\n            case HTTPSTATE_SEND_DATA:\n\n            case HTTPSTATE_SEND_DATA_TRAILER:\n\n                if (!c->is_packetized) {\n\n                    /* for TCP, we output as much as we can (may need to put a limit) */\n\n                    c->poll_entry = poll_entry;\n\n                    poll_entry->fd = fd;\n\n                    poll_entry->events = POLLOUT;\n\n                    poll_entry++;\n\n                } else {\n\n                    /* not strictly correct, but currently cannot add\n\n                       more than one fd in poll entry */\n\n                    delay = 0;\n\n                }\n\n                break;\n\n            case HTTPSTATE_WAIT_REQUEST:\n\n            case HTTPSTATE_RECEIVE_DATA:\n\n            case HTTPSTATE_WAIT_FEED:\n\n            case RTSPSTATE_WAIT_REQUEST:\n\n                /* need to catch errors */\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;/* Maybe this will work */\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_WAIT:\n\n                c->poll_entry = NULL;\n\n                delay1 = compute_send_delay(c);\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            case HTTPSTATE_WAIT_SHORT:\n\n                c->poll_entry = NULL;\n\n                delay1 = 10; /* one tick wait XXX: 10 ms assumed */\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            default:\n\n                c->poll_entry = NULL;\n\n                break;\n\n            }\n\n            c = c->next;\n\n        }\n\n\n\n        /* wait for an event on one connection. We poll at least every\n\n           second to handle timeouts */\n\n        do {\n\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n\n        } while (ret == -1);\n\n        \n\n        cur_time = gettime_ms();\n\n\n\n        if (need_to_start_children) {\n\n            need_to_start_children = 0;\n\n            start_children(first_feed);\n\n        }\n\n\n\n        /* now handle the events */\n\n        for(c = first_http_ctx; c != NULL; c = c_next) {\n\n            c_next = c->next;\n\n            if (handle_connection(c) < 0) {\n\n                /* close and free the connection */\n\n                log_connection(c);\n\n                close_connection(c);\n\n            }\n\n        }\n\n\n\n        poll_entry = poll_table;\n\n        /* new HTTP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(server_fd, 0);\n\n        }\n\n        poll_entry++;\n\n        /* new RTSP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(rtsp_server_fd, 1);\n\n        }\n\n    }\n\n}\n", "idx": 24542, "substitutes": {"server_fd": ["ser_fp", "server_fp", "ser_fn", "server__fn", "erver_d", "server64fp", "server_d", "server_td", "server__fp", "ser_fd", "http_dir", "server_dl", "erver_fd", "server_FD", "server_dir", "server64fn", "erver_fc", "http_td", " server_handler", "server64fd", "server64fc", "erver_dl", "server_fc", " server_dl", "server__fc", "http_FD", "server__fd", "ser_fc", "server_fn", "server_handler", " server_fc", "http_fd"], "ret": ["rec", "run", "status", "rx", "del", "err", " wait", "req", "len", "wa", "done", "gc", "result", "resp", "sleep", "queue", "complete", "fail", "def", "callback", "fun", "sync", "exec", "seq", "sec", "val"], "rtsp_server_fd": ["rtsp_server64fn", "rtsp_server_fn", "rtsp_server64fd", "rtsp_erver_buf", "rtsp_client_fc", "rtsp_server_fin", "rtsp_erver_fn", "rtsp_ser_fd", "rtsp_client_dc", "rtsp_server_fc", "rtsp_erver_fd", "rtsp_server_dc", "rtsp_server_dl", "rtsp_server64fc", "rtsp_server_cb", "rtsp_erver_fc", "rtsp_client_cb", "rtsp_ser_fc", "rtsp_client_handler", "rtsp_ser_fn", "rtsp_server64buf", "rtsp_client_fd", "rtsp_client_dl", "rtsp_server_buf", "rtsp_server_handler", "rtsp_ser_fin"], "delay": ["seed", "nl", "rec", "hide", "status", "live", "rel", "error", "da", "del", "repeat", "mode", "wait", "shift", "req", "shell", "timeout", "send", "dy", "ait", "sel", "wa", "day", "duration", "trial", "rate", "sleep", "mu", "pid", "stay", "skip", "range", "queue", "draw", "lock", "poll", "hold", "fail", "def", "ll", "sync", "dd", "start", "d", "sec", "until", "pause", "load", "dl", "ay", "val", "data", "length"], "delay1": ["delayOne", "wait1", "sleep1", "pauseOne", "sleepOne", "waitOne", "pause1"], "poll_table": ["poll_cache", " poll_course", "server_entry", "pollgtable", "server_table", "pollgentry", "poll_list", "pollallentry", " poll_cache", "pollgcourse", "poll_course", "pollallcourse", "pollgcache", "server_list", "pollallcache", "pollalltable", "server_TABLE", "poll_TABLE"], "poll_entry": ["pollerelement", "polledEntry", "job_Entry", "poll_cell", "pollureenter", "poll_internal", "pollkentry", "pollensee", "pollfgroup", "pollkcell", "llappowner", "pollaciterator", "ll_entry", "oll_entry", "pollacenter", "pollingtry", "search_section", "pollerentry", "poll_term", "job_entry", "pollallenter", "poll_try", "poll_archive", "pollenentry", "llappspec", "pollingelement", "search_element", "live_Entry", "poll_iterator", "pollappelement", "pollureextra", "polledsection", "polledresponse", "oll_exit", "search_response", "pollfno", "pollingsource", "ll_inc", "selectersource", "blocksentry", "exec_entry", "ollksetting", "pollacreader", "pollingenter", "poll_owner", "blockselement", "pollurearchive", "pollerterm", "poll64enter", "pollscell", "exec_see", "pollappentry", "poll_section", "pollallentry", "liveuretry", "pollapptable", "pollsenter", "Poll_global", "pollablery", "exec_argument", "poll_no", "pollacelement", "exec_Entry", "pollenenter", "block_enter", "pollkauthor", "pollacexit", "pollurecomment", "poll_site", "syncerentry", "pollOentry", "ollkentry", "polluretable", "syncerterm", "exec_resource", "sync_element", "sync_reader", "sync_term", "search_group", "poll_source", "pollappsession", "exec_archive", "poll_session", "exec_session", "sync_entry", "search_no", "pollkelement", "pollallreader", "pollertable", "pollersource", "pollappenter", "ollkauthor", "pollappsource", "pollallarchive", "job_source", "Poll_internal", "pollacsource", "pollsentry", "pollallauthor", "poll_group", "poll\u00b7response", "poll_author", "Poll_enter", "pollenelement", "pull_entry", "oll_iterator", "oll_setting", "pollurespec", "polluretry", "poll\u00b7setting", "poll_reader", "polleninner", "pollalliterator", "Poll_entry", "pollappowner", "pollerident", "syncerreader", "liveurecomment", "pollerenter", "pollPterm", "poll_exit", "pollfentry", "oll_site", "poll_see", "poll64Entry", "pollappinc", "pollallresource", "pollallsite", "polloextra", "Poll_table", "job_enter", "pollingentry", "pull_enter", "pollPelement", "poll\u00b7author", "poll_comment", "search_entry", "select_entry", "pollfelement", "poll_element", "pollureentry", "pollallsetting", "ollalliterator", "liveureentry", "pollOident", "pollureinc", "select_source", "Poll_source", "live_comment", "live_entry", "selectertable", "oll_author", "polloentry", "select_table", "search\u00b7response", "pollacentry", "pollkenter", "poll_inner", "pollsauto", "pollacresult", "block_auto", "ll_spec", "poll_extra", "syncerelement", "pollureowner", "searchfno", "poll_argument", " poll_term", "pollingcomment", "poll_spec", "pollPentry", "pollableentry", "pollfterm", "live_try", "liveureEntry", "poll_response", "poll\u00b7entry", "ollksite", "pollableenter", "pollureEntry", "pollacterm", "block_element", "poll_ident", "poll_ry", "searchfelement", "pollerreader", "pollPreader", "blocksenter", "exec_ry", "pollappspec", "pollopackage", "search_Entry", "pull_inner", "blocksauto", "poll\u00b7site", "search\u00b7entry", "poll_resource", "pollksetting", "pollappauto", "exec_enter", "pollureglobal", "pollurepackage", " poll_result", "search\u00b7section", "poll64element", "select_ident", "pollensession", "poll_result", "ll_owner", "poll_Entry", "pollOtable", "poll_enter", "searchfgroup", "pollacglobal", "selecterident", "pollOsource", "polledentry", "oll_reader", "pollksite", "poll_global", "exec_element", "search\u00b7Entry", "pollureresource", "pull_cell", "searchfentry", " poll_element", "ollallreader", "pollerinner", "pollingEntry", "ollallexit", "pollureident", "poll\u00b7section", "pollallexit", "polluresource", "poll_setting", "pollfexit", "pollableargument", "poll64entry", "selecterentry", " poll_source", "llappentry", "pollfreader", "pull_element", "ollallentry", "pollappsee", "pollselement", "pollfiterator", " poll_extra", "poll\u00b7Entry", "block_entry", " poll_package", "llappinc", "poll_auto", "poll_inc", "poll_package"], "c": ["b", "coll", "fc", "dc", "n", "ch", "xc", "sc", "conf", "bc", "cmp", "ca", "nc", "ac", "cc", "cp", "ctx", "r", "mc", "g", "cache", "cv", "l", "v", "h", "conn", "ce", "cf", "t", "enc", "con", "icc", "oc", "vc", "p", "cl", "cs", "ic", "cr", "tc", "cn", "s", "m", "cur", "C", "w", "cm", "ctrl", "rc", "ct", "k", "jc", "e", "exec", "d", "pc", "f", "lc", "ec", "sec", "cb", "co", "cu", "ci", "client", "abc", "cd"], "c_next": ["c__reply", "c_sec", "p_next", "p_new", "c__new", "p_sec", "c_new", "p_reply", "c_reply", "c__sec", "c__next"], "fd": ["dir", "dc", "fs", "dn", "grad", "lf", "socket", "handler", "dd", "DC", "fen", "xd", "ff", "ln", "fb", "buf", "err", "fp", "pid", "conn", "fed", "wd", "enc", "cl", "FD", "fm", "feat", "feed", "bf", "dl", "fa", "fe", "client", "nd", "FH", "cd", "dist", "fc", "sf", "sd", "dial", "wait", "ffff", "timeout", "none", "dra", "dig", "fi", "cf", "did", "draw", "addr", "fn", "pd", "f", "ds", "draft", "dt", "win", "df", "func", "dy", " d", "bd", "poll", "nil", "ld", "md", "db", "loc", "d", "td", "cb", "fx", "wat", "pipe", "length", "fff", "fl"]}}
{"project": "FFmpeg", "commit_id": "f3c0e0bf6f53df0977f3878d4f5cec99dff8de9e", "target": 0, "func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n\n                               const uint8_t *buf, int buf_size,\n\n                               int first_field)\n\n{\n\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n\n    int i, cid, ret;\n\n\n\n    if (buf_size < 0x280)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5)) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"error in header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf[5] & 2) { /* interlaced */\n\n        ctx->cur_field = buf[5] & 1;\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n\n    }\n\n\n\n    ctx->height = AV_RB16(buf + 0x18);\n\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n\n\n    av_dlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height);\n\n\n\n    ctx->is_444 = 0;\n\n    if (buf[0x4] == 0x2) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n\n        }\n\n        ctx->is_444 = 1;\n\n    } else if (buf[0x21] & 0x40) {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n\n        ctx->avctx->bits_per_raw_sample = 10;\n\n        if (ctx->bit_depth != 10) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 10;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n\n        }\n\n    } else {\n\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n\n        ctx->avctx->bits_per_raw_sample = 8;\n\n        if (ctx->bit_depth != 8) {\n\n            ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n\n            ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n\n            ctx->bit_depth = 8;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n\n        }\n\n    }\n\n\n\n    cid = AV_RB32(buf + 0x28);\n\n    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n\n        return ret;\n\n\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ctx->mb_width  = ctx->width >> 4;\n\n    ctx->mb_height = buf[0x16d];\n\n\n\n    av_dlog(ctx->avctx,\n\n            \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);\n\n\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n\n        ctx->height <<= 1;\n\n\n\n    if (ctx->mb_height > 68 ||\n\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR,\n\n               \"mb height too big: %d\\n\", ctx->mb_height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (i = 0; i < ctx->mb_height; i++) {\n\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n\n        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24555, "substitutes": {"ctx": ["scope", "sc", "bc", "id", "ca", "gc", "kw", "Context", "cam", "history", "na", "sync", "co", "cu", "ci", " context", "fw", "coll", "context", "xc", "conf", "nc", "cc", "cp", "cms", "connection", "crit", "window", "conn", "gpu", "cl", "kt", "cs", "conv", "wcs", "c", "pc", "lc", "cli", "qa", "client", "kb", "_", "que", "css", "cmp", "pkg", "ck", "coe", "wx", "cf", "config", "cmd", "cn", "mac", "cm", "cfg", "jp", "utils", "np", "sys", "cpu", "sci", "anc", "hw", "cus", "r", "cv", "cas", "hub", "vc", "act", "tc", "ctrl", "tx", "console", "cca", "loc", "d", "component", "cb", "cpp", "support"], "frame": ["fw", "coll", "context", "que", "cpu", "base", "cmp", "ca", "stack", "window", "game", "image", "flow", "coe", "framework", "cycle", "fp", "conn", "iframe", "cf", "fi", "slice", "config", "range", "kt", "fr", "conv", "buffer", "tx", "cfg", "feat", "Frame", "jp", "setup", "process", "sys", "family", "module", "component", "frames", "val", "thread", "co", "qa", "fram", "buff"], "buf": ["b", "prop", "context", "port", "box", "pb", "cap", "que", "grab", "home", "bc", "vec", "cmp", "aka", "bh", "proc", "func", "text", "fam", "bb", "ctr", "header", "begin", "fd", "rb", "pkg", "wb", "br", "cv", "Buffer", "cas", "auc", "cf", "src", "config", "batch", "queue", "alloc", "bu", "gb", "comb", "exc", "conv", "cmd", "ab", "BU", "broad", "rc", "buffer", "bed", "feat", "loc", "uc", "bag", "seq", "uint", "ha", "img", "msg", "cb", "bf", "data", "uf", "Buff", "pad", "bg", "fb", "buff"], "buf_size": ["buffer_large", "buf_depth", " buf_depth", "buf_SIZE", "buf__SIZE", "buf__length", "buf_length", "buf__size", "buf__depth", " buf_length", "buffer_SIZE", " buf_SIZE", "buffer_size", "buf_large"], "first_field": ["firstofffields", " first_fields", "front_level", "frontOfffield", "firstOfffields", "front_byte", "first_fields", "firstOfffield", " first_window", " first_channel", "firstoffbyte", "first_channel", "firstamchannel", "firstOfflevel", "firstOffbyte", "firstamfields", "frontOfflevel", "first_window", "frontOfffields", "front_field", "firstvelfields", "firstofflevel", "firstamwindow", "front_fields", "first_level", "first_byte", "frontOffbyte", "firstamfield", "firstvelchannel", "firstvelfield", "firstvelwindow", "firstofffield"], "header_prefix": ["extra_pre", "header__prefix", " header_sequence", "extra__pre", "extra_pad", "extra__path", "headeracprefix", "header__pre", "headeracprot", " header_prot", "header_prot", "header_pad", "extra_path", "header__path", "header_sequence", "header_path", "extra__prefix", "extra__pad", "extra_prefix", "header__pad", "headeracsequence", "header_pre"], "header_prefix444": ["header_pattern448", "headeracprefix602", "headeracwrapper448", "header_pointer443", "header_fix555", "header_fix443", "header_fix446", "header_prefix602", "header_index444", "headeracprefix448", "header_prefix443", "header_sequence555", "header_indexCustom", "headeracwrapper602", "header_wrapper448", "header_pointer446", "header_wrapper444", "header_fix444", "header_sequence444", "header_wrapperCustom", "header_prefix555", "headeracprefix444", "header_patternCustom", "header_wrapper602", "headeracwrapper444", "header_sequence446", "header_index602", "header_prefixCustom", "header_pattern602", "header_index448", "header_pointer444", "headeracprefixCustom", "header_prefix446", "header_pointer555", "header_sequence443", "headeracwrapperCustom", "header_prefix448", "header_pattern444"], "i": ["index", "ai", "b", "li", "pi", "base", "id", "j", "iu", "ip", "image", "ti", "io", "fi", "uri", "uni", "p", "di", "I", "ii", "k", "c", "d", "f", "ui", "ci", "ri", "mi"], "cid": ["cnt", "cfid", "cids", "cfids", " cids", " cnt", "ucids", "ucid", "ucnt", "cfnt"], "ret": ["bc", "RET", "std", "flags", "info", "result", "resp", "mem", "rev", "code", "def", "obj", "rc", "buffer", "feat", "desc", "seq", "cb", "aux", "val", "cat", "back", "Ret", "res"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559, "substitutes": {"pval": ["lpval", "Peval", "pVAL", "tVal", "PVal", "speval", "lpvalid", "pvalue", "lpVAL", "peval", "fpvalue", "preval", "Pval", "spvalue", "pvalid", " pVal", "Pdata", "pvals", " pvalid", "tval", "prevalid", "lppol", "spval", "pdata", "Pvals", " peval", " pVAL", "feval", "fpVal", "ppol", "fval", "cvalue", " pdata", "preVAL", "cval", "tvalue", "cdata", " pvalue", "Pvalue", "pVal", "fvalue", "tvals", "spVal", "fpval", "fpvals", " ppol", "cVal", "prepol"], "name": ["alias", "n", "key", "path", "value", "normal", "base", "id", "description", "self", "space", "none", "action", "image", "word", "size", "group", "type", "new", "no", "ref", "part", "named", "style", "config", "version", "label", "on", "code", "nam", "cmd", "address", "prefix", "init", "names", "ame", "Name", "time", "block", "param", "data", "call", "am", "val", "NAME"], "md": ["mp", "dc", "Cmd", "mode", "MD", "req", "managed", "fd", "mem", "sm", "grad", "mb", "ms", "old", "dd", "mag", "mi", "da", "mt", "nt", "add", "amd", "conn", "vd", "node", "pt", "ind", "meta", "ad", "o", "nd", "pm", "cd", "sd", "mid", "self", "od", "hd", "kg", "dr", "ma", "hm", "code", "m", "cmd", "di", "def", "cm", "head", "mand", "amp", "exec", "rm", "pd", "ds", "ng", "data", "mm", "am", "dat", "mod", "dt", "df", "own", " MD", "mc", "dom", "bd", "mo", "dev", "dm", "ld", "db", "doc", "d", "td", "diff", "nm"], "ptr": ["buf", "ext", "port", "pb", "inter", "pair", "proc", "ace", "shift", "req", "sth", "ctr", "fd", "enter", "rb", "coord", "br", "attr", "amd", "dr", "iter", "ref", "slice", "tr", "src", "alloc", "code", "address", "inst", "rc", "buffer", "push", "desc", "addr", "rt", "loc", "pt", "ind", "pc", " pointer", "buff", "Ptr", "td", "val", "mount", "pos", "eth", "adr", "pad", "length", "pointer", "tty", "offset"], "env": ["buf", "dir", "context", "scope", "que", "vm", "vs", "eu", "vel", "state", "nc", "inet", "edge", "net", "environment", "end", "ctx", "len", "size", "cv", "v", "conn", "priv", "oa", "enc", "config", "code", "dev", "exc", "equ", "obj", "ev", "rc", "console", "ct", "db", "addr", "rt", "e", "loc", "ea", "nw", "eni", "ec", "sec", "np", "pos", "iv", "viron", "en", "sys"]}}
{"project": "qemu", "commit_id": "5f9099d9cee0e9ed377aee705ca9f4db75e8948d", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578, "substitutes": {"env": ["engine", "context", "et", "que", "erg", "eu", "conf", "vs", "nc", "bc", "proc", "energy", "environment", "req", "ctx", "gui", "enter", "rb", "cache", "qt", "org", "session", "cv", "esi", "conn", "priv", "enc", "config", "code", "exc", "equ", "iss", "inst", "ev", "init", "ef", "txt", "e", "exec", "eng", "ea", "c", "eni", "ec", "dat", "gov", "np", "viron", "osc", "opt", "en", "here"], "frame_addr": ["thread_address", "frame_address", "frame__ptr", "frame1address", "thread_nr", " frame_address", " frame_ptr", "frame__address", "frame1name", "thread_ptr", " frame_name", "frame1ptr", "frame_ptr", "frame1addr", "frame_nr", "frame__addr", "frame_name", "thread_addr", "frame__nr"], "uc": ["context", "fc", "unc", "un", "uca", "ucc", "soc", "sc", "xc", "bc", "com", "nc", "ac", "cc", "self", "fat", "current", "ou", "lu", "mc", "uu", "auc", "cf", "con", "instance", "config", "oc", "uci", "ub", "util", "tc", "u", "rc", "input", "ct", "um", "this", "exec", "c", "ec", "gnu", "lc", "pc", "ul", "uh", "uf", "usc", "UC", "client", "org", "userc"], "host_set": ["host_read", " host_add", "hostlexadd", "hostaminit", "hostnameset", "host_clear", "host_name", "address_set", "hostnamename", "hostnameadd", "hostamset", "address_store", " host_name", "hostamclear", "hostamSet", "host_init", "auth_clear", "auth_Set", "auth_set", "host_store", "host_add", "hostlexread", "address_add", "host_Set", "hostlexset", "hostlexstore", "auth_init", "address_read"], "regspace": ["regrange", "mempace", "argarray", "regarray", "memrange", "ginarray", "ginrange", "argpace", "argspace", "ginspace", "argrange", "regpace", "ginpace", "memarray", "memspace"]}}
{"project": "qemu", "commit_id": "619d11e4631000f20318dec90b87f314272bfa4a", "target": 0, "func": "FWCfgState *pc_memory_init(MemoryRegion *system_memory,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           ram_addr_t below_4g_mem_size,\n\n                           ram_addr_t above_4g_mem_size,\n\n                           MemoryRegion *rom_memory,\n\n                           MemoryRegion **ram_memory,\n\n                           PcGuestInfo *guest_info)\n\n{\n\n    int linux_boot, i;\n\n    MemoryRegion *ram, *option_rom_mr;\n\n    MemoryRegion *ram_below_4g, *ram_above_4g;\n\n    FWCfgState *fw_cfg;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* Allocate RAM.  We allocate it as a single memory region and use\n\n     * aliases to address portions of it, mostly for backwards compatibility\n\n     * with older qemus that used qemu_ram_alloc().\n\n     */\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"pc.ram\",\n\n                           below_4g_mem_size + above_4g_mem_size);\n\n    vmstate_register_ram_global(ram);\n\n    *ram_memory = ram;\n\n    ram_below_4g = g_malloc(sizeof(*ram_below_4g));\n\n    memory_region_init_alias(ram_below_4g, NULL, \"ram-below-4g\", ram,\n\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n", "idx": 24588, "substitutes": {"system_memory": ["systemalmemory", "system_usage", " system_media", "system_program", "systemalimage", "runtime_image", "system___resource", "runtime_program", "system___usage", "system___memory", "kernel_vm", "kernel_message", "kernel_memory", "system_media", "systemalmessage", "system_resource", "system_image", "kernel_image", "systemalvm", "system___media", "system_global", "system_vm", "runtime_global", "system_message", " system_usage", " system_resource", "runtime_memory"], "kernel_filename": ["kernel_platform", "kernel_directory", "kernellogmemory", "kernelfilesettings", "kernelfilefilename", "kernellogplatform", "kerneldbfile", "kernelockplatform", "kerneldbdirectory", "kernelfiledirectory", "kerneldbfilename", "kernelockfile", "kerneldbsettings", " kernel_file", "kernel_settings", " kernel_platform", " kernel_memory", "kernel_memory", "kernellogfilename", "kernelockmemory", "kernellogfile", " kernel_directory", "kernelockfilename", "kernel_file", "kernelfilefile", " kernel_settings"], "kernel_cmdline": ["kernel_hostline", "kernel_cmdfile", "kernel_hostname", "kernel_bootfile", "kernel_bootline", "kernel_bootstring", "kernel_hostfile", "kernel_commandfile", "kernel_commandstring", "kernel_bootname", "kernel_cmdstring", "kernel_commandname", "kernel_hoststring", "kernel_commandline", "kernel_cmdname"], "initrd_filename": ["initrdtprofile", "initacl_profile", "initrd_profile", "initrdallprofile", "initrdtfilename", "initacl_config", "initrdmatsettings", "initrd_config", "initrdmatconfig", "initrdallfilename", "initaclmatconfig", "initaclmatprofile", "initacl_settings", "initacl_filename", "initrdtsettings", "initrdallconfig", "initrdtconfig", "initrdmatfilename", "initaclmatsettings", "initrdallsettings", "initaclmatfilename", "initrdmatprofile", "initrd_settings"], "below_4g_mem_size": ["below_4g_mem_loc", "below_4g_mem_sum", "below_4g_memory_scale", "below_4g_mem_source", "below_4g_mem\u00b7loc", "below_4g_memssource", "below_4g_memsloc", "below_4g_memory_second", "below_4g_mem_pos", "below_4g_memory_num", "below_4g_memory_name", "below_4g_mem_num", "below_4g_mem\u00b7size", "below_4g_memxscale", "below_4g_memssize", "below_4g_mem\u00b7source", "below_4g_memxrate", "below_4g_memxsize", "below_4g_memory_rate", "below_4g_mem_scale", "below_4g_memory_size", "below_4g_mem_second", "below_4g_memory_sum", "below_4g_memory_pos", "below_4g_mem_rate", "below_4g_mem_name"], "above_4g_mem_size": ["above_4g_mem2address", "above_4g_mem_address", "above_4g_mem_capacity", "above_4g_mem1size", "above_4g_mem2size", "above_4g_mem2offset", "above_4g_memnaddress", "above_4g_memory_sum", "above_4g_memory_capacity", "above_4g_mem_name", "above_4g_mem1num", "above_4g_mem_sum", "above_4g_memory_offset", "above_4g_mem_scale", "above_4g_mem_speed", "above_4g_mem1name", "above_4g_memory_speed", "above_4g_mem_offset", "above_4g_mem_num", "above_4g_memory_num", "above_4g_memnsize", "above_4g_memory_scale", "above_4g_memory_address", "above_4g_memory_name", "above_4g_memnoffset", "above_4g_memory_size"], "rom_memory": ["ram_size", "drm_ram", "rom_manager", "drm_mem", "rom___size", "rom_size", "drm_memory", "rom___mem", "rom_mem", "drm_manager", "rom___memory", "rom_ram", "ram_mem", "rom___mobile", "rom_mobile", "ram_mobile"], "ram_memory": ["ram_region", "ram_config", "ram_description", "rom_mem", "gram_description", "gram_cache", "rom_config", "gram_mem", "ramallregion", "ram_mem", "gram_memory", "ram_cache", "ramallmem", "rom_region", "ramallmemory", "ramallconfig"], "guest_info": ["guess_manager", "guest_hand", "guesterinfo", "guest_conf", "guestermanager", "guest_manager", "guess_Info", "guess_hand", "guest_Info", "guesterhand", "guess_conf", "guess_info"], "linux_boot": ["linux_disk", "linux01connection", "linux67disk", "linux67config", "linux_connection", "linux_init", " linux_disk", " linux_connection", "linux__connection", "linux01boot", "linux67mount", "linux_config", "linux__boot", " linux_config", "linux67boot", " linux_mount", "linux01init", "linux01config", "linux__config", " linux_init", "linux_mount", "linux__init"], "i": ["b", "li", "in", "n", "pi", "j", "info", "r", "ip", "g", "image", "ix", "io", "ib", "ini", "instance", "p", "m", "I", "mac", "ii", "init", "c", "cli", "ui", "ci", "ni", "im"], "ram": ["disk", "array", "ra", "remote", "gra", "vm", "win", "gem", "Ram", "mode", "rame", "RM", "program", "mx", "AM", "row", "jam", "image", "mc", "dim", "lam", "max", "amd", "mem", "rom", "resource", "raw", "sam", "null", "range", "cam", "config", "instance", "container", "scan", "pass", "arm", "man", "nam", "yan", "address", "broad", "mac", "machine", "buffer", "cm", "gam", "gram", "region", "iam", "process", "media", "RAM", "param", "module", "sim", "mor", "img", "RGB", "MM", "mm", "am", "ray", "mount", "memory", "rum", "micro", "rw", "sum"], "option_rom_mr": ["option_ram_mr", "option_rom__rr", "option_rom__mr", "option_rom_", "option_mem_", "option_mem\n", "option_rom__dr", "option_rome_", "option_ram_rr", "option_rom\n", "option_rm\n", "option_ram_rm", "option_rom_dr", "option_rm_", "option_rom_lr", "option_rom_rr", "option_rom_rm", "option_ram_dr", "option_rom__lr", "option_rom_nr", "option_rome\n", "option_ram_lr", "option_ram_nr"], "ram_below_4g": ["ram_below_fourgen", "ram_below_4gg", "ram_below_04d", "ram_below_4gm", "ram_below_fourg", "ram_below_40gg", "ram_below_5gm", "ram_below_fourG", "ram_below_40gen", "ram_below_04G", "ram_below_8gg", "ram_below_114gs", "ram_below_5G", "ram_below_8g", "ram_below_40G", "ram_below_04gs", "ram_below_24G", "ram_below_24g", "ram_below_40gs", "ram_below_114gg", "ram_below_40g", "ram_below_2g", "ram_below_8gm", "ram_below_2G", "ram_below_2gen", "ram_below_8d", "ram_below_114gu", "ram_below_4gs", "ram_below_2gs", "ram_below_8G", "ram_below_4d", "ram_below_24gu", "ram_below_4gu", "ram_below_8gs", "ram_below_24gs", "ram_below_8gu", "ram_below_04g", "ram_below_164gg", "ram_below_164g", "ram_below_40gu", "ram_below_164G", "ram_below_40d", "ram_below_4G", "ram_below_fourgs", "ram_below_5gg", "ram_below_4gen", "ram_below_5g", "ram_below_114g", "ram_below_04gu", "ram_below_164gm"], "ram_above_4g": ["ram_above_64gh", "ram_above_256b", "ram_above_8gu", "ram_above_9eg", "ram_above_29l", "ram_above_64g", "ram_above_256gu", "ram_above_4l", "ram_above_29s", "ram_above_fours", "ram_above_4n", "ram_aboveMfours", "ram_above_04d", "ram_above_5n", "ram_above_40g", "ram_above_9ga", "ram_above_40eg", "ram_above_4gh", "ram_above_5g", "ram_above_04gu", "ram_above_04G", "ram_above_fourl", "ram_above_04g", "ram_above_40d", "ram_above_40gas", "ram_above_8gh", "ram_above_8G", "ram_above_04gs", "ram_above_29g", "ram_above_4eg", "ram_above_40ga", "ram_above_8s", "ram_above_29gu", "ram_above_04gas", "ram_above_04eg", "ram_aboveMfourg", "ram_above_4gs", "ram_above_04n", "ram_above_8n", "ram_above_40G", "ram_above_8gs", "ram_above_504d", "ram_above_504gu", "ram_above_40gu", "ram_above_9g", "ram_aboveM4gu", "ram_above_8g", "ram_above_504gas", "ram_above_fourgu", "ram_above_64b", "ram_above_4gu", "ram_aboveMfourl", "ram_above_64gu", "ram_above_4ga", "ram_above_504g", "ram_above_fourg", "ram_aboveM4l", "ram_above_256g", "ram_aboveMfourgu", "ram_above_4s", "ram_above_04ga", "ram_above_4G", "ram_above_4gas", "ram_above_4d", "ram_above_9G", "ram_aboveM4s", "ram_above_5G", "ram_above_8l", "ram_above_8b", "ram_above_256gh", "ram_above_5gs", "ram_aboveM4g", "ram_above_4b"], "fw_cfg": ["fw_config", "fw_state", "fwjstates", "fwjconfig", "FW_cfg", "fwjstate", "FW_config", "FW_states", "fwjcfg", "fw_states", "FW_state"]}}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603, "substitutes": {"vs": ["ents", "qs", "css", "conf", "env", "vers", "sv", "state", "gs", "events", "http", "os", "rs", "vp", "VS", "sb", "verts", "fs", "bs", "obs", "ps", "ys", "cv", "ts", "vas", "v", "ks", "las", "sk", "vc", "ves", "vals", "cs", "s", "acs", "alls", "ums", "ms", "ns", "forces", "ss", "xs", "ls", "ds", "va", "services", "views", "uses", "plugins", "ses", "sys", "stats"], "keysym": ["typessym", " Keysyn", "keysyn", " keyscm", " Keyssym", " keysy", "keysy", "typesyn", "Keysym", "typesym", " Keysym", "keyscm", "typescm", "Keysy", "typesys", "typesy", "typesem", "Keysem", "keysys", "keysem", " keysyn", " Keyscm", " keyssym", " keysem", " keysys", "keyssym", "Keysys"]}}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static void s390_virtio_device_sync(VirtIOS390Device *dev)\n\n{\n\n    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    ram_addr_t cur_offs;\n\n    uint8_t num_vq;\n\n    int i;\n\n\n\n    virtio_reset(dev->vdev);\n\n\n\n    /* Sync dev space */\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);\n\n\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n", "idx": 24606, "substitutes": {"dev": ["dc", "home", "driver", "req", "result", "gd", "ver", "cam", "pro", "ev", "device", "comment", "block", "dd", "adv", "user", "conf", "gh", "debug", "valid", "end", "rad", "info", "flow", "conn", "wd", "container", "plug", "die", "img", "api", "ad", "client", "error", "self", "ow", "od", "lib", "test", "av", "non", "ov", "model", "DEV", "root", "config", "app", "cmd", "di", "def", "pub", "w", "bug", "data", "server", "reg", "engine", "mod", "dt", "ch", "der", "game", "dom", "serial", "controller", "v", "hub", "pack", "nov", "de", "md", "Dev", "kick", "var", "gu", "d", "diff"], "bus": ["b", "dir", "engine", "buf", "loop", "port", "path", "ch", "conf", "driver", "bc", "id", "http", "proc", "self", "connection", "lib", "board", "cache", " BUS", "session", "Bus", "boot", "serial", "io", "hub", "BUS", "config", "pass", "lock", "def", "bug", "device", "plug", "db", "feed", "block", "sync", "bridge", "gen", "cat", "mount", "usb", "back", "use", "bit", "us"], "cur_offs": [" cur_sticks", " cur_asks", "cur_off", " cur_works", "curPtips", " cur_roots", " cur_sets", "cur_works", "cur_sticks", " cur_opens", "cur67off", " cur_off", "curPoff", " cur_times", "cur_sets", "curPsticks", "curProots", "cur67offs", "cur_asks", "curPopens", "cur_tips", "cur67roots", "cur_times", "cur_roots", "cur_opens", "cur67sticks", " cur_tips", "curPoffs"], "num_vq": ["num_hz", "num_vue", "numLvoltq", "num_cvquad", "num_vid", "num_lqs", "num_vqq", "num_xq", "num_sviq", "num_vquad", "num_vcid", "num_aviq", "numOfvz", "num_lqq", "num_vqs", "num_vqi", "numOfvaqs", "num_uvid", "num_cvqs", "numLvoltqi", "numOfvq", "num_voltqi", "num_uq", "numOfvquad", "num_hquad", "num_vcqu", "numacvq", "num_uvqu", "num_liq", "num_cvz", "num_evqu", "numOfvqs", "numOfvaq", "num_avqs", "numacuqu", "num_vaq", "num_viq", "num_pqu", "num_fq", "num_xqu", "num_vaqs", "num_vz", "num_voltq", "num_voltqu", "num_vaquad", "num_vcq", "numOfvaquad", "numacvsq", "numLvq", "num_lqu", "num_uvq", "numacuid", "num_hq", "num_vaz", "num_pue", "num_vcsq", "num_uqu", "num_fue", "num_avqq", "num_uvsq", "num_hqs", "num_svq", "num_uid", "num_vQ", "num_fQ", "num_lq", "numacvqu", "numOfvaz", "num_evqi", "num_lqi", "numacusq", "num_fqu", "num_xQ", "num_pq", "numLvqu", "num_vsq", "numacuq", "numLvqi", "num_evq", "num_avq", "num_pQ", "num_svqs", "num_usq", "num_vqu", "num_xue", "numLvoltqu", "numacvid", "num_cvq", "num_svqq"], "i": ["ai", "index", "mini", "x", "b", "li", "pi", "n", "z", "id", "j", "end", "yi", "info", "r", "iu", "ip", "hi", "ix", "type", "gi", "ri", "bi", "l", "ti", "v", "fi", "mu", "slice", "y", "uri", "xi", "ini", "name", "multi", "p", "qi", "zi", "m", "di", "I", "t", "chi", "u", "ski", "it", "ii", "k", "si", "gu", "c", "uli", "d", "sup", "eni", "f", "e", "api", "ui", "phi", "ci", "o", "ni", "ji", "ki", "mi"], "vring": ["quro", "versionsetting", "quray", "versionring", "nvstring", "vmring", "quring", "vmray", "svding", "jrings", "svray", "svsetting", "bray", "vmro", "fstring", "fpc", "jring", "qray", "vining", "mring", "nvq", "vmry", "jining", "svring", "bring", "versionray", " vining", "bining", "qro", "mpc", "vq", "mstring", "vro", "vsetting", "qry", "jray", "fq", "versionding", " vray", "vpc", "vstring", "vray", " vding", "vry", "vding", "qring", "fring", " vsetting", "nvring", "nvpc", "brings", "qury", "mq", "vrings", " vrings"]}}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n", "idx": 24621, "substitutes": {"_src": ["_rc", "_dest", " _source", " _rc", "_img", "_usc", "_source", " _dest", " _img", " _usc"], "stride": ["arriden", "strride", "strided", "dride", "Strider", "arride", " strided", "striided", "Strides", " strine", "drid", "strides", "arrider", "strid", "strider", "strIDE", " strension", "Striden", "striace", "hrided", "slension", "drided", " strid", "divider", "divIDE", "dividen", "drine", " strides", "strace", "Stride", "bride", "brider", "brided", "hrine", "divided", " strace", "StrIDE", "slided", "hrride", "brace", " strider", "drider", "strine", "Strided", "brine", "Strension", "hrance", "stided", "brance", "slIDE", "slides", "strance", "hrider", "brride", " straine", "staine", "draine", "stide", "straine", "striider", "divide", "arrided", " strance", "strension", "stine", "Strid", "striide", "hride", "slider", "slide", "striden"], "i": ["ai", "x", "index", "oi", "li", "pi", "in", "ie", "ji", "z", "id", "j", "me", "anti", "info", "r", "iu", "ip", "hi", "g", "ix", "gi", "bi", "is", "l", "v", "ti", "io", "fi", "y", "slice", "uri", "xi", "ini", "mu", "multi", "p", "qi", "zi", "m", "di", "I", "s", "u", "it", "init", "ii", "my", "si", "e", "c", "d", "eni", "f", "ami", "cli", "ori", "ui", "phi", "ci", "vi", "o", "ni", "ri", "ir", "mi"], "dc0": ["ac2", "DC4", "rc2", "cd50", "mc50", "nc1", "DCfe", "dc000", "cd8", "dc50", "disc00", "cd0", "dcfe", "disc000", "mc4", " dc1", "nc18", " dc50", "c18", "disc2", "ac000", "dc4", " dcfe", " dc18", "DC00", "dc8", "rc50", "ac00", "mc8", "rcfe", "c3", "DC0", "cd4", "DC000", "dc18", "rc0", "nc3", "dc00", "c0", "ac0", " dc3", "disc0", "dc3", "dc1", "nc0", "DC50", "DC8", "mc0", "c1", "DC2"], "dc2": ["dcTwo", "circ2", "DC4", "rc2", " dc256", "fc6", "lc0", "lc1", "cd1", "DCTwo", "dctwo", "c6", "ctwo", " dc4", "circTwo", "lc2", "cdtwo", "DC02", "dc4", "dc02", "c02", "cd2", "rc1", "DC1", "DC0", "circ256", "rc4", "DCtwo", "lctwo", "c0", "fctwo", "DC256", "c4", "rc02", "dc256", "dc6", "fc1", "dc1", " dcTwo", "cd6", "c1", "circ4", "DC2", "fc2", "c2"], "dc0splat": ["dc00splAT", "dc0platch", "dc0ppater", "dc0spland", "dc0plats", "dc2plat", "dc0Splat", "dc0splater", "dc2splatch", "dc0plAT", "dc0splAT", "dc1splAT", "dc0plugand", "dc00PlAT", "dc0plit", "dc0Splatch", "dc0Spland", "dc1splat", "dc1SplAT", "dc0splats", "dc0ppat", "dc0spAT", "dc0plat", "dc1splatter", "dc0splatter", "dc0splitatter", "dc0spats", "dc0splitat", "dc0SplAT", "dc2spland", "dc0plugatch", "dc2platch", "dc0spat", "dc0Plats", "dc00Plats", "dc0Plit", "dc0split", "dc0plugit", "dc0Plat", "dc0ppatter", "dc00splats", "dc0Splatter", "dc0splatch", "dc2plit", "dc1Splater", "dc2split", "dc1Splatter", "dc0ppAT", "dc0Splater", "dc0spit", "dc0pland", "dc00Plit", "dc0splitater", "dc0Split", "dc0splitAT", "dc0plugat", "dc1Splat", "dc00splat", "dc2pland", "dc00split", "dc00Plat", "dc0PlAT", "dc1splater"], "dc2splat": ["dc2slAT", "dc4split", "dc2plat", "dc2SplAT", "dc4splAT", "dc4plat", "dc0plAT", "dc0splAT", "dc1splAT", "dc1Split", "dc0plit", "dc2splAT", "dc1splat", "dc1SplAT", "dc2slit", "dc0plat", "dc4plare", "dc2Spland", "dc2islAT", "dc2splare", "dc4splare", "dc2Splat", "dc0split", "dc4plit", "dc1Spland", "dc2slat", "dc1spland", "dc2plar", "dc2splar", "dc1split", "dc2plit", "dc2split", "dc0plar", "dc4splat", "dc0splar", "dc2Split", "dc2islat", "dc4plAT", "dc2Splar", "dc2Splare", "dc2islare", "dc2slar", "dc1Splat", "dc2islit", "dc2pland", "dc2plare", "dc2spland", "dc2plAT"], "src": ["rect", "fc", "sr", "sl", "dc", "remote", "rin", "sc", "rib", "http", "source", "proc", "scene", "rs", "supp", "text", "lib", "https", "sb", "secure", "sel", "r", "host", "rb", "image", "size", "transform", "resource", "url", "uri", "stream", "config", "rest", "gb", "core", "rl", "chrom", "channel", "inst", "sit", "rss", "rc", "input", "feat", "scale", "camera", "loc", "sup", "sync", "pixel", "c", "img", "cb", "spec", "component", "cli", "ci", "dest", "iv", "usc", "obl", "st", "RC", "scl", "support", "impl", "cur"]}}
{"project": "FFmpeg", "commit_id": "48aecf5a7dd8e914d44cb4210a09172dbd8d5d86", "target": 1, "func": "static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n", "idx": 24625, "substitutes": {"poutbuf": ["pallbuf", "pouport", "pOutcb", "pantbuf", " pallbuff", "pintbuf", "punuf", "poutvec", "pouttab", "pupbuffer", "pouterimg", "ipoffbox", "poutbox", "pupbr", "pexbuff", "poutrb", " poutrb", " pallbuf", "lexbuf", "pbootbr", " poutvec", "puncb", "ipoutport", "poutervec", "poutflo", "pupimg", "poutuf", "loutbuf", "lexrb", "pintbuff", "painbuf", " pOutbag", "poutimg", "pOutbag", " poutbag", "pbootbag", "poutport", "painbuffer", " poutflo", "lexuf", "punbuf", "pupport", "poutingflo", " pupbuf", " poutbuffer", "poutcb", "pdownvec", "ipoffvec", "pallbuff", "pdownbuff", "pbootcb", "poffbuf", "pintrb", "pexbuf", "poutcf", "poutingbu", " pouttab", "pdownbuf", " poutcb", "pOutbr", "pupvec", "puptab", " poutuf", " pOutbuf", "puntab", "pintuf", "pupbox", "poutingbuf", "pouterbuffer", "pdowncf", "pOutbuffer", "poutingrb", "poubuf", "pantrb", "pexuf", " poutbuff", "painbuff", "poubox", "pdowncv", "loutuf", " pOutbr", " poutport", " poutcv", "loutbuff", "poutbuffer", "pupcv", "poffbox", " pOutbuff", "ipoffport", "pupbuf", "pouterbuff", "pOutbuff", "pupbuff", "pantbu", "ipoutvec", "pupuf", "poffport", "poutbuff", "ipoffbuf", "pupcb", "pbootbuf", "poutbag", " pupvec", " pOutbuffer", "pupbag", " pOutcb", "pdownport", "pallvec", "pallport", " poutcf", " pupcf", "pantflo", " poutimg", "pOutbuf", "ipoutbox", "poutercf", " poutbr", "poutbu", " poutbu", " pallvec", "paincb", "poutcv", "loutrb", " pallport", "pouvec", "poutercv", "pexrb", "pouterbuf", "poutbr", " pupcv", "ipoutbuf", "pupcf", "poffvec", "lexbuff"], "poutbuf_size": ["poutbuf_small", "poutbuf_scale", "poutbuf_loc", "poutbuf_capacity", "poutbuf_max"], "sps_pps": ["spse_ppo", "spse___ppo", "sps__ops", "sps_pp", "sps___pps", "sps__pp", "sps__dds", "sps___pp", "sips_pps", "sps__pps", "spse_pp", "sips_ops", "sps_ppa", "spse___pps", "sps_dds", "sips_params", "sps___ppo", "sps_ppo", "sps__ppo", "sips_pp", "spse_pps", "sps___dds", "sips_ppa", "spse_dds", "spse___dds", "sps_params", "spse___pp", "sps_ops", "sps__params"], "sps_pps_size": ["sps_pps_small", "sps_ps_small", "sps_pps_num", "sps_pps_offset", "sps_ps_offset", "sps_ps_ize", "sps_ppa_core", "sps_pps_core", "sps_ps_c", "sps_pps_ize", "sps_ps_num", "sps_ppa_small", "sps_pps_c", "sps_ppa_size", "sps_ps_size"], "in": ["index", "x", "isin", "nin", "win", "inside", "id", "inn", "ac", "margin", "inf", "end", "include", "current", "In", "image", "inas", "IN", "new", "url", "before", "ins", "p", "m", "amin", "into", "input", "time", "e", "inc", "i", "min", "out", "o", "a", "bin", "at", "as"], "in_size": ["invalcapacity", "in_length", "in_storage", " in_storage", "invalsize", "out_scale", "plan_bytes", "in64bytes", "in96size", "planvalbytes", "planvalcapacity", "out_size", "invalbytes", "in64length", "in_capacity", "in96length", " in_scale", "in64capacity", "plan_length", "in64size", "planvalsize", "in_bytes", "plan_size", "in96scale", "in_scale", "plan_capacity", "invallength", "planvallength", "out_length"]}}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n", "idx": 24626, "substitutes": {"ctx": ["console", "context", "scope", "fc", "dc", "xc", "sci", "sc", "conf", "bc", "cmp", "ca", "anc", "handler", "nc", "cc", "cp", "cy", "connection", "hw", "crit", "pkg", "gc", "mc", "cv", "kw", "conn", "cf", "Context", "config", "cl", "vc", "core", "cs", "conv", "cmd", "cn", "tc", "cm", "tx", "cfg", "ctrl", "ct", "acl", "jp", "cca", "utils", "loc", "exec", "c", "git", "sync", "module", "pc", "lc", "cli", "component", "cb", "cu", "ci", "np", "qa", "cdn", "client", "chan"], "e": ["x", "E", "n", "ed", "ie", "eu", "j", "source", "edge", "er", "end", "none", "ne", "r", "g", "esi", "ae", "es", "l", "v", "y", "h", "ce", "be", "pe", "p", "ee", "m", "eg", "ev", "de", "w", "eve", "u", "el", "exec", "c", "ea", "element", "d", "ec", "eps", "f", "i", "event", "fe", "xe", "le", "o", "ei", "se", "entity", "oe"], "io_notify": ["io_nine", "io_signification", "io_disifier", "io_navificate", "io_disification", "io_nonifier", "io_notine", "io_notification", "io_verifier", "io_navish", "io_noten", "io_failpire", "io_Notificate", "io_Notify", "io_disen", "io_nify", "io_notate", "io_nen", "io_nification", "io_failen", "io_navify", "io_nate", "io_notifier", "io_notificate", "io_nonificate", "io_verify", "io_signpire", "io_signine", "io_signate", "io_notpire", "io_navifier", "io_notish", "io_verate", "io_failifier", "io_signify", "io_nifier", "io_failify", "io_npire", "io_nonish", "io_signifier", "io_failification", "io_Notish", "io_verine", "io_disify", "io_Notifier", "io_nonify"], "io_flush": ["io_clear", "auto_flush", "io_lock", "io__lock", " io_flow", "io__clear", " io_clear", " io__flush", "io_sync", " io_flash", "io__flow", "io_flow", "iofsend", " io_send", "io\u00b7sync", "io\u00b7clear", " io__flow", "io\u00b7lock", "auto_close", "io\u00b7send", "io__flush", " io_sync", "io\u00b7flow", "io_send", "iofflush", "iofclose", "auto_send", " io_lock", " io__lock", "iofsync", "io_flash", " io__clear", "auto_sync", "io\u00b7flush", "io\u00b7flash", "io_close"], "node": ["seed", "remote", "child", "id", "function", "ne", "g", "new", "instance", "inner", "core", "comment", "handler", "view", "block", "wh", "document", "cdn", "name", "holder", "post", "ode", "native", "n", "key", "path", "parent", "live", "edge", "N", "huge", "writer", "connection", "Node", "host", "open", "enc", "parse", "obj", "callback", "nn", "c", "event", "o", "slave", "index", "cmp", "note", "message", "self", "od", "loader", "none", "op", "leaf", "graph", "root", "no", "master", "location", "resource", "query", "null", "empty", "route", "stage", "peer", "hop", "target", "fn", "module", "gen", "call", "server", "source", "ko", "storage", "hub", "nil", "one", "package", "local", "missing", "nw", "loc", "component", "cb", "object", "tree", "load", "content"]}}
{"project": "FFmpeg", "commit_id": "40ad05bab206c932a32171d45581080c914b06ec", "target": 0, "func": "int float_near_ulp(float a, float b, unsigned max_ulp)\n\n{\n\n    union av_intfloat32 x, y;\n\n\n\n    x.f = a;\n\n    y.f = b;\n\n\n\n    if (is_negative(x) != is_negative(y)) {\n\n        // handle -0.0 == +0.0\n\n        return a == b;\n\n    }\n\n\n\n    if (abs(x.i - y.i) <= max_ulp)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n", "idx": 24629, "substitutes": {"a": ["ai", "n", "aa", "alpha", "A", "ac", "ia", "ba", "ae", "l", "sa", "as", "au", "ma", "area", "p", "ab", "asa", "u", "ar", "na", "an", "e", "c", "ea", "d", "i", "f", "fa", "va", "am", "at", "pa"], "b": ["abb", "n", "base", "nb", "j", "bb", "sb", "r", "ba", "bs", "rb", "g", "wb", "bi", "l", "v", "be", "ib", "bd", "p", "xb", "ub", "ab", "eb", "k", "e", "c", "bp", "i", "f", "cb", "lb", "o", "B", "fb"], "max_ulp": [" max_imp", " max_early", "max_zip", " max_fp", "maxFulp", " max_pull", "max_fp", "max_imp", "max_early", " max_zip", "maxFfp", "max_pull", "maxFimp", "maxFearly"], "x": ["n", "rx", "z", "xxx", "ax", "X", "g", "ix", "px", "l", "v", "h", "wx", "xi", "cross", "p", "xx", "m", "one", "u", "w", "ex", "xy", "tx", "dx", "an", "e", "c", "d", "i", "xs", "f", "fx", "ci", "ad", "o"], "y": ["oy", "vy", "Y", "n", "ny", "z", "j", "cy", "dy", "bb", "yi", "type", "ys", "yo", "v", "h", "ym", "p", "yt", "t", "u", "w", "xy", "ii", "zy", "e", "c", "ey", "d", "i", "f", "ya", "ay", "iy", "yy", "o", "ry", "ty"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}", "idx": 24631, "substitutes": {"avctx": ["evctl", "evconn", "AVcas", "AVlc", "avdc", "vercit", " avcv", "ajcit", "camconn", " avconn", "aveconn", " avcontext", "afctrl", "avectx", "avalctrl", "avalcontext", "afcontext", " avloc", "AVgc", "avecontext", "AVloc", "avalctx", "avecv", "navcas", "ajcontext", "avca", "AVctl", "afgc", "avaldc", "vercmp", "avecca", "versync", "ajconn", "verconn", "AVconn", "AVsync", "verlc", "camctx", "AVcoll", "avctl", "verctrl", "verctx", "afca", "avalgc", " avcmp", " avcoll", "avcv", "avgc", "evcontext", "aveca", "avallc", "afctx", "avconn", "avcit", "avsync", "AVcca", "AVcit", "afsync", "navctrl", "AVdc", "AVcontext", "avctrl", " avca", "avcoll", "evctx", "avcmp", "ajctx", "aflc", "avlc", "avecoll", "navctx", "camctl", "vercontext", "AVctrl", "camcontext", "avcas", "afcv", "afcmp", "averctrl", "averctx", "avcontext", "avalcca", "avcca", "navcontext", " avctrl", "avercontext", "avedc", "avloc", "avalloc", "avercas", "AVctx"], "context": ["index", "network", "scope", "database", "general", "parser", "path", "parent", "sc", "driver", "kernel", "anc", "ca", "stack", "metadata", "connection", "text", "ctx", "current", "cache", "result", "reader", "resource", "ce", "Context", "config", "instance", "manager", "container", "channel", "package", "address", "subject", "buffer", "input", "acl", "definition", "component", "object", "aux", "document", "data", "event", "qa", "memory", "concept", "support"]}}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648, "substitutes": {"cs": ["css", "qs", "sc", "cing", "cmp", "ca", "nc", "cc", "cms", "rs", "ctx", "CS", "cus", "fs", "ced", "ocr", "ix", "cks", "ics", "ps", "cas", "ks", "cf", "ce", "sk", "ras", "vc", "gb", "core", "cn", "wcs", "acs", "ns", "sync", "c", "cons", "ec", "pc", "lc", "ls", "spec", "ds", "ci", "ces", "sys"], "fdt": ["vdt", "vdit", "fedt", "vdta", "FDt", "FDte", "dfd", "lfit", "dltm", "fdd", "dln", "dfta", "FDtm", "FDn", "dfit", "fedtm", "lfta", "fedte", "vdd", "dlte", "lfd", "lft", "dlt", "fdte", "fdit", "dft", "fdta", "fdn", "fedn", "fdtm"], "offset": ["index", "reset", "alias", "set", "align", "error", "phase", "slot", "shift", "end", "timeout", "Offset", "len", "position", "size", "location", "slice", "part", "off", "range", "origin", "initial", "address", "prefix", "addr", "loc", "limit", "start", "padding", "f", "delay", "output", "pos", "o", "length"], "spapr": ["spaper", "spappr", "scapl", "pAPn", "spAPr", "papR", "spapel", "spapsl", "spapl", "scapsR", "spagn", "spappR", "spappn", "scapsl", "spAPR", "papr", "spaprs", "spapn", "spAPrs", "pAPr", "spapsR", "spagr", "scapsr", "spagR", "spapsr", "spapprs", "paprs", "spAPn", "papn", "spapR", "pAPR", "pAPrs", "spapeR", "spagrs", "scapr", "spAPl", "scapR"], "cpu": ["platform", "gp", "fc", "dc", "vm", "proxy", "bc", "pu", "cmp", "nc", "proc", "cc", "cp", "loader", "hw", "ctx", "prem", "CP", "cache", "coe", "px", "nic", "boot", "conn", "gpu", "roc", "config", "instance", "frame", "processor", "core", "uci", "cn", "unit", "socket", "device", "process", "node", "sync", "c", "linux", "clock", "CPU", "GPU", "pc", "lc", "component", "lb", "pai", "np", "chip", " CPU"], "env": ["dir", "scope", "path", "conf", "energy", "eu", "err", "state", "visor", "esp", "environment", "shell", "gui", "exe", "cv", "estate", "style", "enc", "config", "core", "exc", "equ", "args", "profile", "ev", "ef", "desc", "export", "e", "ea", "eni", "ec", "np", "dest", "viron", "opt", "en", "skin", "ext"], "pcc": ["Pcc", "PCC", "pcca", " pcca", "jpcc", "pck", "Pcca", " pck", " pCC", "jpCC", "jpcca", "Pck", "jpck", "pCC"], "segs": ["mega", "pega", "perseg", "sega", "megs", "pegs", "megments", "persegments", "meg", "pegments", "persegs", "persega", "peg", "segments", "seg"], "page_sizes_prop": ["page_sizesingprop", "page_sizesingattr", "page_size_prop", "page_size_Prop", "page_sizesingProp", "page_size_attr", "page_sizes_Prop", "page_sizes_attr"], "page_sizes_prop_size": ["page_sizes_prop_length", "page_sizes_prop64size", "page_sizes_prop642", "page_sizes_Prop_max", "page_sizes_prop_max", "page_sizes_Prop_length", "page_sizes_prop64length", "page_sizes_prop64max", "page_sizes_Prop_size", "page_sizes_prop_2", "page_sizes_Prop_2"], "pft_size_prop": ["pft_sec_prop", "pft_sec_opt", "pft_size_cp", "pft_size_opt", "pft_sizeallcomp", "pft_sec_comp", "pft_size_comp", "pft_sizeallprop", "pft_sizeallcp", "pft_sec_cp", "pft_sizeallopt"], "drc": ["ldRC", " dRC", "Drc", "ddc", "dirc", "bdsc", "dsc", "drec", "adrec", "ldbc", "ldrc", "dsrc", "dbc", "bdrc", "DRC", "dRC", "bdc", "bdrec", " dirc", " dsrc", "Ddc", "bdsrc", "Dbc", "Dirc", "bdRC", " drec", " dbc", "lddc", "adsrc", "bRC", "bsrc", "adirc", "ldsrc", "brc", "adbc", "Dsrc", "adrc", "bdbc", "adsc", " dsc", "adRC"], "drck": ["Drk", "errck", "drk", " drkk", "Drck", "mirkk", "Drct", "mirck", "derce", "mircus", "drrick", " drok", "drcc", "rrcc", "errcc", "drkk", " drce", "derrick", "derok", " drcc", "rrck", " drct", "errcus", "drok", "dercc", "mircc", " drrick", "derck", " drk", "rrok", "rrrick", "errkk", "drct", "drcus", "Drce", "derct", " drcus", "derk", "drce"], "drc_index": ["drcxid", "dsrc_index", "dxc_len", "drc64label", "drc__label", "dsrc_i", "dxcxindex", "dsrc_label", "dxc_index", "drcxindex", "drc_len", "drcxlen", "drcxnum", "drc_num", "dRC_Index", "drc__position", "dsrc_position", "dxcxnum", "dRC_id", "drc__i", "dxcxlen", "dxc_num", "drc_i", "drc_id", "drc_Index", "drc_label", "drc__index", "drc64position", "dxc_id", "drc_position", "dRC_index", "drc64index", "dxcxid", "drc64i"], "radix_AP_encodings": ["radix_max_encoderINGS", "radix_max_encODINGS", "radix_max_ENCODINGS", "radix_max_encoding", "radix_max_encodering", "radix_max_ENCODings", "radix_max_encODing", "radix_max_ENCODers", "radix_max_ENCodings", "radix_max_encodesers", "radix_max_encODers", "radix_max_encodesINGS", "radix_max_ENCodINGS", "radix_max_encodesing", "radix_max_encoderings", "radix_max_encodINGS", "radix_max_ENCODing", "radix_max_ENCoding", "radix_max_encodings", "radix_max_encoders", "radix_max_encODings", "radix_max_encoderers", "radix_max_encodesings", "radix_max_ENCoders"], "i": ["b", "pi", "n", "z", "id", "j", "abi", "interface", "iu", "ip", "bi", "is", "l", "ti", "multi", "p", "qi", "I", "it", "ii", "si", "e", "c", "f", "data", "ui", "a"]}}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void test_function(const TestStruct test_sample)\n\n{\n\n    int ret, i;\n\n    void **output_data  = NULL;\n\n    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,\n\n                                            test_sample.nb_samples_pch);\n\n    if (!afifo) {\n\n        ERROR(\"ERROR: av_audio_fifo_alloc returned NULL!\");\n\n    }\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n\n    }\n\n    printf(\"read: %d\\n\", ret);\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    /* test av_audio_fifo_peek */\n\n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n\n    }\n\n    printf(\"peek:\\n\");\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_peek_at */\n\n    printf(\"peek_at:\\n\");\n\n    for (i = 0; i < afifo->nb_samples; ++i){\n\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n\n        if (ret < 0){\n\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n\n        }\n\n        printf(\"%d:\\n\", i);\n\n        print_audio_bytes(&test_sample, output_data, ret);\n\n    }\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_drain */\n\n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n\n    }\n\n    if (afifo->nb_samples){\n\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n\n    }\n\n\n\n    /* deallocate */\n\n    for (i = 0; i < afifo->nb_buffers; ++i){\n\n        av_freep(&output_data[i]);\n\n    }\n\n    av_freep(&output_data);\n\n    av_audio_fifo_free(afifo);\n\n}\n", "idx": 24655, "substitutes": {"test_sample": ["txtksample", "test_database", "seed_resource", "testinggroup", "testingcomponent", "testappgroup", "testablegroup", "writelsample", "check00ample", " test_shape", "testingexample", "sample_sample", "test_case", "testerscale", "testuresample", "testdsample", "writelfolder", "train_phase", "liveedsequence", "testggroup", " test_scale", "test2sample", "txt_node", " test_component", "test_space", "test_sequence", "sampleablepackage", "sample_cell", "test_string", "live_sample", "savedsample", "test2example", "testedsample", "test_component", "liveedname", "testuregold", "testkgroup", " test_group", "txt_stage", "testfexample", "testkstage", "test_ample", "testerspace", "testvalpackage", "testmfolder", "stageingexample", "test_group", "check_phase", "testedsequence", "test_test", "stage_instance", "seedvalresource", "txtkstage", "check_sample", "test_package", "testappexample", "savedexample", "stage_group", "testablenode", "stageinginstance", "save_example", "testfcase", "seedvalpackage", "test_resource", "live_sequence", "test_shape", "test_model", "liveedproject", "train_component", " test_test", "testfsound", "testdsound", "testmservice", "testgsample", "train_sample", "testdexample", "test_example", "testableslice", "check_ample", "testnsample", "testableresource", "writelservice", "test_project", "write_model", "testedexample", "test_cell", "sample_string", "stage_sample", "testablestage", "test_slice", "sample_data", "testfsample", "save_sound", "savedsound", "seedvalsample", "testablegold", "test2group", "save_sample", "test00phase", "testvalsample", "stage_example", "test_Sample", "testedproject", "seed_package", "savedcase", "testlservice", "testingspace", "txt_sample", "testablecell", "test_sound", "write_sample", "seed_sample", "test00ample", "txtknode", "test_instance", "save_case", "testlfolder", "testnphase", "test_name", "testdcase", "testedcase", "test_scale", " test_space", "seedvalgold", "testlsample", "testureresource", "stageinggroup", "test_data", "test_service", "testgshape", "testvalgold", "testablesample", "testingsample", "testnample", "testersample", "testingscale", "test00sample", "write_service", "testinginstance", "write_folder", "testableSample", "live_project", "test00database", "test_gold", "live_name", "check00database", "testablepackage", "train_model", "txt_group", "testabledata", "testedsound", "check00phase", "testmmodel", "test2instance", "check_database", "testappsample", "testndatabase", "test_folder", "seed_gold", "sample_slice", "sampleablesample", "writelmodel", "test_stage", "testablestring", "testappinstance", "testvalresource", "test_node", "testedname", "testurepackage", "txtkgroup", "testmsample", "sample_package", "testgtest", "testercomponent", "check00sample", "sampleableSample", "testlmodel", "stageingsample", "sampleableslice", "testksample", "testknode", "sample_Sample", "test_phase", "liveedsample"], "ret": ["reset", "sr", "id", "RET", "result", "mem", "url", "ref", "rets", "match", "att", "usr", "rep", "art", "pat", "en", "post", "cur", "pret", "key", "reply", "mt", "err", "xt", "format", "valid", "let", "info", "gt", "nt", "rb", "al", "rev", "arr", "ft", "obj", "feat", "arg", " Ret", "bf", "val", "pet", "cat", "bit", "opt", "detail", "ext", "fit", "rf", "error", "full", "len", " RET", "group", "br", "get", "all", "pass", "code", "rl", "def", "rt", "f", "str", "data", "back", "Ret", "reg", "flag", "base", "r", "alt", "det", "sur", "part", "store", "fun", "ct", "db", "active", "lit", "html", "res", "success", "re"], "i": ["index", "mini", "ai", "x", "b", "li", "pi", "in", "ie", "key", "rel", "err", "id", "j", "end", "len", "yi", "info", "iu", "ip", "hi", "g", "ix", "gi", "bi", "l", "mu", "ti", "io", "ref", "y", "slice", "uri", "xi", "ini", "multi", "p", "qi", "rest", "di", "I", "t", "u", "it", "init", "ii", "k", "si", "c", "ind", "eni", "ami", "f", "val", "rep", "ori", "phi", "ui", "ci", "o", "ni", "bit", "ri", "mi"], "output_data": ["byte_length", "application_data", "outputPlen", "outputingdat", "outputPspace", "outputPlist", " output_format", "outputPdat", "outputsdata", "input_dat", "outputalldefault", "application_alpha", "doublesdata", "response_data", "outputPbody", "input_data", " output_size", "doublesresults", "byte_list", "input_valid", "outputedbytes", "outputingdone", "response_bytes", "input_body", "double_data", "response_dat", "output_valid", "output_size", "output_bytes", "output_results", "bytePlength", "outputingbody", "output_done", "response_space", "output2data", "output_body", "outputedvalid", "input_done", "outputPlength", "output_length", "output_len", "output2format", "bytePdata", "output_list", "outputeddata", "outputPdone", "outputsresults", "outputingsize", "application_buffer", "outputsbytes", "application_space", "byte_len", "doublesbytes", "input_bytes", "bytePlist", "output_dat", "output_format", "outputPdata", "outputeddefault", "double_results", "output_buffer", "outputalldata", "input_default", "output_default", "byte_data", "output_alpha", "outputPbytes", "outputingdata", "outputallvalid", "output_space", "bytePlen", "outputingformat", "double_bytes", "outputallbytes", "output2size"], "afifo": ["afiferano", "afiffoo", "faifoo", "afihoa", "afiolo", "afiffo", "afafi", "affifoa", "aviplo", "afiffn", "afifol", "afilos", "afiffno", "afipo", " af\n", "aftifoo", "afihno", "afinfiso", "afiplo", "afili", "afiplos", "afafo", "affn", "afiloa", "afiffone", "afilo", "aliolbo", "afianos", "afiho", "affiffn", "aviplos", "affiffio", "affifn", "avifiso", "afifoi", "afinfbo", "afifto", "afipli", "afihos", "afiploa", "afianoin", "afiffd", "afinfo", "affipo", "affi", "af\n", "afippo", "aliolo", "afofio", "avifoff", "aviferiso", "affipoo", "afefo", "alifol", "affifo", "aftifo", "afiftode", "aphefio", "aphifoin", "avinfiso", "afiffio", "avifo", "aflifano", "afafos", "afefoa", "afiffos", "aftifi", "afinfoo", "aphefoin", "afifano", "avinfo", "afifiso", "afipoo", "afifoo", "afefio", "affifoo", "avinfoo", "afiffi", "affifi", "afiolbo", "ab\n", "afigd", "affiffi", "afiftno", "alifoi", "aifo", "aphifio", "afiferoff", "afifn", "afofiso", "avifdo", "avifero", "avifos", "afiano", "afigo", "afifoa", "atifo", "affifode", "failoo", "afilno", "affiffone", "afigoo", "afofn", "alifbo", "afifio", "aftifone", "avifi", "affipno", "afippano", "aftifno", "afofdo", "avipli", "alifo", "atifoa", "affiffno", "afiloo", "afispbo", "affipode", "afifd", "aifoa", "aflifo", "avifano", "afianio", "faild", "afipode", "afinfol", "afispo", "aviferano", "faifo", "afofi", "afild", "afifode", "afinfoi", "afinfdo", "afofo", "aftifode", "affifone", "affo", "afifos", "aphifos", "afiffoa", "aifi", "afifoff", "affiffoa", "failo", "affiffos", "affio", "afiplone", "afefoin", "afiolol", "aphefos", "afifoin", "afafone", "afiffiso", "faifd", "afiploff", "affiffo", "afioloi", "aftifoa", "aliolol", "afefos", "afifi", "affifno", "afippiso", "aflifoff", "avifoo", "aflifiso", "afispoi", "afofoo", "failoa", "afiffoin", "afippoff", "afefone", "affifos", "afefi", "aifone", "afipno", "afifno", "afiferiso", "aff\n", "afiffdo", "afiloff", "afifdo", "faifoa", "atifone", "aphifo", "afifero", "afifbo", "alioloi", "afiftoo", "affifio", "aviferoff", "aviploff", "afifone", "atifi", "avinfdo", "afigoa", "aphefo", "afispol"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n", "idx": 24668, "substitutes": {"dest": ["orig", "buf", "dist", "Dest", "dc", "source", " destination", "end", "save", "ignore", "done", "dim", "wb", "cont", "src", "large", "destroy", "draw", "rest", "comb", "route", "di", "local", "later", "ident", "de", "feat", "flat", "target", "desc", "node", "loc", "img", "outer", "global", "opt", "class", "temp", "delete"], "line_size": ["line0address", "line__small", " line0address", "line_scale", "line_SIZE", "line__SIZE", " line_SIZE", " line_small", "line_weight", "line__address", "line_address", " line0size", "line0small", "line2weight", " line_weight", "line0size", " line0small", " line0SIZE", "line2scale", "line2SIZE", "line_small", "line__size", " line_address", "line0SIZE", "line2size", " line_scale"], "block": ["circle", "plugin", "bl", "box", "parent", "filter", "blocks", "shape", "source", "end", "chain", "function", "image", "Block", "ip", "cache", "group", "type", "slice", "check", "config", "label", "cl", "p", "pack", "lock", "line", "channel", "unit", "device", "buffer", "node", "loc", "point", "pixel", "output", "object", "data", "outer", "event", "out", "mask", "name", "bin"]}}
{"project": "FFmpeg", "commit_id": "5a08ba5381cf8d46034440163e71cd95748beceb", "target": 0, "func": "static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)\n\n{\n\n    Hnm4VideoContext *hnm = avctx->priv_data;\n\n    GetByteContext gb;\n\n    uint32_t writeoffset = 0, count, left, offset;\n\n    uint8_t tag, previous, backline, backward, swap;\n\n\n\n    bytestream2_init(&gb, src, size);\n\n\n\n    while (bytestream2_tell(&gb) < size) {\n\n        count = bytestream2_peek_byte(&gb) & 0x1F;\n\n        if (count == 0) {\n\n            tag = bytestream2_get_byte(&gb) & 0xE0;\n\n            tag = tag >> 5;\n\n            if (tag == 0) {\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n            } else if (tag == 1) {\n\n                writeoffset += bytestream2_get_byte(&gb) * 2;\n\n            } else if (tag == 2) {\n\n                count = bytestream2_get_le16(&gb);\n\n                count *= 2;\n\n                writeoffset += count;\n\n            } else if (tag == 3) {\n\n                count = bytestream2_get_byte(&gb) * 2;\n\n                while (count > 0) {\n\n                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);\n\n                    count--;\n\n                }\n\n                bytestream2_skip(&gb, 1);\n\n            } else {\n\n                break;\n\n            }\n\n        } else {\n\n            previous = bytestream2_peek_byte(&gb) & 0x20;\n\n            backline = bytestream2_peek_byte(&gb) & 0x40;\n\n            backward = bytestream2_peek_byte(&gb) & 0x80;\n\n            bytestream2_skip(&gb, 1);\n\n            swap   = bytestream2_peek_byte(&gb) & 0x01;\n\n            offset = bytestream2_get_le16(&gb);\n\n            offset = (offset >> 1) & 0x7FFF;\n\n            offset = writeoffset + (offset * 2) - 0x8000;\n\n\n\n            left = count;\n\n\n\n            if (!backward && offset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (backward && offset >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (writeoffset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"Attempting to write out of bounds\");\n\n                break;\n\n            }\n\n\n\n            if (previous) {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            } else {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            }\n\n\n\n            if (swap) {\n\n                left         = count;\n\n                writeoffset -= count * 2;\n\n                while (left > 0) {\n\n                    swap = hnm->current[writeoffset];\n\n                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];\n\n                    hnm->current[writeoffset + 1] = swap;\n\n                    left--;\n\n                    writeoffset += 2;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24677, "substitutes": {"avctx": ["avcb", "ahcas", "awcontext", "avconnection", "AVloc", "afcb", "afcas", "awcas", "afloc", "afctx", "afconnection", "avcas", "ahcontext", "avcontext", "ahconnection", "AVcb", "awconnection", "awctx", "AVcontext", "apcb", "avloc", "apcontext", "aploc", "apctx", "afcontext", "AVctx", "ahctx"], "src": ["buf", "sr", "sl", "sc", "bc", "rob", "source", "filename", "scene", "func", "rs", "lib", "sub", "ctx", "ssl", "sb", "sel", "secure", "image", "rb", "storage", "url", "slice", "stream", "config", "channel", "inst", "rc", "input", "buffer", "loc", "sync", "img", "cb", "data", "dest"], "size": ["ize", "sum", "sc", "z", "mode", "shape", "timeout", "bytes", "len", "fee", "storage", "max", "six", "style", "empty", "SIZE", "code", "cs", "address", "unit", "args", "scale", "small", "loc", "c", "sec", "sized", "data", "global", "Size", "esc", "en", "length"], "hnm": ["cnf", "rnM", "hnc", "dnc", "wnc", "hnf", "rnfm", "ennf", "wnM", "dnl", "wnm", "wnms", "hnl", "wnf", "wnfm", "gnc", "hnms", "cnm", "nnr", "knc", "ennsm", "gnmm", "gnM", "knr", "hnfm", "nnc", "wnsm", "dnf", "gnf", "gnfm", "wnmm", "hnsm", "ennmos", "nnl", "dnm", "ennm", "rnms", "gnms", "wnmos", "knl", "dnmos", "gnm", "nnm", "hnr", "cnmm", "hnmos", "knm", "dnr", "cnc", "hnM", "rnm", "hnmm", "dnsm"], "gb": ["gz", " gcc", "bc", "byte", " rg", " eg", " GC", "yg", "sb", "binary", "g", "gd", " camera", "gy", " img", "mb", "ogg", "git", "gal", " cf", "ci", "usb", " prog", " kb", "bg", "bm", "pg", "gio", "gl", "gh", "gs", "gin", "rb", " bi", "rg", "gpu", " msg", "greg", " now", "rc", "cgi", "eb", "bf", " gui", " alloc", "ui", " gl", "tg", "kb", "ga", "gm", "gp", " mem", " conf", "gom", "lib", "bb", " cd", "gn", "GB", "cmd", "cfg", "gam", " co", "cod", "gg", " channel", "gru", " scene", "buff", "gae", "ko", " rc", "ctx", "game", "storage", "uu", " db", "hub", " disp", " chunk", "py", "broad", "db", "gram", "region", "gu", " storage"], "count": ["child", "allow", "id", "keep", "cache", "type", "p", "core", "counter", "match", "comment", "carry", "limit", "more", "name", "depth", "coll", "num", "key", "parent", "cc", "connection", "col", "cycle", "cast", "skip", "large", "pool", "low", "c", "start", "ind", "val", "cat", "use", "cond", "index", "Count", "len", "current", "max", "session", "cost", "level", "label", "code", "bug", "call", "flag", "weight", "base", "number", "tail", "catch", "close", "part", "batch", "time", "process", "loc", "content", "list", "length", "sum"], "offset": ["index", "alias", "loss", "et", "set", "error", "align", "alpha", "slot", "shift", "end", "timeout", "Offset", "len", "fee", "patch", "image", "position", "tail", "type", "operation", "attr", "iso", "alt", "number", "location", "slice", "ref", "part", "off", "skip", "range", "origin", "sort", "address", "attribute", "online", "loc", "point", "limit", "sync", "start", "padding", "output", "gap", "layer", "data", "api", "next", "pos", "o", "length", "pointer", "at"], "tag": ["ag", "port", "loop", "big", "child", "id", "byte", "rule", "patch", "cache", "type", "character", "ref", "ver", "match", "month", "comment", "block", "gap", "co", "user", "sign", "name", "class", "post", "cur", "year", "key", "parent", "debug", "format", "rate", "style", "role", "feat", "c", "cat", "meta", "use", "bit", "TAG", "Tag", "error", "token", "category", "option", "attr", "cost", "pe", "label", "code", "channel", "bug", "attribute", "hop", "call", "reg", "flag", "date", "tags", "ack", "image", "word", "number", "tail", "catch", "uu", "close", "go", "batch", "loc", "eng", "round", "length", "bad", "sum"], "previous": ["perprev", "prevert", "Preprev", "forevert", "Previous", "intertext", " prevert", "previously", "Precision", "reviously", "reprev", "intervious", "forevious", "Previously", "perviously", "interpre", "revious", "prepre", "pretext", "pervious", "forepre", " prepre", " pretext", "percision", "recision", "foretext", "intervert", "preprev"], "backline": ["worklines", "bottomlink", "backlines", "bottomplane", "bookside", "firstlink", "backlined", "workwrite", "frontwrite", " backwrite", "frontlines", "bottomline", " backlined", "booklink", "firstplane", "backwrite", "backside", " backlines", "bottomside", "worklined", "backplane", "backlink", "firstside", "bookline", "frontline", "frontlined", "bookplane", "workline", "firstline"], "backward": ["BACKboard", " backwards", " backforward", "Backwards", "Backforward", "Backboard", "backboard", "Backline", "Backward", " backboard", "BACKward", "frontforward", "BACKforward", "frontward", "backforward", "frontwards", "BACKwards", "frontline", "backwards"], "swap": ["rewag", "chave", "scap", "swave", "scapper", "scip", " swip", "chap", " swave", " swaps", "rewapping", "swip", "swaps", "chapper", " swapping", "Swaps", "Swap", "scave", " swag", "rewaps", "Swapping", "swapper", "swag", "Swag", "chip", "swapping", "rewap", " swapper"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720, "substitutes": {"sig": ["psig", "nsigma", "sigs", "setsig", "setsigs", "psigh", "pigma", "SIG", " sigma", "asig", "setsigma", "gigma", "asigh", "slic", " slic", "sigh", "pigs", "gigs", "gib", "pIG", "setsigh", "nsig", "sigma", "pib", " sib", "nsIG", "gig", "pig", "sIG", "Slic", " sigs", "nslic", "asigma", "asigs", "Sigs", "pigh", " sigh", "nsigs", "psigma", " sIG", "Sig", "sib", "psigs", "nsigh"], "ka": ["ai", "ke", "ja", "sci", "da", "sc", "aka", "kernel", "ana", "ca", "ko", "ta", "ia", "ket", "ctx", "kl", "ama", "ba", "ae", "ku", "sa", "la", "au", "ma", "oa", "sta", "eka", "kee", "KA", "kt", "qua", "asa", "ker", "ua", "cha", "na", "cca", "Ka", "ha", "ea", "ya", "java", "va", "qa", "kb", "LA", "ki", "ga", "pa"], "set": ["site", "reset", "context", "et", "ut", "base", "state", "net", "end", "lex", "test", "ise", "send", "op", "update", "ets", "Set", "session", "en", "get", "ner", "store", "config", "parse", "sche", "pack", "ze", "iss", "def", "ex", "vert", "init", "unit", "tx", "sets", "el", "setup", "settings", "ha", "sync", "export", "loc", "ind", "start", "gen", "spec", "kit", "stat", "section", "sign", "setting", "SET", "dat", "se"], "env": ["scope", "ette", "ne", "qt", "oa", "ini", "define", "core", "ze", "args", "ev", "el", "ah", "eni", "fen", "en", "her", "context", "ench", "dict", "me", "er", "shell", "conn", "anne", "enc", "exc", "e", "ext", "eq", "que", "net", "inet", "environment", "ise", "enter", "session", "vag", "esm", " environment", "config", "stage", "etta", "cfg", "po", "ef", "export", "ea", "ey", "ec", "np", "dat", "engine", "et", "chal", "dt", "eu", "ctx", "gui", "eh", "enh", "esi", "equ", "iss", "init", "console", "db", "eng", "Environment", "ep", "global", "gear", "viron", "vel"], "frame": ["b", "ke", "scope", "za", "function", "ne", "framework", "sequence", "ock", "figure", "define", "lock", "line", "ze", "el", "view", "block", "document", "thread", "tick", "fram", "play", "fb", "shot", "context", "state", "shape", "show", "feature", "flow", "build", "cycle", "iframe", "style", "parse", "processor", "vert", "die", "node", "e", "point", "c", "ind", "val", "event", "fe", "trace", "runner", "step", "orig", "que", "message", "ace", "scene", "ise", "none", "rame", "position", "update", "up", "session", "dr", "boot", "fi", "slice", "cf", "ce", "config", "code", "draw", "sche", "fr", "stage", "def", "cfg", "seq", "module", "f", "gen", "frames", "data", "call", "plate", "cpu", "body", "game", "image", "fake", "raise", "range", "nil", "init", "Frame", "sample", "setup", "file", "element", "object", "next", "load", "face", "section", "zone"]}}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730, "substitutes": {"bs": ["js", "b", "pb", "bl", "css", "Bs", "vs", "bc", "blocks", "gs", "rs", "os", "bb", "sb", "fs", "ba", "ps", "aws", "ts", "sa", "bt", "ks", "ins", "gb", "cs", "obj", "bas", "ns", "BS", "ss", "ls", "ds", "lb", "ses", "fb"], "s": ["js", "b", "sf", "n", "sl", "a", "state", "S", "sv", "gs", "os", "rs", "opens", "ssl", "sb", "fs", "storage", "ps", "aws", "ts", "es", "sa", "ks", "service", "p", "cs", "sym", "su", "ns", "si", "settings", "e", "sync", "c", "d", "ss", "f", "spec", "ls", "ds", "services", "sq", "o", "ses"]}}
{"project": "FFmpeg", "commit_id": "93c39db5f1544d1220488cfeb93bfe812a52f374", "target": 1, "func": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;", "idx": 24732, "substitutes": {"s": ["js", "sl", "qs", "a", "set", "sites", "sv", "S", "gs", "self", "ions", "os", "less", "ops", "opens", "ssl", "sb", "fs", "sts", "g", "session", "ps", "ans", "ts", "es", "is", "sa", "src", "service", "ins", "p", "cs", "sym", "t", "w", "sets", "su", "ns", "sg", "sch", "si", "settings", "e", "c", "xs", "f", "spec", "ls", "ds", "ss", "services", "sq", "us", "se", "ses", "sys"], "pkt": ["packer", " packet", "prcht", " packer", "apacket", " pet", "pret", "ppnt", "pracket", "pnt", "ppk", "pk", "Pcht", "Packer", " pk", " pnt", "packet", "Pk", "apct", "tpkt", "tpet", "Ppt", "prkt", "ppt", " pct", "ppkt", "tpnt", "Pet", "pct", " peth", "preth", "pracker", " pcht", "Packet", "apkt", "appt", "pet", "peth", "tpacket", " ppt", "Pct", "pcht", "Pnt", "Pkt", "Peth", "ppacket"], "st": ["sd", "sf", "ist", "et", "sl", "ut", "dt", "set", "ost", "bl", "sc", "mt", "sv", "std", "stop", "stand", "stack", "sth", "sb", "sp", "nt", "sts", "St", "ust", "sa", "sk", "src", "sta", "cl", "sed", "rest", "est", "kt", "fr", "ess", "stage", "ste", "ft", "inst", "ld", "t", "ast", "ct", "pt", "start", "ss", "td", "ST", "ds", "str", "sn", "sw", "fe", "client", "nd", "se"], "aiff": [" aIFF", "saif", "aIFF", "saisk", "gaef", "gaqa", "saqa", "Aiff", "aiper", " aif", "gaiper", "naif", "aqa", "aisk", "a8", "Aif", "vaiff", "naiff", " aisk", "aef", "vaef", "naisk", "vaqa", "sa8", "aif", " aiper", "saIFF", "vaiper", "na8", "AIFF", " aqa", "gaiff", "Aqa", "saiff", " a8", " aef"], "max_size": ["maximumlexsize", "maxlexsize", "total67shape", "max64length", "total_size", "maxlexwidth", "maximum_width", "total67length", "maxlexlength", "maxlexstorage", "max64shape", "maximum_storage", "max_align", "max67size", "max_sec", "maximumlexwidth", "max67shape", "total_shape", " max_age", "max_shape", "max_age", "maximumlexlength", "max_storage", "total67size", "max_length", "maximumlexstorage", " max_align", " max_sec", "maximum_length", "max64size", "max_width", "max64sec", "maximum_size", " max_width", "max64width", "total_length", "max67length"], "res": ["js", "Res", "results", "details", "rx", "errors", "gr", "resolution", "changes", "blocks", "err", "id", "rows", "rs", "os", "req", "rem", "breaks", "resh", "response", "bytes", "len", "pres", "row", "r", " resolution", "max", "result", "ps", "resp", "rate", "es", "ares", "ver", "range", "ras", "rev", "rez", "ress", "cs", "rss", "rh", "des", "ex", "rc", "ms", "runs", "ries", "data", "rep", "content", "min", "ris", "pos", "reg", "nos", "re", "used", "sum"], "size": ["mini", "num", "sex", "ize", "resolution", "value", "z", "sc", "id", "shape", "ace", "shift", "end", "send", "bytes", "len", "fee", "max", "resource", "slice", "go", "large", "range", "empty", "SIZE", "code", "speed", "cs", "core", "iz", "address", "unit", "sea", "page", "rc", "capacity", "scale", "si", "time", "small", "e", "loc", "sent", "eng", "c", "grow", "i", "sec", "ng", "sized", "data", "content", "min", "ui", "sw", "Size", "esc", "pos", "form", "sn", "name", "length", "sum"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 24742, "substitutes": {"arg1": [" arg01", "argument3", "Arg2", "Argone", "Arg01", "argument2", "argument01", "ax3", "ax01", "Arg1", " argone", "argument1", "ax2", "ax1", "axone", "arg01", "argone"], "arg2": ["argument3", "ax4", "ark3", "argument4", "arg02", "args2", "argument2", "ark2", "args1", " arg02", "args02", "ax02", "argument1", "args4", "ax2", "arg4", "ax1", "ark1", "ark4", " arg4"], "arg3": ["args3", " arg53", "argument3", "argument03", "Arg2", "arg53", " arg03", "ag3", "argument2", "args53", "Arg3", "args1", "args03", "Arg1", "ag03", "argument1", "arg03", "Arg03", "ag1", "ag53"], "farg1": [" fargA", "Farg1", " farg4", "Farg10", "fullarc2", "fax2", "farg81", "fparam1", "fig1", "fArg6", "Farg5", "farg5", "fArg01", "fullarc3", "faccess100", "ofarg17", "fark3", " fax1", "ferr13", "ferr100", "farc3", "Fargs1", " fArg0", "fullarg01", "ferr1", "Farg100", " farg0", "fax71", "ferr3", "fullarg2", "fullarc01", "farc01", " fax81", "farg13", "farm1", "Fark01", "farg100", "farg17", "farmn", " fArg1", "fArg0", "Fax5", "fparam5", "fArg1", "fArgn", "fargs1", " fArg2", "Fark3", "Fargone", "fullarg3", "faxone", "farm3", "fang1", "farg10", "Fax3", "ofarg1", "fagg1", "fark1", "fax5", "Fark10", "fig01", "fargs6", "fark100", "fargn", "fang3", " farg71", "Fark13", "Fark100", "fag1", "fark01", "fArg4", "farg0", "faccess13", "fArg2", "fArg17", "fagg71", "faxA", "fargs2", "ofang3", "Fax1", "fangA", "fagg81", "fArg81", "fax1", "farg01", "ofang1", "fargs0", " fax3", "fang17", " farg81", "fargs3", "Fargs3", "fag10", "Faxone", "ofang17", "Fargsn", "farc2", "fullarc1", "ofarg3", "fark10", "farg4", "fax3", "Fark1", "fparam3", "farg71", "fullarg1", "fang2", "farm6", "Farg13", "fargs01", " fArg4", "fag3", "Farg01", "Farg6", "fargsone", "faccess3", "Fargs6", "fargA", "fagg3", "faccess1", "fark13", "fang01", "fargs4", "farg6", "fArg71", " fax71", "fargsn", "ofarg01", "fparamone", "fargone", "fag01", "farc1", "fArg10", "fargs5", "fig3", "Farg3", "Fargn", "fig17", "fax81", "fArg3", "ofang01"], "farg2": [" farg4", "farkTwo", " fArg02", "fang62", " fang72", "floadsecond", "fmembersecond", "fangb", "fark3", "frarc2", "fark2", "fvar72", "fargs02", "fagnTwo", " fang02", "frarg82", "frarg2", "frargb", "fparamTwo", "fcat27", "foragn3", "fracksecond", " farg02", "fxarg62", "farcii", "fmember27", "fang72", "farg72", "fxag27", "fracktwo", " fArg1", " farg72", "fArg1", "fArg02", "fargs1", " fArg2", "fmember62", "foragn2", "fxarg2", "farcsecond", "fagn2", "fcatsecond", "fdate62", "forarg2", "foragnTwo", "fvar2", "fargs6", "fargii", "fang6", "floadtwo", "fagn3", "fdateii", "fArg4", "fload2", "fxag2", "fvar02", "frargii", "fArg2", "fcat62", "fdate2", "fag62", "fargs2", "fxagsecond", "fargb", "frack2", "fdateb", "fmember2", "fparamtwo", "facktwo", "facksecond", "farcb", "fvar6", "frarg62", "frargtwo", "fload82", "farc2", "fack2", "farg4", "fargTwo", "fangii", "fparam3", "fang2", " fang2", "farg02", "foragntwo", " fArg4", "fxarg27", " fang6", "farg82", "farc82", "farg27", "forargtwo", "fargsecond", "farktwo", "fag27", "fargs4", "forarg3", "farg6", "fxag62", "fcat2", "forargTwo", "farg62", "fargs72", "frack82", "farctwo", "fparam2", "fagntwo", "fagsecond", "fack82", "frarcii", "fang02", " farg6", "fargtwo", "frargsecond", "frarc62", "fxargsecond", "fag2", "frarcb", "farc62"], "farg3": ["fplay12", " farg4", "fax2", "frarg7", "fackThird", "farg7", "fmagthree", "frarg3", "fvalid3", "farg20", " fax03", "fax93", "farg12", "frg03", "targ03", "fargs03", "ifax03", "fard7", "fax23", "ifargThird", "fmag03", "fig40", "frgen93", "fearg3", "tplay7", "frarg15", "fackthree", "fArg03", "farg43", " fax2", "tplay3", "frgen3", "fang03", "fang12", "fgen3", "cfarg3", " fax4", "fargthree", "farg23", "farg40", "fevalid3", "fax03", "fmag3", "farm3", "ifargthree", "fvalid43", "farmthird", "targ7", "fang3", "frg3", "fevalid43", "fearg20", "fArg4", "fard15", "fax15", "fag20", "fArg2", "cfax03", "fack03", "fag40", "fargs2", "fgen7", "targ3", "frgen7", "fevalid40", "cfax23", "fearg43", "farm23", " fax3", "fargs3", "fax7", "cfarg03", "farg03", "frgen15", "farg4", "cfax3", "fax3", "ifarg3", "fearg40", "farg93", "frarg93", "fig20", "fvalid20", "targ12", "frgthird", "fag3", "fgen15", "faxThird", "fard93", "fig43", "frg23", "fgen93", "fgroup12", "fevalid20", "fgroup03", "fmagThird", "ifaxthree", "farm03", "ifaxThird", "fax4", "fgroup7", "fargs4", "tplay12", "fplay7", "ifarg03", "fargThird", "cfarg23", "faxthree", "fag43", "fplay3", " farg03", "cfargthird", "farg15", "fplay03", "fig3", "fard3", "ifax3", "fargthird", "fvalid40", "fack3", "faxthird", "fArg3", "fang7", "tplay03", "fgroup3", "cfaxthird"], "ft0_128": ["ft0__33", "ft1_64", "ft7_32", "ft0__257", "ft0_123", "ft1_1024", "ft0_1024", "ft1_256", "ft2_128", "ft8_123", "ft11__33", "ft0_48", "ft0_132", "ft2_256", "ft0_64", "ft0_33", "ft0__1024", "ft8_128", "_", "ft0_32", "ft7_128", "ft0_256", "ft8_328", "ft11_257", "all", "ft0__128", "ft0_328", "ft0_512", "ft11__1024", "ft7_132", "ft7_256", "unc", "ft2_48", "ft11_128", "ft2_1024", "ft11_1024", "ft11_33", "ft0_257", "ft11__128", "ft8_256", "ft11__257", "ft1_512"], "ft1_128": ["ft1A65", "ft0_32", "ft0_256", "ft0_127", "ft1_32", "ft0_123", "ft1A48", "ft0_48", "ft1A128", "ft0_132", "ft1_132", "ft1_48", "ft0_65", "ft1_256", "ft0_512", "ft1_127", "ft1_65", "ft1_123", "ft1A256", "ft1_512"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n", "idx": 24744, "substitutes": {"dc": ["context", "fc", "dt", "sc", "da", "bc", "df", "duc", "anc", "nc", "central", "ac", "cc", "disc", "ctx", "fd", "gui", "enter", "arc", "mc", "gc", "auc", "conn", "cf", "config", "vc", "draw", "tc", "cr", "dm", "di", "cit", "dp", "de", "rc", " DC", "cm", "ct", "input", "db", "design", "center", "cca", "jc", "desc", "loc", "uc", "c", "doc", "d", "exec", "ec", "pc", "lc", "td", "ds", "ea", "DC", "data", "cdn", "dat", "ga", "cd"], "l1": ["l0", "ll0", "el2", "L8", "Ln", " l3", "dlone", "L0", "lone", "el1", "ll2", "ll8", "ar2", "L3", "el0", " l0", " l2", "dl2", "dl0", "l8", "dln", "ar0", "ll1", "ar1", "dl8", " ln", "el3", "L2", "L1", "l3", " lone", "l2", "dl1", "Lone", "ln"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n", "idx": 24748, "substitutes": {"opaque": [" opacity", "OPacle", "OPaque", "openacle", "openacity", "OPacity", "opacity", " opacle", "opacle", "openaque"], "addr": ["x", "index", "ext", "port", "alias", "align", "cmp", "slot", "edge", "ace", "ptr", "host", "ip", "ix", "coord", "alt", "attr", "dr", "amd", "osi", "xp", "src", "oa", "p", "grad", "address", "prefix", "device", "md", "mac", "adr", "rc", "arg", "target", "node", "point", "seq", "start", "padding", "i", "adder", "layer", "val", "data", "ad", "pos", "ord", "eth", "pointer", "offset"], "value": ["index", "x", "port", "array", "entry", "message", "write", "format", "valid", "end", "VALUE", "image", "flow", "number", "ip", "type", "result", "v", "version", "p", "m", "address", "w", "buffer", "target", "Value", "padding", "age", "val", "values", "data", "server", "memory", "name", "offset"]}}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n\n{\n\n\n\n    if (err == 0 || errno != ENOENT) {\n\n        err = -errno;\n\n        goto out;\n\n    }\n\n\n\n    if (vs->perm & P9_STAT_MODE_DIR) {\n\n        err = v9fs_do_mkdir(s, vs);\n\n        v9fs_create_post_mkdir(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {\n\n        err = v9fs_do_symlink(s, vs);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_LINK) {\n\n        int32_t nfid = atoi(vs->extension.data);\n\n        V9fsFidState *nfidp = lookup_fid(s, nfid);\n\n        if (nfidp == NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n", "idx": 24754, "substitutes": {"s": ["js", "b", "S", "rs", "ssl", "sb", "fs", "g", "states", "h", "tests", "sis", "p", "sets", "ms", "si", "sync", "xs", "serv", "sq", "uses", "as", "native", "qs", "state", "gs", "ys", "es", "ks", "service", "cs", "t", "su", "sie", "e", "c", "ches", "ss", "spec", "o", "stats", "site", "its", "status", "self", "ops", "session", "ts", "is", "src", "m", "f", "ds", "server", "ses", "bis", "sys", "sv", "http", "os", "r", "bs", "ps", "v", "ves", "south", "ns", "settings", "ls", "services", "us", "se"], "vs": ["js", "wp", "env", "vers", "write", "rs", "lv", "sb", "vt", "fs", "g", "obs", "type", "states", "ver", "p", "args", "ev", "ms", "lines", "xs", "va", "serv", "pg", "qs", "path", "gs", "end", "verts", "ys", "vol", "es", "params", "ims", "isl", "open", "ks", "vals", "cs", "ports", "virt", "alls", "ils", "c", "ss", "versions", "Vs", "stats", "_", "css", "vm", "posts", "ops", "VS", "ov", "ts", "cf", "sk", "vr", "vo", "eps", "f", "ds", "values", "views", "plugins", "iv", "nets", "ses", "sys", "sv", "http", "func", "os", "vp", "r", "bs", "sts", "ps", "cv", "v", "nav", "vc", "ves", "dev", "ums", "var", "ns", "settings", "d", "ls", "services", "vi", "vis"], "err": ["erg", " error", "lr", "count", "req", "far", "result", "ner", "url", "ver", "fg", "rh", "ler", "ah", "erer", "rr", "order", " Err", "er", "valid", "end", "nor", "magic", "rb", "mr", "rage", "rev", "arr", "eor", "aster", "msg", "icer", "later", "orig", "last", "errors", "error", "gr", "finder", "proc", "ise", "test", "ctr", "len", "Error", "Er", "br", "dr", "resp", "iter", "attr", "yr", "y", "fi", "code", "rn", "fr", "rl", "wr", "bug", "cfg", "fer", "ng", "str", "call", "org", "nr", "ter", "der", "r", "oller", "work", "go", "cr", "ar", "var", "doc", "kr", "cb", "pr", "res", "rar", "ir"], "nfidp": ["nlfstrps", "nfidsd", "nffm", "nfidsl", "nlfstrc", "nfIdl", "nffr", "nfidsP", "nlfstrp", "ncfidd", "nffP", "ncfidsP", "nfidps", "nfsidecp", "nlfidc", "ncfidcp", "nfIdd", "nfidl", "nfaidps", "nfidsps", "nlfidp", "ncfidm", "ncfidsl", "nfsidep", "nfsided", "ncfidsr", "nfstrP", "ncfidp", "ncfidP", "nfaidr", "ncfidsp", "ncfidsm", "nfsidel", "nfaidP", "nfstrp", "nfIdcp", "nfaidm", "nffp", "nfidsc", "nfidsp", "nfaidc", "nlfidP", "ncfidsd", "ncfidl", "nfIdp", "nfidscp", "nfidsm", "nfaidp", "ncfidscp", "nfidm", "nfidc", "nfstrps", "nlfidps", "nlfstrP", "nfstrc", "nfidr", "nfidP", "nfidcp", "ncfidr", "nfidsr", "nfidd"], "ctype": ["CType", "ctitle", "CTropy", "cattype", "ctyle", "cttype", "octypes", "ctropy", "CTtype", "CTypes", "catyle", "octyle", "cype", "catype", "acttype", "ctyp", "pttype", "ptypes", "CTyp", "octropy", "CTpe", "cfitle", "cfyle", "cftype", "actpe", "cyp", "catitle", "octitle", "actyp", "octype", "ctypes", "cpe", "ptropy", "actype", "ctpe", "ptype", "cfype", "octtype"], "major": ["owner", "ter", "num", "mod", "mid", "Major", "release", "oper", "gr", "driver", "inter", "der", "valid", "nir", "or", "none", "over", "current", "ior", "total", "patch", "feature", "type", "master", "serial", "ner", "ver", "older", "inner", "power", "version", "pre", "primary", "processor", "dev", "ser", "vert", " Major", "mac", "olar", "bor", "usr", "ajor", "gener", "next", "min", "server", "little", "micro", "length", "post"], "minor": ["indor", "anchory", "tenored", "Minion", "victour", "tenOR", "minion", "tenor", "anchOR", " minour", "MINor", "victor", "minory", " minored", "Minor", "minour", "MINory", "Minored", "victOR", "MINore", "anchore", "MINour", "minOR", "minored", "indOR", "MINOR", " minior", "MINior", "indory", " minOR", "minior", "indore", "tenion", "anchor", "victior", "minore", "MinOR", " minion"]}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "void pal_init (CPUState *env)\n\n{\n\n}\n", "idx": 24756, "substitutes": {"env": ["dir", "buf", "cap", "et", "conf", "err", "environment", "end", "ov", "v", "conn", "priv", "fi", "enc", "erv", "config", "fg", "ev", "db", "ef", "e", "ec", "cb", "np", "viron", "iv", "en", "bg"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759, "substitutes": {"spapr": ["wpaptr", "wpaprar", " spapR", "spappr", "spatra", " spappr", "Spappar", "wpapsr", "wpaptra", "spapprd", " spaprd", " spappra", "spaptra", "SpapR", "spatr", "spajra", "spiprar", "spipr", " spappR", "Spappr", "spatrar", "sprapra", "spajrd", "spappR", "spapprar", "sparpar", "spaptsr", " spapprd", "sparpR", "sparprar", "spapsar", "wpapr", "spapsR", "spappar", "spaptr", "spappra", "Spapprar", "spipsr", "spapar", "Spapar", "wpaptrar", "spapsrar", "spaprd", "spapsr", "sprapR", "SpappR", "Spapr", "spapra", "wpapra", "Spaprar", "spajR", "spatsr", "wpaptsr", "spraprd", " spapra", "spapR", "spaprar", "spaptrar", "sparpr", "spajr", "sprapr", "spipra"], "token": ["date", "seed", "year", "key", "KEN", "wt", "column", "rule", "byte", "note", "shadow", "format", "text", "timeout", "sid", "tag", "len", "header", "function", "option", "prot", "word", "number", "duration", "type", "character", "session", "trial", "secret", "notice", "sequence", "template", "uri", "oken", "version", "variable", "code", "password", "stage", "channel", "prefix", "argument", "socket", "username", "arg", "target", "ok", "node", "sync", "limit", "element", "eni", "Token", "start", "random", "api", "document", "event", "sn", "tick", "cookie", "remember", "o", "auth", "name", "length", "offset"], "nargs": [" ngs", " nvalid", "pargs", "lvalid", "nparams", "natarg", "lparams", "lgs", "natret", "pvalid", "ngs", " narg", "narg", " nparams", "larg", "carg", "cparams", "pparams", "cret", "natargs", "cgs", "nvalid", "largs", "cargs"], "args": ["context", "results", "details", "ret", "err", "flags", "gs", "func", "rs", "col", "len", "info", "ans", "resp", "params", "secret", "Args", "aws", "fields", "conn", "config", "files", "ras", "strings", "arr", "vals", "parse", "cs", "cmd", "argument", "names", "var", "fun", "arg", "doc", "seq", "ig", "extra", "msg", "aux", "next", "data", "ars", "pos", "res", "stats", "ants"], "nret": [" nalt", "calt", "lRET", "nRET", "nreturn", "Nrets", "Nreturn", "cresult", "enreturn", "nalt", " nRET", "Nret", "nrets", "lreturn", " nrets", "nresult", "clen", "enret", "lresult", " nlen", " nresult", "enrets", "cret", "cRET", "creturn", "Nlen", " nreturn", "enalt", "nlen", "crets", "lret"], "rets": ["items", "ents", "pillar", "details", "results", "errors", "ret", "RET", "rows", "flags", "rs", "breaks", "nas", "ops", "verts", "vt", "fs", "red", "info", "tails", "alt", "secret", "ts", "fields", "artifacts", "cas", "ras", "strings", "vals", "ints", "ails", "def", " secrets", "des", "protected", "ats", "fun", "urs", "ieves", "att", "runs", "lines", "ns", "utils", "rules", "aux", "ds", "uments", "uds", "res", "urses", "ants"], "call": ["make", "run", "key", "Call", "ac", "roll", "end", "send", "ack", "create", "function", "build", "cache", "cell", "cal", "work", "close", "kill", "mix", "parse", "pass", "code", "p", "act", "ell", "def", "init", "push", "e", "exec", "block", "c", "invoke", "sync", "f", "can", "ec", "ul", "apply", "cat", "co", "event", "use", "name", "play", "throw"]}}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n", "idx": 24761, "substitutes": {"out": ["b", "array", "n", "parent", "filter", "outs", "source", "outside", "op", "Out", "cache", "image", "up", "group", "update", "result", "new", "v", "all", "ref", "part", "dot", "OUT", "inner", "app", "pre", "pass", "p", "code", "m", "again", "other", "line", "conv", "vert", "obj", "init", "input", "flat", "process", "append", "doc", "sync", "c", "output", "copy", "object", "outer", "data", "call", "co", "o", "flag", "list", "client", "temp", "bin", "at"], "in": ["ai", "b", "orig", "index", "isin", "rec", "n", "nin", "din", "win", "inside", "id", "source", "inn", "ac", "inf", "binary", "In", "image", "update", "up", "IN", "new", "work", "ref", "part", "ini", "before", "ins", "inner", "con", "pre", "pass", "p", "arr", "config", "m", "ic", "again", "line", "table", "init", "input", "ii", "this", "exec", "c", "ind", "ani", "data", "min", "a", "bin", "at"], "order": ["ai", "dir", "orig", "index", "seed", "rec", "rank", "error", "err", "id", "rule", "count", "er", "end", "asc", "info", "r", "max", "record", "iter", "part", "ini", "inner", "sort", "level", "code", "page", "init", "ii", "reverse", "first", "oder", "si", "ordered", "ind", "limit", "start", "Order", "next", "min", "pos", "grade", "use", "ord", "orders", "list", "en", "length"], "direction": ["depth", "dir", "ward", "dist", "rec", "weight", "dc", "quad", "normal", "phase", "mode", "forward", "degree", "dy", "irection", "dim", "dn", "period", "wd", "range", "sort", "orient", "di", "vert", "unit", "oriented", "reverse", "ii", "gradient", "direct", "desc", "directory", "d", "ind", "round", "diff", "linear", "dest", "length", "step", "directed"], "tns_coefs": ["tns_cofferences", "tns_corefsets", "tns_coeffments", "tns_coeffors", "tns_coefds", "tns_corefs", "tns_coafds", "tns_coefors", "tns_Coffds", "tns_coafsets", "tns_Coffs", "tns_coecds", "tns_coffds", "tns_coecments", "tns_coffors", "tns_coffs", "tns_coffnames", "tns_coefferences", "tns_corefnames", "tns_coefnames", "tns_coecsets", "tns_Coffsets", "tns_coefsets", "tns_coecs", "tns_coeffnames", "tns_coafors", "tns_Coefsets", "tns_coefments", "tns_coffsets", "tns_Coefds", "tns_coeffs", "tns_coeferences", "tns_Coefments", "tns_Coffments", "tns_coreferences", "tns_coeffsets", "tns_coeffds", "tns_coafs", "tns_coffments", "tns_Coefs"], "ltp_used": ["ltp_using", "ltp_active", "ltnp_needed", "ltps_using", "ltps_active", "ltnp_use", "ltnp_enabled", "ltp_enabled", "ltnp_used", "ltp_needed", "ltps_used", "ltp_use"], "w": ["weight", "wp", "win", "aw", "wt", "z", "iw", "nc", "wait", "ow", "wave", "W", "wa", "r", "wl", "kw", "v", "h", "wx", "wd", "nw", "c", "wh", "d", "f", "wind", "sw"], "filt": ["ofilt", "flet", "efilt", "flt", "efitter", "ofitter", "oflet", "tflet", "tfilt", "tfitter", "tflt", "oflt", "eflt", "eflet", "fitter"], "start_i": ["start_in", " start_p", " start_j", " start_in", "end_i", "start_j", "end_start", "start_I", "end_j", "start_p", "end_I", "start_start"], "len": ["li", "n", "win", "base", "z", "lim", "net", "count", "end", "lib", "non", "lu", "fin", "size", "en", "l", "la", "L", "part", "lon", "lock", "line", "lf", "lin", "ii", "el", "ll", "loc", "limit", "seq", "start", "ind", "f", "lc", "val", "dl", "min", "pos", "list", "lp", "Len", "length", "ln"], "i": ["x", "ai", "b", "index", "mini", "oi", "li", "n", "pi", "ie", "ji", "z", "id", "yi", "info", "r", "iu", "ip", "hi", "ix", "gi", "bi", "l", "v", "y", "fi", "io", "uri", "xi", "ini", "p", "qi", "m", "zi", "ic", "di", "I", "u", "it", "ii", "my", "init", "k", "si", "e", "c", "start", "ind", "f", "eni", "cli", "api", "ui", "phi", "ci", "o", "ni", "ri", "a", "mi"], "j": ["jet", "b", "x", "adj", "js", "index", "li", "n", "ja", "ie", "key", "aj", "z", "journal", "note", "jen", "jo", "jam", "g", "jon", "job", "l", "v", "y", "h", "ij", "py", "oj", "bj", "p", "qi", "m", "json", "t", "obj", "u", "it", "ii", "je", "jp", "jc", "k", "e", "jj", "c", "start", "ind", "d", "pt", "jit", "f", "jl", "uj", "q", "next", "ui", "pr", "o", "jing", "ji", "length", "dj", "J"], "inc": ["index", "dir", "num", "adj", "rec", "n", "dc", "alpha", "win", "z", "inter", "nc", "keep", "inn", "count", "inf", "ir", "end", "req", "asc", "zip", "sp", "r", "update", "pp", "cycle", "iter", "Inc", "acc", "enc", "ini", "inner", "ins", "sort", "p", "pack", "fr", "zi", "inst", "page", "init", "ii", "rc", "lin", "k", "loc", "c", "ind", "d", "f", "start", "lc", "diff", "INC", "min", "incre", "ci", "sign", "circ", "step"], "tmp": ["b", "front", "mp", "wp", "nb", "cmp", "proc", "cp", "stuff", "test", "sb", "perm", "zip", "done", "sp", "rb", "up", "cache", "result", "pp", "attr", "params", "job", "emp", "fp", "v", "slice", "part", "src", "prep", "frac", "py", "pre", "area", "app", "p", "code", "obj", "table", "page", "now", "input", "flat", "jp", "ppo", "amp", "txt", "rup", "sup", "start", "output", "copy", "cb", "img", "dat", "data", "map", "np", "dest", "nm", "ff", "st", "pm", "pad", "temp", "post", "fb"]}}
{"project": "FFmpeg", "commit_id": "69c1fe7c9c9bc85eebfc02c6a19caf7e88cd74ff", "target": 0, "func": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n\n                                AVPacket *pkt)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n\n    uint8_t *start, *end, *data = pkt->data;\n\n    ebml_master blockgroup;\n\n    char buffer[2048];\n\n\n\n    while (data_size) {\n\n        int duration = ass_get_duration(data);\n\n        max_duration = FFMAX(duration, max_duration);\n\n        end          = memchr(data, '\\n', data_size);\n\n        size         = line_size = end ? end - data + 1 : data_size;\n\n        size        -= end ? (end[-1] == '\\r') + 1 : 0;\n\n        start        = data;\n\n        for (i = 0; i < 3; i++, start++)\n\n            if (!(start = memchr(start, ',', size - (start - data))))\n\n                return max_duration;\n\n        size -= start - data;\n\n        sscanf(data, \"Dialogue: %d,\", &layer);\n\n        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",\n\n                     s->streams[pkt->stream_index]->nb_frames, layer);\n\n        size = FFMIN(i + size, sizeof(buffer));\n\n        memcpy(buffer + i, start, size - i);\n\n\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"Writing block at offset %\" PRIu64 \", size %d, \"\n\n               \"pts %\" PRId64 \", duration %d\\n\",\n\n               avio_tell(pb), size, pkt->pts, duration);\n\n        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n\n                                       mkv_blockgroup_size(size));\n\n        put_ebml_id(pb, MATROSKA_ID_BLOCK);\n\n        put_ebml_num(pb, size + 4, 0);\n\n        // this assumes stream_index is less than 126\n\n        avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n\n        avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n\n        avio_w8(pb, 0);\n\n        avio_write(pb, buffer, size);\n\n        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n\n        end_ebml_master(pb, blockgroup);\n\n\n\n        data      += line_size;\n\n        data_size -= line_size;\n\n    }\n\n\n\n    return max_duration;\n\n}\n", "idx": 24768, "substitutes": {"s": ["b", "sf", "n", "sl", "qs", "a", "sci", "sc", "sv", "S", "gs", "self", "http", "space", "rs", "os", "ssl", "ctx", "sb", "fs", "g", "storage", "bs", "session", "ps", "sa", "v", "sam", "service", "p", "cs", "t", "su", "ns", "sg", "si", "e", "c", "f", "ss", "spec", "ls", "ds", "services", "sq", "server", "o", "client", "ses", "sys", "stats"], "pb": ["b", "platform", "mp", "wp", "bc", "bh", "sb", "prot", "g", "bps", "p", "gb", "dp", "pro", "tp", "fb", "buf", "num", "pg", "pl", "python", "rb", "fp", "ib", "kt", "xb", "eb", "plug", "pit", "bp", "pc", "length", "bf", "typ", "api", "dl", "client", "_", "plugin", "proc", "summary", "PB", "pkg", "all", "jp", "amp", "pd", "uf", "np", "plugins", "parser", "vp", "ctx", "bos", "r", "pp", "hub", "ppa", "tc", "db", "uc", "d", "cb", "lb", "pos", "lp", "pa"], "pkt": ["apdt", " packet", " pqt", "apacket", "Pcp", " pdt", "mnt", "matt", "Patt", "pnt", "pqt", " pnt", "fnt", "packet", "patt", "lacket", "Pqt", "apnt", "placket", " pft", "mct", "plkt", "pke", "Pdt", "fkt", "Pke", "pcp", "apke", "lkt", "plct", "mdt", "mcp", "mkt", " pct", "fct", "lnt", "pdt", "pft", "pct", "Pft", " pcp", "plft", "Packet", "apkt", "mqt", "apqt", "facket", "Pct", "macket", "mke", "Pnt", "Pkt", "latt"], "mkv": ["skvt", "mkf", "cpf", "kvd", "kf", "ikw", " mkf", "mkvt", "skv", " mkvd", " mkvt", "mkvd", "cpw", "kw", "skvd", "skf", "ikc", "kc", "cpc", "kv", "mkw", "mkc", "ikf", "kvt", "cpv", "ikv"], "i": ["index", "x", "ai", "mini", "b", "li", "pi", "n", "ie", "inter", "z", "idi", "id", "j", "info", "hi", "ip", "position", "esi", "ix", "ice", "gi", "iter", "bi", "is", "l", "ti", "y", "fi", "slice", "part", "uri", "xi", "ini", "uni", "inner", "multi", "p", "qi", "zi", "m", "line", "di", "I", "it", "init", "ii", "si", "e", "uli", "c", "ind", "d", "eni", "cli", "f", "layer", "ui", "ci", "phi", "ni", "length", "mi", "offset"], "size": ["mode", "send", "fee", "g", "ice", "core", "line", "address", "page", "scale", "si", "eni", "sized", "ci", "en", "name", "mi", "x", "num", "span", "n", "shape", "six", "l", "large", "SIZE", "speed", "capacity", "small", "e", "c", "ui", "use", "offset", "ize", "shift", "timeout", "bytes", "len", "position", "max", "empty", "code", "unit", "extra", "engine", "weight", "align", "member", "body", "storage", "number", "stream", "area", "time", "loc", "sec", "content", "Size", "length", "sum"], "line_size": [" line2sized", "data_size", " line_len", " line2len", "line_scale", "line_sized", "data_width", "line_count", " line2scale", " line_sized", "line2len", "line_len", "line2scale", "line_width", " line2size", "data_count", "line2sized", "line2size", " line_scale"], "start": ["seed", "ie", "id", "Start", "type", "new", "p", "line", "address", "scale", "si", "block", "art", "name", "cur", "x", "span", "key", "set", "stop", "space", "info", "add", "style", "parse", "e", "ind", "ad", "use", "grade", "st", "step", "offset", "index", "mid", "error", "j", "shift", "len", "starting", "current", "sp", "max", "get", "root", "resource", "slice", "rest", "middle", "min", "started", "alpha", "source", "work", "v", "part", "before", "range", "it", "init", "time", "like", "d", "from", "next", "load", "pos", "pad", "se", "length"], "end": ["index", "last", "x", "after", "ended", "ed", "set", "id", "edge", "stop", "body", "send", "END", "len", "begin", "update", "max", "open", "h", "all", "style", "enc", "inner", "ending", "p", "change", "est", "line", "address", "ent", "except", "End", "feed", "append", "e", "exec", "limit", "desc", "pend", "f", "until", "next", "event", "content", "ad", "pos", "use", "nd", "en", "length", "post", "offset"], "data": ["li", "blocks", "id", "cache", "result", "new", "reader", "zero", "inner", "frame", "p", "complete", "address", "device", "scale", "media", "three", "block", "dd", "gap", "a", "buf", "parent", "da", "space", "text", "audio", "window", "record", "open", "feed", "delay", "api", "ui", "ad", "step", "offset", "dist", "message", "shift", "timeout", "bytes", "response", "len", "current", "resource", "slice", "queue", "code", "stage", "di", "channel", "Data", "input", "frames", "layer", "middle", "dat", "video", "date", "results", "alpha", "base", "source", "body", "actions", "DATA", "image", "work", "stream", "area", "batch", "one", "first", "sample", "time", "d", "next", "load", "content", "pos", "memory", "pad", "length"], "blockgroup": ["poolgroup", "BlockGROUP", "blockmap", " blockGROUP", "poolmap", "rowGroup", "rowgroups", "blockgroups", "blockGROUP", " blockgroups", "rowgroup", " blockGroup", "blockGroup", " blockblock", "bytegroups", "byteGroup", "Blockmap", "byteblock", "rowblock", "bytegroup", "poolGROUP", " blockmap", "blockblock", "Blockgroup"], "buffer": ["buf", "b", "cap", "video", "byte", "shape", "source", "message", "texture", "wave", "text", " buffers", "audio", "offset", "header", "binary", "window", "image", "cache", "position", "duration", "result", "Buffer", "iter", "resource", "url", "slice", "null", "frame", "batch", "queue", "code", "p", "line", "cube", "channel", "read", "address", "device", "input", "block", "transfer", "f", "buff", "gap", "layer", "document", "memory", "pad", "length", "bin", "uffer"]}}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "substitutes": {"block_name": ["block_prefix", "blockfprefix", "blockfsize", " block_address", " block_prefix", "blockfaddress", "block_size", " block_size", "block_address", "blockfname"], "host_addr": ["block_offset", "block_id", "host_offset", "host_size", "host_name", "host_address", "block_addr", "hostbaddress", "hostacaddr", "hostbname", "hostbaddr", "hostacsize", "host_id", "block_size", "block_address", "hostacoffset", "hostbid", "hostacaddress"], "offset": ["index", "set", "parent", "align", "base", "entry", "error", "end", "Offset", "len", "position", "ref", "slice", "off", "style", "range", "origin", "address", "prefix", "addr", "loc", "limit", "start", "data", "pos", "order", "pointer"], "length": ["depth", "index", "port", "base", "filename", "shape", "count", "len", "pull", "info", "build", "position", "duration", "type", "sequence", "l", "url", "slice", "style", "range", "level", "line", "address", "match", "read", "angle", "ength", "view", "family", "block", "limit", "seq", "padding", "library", "delay", "Length", "mount", "section", "pad"], "opaque": ["opcos", "oppaques", "oppaque", "Opatile", "opmac", " oprobe", "opatile", " opcos", "Opaque", " opmac", " opaques", "ospaque", "Opaques", "Oprobe", "ospcos", " opatile", "opusaque", "opusatile", "opusmac", "ospmac", "oppatile", "opaques", "oprobe", "opprobe", "ospatile", "opuscos"], "mis": ["scope", "pas", "rec", "mic", "Mis", "voc", "mn", "abi", "os", "proc", "mes", "bos", "fs", "mc", "isi", "session", "params", "cas", "is", "tis", "miss", "fi", "osi", "cci", "oc", "oci", "m", "mos", "iss", "acs", "mac", "ms", "mas", "pc", "vis", "sys", "mi"], "reg_struct": ["mod_feat", "rec_struct", "Reg_struct", "reg2construct", "reg_config", "reg_construct", "regacstruct", "reg_const", "reg2config", "Reg_feat", " reg_addr", " reg_ptr", "mod_struct", "mod_config", "reg2const", "rec_config", "reg_string", " reg_feat", " reg_string", "reg_feat", "rec_construct", "reg_addr", "reg2struct", "reg_return", "regacfeat", "reg_ptr", "reg_int", " reg_Struct", "regacnat", " reg_nat", "regacint", "mod_return", "reg_nat", "rec_const", "reg_Struct", "Reg_nat", "Reg_int"]}}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void draw_bar_yuv(AVFrame *out, const float *h, const float *rcp_h,\n\n                         const ColorFloat *c, int bar_h)\n\n{\n\n    int x, y, yh, w = out->width;\n\n    float mul, ht, rcp_bar_h = 1.0f / bar_h;\n\n    uint8_t *vy = out->data[0], *vu = out->data[1], *vv = out->data[2];\n\n    uint8_t *lpy, *lpu, *lpv;\n\n    int lsy = out->linesize[0], lsu = out->linesize[1], lsv = out->linesize[2];\n\n    int fmt = out->format;\n\n\n\n    for (y = 0; y < bar_h; y += 2) {\n\n        yh = (fmt == AV_PIX_FMT_YUV420P) ? y / 2 : y;\n\n        ht = (bar_h - y) * rcp_bar_h;\n\n        lpy = vy + y * lsy;\n\n        lpu = vu + yh * lsu;\n\n        lpv = vv + yh * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            if (h[x] <= ht) {\n\n                *lpy++ = 16;\n\n                *lpu++ = 128;\n\n                *lpv++ = 128;\n\n            } else {\n\n                mul = (h[x] - ht) * rcp_h[x];\n\n                *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (fmt == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n\n\n        ht = (bar_h - (y+1)) * rcp_bar_h;\n\n        lpy = vy + (y+1) * lsy;\n\n        lpu = vu + (y+1) * lsu;\n\n        lpv = vv + (y+1) * lsv;\n\n        for (x = 0; x < w; x += 2) {\n\n            /* u and v are skipped on yuv420p */\n\n            if (fmt != AV_PIX_FMT_YUV420P) {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (out->format == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24787, "substitutes": {"out": ["cmd", "array", "in", "n", "parent", "error", "png", "base", "outs", "err", "by", "source", "connection", "window", "op", "Out", "up", "image", "word", "group", "model", "down", "cache", "new", "result", "band", "io", "conn", "dot", "off", "OUT", "figure", "part", "version", "draw", "again", "conv", "line", "one", "obj", "prefix", "w", "page", "input", "device", "it", "init", "process", "point", "sync", "output", "img", "object", "next", "data", "call", "outer", "copy", "global", "o", "client", "user", "name", "a", "bin", "at"], "h": ["b", "n", "oh", "ch", "ih", "home", "z", "err", "http", "both", "bh", "hd", "end", "sh", "header", "r", "hi", "g", "hl", "host", "l", "v", "hh", "hs", "hm", "p", "code", "m", "history", "rh", "t", "u", "w", "ah", "k", "ha", "e", "ph", "d", "f", "hr", "uh", "q", "H", "o"], "rcp_h": ["rcp_p", "rcpxc", "rcp_hm", "rcjpxh", "rcpamheight", "rcp_c", "rcp_sh", "rcp2c", "rcp2sh", "rcpamh", "rcpamhm", "rcjp_height", "rcpamc", "rcP_c", "rcP_sh", "rcjpxheight", "rcjpxc", "rcP_h", "rcpxh", "rcjpxhm", "rcP_p", "rcjp_h", "rcjp_c", "rcjp_hm", "rcp2h", "rcp2p", "rcpxheight", "rcp_height", "rcpxhm"], "c": ["b", "n", "dc", "ch", "xc", "sc", "nc", "ac", "cc", "cp", "ctx", "r", "arc", "g", "mc", "cache", "cycle", "v", "ce", "cf", "con", "cl", "p", "code", "m", "cs", "cr", "t", "cn", "s", "conv", "u", "C", "w", "cm", "ct", "k", "e", "d", "f", "ec", "i", "q", "co", "ci", "a"], "bar_h": ["bar0height", "bar_H", " bar_hh", " bar_rh", " bar_hm", "bar_height", "car_hp", " bar_sh", "bar_z", "car_z", "bar_c", "bar_hp", "bar_sh", "car_c", "bar0sh", "bar0h", "bar0H", " bar_H", " bar_w", " bar_c", "bar_hh", "car_h", "bar_rh", "bar_w", " bar_height", "bar_hm"], "x": ["b", "in", "id", "xxx", "px", "cross", "p", "xx", "gy", "dx", "u", "plus", "el", "k", "any", "xs", "xml", "name", "en", "a", "n", "zx", "key", "rx", "by", "xc", "xt", "wa", "host", "hi", "l", "t", "xy", "e", "event", "step", "ext", "index", "sex", "z", "j", "full", "ix", "wx", "pe", "on", "code", "m", "ux", "s", "ex", "w", "my", "this", "f", "min", "ctx", "X", "ady", "r", "ip", "image", "work", "v", "xp", "xi", "change", "tx", "time", "ph", "d", "i", "fx", "sw", "yx"], "y": ["b", "oy", "yn", "yl", "Y", "n", "ny", "ch", "z", "ky", "j", "cy", "dy", "yi", "hi", "ye", "ys", "sy", "yo", "l", "ish", "v", "yr", "py", "ym", "hy", "p", "sky", "xx", "yt", "t", "u", "w", "xy", "ey", "d", "ya", "i", "f", "ay", "iy", "yy", "o", "yd", "ry", "height", "ty"], "yh": ["xhr", " ygh", "vyh", "xh", "vybh", " yf", "yH", "eyh", "eygh", "eyhr", "vyH", "xbh", "Ygh", " yv", "vyw", "cyw", "eyH", " yhr", "cyH", "YH", "eyv", "pyhi", "yf", "cyh", "cybh", "eyf", "yhr", " yhi", "Yv", "eyhi", "yw", "pyH", "xf", "pyhr", "xH", "Yh", "ygh", "yhi", "yv", "ybh", "pyh", " yH", "xw"], "mul": ["mur", "tmul", "smuli", "manduli", "Mull", " mulus", "amuli", "tmuli", "mmuli", "mmul", "emulus", "lull", "mush", "Mulus", "mandul", " mall", "tmular", "Muli", "muli", "mmush", "Mur", "tmall", "muls", " muli", "smUL", "emul", "lulus", "Mul", " mur", "amuls", "emull", "amular", "mandular", "smlu", "Mule", "smul", " mush", "mull", "nmul", "omall", "tmull", "mmule", " mlu", "mall", "mular", "mUL", "omular", " mull", "omuli", "mule", "omul", " mule", "MUL", "nmlu", "Mush", " mular", " mUL", "mmull", "emuli", " muls", "mmUL", "mulus", "luli", "amul", "nmUL", "Mlu", "nmulus", "manduls", "tmur", "lul", "mlu"], "ht": ["fw", "hhh", "dq", "gp", "wp", "dt", "ch", "ih", "wt", "iw", "gh", "bh", "hd", "th", "zh", "lv", "hw", "qq", "he", "sh", "vt", "gt", "hi", "host", "tt", "hl", "ich", "hart", "mot", "wx", "hh", "wd", "hy", "hm", "hs", "vc", "yt", "rh", "hat", "force", "ft", "hard", "ct", "att", "ush", "rt", "pt", "hp", "lat", "hr", "uh", "q", "yy"], "vy": ["oy", "ny", "ky", "sv", "wy", "cy", "zh", "dy", "yi", "vt", "ady", "nv", "fy", "hi", "px", "yo", "sy", "v", "py", "hy", "vc", "sky", "gb", "xx", "yt", "xy", "si", "ey", "ya", "iy", "yy", "vi", "ry", "ty"], "vu": ["vg", "ju", "env", "pu", "ve", "wy", "lv", "vp", "vt", "lu", "von", "nv", "iu", "vet", "vid", "uu", "v", "mu", "vc", "uci", "vr", "u", "su", "qv", "vo", "vin", "nu", "yu", "va", "ui", "cu", "vi", "tu", "ni", "uv"], "vv": ["vg", "vs", "sv", "ve", "hd", "lv", "zh", "hw", "vp", "xxx", "vt", "von", "nv", "vet", "vid", "ov", "uu", "cv", "dn", "v", "vag", "hh", "wx", "vc", "xx", "nov", "vr", "u", "eve", "vd", "qv", "su", "vo", "nu", "tv", "va", "vi", "yy", "uv"], "lpy": ["mpu", " lpi", "lbsy", "llpe", "lbpa", "Lpi", "llpy", "elsy", " lpa", "lbpy", "dlpi", "mpy", " lmi", "elpa", "llpu", "Lcp", "lpa", "dlmi", "llcp", "lbpu", "dlcp", "dlpy", "elpu", "elcp", "dlpa", "elpy", " lcp", "elpi", "Lpy", "Lmi", "mcp", "lsy", "dlsy", "Lpa", "mpe", "lpe", "lmi", "lcp", " lpe", " lsy", "lpi"], "lpu": [" lpi", "Lsu", "lgpu", "lwu", "klcu", " lsu", "lipc", "lipu", "Lpi", " lpa", "lcpu", "elpa", "lipa", " lwu", "lccu", "klpy", "lpa", "slpc", "elwu", "lcu", "lpc", "elpu", " lpc", " lcu", "lcgpu", "elpy", "lpi", "Lpy", "lsu", "elpc", "slsu", "klpi", "lcsu", "slpu", "Lpa", "liwu", "slpy", "klpa", "klsu", "klgpu", "klpu", " lgpu", "Lpu", "elsu"], "lpv": ["lipf", "ppu", "ppp", "pelversion", "pelf", "fpv", "dlv", "bpp", "ilkv", "ppv", "LPu", "lipu", "pbj", "bpv", "ilkver", "dlversion", "lipp", "lpp", "dlu", "bpview", "dpva", "dpv", "lipversion", "lpf", "bpu", "ilku", "LPf", "lipview", "lipj", "fpview", "LPversion", "pbversion", "lbp", "bpvin", "lbu", "lpj", "dpu", "pelvin", "pelu", "dpp", "dlf", "fpu", "lpver", "LPj", "lipv", "lpversion", "pelv", "lbv", "lpva", "fpp", "LPv", "pelver", "ppva", "bpver", "pbv", "lpview", "lpvin", "lbva", "pbf", "ilkvin"]}}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n", "idx": 24794, "substitutes": {"opts": ["obts", "optts", " ops", "OPtt", "OPt", " optt", "ops", "optops", "obs", "opttt", "obt", "obops", "opops", "OPts", "OPs", "OPops", " opt", "optt", "opt"], "_chr": [" _chtr", " _corsr", " _chm", " _corr", "_chtr", "_Chm", "_achr", "_corrs", " _chrs", " _Chr", "_Chr", " _corrs", "_ichm", " _Chsr", "_ichrs", "_schsr", " _chsr", "_achm", "_ichsr", " _Chm", "_chrs", "_chsr", "_schrs", "_corr", "_achsr", "_Chrs", " _cortr", "_schtr", "_corsr", "_achrs", "_Chsr", "_chm", "_ichr", "_schr", " _Chrs", "_cortr"], "file_out": ["fd_path", "file_path", "file_ex", "file_in", "file__OUT", "fd_window", "file__in", "file__path", "fd_ex", "fd_OUT", "file_OUT", "fd_in", "file__out", "file_window"], "fd_out": ["file_in", "FD_again", "file_id", "fd_outs", "file_again", "fd_again", "fd_Out", "fd_id", "file_outs", "FD_out", "file_Out", "FD_in", "fd_OUT", "FD_Out", "fd_in", "file_OUT"]}}
{"project": "FFmpeg", "commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "target": 1, "func": "int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int i, len;\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        H264Picture *sorted[32];\n\n        int cur_poc, list;\n\n        int lens[2];\n\n\n\n        if (FIELD_PICTURE(h))\n\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n\n        else\n\n            cur_poc = h->cur_pic_ptr->poc;\n\n\n\n        for (list = 0; list < 2; list++) {\n\n            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);\n\n            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);\n\n            av_assert0(len <= 32);\n\n\n\n            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                                  sorted, len, 0, h->picture_structure);\n\n            len += build_def_list(h->default_ref_list[list] + len,\n\n                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                                  h->long_ref, 16, 1, h->picture_structure);\n\n            av_assert0(len <= 32);\n\n\n\n            if (len < sl->ref_count[list])\n\n                memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n\n            lens[list] = len;\n\n        }\n\n\n\n        if (lens[0] == lens[1] && lens[1] > 1) {\n\n            for (i = 0; i < lens[0] &&\n\n                        h->default_ref_list[0][i].parent->f.buf[0]->buffer ==\n\n                        h->default_ref_list[1][i].parent->f.buf[0]->buffer; i++);\n\n            if (i == lens[0]) {\n\n                FFSWAP(H264Ref, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n            }\n\n        }\n\n    } else {\n\n        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                              h->short_ref, h->short_ref_count, 0, h->picture_structure);\n\n        len += build_def_list(h->default_ref_list[0] + len,\n\n                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                              h-> long_ref, 16, 1, h->picture_structure);\n\n        av_assert0(len <= 32);\n\n\n\n        if (len < sl->ref_count[0])\n\n            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n\n    }\n\n#ifdef TRACE\n\n    for (i = 0; i < sl->ref_count[0]; i++) {\n\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n\n                (h->default_ref_list[0][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                h->default_ref_list[0][i].pic_id,\n\n                h->default_ref_list[0][i].parent->f.data[0]);\n\n    }\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        for (i = 0; i < sl->ref_count[1]; i++) {\n\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n\n                    (h->default_ref_list[1][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                    h->default_ref_list[1][i].pic_id,\n\n                    h->default_ref_list[1][i].parent->f.data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24818, "substitutes": {"h": ["b", "adh", "hash", "oh", "ch", "ih", "z", "http", "gh", "bh", "hd", "dh", "zh", "th", "hw", "he", "sh", "header", "ctx", "r", "host", "enh", "hl", "eh", "hi", "image", "g", "hist", "l", "v", "hh", "hs", "hm", "p", "m", "history", "rh", "s", "t", "u", "w", "hel", "ah", "e", "ha", "c", "ph", "hp", "f", "img", "hr", "uh", "ul", "q", "H", "ht", "her", "o", "en", "kh", "FH"], "sl": ["coll", "sf", "pl", "ih", "sc", "gl", "lr", "sth", "sh", "ssl", "sel", "sb", "kl", "hl", "l", "sa", "url", "SL", "src", "al", "il", "cl", "p", "spl", "fr", "util", "s", "su", "el", "si", "loc", "c", "ph", "f", "sec", "lc", "ls", "tl", "Sl", "ul", "serv", "ml", "sn", "sw", "api", "sil", "sch", "fl", "cur"], "i": ["index", "x", "ai", "num", "b", "li", "pi", "n", "ie", "z", "id", "j", "count", "yi", "r", "iu", "ip", "ix", "field", "gi", "ri", "bi", "l", "ti", "v", "fi", "mu", "y", "io", "xi", "ini", "p", "code", "qi", "zi", "di", "I", "chi", "u", "ii", "si", "e", "c", "ani", "ind", "start", "f", "eni", "d", "ui", "ci", "pos", "phi", "ni", "ji", "ki"], "len": ["bl", "li", "ie", "led", "split", "id", "count", "cache", "syn", "url", "ref", "p", "line", "lf", "ler", "el", "elt", "limit", "sil", "en", "name", "ln", "num", "span", "n", "err", "lim", "vec", "compl", "l", "L", "conn", "rev", "pre", "lon", "vert", "lin", "lc", "length", "val", "dl", "le", "Len", "bin", "z", "lib", "lu", "il", "ll", "fn", "seq", "str", "min", "lang", "body", "fin", "size", "la", "v", "part", "ld", "fun", "fl", "lit", "ul", "lt", "pos", "lp"], "sorted": ["unsorter", "Sorters", "isressed", " sorting", "psorts", " sorter", " sorters", "siteslied", "gort", "forted", "sitesorted", "fources", "sorting", " sorts", "psources", "opensored", "gorted", "Sorting", "unsorters", "forting", " sources", "slied", "unsorted", "sources", "isorted", "opensressed", "opensorted", "sort", "sressed", "sitesressed", "islied", "sorters", "psorted", "sorter", "unsort", "Sorted", "Sorter", "forts", "sitesored", "psorting", "Sort", "gorting", " sort", "sorts", "openslied", "sored", "isored", "gorter"], "cur_poc": ["cur_sac", "cur_soc", "cur_Perc", "cur_peroint", "cur_jac", "cur_pect", "cur_pow", "cur_npoo", "cur_Pock", "cur_proc", "cur_phpac", "cur_piac", "cur_jOC", "cur_soint", "cur_Proc", "cur_pioc", "cur_fOC", "cur_mpoint", "cur_npoci", "cur_POC", "cur_wpoc", "cur_Poc", "cur_joc", "cur_mpac", "cur_pOC", "cur_peroc", "cur_wpoci", "cur_piect", "cur_Poci", "cur_jerc", "cur_poci", "cur_perow", "cur_perac", "cur_pock", "cur_phproc", "cur_mproc", "cur_Pect", "cur_mpoc", "cur_fac", "cur_poo", "cur_piock", "cur_point", "cur_Pow", "cur_phpoint", "cur_Pac", "cur_Point", "cur_sow", "cur_foc", "cur_npoc", "cur_vpoc", "cur_ferc", "cur_wpac", "cur_Poo", "cur_vpac", "cur_vpect", "cur_wpoo", "cur_npac", "cur_perc", "cur_phpoc", "cur_vpock", "cur_pac"], "list": ["loop", "bl", "li", "entry", "id", "keep", "count", "lv", "g", "cache", "type", "cont", "p", "match", "ler", "page", "old", "view", "block", "lp", "name", "en", "x", "coll", "pl", "n", "set", "key", "parent", "rel", "gl", "err", "LIST", "l", "L", "low", "pre", "cl", "arr", "listed", "List", "feat", "e", "c", "lc", "cli", "tl", "dl", "val", "st", "index", "lists", "test", "full", "lu", "hl", "all", "null", "config", "queue", "code", "rest", "acl", "this", "seq", "lat", "str", "base", "lex", "chain", "alt", "la", "v", "part", "range", "batch", "ld", "ul", "diff", "load", "pos", "length"], "lens": [" loss", "loss", "lizes", "elowers", "sloss", "celenth", "lents", "slents", " lenses", "elenth", " lowers", "celkens", "lenth", "lening", "olens", " lening", "slenth", "elens", "flents", "olening", "olkens", "olenth", "Lents", "Loss", "celens", " lkens", "elents", "eloss", "slens", "celening", "flens", "elenses", "Lens", "flizes", " lenth", "lenses", "lowers", "slenses", "elizes", "slen", "elen", "Lenth", "Lenses", "lkens", " lents", "flowers", "Len", " lizes"]}}
{"project": "qemu", "commit_id": "a3f409cb4a35d9aa6a4d24a7a1e05423e189cb7a", "target": 1, "func": "static void vtd_init(IntelIOMMUState *s)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    memset(s->csr, 0, DMAR_REG_SIZE);\n\n    memset(s->wmask, 0, DMAR_REG_SIZE);\n\n    memset(s->w1cmask, 0, DMAR_REG_SIZE);\n\n    memset(s->womask, 0, DMAR_REG_SIZE);\n\n\n\n    s->iommu_ops.translate = vtd_iommu_translate;\n\n    s->iommu_ops.notify_started = vtd_iommu_notify_started;\n\n    s->root = 0;\n\n    s->root_extended = false;\n\n    s->dmar_enabled = false;\n\n    s->iq_head = 0;\n\n    s->iq_tail = 0;\n\n    s->iq = 0;\n\n    s->iq_size = 0;\n\n    s->qi_enabled = false;\n\n    s->iq_last_desc_type = VTD_INV_DESC_NONE;\n\n    s->next_frcd_reg = 0;\n\n    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |\n\n             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;\n\n    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;\n\n\n\n    if (x86_iommu->intr_supported) {\n\n        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;\n\n    }\n\n\n\n    vtd_reset_context_cache(s);\n\n    vtd_reset_iotlb(s);\n\n\n\n    /* Define registers with default values and bit semantics */\n\n    vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n\n    vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n\n    vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n\n    vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n\n    vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n\n    vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n\n    vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n\n\n\n    /* Advanced Fault Logging not supported */\n\n    vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n\n    vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n\n    vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n\n\n\n    /* Treated as RsvdZ when EIM in ECAP_REG is not supported\n\n     * vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0xffffffffUL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n\n\n\n    /* Treated as RO for implementations that PLMR and PHMR fields reported\n\n     * as Clear in the CAP_REG.\n\n     * vtd_define_long(s, DMAR_PMEN_REG, 0, 0x80000000UL, 0);\n\n     */\n\n    vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n\n\n\n    vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n", "idx": 24824, "substitutes": {"s": ["js", "b", "scope", "in", "S", "rs", "ssl", "sb", "fs", "g", "states", "h", "hs", "p", "u", "sets", "si", "sync", "sq", "a", "as", "native", "n", "qs", "set", "conf", "state", "gs", "es", "l", "ks", "has", "service", "cs", "t", "su", "e", "c", "sports", "ss", "spec", "stat", "o", "stats", "site", "its", "status", "vs", "self", "current", "session", "ts", "is", "m", "sym", "sg", "f", "ds", "server", "plugins", "ses", "sys", "http", "os", "private", "r", "storage", "ps", "ins", "south", "ns", "settings", "an", "d", "i", "sec", "ls", "services", "us", "se", "sum"], "x86_iommu": ["x86_uiomu", "x86_iommur", "x86_xiommur", "x86_xiommu", "x86_iompu", "x86_xiormmu", "x86_xiormu", "x86_iompur", "x86_iormui", "x86_uiommur", "x86_iormmu", "x86_uiommou", "x86_uiomur", "x86_uiommu", "x86_uiommus", "x86_xiormur", "x86_iammui", "x86_iomur", "x86_xiommui", "x86_iomus", "x86_iomui", "x86_iormus", "x86_iomou", "x86_iormur", "x86_iompus", "x86_iammmu", "x86_uiomou", "x86_iormu", "x86_iommus", "x86_iomu", "x86_uiomus", "x86_iormou", "x86_iammu", "x86_xiommmu", "x86_iammur", "x86_iompou", "x86_iommui", "x86_xiormui", "x86_iommmu", "x86_iommou"]}}
{"project": "FFmpeg", "commit_id": "ce19aec15b4291dc48e791d89a1f940babc22cdc", "target": 0, "func": "const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)\n\n{\n\n    av_assert2(p < end);\n\n\n\n    end-=2;\n\n    p++;\n\n    for(;p<end; p+=2){\n\n        if(!*p){\n\n            if     (!p[-1] && p[1]) return p - 1;\n\n            else if(!p[ 1] && p[2]) return p;\n\n        }\n\n    }\n\n    return end+2;\n\n}\n", "idx": 24829, "substitutes": {"av_restrict": ["av_refricted", "av_Restricted", "av_resricted", "av_refrict", "av_distact", "av_distriction", "av_refact", "av_restriction", "av_district", "av_stact", "av_refriction", "av2refricted", "av_distrupt", "av_restricted", "av_strict", "av2refrict", "av_resact", "av_Restrict", "av2refact", "av2refriction", "av_Restact", "av_resrict", "av2restact", "av_districted", "av_stricted", "av2restricted", "av_restrupt", "av_restact", "av2restriction", "av2restrict", "av_resriction", "av_Restrupt", "av_strupt"], "p": ["b", "port", "patch", "h", "ap", "dp", "u", "page", "k", "pat", "tp", "a", "x", "n", "path", "parent", "cp", "end", "l", "fp", "pid", "pre", "t", "e", "point", "c", "start", "bp", "pc", "api", "o", "pm", "at", "after", "j", "sp", "op", "up", "y", "pe", "m", "s", "w", "po", "jp", "f", "q", "data", "np", "pi", "prev", "r", "ip", "pp", "ps", "v", "part", "change", "one", "P", "pn", "d", "i", "next", "pr", "pos", "lp", "pa"]}}
{"project": "qemu", "commit_id": "736d120af4bf5f3e13b2f90c464b3a24847f78f0", "target": 0, "func": "void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n", "idx": 24847, "substitutes": {"env": ["scope", "entry", "eff", "ou", "ne", "cache", "qt", "oa", "core", "args", "ev", "el", "ah", "txt", "en", "context", "dep", "pg", "dict", "conf", "err", "nc", "er", "end", "conn", "enc", "erv", "theme", "exc", "obj", "e", "c", "event", "em", "ext", "site", "enable", "que", "vm", "vs", "net", "proc", "self", "environment", "loader", "session", "ce", "config", "app", "queue", "code", "stage", "export", "exec", "ea", "ec", "output", "data", "server", "np", "org", "dat", "engine", "dt", "eu", "ctx", "emb", "gui", "cv", "v", "manager", "dev", "init", "console", "forge", "db", "nw", "eng", "Environment", "ep", "global", "pos", "viron", "vel"], "arg1": ["arg11", "rgpre", "arg251", "argonce", "ace61", "aceonce", "exec1", "argument01", "argsone", "valpre", "valone", "num01", "args1", "ag11", " arginf", "rgOne", "tag11", "argone", "ag1", "argument251", "args3", "aceone", "numone", "exec3", "argOne", "argsinf", "arg3", "arg0", "item1", "argumentone", "iteminf", "ag61", "ace1", "ig251", "argpre", "locone", " arg3", "val01", " arg2", "argumentOne", "ace100", "Arg2", " argonce", "ace11", "tag61", " argpre", "args2", "locOne", "argument2", "ag100", "val251", "loc01", "num251", " argone", "exec2", "argument1", "itemone", "ig01", "arginf", "rg1", "valOne", "argumentonce", "ig1", "arg01", "igone", "execinf", "val2", "tag1", " arg01", "rg2", "argument3", "arg61", "loc1", "tag100", "val3", "arg100", " argOne", "arg2", "Argone", "argumentinf", "Arg01", "ace2", "Arg0", "argument0", "Arg1", "num1", "item2", " arg0", "val1"], "reg": ["orig", "rec", "rule", "debug", "proc", "rem", "lex", "tag", "g", "mem", "rg", "config", "pre", "rest", "arm", "eg", "REG", "match", "rc", "fun", "Reg", "arg", "region", "feat", "addr", "loc", "exec", "eng", "ig", "sec", "round", "stat", "thread", "pattern", "flag", "abc", "bit", "res", "re", "bg"]}}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853, "substitutes": {"opaque": ["oplaques", "OPque", "Opcca", "Opaque", "opercca", "OPacity", " opque", "OPaques", " opaques", "oplaque", "Opaques", " opacity", "opcca", "defaque", "operaques", "OPaque", "opque", "Opque", "opacity", "defaques", "defacity", "defque", "opaques", "oplque", "operaque", "operque", "oplcca"], "irq": ["risf", "virflow", "iriflow", "ariq", "irqu", "virq", "rinqt", "ierqual", "riq", "IRf", "iriquest", "risry", "irf", "irqual", "irqt", "rinq", "iraQ", "ariquest", "virque", "virquest", "rinqual", "iref", "irtqual", "irry", "ierqt", "IRQ", "ireQ", "irery", " irqs", "arique", "IRqu", "irquest", "irequ", "ironf", "irtQ", "riqu", "irtq", "ariflow", "ierQ", "risqs", "iraq", "iraqu", " irry", "irflow", "IRq", "irique", "iraf", "ironqu", "rinQ", "irque", "riQ", "ireq", "risq", "irtqt", "ireqs", "rif", "irQ", "ironq", "ironQ", "irqs", "iriq", " irf", "ierq"], "level": ["depth", "index", "coll", "scope", "loop", "weight", "key", "path", "parent", "mode", "id", "full", "wl", "type", "levels", "url", "cost", "style", "enc", "lvl", "code", "stage", "where", "wall", "clean", "letter", "loc", "point", "limit", "inc", "round", "layer", "str", "thread", "Level", "method", "name", "length", "vel"], "env": ["engine", "context", "scope", "et", "chal", "que", "ench", "vm", "dict", "conf", "energy", "eu", "err", "inet", "nc", "esp", "edge", "net", "environment", "er", "end", "req", "loader", "ctx", "ne", "enh", "cache", "esi", "here", "erb", "v", "conn", "style", "oa", "enc", "erv", "config", "queue", "code", "core", "password", "exc", "equ", "args", "ev", "console", "el", "db", "ef", "ah", "forge", "e", "ea", "eng", "eni", "ec", "np", "fen", "qa", "viron", "server", "en", "her", "vel"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n", "idx": 24855, "substitutes": {"bdrv": ["htrvt", "btrva", "hdrv", "bsrv", " bdrf", "brrv", "bsrvr", " bsrf", "htrva", "brcva", "brrvt", "brcvm", "brcvt", " bsrc", " bsrvr", "htrvm", "brrvm", "bgrvr", "brcv", "bdrc", "bdrvm", "bgrc", "bdrvr", "btrvt", "hdrvt", "btrvm", "hdrva", "bsrf", " bsrv", "bgrf", "bdrf", "btrv", "bsrc", "bgrv", "hdrvm", "brrva", " bdrvr", "bdrva", " bdrc", "htrv", "bdrvt"], "cmd": ["cd", "gz", "dc", "Cmd", "comm", "dict", "mode", "cmp", "cc", "cp", "req", "ctr", "ctx", "header", "window", "host", "pkg", "ck", "dom", "gn", "command", "conn", "cf", "src", "config", "code", "grad", "core", "route", "ux", "prefix", "mac", "md", "cfg", "head", "input", "cm", "ctrl", "node", "doc", "c", "seq", "cod", "img", "msg", "cli", "cb", "uf", "cat", "bind", "cookie", "method", "client", "opt", "pipe", "buff"], "buf": ["b", "border", "port", "box", "bc", "byte", "req", "header", "fd", "result", "mem", "alloc", "bed", "ff", "fb", "num", "path", "vec", "fab", "text", "window", "rb", "off", "pool", "comb", "conv", "rc", "buffer", "desc", "feed", "img", "msg", "runner", "prop", "front", "cmp", "proc", "bytes", "bo", "pkg", "br", "cf", "src", "config", "queue", "ef", "seq", "data", "uf", "bus", "buff", "grab", "rows", "func", "ctx", "wb", "cv", "band", "cas", "v", "batch", "ab", "fun", "loc", "uc", "bag", "doc", "cb", "aux", "pad", "uv"], "sensebuf": ["anectx", "sebuff", "sensebuffer", "sequeue", "kequeue", "ensebuff", "ensebuf", "sebuf", "sensectx", "kebuff", " sensebuffer", "anebuf", "anebuffer", "ensebuffer", "isepkg", "sensepkg", "kebuffer", " sensectx", "isebuf", "anefile", "anebuff", " sensepkg", " sensebuff", "ensequeue", "sefile", "isectx", " sensefile", "sensebuff", "kebuf", "sebuffer", "sensefile", "anepkg", "sensequeue", "isebuff"], "io_header": [" io_parser", "io_writer", "io_message", "io__header", "iol_layer", "io__driver", "iol_server", "io__server", " io_line", "ios_info", "server_header", " io_handler", "io_module", "ilo_director", "io__writer", "io_driver", "io_player", " io_module", "io_head", "io_config", "iol_buffer", "io__layer", "io_line", "io_wrapper", "io__document", "iloappheader", "ioappbuffer", "io_document", "io_cookie", "server_message", " io_director", " io_config", "ioappdirector", "io_handler", " io_secondary", "io_parser", "iol_leader", "io_tail", "ilo_cookie", " io_document", "iol_head", " io_server", "ios_buffer", "io_key", "ios_dr", "io_secondary", "io_info", "io__dr", " io_head", "io_director", "io__leader", "iloappdirector", "ioappcookie", " io_key", " io_holder", "ios_writer", " io_dr", "io_server", "io_layer", "ios_server", " io_driver", "ilo_head", "ilo_header", "iol_header", "ios_head", "io__buffer", "iol_driver", "ioappheader", " io_tail", "server_director", "ios_header", "io_leader", "io_buffer", " io_player", "io_holder", "io__message", "io__head", "iol_dr", "ios_layer", "iol_message", " io_cookie", "ioapphead", "iloappcookie", "server_document", "io_dr", "ioappleader", " io_wrapper", "iloapphead", "io__director"], "ret": ["num", "sr", "reply", "mt", "RET", "j", "count", "mer", "len", "red", "r", " RET", "nt", "fin", "result", "alt", "resp", "iter", "mem", "det", "ref", "part", "rets", "code", "match", "rc", "fun", "att", "arg", "rt", " Ret", "pt", "lit", "val", "out", "Ret", "reg", "flag", "res", "pat", "back", "success", "re", "cur"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24880, "substitutes": {"bs": ["banks", "b", "pb", "base", "vs", "bc", "outs", "blocks", "gs", "bh", "bits", "os", "rs", "nas", "ubs", "sb", "bid", "bos", "fs", "obs", "rb", "ps", "bi", "bps", "ks", "ras", "ins", "boxes", "cases", "gb", "cs", "ab", "lbs", "iss", "bas", "ns", "eb", "bes", "BS", "ss", "ls", "ds", "ses", "bis", "fb"], "ign": ["sect", "ach", "anch", "align", " align", "anc", "igning", "inet", "xt", "ignment", "lex", "ica", "igned", "ass", "urn", " assign", "conn", "aff", "ect", "cl", "oci", "act", "address", "iss", "IGN", "ident", "clean", "pect", "exec", "ig", "ind", "aligned", "issa", "gener", "account", "sign", "form", "abc"], "offset": ["index", "reset", "et", "eno", "set", "align", "entry", "base", "inet", "shift", "end", "Offset", "reference", "len", "ptr", "position", "type", "location", "fp", "ref", "part", "off", "origin", "area", "address", "prefix", "attribute", "absolute", "addr", "loc", "limit", "start", "aligned", "from", "adjust", "pos", "art", "order", "length", "pointer"], "size": ["ize", "parent", "shape", "shift", "end", "timeout", "send", "len", "fee", "storage", "en", "six", "empty", "SIZE", "iz", "s", "address", "unit", "capacity", "scale", "si", "small", "loc", "sync", "from", "sec", "sized", "content", "Size", "esc", "pos", "name", "length", "sum"]}}
{"project": "FFmpeg", "commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "target": 0, "func": "int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    Picture *pic;\n\n    s->mb_skipped = 0;\n\n\n\n    if (!ff_thread_can_start_frame(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* mark & release old frames */\n\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n\n        s->last_picture_ptr != s->next_picture_ptr &&\n\n        s->last_picture_ptr->f.buf[0]) {\n\n        ff_mpeg_unref_picture(s, s->last_picture_ptr);\n\n    }\n\n\n\n    /* release forgotten pictures */\n\n    /* if (mpeg124/h263) */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (&s->picture[i] != s->last_picture_ptr &&\n\n            &s->picture[i] != s->next_picture_ptr &&\n\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n\n            if (!(avctx->active_thread_type & FF_THREAD_FRAME))\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"releasing zombie picture\\n\");\n\n            ff_mpeg_unref_picture(s, &s->picture[i]);\n\n        }\n\n    }\n\n\n\n    ff_mpeg_unref_picture(s, &s->current_picture);\n\n\n\n    release_unused_pictures(s);\n\n\n\n    if (s->current_picture_ptr &&\n\n        s->current_picture_ptr->f.buf[0] == NULL) {\n\n        // we already have a unused image\n\n        // (maybe it was set before reading the header)\n\n        pic = s->current_picture_ptr;\n\n    } else {\n\n        i   = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        pic = &s->picture[i];\n\n    }\n\n\n\n    pic->reference = 0;\n\n    if (!s->droppable) {\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            pic->reference = 3;\n\n    }\n\n\n\n    pic->f.coded_picture_number = s->coded_picture_number++;\n\n\n\n    if (ff_alloc_picture(s, pic, 0) < 0)\n\n        return -1;\n\n\n\n    s->current_picture_ptr = pic;\n\n    // FIXME use only the vars from current_pic\n\n    s->current_picture_ptr->f.top_field_first = s->top_field_first;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (s->picture_structure != PICT_FRAME)\n\n            s->current_picture_ptr->f.top_field_first =\n\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n\n    }\n\n    s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&\n\n                                                 !s->progressive_sequence;\n\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n\n\n    s->current_picture_ptr->f.pict_type = s->pict_type;\n\n    // if (s->flags && CODEC_FLAG_QSCALE)\n\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n\n    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n\n                                   s->current_picture_ptr)) < 0)\n\n        return ret;\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n\n        s->last_picture_ptr = s->next_picture_ptr;\n\n        if (!s->droppable)\n\n            s->next_picture_ptr = s->current_picture_ptr;\n\n    }\n\n    av_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n\n            s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,\n\n            s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,\n\n            s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,\n\n            s->pict_type, s->droppable);\n\n\n\n    if ((s->last_picture_ptr == NULL ||\n\n         s->last_picture_ptr->f.buf[0] == NULL) &&\n\n        (s->pict_type != AV_PICTURE_TYPE_I ||\n\n         s->picture_structure != PICT_FRAME)) {\n\n        int h_chroma_shift, v_chroma_shift;\n\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n\n                                         &h_chroma_shift, &v_chroma_shift);\n\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocating dummy last picture for B frame\\n\");\n\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"warning: first frame is no keyframe\\n\");\n\n        else if (s->picture_structure != PICT_FRAME)\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocate dummy last picture for field based first keyframe\\n\");\n\n\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->last_picture_ptr = &s->picture[i];\n\n\n\n        s->last_picture_ptr->reference   = 3;\n\n        s->last_picture_ptr->f.key_frame = 0;\n\n        s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n\n            s->last_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n\n\n        memset(s->last_picture_ptr->f.data[0], 0x80,\n\n               avctx->height * s->last_picture_ptr->f.linesize[0]);\n\n        memset(s->last_picture_ptr->f.data[1], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[1]);\n\n        memset(s->last_picture_ptr->f.data[2], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[2]);\n\n\n\n        if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n\n            for(i=0; i<avctx->height; i++)\n\n            memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);\n\n        }\n\n\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n    if ((s->next_picture_ptr == NULL ||\n\n         s->next_picture_ptr->f.buf[0] == NULL) &&\n\n        s->pict_type == AV_PICTURE_TYPE_B) {\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->next_picture_ptr = &s->picture[i];\n\n\n\n        s->next_picture_ptr->reference   = 3;\n\n        s->next_picture_ptr->f.key_frame = 0;\n\n        s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n\n            s->next_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n\n\n#if 0 // BUFREF-FIXME\n\n    memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));\n\n    memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));\n\n#endif\n\n    if (s->last_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->last_picture);\n\n        if (s->last_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->last_picture,\n\n                                       s->last_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n    if (s->next_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->next_picture);\n\n        if (s->next_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->next_picture,\n\n                                       s->next_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n\n                                                 s->last_picture_ptr->f.buf[0]));\n\n\n\n    if (s->picture_structure!= PICT_FRAME) {\n\n        int i;\n\n        for (i = 0; i < 4; i++) {\n\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n\n                s->current_picture.f.data[i] +=\n\n                    s->current_picture.f.linesize[i];\n\n            }\n\n            s->current_picture.f.linesize[i] *= 2;\n\n            s->last_picture.f.linesize[i]    *= 2;\n\n            s->next_picture.f.linesize[i]    *= 2;\n\n        }\n\n    }\n\n\n\n    s->err_recognition = avctx->err_recognition;\n\n\n\n    /* set dequantizer, we can't do it during init as\n\n     * it might change for mpeg4 and we can't do it in the header\n\n     * decode as init is not called for mpeg4 there yet */\n\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n\n    } else {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24881, "substitutes": {"s": ["js", "b", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "h", "hs", "sis", "p", "times", "args", "u", "sets", "ms", "si", "sync", "xs", "sq", "parts", "a", "as", "n", "qs", "conf", "gs", "aws", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "sports", "ss", "spec", "o", "client", "stats", "its", "sf", "details", "css", "sites", "vs", "j", "self", "ops", "full", "session", "ans", "ts", "is", "m", "sym", "sg", "f", "ds", "plugins", "ses", "sys", "bis", "http", "sv", "ions", "os", "uns", "r", "storage", "ps", "v", "ins", "ns", "settings", "d", "ls", "services", "words", "comments", "us", "se"], "avctx": ["avecoll", "navctx", "avxc", "vrctrl", "mpcmp", "Avconfig", "navconfig", "aveconfig", "avconnection", "avecontext", "absync", "afcontext", "abcontext", "abconfig", "afloc", "avectrl", "afctx", "avecmp", "mpcoll", "armcmp", "Avconnection", "Avcontext", "armctx", "AVconnection", "avsync", "ajxc", "ajcca", "ajcontext", "aucca", "avcontext", "afxc", "vrcontext", "mpctx", "afcoll", "vrctx", "afcmp", "AVcmp", "afcca", "avcca", "navcontext", "auxc", "aucontext", "mpcontext", "AVcontext", "armctl", "AVctl", "avctrl", "afctl", "abctx", "Avctx", "vrloc", "aveconnection", "avloc", "navsync", "AVsync", "avcoll", "auctx", "afctrl", "AVconfig", "avectx", "avctl", "aveloc", "avcmp", "avconfig", "armcontext", "ajctx", "AVctx"], "i": ["b", "li", "in", "ie", "id", "count", "iu", "g", "type", "ti", "ini", "p", "line", "I", "u", "k", "si", "eni", "adi", "phi", "ci", "ni", "ji", "name", "ei", "a", "mi", "x", "oi", "n", "err", "abi", "end", "info", "hi", "gi", "l", "qi", "zi", "t", "ii", "e", "c", "ind", "start", "lc", "cli", "api", "val", "ui", "o", "ri", "index", "z", "j", "ix", "y", "fi", "slice", "uri", "code", "m", "di", "ski", "f", "data", "aci", "iv", "ki", "ai", "mini", "pi", "yi", "r", "ip", "bi", "v", "io", "xi", "multi", "chi", "it", "d", "ori"], "ret": ["num", "reply", "RET", "len", "r", "gc", "result", "resp", "fi", "arr", "obj", "rc", "feat", "arg", "jp", "ru", "val", "Ret", "res", "ri", "bis", "J"], "pic": ["mini", "fc", "li", "sci", "bc", "vec", "ac", "fat", "piece", "pin", "picture", "pot", "lib", "photo", "avi", "image", "feature", "cus", "cache", "bi", "pict", "sa", "fp", "fi", "style", "xi", "Pic", "config", "Picture", "capt", "parse", "photos", "p", "ic", "zi", "mac", " picture", "study", "feat", "jp", "si", "pse", "file", "doc", "fn", "ig", "pc", "img", "lc", "spec", "sec", "str", "cat", "pins", "pa"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895, "substitutes": {"opaque": ["ipacity", "openaques", "ipsea", "OPque", "octaque", "OPacity", "openque", "opsque", "OPaques", " opaques", "opsacity", "opsea", "openaque", " opsea", " opacity", "ipaque", "opsaque", "octsea", "OPaque", "opque", "octacity", "opacity", "opsaques", "octaques", "ipaques", "opaques", "openacity"], "s": ["b", "scope", "n", "sl", "a", "secondary", "S", "ops", "sb", "ssl", "fs", "g", "session", "sa", "hs", "submit", "p", "m", "sym", "socket", "south", "ns", "sg", "si", "settings", "e", "sie", "c", "sync", "ss", "f", "spec", "ds", "services", "sq", "server", "o", "ses", "sys"]}}
{"project": "FFmpeg", "commit_id": "41abc9da50ba7a7b68bbbf6622475ce7a3c72e3f", "target": 1, "func": "static int decode_frame_ilbm(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for (plane = 0; plane < s->bpp; plane++) {\n\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for(y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n\n                    if (start >= buf_end)\n\n                        break;\n\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n\n        int x;\n\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n\n            buf += raw_width;\n\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n\n                for(x = 0; x < avctx->width; x++)\n\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { // PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 24896, "substitutes": {"avctx": ["avcb", "afcli", "akcci", "avxc", "akcontext", "apcf", "avcci", "afcb", "afpkg", "ajrt", "afcu", "afcoll", "avecli", "alctx", "abcoll", "avpkg", "ajhw", "avsci", "abctx", " avconn", "aveconn", "apcontext", " avcontext", "afctrl", "avectx", "apctx", "avalctrl", "avalcontext", "afcontext", " avcu", "avecontext", "akconn", "ajconfig", "abcontext", "avalctx", "avecue", "ajcue", "afcue", "navpkg", "avalsync", "ajcontext", "afxc", "afsci", "ajcot", "avca", "ajctl", "avcli", "alpkg", "avesync", "vercmp", "avc", "verconn", "navsync", "afhw", "afcf", "avalcci", "avalchan", "avctl", "AVconfig", "avalsci", "afconfig", "verctx", "vercf", "avepkg", "avcue", "afca", "alcontext", "navconfig", "aveconfig", "akchan", " avcoll", "avcu", "abcf", "avcf", "aveca", "akcb", "avectrl", "afctx", "afchan", "avrt", "afconn", "avconn", "apconn", "avsync", "akctx", "afsync", "navcli", "afcot", " avctl", "AVcontext", "avctrl", "afctl", "apcoll", "alconn", "avcoll", "afc", "avcmp", "avalpkg", "abc", "avconfig", "afcci", "ajctx", "navctx", "vercontext", "avecb", "AVpkg", "akpkg", "avcot", " avcot", "avalconn", "afrt", "afcmp", "avcontext", "avecu", " avpkg", "navcontext", "avehw", "avchan", "abcmp", "ajcf", " avxc", "akca", "aprt", "versci", "avhw", "avalxc", "ajc", "ajcoll", "AVctx", "ajsync"], "data": ["split", "id", "header", "cache", "result", "sequence", "zero", "frame", "p", "read", "address", "table", "lines", "media", "block", "map", "name", "a", "parent", "da", "format", "end", "action", "window", "series", "open", "style", "buffer", "delay", "ad", "bin", "offset", "index", "last", "value", "message", "shift", "bytes", "slice", "empty", "code", "draw", "Data", "w", "input", "head", "module", "output", "dat", "buff", "results", "alpha", "base", "align", "source", "body", "DATA", "actions", "done", "layout", "image", "size", "ata", "batch", "one", "first", "sample", "d", "padding", "i", "ul", "next", "content", "memory", "pad", "length"], "data_size": ["image_len", "image1size", "data1shape", "image1shape", "image_size", "image_shape", "data1len", "data_shape", "data1size", "image1len", "data_len", "data1length", "image_length", "data_length", "image1length"], "avpkt": ["avccht", "avpce", "avpeect", " avPkt", "avfce", "abpcht", "avfacket", "ajpacket", "avpacket", "avfett", "avlpett", "afpdt", "avpka", "avlpeth", "avpckt", "avspke", "avPqt", "avperdt", "avfKT", "avckt", "abfct", "avperka", "avpdt", "avPKT", "aphpeth", " avPacket", "ajlpkt", "aphpke", " avPqt", "avperacket", "afpki", "afpect", "avpcka", "affce", "avppkt", "avpercht", "affacket", "avfeth", "affkt", "ajlpacket", "avfki", "afpkid", "avvacket", "avpeth", "avfkt", "avfct", "avpeacket", "avbpacket", "afpce", "aphpkt", "avfcht", "avspect", "avcacket", "affkid", "avecht", "avpki", "avpct", "aphlpke", "avvki", "ajpkt", "avlpkid", "affdt", "avpcht", "avfpqt", "avect", "avpett", "avspce", "avperkt", "avpccht", "avfqt", "abpct", "avpece", " avpacket", "avpekt", "avlpacket", "avvdt", "avvkt", "avpke", "avfdt", "avbpett", "avlpkt", "avspeth", "abpacket", "avfke", "aphlpacket", "avfka", "avbpkid", "avfkid", "avPacket", "aphpacket", "afpkt", "afpka", "ajpkid", "abfcht", "avbpkt", "affka", "ajlpett", "avpqt", " avpKT", "avlpce", "avpKT", "affki", "ajpett", "avfpKT", "avfpacket", "avfpkt", "avekt", "avpcacket", "avperki", "abfkt", " avPKT", " avpqt", "avlpke", "ajlpkid", "avPkt", "abpkt", "affcht", "avfect", "aphlpeth", "avpect", "afpacket", "avppkid", "afpcht", "aveacket", "abfacket", "avspacket", "avspkt", "avppacket", "aphlpkt", "avppce", "avcct", "avpkid", "affect"], "s": ["js", "its", "n", "details", "qs", "sc", "conf", "http", "S", "gs", "rs", "os", "ops", "full", "ssl", "sb", "stats", "fs", "r", "g", "bs", "xs", "session", "ps", "aws", "ts", "es", "l", "is", "v", "ks", "sk", "service", "ins", "hs", "p", "m", "cs", "t", "args", "sym", "w", "sets", "su", "ns", "sg", "si", "e", "sync", "c", "sup", "ses", "d", "f", "i", "spec", "ls", "ds", "ss", "sec", "services", "sq", "parts", "o", "us", "se", "a", "sys", "as"], "buf": ["cap", "b", "num", "fw", "box", "base", "home", "bc", "vec", "lim", "cp", "wave", "bytes", "offset", "header", "len", "rb", "flow", "cache", "fin", "bar", "wb", "cv", "max", "bn", "zero", "h", "cf", "empty", "batch", "queue", "alloc", "cmd", "ab", "cur", "xy", "w", "buffer", "loc", "block", "limit", "seq", "uc", "f", "fl", "gen", "cb", "uf", "bus", "length", "bg", "buff"], "buf_end": ["fileaclimit", "buf_max", "buf_End", "file_limit", "fileacend", "buf_start", "buf2max", "bufaclimit", "buf2end", "buf_size", "buffer_end", "buffer_start", "buf_limit", "fileacEnd", "file_start", "buf2End", "bufacstart", "buffer_max", "bufacEnd", "fileacstart", "file_End", "buf2start", "buf2limit", "file_end", "buf2size", "bufacend", "buffer_size"], "y": ["b", "oy", "vy", "port", "Y", "n", "key", "ny", "ch", "base", "z", "j", "cy", "col", "dy", "ady", "g", "ip", "ye", "type", "yo", "sy", "l", "h", "yr", "py", "area", "p", "gy", "m", "t", "w", "hop", "c", "ey", "ind", "d", "ya", "i", "f", "ay", "iy", "yy", "o", "height", "a"], "plane": ["jet", "num", "port", "span", "weight", "n", "drop", "key", "pose", "nat", "z", "direction", "cp", "col", "fly", "len", "flow", "axis", "slice", "pe", "period", "mo", "level", "plan", "p", "orient", "core", "priority", "line", "ge", "per", "sea", "page", "w", "xy", "scale", "e", "pen", "flo", "rot", "ane", "f", "i", "age", "lane", "cat", "pos", "se", "planes", "den", "zone", "fl"], "res": ["js", "reset", "rec", "Res", "results", "status", "rx", "details", "error", "resolution", "gr", "ret", "err", "score", "errors", "conf", "rem", "req", "rs", "os", "breaks", "resh", "response", "pres", "ros", "r", "bs", "cache", "rates", "rex", "result", "RES", "resp", "ps", "rate", "root", "sol", "ber", "ver", "rev", "range", "ras", "mr", "pass", "arr", "vals", "ress", "cs", "cr", "rh", "rss", "args", "des", "obj", "clean", "ms", "e", "css", "cons", "gen", "msg", "rap", "val", "content", "min", "press", "rus", "ris", "reg", "nos", "success", "re"], "row": ["index", "num", "port", "key", "win", "entry", "sc", "value", "id", "byte", "rows", "col", "zip", "ip", "cell", "max", "slice", "line", "month", "w", "rc", "feed", "block", "val", "q", "pos", "ry", "offset"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n", "idx": 24897, "substitutes": {"addr": ["ag", "shi", "env", "ne", "url", "oa", "p", "line", "rh", "address", "socket", "si", "ha", "block", "dd", "rr", "co", "adder", "name", "state", "edge", "er", "info", "host", "conn", "off", "sta", "obj", "nn", "rc", "node", "ad", "o", "opt", "offset", "ext", "ino", "error", "proxy", "cmp", "proc", "ace", "od", "bb", "len", "ptr", "bo", "sp", "pkg", "oo", "dr", "attr", "no", "sa", "osi", "slice", "config", "code", "cmd", "vr", "mac", "po", "sg", "hop", "rt", "amp", "player", "ea", "hp", "extra", "str", "data", "layer", "server", "np", "adr", "nr", "afi", "alias", "et", "align", "ack", "ctx", "ip", "coord", "alt", "la", "ati", "au", "part", "ada", "ar", "md", "loc", "inc", "load", "pos", "eth", "ord"], "so": ["ke", "li", "shi", "ie", "zh", "sh", "sb", "sel", "ou", "ne", "ock", "oa", "sm", "pro", "plus", "si", "sync", "wh", "oso", "since", "sq", "zo", "co", "cu", "oe", "pg", "oh", "info", "So", "wo", "style", "ao", "service", "cs", "obj", "su", "oss", " SO", "flo", "osa", "pc", "cli", "ho", "o", "client", "OO", "sf", "proxy", "ace", "ow", "bo", "sp", "oo", "coe", "sa", "no", "osi", "ce", "cf", "sk", "code", "s", "ge", "ski", "now", "po", "sg", "lo", "who", "tto", "sl", "fo", "ko", "os", "to", "la", "io", "olo", "go", "py", "mo", "LO", "ste", "one", "SO", "from", "sing", "how", "ro", "se", "ob"]}}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899, "substitutes": {"opaque": ["oppaca", "OPac", "oppaques", "opaca", "oppaque", "opatile", "OPacity", "ospaque", "obaques", "opac", " opacity", "obaque", "obaca", "opsaque", " opya", "ospya", "opsatile", " opac", "opsaca", "OPya", "OPaque", "ospac", "opya", "opsaques", "opacity", "oppatile", "opaques", "obatile", "ospacity"], "addr": ["port", "dc", "mode", "id", "byte", "req", "asm", "url", "ref", "oa", "frame", "arm", "grad", "address", "args", "socket", "device", "hard", "intel", "ha", "dd", "clock", "rr", "art", "adder", "name", "x", "slot", "edge", "nc", "host", "add", "amd", "conn", "wd", "sta", "arr", "kt", "callback", "prefix", "nn", "node", "point", "ad", "pointer", "arp", "offset", "index", "ext", "ost", "cmp", "proc", "ace", "hd", "len", "ptr", "pkg", "dr", "attr", "osi", "advert", "src", "config", "code", "route", "cmd", "vr", "mac", "hop", "amp", "rt", "layer", "data", "np", "reg", "adr", "afi", "alias", "cpu", "align", "base", "nick", "ack", "rpm", "ip", "work", "la", "xp", "ld", "ar", "md", "loc", "cb", "fx", "ord", "eth", "pad", "handle"], "irqmp": ["irgMP", "irQmp", "irqumb", "iriquma", "iriqma", "ircpy", "irqqma", "Irqmm", "irchpm", "irqpm", "ircem", "ircmp", " irgpm", "irqump", "irqum", "irchmm", " irgmm", "ircmm", " irqmm", "irchmp", "ircema", "irqmm", " irqMP", "irqupy", "irgmm", "irquMP", "irquma", "ircemp", "irchMP", "Irqmp", "irQpm", "Irqump", "ircemm", "irqqmb", "irceMP", " irgmp", "irqqmp", "iriqm", "iriqumb", "irQMP", "Irqupy", "iriqump", "ircepy", "irqmb", "irqm", "iriqum", "iriqmp", "irqMP", "iriqmb", "irgpm", " irgMP", "irqma", "irqumm", "irqpy", " irqpm", "IrqMP", "IrquMP", "Irqpy", "irqqm", "ircemb", "irQmm", "ircMP", "irgmp", "Irqumm"], "state": ["ke", "seed", "scope", "port", "mode", "rule", "count", "patch", "cache", "type", "states", "new", "lock", "address", "force", "sync", "co", "map", "name", "order", "key", "set", "dict", "parent", "err", "er", "connection", "tag", "info", "open", "notice", "conn", "style", "parse", "node", "e", "param", "start", "spec", "stat", "val", "event", "grade", "o", "trace", "step", "status", "error", "value", "note", "message", "self", "ace", "test", "session", "master", "resource", "all", "slice", "config", "level", "code", "push", "data", "call", "source", "progress", "body", "STATE", "size", "State", "work", "estate", "part", "store", "range", "manager", "print", "statement", "component", "object", "list", "se", "length"]}}
{"project": "qemu", "commit_id": "ea8d82a1ed72634f089ed1bccccd9c84cc1ab855", "target": 1, "func": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}", "idx": 24902, "substitutes": {"qsg": ["dqsa", "Qsq", "qusb", "Qgu", "qgu", "qusa", "dqsb", "qsc", "Qsg", " qsq", "psb", "qsa", "psc", "qusg", "qsq", " qsa", "psa", "dqsc", " qgu", "Qsa", "qusc", "psg", "qsb", "qugu", "qusq", "dqsg"]}}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921, "substitutes": {"vdev": ["vprom", "ldev", "vpriv", "vconf", "vdevice", "svdev", "xconf", " vde", "xdevice", "svdevice", "ddd", "svconf", "Vdev", "lprom", "dconf", "gdevice", " vdevice", "svdd", "gconf", "xdev", " vconf", "pdevice", "pde", "vdd", "gprom", "xdd", "Vpriv", "lconf", "ldevice", "ddev", "vde", " vpriv", "ppriv", "Vdevice", " vprom", "ddevice", "Vde", "gdev", "pdev"], "s": ["js", "b", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "h", "hs", "tests", "ssh", "p", "args", "sets", "si", "sup", "sync", "xs", "serv", "parts", "a", "as", "n", "qs", "set", "secondary", "conf", "state", "gs", "aws", "es", "l", "ims", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "stats", "site", "its", "your", "self", "full", "session", "ts", "is", "m", "sym", "w", "side", "sg", "f", "ds", "data", "server", "ses", "sys", "sl", "os", "uns", "storage", "ps", "v", "ns", "settings", "d", "ls", "services"], "i": ["index", "ai", "x", "b", "oi", "li", "pi", "in", "n", "key", "ji", "id", "j", "yi", "info", "iu", "hi", "ix", "type", "gi", "ri", "bi", "l", "ti", "v", "fi", "mu", "uri", "xi", "ini", "hei", "multi", "p", "qi", "zi", "m", "I", "di", "chi", "u", "t", "ii", "k", "si", "e", "c", "sup", "d", "ind", "f", "eni", "start", "ui", "ci", "phi", "ni", "name", "a", "ki", "mi"], "len": ["bl", "li", "pl", "n", "lif", "sl", "lan", "err", "lim", "Len", "id", "count", "lib", "dy", "non", "lu", "nt", "fin", "dim", "size", "mem", "l", "la", "all", "low", "il", "lon", "lf", "ler", "ld", "lin", "fun", "el", "elt", "lo", "limit", "seq", "ind", "fl", "lc", "lit", "val", "dl", "ann", "min", "lt", "pos", "le", "ni", "lp", "en", "length", "ln", "mi", "lang"], "stat": ["Stat", "dir", "disk", "lif", "css", "cpu", "status", "nat", "mode", "debug", "proc", "rs", "task", "ctl", "info", "cache", "raf", "attr", "nic", "mem", "conn", "dot", "util", "nam", "cmd", "def", "link", "exec", "block", "sync", "gen", "spec", "sec", "cat", "serv", "meta", "reg", "STAT", "opt", "name", "stats", "sys"], "fse": [" fpe", "gse", "dsp", "gde", " fsu", " fce", "sffe", " fste", "psee", "sfse", "pze", "fde", "dfbe", " fge", "Fge", "rfse", "dfsel", "cfce", "gsee", " fsp", " fses", "vze", "vke", "fbe", "fxse", "fce", "dfe", "vste", "sfpse", "fpse", "fke", " fke", "fsee", " fpse", "cfse", "fxses", "vsel", "fsp", "rfce", "cfbe", " fsel", "fses", "vce", "vse", "ffe", " fze", " fsee", "dfse", "Fce", "dse", "sfsp", " fde", " fbe", "fpe", "cfze", "fge", "rfpe", "vbe", "Fse", "Fpe", "fsel", "fze", "rfge", "gze", "vsu", "fsu", "pde", " ffe", "dfke", "pse", "fxsu", "fxste", "fste", "vses", "dpse"], "path": ["dir", "port", "alias", "key", "ch", "parent", "sc", "home", "err", "mode", "id", "source", "self", "er", "ath", "end", "loader", " paths", "r", "host", "image", "result", "root", "url", "ref", "uri", "config", "code", "m", "cmd", "address", "prefix", "Path", "w", "device", "target", "file", "node", "loc", "fn", "c", "d", "ec", "f", "str", "data", "next", "mount", "PATH", "name", " Path"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_request(V9fsProxy *proxy, int type,\n\n                        void *response, const char *fmt, ...)\n\n{\n\n    dev_t rdev;\n\n    va_list ap;\n\n    int size = 0;\n\n    int retval = 0;\n\n    uint64_t offset;\n\n    ProxyHeader header = { 0, 0};\n\n    struct timespec spec[2];\n\n    int flags, mode, uid, gid;\n\n    V9fsString *name, *value;\n\n    V9fsString *path, *oldpath;\n\n    struct iovec *iovec = NULL, *reply = NULL;\n\n\n\n    qemu_mutex_lock(&proxy->mutex);\n\n\n\n    if (proxy->sockfd == -1) {\n\n        retval = -EIO;\n\n        goto err_out;\n\n    }\n\n    iovec = &proxy->out_iovec;\n\n    reply = &proxy->in_iovec;\n\n    va_start(ap, fmt);\n\n    switch (type) {\n\n    case T_OPEN:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_OPEN;\n\n        }\n\n        break;\n\n    case T_CREATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        flags = va_arg(ap, int);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdddd\", path,\n\n                                    flags, mode, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CREATE;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        rdev = va_arg(ap, long int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsdq\",\n\n                                    uid, gid, path, mode, rdev);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKNOD;\n\n        }\n\n        break;\n\n    case T_MKDIR:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddsd\",\n\n                                    uid, gid, path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_MKDIR;\n\n        }\n\n        break;\n\n    case T_SYMLINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ddss\",\n\n                                    uid, gid, oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_SYMLINK;\n\n        }\n\n        break;\n\n    case T_LINK:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\",\n\n                                    oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LINK;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSTAT;\n\n        }\n\n        break;\n\n    case T_READLINK:\n\n        path = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, size);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_READLINK;\n\n        }\n\n        break;\n\n    case T_STATFS:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_STATFS;\n\n        }\n\n        break;\n\n    case T_CHMOD:\n\n        path = va_arg(ap, V9fsString *);\n\n        mode = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sd\", path, mode);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHMOD;\n\n        }\n\n        break;\n\n    case T_CHOWN:\n\n        path = va_arg(ap, V9fsString *);\n\n        uid = va_arg(ap, int);\n\n        gid = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sdd\", path, uid, gid);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_CHOWN;\n\n        }\n\n        break;\n\n    case T_TRUNCATE:\n\n        path = va_arg(ap, V9fsString *);\n\n        offset = va_arg(ap, uint64_t);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sq\", path, offset);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_TRUNCATE;\n\n        }\n\n        break;\n\n    case T_UTIME:\n\n        path = va_arg(ap, V9fsString *);\n\n        spec[0].tv_sec = va_arg(ap, long);\n\n        spec[0].tv_nsec = va_arg(ap, long);\n\n        spec[1].tv_sec = va_arg(ap, long);\n\n        spec[1].tv_nsec = va_arg(ap, long);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sqqqq\", path,\n\n                                    spec[0].tv_sec, spec[1].tv_nsec,\n\n                                    spec[1].tv_sec, spec[1].tv_nsec);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_UTIME;\n\n        }\n\n        break;\n\n    case T_RENAME:\n\n        oldpath = va_arg(ap, V9fsString *);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", oldpath, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_RENAME;\n\n        }\n\n        break;\n\n    case T_REMOVE:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_REMOVE;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ,\n\n                                    \"dss\", size, path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LGETXATTR;\n\n        }\n\n        break;\n\n    case T_LLISTXATTR:\n\n        size = va_arg(ap, int);\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ds\", size, path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LLISTXATTR;\n\n        }\n\n        break;\n\n    case T_LSETXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        value = va_arg(ap, V9fsString *);\n\n        size = va_arg(ap, int);\n\n        flags = va_arg(ap, int);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"sssdd\",\n\n                                    path, name, value, size, flags);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LSETXATTR;\n\n        }\n\n        break;\n\n    case T_LREMOVEXATTR:\n\n        path = va_arg(ap, V9fsString *);\n\n        name = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"ss\", path, name);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_LREMOVEXATTR;\n\n        }\n\n        break;\n\n    case T_GETVERSION:\n\n        path = va_arg(ap, V9fsString *);\n\n        retval = proxy_marshal(iovec, PROXY_HDR_SZ, \"s\", path);\n\n        if (retval > 0) {\n\n            header.size = retval;\n\n            header.type = T_GETVERSION;\n\n        }\n\n        break;\n\n    default:\n\n        error_report(\"Invalid type %d\", type);\n\n        retval = -EINVAL;\n\n        break;\n\n    }\n\n    va_end(ap);\n\n\n\n    if (retval < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* marshal the header details */\n\n    proxy_marshal(iovec, 0, \"dd\", header.type, header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n", "idx": 24933, "substitutes": {"proxy": ["x", "engine", "port", "plugin", "context", "base", "project", "http", "super", "proc", "connection", "python", "ssl", "zip", "fax", "host", "prot", "cache", "image", "request", "resource", "io", "ref", "pe", "roxy", "pool", "service", "null", "query", "echo", "queue", "pro", "address", "pex", "callback", "socket", "buffer", "cgi", "pse", "linux", "bridge", "pc", "f", "Proxy", "api", "call", "server", "fe", "client", "clone", "pipe", "cop", "ping", "pa"], "type": ["port", "in", "key", "status", "parent", "rel", "set", "id", "state", "http", "error", "format", "ype", "tag", "len", "action", "binary", "token", "info", "op", "day", "size", "model", "field", "request", "y", "url", "ref", "pe", "single", "style", "part", "py", "role", "config", "pre", "version", "code", "t", "TYPE", "link", "side", "active", "time", "block", "like", "types", "copy", "typ", "val", "call", "method", "flag", "class", "ping", "post", "Type"], "response": ["report", "status", "parent", "http", "req", "timeout", "cache", "result", "resp", "request", "respond", "ref", "service", "callback", "buffer", "Response", "data", "call", "next", "server", "res", "method", "xml", "respons"], "fmt": ["sflt", "Flt", "Fformat", "sfmt", "Fprintf", " fnt", "fnt", "Fnt", "sfprintf", " flt", "fformat", "FMT", "sfformat", " fformat", "flt", "sfMT", " fMT", "Fmt", "sfnt", "fMT"], "rdev": ["irdev", "ldesc", "rteal", "ldev", "tdelta", "rdata", "rbelta", "irdeal", "rbev", "irdef", "rbef", "ldef", "rdef", "rtef", "rtata", "rbesc", "tdesc", "ldeal", "irdata", "ldata", "rdesc", "rdelta", "ldelta", "tdef", "tdev", "rdeal", "rtev"], "ap": ["apache", "ag", "mp", "wp", "cache", "p", "apy", "address", "ak", "na", "ha", "gap", "rep", "map", "xml", "tp", "a", "as", "hap", "aps", "snap", "array", " AP", "ape", "al", "skip", "external", "img", "api", "Ap", "at", "arp", " op", "pac", "aj", "apt", "av", "or", "ptr", "sp", "op", "ae", "all", "app", "jp", "addr", "amp", "this", "archive", "lat", "AP", "np", "tap", "dat", "cap", "report", "base", "http", "https", "ip", "ps", "nav", "au", "ab", " sp", "ar", "ang", "ns", "html", "ep", "pos", "apps", "pa"], "offset": ["index", "set", "parent", "error", "base", "count", "shift", "timeout", "Offset", "final", "len", "done", "info", "number", "put", "ref", "empty", "alloc", "seq", "start", "pos", "flag", "SET", "length"], "spec": ["ature", "byte", "shape", "ace", "Spec", " specification", "len", " sup", "info", "size", "ice", "pack", "I", "def", "match", "ef", "desc", "sec", "ul", "str", "data", "opt", "class", "length", "ext"], "flags": ["items", "ips", "details", "status", "errors", "ids", "filename", "bits", "format", "posts", "opens", "bytes", "ops", "Flags", "len", "faces", "fd", "fs", "size", "levels", "fields", "reads", "fts", "options", "files", "rets", "version", "vals", "s", "features", "args", "lf", "properties", "fun", "acl", "ns", "lines", "settings", "rules", "links", "f", "includes", "types", "ds", "stat", "data", "values", "versions", "content", "ls", "mask", "plugins", "flag", "planes", "groups", "locks", "steps", "stats", "ants", "mods"], "mode": ["dir", "owner", "coll", "alias", "plugin", "mod", "mid", "key", "phase", "driver", "id", "direction", "du", "filename", "mission", "sid", "perm", "group", "size", "dim", "model", "style", "uri", "role", "range", "version", "level", "m", "route", "prefix", "MODE", " modes", "device", "md", "de", "language", "scale", "time", "node", "kind", "module", "data", "lane", "mask", "Mode", "user", "grade", "vel"], "uid": ["owner", "eno", "cpu", "home", "UID", "kid", "id", "du", "direction", "gin", "sid", "ou", "lu", "host", "vid", "size", "uu", "session", "ud", "udi", "uin", "pid", " u", "gpu", "uri", "uni", "gy", "password", "ug", "cmd", "username", "u", "nn", "device", "su", "usr", "uc", "gu", "uint", "wallet", "nu", "upid", "ui", "uv", "mask", "who", "user", "umi", "auth", "ua"], "gid": ["gidd", "ginid", "sgaid", " gbit", " gip", "Gid", " gids", "guids", "rgid", "pgID", "pgname", "rgID", "Gids", "pgid", "gids", "gide", "gname", "ginidd", "sgid", " gaid", "angid", "pgids", "sgide", " gidd", "guip", " gname", "angidd", "rgaid", " gide", "Gname", "angID", "rgids", "rgip", "guid", "rgide", "gbit", "ginbit", "gID", "gip", "GID", "sgID", "gaid", "angbit", "ginID", " gID"], "name": ["alias", "parent", "base", "child", "member", "filename", "format", "shell", "info", "host", "ip", "image", "group", "version", "address", "prefix", "username", "names", "Name", "time", "node", "data", "meta", "mask", "NAME", "ext"], "value": ["depth", "port", "key", "entry", "description", "message", "format", "write", "property", "text", "end", "VALUE", "ip", "alt", "v", "uri", "range", "version", "vals", "device", "media", "settings", "Value", "val", "values", "content", "data"], "path": ["dir", "prop", "alias", "context", "key", "wp", "parent", "entry", "child", "id", "filename", "ath", "text", "th", "end", "col", "full", "ith", "token", "info", "host", "image", "root", "location", "resource", "transform", "url", "part", "uri", "skip", "enc", "area", "pass", "p", "code", "password", "route", "rh", "match", "prefix", "Path", "join", "link", "clean", "txt", "loc", "sync", "ph", "fn", "file", "node", "data", "content", "pattern", "dest", "method", "PATH", "sign", "pointer"], "oldpath": ["origloc", "origpath", "prevname", "oldname", "newdesc", "oldloc", "prevloc", "prevpath", "origname", "origdesc", "newloc", "newpath", "olddesc", "newname", "prevdesc"], "iovec": ["xioref", "iovecd", "iovect", "xiovec", " iokef", "iosef", " ioleh", "xiorec", "ioreuc", "ioodlec", "iokeci", " iolecin", "iopercat", "ioucs", "iomect", " iouct", " iokec", "iobyuc", "xioveuc", "iouct", "iosecc", "ioveh", "ioperc", " ioucc", "xiovecs", "ioveci", "ioyh", "iopercd", " ioveh", " iouc", "iovex", "iovecat", "iosecd", "iolec", "iokef", "iokec", " iovecin", " iolec", "ioretcat", "ioucc", "iobycs", "iorec", " iovef", "iosex", "ioodlect", "iobyc", " ioretcs", "ioyc", "iovecs", "iomecc", " ioucs", "iopercs", "ioycin", " iovecs", "ioretcd", "ioodlecs", "iosecs", "ioref", "ioodlecc", "ioviex", "ioyf", "xiovex", "xiovef", "xioreuc", " ioveci", "iokeh", "iorecc", "iorecs", "iorex", "xiovecc", "iobyf", "ioretc", "iomecs", "iokecs", "iovecc", "ioviec", "iovecin", " iovecat", "xiorecs", "iosecat", " ioretcd", "xiorecc", "ioveuc", " iovecc", "iouci", " iolef", "iolecin", "ioreci", "iomec", "iosec", "ioleh", " iokeci", "iolef", " ioretc", " iovecd", "iouuc", "iovief", "iouc", "iokecin", "iovef", "iouf", " ioretcat", " iokecs", " iovect", "ioretcs", "ioviecc", "xiorex"], "reply": ["report", "message", "write", "req", "Reply", "connection", "body", "send", "answer", "info", "cache", "session", "result", "resp", "request", "respond", "query", "py", "queue", "related", "route", "reverse", "buffer", "link", "jp", "sync", "next", "Response", "call", "replace", "rr", "rep", "server"]}}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n", "idx": 24968, "substitutes": {"r": ["ra", "sr", "rf", "rx", "gr", "lr", "self", "rs", "req", "er", "rb", "g", "br", "dr", "result", "request", "l", "resource", "rg", "tr", "mr", "parse", "R", "p", "fr", "m", "cr", "rh", "rss", "rl", "vr", "ar", "rc", "k", "re", "e", "usr", "kr", "hr", "ru", "rr", "pr", "res", "rar", "nr", "ir"], "status": ["index", "weight", "security", "err", "score", "state", "description", "mode", "progress", "source", "write", "id", "info", "fps", "update", "model", "result", "sol", "style", "Status", "service", "running", "code", "speed", "complete", "stage", "prefix", "device", "active", "si", "settings", "e", "sync", "enabled", "f", "msg", "spec", "stat", "str", "content", "uses", "STAT", "name", "success", "stats"], "sense_code": [" sense_codes", "senseidtag", "sense_tag", "sensevalcod", "sense_cod", " sense_core", "senseidcodes", " sense_number", "sense_number", " sense_cod", " sense_tag", "senseidcode", "senseidnumber", "sensevalcore", "sensevalcodes", "sense_core", "sensevalcode", "sense_codes"], "s": ["js", "scope", "sf", "n", "sl", "z", "http", "S", "rs", "sb", "ssl", "fs", "info", "g", "states", "h", "service", "instance", "p", "m", "u", "side", "su", "ns", "si", "settings", "e", "sync", "c", "d", "ss", "f", "spec", "ds", "services", "sq", "server", "o", "ses", "sys"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n", "idx": 25005, "substitutes": {"s": ["js", "b", "port", "home", "changes", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "request", "grades", "hs", "p", "u", "sets", "si", "sync", "sq", "native", "n", "set", "secondary", "conf", "state", "gs", "aws", "params", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "site", "its", "sf", "your", "status", "self", "ops", "secure", "none", "session", "ans", "ts", "is", "slice", "m", "sym", "sg", "f", "ds", "server", "plugins", "ses", "sys", "sl", "sv", "http", "os", "uns", "r", "storage", "ps", "ins", "manager", "south", "ns", "settings", "an", "d", "i", "ls", "services", "us"], "value": ["index", "after", "set", "status", "key", "state", "sv", "message", "id", "source", "description", "property", "valid", "end", "format", "response", "none", "fee", "VALUE", "current", "option", "total", "update", "size", "number", "type", "result", "expression", "v", "resource", "style", "store", "range", "service", "version", "m", "complete", "json", "address", "now", "attribute", "si", "settings", "Value", "d", "element", "reason", "object", "val", "values", "data", "section", "xml", "name"]}}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n", "idx": 25024, "substitutes": {"opts": ["otte", "prots", " optd", "adds", "opps", " opte", "opcs", "otps", "opter", "otter", "otoptions", "optts", " ops", "preths", "ops", "opte", "otTs", "optps", "OPds", "pretes", " opter", "omte", "protd", "prote", "opoptions", "omts", "optoptions", "opTs", "optd", "proths", " opcs", " optes", "optTs", "ads", "prets", "opttd", "optes", "OPts", "optte", "adts", "adths", "omTs", " opoptions", "OPs", "optter", "opths", "optths", "precs", "optcs", "OPths", "opttes", "omps", "opds", "otts", " opths", " opds"], "backend": ["ackend", "frontending", "backender", "bootward", "calender", " backen", "calended", "backends", "suppended", "backengine", "frontload", "behindends", "bended", "homeend", "headended", "ackended", "Backward", "aggended", "fronten", "frontward", "homesend", "frontsend", "backedserver", " backserver", "backedended", "Backserver", "workend", "frontserver", "backended", "returnending", "headend", "Backended", " backsend", "ckend", "aggward", " backending", "bootend", " backender", "returnend", "worksend", "buffended", "workending", "ckender", "backserver", "headending", "backen", "buffsend", "homeended", "frontended", "workended", "suppend", "aggsend", "headsend", "Backend", "bend", "worken", "Backender", "landload", "aggend", "backload", "suppward", "Backengine", "frontender", "buffward", "backedsend", "landsend", "returnends", "behindending", "returnengine", "ckending", "backsend", "ackload", "bsend", "frontend", "behindend", "backending", "buffend", "bootender", "bootengine", "suppsend", " backengine", "backward", " backends", "landend", "acksend", "calend", "behindengine", " backward", "homeender", " backended", "landended", "ckended", "bender", "backedend", "calending"], "errp": ["lererror", "ersp", "errerror", "lersp", " errerror", " errr", "lerr", " errsp", "err", "errsp", "lerp", "erp", "ererror", "errr"], "val": ["x", "b", "_", "num", "sl", "key", "rel", "live", "value", "base", "slot", "count", "req", "valid", "eval", "col", "len", "sel", "pol", "dim", "alt", "vol", "cal", "l", "v", "all", "ref", "part", "al", "ver", " Val", "VAL", "aval", "py", "il", "vc", "vals", "xx", "grad", "unit", "vert", "fail", "it", "tx", "var", "el", "elt", "rt", "ol", "loc", "doc", "pt", "ind", "lat", "f", "gen", "gal", "data", "call", "min", "Val", "pos", "serv", "cond", "vel", "fl"]}}
{"project": "FFmpeg", "commit_id": "39e0accb7a934bfe3d42324b016dd8790790746d", "target": 1, "func": "static unsigned int find_best(struct vf_instance *vf){\n\n  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);\n\n  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))\n\n    return IMGFMT_YV12;\n\n  else\n\n    return 0;\n\n}\n", "idx": 25066, "substitutes": {"vf": ["ffp", "Vc", " vfs", "vrf", "qfs", " vsf", "svsf", "svdf", "fsf", "svfp", "Vfs", " vrf", "ffs", "vc", "qf", "frf", "svf", "avfs", "avf", "svc", "Vdf", "vsf", " vfp", "Vf", "vdf", "qdf", "vfs", "qc", "svrf", "ff", "svfs", "avsf", "vfp", "avrf"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075, "substitutes": {"den": ["DEN", "ne", "dn", "pri", "ner", "oa", "nen", "limit", "fen", "en", "order", "n", "un", "da", "du", "err", "end", "norm", "iden", "plan", "Den", "sen", "su", "e", "flo", "ind", "dem", "zen", "dan", "mon", "que", "lan", "don", "none", "len", "dim", "m", "di", "wall", "side", "po", "nu", "data", "ven", "min", " Den", "der", "dy", "ten", "nan", "dom", "uni", "con", "range", "ben", "dev", "dm", "de", "db", "pen", "ani", "d", "diff", "pos", "fl"], "q": ["x", "depth", "b", "eq", "dq", "Q", "n", "qs", "un", "ch", "z", "id", "count", "req", "qu", "quant", "qq", "g", "qt", "l", "v", "h", "y", "query", "p", "qi", "m", "u", "w", "k", "e", "ue", "c", "d", "f", "sq", "qa", "o", "order", "cur"], "r": ["x", "b", "n", "sr", "err", "rs", "req", "er", "or", "rb", "result", "rate", "l", "v", "h", "rg", "range", "order", "R", "p", "m", "rh", "u", "ar", " R", "rc", "ur", "k", "e", "c", "d", "i", "f", "ru", "rr", "pr", "rar", "res", "o", "nr", "a", "re"], "num": ["b", "iq", "n", "mon", "un", "mult", "nb", "du", "id", "nc", "mn", "norm", "len", "g", "dim", "number", "bn", "uu", "en", "max", "dom", "cal", "no", "mu", "zero", "Num", "nom", "off", "uni", "con", "multi", "p", "m", "om", "unit", "u", "w", "su", "um", "na", "inc", "d", "nu", "f", "gen", "i", "NUM", "np", "nm", "o", "name", "bin", "sum"]}}
{"project": "FFmpeg", "commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "target": 1, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n\n{\n\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n\n    int t10, t11, t12, t13;\n\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n", "idx": 25081, "substitutes": {"blk": ["BLck", "plk", "oblk", "ylkin", "BLv", "brb", "Blck", "glq", "brsk", "plK", "llb", "BLk", "nlk", "brck", "slb", " blK", "brk", "mlch", "blkin", "nlsk", "mlK", " blke", "llsk", "glck", "mlks", "ylsk", "slku", "slsk", " blks", " blch", "Blk", "plsk", "llk", "oblb", "silK", "blck", "Blsk", "oblsk", "blku", "blb", "plks", "ylk", "llq", " blkin", "nlb", "glk", "mlk", "plck", "blch", " blsk", "silk", "oblck", "llks", "plke", "nlku", "glK", "blks", "blsk", "mlkin", " blq", "silks", " blck", "ylks", "Blb", "plb", "llke", " blku", "mlsk", "blv", "blke", " blb", "blK", "blq", " blv", "plq", "plv", "slk", "silch", "llck", "BLq"], "quant": ["product", "rec", "dash", "quad", "mult", "sc", "quick", "count", "charge", "text", "qu", "qq", "qual", "private", "quart", "total", "patch", "color", "compl", "serial", "percent", "mix", "query", "frac", "config", "app", "draw", "requ", "Quant", "util", "print", "integer", "pub", "local", "complex", "ident", "comp", "comment", "scale", "pay", "inc", "chart", "spec", "gap", "buff", "stat", "q", "cat", "press", "event", "sign", "form", "client", "pad", "post", "cur"], "t0": ["p8", "te000", "t000", "t00", "p2", "T1", "tzero", "f0", "te00", "f8", "dt0", "dt02", "dt000", "Tzero", "T0", "d0", "ta0", "T00", "T4", "dt00", "te02", "at0", "T2", "p4", "f1", "f4", "ta4", "d02", "f2", "te0", "at1", "szero", "atzero", "ta2", "s00", "ta8", "d000", "t02", "at00", "p0", "d00"], "t1": ["p1", "p3", "y4", "d4", "T1", "d1", "p2", "ta3", "T7", "p7", "p5", "y3", "ta7", "T4", "T2", "p4", "y1", "d2", "ta4", "f4", "f5", "f1", "d7", "T3", "ta1", "y5", "f3"], "t2": ["m2", "T5", "pB", "m5", "it4", "p2", "taB", "m0", "T7", "f0", "p5", "it62", "m4", "ta6", "ta5", "T4", "p4", "it2", "T2", "n7", "f4", "ta4", "t62", "n5", "f5", "f2", "n2", "p62", "ta2", "n4", "ta62", "p0", "itB"], "t3": ["pt3", "t03", "p1", "p3", "T5", "v1", "v5", "T03", "the3", "T1", "ta3", "e5", "T6", "ft3", "p7", "p5", "s03", "v3", "it5", "ta6", "it3", "T4", "e8", "ta5", "it2", "the5", "T2", "ft8", "ta03", "ta4", "pt13", "ft2", "pt5", "e2", "e3", "T8", "it13", "v7", "T3", "ta1", "ft5", "the13", "pt2", "the2"], "t4": ["tp4", "i8", "i2", "tp2", "i4", "ta5", "fB", "tpB", "f4", "ta4", "f2", "tp6", "ta2", "f6", "ta8", "i5"], "t5": ["p8", "it6", "p3", "m5", "it4", "p2", "ta45", "p5", "t45", "m4", "it5", "ta6", "ta5", "it3", "m6", "it2", "ta4", "it8", "it45", "m45"], "t6": ["T66", "t66", "t06", "e06", "f66", " t06", "ta3", "pt8", "e5", "T6", "f8", "ts6", "e8", "ta6", "ta7", "T4", "ta5", "ts8", "e12", "pt4", "pt66", "f4", "ta4", "e6", "ta9", "e9", "T8", "f6", "e4", "ta8", "pt6", "ts06", "f7", "ts12", "f3"], "t7": ["ta97", "ty07", " t07", "te74", "ta13", "ty7", " t74", "te07", "te13", "n07", "t07", "ty87", "tt13", "t97", "ta87", "te87", "te7", " t97", "ty13", " t87", "n13", "t87", "t74", "ta7", "n7", "tt07", "ta07", "te97", "n87", "tt74", "tt7"], "t8": ["it86", "ta08", "it6", "f10", "t08", "f8", "f86", "te8", "te08", "taE", "teEight", "taEight", "it8", "teE", "T8", "TE", "T08", "f6", "ta8", "it10", "TEight", "tEight", "t86", " t86"], "t9": ["d19", "it9", "ta99", " t09", "t19", "d49", "t09", "it11", "t99", "d11", "ta09", "t49", "pt9", "it49", "T99", "T09", "ta9", " t99", "d9", "pt49", "T8", "pt11", "pt19", "ta8", "T9", "it19"], "tA": ["teA", "mtC", "yO", "TC", "TB", "yC", "teI", "teC", "mtB", "mtA", "retC", "tO", "mtO", "yA", "yB", "tI", "teB", "TI", "retO", " tI", "retB", "retA", "TA"], "tB": ["tb", "TL", "taskB", "TB", "t42", "tiB", "taB", "taBB", "TR", "taskR", "T42", "taskBB", "tiBB", "taskL", " t42", "tiL", "tiR", "tR", "Tb", "TBB", " tBB", " tb", "ta42", "tab", "tL", "tBB"], "tC": [" tN", " tc", "wtB", "ttE", "fE", "vB", "TC", "yE", "tN", "taC", "yC", "atP", "taB", "tG", "yD", "atC", "pC", "vD", "otG", "wtC", "fB", "taE", "wtD", " tG", "atG", "tc", "ttB", "yB", " tP", "ttC", "TN", "pN", "pA", "otC", "ttD", "fC", "wtE", "vC", "taD", "tP", "otc", "TA", "pD", "atc", "TD", "otP", "fD", "vE"], "tD": ["pB", "tiD", "taC", "tiB", "taB", "tfD", "pC", "taF", "pF", "ptD", "tU", "ptC", "ptU", "tiC", "taD", "tfB", "pD", "tfC", "tfU", "ptB", "tiU"], "tE": ["mtC", "ttE", "tuV", "tuE", "ttV", "tV", "teC", "tG", "ttG", " tL", "teL", "timE", "mtG", "ttC", "timL", "tuC", "tuG", "teB", "teE", "timC", "tL", "mtV", "mtE", "timB"], "tF": ["taY", "tzY", "taV", " tV", " tY", "tzF", "tP", "taF", "taP", " tP", "tzV", "tY", "tV", "tzP"], "t10": ["t50", "s10", "set12", "f10", "s12", "s11", "f12", "f50", "set10", "s50", "set50", "set11", "f11"], "t11": ["T10", "f10", " t14", "T12", "f14", "f12", "T11", "T14", "t14", "f11"], "t12": ["p12", "all12", "p14", " t14", " t15", "all15", "p15", "all13", "t15", "all14", "t14", "p13"], "t13": ["s13", "t19", "tu13", "tu19", "s12", "t57", "tu57", "f57", "f19", "f13", "s57", "tu12", "s19", "f12"], "s0": ["p1", " s50", "ses0", "ps8", "s90", "p2", "s8", "ps1", "s12", "si90", "si2", "si0", " s8", "p90", "ses50", "s50", "si1", " s12", "si12", "ses8", "t90", "ses1", "ps0", "p0", "ps50"], "s1": ["ss1", "p1", "p3", "g4", "n1", "ns3", "ss9", "p2", "d1", "d3", "p7", "ss4", "ss3", "p5", "g9", "s9", "f1", "d2", "f5", "n7", "g1", "n5", "n2", "ns4", "d7", "g3", "f7", "f3", "ns9", "ns1"], "s2": ["s10", "g4", "p0", "ns10", "d5", "m5", "m8", "d4", "p2", "s8", "g5", "g2", "e5", "c5", "is2", "is4", "f0", "ns5", "e1", "p5", "c10", "m4", "d0", " s8", "p4", "is5", "f4", "ns2", "f5", "d2", "g1", "f2", "e2", "ns4", "c4", "e4", "p10", "is8", "m2", "c2"], "s3": ["se13", " s15", "p3", "p1", "d5", "se5", "m5", "sin53", "d4", "Sed", "sin3", "S03", "s8", "d3", "sined", "se4", "sin15", "g53", "d13", "p5", " s03", " s53", " sed", "s03", "m4", "S53", "S8", "s13", " s8", "p6", "sed", "f1", "f5", "s53", "m13", "s15", "se3", "m3", "S3", "g8", "f6", "S15", "g03", "g3", "f3"], "s4": ["p1", "g4", "d5", "w3", "d4", "p2", "s8", "g5", "d3", "g2", "p5", "w8", "d8", "n6", " s8", "p6", "p4", "w5", "g1", "n5", "n2", "w4", "n4"], "s5": ["d6", "p1", "i1", "d5", "p2", "s8", "d1", "c6", "e5", "i8", "c5", "s12", "ss4", "su12", "e1", "p5", "i3", "su5", "su4", "e8", "p6", "f1", "f5", "d2", "ss5", "f2", "ss12", "e3", " s12", "f6", "ss2", "c1", "i5", "su2", "c2"], "s6": ["p8", "g4", "ses6", "s8", "p2", "g2", "si11", "p7", "s12", "s11", "f8", "n8", "n6", " s8", "p6", "p4", "n7", "f4", " s12", "si12", "g8", "si6", "ses8", "f6", "n4", "g6", "ses11", " s11", "f3", "ses12", "si8"], "s7": ["p8", "sets712", "sys718", "h13", " s57", "v718", "sys87", "s667", "s07", "s8", "es8", "v87", "l7", "sets17", "l13", " s13", "ssl17", "p7", " s07", "s87", "es07", "sys07", "s57", "session17", "l57", "ssl712", "sets7", "session712", "z7", "session7", "z07", "h5", "s13", "ssl7", " s8", "es7", "v07", "sys7", "h7", "l5", "v7", "ssl718", "s712", "p667", " s667", "z718", "session718", "h57", "p07", "es667", "s718", "z87", "s17", "sets718"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 25091, "substitutes": {"p": ["b", "pb", "n", "a", "wp", "j", "http", "proc", "progress", "sp", "r", "op", "g", "patch", "ps", "pp", "l", "fp", "v", "pre", "m", "ap", "t", "s", "P", "per", "u", "jp", "k", "e", "c", "d", "bp", "pc", "i", "f", "data", "api", "np", "o", "tp", "lp", "post", "pa"]}}
{"project": "FFmpeg", "commit_id": "2c9be3882a03823413945bd9e2d9af33e6e322d5", "target": 0, "func": "static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,\n\n                              ScanTable *intra_scantable,\n\n                              uint16_t luma_intra_matrix[64],\n\n                              uint16_t chroma_intra_matrix[64],\n\n                              int hsample[3])\n\n{\n\n    int i, j, size;\n\n    uint8_t *ptr;\n\n    MpegEncContext *s = avctx->priv_data;\n\n\n\n    if (avctx->codec_id != AV_CODEC_ID_LJPEG) {\n\n        int matrix_count = 1 + !!memcmp(luma_intra_matrix,\n\n                                        chroma_intra_matrix,\n\n                                        sizeof(luma_intra_matrix[0]) * 64);\n\n    if (s->force_duplicated_matrix)\n\n        matrix_count = 2;\n\n    /* quant matrixes */\n\n    put_marker(p, DQT);\n\n    put_bits(p, 16, 2 + matrix_count * (1 + 64));\n\n    put_bits(p, 4, 0); /* 8 bit precision */\n\n    put_bits(p, 4, 0); /* table 0 */\n\n    for(i=0;i<64;i++) {\n\n        j = intra_scantable->permutated[i];\n\n        put_bits(p, 8, luma_intra_matrix[j]);\n\n    }\n\n\n\n        if (matrix_count > 1) {\n\n            put_bits(p, 4, 0); /* 8 bit precision */\n\n            put_bits(p, 4, 1); /* table 1 */\n\n            for(i=0;i<64;i++) {\n\n                j = intra_scantable->permutated[i];\n\n                put_bits(p, 8, chroma_intra_matrix[j]);\n\n            }\n\n        }\n\n    }\n\n\n\n    if(avctx->active_thread_type & FF_THREAD_SLICE){\n\n        put_marker(p, DRI);\n\n        put_bits(p, 16, 4);\n\n        put_bits(p, 16, (avctx->width-1)/(8*hsample[0]) + 1);\n\n    }\n\n\n\n    /* huffman table */\n\n    put_marker(p, DHT);\n\n    flush_put_bits(p);\n\n    ptr = put_bits_ptr(p);\n\n    put_bits(p, 16, 0); /* patched later */\n\n    size = 2;\n\n\n\n    // Only MJPEG can have a variable Huffman variable. All other\n\n    // formats use the default Huffman table.\n\n    if (s->out_format == FMT_MJPEG && s->huffman == HUFFMAN_TABLE_OPTIMAL) {\n\n        size += put_huffman_table(p, 0, 0, s->mjpeg_ctx->bits_dc_luminance,\n\n                                  s->mjpeg_ctx->val_dc_luminance);\n\n        size += put_huffman_table(p, 0, 1, s->mjpeg_ctx->bits_dc_chrominance,\n\n                                  s->mjpeg_ctx->val_dc_chrominance);\n\n\n\n        size += put_huffman_table(p, 1, 0, s->mjpeg_ctx->bits_ac_luminance,\n\n                                  s->mjpeg_ctx->val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, s->mjpeg_ctx->bits_ac_chrominance,\n\n                                  s->mjpeg_ctx->val_ac_chrominance);\n\n    } else {\n\n        size += put_huffman_table(p, 0, 0, avpriv_mjpeg_bits_dc_luminance,\n\n                                  avpriv_mjpeg_val_dc);\n\n        size += put_huffman_table(p, 0, 1, avpriv_mjpeg_bits_dc_chrominance,\n\n                                  avpriv_mjpeg_val_dc);\n\n\n\n        size += put_huffman_table(p, 1, 0, avpriv_mjpeg_bits_ac_luminance,\n\n                                  avpriv_mjpeg_val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, avpriv_mjpeg_bits_ac_chrominance,\n\n                                  avpriv_mjpeg_val_ac_chrominance);\n\n    }\n\n    AV_WB16(ptr, size);\n\n}\n", "idx": 25095, "substitutes": {"avctx": ["airpc", "airctx", " avvoc", "aveconfig", "apcf", "avconnection", "avecontext", "afpc", "afcontext", "avpc", "avcf", "afsc", "afctx", "afconnection", "Avcontext", "afconn", "avconn", "AVconnection", "airconn", "avcontext", "afsci", "Avsci", "AVctx", "apconfig", "avvoc", "AVcontext", "AVsc", "avsci", "AVcf", "Avctx", "aveconnection", "AVconn", "avsc", "aveconn", "afvoc", "apcontext", " avsci", " avcontext", "aircontext", "afcf", "AVpc", "AVconfig", "avectx", "apctx", "avconfig", "avesc", "afconfig", "Avvoc"], "p": ["x", "b", "port", "pb", "pi", "pl", "wp", "a", "php", "pair", "http", "proc", "progress", "cp", "er", "vp", "python", "ctx", "private", "or", "current", "sp", "point", "r", "op", "pkg", "patch", "cache", "up", "g", "pp", "ps", "result", "l", "fp", "y", "v", "part", "pre", "at", "m", "ap", "complete", "t", "package", "P", "u", "per", "comp", "jp", "e", "exec", "c", "like", "bp", "d", "pc", "f", "hp", "img", "param", "api", "np", "pr", "o", "tp", "lp", "post", "pa"], "intra_scantable": ["intra_descantiable", "intra_swantable", "intra_descanniable", "intra_swantatable", "intra_swattable", "intra_scattacle", "intra_scaintada", "intra_scaintation", "intra_scantada", "intra_expaintada", "intra_swattada", "intra_swattatable", "intra_expaintable", "intra_expaintation", "intra_swattacle", "intra_scannable", "intra_scantiable", "intra_scutation", "intra_scannation", "intra_descannables", "intra_scartable", "intra_scartada", "intra_scatative", "intra_descannation", "intra_scardada", "intra_scactable", "intra_expantada", "intra_scantacle", "intra_scutative", "intra_scaintable", "intra_swantacle", "intra_scantables", "intra_scatable", "intra_scardatable", "intra_scatada", "intra_scutable", "intra_scantative", "intra_expantation", "intra_scaintative", "intra_scactiable", "intra_scceptation", "intra_descannable", "intra_scantation", "intra_swantada", "intra_scattatable", "intra_scactables", "intra_scardable", "intra_scutada", "intra_scattada", "intra_scantatable", "intra_scatation", "intra_scceptables", "intra_descantable", "intra_scceptable", "intra_scartacle", "intra_descantables", "intra_scactation", "intra_descantation", "intra_scceptiable", "intra_expantable", "intra_expaintative", "intra_scannables", "intra_expantative", "intra_scattable", "intra_scanniable", "intra_scardacle", "intra_scartatable"], "luma_intra_matrix": ["luma_intra_bitrics", "luma_intra_protric", "luma_intra_metrices", "luma_intra_matramid", "luma_intra_contronic", "luma_intra_matensor", "luma_intra_bitrices", "luma_intra_attric", "luma_intra_protri", "luma_intra_attensor", "luma_intra_matronic", "luma_intra_projectri", "luma_intra_matrices", "luma_intra_protrix", "luma_intra_attrix", "luma_intra_attronic", "luma_intra_monrices", "luma_intra_atramid", "luma_intra_matri", "luma_intra_metractor", "luma_intra_matractor", "luma_intra_contensor", "luma_intra_contric", "luma_intra_atrix", "luma_intra_matric", "luma_intra_atri", "luma_intra_protramid", "luma_intra_projectrix", "luma_intra_monrix", "luma_intra_atronic", "luma_intra_bitric", "luma_intra_metric", "luma_intra_monric", "luma_intra_monrics", "luma_intra_matrics", "luma_intra_atractor", "luma_intra_bitrix", "luma_intra_contrix", "luma_intra_metrix", "luma_intra_projectric", "luma_intra_contrices", "luma_intra_atrics", "luma_intra_projectramid", "luma_intra_atric", "luma_intra_contractor", "luma_intra_atrices", "luma_intra_atensor"], "chroma_intra_matrix": ["chroma_intra_atrices", "chroma_intra_metrices", "chroma_intra_monrix", "chroma_intra_attrix", "chroma_intra_mitric", "chroma_intra_mitrix", "chroma_intra_attogram", "chroma_intra_metric", "chroma_intra_attrices", "chroma_intra_atogram", "chroma_intra_mitrices", "chroma_intra_monogram", "chroma_intra_atric", "chroma_intra_mitogram", "chroma_intra_matrices", "chroma_intra_mitrics", "chroma_intra_matric", "chroma_intra_matogram", "chroma_intra_metrix", "chroma_intra_atment", "chroma_intra_attment", "chroma_intra_attric", "chroma_intra_matment", "chroma_intra_matrics", "chroma_intra_monment", "chroma_intra_metrics", "chroma_intra_atrix", "chroma_intra_atrics", "chroma_intra_monric"], "hsample": ["HSpec", "hsamples", "hhpec", "hopssample", "HSamp", "ricsample", "ricsamp", "psample", "ricssample", "hhamp", "hopsamp", "hsamp", "HSample", "ricsamples", "hopspec", "hopsamples", "hssample", "psamp", "hhample", "hopsample", "HSamples", "hspec", "hhamples", "pssample", "psamples"], "i": ["x", "index", "b", "ai", "oi", "in", "pi", "n", "li", "ie", "key", "ji", "z", "id", "yi", "r", "iu", "ip", "g", "hi", "ix", "gi", "bi", "l", "v", "ti", "y", "io", "mu", "fi", "uri", "xi", "ini", "qi", "ik", "di", "I", "u", "it", "init", "ii", "my", "si", "e", "c", "ani", "d", "ind", "f", "eni", "ami", "ori", "ui", "ci", "vi", "phi", "o", "ni", "ri", "mi"], "j": ["index", "b", "jet", "adj", "js", "kj", "x", "li", "n", "ja", "key", "ie", "aj", "z", "jo", "r", "g", "job", "l", "y", "v", "ij", "xi", "qi", "m", "u", "ii", "je", "k", "jp", "si", "jc", "e", "jj", "ani", "d", "f", "jit", "jl", "q", "uj", "ui", "pos", "o", "ni", "ji", "dj", "J", "offset"], "size": ["x", "index", "weight", "n", "ize", "sc", "z", "count", "shift", "sh", "len", "sp", "g", "ix", "l", "empty", "code", "SIZE", "speed", "cs", "address", "unit", "scale", "capacity", "si", "small", "e", "loc", "c", "sec", "sized", "sn", "ci", "Size", "sum", "offset"], "ptr": ["depth", "index", "port", "scope", "oper", "inter", "err", "sh", "len", "dim", "br", "dr", "attr", "tr", "src", "rw", "code", "tmp", "alloc", "address", "ft", "inst", "rc", "buffer", "ii", "push", "addr", "loc", "pt", "Ptr", "str", "val", "pos", "iv", "trace", "length", "pointer", "fl", "offset"], "s": ["js", "b", "_", "n", "a", "parser", "sc", "id", "sv", "S", "gs", "space", "ops", "ssl", "sb", "bytes", "sp", "r", "g", "storage", "session", "params", "sa", "all", "service", "m", "cs", "t", "buffer", "ns", "sg", "si", "settings", "e", "c", "ses", "f", "spec", "data", "services", "sq", "o", "client", "stats", "support", "sys"]}}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103, "substitutes": {"machine": ["b", "scope", "database", "vm", "base", "home", "mode", "kernel", "state", "note", "message", "space", "interface", "connection", "loader", "managed", "info", "host", "image", "cache", "jam", "model", "cell", "session", "boot", "template", "mobile", "part", "config", "instance", "manager", "computer", "M", "m", "Machine", "address", "table", "mac", "device", "hard", "comment", "process", "node", "e", "linux", "module", "object", "data", "server", "class", "slave"], "spapr": ["spaper", "spapersr", "spapl", "spapert", "spadyr", "SPapper", " spapsru", "sprapra", "spamprs", "skapar", "spamprt", "scapeb", "spadpr", "skapb", "spapsar", " spaper", "SPapprs", "scapepr", "scapb", "SPapprator", "scaprs", "spupr", "spapsrc", "skarpr", "skarpar", " spapl", "sparpsr", "spapprs", "skapsr", " spaprb", "sprapl", "spapR", " spappre", "sparpr", "spampre", "spappre", "spappb", "spAPr", "spashre", " spapprt", "scapyr", "scapeer", "spaityr", "SPapr", "spampr", "spampR", "spapsrb", " spapar", " spaptrb", "spAPrs", " spaptr", "spappar", "spapeyr", "spuprb", "SPapprc", "spaprb", "skapr", "spashrt", "spapepr", "spapsru", " spappru", "spapra", "spampru", "SPapprb", "spaptl", "spamper", "spraprs", " spapsr", "spapprator", " spappsr", "SPaprator", "scapert", " spappb", "scapr", "sprapr", "spaprc", "spappr", " spapsrs", "spapsl", "skarpsr", "spashr", "spasher", "scapeyr", "spaprt", "spaptrb", "SPaprc", "sparprc", "spadr", "sparpru", "spaprs", "spapser", "spapprb", "spappru", "spraprb", "spapeb", "spaptr", " spapb", "sparpb", "spapru", "spappsr", "spadrs", "spaitrs", " spapru", "SPaprb", "spapsr", "skarpb", "spampb", "spaprator", "scaprt", " spapsl", " spapra", "scaper", "SPaprs", "spampsr", "spapeer", "spaptar", " spaprs", "spapre", " spapR", "spapper", "spapsrator", " spappr", " spaprt", "scappr", "spapb", "spAPru", "sparprator", "spapsrs", "spaptra", "scapers", " spapsar", "sparpar", "spAPR", " spapre", "spupra", " spapsR", "spapsR", "spapyr", "spaperr", "spapers", "spapprt", " spapper", "spapar", " spaptra", "sparprs", "spaitr", "spupl", "spaptrs", "SPaper", "spaperb", "spaperar", "spapprc", "SPappr", " spaptl", "spaitpr", "sprapar"], "smc": ["mmc", "mmp", "smp", "svcc", "smcc", "SMf", "SMcc", "SMp", "svp", "mmcc", "svf", "SMc", "mmf", "smf", "svc"], "kernel_filename": ["kernelpubfilename", "kernel_description", "linux_username", "kernel_source", "kernelingdescription", "linux_description", " kernel_username", "linux_filename", "kernel___description", "kernelpubfile", "kernelingfilename", "kernelpubpassword", " kernel_file", "kernelingusername", "kernel_password", "kernel___source", "kernel___username", "kernelingsource", "kernelpubusername", "kernel___filename", "kernel_file", "kernel_username", "linux_source", " kernel_password"], "kernel_cmdline": ["kernel_hostline", "kernel_hostLine", "kernel_commandli", "kernel_cmdLine", "kernel_hostli", "kernel_hostname", "kernel_macli", "kernel_macline", "kernel_macLine", "kernel_commandLine", "kernel_cleanline", "kernel_commandname", "kernel_cleanLine", "kernel_cleanname", "kernel_commandline", "kernel_cmdname", "kernel_cmdli"], "initrd_filename": ["initrt_name", "initrt_filename", "initrs_name", "initrd_file", "initrd_name", "initrs_file", "initrt_mode", "initrs_filename", "initrd_mode", "initrt_file", "initrd_location", "initrs_location"], "cpu": ["gp", "disk", "vm", "pu", "net", "proc", "cp", "hw", "mx", "lu", "cache", "nic", "boot", "mem", "conn", "gpu", "pool", "computer", "processor", "process", "node", "linux", "CPU", "pc", "gnu", "cow", " CPU"], "phb": [" phbs", " php", "ppp", " phB", "ppbs", "ppb", "PHbs", "PHb", "phB", "ppB", "php", "phbs", "PHB", "PHp"], "i": ["ai", "b", "pi", "n", "z", "j", "r", "ip", "is", "l", "h", "io", " I", "p", "ress", "m", "s", "I", "it", "si", "e", "c", "d", "f", "o", "ni", "ri", "a"], "sysmem": ["sysram", "proclang", "procmem", "systemmemory", " syslang", "procram", "syslang", "systemlang", " sysram", "procmemory", "systemmem", " sysmemory", "sysmemory", "systemram"], "ram": ["disk", "sc", "tm", "Ram", "mode", "cms", "ream", "AM", "image", "cache", "mem", "rom", "resource", "sam", "instance", "cam", "range", "access", "mac", "gram", "iam", "process", "RAM", "sim", "img", "cow", "mm", "rams"], "rma_region": ["rma_location", "rna_resource", "rna_location", "rma_area", "rna_area", "rma_resource", "rna_region"], "rma": ["Rmas", "Rga", "srma", "Rfa", "Rma", " rta", " rga", "srfa", "rga", "nrfa", "Rta", "srmas", "rmas", " rmas", "nrma", "rta", " rfa", "nrga", "rfa", "nrmas", "srta"], "rma_alloc_size": ["rma_alloc_ize", "rma_allocetnum", "rma_allocetcount", "rma_loc_num", "rma_alloc_unit", "rma_allocallid", "rma_loc_count", "rma_alloc_id", "rma_alloc_num", "rma_loc_size", "rma_alloc__num", "rma_alloc_scale", "rma_alloc__count", "rma_alloc_number", "rma_allocetize", "rma_alloc__ize", "rma_alloc32scale", "rma_alloc_count", "rma_alloc_length", "rma_loc_ize", "rma_alloc32small", "rma_allocallsize", "rma_alloc32number", "rma_allocallunit", "rma_alloc_small", "rma_allocetsize", "rma_alloc_address", "rma_alloc_capacity", "rma_alloc__size", "rma_alloc32size", "rma_alloc_name", "rma_allocallscale"], "load_limit": ["loadinglength", "loadinglim", "load_length", "load_limited", "loader_lim", "load___limit", "loadingpolicy", "loadinglimit", "load_policy", "load_lim", "loader_policy", "load___lim", "loader_length", "load___length", "loader_limit", "load___policy", "load_limits", "loader_limited", "loader_limits"], "fw_size": ["hw_length", "hw_size", "fw_length", "hw_capacity", "fw_address", "fw_capacity", "hw_address"], "filename": ["alias", "path", "dll", "description", "fil", "loader", "fd", "title", "jpg", "url", "original", "wav", "uri", "src", "files", "processor", "password", "cmd", "username", "prefix", "file", "fn", "phrase", "Filename", "name"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n", "idx": 25113, "substitutes": {"s": ["js", "b", "in", "sc", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "tests", "p", "features", "args", "u", "sets", "si", "sync", "xs", "as", "n", "qs", "conf", "gs", "less", "es", "l", "ks", "service", "strings", "cs", "t", "su", "e", "c", "ss", "spec", "its", "sf", "your", "sites", "self", "ops", "full", "session", "ts", "is", "src", "sym", "sg", "f", "ds", "server", "ses", "bis", "sys", "os", "uns", "ps", "ins", "south", "ns", "settings", "d", "i", "ls", "services", "comments", "us"], "otp_region": ["otp_version", "otp_union", "otp_reg", "otip_location", "otpa_reg", "otp8location", "otpa_version", "otp_country", "otp8region", "otip_region", "otcp_union", "otp_division", "otcp_division", "otip_country", "otcp_reg", "otp_location", "otp_string", "otcp_region", "otp8version", "otpa_location", "otip_string", "otcp_location", "otp8reg", "otpa_region"], "dinfo": ["darea", "wblock", "ddni", "cinfo", "sddata", "sdinf", " dInfo", "cblock", " dblock", "finfo", "DInfo", "dblock", " dafi", "winfo", "dinf", "fInfo", "finf", "ddata", " ddata", "Dinfo", "cInfo", "dInfo", "dafi", "dni", "ddisu", "dbisu", " darea", "idinfo", "iddata", "dbinfo", "warea", "wInfo", "ddinfo", "ddafi", "Ddata", " disu", "dbni", "sdinfo", "sdInfo", " dinf", "dbafi", "idInfo", "disu", "carea", "fdata", " dni"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n", "idx": 25119, "substitutes": {"env": ["sb", "ou", "ne", "cache", "h", "oa", "ini", "p", "core", "args", "inst", "ev", "u", "el", "txt", "eni", "fen", "en", "her", "context", "n", "un", "dict", "conf", "edge", "end", "conn", "enc", "rev", "exc", "obj", "e", "c", "event", "qa", "ext", "site", "que", "vm", "vs", "inet", "net", "proc", "environment", "loader", "enter", " environment", "config", "fr", "m", "cfg", "ef", "export", "ea", "extra", "ec", "output", "np", "server", "org", "engine", "et", "chal", "dt", "eu", "energy", "gui", "inv", "cv", "v", "py", "manager", "equ", "operator", "init", "eve", "console", "forge", "db", "assets", "settings", "eng", "ig", "Environment", "fx", "global", "viron"], "f": ["x", "b", "fw", "fc", "sf", "n", "rf", "fo", "filename", "j", "func", "tf", "fd", "function", "fs", "r", "fac", "l", "fp", "v", "fi", "h", "cf", "p", "fr", "m", "t", "F", "fm", "u", "fun", "feed", "file", "e", "c", "fn", "d", "exec", "af", "bf", "fore", "fa", "fx", "fen", "fe", "o", "ff", "form", "fb", "buff"], "cpu_fprintf": ["cpu_grint", "cpu_dformat", "cpu_lformat", "cpu_rfprintf", "cpu_fwrite", "cpu__fformat", "cpulexlprintf", "cpu2rfprintf", "cpu_faffle", "cpu_efetch", "cpulexlprint", "cpu__frep", "cpu_wprintf", "cpu_lprint", "cpu_rfprintln", "cpu_Fprintf", "cpu_infrep", "cpu_frep", "cpu_rfenny", "cpu_cenny", "cpu__rfrep", "cpulexfenny", "cpu__rfrint", "cpu2fformat", "cpu_fblt", "cpu_fbformat", "cpuloginfformat", "cpu_Fxp", "cpulogfrep", "cpu_confprintf", "cpupyefprintln", "cpu_Faffle", "cpu_rfrep", "cpupyefetch", "cpulexfformat", "cpu_fmt", "cpu_efprint", "cpu_grep", "cpu_fxp", "cpu_cprintln", "cpu__rfprintf", "cpu2fxp", "cpu_Fformat", "cpu__fecho", "cpu__fwrite", "cpu_Fwrite", "cpu_lprintf", "cpu_fbprintf", "cpu_inflt", "cpu_fprintln", "cpu_bprintln", "cpu__decho", "cpu_confrint", "cpu_infprintf", "cpu__fprintf", "cpulogflt", "cpu_wxp", "cpu_fprint", "cpupyefprint", "cpu_rfprint", "cpu_rfformat", "cpulexlenny", "cpu_clt", "cpulexfprintf", "cpu_Fprintln", "cpu_cwrite", "cpulexlformat", "cpu__dformat", "cpu2rfxp", "cpu_cetch", "cpu_confecho", "cpu_rfmt", "cpuloginfrep", "cpu_caffle", "cpu_fenny", "cpulexfprint", "cpu_fformat", "cpu_cprintf", "cpu__dwrite", "cpu__frint", "cpu_wformat", "cpu_rfrint", "cpu2fprintln", "cpu_confwrite", "cpupyfprint", "cpu_confformat", "cpu_frint", "cpu_dwrite", "cpu_fecho", "cpu2rfformat", "cpu2rfprintln", "cpu_wprintln", "cpu_lenny", "cpu_dprintf", "cpupyfprintln", "cpuloginfprintf", "cpu__dprintf", "cpupyfetch", "cpuloginflt", "cpu_cprint", "cpu_efprintln", "cpu_cecho", "cpu_gprintf", "cpu_bprintf", "cpu_Fprint", "cpulogfprintf", "cpu_baffle", "cpu2fprintf", "cpu_crep", "cpu_flt", "cpu_infformat", "cpu_confrep", "cpu_bwrite", "cpu_efprintf", "cpu_Fmt", "cpu_cformat", "cpu_fetch", "cpupyfprintf", "cpulogfformat", "cpu_rfxp", "cpu_decho", "cpupyefprintf", "cpu_fbrep"], "flags": ["ips", "lag", "does", "status", "vs", "bits", "ops", "Flags", "len", "faces", "fd", "fs", "fps", "ags", "fields", "options", " Flags", "files", "fg", "vals", "ints", "alf", "features", "lf", "args", "ports", "alls", "lbs", "fun", "forces", "ils", "utils", "settings", "fish", "types", "frames", "fx", "fires", "flag", "ff", "eth", "stats", "ants", "fl"], "c0_status": ["c0_width", "c0_stats", "c0lexlevel", "c1_status", "c1_state", "c0lexStatus", "c0lexsuccess", "c1_stat", "c15_Status", "c0_speed", "c0lexstatus", "c0Pspeed", "c0Pstat", "c15_success", "c1_Status", "c15lexlevel", "c0_state", "c15lexStatus", "c0Pstate", "c1_speed", "c1_width", "c1_err", "c0_stat", "c0_success", "c15_status", "c0Pstatus", "c1_stats", "c0_level", "c15_level", "c15lexsuccess", "c15lexstatus", "c0_err", "c0_Status"], "i": ["index", "x", "ai", "b", "loop", "oi", "li", "pi", "n", "in", "base", "id", "j", "abi", "col", "yi", "info", "r", "hi", "ip", "iu", "type", "gi", "bi", "l", "ti", "v", "io", "h", "fi", "mu", "uri", "xi", "ini", "uni", "multi", "p", "qi", "code", "zi", "m", "conv", "di", "I", "t", "u", "it", "ii", "k", "si", "e", "c", "uli", "d", "start", "eni", "adi", "diff", "cli", "api", "ui", "phi", "ci", "o", "ni", "ri", "mi"]}}
{"project": "FFmpeg", "commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "target": 1, "func": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n", "idx": 25130, "substitutes": {"state": ["seed", "oper", "j", "proc", "body", "test", "ctx", "private", "r", "STATE", "cache", "session", "states", "attr", "params", "State", "boot", "resource", "conn", "part", "store", "config", "inner", "code", "address", "args", "callback", "obj", "inst", "handle", "addr", "settings", "media", "param", "start", "str", "data", "st", "length", "buff"], "hdr_info": ["hhr_info", "hDR_info", "hhr_inter", "hDR_inf", "hdrsinf", "hDR_Info", "hdrsInfo", "hdr_id", "hDR_id", "hdr_Info", "hdrsid", "hdrsinfo", "hdr_error", "hdr0info", "hdr_fo", "hhr_index", "hdr0inter", "hhr_private", "hhr_inf", "hhr_fo", "hdr_private", "hDR_diff", "hhr_Info", "hdr0private", "hhr_error", "hdr_diff", "hDR_di", "hdr_inter", "hdr0inf", "hdr_di", "hdr_index", "hdr_inf"], "need_next_header": ["need_next_frame", "need_new_header", "need_next_layer", "need_new_layer", "need_new_message", "need_next_message", "need_next_channel", "need_new_channel", "need_new_frame"], "new_frame_start": ["new_frame2set", "new_frame_pos", "new_fram_offset", "new_fram_end", "new_frame2start", "new_frame2end", "new_fram_id", "new_fram_pos", "new_frame_end", "new_fram_set", "new_frame_offset", "new_frame_set", "new_frame_id", "new_fram_start", "new_frame2id"], "bits": ["sections", "ips", "mp", "details", "bc", "outs", "cmp", "flags", "proc", "rs", "self", " buffers", "hops", "bytes", "ops", "ctx", "sb", "fps", "bs", "cache", "ps", "params", "boot", "bps", "options", "rooms", "py", "config", "boxes", "batch", "ints", "t", "features", "mins", "bug", " bytes", "tx", "lins", "init", "pieces", "utils", "settings", "txt", " tcp", "bugs", "buff", " props", "cb", "data", "pins", "parts", "pos", "nos", "bit", "opt", "nets", "locks", "temp", "bis", "stats"], "hdr": ["handdr", " dhtr", "phDR", "bhver", " hDR", " hrs", " hsr", "adhdr", "phrs", "herler", "chder", "hder", " hman", "hlman", "adhDR", "ohsr", "bhdr", "htr", "rhder", " hver", "wdr", "ohder", "hldr", " hler", "hDR", "hller", "adhrs", "adhder", "hsr", "rhrs", "handder", "hdder", "hdvar", "ohrid", "hhr", "hvar", "hver", "hrs", "herdr", "rhver", "hdhr", "hhtr", "hler", "wvar", "chrid", "hrid", "hhdr", "chsr", " hrid", "hhder", "phder", "chdr", "handvar", "ohdr", "wder", "whr", "hman", "handhr", "herman", "bhder", " dhder", " htr", "phdr", "bhrs", " hder", "rhdr", " dhdr", "hddr"], "size": ["x", "n", "ize", "sum", "big", "cmp", "shape", "count", "bytes", "send", "full", "len", "cache", "number", "new", "part", "empty", "SIZE", "code", "pack", "iz", "address", "unit", "args", "rc", "scale", "capacity", "handle", "small", "loc", "c", "start", "extra", "sec", "from", "i", "sized", "ui", "Size", "pos", "en", "length", "offset"], "u8": ["f16", "u6", "u32", "uint16", "c16", "c6", "x16", "c32", "U8", "f8", "c8", "u16", "ui32", "ui6", "x8", "x32", "uint6", "ui8", "U6", "ui16", "f6", "f32", "uint32", "U32", "U16", "x6", "uint8"], "tmp": ["buf", "prop", "array", "mp", "nb", "cmp", "proc", "cp", "stuff", "tf", "bb", "sb", "ctx", "vt", "rb", "storage", "cache", "attr", "params", "boot", "fp", "bt", "part", "src", "py", "config", "app", "obj", "fm", "inst", "input", "jp", "amp", "txt", "img", "cb", "data", "np", "tp", "dat", "temp", "uv", "fb", "buff"]}}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,\n\n                       int sign)\n\n{\n\n    uint64_t ret = 0;\n\n#if defined(DEBUG_ASI)\n\n    target_ulong last_addr = addr;\n\n#endif\n\n\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    switch (asi) {\n\n    case 0x82: /* Primary no-fault */\n\n    case 0x8a: /* Primary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n", "idx": 25134, "substitutes": {"env": ["enable", "context", "chal", "que", "vm", "dt", "conf", "eu", "err", "proc", "environment", "shell", "dh", "req", "vt", "emb", "qt", "cv", "conn", "fi", "cf", "enc", "erv", "config", "py", "core", "exc", "equ", "iss", "obj", "ev", "init", "eve", "console", "forge", "db", "ef", "e", "ea", "eng", "eni", "ec", "cb", "dat", "np", "viron", "iv", "en", "ext"], "addr": ["dc", "remote", "erg", "mode", "ac", "asm", "url", "oa", "arm", "grad", "complete", "address", "socket", "ast", "usr", "bridge", "eni", "art", "adder", "en", "name", "x", "rx", "da", "err", "state", "nc", "edge", "er", "host", "add", "amd", "conn", "anne", "enc", "sta", "kt", "arr", "prefix", "rc", "node", "start", "ad", "grade", "ext", "offset", "error", "ret", "ace", "ptr", "enter", "dr", "attr", "osi", "advert", "slice", "uri", "src", "config", "route", "rss", "cmd", "mac", "acl", "hop", "amp", "rt", "player", "ea", "layer", "data", "server", "np", "gru", "adr", "nr", "afi", "alias", "align", "aug", "r", "ip", "coord", "alt", "work", "la", "xp", "au", "area", "ar", "loc", "ord", "pad"], "asi": ["ai", "afi", "pi", " si", "aa", "aka", "isa", "ois", "ta", "anti", "ara", "anza", "iso", "esi", "assi", "axis", "asis", "asm", "params", "sa", "ti", "osi", "ati", "uri", "oa", "ini", "asu", "arity", "sta", " sa", "zi", "address", "asa", "ski", "radius", "acl", "ity", "si", "ais", "asio", "ani", "agi", "eni", "osa", "ami", "i", "adi", "aaa", "asia", "api", "ui", "aci", "qa", "sha", "ni", "adr", "ei"], "size": ["engine", "year", "n", "security", "ize", "ny", "align", "member", "z", "mode", "shape", "source", "format", "timeout", "offset", "len", "sh", "fee", "storage", "number", "en", "six", "ice", "gn", "hh", "slice", "style", "enc", "large", "empty", "sort", "SIZE", "code", "speed", "cs", "password", "address", "unit", "complete", "south", "page", "cm", "scale", "capacity", "si", "time", "small", "loc", "sync", "c", "extra", "sec", "i", "eni", "sized", "ui", "sn", "Size", "esc", "form", "name", "length", "sum"], "sign": ["mini", "mod", "Sign", "ize", "align", "big", "shape", "shift", "format", "lex", "send", " sig", "magic", "sp", "connect", "wrap", "gn", "secret", "SIGN", "enc", "ign", "pass", "act", "plus", "rc", "scale", "small", "sync", "inc", "ig", "ss", "spec", "round", "account", "load", "sw", "reg", "form", "en", "se", "sum"]}}
{"project": "FFmpeg", "commit_id": "3228ac730c11eca49d5680d5550128e397061c85", "target": 1, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift, ret;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance < FF_COMPLIANCE_STRICT) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Format does not strictly comply with VC2 specs\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, decrease strictness to use it.\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    ret = av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n    if (ret)\n\n        return ret;\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 25135, "substitutes": {"avctx": ["AVconv", "evconn", "svctx", "nav\n", "afpkg", "afcu", "ajpkg", "av\n", "ivcms", "svcontext", "navcmp", "abconv", "avecms", "ivkb", "aucf", "avpkg", "abctx", " avconn", "aveconn", " avcontext", "ajnum", "evcu", "avectx", " avcf", "auloc", "afcontext", "ivctx", "ovchan", "avecontext", "AVkb", "abcontext", "AVcms", "afloc", "ajconv", "navpkg", "ovcontext", "ausys", "ajcontext", "ivcontext", "ajctl", "navcu", "ajcmp", "abconn", "avecca", "AVconn", "navconn", "avctl", "avnum", "avepkg", "auconn", "avekb", "avcu", "evcontext", "avcf", "afctx", "afchan", "avecmp", "afconn", "avconn", "AVcca", "avconv", "avcms", "aucontext", "AVcontext", "afctl", "AVcf", "AVcu", "evctx", "aunum", "aveloc", "avcmp", "evcmp", "navcca", "ajctx", "avsys", "navctx", "evchan", "svpkg", "AVpkg", "ovconn", "ovctx", "navx", "afcmp", "avcontext", "svctl", "AVcmp", "avecu", "avcca", "avchan", "navcontext", "abcmp", "avkb", "navnum", "ajx", "afsys", "aj\n", "avloc", "auctx", "avesys", "aux", "au\n", "avx", "AVctx"], "p": ["gp", "pb", "pi", "n", "wp", "pu", "cp", "op", "pp", "pe", "pre", "m", "ap", "t", "P", "u", "jp", "e", "c", "bp", "hp", "pc", "q", "np", "tp", "lp", "pa"], "b": ["buf", "base", "nb", "bb", "sb", "binary", "bs", "rb", "bar", "br", "boot", "l", "v", "ib", "bd", "gb", "ab", "buffer", "c", "bp", "cb", "lb", "B", "a", "bin"], "i": ["x", "index", "depth", "ai", "oi", "mini", "in", "pi", "n", "li", "ie", "ji", "z", "id", "source", "abi", "yi", "info", "iu", "ip", "ix", "gi", "bi", "l", "is", "ti", "io", "fi", "v", "y", "uri", "xi", "ini", "uni", "inner", "part", "name", "multi", "qi", "m", "zi", "I", "di", "chi", "t", "it", "ii", "k", "si", "e", "c", "gu", "d", "start", "f", "eni", "ind", "uli", "ui", "ci", "phi", "ni", "ri", "ki", "mi"], "j": ["js", "li", "n", "key", "rel", "z", "note", "len", "op", "pop", "l", "v", "ij", "m", "it", "ii", "k", "jp", "f", "jl", "q", "uj", "pos", "im", "ji", "J"], "level": ["depth", "index", "scope", "temp", "weight", "key", "path", "parent", "rel", "sc", "value", "mode", "source", "count", "col", "full", "len", "zip", "hi", "position", "size", "type", "levels", "quality", "volume", "pe", "style", "role", "low", "lvl", "cl", "version", "priority", "speed", "lock", "stage", "line", "code", "unit", "profile", "where", "scale", "time", "file", "loc", "inc", "limit", "delay", "str", "val", "q", "layer", "server", "le", "grade", "name", "height", "length", "vel", "fl"], "o": ["num", "oi", "n", "mode", "os", "option", "op", "position", "type", "no", "io", "oa", "range", "mo", "m", "O", "po", "ol", "e", "f", "out", "opt", "ob", "oe", "offset"], "shift": ["depth", "ch", "mode", "cp", "len", "op", "pop", "dim", "size", "max", "br", "dr", "cv", "type", "src", "skip", "off", "sort", "rc", "push", "scale", "jp", "sup", "cb", "pos", "length", "offset"], "ret": ["depth", "num", "rec", "mode", "std", "rows", "count", "pin", "len", "mi", "dim", "alt", "no", "nz", "quiet", "rc", "deep", "att", "layer", "val", "back", "Ret", "flag", "bit", "en", "fl"], "fmt": ["tftm", "fortm", "Flt", " frt", "defformat", "tfrt", "mmt", "frt", "forilt", "cMT", "infmt", "infformat", "frtt", "mtm", "cnt", "forprintf", "flt", "infilt", "ctm", "Fnm", "tfformat", "mformat", "fmp", "rfnm", "infmn", "frmt", "Fnt", " flt", "pmt", "mMT", "fformat", "tfilt", "formMT", "formmt", "frmn", "inftt", " fnm", " filt", "formrt", "fnm", "mprintf", "Ftm", "infprintf", "ptm", "fnt", "prt", "rfilt", "milt", "frformat", " ftm", "formlt", "deftt", "defmt", "tfmt", "plt", "FMT", "filt", "tflt", "fMT", "defmn", " fmp", "mmp", "Filt", "rfMT", "formt", "ftm", "tfMT", "Frt", " fformat", "rfmt", "cmt", "ftt", " fMT", "Fmt", "forformat", " fnt", "fmn", "Fmp"], "s": ["js", "S", "rs", "ssl", "sb", "fs", "g", "new", "hs", "u", "sets", "si", "sup", "sync", "xs", "sq", "parts", "a", "n", "qs", "secondary", "conf", "gs", "info", "params", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "stats", "site", "its", "details", "sites", "self", "ops", "full", "session", "ts", "is", "m", "sym", "sg", "f", "ds", "data", "ses", "sys", "sv", "os", "ctx", "r", "storage", "ps", "v", "ins", "ns", "settings", "d", "ls", "services", "comments", "groups"]}}
{"project": "FFmpeg", "commit_id": "b86651a208ee67666a7305b002bc9f14b21dae7f", "target": 1, "func": "static av_cold int rv40_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n\n\n    r->rv30 = 0;\n\n    ff_rv34_decode_init(avctx);\n\n    if(!aic_top_vlc.bits)\n\n        rv40_init_tables();\n\n    r->parse_slice_header = rv40_parse_slice_header;\n\n    r->decode_intra_types = rv40_decode_intra_types;\n\n    r->decode_mb_info     = rv40_decode_mb_info;\n\n    r->loop_filter        = rv40_loop_filter;\n\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n\n    return 0;\n\n}\n", "idx": 25149, "substitutes": {"avctx": ["ivctx", "avecrit", "navctx", "navkb", "afca", "awcontext", "avecontext", "afcc", "aveca", "afcas", "awcas", "afctx", "navcas", "avcas", "afkb", "ajcc", "ajctx", "avcrit", "afcmp", "ajcontext", "avcontext", "avca", "ivcontext", "avcc", "AVcmp", "ajcmp", "awctx", "navcontext", "ivca", "AVcontext", "avkb", "ivcrit", "awkb", "avectx", "avcmp", "afcontext", "AVcc", "afcrit", "AVctx"], "r": ["b", "array", "sr", "n", "err", "self", "rs", "er", "ir", "or", "rb", "g", "result", "dr", "br", "attr", "l", "reader", "v", "ner", "rg", "tr", "mr", "R", "p", "arr", "fr", "m", "cr", "rh", "t", "u", "rc", "ar", "ur", "rt", "e", "c", "d", "f", "i", "hr", "ru", "kr", "data", "rr", "pr", "rar", "o", "adr", "nr", "re"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 25163, "substitutes": {"opaque": ["ipacity", "compacity", "Opaque", "compque", "openque", " opque", "openaque", "Opacity", "ospicit", "ospaque", " opacity", "ipaque", "compaque", "Opicit", "ospque", "opque", "Opque", "opacity", "ipicit", "ipque", "openacity", "ospacity", "opicit"], "sprn": ["wrn", " sprb", " sprN", "Sprnum", "sprns", "prn", "sprnum", "wrN", "wrnum", "prnum", "SprN", " sprns", "sprN", "Sprb", "prN", "Sprns", "sprb", "Sprn", "prb", "wrb", "prns"], "ctx": ["context", "scope", "unc", "bc", "cmp", "ca", "anc", "proc", "cc", "cp", "pkg", "cv", "cas", "fp", "conn", "ref", "cf", "src", " cx", "alloc", "grad", "prefix", "obj", "rc", "cm", "tx", "ctrl", "acl", "jp", "cca", "loc", "exec", "c", "sync", "bp", "pc", "lc", "cb", "qa", " context"]}}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167, "substitutes": {"format": ["ant", "array", "Format", "value", "column", "base", "source", "filename", "space", "property", "text", "len", "magic", "function", "type", "character", "field", "command", "transform", "template", "style", "version", "pretty", "unit", "prefix", "argument", "package", "attribute", "args", "language", "scale", "letter", "feat", "arg", "file", "target", "f", "spec", "str", "data", "term", "cat", "pattern", "method", "form", "name", "length", "pointer", "at"]}}
{"project": "FFmpeg", "commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "target": 1, "func": "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n\n                                   uint8_t **data, int *size)\n\n{\n\n    static const int extradata_nal_types_hevc[] = {\n\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n\n    };\n\n    static const int extradata_nal_types_h264[] = {\n\n        H264_NAL_SPS, H264_NAL_PPS,\n\n    };\n\n\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n\n\n    H2645Packet h2645_pkt = { 0 };\n\n    int extradata_size = 0;\n\n    const int *extradata_nal_types;\n\n    int nb_extradata_nal_types;\n\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n        extradata_nal_types    = extradata_nal_types_hevc;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n\n    } else {\n\n        extradata_nal_types    = extradata_nal_types_h264;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n\n    }\n\n\n\n    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,\n\n                                ctx, 0, 0, ctx->par_in->codec_id, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &h2645_pkt.nals[i];\n\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n\n            extradata_size += nal->raw_size + 3;\n\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n\n            } else {\n\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (extradata_size &&\n\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n", "idx": 25179, "substitutes": {"ctx": ["context", "fc", "qs", "sci", "sc", "conf", "tk", "bc", "cmp", "ca", "anc", "cc", "cp", "cms", "req", "pkg", "ck", "qt", "cv", "cas", "kw", "fp", "conn", "cf", "Context", "config", "cam", "vc", "p", "kt", "grad", "cs", "tc", "cmd", "conv", "wcs", "rc", "cm", "tx", "ct", "ctrl", "jp", "cca", "txt", "exec", "c", "git", "sync", "pc", "lc", "cb", "q", "sq", "cu", "ci", "np", "qa", "client", "kb", "concept", " context"], "pkt": [" packet", " pet", "hkg", "hacket", " psth", "het", "hkt", "cpsth", "cpkt", "pelt", " pkg", "helt", "packet", "pkg", "Pkg", "psth", " pelt", "pke", "Pke", "Pelt", "hke", " pct", "Pet", "pct", " pke", "Packet", "pet", "Pct", "cpct", "Pkt", "Psth", "cpacket"], "data": ["accept", "parent", "value", "id", "message", "connection", "body", "bytes", "response", "DATA", "zip", "binary", "window", "cache", "type", "result", "reader", "ata", "slice", "name", "config", "batch", "p", "draw", "read", "address", "Data", "args", "device", "input", "buffer", "missing", "sample", "media", "start", "d", "next", "load", "content", "memory", "dat", "bin"], "size": ["depth", "cap", "n", "ize", "mode", "shape", "body", "send", "bytes", "offset", "len", "storage", "type", "slice", "empty", "version", "SIZE", "code", "address", "args", "channel", "capacity", "scale", "small", "c", "sec", "sized", "Size", "name", "length", "sum"], "extradata_nal_types_hevc": ["extradata_nal_types_hll", "extradata_nal_types_shec", "extradata_nal_types_keVC", "extradata_nal_types_shevc", "extradata_nal_types_kevc", "extradata_nal_types_pell", "extradata_nal_types_sheVC", "extradata_nal_types_hxc", "extradata_nal_types_peVC", "extradata_nal_types_pec", "extradata_nal_types_hc", "extradata_nal_types_shexc", "extradata_nal_types_hell", "extradata_nal_types_pevc", "extradata_nal_types_hVC", "extradata_nal_types_kec", "extradata_nal_types_kell", "extradata_nal_types_hexc", "extradata_nal_types_hec", "extradata_nal_types_pexc", "extradata_nal_types_hvc", "extradata_nal_types_heVC"], "extradata_nal_types_h264": ["extradata_nal_types_h128", "extradata_nal_types_H265", "extradata_nal_types_v64", "extradata_nal_types_phavi", "extradata_nal_types_v24", "extradata_nal_types_ph128", "extradata_nal_types_H64", "extradata_nal_types_he24", "extradata_nal_types_v128", "extradata_nal_types_ph265", "extradata_nal_types_Havi", "extradata_nal_types_pavi", "extradata_nal_types_H24", "extradata_nal_types_H264", "extradata_nal_types_p264", "extradata_nal_types_ph264", "extradata_nal_types_v264", "extradata_nal_types_h265", "extradata_nal_types_p64", "extradata_nal_types_h24", "extradata_nal_types_he128", "extradata_nal_types_he264", "extradata_nal_types_v265", "extradata_nal_types_he64", "extradata_nal_types_ph24", "extradata_nal_types_h64", "extradata_nal_types_havi", "extradata_nal_types_p24", "extradata_nal_types_ph64"], "s": ["n", "qs", "a", "parser", "sc", "gs", "ssl", "g", "session", "sa", "h", "p", "csv", "cs", "t", "w", "sac", "ns", "sg", "e", "c", "d", "f", "sec", "spec", "ss", "sq", "ses"], "extradata_nal_types": ["extradata_nals_type", "extradata_nal_type", "extradata_nals_names", "extradata_nals_styles", "extradata_nal_styles", "extradata_nals_types", "extradata_nal_ypes", "extradata_nal_pes", "extradata_nal_properties", "extradata_naled_type", "extradata_naled_pes", "extradata_naled_types", "extradata_nals_properties", "extradata_nal_names", "extradata_nal_times", "extradata_nals_ypes", "extradata_nals_resources", "extradata_naled_times", "extradata_nal_resources"], "nb_extradata_nal_types": ["nb_extradata_naled_plugins", "nb_extradata_naled_types", "nb_extradata_nal_type", "nb_extradata_nal_resources", "nb_extradata_naled_type", "nb_extradata_nal_ids", "nb_extradata_nal_names", "nb_extradata_naler_type", "nb_extradata_nals_ids", "nb_extradata_nals_type", "nb_extradata_nals_names", "nb_extradata_naled_ids", "nb_extradata_naler_ids", "nb_extradata_nals_types", "nb_extradata_naler_resources", "nb_extradata_nal_plugins", "nb_extradata_naler_types"], "i": ["index", "b", "x", "num", "mini", "ai", "oi", "li", "pi", "n", "in", "key", "ie", "ret", "id", "j", "count", "len", "yi", "iu", "ip", "hi", "ix", "type", "result", "gi", "bi", "v", "ti", "fi", "io", "y", "uri", "xi", "ini", "multi", "p", "qi", "ik", "zi", "m", "di", "I", "chi", "u", "it", "ii", "k", "si", "e", "ani", "gu", "d", "start", "f", "eni", "jit", "adi", "c", "ind", "ui", "phi", "im", "ri", "a", "ki", "mi"], "nal": ["ynal", "noneal", "nalis", "naale", "nonale", "nanale", "nanal", "naal", "nealis", "pnAL", "rnmal", "pnals", "ynAL", "naalis", " nals", "neal", "ynals", " nale", "nals", "namal", "nonal", "nonals", "rnalis", " neal", "pnal", "nemal", "rnale", "nale", "ynale", "rnal", "nanals", " nAL", "pnale", "nAL", "neale", "nmal", "naneal"]}}
{"project": "FFmpeg", "commit_id": "0409d333115e623b5ccdbb364d64ca2a52fd8467", "target": 1, "func": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,\n\n                                       int16_t *src2,\n\n                                       int height, int denom, int wx0, int wx1,\n\n                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)\n\n{\n\n    int x, y;\n\n    pixel *src = (pixel *)_src;\n\n    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);\n\n    pixel *dst          = (pixel *)_dst;\n\n    ptrdiff_t dststride = _dststride / sizeof(pixel);\n\n    const int8_t *filter = ff_hevc_epel_filters[mx - 1];\n\n    int shift = 14 + 1 - BIT_DEPTH;\n\n    int log2Wd = denom + shift - 1;\n\n\n\n    ox0     = ox0 * (1 << (BIT_DEPTH - 8));\n\n    ox1     = ox1 * (1 << (BIT_DEPTH - 8));\n\n    for (y = 0; y < height; y++) {\n\n        for (x = 0; x < width; x++)\n\n            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +\n\n                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));\n\n        src  += srcstride;\n\n        dst  += dststride;\n\n        src2 += MAX_PB_SIZE;\n\n    }\n\n}\n", "idx": 25181, "substitutes": {"_dst": ["_rset", "_bbl", "_rest", "_rst", "_idest", "_sst", "_sset", "_idst", "_idsts", "_dest", "_lsp", " _lst", "_dstr", "_bst", "_lst", " _dbl", "_lstr", "_Dst", " _dsp", " _dset", " _lsp", "_Dbl", " _lbl", "_dsts", "_rsts", "_idset", "_bstr", "_bsp", " _rest", " _lstr", "_ssts", "_Dsp", "_Dstr", "_sest", " _dsts", " _dest", " _dstr", " _rst", "_lbl", " _rsts", "_dsp", "_dbl", "_dset", " _rset"], "_dststride": ["_dndstrided", "_dstStrided", "_dstSTRride", "_dndstrides", "_dstdrride", "_dststrride", "_dndbride", "_dostStrided", "_dstbrise", "_dstSTRide", "_dstdrise", "_dostStrride", "_dstdrided", "_dstbride", "_dostStriding", "_dstStriding", "_dstbrides", "_dststrided", "_doststride", "_dstdrides", "_dndbrides", "_doststrride", "_dstdride", "_dststriding", "_dndstrise", "_dstdriding", "_dstbrided", "_dstSTRiding", "_dstStrides", "_dndstride", "_dstStrise", "_dstStrride", "_doststriding", "_dndbrise", "_dstSTRided", "_dostStride", "_doststrided", "_dststrides", "_dststrise", "_dstStride", "_dndbrided"], "_src": ["_sb", "_rc", " _loc", "_sl", " _source", "_loc", " _sl", "_source"], "_srcstride": ["_srcSTRides", "_locStrride", "_srcStrides", "_locStride", "_locStrides", "_srcbrided", "_srcstrided", "_srcSTRride", "_srcStride", "_srcbrride", "_srcStrided", "_locStrided", "_srcbrider", "_srcstider", "_srcSTRide", "_srcstrider", "_srcbrides", "_srcbride", "_srcSTRider", "_srcStrride", "_locstrided", "_srcstrride", "_srcstide", "_srcstrides", "_srcstides", "_locstrride", "_locstride", "_locstrides", "_srcSTRided"], "src2": ["src32", "rc2", "src4", "loc1", "source1", "loc2", "rc32", " src4", "loc4", " src1", "source0", "src1", "src0", "rc1", " src0", "RC2", "rc3", "rc0", " src32", "rc4", "RC1", "src3", "source3", "source2", " src3", "RC32"], "height": ["depth", "z", "shape", "thin", "gh", "rows", "crop", "tight", "th", "dy", "Height", "sh", "pull", "row", "window", "ip", "size", "dim", "han", "max", "h", "hh", "style", "def", "wall", "w", "deep", "center", "d", "img", "bottom", "length"], "denom": ["denym", "sinym", "Denomin", " denow", " denomin", "sinomin", "DENoom", "Denom", "denow", "DENow", "Denoom", "Denow", "denomin", "denam", "Denam", "Denym", "DENom", " denam", "sinam", " denym", " denoom", "sinom", "denoom", "DENomin"], "wx0": ["ww8", "wx2", "hw8", "xy0", "wx8", "x1", "hw0", "x8", "xy1", "xy8", "hw2", "hw1", "xy2", "ww0", "ww1", "x2", "x0", "ww2"], "wx1": ["wx01", "wp3", "wx2", "rw1", "fw1", "x1", "wp1", "fw2", "wx3", "xy01", "rw3", "wp2", "rw01", "xy1", "xy2", "fw0", "wp01", "ww0", "rw2", "ww1", "x2", "xy3", "x0", "ww2"], "ox0": [" ox10", "oxk", "ex00", "ox10", "mix8", "box0", "x00", "box2", "wx2", "mix10", " oxk", "x1", "wx00", " ox2", "ck1", "ix00", "ck0", "ex0", "ix0", "xi", " ox8", "oxi", "ix2", "ox8", "mix0", "ck00", "ox2", "ex8", "wxk", "ex10", " ox00", "ix1", "wxi", "mix00", "boxk", "x2", "box00", "x0", "ox00", "ixi", "ck2"], "ox1": ["ixOne", "xone", "wxone", "box0", "box1", "ex11", "box2", "wx2", "x11", "x1", "oxone", " ox2", "exone", "xOne", "ix0", "ix2", " oxOne", "ix11", "ox2", "oxOne", "ix1", "ox11", "ex1", "x2", "x0", "ex2", "boxone", "ixone"], "mx": ["weight", "mic", "vm", "cpu", "rx", "xc", "MX", "mode", "byte", "mn", "mc", "image", "ix", "px", "xp", "wx", "cf", "ij", "py", "large", "nz", "xx", "m", "ap", "ux", "dm", "mb", "nn", "mac", "cm", "tx", "ms", "hop", "wm", "module", "ng", "mm", "ml", "mask", "nm", "xml", "nr", "mag"], "my": ["world", "mic", "mon", "wp", "ny", "win", "gray", "mn", "dll", "wave", "cy", "mal", "ys", "ma", "imag", "py", "gy", "amin", "mb", "md", "ms", "mm", "ml", "tiny", "micro", "bin", "sys", "mi"], "x": ["b", "index", "n", "key", "rx", "xc", "z", "id", "j", "xxx", "ax", "wa", "X", "ady", "ip", "image", "ix", "px", "no", "work", "h", "v", "xi", "cross", "on", "p", "code", "xx", "t", "ex", "w", "dx", "xy", "tx", "u", "el", "time", "e", "pixel", "c", "d", "ey", "f", "i", "ph", "xs", "q", "fx", "sw", "o", "yx", "en"], "y": ["b", "yl", "vy", "oy", "yn", "Y", "n", "ny", "ch", "z", "id", "j", "ky", "wy", "cy", "col", "dy", "yi", "ye", "type", "ys", "sy", "h", "yr", "v", "py", "ym", "p", "gy", "m", "yt", "t", "xy", "w", "hop", "c", "ey", "d", "i", "f", "ya", "ay", "iy", "yy", "o", "yx", "ry", "ty"], "src": ["rect", "gz", "bl", "upp", "sl", "sr", "rx", "rel", "sc", "source", "filename", "proc", "req", "lib", "sub", "sb", "ctx", "sel", "upload", "r", "rb", "image", "cv", "url", "slice", "sur", "stream", "config", "gb", "core", "rl", "rss", "channel", "chrom", "inst", "vr", "rc", "camera", "loc", "uc", "sup", "sync", "start", "c", "img", "cb", "sq", "dest", "RC", "bg", "cur"], "dst": [" ddr", "Dest", "sst", "dbl", "bsp", "sdst", "dsc", "sbl", "dsp", "rdr", "adst", "ddr", " dsp", "bst", "dsts", " dbl", "bstr", "Dst", "rsc", "dsl", "Dbl", "sdsp", " dstr", "sest", "sdstr", " dsts", "bbl", " dest", "Dsts", "addr", "rst", "adsl", "sdbl", "rsl", "ssts", "dest", "adsc", " dsl", "dstr", " dsc"], "filter": ["Filter", "path", "parent", "source", "wave", "header", "include", "sel", "feature", "cache", "type", "transform", "url", "stream", "config", "sort", "channel", "force", "effect", "block", "fn", "layer", "map", "mask", "opt", "bin", "fl"]}}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182, "substitutes": {"dcl": ["pdbl", "sdcl", "dbl", " dfl", "dsc", "pacl", "fcl", "ffl", "pdsc", "pdacl", "dml", "dfl", "dbc", "pbl", "Dacl", " dbl", " dacl", "dpl", "pcl", "pdcl", "Dfl", "psc", "bacl", "fbc", " dpl", "Dml", "sdbc", "bfl", " dbc", "sdpl", " dml", "Dcl", "dacl", "fpl", "sdfl", "bcl", "bml", " dsc"], "backing_id": ["backings_side", "backings_name", "backings_type", "backing_ids", "backing_type", "backings_ids", "backings_id", "backings_start", "backing_side", "backing_name", "backing_start"], "backing_y_0_top": ["backing_y_in_high", "backing_y_from_top", "backing_y_0_high", "backing_y_from_bottom", "backing_y_from_high", "backing_y_0_tops", "backing_y_in_tops", "backing_y_from_tops", "backing_y_in_top", "backing_y_0_bottom", "backing_y_in_bottom"], "x": ["b", "index", "n", "win", "z", "id", "ax", "X", "g", "ix", "px", "l", "v", "wx", "xi", "p", "xx", "m", "t", "address", "s", "ex", "dx", "xy", "tx", "u", "e", "c", "d", "i", "f", "xs", "data", "pos", "name", "a"], "y": ["b", "oy", "yn", "vy", "year", "Y", "n", "ny", "z", "id", "ky", "wy", "cy", "dy", "yi", "ye", "type", "sy", "yo", "l", "v", "py", "hy", "p", "yt", "u", "ii", "c", "ey", "i", "ya", "q", "ay", "yy", "o", "yx", "ry", "ty"], "w": ["b", "fw", "weight", "n", "wp", "win", "aw", "z", "id", "ow", "wave", "ew", "W", "wa", "r", "ww", "g", "size", "wl", "wb", "l", "work", "v", "wx", "wal", "wd", "p", "m", "t", "s", "u", "we", "k", "e", "c", "d", "wh", "f", "i", "sw", "o", "height", "rw"], "h": ["b", "top", "n", "oh", "ih", "z", "id", "j", "bh", "end", "dy", "sh", "wa", "hi", "g", "host", "eh", "l", "v", "hs", "hm", "p", "m", "t", "rh", "s", "u", "k", "ah", "ha", "e", "c", "ph", "d", "f", "i", "q", "ht", "H", "o", "height"], "scon": ["lsCon", "physcon", "dswin", "sportsconst", " sctrl", "suc", "sgin", "sctrl", "psocon", "sconnect", "dconn", "dsrc", " sun", "esconst", "osrc", "wsconst", "tscon", "lscn", "ansconnect", "itsconn", " sca", "physron", "skyran", "gscon", "physcn", "sfac", "sinuc", " scn", " src", "sconst", "osconnect", " sacon", "ansrc", "ssconn", "dsocon", "lsdon", "osgin", "dsconn", " socon", "dsca", "sran", "physfc", "skycn", "portcon", "esdon", "gsfac", "sincon", "spen", "fwin", "ssel", "psconn", "sdon", "sron", "sinCON", "ssun", "itsfc", "tsfc", "fconnect", "tsdon", "dwin", "dsun", "symcon", "opensco", "symocon", "wsocon", "itsron", "lsconnection", "sun", "sinban", "itscon", "itscn", "sportscon", "gsocon", " sgin", "esocon", "sympen", "sCON", "psban", "opensfac", "itsconst", "dcon", " sconnect", "psuc", "itsban", "tspen", "anscon", "fcon", "wspen", "sco", "dfc", "oscon", "lsocon", " sfc", "gsconst", " sco", "sinco", "sinCon", "scn", "sconnection", "sCon", "sportssel", "sfc", "lsctrl", "Scon", "Sca", " sCON", "lsCON", " sconnection", " sCon", " sban", "sinocon", "src", "dscn", "dsconnect", " ssel", "tsconst", "gsctrl", "ssrc", "psconst", " sfac", "sban", " sron", "Sacon", "pscon", "lscon", "osfc", "openscon", "sinca", "dscon", "wscon", "sca", "dca", "psco", "lsban", "dsran", "osocon", "lsconst", "swin", "symconst", "portconst", "gspen", "lsran", "ansgin", "sacon", "sconn", "openspen", "skycon", "drc", "gsco", "portpen", "sportspen", " spen", "dsco", "docon", "escon", " sconn", "tsocon", " suc", " sconst", "portocon", "dsfc", " swin", "fco", "tsrc", "sscon", "skyocon", "SCON", "sinacon", "gsconnection", "socon"]}}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185, "substitutes": {"t": ["b", "port", "n", "ut", "dt", "r", "g", "tt", "ts", "l", "v", "p", "m", "s", "w", "it", "ct", "time", "e", "c", "d", "f", "i", "tick", "T", "o", "tp", "tty"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_write));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the entire\n\n       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 25189, "substitutes": {"s": ["js", "b", "site", "scope", "sf", "in", "n", "qs", "secondary", "conf", "sv", "S", "gs", "self", "ions", "source", "os", "ssl", "sb", "info", "r", "fs", "g", "session", "states", "new", "es", "request", "is", "l", "h", "service", "tests", "sis", "p", "m", "cs", "sym", "t", "u", "sets", "ns", "sg", "si", "sample", "settings", "e", "sync", "c", "sup", "d", "f", "i", "ss", "ds", "sec", "spec", "services", "sq", "stat", "o", "us", "se", "ses", "sys", "stats"], "data": ["buf", "array", "rec", "decl", "align", "da", "base", "source", "proc", "xxx", "ctx", "DATA", "len", "info", "ip", "cache", "size", "session", "record", "result", "new", "reader", "la", "resource", "slice", "src", "config", "arr", "p", "grad", "m", "address", "def", "Data", "args", "buffer", "input", "sample", "d", "f", "object", "ds", "str", "api", "map", "ad", "ui", "reg", "pos", "res", "memory", "dat", "bin"], "addr": ["orig", "buf", "alias", "array", "rx", "align", "proxy", "da", "nc", "dll", "proc", "ace", "rs", "source", "ack", "sb", "ctx", "ptr", "r", "coord", "attr", "dr", "amd", "asm", "la", "slice", "src", "sta", "arr", "code", "cmd", "address", "obj", "rc", "pad", "loc", "e", "ea", "seq", "amp", "sample", "ad", "np", "pos", "reg", "Address", "ord", "adr", "dat", "nr", "pointer", "offset"], "oi": ["ai", "pi", " si", "omi", "ie", "oko", "ih", "aram", "abi", "odi", "asi", "ois", " iii", "ilo", " vi", "oda", "yi", " ie", " pci", "ctx", "iu", "ip", " di", "ti", "osi", " bi", "oni", "fi", " Xi", "oa", "ini", "roc", "ib", "tmp", "uci", "oci", "igi", "sym", "di", " ki", " mi", "oid", "ski", "ii", "cm", " ii", "oji", "si", "ok", " i", "e", "isu", "agi", "eni", "i", "ogi", "mm", "ori", "ui", "rio", "ci", "phi", "api", " pi", "o", "im", "ei", "ki", "mi", "offset"], "addrz": [" addrzi", "adriz", "addrzi", "acez", "layerZ", " addriz", "addrw", "acezip", "addrZ", "acezi", "layerz", "adrw", "adrz", "layerzip", "leniz", "addressz", "aceZ", "addrza", " addrZ", "adrza", "adrZ", "lenzi", " addrzip", "lenz", "lenza", "layerzi", "adrzi", "addrzip", "addriz", " addrw", " addrza", "addressZ", "addressw"], "param": ["im", "index", "prim", "num", "key", "vm", "error", "da", "aram", "member", "err", "ram", "source", "proc", "col", "begin", "category", "jam", "dim", "model", "type", "attr", "asm", "params", "amd", "mem", "pri", "request", "item", "rom", "ref", "sam", "resource", "see", "sm", "p", "tmp", "arm", "m", "rn", "sym", "atom", "address", "channel", "adr", "cm", "var", "comment", "amp", "loc", "Param", "inc", "rm", "c", "pc", "i", "mm", "am", "ad", "pos", "qa", "grade", "nm", "par", "pm", "name", "prom", "temp", "mi"], "func": ["orig", "b", "buf", "fc", "unc", "rx", "lambda", "nc", "dll", "proc", "cc", "self", "xxx", "lib", "ctx", "function", "r", "rb", "attr", "asm", "amd", "job", "work", "kw", "xp", "fi", "cf", "slice", "src", "go", "code", "grad", "cmd", "args", "callback", "obj", "fun", "var", "wrapper", "mac", "loc", "exec", "fn", "dd", "c", "pc", "f", "sec", "cb", "aux", "val", "call", "method", "abc", "sys"], "label_ptr": ["label6pointer", " label_pos", "label6code", " label_size", "labelingPtr", "labelingptr", "field_ptr", "label_Ptr", "label67size", " label_addr", "label67code", "field_pos", "label67length", " label_length", "labelingpos", "labelingpointer", "label67ptr", "label_size", " label_code", " label_pointer", "labelingaddr", "label67pointer", "field_Ptr", "label_addr", "label_code", "label6ptr", "label_pos", "label_length", "label6size", "label_pt", "label67addr", "field_pt", "labelingpt", "label67pt", "label_pointer", " label_pt"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n", "idx": 25223, "substitutes": {"fd": ["buf", "dir", "fc", "sf", "sd", "dc", "df", "id", "format", "connection", "fee", "fs", "flow", "size", "dn", "fp", "fed", "bd", "wd", "FD", "lf", "ld", "socket", "md", "xf", "db", "handler", "feed", "fff", "file", "fn", "pd", "d", "f", "fl", "length", "td", "ds", "cb", "dl", " f", "fa", "fx", " FD", "data", "bf", "fe", "cond", "ff", "client", "nd", "pipe", "temp", " fid", "fb", "buff"], "s": ["js", "b", "ips", "sf", "n", "sl", "qs", "http", "S", "gs", "self", "source", "os", "rs", "rows", "sb", "sh", "ssl", "fs", "r", "g", "ps", "aws", "ts", "es", "l", "is", "v", "ks", "src", "service", "ins", "p", "m", "sym", "t", "cs", "args", "u", "w", "socket", " fs", "side", "su", "ns", "sg", "si", "an", "e", "settings", "c", "sync", "d", "f", "i", "ss", "ls", "spec", "ds", "services", "sq", "server", "als", "o", "se", "ses", "as"]}}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->sei.unregistered.x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->sei.unregistered.x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 25245, "substitutes": {"h": ["oh", "ch", "ih", "http", "gh", "bh", "self", "hw", "he", "sh", "hi", "eh", "hl", "g", "host", "l", "v", "hh", "hs", "hm", "cl", "p", "history", "rh", "t", "s", "u", "w", "handler", "ah", "ha", "e", "ph", "c", "hp", "f", "hr", "q", "H", "ht"], "sl": ["nl", "bl", "li", "pl", "sf", "pg", "oper", "gl", "sc", "split", "lit", "lr", "bh", "zh", "ssl", "sh", "sel", "sb", "kl", "hl", "wl", "isl", "l", "sa", "la", "kel", "SL", "slice", "sk", "il", "cel", "cl", "sm", "spl", "util", "rl", "s", "t", "ell", "acl", "el", "su", "hel", "si", "ll", "loc", "c", "flo", "f", "lc", "ul", "ls", "Sl", "dl", "ml", "tl", "sn", "sw", "serv", "sil", "sch", "se", "ln", "fl"], "mb_type": ["mbqlength", "MB_types", "mb_length", "mb_TYPE", "mn_type", "db_TYPE", "MB_id", "mb_size", "mn_TYPE", "MB_type", "mbqid", "db_family", "db_id", "MB_length", "mbqtypes", "db_type", "mn_size", "mb_id", "mbqtype", "mb_types", "mb_family"], "mb_type_col": ["mb_types_row", "mb_types_column", "mb_types_col", "mb_type_column", "mb_type_type", "mb_types_type", "mb_type_row"], "l1mv0": ["l1mw2", "l1mh6", "l1mx1", "l1cmw0", "l1cmv0", "l1cmv1", "l1cmw6", "l1mw6", "l1cmv2", "l1mh1", "l1cmw1", "l1mx2", "l1mw0", "l1cmv6", "l1mh0", "l1cmw2", "l1mv6", "l1mw1", "l1mx6", "l1mx0", "l1mh2", "l1mv2"], "l1mv1": ["l1dv1", "l1mw3", "l1dh1", "l1mh1", "l1mw0", "l1mb1", "l1mh0", "l1dv0", "l1mw1", "l1dh0", "l1mb3", "l1mh3", "l1mb0", "l1dv3", "l1mv3", "l1dh3"], "l1ref0": ["l1p1", "l1Ref1", "l_reference2", "l1Ref2", "l1Ref4", "l1reference2", "l1p2", "l1Ref0", "l_ref0", "l1ref2", "l1reference0", "l_reference1", "l_ref1", "l1p0", "l_reference4", "l1p4", "l_reference0", "l_ref4", "l1reference1", "l_ref2", "l1reference4", "l1ref4"], "l1ref1": ["l1reference8", "l1arc8", "l2f1", "l2ref1", "l1ref8", "l1f1", "l1reference1", "l2f8", "l1arc1", "l1f8", "l2ref8"], "i8": ["u6", "m10", "i6", "p8", "p6", "m6", "i16", "p10", "m16", "u10", "u16", "p16", "m8", "i10", "u8"], "i4": ["int8", "i6", "int4", "l8", "int64", " i6", "i64", " i64", "l4", "l64", "int6", "l6"], "ref": ["index", "num", "rec", "rel", "base", "conf", "inter", "id", "count", "col", "reference", " reference", "row", "info", "arc", "cache", "cal", "all", "null", "range", "config", "pre", "aff", "p", "REF", "def", "rc", "buffer", "Ref", "input", "comp", "comment", "ef", "arg", "block", "f", "diff", "val", "call", "pos", "pointer"], "mv": [" mq", "bmj", "mvp", " mj", "pmvp", "bmq", "mj", "bmvp", " mvp", "pmq", "bmv", "pmj", "mq", "pmv"], "list": ["loop", "bl", "li", "com", "child", "entry", "id", "count", "pull", "g", "cache", "type", "cont", "p", "complete", "table", "comment", "old", "view", "block", "sync", "map", "name", "coll", "pl", "set", "key", "parent", "gl", "conf", "LIST", "record", "l", "L", "large", "pool", "low", "see", "pre", "cl", "arr", "listed", "List", "comp", "feat", "e", "lc", "cli", "cat", "out", "index", "lists", "que", "pair", "self", "test", "full", "len", "group", "all", "null", "config", "CL", "queue", "code", "rest", "seq", "module", "str", "call", "server", "ch", "base", "member", "source", "stack", "LI", "chain", "la", "batch", "act", "hold", "like", "i", "ul", "diff", "load"], "C": ["E", "V", "D", "S", "N", "CM", "JC", "W", "EC", "L", "G", "CA", "U", "CL", "M", "R", "K", "O", "F", "I", "P", "LC", "VC", "c", "DC", "H", "CR", "T", "FC"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n", "idx": 25247, "substitutes": {"opaque": ["opaco", "OPque", "copqua", " opque", "OPaques", " opaques", " opqua", " opacity", " opaco", "copacity", "operacity", "operaques", "OPaco", "opque", "OPaque", "opacity", "operaco", "copaques", "operqua", "opaques", "operaque", "copaque", "operque", "opqua"], "event": ["date", "x", "key", "error", "vent", "child", "id", "shape", "message", "events", "text", "end", "test", "ack", "current", "Event", "layout", "image", "size", "g", "type", "which", "command", "ce", "style", "ee", "t", "address", "ent", "channel", "callback", "input", "view", "node", "e", "start", "d", "age", "ec", "data", "press", "esc", "xml", "name"], "s": ["sf", "n", "sl", "a", "your", "secondary", "state", "S", "gs", "self", "rs", "ops", "sb", "ssl", "fs", "r", "g", "session", "states", "aws", "new", "h", "service", "hs", "p", "m", "sym", "t", "south", "u", "sets", "side", "su", "sg", "ns", "an", "e", "sync", "c", "sports", "f", "ss", "ds", "stat", "services", "sq", "o", "ses", "sys"]}}
{"project": "qemu", "commit_id": "ba7806ad92a2f6b1625cfa67d44dc1b71e3be44e", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252, "substitutes": {"ci": ["li", "dc", "sci", "xc", "cy", "reci", "cium", "coe", "ice", "fi", "ce", "cci", "uri", "ini", "icc", "uci", "oci", "ic", "di", "CI", "cit", "ii", "cm", "cgi", "si", "jc", "cod", "c", "lc", "cli", "co", "cu", "cia", "ni", "ei", "ili", "ki", "cd"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static void openpic_update_irq(OpenPICState *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25260, "substitutes": {"opp": ["owner", "dep", "coll", "front", "upp", "rog", "oper", "ost", "oph", "cmp", "supp", "own", "omp", "proc", "ko", "eff", "od", "ops", "ack", "agg", "pps", "op", "rb", "ov", "pkg", "cho", "pp", "off", "roc", "lov", "app", "oc", "tmp", "odd", "imp", "fail", "obj", "inst", "rc", "kick", "ogg", "comp", "plug", "ripp", "jp", "hack", "ppo", "sup", "OP", "gg", "opl", "cpp", "kk", "iop", "iv", "ff", "ord", "org", "cop", "ipp", "ob", "oe", "buff"], "n_IRQ": ["n_PRQ", "n_REX", "n_IRP", "n_AREC", "n_ARRQ", "n_IREB", "n_ARRP", "n_IRq", "n_ARB", "n_FRQUIRE", "n_IRU", "n_IREC", "n_ARV", "n_PRQL", "n_RRU", "n_RRANCE", "n_ARQual", "n_IRQL", "n_ARQ", "n_RRQL", "n_RREC", "n_TRQ", "n_RRLY", "n_RRQUIRE", "n_Mirq", "n_IRLY", "n_ARRANCE", "n_ARq", "n_MirQual", "n_IRX", "n_IREV", "n_PRP", "n_ARQUIRE", "n_IRB", "n_IREANCE", "n_FRQ", "n_MirP", "n_RRq", "n_TRP", "n_IRQual", "n_TRq", "n_ARU", "n_PRV", "n_RRX", "n_IREP", "n_ARANCE", "n_MirQ", "n_IRANCE", "n_RRQ", "n_RRV", "n_IRV", "n_REQ", "n_ARLY", "n_IRQUIRE", "n_ARX", "n_RRB", "n_ARP", "n_IREQ", "n_ARQL", "n_IREQL", "n_TRQual", "n_ARRV", "n_REU", "n_IRELY", "n_RRP", "n_IREEC", "n_FRq"], "src": ["sr", "sc", "bc", "inf", "send", "sb", "ssl", "sel", "scenes", "url", "gb", "grad", "chrom", "inst", "socket", "usr", "sup", "sync", "download", "sq", "sn", "bg", "cur", "buf", "dep", "gl", "rob", "std", "sub", "host", "rb", "tmp", "obj", "rc", "comp", "feat", "desc", "node", "ruby", "small", "img", "spec", "lc", "typ", "st", "impl", "dist", "fc", "ost", "rin", "liv", "cmp", "proc", "sth", "lib", "secure", "ptr", "hl", "attr", "resource", "wx", "null", "config", "rl", "rss", "btn", "input", "target", "rt", "uint", "kk", "iop", "RC", "sys", "sl", "supp", "source", "func", "stack", "ack", "sur", "stream", "ripp", "loc", "uc", "sec", "lit", "cb", "load", "dest", "obl", "support"], "i": ["ai", "b", "index", "mini", "x", "oi", "li", "pi", "n", "ie", "ji", "z", "id", "j", "me", "anti", "yi", "info", "iu", "ip", "hi", "ix", "gi", "bi", "l", "ti", "v", "fi", "mu", "io", "y", "uri", "xi", "ini", "slice", "inner", "p", "qi", "m", "zi", "t", "I", "di", "ski", "u", "it", "init", "ii", "my", "k", "si", "e", "c", "d", "eni", "f", "ami", "adi", "cli", "api", "ui", "phi", "ci", "o", "ni", "ri", "a", "mi"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n", "idx": 25263, "substitutes": {"s": ["js", "b", "native", "a", "secondary", "sv", "state", "http", "S", "gs", "os", "rs", "uns", "self", "ops", "opens", "ssl", "sb", "r", "session", "aws", "ts", "is", "v", "service", "p", "m", "sym", "t", "u", "w", "socket", "sets", "side", "su", "ns", "si", "e", "sync", "c", "f", "ss", "spec", "services", "sq", "o", "ses", "sys"], "fifo": ["logao", "promo", "pullo", "phyodo", "fifoff", "pullbo", "Fifpo", "flexo", "ippoo", " fifology", "FifO", "lipow", "lifpo", " fifodo", "fifbo", "fifode", "ditao", "fifpo", "fundo", "promoo", "phyo", "fifoa", "Fifoo", "lifoin", "pulloo", "fundos", "ritao", "ritpo", "promoid", "pullology", "filbo", "lipO", "filao", "infao", "ippoff", "rawno", " fifoko", "Fifo", "filo", "filoo", " fifop", "info", "rawnop", " fifoco", "infoff", "fetoo", "Fifoco", "pulloid", "fundoko", "Fifodo", "livo", "rawnoid", "ritoco", "lifao", "fifology", "infodo", "prombo", " fifos", "fetop", " fifow", "phyoo", "logbo", " fifoa", " fifO", " fifpo", "fifow", "logodo", " fifoff", "fifoin", "ligo", "fifO", "ritoo", "pullos", "ditoko", "fundoa", " fifoid", "fifop", "filodo", "fundbo", "fifao", "Fifode", "fundao", "flexpo", "lipo", "ligodo", "fifodo", " fifao", "flexoin", "feto", "livology", "fifoko", "Fifow", "logo", "rawnoo", " fifoin", "phyode", "ditodo", "Fifos", "lipos", "ligoa", "flexao", "fifos", "dito", "fifoo", "ippo", " fifoo", "livos", "fundodo", "fifoid", "fifoco", "filoid", "livode", "rito", "lifo", "fetoid", "infoo", "ritodo", "ditoa", "ritoa", "infoa", "ligos", "livodo", "livoo"], "send": ["set", "reply", "source", "message", "write", "shift", "text", "end", "final", "function", "update", "size", "fin", "open", "command", "kill", "query", "define", "service", "see", "empty", "parse", "draw", "pack", "read", "init", "push", "Send", "find", "feed", "missing", "export", "exec", "sent", "sync", "e", "transfer", "from", "sec", "start", "invoke", "apply", "call", "execute", "use", "later"], "complete": ["enable", "correct", "status", "progress", "func", "completely", "response", "full", "secure", "final", "done", "fee", "total", "escape", "closure", "result", "open", "master", "request", "close", "empty", "cl", "queue", "code", "lock", "fail", "callback", "fun", "complex", "Complete", "sync", "block", "seq", "exec", "transfer", "delay", "call", "content", "closed", "finished", "partial", "success"], "data": ["li", "del", "id", "byte", "req", "fee", "function", "cache", "result", "new", "zero", "url", "p", "el", "block", "cookie", "partial", "en", "name", "a", "buf", "parent", "da", "connection", "wa", "info", "open", "raw", "off", "low", "rev", "pre", "buffer", "start", "delay", "val", "api", "ui", "offset", "error", "lib", "bytes", "response", "full", "none", "current", "update", "no", "empty", "queue", "code", "def", "Data", "seq", "f", "str", "dat", "alpha", "base", "body", "DATA", "done", "image", "size", "la", "ata", "one", "fail", "ada", "first", "missing", "d", "i", "ul", "next", "content", "pos", "res", "length"], "len": ["loss", "li", "in", "ie", "split", "id", "count", "lic", "url", "lock", "line", "lf", "ler", "el", "block", "limit", "en", "name", "ln", "num", "n", "vec", "lim", "err", "end", "l", "low", "pre", "lon", " el", "lin", "e", " length", "start", "lc", "val", "dl", " lang", "le", "Len", "lan", "z", "net", "lib", "full", "lu", "hl", "all", "fi", "label", "code", "lo", "fn", "seq", "f", "layer", "min", "den", "lang", "lif", "base", "body", "lex", "dy", "fin", "size", "la", " lib", "fun", "d", "i", "lit", "pos", "length"]}}
{"project": "FFmpeg", "commit_id": "c2c1726847fe3a043762062db40774bf0cc434c3", "target": 0, "func": "static void compute_status(HTTPContext *c)\n\n{\n\n    HTTPContext *c1;\n\n    FFStream *stream;\n\n    char *p;\n\n    time_t ti;\n\n    int i, len;\n\n    AVIOContext *pb;\n\n\n\n    if (avio_open_dyn_buf(&pb) < 0) {\n\n        /* XXX: return an error ? */\n\n        c->buffer_ptr = c->buffer;\n\n        c->buffer_end = c->buffer;\n\n        return;\n\n    }\n\n\n\n    avio_printf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n\n    avio_printf(pb, \"Content-type: %s\\r\\n\", \"text/html\");\n\n    avio_printf(pb, \"Pragma: no-cache\\r\\n\");\n\n    avio_printf(pb, \"\\r\\n\");\n\n\n\n    avio_printf(pb, \"<html><head><title>%s Status</title>\\n\", program_name);\n\n    if (c->stream->feed_filename[0])\n\n        avio_printf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feed_filename);\n\n    avio_printf(pb, \"</head>\\n<body>\");\n\n    avio_printf(pb, \"<h1>%s Status</h1>\\n\", program_name);\n\n    /* format status */\n\n    avio_printf(pb, \"<h2>Available Streams</h2>\\n\");\n\n    avio_printf(pb, \"<table cellspacing=0 cellpadding=4>\\n\");\n\n    avio_printf(pb, \"<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\\n\");\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        char sfilename[1024];\n\n        char *eosf;\n\n\n\n        if (stream->feed != stream) {\n\n            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n\n            eosf = sfilename + strlen(sfilename);\n\n            if (eosf - sfilename >= 4) {\n\n                if (strcmp(eosf - 4, \".asf\") == 0)\n\n                    strcpy(eosf - 4, \".asx\");\n\n                else if (strcmp(eosf - 3, \".rm\") == 0)\n\n                    strcpy(eosf - 3, \".ram\");\n\n                else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n\n                    /* generate a sample RTSP director if\n\n                       unicast. Generate an SDP redirector if\n\n                       multicast */\n\n                    eosf = strrchr(sfilename, '.');\n\n                    if (!eosf)\n\n                        eosf = sfilename + strlen(sfilename);\n\n                    if (stream->is_multicast)\n\n                        strcpy(eosf, \".sdp\");\n\n                    else\n\n                        strcpy(eosf, \".rtsp\");\n\n                }\n\n            }\n\n\n\n            avio_printf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \",\n\n                         sfilename, stream->filename);\n\n            avio_printf(pb, \"<td align=right> %d <td align=right> \",\n\n                        stream->conns_served);\n\n            fmt_bytecount(pb, stream->bytes_served);\n\n            switch(stream->stream_type) {\n\n            case STREAM_TYPE_LIVE: {\n\n                    int audio_bit_rate = 0;\n\n                    int video_bit_rate = 0;\n\n                    const char *audio_codec_name = \"\";\n\n                    const char *video_codec_name = \"\";\n\n                    const char *audio_codec_name_extra = \"\";\n\n                    const char *video_codec_name_extra = \"\";\n\n\n\n                    for(i=0;i<stream->nb_streams;i++) {\n\n                        AVStream *st = stream->streams[i];\n\n                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                        switch(st->codec->codec_type) {\n\n                        case AVMEDIA_TYPE_AUDIO:\n\n                            audio_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*audio_codec_name)\n\n                                    audio_codec_name_extra = \"...\";\n\n                                audio_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_VIDEO:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*video_codec_name)\n\n                                    video_codec_name_extra = \"...\";\n\n                                video_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case AVMEDIA_TYPE_DATA:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                    }\n\n                    avio_printf(pb, \"<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s\",\n\n                                 stream->fmt->name,\n\n                                 stream->bandwidth,\n\n                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,\n\n                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);\n\n                    if (stream->feed)\n\n                        avio_printf(pb, \"<td>%s\", stream->feed->filename);\n\n                    else\n\n                        avio_printf(pb, \"<td>%s\", stream->feed_filename);\n\n                    avio_printf(pb, \"\\n\");\n\n                }\n\n                break;\n\n            default:\n\n                avio_printf(pb, \"<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\\n\");\n\n                break;\n\n            }\n\n        }\n\n        stream = stream->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        if (stream->feed == stream) {\n\n            avio_printf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n\n            if (stream->pid) {\n\n                avio_printf(pb, \"Running as pid %d.\\n\", stream->pid);\n\n\n\n#if defined(linux) && !defined(CONFIG_NOCUTILS)\n\n                {\n\n                    FILE *pid_stat;\n\n                    char ps_cmd[64];\n\n\n\n                    /* This is somewhat linux specific I guess */\n\n                    snprintf(ps_cmd, sizeof(ps_cmd),\n\n                             \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\",\n\n                             stream->pid);\n\n\n\n                    pid_stat = popen(ps_cmd, \"r\");\n\n                    if (pid_stat) {\n\n                        char cpuperc[10];\n\n                        char cpuused[64];\n\n\n\n                        if (fscanf(pid_stat, \"%9s %63s\", cpuperc,\n\n                                   cpuused) == 2) {\n\n                            avio_printf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\",\n\n                                         cpuperc, cpuused);\n\n                        }\n\n                        fclose(pid_stat);\n\n                    }\n\n                }\n\n#endif\n\n\n\n                avio_printf(pb, \"<p>\");\n\n            }\n\n            avio_printf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\");\n\n\n\n            for (i = 0; i < stream->nb_streams; i++) {\n\n                AVStream *st = stream->streams[i];\n\n                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                const char *type = \"unknown\";\n\n                char parameters[64];\n\n\n\n                parameters[0] = 0;\n\n\n\n                switch(st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_AUDIO:\n\n                    type = \"audio\";\n\n                    snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->sample_rate);\n\n                    break;\n\n                case AVMEDIA_TYPE_VIDEO:\n\n                    type = \"video\";\n\n                    snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height,\n\n                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                avio_printf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\",\n\n                        i, type, st->codec->bit_rate/1000, codec ? codec->name : \"\", parameters);\n\n            }\n\n            avio_printf(pb, \"</table>\\n\");\n\n\n\n        }\n\n        stream = stream->next;\n\n    }\n\n\n\n    /* connection status */\n\n    avio_printf(pb, \"<h2>Connection Status</h2>\\n\");\n\n\n\n    avio_printf(pb, \"Number of connections: %d / %d<br>\\n\",\n\n                 nb_connections, nb_max_connections);\n\n\n\n    avio_printf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\",\n\n                 current_bandwidth, max_bandwidth);\n\n\n\n    avio_printf(pb, \"<table>\\n\");\n\n    avio_printf(pb, \"<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\");\n\n    c1 = first_http_ctx;\n\n    i = 0;\n\n    while (c1 != NULL) {\n\n        int bitrate;\n\n        int j;\n\n\n\n        bitrate = 0;\n\n        if (c1->stream) {\n\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n\n                if (!c1->stream->feed)\n\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n\n                else if (c1->feed_streams[j] >= 0)\n\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n\n            }\n\n        }\n\n\n\n        i++;\n\n        p = inet_ntoa(c1->from_addr.sin_addr);\n\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\",\n\n                    i,\n\n                    c1->stream ? c1->stream->filename : \"\",\n\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n\n                    p,\n\n                    c1->protocol,\n\n                    http_state[c1->state]);\n\n        fmt_bytecount(pb, bitrate);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, c1->data_count);\n\n        avio_printf(pb, \"\\n\");\n\n        c1 = c1->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    /* date */\n\n    ti = time(NULL);\n\n    p = ctime(&ti);\n\n    avio_printf(pb, \"<hr size=1 noshade>Generated at %s\", p);\n\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n\n    c->buffer_ptr = c->pb_buffer;\n\n    c->buffer_end = c->pb_buffer + len;\n\n}\n", "idx": 25265, "substitutes": {"c": ["b", "coll", "context", "dc", "n", "ch", "xc", "sc", "conf", "bc", "ca", "nc", "anc", "ac", "cc", "cp", "cy", "ctx", "r", "mc", "g", "cache", "cv", "l", "v", "h", "ce", "cf", "enc", "con", "icc", "config", "cl", "vc", "cs", "ic", "tc", "cr", "t", "cur", "m", "u", "C", "rc", "cm", "ct", "k", "e", "uc", "d", "f", "pc", "lc", "ec", "cu", "ci", "cd"], "c1": ["lc4", " c3", "c4", "C3", "C2", "C1", "lc3", "lc2", " c4", "lc1", "c3", "C4", " c2", "c2"], "stream": ["port", "loop", "sc", "child", "sem", "ssl", "ream", "hook", "fd", "new", "reader", "request", "zero", "url", "view", "sync", "trans", "thread", "user", "prom", "post", "cur", "coll", "context", "path", "live", "stem", "valid", "sub", "host", "record", "open", "transform", "enc", "pool", "speed", "buffer", "clean", "feed", "event", "each", "client", "forward", "track", "message", "self", "full", "current", "model", "resource", "pe", "src", "draw", "stage", "rss", "channel", "input", "f", "server", "follow", "form", "draft", "engine", "sl", "filter", "source", "progress", "stack", "roll", "control", "ack", "zip", "row", "cook", "steam", "put", "go", "hold", "public", "uc", "round", "object", "load", "content", "sw", "method", "Stream", "pipe", "length"], "p": ["b", "port", "pi", "n", "wp", "cp", "vp", "r", "ps", "fp", "pid", "pre", "m", "t", "P", "pn", "jp", "e", "bp", "pc", "f", "np", "o", "tp", "lp", "pointer"], "ti": ["li", "ita", "icker", "to", "ta", " li", "gt", "bi", "io", "au", " pri", "off", "ao", "ic", "t", "rie", " mi", "ii", "si", " fa", "pc", "ty", "tl", "ci", "fe", "ri", "mi"], "i": ["ai", "li", "pi", "n", "id", " vi", "info", "ip", "is", "l", "v", "h", "t", "I", " ii", "si", "e", "d", "f", "ui", "ci", "ni"], "len": ["bl", "li", "lim", "count", "offset", "fd", "fin", "en", "resp", "l", "la", "rev", "lon", "line", "lf", "lin", "el", "limit", "seq", "val", "lt", "pos", "le", "Len", "length", "ln", "fl", "lang"], "pb": ["buf", "b", "platform", "bm", "pg", "fc", "pl", "plugin", "wp", "parser", "bc", "rob", "bh", "proc", "cp", "summary", "fab", "bb", "vp", "python", "sb", "ctx", "PB", "fb", "prot", "pkg", "rb", "bs", "wb", "cv", "lab", "fp", "bps", "kb", "py", "ppa", "xb", "gb", "tp", "dp", "ab", "buffer", "db", "eb", "jp", "cod", "bot", "bp", "pd", "pc", "lc", "cb", "bf", "lb", "cpp", "uf", "dl", "phrase", "api", "np", "typ", "abc", "pm", "lp", "pa"], "sfilename": ["wsfilename", " sfile", "esfn", "setsstring", "esFilename", "southinline", "lsfilename", "skyusername", "Sfilename", "SFilename", "setsfilename", "dfilename", "sesfile", "dFilename", "ssname", "wsusername", "sutf", "SSourceFile", "ssbinary", " SFilename", "ssfile", " sname", "ffn", "sFilename", " susername", "ansfilename", "southusername", " sbinary", " sfn", "esfile", "wsinline", "Susername", "wsroot", "ssfilename", "sroot", "ssFilename", "susername", "dfile", "ansusername", "southstring", "sbinary", " sstring", "fbinary", "sstring", "vespackage", "lsFilename", "sesname", "ffilename", "sfn", "skyfilename", "dname", "skytitle", " Sname", "vesfilename", "esstring", "lsutf", "sSourceFile", "vesname", "esfilename", "ssfn", "setsusername", "southfn", "sname", "stitle", "sinline", " sFilename", "sesfn", "ssutf", "lsname", "sfile", "espackage", "sesstring", "Sname", " sSourceFile", "sesfilename", "southroot", " stitle", "sesFilename", "skyinline", "skySourceFile", "southfilename", "vesfile", "skyroot", "ansstring", "setsfn", " Sfilename", "sesusername", "ffile", " Sutf", "Stitle", "esusername", " spackage", "ansfn", "spackage", "skyFilename", "esname"], "eosf": ["eosform", "eosif", "eisfo", "eossf", "eaosfc", " eoconfor", "eoconf", "erosfen", "erosl", "eosfm", "eosesv", "eoesfo", "eoidff", "eoosf", "eoesm", "eoosl", "eeosfat", "erosf", "eoosfat", "eoosp", "eaosfp", "eoesn", "eosd", "eoidf", "eeoesf", " eisf", " eaosf", "eeosf", " eiosff", "eoosfe", " eosfor", "eozf", "erosfo", "eoshd", "eaosfw", "eossv", "feoesf", "eiosfor", "eeoosl", "eaosfr", "erosfp", " eosfo", "eosfac", "eeoesm", " eaosfp", "feoesfen", " eosff", "eozv", "neosif", "eoesfat", " eosfr", " eaosfm", " eosp", "eOSfamily", " eosfw", "eoosd", "eoesd", "eoconfw", "eosh", " eiosfe", "eosm", " eoconfw", "eeosd", "eoosfc", "eosesfp", "feosfen", "eoesf", "eiosl", "eisf", "eisd", "eeoosh", "eeoesd", "eoidfp", "eoosfor", "eoosh", " eosfc", "eosesfs", "feosif", "eaosfs", "eosesif", "eiosfull", " eosd", " eoosv", "eosfc", " eoconf", " eaosfs", " eiosfac", "eiosfp", "eosfp", " eosl", "eisfs", "eOsfac", "eeosm", "eiosfw", "eoesfen", "eoesv", "eoshv", "eosfo", "eozfc", "eossfac", "eeoosv", "eOsfe", "eossh", "eosp", "eaosform", "eiosfac", " eisfs", "eosn", "eeosl", "eosfull", "feoesif", "eoesfs", "eaosfor", " eoconfc", "eosfen", "feosf", "eosff", "eaosfm", " eosfac", " eosv", "eaosf", "eosl", "eeosh", "eosfw", "eosesfen", "eoesfac", " eiosfor", " eosform", " eoosfc", "eossl", "eoidl", "eOSif", " eosfp", "eOsfor", "eaosn", "eOSfull", "erosd", "eeosfac", "neiosf", " eosfm", " eoosp", "eoesfc", "eoesfr", "erosif", "eoconfc", "neiosif", "erosfs", "eosesh", "eoesfm", "eosfamily", "eeoosf", "neosfull", "eoesform", "eiosf", "eOSf", "neosf", "eoshf", "neiosfull", "eiosm", "eoconfor", " eoosf", "eosfor", "eosfr", "eoesfp", " eisfo", "eosesl", " eosn", "neosfamily", " eiosf", "eiosif", "eoesl", "eiosfc", "eiosfamily", "eosfs", "eoshfat", "eossm", "eozp", "neiosfamily", "eeoesl", "eosv", "eOsf", "eoesp", " eiosfp", "eosfat", "eosesfm", "eoosv", "feoesfs", "eeoesv", "eiosfe", "eoosfac", " eosfe", "eeoesfat", "eosfe", "eosesf", "eiosff", " eiosl", "eoesif", " eosfs", "eeoesfac", "feosfs", "eeosv", "erosff", " eisd"]}}
{"project": "qemu", "commit_id": "b3be28969b797b27d7f7f806827e9898e4ee08f0", "target": 0, "func": "static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,\n\n                                    bool last_stage,\n\n                                    uint64_t *bytes_transferred)\n\n{\n\n    int pages = -1;\n\n    uint64_t bytes_xmit;\n\n    uint8_t *p;\n\n    int ret;\n\n    RAMBlock *block = pss->block;\n\n    ram_addr_t offset = pss->offset;\n\n\n\n    p = block->host + offset;\n\n\n\n    bytes_xmit = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n", "idx": 25284, "substitutes": {"f": ["b", "fw", "fc", "sf", "n", "rf", "df", "fo", "j", "self", "inf", "tf", "fd", "fs", "info", "r", "g", "cache", "framework", "l", "fp", "v", "fi", "ref", "cf", "m", "fr", "lf", "F", "def", "k", "feed", "this", "file", "e", "elf", "c", "fn", "d", "af", "i", "bf", "fa", "fx", "fen", "fe", "ff", "form", "fb", "buff"], "pss": ["piss", "pts", "css", "cpts", " pds", "apSS", "pds", " pcs", "qsc", "cds", "cts", " psc", "cpss", "pcs", "pSS", "qSS", "psc", "apss", "ciss", " pSS", "Piss", " pts", " prss", "Pds", "Pss", "apsc", "cpds", "aprss", "PSS", "cpcs", "cSS", "qrss", " piss", "ccs", "prss", "qss"], "last_stage": ["last_sent", "last__sent", "next_channel", "next_sent", "laststfinished", "next_stage", "last__channel", "last_channel", "last__stage", "next_finished", "last_finished", "laststsent", "last__finished", "lastststage", "laststchannel"], "bytes_transferred": ["bytes_compidered", "bytes_xferred", "bytes_xlated", "bytes_transported", "bytes_peraved", "bytes_compferred", "bytes_transmitted", "bytes_compmitted", "bytes_xfixed", "bytes_suppped", "bytes_compaved", "bytes_transmit", "bytes_rexmitted", "bytes_transidered", "bytes_remitted", "bytes_interferred", "bytes_formped", "bytes_xcluded", "bytes_transcluded", "bytes_waferred", "bytes_transverted", "bytes_suppaved", "bytes_suppferred", "bytes_interverted", "bytes_premit", "bytes_reaved", "bytes_suppmitted", "bytes_preformed", "bytes_waverted", "bytes_transaved", "bytes_perverted", "bytes_transformed", "bytes_permit", "bytes_xported", "bytes_xformed", "bytes_intermitted", "bytes_preferred", "bytes_complated", "bytes_translated", "bytes_xped", "bytes_transfixed", "bytes_xaved", "bytes_premitted", "bytes_rexidered", "bytes_reformed", "bytes_formmitted", "bytes_remit", "bytes_perlated", "bytes_reported", "bytes_intermit", "bytes_wamitted", "bytes_referred", "bytes_rexcluded", "bytes_rexferred", "bytes_suppfixed", "bytes_xidered", "bytes_formfixed", "bytes_perferred", "bytes_compcluded", "bytes_permitted", "bytes_formferred", "bytes_xmitted", "bytes_transped", "bytes_wamit", "bytes_suppported"], "bytes_xmit": ["bytes_rxit", "bytes_xit", "bytes_pervert", "bytesOxmission", "bytes_xfmit", "bytes_exMIT", "bytes_transmitted", "bytes_overmit", "bytesOxmit", "bytes_nexcat", "bytes_whmt", "bytes_transfer", "bytes_xMIT", "bytes_transmit", "bytes___xmit", "bytes_fxMIT", "bytes_whmission", "bytes_xmont", "bytes_xmission", "bytes_xfvis", "bytes_transmission", "bytes_exmit", "bytes_interfer", "bytes_nexmission", "bytes_xxmission", "bytes_axmit", "bytes_overmon", "bytes_xfer", "bytes_xdpire", "bytes_xlate", "bytes___xcat", "bytes_ixmiss", "bytes_permission", "bytes_xvert", "bytes_xfmt", "bytes_xfpire", "bytes_xmt", "bytes_nexpire", "bytes_andmits", "bytes_transmon", "bytes_exit", "bytes_fxmiss", "bytes_xdmit", "bytes_wmits", "bytes_andmit", "bytes_andmitt", "bytes_widemitted", "bytes___nexpire", "bytes_axmitt", "bytes_xdmitted", "bytes_axit", "bytes_exmitter", "bytes_Xmission", "bytesOxmt", "bytes_xmitt", "bytes_axmits", "bytes_overfer", "bytes_exmitt", "bytes_Xvert", "bytes_exmits", "bytes_ixmit", "bytes_ixmitter", "bytes_xmiss", "bytesOxfvis", "bytes_wmission", "bytes_nexmit", "bytes_xxmt", "bytes_permit", "bytesOxvis", "bytes_Xpire", "bytes_overmiss", "bytes_rxmit", "bytes_widemit", "bytes_rxMIT", "bytes_whmit", "bytes_xcat", "bytes_transvert", "bytes_overmitter", "bytes_widepire", "bytes___xmission", "bytes_exmission", "bytes_intermont", "bytesOxfmit", "bytes___xpire", "bytes_xxmit", "bytes_andit", "bytesOxfmt", "bytes_transmont", "bytes_xpire", "bytes_xfcat", "bytes_intermit", "bytes___nexmit", "bytes_xxmits", "bytes_xvis", "bytes_overit", "bytes_exmiss", "bytes_rxmiss", "bytesOxfmission", "bytes___nexcat", "bytes_fxit", "bytes_Xmitted", "bytes_xfmission", "bytes_Xlate", "bytes_xmitter", "bytes_xmits", "bytes_wmt", "bytes_exmt", "bytes_permitted", "bytes_wvis", "bytes_fxmit", "bytes___nexmission", "bytes_xmitted", "bytes_wmit", "bytes_overmont", "bytes_ixit", "bytes_whvis", "bytes_intermon", "bytes_xdlate", "bytes_widelate", "bytes_Xmit", "bytes_xmon"], "p": ["b", "port", "pb", "pi", "n", "wp", "path", "parent", "base", "j", "cp", "sp", "patch", "ip", "cache", "up", "op", "pp", "ps", "params", "l", "fp", "h", "v", "pre", "post", "m", "ap", "t", "P", "u", "page", "per", "jp", "e", "c", "point", "bp", "padding", "pc", "i", "d", "data", "api", "q", "np", "pos", "o", "tp", "lp", "pointer", "at", "offset"], "ret": ["ext", "reply", "RET", "progress", "req", "full", "len", " RET", "nt", "cache", "result", "alt", "resp", "iter", "job", "mem", "det", "url", "ref", "conn", "rev", "rets", "arr", "rl", "def", "page", "rc", "fun", "att", "feat", "rt", " Ret", "lit", "val", "rep", "cat", "Ret", "reg", " result", "res", "art", "flag", "en", "success", "re", "post"], "block": ["bl", "box", "run", "bc", "byte", "header", "cache", "type", "ref", "frame", "lock", "line", "address", "page", "device", "k", "view", "sync", "clock", "name", "fb", "network", "un", "parent", "info", "flow", "field", "record", "open", "job", "check", "off", "pool", "pre", "cl", "prefix", "buffer", "node", "bin", "offset", "plugin", "error", "full", "group", "session", "label", "queue", "channel", "unit", "wall", "def", "F", "exec", "blocking", "base", "ack", "chain", "row", "r", "layout", "ip", "Block", "image", "number", "work", "panel", "io", "part", "range", "batch", "initial", "tx", "link", "object", "pos", "section"], "acct_info": ["acct_error", "acct_init", "acst_cache", "acst_INFO", "acct_state", "acc_error", "acc_info", "acct_cache", "acct_def", "acc_init", "accent_info", "acctallinit", "accent_state", "acct_INFO", "accent_def", "accent_error", "acst_info", "acctallstate", "acc_manager", "acctalldef", "acct_manager", "acctallerror", "acctallmanager", "acst_error", "acctallinfo"], "norm_pages": ["normedmaps", "norm_images", "norm_projects", "normal_images", "normal_maps", "normedimages", "norm_cats", "normal_cats", "norm_maps", "normal_pages", "norm_page", "normedpage", "normal_projects", "normal_page", "normedpages"], "dup_pages": ["duping_page", "duping_cells", "duping_pages", "dup_cells", "dup_page", "duping_sites", "dup_sites"]}}
{"project": "qemu", "commit_id": "554b614765090f47d97a20ca6981e17e96515ec1", "target": 0, "func": "void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n\n                      bool has_base, const char *base,\n\n                      bool has_backing_file, const char *backing_file,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_error, BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 25310, "substitutes": {"has_job_id": ["has_jobbookcheck", "has_block_ids", "has_jobbookids", "has_job_check", "has_jobs_error", "has_jobs_id", "has_jobbookinfo", "has_job00id", "has_job00ids", "has_job_file", "has_block_info", "has_jobs_ids", "has_jobingids", "has_job_error", "has_block_id", "has_job_info", "has_job00error", "has_job_ids", "has_jobingid", "has_jobingerror", "has_jobbookid", "has_block_check", "has_jobs_file", "has_jobingfile", "has_job00file"], "job_id": [" job_number", "job_ids", " job_sid", "job_name", " job_ids", " job_name", " job_index", "job_sid", "job_number", "job_index"], "device": ["network", "plugin", "port", "disk", "remote", "vm", "driver", "mode", "connection", "task", "host", "feature", "image", "ip", "model", "Device", "serial", "controller", "root", "mobile", "service", "dev", "di", "devices", "address", "android", "unit", "machine", "buffer", "directory", "node", "block", "module", "component", "layer", "mount", "server", "user"], "has_base": ["have_base", "had_base", "hasetsource", "hasEbase", "has_source", "hasetbase", "has_db", "has__file", "have_support", "had_source", "have_fixed", "hasEfixed", "has_b", "hasetdb", "has_file", "has__fixed", "hasEfile", "has__support", "had_db", "has_support", "have_file", "has__base", "hasEsupport", "had_b", "has_fixed", "hasetb"], "base": ["site", "b", "key", "parent", "home", "id", "http", "source", "based", "body", "image", "position", "model", "common", "type", "cache", "fake", "bi", "root", "resource", "url", "part", "version", "area", "change", "p", "core", "address", "unit", "Base", "profile", "prefix", "ase", "buffer", "bas", "db", "family", "file", "block", "bot", "stable", "i", "kit", "layer", "data", "server", "back", "bare", "client", "name", "support"], "has_backing_file": ["has_backing2files", "has_backingablefile", "has_backacking_filename", "has_backingablename", "has_backing_files", "has_backingablefiles", "has_backning_filename", "has_backging_files", "has_backacking_file", "has_backning_image", "has_backing_name", "has_backging_file", "has_backning_files", "has_backning_file", "has_backing2filename", "has_backging_path", "has_backingablepath", "has_backging_name", "has_backing_filename", "has_backacking_files", "has_backing2file", "has_backing_path", "has_backing_image", "has_backing2name", "has_backacking_name"], "backing_file": ["backding_path", "backing_image", "backing___files", "backding___file", "backding_files", "backing___url", "backing___file", "backging_files", "backing_path", "backding_file", "backing_uri", "backingfilefiles", "backding___url", "backingfilepath", "backingfilefile", "backing_files", "backingfileurl", "backing_url", "backding___path", "backging_image", "backging_uri", "backding_url", "backing___path", "backding___files", "backging_file"], "has_speed": ["hasOrate", "has__grade", "has_rate", " has_grade", "hasOspeed", "has__speed", "hasOgrade", "has__rate", "has_grade", " has_rate", "has__weight", "has_weight", " has_weight"], "speed": ["index", "engine", "wash", "ips", "weight", "status", "frequency", "rank", "error", "ride", "score", "reshold", "count", "progress", "stop", "ributes", "peed", "ensor", "fps", "size", "number", "duration", "rate", "percent", "race", "stream", "config", "power", "sort", "performance", "sm", "lock", "screen", "read", "scale", "gain", "sync", "param", "start", "mark", "delay", "Speed", "grade", "shock", "name", "length", "strength"], "has_on_error": ["has_off_error", "has_ononerr", "has_off_comment", "has_off_err", "has_on_complete", "has_off_progress", "has_on_err", "has_off_complete", "has_ononprogress", "has_ononerror", "has_on_progress", "has_ononcomment", "has_on_comment"], "on_error": [" on_success", "on67success", "onfsuccess", "on_errors", "onfmode", "on_warning", "on67error", "onferr", "on_success", "onfwarning", " on_status", " on_warning", "on67ror", "on67status", " on_err", " on_mode", "on_mode", "onalerrors", "onferror", "onalerr", "onalerror", "onfror", "on_status", " on_ror", "on_ror", "on_err", "onalwarning", "onfstatus", " on_errors"], "errp": [" errpi", "serpr", "acepi", "err", " errP", "ferP", " errpre", "ferp", " errfp", "acer", "acefp", "errpr", "acep", "aerpr", "serp", " errpc", "erpre", "yrpr", "errsp", "erpr", "errfp", "erp", "ferr", "rrr", "errorp", "errorpc", "rrp", "errpre", "ferpr", "errpi", "erfp", "yrp", "aerp", "erpc", " errr", "errP", "serpc", "errpc", "yrpc", "errorr", "aerr", "errr", " errpr", "aerpc", "erpi", "sersp", "rrP", "rrpre", " errsp", "yrsp", "erP"], "bs": ["js", "b", "banks", "bl", "pb", "css", "vs", "bc", "blocks", "state", "gs", "bh", "bits", "os", "rs", "bb", "ubs", "bytes", "sb", "ctx", "bid", "bos", "ops", "fs", "ba", "obs", "ps", "br", "bi", "bps", "bing", "hub", "las", "src", "ins", "gb", "core", "cs", "s", "iss", "obj", "bas", "ns", "db", "bes", "BS", "eb", "block", "bot", "sync", "ss", "lc", "ls", "cb", "lb", "ds", "ses", "ob", "bis", "fb"], "base_bs": ["bare_bs", "bas_fs", " base_bal", "base_ns", "basexbal", "basexref", "bas_bas", "bas_ns", "base6bas", "base_bas", " base_bc", " base_js", "base_bytes", "base_gb", "base67bs", "bas_bs", "bare_gb", "bare_css", "base64sync", " base_ref", "base64name", "base_bal", "base_fs", "base_ref", "base_js", " base_bytes", "base_css", "base_sync", " base_bas", "basexbs", " base_iss", "base6bs", "baseCname", "base6bal", "bare_fs", "base_bc", "base67iss", "base64fs", "base6ref", " base_fs", "baseCbs", "base67js", "basexbas", "base_iss", "baseCfs", " base_sync", "baseCsync", "base67bytes", "base64bs"], "aio_context": ["aios_support", "aio_scope", "aio_ctx", "aiogsupport", "aIO_config", "aiogcontext", "aIO_context", "aios_scope", "aio_cache", "aios_ctx", "aio_support", "aios_context", "aIO_ctx", "aiogctx", "aio_config", "aios_control", "aios_cache", "aio_control", "aios_loc", "aioamconfig", "aio_loc", "aios_config", "aioamcontext", "aiogcontrol", "aioamloc", "aioamctx"], "local_err": ["localmmerr", "local__error", "local_call", "local_req", "localayerr", "localayerror", "global_error", "local_rr", "internal_call", "localamerror", "localayexc", "localmmerror", " local_error", "local__err", "localayer", "local_exc", "localamcall", "global_exc", "internal_error", "global_err", "local_er", "local_error", "internal_req", "global_req", "local__rr", "localamerr", "local__dev", " local_dev", "global_er", "localamreq", "internal_err", "localmmrr", " local_rr", "localmmdev", "local_dev"], "base_name": ["job_size", "based8named", "job_name", "basexname", "basexsize", " base_size", "baseCsize", " base_names", "base__size", "base8name", " base_id", "baseCbase", "base_size", "base_file", "job_prefix", "based8name", "base__file", "based_name", "based_Name", "base__id", "base5named", "base_prefix", "base_line", "base_Name", "base_id", "baseCname", " base_base", "base2size", "based_line", "baseCnames", "based_size", "basexnames", "job_names", "base_named", "base8named", "base2Name", "base5line", "base5names", "based8line", " base_file", "based_names", "basexprefix", "base8line", "base2named", "based8names", "base5name", "based_named", "base8names", "base_names", "base_base", "base2name", "base__name"]}}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n\n                           AVDXVAContext *ctx,\n\n                           DECODER_BUFFER_DESC *dsc,\n\n                           unsigned type, const void *data, unsigned size,\n\n                           unsigned mb_count)\n\n{\n\n    void     *dxva_data;\n\n    unsigned dxva_size;\n\n    int      result;\n\n    HRESULT hr;\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,\n\n                                                 D3D11VA_CONTEXT(ctx)->decoder,\n\n                                                 type,\n\n                                                 &dxva_size, &dxva_data);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,\n\n                                            &dxva_data, &dxva_size);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",\n\n               type, hr);\n\n        return -1;\n\n    }\n\n    if (size <= dxva_size) {\n\n        memcpy(dxva_data, data, size);\n\n\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n\n            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n\n            memset(dsc11, 0, sizeof(*dsc11));\n\n            dsc11->BufferType           = type;\n\n            dsc11->DataSize             = size;\n\n            dsc11->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n\n            DXVA2_DecodeBufferDesc *dsc2 = dsc;\n\n            memset(dsc2, 0, sizeof(*dsc2));\n\n            dsc2->CompressedBufferType = type;\n\n            dsc2->DataSize             = size;\n\n            dsc2->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n\n\n        result = 0;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);\n\n        result = -1;\n\n    }\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to release buffer type %u: 0x%x\\n\",\n\n               type, hr);\n\n        result = -1;\n\n    }\n\n    return result;\n\n}\n", "idx": 25344, "substitutes": {"avctx": ["svconfig", "navctx", "vercontext", "afcmd", "aveconfig", "avecontext", "afcontext", "avpc", "avcv", "abcontext", "evcontext", "navcmd", "evconn", "abconfig", "navpc", "svctx", "afctx", "avecv", "avconn", "navcmp", "verconfig", "afcmp", "evconfig", "avcontext", "svctl", "AVcmp", "svcontext", "verctx", "abconn", "devctx", "devcontext", "AVctl", "AVcontext", "navcontext", "avcmd", "devconfig", "AVcmd", "AVcv", "abctx", "verconn", "AVconn", "devctl", "verpc", "navconn", "AVpc", "evctx", "avctl", "AVconfig", "abcv", "avectx", "avcmp", "avconfig", "AVctx"], "ctx": ["context", "sci", "sc", "bc", "cmp", "ca", "anc", "voc", "cp", "req", "lib", "hw", "qq", "crit", "cus", "nt", "pkg", "ocr", "storage", "cv", "cas", "kw", "fp", "conn", "cf", "hub", "src", "Context", "config", "cam", "cl", "vc", "kt", "grad", "conv", "tc", "cn", "cmd", "rc", "mac", "tx", "ctrl", "cca", "txt", "loc", "exec", "c", "lc", "cli", "component", "sq", "cu", "qa", "client", "kb", "concept", "ga"], "dsc": ["jisc", "gsp", "Dsp", "bsp", "pSC", "fsp", "gsc", "dsp", " dsp", "dbc", "bsc", "prc", "drc", "gisc", "fesc", "lesc", "psc", "Dbc", " dSC", " drc", "fbc", " dbc", "besc", "bbc", "pesc", "fsc", "desc", "jsp", " desc", "gbc", "jsc", "Dsc", "lrc", "lsc", "lSC", "dSC", "Disc", "jbc", "disc"], "type": ["port", "key", "parent", "error", "value", "id", "rule", "shape", "http", "format", "test", "ype", "none", "info", "op", "ip", "model", "field", "attr", "root", "y", "url", "slice", "pe", "part", "style", "role", "version", "pre", "sort", "p", "t", "address", "unit", "table", "attribute", "buffer", "TYPE", "handler", "ity", "time", "kind", "block", "like", "types", "length", "typ", "event", "method", "client", "name", "class", "ping", "ty", "Type"], "data": ["buf", "alpha", "value", "da", "byte", "source", "message", "body", "bytes", "response", "none", "DATA", "binary", "window", "image", "cache", "reader", "raw", "zero", "inner", "batch", "draw", "one", "Data", "buffer", "input", "missing", "sample", "media", "block", "d", "start", "next", "content", "ui", "memory", "dat", "a"], "size": ["weight", "ize", "status", "ny", "sum", "mode", "shape", "filename", "source", "timeout", "len", "fee", "g", "storage", "cache", "number", "max", " sizes", "hh", "slice", "style", "large", "empty", "SIZE", "code", "speed", "password", "address", "unit", "capacity", "scale", "si", "time", "small", "loc", "c", "sec", "sized", "content", "sn", "Size", "esc", "use", "name", "length", "offset"], "mb_count": ["byte_len", "mbcountth", "byte_th", "mb2th", "mb8len", "MB_len", "mbcountsize", "mb2size", "MB_count", "mb_size", "byte_size", "MB_size", "mbcountlen", "byte_count", "mbcountcount", "mb2len", "mb8size", "mb_len", "mb_th", "mb8count", "mb2count"], "dxva_data": ["dxva_Data", "dxva_buf", "dxena_content", "dxva67ui", "dxva_memory", "dxva_buffer", "dxaa_buf", "dxva1dat", "dxaa_last", "dxena_data", "dxvas67media", "dxva_last", "dxvas67uri", "dxva1content", "dxva6uri", "dxva1data", "dxva_ui", "dxva1uri", "dxva6dat", "dxvas_data", "dxena6content", "dxva_dat", "dxsa_data", "dxsa_size", "dxvas_uri", "dxvas67data", "dxena6uri", "dxva6content", "dxaa_Data", "dxva2buf", "dxva67media", "dxena_dat", "dxsa_memory", "dxva67uri", "dxaa_data", "dxvas67ui", "dxena_uri", "dxena6dat", "dxva_content", "dxva6data", "dxva_media", "dxva2last", "dxvas_media", "dxena6data", "dxva_uri", "dxva2data", "dxva67data", "dxvas_ui", "dxva2Data", "dxsa_buffer"], "dxva_size": ["dxvo_loc", "dxha_size", "dxva_sum", "dxva_loc", "dxha_data", "dxva_sized", "dxvo_stream", "dxha_sized", "dxva_width", "dxva_count", "dxvo_length", "dxvo_desc", "dxvo_width", "dxva_name", "dxvo_size", "dxha_name", "dxvo_count", "dxva_stream", "dxvo_sum", "dxva_length", "dxvo_name", "dxva_desc"], "result": ["Result", " cr", " res", "sr", "results", " rs", "rx", "ret", "err", "rs", " rc", "response", " r", "dr", "resp", " ret", "src", "mr", " success", "rl", "rh", " thr", " sr", " results", "res", "HR"], "hr": ["worker", "sr", "DR", "rx", " HR", "gr", "ih", "err", "id", "lr", "bh", "rs", "WR", "req", "er", "MR", "resh", "ctr", "rd", "header", "pull", "rid", "r", "RS", "hl", "br", "dr", "work", "yr", "h", "hour", "rg", "hh", "src", "mr", "rw", "p", "arr", "fr", "cr", "rh", "callback", "wr", "rc", "shr", "e", "ha", "c", "hn", "ec", "kr", "uh", "img", "str", "rr", "pr", "nr", "ir", "HR"], "dsc11": [" desc1", "drc11", "desc10", "drc101", "dSC10", " desc14", "dbc11", "desc12", " dsc13", "dbc10", "desc14", "desc100", "drc14", "Dsc31", "Dsc13", "dc31", "drc13", "dosc12", " dsc31", "desc11", " dsc100", "dsc12", "dsc31", " desc101", "dSC12", " dsc12", "dbc101", "drc1", " desc11", "dSC100", "Drc14", " dsc14", "desc101", "desc1", "Drc11", "dc11", "Dsc14", " dsc101", "dSC13", "drc31", "dSC14", " desc31", " desc13", "dsc1", "dbc14", "dsc100", "dosc11", "dSC11", "dosc100", "Dsc101", "desc13", "Drc101", " dsc1", "dsc10", "dsc14", "Drc13", "dc14", " dsc10", " desc12", "dsc13", "drc10", " desc100", "dbc13", "Drc31", "Dsc11", "dsc101", "dSC101", "dc1", " desc10", "desc31", "dosc13"], "dsc2": [" dbc22", "Drc4", "dscTwo", " dsc3", "Dsc4", "dbc4", "desc2", "descTwo", "dbc2", " dsc4", "desc4", "desc02", "duc1", "drc02", "desc3", " dsc02", "desc22", "dbc3", " dbcTwo", "duc02", "dasc2", "dsc3", " dbc3", "drc4", "dsc1", "dSC1", "dbc22", "dcr02", " dbc1", "Dsc1", "dcrTwo", "Dsc02", "Drc1", "drcTwo", " dbc4", "dcr1", "dSC22", "drc1", " drcTwo", "duc2", "Dsc2", "dasc3", "dsc22", " drc2", "dSC2", "dascTwo", "desc1", "dcr2", " drc02", "dasc4", " dbc2", "drc2", " dsc1", "dsc02", "dbc02", "dSC4", " drc1", "dsc4", " dsc22", "Drc02", "duc4", "Drc2", "dbcTwo", " dscTwo", "dbc1"]}}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353, "substitutes": {"saddr": ["phost", "svadr", "symenv", "padr", "sadd", "servicesaddress", "fattr", "wsptr", "sslhost", "servicesprot", "dshost", " sadr", "sptr", "symaddr", " sptr", "fenv", "faddr", "sadr", "taddress", "southaddress", "nsadr", "svadd", "fadr", " sconfig", "saddress", "southaddr", "paddr", "wsvr", "symattr", "shop", "naddress", "sprot", " svr", "svvr", "svaddress", "nsaddr", "seshop", "shipaddr", " shop", "ssladr", "dslayer", "nconfig", " sadd", " sord", "servicelayer", "shipaddress", "svr", "svord", "dsptr", "svaddr", " salign", " slayer", "dsaddr", "dsaddress", "sattr", "tlayer", "sesaddr", "sord", "tconfig", "sconfig", "shipprot", "servicehop", "southattr", "ford", "faddress", " shost", "southenv", " sprot", "shipalign", "senv", "serviceaddr", " saddress", "wsaddr", "wsaddress", "servicesaddr", "seslayer", "shost", "nsaddress", "sesaddress", "servicesalign", "nshost", "svhost", "slayer", "naddr", "serviceaddress", "nslayer", "nlayer", "symaddress", "salign", "ssladdress", "dsvr", "paddress", "pvr", "taddr", "ssladdr"], "port_offset": ["ort_bound", "port67off", "port_off", "port___offset", "port_limit", "connection_limit", "port_padding", "port_optional", "ort_len", "port_default", "ort_offset", "connection_padding", "port___alt", "connection_optional", "port_range", "connection_offset", "port_bound", "ort_off", "port_ext", "port67offset", "ort_ext", "port___off", "Port_default", "port_auto", "portlenoff", "port_alt", "ort_alt", "portlendefault", "Port_range", "portlenoffset", "portlenrange", "port67ext", "port___ext", "Port_offset", "Port_off", "port67alt", "port_len", "ort_auto"], "update_addr": ["update64orig", "updateIforig", " changeFptr", "update_orig", "updateIfaddr", " change_orig", " changeForig", " changeFmac", "update64addr", "updateFmac", "updateFaddr", "update_ptr", " change_mac", " changeFaddr", "updateIfptr", "updateForig", "updateIfmac", "update_mac", "update64ptr", "update64mac", " change_ptr", "updateFptr", " change_addr"], "errp": [" errpi", "arrr", " erb", " errb", "errf", " erf", " errP", "grfp", "grf", " errpre", "errorc", " errfp", " erp", "erk", "errb", "rrb", "arrk", " erpe", "grc", " errpc", "errc", "erpre", "errorfp", "errorpre", "errfp", "rrf", "erf", "erp", "erb", " errc", "rrr", "errorp", "errorpc", "errpi", "errpre", "rrp", "erfp", "rrfp", "erpc", "errP", " errr", "errorf", "rrpe", "errorP", "errpc", " errpe", "errpe", "grp", "errr", " erc", " erpi", "arrp", "erpi", "arrf", "errk", "rrc", " errk", " errf", "erP"], "ai": ["issue", "ca", "ac", "asi", "ia", "aii", "ti", "ini", "address", "si", "na", "ha", "agi", "eni", "aaa", "iri", "ami", "ci", "umi", "ni", "a", "mi", "air", "aim", "ra", "aa", "AU", "abi", "sub", "ait", "iat", "info", " bi", "conn", "qi", "ee", "oci", "access", "iam", "pc", "af", "api", "fa", "ay", "ui", "qa", "ga", "iana", "ana", " AI", "net", "AI", "aud", "attr", "ae", "sa", "fi", "uri", "config", "mac", "pai", "ann", "aci", "afi", "pi", "gui", "bi", "au", "acc", "man", " mi", "an", "ais", "ani", "ig", "i", "ru", "hai", "auth", "pa"], "res": ["rec", "Res", "results", "rx", "gr", "ret", "rs", "rem", "req", "os", "response", "ack", "pres", "ros", "r", "result", "resp", "conn", "rev", "ras", "mr", "arr", "ress", "rss", "rh", "ex", "ru", "rr", "ris", "reg", "rar", "ry", "re"], "e": ["E", "eu", "debug", "ace", "rs", "er", "ir", "end", "r", "ei", "ae", "resp", "es", "enc", "ee", "exc", "ev", "ef", "c", "ea", "ec", "ep", "event", "fe", "esc", "en", "re"], "port": ["entry", "allow", "rule", "direction", "PORT", "header", "patch", "type", "request", "url", "core", "json", "address", "match", "username", "socket", "page", "table", "comment", "serv", "name", "post", "path", "parent", "nat", "format", "phone", "cp", "text", "end", "connection", "fat", "host", "pid", "Port", "service", "pre", "mail", "ports", "feed", "point", "pt", "api", "opt", "ORT", "pointer", "offset", "value", "proxy", "project", "message", "interface", "timeout", "test", "ort", "ptr", "token", "option", "position", "resource", "slice", "uri", "null", "config", "queue", "code", "rest", "password", "route", "m", "channel", "bug", "mac", "hop", "target", "export", "data", "term", "mount", "server", "form", "date", "contract", "report", "body", "zip", "ip", "number", "duration", "part", "stream", "version", "select", "file", "component", "object", "phrase", "pos", "pr", "method", "pad", "length"], "uaddr": [" uptr", "_host", "uuaddress", "uhost", "_addr", "uptr", "uuaddr", "uuptr", "_ptr", " uaddress", "uaddress", " uhost", "_address", "uuhost"], "uport": ["uconfig", "Uport", "urports", "ushost", "urhost", "uhost", "usports", "Uconfig", "usport", "uports", "urconfig", "urport", "usconfig", "Uports", "Uhost"], "slisten": ["sliston", "nslistenc", "nsnamenc", "slistener", "sdefen", "nsnamen", "nsnamener", "sdefon", "snamon", "nslistener", "snamener", "nsnamon", "sdefenc", "nslisten", "snamenc", "slistenc", "snamen", "sdefener", "nsliston"], "rc": ["dc", "sr", "sc", "bc", "id", "ac", "rs", "g", "result", "rh", "rr", "co", "cur", "num", "rx", "xc", "reply", "nc", "cc", "rb", "add", " RC", "rg", "parse", "irc", "ok", "c", "pc", "_", "fc", "error", "ck", "ror", "src", "ras", "rn", "rl", "rt", "ec", "back", "abc", "RC", "rec", "anc", "ack", "r", "auc", "roc", "oc", "vc", "loc", "uc", "d", "cb", "success"], "port_min": ["port64min", "port_limit", "port_range", "port64max", "port64limit", " port_range", " port_limit", "port64range"], "port_max": ["portflimit", "port_limit", "portfmin", "port_diff", " port_diff", "portfdiff", " port_limit", "portfmax"], "p": ["pb", "pi", "a", "proc", "cp", "r", "patch", "ip", "op", "pp", "ps", "fp", "pid", "dp", "P", "po", "jp", "c", "param", "pc", "i", "q", "pos", "pat", "tp", "ping"], "err": ["gz", "errors", "rx", "error", "gr", "erg", " error", "lr", "acer", "der", "rs", "er", "req", "ise", "ace", " er", "ait", "Error", "fee", "r", "fy", "Er", "here", "result", "dr", "resp", "iter", "oe", "cer", "fi", "mr", "rage", "rev", "arr", "ee", "exc", "cr", "rh", "rss", "eor", "ler", "ev", "fr", "ar", "bug", "tx", "rag", "aster", "doc", "rm", "ind", "ec", "aaa", "kr", "cb", "rr", "pr", "rar", "runner", "order", "ir", "sys"], "baseport": ["Baseport", "basep", "sitestate", "ancect", " baseland", " basemin", "basestate", "Basect", "basect", "bidestate", "baseename", " basetime", " basety", "Basep", "bidename", "Basemin", "siteport", "basetime", "Basety", "Baseland", "baseetime", " basect", "baseety", "baseemin", "basety", "Basetime", "ancename", "Basename", "siteto", " basep", "anceland", "baseland", "sitename", "baseep", "baseeport", " basestate", "anceport", "basemin", "bideport", " baseto", "basename", "baseto", "bideto", " basename"]}}
{"project": "FFmpeg", "commit_id": "a7f27453f64d9020b92b01687baeb5909c6cdad0", "target": 0, "func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;\n\n    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n\n        codec->codec_id == AV_CODEC_ID_H264 &&\n\n        atom.size > 11) {\n\n        avio_skip(pb, 10);\n\n        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n\n        if (avio_rb16(pb) == 0xd4d)\n\n            codec->width = 1440;\n\n        return 0;\n\n    }\n\n\n\n    return mov_read_avid(c, pb, atom);\n\n}\n", "idx": 25357, "substitutes": {"c": ["b", "coll", "fc", "dc", "ch", "xc", "sc", "bc", "cmp", "ca", "nc", "ac", "cc", "cp", "cy", "ctx", "cus", "mc", "cv", "l", "conn", "ce", "cf", "con", "icc", "config", "cl", "vc", "p", "oc", "core", "cs", "m", "cr", "tc", "cn", "cur", "C", "cm", "ctrl", "ct", "jc", "e", "uc", "ec", "pc", "lc", "f", "cb", "co", "ci", "abc", "cd"], "pb": ["b", "platform", "bm", "pg", "fc", "pl", "mp", "abb", "bc", "cmp", "rob", "bh", "cp", "fab", "bb", "ctx", "sb", "PB", "fb", "rb", "wb", "fp", "bps", "ib", "ppa", "p", "xb", "gb", "tmp", "tc", "ab", "dp", "eb", "db", "jp", "uc", "bot", "bp", "pc", "cb", "lb", "cpp", "typ", "api", "pm", "lp", "pa"], "atom": ["prop", "num", "parent", "com", "tm", "orbit", "ac", "abi", "fab", "orb", "bb", "tag", "mom", "canon", "emb", " Atom", "op", "image", "chem", "material", "type", "cell", "attr", "ator", "article", "asm", "item", "tom", "mag", "instance", "config", "atomic", "app", "container", "tmp", "m", "tc", "om", "chrom", "ab", "obj", "operator", "cm", "hop", "amp", "node", "param", "spec", "component", "object", "data", "typ", "term", "xml", "temp", "at"], "codec": ["copenc", "pedec", "Codac", "pedbc", "compEC", "comproc", "pedenc", "codac", "codbc", "equoc", "equenc", "odroc", "odec", "odEC", "odbc", "Codoc", "equec", "compec", "codEC", "coduc", "CodEC", "Codex", "Codef", "Codenc", "odac", "odex", " codesc", "codeEC", "pedef", "odenc", "copesc", "compex", " codEC", "copuc", "codroc", "codenc", "codeec", "Codroc", "codeoc", "codex", "odoc", "codesc", "oduc", "peduc", "codoc", "pedac", " codoc", "odesc", "copec", "equEC", "Codec", "odef", "Codbc", "codeesc", "codef", "pedesc"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370, "substitutes": {"vmsd": [" vmmd", "vmesD", "vimsds", " vmmds", "vmsdh", "vemsd", "vmesds", " vmmdl", " vksd", "vmesd", "vksD", "varesdc", " vksD", "vemsdm", "vmasd", "vmmhd", "vmmd", "vimsdl", " vmsds", "hmsdh", "hmesd", " vmshd", "hmesds", "vmasds", " vmsD", " vmmhd", " vksdc", "vssd", "vmmdl", " vmsdl", "vmsds", "vmesdh", "vemsds", "vmesdc", "vmsdl", "vemsdh", "vksd", " vksdy", "vimshd", "vmsdm", "hmesdm", "vssdl", "vmsdc", "vksdc", "varesd", "vimsd", "vmshd", "vmesdy", "vmsdy", "varesdy", "vmesdm", "vmasdh", "varesD", "vksdy", "vmmds", "hmsd", "hmesdh", " vmsdc", "vsshd", "hmsdm", "hmsds", " vmsdy", "vssds", "vmasdm", "vmsD"], "opaque": ["opusacity", "oaque", "opusaques", "oifice", "Opaque", "octaque", "oacity", "operga", "Opga", " opaques", "Opacity", "opifice", "Opaques", " opity", "opga", " opacity", " opifice", "copacity", "operacity", "opusity", "octga", "operaques", "copity", "operifice", "operity", "opusaque", "octacity", "opacity", "octaques", "opity", "copaques", "opaques", "operaque", "oity", "copaque"], "se": ["ke", "sl", "ie", "entry", "sle", "ve", "sem", "lex", "sh", "sel", "sp", "ne", "cle", "session", "ae", "es", "sa", "ce", "pe", "be", "sk", "service", "see", "parse", "sed", "sche", "inse", "ee", "ze", "s", "ser", "ge", "sea", "de", "isse", "ase", "asse", "su", "si", "pse", "e", "Se", "sec", "serv", "SE", "le", "te", "so", "ade", "ses"], "new_se": [" new_SE", "current_sea", "new_sea", " new_parse", "current_parse", "new_SE", "new_sem", " new_sem", "current_sche", "new_sche", "new_parse", "current_se"]}}
{"project": "qemu", "commit_id": "edc243851279e3393000b28b6b69454cae1190ef", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382, "substitutes": {"n": ["network", "b", "num", "adj", "in", "un", "nb", "z", "j", "mn", "N", "net", "inn", "zn", "tun", "nor", "non", "none", "ne", "nv", "nt", "g", "bn", "syn", "gn", "nic", "dn", "l", "new", "h", "conn", "on", "p", "rn", "m", "t", "cn", "nov", "nn", "u", "pn", "ns", "not", "na", "node", "an", "c", "fn", "d", "nu", "f", "i", "min", "sn", "np", "nm", "cdn", "ni", "nd", "en", "ln"], "cmd": ["dc", "Cmd", "comm", "path", "mode", "cmp", "id", "dll", "cc", "cp", "req", "text", "col", "qq", "ctr", "ctx", "ctl", "nt", "pkg", "gn", "command", "conn", "cf", "src", "config", "cl", "code", "grad", "act", "mac", "cfg", "md", "init", "ctrl", "ct", "acl", "node", "cod", "seq", "c", "gen", "msg", "cb", "cli", "bind", "method", "client", "opt", "name", "cd"], "iov": ["obo", "nih", "ilib", "gio", "gmail", "liv", "icon", "nova", "kok", "vec", "mn", "rolet", "voc", "iol", "ilo", "emn", "imedia", "dyl", "mia", "mx", "iu", "\u00ef", "nic", "ibl", "drm", "mu", "vre", "io", "music", "hub", "wav", "audi", "pai", "lov", "icho", "rn", "mos", "colo", "chrom", "oyer", "iasm", "mus", "nox", "oji", "uno", "hn", "yon", "eni", "gnu", "yout", "gener", "iris", "nikov", "oren", "iop", "iola", "voice", "gru", "iv", "clinton", "cdn", "club", "veh", "nr", "userc"], "iov_cnt": ["iov_mcateg", "iov_cred", "iov_arcrowd", "iov_cfnt", "iov_acnn", "iov_icnt", "iov_pcursor", "iov_connt", "iov_crrowd", "iov_uncred", "iov_dcannot", "iov_fcred", "iov_conannot", "iov_cfound", "iov_mcursor", "iov_conrowd", "iov_crowd", "iov_Cnn", "iov_crypt", "iov_uncrt", "iov_acNT", "iov_uncnt", "iov_cound", "iov_arcnt", "iov_cursor", "iov_countrypted", "iov_Cnt", "iov_lcrypt", "iov_cfst", "iov_crypted", "iov_lred", "iov_uncateg", "iov_ecrowd", "iov_uncursor", "iov_cant", "iov_lcnn", "iov_cNT", "iov_countound", "iov_arcoding", "iov_countst", "iov_dcnt", "iov_arcannot", "iov_dcoding", "iov_fcant", "iov_coding", "iov_connn", "iov_pcnt", "iov_mcrowd", "iov_countnt", "iov_fcnt", "iov_fcrt", "iov_count", "iov_lrt", "iov_ecount", "iov_icount", "iov_lcount", "iov_lcst", "iov_uncrowd", "iov_pcateg", "iov_lcound", "iov_cannot", "iov_pcrowd", "iov_conount", "iov_CNT", "iov_lcNT", "iov_uncant", "iov_cfrypted", "iov_Crypt", "iov_acount", "iov_mcnt", "iov_categ", "iov_acnt", "iov_icant", "iov_Count", "iov_ecant", "iov_conoding", "iov_ecnt", "iov_icrowd", "iov_lant", "iov_crt", "iov_conrypt", "iov_dcrowd", "iov_lcnt", "iov_crount", "iov_cnn", "iov_lcrypted", "iov_cst", "iov_crant", "iov_crnt", "iov_lnt"], "mac_data": ["mac_database", "macpdatabase", "mac_la", "macfbatch", "mackdone", "Mac_DATA", "mackdata", "MAC_info", "mac_cache", "mac_action", "micro_Data", "mac2start", "macsdat", "macpcache", "macPkeys", " mac_", "MAC_data", "macfdat", "macgfail", "cas_data", "mac2DATA", "micro_DATA", "mac2data", "mac_info", "macpdata", "mc_database", "mic_la", "mic_dat", "macsdata", "mc_cache", "feature_dat", "macgtype", "macMnew", "mac_start", "featurefdata", "mic_data", "macgdata", "featurefbatch", "mic_done", "macsbatch", "macMtype", "macPdata", "mc\n", "micro_data", "mac_new", " mac_database", "mac7dat", "mac_DATA", "macgnew", "feature_data", "mac_", "macMdata", "mic_action", "MAC_start", "macendinfo", "feature_database", "macenddata", "mac7data", "mc_type", " mac\n", "macendDATA", " mac_keys", "mac_fail", "mac\n", "macMfail", " mac_dat", "mac7database", "macPdatabase", "macsdatabase", "mac_type", "Mac_cache", "mac_Data", "featurefdatabase", "featurefdat", "mackkeys", "feature_batch", "mac_rec", "macPdat", "MAC\n", "micro_database", "macfdatabase", "Mac_data", "mac_done", "cas_fail", "Mac_rec", "cas_new", "mic_keys", "mc_", "mackaction", "MAC_", "mc_data", "mac_keys", "cas_type", "mac7keys", "MAC_DATA", "macfdata", "mac_batch", "mac2info", "macendstart", "mac_dat", "macptype"], "s": ["js", "b", "S", "rs", "send", "sb", "ssl", "fs", "g", "result", "h", "p", "args", "sets", "lines", "si", "sync", "sq", "sn", "network", "secondary", "conf", "gs", "params", "l", "cs", "t", "su", "small", "e", "c", "ss", "spec", "o", "stats", "site", "sf", "details", "status", "sites", "ops", "session", "is", "src", "m", "sym", "input", "side", "sg", "f", "ds", "server", "ses", "sys", "sl", "sv", "os", "r", "size", "v", "south", "ns", "sample", "d", "i", "sec", "ls", "say", "services", "sw"], "nc": ["network", "nl", "dc", "NC", "bc", "nb", "anc", "mn", "voc", "cc", "ctx", "ne", "nv", "nt", "mc", "cv", "nic", "dn", "conn", "rn", "cs", "nec", "cn", "nn", "irc", "rc", "ns", "nw", "c", "pc", "lc", "ng", "sn", "ci", "nm", "cdn", "nr"], "macs": ["macts", "Mac", "Macts", "macks", "premAC", " maces", "vacts", "imacks", "premaces", " mAC", " macks", " macts", "vacs", "imaces", "mAC", "mac", "premacs", " mats", "vats", "premacks", "Mats", "Macs", "mats", " mac", "imAC", "vac", "imacs", "maces"]}}
{"project": "FFmpeg", "commit_id": "14a90c9ef09a4b046500dceab5ca1875e330a376", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401, "substitutes": {"avctx": ["akcontext", "awcontext", "airctrl", "AVcas", "awpkg", "avecf", "AVcfg", "avalcmd", "avalcms", "navcmp", "awctx", "AVsc", "avcmd", "AVc", "avpkg", " avconn", "aveconn", " avcontext", "afctrl", "avectx", "avalcontext", "afcontext", "avesc", " avc", "avconsole", "avecontext", "akctl", "ajconsole", "AVcms", "avalctx", "akctrl", "ajcontext", "avca", "avcli", "AVcmd", "ajconn", "avc", "avechan", "AVconn", "avec", "airctl", "afcf", "avalchan", "avctl", "varctx", "airctx", "afca", "akcfg", " avcmp", "avcf", "aveca", "afctx", "avecmp", "aveconsole", "afconn", "avconn", "akctx", "avcc", "navcli", "avcms", "AVcontext", "afctl", "avctrl", " avcli", "AVcf", "avsc", "varcontext", "avcmp", "afcms", "ajctx", "awcfg", " avcms", "navctx", "avalcmp", "AVpkg", "afcc", "varcms", "AVca", "akpkg", "varcmd", "avcas", " avcas", "avcfg", "avcontext", " avcc", "AVcmp", "navcontext", "ajcas", "ajcf", "avchan", " avsc", "aircontext", "AVchan", "AVcli", "AVconsole", "varcc", "AVctx"], "ctx": ["coll", "context", "general", "xc", "parent", "bc", "cmp", "ca", "anc", "voc", "cc", "cp", "cms", "text", "connection", "hw", "pkg", "cv", "cas", "conn", "cf", "cci", "service", "config", "cam", "vc", "cs", "conv", "cmd", "wcs", "cn", "rc", "cm", "tx", "ctrl", "console", "cca", "c", "git", "lc", "cb", "component", "cli", "event", "cu", "ci", "qa", "client", " context"], "status": ["error", "ret", "sc", "bc", "err", "state", "std", "wait", "success", "proc", "progress", "response", "sb", "crit", "gc", "session", "result", "resp", "job", " ret", "Status", "null", "code", "s", "rc", " resp", "usr", "exec", "sync", "sec", "msg", "cb", "output", "str", "stat", "val", "cat", "STAT", "res", "flag", "class", "temp", "bg"], "format_in": [" format_id", "feedablenew", "template_in", "type_for", "Format_in", "formatableIn", "formatacdiff", "formatablenew", " format_In", "format___ac", "formatableout", "format_IN", "live_ins", "format_ins", "formatoc0", "feedableout", " format_init", "format_ac", "filter_ini", "form_out", "formatacin", "form_ac", "format_for", "formatingdiff", "format_again", "Format\n", "formatMixin", "feed_in", "template_ini", " format\n", "format\n", "formatacnew", "formatocat", "formatformat", "type_in", "formatingin", "filter_out", "format___IN", " format_inc", "feed_In", "feedableIn", "live_in", "format_ini", "formatMixat", "format_at", "Format_In", "type_inc", "filter_in", "format_init", "format_In", "format_0", "format_out", "template_0", "format_inn", "Formatformat", "filter_inn", "Format_ins", "feed_out", "live_inc", "form_IN", "Format_inc", "formatocini", "type_In", "filterformat", "formatingnew", "Format_out", " formatformat", "format_new", "form_in", "formatocinit", " format_at", "Format_again", " format_diff", "format_diff", "format_inc", "format___out", "format_id", "format___in", " format_out", " format_new", "formatablein", " format_IN", "feedablein", "formatocin", "filter\n", "formatMixinit", "feed_new"], "decoder": ["encater", "Decater", "Decoding", " decoding", "encoding", "decade", "encrator", "ecoding", "decoding", "decater", "decader", "encoded", "Decoder", " decoded", "recode", "ecode", "encode", "decoded", "deoded", "ecoder", " decader", "declater", "declade", "declrator", " decode", "decrator", "recade", "ecater", "deoder", "recader", "recoder", "deode", "declode", " decrator", "deoding", "encoder", "Decode", "decloding", "decode", "declader", " decade", "decloder"], "tmp": [" proc", "mp", "MP", "cmp", "proc", " rc", "bb", " app", "sb", " param", " obj", " reply", " params", " dst", " pad", "src", " msg", " img", "obj", " pts", " co", " resp", "img", " ecc", "cb", "pad", "temp", " dup"]}}
{"project": "FFmpeg", "commit_id": "9e1c55cfdec1e1e46fa39b92ea5c425ba9499c68", "target": 1, "func": "static int ogg_get_length(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int i;\n\n    int64_t size, end;\n\n    int streams_left=0;\n\n\n\n    if(!s->pb->seekable)\n\n        return 0;\n\n\n\n// already set\n\n    if (s->duration != AV_NOPTS_VALUE)\n\n        return 0;\n\n\n\n    size = avio_size(s->pb);\n\n    if(size < 0)\n\n        return 0;\n\n    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, end, SEEK_SET);\n\n\n\n    while (!ogg_read_page (s, &i)){\n\n        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&\n\n            ogg->streams[i].codec) {\n\n            s->streams[i]->duration =\n\n                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);\n\n            if (s->streams[i]->start_time != AV_NOPTS_VALUE){\n\n                s->streams[i]->duration -= s->streams[i]->start_time;\n\n                streams_left-= (ogg->streams[i].got_start==-1);\n\n                ogg->streams[i].got_start= 1;\n\n            }else if(!ogg->streams[i].got_start){\n\n                ogg->streams[i].got_start= -1;\n\n                streams_left++;\n\n            }\n\n        }\n\n    }\n\n\n\n    ogg_restore (s, 0);\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, s->data_offset, SEEK_SET);\n\n    ogg_reset(s);\n\n\n    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {\n\n\n        int64_t pts = ogg_calc_pts(s, i, NULL);\n\n        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            s->streams[i]->duration -= pts;\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }\n\n        }\n\n            if(streams_left<=0)\n\n                break;\n\n    }\n\n    ogg_restore (s, 0);\n\n\n\n    return 0;\n\n}", "idx": 25404, "substitutes": {"s": ["js", "b", "in", "com", "sc", "S", "events", "rs", "ssl", "sb", "fs", "g", "obs", "states", "tests", "p", "times", "u", "sets", "ms", "sync", "xs", "sq", "a", "as", "n", "qs", "conf", "gs", "aws", "params", "es", "l", "ks", "service", "cs", "t", "e", "c", "ss", "spec", "ogs", "o", "stats", "its", "sf", "self", "ops", "session", "ts", "is", "m", "sym", "input", "uploads", "sg", "f", "ds", "server", "plugins", "ses", "sys", "bis", "comm", "ch", "sv", "http", "rows", "ions", "os", "ows", "r", "game", "bs", "ps", "ins", "ns", "settings", "an", "d", "sec", "ls", "services", "sw", "comments", "us", "se"], "ogg": ["ogl", "gz", "wp", "oga", "podcast", "sb", "agg", "obs", "ocr", "gd", "kw", "ev", "og", "media", "dd", "co", "pg", "gs", "gross", "audio", "window", "mpeg", "wav", "obb", "tmp", "oss", "eb", "feed", "cli", "gov", "ogs", "tg", "ga", "ogo", "owl", "ow", "od", "aud", "bb", "tt", "ov", "wx", "config", "app", "ood", "rss", "cmd", "bug", "input", "cfg", "ohm", "gg", "ogi", "mm", "google", "ogle", "org", "ott", "gow", "omm", "gae", "comm", "rog", "oper", "ch", "php", "hw", "ows", "game", "acc", "stream", "roc", "oc", "gram", "doc", "uc", "ob"], "i": ["index", "b", "ai", "x", "oi", "li", "pi", "n", "iii", "ie", "z", "id", "j", "abi", "yi", "info", "iu", "ip", "g", "ix", "type", "gi", "ri", "bi", "is", "l", "ti", "h", "io", "v", "fi", "y", "uri", "xi", "ini", "inner", "multi", "p", "qi", "ic", "m", "di", "I", "t", "u", "it", "ii", "init", "si", "e", "c", "start", "d", "eni", "f", "cli", "lc", "module", "api", "q", "ori", "ui", "ci", "pos", "phi", "iv", "o", "ni", "ei"], "size": ["mini", "engine", "video", "last", "sd", "ize", "big", "sum", "bytes", "send", "full", "len", "fee", "g", "storage", "cache", "day", "max", "en", "l", "h", "be", "large", "empty", "cl", "code", "SIZE", "speed", "cs", "iz", "complete", "address", "unit", "args", "core", "sea", "cm", "page", "scale", "capacity", "si", "time", "small", "loc", "e", "c", "sync", "start", "sec", "sized", "data", "content", "ui", "ci", "Size", "use", "fe", "form", "name", "se", "length", "offset"], "end": ["index", "last", "port", "after", "ended", "set", "entry", "z", "id", "stop", "send", "END", "max", "type", "open", "close", "enc", "range", "inner", "ending", "est", "stage", "line", "address", "End", "scale", "time", "e", "loc", "limit", "export", "start", "ad", "pos", "ff", "client", "nd", "en", "length", "post", "offset"], "streams_left": ["streamabs_Left", "streames_left", "streaming_right", "streams__found", "streams2Left", "streamabs_left", "streaming_found", "streams__l", "streams_cle", "streamabs_found", "streaming_in", "streaming__in", "streams_found", "streams2left", "streams_allowed", "streames_cle", "streamabs_allowed", "streaming__left", "streaming__right", "streams__in", "streames_leave", "streams_leave", "streams_right", "streams_l", "streams_Left", "streams2allowed", "streams2found", "streams__cle", "streams__right", "streams_in", "streaming__found", "streaming_left", "streames_l", "streams__left", "streams__leave"]}}
{"project": "FFmpeg", "commit_id": "80387f0e2568746dce4a68e2217297029a053dae", "target": 1, "func": "static int mimic_decode_frame(AVCodecContext *avctx, void *data,\n\n                              int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MimicContext *ctx = avctx->priv_data;\n\n    GetByteContext gb;\n\n    int is_pframe;\n\n    int width, height;\n\n    int quality, num_coeffs;\n\n    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;\n\n\n\n    if (buf_size <= MIMIC_HEADER_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"insufficient data\\n\");\n\n        return -1;\n\n    }\n\n\n\n    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);\n\n    bytestream2_skip(&gb, 2); /* some constant (always 256) */\n\n    quality    = bytestream2_get_le16u(&gb);\n\n    width      = bytestream2_get_le16u(&gb);\n\n    height     = bytestream2_get_le16u(&gb);\n\n    bytestream2_skip(&gb, 4); /* some constant */\n\n    is_pframe  = bytestream2_get_le32u(&gb);\n\n    num_coeffs = bytestream2_get_byteu(&gb);\n\n    bytestream2_skip(&gb, 3); /* some constant */\n\n\n\n    if(!ctx->avctx) {\n\n        int i;\n\n\n\n        if(!(width == 160 && height == 120) &&\n\n           !(width == 320 && height == 240)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid width/height!\\n\");\n\n            return -1;\n\n        }\n\n\n\n        ctx->avctx     = avctx;\n\n        avctx->width   = width;\n\n        avctx->height  = height;\n\n        avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        for(i = 0; i < 3; i++) {\n\n            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));\n\n            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;\n\n        }\n\n    } else if(width != ctx->avctx->width || height != ctx->avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"resolution changing is not supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decoding must start with keyframe\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->buf_ptrs[ctx->cur_index].reference = 1;\n\n    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;\n\n    if(ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->next_prev_index = ctx->cur_index;\n\n    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;\n\n\n\n    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],\n\n                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    ff_thread_finish_setup(avctx);\n\n\n\n    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,\n\n                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if(!ctx->swap_buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ctx->dsp.bswap_buf(ctx->swap_buf,\n\n                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),\n\n                        swap_buf_size>>2);\n\n    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);\n\n\n\n    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {\n\n        if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);\n\n        else {\n\n            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ctx->prev_index = ctx->next_prev_index;\n\n    ctx->cur_index  = ctx->next_cur_index;\n\n\n\n    /* Only release frames that aren't used for backreferences anymore */\n\n    if(ctx->buf_ptrs[ctx->cur_index].data[0])\n\n        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    return buf_size;\n\n}\n", "idx": 25413, "substitutes": {"avctx": ["avxc", "akcontext", "evconn", "navcmd", "appctl", "akconfig", "afcu", " avcfg", "AVcfg", " avcv", "avcmd", "abctx", "akcli", "aveconn", " avkw", "varcal", "afcfg", " avcontext", "evcu", "avectx", " avgpu", "varvoc", "avalcontext", "afcontext", "avecontext", "avgpu", "abcontext", "akctl", "avalctx", "appcmp", "avcli", "AVctl", "AVcmd", "navvoc", "afcf", "AVconfig", "avctl", "avalcfg", "avalgpu", "afconfig", "AVxc", "varctx", "akcfg", "aveconfig", "avcu", "avcv", "evcontext", "abcf", "avcf", "abconfig", "avkw", "afctx", "avecmp", "afconn", "avconn", "navcomponent", "avalcv", "akctx", "avvoc", " avctl", "AVcontext", "AVcv", "afctl", "abcu", "avalconfig", " avcli", "AVcf", "AVcu", "evctx", "avalkw", "varcontext", "avcmp", "AVkw", "avconfig", "navctx", "avcomponent", "varcmd", " avconfig", "navcal", "avcal", "afcmp", "avcfg", "avecfg", "avcontext", "appcontext", "varcomponent", "AVcmp", "avecu", "AVgpu", "navcontext", "abcmp", "AVvoc", "appctx", " avxc", "avalxc", "AVcli", "AVctx"], "data": ["parent", "base", "bc", "source", "message", "connection", "body", "DATA", "window", "image", "cache", "size", "result", "reader", "src", "config", "frame", "batch", "queue", "code", "read", "channel", "Data", "obj", "address", "buffer", "input", "addr", "media", "block", "next", "uf", "val", "content", "load", "client", "memory", "dat", "video", "buff"], "data_size": ["data_SIZE", " data_capacity", " data_SIZE", "data_capacity", " data_data", "data_data"], "avpkt": ["avvpkt", "AVPkt", "avmsth", "avcpkt", "avperacket", "avPct", "avcpck", "AVvpkt", "avperct", "AVpKT", "avmacket", "avpct", "AVpkt", "avpKT", "avfacket", "avvpct", "avmkt", "avperkt", "avPck", "AVpct", "AVPacket", "avpacket", "AVpck", "avmct", "AVcpacket", "avvpKT", "avcpKT", "avPkt", "AVcpkt", "avcpct", "AVcpka", "avpka", "avfsth", "AVPsth", "AVpsth", "avpck", "avcpacket", "avPsth", "avfkt", "avvpck", "avpsth", "avfct", "AVpacket", "AVvpck", "avperka", "avcpka", "avfka", "avPacket", "AVPct", "AVvpKT", "AVvpct", "avPKT", "AVcpct", "AVpka"], "buf": ["cap", "box", "bc", "vec", "bb", "fd", "window", "rb", "cache", "cv", "br", "Buffer", "cas", "fp", "cf", "src", "pool", "config", "queue", "alloc", "code", "cmd", "rc", "buffer", "block", "bag", "seq", "uc", "cb", "uf", "bus", "map", "val", "ff", " buffer", "buff"], "ctx": ["fw", "coll", "context", "fc", "css", "xc", "sci", "bc", "cmp", "ca", "anc", "cc", "cp", "hw", "qq", "window", "cus", "pkg", "ck", "cv", "cas", "cal", "kw", "conn", "wx", "cf", "cci", "Context", "config", "cam", "vc", "cs", "act", "conv", "cmd", "tc", "cn", "wcs", "prefix", "cfg", "tx", "ctrl", "cm", "console", "acl", "cca", "utils", "na", "loc", "c", "git", "pc", "lc", "cb", "component", "cli", "cu", "ci", "qa", "client", "kb"], "gb": ["b", " gcc", "bc", " rg", " eg", " GC", "yg", "sb", "g", "gc", "gd", "kw", "gy", "mb", "bridge", "gal", " cf", " cc", " prog", " kb", "bg", "bm", "pg", "gio", " ig", "gl", "gh", "gs", "gin", " pci", "rb", " bi", "rg", "gpu", "greg", "cgi", "eb", "pc", "bf", " gui", " alloc", "ui", " gl", "tg", "ga", "gm", "gp", " conf", "nb", "gom", "bb", " cd", " bus", "GB", " gp", "cfg", "gam", " co", "gg", "uf", " rgb", "gru", "vg", "abb", "gae", "ko", " rc", "storage", " db", "hub", " lib", "gram", "db", "gu", " storage"], "is_pframe": ["is__pframe", "is__fstate", "is_bframe", "is_ipfram", "is_prerame", "is__pstate", "is_pstate", "is__fframes", "is_ipstate", "is__ffram", "is_ipframe", "is_fframe", "is_fpstate", "is_bfram", "is_preframe", "is__pframes", "is_hfram", "is_fstate", "is_ipframes", "is_hrame", "is_brame", "is_ffram", "is_fpfram", "is_pframes", "is_pfram", "is_fframes", "is_prefram", "is_fpframe", "is_fpframes", "is_hframe", "is__pfram", "is_prame", "is__fframe"], "height": ["direction", "tight", "ths", "pull", "han", "distance", "h", "history", "rh", "east", "times", "view", "grow", "gap", "above", "arrow", "bottom", "gallery", "depth", "x", "fw", "rank", "shape", "huge", "gh", "th", "Height", "window", "build", "gpu", "thumbnails", "density", "definition", "capacity", "high", "img", "generation", " heights", "stroke", "gravity", "details", "resolution", "thin", "crop", "dim", "y", "slice", "level", "def", "wall", "w", "input", "deep", "lat", "alpha", "rows", "hang", "dy", "layout", "ows", "image", "size", "duration", "v", "volume", "missing", "d", "padding", "inches", "ht", "wide", "length", "ty", "upper"], "quality": ["depth", "weight", "confidence", "frequency", "resolution", "value", "alpha", "z", "format", "qual", "len", "window", "dim", "distance", "rate", "style", "query", "frame", "version", "level", "speed", "quiet", "density", "buffer", "deep", "scale", "capacity", "time", "padding", "gap", "diff", "Quality", "q", "grade", "qa", "memory", "name", "length"], "num_coeffs": ["num_COffes", "num_coffes", "num_coEFFi", "num_coefes", "num_coefficientsi", "num_coeffi", "num_coefficientsps", "num_coefficientses", "num_coEFFps", "num_COeffps", "num_coEFFes", "num_coefficientss", "num_coffps", "num_coeffps", "num_COffi", "num_COeffs", "num_coeffes", "num_COffs", "num_COffps", "num_coEFFs", "num_coffs", "num_coefps", "num_COeffi", "num_COeffes", "num_coffi", "num_coefi", "num_coefs"], "i": ["index", "x", "mini", "num", "b", "oi", "ai", "li", "pi", "n", "ie", "child", "idi", "id", "j", "count", "abi", "anti", "yi", "info", "iu", "ip", "hi", "ix", "gi", "ri", "bi", "l", "v", "y", "io", "fi", "ti", "mu", "uri", "xi", "ini", "h", "inner", "area", "multi", "p", "qi", "zi", "m", "di", "I", "t", "chi", "u", "it", "ii", "si", "block", "e", "c", "uli", "eni", "lc", "adi", "diff", "ori", "ui", "phi", "ci", "ni", "ji", "a", "mi"]}}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x8(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[2];\n\n    unsigned int flags = 0;\n\n\n\n    /* 2-color encoding for each 4x4 quadrant, or 2-color encoding on\n\n     * either top and bottom or left and right halves */\n\n    CHECK_STREAM_PTR(2);\n\n\n\n    P[0] = *s->stream_ptr++;\n\n    P[1] = *s->stream_ptr++;\n\n\n\n    if (P[0] <= P[1]) {\n\n\n\n        CHECK_STREAM_PTR(14);\n\n        s->stream_ptr -= 2;\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // new values for each 4x4 block\n\n            if (!(y & 3)) {\n\n                P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                flags = bytestream_get_le16(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 1)\n\n                *s->pixel_ptr++ = P[flags & 1];\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n\n\n        /* need 10 more bytes */\n\n        CHECK_STREAM_PTR(10);\n\n\n\n        if (s->stream_ptr[4] <= s->stream_ptr[5]) {\n\n\n\n            flags = bytestream_get_le32(&s->stream_ptr);\n\n\n\n            /* vertical split; left & right halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 16; y++) {\n\n                for (x = 0; x < 4; x++, flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) {\n\n                    s->pixel_ptr -= 8 * s->stride - 4;\n\n                    P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                    flags = bytestream_get_le32(&s->stream_ptr);\n\n                }\n\n            }\n\n\n\n        } else {\n\n\n\n            /* horizontal split; top & bottom halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 8; y++) {\n\n                if (y == 4) {\n\n                    P[0] = *s->stream_ptr++;\n\n                    P[1] = *s->stream_ptr++;\n\n                }\n\n                flags = *s->stream_ptr++ | 0x100;\n\n\n\n                for (; flags != 1; flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->line_inc;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 25448, "substitutes": {"s": ["js", "b", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "h", "hs", "tests", "p", "features", "times", "args", "u", "sets", "ms", "lines", "si", "sync", "sq", "parts", "a", "as", "native", "n", "qs", "conf", "gs", "less", "opens", "aws", "params", "es", "l", "ims", "ks", "service", "cs", "t", "ats", "e", "c", "sports", "ss", "o", "site", "its", "sf", "your", "ops", "session", "ans", "ts", "is", "m", "ads", "sym", "w", "side", "sg", "f", "ds", "data", "phys", "ses", "sys", "bis", "ips", "http", "os", "r", "ps", "ins", "ns", "settings", "an", "d", "i", "ls", "services", "words", "comments", "us"], "x": ["index", "b", "num", "sex", "in", "n", "key", "rx", "xc", "win", "z", "id", "j", "wy", "col", "ax", "wa", "X", "ww", "ip", "image", "ix", "px", "no", "l", "v", "h", "pe", "xi", "name", "cross", "on", "p", "code", "xx", "gy", "t", "u", "w", "ex", "dx", "xy", "my", "el", "tx", "time", "e", "any", "c", "ey", "d", "ph", "i", "f", "xs", "data", "ay", "fx", "pos", "yx", "en", "a", "ty"], "y": ["b", "oy", "vy", "yl", "yn", "uy", "yer", "year", "Y", "n", "key", "ny", "ch", "by", "isy", "z", "id", "ky", "j", "count", "cy", "dy", "yi", "ady", "hi", "ye", "g", "size", "type", "ys", "sy", "yo", "l", "yr", "h", "v", "py", "ym", "hy", "p", "sky", "gy", "m", "yt", "lon", "t", "xy", "w", "zy", "c", "ey", "d", "i", "ya", "f", "ay", "iy", "yy", "o", "yd", "ry", "height", "length", "ty"], "P": ["E", "V", "Q", "API", "Y", "FP", "DP", "PA", "PR", "Ps", "D", "A", "NP", "S", "N", "Page", "Path", "Part", "SP", "CP", "PO", "X", "HP", "Pool", "JP", "WP", "ARP", "LP", "L", "G", "PU", "Port", "PP", "M", "p", "K", "R", "PD", "Position", "O", "I", "F", "PIN", "C", "PS", "Data", "YP", "Push", " p", "BP", "IP", "XP", "VP", "PUT", "Py", "GP", "TP", "AP", "Point", "FF", "PE", "PF", "H", "T", "RP", "B", "J"]}}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "substitutes": {"env": ["site", "buf", "engine", "enable", "context", "scope", "et", "que", "dict", "conf", "err", "eu", "nc", "me", "proc", "self", "net", "environment", "er", "esp", "end", "loader", "ctx", " en", "ne", "ass", "cache", "NV", "conn", "priv", " environment", "style", "enc", "erv", "config", "app", "manager", "external", "code", "core", "dev", "exc", "obj", "ev", "console", " environments", "db", "el", "this", "txt", "e", "exec", "eng", "ea", "Environment", "export", "ec", "nw", "eni", "extra", "data", "event", "global", "server", "np", "viron", "cdn", "en", "her", "ext"], "mem_buf": ["memingfd", "mem_buffer", " mem_buff", "memmemdone", "memalprim", "memmembuf", "Mem_bag", "memingbuff", "mem_bu", "memalbuf", "sm_bu", "Mem_coord", "Mem_bu", "sm_buf", "mem_brace", "mem_fd", "mem_buff", "memalbuffer", "Mem_buff", "mem0prim", "mem_bag", "sm_begin", "Mem_buf", "sm_raf", " mem_hor", "Mem_vec", " mem_prim", "mem0hor", "mem_hor", " mem_buffer", "memmemvec", "Mem_brace", "mem_begin", "mem_vec", "Mem_buffer", " mem_fd", "mem_prim", "memingbuffer", "memingbuf", "memmembuff", "mem_done", "mem_raf", "mem0buf", "memalhor", "mem_coord", "mem0buffer", "Mem_done"], "n": ["x", "b", "network", "num", "in", "un", "nat", "nb", "z", "j", "nc", "N", "self", "net", "or", "nor", "len", "ne", "r", "nt", "number", "no", "l", "y", "v", "conn", "all", "name", "config", "on", "p", "m", "t", "cn", "s", "nn", "u", "pn", "w", "ns", "k", "an", "e", "node", "c", "fn", "d", "nw", "i", " N", "f", "nu", "sn", "np", "o", "ni", "en", "nr"]}}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_draw_text(VGACommonState *s, int full_update)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;\n\n    int cx_min, cx_max, linesize, x_incr, line, line1;\n\n    uint32_t offset, fgcol, bgcol, v, cursor_offset;\n\n    uint8_t *d1, *d, *src, *dest, *cursor_ptr;\n\n    const uint8_t *font_ptr, *font_base[2];\n\n    int dup9, line_offset;\n\n    uint32_t *palette;\n\n    uint32_t *ch_attr_ptr;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);\n\n\n\n    /* compute font data address (in plane 2) */\n\n    v = s->sr[VGA_SEQ_CHARACTER_MAP];\n\n    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;\n\n    if (offset != s->font_offsets[0]) {\n\n        s->font_offsets[0] = offset;\n\n        full_update = 1;\n\n    }\n\n    font_base[0] = s->vram_ptr + offset;\n\n\n\n    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;\n\n    font_base[1] = s->vram_ptr + offset;\n\n    if (offset != s->font_offsets[1]) {\n\n        s->font_offsets[1] = offset;\n\n        full_update = 1;\n\n    }\n\n    if (s->plane_updated & (1 << 2) || s->has_chain4_alias) {\n\n        /* if the plane 2 was modified since the last display, it\n\n           indicates the font may have been modified */\n\n        s->plane_updated = 0;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_basic_params(s);\n\n\n\n    line_offset = s->line_offset;\n\n\n\n    vga_get_text_resolution(s, &width, &height, &cw, &cheight);\n\n    if ((height * width) <= 1) {\n\n        /* better than nothing: exit if transient size is too small */\n\n        return;\n\n    }\n\n    if ((height * width) > CH_ATTR_SIZE) {\n\n        /* better than nothing: exit if transient size is too big */\n\n        return;\n\n    }\n\n\n\n    if (width != s->last_width || height != s->last_height ||\n\n        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {\n\n        s->last_scr_width = width * cw;\n\n        s->last_scr_height = height * cheight;\n\n        qemu_console_resize(s->con, s->last_scr_width, s->last_scr_height);\n\n        surface = qemu_console_surface(s->con);\n\n        dpy_text_resize(s->con, width, height);\n\n        s->last_depth = 0;\n\n        s->last_width = width;\n\n        s->last_height = height;\n\n        s->last_ch = cheight;\n\n        s->last_cw = cw;\n\n        full_update = 1;\n\n    }\n\n    full_update |= update_palette16(s);\n\n    palette = s->last_palette;\n\n    x_incr = cw * surface_bytes_per_pixel(surface);\n\n\n\n    if (full_update) {\n\n        s->full_update_text = 1;\n\n    }\n\n    if (s->full_update_gfx) {\n\n        s->full_update_gfx = 0;\n\n        full_update |= 1;\n\n    }\n\n\n\n    cursor_offset = ((s->cr[VGA_CRTC_CURSOR_HI] << 8) |\n\n                     s->cr[VGA_CRTC_CURSOR_LO]) - s->start_addr;\n\n    if (cursor_offset != s->cursor_offset ||\n\n        s->cr[VGA_CRTC_CURSOR_START] != s->cursor_start ||\n\n        s->cr[VGA_CRTC_CURSOR_END] != s->cursor_end) {\n\n      /* if the cursor position changed, we update the old and new\n\n         chars */\n\n        if (s->cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[s->cursor_offset] = -1;\n\n        if (cursor_offset < CH_ATTR_SIZE)\n\n            s->last_ch_attr[cursor_offset] = -1;\n\n        s->cursor_offset = cursor_offset;\n\n        s->cursor_start = s->cr[VGA_CRTC_CURSOR_START];\n\n        s->cursor_end = s->cr[VGA_CRTC_CURSOR_END];\n\n    }\n\n    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;\n\n    if (now >= s->cursor_blink_time) {\n\n        s->cursor_blink_time = now + VGA_TEXT_CURSOR_PERIOD_MS / 2;\n\n        s->cursor_visible_phase = !s->cursor_visible_phase;\n\n    }\n\n\n\n    dest = surface_data(surface);\n\n    linesize = surface_stride(surface);\n\n    ch_attr_ptr = s->last_ch_attr;\n\n    line = 0;\n\n    offset = s->start_addr * 4;\n\n    for(cy = 0; cy < height; cy++) {\n\n        d1 = dest;\n\n        src = s->vram_ptr + offset;\n\n        cx_min = width;\n\n        cx_max = -1;\n\n        for(cx = 0; cx < width; cx++) {\n\n            ch_attr = *(uint16_t *)src;\n\n            if (full_update || ch_attr != *ch_attr_ptr || src == cursor_ptr) {\n\n                if (cx < cx_min)\n\n                    cx_min = cx;\n\n                if (cx > cx_max)\n\n                    cx_max = cx;\n\n                *ch_attr_ptr = ch_attr;\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n                ch = ch_attr >> 8;\n\n                cattr = ch_attr & 0xff;\n\n#else\n\n                ch = ch_attr & 0xff;\n\n                cattr = ch_attr >> 8;\n\n#endif\n\n                font_ptr = font_base[(cattr >> 3) & 1];\n\n                font_ptr += 32 * 4 * ch;\n\n                bgcol = palette[cattr >> 4];\n\n                fgcol = palette[cattr & 0x0f];\n\n                if (cw == 16) {\n\n                    vga_draw_glyph16(d1, linesize,\n\n                                     font_ptr, cheight, fgcol, bgcol);\n\n                } else if (cw != 9) {\n\n                    vga_draw_glyph8(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol);\n\n                } else {\n\n                    dup9 = 0;\n\n                    if (ch >= 0xb0 && ch <= 0xdf &&\n\n                        (s->ar[VGA_ATC_MODE] & 0x04)) {\n\n                        dup9 = 1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n", "idx": 25472, "substitutes": {"s": ["js", "b", "in", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "sis", "p", "u", "sets", "si", "sync", "xs", "sq", "a", "as", "n", "qs", "secondary", "conf", "state", "gs", "less", "es", "l", "ks", "service", "cs", "t", "su", "sie", "e", "c", "sports", "ss", "spec", "o", "site", "sf", "details", "your", "status", "sites", "self", "ops", "session", "ts", "is", "y", "m", "styles", "sym", "sg", "this", "f", "ds", "server", "ses", "sys", "sl", "sv", "http", "os", "r", "ps", "ins", "south", "ns", "settings", "i", "ls", "services", "comments", "se"], "full_update": ["fullpreupdated", " full_updated", " full_edit", "full_status", "full_save", " full_database", "full_append", "complete_status", "fulllexstatus", "fulllexupdate", "full_updated", "complete_flush", "full_database", " full_append", "complete_update", "fullpreupdate", "fulllexflush", " full_UPDATE", "complete_updated", "full___update", "full_flush", "full_edit", "fullpreflush", "fulllexupdated", "full___append", " full_flush", " full_save", "full___edit", "full_UPDATE", "fullprestatus"], "surface": ["site", "sl", "sc", "texture", "source", "scene", "ssl", "faces", "layout", "image", "sheet", "panel", "slice", "sur", "stream", "sm", "draw", "screen", "sym", "wrapper", "console", "aster", "side", "sim", "document", "face", "skin"], "cx": ["Cw", "rctx", "ctx", "Ctx", " cwx", "rcw", "rcwx", "cwx", "Cx", "Cwx", " ctx", "rcx"], "cy": ["yl", "vy", "iw", "ca", "ky", "wy", "gray", "cc", "dy", "cycle", "wx", "cf", "py", "gy", "ee", "cr", "xy", "cm", "ct", "sty", "cb", "ay", "ci", "yx", "ry", "ty", "cd"], "cheight": ["Cheights", "ceight", "chyadh", "Cheadh", "Cheffield", "ueight", "cheights", "ceq", "peq", "feffield", "cheadh", "Cheight", "chyight", "cheq", "cheigh", "ceigh", "feadh", "peight", "cheust", "feight", "feights", "ueq", "cheffield", "chyights", "peust", "chyffield", "peigh", "ceust", "ueust", "ueigh"], "cw": ["Cw", "Cwd", "kx", "Cx", "pcwd", "dh", "cwd", "crwd", "kws", "crx", "cv", "kw", "cws", "Cv", "crw", "dx", " cws", "crv", "dw", "pcx", "pcv", "kh", "pcw", "dws"], "ch": ["ach", "align", "conf", "z", "count", "bh", "cp", "th", "zh", "col", "sh", "ctx", "cf", "power", "vc", "code", "cm", "el", "chan", "c", "wh", "img", "ht", "ci", "cd"], "cattr": [" cwm", "bwd", "cwd", "cptr", " cwd", "bptr", "battr", " cptr", "nwm", "nattr", "nptr", "cwm", "nwd", "bwm"], "height": ["depth", "x", "fw", "stroke", "gravity", "alpha", "resolution", "png", "id", "thin", "rows", "shape", "crop", "direction", "hd", "th", "zh", "dy", "Height", "window", "layout", "image", "flow", "size", "dim", "duration", "max", "y", "volume", "style", "density", "w", "angle", "input", "deep", "high", "padding", "img", "gap", "html", "above", "arrow", "bottom", "length"], "ch_attr": ["char_unit", "ch_offset", "ch_unit", "ch_attribute", "char_attribute", "chblockattr", "char_attr", "chblockunit", "chblockoffset", "char_offset", "chblockattribute"], "cx_min": ["cx_version", "cw_mid", "cx_mid", "cw_version", "cw_min", "cw_max"], "cx_max": ["cw_mid", "cw_ax", "cx_mid", "cw_min", "cw_max", "cx_ax"], "linesize": [" linespeed", "lsize", "planesize", "linessize", "linespeed", "planessize", " linessize", "lsiz", "planesiz", "linesiz", "lspeed", "lssize", " linesiz", "planespeed"], "x_incr": ["x_decp", "x_increp", "x_incrers", "x_incp", "x_increur", "x_increr", "x_intr", "x_decr", "x_intrs", "x_incrs", "x_incur", "x_decur", "x_decrs", "x_intur", "x_intp"], "line": ["lined", "mode", "source", "write", "col", "len", "position", "size", "cell", "l", "style", "range", "frame", "level", "code", "unit", "page", "w", "lin", "lines", "e", "block", "lc", "pos", "le", "name", "length"], "line1": ["lin1", "Line1", "line0", "lin0", "Line0", " line0"], "offset": ["reset", "port", "adjusted", "entry", "id", "count", "type", "usage", "url", "address", "angle", "page", "online", "sync", "limit", "enabled", "gap", "num", "set", "phase", "slot", "format", "abi", "end", "col", "info", "optional", "off", "style", "skip", "scroll", "append", "start", "api", "ui", "adjust", "o", "pointer", "index", "error", "shift", "ptr", "option", "position", "update", "no", "location", "slice", "attribute", "addr", "layer", "data", "exclusive", "flag", "notation", "alias", "align", "base", "alpha", "margin", "Offset", "row", "layout", "image", "size", "alt", "part", "origin", "area", "padding", "outer", "pos", "length"], "fgcol": ["fxcolor", "fgcolor", "fgCol", "cfgcol", "fxblock", "bgblock", "fgblock", "cfgblock", "bgcolor", "cfgCol", "fxCol", "fxcol", "cfgcolor", "bgCol"], "bgcol": ["bluecolumn", "bluefl", "fgcolumn", "fgCol", "wxfl", "bluecol", "wxcolumn", "blueCol", "bgfl", "bgcolumn", "wxCol", "fgfl", "wxcol", "bgCol"], "v": ["x", "b", "V", "n", "volt", "value", "vs", "z", "sv", "ve", "j", "lv", "av", "vp", "vt", "r", "nv", "g", "position", "ov", "vol", "l", "volume", "ver", "version", "p", "m", "conv", "t", "vert", "u", "w", "ev", "vv", "k", "view", "e", "gu", "c", "f", "i", "tv", "val", "va", "q", "vi", "iv", "video", "uv"], "cursor_offset": ["cairo_off", "cairo_ptr", "cairo_offset", "cairo_pos", "cursor_pos", "cursor_off"], "d1": ["D2", "ds1", "f1", "d2", "ds2", "f2", "D1"], "d": ["x", "dir", "dist", "dc", "D", "direction", "source", "dy", "g", "l", "p", "draw", "m", "dp", "di", "u", "w", "desc", "e", "c", "start", "f", "ds", "out"], "src": ["b", "dist", "bl", "sl", "source", "filename", "crop", "text", "sub", "image", "rb", "attr", "url", "slice", "config", "origin", "rc", "input", "reverse", "loc", "sup", "start", "img", "data", "st", "bg"], "dest": ["dir", "dist", "dep", "Dest", "dc", "path", "source", "direction", "text", "done", "dim", "coord", "url", "origin", "dev", "comb", "route", "di", "vert", "desc", "txt", "img", "cb"], "cursor_ptr": ["cursor2pad", "cursor_pad", "cairo_pointer", "cairo_ptr", "cairo_offset", "cursor2pointer", "cursor2offset", "cairo_pad", "cursor2ptr", "cursor_pointer"], "font_ptr": ["text_ptr", "text_address", "text_offset", "text_pointer", "font_pointer", "font_address", "font_offset"], "font_base": ["fontamsupport", " font_area", "font_bare", "fontlexsize", "font_ase", "file_base", "fontlexbase", "font_size", " font_size", "file_ase", "fontlexcache", "fontlexarea", "fontamspace", "fontambase", "fileambase", "fontlexformat", "fileamsupport", " font_format", "fontamase", "font_support", "file_support", "file_space", "font_cache", "fileamspace", " font_type", "fontlextype", " font_cache", "fontlexbare", "font_format", " font_bare", "font_area", "font_space", "font_type", "fileamase"], "dup9": ["dub7", "udp96", "duv96", "udp9", "dub9", "duv9", "dup96", "dub96", "dups11", "dups7", "duv11", "udv7", "udv11", "udv96", "udp11", "udv9", "dup7", "dub11", "dups96", "udp7", "dups9", "duv7", "dup11"], "line_offset": ["line_off", "lin_position", "line\u00b7offset", "line\u00b7off", "inline_off", " line_off", "line_position", "inline_base", "line_index", "line\u00b7base", "line_address", "inline_offset", "lin_address", "line\u00b7notation", " line_index", "inline_notation", "line_location", "lin_off", "line_notation", " line_location", "lin_offset", "line_base"], "palette": ["palignment", "plette", "palant", "capignment", "plettes", "Palignment", "capette", "capettes", "plant", "Palette", "plignment", "Palettes", "palettes", "capant", "Palant"], "ch_attr_ptr": ["ch_attr_tr", "ch_attr_addr", "ch_att_pointer", "ch_att_ptr", "ch_att_addr", "ch_attr_pointer", "ch_att_tr"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492, "substitutes": {"f": ["fw", "fc", "rf", "df", "fo", "proc", "func", "inf", "tf", "fd", "fs", "raf", "l", "fp", "h", "fi", "ref", "cf", "p", "fr", "m", "lf", "F", "t", "feed", "file", "e", "c", "d", "i", "af", "bf", "data", "fx", "fen", "fe", "fb", "buff"]}}
{"project": "FFmpeg", "commit_id": "2d40a09b6e73230b160a505f01ed1acf169e1d9f", "target": 1, "func": "static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    return av_read_frame(qc->fmtctx, pkt);\n\n}\n", "idx": 25501, "substitutes": {"s": ["b", "sf", "n", "a", "sc", "sv", "S", "gs", "self", "rs", "ctx", "ssl", "sb", "r", "g", "v", "src", "p", "cs", "m", "t", "u", "ns", "sg", "k", "an", "e", "c", "d", "ss", "f", "spec", "i", "ds", "data", "sq", "parts", "client", "ses"], "pkt": [" packet", " pet", "mnt", "nk", "pnt", "pk", "nkt", " pk", " pkg", "packet", "pkg", "Pkg", " pnt", "Pk", "met", "mkt", "Pet", "Packet", "pet", "nacket", "macket", "Pnt", "Pkt", "nkg"], "qc": ["klc", "Qlc", "dqlc", "cfcu", "Qdc", "qtc", " qdc", "cfpc", "Qci", "dqdc", "qcu", " qlc", "qpc", "kpc", "qdc", "kc", "qtpc", "dqc", "qtcu", "qci", "qlc", "cflc", "dqci", "kcu", "qtlc", "cfc", " qci", "Qc"]}}
{"project": "qemu", "commit_id": "30d335d68d93705eb346387c03bb6aca0f52454a", "target": 1, "func": "static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n\n                                           const char *devaddr,\n\n                                           const char *opts)\n\n{\n\n    PCIDevice *dev;\n\n    DriveInfo *dinfo = NULL;\n\n    int type = -1;\n\n    char buf[128];\n\n    PCIBus *bus;\n\n    int devfn;\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", opts)) {\n\n        if (!strcmp(buf, \"scsi\"))\n\n            type = IF_SCSI;\n\n        else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 25505, "substitutes": {"mon": ["date", "mini", "mun", "mid", "un", "normal", "home", "pal", "mt", "thin", "mn", "ko", "MON", "mer", "monitor", "gin", "pin", "col", "connection", "non", "prem", "bo", "mat", "mc", "day", "dom", "session", "master", "boot", "vol", "mu", "tom", "conn", "part", "con", "mr", "mo", "plan", "lock", "m", "man", "mail", "cmd", "atom", "amon", "month", "bug", "lin", "my", "fun", "Mon", "an", "lo", "meter", "block", "module", "msg", "mm", "ann", "mount", "bean", "pos", "reg", "min", "user", "mit", "mag", "bin", "mi"], "devaddr": ["evname", "diffaddress", "devicename", "evAddress", "appaddress", "diffAddress", "evfn", "devicefn", "appaddr", "devaddress", "deviceAddress", " devname", "devname", " devref", "deviceref", " devaddress", "evaddr", "difffn", "deviceaddr", "evlen", " devlen", "devref", "devlen", "evaddress", "devAddress", "appfn", "devicelen", "diffaddr", "evref", "deviceaddress"], "opts": ["OPouts", "optgs", "opTS", "opcs", "optTS", " optgs", "OPted", "optts", " ops", "OPt", " optr", "ops", "iopts", "opth", "optters", " opted", "opouts", "opttr", "optr", " opgs", "opters", "iopTS", " opters", " opouts", "iopt", "OPters", "OPts", "optth", " opth", "OPtr", "OPTS", "iopcs", "OPcs", "optouts", "opted", "opgs", "optcs", "optted", " opt", "optt", "opt", " optts", " optth"], "dev": ["prop", "dist", "mod", "dc", "ch", "error", "conf", "driver", "prof", "err", "ve", "debug", "id", "fo", "valid", "req", "lib", "test", "rad", "info", "cache", "dom", "result", "DEV", "vol", "serial", "root", "compl", "conn", "priv", "off", "ver", "app", "di", "nov", "def", "pub", "ev", "fail", "device", "bug", "Dev", "var", "kick", "comment", "die", "good", "gu", "block", "dd", "kind", "d", "ani", "diff", "data", "adv", "pos", "user", "client", "development", "dem", "prom", "temp"], "dinfo": ["dINFO", "ninf", "dcconf", "dayINFO", "dsafe", "dhinf", "disnow", "ddiff", "dfi", "dderror", "ffi", "dsfo", "disinf", "ninfo", "finfo", "ndINFO", "dcInfo", "DInfo", "dconf", "lderror", "linf", "finf", "dlINFO", "dsinfo", " dinit", "aderror", " dinf", " dconf", " dfi", "dninfo", "dnow", "dnhelp", "lfo", "disINFO", "adinf", "dhinfo", " dfo", "dinf", "dserror", "dlinfo", "nfo", "ndinfo", "nfi", "ddinfo", "pdsafe", "dcinfo", "ldinf", " dINFO", " ddiff", "ddinf", "ddInfo", "ndinf", "lInfo", "dcerror", "disinfo", "addiff", "ffo", " dhelp", "fInfo", "dlinf", "pderror", "dayinf", "dddiff", "pdinfo", "ldsafe", "pdinf", " dsafe", "dlnow", "Dinf", "dinit", "dsinf", "dhhelp", " dInfo", "dfo", "ddconf", "dhINFO", " derror", "linfo", "ndinit", "dnINFO", "lerror", "Dinfo", "dninf", "dhelp", "dInfo", "dayinfo", "derror", "dayinit", " dnow", "ldinfo", "adinfo"], "buf": ["b", "cap", "pb", "bl", "box", "path", "home", "base", "blocks", "vec", "lim", " bc", "bc", "bang", "bh", "func", " aux", "text", "fam", "ctx", "bid", "fd", "bo", "rb", "raf", " bu", "br", "cv", "wb", "result", "cas", "la", "bt", "url", "src", "brace", "config", "batch", "bu", "alloc", "queue", "conv", "ab", "cmd", "rc", "buffer", "bed", "mac", " b", "feat", "feed", " buff", "loc", "uc", "bag", "seq", "bound", "cb", "tab", "aux", "data", "uf", "ff", "Buff", "runner", " buffer", "pad", "fb", "buff"], "bus": ["b", "coll", "port", "loop", "box", "li", "pl", "front", "proxy", "driver", "base", "bc", "pu", "home", "http", "proc", "lib", "bid", "pull", "bo", "board", "host", "bs", "cache", "session", "Bus", "boot", "lab", "root", "serial", "mot", "io", "conn", "hub", "BUS", "las", "config", "pass", "lock", "local", "device", "bug", "plug", "die", "feed", "block", "bridge", "gen", "cat", "serv", "mount", "usb", "pos", "us", "class", "bin", "used"], "devfn": ["devln", "evname", " devln", "devicename", "Devfp", "evln", "evfn", "devicefn", "DevFN", "deffp", "devf", " devname", "devname", "divname", "Devf", " devFN", "divfd", "pubf", "devicefd", " devfd", "evlen", "divfp", " devf", "pubfn", "devlen", "divfn", "pubfp", "pubFN", "devfp", "deviceln", "deffn", "deflen", "devicelen", "devn", " devfp", "defname", " devn", "devfd", "divln", "devFN", "Devfn", "devicen", "divn", "defln"], "scsibus": ["scsgisu", "scpsibus", " scssibus", "scosibus", "scsasi", "scosbis", " scsis", " scssis", "Scssibus", "scssisu", " scssbis", "scsis", "scosisu", "scsbis", "Scsidi", "Scssisu", "scsidi", "scrsidi", "scsisu", "scssis", "scrsasi", "Scsasi", "Scssidi", "scsgidi", "scssidi", " scsisu", "Scsisu", "scpsis", " scssisu", "scssbis", "scpsisu", "scsgasi", "scrsisu", "scpsbis", "scssibus", "Scsibus", "Scssasi", "scsgibus", "scssasi", "scosis", "scrsibus", " scsbis"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510, "substitutes": {"eeprom": [" eppram", "eeprm", "emprom", "peefram", "pseeprom", "pseegrm", "eegrome", "peepron", "eefram", "eppron", "eefrim", "eefrome", "empram", "pseegram", " epprom", "eefrm", "eEpchrom", " eaprom", "eefron", "eEprom", "eeprim", "peefrom", "eegrom", "epprm", "pseeprm", " epprim", " eppron", "peeprm", "eegram", " eaprod", "pseepram", "epprome", " eeprod", "eefrom", "emprm", "eegrm", "pseegrome", "peefrm", " eapchrom", " eepram", "eapron", "pseeprome", "eepsrod", "eaprom", "eepschrom", "peepram", "eEprod", "epprim", "eEpron", "eepsrom", "eaprod", "eeprome", "epprom", "eepram", "emprim", " eapron", "eapchrom", " eepchrom", "eepron", "empron", " eepron", "pseegrom", "peefron", "eepsron", "eppram", "eeprod", " eeprim", "peeprom", "eepchrom"]}}
{"project": "qemu", "commit_id": "f3172a0e2e7bd983cada19f11d9bb59400e0dd3d", "target": 0, "func": "static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)\n\n{\n\n    MilkymistSysctlState *s = opaque;\n\n\n\n    trace_milkymist_sysctl_memory_write(addr, value);\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_GPIO_OUT:\n\n    case R_GPIO_INTEN:\n\n    case R_TIMER0_COUNTER:\n\n        if (value > s->regs[R_TIMER0_COUNTER]) {\n\n            value = s->regs[R_TIMER0_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer0: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER0_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer0, value);\n\n        break;\n\n    case R_TIMER1_COUNTER:\n\n        if (value > s->regs[R_TIMER1_COUNTER]) {\n\n            value = s->regs[R_TIMER1_COUNTER];\n\n            error_report(\"milkymist_sysctl: timer1: trying to write a \"\n\n                    \"value greater than the limit. Clipping.\");\n\n        }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n", "idx": 25515, "substitutes": {"opaque": ["OPac", " opca", "OPc", " opaques", "opac", "operca", "OPca", "opsc", "opsaque", "operaques", " opac", "operac", "OPaque", "operc", " opc", "opca", "opsaques", "opc", "opaques", "operaque"], "addr": ["port", "hash", "driver", "env", "mode", "expr", "id", "fd", "asm", "url", "ref", "oa", "p", "grad", "address", "socket", "usr", "ha", "bridge", "rr", "adder", "name", "x", "buf", "worker", "slot", "host", "add", "rg", "anne", "kt", "prefix", "arg", "node", "ad", "Address", "pointer", "ext", "offset", "site", "proxy", "ace", "len", "ptr", "pkg", "hl", "dr", "attr", "src", "config", "code", "route", "cmd", "channel", "vr", "wr", "mac", "hop", "rt", "seq", "layer", "data", "org", "adr", "cap", "alias", "align", "aug", "func", "href", "ack", "ip", "coord", "alt", "work", "xp", "ld", "ar", "md", "forge", "loc", "cb", "pos", "ord", "eth", "pad", "handle"], "value": ["port", "entry", "child", "home", "id", "rule", "description", "count", "write", "create", "fee", "function", "type", "result", "complete", "json", "address", "match", "device", "scale", "view", "ha", "limit", "Value", "multiple", "xml", "name", "native", "array", "key", "set", "parent", "format", "valid", "end", "connection", "wa", "flow", "gi", "off", "large", "buffer", "capacity", "node", "start", "val", "join", "offset", "index", "message", "test", "non", "none", "current", "total", "money", "position", "update", "model", "get", "root", "no", "resource", "cost", "two", "m", "password", "example", "unit", "w", "now", "age", "output", "data", "values", "server", "weight", "member", "php", "source", "reference", "VALUE", "image", "number", "size", "alt", "command", "v", "work", "version", "multi", "one", "paid", "sample", "component", "content", "memory", "length"], "s": ["js", "b", "scope", "in", "S", "rs", "ssl", "sb", "fs", "g", "states", "hs", "p", "args", "u", "sets", "si", "sync", "xs", "sq", "as", "native", "n", "qs", "set", "secondary", "conf", "gs", "aws", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "stat", "o", "stats", "site", "its", "sf", "sites", "full", "session", "ts", "is", "y", "m", "sym", "sg", "f", "ds", "server", "ses", "sys", "sl", "uns", "r", "ins", "iss", "ns", "settings", "d", "ls", "services", "comments", "us", "se"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_mallocz(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avcodec_get_frame_defaults(frame);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    return frame;\n\n}\n", "idx": 25526, "substitutes": {"frame": ["hide", "base", "value", "ace", "hole", "property", "scene", "body", "dy", "none", "row", "board", "function", "image", "flow", "feature", "position", "result", "cycle", "framework", "boot", "fp", "iframe", "slice", "cf", "part", "ce", "instance", "code", "fr", "ze", "line", "buffer", "scale", "Frame", "setup", "e", "point", "flo", "c", "element", "f", "component", "length", "object", "next", "data", "val", "call", "frames", " Frame", "video", "pointer", "fram", "fb"]}}
{"project": "FFmpeg", "commit_id": "ed1a6878564a97e67e5fe3a25bc099208cfed024", "target": 1, "func": "static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n", "idx": 25530, "substitutes": {"dst": ["sdconst", "sdst", "dssrc", "jcast", " dcast", " dconst", "dsc", "idST", "dsp", " dST", "rdST", "adst", "ddest", " dsp", "dsrc", "dsts", "dconst", "idsts", "dost", "rdst", "idst", "sdcast", "cdsrc", "cdsts", " dsrc", "ldsts", "dST", "sdsp", "cddest", " ddest", "dssts", "adsp", "ldst", " dsts", "jsp", "rdsts", "adsts", "rdost", "jconst", "dcast", "dsdest", "ldsp", "dsst", " dost", "cdst", "jst", "adsc", "ldsc", "idost", " dsc"], "src": ["b", "fc", "in", "sr", "rank", "sc", "source", "stack", "cc", "inf", "sub", "ctx", "sb", "ssl", "asc", "rb", "record", "attr", "cv", "url", "ins", "config", "scan", "sort", "rest", "tmp", "conv", "inst", "expl", "rc", "reverse", "desc", "loc", "uc", "sup", "img", "spec", "sec", "kk", "sq", "sn", "dest", "usc", "st", "scl", "support"], "mask": ["weight", "rec", "key", "sc", "filter", "conf", "allow", "card", "flags", "shape", "shadow", "count", "cc", "shift", "ack", "Mask", "info", "patch", "group", "fac", "asm", "black", "ask", "work", "fix", "check", "sk", "skip", "scan", "label", "pass", "arr", "pack", "lock", " img", "m", "match", "clear", "mac", "comment", "scale", "cover", "hack", "block", "inc", "img", "delay", "map", "qa", "reg", "sign", "flag", "bit", "mark", "sum"], "w": ["x", "fw", "wn", "weight", "n", "win", "aw", "wt", "z", "iw", "ow", "end", "ew", "W", "wa", "window", "r", "ww", "wb", "max", "l", "work", "v", "h", "wx", "y", "kw", "wd", "p", "m", "t", "wcs", "wall", "u", "k", "c", "wh", "d", "f", "q", "tw", "sw"], "acc": ["contract", "fc", "weight", "rec", "dc", "aa", "alpha", "sc", "AC", "card", "aug", "conf", "anc", "shape", "allow", "ac", "cc", "ace", "eff", "inf", "abi", "test", "ack", "asc", "rac", "ass", "g", "cache", "circ", "result", "fac", "attr", "asm", "ask", "enc", "config", "app", "batch", "pass", "pack", "comb", "ACC", "access", "u", "rc", "acl", "mac", "complex", "comment", "ak", "gain", "effect", "uc", "inc", "c", "sup", "amp", "f", "account", "Acc", "CC", "ann", "qa", "sign", "abc", "order", "a"], "i": ["ai", "x", "index", "b", "oi", "isin", "li", "pi", "n", "in", "ie", "key", "iii", "id", "j", "abi", "yi", "info", "iu", "hi", "ix", "gi", "ri", "bi", "l", "v", "ti", "y", "mu", "io", "fi", "uri", "xi", "ini", "inner", "p", "qi", "m", "zi", "di", "I", "t", "s", "u", "it", "ii", "init", "k", "si", "e", "c", "uli", "d", "start", "f", "lc", "cli", "ui", "phi", "ci", "o", "ni", "ji", "a", "mi"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549, "substitutes": {"base": ["b", "reset", "buf", "path", "vs", "bc", "byte", "net", "inet", "ace", "end", "aos", "full", "ctx", "len", "info", "r", "ba", "ip", "up", "fs", "cache", "ix", "bi", "es", "work", "fp", "root", "real", "be", "au", "v", "py", "area", "p", "gb", "weak", "core", "Base", "ada", "address", "buffer", "po", "e", "c", "seq", "f", "obe", "bf", "server", "out", "en", "used", "as"], "env": ["network", "enable", "context", "scope", "que", "path", "ch", "vs", "energy", "z", "state", "eu", "nc", "net", "conf", "inet", "environment", "er", "end", "ctx", "sb", "cache", "inv", "es", "v", "y", "conn", "h", "oa", "enc", "config", "p", "core", "exc", "iss", "ev", "ex", "w", "init", "si", "settings", "e", "ea", "c", "ey", "eni", "ec", "f", "ep", "np", "viron", "en", "ses"], "s": ["js", "b", "sc", "S", "rs", "ssl", "sb", "fs", "g", "states", "sis", "p", "socket", "u", "si", "sync", "sq", "en", "n", "qs", "conf", "state", "gs", "es", "l", "cs", "t", "su", "e", "c", "ss", "spec", "o", "client", "its", "sf", "sites", "vs", "z", "secure", "session", "ts", "secret", "is", "y", "sk", "m", "sym", "w", "sg", "f", "ds", "q", "server", "ses", "sys", "sl", "os", "ctx", "r", "ps", "v", "south", "ns", "settings", "d", "i", "ls", "services", "us"], "iomemtype": ["iomeartype", "iomEMtype", "iomEMtypes", "iopemTYPE", "iomhemval", "loveartype", "iopademtype", "iomearval", "voceltypes", "iomelid", "lovemid", "iomertype", "iomimertype", "iomhemTYPE", "iomeltypes", "iomhemtype", "iomimertypes", "iomelval", "iomemstyle", "iomimerrole", "vocemtype", "iomademTYPE", "lovearid", "vocemType", "iomelrole", "iomEMTYPE", "iomemtypes", "lovearval", "iomemType", "iomearid", "vocelrole", "iomerrole", "iopemtypes", "iopademTYPE", "vocelType", "iomemTYPE", "iomelType", "iopademstyle", "lovemval", "iopemstyle", "iomearType", "iomertypes", "lovemType", "iomademstyle", "iomademtype", "iomEMstyle", "iopemtype", "iomeltype", "iomemrole", "iomemval", "iomemid", "iomhemType", "iomhemid", "iomerType", "vocemrole", "iomhemtypes", "iomhemstyle", "lovemtype", "iomimerType", "lovearType", "iopademtypes", "vocemtypes", "iomademtypes", "voceltype"], "qi": ["ai", "iq", "dq", "li", "shi", "qs", "sci", "ace", "req", " q", "qq", " iii", "ctx", "yi", "gui", "ahi", "qt", "esi", "bi", "mu", "fi", "ce", "cf", "query", "xi", "config", "p", "zi", " ni", "iaz", "qua", "chi", " ki", "ii", "qv", " ii", "jp", "si", "c", "agi", "eni", "i", "cli", "q", "aq", "pai", "sq", "ci", "fen", "qa", "ni", "ei"]}}
{"project": "qemu", "commit_id": "4a917c39aed9ad7f648c435204a6586c4ca3f2f2", "target": 0, "func": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25550, "substitutes": {"opts": ["opsts", "obts", "obls", "edTs", "opps", "obtics", "opter", "edts", "optts", "optics", "OPt", "popsts", "opte", "ops", "optps", "popments", " opter", "obs", "opments", "obt", "opTs", "optd", "catps", "opls", "optTs", "catts", "catte", "oprs", "popps", "otrs", "optls", "optrs", "opttd", "OPns", "OPts", "optte", "otsts", "popts", "obTs", "optns", "OPter", "OPs", "edls", "opttics", "otments", "obrs", "cattd", "edtics", "optter", "popte", "opns", " opments", " opns", "poptd", "poprs", " opsts", " opt", "optt", "opt", " oprs", "otts", "OPrs"], "new_opts": ["new_OPt", "new_OPps", "new_optps", "new_operts", "new_OPs", "new_operps", "new_opers", "new_ops", "new_opert", "new_opt", "new_optts", "new_opps", "new_OPts", "new_optt"], "name": ["network", "cap", "alias", "n", "key", "path", "parent", "base", "id", "space", "connection", "host", "word", "ip", "size", "type", "new", "no", "part", "named", "options", "m", "nam", "address", "prefix", "w", "names", "ame", "Name", "active", "time", "call", "o", "client", "NAME", "nm", "temp"], "vlan": ["vnet", " vnic", "qpn", "msl", " vsl", "jni", "nvpn", "jLAN", "jlan", "vnic", "nvnet", "vni", "mni", "qlan", " vpn", " vnet", "nvlan", " vLAN", "jsl", "vLAN", "mlan", "vsl", " vni", "nvnic", "qnic", "mLAN", "vpn", "qnet"], "sock": [" sick", "socks", "pock", " sck", "Socker", "Sock", "spvc", "spick", "pocks", "socker", "spock", "Sink", "sick", " socker", "sck", "Sck", "pick", " sink", "Socks", "pvc", "sink", "spocks", " svc", " socks", "svc"], "group": ["coll", "scope", "context", "mod", "key", "parent", "gr", "id", "note", "gh", "count", "GROUP", "roup", "host", "g", "size", "number", "ip", "type", "band", "field", "cost", "part", "style", "range", "config", "sort", "label", "version", "password", "company", "package", "force", "where", "guard", "family", "gu", "Group", "module", "gg", "gap", "global", "mask", "user", "groups", "order"], "port": ["index", "prop", "mod", "key", "value", "id", "project", "direction", "PORT", "count", "phone", "interface", "timeout", "ort", "host", "ip", "op", "number", "position", "type", "pid", "Port", "options", "pool", "config", "range", "priority", "version", "service", "p", "route", "address", "ports", "hop", "target", "time", "point", "limit", "import", "pos", "method", "length", "offset"], "mode": ["depth", "dir", "ward", "mod", "key", "lan", "driver", "id", "direction", "ace", "position", "size", "model", "dim", "type", "move", "max", "rate", "command", "slice", "style", "role", "range", "priority", "level", "version", "m", "route", "line", "cmd", "month", "MODE", "device", "md", "language", "scale", "time", "module", "delay", "lane", "mm", "grade", "Mode", "mask", "order", "step", "slave"]}}
{"project": "FFmpeg", "commit_id": "f57b00e89749b559da7cd99a4b630c90617e17d4", "target": 1, "func": "static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n\n{\n\n    int i = 0;\n\n    while (ff_id3v2_extra_meta_funcs[i].tag3) {\n\n        if (!memcmp(tag,\n\n                    (isv34 ?\n\n                        ff_id3v2_extra_meta_funcs[i].tag4 :\n\n                        ff_id3v2_extra_meta_funcs[i].tag3),\n\n                    (isv34 ? 4 : 3)))\n\n            return &ff_id3v2_extra_meta_funcs[i];\n\n        i++;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 25557, "substitutes": {"tag": ["date", "prop", "num", "year", "key", "TAG", "pair", "id", "text", "test", "token", "category", "patch", "feature", "word", "tail", "type", "attr", "ref", "code", "atom", "match", "prefix", "attribute", "bug", "comment", "feat", "loc", "block", "param", "val", "call", "cat", "reg", "Tag", "name", "class", "length"], "isv34": ["isuv34", "isuv31", "risv34", "risv31", "risvv31", "isv33", "isu36", "isv339", "risv349", "isvs35", "isv36", "ISv34", "isf33", "isV33", "isV34", "isV349", "isuv339", "risvv339", "isvv31", "isf35", "Isv33", "isvv34", "isv349", "Isvp35", "ISv35", "isV35", "Isvp349", "risvv34", "isvp33", "risvv349", "ISv36", "Isv349", "isvs34", "ISV33", "Isv35", "isvv339", "isv31", "risv339", "isV36", "isvs31", "isvv349", "isv35", "isu33", "isvp34", "ISV35", "Isv34", "ISV36", "isu34", "isf36", "isvs339", "Isvp33", "Isvp34", "isuv349", "ISV34", "isf34", "isvp35", "ISv33", "isvp349", "isvs349", "isu35", "isvs33"], "i": ["ai", "index", "b", "x", "oi", "li", "pi", "iii", "ie", "key", "j", "abi", "yi", "info", "iu", "ip", "g", "ix", "gi", "bi", "l", "v", "ti", "io", "slice", "y", "mu", "uri", "xi", "ini", "multi", "p", "qi", "m", "di", "I", "t", "ski", "u", "init", "ii", "si", "e", "c", "uli", "d", "start", "f", "adi", "api", "ui", "phi", "ci", "o", "ni", "ri", "a"]}}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}", "idx": 25566, "substitutes": {"buffer_filter": ["buffer_fil", "buffer_force", "buffer0finder", "bufferlexset", "bufferlexcontext", "queue_proxy", "callback_finder", "bufferwfil", "thread_fil", "bufferlexfilter", "buffervfilter", "thread_handler", "callback_fil", "buffervfil", "buffer_handler", "buffer_set", "callbackvfinder", "buffer0filter", "bufferwcontrol", "code_filter", "code_find", "buffer_ref", "callbackvfil", "thread_filter", "buffer0control", "buffer_finder", "buffervcontrol", "buffer_control", "bufferwfinder", "bufferwfilter", "code_force", "buffer_find", "bufferlexproxy", "buffer_proxy", "buffervfinder", "buffer_slice", "buffer_context", "queue_filter", "queue_context", "thread_slice", "callback_control", "callbackvcontrol", "code_ref", "queue_set", "callbackvfilter", "buffer0fil", "callback_filter"], "picref": ["icdef", "busdef", "pinurl", " picconfig", "icREF", "icreference", "picalf", "bcref", "pcdef", "nicRef", "picREF", "busval", "picval", "Picconfig", "busref", "pinconfig", "nicref", "pinreference", "pcref", "nicdef", "nicval", "bcRef", " picRef", " picalf", "pcRef", "bcalf", "bcreference", "nicfilter", "picconfig", "picreference", " picurl", "Picurl", "pitcol", "picdef", "nicurl", "piccol", " picreference", "Picreference", "pinref", "icref", "picurl", " picfilter", "macurl", "macreference", "macref", "nicREF", "pitreference", "busRef", "nicreference", " picalt", "pitalt", "pincol", " piccol", "icRef", "picRef", "pinalt", "macfilter", "picalt", "pcval", "pitref", "icalf", "Picref", " picdef", " picREF", "picfilter"], "flags": ["nl", "lag", "sf", "status", " bits", "bits", "ops", "Flags", "fee", "fd", "fs", "caps", "ags", "fields", "options", "files", "rets", "vals", "styles", "features", "s", "args", "lf", "alls", "ats", " fs", "fun", "lines", "ils", "utils", "settings", "rules", "bugs", "types", "checks", "fx", "parts", "mask", "books", "flag", "plugins", "planes", "locks", "FLAG", "stats", "ants", "fl"], "c": ["b", "coll", "context", "dc", "ch", "xc", "sc", "conf", "bc", "ca", "self", "cc", "ac", "cp", "cy", "ctx", "mc", "cache", "g", "cv", "l", "v", "conn", "ce", "cf", "enc", "con", "icc", "config", "oc", "vc", "p", "cl", "cs", "m", "cr", "tc", "t", "u", "C", "rc", "cm", "ctrl", "ct", "w", "k", "e", "exec", "uc", "d", "f", "pc", "lc", "ec", "call", "cat", "co", "cu", "ci", "o", "cur"], "buf": ["b", "port", "box", "home", "bc", "bh", "fd", "cache", "result", "ref", "brace", "alloc", "gb", "ff", "bg", "cur", "fb", "pb", "vec", "fat", "cp", "rb", "raf", "job", "fp", "off", "pool", "tmp", "obj", "rc", "buffer", "feat", "plug", "feed", "img", "bf", "val", "runner", "bin", "proc", "len", "pkg", "br", "fi", "cf", "src", "config", "queue", "cmd", "seq", "f", "str", "data", "uf", "Buff", "buff", "cap", "func", "ctx", "wb", "cv", "cas", "la", "bd", "ab", "fun", "loc", "uc", "bag", "cb", "aux", "lb"], "ret": ["reset", "run", "sr", "id", "RET", "over", "result", "mem", "ref", "rets", "match", "att", "re", "art", "pat", "en", "repl", "cur", "num", "reply", "err", "debug", "format", "let", "red", "nt", "rb", "job", "al", "rev", "ft", "obj", "rc", "arg", "af", "bf", "val", "pet", "cat", "out", "bit", "ext", "rf", "error", "value", "lib", "len", " RET", "utf", "no", "pass", "code", "def", "rt", "data", "back", "Ret", "reg", "flag", "base", "r", "fin", "alt", "det", "part", "fail", "fun", "active", "bot", "lit", "res", "success", "bad"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n", "idx": 25571, "substitutes": {"obj": ["x", "js", "oi", "n", "Obj", "id", "j", "bh", "self", "os", "xxx", "objects", "ctx", "ref", "src", "obb", "bj", "arr", "tmp", "p", "act", "args", "inst", "init", "Object", "po", "pty", "active", "this", "txt", "fn", "pt", "bot", "xs", "img", "object", "str", "data", "q", "pos", "o", "art", "so", "ob"], "qs": ["js", "iq", "pg", "dq", "ips", "results", "ql", "quad", "vs", "rows", "gs", "events", "rs", "req", "qq", "igs", "ctx", "fs", "bs", "qt", "ps", "points", "ts", "fields", "ks", "fts", "query", "hs", "ins", "tests", "strings", "qi", "ints", "cs", "ads", "s", "wcs", "args", "qv", "forces", "ns", "eps", "maps", "eries", "xs", "ls", "ds", "pages", "q", "str", "checks", "sq", "parts", "qa", "books", "plugins", "als", "mods"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n", "idx": 25574, "substitutes": {"ctx": ["context", "scope", "fc", "dc", "xc", "conf", "bc", "ca", "nc", "anc", "cc", "cms", "connection", "hw", "crit", "cus", "pkg", "ocr", "cache", "cv", "cas", "kw", "conn", "cf", "Context", "config", "cs", "conv", "cmd", "cn", "tc", "cm", "tx", "ct", "ctrl", "cfg", "cca", "loc", "c", "lc", "cli", "component", "cb", "cu", "ci", "qa", "client", "cdn", "cd"], "node": ["remote", "child", "id", "function", "ref", "instance", "inner", "core", "comment", "handler", "view", "sync", "document", "cdn", "name", "post", "num", "context", "native", "n", "key", "path", "parent", "live", "edge", "connection", "Node", "host", "conn", "enc", "parse", "callback", "nn", "c", "msg", "event", "client", "self", "loader", "none", "consumer", "op", "leaf", "odes", "session", "graph", "root", "no", "query", "null", "config", "route", "stage", "cmd", "this", "exec", "fn", "module", "gen", "call", "server", "source", "func", "command", "hub", "package", "loc", "nw", "component", "object", "tree", "load", "content", "global"]}}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578, "substitutes": {"vq": ["svck", "gqs", "vqs", "ivux", "Vux", "svq", " vque", "gque", "Vck", "svux", "vck", "iviq", "vQ", " vQ", "svqs", " vqs", "ivq", "vque", "gQ", "vux", "Viq", "sviq", "gq", "ivck", "viq", "svque", "Vq", "svQ"], "in": ["index", "b", "isin", "rec", "n", "din", "nin", "rin", "win", "kin", "id", "byte", "inn", "ac", "margin", "pin", "gin", "ax", "len", "In", "Out", "inas", "max", "IN", "new", "raw", "ini", "ins", "pass", "m", "again", "read", "ex", "input", "arg", "inc", "c", "d", "f", "i", "pc", "diff", "str", "data", "val", "min", "login", "qa", "name", "bin"], "out": ["index", "isin", "nin", "outs", "id", "net", "gin", "ax", "In", "token", "gt", "nt", "Out", "IN", "new", "no", "wx", "off", "OUT", "ins", "arr", "again", "cmd", "ex", "init", "doc", "inc", "diff", "str", "outer", "call", "qa", "o", " Out", "bin", "ext"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "substitutes": {"argc": ["argsf", " argn", "argsn", " argf", "argf", "argsv", "argn", "Argf", "argsc", "Argn", "Argc", "Argv"], "argv": ["argp", "Argb", " argp", "argsv", " argb", "argsc", "argsb", "argb", "Argc", "Argv", "argsp", "Argp"]}}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583, "substitutes": {"ram_size": ["memory_address", "ram_source", "gram_scale", "memory_Size", " ram_addr", "ramingshape", "gram_address", "ram_Size", "gram_source", "ramingsize", "ram_shape", "ram6Size", "ram6size", "ram_scale", "memory_size", "ram6address", "ramingc", " ram_c", "gram_size", "memory_addr", "ram_addr", "ram_address", "ram6addr", "ram_c", " ram_shape", "ramingaddr"], "boot_device": ["boot_memory", "boot_root", "kernel_root", "bootportroot", "bootportdevice", "kernel_mode", "kernel_device", "bootportmode", "kernel_memory", "bootbookroot", "bootbookdevice", "bootbookmode", "bootportmemory", "bootbookmemory", "boot_mode"], "kernel_filename": ["kernel_platform", " kernel_username", "base_platform", "base_document", "kernel_document", "kernel_url", "base_filename", " kernel_file", " kernel_platform", "base_url", "kernel_file", "kernel_username"], "kernel_cmdline": ["kernel_configLINE", "kernel_hostline", "kernel_hostLine", "kernel_configLine", "kernel_Cmdlines", "kernel_cmdlined", "kernel_cmdLine", "kernel_hostlines", "kernel_commandlin", "kernel_Cmdline", "kernel_commandLINE", "kernel_commandlined", "kernel_commandlines", "kernel_cmdLINE", "kernel_cmdlin", "kernel_commandLine", "kernel_cmdlines", "kernel_configline", "kernel_hostlin", "kernel_Cmdlined", "kernel_configlin", "kernel_hostLINE", "kernel_commandline", "kernel_hostlined"], "initrd_filename": ["initrd_url", "initnd_file", "initrt_filename", "initrdOfiles", "initnd_url", "initrd_file", "initrt_files", "initrd_Filename", "initrd_files", "initrt_Filename", "initrt_mode", "initrdOFilename", "initnd_filename", "initrd_mode", "initrdOfilename", "initrd_fp", "initnd_fp", "initrdOmode"], "cpu_model": ["cpuachandler", "cpu_mode", "cpu_location", "core_handler", "cpu_models", "pu_model", "cpuaclocation", "cpu_handler", "cpu_spec", "pu_mode", "pu_spec", "core_models", "core_location", "core_model", "cpuacmodels", "cpuacmodel", "pu_models"], "pci_enabled": ["pcc_disabled", "pcc67Enabled", "pci67Enabled", "pcc_enabled", "pki_enable", "pcc67enable", "pci_interrupted", "pcc67enabled", "pci67disabled", "pcc_Enabled", "pci67enable", "pci__enabled", "pci67enabled", "pci_loaded", "pci_enable", "pki_disabled", "pcc_enable", "pci_disabled", "pki_enabled", "pci_Enabled", "pki_interrupted", "pci__enable", "pci__disabled", "pcc67disabled", "pki_loaded"], "kvmclock_enabled": ["kvmlock_provided", "kvmlock_led", "kvmsync_disabled", "kvmclock_enable", "kvmclock_disabled", "kvmlock_enabled", "kvmclock_provided", "kvmsync_enable", "kvmclock_Enabled", "kvmsync_enabled", "kvmlock_disabled", "kvmclock_led", "kvmsync_Enabled"], "i": ["x", "b", "pi", "n", "id", "j", "proc", "r", "ip", "type", "is", "l", "v", "h", "io", " I", "p", "m", "s", "I", "counter", "k", "e", "c", "d", "f", "a"], "below_4g_mem_size": ["below_4g_mem_sum", "below_4g_memory_size", "below_4g_memory_Size", "below_4g_mem_capacity", "below_4g_memory_sum", "below_4g_memory_address", "below_4g_mem_Size", "below_4g_memory_capacity", "below_4g_mem_address"], "above_4g_mem_size": ["above_4g_mem64Size", "above_4g_mem2size", "above_4g_mem2sum", "above_4g_mem64size", "above_4g_mem2speed", "above_4g_mem_sum", "above_4g_memory_Size", "above_4g_mem_speed", "above_4g_memory_time", "above_4g_mem64time", "above_4g_mem_time", "above_4g_mem_Size", "above_4g_memory_size"], "pci_bus": ["pci_cache", "pcijbridge", "pci__bridge", "pcijboot", "pki_device", "pci_device", "pciamboot", "pci__bus", "pci_session", "pciamsession", "pki_boot", "pci__boot", "pci_lib", "pciamlib", "pci__cache", "pci_boot", "pki_lib", "pciambus", "pki_bridge", "pcijbus", "pki_cache", "pcijcache", "pki_session", "pci_bridge", "pki_bus"], "i440fx_state": ["i440fs_work", "i440fs_config", "i440fs_states", "i440plex67state", "i440plex_state", "i440plex67manager", "i440plex67config", "i440fx67data", "i440fx_manager", "i440fx_config", "i440plex_config", "i440fs_state", "i440fx_states", "i440fx_data", "i440plex67data", "i440fx_work", "i440fx67state", "i440fx67manager", "i440plex_data", "i440plex_manager", "i440fx67config"], "cpu_irq": ["cpu_irsq", "cpu_iraquest", "cpu_IRp", "cpu_pirQ", "cpu_ircle", "cpu_irqs", "cpu_irtqs", "cpu_rinsq", "cpu_irtq", "cpu_pirp", "cpu_ireQ", "cpu_pirquest", "cpu_IRqa", "cpu_rinqs", "cpu_irqa", "cpu_irquest", "cpu_rfqs", "cpu_ierquest", "cpu_irtch", "cpu_iraqs", "cpu_rfch", "cpu_rfq", "cpu_iracle", "cpu_irtsq", "cpu_pirq", "cpu_ierqs", "cpu_irch", "cpu_irep", "cpu_iraq", "cpu_ierq", "cpu_IRq", "cpu_pirqs", "cpu_rfsq", "cpu_pircle", "cpu_irQ", "cpu_IRQ", "cpu_iercle", "cpu_ireq", "cpu_rinq", "cpu_pirqa", "cpu_irp", "cpu_rinch", "cpu_ireqa"], "isa_irq": ["isa_ircle", "isa_irtch", "isa_ierqs", "isa_yrqt", "isa_irqa", "isa__irqa", "isa__irqs", "isa__irtqs", "isa_irQ", "isa_irtq", "isa_IRqa", "isa_mirq", "isa__irtQ", "isa__irq", "isa_mirqq", "isa_irtqq", "isa_irtQ", "isa_irquest", "isa_IRqs", "isa_irtqs", "isa_yrcle", "isa_irtquest", "isa_ierqt", "isa_irtqa", "isa_ierq", "isa_yrq", "isa__irtq", "isa_Irqa", "isa_ierqq", "isa_Irq", "isa_irqq", "isa_IRq", "isa__irQ", "isa_Irqs", "isa_irch", "isa_IRQ", "isa_iercle", "isa_mirqs", "isa_irqt", "isa_yrquest", "isa_irqs", "isa__irtqa", "isa_mirch", "isa_irtcle", "isa_ierch", "isa_irtqt", "isa_ierquest", "isa_IrQ"], "i8259": ["i18129", "i8139", " i0259", "i959", "i6239", "i108259", "xi6129", "xi8579", "i025", "i8579", "i864129", "i12259", "i6249", "i8199", "i108252", "i4239", "xi8129", " i8252", "i4252", "i059", "pi8129", "i6579", " i0252", "i12199", "i6129", "pi4129", "i8129", "i8169", "xi8259", "i9259", " i059", " i859", "i10859", "i7139", "pi8239", "xi6259", "i925", "pi4259", "si15199", "si8199", "i7169", "i864259", "i8249", "xi6579", "i18579", "i864249", "i0129", "xi6249", "i12169", "si8169", "i4259", "i8239", "i12139", "i7199", "si15259", "si15169", "i18259", "i6252", "i8252", "i859", "i0239", " i825", "i4129", "i825", "pi4252", "i18249", "i0252", "pi8252", "xi8249", "si8139", " i025", "i0259", "i15259", "i15199", "i15169", "i7259", "i15139", "i6259", "i10825", "i9252", "i864579", "si8259", "pi8259", "si15139", "pi4239"], "cmos_s3": ["cmos_g3", "cmos_psnd", "cmos_ggd", "cmos_csgd", "cmos_psgd", "cmos_snd", "cmos_gics", "cmos_ps3", "cmos_sics", "cmos_psics", "cmos_gnd", "cmos_csnd", "cmos_sgd", "cmos_csics", "cmos_cs3"], "smi_irq": ["smi_errquest", "smi_irag", "smi_pirq", "smi_pirquest", "smi_irqs", "smi_irg", "smi_iraq", "smi_irquest", "smi_pirqs", "smi_iraqs", "smi_pirg", "smi_errq", "smi_iraquest", "smi_errqs", "smi_errg"], "isa_irq_state": ["isa_irquire_parent", "isa_irquire_state", "isa_irquest_store", "isa_irquire_states", "isa_irq_manager", "isa_irQ_rule", "isa_irq_mode", "isa_irr_config", "isa_irp_state", "isa_irr_states", "isa_irp_rule", "isa_irq_config", "isa_irq__state", "isa_irq__states", "isa_irq__data", "isa_irqa_manager", "isa_irqrstate", "isa_irq_store", "isa_irQ_state", "isa_irQ_states", "isa_irqrback", "isa_irqrrule", "isa_irq_parent", "isa_irqa_rule", "isa_irqa_state", "isa_irr_state", "isa_irquest_states", "isa_irQ_back", "isa_irr_data", "isa_irq_back", "isa_irq__config", "isa_irq_rule", "isa_irquest_state", "isa_irp_mode", "isa_irq_data", "isa_irqrstates", "isa_irq_states"], "hd": ["dist", "dt", "df", "du", "hw", "fd", "dr", "udi", "gd", "hub", "wd", "bd", "hm", "rh", "di", "ld", "hid", "md", "vd", "dd", "pd", "hp", "cow", "HD", "ht", "xd", "dri", "cd"], "MAX_IDE_BUS": ["MAX_IDEAMUS", "MAX_ISE_US", "MAX_ISE_BUS", "MAX_ISE_DI", "MAX_ISE_LINE", "MAX_ISE_USE", "MAX_IDEAMBUS", "MAX_IDE_US", "MAX_IDEAMDI", "MAX_IDE_DI", "MAX_IDE_LINE", "MAX_IDE_USE"], "MAX_IDE_DEVS": ["MAX_IDE_DIV", "MAX_IDE_DVICE", "MAX_IDE_DEFS", "MAX_IDE_DRVS", "MAX_IDE_DIFS", "MAX_IDE_DEVICE", "MAX_IDE_DIVICE", "MAX_IDE_DFS", "MAX_IDE_DVS", "MAX_IDE_DRFS", "MAX_IDE_DV", "MAX_IDE_DRVICE", "MAX_IDE_DIVS", "MAX_IDE_DEV", "MAX_IDE_DRV"], "floppy_controller": ["floppy_design", "floppy2design", "flp_controller", "flp_design", "floppy_driver", "floppy2driver", "flp_control", "flp_driver", "floppy2controller", "floppy_control", "floppy2control"], "idebus": ["ieBUS", "inebus", "IDEBUS", "IDEBus", "ieBus", "iebus", "ideBUS", "idecache", "IDEcache", "ideBus", "ineBus", "iecache", "inecache", "IDEbus", "ineBUS"], "rtc_state": ["rtac_state", "rtac_model", "rtc_model", "rtc_states", "rtac_states", "rtac_config", "rtc_config"]}}
{"project": "FFmpeg", "commit_id": "8be23d424feea50d4ee892cdbdd6abd9a807709f", "target": 0, "func": "static av_cold int roq_decode_init(AVCodecContext *avctx)\n\n{\n\n    RoqContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n\n\n    if (avctx->width % 16 || avctx->height % 16) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Dimensions must be a multiple of 16\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    s->last_frame    = av_frame_alloc();\n\n    s->current_frame = av_frame_alloc();\n\n    if (!s->current_frame || !s->last_frame) {\n\n        av_frame_free(&s->current_frame);\n\n        av_frame_free(&s->last_frame);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n\n\n\n    return 0;\n\n}\n", "idx": 25593, "substitutes": {"avctx": ["avcb", "afwcs", "akcontext", "afcmd", "afcb", "afpkg", "akcu", "afcu", "ajpkg", "avalcmd", "avcmd", "avpkg", "abctx", "avtx", "aveconn", "afcfg", " avcontext", "vertx", "avectx", " avcf", "avalcontext", "afcontext", "ajtx", " avcu", " avcca", "avecontext", "verwcs", "abcontext", "avalctx", "avalsync", "aftx", "ajcontext", "varcu", "afcca", "ajcmp", "avesync", "avecca", "ajconn", "afcup", "abtx", "afcf", "verctx", "avepkg", "varctx", "akcfg", " avcmp", "avcu", "avcf", "avkw", "afctx", "avalcb", "avecmp", "varcup", "afconn", "avconn", "avsync", "akctx", "avekw", "afsync", "AVcontext", " avcb", "abcu", "AVcf", "varcontext", "avcmp", "ajctx", "avcup", "avecmd", "ajwcs", "vercontext", " avtx", "ajkw", "avecb", "avecup", "afkw", "avalconn", "afcmp", "avecfg", "avcfg", "avcontext", "AVcmp", "avecu", "avcca", "avwcs", "AVctx"], "s": ["js", "b", "its", "sf", "n", "qs", "sc", "vs", "S", "gs", "os", "rs", "uns", "nas", "ops", "ssl", "ctx", "sb", "fs", "g", "bs", "session", "ps", "ans", "aws", "ts", "es", "l", "sa", "v", "is", "ks", "sk", "ins", "p", "m", "cs", "t", "args", "acs", "u", "w", "sets", "ms", "ns", "sg", "si", "this", "e", "sync", "c", "ses", "d", "f", "i", "sec", "ls", "ss", "ds", "data", "xs", "services", "sq", "parts", "o", "us", "a", "sys", "as"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602, "substitutes": {"dev": ["sd", "mod", "ch", "conf", "ve", "proc", "self", "od", "hw", "rad", "sh", "private", "info", "g", "dom", "serial", "gd", "v", "conn", "priv", "cam", "dm", "di", "def", "pro", "ev", "de", "device", "md", "Dev", "w", "plug", "die", "an", "dd", "d", "ds", "data", "ad", "dem", "pad"], "p": ["b", "port", "pg", "pb", "gp", "pi", "n", "mp", "wp", "parser", "ch", "a", "php", "j", "proc", "cp", "er", "vp", "current", "sp", "r", "op", "g", "ip", "patch", "cache", "up", "pm", "ps", "pp", "l", "fp", "v", "h", "pe", "part", "py", "pre", "parse", "m", "ap", "dp", "t", "P", "u", "per", "ar", "po", "jp", "k", "process", "e", "exec", "c", "param", "d", "bp", "pc", "pd", "f", "i", "ep", "data", "api", "press", "np", "o", "tp", "lp", "post", "pa"], "s": ["js", "b", "sr", "S", "rs", "sh", "ssl", "sb", "fs", "g", "tests", "sis", "args", "u", "ms", "si", "sync", "sup", "xs", "sq", "as", "x", "native", "n", "qs", "gs", "less", "aws", "es", "l", "has", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "its", "sd", "sf", "css", "self", "ops", "full", "sp", "session", "ts", "is", "sa", "y", "m", "sym", "w", "sg", "f", "ds", "plugins", "ses", "sys", "sl", "php", "sv", "http", "ions", "os", "uns", "private", "r", "ps", "v", "ins", "ns", "d", "i", "ls", "services", "sw", "us"]}}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 25619, "substitutes": {"cpu": ["apache", "port", "gp", "vm", "proxy", "pu", "prof", "proc", "cp", "loader", "fps", "cache", "nic", "boot", "mem", "pid", "conn", "gpu", "pool", "processor", "process", "linux", "clock", "CPU", "GPU", "pc", "gnu", " CPU"], "spapr": ["spaper", "spappr", "scapm", "spAPr", "scappar", "scappr", "scapar", "SpapR", "Spaprs", "SpapeR", "spamprs", "spampr", "Spaper", "spAPR", "spaprs", "spapm", "spAPrs", "spappar", "spappm", "spAPar", "spapers", "scaprs", "spampm", "scapprs", "spapar", "Spapr", "spapprs", "scappm", "spapR", "Spapers", "spampar", "spapeR", "scapr", "spAPm"], "token": ["reset", "native", "win", "reply", "nat", "slot", "bits", "timeout", "response", "function", "prot", "session", "resp", "secret", "config", "oken", "util", "match", "callback", "socket", "protected", "target", "ok", "seq", "random", "call", "stats"], "nargs": ["numparams", "sarg", "cflags", "bparams", "sflags", "nparams", "barg", " nrows", "snparams", "numrows", "sargs", "snargs", "bargs", "narg", " narg", " nparams", "carg", "cparams", "nflags", "snflags", "numargs", "sparams", "nrows", "cargs", "brows", "snarg", "numarg"], "args": ["reply", "flags", "gs", "func", "rs", "bits", "os", "bytes", "len", "cache", "size", "states", "params", "boot", "Args", "fields", "is", "conn", "all", "options", "enc", "py", "config", "frame", "ras", "parse", "arr", "vals", "cs", "cmd", "features", "argument", "alls", "init", "var", "ns", "arg", "active", "lines", "addr", "loc", "sec", "msg", "cb", "data", "call", "serv", "parts", "res", "stats"], "nret": ["NRET", "neret", "nopt", "snRET", "ndef", "dargs", "lRET", "Npart", "Nmatch", "nRET", "nealt", "nreturn", "Nargs", " ndef", "nalt", "dreply", "dret", "nepart", "npart", " nRET", "narg", "larg", "Nret", " narg", "Nalt", "snalt", "lreturn", "snpart", " nmatch", "copt", "lopt", "ddef", "cret", "lmatch", "cRET", "creturn", "Ndef", "Nreply", "nreply", "nmatch", "neRET", " nopt", " nreturn", "Nreturn", " nreply", "lret", "snret", "Narg"], "rets": ["its", "ips", "dies", "results", "details", "errors", "qs", "reply", "outs", "vers", "flags", "rows", "proc", "bits", "rs", "fits", "RET", "nas", "bytes", "opens", "verts", "fs", "nt", "alt", "states", "secret", "ts", "mem", "fields", "jas", "fts", "grades", "tests", "strings", "vals", "ints", "features", "ails", "def", " secrets", "des", "nuts", "urs", "runs", "ils", "utils", "stores", "uts", "seq", "types", "sec", "ls", "aux", "checks", "ds", "values", "ries", "expected", "reg", "res", "Ret", "uds", "als", "nets", "groups", "bis"], "sphb": ["psmphp", "ssaphb", "ssaphbb", "fmphb", "sphab", "nsPHl", "saphl", "fmphab", "sephb", "sapha", "saphab", "smphbase", " sPhr", "scpbb", "fmphf", "sPhl", "psmphb", "saphbase", "psphp", "fmphbase", "saphB", "saphr", "smphp", "saphbb", "saphlb", "shtr", "sPHlb", "nsphlb", "sphpb", "psphr", "scpr", "fphbase", "scpB", "ssaphr", "sphabe", "sPhlb", "shtabe", "psphb", "sphB", "smphf", "sphl", "sPHa", "spha", " sphr", "nspha", " sphabe", "sphpabe", "saphp", "sPhr", " sphpart", "psmphr", " sPhabe", "sphlb", "saphb", "smphB", "sephbase", "psphB", "ssphb", "fphb", "saphf", "sPhabe", "ssphr", "sephab", "sphf", "ssaphB", "sPhpart", "sPhb", "nsPHlb", "fphab", " sPhpart", "sPha", "shtb", "ssphbb", "sphppart", " sPhb", "sphr", "sephf", "smphab", "sphpart", "ssphB", "sphpr", "nsphl", "nsPHb", "nsPHa", "smphb", "psmphB", "fphf", "sphbase", "sphp", "sPHb", "shtpart", "nsphb", "sphbb", "smphr", "sPHl", "scpb"], "spc": ["Spac", " splc", "Splc", "spp", "apd", " spd", "splc", "ppc", "SPlc", "SPC", "apf", "ppf", "prc", " spac", " spp", " spci", " spf", "spf", "apc", "SPc", "app", "SPcs", "SpC", "spci", "Spcs", "Spci", "spcs", "prp", "spac", " spcs", "ppcs", "prf", "SPci", "spd", "SPf", "prd", "ppac", "Spc", " spC", "spC", "Spf"], "buid": ["Buid", " buip", "basId", "buip", "buis", "luids", "luid", "basid", "luID", " buID", "buID", "basids", "auid", "basip", "buId", "basID", " buId", "auip", "buids", " buin", "buin", "Buis", " buids", "Buids", "auin", " buis", "basin", "bufid", "bufids", "bufId", "luis", "bufID", "BuID", "auids"], "state": ["reset", "port", "key", "status", "error", "value", "err", "id", "rule", "ace", "test", "tag", "len", "private", "nt", "STATE", "size", "type", "alt", "result", "session", "secret", "State", "states", "resource", "conn", "part", "style", "al", "store", "config", "version", "code", "rest", "address", "arg", "addr", "loc", "start", "f", "stat", "val", "str", "out", "reg", "grade", "art", "back", "ry", "name"], "ret": ["pret", "status", "reply", "value", "mt", "id", "RET", "len", "ne", "nt", "trial", "alt", "result", "resp", "secret", "job", "mem", "fi", "ref", "part", "al", "store", "rest", "match", "obj", "fun", "att", "feat", "arg", "rt", "lit", "str", "rep", "val", "pet", "data", "cat", "back", "reg", "Ret", "res", "art", "flag", "ry", "success", "re", "fire", "ext"]}}
{"project": "qemu", "commit_id": "c91e681a558fc21073ffc491b5a022d5f340fa0b", "target": 0, "func": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n", "idx": 25636, "substitutes": {"value": ["index", "num", "key", "id", "message", "count", "format", "property", "valid", "end", "timeout", "reference", "current", "VALUE", "fee", "total", "function", "image", "flow", "size", "number", "feature", "max", "type", "rate", "expression", "v", "volume", "large", "range", "one", "unit", "now", "buffer", "scale", "media", "Value", "start", "age", "val", "data", "values", "min", "server", "grade", "memory", "name", "length"], "errp": ["irop", "errcp", " errop", " errcp", " errP", "ircp", " errlp", "erop", "errc", "armlp", "erp", " errc", "errop", "rrp", "errlp", "errP", "armc", "rrlp", "irp", "armp", "rrP", "ercp", "armP", "rrc", "erP", "irP"], "s": ["b", "sf", "n", "sl", "status", "sv", "S", "gs", "rs", "os", "sb", "ssl", "fs", "ps", "states", "ts", "es", "is", "sa", "service", "p", "m", "sym", "cs", "args", "u", "ns", "si", "settings", "e", "sync", "c", "ss", "f", "ls", "ds", "services", "ses", "sys"]}}
{"project": "qemu", "commit_id": "f53f4da9c68941fe70a3ca9e3fc792c8acf69c0c", "target": 1, "func": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n", "idx": 25669, "substitutes": {"path": ["x", "prop", "relative", "n", "parent", "value", "php", "pair", "anc", "cp", "ath", "text", "python", "current", "sp", "patch", "type", "root", "l", "template", "transform", "h", "part", "enc", "config", "code", "route", "s", "package", "prefix", "Path", "w", "page", "po", "e", "point", "c", "ph", "sync", "f", "length", "str", "data", "api", "next", "pattern", "np", "pr", "method", "pat", "PATH", "name", "temp", "pointer"], "p": ["x", "b", "pb", "pi", "n", "a", "j", "cp", "pard", "vp", "sp", "r", "op", "g", "patch", "ps", "pp", "l", "fp", "v", "y", "h", "pe", "part", "pre", "m", "ap", "t", "s", "P", "u", "Path", "w", "page", "it", "po", "jp", "e", "point", "c", "bp", "pc", "i", "f", "ep", "data", "api", "np", "pr", "pos", "o", "pat", "tp", "lp", "pointer", "pa"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n", "idx": 25670, "substitutes": {"ov": ["ant", "oy", "oven", "oh", "ove", "oper", "kov", "vs", "rov", "ork", "akov", "sv", "vers", "voc", "ow", "od", "orb", "oker", "ull", "av", "ou", "op", "ever", "oo", "ocr", "cv", "ovan", "oe", "v", "ova", "OV", "off", "oa", "ver", "lov", "obb", "oc", "om", "ood", "nov", "vr", "ev", "oid", "oyer", "vo", "ol", "tv", "ovo", "raft", "opp", "iv", "o", "opt", "ott", "ob", "uv"], "iter": [" iterator", " ir", "coll", "loop", "oper", "inter", "iterator", "tri", "former", "keep", "er", "ite", "ise", "or", " inter", "chain", "enter", "ip", "Iter", "itter", "ator", "l", "v", "tr", "store", "inner", "il", "scan", "oc", "ee", "it", "init", "el", "design", "loc", "walker", "exec", "inc", "f", "gen", "gener", "ul", "str", "iv", "order", "ir"], "any": ["x", "iq", "coll", "array", "worker", "parent", "sc", "allow", "ac", "cc", "anything", "ise", "ack", "or", "none", "ait", "Any", "either", "ANY", "chain", "g", "optional", "common", "which", "ask", "all", "single", "query", "empty", "arr", "other", "one", "args", "whatever", "ar", "unknown", "ast", "sync", "inc", "pc", "can", "q", "call", "ay", "co", "each", "global", "qa", "some"], "depth": ["index", "seed", "dep", "weight", "path", "rank", "parent", "id", "debug", "stack", "cache", "dim", "root", "cost", "query", "priority", "level", "version", "reverse", "push", "input", "deep", "Depth", "delay", "round", "layer", "data", "name", "order"], "first": ["last", "must", "parent", "alpha", "error", "prev", "sc", "func", "cc", "valid", "th", "none", "header", "First", "current", "r", "catch", "only", "root", "all", "null", "instance", "empty", "p", "initial", "primary", "fr", "other", "one", "head", "latest", "missing", "c", "start", "f", "pc", "second", "next", "then", "use", "st", "name"]}}
{"project": "FFmpeg", "commit_id": "204cb29b3c84a74cbcd059d353c70c8bdc567d98", "target": 1, "func": "static av_cold int shorten_decode_close(AVCodecContext *avctx)\n\n{\n\n    ShortenContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < s->channels; i++) {\n\n        s->decoded[i] -= s->nwrap;\n\n        av_freep(&s->decoded[i]);\n\n        av_freep(&s->offset[i]);\n\n    }\n\n    av_freep(&s->bitstream);\n\n    av_freep(&s->coeffs);\n\n\n\n    return 0;\n\n}\n", "idx": 25672, "substitutes": {"avctx": ["Avcas", "afctx", "AVcas", "Avconn", "Avcontext", "avconn", "avcas", "avcit", " avcas", "AVcit", "afcmp", "ajcontext", "avcontext", "AVcmp", "ajcmp", "AVcontext", "ajcit", "Avctx", " avconn", "AVconn", " avcontext", "afcit", "avcmp", "afcontext", "ajctx", "AVctx"], "s": ["js", "b", "sf", "qs", "comm", "sc", "vs", "conf", "sv", "S", "gs", "self", "os", "rs", "ops", "ctx", "ssl", "sb", "fs", "g", "bs", "session", "ps", "ans", "aws", "ts", "es", "sa", "l", "v", "is", "ks", "p", "cs", "sym", "t", "args", "ads", "u", "ms", "ns", "sg", "si", "an", "e", "sync", "c", "d", "ses", "f", "ss", "xs", "ds", "spec", "data", "ls", "services", "sq", "sec", "parts", "als", "o", "a", "sys", "as"], "i": ["x", "ai", "index", "b", "oi", "li", "pi", "n", "z", "j", "info", "iu", "ip", "hi", "ix", "gi", "bi", "l", "ti", "v", "y", "io", "mu", "fi", "uri", "xi", "ini", "multi", "p", "qi", "m", "zi", "di", "I", "t", "u", "ii", "k", "si", "e", "c", "d", "eni", "f", "start", "q", "ui", "phi", "ci", "o", "ni", "ji", "a", "mi"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,\n\n                                         src - (stride * 2),\n\n                                         stride, dst, stride);\n\n}\n", "idx": 25693, "substitutes": {"dst": ["Drc", "sdrc", "sdst", "dsc", "sdsrc", "sdsc", "ldrc", "dsrc", "Dst", "drc", " dsrc", " drc", "ldst", "ldsrc", "Dsc", "Dsrc", "ldsc", " dsc"], "src": ["b", "dist", "gz", "sr", "sl", "sc", "rib", "cmp", "rob", "source", "supp", "lib", "sub", "ctr", "sb", "sel", "rb", "attr", "dr", "url", "slice", "sur", "config", "gb", "grad", "inst", "rc", "sync", "sup", "c", "img", "sec", "cb", "sq", "dest", "iv", "st", "bg", "cur"], "stride": ["divade", "etride", "Strip", "strided", "dride", "Strider", "brie", " strided", "etrider", " strine", "arride", "strider", " strie", "strip", "divine", "drided", "stider", "trade", "etrided", "trode", "stiden", "strie", "Stride", "driden", "bride", "Strine", "collider", "Strade", "brided", "vertade", "collided", "divided", " strider", "strine", "drider", "Strided", "brine", " strip", "arrie", "stided", " strade", "etrip", " strode", "tride", "vertider", "vertode", "stide", "collide", "divide", "arrided", "strode", "trider", "arrine", "vertide", "colliden", "striden", "strade"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    DeviceState *d;\n\n    APICCommonState *s;\n\n    uint32_t val;\n\n    int index;\n\n\n\n    d = cpu_get_current_apic();\n\n    if (!d) {\n\n        return 0;\n\n    }\n\n    s = DO_UPCAST(APICCommonState, busdev.qdev, d);\n\n\n\n    index = (addr >> 4) & 0xff;\n\n    switch(index) {\n\n    case 0x02: /* id */\n\n        val = s->id << 24;\n\n        break;\n\n    case 0x03: /* version */\n\n        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */\n\n        break;\n\n    case 0x08:\n\n        apic_sync_vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n", "idx": 25704, "substitutes": {"opaque": ["opcode", "obcode", "opac", "OPac", "OPque", "oac", "OPaque", "opque", "oaque", "OPcode", "oque", "obaque", "obac", "obque", "ocode"], "addr": ["x", "alias", "dc", "id", "byte", "slot", "ace", "sid", "ptr", "host", "add", "ip", "ix", "amd", "asm", "conn", "ref", "part", "src", "config", "arr", "arm", "route", "address", "mac", "amp", "node", "point", "dd", "seq", "data", "ad", "pos", "Address", "ord", "adr", "pad", "pointer", "offset"], "d": ["b", "sd", "does", "dc", "dos", "n", "dt", "dict", "D", "z", "id", "state", "dh", "dy", "rd", "fd", "g", "dom", "dr", "dn", "l", "ded", "did", "bd", "dB", "p", "m", "t", "dm", "ld", "dx", "di", "u", "md", "db", "e", "c", "dd", "pd", "f", "i", "Ds", "ds", "dl", "ad", "o", "dat", "cd"], "s": ["js", "b", "scope", "S", "sb", "ssl", "fs", "g", "states", "request", "hs", "tests", "p", "args", "sets", "si", "sync", "xs", "serv", "sq", "parts", "a", "as", "native", "n", "secondary", "state", "gs", "the", "es", "l", "ks", "service", "cs", "t", "su", "sie", "e", "c", "ss", "spec", "stat", "o", "stats", "site", "its", "sd", "sf", "your", "self", "ops", "session", "ts", "is", "y", "slice", "hm", "m", "sym", "w", "sg", "f", "ds", "server", "ses", "sys", "bis", "sl", "sv", "os", "r", "sts", "storage", "ps", "v", "ins", "south", "ns", "an", "settings", "i", "sec", "ls", "services", "comments", "us", "se", "sum"], "val": ["num", "bl", "pl", "sl", "rel", "value", "ret", "base", "err", "bc", "slot", "split", "valid", "eval", "col", "crit", "len", "sel", "pol", "rol", "alt", "attr", "vol", "ail", "cal", "v", "pid", "all", "ref", "part", "al", "VAL", "aval", "pre", "vals", "grad", "ee", "util", "rl", "def", "unit", "fail", "var", "el", "db", "arg", "mean", "ol", "doc", "loc", "exec", "pt", "ind", "lit", "msg", "stat", "data", "ann", "serv", "Val", "pos", "call", "reg", "cond", "mit", "fl", "sum"], "index": ["loop", "search", "column", "mode", "id", "xxx", "type", "address", "match", "page", "comment", "Index", "block", "xxxx", "name", "x", "num", "key", "path", "shape", "valid", "connection", "end", "open", "style", "node", "point", "ind", "length", "bit", "pointer", "offset", "site", "found", "error", "value", "he", "len", "option", "group", "position", "dim", "update", "mix", "slice", "config", "label", "level", "route", "input", "find", "module", "f", "lead", "date", "weight", "ticket", "alpha", "connect", "image", "size", "number", "de", "active", "loc", "inc", "element", "i", "diff", "object", "pos", "success", "fff"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 25711, "substitutes": {"host_port": [" host_address", "address_server", " host_host", "host_type", "hostblockport", "host_address", "host_host", "address_address", "hostblockserver", "address_type", "host_server", "hostblockaddress", "hostblocktype", "address_port"], "errp": ["eepp", " errP", "rorp", " errfp", " errlp", "errfp", "erp", "eelp", "erip", "errip", "rorip", "eep", "rorlp", "errlp", "errP", "eefp", " errip", "rorpe", " errpe", "errpe", "errpp", " errpp", "rorpp", "rorfp", "erpe", "erP", "rorP"], "iaddr": ["siptr", "Iass", "iext", "saddress", "siext", "xiplayer", "sAddress", "sass", "soder", "rioder", "iiaddr", "siaddr", "siaddress", " iass", "iiptr", "iass", "riaddr", "Iaddr", "iptr", "xiAddress", "ioffset", " iplayer", "sinfo", "sptr", "ioder", "soffset", "Iinfo", "sext", " iaddress", "Iaddress", "iinfo", "riaddress", "sioffset", " iAddress", "iAddress", "iaddress", "sioder", "iiaddress", "splayer", "xiaddress", "xiaddr", "iioffset", "riext", " iinfo", "iplayer"], "saddr": ["unode", "lsptr", "tsaddress", "saddress", "tsnode", " saddress", "sdr", "sdd", "smd", "Sfd", "tsalign", "sadd", "sslptr", "sad", "idd", "sindd", " sbuilder", "sfd", "semd", "sptr", " smd", "sord", "sinadd", " sdd", "Saddr", " sad", "fadd", "sinbuilder", " sptr", "seaddr", "Sptr", "ssldr", "septr", "sslfd", "Sdr", "tsaddr", "sinaddr", "lsaddr", "faddr", "snode", "salign", "ualign", " sadd", "iaddress", "ford", "faddress", "sbuilder", "lsad", " sord", "ialign", "uaddr", "iadd", "lsmd", "uaddress", "ibuilder", "ssladdr", "sead", "iord", "inode"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n", "idx": 25729, "substitutes": {"x0": ["p8", "X1", "y12", "p1", "ya1", "ex00", "y00", "x00", "x86", "p00", "y8", "Xx", "ex0", "X0", " x2", "x8", "X86", "xx", "ex8", "y86", "y2", " xx", "ex1", "ya86", "ya2", "x12", "x2", "X12", " x12", "yx", "p0", "X2", "ya0"], "y0": ["x90", " y8", "ey0", "Y0", "Y1", "Y8", "ey1", "Yx", "ry0", " y2", "y8", "ry1", " y6", "ey6", "dy6", "Y2", "y6", "xee", " y3", "y3", "x8", "x3", "xx", " yx", "dy0", "ey3", "y90", "yee", "y2", "dyee", "x2", "dy1", "eyee", "Y90", "ry90", "yx", "x6"], "x1": ["x01", "X1", "yn", "ixOne", "ix01", "xOne", "X0", "ix0", " x2", " xOne", "Xn", "yOne", " x01", "y2", "ix1", "xn", "x2", "y01", "X2", " xn"], "y1": ["xone", "z1", "ey0", "Y0", "Y1", "ey1", " yone", "zOne", "xOne", "Y2", " yOne", "ey2", "z0", "yOne", "y2", "x2", "yone", "zone"], "buf": ["b", "cap", "port", "context", "box", "bc", "vec", "fab", "text", "fam", "ctx", "ptr", "fd", "rb", "cache", "cv", "br", "Buffer", "cas", "fi", "cf", "src", "pool", "config", "queue", "alloc", "conv", "ab", "cmd", "cube", "cur", "buffer", "feat", "db", "feed", "uc", "bag", "seq", "output", "img", "cb", "aux", "data", "uf", "Buff", "runner", "fb", "buff"], "x": ["index", "b", "n", "Y", "rx", "xc", "base", "z", "xxx", "dy", "ax", "ctx", "X", "ady", "ww", "ix", "px", "l", "y", "h", "xp", "v", "xi", "xx", "p", "code", "dx", "ex", "w", "xy", "tx", "e", "c", "d", "ya", "i", "xs", "f", "yx", "ry"]}}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734, "substitutes": {"qiv": ["quenc", "questoy", "quexp", "dqiv", "qsiv", "qtiva", "erhr", "questev", "sqoc", "qhr", "qiver", "waiver", "sqiva", " qIV", "quiva", "qtirc", "qroc", "dqivist", " qov", "qerv", "phpou", "quroc", "qexp", "quIV", "waivist", "qterv", "qih", "qev", "questiv", "questoc", "quirc", " qirc", "sqiv", "quivist", " qexp", " qoy", "qou", "waiv", "qsiver", "dqoc", "waiva", "qIV", " qoc", "sqivo", "qirc", "quiv", "sqirc", "erirc", "qqiv", " qroc", "qiva", "Qoy", "quhr", "quou", "qsiva", "quiver", "phpiv", "phpIV", " qhr", "quoc", "sqerv", "qivist", " qou", "sqivist", "Qenc", "qqenc", "qqev", "quih", " qenc", "querv", "Qiv", "sqroc", "qoy", "sqih", "phpexp", "eriva", "qtiv", "quev", " qiva", "qenc", "eriv", "questenc", "Qov", " qih", "quivo", "dqivo", "qov", "qoc", "qivo", "qqoc", "questov", "qsivist"], "name": ["x", "alias", "n", "key", "path", "parent", "search", "base", "value", "entry", "id", "self", "space", "none", "known", "word", "size", "common", "type", "new", "no", "resource", "part", "named", "style", "null", "label", "code", "core", "nam", "prefix", "names", "ame", "Name", "comment", "time", "object", "data", "NAME", "class"], "qobj": ["qbh", "kobj", "eqlib", "Qorb", "dqobj", "capi", "questobject", "qcdn", "sqbj", "klib", "playobj", "wob", "qualorb", "questcdn", "kobi", "eqbh", "eqobj", "wobject", "sqapi", " qtmp", "Qobject", "questobj", " qobject", "dqorb", "sqobject", "qorb", "qapi", "quorb", "qobject", "qqobb", "kapi", "qocl", "qualob", "Qobj", "qlib", "questlib", "qbj", "qqlib", "cobj", "cocl", "eqocl", "quobj", "qutmp", "dqtmp", "qobb", "qtmp", "sqobj", "qopt", "cbh", "Qob", "eqobject", "sqobb", "kcdn", "qob", "questobi", "qqopt", "worb", "playbh", "kaj", "eqcdn", "qualobj", " qorb", "dqobject", "playocl", "qaj", "wobj", "eqopt", "questaj", "qqobj", "cobject", "cbj", "sqopt", "eqobb", "qobi", "qualobject", "playobject", "sqaj", "sqlib", "sqobi", "kobject", "quobject", "kbj"]}}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "static BufferPoolEntry *get_pool(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *cur = NULL, *last = NULL;\n\n\n\n    do {\n\n        FFSWAP(BufferPoolEntry*, cur, last);\n\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n\n        if (!cur)\n\n            return NULL;\n\n    } while (cur != last);\n\n\n\n    return cur;\n\n}\n", "idx": 25737, "substitutes": {"pool": ["buf", "coll", "port", "loop", "pg", "parent", "bc", "pair", "allow", "ca", "slot", "ac", "hole", "connection", "col", "full", "wa", "current", "row", "Pool", "board", "host", "image", "cache", "flow", "type", "work", "ref", "null", "con", "batch", "queue", "p", "cl", "lock", "container", "poll", "alloc", "buffer", "wrapper", "guard", "comment", "hop", "capacity", "block", "pc", "call", "thread", "server", "client", "memory", "ping", "pointer", "pa"], "cur": ["pub", "Cur", "coll", "unc", "dc", "sl", "ch", "prev", "keep", "sth", "always", "or", "ctr", "pull", "sel", "current", "ptr", "try", "r", "build", "cache", "cer", "result", "dr", "iter", "cont", "cor", "sur", "cf", "tr", "src", "ce", "oc", "rest", "cr", "aur", "ser", "per", "car", " Cur", "rc", "var", "ur", "first", "ar", "ct", "ah", "ok", "feed", "loc", "uc", "c", " prev", "lc", "ul", "next", "cat", "pr", " result", "client", "focus", "length"], "last": [" Last", "parent", "base", "sc", "prev", "child", "id", "self", "end", "th", "always", "or", "full", "col", "final", "current", "row", "build", "cle", "max", "cycle", "l", "worst", "cor", "tr", "empty", "cl", "code", "est", "p", "fr", "first", "latest", "old", "sync", "c", "Last", "lc", "ul", "next", "cat", "st", "nd", "se", "slave", "later"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n\n                          int *end_pos2)\n\n{\n\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n\n        s->gb           = s->in_gb;\n\n        s->in_gb.buffer = NULL;\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        skip_bits_long(&s->gb, *pos - *end_pos);\n\n        *end_pos2 =\n\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n\n        *pos      = get_bits_count(&s->gb);\n\n    }\n\n}\n", "idx": 25738, "substitutes": {"s": ["js", "b", "sf", "n", "qs", "css", "a", "conf", "S", "gs", "self", "rs", "os", "uns", "ops", "sb", "fs", "g", "side", "session", "ps", "aws", "ts", "es", "is", "h", "ks", "hs", "service", "ins", "strings", "p", "cs", "t", "w", "sets", "ms", "ns", "sg", "su", "si", "lines", "settings", "e", "sync", "c", "ss", "f", "xs", "ls", "ds", "i", "services", "sq", "us", "se", "ses", "sys", "as"], "pos": ["index", "x", "prop", "port", "Pos", "n", "pose", "count", "os", "body", "none", "len", "pres", "sp", "ass", "position", "size", "cache", "type", "ps", "no", "pid", "all", "neg", "ref", "slice", "pre", "pass", "p", "POS", "pro", "unit", "des", "def", "push", "po", "comp", "lines", "loc", "block", "doc", "pt", "start", "seq", "pc", "ss", "diff", "gen", "val", "trans", "min", "nos", "cond", "en", "pointer", "post", "offset"], "end_pos": ["end00part", "edge00pos", "END__pos", "start_pos", "end_len", "end_line", "end__len", "end__pose", "END_Pos", "edge00line", "END__Pos", "end00pos", "end2len", "end__loc", "edge_line", "start_loc", "end__position", "start_len", "END__os", "end2position", "edge_pos", "end__pos", "END_pose", "end_pose", "end_loc", "end_os", "start_position", "edge_part", "edge00part", "end__Pos", "END_os", "end__os", "end_part", "end2loc", "END_pos", "END__pose", "end_Pos", "end_position", "end00line", "end2pos"], "end_pos2": ["end_pos4", "end__position2", "end_loc2", "end__position4", "end_position1", "end__pos2", "end__pos4", "end_len4", "end_pos1", "end_position2", "end_len1", "end_po1", "end_po4", "end_pose4", "end_loc4", "end_len2", "end_position4", "end_pose2", "end_po2"]}}
{"project": "qemu", "commit_id": "0d4cc3e715f5794077895345577725539afe81eb", "target": 1, "func": "static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25741, "substitutes": {"bs": ["js", "b", "banks", "ubis", "pb", "bl", "css", "qs", "base", "vs", "bc", "blocks", "outs", "http", "gs", "bh", "bits", "os", "abi", "bb", "ubs", "bytes", "sb", "bid", "bos", "stats", "fs", "ros", "rb", "obs", "aws", "bi", "sa", "bps", "bing", "ks", "las", "ins", "gb", "cs", "lbs", "iss", "ab", "bas", "ns", "bes", "BS", "sync", "ss", "ls", "ds", "lb", "cb", "org", "us", "ses", "bis", "fb"], "sector_num": ["sectorIdsum", "sector_nam", "sector_no", " sector_um", "sectorIdnr", "sectoridno", " sector_nom", " sector_gen", "sector_gen", " sector_header", "section_num", " sector_number", "sector_nom", "sectoridheader", "sector_sum", " sector_name", "section_sum", " sector_n", "sector_header", "sectoridnumber", "sectoridnum", "sector_id", "section_name", "sector_nr", "sector_number", "sector_um", "sector_n", "sectorIdnum", "sector_name", " sector_nam", "sectorIdnumber", "section_nr", " sector_id", " sector_no", "section_number", "section_off", "sector_off"], "buf": ["b", "num", "port", "pb", "array", "path", "home", "bc", "vec", "func", "ctx", "len", "fd", "board", "rb", "wb", "Buffer", "cas", "mem", "fp", "fi", "raw", "cf", "src", "off", "bd", "pool", "batch", "queue", "alloc", "gb", "cmd", "ab", "rc", "buffer", "feat", "block", "bag", "seq", "uc", "msg", "cb", "aux", "lb", "data", "uf", "ff", "fb", "buff"], "nb_sectors": ["nb_psectors", "nb_secs", "nb_svers", "nb_teors", "nb_SEapters", "nb_tectors", "nb_slectors", "nb_desgments", "nb_veivers", "nb_sctors", "nb_seors", "nb_seces", "nb_vections", "nb_pevers", "nb_perics", "nb_sgments", "nb_SEctors", "nb_pseapters", "nb_psections", "nb_gectors", "nb_SEctor", "nb_gevers", "nb_desivers", "nb_severs", "nb_sergments", "nb_sercs", "nb_secgments", "nb_serctions", "nb_sector", "nb_servers", "nb_pegments", "nb_serics", "nb_pections", "nb_desrics", "nb_psector", "nb_veces", "nb_pectors", "nb_vegments", "nb_vecs", "nb_seapters", "nb_slegments", "nb_vevers", "nb_secctions", "nb_tevers", "nb_sections", "nb_segments", "nb_serctors", "nb_gegments", "nb_vectors", "nb_tegments", "nb_desctions", "nb_desces", "nb_sctions", "nb_desctors", "nb_verics", "nb_serors", "nb_gections", "nb_seccs", "nb_SEctions", "nb_secctors", "nb_veors", "nb_peapters", "nb_seivers", "nb_sleivers", "nb_sleces", "nb_pector"], "s": ["b", "sf", "n", "sl", "qs", "a", "state", "S", "gs", "http", "os", "space", "sb", "ssl", "r", "g", "storage", "session", "ps", "ts", "is", "sa", "v", "service", "p", "cs", "sym", "t", "ns", "si", "bis", "e", "sync", "c", "f", "i", "ss", "ls", "ds", "spec", "services", "sq", "o", "ses", "sys", "stats"], "offset": ["index", "reset", "num", "afi", "alias", "et", "set", "align", "base", "nb", "alpha", "error", "slot", "disabled", "stop", "shift", "offer", "end", "timeout", "office", "Offset", "len", "activation", "ptr", "fee", "option", "image", "position", "size", "number", "type", "operation", "esi", "location", "fp", "url", "part", "off", "skip", "origin", "area", "alloc", "route", "line", "address", "prefix", "online", "not", "addr", "loc", "block", "limit", "seq", "start", "padding", "bound", "i", "af", "rot", "layer", "api", "adjust", "pos", "o", "art", "partial", "order", "length", "pointer", "slave"], "sectors": ["apeivers", " seivers", "insectors", "vesections", "surets", "secsections", "SEctors", "alrets", "sellers", "suctors", "veivers", "sexgments", "gelements", "sexefficients", "psections", "insegments", "spesections", "suvers", "kellers", "sexctors", " selements", "sperets", "selements", "gellers", "secctions", "psectors", "seefficients", "secctors", "spegments", "spections", "SEllers", "gections", "insections", " sections", "secvers", "veefficients", "psegments", "sections", "vections", "serctors", "pserets", " segments", "apections", "sexctions", "kections", "gevers", "vectors", "kegments", "serlements", "psellers", "severs", "spevers", "secefficients", "apegments", "serets", "SEvers", "kectors", "spellers", "alllers", "insellers", "sesections", "verets", "seivers", "secgments", "alctors", "vellers", "vegments", "gegments", "segments", "gectors", "serctions", "sergments", "SEctions", "apectors", "alctions", "suctions", "secrets", "secllers", "spectors"], "sectors_per_block": ["sectors_Per_block", "sectors_for_block", "sectors_for_blocks", "sectors_per_Block", "sectors_by_length", "sectors_per32length", "sectors_by_lock", "sectors_Per_line", "sectors_per_lock", "sectors_Per_Block", "sectors_by_block", "sectors_per_line", "sectors_per_blocks", "sectors_per_length", "sectors_for_lock", "sectors_per_byte", "sectors_per32block", "sectors_for_byte", "sectors_per_unit", "sectors_per32lock"], "ret": ["et", "error", "reply", "id", "RET", "count", "len", "sel", "total", "nt", " RET", "result", "alt", "resp", "iter", "secret", "det", "conn", "ref", "part", "sur", "rev", "rets", "read", "def", "match", "rc", "fun", "att", "arg", "rt", " Ret", "rot", "seq", "sec", "lit", "str", "val", "data", "Ret", "reg", "flag", "res", "bit", "opt", "expected", "en", "success", "re", "ext"], "footer": ["owner", "scheer", "Footker", "scheier", "footker", "Footner", "owning", "sawner", "owners", "scheker", "Footers", "footner", "sawier", "footier", "Footer", "schener", "sawer", "footing", "sawker", "ownizer", "Footizer", " footing", "Footing", "Footier", "footers", "footizer", " footers", " footizer"]}}
{"project": "FFmpeg", "commit_id": "4ffe5e2aa5241f8da9afd2c8fbc854dcc916c5f9", "target": 1, "func": "static int read_old_huffman_tables(HYuvContext *s){\n\n#if 1\n\n    GetBitContext gb;\n\n    int i;\n\n\n\n    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);\n\n    if(read_len_table(s->len[0], &gb)<0)\n\n        return -1;\n\n    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);\n\n    if(read_len_table(s->len[1], &gb)<0)\n\n        return -1;\n\n\n\n    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n\n    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n\n\n\n    if(s->bitstream_bpp >= 24){\n\n        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n\n        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n\n    }\n\n    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n\n    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));\n\n\n\n    for(i=0; i<3; i++){\n\n        ff_free_vlc(&s->vlc[i]);\n\n        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);\n\n    }\n\n\n\n    generate_joint_tables(s);\n\n\n\n    return 0;\n\n#else\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"v1 huffyuv is not supported \\n\");\n\n    return -1;\n\n#endif\n\n}\n", "idx": 25748, "substitutes": {"s": ["js", "b", "in", "sc", "S", "rs", "ssl", "fs", "g", "states", "new", "request", "tests", "p", "u", "sets", "ms", "lines", "sync", "xs", "sq", "parts", "a", "n", "qs", "conf", "gs", "es", "l", "ks", "service", "cs", "t", "e", "c", "ss", "spec", "o", "stats", "site", "its", "sf", "sites", "self", "ops", "session", "ts", "is", "y", "m", "sym", "sg", "f", "ds", "data", "server", "ses", "sys", "http", "ions", "os", "uns", "r", "ps", "ins", "south", "ns", "settings", "d", "ls", "services", "us"], "gb": ["b", "gm", "bm", "gz", "gp", "abb", "gio", "gl", "nb", "bc", " bc", "Gb", "gh", "gs", "gin", " rc", " eg", " rg", "bb", " cs", "sb", "yg", "kg", "gt", "g", "gc", "mc", "bn", "gn", "gi", " db", "gd", "rg", "G", "hub", " g", "GB", "gy", "ge", "mb", "rc", "cm", "cfg", "cgi", "gam", "db", "sg", "gu", "gg", "pc", "cb", "bf", "gal", " rgb", "ci", "tg", "kb", "ga", "bg"], "i": ["x", "b", "index", "ai", "mini", "oi", "li", "pi", "n", "in", "ie", "key", "id", "j", "me", "abi", "yi", "info", "iu", "g", "ip", "hi", "mu", "ix", "gi", "bi", "l", "is", "ti", "v", "y", "io", "fi", "uri", "xi", "ini", "name", "slice", "inner", "part", "multi", "p", "qi", "zi", "t", "I", "di", "u", "it", "ii", "chi", "si", "e", "c", "d", "eni", "f", "api", "ui", "phi", "ci", "vi", "o", "ni", "ri", "a", "mi"]}}
{"project": "qemu", "commit_id": "7264961934130df50d151def5eb415efa2e28ec5", "target": 0, "func": "exynos4_boards_init_common(MachineState *machine,\n\n                           Exynos4BoardType board_type)\n\n{\n\n    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n", "idx": 25753, "substitutes": {"s": ["b", "its", "sf", "n", "sl", "sc", "state", "S", "gs", "rows", "os", "space", "rs", "sb", "fs", "r", "ows", "g", "session", "ps", "states", "ts", "es", "sa", "is", "l", "service", "p", "m", "cs", "t", " ads", "south", "machine", "ms", "su", "sg", "e", "sync", "c", "d", "sim", "f", "spec", "ss", "ds", "ings", "services", "sq", "o", "us", "ses", "sys"], "mc": ["coll", "bm", "fc", "mic", "mp", "dc", "vm", "sc", "bc", "ca", "ram", "mn", "cc", "ac", "mx", "mot", "ma", "mr", "mo", "container", "m", "man", "machine", "md", "cm", "mac", "cfg", "MC", "c", "module", "pc", "lc", "mm", "co", "mi", "Mc"]}}
{"project": "FFmpeg", "commit_id": "29d46d7bce1c67852e4c6e22605144eb32b21072", "target": 1, "func": "static void json_print_section_header(WriterContext *wctx)\n\n{\n\n    JSONContext *json = wctx->priv;\n\n    AVBPrint buf;\n\n    const struct section *section = wctx->section[wctx->level];\n\n    const struct section *parent_section = wctx->level ?\n\n        wctx->section[wctx->level-1] : NULL;\n\n\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n\n        printf(\",\\n\");\n\n\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n\n        printf(\"{\\n\");\n\n        json->indent_level++;\n\n    } else {\n\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n        json_escape_str(&buf, section->name, wctx);\n\n        JSON_INDENT();\n\n\n\n        json->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n\n        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n\n        } else {\n\n            printf(\"{%s\", json->item_start_end);\n\n\n\n            /* this is required so the parser can distinguish between packets and frames */\n\n            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n\n                if (!json->compact)\n\n                    JSON_INDENT();\n\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n\n            }\n\n        }\n\n        av_bprint_finalize(&buf, NULL);\n\n    }\n\n}\n", "idx": 25787, "substitutes": {"wctx": ["Wjc", "rcv", " wconn", "rcf", "wslc", "wci", " wcf", "wcv", "rctx", "wwcmp", "ewcv", "Wcf", " wtx", "wecmp", "owcu", "wakb", " wcmp", " wlc", "wtcontext", "fwcmp", "wtx", "wwcontext", "ewctx", "wwci", "Wcontext", " wc", "wsctx", "wacontext", "wactx", "wsconn", "wcontext", "Wctx", "fwcontext", "hcontext", "Wcmp", "wacf", "owconn", "owcmp", "wconn", " wcontext", " wcu", "Wcb", "wttx", "ewcu", "wlc", "wectx", " wkb", "wscf", "fwctx", "wc", "Wc", "waci", "webjc", " wjc", "Wlc", "wscb", "webcontext", "wtctx", "wscmp", "wwctx", "wcmp", "rcu", "ewcontext", "wacmp", "wsci", "fwconn", "hjc", "wcu", "rcontext", "wtjc", "wcb", "owctx", "htx", "ewc", "wkb", " wcv", "wscontext", "ewcmp", "hctx", "wecontext", "wcf", "webcmp", "ewconn", "rkb", " wcb", "welc", "wjc", "webctx"], "json": ["js", "coll", "context", "database", "rec", "general", "ja", "key", "parser", "wp", "parent", "value", "journal", "j", "filename", "JSON", "format", "sv", "writer", "text", "note", "source", "full", "ssl", "zip", "python", "ctx", "info", "jack", "size", "root", "serial", "kw", "job", "null", "john", "config", "service", "son", "pack", "nil", "rss", "javascript", "obj", "now", "jc", "feed", "txt", "ruby", "view", "length", "html", "java", "tree", "api", "data", "global", "server", "xml", "memory", "temp", "wire"], "buf": ["fw", "border", "context", "port", "pb", "box", "home", "base", "bc", "vec", "bh", "func", "loc", "bb", "sb", "ctx", "fd", "rb", "cache", "pkg", "wb", "result", "cv", "br", "Buffer", "job", "cas", "la", "fp", "fi", "cast", "cf", "bd", "pool", "config", "queue", "bu", "cmd", "ab", "obj", "callback", "buffer", "db", "feat", "usr", "uc", "bag", "dump", "fn", "output", "msg", "cb", "seq", "aux", "builder", "uf", "book", "Buff", "runner", " buffer", "bg", "rw", "fb", "buff"], "section": ["sect", "ie", "entry", "column", "child", "journal", "description", "header", "function", "patch", "jack", "closure", "ruction", "instance", "except", "table", "page", "block", "setting", "name", "array", "key", "set", "parent", "format", "writer", "connection", "python", "tag", "itution", "action", "article", "job", "cript", "service", "container", "Section", "definition", "small", "lc", "account", "sections", "plugin", "course", "project", "j", "cription", "environment", "test", "option", "group", "position", "sector", "chapter", "item", "config", "vision", "script", "code", "stage", "ion", "module", "layer", "ure", "uration", "server", "draft", "parser", "division", "part", "version", "area", "package", "file", "element", "sec", "component", "object", "tree", "se"], "parent_section": ["parentenchild", "parentablesection", "parentallcomponent", "parentedsection", "parentablecomponent", "ruleallsection", "parentencomponent", "ruleallchild", "parentensetting", "parent_setting", "current_section", "parentedsetting", "parentablestruct", "rule_child", "child_sector", "parentedcomponent", "parent_sector", "child_option", "parentensection", "parent_component", "current_sector", "child_section", "current_struct", "ruleallsetting", "parent_child", "ruleallcomponent", "parent_option", "parentallsetting", "current_component", "parent_struct", "parentallchild", "parentablesector", "parentallsection", "rule_component", "rule_section", "child_division", "rule_setting", "parent_division", "parentedchild"], "indent_level": ["indent_limit", "indentingalpath", "indentpline", "indent_line", "indentingalcol", "indentperror", "indenting_col", "indentplevel", "indenting_error", "indentalpath", "indentingplevel", "indentingperror", "indentingallimit", "indentallimit", "indentallevel", "indenting_limit", "indenting_line", "indentplimit", "indenting_level", "indent_error", "indent_path", "indenting_path", "indentalcol", "indent_col", "indentingpline", "indentingallevel", "indentingplimit"]}}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810, "substitutes": {"memmap": ["membar", "memorylist", "gramshare", "memorycache", " memdata", "poolshare", "dimhash", "memoryMap", " memcap", "limmap", "Memlist", "rammap", "poolmap", "poolstore", "imagedown", "memhash", "dimmap", "memshare", "imagebar", "memoryblock", "memcap", "limbar", "memMap", "gramhash", "limdown", "dimshare", "poolhash", "Memmap", "grammap", "memblock", "memorybar", " memblock", " memlist", "ramdata", "dimstore", "ramblock", "limcache", "memorydata", "memdown", "memorydown", "ramcap", "memorymap", "memorycap", "memlist", "memstore", "MemMap", "gramstore", "imagecache", "imagemap", "memdata", " memMap", "memcache"], "irqmap": ["irpblock", "irqumap", "irqspace", "pirqmap", "pirpblock", "pirparray", "pirqarray", "irQarray", "irparray", "irQblock", "irquspace", "irwlist", "irwspace", "irquconf", "srqspace", "srqlist", "irkspace", "irqarray", "irwconf", "irkblock", "irkconf", "srquspace", "irkmap", "pirqblock", "irqblock", "irplist", "pirqlist", "irQlist", "irwmap", "irpmap", "irQmap", "srqmap", "irqulist", "srqconf", "irklist", "srqumap", "irkarray", "irqlist", "srqulist", "pirplist", "pirpmap", "irqconf", "srquconf"], "madt": ["jadtt", "mrt", " madT", "aidT", "adT", " madta", "mandtor", "medten", "jadt", "jadten", "aidts", "madtu", "medty", "madta", "madtt", "mingtt", "mandt", "mrtt", "mrten", "midtu", "medt", "adt", "jadty", "madten", "mingtor", " madts", "midtt", "midtor", "madtor", "aidta", "medtt", "adts", "madT", "adta", "mandtu", "mingt", "mandtt", "madty", "aidt", "mrty", "madts", "midt", "mingtu"], "gicd": ["gacf", " gicf", " gicdl", "giaccd", "gicandb", "gaicdl", "gizt", "gicccd", "gixsd", "gicdb", " gikdn", "gisccd", " gicl", "egicdt", "giscdd", "gicitdt", "gicdd", "Gicds", "giccdl", "gircd", "egicd", "gaccd", "gessd", " gricl", "gacds", " gaicdi", " gricc", "Gicd", "gessdi", "Gicn", " gaicd", "ogicitdh", "ogicitdd", "giccdt", "Gacd", "giccu", "giacdl", "gizl", "gicdh", "gicl", "gaicd", "gircdb", "gikdt", " giscf", " gicds", "giscds", "egicsd", "giacd", "giacn", " gaicdl", "gicansd", "gikdn", "gixdt", "gicitdd", "gicitdh", "picu", "gessu", "ogicdb", "giscdi", "giccf", "piscdd", " gricd", "giccds", "Gacds", "giscn", " grict", " gisct", "gicitd", "piscdi", " gikd", "egicitd", "gicn", "gicandd", " gicdi", " gikdt", "gicst", "picd", "egicdh", "giccdd", "gicsl", " gicdt", "gicitsd", "egicitsd", "gict", "gizc", "gaicdi", " giscd", "Gaccd", "gessdd", "gicsd", " gicdn", "gircdh", "gricd", " giccd", "ogicitd", "gact", "gicitdb", "ogicd", "ogicdh", "giscu", "Gacn", "gacn", "gicdl", "gizd", "gicandh", "egicitdt", "gircdd", "gricl", "gicdt", "giccd", " giscds", "gicf", "egicitdh", "giacdi", "gicds", "piscd", "gicandn", "gacd", "ogicdd", "gicdi", "gikd", "grict", "giccdn", "gicand", "gikcd", "gicu", "gricc", "piscu", "gixd", "giscf", "gicancd", "Giccd", "giacds", " gict", "ogicitdb", "picdd", "gicct", "gicdn", "gicandt", "gisct", "giccdi", "gicsc", "gixdh", "picdi", " gikcd", "giscd"], "gic_msi": ["gic_ksb", "gic_csd", "gic_ksi", "gic__ansb", "gic_csi", "gic__ansd", "gic__msb", "gic_ansb", "gic__ansi", "gic__msi", "gic_ansi", "gic_ksii", "gic_csii", "gic__msii", "gic_ansii", "gic_ansd", "gic_ksd", "gic_msb", "gic__ansii", "gic_msd", "gic_csb", "gic__msd", "gic_msii"], "i": ["index", "mini", "b", "x", "oi", "li", "pi", "n", "z", "idi", "id", "j", "abi", "anti", "yi", "gui", "iu", "ip", "hi", "type", "gi", "ri", "bi", "udi", "l", "ti", "v", "fi", "mu", "io", "slice", "uri", "xi", "ini", "name", "h", "multi", "p", "qi", "m", "zi", "di", "I", "t", "chi", "ski", "u", "s", "ii", "it", "k", "si", "e", "c", "uli", "lo", "eni", "f", "d", "cli", "ui", "phi", "ci", "ni", "ji", "ki", "mi"], "gicc": [" gigg", "agusc", "wci", "agci", "rgirc", "agigg", "genirc", "rgitech", "agosc", "gocl", "gitech", " gci", "Gitech", "igocl", " gusc", "agirc", "agicc", "gaicc", "giac", " gisi", "genaic", "wiac", "gairc", "Girc", "igusc", "rgicc", "gisi", "kigg", "gusc", " gisc", "wusc", "igisi", "geib", "genica", "agica", "gib", "gisc", "genisi", "gosc", "musc", "pci", "gica", "Giac", "genib", "kitech", "gaigg", "kirc", "genusc", "gifi", " gifi", "igiac", "miac", "Gicc", "micc", "gaic", "genicc", "gaiac", "geci", "genisc", "genocl", "maic", " gib", "agocl", "gaosc", " giac", "wicc", "Gigg", "genifi", "Gib", "kusc", " gosc", "agib", "agisc", "geirc", "Gocl", " gica", "pusc", "igaic", "geicc", "kiac", "piac", "genigg", "agiac", "genci", "girc", " gocl", "rgigg", "igib", "igicc", "kicc", "gaocl", "gausc", "picc", "gci", "gigg", "igifi", "geniac"], "armcpu": ["mpu", "adjpc", "rampc", "arggpu", "ramCPU", "armprocessor", "armpc", "mgpu", "amchu", "rampu", "mprocessor", "ampc", "ramchu", "amgpu", "mccpu", "armchu", "mcprocessor", "argCPU", "amprocessor", "adjchu", "mcpu", "mcgpu", "armpu", "armgpu", "armCPU", "adjcpu", "ampu", "argpu", "adjgpu", "amcpu", "ramcpu", "mCPU", "ramgpu", "argcpu"], "gic_its": ["glic_its", "glic_ms", "glic_times", "gic_ins", "gic_times", "gic__ins", "glic_ins", "gic__ms", "gic__its", "gic__times", "gic_ms"]}}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n", "idx": 25813, "substitutes": {}}
{"project": "qemu", "commit_id": "7f595609b49615b07c50b7182c4ef125c39cb5da", "target": 0, "func": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n", "idx": 25814, "substitutes": {"klass": ["sclass", " klf", "ckpl", "kclass", "jclass", "jazz", "Klass", "Kazz", "kcl", "cklf", "tkazz", " kclass", "kpl", "sclf", "scclass", "tkcl", "ckclass", "klf", "scpl", "cklass", "Kclass", "tklass", " kpl", "jcl", "Kcl", "kazz", "jlass", "tkclass"], "data": ["buf", "parent", "base", "child", "da", "func", "connection", "ctx", "DATA", "board", "cache", "type", "ata", "config", "package", "Data", "device", "input", "d", "module", "object", "bus", "load", "ui", "dat", "class"], "uc": ["fc", "unc", "uca", "ucc", "sc", "home", "bc", "anc", "ca", "ac", "cc", "ubs", "sub", "asc", "lu", "cus", "mc", "utf", "uu", "cv", "cas", "auc", "hub", "acc", "uma", "con", "instance", "config", "oc", "uci", "ub", "tc", "pub", "u", "rc", "mac", "input", "su", "plug", "um", "ec", "pc", "lc", "ul", "uh", "ru", "uf", "ui", "cu", "usb", "usc", "UC", "client", "us", "userc"]}}
{"project": "FFmpeg", "commit_id": "77d98898211eeb0241e8411428b0b364a6231744", "target": 1, "func": "static int pixlet_decode_frame(AVCodecContext *avctx, void *data,\n                               int *got_frame, AVPacket *avpkt)\n{\n    PixletContext *ctx = avctx->priv_data;\n    int i, w, h, width, height, ret, version;\n    AVFrame *p = data;\n    ThreadFrame frame = { .f = data };\n    uint32_t pktsize;\n    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);\n    pktsize = bytestream2_get_be32(&ctx->gb);\n    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid packet size %\"PRIu32\"\\n\", pktsize);\n    }\n    version = bytestream2_get_le32(&ctx->gb);\n    if (version != 1)\n        avpriv_request_sample(avctx, \"Version %d\", version);\n    bytestream2_skip(&ctx->gb, 4);\n    if (bytestream2_get_be32(&ctx->gb) != 1)\n    bytestream2_skip(&ctx->gb, 4);\n    width  = bytestream2_get_be32(&ctx->gb);\n    height = bytestream2_get_be32(&ctx->gb);\n    w = FFALIGN(width,  1 << (NB_LEVELS + 1));\n    h = FFALIGN(height, 1 << (NB_LEVELS + 1));\n    ctx->levels = bytestream2_get_be32(&ctx->gb);\n    if (ctx->levels != NB_LEVELS)\n    ctx->depth = bytestream2_get_be32(&ctx->gb);\n    if (ctx->depth < 8 || ctx->depth > 15) {\n        avpriv_request_sample(avctx, \"Depth %d\", ctx->depth);\n    }\n    ret = ff_set_dimensions(avctx, w, h);\n    if (ret < 0)\n        return ret;\n    avctx->width  = width;\n    avctx->height = height;\n    if (ctx->w != w || ctx->h != h) {\n        free_buffers(avctx);\n        ctx->w = w;\n        ctx->h = h;\n        ret = init_decoder(avctx);\n        if (ret < 0) {\n            free_buffers(avctx);\n            ctx->w = 0;\n            ctx->h = 0;\n            return ret;\n        }\n    }\n    bytestream2_skip(&ctx->gb, 8);\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n    p->color_range = AVCOL_RANGE_JPEG;\n    ret = ff_thread_get_buffer(avctx, &frame, 0);\n    if (ret < 0)\n        return ret;\n    for (i = 0; i < 3; i++) {\n        ret = decode_plane(avctx, i, avpkt, frame.f);\n        if (ret < 0)\n            return ret;\n        if (avctx->flags & AV_CODEC_FLAG_GRAY)\n            break;\n    }\n    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);\n    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);\n    *got_frame = 1;\n    return pktsize;\n}", "idx": 25828, "substitutes": {"avctx": ["avxc", "akcontext", "afcmd", "navcmd", "afpkg", "AVlc", "afcu", "afcoll", "AVcn", "avcmd", "airpkg", "avpkg", "AVsci", "avsci", "abctx", "avtx", "afcfg", " avcontext", "afctrl", "avectx", "afcontext", " avcu", "avecontext", "abcontext", "aircoll", "avesci", "aftx", "afxc", "afsci", "afcn", "aklc", "Avcu", "aircn", "varctrl", "Avtx", "avetx", "verctx", "avepkg", "varctx", "airctx", "akcfg", "avcu", "afctx", "Avcontext", "airlc", "akctx", "Avsci", "navctrl", "AVcontext", "avctrl", "abcu", "Avctx", "AVcu", "avcoll", "varcontext", "avcmp", "aflc", "avlc", "avecoll", "navctx", "vercontext", "Avxc", "varcmd", "avcn", "avcfg", "avcontext", "AVcmp", "avecu", "navcontext", "abcmp", " avxc", "versci", "aircontext", "vercu", "AVctx"], "data": ["buf", "video", "database", "array", "results", "parent", "base", "da", "value", "id", "mode", "source", "proc", "valid", "body", "bytes", "response", "DATA", "len", "window", "image", "cache", "size", "result", "open", "reader", "slice", "frame", "empty", "batch", "draw", "primary", "code", "one", "def", "Data", "read", "channel", "init", "buffer", "input", "sample", "media", "pad", "start", "d", "f", "next", "val", "api", "load", "o", "memory", "dat", "length", "bin"], "got_frame": ["got2frames", "gotfframe", "aved_size", "aved_frame", "got2frame", "gotfsize", "gotfimage", "got_size", "gotfframes", "aved_image", "aved_frames", "got_image", "got_frames", "got2size", "got2image"], "avpkt": [" avppkt", "avpqt", "avvpkt", " avbct", "avPct", "avfkl", " avlpcht", "avpct", " avpft", "avfacket", "avtpacket", " avlpkt", "avpkl", "avppkt", " avpkl", "avpcht", "avppqt", "avvpct", " avppkl", "avbkt", " avppft", "avpacket", "avppft", "avbct", "avbacket", " avpqt", "avppct", " avpacket", "avPkt", "avlpcht", " avpcht", "avpft", "avpke", "avPke", "avlpqt", " avbacket", "avlpkt", " avpct", " avbkt", "avppcht", "avfkt", "avbke", "avfke", "avfct", "avtpkt", "avvpqt", " avlpct", " avlpqt", "avPacket", " avbke", " avpke", "avtpkl", "avtpft", "avppacket", "avppkl", "avvpcht", "avlpct", " avppacket", "avfft"], "ctx": ["scope", "dc", "bc", "ca", "g", "cache", "kw", "Context", "hs", "instance", "cam", "git", "sq", "cu", "ci", "co", "buf", "fw", "coll", "context", "num", "xc", "conf", "nc", "cc", "cms", "cp", "connection", "crit", "window", "conn", "cs", "conv", "wcs", "obj", "prefix", "rc", "c", "pc", "lc", "cli", "qa", "client", "kb", "concept", "_", "general", "cmp", "pkg", "cal", "wx", "all", "cf", "config", "util", "cmd", "cn", "s", "cm", "cfg", "acl", "rt", "utils", "this", "exec", "ann", "sys", "sci", "hw", "qq", "cus", "r", "mc", "cv", "cas", "cci", "vc", "act", "tc", "tx", "ctrl", "cca", "loc", "d", "component", "cb", "length", "support", "chan"], "i": ["index", "b", "x", "in", "pi", "n", "len", "iu", "ix", "is", "l", "v", "io", "code", "di", "I", "init", "ii", "si", "e", "c", "d", "f", "ui", "ci", "ni", "mi"], "w": ["x", "b", "fw", "wn", "weight", "n", "wp", "win", "aw", "wt", "z", "home", "iw", "wid", "wy", "ow", "ew", "hw", "sh", "W", "wa", "window", "r", "widget", "g", "ww", "wl", "wb", "max", "l", "kw", "y", "v", "work", "wal", "wx", "wd", "t", "wall", "u", "wi", "we", "nw", "d", "wh", "f", "q", "sw", "name", "rw"], "h": ["x", "b", "depth", "n", "ih", "z", "j", "gh", "bh", "hd", "th", "sh", "wa", "r", "g", "hi", "hl", "max", "l", "y", "v", "hh", "hm", "m", "t", "rh", "u", "e", "ha", "c", "ph", "d", "hp", "f", "hr", "q", "H", "ht", "o", "en", "length"], "height": ["depth", "x", "fw", "adh", "resolution", "z", "thin", "gh", "huge", "shape", "direction", "hd", "th", "hang", "shadow", "dy", "hw", "sh", "Height", "wa", "row", "window", "layout", "enh", "hi", "build", "size", "image", "han", "distance", "quality", "y", "volume", "hh", "style", "hz", "gy", "history", "density", "rh", "east", "wall", "head", "k", "high", "ph", "d", "padding", "inches", "img", "uh", "gap", "ht", "bottom", "length", "upper"], "ret": ["last", "sr", "status", "error", "value", "reply", "mt", "err", "RET", "debug", "progress", "valid", "let", "len", "gt", "nt", "feature", " RET", "result", "alt", "det", "url", "ref", "ver", "rev", "rets", "arr", "code", "ft", "def", "match", "fail", "rc", "fun", "sat", "att", "feat", "rt", "seq", "lit", "val", "cat", "back", "Ret", "reg", "res", "flag", "bit", "art", "success", "re", "ext"], "version": ["depth", "num", "VERSION", "platform", "seed", "weight", "status", "release", "parent", "driver", "value", "mode", "vers", "debug", "progress", "format", "Version", "brand", "python", "len", "current", "option", "feature", "update", "number", "model", "uu", "type", "result", "cv", "v", "url", "ver", "beta", "rev", "vision", "level", "stage", "channel", "vert", "package", "bug", "scale", "latest", "support", "round", "download", "val", "versions", "server", "qa", "section", "name", "draft", "length", "step"], "p": ["b", "pb", "pi", "n", "a", "wp", "j", "cp", "fp", "v", "m", "ap", "t", "P", "e", "c", "bp", "d", "f", "pc", "q", "np", "o", "tp", "lp", "pointer", "pa"], "pktsize": ["pktesize", "pkatsiz", "pkoutsiz", "pkssz", "pktsizing", "psktssize", "pktessize", "puktsizable", "pkTSizer", "pktsizes", "pkstsizable", "puktizer", "puktize", "psktsz", "pkoutsize", "pktesizable", "psktiz", "pktsizable", "pktizes", "pkatsizing", "psktizable", "pkTSiz", "pkTSize", "puktsizer", "pkstsize", "pktsz", "pksssize", "pktdizable", "pkstsiz", "pktesizer", "puktesizable", "puktsize", "pktdize", "puktiz", "pktesizing", "pktesiz", "pkTSsize", "pktiz", "pktizable", "pktize", "puktesizing", "pkatsize", "puktesize", "pktdsize", "pktsiz", "pkoutssize", "pktdiz", "pkatssize", "psktsiz", "pkatsizes", "puktessize", "psktsize", "pkssizes", "psktsizes", "puktsiz", "pkoutsizing", "pktssize", "puktesiz", "pkstssize", "psktsizable", "pktsizer", "puktsizing", "psktize", "psktz", "pkatsz", "puktssize", "pkssize", "pktizer", "psktizes", "pktz"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831, "substitutes": {"mc": ["coll", "fc", "mic", "dc", " MC", "bc", "ca", "nc", "anc", "ac", "cc", "cus", "arc", "model", "dr", "cci", "mr", "config", "vc", "wic", "m", "ic", "tc", "cn", "mac", "md", "cm", "rc", "MC", "doc", "uc", "c", "module", "pc", "ec", "lc", "spec", "mm", "ml", "ci", "class", "mi", "Mc"], "s390mc": ["s30dc", "s90module", "s390mm", " s90module", "s310mm", "s370mac", "s170mac", "s170MC", " s390mi", "s350mi", "s390cc", " s90mc", " s30mi", " s390mm", "s90mc", " s90cci", "s090module", "s40mc", "s370MC", "s30mc", "s390mac", "s370mc", "s30mac", "s370dc", " s390cci", "s350mm", "S390MC", "s350mac", "s170mc", "s30mi", " s30mc", "s40cc", " s90cc", "s170dc", "S170mac", "s30MC", "S390mc", "s310mac", "s90cc", "S390dc", "s350mc", "s090cc", "s90cci", "s40cci", "s40module", "s310mi", " s30mm", "s390module", "s090mc", "s390MC", "S170MC", "s30mm", "S170dc", "s090cci", " s390mac", " s390module", "s390dc", "s390cci", "S170mc", " s30mac", "s310mc", "S390mac", "s390mi", " s390cc"]}}
{"project": "FFmpeg", "commit_id": "d9fe6b926cd619c311e45e0ae352cf09713c482c", "target": 1, "func": "static int matroska_read_header(AVFormatContext *s)\n\n{\n\n    MatroskaDemuxContext *matroska = s->priv_data;\n\n    EbmlList *attachements_list = &matroska->attachments;\n\n    MatroskaAttachement *attachements;\n\n    EbmlList *chapters_list = &matroska->chapters;\n\n    MatroskaChapter *chapters;\n\n    MatroskaTrack *tracks;\n\n    uint64_t max_start = 0;\n\n    int64_t pos;\n\n    Ebml ebml = { 0 };\n\n    AVStream *st;\n\n    int i, j, k, res;\n\n\n\n    matroska->ctx = s;\n\n\n\n    /* First read the EBML header. */\n\n    if (ebml_parse(matroska, ebml_syntax, &ebml)\n\n        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)\n\n        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n        ebml_free(ebml_syntax, &ebml);\n\n        return AVERROR_PATCHWELCOME;\n\n    } else if (ebml.doctype_version == 3) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n    }\n\n    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)\n\n        if (!strcmp(ebml.doctype, matroska_doctypes[i]))\n\n            break;\n\n    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);\n\n    }\n\n    ebml_free(ebml_syntax, &ebml);\n\n\n\n    /* The next thing is a segment. */\n\n    pos = avio_tell(matroska->ctx->pb);\n\n    res = ebml_parse(matroska, matroska_segments, matroska);\n\n    // try resyncing until we find a EBML_STOP type element.\n\n    while (res != 1) {\n\n        res = matroska_resync(matroska, pos);\n\n        if (res < 0)\n\n            return res;\n\n        pos = avio_tell(matroska->ctx->pb);\n\n        res = ebml_parse(matroska, matroska_segment, matroska);\n\n    }\n\n    matroska_execute_seekhead(matroska);\n\n\n\n    if (!matroska->time_scale)\n\n        matroska->time_scale = 1000000;\n\n    if (matroska->duration)\n\n        matroska->ctx->duration = matroska->duration * matroska->time_scale\n\n                                  * 1000 / AV_TIME_BASE;\n\n    av_dict_set(&s->metadata, \"title\", matroska->title, 0);\n\n\n\n    if (matroska->date_utc.size == 8)\n\n        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));\n\n\n\n    tracks = matroska->tracks.elem;\n\n    for (i=0; i < matroska->tracks.nb_elem; i++) {\n\n        MatroskaTrack *track = &tracks[i];\n\n        enum CodecID codec_id = CODEC_ID_NONE;\n\n        EbmlList *encodings_list = &track->encodings;\n\n        MatroskaTrackEncoding *encodings = encodings_list->elem;\n\n        uint8_t *extradata = NULL;\n\n        int extradata_size = 0;\n\n        int extradata_offset = 0;\n\n        uint32_t fourcc = 0;\n\n        AVIOContext b;\n\n\n\n        /* Apply some sanity checks. */\n\n        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&\n\n            track->type != MATROSKA_TRACK_TYPE_AUDIO &&\n\n            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n\n                   track->type);\n\n            continue;\n\n        }\n\n        if (track->codec_id == NULL)\n\n            continue;\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            if (!track->default_duration)\n\n                track->default_duration = 1000000000/track->video.frame_rate;\n\n            if (!track->video.display_width)\n\n                track->video.display_width = track->video.pixel_width;\n\n            if (!track->video.display_height)\n\n                track->video.display_height = track->video.pixel_height;\n\n            if (track->video.color_space.size == 4)\n\n                fourcc = AV_RL32(track->video.color_space.data);\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            if (!track->audio.out_samplerate)\n\n                track->audio.out_samplerate = track->audio.samplerate;\n\n        }\n\n        if (encodings_list->nb_elem > 1) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR,\n\n                   \"Multiple combined encodings not supported\");\n\n        } else if (encodings_list->nb_elem == 1) {\n\n            if (encodings[0].type ||\n\n                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&\n\n#if CONFIG_ZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&\n\n#endif\n\n#if CONFIG_BZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&\n\n#endif\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {\n\n                encodings[0].scope = 0;\n\n                av_log(matroska->ctx, AV_LOG_ERROR,\n\n                       \"Unsupported encoding type\");\n\n            } else if (track->codec_priv.size && encodings[0].scope&2) {\n\n                uint8_t *codec_priv = track->codec_priv.data;\n\n                int offset = matroska_decode_buffer(&track->codec_priv.data,\n\n                                                    &track->codec_priv.size,\n\n                                                    track);\n\n                if (offset < 0) {\n\n                    track->codec_priv.data = NULL;\n\n                    track->codec_priv.size = 0;\n\n                    av_log(matroska->ctx, AV_LOG_ERROR,\n\n                           \"Failed to decode codec private data\\n\");\n\n                } else if (offset > 0) {\n\n                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n\n                    memcpy(track->codec_priv.data,\n\n                           encodings[0].compression.settings.data, offset);\n\n                    memcpy(track->codec_priv.data+offset, codec_priv,\n\n                           track->codec_priv.size);\n\n                    track->codec_priv.size += offset;\n\n                }\n\n                if (codec_priv != track->codec_priv.data)\n\n                    av_free(codec_priv);\n\n            }\n\n        }\n\n\n\n        for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n\n            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n\n                        strlen(ff_mkv_codec_tags[j].str))){\n\n                codec_id= ff_mkv_codec_tags[j].id;\n\n                break;\n\n            }\n\n        }\n\n\n\n        st = track->stream = avformat_new_stream(s, NULL);\n\n        if (st == NULL)\n\n            return AVERROR(ENOMEM);\n\n\n\n        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")\n\n            && track->codec_priv.size >= 40\n\n            && track->codec_priv.data != NULL) {\n\n            track->ms_compat = 1;\n\n            fourcc = AV_RL32(track->codec_priv.data + 16);\n\n            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);\n\n            extradata_offset = 40;\n\n        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")\n\n                   && track->codec_priv.size >= 14\n\n                   && track->codec_priv.data != NULL) {\n\n            int ret;\n\n            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,\n\n                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);\n\n            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);\n\n            if (ret < 0)\n\n                return ret;\n\n            codec_id = st->codec->codec_id;\n\n            extradata_offset = FFMIN(track->codec_priv.size, 18);\n\n        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")\n\n                   && (track->codec_priv.size >= 86)\n\n                   && (track->codec_priv.data != NULL)) {\n\n            fourcc = AV_RL32(track->codec_priv.data);\n\n            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);\n\n        } else if (codec_id == CODEC_ID_PCM_S16BE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;\n\n            }\n\n        } else if (codec_id == CODEC_ID_PCM_S16LE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;\n\n            }\n\n        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n\n            codec_id = CODEC_ID_PCM_F64LE;\n\n        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {\n\n            int profile = matroska_aac_profile(track->codec_id);\n\n            int sri = matroska_aac_sri(track->audio.samplerate);\n\n            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n\n            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);\n\n            if (strstr(track->codec_id, \"SBR\")) {\n\n                sri = matroska_aac_sri(track->audio.out_samplerate);\n\n                extradata[2] = 0x56;\n\n                extradata[3] = 0xE5;\n\n                extradata[4] = 0x80 | (sri<<3);\n\n                extradata_size = 5;\n\n            } else\n\n                extradata_size = 2;\n\n        } else if (codec_id == CODEC_ID_TTA) {\n\n            extradata_size = 30;\n\n            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            ffio_init_context(&b, extradata, extradata_size, 1,\n\n                          NULL, NULL, NULL, NULL);\n\n            avio_write(&b, \"TTA1\", 4);\n\n            avio_wl16(&b, 1);\n\n            avio_wl16(&b, track->audio.channels);\n\n            avio_wl16(&b, track->audio.bitdepth);\n\n            avio_wl32(&b, track->audio.out_samplerate);\n\n            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);\n\n        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n\n                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n\n            extradata_offset = 26;\n\n        } else if (codec_id == CODEC_ID_RA_144) {\n\n            track->audio.out_samplerate = 8000;\n\n            track->audio.channels = 1;\n\n        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||\n\n                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {\n\n            int flavor;\n\n            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,\n\n                          0, NULL, NULL, NULL, NULL);\n\n            avio_skip(&b, 22);\n\n            flavor                       = avio_rb16(&b);\n\n            track->audio.coded_framesize = avio_rb32(&b);\n\n            avio_skip(&b, 12);\n\n            track->audio.sub_packet_h    = avio_rb16(&b);\n\n            track->audio.frame_size      = avio_rb16(&b);\n\n            track->audio.sub_packet_size = avio_rb16(&b);\n\n            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);\n\n            if (codec_id == CODEC_ID_RA_288) {\n\n                st->codec->block_align = track->audio.coded_framesize;\n\n                track->codec_priv.size = 0;\n\n            } else {\n\n                if (codec_id == CODEC_ID_SIPR && flavor < 4) {\n\n                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };\n\n                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];\n\n                    st->codec->bit_rate = sipr_bit_rate[flavor];\n\n                }\n\n                st->codec->block_align = track->audio.sub_packet_size;\n\n                extradata_offset = 78;\n\n            }\n\n        }\n\n        track->codec_priv.size -= extradata_offset;\n\n\n\n        if (codec_id == CODEC_ID_NONE)\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id);\n\n\n\n        if (track->time_scale < 0.01)\n\n            track->time_scale = 1.0;\n\n        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n\n\n        st->codec->codec_id = codec_id;\n\n        st->start_time = 0;\n\n        if (strcmp(track->language, \"und\"))\n\n            av_dict_set(&st->metadata, \"language\", track->language, 0);\n\n        av_dict_set(&st->metadata, \"title\", track->name, 0);\n\n\n\n        if (track->flag_default)\n\n            st->disposition |= AV_DISPOSITION_DEFAULT;\n\n        if (track->flag_forced)\n\n            st->disposition |= AV_DISPOSITION_FORCED;\n\n\n\n        if (!st->codec->extradata) {\n\n            if(extradata){\n\n                st->codec->extradata = extradata;\n\n                st->codec->extradata_size = extradata_size;\n\n            } else if(track->codec_priv.data && track->codec_priv.size > 0){\n\n                st->codec->extradata = av_mallocz(track->codec_priv.size +\n\n                                                  FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if(st->codec->extradata == NULL)\n\n                    return AVERROR(ENOMEM);\n\n                st->codec->extradata_size = track->codec_priv.size;\n\n                memcpy(st->codec->extradata,\n\n                       track->codec_priv.data + extradata_offset,\n\n                       track->codec_priv.size);\n\n            }\n\n        }\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_tag  = fourcc;\n\n            st->codec->width  = track->video.pixel_width;\n\n            st->codec->height = track->video.pixel_height;\n\n            av_reduce(&st->sample_aspect_ratio.num,\n\n                      &st->sample_aspect_ratio.den,\n\n                      st->codec->height * track->video.display_width,\n\n                      st->codec-> width * track->video.display_height,\n\n                      255);\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n            if (track->default_duration)\n\n                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);\n\n\n\n            /* export stereo mode flag as metadata tag */\n\n            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)\n\n                av_dict_set(&st->metadata, \"stereo_mode\", matroska_video_stereo_mode[track->video.stereo_mode], 0);\n\n\n\n            /* if we have virtual track, mark the real tracks */\n\n            for (j=0; j < track->operation.combine_planes.nb_elem; j++) {\n\n                char buf[32];\n\n                if (planes[j].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)\n\n                    continue;\n\n                snprintf(buf, sizeof(buf), \"%s_%d\",\n\n                         matroska_video_stereo_plane[planes[j].type], i);\n\n                for (k=0; k < matroska->tracks.nb_elem; k++)\n\n                    if (planes[j].uid == tracks[k].uid) {\n\n                        av_dict_set(&s->streams[k]->metadata,\n\n                                    \"stereo_mode\", buf, 0);\n\n                        break;\n\n                    }\n\n            }\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->sample_rate = track->audio.out_samplerate;\n\n            st->codec->channels = track->audio.channels;\n\n            if (st->codec->codec_id != CODEC_ID_AAC)\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n        }\n\n    }\n\n\n\n    attachements = attachements_list->elem;\n\n    for (j=0; j<attachements_list->nb_elem; j++) {\n\n        if (!(attachements[j].filename && attachements[j].mime &&\n\n              attachements[j].bin.data && attachements[j].bin.size > 0)) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");\n\n        } else {\n\n            AVStream *st = avformat_new_stream(s, NULL);\n\n            if (st == NULL)\n\n                break;\n\n            av_dict_set(&st->metadata, \"filename\",attachements[j].filename, 0);\n\n            av_dict_set(&st->metadata, \"mimetype\", attachements[j].mime, 0);\n\n            st->codec->codec_id = CODEC_ID_NONE;\n\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n\n            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if(st->codec->extradata == NULL)\n\n                break;\n\n            st->codec->extradata_size = attachements[j].bin.size;\n\n            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n\n\n\n            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n\n                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n\n                             strlen(ff_mkv_mime_tags[i].str))) {\n\n                    st->codec->codec_id = ff_mkv_mime_tags[i].id;\n\n                    break;\n\n                }\n\n            }\n\n            attachements[j].stream = st;\n\n        }\n\n    }\n\n\n\n    chapters = chapters_list->elem;\n\n    for (i=0; i<chapters_list->nb_elem; i++)\n\n        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid\n\n            && (max_start==0 || chapters[i].start > max_start)) {\n\n            chapters[i].chapter =\n\n            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n\n                           chapters[i].start, chapters[i].end,\n\n                           chapters[i].title);\n\n            av_dict_set(&chapters[i].chapter->metadata,\n\n                             \"title\", chapters[i].title, 0);\n\n            max_start = chapters[i].start;\n\n        }\n\n\n\n    matroska_add_index_entries(matroska);\n\n\n\n    matroska_convert_tags(s);\n\n\n\n    return 0;\n\n}\n", "idx": 25854, "substitutes": {"s": ["js", "sf", "qs", "a", "soc", "sci", "sc", "conf", "sv", "S", "gs", "rs", "space", "os", "ops", "ctx", "ssl", "sb", "fs", "r", "g", "storage", "session", "ts", "es", "sa", "request", "v", "h", "service", "p", "cs", "sym", "t", "sets", "su", "ns", "sg", "si", "e", "c", "f", "ss", "spec", "ds", "services", "sq", "serv", "server", "client", "comments", "se", "ses", "support", "sys"], "matroska": ["matroneska", " matreskee", "matrisaka", "matrsaka", "matroskaya", "macroskee", "matrosya", "matroskee", "Matrosky", "matraskee", "matronskaya", "Matrski", "matrotla", "matreska", "matrockee", "matroseya", "matroneski", "matrosaka", "matrisku", "matrosela", "macrosya", "matrokaya", "matrssla", "Matroska", "matruski", "Matrosla", "macrola", "matronsya", "matrotka", "matroya", " matreska", "matrosena", "matrsska", "Matrskee", "matrsya", "matronesku", "matrska", "matronskee", "matoskee", "matrski", "matrusaka", "matrocky", "matrskee", "matroski", "macroski", "macroki", "matosla", "matrotkee", "matresya", "matrocki", "matronska", "Matrola", "matronesla", "matronesaka", "matroaka", "Matrosku", "Matrockee", "macrokee", "macrosena", "Matroskee", "macroka", " matresya", "Matrska", "Matroka", " matrosaka", "Matrsaka", "matrosky", "matriska", "matrosla", "matroka", "Matroku", "matraska", "macrosla", "matruskee", "Matrocky", "matroena", "matrokee", "matroki", "matresaka", "matroku", "matrotkaya", "matronsla", "macrokaya", "matrosku", "matroseka", "matrola", "matrisla", "matrsski", "macroya", "Matrocla", " matresaka", "matrocena", "Matroski", "matronsaka", " matrosya", "matrasla", "matoska", "matosky", "matrssena", "matrocla", "matrosekee", "matreskee", "Matrosaka", "matrasya", "matoski", "Matrocka", "matrocka", "matruska", "matrusky", "macroskaya", " matroskee", "macroska", "Matroaka", "matrusla", "matroneskee", "macroena"], "attachements_list": ["attachements__type", "attachements__list", "attacheles_diff", "attacheles_type", "attachements_type", "attachements__diff", "attacheles_list", "attachements_diff"], "attachements": ["assachement", "attachls", "assachments", "attachement", "attachels", "attachures", "assacheures", "attaitment", "attailment", "attailures", "attachment", "assachements", "attaitments", "assachls", "attacheures", "attaitls", "assachment", "assachels", "attailments", "attachments", "attaills", "assachures", "attaitures"], "chapters_list": ["chapters_name", "channels_name", "chapters_set", "channels_list", "channels_set", "chapters_LIST", "channels_LIST"], "chapters": ["chunks", " charts", " chunks", "channels", "achapters", "pharts", "chants", "achorts", "phapters", "corts", "phunks", "chassis", "adorts", "capters", "acharts", " channels", "chorts", "achunks", "adapters", "cants", "adants", "achants", "achassis", "phannels", "cassis", "achannels", "charts", "adassis"], "tracks": ["flows", "sections", "items", "ips", "ids", "clips", "events", "rows", "series", "phones", "reads", "grades", "tracking", "shows", "media", "acks", "videos", "frames", "relations", "views", "parts", "comments", "groups", "steps", "tags", "mods", "notes"], "pos": ["index", "port", "loop", "Pos", "rel", "os", "body", "len", "sp", "position", "cache", "fin", "type", "resp", "params", "cas", "no", "put", "pid", "all", "ref", "part", "pro", "POS", "args", "def", "obj", "po", "su", "loc", "block", "limit", "pt", "seq", "start", "pc", "sec", "spec", "diff", "next", "val", "nos", "offset"], "st": ["bl", "ist", "sl", "ost", "sc", "std", "stack", "sth", "sp", "sts", "St", "sa", "stim", "sta", "rest", "est", "stage", "cr", "ste", "rss", "inst", "ast", "ss", "ST", " ss", "sw", "sn"], "i": ["x", "index", "ai", "oi", "in", "li", "n", "pi", "ie", "key", "z", "id", "count", "abi", "yi", "info", "r", "iu", "ip", "hi", "ix", "gi", "ri", "bi", "l", "ti", "h", "io", "fi", "mu", "slice", "part", "xi", "ini", "v", "uri", "multi", "p", "qi", "zi", "m", "I", "di", "t", "ski", "chi", "ii", "si", "e", "c", "d", "start", "f", "eni", "ind", "adi", "ui", "ci", "phi", "ni", "ji", "ki", "mi"], "j": ["kj", "n", "ja", "ie", "z", "sp", "r", "g", "l", "y", "ij", "py", "p", "m", "ii", "je", "jp", "si", "jj", "jl", "q", "uj", "o", "ji", "J"], "k": ["kj", "ke", "key", "kid", "z", "ky", "ko", "ck", "ku", "kw", "ks", "sk", "ek", "K", "p", "ik", "w", "ak", "ok", "ka", "mk", "kr", "km", "q", "kk", "o", "ki"], "res": ["js", "rec", "Res", "rx", "vs", "err", "rows", "os", "rs", "req", "ack", "pres", "sp", "r", "ps", "resp", "ks", "rev", "R", "cr", "rss", "rc", "ru", "sw", "ro", "us", "rw"]}}
{"project": "FFmpeg", "commit_id": "feb13aed794a7f1a1f8395159e9b077351348a34", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    SignatureContext *sic = ctx->priv;\n\n    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);\n\n    FineSignature* fs;\n\n\n\n    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };\n\n    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296\n\n    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...\n\n    */\n\n    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};\n\n    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};\n\n\n\n    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */\n\n    uint64_t intpic[32][32];\n\n    uint64_t rowcount;\n\n    uint8_t *p = picref->data[0];\n\n    int inti, intj;\n\n    int *intjlut;\n\n\n\n    uint64_t conflist[DIFFELEM_SIZE];\n\n    int f = 0, g = 0, w = 0;\n\n    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;\n\n    int64_t denom;\n\n    int i, j, k, ternary;\n\n    uint64_t blocksum;\n\n    int blocksize;\n\n    int64_t th; /* threshold */\n\n    int64_t sum;\n\n\n\n    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;\n\n\n\n    /* initialize fs */\n\n    if (sc->curfinesig) {\n\n        fs = av_mallocz(sizeof(FineSignature));\n\n        if (!fs)\n\n            return AVERROR(ENOMEM);\n\n        sc->curfinesig->next = fs;\n\n        fs->prev = sc->curfinesig;\n\n        sc->curfinesig = fs;\n\n    } else {\n\n        fs = sc->curfinesig = sc->finesiglist;\n\n        sc->curcoarsesig1->first = fs;\n\n    }\n\n\n\n    fs->pts = picref->pts;\n\n    fs->index = sc->lastindex++;\n\n\n\n    memset(intpic, 0, sizeof(uint64_t)*32*32);\n\n    intjlut = av_malloc_array(inlink->w, sizeof(int));\n\n    if (!intjlut)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < inlink->w; i++) {\n\n        intjlut[i] = (i*32)/inlink->w;\n\n    }\n\n\n\n    for (i = 0; i < inlink->h; i++) {\n\n        inti = (i*32)/inlink->h;\n\n        for (j = 0; j < inlink->w; j++) {\n\n            intj = intjlut[j];\n\n            intpic[inti][intj] += p[j];\n\n        }\n\n        p += picref->linesize[0];\n\n    }\n\n    av_freep(&intjlut);\n\n\n\n    /* The following calculates a summed area table (intpic) and brings the numbers\n\n     * in intpic to the same denominator.\n\n     * So you only have to handle the numinator in the following sections.\n\n     */\n\n    dh1 = inlink->h / 32;\n\n    if (inlink->h % 32)\n\n        dh2 = dh1 + 1;\n\n    dw1 = inlink->w / 32;\n\n    if (inlink->w % 32)\n\n        dw2 = dw1 + 1;\n\n    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        rowcount = 0;\n\n        a = 1;\n\n        if (dh2 > 1) {\n\n            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32;\n\n            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32;\n\n            a = (a == dh1)? dh2 : dh1;\n\n        }\n\n        for (j = 0; j < 32; j++) {\n\n            b = 1;\n\n            if (dw2 > 1) {\n\n                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32;\n\n                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32;\n\n                b = (b == dw1)? dw2 : dw1;\n\n            }\n\n            rowcount += intpic[i][j] * a * b * precfactor / denom;\n\n            if (i > 0) {\n\n                intpic[i][j] = intpic[i-1][j] + rowcount;\n\n            } else {\n\n                intpic[i][j] = rowcount;\n\n            }\n\n        }\n\n    }\n\n\n\n    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;\n\n\n\n    for (i = 0; i < ELEMENT_COUNT; i++) {\n\n        const ElemCat* elemcat = elements[i];\n\n        int64_t* elemsignature;\n\n        uint64_t* sortsignature;\n\n\n\n        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!elemsignature)\n\n            return AVERROR(ENOMEM);\n\n        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!sortsignature)\n\n            return AVERROR(ENOMEM);\n\n\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            blocksum = 0;\n\n            blocksize = 0;\n\n            for (k = 0; k < elemcat->left_count; k++) {\n\n                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n            }\n\n            sum = blocksum / blocksize;\n\n            if (elemcat->av_elem) {\n\n                sum -= 128 * precfactor * denom;\n\n            } else {\n\n                blocksum = 0;\n\n                blocksize = 0;\n\n                for (; k < elemcat->block_count; k++) {\n\n                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n                }\n\n                sum -= blocksum / blocksize;\n\n                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));\n\n            }\n\n\n\n            elemsignature[j] = sum;\n\n            sortsignature[j] = FFABS(sum);\n\n        }\n\n\n\n        /* get threshold */\n\n        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);\n\n        th = sortsignature[(int) (elemcat->elem_count*0.333)];\n\n\n\n        /* ternarize */\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            if (elemsignature[j] < -th) {\n\n                ternary = 0;\n\n            } else if (elemsignature[j] <= th) {\n\n                ternary = 1;\n\n            } else {\n\n                ternary = 2;\n\n            }\n\n            fs->framesig[f/5] += ternary * pot3[f%5];\n\n\n\n            if (f == wordvec[w]) {\n\n                fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];\n\n                if (w < 24)\n\n                    w++;\n\n            }\n\n            f++;\n\n        }\n\n        av_freep(&elemsignature);\n\n        av_freep(&sortsignature);\n\n    }\n\n\n\n    /* confidence */\n\n    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);\n\n    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);\n\n\n\n    /* coarsesignature */\n\n    if (sc->coarsecount == 0) {\n\n        if (sc->curcoarsesig2) {\n\n            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));\n\n            if (!sc->curcoarsesig1)\n\n                return AVERROR(ENOMEM);\n\n            sc->curcoarsesig1->first = fs;\n\n            sc->curcoarsesig2->next = sc->curcoarsesig1;\n\n            sc->coarseend = sc->curcoarsesig1;\n\n        }\n\n    }\n\n    if (sc->coarsecount == 45) {\n\n        sc->midcoarse = 1;\n\n        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));\n\n        if (!sc->curcoarsesig2)\n\n            return AVERROR(ENOMEM);\n\n        sc->curcoarsesig2->first = fs;\n\n        sc->curcoarsesig1->next = sc->curcoarsesig2;\n\n        sc->coarseend = sc->curcoarsesig2;\n\n    }\n\n    for (i = 0; i < 5; i++) {\n\n        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);\n\n    }\n\n    /* assuming the actual frame is the last */\n\n    sc->curcoarsesig1->last = fs;\n\n    if (sc->midcoarse) {\n\n        for (i = 0; i < 5; i++) {\n\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n\n        }\n\n        sc->curcoarsesig2->last = fs;\n\n    }\n\n\n\n    sc->coarsecount = (sc->coarsecount+1)%90;\n\n\n\n    /* debug printing finesignature */\n\n    if (av_log_get_level() == AV_LOG_DEBUG) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n\n        for (i = 0; i < 5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] );\n\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n\n        for (i = 0; i < SIGELEM_SIZE/5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] );\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n\n\n    if (FF_INLINK_IDX(inlink) == 0)\n\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n\n    return 1;\n\n}\n", "idx": 25859, "substitutes": {"inlink": ["inclog", "innlink", "inslog", "incli", "innframe", "inLink", " inlock", "insload", "innurl", "outurl", "inli", "innli", "outli", "incload", "inspath", "inslink", "inload", "inpath", "insframe", "innbase", "innlog", "inslock", "innlock", "innload", "innpath", "outlink", "inlock", "insbase", "incframe", "incurl", "incLink", " inbase", "inurl", "inlog", "inbase", "innLink", "inclink", " inpath", "inframe", "outLink"], "picref": ["picrel", "pinsdef", "icREF", "Picdef", "icreference", "picREF", "pinsrel", "pinreference", "Picnum", "pinREF", "pinsref", "PicREF", "pinsnum", "picreference", " picrel", "picdef", "PicRef", "Picreference", "pinref", "icref", "Picrel", "picnum", " picnum", "icRef", "picRef", "pinRef", "Picref", " picdef"], "ctx": ["context", "fc", "unc", "soc", "sci", "conf", "bc", "ca", "nc", "anc", "cc", "cp", "cms", "ctr", "ck", "cv", "conn", "cf", "Context", "cci", "src", "cam", "cs", "tc", "rc", "cm", "tx", "ctrl", "cca", "uc", "c", "pc", "lc", "cb", "cu", "ci"], "sic": ["isc", "shi", "soc", "sci", "bc", "anc", "voc", "ac", "sb", "cus", "org", "ics", "bitcoin", "ku", "priv", "cci", "icc", "sis", "uci", "ic", "ik", "tc", "acs", "irc", "sac", "cies", "si", "isu", "SEC", "ec", "sec", "lc", "cot", "pic", "SC", "usc", "osc", "sch", "ses", "userc"], "sc": ["isc", "context", "scope", "fc", "dc", "soc", "sci", "conf", "bc", "ca", "nc", "anc", "Sc", "cc", "cms", "sem", "asc", "cus", "mc", "ocr", "ck", "cer", "cv", "src", "config", "cam", "cl", "sche", "gb", "cs", "cr", "tc", "rc", "ctrl", "desc", "cca", "loc", "uc", "c", "sync", "git", "exec", "ec", "pc", "sec", "spec", "co", "esc", "SC", "osc", "usc", "RC", "scl", "cur"], "fs": ["flows", "fw", "fc", "ips", "sf", "qs", "df", "vs", "outs", "flags", "rows", "gs", "rs", "fits", "os", "fu", "gets", "ups", "fd", "fee", "fps", "ows", "bs", "FS", "obs", "raf", "ps", "ts", "Fs", "fields", "fp", "fi", "fts", "cf", "ks", "hs", "files", "rets", "ves", "vals", "cs", "s", "wcs", "lf", "acs", "fm", "ums", "ms", "xf", "ns", "feed", "fn", "xs", "ls", "bf", "frames", "ds", "fx", "fe", "irs", "sys", "fb"], "pot3": ["latd", "chan6", "lat3", "ft3", "ft6", "ft5", "lat5", "lat6", "ftd", "potd", "pot5", "chan3", "chand", "chan5", "pot6"], "wordvec": ["wordseq", "wavepad", "allvec", "wavevec", "Wvec", "allbuffer", "Wpad", "wordbuffer", "wavebuffer", "allpad", "allseq", "Wseq", "Wbuffer", "waveseq", "wordpad"], "s2usw": ["sblbusiw", "s2uwer", "s2buswe", "s2auswe", "sbluswer", "s2uw", "s2auswer", "s2uiw", "s2uswer", "s2uwe", "sbluswe", "sblusw", "s2busw", "s2ausiw", "sblbuswer", "sblbuswe", "s2uswe", "s2buswer", "s2busiw", "s2ausw", "sblusiw", "s2usiw", "sblbusw"], "wordt2b": ["wordint2w", "wordt0b", "wordinttoa", "wordt6a", "wordt2c", "wordint2b", "wordt6b", "wordt0a", "wordinttob", "wordttoc", "wordttoa", "wordt6w", "wordt2w", "wordttob", "wordt6c", "wordint2a", "wordt0w", "wordint2c", "wordt0c", "wordinttoc", "wordttow", "wordinttow", "wordt2a"], "intpic": ["charpic", "intstruct", "numpic", "charseq", "maxtoc", "maxpic", "charstruct", "inttoc", "maxseq", "chartoc", "intseq", "numstruct", "numtoc", "numseq", "maxstruct"], "rowcount": ["rowsnum", "bitlen", "bitcount", "byteCount", "bitCount", "bytecount", "bytenum", "rowslen", "bitnum", "bytelen", "rowCount", "rowsCount", "rownum", "rowlen", "rowscount"], "p": ["pi", "n", "sp", "r", "op", "g", "pp", "h", "pid", "m", "t", "s", "P", "e", "c", "d", "pc", "q", "data", "np", "pic", "o", "tp", "lp"], "inti": ["Inti", "intI", "indI", " intI", "Intj", "IntI", "indi", "indj"], "intj": ["indf", "netf", " intk", "netj", " intf", "intk", "intf", "indj", "netk", "indk"], "intjlut": ["floatiglull", "floatjlull", "intklus", "intiglus", "intklull", "intjlull", "intjlus", "intjlu", "floatiglut", "floatiglus", "intklut", "intgnus", "intiglull", "intgnu", "floatjlut", "floatjlus", "intgnut", "intgnull", "floatjlu", "intiglu", "intklu", "intiglut", "floatiglu"], "conflist": ["constrize", "constrst", "confline", "concline", "conflize", "coclst", "cocline", "confist", "confst", "conclize", "confize", "cofline", "constrist", "conflst", "conclist", "coflize", "coclist", "confine", "conclst", "coclize", "coflst", "coflist", "constrine"], "a": ["ai", "x", "n", "aa", "A", "ac", "r", "ae", "sa", "y", "m", "s", "u", "ar", "ak", "an", "e", "c", "d", "am", "ad", "o"], "b": ["x", "n", "r", "bs", "g", "rb", "wb", "l", "y", "v", "h", "ab", "s", "u", "eb", "e", "c", "d", "o", "B"], "denom": ["leno", "donum", "dono", "nanow", "nano", "lenom", "deno", "donom", "donow", "nanom", "nanum", "lenow", "denow", "lenum", "denum"], "i": ["x", "in", "li", "n", "z", "r", "g", "is", "l", "y", "v", "h", "m", "I", "u", "ii", "e", "c", "d", "ci", "o"], "j": ["x", "li", "n", "z", "sp", "r", "g", "l", "y", "v", "h", "ij", "m", "ii", "je", "jp", "e", "d", "uj", "o", "ji", "J"], "k": ["x", "ke", "n", "key", "ch", "z", "kl", "kw", "v", "y", "h", "ks", "sk", "K", "ik", "m", "s", "u", "ak", "ok", "e", "c", "ka", "q", "kk", "o", "ki"], "ternary": ["ternical", "signality", "ternaries", "primary", "primality", "signaries", "ternality", "signical", "literality", "literical", "primaries", "literaries", "signary", "literary", "primical"], "blocksum": ["outsumm", "ocksumm", "outsum", "ocksums", "ocksume", "outsums", "ocksum", "bitsums", "bitsum", "bitsume", "bitsumm", "blocksums", "blocksume", "outsume", "blocksumm"], "blocksize": ["framesizes", " blocksiz", "blocksizes", "framesize", "bitsizes", "framesizer", " blocksizer", " blocksizes", "bitsizer", "blocksiz", "blocksizer", "bitsize", "bitsiz", "framesiz"], "th": ["last", "num", "prime", "ch", "gh", "thin", "std", "bh", "col", "ctr", "oth", "sh", "sel", "row", "rate", "tr", "src", "skip", "batch", "comb", "first", "sec", "thread", "each", "ht", "mask", "eth", "kh", "rw"], "sum": ["Sum", "num", "seed", "weight", "hash", "mass", "count", "sub", "sh", "total", "add", "mem", "sa", "miss", "mix", "cost", "skip", "dev", "sym", "ums", "gam", "gram", "scale", "mean", "um", "sim", "min", "mask", "sign"], "w": ["x", "fw", "weight", "n", "win", "z", "W", "wa", "window", "r", "g", "kw", "y", "v", "h", "wx", "wan", "m", "u", "wi", "wh", "q", "sw", "rw"], "f": ["index", "x", "num", "fc", "n", "z", "info", "g", "field", "l", "v", "h", "m", "t", "F", "fm", "e", "c", "fn", "fa", "fen", "o", "fb"]}}
{"project": "qemu", "commit_id": "248de4a89915001e64176580d620d22b612e06f2", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862, "substitutes": {"ahci": ["avki", "ehcci", "yahci", "akcu", "ahsci", "coreci", "ehcin", "aksci", "ahii", "AHci", "ehcu", "actcu", "akci", "corecu", "amcu", "ohsi", "akcin", "ohlc", "ervcin", "hcium", "ohsci", "ahcium", "AHCI", "ahpi", "corecin", "amcia", "amci", "hrcu", "ahki", "ohcin", "ehcus", "aklc", "ohpi", "ervci", "ohci", "ehcit", "ahcin", "hrpi", "hcu", "amcit", "avci", "yahCI", "hci", "ohcit", "hcin", "amsi", "ghci", "hrcit", "avcu", "ohcci", "ahcit", "hrcia", "erci", "angci", "ahCI", "avcia", "hcia", "AHcci", "ahcia", "ahsi", "ohcu", "ahcus", "yahcit", "ahcu", "hrii", "corecia", "ghki", "hki", "ehlc", "hrlc", "ehci", "angcia", "actcin", "ehcium", "AHcit", "ehsi", "ahlc", "ohki", "amlc", "ghcus", "actcia", "amcci", "akcit", "ghcin", "ervcium", "ohcia", "ervcu", "akii", "actci", "yahcci", "ersci", "ehki", "ahcci", "ohii", "ohcus", "ehpi", "angcu", "angcin", "ehCI", "hrci", "ercin", "ercu", "akpi", "ghcu"], "cmd": ["x", "buf", "gz", "dc", "Cmd", "comm", "css", "help", "custom", "cmp", "nc", "func", "cp", "req", "cc", "cms", "col", "qq", "hw", "ctr", "ctx", "ctl", "pkg", "ck", "command", "conn", "wo", "cf", "scl", "config", "cl", "vc", "code", "grad", "core", "act", "cr", "cn", "prefix", "callback", "md", "cfg", "ctrl", "cm", "ct", "acl", "clean", "cgi", "setup", "addr", "cod", "c", "module", "gen", "msg", "cb", "cli", "cpp", "call", "cookie", "method", "client", "pipe", "phy", "cd"], "px": ["x", "plugin", "fc", "pl", "zx", "pi", "css", "wp", "xc", "cpu", "cc", "cp", "ico", "lex", "ffff", "xxx", "ctx", "mx", "vt", "cus", "ix", "pp", "cas", "fp", "xp", "wx", "pe", "py", "config", "cel", "xx", "p", "cs", "ux", "pex", "prefix", "xy", "cm", "ct", "pty", "amp", "pixel", "pt", "acy", "padding", "pc", "ss", "kit", "val", "cpp", "fx", "ci", "pos", "ff", "yp", "pm", "pointer", "pa"], "tx": ["x", "buf", "index", "context", "ra", "zx", "tri", "shape", "req", "text", "lex", "test", "xxx", "ax", "ctx", "Tx", "xa", "ctr", "pull", "r", "nt", "ps", "cas", "fp", "wx", "cf", "pe", "src", "tr", "cross", "xx", "hea", "ux", "pex", "t", "cr", "tc", "ex", "rh", "rc", "push", "addr", "txt", "loc", "rt", "pt", "TX", "xs", "trans", "pc", "ds", "q", "data", "fx", "temp", "rw", "ty", "cd"], "rx": ["x", "buf", "zx", "rf", "sr", "xc", "rin", "lr", "rs", "req", "lex", "ctx", "rd", "mx", "row", "r", "rb", "rex", "reader", "xp", "wx", "src", "ux", "rss", "rh", "cr", "prefix", "ex", "vr", "rc", "rl", "rt", "addr", "loc", "sync", "rm", "TX", "pc", "fx", "rr", "sw", "xxxxxxxx", "ry", "rw"], "ptr": ["x", "index", "buf", "rect", "port", "pg", "context", "sr", "rog", "xt", "proc", "cp", "req", "sth", "ffff", "ctr", "ctx", "fd", "fif", "prot", "cache", "pp", "dr", "fp", "xp", "ref", "cf", "tr", "src", "rw", "alloc", "tmp", "p", "code", "cr", "address", "vr", "wr", "rc", "po", "plug", "push", "rt", "addr", "loc", "pt", "pend", "pc", "buff", "Ptr", "fx", "pos", "pr", "eth", "pad", "temp", "pointer", "tty", "offset"]}}
{"project": "qemu", "commit_id": "ba737541edddf9d0026460eb7b1d1c599b4c8ae9", "target": 1, "func": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n", "idx": 25865, "substitutes": {"opaque": ["opaco", "opusacity", " opmA", "opaya", " opbuffer", "opusmA", " opaques", "opbuffer", "openaque", "ospaque", " opacity", "openaya", " opaco", "opusaya", "copbuffer", "ospbuffer", "opusaque", "opacity", "ospaco", "copaques", "opaques", "copaco", "copaque", "ospaques", "openacity", "openmA", "opmA", " opaya"], "addr": ["x", "buf", "index", "ext", "port", "rx", "align", "base", "mode", "slot", "nc", "ace", "aud", "ctx", "len", "ptr", "fd", "host", "prot", "size", "alt", "amd", "asm", "attr", "url", "ref", "part", "src", "code", "p", "cmd", "address", "prefix", "rc", "mac", "hop", "rt", "amp", "point", "start", "bridge", "pc", "layer", "data", "val", "ad", "pos", "eth", "adr", "pad", "ord", "pointer", "offset"], "g": ["gm", "vg", "pg", "gp", "erg", "gs", "gin", "agg", "game", "gc", "group", "gn", "gi", "mg", "v", "G", "rg", "go", "greg", "p", "gb", "gate", "eg", "m", "s", "ge", "u", "w", "cfg", "sg", "e", "gu", "c", "ig", "d", "gg", "i", "f", "msg", "gen", "gas", "tg", "ga", "bg"]}}
{"project": "FFmpeg", "commit_id": "ca402f32e392590a81a1381dab41c4f9c2c2f98a", "target": 1, "func": "static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    int64_t size;\n\n    AVIOContext *pb  = s->pb;\n\n    WAVContext    *wav = s->priv_data;\n\n    AVStream *st;\n\n    uint8_t guid[16];\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_riff, 16))\n\n        return -1;\n\n\n\n    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */\n\n        return -1;\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_wave, 16)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find wave guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    size = find_guid(pb, guid_fmt);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find fmt guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* subtract chunk header size - normal wav file doesn't count it */\n\n    ff_get_wav_header(pb, st->codec, size - 24);\n\n    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);\n\n\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n\n\n    av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n    size = find_guid(pb, guid_data);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find data guid\\n\");\n\n        return -1;\n\n    }\n\n    wav->data_end = avio_tell(pb) + size - 24;\n\n    wav->w64      = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 25868, "substitutes": {"s": ["js", "b", "sf", "in", "n", "sl", "qs", "sc", "sv", "S", "gs", "self", "i", "os", "rs", "less", "ops", "or", "ssl", "sb", "sp", "r", "g", "sts", "bs", "session", "ps", "ans", "ts", "es", "sa", "is", "v", "ks", "service", "p", "cs", "sym", "t", "south", "su", "ns", "sg", "si", "bis", "an", "e", "sync", "c", "ss", "f", "spec", "ls", "ds", "sing", "xs", "stat", "services", "sq", "sn", "server", "comments", "se", "ses", "sys", "as", "stats"], "ap": ["ai", "aps", "cap", "prop", "array", "pi", "mp", "pac", "wp", "ac", "cp", "sp", "arp", "pp", "attr", "au", "al", "dp", "ams", "att", "hp", "pc", "AP", "api", "am", "ad", "np", "tp", "pa"], "size": ["li", "count", "send", "fee", "function", "g", "cache", "ice", "p", "address", "args", "sea", "page", "scale", "si", "any", "sync", "gap", "sized", "sn", "ci", "name", "en", "x", "num", "shape", "six", "large", "SIZE", "external", "speed", "rc", "capacity", "desc", "small", "e", "c", "ui", "use", "grade", "sum", "offset", "ize", "ny", "value", "z", "or", "len", "ce", "empty", "code", "unit", "now", "cm", "ng", "esc", "who", "form", "date", "weight", "member", "source", "body", "zip", "day", "go", "time", "loc", "i", "sec", "content", "Size", "length", "handle"], "pb": ["b", "prop", "platform", "plugin", "pg", "bm", "pl", "mp", "fc", "pac", "parser", "wp", "bc", "prof", "rob", "bh", "proc", "cp", "summary", "vp", "sb", "ctx", "PB", "prot", "rb", "pkg", "pm", "wb", "cv", "pp", "fp", "bps", "hub", "pa", "ppa", "p", "gb", "ub", "xb", "tc", "ab", "dp", "pro", "db", "aph", "jp", "eb", "bp", "pd", "pc", "hp", "cb", "bf", "lb", "cpp", "api", "typ", "uf", "np", "orp", "tp", "lp", "verb", "fb"], "wav": ["buf", "waves", "mp", "wp", "aw", "wt", "voc", "writer", "wave", "aver", "WA", "craft", "audio", "av", "hw", "ave", "www", "sound", "wa", "avi", "aaaa", "wl", "wb", "cv", "aws", "mpeg", "kw", "wal", "wo", "music", "acc", "writers", "WS", "wan", "wcs", "w", "wi", "web", "wm", "uc", "af", "aux", "sw", "voice", "xml", "rw"], "st": ["sd", "sf", "ist", "sl", "ost", "sc", "std", "sth", "th", "sb", "sh", "sp", "r", "nt", "sts", "St", "stab", "sa", "be", "sam", "stim", "src", "stream", "sta", "cl", "p", "rest", "est", "fr", "ess", "cr", "ste", "ft", "inst", "ld", "obj", "ast", "t", "irst", "ct", "c", "pt", "start", "ss", "td", "ST", "str", "stage", "sn", "sw", "fe", "art", "so", "nd", "se", "stress"], "guid": ["squide", "uuid", "Guision", " guaid", "uuID", " guide", "ruide", "iuide", "uniqueider", "ruid", "uuidate", "uuide", "aguid", "gamiden", "ruids", "Gukid", "squision", "iuID", "grid", "ruID", "bugid", "GuID", "acision", "aguaid", " guID", "uniqueid", "acID", "gamid", "guision", "uniqueID", "gukid", " guider", "iuidate", "guider", "guiden", "acid", "grID", "Guiden", "aguider", "bugiden", "gamide", "Guide", "squID", "guaid", "gamkid", "gride", "grids", "bugide", "squid", " guidate", "aguID", "Guids", "bugkid", "guide", "Guid", "iuid", "acide", "guids", "guidate", "uniqueaid", "guID"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 25869, "substitutes": {"src": ["buf", "dist", "rect", "sl", "sc", "gl", "rob", "source", "http", "supp", "stack", "req", "sth", "sub", "sb", "ctx", "sel", "ssl", "rb", "url", "slice", "sur", "config", "rest", "gb", "rl", "inst", "rc", "input", "comp", "loc", "sync", "sup", "start", "img", "cb", "sq", "dest", "st", "scl", "cur"], "dst": ["sst", "iddest", "dbl", "sbl", "wst", "sST", "idST", " dST", "lst", "ddest", "lbl", "Ddest", "dsts", "wbl", "idsts", "Dst", "idst", "lsts", "lST", "dST", "DST", " ddest", " dsts", "Dsts", "wsts", "wST", "ssts"], "src_size": ["src_address", " src_address", "src_Size", "src_scale", " src_Size", " src_scale"], "i": ["index", "ai", "oi", "li", "pi", "n", "ji", "id", "j", "abi", "info", "iu", "hi", "gi", "bi", "l", "is", "v", "ti", "io", "mu", "y", "uri", "xi", "ini", "multi", "p", "qi", "zi", "m", "di", "I", "u", "it", "init", "ii", "k", "si", "e", "c", "d", "eni", "f", "ami", "cli", "adi", "api", "clip", "ori", "ui", "phi", "ci", "o", "ni", "ri", "a", "mi"], "b": ["x", "reb", "abb", "n", "big", "bb", "sb", "fb", "rb", "wb", "br", "bi", "l", "y", "v", "p", "gb", "m", "s", "ab", "u", "w", "db", "k", "e", "c", "d", "f", "o", "B", "a", "ob", "bg"], "g": ["x", "gm", "pg", "gp", "n", "gr", "big", "gh", "gs", "group", "gre", "gn", "gi", "l", "v", "y", "h", "rg", "G", "p", "gb", "m", "s", "ge", "u", "w", "gam", "sg", "k", "e", "gu", "c", "d", "gg", "f", "q", "o", "a", "ga", "bg"], "r": ["x", "sr", "n", "gr", "j", "rs", "er", "rb", "br", "l", "v", "h", "rg", "range", "p", "R", "m", "rl", "t", "s", "u", "w", "rc", "ur", "k", "e", "c", "d", "f", "q", "rr", "pr", "o", "ro", "nr", "a", "re"], "rgb": ["rbba", "cgb", "arpi", "brgb", "hgg", "brpi", " rgp", "wbg", "rgg", "lgd", "arbb", "rcgb", "rcgg", "rcg", " rgg", "rbg", "brgg", " rbg", "srgb", "nrgo", " rg", "rgd", " rbb", "lga", "rbgo", " rga", "hbb", "rgp", "cga", "rga", "cgg", " rgd", "rpi", "nrba", "cgd", "wgb", "rspi", "lgb", "rg", "nrgb", "argg", "rbb", "rbgd", "rba", "srgo", "wgg", "lgg", "rbgb", "rsgb", "srba", "hgb", "rgo", "rcgp", "brbb", "wbb", "arg", "nrgd", "argp", "srgd", "rsgg", "rsbb", "argb", "hbg"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872, "substitutes": {"job": ["b", "plugin", "worker", "run", "base", "child", "project", "j", "connection", "row", "game", "image", "group", "session", "command", "item", "work", "manager", "batch", "queue", "lock", "Job", "route", "line", "page", "db", "feed", "node", "block", "seq", "module", "cb", "layer", "event", "server", "section", "order", "ob"], "x": ["b", "index", "n", "path", "rx", "win", "z", "id", "shape", "dy", "X", "r", "image", "px", "ick", "l", "work", "wx", "v", "xi", "p", "xx", "code", "m", "t", "address", "dx", "xy", "ex", "loc", "point", "c", "d", "lat", "f", "i", "data", "pos", "name", "height", "a"], "y": ["b", "oy", "vy", "year", "Y", "ny", "z", "j", "wy", "cy", "dy", "yi", "ye", "type", "ys", "sy", "yo", "py", "ym", "p", "yt", "t", "ies", "xy", "zy", "c", "ey", "d", "i", "ya", "ay", "yy", "ry", "a", "ty"], "w": ["b", "fw", "weight", "n", "win", "wt", "z", "wid", "ow", "ew", "hw", "sh", "W", "wa", "r", "max", "l", "work", "wx", "v", "wd", "p", "m", "t", "u", "ex", "k", "c", "wh", "d", "f", "i", "length", "q", "sw", "o", "height", "a", "rw"], "h": ["b", "depth", "n", "oh", "home", "z", "gh", "dh", "hw", "sh", "r", "hi", "host", "size", "l", "v", "hs", "hm", "p", "m", "t", "rh", "u", "k", "e", "c", "ph", "d", "f", "i", "q", "H", "ht", "o", "height"], "entry": ["index", " Entry", "array", "Entry", "ie", "key", "path", "parent", "set", "child", "base", "inter", "id", "step", "member", "end", "connection", "or", "row", "info", "enter", "insert", "image", "update", "add", "reader", "item", "service", "inner", "queue", "route", "line", "ge", "ent", "it", "rc", "link", "si", "feed", "desc", "export", "e", "inc", "element", "module", "start", "import", "lc", "object", "next", "data", "cat", "event", "server", "section", "ry", "pointer", "post", "offset"]}}
{"project": "qemu", "commit_id": "54f254f973a1b2ed0f3571390f4de060adfe23e8", "target": 0, "func": "static void uhci_async_complete_packet(USBPacket * packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCI_QH qh;\n\n    UHCI_TD td;\n\n    uint32_t link;\n\n    uint32_t old_td_ctrl;\n\n    uint32_t val;\n\n    uint32_t frame_addr;\n\n    int ret;\n\n\n\n    /* Handle async isochronous packet completion */\n\n    frame_addr = s->async_frame_addr;\n\n    if (frame_addr) {\n\n        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);\n\n        le32_to_cpus(&link);\n\n\n\n        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret == 2) {\n\n            s->async_frame_addr = frame_addr;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            val = cpu_to_le32(td.link);\n\n            cpu_physical_memory_write(frame_addr,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 25925, "substitutes": {"packet": ["packer", "viewacket", "packacket", "octer", "comper", "viewet", "octets", "octet", "packets", "viewets", "octacket", "compets", "compet", "compacket", "viewer"], "opaque": ["ocayne", "ocque", " opec", "opusayne", "ocaque", "OPec", " opque", "OPc", "opayne", "ipc", "ipacs", "ipaque", "ipec", "OPacs", "opusaque", " opacs", "OPaque", "opque", " opc", "opusec", "opc", "opacs", "opusque", "ocec", "opec", " opayne"], "s": ["site", "b", "scope", "sf", "n", "sl", "secondary", "state", "S", "gs", "sv", "http", "self", "os", "rs", "summary", "ops", "ssl", "sb", "g", "storage", "session", "states", "ps", "params", "ts", "sa", "is", "single", "share", "service", "instance", "ssh", "p", "cs", "t", "socket", "sets", "side", "su", "ns", "sg", "si", "utils", "sie", "e", "sync", "c", "settings", "ss", "f", "spec", "ls", "services", "sq", "server", "o", "client", "se", "ses", "sys", "slave", "stats"], "qh": ["qbh", "iqhd", "khm", "qd", "idd", "iqh", "quH", " qrh", "qqh", "sqh", "questionh", "quh", "qhr", "qurh", "qqbh", " qhy", "questr", "iqhr", "sqr", "idh", "qe", "Qsh", "qhd", "QH", "questionhr", "questrh", " qe", "khs", "qsh", "qH", "sqd", "qhy", "qud", "dqbh", "qha", "Qc", "dqH", "que", "qhm", "questhy", "questionhd", "quha", "qhi", "quhm", "questhi", "Qe", "iqc", " qhr", " qha", "sqhi", "Qh", "qrh", "qur", "Qbh", " qc", "qc", "qqH", "qqsh", "kh", "qr", "quhi", "kd", "idhm", " qhd", "questh", "idhs", " qH", "questionc", "questd", "qhs", "dqh", "questha", "quhs", "quhy", "dqsh", "quc"], "td": [" dd", "sd", " TD", "pb", "dc", "sl", "fc", "dt", "dial", "pl", "bl", "tm", "TB", "butt", "std", "dll", "od", "hd", "dh", "th", "tf", "sb", "ctl", "rd", "ssl", "sel", "fd", "BT", "gt", "nt", "cz", "ud", "dn", "LD", "tr", "SD", "wd", "bd", "config", "gb", "primary", "PD", "nil", "tc", "di", "lf", "ld", "table", "md", "elt", "db", "txt", "dd", "cod", "pd", "d", "pt", "ds", "dat", "dl", "tab", "layer", "tn", "ad", "lt", "typ", "tif", "ff", "nd", "TD", "cd"], "link": ["loop", "li", "lag", "child", "id", "write", "ssl", "cache", "cell", "type", "url", "ref", "cross", "frame", "lock", "line", "lf", "read", "match", "address", "comment", "sync", "block", "dd", "co", "ci", "user", "ln", "network", "set", "path", "rel", "reply", "cp", "connection", "tag", "info", "hip", "field", "open", "l", "conn", "check", "style", "feed", "ind", "delay", "stat", "slave", "index", "error", "cmp", "Link", "self", "ace", "lib", "len", "group", "ck", "model", "light", "slice", "level", "label", "route", "di", "channel", "bug", "target", "lo", "ink", "data", "call", "reg", "follow", "focus", "weight", "base", "source", "lex", "control", "linked", "chain", "layout", "connect", "image", "pack", "dev", "ld", "local", "loc", "links", "load", "list", "length", "handle"], "old_td_ctrl": ["old_sd_ctrl", "old_td__trl", "old_sd_ctr", "old_dd_control", "old_td_lc", "old_dd_trl", "old_dd_ctrl", "old_td__control", "old_td_Ctrl", "old_sd_trl", "old_td_trl", "old_sd_Ctrl", "old_td_ctr", "old_sd_controller", "old_dd_lc", "old_td_controller", "old_td_control", "old_td__Ctrl", "old_sd_control", "old_td__ctrl"], "val": ["b", "bl", "li", "count", "eval", "sel", "result", "ref", "el", "elt", "serv", "play", "x", "key", "rel", "live", "err", "slot", "fat", "valid", "col", "bal", "vol", "al", "vals", "ee", "arg", "ol", "pt", "delay", "stat", "Val", "cond", "bin", "index", "lay", "value", "len", "bo", "update", "sol", "cal", "all", "VAL", "il", "pass", "unit", "def", "seq", "rot", "data", "call", "sl", "win", "base", "alt", "la", "put", "v", "part", "py", "store", "change", "fail", "local", "var", "loc", "doc", "lit", "ul", "fl"], "frame_addr": ["framekaddress", "frame67url", "frameacaddress", " frame_ptr", "frame__address", "frame_data", " frame_host", "frameachost", "frame__order", "frameingaddr", "frame64ptr", "frame64address", " frame_address", "frameinginfo", " frame_grad", "frame_info", "frame67addr", "frameacaddr", " frame_info", "frameingcallback", "frame67address", "frameingaddress", "frame_order", "frame64index", " frame_callback", "frame_len", "frame_callback", " frame_order", "frameamdata", "frameamurl", "frame_index", "framekaddr", "frame64info", "frame_ptr", "frame64callback", " frame_index", "frameacgrad", "frame__addr", " frame_align", "frame_grad", " frame_data", "framekorder", "frame_address", "frameamaddr", "framekalign", "frame67len", "frame_host", "frame_url", "frame64addr", " frame_len", "frame_align", " frame_url", "frame__align", "frameamaddress"], "ret": ["reply", "mt", "RET", "valid", "col", "let", "len", "final", "sel", "gt", "nt", " RET", "result", "alt", "resp", "mem", "det", "ref", "part", "al", "rev", "rets", "rl", "ft", "match", "def", "rc", "fun", "att", "arg", "rt", " Ret", "sec", "lit", "rep", "cat", "lt", "back", "Ret", "reg", "res", "flag", "bit", "opt", "success", "re", "cur"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n", "idx": 25932, "substitutes": {"req": ["ext", "dep", "iq", "dq", "rec", "mod", "rf", "rx", "gr", "err", "cmp", "progress", "proc", "sem", "loader", "ctr", "crit", "ctx", "pull", "r", "rb", "pkg", "qt", "dr", "ready", "request", "ref", "low", "require", "queue", "requ", "grad", "fr", "peer", "def", "obj", "push", "comp", "arg", "jp", "desc", "exec", "seq", "f", "hr", "cb", "msg", "next", "q", "call", "load", "rr", "sq", "str", "list", "org", "cur"], "bs": ["bc", "outs", "gs", "os", "bb", "bytes", "sb", "bid", "fs", "bal", "ps", "ts", "bi", "bt", "bps", "bu", "cs", "bas", "ns", "BS", "ss", "ls", "ds", "us", "ses", "bis", "as"], "serialising_in_flight": ["serialising_in_progress", "serialising_out_process", "serialising_out_queue", "serialising_in_queue", "serialising_in_process", "serialising_out_flight", "serialising_out_progress"]}}
{"project": "FFmpeg", "commit_id": "ac94b8bcc6cdba000ada0c84b4c287f7f37f2384", "target": 0, "func": "static int adpcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    ADPCMDecodeContext *c = avctx->priv_data;\n\n    ADPCMChannelStatus *cs;\n\n    int n, m, channel, i;\n\n    int block_predictor[2];\n\n    short *samples;\n\n    short *samples_end;\n\n    const uint8_t *src;\n\n    int st; /* stereo */\n\n\n\n    /* DK3 ADPCM accounting variables */\n\n    unsigned char last_byte = 0;\n\n    unsigned char nibble;\n\n    int decode_top_nibble_next = 0;\n\n    int diff_channel;\n\n\n\n    /* EA ADPCM state variables */\n\n    uint32_t samples_in_chunk;\n\n    int32_t previous_left_sample, previous_right_sample;\n\n    int32_t current_left_sample, current_right_sample;\n\n    int32_t next_left_sample, next_right_sample;\n\n    int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n\n    uint8_t shift_left, shift_right;\n\n    int count1, count2;\n\n    int coeff[2][2], shift[2];//used in EA MAXIS ADPCM\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    //should protect all 4bit ADPCM variants\n\n    //8 is needed for CODEC_ID_ADPCM_IMA_WAV with 2 channels\n\n    //\n\n    if(*data_size/4 < buf_size + 8)\n\n        return -1;\n\n\n\n    samples = data;\n\n    samples_end= samples + *data_size/2;\n\n    *data_size= 0;\n\n    src = buf;\n\n\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_IMA_QT:\n\n        n = buf_size - 2*avctx->channels;\n\n        for (channel = 0; channel < avctx->channels; channel++) {\n\n            int16_t predictor;\n\n            int step_index;\n\n            cs = &(c->status[channel]);\n\n            /* (pppppp) (piiiiiii) */\n\n\n\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n\n            predictor = AV_RB16(src);\n\n            step_index = predictor & 0x7F;\n\n            predictor &= 0xFF80;\n\n\n\n            src += 2;\n\n\n\n            if (cs->step_index == step_index) {\n\n                int diff = (int)predictor - cs->predictor;\n\n                if (diff < 0)\n\n                    diff = - diff;\n\n                if (diff > 0x7f)\n\n                    goto update;\n\n            } else {\n\n            update:\n\n                cs->step_index = step_index;\n\n                cs->predictor = predictor;\n\n            }\n\n\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n\n\n            samples = (short*)data + channel;\n\n\n\n            for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n\n                samples += avctx->channels;\n\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n\n                samples += avctx->channels;\n\n                src ++;\n\n            }\n\n        }\n\n        if (st)\n\n            samples--;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WAV:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n//        samples_per_block= (block_align-4*chanels)*8 / (bits_per_sample * chanels) + 1;\n\n\n\n        for(i=0; i<avctx->channels; i++){\n\n            cs = &(c->status[i]);\n\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n\n\n\n            cs->step_index = *src++;\n\n            if (cs->step_index > 88){\n\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n\n                cs->step_index = 88;\n\n            }\n\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n\n        }\n\n\n\n        while(src < buf + buf_size){\n\n            for(m=0; m<4; m++){\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] & 0x0F, 3);\n\n                for(i=0; i<=st; i++)\n\n                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] >> 4  , 3);\n\n                src++;\n\n            }\n\n            src += 4*st;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_4XM:\n\n        cs = &(c->status[0]);\n\n        c->status[0].predictor= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].predictor= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].step_index= (int16_t)bytestream_get_le16(&src);\n\n        if(st){\n\n            c->status[1].step_index= (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        if (cs->step_index < 0) cs->step_index = 0;\n\n        if (cs->step_index > 88) cs->step_index = 88;\n\n\n\n        m= (buf_size - (src - buf))>>st;\n\n        for(i=0; i<m; i++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] & 0x0F, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] & 0x0F, 4);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] >> 4, 4);\n\n            if (st)\n\n                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] >> 4, 4);\n\n        }\n\n\n\n        src += m<<st;\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_MS:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n        n = buf_size - 7 * avctx->channels;\n\n        if (n < 0)\n\n            return -1;\n\n        block_predictor[0] = av_clip(*src++, 0, 6);\n\n        block_predictor[1] = 0;\n\n        if (st)\n\n            block_predictor[1] = av_clip(*src++, 0, 6);\n\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n\n        if (st){\n\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n\n        }\n\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[0]];\n\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[0]];\n\n        c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor[1]];\n\n        c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor[1]];\n\n\n\n        c->status[0].sample1 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n\n        c->status[0].sample2 = bytestream_get_le16(&src);\n\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n\n\n\n        *samples++ = c->status[0].sample2;\n\n        if (st) *samples++ = c->status[1].sample2;\n\n        *samples++ = c->status[0].sample1;\n\n        if (st) *samples++ = c->status[1].sample1;\n\n        for(;n>0;n--) {\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n\n            src ++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK4:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        c->status[0].predictor  = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = *src++;\n\n        src++;\n\n        *samples++ = c->status[0].predictor;\n\n        if (st) {\n\n            c->status[1].predictor  = (int16_t)bytestream_get_le16(&src);\n\n            c->status[1].step_index = *src++;\n\n            src++;\n\n            *samples++ = c->status[1].predictor;\n\n        }\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_DK3:\n\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n\n            buf_size = avctx->block_align;\n\n\n\n        if(buf_size + 16 > (samples_end - samples)*3/8)\n\n            return -1;\n\n\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n\n        c->status[0].step_index = src[14];\n\n        c->status[1].step_index = src[15];\n\n        /* sign extend the predictors */\n\n        src += 16;\n\n        diff_channel = c->status[1].predictor;\n\n\n\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n\n         * the buffer is consumed */\n\n        while (1) {\n\n\n\n            /* for this algorithm, c->status[0] is the sum channel and\n\n             * c->status[1] is the diff channel */\n\n\n\n            /* process the first predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the diff channel predictor */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n\n\n            /* process the first pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n\n\n            /* process the second predictor of the sum channel */\n\n            DK3_GET_NEXT_NIBBLE();\n\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n\n\n            /* process the second pair of stereo PCM samples */\n\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_ISS:\n\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 0);\n\n        c->status[0].step_index = src[2];\n\n        src += 4;\n\n        if(st) {\n\n            c->status[1].predictor  = (int16_t)AV_RL16(src + 0);\n\n            c->status[1].step_index = src[2];\n\n            src += 4;\n\n        }\n\n\n\n        while (src < buf + buf_size) {\n\n            uint8_t v1, v2;\n\n            uint8_t v = *src++;\n\n            /* nibbles are swapped for mono */\n\n            if (st) {\n\n                v1 = v >> 4;\n\n                v2 = v & 0x0F;\n\n            } else {\n\n                v2 = v >> 4;\n\n                v1 = v & 0x0F;\n\n            }\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_XA:\n\n        while (buf_size >= 128) {\n\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n\n                avctx->channels);\n\n            src += 128;\n\n            samples += 28 * 8;\n\n            buf_size -= 128;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n        samples_in_chunk = bytestream_get_le32(&src) >> (1-st);\n\n\n\n        if (samples_in_chunk > buf_size-4-(8<<st)) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].step_index = bytestream_get_le32(&src);\n\n        for (i=0; i<=st; i++)\n\n            c->status[i].predictor  = bytestream_get_le32(&src);\n\n\n\n        for (; samples_in_chunk; samples_in_chunk--, src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n        for (; src < buf+buf_size; src++) {\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA:\n\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n\n           each coding 28 stereo samples. */\n\n        if (buf_size < 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        samples_in_chunk = AV_RL32(src);\n\n        if (samples_in_chunk / 28 > (buf_size - 12) / 30) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid frame\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        src += 4;\n\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n\n\n\n        for (count1 = 0; count1 < samples_in_chunk/28;count1++) {\n\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n\n            src++;\n\n\n\n            shift_left  = (*src >> 4  ) + 8;\n\n            shift_right = (*src & 0x0F) + 8;\n\n            src++;\n\n\n\n            for (count2 = 0; count2 < 28; count2++) {\n\n                next_left_sample  = (int32_t)((*src & 0xF0) << 24) >> shift_left;\n\n                next_right_sample = (int32_t)((*src & 0x0F) << 28) >> shift_right;\n\n                src++;\n\n\n\n                next_left_sample = (next_left_sample +\n\n                    (current_left_sample * coeff1l) +\n\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n\n                next_right_sample = (next_right_sample +\n\n                    (current_right_sample * coeff1r) +\n\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n\n\n                previous_left_sample = current_left_sample;\n\n                current_left_sample = av_clip_int16(next_left_sample);\n\n                previous_right_sample = current_right_sample;\n\n                current_right_sample = av_clip_int16(next_right_sample);\n\n                *samples++ = (unsigned short)current_left_sample;\n\n                *samples++ = (unsigned short)current_right_sample;\n\n            }\n\n        }\n\n\n\n        if (src - buf == buf_size - 2)\n\n            src += 2; // Skip terminating 0x0000\n\n\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n\n        for(channel = 0; channel < avctx->channels; channel++) {\n\n            for (i=0; i<2; i++)\n\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n\n            shift[channel] = (*src & 0x0F) + 8;\n\n            src++;\n\n        }\n\n        for (count1 = 0; count1 < (buf_size - avctx->channels) / avctx->channels; count1++) {\n\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n\n                for(channel = 0; channel < avctx->channels; channel++) {\n\n                    int32_t sample = (int32_t)(((*(src+channel) >> i) & 0x0F) << 0x1C) >> shift[channel];\n\n                    sample = (sample +\n\n                             c->status[channel].sample1 * coeff[channel][0] +\n\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n\n                    c->status[channel].sample2 = c->status[channel].sample1;\n\n                    c->status[channel].sample1 = av_clip_int16(sample);\n\n                    *samples++ = c->status[channel].sample1;\n\n                }\n\n            }\n\n            src+=avctx->channels;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_EA_R1:\n\n    case CODEC_ID_ADPCM_EA_R2:\n\n    case CODEC_ID_ADPCM_EA_R3: {\n\n        /* channel numbering\n\n           2chan: 0=fl, 1=fr\n\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n\n        int32_t previous_sample, current_sample, next_sample;\n\n        int32_t coeff1, coeff2;\n\n        uint8_t shift;\n\n        unsigned int channel;\n\n        uint16_t *samplesC;\n\n        const uint8_t *srcC;\n\n        const uint8_t *src_end = buf + buf_size;\n\n\n\n        samples_in_chunk = (big_endian ? bytestream_get_be32(&src)\n\n                                       : bytestream_get_le32(&src)) / 28;\n\n        if (samples_in_chunk > UINT32_MAX/(28*avctx->channels) ||\n\n            28*samples_in_chunk*avctx->channels > samples_end-samples) {\n\n            src += buf_size - 4;\n\n            break;\n\n        }\n\n\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n\n                                         : bytestream_get_le32(&src))\n\n                           + (avctx->channels-channel-1) * 4;\n\n\n\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n\n            srcC  = src + offset;\n\n            samplesC = samples + channel;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n\n            } else {\n\n                current_sample  = c->status[channel].predictor;\n\n                previous_sample = c->status[channel].prev_sample;\n\n            }\n\n\n\n            for (count1=0; count1<samples_in_chunk; count1++) {\n\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n\n                    srcC++;\n\n                    if (srcC > src_end - 30*2) break;\n\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n\n\n\n                    for (count2=0; count2<28; count2++) {\n\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                } else {\n\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n\n                    shift = (*srcC++ & 0x0F) + 8;\n\n\n\n                    if (srcC > src_end - 14) break;\n\n                    for (count2=0; count2<28; count2++) {\n\n                        if (count2 & 1)\n\n                            next_sample = (int32_t)((*srcC++ & 0x0F) << 28) >> shift;\n\n                        else\n\n                            next_sample = (int32_t)((*srcC   & 0xF0) << 24) >> shift;\n\n\n\n                        next_sample += (current_sample  * coeff1) +\n\n                                       (previous_sample * coeff2);\n\n                        next_sample = av_clip_int16(next_sample >> 8);\n\n\n\n                        previous_sample = current_sample;\n\n                        current_sample  = next_sample;\n\n                        *samplesC = current_sample;\n\n                        samplesC += avctx->channels;\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n\n                c->status[channel].predictor   = current_sample;\n\n                c->status[channel].prev_sample = previous_sample;\n\n            }\n\n        }\n\n\n\n        src = src + buf_size - (4 + 4*avctx->channels);\n\n        samples += 28 * samples_in_chunk * avctx->channels;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_EA_XAS:\n\n        if (samples_end-samples < 32*4*avctx->channels\n\n            || buf_size < (4+15)*4*avctx->channels) {\n\n            src += buf_size;\n\n            break;\n\n        }\n\n        for (channel=0; channel<avctx->channels; channel++) {\n\n            int coeff[2][4], shift[4];\n\n            short *s2, *s = &samples[channel];\n\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n\n                for (i=0; i<2; i++)\n\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n\n                shift[n] = (src[2]&0x0F) + 8;\n\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n\n            }\n\n\n\n            for (m=2; m<32; m+=2) {\n\n                s = &samples[m*avctx->channels + channel];\n\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n\n                        int level = (int32_t)((*src & (0xF0>>i)) << (24+i)) >> shift[n];\n\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        samples += 32*4*avctx->channels;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_AMV:\n\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n\n        c->status[0].step_index = bytestream_get_le16(&src);\n\n\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n            src+=4;\n\n\n\n        while (src < buf + buf_size) {\n\n            char hi, lo;\n\n            lo = *src & 0x0F;\n\n            hi = *src >> 4;\n\n\n\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n\n                FFSWAP(char, hi, lo);\n\n\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                lo, 3);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n\n                hi, 3);\n\n            src++;\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_CT:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SBPRO_4:\n\n    case CODEC_ID_ADPCM_SBPRO_3:\n\n    case CODEC_ID_ADPCM_SBPRO_2:\n\n        if (!c->status[0].step_index) {\n\n            /* the first byte is a raw sample */\n\n            *samples++ = 128 * (*src++ - 0x80);\n\n            if (st)\n\n              *samples++ = 128 * (*src++ - 0x80);\n\n            c->status[0].step_index = 1;\n\n        }\n\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n\n            while (src < buf + buf_size) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] >> 4, 4, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x0F, 4, 0);\n\n                src++;\n\n            }\n\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n\n            while (src < buf + buf_size && samples + 2 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 5        , 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x07, 3, 0);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    src[0] & 0x03, 2, 0);\n\n                src++;\n\n            }\n\n        } else {\n\n            while (src < buf + buf_size && samples + 3 < samples_end) {\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                     src[0] >> 6        , 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    (src[0] >> 4) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n\n                    (src[0] >> 2) & 0x03, 2, 2);\n\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n\n                    src[0] & 0x03, 2, 2);\n\n                src++;\n\n            }\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_SWF:\n\n    {\n\n        GetBitContext gb;\n\n        const int *table;\n\n        int k0, signmask, nb_bits, count;\n\n        int size = buf_size*8;\n\n\n\n        init_get_bits(&gb, buf, size);\n\n\n\n        //read bits & initial values\n\n        nb_bits = get_bits(&gb, 2)+2;\n\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n\n        table = swf_index_tables[nb_bits-2];\n\n        k0 = 1 << (nb_bits-2);\n\n        signmask = 1 << (nb_bits-1);\n\n\n\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n\n                c->status[i].step_index = get_bits(&gb, 6);\n\n            }\n\n\n\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n\n                int i;\n\n\n\n                for (i = 0; i < avctx->channels; i++) {\n\n                    // similar to IMA adpcm\n\n                    int delta = get_bits(&gb, nb_bits);\n\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n\n                    int k = k0;\n\n\n\n                    do {\n\n                        if (delta & k)\n\n                            vpdiff += step;\n\n                        step >>= 1;\n\n                        k >>= 1;\n\n                    } while(k);\n\n                    vpdiff += step;\n\n\n\n                    if (delta & signmask)\n\n                        c->status[i].predictor -= vpdiff;\n\n                    else\n\n                        c->status[i].predictor += vpdiff;\n\n\n\n                    c->status[i].step_index += table[delta & (~signmask)];\n\n\n\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n\n\n\n                    *samples++ = c->status[i].predictor;\n\n                    if (samples >= samples_end) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        src += buf_size;\n\n        break;\n\n    }\n\n    case CODEC_ID_ADPCM_YAMAHA:\n\n        while (src < buf + buf_size) {\n\n            uint8_t v = *src++;\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n\n        }\n\n        break;\n\n    case CODEC_ID_ADPCM_THP:\n\n    {\n\n        int table[2][16];\n\n        unsigned int samplecnt;\n\n        int prev[2][2];\n\n        int ch;\n\n\n\n        if (buf_size < 80) {\n\n            av_log(avctx, AV_LOG_ERROR, \"frame too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        src+=4;\n\n        samplecnt = bytestream_get_be32(&src);\n\n\n\n        for (i = 0; i < 32; i++)\n\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        /* Initialize the previous sample.  */\n\n        for (i = 0; i < 4; i++)\n\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        if (samplecnt >= (samples_end - samples) /  (st + 1)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (ch = 0; ch <= st; ch++) {\n\n            samples = (unsigned short *) data + ch;\n\n\n\n            /* Read in every sample for this channel.  */\n\n            for (i = 0; i < samplecnt / 14; i++) {\n\n                int index = (*src >> 4) & 7;\n\n                unsigned int exp = 28 - (*src++ & 15);\n\n                int factor1 = table[ch][index * 2];\n\n                int factor2 = table[ch][index * 2 + 1];\n\n\n\n                /* Decode 14 samples.  */\n\n                for (n = 0; n < 14; n++) {\n\n                    int32_t sampledat;\n\n                    if(n&1) sampledat=  *src++    <<28;\n\n                    else    sampledat= (*src&0xF0)<<24;\n\n\n\n                    sampledat = ((prev[ch][0]*factor1\n\n                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);\n\n                    *samples = av_clip_int16(sampledat);\n\n                    prev[ch][1] = prev[ch][0];\n\n                    prev[ch][0] = *samples++;\n\n\n\n                    /* In case of stereo, skip one sample, this sample\n\n                       is for the other channel.  */\n\n                    samples += st;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* In the previous loop, in case stereo is used, samples is\n\n           increased exactly one time too often.  */\n\n        samples -= st;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 25936, "substitutes": {"avctx": ["navctx", "Avcf", "avalcmp", "avxc", "ovcf", "navconfig", "awcontext", "afqa", "Avcmp", "avalconv", "AVloc", " avcmp", "AVconv", "evcontext", "avcf", "afloc", "avalctx", "ovpkg", "afctx", "afpkg", "ovctx", "Avcontext", "ovcontext", "awclient", "evpkg", "afcmp", "afconv", "afxc", "avcontext", "avconv", "afclient", "AVcmp", "awctx", "navcontext", "AVcontext", " avclient", "evcf", " avqa", "avpkg", "AVcf", "Avctx", " avxc", "avloc", "awqa", " avcontext", "afcf", "evctx", "AVconfig", "navloc", "avconfig", "avclient", "avcmp", " avcf", "avqa", "afcontext", "avalcontext", "afconfig", "AVctx", "AVxc"], "data": ["database", "array", "results", "a", "base", "da", "blocks", "source", "connection", "body", "bytes", "DATA", "len", "window", "image", "cache", "size", "result", "new", "open", "reader", "raw", "zero", "slice", "config", "frame", "empty", "batch", "queue", "multi", "package", "Data", "one", "buffer", "input", "first", "sample", "media", "pad", "block", "d", "start", "module", "next", "load", "content", "pos", "client", "memory", "dat", "video", "bin", "buff"], "data_size": ["dataqsize", "batch_scale", "batch_width", "data_center", "data_length", "data\u00b7size", "block_size", "message_width", "data\u00b7scale", "dataqscale", "data_width", "batch_end", "data_fee", "batch_size", "data_count", "dataqend", "data\u00b7number", "dataqwidth", "data_end", " data_center", "message_length", " data_fee", "data\u00b7range", "data_number", "message_count", "block_number", "block_range", " data_scale", "data_scale", "message_size", "data_range", "block_scale"], "avpkt": ["avpqt", "avtct", "avccht", "avcpkt", "aimtqt", "avPct", "avcpck", "avckg", "avwpkt", "avcpcp", "avpct", "abpcht", "avfacket", "avwpck", "avppkt", "affcp", "abcpkt", "avfck", "avcpqt", "abcpct", "avpcht", "affacket", "affkt", "affck", "aimpkt", "aimpct", "avpacket", "abcpcht", "abcpkg", "abpct", "aimpqt", "avppct", "abpkg", "avPkt", "abpkt", "avcpct", "avtcp", "avpck", "avcpacket", "aimpcp", "afpacket", "avPqt", "avppcht", "avfkt", "avcpkg", "avpkg", "avcct", "avPcp", "avckt", "avtkt", "aimtkt", "avwpcp", "aimtcp", "avppkg", "afpck", "avfcp", "afpkt", "afpcp", "avcpcht", "aimtct", "avpcp", "avwpacket", "avtqt"], "buf": ["b", "port", "array", "box", "bc", "vec", "proc", "func", "text", "bytes", "rb", "cache", "wb", "cv", "br", "result", "cas", "fp", "raw", "cf", "pool", "config", "batch", "queue", "alloc", "tmp", "cmd", "rc", "buffer", "uc", "bag", "seq", "msg", "cb", "uf", "fb", "buff"], "c": ["dc", "sc", "bc", "cmp", "ca", "nc", "ac", "cc", "cp", "ctx", "mc", "g", "conn", "cf", "con", "cam", "vc", "p", "cn", "C", "cm", "ct", "e", "pc", "ec", "lc", "cb", "co", "cu", "ci", "cd"], "cs": ["css", "qs", "sc", "vs", "bc", "nc", "gs", "ac", "cc", "cp", "rs", "cms", "os", "Cs", "ctx", "CS", "cus", "fs", "bs", "cache", "ics", "cv", "ps", "ts", "cas", "ks", "cf", "sk", "hs", "ras", "vc", "cells", "wcs", "cn", "acs", "args", "rc", "cm", "ns", "sync", "eps", "cons", "ec", "pc", "lc", "spec", "ds", "ls", "ss", "stats"], "n": ["x", "b", "network", "num", "nb", "z", "j", "nc", "N", "net", "nor", "len", "ne", "r", "nt", "g", "l", "v", "p", "t", "cn", "nn", "u", "w", "k", "e", "fn", "d", "f", "sn", "np", "o", "nm", "en"], "m": ["num", "mon", "mid", "mode", "mn", "r", "mc", "g", "dim", "v", "y", "h", "M", "p", "man", "dm", "u", "w", "cm", "e", "d", "f", "middle", "mm", "o", "nm", "en", "mi"], "channel": ["index", "que", "error", "sc", "member", "mode", "course", "source", "direction", "nc", "nick", "shape", "ko", "message", "connection", "chn", "col", "board", "category", "consumer", "group", "number", "type", "cv", "cycle", "chron", "session", "character", "controller", "resource", "open", "stream", "config", "con", "version", "container", "change", "queue", "wan", "core", "chat", "unit", "page", "rc", "cm", "scale", "target", "cup", "sync", "block", "uc", "can", "component", "gap", "layer", "second", "event", "ann", "server", "qa", "client", "name", "video", "chan"], "i": ["x", "b", "ai", "index", "li", "pi", "id", "j", "iu", "ip", "ti", "v", "h", "ini", "p", "di", "I", "u", "ii", "si", "d", "f", "ui", "ci", "ni", "mi"], "block_predictor": ["block_ppector", "block_pempter", "block_predictation", "block_npredictable", "block_predicter", "block_npemptable", "block_npredicter", "block_pemptation", "block_predictable", "block_pemptor", "block_ppectable", "block_pemptable", "block_npempter", "block_npredictation", "block_pveyable", "block_npemptor", "block_pveyation", "block_pveyor", "block_pveyer", "block_npredictor", "block_ppecter", "block_npemptation", "block_ppectation"], "samples": ["ssessions", "Samps", "sesources", "Sources", "ssamps", "offsums", "samps", "sesessions", "testsamps", "offsources", "Sample", "sums", "ssources", "offsamples", "sources", "sesamps", "pample", "sesample", "testsessions", "ssamples", "setsums", "setsources", "offsamps", "sample", "Sums", "testsamples", "pamps", "setsamps", "sesamples", "setsamples", "testsources", "sessions", "pamples", "Samples", "pources"], "samples_end": ["sips_end", "samples_begin", "sources_start", "samples_max", "samples_edge", "sips__max", "sips_max", "samples___size", "samples_start", "samples_size", "samples___end", "sources_size", "samples___start", "sips__begin", "sources_edge", "samples___edge", "samples__max", "sips__end", "samples__begin", "sources_end", "samples__end", "sips_begin"], "src": ["dist", "seed", "rect", "dc", "sl", "sr", "sc", "gl", "bc", "cmp", "supp", "source", "nc", "proc", "sid", "ctx", "sb", "sel", "ctr", "ptr", "rb", "attr", "url", "slice", "sur", "uri", "stream", "config", "tmp", "chrom", "inst", "rc", "input", "loc", "sync", "uc", "seq", "sup", "uint", "img", "component", "cb", "sec", "spec", "sn", "dest", "RC", "video", "fl", "chan"], "st": ["set", "sc", "state", "std", "nc", "stop", "stack", "sth", "sh", "sb", "nt", "sts", "St", " stride", "stream", "store", "sta", "cl", "rest", "est", "stage", "t", "ste", "inst", "ct", "si", "sync", "start", "ss", "ST", "str", "since", "sw", "ci", "sn", "fe", "nd", "se", "step"], "nibble": [" nig", "rnistor", "pnibble", "pnseq", " nseq", "nseq", "pnistor", "rnibble", "nistor", "rnseq", "nig", " nistor", "rnig", "pnig"], "diff_channel": ["diff_group", " difference_error", "diff_error", " difference_size", " difference_group", " difference_channel", "diff_size"], "samples_in_chunk": ["samples_in_funks", "samples_in_Chunk", "samples_in_Chacket", "samples_in_packet", "samples_in_chace", "samples_in_chacket", "samples_in_facket", "samples_in_pace", "samples_in_punks", "samples_in_Chunks", "samples_in_face", "samples_in_Chace", "samples_in_punk", "samples_in_chunks", "samples_in_funk"], "previous_left_sample": ["previous_leftxsample", "previous_left_pipe", "previous_leftxpipe", "previous_leftxSample", "previous_left_Sample", "previous_right_pipe", "previous_right_part", "previous_left_part", "previous_right_Sample", "previous_leftxpart"], "previous_right_sample": ["previous_left_sequence", "previous_left_Sample", "previous_right_sequence", "previous_right_Sample"], "current_left_sample": ["current_leftmmSample", "current_right_part", "current_left_charge", "current_right_charge", "current_right_Sample", "current_leftmmsample", "current_left_Sample", "current_left_part", "current_leftmmcharge", "current_leftmmpart"], "current_right_sample": ["current_left_size", "current_right_size", "current_right_Sample", "current_left_Sample"], "next_left_sample": ["next_left_step", "next_left_Sample", "next_right_Sample", "next_right_bin", "next_right_step", "next_left_bin"], "next_right_sample": ["next_right_group", "next_left_Sample", "next_right_Sample", "next_left_group", "next_right_scale", "next_left_scale"], "coeff1l": ["coeff_b", "coeff_d", "coeff1d", "coef1d", "coef1b", "coeff_l", "coef1r", "coeff_r", "coef1l", "coeff2d", "coeff1b", "coeff2b"], "coeff2l": ["coeff5r", "coff2l", "coeff4l", "coff1b", "coeff4b", "coff2d", "coeff1d", "coff1d", "coff2r", "coeff5l", "coeff2d", "coeff5d", "coeff4d", "coeff5b", "coff2b", "coff1l", "coeff1b", "coeff2b", "coff1r", "coeff4r"], "coeff1r": ["coff2l", "coff1p", "coeff1n", "coeff4l", "coeff4n", "coff2p", "coff2r", "coeff_l", "coeff_p", "coeff4p", "coeff_r", "coeff_n", "coeff2n", "coeff1p", "coff1l", "coff1r", "coeff2p", "coeff4r", "coff1n", "coff2n"], "coeff2r": ["coeff5r", "coef2p", "coeff4l", "coef2l", "coeff4R", "coeff5R", "coef1R", "coef1p", "coeff2R", "coef2r", "coef1r", "coeff4p", "coef2R", "coeff5l", "coef1l", "coeff1p", "coeff1R", "coeff2p", "coeff4r", "coeff5p"], "shift_left": ["shift_l", " shift_l", " shift2left", " shift2l", " shift2right", "shift2left", "shift2right", "shift2l"], "shift_right": ["shift_r", " shift2left", " shift_r", "shift1right", " shift2right", "shift2r", "shift1left", "shift2left", "shift2right", "shift1r", " shift2r"], "count1": ["Count1", "count01", "seq1", "Count2", "seqone", "seq01", "Countone", "Count01", " countone", "countone", " count01", "seq2"], "count2": ["weight2", "count5", " count5", "weight1", "shift5", "shift4", " count4", "weight5", "shift2", "shift1", "weight4", "count4"], "coeff": [" coff", "collef", "collefficient", "collff", " coef", "Coefficient", "coef", "coff", "Coff", "colleff", "Coeff", "coefficient", "Coef", " coefficient"], "shift": ["dist", "seed", "set", "align", "repeat", "shape", "pull", "pop", "transform", "mix", "slice", "hift", "power", "Shift", "change", "reverse", "push", "center", "scale", "carry", "sample", "gap", "mask", "pad", "sum", "offset"], "predictor": ["ppectors", " pvictors", "predictori", " pacherors", "pvicter", "nriptor", "pvictors", "pvictoria", "pceleror", "predictrator", "pcelerior", "pcelerrator", "preredictor", "nredictori", " pvictation", "predicter", "ppredutor", "predictior", "pruptrator", "pributation", " pacheristor", " pacheror", "paitoria", " pveyors", "ppectistor", "paitors", " predictutor", "pacheror", " predictistor", "ppredors", "pruptior", "pcorrecture", "preruptior", "ppredation", "nredicture", "pacherion", "nredictorer", " predictation", " predicter", "predictorer", "pcorrecter", "pributure", " predictori", "predicture", "priptorer", "pveyer", " pveyer", "priptori", " prediction", "predictutor", "pvictation", "pributor", "pcorrector", "pvictutor", "ppector", "pributors", "predictation", "predictistor", " pvictor", "pruptors", " pvictutor", "pripture", " pveyori", "pvictrator", "preredictior", "nredictor", "ppection", " predictors", "pacherors", "pvictor", "pcelerors", "preruptrator", "pvictistor", "ppredor", "paiter", " pacherion", "pcorrectorer", "pruptor", "preruptors", " pvictoria", "pveyors", "prediction", "preruptor", "pviction", "priptor", "pributori", "pcorrectori", "predictoria", "pributorer", "pveyori", "pvictior", " pvicter", "pacheristor", "nriptori", "nriptorer", "paitor", " predictoria", "preredictors", "nripture", "pveyor", " pveyor", "pribututor", "preredictrator", "predictors", "pcorrectors"], "step_index": ["code___offset", "step2info", "step_header", "action_type", "stepxindex", " step_count", "step___end", "stepflowindex", "stepxtype", "step___offset", "step___header", "actionxindex", "stepflowoffset", "step64position", "step_num", " step_offset", "step_count", "code___header", "stepPsize", "code___index", "step_length", "stepPindex", "stepflowend", " step_size", "step64index", "step2index", "action_num", "code___end", "stepflowheader", "actionxinfo", " step_length", "actionxtype", "actionxnum", "step2num", "step_size", "step_type", "step2type", "code_header", "step64count", "code_index", "action_info", "action_index", "step_end", "step_position", " step_position", "code_end", "step_info", "stepxnum", "step_offset", "step64length", "stepPoffset", "code_offset", "step___index", "stepxinfo"]}}
{"project": "FFmpeg", "commit_id": "50cbe09d8ced75422571d29bbec1f35a33a0d3ed", "target": 0, "func": "static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)\n\n{\n\n    int res;\n\n    HuffContext huff;\n\n    HuffContext tmp1, tmp2;\n\n    VLC vlc[2] = { { 0 } };\n\n    int escapes[3];\n\n    DBCtx ctx;\n\n    int err = 0;\n\n\n\n    if(size >= UINT_MAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"size too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    tmp1.length = 256;\n\n    tmp1.maxlength = 0;\n\n    tmp1.current = 0;\n\n    tmp1.bits = av_mallocz(256 * 4);\n\n    tmp1.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp1.values = av_mallocz(256 * sizeof(int));\n\n\n\n    tmp2.length = 256;\n\n    tmp2.maxlength = 0;\n\n    tmp2.current = 0;\n\n    tmp2.bits = av_mallocz(256 * 4);\n\n    tmp2.lengths = av_mallocz(256 * sizeof(int));\n\n    tmp2.values = av_mallocz(256 * sizeof(int));\n\n\n\n    if(get_bits1(gb)) {\n\n        smacker_decode_tree(gb, &tmp1, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp1.current > 1) {\n\n            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,\n\n                        tmp1.lengths, sizeof(int), sizeof(int),\n\n                        tmp1.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[0].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping low bytes tree\\n\");\n\n    }\n\n    if(get_bits1(gb)){\n\n        smacker_decode_tree(gb, &tmp2, 0, 0);\n\n        skip_bits1(gb);\n\n        if(tmp2.current > 1) {\n\n            res = init_vlc(&vlc[1], SMKTREE_BITS, tmp2.length,\n\n                        tmp2.lengths, sizeof(int), sizeof(int),\n\n                        tmp2.bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n\n            if(res < 0) {\n\n                av_log(smk->avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (!vlc[1].table) {\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"Skipping high bytes tree\\n\");\n\n    }\n\n\n\n    escapes[0]  = get_bits(gb, 16);\n\n    escapes[1]  = get_bits(gb, 16);\n\n    escapes[2]  = get_bits(gb, 16);\n\n\n\n    last[0] = last[1] = last[2] = -1;\n\n\n\n    ctx.escapes[0] = escapes[0];\n\n    ctx.escapes[1] = escapes[1];\n\n    ctx.escapes[2] = escapes[2];\n\n    ctx.v1 = &vlc[0];\n\n    ctx.v2 = &vlc[1];\n\n    ctx.recode1 = tmp1.values;\n\n    ctx.recode2 = tmp2.values;\n\n    ctx.last = last;\n\n\n\n    huff.length = ((size + 3) >> 2) + 3;\n\n    huff.maxlength = 0;\n\n    huff.current = 0;\n\n    huff.values = av_mallocz(huff.length * sizeof(int));\n\n\n\n    if (smacker_decode_bigtree(gb, &huff, &ctx) < 0)\n\n        err = -1;\n\n    skip_bits1(gb);\n\n    if(ctx.last[0] == -1) ctx.last[0] = huff.current++;\n\n    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;\n\n    if(ctx.last[2] == -1) ctx.last[2] = huff.current++;\n\n    if(huff.current > huff.length){\n\n        ctx.last[0] = ctx.last[1] = ctx.last[2] = 1;\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"bigtree damaged\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    *recodes = huff.values;\n\n\n\n    if(vlc[0].table)\n\n        ff_free_vlc(&vlc[0]);\n\n    if(vlc[1].table)\n\n        ff_free_vlc(&vlc[1]);\n\n    av_free(tmp1.bits);\n\n    av_free(tmp1.lengths);\n\n    av_free(tmp1.values);\n\n    av_free(tmp2.bits);\n\n    av_free(tmp2.lengths);\n\n    av_free(tmp2.values);\n\n\n\n    return err;\n\n}\n", "idx": 25937, "substitutes": {"smk": ["limK", "spK", "snkt", " smck", "smijk", "spkt", "spk", "ismck", "snK", "smke", "Smks", " smc", "mmak", "slck", "spak", "limkt", "smc", "spks", "SMk", "slks", "SMK", "Smck", "snk", "slkt", "Smke", " smke", "Smk", "mmk", "mmK", "smck", "slk", "ismks", "ismke", "smK", "mmkt", "limijk", "smks", "SMijk", "slc", "slK", "limk", "SMkt", "slijk", "spc", "spck", "smak", "snak", "smkt", " smks", "ismk"], "gb": ["gow", "gm", "bm", "gz", "gp", "abb", "plugin", "vm", "nb", "bc", "tm", "gh", "gs", "hd", "gin", "bb", "ubs", "sb", "binary", "agg", "gt", "rb", "storage", "g", "bn", "gn", "gd", "bt", "bps", "rg", "hub", "bd", "ym", "py", "hm", "GB", "gy", "cmd", "mb", "cfg", "cgi", "gam", "db", "eb", "phy", "cod", "git", "bp", "gg", "pc", "gnu", "cb", "bf", "api", "usb", "tg", "kb", "ga", "bg"], "recodes": [" recoding", "reodes", "recode", " recode", "reoding", "Recoding", "records", "Recodes", "Recode", "Records", "reords", "recoding", " records", "reode"], "last": ["depth", "after", "parent", "child", "prev", "events", "count", "end", "full", "final", "total", "cache", "max", "br", "cycle", "tests", "batch", "code", "first", "latest", "region", "loc", "cycles", "recent", "extra", "next", "used", "cur"], "size": ["n", "ize", "shape", "count", "timeout", "bytes", "len", "fee", "g", "cache", "max", "six", "SIZE", "code", "s", "address", "cm", "capacity", "scale", "si", "small", "loc", "c", "extra", "i", "sized", "data", "Size", "out", "name", "length"], "res": ["js", "Res", "results", "details", "css", "ids", "resolution", "error", "ret", "err", "id", "gr", "rows", "ons", "count", "rs", "os", "acts", "resh", "pres", "r", "powers", "cache", "result", "RES", "resp", "params", "ps", "br", "sol", "ver", "rev", "ras", "rez", "code", "vals", "arr", "ress", "rest", "rss", "rh", "ex", "rc", "ms", "eps", "cons", "rep", "val", "out", "reg", "nos", "pos", "re"], "huff": [" Huff", " huf", " dhuff", "huffy", " Huffy", " dhuffy", " dhuf", " huffy", " Huf", " Hazz", " hazz", "hazz", "huf", " dhazz"], "tmp1": ["tmp5", "config3", "tmp17", "mp3", "eltall", "tmp6", "txtn", "temp01", "tmpall", "tmp3", "txt1", "tmpn", "tempone", "config01", " tmp81", "proc1", "tmp0", " tmp8", "jp1", "jp8", "jpn", "temp8", "txt4", "tmp8", "attr1", "txt6", "tmp01", "ppa1", "temp2", " tmp0", "proc2", "mp0", "mpone", "elt1", "attrone", " tmp5", "tempn", "mp2", " tmpall", "mp01", "proc0", "txt2", "temp5", "mp1", " tmp17", "tmp4", " tmp6", "temp17", "temp1", "attr81", " tmpn", " tmpone", "txtone", "txt0", "tmpone", "mpn", " tmp01", "config1", "elt2", "tmp81", "mpall", "temp6", "ppa5", "ppaone", "jp01", "mp5", "txt81", "ppa17", "elt0", "config2", "temp4", " tmp4", " tmp3", "temp0"], "tmp2": ["appsecond", "tpTwo", "app22", "id", "rt02", "rt0", "temp42", "tmp6", "tmp22", "temptwo", "txt1", "attr8", "tmp14", "attrsecond", "tmp0", " tmp8", "attr4", "temp8", "txt4", "tmp8", "metadata2", "txt6", "temp2", " tmp02", " tmp0", "vtTwo", "temp02", "tmpTwo", "metadatasecond", "app4", "mp2", "rttwo", "txt2", "vt2", "metadata14", "mp1", "txt02", "txt22", "temp22", "attr2", "tmp42", "tmp4", "txt42", " tmp6", "bytes", "txt0", "all", " tmpsecond", "s", "tempsecond", "rt2", "txtsecond", "mp02", "temp0", "metadata8", "tptwo", "vttwo", "mp4", "temp6", "attr0", " tmp14", " tmpTwo", "r", "tmp02", "tp2", " tmptwo", "app2", "temp4", "tmpsecond", "attr14", " tmp4", "tmptwo", "txt8", "attr42"], "vlc": ["vlcs", "tlcs", "lvcs", "vldc", "llcs", "ellci", "tldc", "nlt", "elll", "vll", "ervl", "lvp", "nlp", "rlc", "rll", "tlt", "lvt", "lvc", "rlci", "ervcs", "ervc", "svp", "lvdc", "nlc", "ellcs", "vlp", "svf", "llt", "tlc", "ellc", "ervci", "rlcs", "llc", "nlf", "svt", "vlt", "vlf", "lvf", "vlci", "lldc", "svc"], "escapes": ["secapes", "shaped", "secopes", "regaped", "secaped", "regaps", "escaps", "shaps", "shopes", "shapes", "escopes", "escaped", "secaps", "regopes", "regapes"], "ctx": ["buf", "context", "scope", "parent", "sc", "bc", "cmp", "ca", "cc", "lib", "cache", "ce", "cf", "Context", "config", "cs", "cr", "cm", "ctrl", "ct", "tx", "loc", "lc", "cb", "cu", "ci", "qa", "kb", " context"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int standard_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);\n\n    skip_bits(gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);\n\n    v->s.pict_type = get_bits(gb, 1);\n\n    if (v->s.avctx->max_b_frames)\n\n    {\n\n        if (!v->s.pict_type)\n\n        {\n\n            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;\n\n            else v->s.pict_type = B_TYPE;\n\n        }\n\n        else v->s.pict_type = P_TYPE;\n\n    }\n\n    else v->s.pict_type++;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_primary_header(v); break;\n\n    case BI_TYPE:\n\n    case B_TYPE: status = decode_b_picture_primary_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v->s.avctx, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25947, "substitutes": {"v": ["x", "b", "ant", "vg", "V", "n", "vm", "volt", "value", "vs", "z", "sv", "j", "ve", "self", "vers", "lv", "av", "vp", "hw", "vt", "nv", "r", "g", "ov", "inv", "cv", "vol", "es", "l", "vic", "h", "vim", "ver", "rev", "version", "vc", "p", "at", "dev", "m", "conv", "t", "ev", "w", "u", "vd", "qv", "k", "e", "gu", "c", "d", "vin", "i", "f", "tv", "val", "va", "api", "q", "serv", "vi", "uv", "ui", "iv", "o", "server", "video", "vv"], "gb": ["gow", "b", "gm", "bm", "gz", "gp", "pg", "abb", "gio", "tm", "bc", "Gb", "nb", "gh", "gs", "gom", "lib", "bb", "hw", "yg", "sb", "ctx", "gui", "gt", "mi", "anim", "rb", "gc", "dim", "storage", "pm", "g", "game", "gi", "gd", "rg", "hub", "gpu", "GB", "gy", "dm", "mb", "ge", "xy", "bug", "cfg", "gold", "cgi", "gam", "db", "sg", "ged", "phy", "gu", "gg", "pc", "cb", "bf", "gal", "lb", "ci", "usb", "gru", "kb", "ga", "bg"], "s": ["site", "js", "network", "its", "native", "in", "qs", "secondary", "sc", "conf", "S", "gs", "rs", "os", "ops", "ssl", "fs", "states", "ps", "aws", "ts", "es", "is", "l", "params", "ks", "share", "service", "submit", "ins", "hs", "p", "m", "sym", "t", "cs", "screen", "ads", "sets", "ms", "ns", "settings", "e", "sync", "c", "sup", "start", "sports", "i", "ss", "spec", "ls", "ds", "services", "o", "us", "se", "ses", "sys"], "pict_type": ["adverticaltype", "picticalkey", "pict_key", "configitytype", "config_class", "pictickstatus", "pictpype", "pict\u00b7parent", "pictitykey", "advert_type", "pict_single", "adverticalstatus", "pictalkey", "pict_status", "pict_class", "advert_status", "picticalsingle", "config_key", "picticalstatus", "pict_ype", " pict_ype", "configitykey", "adverticalsingle", "pictickkey", "picture_size", "picture_type", "picture_name", "advert_key", "pictptypes", "pict\u00b7TYPE", "pict_size", "configityclass", "pictitystatus", "picticktype", "picticksingle", "pict_types", "pictalstatus", "pictitytype", "picture_parent", "picture_types", "pictalclass", "picture_TYPE", " pict_action", "pict_name", "pict_id", "pict\u00b7name", "pictaltype", "advert_single", "pict_TYPE", "pict_order", "picture_id", "pict\u00b7id", "pictpaction", "pict\u00b7types", "config_type", "configitystatus", "pictptype", "config_status", "pict_action", "adverticalkey", "pict_parent", "picticaltype", " pict_types", "pict\u00b7type", "pictityclass", "picture_order"]}}
{"project": "FFmpeg", "commit_id": "a18456a2032e49385447a1d0d2f146f65fe9a5e1", "target": 0, "func": "static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)\n\n{\n\n    FILE* f;\n\n    char line[1024];\n\n    char  cmd[1024];\n\n    FFServerIPAddressACL *acl = NULL;\n\n    int line_num = 0;\n\n    const char *p;\n\n\n\n    f = fopen(stream->dynamic_acl, \"r\");\n\n    if (!f) {\n\n        perror(stream->dynamic_acl);\n\n        return NULL;\n\n    }\n\n\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n\n\n\n    /* Build ACL */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL)\n\n            break;\n\n        line_num++;\n\n        p = line;\n\n        while (av_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0' || *p == '#')\n\n            continue;\n\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n\n    }\n\n    fclose(f);\n\n    return acl;\n\n}\n", "idx": 25948, "substitutes": {"stream": ["engine", "coll", "context", "loop", "port", "fc", "sl", "path", "sc", "child", "forward", "stack", "cc", "control", "ack", "ssl", "row", "host", "model", "reader", "transform", "resource", "url", "src", "enc", "cl", "channel", "w", "input", "wrapper", "clean", "feed", "view", "sync", "uc", "document", "thread", "sw", "server", "mount", "iv", "user", "Stream", "form", "client", "pipe", "draft", "cur"], "c": ["coll", "dc", "ch", "xc", "bc", "cc", "cy", "ctx", "r", "mc", "gc", "v", "cont", "con", "icc", "vc", "m", "tc", "t", "C", "cm", "ct", "pc", "i", "lc", "cu", "ci"], "f": ["x", "b", "fw", "fc", "sf", "rf", "df", "fo", "func", "inf", "fd", "fs", "r", "g", "flow", "raf", "l", "fp", "h", "fi", "v", "cf", "aff", "fr", "m", "t", "F", "lf", "arf", "u", "fm", "s", "feed", "file", "e", "fn", "d", "fl", "i", "bf", "fa", "fx", "fen", "fe", "o", "ff", "form", "fff", "fb"], "line": ["x", "b", "Line", "nl", "n", "sl", "base", "rule", "col", "len", "row", "r", "ip", "word", "cell", "l", "v", "ine", "url", "pe", "enc", "range", "frame", "cl", "code", "m", "lf", "cr", "page", "w", "lin", "link", "buffer", "comment", "lines", "pipe", "file", "loc", "block", "e", "d", "point", "pc", "lc", "cli", "phrase", "val", "pos", "le", "o", "name", "lp", "ln"], "cmd": ["buf", "prop", "dc", "Cmd", "comm", "path", "dict", "ch", "card", "id", "cmp", "anc", "mode", "cc", "cp", "col", "ack", "ctx", "header", "host", "group", "word", "ck", "op", "dom", "dr", "command", "conn", "cf", "enc", "config", "frame", "range", "cl", "code", "cr", "def", "prefix", "cn", "mac", "md", "cfg", "domain", "comment", "arg", "desc", "pipe", "block", "seq", "d", "msg", "cli", "lc", "data", "call", "content", "cat", "cookie", "opt", "name"], "acl": ["x", "nl", "fc", "pb", "sl", "alpha", "anon", "AC", "z", "bc", "base", "anc", "ac", "ace", "ssl", "kl", "op", "ip", "cache", "l", "v", "fp", "L", "al", "acc", "enc", "pool", "config", "cl", "oc", "ocl", "ic", "lf", "mac", "aml", "el", "ll", "an", "af", "ec", "lc", "pc", "lb", "api", "val", "am", "qa", "policy", "abc", "auth", "list", "lp", "fl"], "p": ["x", "b", "port", "pg", "pb", "pi", "n", "pl", "a", "wp", "z", "ping", "j", "cp", "col", "sp", "r", "op", "ip", "g", "patch", "pp", "l", "v", "y", "fp", "pe", "part", "pre", "cl", "code", "m", "ap", "t", "s", "P", "u", "w", "pn", "page", "po", "jp", "e", "point", "param", "d", "bp", "pc", "i", "padding", "lc", "ep", "api", "np", "pr", "pos", "o", "pat", "tp", "lp", "pointer", "at", "pa"], "line_num": ["line___orig", "line_orig", "line___size", "line_size", "line___n", "page_n", "block_num", "block_no", "page_num", "line_no", "line___num", "line_NUM", "block_nr", "line_nr", "block_Num", " line_no", "page_orig", "line_n", " line_n", "line_Num", "page_size", " line_NUM"]}}
{"project": "qemu", "commit_id": "dc38852aaa4ac187d8b44201f75fc2835241912d", "target": 0, "func": "static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n", "idx": 25958, "substitutes": {"blk": ["Blks", "blb", " blb", "plks", "Blk", " blck", "Blck", "blks", "plk", "blck", "plck", " blks", "Blb", "plb"], "argc": [" arglc", " argf", "argf", "intc", "arv", "agv", "agp", "axci", "axc", "intl", "arlc", "arc", "Argf", "agc", "aglc", "axv", "intci", " argl", " argp", "axl", "argci", "argl", " argci", "arf", "intv", "Argv", "argp", "arglc", "Argc", "arp", "Argp"], "argv": ["angf", "argvs", "agx", " argf", "argsl", "argf", "agv", "arv", "opvs", "argsc", "arml", "argV", "angV", "argsp", "armvs", "axc", "axf", "angc", "arc", "Argf", "agc", "armv", "axve", "axv", "axV", "argx", "axp", "arvs", " argl", " argp", "axl", "argl", " argsv", " argvs", "armc", "opc", "Argv", "axx", " argve", "argp", "agV", " argV", "ArgV", "argve", "angv", "argsv", "angve", "axsv", "opp", "Argsv", "argsvs", "opv", "Argc", " argx", "arp"], "t1": ["tt2", "p1", "tt1", "tone", "p2", "T1", "ret2", "retOne", " t4", "tOne", "t0", "T0", "ret1", "Tone", " t0", "T4", "ret4", "T2", "ttone", "p4", "tt0", " tone", "t4", "TOne", " tOne", "p0"], "t2": ["p1", "tmp1", "T5", "t6", "talt", "t7", "T1", "table2", "p2", "tmp6", " t4", "T6", "p7", "T7", "tTwo", "t32", "T32", " t32", "t0", "T0", "ta0", " t0", "ta5", " t6", "T4", "ta6", "T2", " t7", "tmp2", "tmpTwo", "Talt", "ta4", "taalt", "t4", "table5", "tablealt", "ta2", "ta32", "ta1", "table1", " tTwo", "TTwo", "p0", "t5"], "c": [" C", "x", " o", "b", "n", "ch", "xc", "z", "err", "nc", "ac", "cc", "end", " rc", "col", "cy", "r", "g", " call", "l", "v", "cf", "enc", "con", "p", "code", "cs", "m", "cr", "s", "t", "channel", "u", "C", "rc", "w", "ct", "k", "e", "d", "f", "i", "ec", "lc", "q", "cat", "ci", "o", "a", "cd"], "ret": ["num", "ext", "rec", "sr", "reply", "err", "RET", "end", "len", "nt", "cache", "gc", "result", "alt", "resp", "get", "mem", "det", "no", "conn", "ref", "part", "py", "rev", "rets", "code", "complete", "rl", "def", "match", "ft", "rc", "fun", "att", "rt", "usr", "seq", "lit", "val", "call", "cat", "rep", "pet", "back", "Ret", "reg", "res", "flag", "en", "success", "re", "cur"], "offset": ["index", "reset", "num", "seed", "et", "parent", "error", "base", "nb", "align", "entry", "sum", "slot", "shift", "end", "timeout", "Offset", "len", "ptr", "fee", "info", "operation", "position", "number", "size", "type", "optional", "iso", "usage", "location", "zero", "url", "ref", "cost", "part", "off", "skip", "origin", "area", "p", "address", "obj", "prefix", "online", "not", "addr", "loc", "block", "limit", "seq", "start", "padding", "af", "output", "i", "delay", "data", "api", "pos", "flag", "o", "name", "order", "length", "pointer", "uple"], "count": ["b", "many", "child", "allow", "id", "keep", "patch", "cache", "type", "ref", "p", "core", "counter", "force", "match", "carry", "old", "limit", "more", "multiple", "name", "order", "depth", "coll", "num", "n", "key", "parent", "err", "end", "col", "info", "add", "cycle", "check", "skip", "low", "ind", "start", "cond", "sum", "found", "error", "wait", "Count", "ount", "len", "total", "group", "max", "resp", "all", "code", "w", "seq", "f", "q", "call", "data", "flag", "weight", "ch", "base", "size", "number", "part", "process", "inc", "content", "list", "length", "handle"], "optind": ["opInd", "offin", "optin", " optin", "optimnt", "offinit", "optinc", "optend", "optiminc", "optiminn", "optionInd", "optimInd", "Optind", " optnt", "opcel", "opnd", "optiminit", "optioninn", "optionend", "optimind", "opind", " optInd", "optionie", "octInd", "optInd", "optimin", " optinit", "opend", "optie", "opinn", " optcel", "Optie", "optimend", "optnd", " optinn", "optinit", " optnd", "optioninc", "optionnd", "optioncel", "octinn", "optionind", "octinc", "Optnd", "optcel", " optie", "optnt", "optinn", "octind", "OptInd", "opinc", "offind", "offnt", "octnd"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n", "idx": 25997, "substitutes": {"mr": ["bm", "sr", "rf", "gr", "tm", "mt", "eu", "lr", "mn", "rs", "er", "MR", "rd", "r", "mc", "rb", "pm", "br", "dr", "reader", "yr", "rg", "tr", "arr", "m", "fr", "rl", "rh", "cr", "vr", "fm", "rc", "ar", "shr", "rt", "rm", "kr", "hr", "ru", "mm", "rr", "Mr", "pr", "rar", "adr", "nr", "ir"], "addr": ["x", "index", "rx", "align", "inter", "base", "mode", "ace", "offset", "len", "ptr", "r", "host", "dr", "attr", "conn", "slice", "ref", "part", "src", "oa", "wd", "xp", "address", "rc", "hop", "amp", "node", "rt", "loc", "seq", "i", "layer", "Address", "ord", "pad", "nr", "pointer", "ext"], "size": ["gz", "ize", "z", "mode", "count", "bytes", "fee", "storage", "en", "ish", "l", "style", "large", "range", "empty", "SIZE", "iz", "address", "unit", "scale", "si", "small", "sec", "sized", "Size", "name", "offset"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n", "idx": 26003, "substitutes": {"vd": ["edd", "sd", "dc", "dt", "df", "od", "hd", "dh", "lv", "rd", "VD", "fd", "vt", "nv", "vid", "cv", "ud", "dr", "dn", "gd", "v", "bd", "vc", "gb", "vr", "ld", "md", "db", "rt", "dd", "d", "pd", "ds", "dl", "va", "ad", "xd", "nd", "vv", "cd"], "addr": ["ag", "dc", "driver", "ac", "rs", "fd", "url", "oa", "ap", "rh", "address", "inst", "ast", "usr", "dd", "rr", "art", "adder", "holder", "x", "mt", "info", "host", "add", "amd", "conn", "anne", "wd", "actor", "kt", "arr", "obj", "nn", "rc", "node", "ad", "owner", "error", "cmp", "ace", "od", "hd", "bb", "ptr", "pkg", "attr", "dr", "advert", "src", "sk", "config", "rn", "route", "cmd", "peer", "vr", "mac", "acl", "hop", "rt", "amp", "data", "org", "adr", "alias", "func", "ack", "ady", "r", "part", "act", "ld", "ar", "md", "db", "cb", "fx", "ord"], "err": ["error", "gr", "acer", "lr", "der", "rs", "er", "req", " er", "Error", "r", "fy", "Er", "oller", "dr", "y", "fi", "cor", "mr", "rage", "order", "arr", "rn", "fr", "cr", "rh", "ln", "ler", "ar", "var", "e", "rm", "kr", "cb", "rr", "orr", "nr", "ir", "sys"]}}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n", "idx": 26008, "substitutes": {"fs_ctx": ["ns_ctx", "fs_obj", "fs_context", "ns_context", "ns_path", "ns_obj"], "fs_path": ["fs_node", " fs_area", "fspath", " fs_node", "fsFnode", "fspctx", " fs_ath", "fs_root", "fsFpath", "fsFroot", "fsFimage", "fs_image", "fsppath", "fs_ath", "fs_area", " fs_image", " fs_root", "fsparea"], "stbuf": ["ctbuff", " strb", " stbuff", "STbuff", "stbuffer", "ctbuffer", "sthrb", "ssrb", "strb", "sthbuff", "ctgb", "STgb", "STbuf", "STbuffer", " stbuffer", "ssbuffer", "ssbuff", "ssbuf", "ctbuf", "sthbuffer", "stbuff", "sthbuf", " stgb", "stgb"], "node": ["index", "ode", "num", "native", "array", "n", "anch", "path", "parent", "value", "child", "member", "source", "edge", "self", "none", "row", "Node", "image", "op", "master", "root", "resource", "ref", "part", "instance", "config", "route", "package", "obj", "device", "block", "fn", "d", "object", "tree", "data", "content", "cdn", "slave"]}}
{"project": "FFmpeg", "commit_id": "f2e9a0ecbef5027f9532c49ffcdfc11d199f6150", "target": 1, "func": "static av_cold int qsv_decode_close(AVCodecContext *avctx)\n{\n    QSVOtherContext *s = avctx->priv_data;\n    ff_qsv_decode_close(&s->qsv);\n    qsv_clear_buffers(s);\n    av_fifo_free(s->packet_fifo);\n    return 0;\n}", "idx": 26030, "substitutes": {"avctx": [" avlc", "akcontext", "ajctrl", " avcor", "afcor", "afctx", "akconfig", " avconfig", "ajcontext", "akctx", "avcontext", "ajlc", "akcor", " avctrl", "avctrl", "avcor", " avcontext", "afctrl", "avconfig", "afconfig", "afcontext", "ajctx", "aflc", "avlc"], "s": ["js", "b", "n", "qs", "your", "S", "gs", "self", "rs", "os", "opens", "ctx", "ssl", "sb", "stats", "fs", "ps", "ans", "aws", "ts", "es", "sa", "v", "ks", "src", "p", "cs", "m", "sym", "args", "u", "ns", "sg", "si", "settings", "e", "sync", "c", "ses", "d", "f", "ss", "i", "ls", "ds", "spec", "data", "xs", "services", "sq", "server", "o", "a"]}}
{"project": "FFmpeg", "commit_id": "c83002a4f8042ccfa0688a9a18e8fa0369c1fda8", "target": 1, "func": "int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n\n                                const char *buf)\n\n{\n\n    const char *text = NULL;\n\n    char new_line[2];\n\n    int text_len = 0;\n\n\n\n    while (*buf) {\n\n        if (text && callbacks->text &&\n\n            (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1 ||\n\n             !strncmp(buf, \"{\\\\\", 2))) {\n\n            callbacks->text(priv, text, text_len);\n\n            text = NULL;\n\n        }\n\n        if (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1) {\n\n            if (callbacks->new_line)\n\n                callbacks->new_line(priv, new_line[0] == 'N');\n\n            buf += 2;\n\n        } else if (!strncmp(buf, \"{\\\\\", 2)) {\n\n            buf++;\n\n            while (*buf == '\\\\') {\n\n                char style[2], c[2], sep[2], c_num[2] = \"0\", tmp[128] = {0};\n\n                unsigned int color = 0xFFFFFFFF;\n\n                int len, size = -1, an = -1, alpha = -1;\n\n                int x1, y1, x2, y2, t1 = -1, t2 = -1;\n\n                if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) {\n\n                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n\n                    len += close != -1;\n\n                    if (callbacks->style)\n\n                        callbacks->style(priv, style[0], close);\n\n                } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", c_num, &color, sep, &len) > 2) {\n\n                    if (callbacks->color)\n\n                        callbacks->color(priv, color, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", c_num, &alpha, sep, &len) > 2) {\n\n                    if (callbacks->alpha)\n\n                        callbacks->alpha(priv, alpha, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->font_name)\n\n                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n\n                } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) {\n\n                    if (callbacks->font_size)\n\n                        callbacks->font_size(priv, size);\n\n                } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) {\n\n                    if (an != -1 && buf[2] != 'n')\n\n                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n\n                    if (callbacks->alignment)\n\n                        callbacks->alignment(priv, an);\n\n                } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n", "idx": 26031, "substitutes": {"callbacks": ["cback", " callups", "callingbacks", "cbacks", "playacks", "callheads", "broadback", "cheads", "Callheads", "callbooks", "playups", "defbacks", "Callacks", "allbacks", "Calleners", "callups", "playbacks", "Callups", "callingbooks", "broadbacks", "cacks", "Callback", " callevents", "callasts", "defbooks", "allacks", "allback", "Callasts", "Callbacks", "broadeners", "callback", " callback", " callacks", " callasts", "callingevents", "Callevents", " callbooks", "callacks", " calleners", "callevents", "Callbooks", " callheads", "defback", "calleners", "defasts"], "priv": ["prop", "pb", "li", "ch", "rib", "Priv", "bc", "prof", "debug", "proc", "cert", "cp", "pred", "req", "func", "ctr", "ctx", "private", "vt", "ptr", "pdf", "info", "rb", "ocr", "cer", "wb", "attr", "reader", "pri", "conn", "fi", "options", "config", "gb", "dev", "password", "pro", "cur", "pub", "access", "rc", "txt", "doc", "uc", "usr", "cb", "data", "rw", "tty", "buff"], "buf": ["b", "port", "loop", "box", "home", "bc", "filename", "bh", "fam", "fd", "cache", "url", "brace", "bu", "txt", "usr", "fb", "cur", "context", "pb", "aka", "vec", "cp", "window", "rb", "raf", "job", "fp", "comb", "exc", "conv", "callback", "profile", "rc", "buffer", "feat", "plug", "feed", "bp", "img", "runner", "proc", "paren", "bb", "ctr", "ptr", "pkg", "utf", "br", "Buffer", "bt", "fi", "cf", "src", "config", "queue", "cmd", "vr", "seq", "data", "uf", "Buff", "buff", "cap", "uber", "ucc", "grab", "prof", "func", "ctx", "uu", "wb", "cv", "coord", "cas", "auc", "tc", "ab", "console", "loc", "uc", "bag", "lit", "cb", "tab", "aux", "ru", "lb", "dest", "length", "rail"], "text": ["contract", "num", "translation", "ut", "path", "value", "id", "source", "format", "write", "connection", "binary", "title", "Text", "info", "image", "word", "type", "br", "url", "check", "editor", "config", "label", "TEXT", "code", "pass", "password", "select", "prefix", "username", "input", "buffer", "tx", "font", "comment", "letter", "feed", "txt", "append", "start", "lit", "object", "str", "data", "math", "event", "buff", "term", "content", "method", "form", "name", "class", "length", "ext"], "new_line": ["newxlines", "newptline", "new_lines", "old_lines", " new_liner", "new_column", "newoutlines", "newvline", "newxname", "old_len", "new_liner", "next_name", "old_line", "next_line", "newvlen", "newvlines", "New_time", "newouttext", "new_time", "newNewlines", "old_code", "newjpage", "newptcode", "New_lines", "New_page", "old_column", "new_len", "newjlines", "newNewcode", " new_word", "newjlist", "newNewlen", "new_word", "newoutline", "newptcolumn", "newvcode", "next_lines", "newxline", "newptlines", "new_name", "newnewliner", "next_text", "newxtext", "new_code", "newjline", "newNewline", "newoutname", "new_text", " new_lines", "newnewlines", "New_line", "newnewline", "old_list", "newnewword", "new_page", "new_list", "old_page"], "text_len": ["txt_length", "ext_len", "ext_pos", "txt_pos", "text_Len", "ext_Len", "text_pos", "text_length", "ext_lin", "txt_Len", "text_lin", "txt_len"], "style": ["border", "span", "li", "sl", "css", "ch", "error", "z", "id", "rule", "source", "shadow", "cp", "margin", "Style", "body", "lib", "tag", "sh", "info", "color", "image", "size", "type", "character", "session", "attr", "sy", "open", "price", "background", "dot", "pe", "py", "cl", "script", "p", "theme", "speed", "styles", "line", "profile", "force", "link", "font", "comment", "k", "si", "white", "sync", "like", "start", "ss", "data", "pattern", "co", "ci", "use", "o", "pad", "class", "length", "offset"], "c": ["b", "n", "dc", "ch", "z", "count", "cc", "cp", "ac", "col", "ctx", "color", "g", "cache", "size", "cz", "cv", "l", "y", "h", "v", "ce", "config", "cl", "p", "csv", "code", "cs", "t", "s", "toc", "w", "C", "rc", "k", "e", "chart", "d", "f", "i", "lc", "ec", "cat", "cu", "ci", "o"], "sep": ["ceg", "aseg", "lepp", "SEk", "cepa", "kemp", "sem", "sepp", " sef", "lemp", "SEph", "seph", " seph", "pref", "SEp", "useg", "asepa", "kept", "spept", " seg", "prepa", "kepp", "kepa", "preg", "sek", "spek", "spep", "semm", "seg", "prep", "usep", "kep", "lem", "semp", "sef", "asep", " sek", "usepa", " sept", "lep", "asept", "kem", "sempp", "cef", "sepa", " sepa", "speg", "SEpt", "keg", "SEpa", "sept", "useph", "cep", "semmp", "SEg"], "c_num": ["C_number", "c1gen", "c_nm", "c__number", "C_nm", " c1number", "cipnumber", "cipid", "c1nm", "c1dom", "cseqloc", "c__num", " c1gen", " c_number", "c__name", "l_number", "c1n", "c_dom", "c_name", "c_n", " c1num", "c_number", "l_num", " c_n", "l_dom", "c1name", "c_id", "ciploc", "lc_number", "cseqid", "l_dim", "C_num", "C_name", "c_gen", "c_loc", " c1n", "cipnum", "lc_id", "c1dim", "c_dim", "lc_num", "c__nm", "lc_loc", "c1num", "c1number", " c_gen", "cseqnum", "cseqnumber"], "tmp": ["border", "span", "z", "source", "proc", "cp", "margin", "option", "rb", "attr", "config", "script", "tc", "toc", "rc", "input", "font", "white", "pixel", "img", "output", "cb", "cpp", "opt", "temp", "bg"], "len": ["depth", "cap", "num", "span", "li", "n", "sl", "lif", "align", "base", "z", "err", "Len", "lim", "count", "fat", "lib", "norm", "dy", "sp", "fin", "size", "type", "alt", "bin", "l", "la", "lang", "enc", "rev", "pre", "lon", "line", "vert", "ler", "lin", "fun", "el", "scale", "pad", "loc", "seq", "limit", "lit", "val", "ann", "fen", "pos", "den", "en", "length", "ln", "fl", "offset"], "x1": ["y3", "x3", " x3", "f1", "f3", "f2"], "y1": ["cy1", "p1", "y0", "p4", "cy2", "x0", "x4", "cy0", "cy4", "y4", "p2", "p0"], "x2": [" x0", "p6", "y0", "p1", " x6", "x0", "p0", "p2", "y6", "x6"], "y2": ["p1", "y0", "Y4", "p4", "x0", "x4", "Y0", "y4", "Y1", "p2", "Y2", "p0"]}}
{"project": "FFmpeg", "commit_id": "2453f40602dd6f5fa670954ee733a4155675f645", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3],\n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n\n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now\n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 62; /* value 63 is not allowed */\n\n            }\n\n\n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\",\n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n\n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            assert(0); //cannot happen\n\n            code = 0;           /* kill warning */\n\n        }\n\n\n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j,\n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 26038, "substitutes": {"scale_code": [" scale_const", " scale_function", "scale2codes", "scale_function", " scale_codes", "scale2function", "scale_codes", "scale2code", "scale_const", "scale2const"], "scale_factors": ["scale_factorories", "scale_formores", "scale_actos", "scale_formions", "scale_formors", "scale_factos", "scale_actors", "scale_factorions", "scale_formos", "scale_factor", "scale_actores", "scale_factorores", "scale_fories", "scale_actories", "scale_factores", "scale_fors", "scale_factions", "scale_factories", "scale_actions", "scale_fores", "scale_for", "scale_factoros", "scale_factorors", "scale_factoror", "scale_actor"], "sb_samples": ["sb_namples", "sb_nales", "sbsscubes", "sbsscipes", "sb_sores", "sb_examps", "sb_scubes", "sbssubes", "sb_scamples", "sbssales", "sbsscales", "sb_sipes", "sbsscamples", "sb_slamples", "sb_slubes", "sb_exores", "sb_sales", "sb_nores", "sb_tipes", "sb_namps", "sbssamples", "sb_slales", "sb_exipes", "sb_nubes", "sb_nipes", "sbssipes", "sb_scipes", "sb_slipes", "sb_tamps", "sb_samps", "sb_scales", "sb_examples", "sb_tamples", "sb_subes", "sb_tores"], "sblimit": ["sblIMite", "sblIMIT", "sblrimIT", "splIMit", "sblrimit", "splimit", "sblimiter", "sbllimited", "sclIMIT", "sclimite", "sbllimIT", "sblimited", "splimited", "sblimIT", "sblimite", "splimite", "sblIMit", "splIMited", "sclimiter", "splIMite", "sblimsit", "sbllimit", "sclimit", "sblimsite", "sblimsiter", "sbllimite", "splIMIT", "sblIMiter", "splimIT", "sblIMited", "sclimIT", "sclIMiter", "sblrimite", "sblrimiter", "sclIMite", "sclIMit", "sblimsIT", "sblimsited"], "p": ["x", "b", "port", "pi", "a", "z", "cp", "sp", "r", "patch", "g", "ip", "ps", "pp", "l", "h", "y", "pe", "py", "m", "ap", "t", "s", "P", "per", "u", "pn", "w", "po", "jp", "e", "point", "c", "pt", "bp", "d", "pc", "f", "q", "api", "np", "pr", "tp", "lp", "pa"], "vmax": ["Vc", "fmax", " vmin", "vparent", "jax", "Vax", "vvdev", "tvco", "svMax", "Vdev", "fMax", "vvco", "lMax", "Vdiv", "vdiv", " vax", "lvmax", "vvmin", "Vmax", "tvdev", "vvlast", "vlast", "vcax", "valrange", "lvmin", "lmax", "svmax", " vc", " vdev", "vtotal", " vtotal", "svlast", "vdev", "vax", "tvc", "svax", "nvrange", "vmad", "vvMax", "lvrange", "jmad", "vctotal", "vvmax", "vmin", "jmax", "svfinal", "fmin", "nvparent", " vco", "vvax", "vfinal", "vvfinal", "Vlast", "jc", "vrange", " vMax", "vMax", "vcmad", "nvmin", "Vmin", "vvc", " vfinal", "vcmax", "valparent", " vlast", "jdiv", "valmax", "lvMax", " vdiv", "vco", "tvmax", "valmin", "lvparent", "nvmax", "VMax", "jtotal", "vc", " vmad", "lmin", "jMax"], "v": ["x", "b", "V", "value", "vs", "z", "sv", "ve", "lv", "av", "vp", "nv", "g", "ov", "max", "cv", "vol", "l", "y", "h", "ver", "m", "conv", "t", "u", "w", "ev", "vv", "c", "d", "f", "tv", "val", "q", "va", "api", "vi", "iv", "uv"], "n": ["x", "b", "num", "network", "ny", "nb", "z", "nc", "N", "net", "mn", "len", "r", "g", "size", "max", "dn", "l", "y", "m", "t", "cn", "u", "w", "pn", "nn", "ns", "na", "e", "c", "d", "ind", "f", "min", "sn", "np", "o", "ni", "en", "a"], "i": ["x", "b", "ai", "li", "pi", "in", "ie", "key", "z", "id", "yi", "iu", "ip", "ix", "bi", "l", "y", "io", "xi", "ini", "qi", "m", "ik", "di", "t", "I", "u", "it", "ii", "s", "si", "jp", "e", "c", "d", "eni", "f", "ind", "api", "ori", "ui", "ci", "phi", "o", "ni", "ji", "mi"], "j": ["x", "b", "js", "jet", "li", "ja", "key", "z", "jo", "r", "g", "l", "y", "h", "ij", "m", "t", "u", "it", "ii", "w", "jp", "jc", "si", "e", "jj", "c", "d", "ind", "f", "start", "jl", "q", "pos", "o", "ji", "J"], "k": ["x", "b", "ke", "key", "ch", "z", "id", "ko", "r", "g", "dk", "l", "kw", "y", "h", "ks", "sk", "ek", "K", "m", "ik", "s", "u", "w", "ak", "uk", "ok", "an", "c", "mk", "ph", "q", "kk", "kn", "o", "ki"], "code": ["key", "Code", "error", "entry", "pair", "id", "state", "nc", "message", "count", "cc", "charge", "text", "end", "xxx", "test", "func", "function", "info", "ne", "size", "catch", "type", "result", "cycle", "sequence", "close", "slice", "xx", "codes", "change", "comb", "line", "example", "address", "unit", "match", "comment", "desc", "loc", "cod", "c", "ind", "start", "condition", "data", "call", "content", "ci", "fe", "use", "name", "length", "offset"], "index": ["loop", "in", "search", "id", "degree", "count", "xxx", "fee", "ne", "type", "zero", "ini", "address", "match", "page", "online", "comment", "si", "Index", "sync", "thread", "name", "x", "network", "num", "key", "path", "shape", "connection", "end", "action", "info", "original", "see", "nn", "node", "c", "ind", "condition", "start", "second", "val", "fe", "pointer", "offset", "error", "value", "none", "current", "position", "update", "ix", "iter", "no", "slice", "ion", "input", "find", "f", "output", "ng", "date", "weight", "alpha", "member", "body", "insert", "size", "number", "expression", "part", "xi", "version", "loc", "inc", "d", "element", "diff", "list", "length"], "d1": ["p8", "p1", "dOne", "cd1", " dn", "p2", "D3", "d3", " d3", "f0", "f8", " d8", "fOne", "dn", "tOne", "d0", "d8", " d0", "D2", "cdOne", "f1", "pn", "f2", "cd3", "D1", "fn", "t3", "D0", "f3", "t1"], "d2": ["do32", " d62", "d6", "d5", "do4", "ldtwo", "du62", "day6", "dutwo", "ld2", "d4", "dctwo", "du02", "p2", "day2", "d62", " dtwo", "day82", "dc2", "du2", "p5", " d4", "dc02", " d5", " d82", "do5", "ld82", "daytwo", "dtwo", "p4", "ld6", " d6", "d02", "p32", "d82", "do2", " d02", "dc62", "d32", " d32"], "sf": ["fw", "dist", "pb", "SF", "gp", "rf", "sd", "fc", "sl", "df", "split", "iw", "sv", "tta", "ffield", "cp", "isf", "gif", "tf", "lv", "vp", "hw", "sb", "ssl", "eph", "fd", "sp", "fs", "fee", "stab", "cv", "result", "fp", "hh", "fi", "fts", "cf", "ppa", "sm", "gb", "fr", "ze", "lf", "ft", "fm", "ffe", "of", "xf", "su", "si", "wm", "settings", "flo", "fn", "f", "xs", "ls", "bf", "diff", "uf", "fx", "sw", "sq", "fe", "fen", "models", "tif", "ff", "tp", "lp", "support", "fb"]}}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 26059, "substitutes": {"opaque": ["oppaques", "openaques", "oppaque", "OPque", "opahi", "octaque", "OPaques", "paques", "openaque", "pque", "pahi", "operacity", "operaques", "oppahi", "paque", "oppque", "OPaque", "opque", "OPahi", "octacity", "opacity", "octaques", "opaques", "operaque", "openacity"], "irq": ["mirquest", "IRqa", "ariqu", "ariq", "irqu", "rilquant", "rilq", "rilqu", "ireqa", "irche", "iriquest", "irqi", "rinq", "ierc", "igrq", "risquest", "IRquest", "IRQ", "ireQ", "mirq", "mirque", "arique", "ariqi", "irquest", "Irche", "iriqi", "ierque", "irisque", "Irquant", "mirqu", "Irqu", "irequest", "risqu", "ironc", "Irq", "irique", "IRq", "ironqu", "rinQ", "irque", "irisqu", "ireq", "irc", "ierqu", "risq", "irice", "irquant", "risce", "irisq", "igrqu", "irisqi", "iriqu", "ironque", "igrche", "rinquest", "mirc", "irQ", "irqa", "rilche", "iriq", "ironq", "rinqa", "mirce", "ierq", "igrquant", "irce"], "s": ["js", "b", "n", "sl", "a", "sc", "sv", "S", "gs", "self", "source", "os", "rs", "ops", "sid", "sb", "ssl", "ctx", "fs", "op", "g", "session", "es", "is", "v", "sis", "spot", "p", "m", "cs", "t", "sym", "su", "ns", "bes", "si", "sie", "e", "c", "f", "ss", "spec", "i", "ls", "sim", "ds", "services", "sq", "server", "o", "ses"], "vec": ["buf", "coll", "soc", "liv", "expr", "finder", "bc", "ve", "voc", "req", "vp", "crit", "feature", "contin", "cer", "cas", "vector", "v", "vre", "fi", "cf", "ver", "rev", "vc", "ves", "cs", "nec", "nov", "vert", "def", "virt", "ev", "obj", "ler", "var", "vr", "comp", "feat", "ef", "ger", "desc", "e", "c", "seq", "vir", "ec", "f", "spec", "i", "lc", "str", "val", "serv", "fx", "fen", "server", "iv", "verb", "vv"]}}
{"project": "qemu", "commit_id": "363e13f86eb60bce1e112a35a4c107505a69c9fe", "target": 0, "func": "static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 26061, "substitutes": {"i": ["index", "b", "x", "ai", "oi", "li", "pi", "n", "in", "ie", "z", "id", "j", "abi", "yi", "info", "r", "hi", "ip", "iu", "ix", "gi", "bi", "l", "is", "y", "h", "fi", "io", "slice", "part", "uri", "xi", "ini", "inner", "multi", "p", "qi", "m", "zi", "di", "I", "t", "u", "it", "init", "ii", "si", "e", "c", "ind", "d", "f", "eni", "lc", "diff", "ori", "ui", "ci", "pos", "phi", "min", "iv", "o", "ni", "ri", "mi"], "decoded": ["decored", "enoding", "encoding", "decided", "encanded", " Decode", "decloded", "encided", "decoding", "encoded", " decrypted", "decrypted", "Decrypted", "declanded", "encode", " Decored", "dedrypted", "dedored", "decanded", " decode", "encored", "desoding", "enoded", "desanded", "dedcoded", "Decoded", "dedoded", "desoded", " deccoded", "Decored", "declided", "desrypted", "Deccoded", " Decrypted", "declrypted", " Decoded", "desided", "deccoded", "decode", "descoded", "enccoded", "enrypted", "encrypted", " decored"], "test_cases": [" test_tests", " teststimes", "Test_cases", "test_forces", "testdcases", "Test_case", "testdforces", "testdtests", "testpletests", "testing_tests", "testplesections", "testplecases", "test_case", "testssections", "testing_times", "testingscases", "case_cases", " teststests", "Test_tests", " test_times", "test2forces", "Test_forces", "case_times", "test2cases", " testscases", "testingstimes", "teststimes", " test_sections", "testscase", "test_sections", "testing_case", "test_times", "testdcase", " testssections", "case_tests", "testingstests", "testing_cases", "test2case", "testpletimes", "testscases", "teststests", "test2tests", "test_tests", "testingscase"], "obj": ["js", "x", "adj", "coll", "oi", "n", "Obj", "ie", "sl", "j", "os", "eff", "ctx", "bo", "nt", "rb", "op", "type", "result", "br", "fi", "ref", "oa", "py", "enc", "bj", "code", "tmp", "arr", "act", "ex", "inst", "oid", "Object", "po", "ns", "elt", "jp", "active", "txt", "e", "pt", "module", "cb", "object", "data", "val", "api", "pr", "pos", "o", "art", "so", "st", "ob"], "str": ["js", "coll", "sr", "sl", "Obj", "dict", "gr", "err", "id", "j", "rs", "text", "sp", "r", "type", "br", "dr", "STR", "tr", "style", "enc", "stri", "rev", "arr", "code", "fr", "cs", "cr", "act", "s", "ct", "ns", "elt", "txt", "doc", "pt", "ss", "kr", "spec", "object", "val", "data", "Str", "pr", "o", "st", "name", "sec", "cur"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n", "idx": 26069, "substitutes": {"qdev": ["qqdata", "qev", "Qdev", "sqdiv", "sqdef", " qdef", "pev", "sqpriv", "Qpriv", "Qdiv", " qmd", "sqdata", "qqdev", "pdiv", " qdata", "sqev", "Qev", "qmd", "qpriv", "sqmd", "qdef", "ppriv", "qqmd", "qqdef", "sqdev", "qdata", "pdev", "qdiv"], "dev": ["fw", "mod", "dc", "error", "home", "conf", "gh", "self", "od", "valid", "end", "lib", "hw", "rad", "info", "patch", "dom", "DEV", "v", "priv", "sk", "wd", "bd", "ver", "cam", "app", "vc", "grad", "di", "nov", "def", "pub", "ev", "de", "device", "md", "var", "Dev", "bug", "plug", "die", "comment", "vd", "kind", "gu", "dd", "d", "diff", "adv", "data", "ad", "dem", "prom"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int gen_sub_bitmap(TeletextContext *ctx, AVSubtitleRect *sub_rect, vbi_page *page, int chop_top)\n\n{\n\n    int resx = page->columns * BITMAP_CHAR_WIDTH;\n\n    int resy = (page->rows - chop_top) * BITMAP_CHAR_HEIGHT;\n\n    uint8_t ci, cmax = 0;\n\n    int ret;\n\n    vbi_char *vc = page->text + (chop_top * page->columns);\n\n    vbi_char *vcend = page->text + (page->rows * page->columns);\n\n\n\n    for (; vc < vcend; vc++) {\n\n        if (vc->opacity != VBI_TRANSPARENT_SPACE) {\n\n            cmax = VBI_NB_COLORS;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (cmax == 0) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"dropping empty page %3x\\n\", page->pgno);\n\n        sub_rect->type = SUBTITLE_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if ((ret = avpicture_alloc(&sub_rect->pict, AV_PIX_FMT_PAL8, resx, resy)) < 0)\n\n        return ret;\n\n    // Yes, we want to allocate the palette on our own because AVSubtitle works this way\n\n    sub_rect->pict.data[1] = NULL;\n\n\n\n    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,\n\n                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],\n\n                            0, chop_top, page->columns, page->rows - chop_top,\n\n                            /*reveal*/ 1, /*flash*/ 1);\n\n\n\n    fix_transparency(ctx, sub_rect, page, chop_top, cmax, resx, resy);\n\n    sub_rect->x = ctx->x_offset;\n\n    sub_rect->y = ctx->y_offset + chop_top * BITMAP_CHAR_HEIGHT;\n\n    sub_rect->w = resx;\n\n    sub_rect->h = resy;\n\n    sub_rect->nb_colors = (int)cmax + 1;\n\n    sub_rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n    if (!sub_rect->pict.data[1]) {\n\n        av_freep(&sub_rect->pict.data[0]);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    for (ci = 0; ci < cmax; ci++) {\n\n        int r, g, b, a;\n\n\n\n        r = VBI_R(page->color_map[ci]);\n\n        g = VBI_G(page->color_map[ci]);\n\n        b = VBI_B(page->color_map[ci]);\n\n        a = VBI_A(page->color_map[ci]);\n\n        ((uint32_t *)sub_rect->pict.data[1])[ci] = RGBA(r, g, b, a);\n\n        av_dlog(ctx, \"palette %0x\\n\", ((uint32_t *)sub_rect->pict.data[1])[ci]);\n\n    }\n\n    ((uint32_t *)sub_rect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0);\n\n    sub_rect->type = SUBTITLE_BITMAP;\n\n    return 0;\n\n}\n", "idx": 26075, "substitutes": {"ctx": ["fw", "context", "dc", "wp", "xc", "sci", "sc", "tk", "bc", "cmp", "anc", "ca", "progress", "cc", "cms", "cp", "proc", "lib", "hw", "pkg", "gc", "ck", "qt", "cv", "cas", "kw", "la", "conn", "wx", "cf", "Context", "config", "cam", " cx", "kt", "conv", "tc", "cn", "wcs", "mac", "cm", "ctrl", "cgi", "tx", "rc", "cca", "node", "loc", "c", "chart", "img", "lc", "cb", "cli", "cpp", "event", "cu", "np", "qa", "client", "kb", "concept", " context"], "sub_rect": [" sub_cover", "sub_json", "subureptr", "subOrect", "user_rect", "singOrect", "subsrect", "sub_shape", "subJbutt", " sub_quant", "sub_dr", "subpslice", "usersshape", "subOtag", "ub_Rect", "sub_dra", "ub_struct", "splitfrect", "sing_transfer", "sing_struct", "subJrect", "main_rt", "user_shape", "sub_record", "ub_dr", " sub_reg", "suberdra", "ub_rect", "sub_container", "sub_ptr", "splitfmount", "suberrect", "subOslice", "subssrc", " sub_json", "sing_rect", " sub_Rect", "sub_port", "subOmount", "main_ror", "subpcontainer", "ub_spec", "ub_butt", "ub_surface", " sub_surface", "singOtransfer", "usersrect", " sub_port", "sub_project", " sub_record", "main_rect", "userssrc", "sub_path", "subsshape", "subOstruct", "suburerog", "subOsurface", "subJdr", "Sub_rt", "subfcontainer", "main_pair", "subfslice", "subpmount", "ub_rog", "sub_butt", "split_slice", "split_container", "sub_mount", "ub_path", "split_mount", "sub_slice", "sub_struct", "singOtag", "Sub_dra", " sub_spec", "sub_pair", "sub_quant", "subssurface", "user_src", "split_rect", "splitfslice", "sub_rt", "ub_ptr", "suberrt", "sub_cover", "Sub_project", "sub_surface", "suburerect", "subJsurface", "suberbutt", "subprect", "subfmount", "userssurface", "Sub_spec", " sub_ptr", "sing_tag", "sub_ror", " sub_butt", "subureRect", "sub_tag", "sub_rog", "subOshape", "Sub_butt", "Sub_rect", "splitfcontainer", "sub_reg", "subOsrc", " sub_struct", "subOtransfer", "sub_spec", "sub_transfer", "subOcontainer", "sub_src", "singOstruct", "subfrect", "sub_Rect", "user_surface"], "page": ["port", "mp", "wp", "www", "header", "sel", "pdf", "cache", "cell", "px", "result", "request", "instance", "p", "screen", "month", "per", "view", "block", "document", "user", "xml", "order", "post", "context", "pg", "pb", "pl", "parent", "me", "window", "photo", "record", "theme", "profile", "node", "c", "pc", "api", "client", "pm", "site", "plugin", "net", "Page", "current", "sp", "group", "model", "session", "ae", "chapter", "root", "item", "resource", "pe", "config", "queue", "wiki", "stage", "ge", "po", "jp", "chart", "module", "age", "server", " PAGE", "gui", "row", "layout", "image", "word", "pp", "area", "manager", "display", "inc", "pages", "html", "phrase", "next", "section", "list", "menu", "lp"], "chop_top": ["chmop_TOP", "chip_bottom", "chop_master", "chopJtop", "chrip_tops", "chopJsearch", "chopJstart", "chrip_next", "chop_next", "chmop_top", "chopJbottom", "chop_TOP", "chop_stop", "chmop_tops", "chhop_left", "chop_left", "chip_top", "chops_bottom", "chrip_stop", "chop_Top", "chop_front", "chrip_left", "chrip_bottom", "chop_start", "chrip_search", "chhop_tops", "chops_top", "chip_left", "chrip_top", "chops_TOP", "chrip_start", "chop_search", "chrip_front", "chops_Top", "chop_bottom", "chhop_master", "chhop_top", "chop_tops"], "ci": ["ai", "iii", "dc", "xc", "ca", "cp", "lic", "ctr", " vi", "ice", "ce", "cf", "code", "gb", "codes", "cr", "di", "rie", "ii", "cm", "ct", "loc", "c", "DC", "cat", "co", "cu", "fe", "cd"], "ret": ["ut", "rx", "reply", "value", "RET", "std", "len", "gt", "red", "nt", "gc", "result", "alt", "resp", "mem", "det", "ref", "tr", "rets", "arr", "rl", "ft", "match", "def", "rc", "fun", "att", "feat", "arg", "desc", "rt", "lit", "val", "data", "cat", "rep", "back", "Ret", "reg", "flag", "pat", "bit", "success", "re", "ext"], "vc": ["ant", "vg", "dq", "fc", "iii", "dc", "xc", "GV", "vs", "bc", "vec", "sv", "nc", "voc", "ac", "cc", "lv", "vp", "vt", "nv", "vid", "cv", "v", "wx", "cf", "cci", "wd", "ic", "cs", "vr", "rc", "vd", "VC", "rt", "c", "pc", "lc", "vl", "cu", "vi", "uv", "sn", "vv"], "vcend": [" vdc", "svcend", "svcent", "avcend", "tcend", " vcd", "svdc", "tcent", " vconst", "avdc", "svconst", "vcent", "tdc", "vdc", "vcd", "vmid", "vconst", "avconst", " vmid", "svmid", " vcent", "svcd", "avmid", "tcd"]}}
{"project": "FFmpeg", "commit_id": "41a052a6badc9ed672a810a40b8e54af5d093b5d", "target": 1, "func": "int opt_default(const char *opt, const char *arg)\n\n{\n\n    const AVOption *oc, *of, *os, *oswr;\n\n    char opt_stripped[128];\n\n    const char *p;\n\n    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;\n\n\n\n    if (!(p = strchr(opt, ':')))\n\n        p = opt + strlen(opt);\n\n    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n\n\n\n    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,\n\n                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n\n#if CONFIG_SWSCALE\n\n    sc = sws_get_class();\n\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        // XXX we only support sws_flags, not arbitrary sws options\n\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    swr_class = swr_get_class();\n\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (oc || of || os || oswr)\n\n        return 0;\n\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n\n    return AVERROR_OPTION_NOT_FOUND;\n\n}\n", "idx": 26087, "substitutes": {"opt": ["wp", "expr", "eff", "inf", "patch", "h", "options", "txt", "usr", "tp", "name", "post", "x", "num", "key", "path", "xt", "cp", "text", "pot", "tag", "open", "neg", "off", "al", "enc", "vert", "prefix", "obj", "oss", "feat", "pt", "cat", "opp", "o", "ext", "orig", "prop", "value", "ret", "proc", "optim", "or", "ort", "token", "option", "op", "attr", "iter", "all", "slice", "config", "po", "Opt", "hop", "lo", "fn", "OP", "f", "str", "term", "iv", "ott", "oper", "prev", "cho", "alt", " option", "xp", "go", "select", "it", "init", "loc", "lit", "object", "lt", "pos", "pr", "dest", "method", "ord", "temp"], "arg": ["ag", "num", "rec", "n", "help", "ret", "value", "slot", "valid", "end", "ax", "tag", "ne", "option", "op", "g", "optional", "alt", "iter", "item", "all", "neg", "enc", "null", "arr", "other", "args", "argument", "ar", "var", "target", "loc", "doc", "param", "ig", "str", "val", "call", "Arg", "pos", "flag", "par", "name", "ext"], "oc": ["oy", "unc", "ot", "dc", "oper", "soc", "bc", "anc", "nc", "voc", "ac", "ow", "od", "OC", "ou", "option", "op", "ob", "ov", "oo", "ocr", "cf", "acc", "oca", "enc", "roc", "config", "off", "oci", "om", "ocol", "toc", "oid", "og", "rc", "hop", "ok", "ol", "loc", "uc", "c", "ec", "pc", "co", "iv", "o", "org", "ir", "oe"], "of": ["ot", "et", "oft", "df", "OF", "voc", "eff", "Of", "or", "ou", "fd", "with", "fee", "ov", "no", "fi", "cf", "off", "on", "oci", "alf", "fr", "other", "oid", "de", "ef", "not", "ok", "ol", "inc", "fn", "f", "ec", "from", "orf", "bf", "por", "fe", "ocated", "o", "org", "ob", "at"], "os": ["ips", "ot", "oper", "ost", "voc", "ops", "or", "ort", "bos", "ros", "option", "op", "obs", "ocr", "org", "ps", "ols", "es", "is", "io", "options", "oa", "oos", "pass", "oci", "om", "s", "des", "oto", "oid", "oss", "ok", "si", "ol", "OS", "loc", "f", "ss", "object", "ose", "sn", "pos", "o", "osc", "so", "ott", "ob", "sys"], "oswr": ["osrw", "oscr", " osrw", "ssrw", "sWR", "oskr", "osscr", "ows", "ocr", "ocws", "osswr", " osWR", "okr", "osWR", "ocwr", "owr", "osws", "sswr", "ockr", "osskr", "ssWR", "ossws", "swr", "occr", "srw"], "opt_stripped": ["opt_stripraped", "opt_straped", "optttraved", "opt_strived", "opt_trapped", "opttstriipped", "opt_striipped", "opttstripped", "opt_stripitched", "opt_wrapping", "opt_stickpped", "opt_stickpping", "optttrapping", "opt_riitched", "opt_stripipped", "opt_traipped", "optttrapped", "opt_stripping", "opt_stpped", "opt_stpping", "opttstripping", "opt_stickipped", "opt_stripved", "opt_stripper", "opt_riipped", "opt_strippping", "optttraipped", "opt_wrapper", "opt_ripping", "opt_strippped", "opt_strippper", "opt_ripper", "opt_wrapped", "opt_rived", "opt_trapping", "opt_riraped", "opt_ripped", "opttstrived", "opt_wraraped", "opt_striraped", "opt_stitched", "opt_striitched", "opt_stickraped", "opt_traved"], "p": ["x", "b", "pg", "n", "wp", "j", "cp", "sp", "r", "op", "type", "ps", "pp", "l", "fp", "h", "v", "pe", "pre", "m", "ap", "dp", "t", "P", "u", "pn", "po", "jp", "e", "c", "pt", "bp", "d", "pc", "i", "f", "q", "np", "pr", "pos", "o", "tp", "lp", "pa"], "cc": ["unc", "dc", "xc", "ucc", "bc", "anc", "ca", "voc", "nc", "ac", "mc", "ck", "cv", "ce", "cf", "cci", "acc", "roc", "icc", "con", "cl", "cs", "tc", "cn", "rc", "cca", "jc", "uc", "c", "pc", "ec", "CC", "co", "cu", "ci", "kk", "cd"], "fc": ["isc", "unc", "sf", "dc", "bc", "ac", "fat", "fd", "fs", "fb", "mc", "fp", "fi", "cf", "con", "icc", "il", "ic", "nec", "fr", "lf", "uc", "inc", "fn", "flo", "pc", "ec", "lc", "ul", "bf", "f", "fa", "fe", "pic", "FC", "fl"], "sc": ["isc", "scope", "dc", " scope", "sci", " Sc", "bc", "ca", "nc", "anc", "Sc", "ac", "rs", " rc", "asc", "sp", "org", "cv", " scr", "cf", "go", "acc", "cl", "cs", "cr", "rc", "si", "desc", "loc", "uc", "c", "inc", "ec", "pc", "lc", "ss", "sq", "sw", "ci", "sn", "esc", "SC", " SC", "osc", "RC"], "swr_class": ["sws_cap", "swr__type", "sws_classes", "swr__lass", "swr_lass", "swr__scope", "swr__cap", "sws_type", "sws_scope", "swr_classes", "swr_cap", "swr_scope", "swr__classes", "sws_class", "swr__class", "sws_lass", "swr_type"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090, "substitutes": {"base": ["b", "big", "normal", "home", "id", "binary", "cache", "ached", "type", "zero", "p", "core", "address", "Base", "plus", "scale", "sync", "gap", "name", "post", "as", "year", "key", "valid", "build", "common", "prefix", "reverse", "ase", "buffer", "bas", "cli", "bf", "kit", "api", "out", "client", "slave", "site", "proxy", "ace", "full", "model", "boot", "root", "resource", "null", "unit", "absolute", "family", "stable", "f", "basic", "server", "source", "os", "chain", "ip", "fake", "bi", "real", "part", "store", "area", "ada", "local", "db", "active", "pse", "file", "bot", "bare", "se", "temp"], "aux1_base": ["aux1_b", "aux1_bas", "aux1__based", "auxn_bas", "aux1_stable", "aux1_full", "aux1_based", "aux1__base", "aux2_last", "aux1__stable", "aux2_based", "auxn_site", "auxn_base", "aux2_bas", "aux2_site", "aux2_stable", "aux1_last", "aux1_site", "aux1__b", "aux1__bas", "auxn_full", "aux1__last", "aux1__site", "aux2_b"], "aux2_base": ["aux1_bas", "aux2_build", "aux1_cache", "aux2_last", "aux2_cycle", "aux2_bas", "aux1_cycle", "aux62_full", "aux2_full", "aux2_core", "aux1_core", "aux62_last", "aux62_base", "aux2_cache", "aux62_build", "aux1_last"], "irq": ["irk", "irqu", "arch", "iraqs", " irk", "iraQ", "idqs", "idch", "arqs", "iwque", "iraq", "irique", "irque", "arq", " irqu", "iwqu", "iwq", "iriqu", "arQ", " irque", "idQ", "irQ", "irqs", "idq", "iriq", "irik", "iwk", "irch", "irach"], "fdc_tc": ["fdac_tc", "fdc_tm", "fdc2tm", "fdc_TC", "fdac_tg", "fdac_mc", "fdc_mc", "fdac_tm", "fdc_tg", "fdac_TC", "fdc2mc", "fdc2tc", "fdc2TC", "fdc2tg"], "dev": ["engine", "mod", "dc", "ch", "error", "driver", "conf", "err", "state", "mode", "ve", "self", "der", "req", "hw", "rad", "info", "g", "result", "DEV", "dn", "serial", "v", "conn", "priv", "ver", "cam", "p", "grad", "pro", "def", "di", "ev", "w", "device", "md", "Dev", "de", "db", "bug", "gu", "block", "dd", "d", "spec", "diff", "data", "bus", "user", "development", "dem", "prom", "temp", " device"], "s": ["js", "b", "S", "ssl", "sh", "sb", "fs", "g", "states", "new", "h", "tests", "p", "u", "device", "k", "si", "sup", "sync", "sq", "uses", "a", "as", "x", "native", "n", "gs", "es", "l", "service", "t", "su", "e", "c", "spec", "ui", "o", "site", "its", "status", "sites", "self", "ops", "full", "session", "ts", "sa", "is", "sk", "m", "sym", "w", "sg", "f", "ds", "server", "ses", "sys", "sl", "http", "rows", "os", "r", "v", "south", "ns", "an", "settings", "d", "i", "services", "us", "se"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n\n{\n\n    if (!mb_x) {\n\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n\n    } else {\n\n        return mb_y ? mode : HOR_VP8_PRED;\n\n    }\n\n}\n", "idx": 26100, "substitutes": {"mode": ["ward", "ode", "mod", "path", "status", "phase", "id", "rule", "direction", "state", "sid", "ODE", "position", "type", "command", "transform", "role", "range", "version", "m", "route", "stage", "def", "access", "MODE", "device", "md", "mac", "language", "scale", "node", "kind", "enabled", "module", "MOD", "disable", "grade", "Mode", "method", "name"], "mb_x": ["mb_p", "MB_x", "MB_v", "mb_v", "mb_w", "MB_w", "mb_z", "MB_y", "MB_z", "MB_p"], "mb_y": ["mm_z", "MB_x", "mb_ye", "mbLogy", "mbxcy", "mbLogye", "mbLogyt", "mb08z", "mbFy", "mbxx", "mb_vy", "MB_yd", "mm_yt", "mm_y", "mbFvy", "mb08yd", "mb08y", "mbxry", "mb08vy", "mb_yd", "mbxy", "mb_z", "mb_ry", "MB_y", "mb_cy", "mm_ye", "MB_z", "mbFyd", "mb_yt", "MB_cy", "MB_vy", "mbLogz", "MB_ry", "mbFz"]}}
{"project": "FFmpeg", "commit_id": "da34e4e13238b755bb0e6ebf549015797d9b4467", "target": 1, "func": "static struct ResampleContext *create(struct ResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear,\n\n        double cutoff, enum AVSampleFormat format, enum SwrFilterType filter_type, double kaiser_beta, double precision, int cheby, int exact_rational){\n\n    soxr_error_t error;\n\n\n\n    soxr_datatype_t type =\n\n        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :\n\n        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :\n\n        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :\n\n        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :\n\n        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :\n\n        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :\n\n        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :\n\n        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;\n\n\n\n    soxr_io_spec_t io_spec = soxr_io_spec(type, type);\n\n\n\n    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);\n\n    q_spec.precision = linear? 0 : precision;\n\n#if !defined SOXR_VERSION /* Deprecated @ March 2013: */\n\n    q_spec.bw_pc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : q_spec.bw_pc;\n\n#else\n\n    q_spec.passband_end = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : q_spec.passband_end;\n\n#endif\n\n\n\n    soxr_delete((soxr_t)c);\n\n    c = (struct ResampleContext *)\n\n        soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);\n\n    if (!c)\n\n        av_log(NULL, AV_LOG_ERROR, \"soxr_create: %s\\n\", error);\n\n    return c;\n\n}\n", "idx": 26110, "substitutes": {"c": ["b", "context", "n", "dc", "ch", "cmp", "ca", "ac", "cc", "cp", "ctx", "r", "mc", "cache", "g", "l", "v", "h", "cont", "cf", "icc", "config", "p", "m", "cs", "tc", "t", "s", "cit", "u", "C", "w", "cm", "ct", "k", "e", "d", "f", "i", "lc", "cb", "q", "ci", "o", "a"], "out_rate": ["out_period", "out_frequency", "out_rates", "in_frequency", "in_rates", "in_period"], "in_rate": ["out_radius", "inacrate", "out_size", "in_size", "in_radius", "out_rates", "inacsize", "inacradius", "in_rates", "inacrates"], "filter_size": ["filter_center", " filter_seed", "filterflowscale", "filterfullseed", "filter_seed", "filterflowsize", "filterfullscale", "filterfullsize", " filter_scale", "filterflowcenter", " filter_center", "filterfullcenter", "filterflowseed", "filter_scale"], "phase_shift": ["line_size", "line\u00b7offset", "line\u00b7index", "line_index", "line_offset", "phase\u00b7offset", "line\u00b7size", "line_shift", "phase_index", "phase\u00b7size", "phase\u00b7index", "phase_offset", "phase\u00b7shift", "line\u00b7shift", "phase_size"], "linear": ["physical", "loop", "alpha", "repeat", "forward", "direction", "lr", "space", "valid", "quant", "neutral", "ssl", "final", "binary", "material", "regular", "params", "serial", "l", "la", "auc", "cost", "initial", "util", "sym", "operator", "local", "reverse", "lin", "gradient", "active", "scale", "increasing", "aligned", "positive", "random", "standard", "round", "global", "partial", "stall"], "cutoff": [" cutoffs", "clipaway", "rubdown", "feedoffset", "putoffs", "Cuton", "clipdown", " cuton", " cutout", "cutoffset", "ruboffs", "CutOFF", "critdown", "cutOFF", "puton", " cutdown", "Cutoffs", "cutdown", "critoff", "critOFF", "ruboff", "cutaway", "rubaway", "Cutdown", "feedoff", "feedoffs", "cutout", "clipoff", "ruboffset", "feeddown", "cutoffs", "rubout", "Cutoff", "cuton", " cutaway", " cutoffset", "putoff", "Cutout", "clipoffs", "rubOFF"], "format": ["ant", "array", "Format", "FORM", "frequency", "AT", "path", "parent", "value", "column", "mode", "filename", "source", "shape", "valid", "offset", "magic", "function", "category", "title", "group", "feature", "number", "model", "size", "field", "type", "position", "quality", "template", "transform", "layout", "options", "style", "config", "range", "version", "pretty", "MAT", "stage", "unit", "package", "force", "it", "attribute", "definition", "language", "scale", "feat", "file", "export", "archive", "output", "types", "f", "object", "data", "api", "pattern", "map", "method", "list", "form", "name", "class", "length", "support", "dimension", "fit"], "filter_type": ["Filter_types", "filter2style", "filter2types", "Filter_type", "Filter_style", "filter_types", "filter_name", "filter2name", "filter2type", "Filter_name", "filter_style"], "kaiser_beta": ["kaise_Beta", "kaiser_Beta", "kaise_beta", "kaiser_alpha", "kaise_alpha", "kaiser_radius", "kaise_radius"], "cheby": ["hebar", "chebi", "gethis", "hopbar", "chergar", "heBY", "hopbi", "cherthis", "hebi", "coreby", "hopBY", "corethis", "coregar", "chegar", "heby", "cherby", "chebar", "schebi", "hopby", "scheby", "gegar", "geby", "cheBY", "chethis", "schebar", "scheBY", "corebi", "cherbi", "gebi"], "exact_rational": ["exception_norm", "exception_trial", "exact_trial", "exception_rational", "exact_alpha", "exact_norm", "exception_alpha"], "error": ["ception", "sc", "err", "self", "Error", "AE", "ae", " Error", "no", " exception", "null", "change", "C", "ERROR", "ok", "Exception", " err", "fe", " E"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113, "substitutes": {"opaque": ["opaco", "oplacity", "oppaque", "opedcus", "iopcus", "oplonymous", "oplaque", "oponymous", " opaco", "oppya", "opedaque", "operacity", "opedaco", "opedonymous", " opcus", "operya", "operonymous", " oponymous", "iopaco", "oppacity", "oplya", "opponymous", "opcus", "opya", "opacity", "ioponymous", "operaque", "iopaque"], "buf": ["b", "cap", "port", "pb", "base", "bc", "vec", "func", "bb", "sb", "len", "fd", "rb", "cv", "Buffer", "fp", "v", "raw", "src", "pool", "config", "queue", "alloc", "cmd", "buffer", "loc", "seq", "bp", "f", "cb", "bf", "data", "uf", "length", "fb", "buff"], "pos": ["index", "port", "Pos", "pose", "base", "conf", "slot", "count", "os", "end", " position", "len", "position", "cache", "axis", "type", "pid", "neg", "ref", "slice", "off", "POS", "address", "Position", "push", "addr", "loc", "limit", "pt", "start", "padding", "pc", "seq", "lit", "i", "val", "data", "pad", "pointer", "offset"], "size": ["n", "ize", "sum", "z", "mode", "count", "end", "send", "bytes", "len", "fee", "g", "enc", "name", "empty", "SIZE", "code", "iz", "address", "unit", "args", "scale", "small", "e", "loc", "c", "sec", "sized", "data", "Size", "en", "length", "offset"], "s": ["js", "b", "scope", "sl", "a", "your", "http", "S", "gs", "self", "os", "rs", "opens", "ops", "ssl", "g", "syn", "session", "ps", "es", "sa", "is", "v", "service", "hs", "p", "core", "m", "sym", "peer", "socket", "w", "ns", "settings", "e", "sync", "c", "f", "ss", "spec", "ls", "ds", "services", "sq", "server", "o", "ses", "sys"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n", "idx": 26117, "substitutes": {"type": ["platform", "port", "id", "count", "url", "ref", "instance", "p", "address", "kind", "block", "sync", "name", "class", "year", "key", "parent", "phase", "state", "format", "ype", "python", "info", "build", "style", "role", "t", "pc", "typ", "o", "pointer", "Type", "index", "plugin", "status", "error", "value", "message", "test", "full", "option", "op", "position", "model", "y", "pe", "null", "config", "level", "code", "unit", "attribute", "TYPE", "family", "module", "f", "data", "ping", "date", "base", "http", "source", "day", "number", "size", "part", "py", "version", "time", "file", "like", "types", "object", "length", "ty"], "clock": ["loop", "watch", "year", "css", "cpu", "proxy", "bc", "course", "http", "journal", "ac", "life", "shift", "keeper", "connection", "timeout", "lib", "ctl", "chain", "cache", "number", "Clock", "week", "chron", "boot", "sleep", "config", "echo", "script", "glass", "lock", "tower", "poll", "tc", "address", "currency", "socket", "push", "kick", "time", "timer", "fact", "block", "sync", "bot", "library", "pc", "delay", "cb", "call", "square", "server", "tick", "length", "offset"]}}
{"project": "qemu", "commit_id": "586502189edf9fd0f89a83de96717a2ea826fdb0", "target": 1, "func": "static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n", "idx": 26136, "substitutes": {"opts": ["prots", "opps", "optts", "OPt", " opls", " optt", "ops", "optps", "prols", "proters", "optters", "opls", "opters", " opters", "props", "optls", "OPts", " optls", "OPs", "OPls", " opps", " optts", "opt", "optt"], "chr": ["archrg", " chn", "chesr", "coldr", "childrg", "cherc", "schr", "childri", "Chru", " chsr", "anchrr", " chru", "chdr", "handn", "schrb", "Chsr", "chcr", "kyru", "cldr", "motru", "clr", "colre", "corsr", "childrr", "coln", "clrer", "motro", "motr", "schrc", "Chrb", "archrr", "uchrg", "motrr", "chrr", " chdr", "motdr", "chersr", "archri", "Chr", "chre", " chro", "cherrg", "handrr", "apprg", "cher", "corcr", "handru", "chri", "gyr", "appro", "cherrar", "schrr", "cherr", "gecr", "colro", " chcr", "chrer", "chn", "colr", "catro", "apprar", "colrr", "cherrb", " chrer", "gyru", "uchri", " chre", "cherro", "anchrb", "gyrr", "chsr", "checr", "catrg", "clrr", "ger", "kyr", "chrar", "handr", "kyrer", "appr", "chrc", "cherru", "geru", "corrb", "chro", "archr", "anchrc", "chru", "corr", "uchr", "cherb", "childr", "gerer", "gydr", "uchrr", " chrb", "kycr", "anchr", "chrg", "catr", "colru", "catrar", "motre", " chrr", "gyrer", "chrb"], "s": ["js", "b", "ips", "sf", "n", "sl", "a", "http", "S", "gs", "rs", "os", "er", "ops", "sb", "ssl", "sp", "ows", "r", "fs", "g", "storage", "session", "ts", "es", "l", "v", "h", "service", "ssh", "p", "m", "sym", "t", "ser", "socket", "w", "u", "su", "ns", "sg", "si", "settings", "e", "sync", "c", "sie", "sports", "ss", "f", "i", "ls", "ds", "services", "serv", "sw", "server", "o", "client", "ses", "sys", "slave"], "tty": ["tta", "proc", "shell", "interface", "sth", "test", "tf", "ta", "task", "sh", "ctl", "private", "vt", "ptr", "python", "token", "ctor", "tt", "slave", "readable", "reader", "tti", "tr", "echo", "sudo", "tmp", "kt", "tc", "t", "timeout", "username", "socket", "tx", "console", "pty", "txt", "phy", "padding", "technology", "touch", "thread", "server", "trace", "tif", "eth", "te", "tp", "pointer", "sys", "ty"], "master_fd": ["master_tty", "primary_df", "masterJtube", "middle_fd", "master_fs", "master_handle", "master_d", "master_df", "master_socket", "master_tube", "master_dra", "masteracfs", " master_ds", "middleapptube", "slave_tty", "slave_cond", "masteracfd", "masterapphandler", "masterJhandler", "slave_fx", "masterJsector", "primary_fs", "slave_sector", "masterbookdf", " master_cond", "middle_tube", "masterpds", "master_sector", "masteracfin", "master_channel", "slave_df", "masterJdra", " master_channel", "masterbooktty", "masterJfin", "middle_dra", "master_file", "slave_fin", "slave_d", "primary_fd", "middle_handler", "masterpchannel", "middleapphandler", " master_handler", "primary_socket", "middleappfd", "masterJfd", "masterappdra", "masteracsector", "masterbookhandler", " master_file", "master_cond", "middleappdra", "master_fin", "slave_handler", " master_handle", "master_fx", "masteracsocket", "master_ds", "masterachandler", "master_handler", "masterapptube", "masteracdf", "masterpcond", "masterpfd", "masterappfd", "masterbookfd"], "slave_fd": ["slave_channel", "master_fn", "master_df", "slave_dl", "server_d", "slaveerdir", "slave_cond", "slaveerconn", "master_dl", "slave_conn", "slaveerfd", "slave_dir", "slave_df", "server_fd", "server_cond", "slave_d", "slave_fn", "master_conn", "master_cond", "server_channel", "slaveerhandler", "master_dir", "slave_handler", "master_handler", "server_handler"], "len": ["num", "span", "li", "n", "sl", "ny", "base", "z", "lim", "Len", "filename", "count", "fat", "end", "dy", "fd", "sp", "fin", "size", "hl", "l", "part", "rev", "lvl", "lon", "lock", "line", "lf", "ld", "lin", "el", "ll", "loc", "limit", "seq", "f", "delay", "lc", "ls", "lit", "dl", "val", "min", "lt", "pos", "le", "lp", "en", "length", "ln", "fl", "offset"], "pty_name": ["ptystype", "pty_len", "pt_type", "pt_path", "pty_path", "slave_name", "ptysid", "pty_names", "slave_names", "py_names", "ptysname", "pty_address", "pty2name", "py_name", "pty_id", "pty_type", "pty2len", "pty2names", "ptysnames", "pt_names", "pt_id", "slave_len", "pt_name", "py_address"]}}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "substitutes": {"env": ["site", "context", "worker", "que", "vm", "dict", "conf", "err", "eu", "state", "esp", "proc", "cp", "environment", "er", "req", "loader", "gui", "info", "exe", "cache", "esi", "v", "conn", "priv", "style", "enc", "erv", "config", "manager", "code", "dev", "exc", "equ", "args", "obj", "ev", "inst", "db", "file", "e", "export", "eng", "ea", "eni", "ec", "ep", "server", "np", "fen", "viron", "opt", "en", "ext"], "order_code": [" order_call", "order2class", "order2count", "order2code", "order2call", " order_codes", "sort_codes", "sort_Code", "orderycode", "order_call", "orderprecode", "order_codes", " order_key", "orderylevel", " order_count", "order_count", "order2Code", "sort_call", " order_level", "orderprecodes", "order_Code", "order_level", "sort_code", "order_class", " order_class", "orderalcount", "orderalkey", "orderprecount", "order_key", "orderalcode", "orderycodes", "orderycall", "orderpreclass", "orderalcodes", "order2codes"], "r1": [" r2", "R4", "R9", "order0", "r3", " r9", "order2", "R2", "r2", "r0", "R0", "order9", "sr0", " r4", "sr1", "R1", "r9", "r4", "e2", "sr2", "R3", "e3", " r0", "e1", " r3", "sr4", "order1"], "cpu_addr": ["gpu_offset", "cpu_ord", "gpu_ord", "cpu_address", "cpu_offset", "gpu_port", "gpu_address", "cpu2ord", "cpu2address", "gpu_addr", "cpu2addr", "cpu_port", "cpu2offset"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2rgb_1_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                     const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                     const uint16_t *abuf0, uint8_t *dest, int dstW,\n\n                     int uvalpha, enum PixelFormat dstFormat,\n\n                     int flags, int y, enum PixelFormat target,\n\n                     int hasAlpha)\n\n{\n\n    int i;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 = buf0[i * 2]     >> 7;\n\n            int Y2 = buf0[i * 2 + 1] >> 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    }\n\n}\n", "idx": 26154, "substitutes": {"i": ["index", "x", "mini", "ai", "oi", "li", "pi", "in", "n", "ie", "key", "z", "id", "j", "source", "me", "abi", "yi", "info", "iu", "ip", "ix", "ei", "gi", "ri", "bi", "l", "is", "ti", "y", "io", "fi", "slice", "v", "uri", "xi", "ini", "mu", "inner", "multi", "p", "qi", "zi", "m", "line", "di", "I", "t", "u", "it", "init", "ii", "my", "si", "e", "c", "d", "eni", "f", "cli", "api", "q", "ori", "ui", "phi", "ci", "o", "ni", "name", "ki", "mi"], "A1": [" A30", "Ac8", "LA2", " A8", "A7", "a1", "AA30", " A7", " A01", "U1", " A100", "A30", "A100", "LA1", "UOne", "An100", "An8", "Ac100", "AAOne", "A01", "U5", "LAOne", "A3", "Ac1", "A5", " A121", " A5", "Uone", "aOne", "LAone", "Ac121", "AA1", "CA01", "AA3", "An121", "a3", "A8", "a30", "An1", "LA01", "Aone", " A3", "LA5", "LA7", "CA1", " AOne", " Aone", "A121", "AOne", "CA7", "CA2"], "A2": ["Isecond", "LA2", " ATwo", "I5", "V2", "BTwo", "B2", "LA1", "Vtwo", "Y02", "EAtwo", "B1", "MA2", "Asecond", "A02", "Ysecond", " A02", " Asecond", "MATwo", "I2", "VTwo", "Y2", "A5", " A5", "Y5", "EA02", "LAtwo", "Ytwo", " Atwo", "MA1", "Itwo", "YTwo", "EA2", "V1", "ATwo", "Atwo", "LATwo", "EATwo"], "r": ["x", "sr", "n", "gr", "err", "er", "or", "rb", "dr", "attr", "l", "v", "h", "y", "rg", "mr", "R", "p", "m", "fr", "rl", "rh", "s", "u", "w", "ar", "ur", "k", "re", "e", "d", "f", "ru", "q", "rr", "pr", "o", "a", "ir"], "g": ["x", "gm", "n", "gl", "j", "gh", "yg", "group", "gn", "gi", "l", "v", "h", "y", "rg", "G", "p", "fg", "gy", "m", "eg", "s", "u", "w", "og", "sg", "k", "e", "gu", "c", "ig", "d", "gg", "f", "gen", "q", "reg", "a", "ga", "bg"], "b": ["x", "abb", "bl", "n", "z", "j", "bh", "lib", "bb", "sb", "ba", "bs", "rb", "wb", "bi", "l", "y", "v", "h", "be", "url", "ib", "bd", "app", "p", "ub", "m", "ab", "t", "mb", "s", "u", "w", "eb", "k", "e", "bot", "d", "f", "lb", "q", "o", "B", "a", "ob", "fb"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 26158, "substitutes": {"s": ["js", "b", "its", "native", "n", "sl", "qs", "secondary", "conf", "S", "gs", "self", "rs", "os", "uns", "ops", "ssl", "sb", "private", "fs", "r", "g", "bs", "session", "ps", "states", "ts", "es", "is", "l", "v", "service", "hs", "ins", "p", "cs", "sym", "t", "iss", "u", "south", "sets", "su", "ns", "sg", "si", "this", "settings", "e", "sync", "c", "ss", "f", "spec", "ls", "ds", "xs", "services", "sq", "server", "comments", "us", "ses", "sys", "stats"], "sec": ["sect", "seconds", "rec", "decl", "year", "security", "sl", "sc", "conf", "proc", "req", "inf", "sub", "ctr", "ssl", "secure", "sid", "zip", "fee", "Sec", "nt", "size", "secret", "sy", "ref", "acc", "enc", "con", "config", "cl", "ct", "desc", "isec", "loc", "sync", "SEC", "seq", "inc", "c", "ec", "lit", "spec", "lc", "second", "sq", "sic", "esc", "section", "reg", "se", "cur"], "secn": ["secureN", "securenan", "ctp", "Secnan", "Secr", "ecp", "seqp", " secl", "ecns", "secc", "securens", "secondn", "Secno", "secr", "Secp", "SecN", "securityns", "condd", "condc", "secondc", "securityn", " secd", "isecn", "isecp", "secnan", "securen", " secr", "Secn", "seqN", "secno", "ctN", "ecN", "ctn", "ecl", "Secns", " secc", "ecn", "ctno", "secondd", " secno", "condn", "isecr", " secp", "isecN", "condN", "secN", "securityN", "secondN", "secns", "isecns", "seqn", " secN", "secp", "seql", "secl", " secns", "securitynan", "secd"], "src": ["buf", "sr", "sl", "SOURCE", "sc", "rib", "rob", "source", "supp", "proc", "super", "Source", "rs", "inf", "sth", "sub", "ctr", "sb", "ssl", "ptr", "rb", "attr", "fp", "url", "ref", "sur", "stream", "roc", "tmp", "inst", "rc", "loc", "img", "cb", "spec", "dest", "RC", "cur"], "sp": ["span", "gp", "pg", "bsp", "sl", "wp", "sr", "mp", "Sp", "space", "cp", " cp", "SP", "sb", "sh", " esp", "op", "ip", "ps", "pp", "prep", "sk", "py", "pre", "p", "ap", " p", "jp", "si", "bp", "pc", "ds", "ep", "spe", "np", "pr", "par", "tp", "ipp"], "dp": ["reb", "prop", "dep", "pg", "pb", "gp", "dq", "dc", "drop", "wp", "DP", "dt", "decl", "proxy", "df", "cp", "dh", "send", "bb", "vp", "ssl", "pkg", "ip", "dim", "pm", "ps", "pp", "dr", "params", "resp", "dn", "fp", "pid", "isp", "prep", "p", "grad", "tp", "di", "address", "dm", "imp", "adr", "db", "jp", "loc", "dd", "eps", "d", "pd", "ds", "ep", "dl", "data", "api", "rep", "port", "deb", "dat", "fb"], "i": ["ai", "b", "oi", "li", "iii", "pi", "in", "ie", "ji", "z", "id", "j", "abi", "info", "hi", "ip", "ix", "dr", "gi", "ri", "bi", "l", "ti", "v", "io", "mu", "fi", "uri", "xi", "ini", "p", "qi", "zi", "di", "I", "u", "it", "ii", "var", " ii", "jp", "si", "e", "uli", "c", "ind", "d", "eni", "f", " init", "ui", "ci", "vi", "phi", " pi", "o", "ni", "ei", "mi"]}}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)\n\n{\n\n    uint64_t magic;\n\n    uint32_t opt;\n\n    uint32_t type;\n\n    uint32_t len;\n\n    uint32_t namelen;\n\n    int error;\n\n\n\n    *name = NULL;\n\n    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n\n        error_setg(errp, \"failed to read list option magic\");\n\n        return -1;\n\n    }\n\n    magic = be64_to_cpu(magic);\n\n    if (magic != NBD_REP_MAGIC) {\n\n        error_setg(errp, \"Unexpected option list magic\");\n\n        return -1;\n\n    }\n\n    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n\n        error_setg(errp, \"failed to read list option\");\n\n        return -1;\n\n    }\n\n    opt = be32_to_cpu(opt);\n\n    if (opt != NBD_OPT_LIST) {\n\n        error_setg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\",\n\n                   opt, NBD_OPT_LIST);\n\n        return -1;\n\n    }\n\n\n\n    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {\n\n        error_setg(errp, \"failed to read list option type\");\n\n        return -1;\n\n    }\n\n    type = be32_to_cpu(type);\n\n    error = nbd_handle_reply_err(ioc, opt, type, errp);\n\n    if (error <= 0) {\n\n        return error;\n\n    }\n\n\n\n    if (read_sync(ioc, &len, sizeof(len)) != sizeof(len)) {\n\n        error_setg(errp, \"failed to read option length\");\n\n        return -1;\n\n    }\n\n    len = be32_to_cpu(len);\n\n\n\n    if (type == NBD_REP_ACK) {\n\n        if (len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n", "idx": 26160, "substitutes": {"ioc": ["iosc", "tiocol", " iocol", "piosc", "pioc", "xioca", "iocol", "ioci", "ioocal", "yivoc", "qioci", "antioci", "uiocal", "ivoc", " iosc", "riocon", "xiir", "iooci", "uiog", " iocl", "uiroc", "tiocl", "tioca", "ioca", " iog", "ioog", "ioirc", "uiocl", "uioc", "iairc", "riocal", "gioci", "givoc", "iocl", "tioc", "iaocal", " ioci", "antioc", "ioocl", " iocal", "qiosc", "iir", "qioc", "ioroc", "uiirc", "qiir", "iirc", "rioc", "iaog", "iaoci", "antiroc", "yioc", "iocal", "yioci", "pioci", "uiocol", "uioci", " iir", "ioocol", "xioc", "riocl", " ioca", "uioca", "qioca", "iooc", "piog", "ioocon", " iocon", "gioc", "iroc", "iog", "qivoc", "iaoc", "iocon", "yioca", "xiosc", "iaosc", "gioca", "antiocol"], "name": ["alias", "n", "key", "path", "parent", "id", "message", "nick", "wave", "info", "option", "op", "ip", "cache", "new", "no", "named", "options", "config", "code", "cmd", "prefix", "init", "names", "ame", "comment", "Name", "block", "seq", "str", "data", "call", "method", "NAME"], "errp": ["erlp", "ierlp", "errps", "errapi", "ierf", "erg", "erpoint", " erp", "Erc", "errc", "erpre", "ierfp", "ierg", "errorpre", "erp", " erlp", " errc", "errpre", "erfp", "refp", "iert", "frapi", "arrb", "orderper", "arrp", "erpe", "armP", "srapi", "errpoint", "iterpoint", "ierp", "aerper", "irpre", " errb", "errf", " errP", "arrps", "iterfp", "oderb", "armfp", "strp", "erper", "errfp", "errorp", "oderps", "errorapi", "reft", "errorf", " errps", "errorP", "ierpe", "srP", "errorlp", "errt", "strg", "irpoint", "Erp", " errper", "aitp", "iterpre", "orderp", "errorping", "srp", "frP", " erpe", "strt", "errorfp", "orderps", "aerp", "errlp", "ErP", "aerfp", "arrper", "irp", "refP", "orderfp", "errg", "aitping", "errper", "strP", "srb", " errpre", "errorc", "errb", "irfp", "aitfp", "errping", "ierP", "oderper", "Erpre", "refg", "erf", " erfp", "frp", "aerps", "oderp", "errP", "frb", "armg", "errpe", "armp", "iterp", "errorb", "erping", "erps", "erP"], "magic": ["mini", "agent", "plugin", "dc", "security", "status", "parser", "base", "custom", "icon", "err", "id", "format", "space", "wave", "xxx", "header", "binary", "token", "info", "cache", "size", "dom", "ix", "generic", "secret", "serial", "special", "config", "lock", "nil", "cmd", "prefix", "virt", "bug", "init", "acl", "domain", "file", "tech", "seq", "bot", "unique", "module", "git", "spec", "stat", "Magic", "data", "cat", "meta", "phys", "cookie", "xml", "mag"], "opt": ["search", "expr", "mode", "id", "prot", "h", "url", "options", "lock", "txt", "block", "key", "parent", "err", "slot", "text", "pot", "info", "open", "style", "off", "vert", "obj", "prefix", "xy", "oss", "feat", "pt", "spec", "cat", "o", "ext", "offset", "prop", "ret", "timeout", "optim", "ort", "token", "option", "op", "operation", "update", "attr", "iter", "config", "cmd", "Opt", "hop", "lo", "rot", "seq", "str", "term", "min", "oper", "zip", "cho", "ip", "alt", " option", "tr", "go", "init", "loc", "bot", "lit", "object", "pos", "auth", "temp"], "type": ["port", "id", "rule", "count", "url", "single", "ver", "p", "lock", "other", "comment", "block", "tp", "class", "post", "num", "key", "set", "rel", "parent", "err", "state", "format", "ype", "action", "info", "style", "off", "role", "pre", "cl", "t", "copy", "typ", "val", "cat", "o", "offset", "Type", "plugin", "value", "test", "or", "none", "token", "option", "op", "model", "attr", "y", "all", "pe", "config", "sort", "on", "code", "TYPE", "target", "call", "ping", "base", "zip", "size", "alt", "part", "py", "version", "area", "var", "time", "loc", "like", "types", "method", "list", "length", "ty"], "len": ["bl", "li", "split", "count", "lic", "url", "lock", "line", "lf", "ler", "el", "elt", "block", "limit", "en", "ln", "depth", "num", "coll", "n", "un", "rel", "err", "fat", "nt", "l", "pre", "lon", "lin", "delay", "lc", "val", "dl", "Len", "offset", "lan", "lib", "op", "hl", "iter", "ll", "fn", "seq", "f", "gen", "layer", "data", "ann", "min", "lang", "sl", "base", "body", "fin", "size", "alt", "la", "part", "version", "fun", "loc", "fl", "lit", "ls", "lt", "pos", "list", "length"], "namelen": ["namelon", "namelinoren", "nam\t", "samelaren", "namelten", "namELen", "nameltoen", "namelinaren", "namelloren", "namularen", "lab\n", "imag\t", "imagellen", "namELaren", "imagelloren", "imagellon", "samelen", "namelton", "sameloen", "namulen", "imag\n", "ram\n", "namelloen", "imagelon", "namelaren", "nameloen", "nameloren", "imageloren", "namELoren", "namulon", "namellaren", "samellen", "samelloen", "imagelaren", "namuloen", "namellon", "namELon", "samellaren", "namelinen", "imagellaren", "lab\t", "namelinon", "nam\n", "ram\t", "samellon", "nameltaren", "namellen", "imagelen", "samelon"], "error": ["index", "date", "last", "errors", "status", "value", "err", "id", "progress", "er", "valid", "ack", "or", "none", "Error", "row", "info", "r", "patch", "op", "danger", "size", "result", " Error", "no", "all", "ror", "null", "rage", "code", "core", "rss", "one", "bug", "unknown", "var", "ERROR", "rc", "comment", "e", "warning", "block", "element", "i", "length", "html", "next", "call", " err", "rr", "event", "grade", "user", "order", "success", "bad"]}}
{"project": "FFmpeg", "commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "target": 1, "func": "static int hwupload_query_formats(AVFilterContext *avctx)\n\n{\n\n    HWUploadContext *ctx = avctx->priv;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n\n    AVFilterFormats *input_formats = NULL;\n\n    int err, i;\n\n\n\n    if (!avctx->hw_device_ctx) {\n\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n\n               \"to upload frames to.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n\n    if (!ctx->hwdevice_ref)\n\n        return AVERROR(ENOMEM);\n\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n\n    if (!constraints) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n\n    output_pix_fmts = constraints->valid_hw_formats;\n\n\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n\n    if (!input_formats) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (input_pix_fmts) {\n\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n\n            if (err < 0) {\n\n                ff_formats_unref(&input_formats);\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n\n                   &avctx->outputs[0]->in_formats);\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&ctx->hwdevice_ref);\n\n    av_hwframe_constraints_free(&constraints);\n\n    return err;\n\n}\n", "idx": 26173, "substitutes": {"avctx": ["avcb", "navctx", "akcontext", "avconsole", "aveconfig", "akcv", "avecontext", "Avcmp", "avekb", "afcb", "afcontext", "AVkb", "avcv", "akcam", "evcontext", "ajconsole", "evconn", "afctx", "avecmp", "avecv", "Avcontext", "afconn", "avconn", "afcv", "afkb", "Avcv", "evconsole", "afcmp", "ajcontext", "akctx", "avcontext", "AVcmp", "AVcb", "navctl", "navcmp", "navcontext", "AVctl", "AVcv", "AVcontext", "AVcam", "avkb", "afctl", "Avcb", "ajconn", "Avctx", "Avcam", "evctx", "avctl", "avectx", "AVconfig", "avconfig", "avcmp", "afconsole", "avcam", "ajctx", "afconfig", "AVctx"], "ctx": ["fw", "context", "xc", "sc", "conf", "bc", "cmp", "ca", "anc", "nc", "cc", "cms", "cp", "hw", "cus", "mc", "pkg", "ck", "cv", "cas", "kw", "conn", "ce", "cf", "config", "cam", "instance", "vc", "kt", "cs", "tc", "cmd", "wcs", "cn", "conv", "cm", "tx", "ctrl", "acl", "jp", "cca", "loc", "uc", "c", "pc", "lc", "cb", "aux", "cat", "sq", "cu", "ci", "qa", "client", "kb"], "constraints": ["conntiffs", "constiffs", "conformaints", "oconstraints", "oconformitives", "confortures", "Conctruments", "uncompluments", "constraint", "concompluments", "constrants", "constritives", "conretitives", "Constiffs", "Conctrants", "constructorts", "conntants", "concomplaints", "conctraint", "constrributes", "contraint", "Constaints", "conretaints", "converributes", "conretures", "constructaints", "Construments", "constructributes", "Conctraint", "concomplants", "oconstrappings", "contrants", "Constriffs", "conctrants", "conforts", "unstruments", "confaint", "confortappings", "converaints", "uncomplributes", "recsts\n", "Constraints", "conformitives", "confortaints", "oconformures", "conretappings", "Constrants", "contraints", "oconstritives", "uncomplorts", "Constants", "Conctraints", "Constrorts", "conctraints", "uncomplaints", "construct\n", "Constructaints", "Constraint", "constaint", "conntaints", "constructaint", "construments", "converorts", "conformappings", "contruments", "constaints", "conribaint", "constructuments", "constrorts", "concomplaint", "Constructaint", "recstr\n", "conctruments", "consts\n", "Constructributes", "constants", "concomplributes", "concomplorts", "confaints", "confributes", "conribaints", "construres", "confortitives", "conntaint", "constrappings", "conformures", "constr\n", "conribiffs", "conribants", "constriffs", "converuments", "conStr\n", "unstrributes", "oconstrures", "unstraints", "Constructorts", "Constaint", "oconformappings", "Constrributes", "oconformaints", "unstrorts"], "input_pix_fmts": ["input_pix_gmt", "input_pix_dimts", "input_pix_fmTS", "input_pix_wmats", "input_pix_wmters", "input_pix_cmps", "input_pix_fcts", "input_pix_gmters", "input_pix_rmts", "input_pix_formats", "input_pix_gmats", "input_pix_mmats", "input_pix_cmms", "input_pix_cmats", "input_pix_fats", "input_pix_formters", "input_pix_fmats", "input_pix_fcats", "input_pix_mats", "input_pix_mmTS", "input_pix_dimters", "input_pix_dimats", "input_pix_fmps", "input_pix_fmms", "input_pix_cmt", "input_pix_fcaters", "input_pix_mmts", "input_pix_wmts", "input_pix_mters", "input_pix_mt", "input_pix_fct", "input_pix_mmms", "input_pix_fms", "input_pix_fTS", "input_pix_formps", "input_pix_fmaters", "input_pix_wmt", "input_pix_dimps", "input_pix_fts", "input_pix_cmts", "input_pix_rmters", "input_pix_cmters", "input_pix_fmters", "input_pix_wmaters", "input_pix_gmts", "input_pix_mts", "input_pix_cmTS", "input_pix_rmats", "input_pix_formts", "input_pix_cmaters", "input_pix_fmt", "input_pix_rmt"], "output_pix_fmts": ["output_pix_umats", "output_pix2wmats", "output_pix2fmt", "output_pix_fmters", "output_pix_umt", "output_pix_cmters", "output_pix_fmTS", "output_pix_formats", "output_pix2wmters", "output_pix2fmks", "output_pix_mps", "output_pix_mt", "output_pix_mtes", "output_pix_rmts", "output_pix_wmats", "output_pix_mats", "output_pix_cmtes", "output_pix_fats", "output_pix2cmt", "output_pix2cmts", "output_pix_fmps", "output_pix_cmt", "output_pix_cmts", "output_pix_fmks", "output_pix_fts", "output_pix_rmks", "output_pix_formts", "output_pix2cmats", "output_pix2fmats", "output_pix2wmTS", "output_pix_rmt", "output_pix_mters", "output_pix_cmTS", "output_pix2cmks", "output_pix_mts", "output_pix_fmats", "output_pix_formters", "output_pix_wmts", "output_pix_rmats", "output_pix_fmt", "output_pix2wmts", "output_pix_fps", "output_pix2fmTS", "output_pix2fmters", "output_pix_ftes", "output_pix2fmts", "output_pix_wmTS", "output_pix_cmks", "output_pix_wmt", "output_pix_cmats", "output_pix_wmters", "output_pix_formTS", "output_pix_umks", "output_pix_cmps", "output_pix_fmtes", "output_pix_umts"], "input_formats": ["input_facolds", "input_formsatter", "input_formaters", "input_feations", "input_formolds", "input_formsats", "input_factats", "input_featter", "input_transformars", "input_formatter", "input_FORMATS", "input_formsations", "input_transformets", "input_commatives", "input_formatatter", "input_operarts", "input_formets", "input_feands", "input_FORMats", "input_operations", "input_factls", "input_feATS", "input_formataps", "input_facars", "input_formatats", "input_factaters", "input_formATS", "input_transformolds", "input_formsATS", "input_facats", "input_FORMarts", "input_formatars", "input_formsaps", "input_formatatives", "input_formations", "input_operats", "input_formaps", "input_commaps", "input_feats", "input_formsatives", "input_formataters", "input_transformats", "input_operATS", "input_formarts", "input_formsaters", "input_formsutters", "input_commats", "input_formatATS", "input_feutters", "input_commaters", "input_formsls", "input_formsolds", "input_formsars", "input_factaps", "input_formands", "input_formsets", "input_FORMations", "input_formls", "input_formatations", "input_formatives", "input_formatutters", "input_facets", "input_formars", "input_fears", "input_formsarts", "input_formutters", "input_formsands", "input_formatands", "input_formatls"], "err": ["orig", " Err", "num", "n", "sr", "error", "gr", " error", "count", "der", "req", "er", "ise", "ctr", "Error", "r", "g", "cache", "size", "rb", "Er", "type", "result", "attr", "dr", "br", "iter", "resp", "ner", "y", "yr", "fi", "ver", "mr", "rage", "inner", "order", "code", "arr", "fr", "rh", "ler", "init", "bug", "var", "ar", "aster", "loc", "usr", "doc", "ind", "kr", "msg", "cb", "str", "val", "rr", "min", "fe", "pr", "res", "rar", "nr", "ir", "later"], "i": ["ai", "x", "b", "index", "oi", "li", "pi", "n", "ie", "z", "id", "j", "abi", "yi", "info", "r", "iu", "ip", "ix", "type", "gi", "ri", "bi", "ti", "v", "fi", "y", "mu", "io", "uri", "xi", "ini", "inner", "multi", "p", "qi", "m", "zi", "di", "I", "t", "chi", "u", "ii", "si", "e", "c", "ind", "eni", "f", "cli", "phi", "ui", "ci", "ni", "ji", "mi"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n", "idx": 26175, "substitutes": {"errp": ["erlp", "rerpre", " errb", "errf", " erf", "err", "rrb", " errpre", "errb", "rerlp", "rypp", "errpr", " errlp", "ryp", " erp", "rarr", " errpc", "errc", "erpre", "erpr", "rrf", "erp", "erb", "rrpp", " erpp", "rrr", " errc", "errlp", "errpre", "rrp", "rerr", "erpc", " errr", "errpc", "errpp", " errpr", "errr", "ryc", " errpp", "rarp", "rerp", "rarpc", "rrpc", "rrc", " errf", "rarpr"], "win32_err": ["win32_nr", "win16_er", "win32__rr", "win16_err", "win16_nr", "win32_er", "win32_Error", "win16_error", "win32__err", "win64_err", "win32__error", "win16_rr", "win32_rr", "win32_error", "win64_rr", "win32__Error", "win64_error", "win64_Error"], "fmt": ["Filt", "Fformat", "tfformat", "Firm", "tfMT", "fformat", "fMT", "formatirm", "tfilt", "tfmt", "FMT", "firm", " fformat", "formatmt", " filt", "formatMT", "formatformat", "filt", " fMT", "Fmt", " firm"], "ap": ["aps", "ag", "snap", "cap", "array", "mp", "pac", " AP", "ac", "ape", "apt", "cp", "av", "ax", "wa", "sp", "op", "ip", "up", "ae", "as", "nav", "au", "al", "capt", "app", "pa", "p", "arr", "ab", "address", " sp", "ar", "ak", "ast", "ang", "jp", "amp", "ha", "aper", "af", "AP", "gap", "ep", "api", "rep", "rap", "pat", "tap", "tp", "a", "arp", "hap"], "msg1": ["Msgone", "err8", "cmdp", "arg1", "Msg2", "cmd1", " msg8", "arg2", "Msg7", "errone", "msg8", "doc1", "Msgp", " msgp", "msgone", " msg3", "cmdone", "Msg3", " msg7", " msgone", "msgp", "doc3", "msg3", "doc8", "doc2", "err1", "Msg1", "argp", "err2", "msg7", "err3", "argone", "cmd3", "cmd7", "cmd2"], "msg2": ["og5", "message1", "MsgTwo", "commsecond", " msg4", "Msg2", " msg0", "msg5", "message5", "doc1", "og2", " msgTwo", "Msg5", "docsecond", "og1", "comm0", " msg5", "msgTwo", "ogTwo", "doc0", " msgsecond", "comm2", "doc2", "comm1", "Msg1", "msgsecond", "Msg4", "og4", "msg0", "msg4", "message4", "message2"]}}
{"project": "FFmpeg", "commit_id": "0114c571d4c8cc1036850ced924683709390681a", "target": 1, "func": "void ff_MPV_frame_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n   } else if((s->error_count || s->encoding || !(s->avctx->codec->capabilities&CODEC_CAP_DRAW_HORIZ_BAND)) &&\n\n              !s->avctx->hwaccel &&\n\n              !(s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) &&\n\n              s->unrestricted_mv &&\n\n              s->current_picture.f.reference &&\n\n              !s->intra_only &&\n\n              !(s->flags & CODEC_FLAG_EMU_EDGE)) {\n\n        int hshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_w;\n\n        int vshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_h;\n\n        s->dsp.draw_edges(s->current_picture.f.data[0], s->current_picture.f.linesize[0],\n\n                          s->h_edge_pos, s->v_edge_pos,\n\n                          EDGE_WIDTH, EDGE_WIDTH,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[1], s->current_picture.f.linesize[1],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n        s->dsp.draw_edges(s->current_picture.f.data[2], s->current_picture.f.linesize[2],\n\n                          s->h_edge_pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n    }\n\n\n\n    emms_c();\n\n\n\n    s->last_pict_type                 = s->pict_type;\n\n    s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f.quality;\n\n    if (s->pict_type!= AV_PICTURE_TYPE_B) {\n\n        s->last_non_b_pict_type = s->pict_type;\n\n    }\n\n#if 0\n\n    /* copy back current_picture variables */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (s->picture[i].f.data[0] == s->current_picture.f.data[0]) {\n\n            s->picture[i] = s->current_picture;\n\n            break;\n\n        }\n\n    }\n\n    assert(i < MAX_PICTURE_COUNT);\n\n#endif\n\n\n\n    if (s->encoding) {\n\n        /* release non-reference frames */\n\n        for (i = 0; i < s->picture_count; i++) {\n\n            if (s->picture[i].f.data[0] && !s->picture[i].f.reference\n\n                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {\n\n                free_frame_buffer(s, &s->picture[i]);\n\n            }\n\n        }\n\n    }\n\n    // clear copies, to avoid confusion\n\n#if 0\n\n    memset(&s->last_picture,    0, sizeof(Picture));\n\n    memset(&s->next_picture,    0, sizeof(Picture));\n\n    memset(&s->current_picture, 0, sizeof(Picture));\n\n#endif\n\n    s->avctx->coded_frame = &s->current_picture_ptr->f;\n\n\n\n    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);\n\n    }\n\n}\n", "idx": 26183, "substitutes": {"s": ["js", "b", "S", "rs", "ssl", "sb", "fs", "g", "states", "sis", "p", "args", "u", "sets", "si", "sync", "xs", "sq", "en", "a", "as", "n", "qs", "set", "secondary", "conf", "gs", "aws", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "sports", "ss", "sim", "spec", "o", "site", "its", "sf", "details", "css", "self", "ops", "full", "session", "ts", "is", "y", "m", "sym", "w", "sg", "f", "ds", "ses", "sys", "http", "ions", "os", "uns", "r", "ps", "v", "ins", "ns", "settings", "d", "sec", "ls", "services", "comments", "us"], "i": ["index", "b", "li", "pi", "in", "id", "j", "r", "iu", "ip", "is", "l", "v", "io", "xi", "p", "I", "counter", "u", "it", "ii", "e", "c", "d", "f", "o", "ri", "a"]}}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191, "substitutes": {"f": ["x", "b", "fw", "fc", "sf", "n", "rf", "found", "df", "conf", "fo", "j", "z", "inf", "tf", "fd", "fs", "r", "info", "flow", "fac", "new", "v", "fp", "fi", "ref", "cf", "p", "fr", "m", "t", "F", "lf", "u", "w", "fm", "of", "flat", "feed", "this", "file", "elf", "e", "c", "d", "family", "i", "af", "fl", "bf", "uf", "fa", "fx", "fen", "fe", "o", "ff", "form", "fb", "buff"], "buf": ["orig", "b", "num", "port", "context", "pb", "box", "path", "base", "bc", "vec", "id", "cmp", "lim", "count", "cp", "ctx", "header", "len", "offset", "fd", "ptr", "rb", "cache", "wb", "result", "cv", "br", "Buffer", "mem", "fp", "v", "ref", "cf", "src", "bd", "queue", "alloc", "p", "cmd", "lf", "cur", "rc", "buffer", "head", "loc", "block", "c", "seq", "bag", "uc", "fl", "cb", "ul", "lb", "data", "uf", "ff", "Buff", "length", "fb", "buff"], "size1": ["ize0", "capacityone", " sizeone", "shapeone", " sizeOne", "sizeOne", "ize1", "Size1", "capacityOne", "Size0", "capacity1", "shape1", "shapeOne", "size0", "address1", " size0", "valueOne", "sizeone", "addressOne", "value1"], "size": ["li", "count", "cache", "url", "cel", "p", "iz", "line", "address", "u", "page", "el", "scale", "si", "sized", "sn", "name", "x", "n", "gl", "shape", "L", "large", "low", "cl", "SIZE", "speed", "ell", "capacity", "small", "e", "c", "lc", "dl", "le", "o", "last", "ize", "z", "len", "kl", "position", "hl", "no", "y", "null", "empty", "code", "m", "s", "unit", "ll", "min", "weight", "sl", "storage", "la", "v", "time", "loc", "like", "d", "i", "Size", "length", "fl"], "l": ["b", "nl", "bl", "li", "pl", "n", "sl", "dL", "z", "lr", "shell", "lv", "len", "kl", "lu", "r", "la", "v", "L", "url", "al", "il", "cel", "cl", "rl", "lf", "ell", "s", "ld", "u", "acl", "el", "ll", "ol", "loc", "e", "lo", "c", "i", "lc", "ls", "ul", "lb", "dl", "length", "jl", "le", "o", "en", "lp", "ln", "fl"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "substitutes": {"addr": ["x", "index", "dist", "ext", "port", "alias", "rx", "align", "inter", "base", "id", "ace", "len", "ptr", "r", "host", "coord", "type", "dr", "asm", "attr", "amd", "alt", " address", "url", "ref", "src", "off", "order", "code", "arr", "arm", "grad", "address", "obj", "ar", "md", "tx", "arg", "hop", "target", "rt", "node", "amp", "dd", "rm", "seq", "start", "loc", "pad", "data", "rr", "ad", "pos", "Address", "ord", "adr", "name", "nr", "pointer", "offset"], "rom": ["im", "coll", "ril", "mod", "comm", "rx", "chrome", "com", "aram", "rob", "ram", "rem", "irm", "roll", "norm", "cry", "ROM", "ctr", "RM", "cum", " chrom", "ros", "r", "roy", "dom", "Rom", "drm", "stim", "rim", "dem", "roc", "rome", "rn", "comb", "om", "rock", "cr", "chrom", "m", "arm", "sym", "cmd", "rc", "cm", "tro", "roman", "rm", "ore", "sim", "ru", "mm", "am", "ray", "co", "hom", "rod", "ro", "rum", "prom"]}}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226, "substitutes": {"opaque": ["copca", "opace", " opca", "oaque", " opaques", "paques", "oace", " opace", "opac", " opacity", "copacity", " opac", "paque", "copace", "opca", "opacity", "copac", "oaques", "copaques", "opaques", "oac", "pacity", "copaque", "pca"], "param": ["im", "index", "pb", "key", "vm", "error", "aram", "member", "conf", "project", "ram", "keep", "source", "rem", "monitor", "connection", "sem", "ctx", "prem", "info", "option", "image", "update", "model", "pm", "type", "asm", "params", "pri", "item", "resource", "advert", "ref", "sam", "part", "pool", "config", "see", "service", "p", "change", "arm", "m", "grad", "atom", "sym", "problem", "channel", " Param", "adr", "cm", "var", "comment", "arg", "iam", "amp", "meter", "Param", "block", "mark", "sync", "rm", "reason", "mm", "am", "grade", "par", "Parameter", "name", "prom", "temp"], "pagesize": ["pagesIZE", "codesz", "filesIZE", "codesiz", "codesize", "blocksization", "blocksize", "Pagesize", "Pagesz", "filessize", "blocksiz", "pagesized", "Pagesiz", "pagessize", "codessize", "Pagessize", "pagesz", "PagesIZE", "userssize", "Pagesized", " pagesiz", "usersiz", " pagesized", "pagesiz", " pagessize", "pagesization", " pagesIZE", " pagesization", "filesize", " pagesz", "usersize", "blockssize", "filesized", "usersization"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234, "substitutes": {"regs": ["rols", "Regs", "regds", " regps", "regals", "Regds", "poolals", "regfs", "REGS", "signs", "roundals", "licps", "REGs", "regps", "rolds", "signm", "rounds", "gregfs", "rolS", "gregals", "pools", "poolfs", "regS", "signps", "gregs", "regm", "REGds", "Regses", "RegS", "REGses", " regm", "rolses", "regses", "lics", "licm", "roundfs"], "frame": ["hide", "que", "cpu", "base", "zone", "message", "ace", "scene", "connection", "header", "function", "window", "host", "image", "feature", "game", "position", "fake", "update", "framework", "boot", "sequence", "fi", "slice", "cf", "iframe", "raise", "role", "config", "instance", "motion", "version", "code", "parse", "processor", "fr", "ze", "line", "channel", "profile", "buffer", "cfg", "Frame", "target", "setup", "file", "e", "node", "point", "element", "module", "f", "component", "frames", "object", "thread", "event", "fe", "tick", " Frame", "fram", "fb"], "frame_addr": [" frame_offset", "frame_address", "frame_adr", "fram_addr", " frame_address", " frame_oa", "frame_ord", "fram_ord", "fram_ptr", "frame_ptr", "fram_address", " frame_ord", " frame_adr", "frame_oa", "frame_offset"], "blocked": ["plocking", " block", "BLocked", "Blocking", "pllocked", "blocking", "BLock", "plocked", "Bllocked", "Block", "plock", "blOCK", "clocked", "clocking", "bllocked", " blocking", "BLlocked", "block", "BlOCK", "plOCK", "clock", "cllocked", " bllocked", "Blocked", "BLocking", "BLOCK"], "target_set": ["target_site", "host_setup", "message64set", "message64site", "target_setup", "component_set", "message64clear", "target64set", "target_sets", "message_set", "targetsSet", "target_sync", "target_Set", "componentssets", "componentsset", "targetsset", "component_sets", "componentsexport", " target_sc", "target_switch", "target_clear", "message_site", "component_export", "message_clear", "target_SET", "componentsrun", "target_run", "targetssc", "host_switch", "targetssets", "component_run", "targetssync", "targetsrun", "targetvalexport", "target_sc", "target64site", "host_set", " target_Set", "targetvalsets", "message64sche", "target64sche", "target_export", "host_SET", "targetvalset", "targetvalrun", " target_sync", "targetsexport", "target_sche", "message_sche", "target64clear"], "r0": [" r2", "result1", " r1", "rr0", "R2", "rloop", "rr180", "r2", "x1", "R0", "sr0", "sr1", "result0", "R1", "result180", "return2", "srloop", "return1", "Rloop", "return0", "r180", "xloop", "x0", "rr1", "r1", " r180"], "i": ["x", "ai", "b", "index", "oi", "li", "pi", "n", "in", "ie", "key", "a", "z", "err", "id", "j", "yi", "r", "iu", "ip", "hi", "gi", "bi", "l", "ti", "v", "fi", "io", "y", "mu", "uri", "xi", "ini", "part", "multi", "p", "qi", "code", "zi", "m", "di", "I", "u", "it", "ii", "page", "si", "e", "c", "d", "ind", "f", "start", "cli", "ui", "ci", "o", "ni", "ri", "length"]}}
{"project": "qemu", "commit_id": "b8eb5512fd8a115f164edbbe897cdf8884920ccb", "target": 0, "func": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n", "idx": 26242, "substitutes": {"dev": ["sd", "mod", "conf", "ve", "debug", "self", "req", "test", "hw", "rad", "g", "dom", "conn", "priv", "tr", "sk", "ver", "cam", "app", "p", "grad", "dm", "devices", "def", "des", "ev", "w", "device", "md", "Dev", "de", "pro", "di", "dd", "d", "ds", "diff", "data", "development", "dem", "prom"], "s": ["js", "b", "sd", "sf", "sl", "a", "details", "state", "S", "self", "os", "rs", "less", "rad", "ssl", "sh", "sb", "r", "fs", "g", "ps", "es", "is", "v", "service", "tests", "p", "m", "cs", "t", "sym", "south", "w", "device", "u", "su", "ns", "sg", "si", "an", "e", "sync", "c", "settings", "d", "ss", "i", "f", "spec", "ds", "data", "services", "sq", "o", "us", "ses", "sys"], "info": ["fw", "afi", "by", "error", "conf", "fo", "id", "thin", "abi", "os", "inf", "fs", "hi", "op", "iso", "Info", "type", "gi", "bi", "is", "INFO", "mis", "fi", "service", "app", "init", "ii", "link", "si", "kind", "block", "tech", "i", "f", "data", "api", "ui", "ci", "o", "name"], "bsp": ["bm", "abb", "bl", "pb", "loop", "sl", "wp", "sc", "nb", "bc", "Sp", "butt", "split", "nc", "bh", "esp", "fab", "hops", "blog", "bb", "www", "sb", " esp", "fee", "sp", "bs", "wb", "br", "bi", "bt", "isp", "fi", " fab", "ib", " disp", "bd", "frac", "blast", "sk", "skip", "p", "gb", "spl", "occ", "ab", " sp", "eb", "amp", "sync", "bp", "pc", "gap", "bf", "lb", "abl", "kb", "bg", "lp", "fb", "buff"]}}
{"project": "qemu", "commit_id": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77", "target": 0, "func": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n", "idx": 26243, "substitutes": {"base": ["index", "b", "last", "x", "site", "reset", "orig", "weight", "proxy", "home", "id", "state", "source", "count", "ace", "body", "full", "total", "prot", "build", "cache", "type", "max", "boot", "bi", "ases", "bt", "root", "work", "null", "store", "frame", "area", "p", "gb", "core", "Base", "address", "prefix", "ada", "init", "ase", "buffer", "bas", "db", "scale", "old", "support", "addr", "file", "c", "bp", "start", "f", "i", "padding", "extra", "kit", "bf", "bat", "server", "back", "bare", "bit", "kb", "name", "bg", "temp", "bin"], "s": ["js", "b", "site", "scope", "sf", "n", "sl", "a", "conf", "state", "S", "gs", "self", "os", "rs", "ssl", "sb", "fs", "g", "storage", "session", "states", "ts", "es", "is", "l", "src", "service", "p", "cs", "sym", "t", "features", "south", "w", "u", "sets", "su", "ns", "si", "settings", "e", "sync", "c", "d", "f", "i", "spec", "ls", "ds", "ss", "services", "sq", "server", "o", "us", "ses", "sys", "stats"], "clk": [" plf", "Clk", "clok", "blb", "plks", "selb", "selq", " plks", "plk", "clq", " clks", "selp", "blp", "clb", "Clp", " clf", "plb", "Clf", "blk", " clp", "Clok", "Clb", "clf", " clq", "plq", "clp", "Clks", "clks", " clok", " plk", "plp", "selk", " clb", " plok", "blks"], "iomemtype": ["iopellike", "iomagpy", "iomapertype", "iopemid", "iomelid", "iomealtype", "iopimpe", "iomemty", "iomagtype", "iotagtype", "iotemtype", "iomompy", "iomempe", "iomemlock", "iotemty", "iomagty", "iopimype", "iopemType", "iopelType", "iomeelock", "iomeeype", "iomaperlike", "iotemtag", "iopemlock", "iomellike", "iomemType", "iopemlike", "iomemlike", "iopemype", "iomealype", "iomemsid", "iomelType", "iotagpy", "iomaxtag", "iomimtype", "iomemsType", "iotempy", "iomimlock", "iomomtag", "iomimype", "iomaperType", "iomeepe", "iopempe", "iopeltype", "iomemtag", "iopimtype", "iomomty", "iomemslike", "iomaperid", "iomimpe", "iomempy", "iotagty", "iomaxpy", "iopemtype", "iomeltype", "iomemid", "iomomtype", "iomealpe", "iomaxty", "iomeetype", "iomagtag", "iotagtag", "iomemstype", "iomemype", "iopelid", "iomaxtype", "iopimlock", "iomeallock"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n", "idx": 26245, "substitutes": {"vs": ["js", "qs", "env", "vers", "sv", "gs", "flags", "rs", "os", "ops", "vp", "VS", "sb", "verts", "vt", "fs", "bs", "ov", "sts", "series", "ps", "ys", "points", "vas", "es", "ts", "v", "ks", "sk", "vals", "cs", "s", "alls", "ms", "ns", "lines", "ils", "utils", "settings", "ss", "xs", "ls", "ds", "plays", "va", "serv", "services", "Vs", "stats", "vv"], "x": ["b", "index", "n", "rx", "win", "z", "wy", "xxx", "ax", "sh", "ctx", "yi", "wa", "X", "hi", "g", "ix", "px", "l", "v", "wx", "xi", "on", "p", "xx", "m", "ic", "t", "ex", "u", "xy", "k", "e", "c", "d", "xs", "f", "ya", "q", "ci", "o", "yx", "ry"], "y": ["b", "oy", "vy", "Y", "n", "ny", "ch", "z", "ky", "cy", "dy", "yi", "ye", "g", "sy", "yo", "l", "v", "py", "p", "gy", "m", "yt", "t", "s", "u", "k", "e", "c", "ey", "d", "f", "ya", "q", "ay", "yy", "o", "ry", "a", "ty"], "w": ["b", "fw", "n", "win", "wt", "z", "ew", "hw", "sh", "W", "wa", "g", "wb", "l", "v", "wx", "wd", "p", "m", "s", "u", "we", "k", "e", "c", "d", "wh", "f", "q", "sw", "a"], "h": ["b", "n", "oh", "ch", "z", "gh", "th", "sh", "r", "hi", "g", "l", "v", "hh", "hs", "hm", "p", "m", "s", "t", "u", "k", "e", "c", "ph", "d", "f", "q", "H", "ht", "o"], "i": ["b", "ai", "index", "li", "pi", "n", "ie", "z", "id", "yi", "iu", "ip", "hi", "ix", "l", "v", "io", "ij", "xi", "ini", "p", "qi", "m", "di", "I", "u", "it", "ii", "k", "si", "e", "c", "d", "ind", "f", "ui", "ci", "vi", "o", "ni", "ji", "a", "mi"], "j": ["b", "js", "li", "n", "ja", "ie", "ch", "aj", "z", "dy", "jo", "r", "g", "l", "v", "ij", "oj", "p", "qi", "m", "t", "u", "ii", "je", "k", "jp", "jc", "si", "e", "jj", "c", "d", "f", "jl", "uj", "o", "ji", "J"], "has_fg": ["hasNfw", "has_fx", "has_fb", "hasNbg", "has_fw", "has_fig", " has_cf", "has_feat", " has_feat", " has_fig", "last_feat", " has_fx", "hasNfg", "has_cf", "last_fb", "hasNfig", " has_fw"], "has_bg": ["has_focus", "has___fg", "has___border", "has_border", "has___bg", "has___mag", "last_mag", "last_focus", "last_border", "has67focus", "has_blue", "last_background", "has_background", "has67fg", "has_mag", "has67bc", "last_bc", "has67bg", "has_bc", "last_blue"], "last_fg": ["last__fg", "last__bg", "last___auth", "last__config", "first_feat", "last_config", "last_ff", "first_tier", "last___cfg", "best_config", " last_id", "last___bg", "first_bg", "lastlybg", "best___fg", "best_auth", "last_auth", " last_pg", "last___fg", "last___config", "last_cfg", "lastlyid", "best___config", "best___auth", "lastlypg", "best_cfg", "first_ff", "best_fg", "lastlyfg", "first_config", "last___ff", "last_feat", "last_tier", "last_pg", "last_id", "first_fg", "best___cfg", "last__ff"], "last_bg": ["last67BG", "last_blue", "lastOconfig", "first_fb", "lastalblue", "lastalbg", "last67fg", "first_bin", "last_bin", "last67bg", "lastOfg", "first_config", "last67fb", "first_lb", "lastallb", "first_blue", "last_BG", "last_config", "lastObin", "last_lb", "first_fg", "last_fb", "lastObg", "first_bg", "lastalfg", "first_BG"], "vd": ["vg", "sd", "dq", "disk", "dc", "vm", "dt", "df", "sv", "od", "hd", "dh", "lv", "eddy", "hw", "VD", "fd", "vt", "nv", "vid", "ov", "ud", "dn", "gd", "v", "bd", "wd", "vc", "gb", "dm", "di", "ld", "vr", "md", "db", "rt", "dd", "d", "pd", "td", "ds", "dl", "va", "xd", "nd", "vv", "fb", "cd"]}}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 26251, "substitutes": {"bs": ["b", "banks", "pb", "bl", "base", "vs", "bc", "gs", "bh", "os", "cms", "rs", "bb", "ubs", "sb", "bid", "bos", "fs", "ba", "obs", "ps", "bi", "is", "bt", "ib", "src", "ins", "bu", "gb", "cs", "s", "lbs", "iss", "obj", "bas", "ns", "eb", "db", "bes", "BS", "ss", "lc", "ls", "bf", "ds", "lb", "cb", "bus", "us", "ses", "bis", "fb"], "sector_num": ["sectorIDnumber", " sector_number", "sector_block", " sector_name", "sectorIDname", "sector_number", " sector_set", "sectorIDset", "sectorIDnum", "sector_set", "sector_name", " sector_block"], "buf": ["b", "num", "pb", "array", "bc", "vec", "abi", "fab", "ctx", "sb", "binary", "fd", "rb", "wb", "cv", "br", "cas", "fp", "ref", "src", "pool", "batch", "queue", "alloc", "gb", "conv", "rc", "buffer", "uno", "block", "bag", "seq", "cb", "bf", "data", "uf", "Buff", "fb", "buff"], "nb_sectors": ["nb_psectors", "nbofseapters", "nb_serets", "nb_secs", "nb_sergments", "nb_SElements", "nb_sercs", "nbofsectors", "nb_verets", "nbofsections", "nbofSEctors", "nb_SEgments", "nb_secgments", "nb_Selements", "nb_pecs", "nb_vecs", "nb_seapters", "nb_SEapters", "nb_veapters", "nb_Sectors", "nb_selements", "nb_sector", "nb_serctor", "nbofSErets", "nb_pegments", "nb_vections", "nb_Serets", "nb_SErets", "nb_SEctions", "nb_pserets", "nb_Segments", "nb_SEctors", "nb_pseapters", "nb_psections", "nbofSEctions", "nb_secctors", "nb_seclements", "nb_sections", "nb_segments", "nb_serctors", "nb_vector", "nb_pectors", "nb_vectors", "nb_vegments", "nb_secrets", "nbofSEapters", "nbofserets", "nb_pector"], "async_ret": ["async2RET", "asynchronous_result", "async2def", "assync_result", "async_break", "async2Ret", "asynchronous_RET", "assync_Ret", "asynchronous_Ret", "async_back", "async_return", "asyncPret", "asynchronous_rets", "asynchronous_back", "assync_alt", "async_rets", "assync_ret", "async2rets", "async2result", "async_def", "async_Ret", "async_alt", "async2ret", "assync_return", "asynchronous_return", "async_RET", "asynchronous_break", "asyncPbreak", "assync_def", "asyncPrets", "async2return", "assync_rets", "assync_RET", "async2alt", "async_result", "asynchronous_ret", "asyncPback"], "acb": ["ecsb", "axbe", "Acbe", " acbs", "ecp", " acbe", " acsb", " acp", "Acp", "ACl", "acbs", "acf", "acp", "axbs", "axsb", "ecbs", "ecbr", "acbr", "ACb", "acl", "Acl", " acl", "ACp", "ecbe", "ACf", " acbr", "Acf", "Acb", "Acbr", "acsb", "ecb", "acbe", "axb", " acf"], "iov": ["obo", "ilib", "imi", " nem", "nih", " bio", "gio", "soc", " ensemble", "liv", "rov", "rob", "rolet", " voc", "voc", "odi", "iol", "ilo", "imedia", " guardian", " mech", "\u00ef", "ibl", "drm", "udi", "vre", "fi", "wav", "audi", "ibr", "lov", "icho", " io", "oyer", "anni", "mus", " multimedia", "nox", "uno", "iro", "ovi", "eni", "wikipedia", "iev", "iris", " virt", "oren", "iop", "voice", "gru", "veh", "iv", "club", "irin", "userc"], "qiov": ["fiop", "pilo", "qqiov", "fliv", "quiov", "quliv", "wiov", "quiop", "quiol", "qiop", "qqliv", "qliv", "quilo", "xilo", "qqilo", "xiev", "qicho", "qqiop", "qiol", "qilo", "quuno", "wilo", "qquno", " qilo", "qqiol", " quno", "wicho", "piov", "fiov", "xicho", "picho", "wiev", "qiev", "quicho", "quno", " qiol", "ficho", "qqicho", "piev", "xiov"]}}
{"project": "qemu", "commit_id": "e57ca75ce3b2bd33102573a8c0555d62e1bcfceb", "target": 0, "func": "static int kvmppc_get_books_sregs(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26257, "substitutes": {"cpu": ["platform", "fc", "gp", "que", "vm", "pu", "cmp", "eu", "nc", "net", "proc", "cp", "environment", "hw", "ctx", "prem", "cache", "ocr", "uu", "px", "pp", "pid", "conn", "gpu", "uri", "pool", "config", "computer", "p", "processor", "uci", "core", "colo", "cn", "rc", "jp", "cca", "node", "uc", "c", "linux", "hp", "CPU", "pc", "eni", "cli", "lc", "cow", "cpp", "ec", "lb", "np", "chip", "ro"], "env": ["scope", "req", "header", "ne", "cache", "ocr", "h", "oa", "fg", "core", "args", "ev", "el", "txt", "eni", "en", "her", "context", "pg", "n", "conf", "err", "state", "nc", "visor", "cp", "end", "exe", "host", "conn", "style", "enc", "exc", "e", "c", "cli", "ext", "site", "enable", "que", "vm", "vs", "net", "inet", "proc", "environment", "loader", "current", "ass", "cf", " environment", "config", "code", "stage", "cfg", "target", "export", "exec", "ea", "extra", "ec", "f", "age", "output", "np", "server", "iv", "org", "dat", "engine", "et", "eu", "energy", "hw", "ctx", "gui", "esi", "v", "dev", "equ", "init", "console", "forge", "db", "eng", "Environment", "global", "viron", "uv"], "sregs": ["servicesreqions", "ssREGi", "sriglines", "ssecns", "scondps", "srefp", "srigions", "srogs", "ssregstates", "sribs", "ssconns", "sreggs", "scountions", "slegps", "srigmaps", " sreggs", "uregions", "servicesregmaps", "sregn", "sysregs", "ssecs", "southreturnps", "srogns", "ssecses", "sregns", "sreturnd", "scountlines", "sRegstates", "sreci", " sconfigjs", "slegs", " scondf", "ssREGp", "southreturnd", "ucondions", "sstatps", "sreqions", "srels", "servicesreqmaps", "sregists", "sRegns", "sRegs", "dsregists", "dsregs", "sregjs", "sregi", " sregments", "scountns", "dsregps", "sconnns", "scondd", " sregns", " sconfigp", "slims", "sregments", "sconfign", "sreljs", "southreglines", "sgraphs", "srefjs", "sysrelings", "sregses", " sconfiggs", "uregns", "scondf", "sreturnps", "sconfigs", "sprogramf", "sregf", " sconfigs", "sstatists", " sregjs", "slimions", " ssecs", "southreturnlines", "uconds", "sconds", "scondions", "sregings", " sregf", "srefs", "sgraphments", "scompings", "slimmaps", " ssecses", "southregd", "sregions", "slegists", "sgraphses", "scondns", "scounts", "srecn", "sREGs", "srelings", "servicesregions", "southregs", "srefns", "sribments", "srogf", "sconfigjs", "ssecments", "sysrels", "scondlines", "srecgs", "southregps", "sprograms", "ssecstates", "slimlines", "slimd", "dslegists", "servicesreglines", " sconds", " sregses", "ssregns", "sregps", "sysreljs", "sreturns", "sREGn", "servicesreqlines", "srigings", "sconnstates", "srecs", "ucondns", "ureglines", "ssregi", "uregs", "sprogramns", "ssregs", " sregp", "ssREGs", "ssregn", "sfunps", "sysregjs", "sreflines", "ssregp", "scompjs", "sconns", " scondns", "sreqlines", "ssREGn", "srecjs", "sREGi", "srefgs", "srigjs", "srigs", "dslegps", "sysregings", "sREGp", "sreqs", "sstats", "sfuns", "sregd", "sregp", "sconfiggs", "servicesregs", "ssconnns", "sreqmaps", "servicesreqs", "srecp", "sfunists", "dslegs", "ssconnstates", "srefions", "sconfigi", "sregmaps", "scomps", "sreturnlines", "slimps", "sribses", "southreturns", "ucondlines", "sregstates", " ssecments", "sconfigp", "sreglines"], "ret": ["_", "last", "num", "ut", "inter", "mt", "RET", "xt", "id", "let", "len", " arg", "gt", "r", "nt", " RET", "fin", "result", "alt", "get", "det", "fi", "ref", "part", "al", "rets", "code", "t", "def", "ft", "rc", "fun", "att", "feat", "arg", "rt", " Ret", "bot", "pt", "af", "sec", "lit", "val", "cat", "out", "Ret", "reg", "res", "flag", "pat", "art", "bit", "back", "success", "re", "cur"], "i": ["b", "isin", "li", "ie", "id", "iu", "g", "result", "ti", "mu", "ini", "p", "I", "u", "si", "eni", "rep", "phi", "ci", "ni", "en", "ji", "a", "ei", "name", "mi", "x", "oi", "n", "set", "key", "err", "info", "hi", "gi", "l", "qi", "zi", "ii", "e", "c", "start", "ind", "cli", "val", "api", "ui", "o", "ri", "index", "j", "len", "isi", "ix", "is", "y", "fi", "uri", "m", "di", "s", "ski", "f", "data", "reg", "iv", "ki", "ai", "pi", "yi", "\u0438", "r", "ip", "esi", "bi", "v", "io", "xi", "multi", "chi", "it", "init", "d", "ori", "vi"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    uint32_t ram_offset;\n\n    qemu_irq *pic;\n\n    qemu_irq *cpu_pic;\n\n    int sd;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(ram_size);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);\n\n    /* And again at address 0x80000000 */\n\n    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);\n\n\n\n    integratorcm_init(ram_size >> 20);\n\n    cpu_pic = arm_pic_init_cpu(env);\n\n    pic = icp_pic_init(0x14000000, cpu_pic[ARM_PIC_CPU_IRQ],\n\n                       cpu_pic[ARM_PIC_CPU_FIQ]);\n\n    icp_pic_init(0xca000000, pic[26], NULL);\n\n    icp_pit_init(0x13000000, pic, 5);\n\n    pl031_init(0x15000000, pic[8]);\n\n    pl011_init(0x16000000, pic[1], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n", "idx": 26259, "substitutes": {"ram_size": ["mem_offset", "ramlexoffset", "mem64length", "ram64size", "ramxoffset", "ram_SIZE", "ram_scale", " ramxslice", "ram_slice", "mem64offset", "rumxoffset", "rum_offset", "rum_limit", " ramxlength", "ram64bytes", "rum_SIZE", " ram_slice", "ramlexsize", "ram_shape", "mem_size", "mem64size", "ram67shape", " ram_length", "ram67offset", "raming6", "mem_length", "ramingsize", " ramxsize", "ramlexlength", "ram_limit", "gram_size", "mem_ize", "ramxlimit", " ram_scale", "rumxlimit", "ram_length", "mem64bytes", "ramingoffset", "ram64offset", "rum_size", " ramxscale", "ram_ize", "gram_6", "ramxSIZE", "rumxSIZE", "ramxlength", "ramxsize", "ramxslice", "ramlexbytes", "ram64length", "ramxscale", "mem_shape", "ram_bytes", "gram_offset", "mem_bytes", "ram67size", "ram_6", "rumxsize", "ram67ize"], "vga_ram_size": ["vga_ram_length", "vga_ram_len", "vga_mem_length", "vga_mem_size", "vga_mem_len"], "boot_device": ["usbingobject", "bootbookchannel", "usbingchannel", "usb_object", "bootingchannel", "bootbookobject", "bootingdevice", "usbingdevice", "bootingobject", "bootbookdevice", "usb_mode", "boot_channel", "bootbookmode", "usb_device", "boot_object", "bootingmode", "boot_mode", "usbingmode", "usb_channel"], "ds": ["dt", "da", "df", "vs", "der", "rs", "dh", "nas", "fs", "bs", "ps", "ys", "dds", "ded", "ks", "DS", "cs", "des", "ld", "tx", "ns", "db", "ils", "dd", "pd", "cons", "ss", "ls", "cdn"], "kernel_filename": ["boot_file", "kernel_location", "kernel__file", "boot_files", "kernel__files", "boot_filename", "kernel_files", "kernel_file", "kernel__filename", "kernel__location", "boot_location"], "kernel_cmdline": ["kernel_hostline", "kernel_commandend", "kernel_hostend", "kernel_cmdfile", "kernel_bootend", "kernel_hostname", "kernel_bootfile", "kernel_bootline", "kernel_hostfile", "kernel_commandfile", "kernel_bootname", "kernel_cmdend", "kernel_commandname", "kernel_commandline", "kernel_cmdname"], "initrd_filename": ["initrm_filename", "initrd_directory", "initrdamesmessage", "initrm_message", "initrdamesdirectory", "initrd_file", "initrm_directory", "initrd_message", "initrdamesfile", "initrdamesfilename", "initrm_file"], "cpu_model": ["cpuermodel", "gpu_control", "cpu_models", "kernel_device", "cpu__channel", "core_mode", "cpuermode", "cpu_system", "gpu_model", "gpu_mode", "cpu_channel", " cpu_system", "cpujsystem", "kernel_image", "cpu_Model", "cpujmodel", "cpu__model", "gpu_models", "cpu_control", "core_device", "cpujsource", "core_Model", "kernel_model", "kernel_channel", "cpuerModel", "cpu__device", "cpu_mode", "cpu_image", " cpu_models", "cpujmodels", "cpuerdevice", "cpu_device", "cpu_source", "cpu__image", " cpu_source", "core_model"], "env": ["enable", "context", "scope", "et", "dict", "vs", "eu", "bc", "conf", "nc", "net", "inet", "proc", "me", "environment", "loader", "hw", "ctx", "vt", "ne", "ov", "cache", "qt", "session", "v", "conn", "priv", "cf", " environment", "oa", "enc", "style", "config", "ras", "empty", "lock", "exc", "equ", "iss", "obj", "ev", "virt", "args", "console", "el", "db", "e", "exec", "ea", "export", "Environment", "eni", "ec", "img", "spec", "global", "iv", "viron", "en", "her", "sys", "ext"], "ram_offset": ["gram_limit", "ream_addr", "mem_offset", "ram67length", "ramfsize", "ream_size", "ramloffset", "mem_loc", "ram___addr", "ram67offset", "ramsoffset", "mem_location", "ramssize", "ramslocation", "ram___size", "mem_length", "ram___offset", "mem_size", "ramlsize", "ramfaddress", "ramfaddr", "ram_limit", "ram_location", "ream_offset", "ramfoffset", "gram_size", "ramslength", "ram_addr", "ram_index", "ram67location", "gram_index", "ram_address", "ramllocation", "ram_loc", "ram___address", "ram_length", "ream_address", "ramlloc", "gram_offset", "ram67size"], "pic": ["mini", "disk", "fc", "mic", "quad", "cpu", "sci", "nat", "kin", "bc", "proc", "fat", "piece", "pin", "picture", "pot", "lic", "lib", "train", "pen", "pull", "pres", "gui", "cus", "image", "mc", "cache", "dim", "feature", "quin", "cycle", "nic", "pict", "mot", "fi", "style", "xi", "enc", "Pic", "config", "capt", "parse", "pass", "script", "ic", "mac", "study", "feat", "jp", "jc", "pse", "txt", "doc", "sync", "vir", "ig", "drive", "seq", "pc", "pick", "lc", "cli", "spec", "typ", "pins", "tick", "loc", "circ", "bin", "sys", "fig"], "cpu_pic": ["cpu_config", "cpu_pid", "processor_pin", "core_nic", "core_config", "processor_pic", "gpu_pic", "cpu_pc", "cpu_pins", "core_cycle", "cpuxpin", "cpu__pins", "core_pc", "gpu_pin", "processor_model", "cpuxpid", "cpu__pid", "cpu_pin", "cpu_cycle", "cpu__gui", "cpu_gui", "core_pic", "gpu_gui", "cpu__pin", "processor_pid", "core_pin", "cpu__model", "gpu_pins", "cpu__pic", "cpuxmodel", "cpuxpic", "cpu_nic"], "sd": ["dist", " dd", " SD", "sf", "sl", "ed", "std", "ism", "od", "hd", "sb", "fd", "sp", "dim", "dk", "ud", "gd", "ded", "SD", "bd", "gb", "dis", "di", " sp", "ld", " td", "ada", "md", "vd", "db", "su", "ity", "si", "dd", "pd", "ind", "d", "ss", "td", "dl", "ay", "sn", "ad", "xd", "sil", "nd", "cd"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n", "idx": 26291, "substitutes": {"mon": ["mini", "mun", "mod", "mid", "un", "com", "mt", "mn", "MON", "mut", "monitor", "pin", "Monitor", "prem", "bo", "mat", "mc", "mons", "dom", "master", "mem", "mu", "con", "mo", "mos", "met", "man", "m", "dm", "Mon", "mand", "meter", "flo", "module", "mor", "mm", "ann", "min", "pm", "mag", "bin", "mi"], "qdict": ["qqdata", "Qict", "Qdata", "Qdat", " qict", " qdat", "Qdict", "qict", "qdata", "qqdat", "qdat", "qqict", "qqdict", " qdata"], "bdev_list": ["bdevice_List", "bblock_default", "bdevsList", "bblock_list", "bdev_l", "bdev_cl", "bdevice_l", "bdev_last", "bdevice_list", "bdev_parent", "bdevsset", "bdevstype", "bdevice_type", "bblock_last", "bdevicestype", "bdevicesset", "bdev_block", "bdevscl", "bdevice_block", "bdevicesblock", "bdevslist", "bdev_type", "bdev_List", "bdevsblock", "bdev_default", "bdevice_set", "bdev_set", "bblock_parent", "bdeviceslist"], "bdev": ["lbdiff", "bbev", "lbdev", "Bdevice", "lbDev", "lbdevice", "rbdef", "ambdevice", "fdev", "ambev", "sbev", "sbdevice", "vdef", "bbdev", "bbdevice", "ambdev", " bev", " bver", "Bcase", "bbcase", "vDev", "bdiv", "fdiff", "Bev", " bde", "rbdev", "lbev", "sbcase", "rbdiff", "fdem", "bbdem", "sbdev", "ambdem", " bdiv", "bver", "vver", " bDev", " bdiff", "bdiff", "vdev", "fdiv", "bcase", "rbdevice", "fdevice", "Bdev", "fev", "bdevice", "bdem", "lbde", " bdevice", "fde", "bde", "bbdiff", "Bdiv", "bev", " bdef", "lbdef", "bbdef", "lbver", "bDev", "bdef"], "err": ["orig", "ra", "rx", "error", "gr", "erg", "acer", "proc", "der", "lr", "er", " er", "Error", "r", "Er", "result", "dr", "resp", "oller", "ner", "cor", "mr", "rage", "inner", "arr", "fg", "fr", "runner", "cr", "rh", "eor", "ler", "ev", "ar", "cfg", "tx", "bug", "rc", "e", "ind", "f", "erer", "rr", "her", "pr", "org", "order", "ir", "sys"]}}
{"project": "FFmpeg", "commit_id": "49cf36f4e3e9183611859af1a07dc6a82ab47288", "target": 1, "func": "static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 26294, "substitutes": {"ctx": ["fw", "context", "fc", "css", "xc", "sci", "sc", "bc", "cmp", "anc", "nc", "ca", "cc", "cp", "cms", "hw", "ctr", "nt", "pkg", "cv", "cas", "cal", "fp", "conn", "cf", "Context", "src", "config", "cam", "vc", "kt", "grad", "cs", "tc", "conv", "cn", "obj", "rc", "cm", "tx", "ct", "acl", "ctrl", "cca", "utils", "txt", "loc", "c", "pc", "lc", "cli", "component", "cpp", "cu", "ci", "qa", "client", "concept"], "frm": ["prms", " frp", "frM", "frmc", "brf", "brm", "brmc", "ferp", "frcm", "frd", "brmi", "fd", "brp", "frmi", " frmc", "trms", " frf", "drms", "ferm", " frd", "drd", "drm", "ferf", " frcm", "prmi", " frM", "fms", "frp", "trmi", "trm", "frf", "fm", "trM", "brM", "prmc", "brms", "drcm", "fcm", " frmi", " frms", "prm", "frms", "ferms"], "npixels": ["NPorts", "fpips", " npamples", "NPamples", "ispips", "bpixel", " npixel", "NPips", " nports", "NPowers", "spixels", "bpips", "upixel", "npowers", "pips", "pixels", "spamples", "nports", "npips", "spowers", " npowers", "upixels", "spips", "picks", "npels", "uports", "apixels", "npixel", "upips", "apixel", "NPixels", "bpixels", "apels", "ispixel", "pixel", "fpicks", "fpixels", "bpicks", "ispixels", " npips", "ispels", "npamples", "fpixel", "pels", "npicks", "apips", "NPixel"], "dst": [" ddr", "sddr", "dbl", "sdst", "bST", " dST", "ddr", "bst", "dsts", "dfe", "Dfe", "sdsts", " dbl", "Dst", "rdst", " dfe", "bsts", "dST", "DST", " dsts", "Dsts", "rdsts", "sdbl", "rddr", "bfe", "rdbl"]}}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306, "substitutes": {"obj": ["js", "x", "b", "n", "Obj", "z", "j", "self", "os", "office", "orb", "ops", "objects", "ctx", "sb", "bo", "ass", "rb", "boot", "v", "src", "oa", "obb", "instance", "p", "m", "act", "t", "args", "inst", "init", "Object", "po", "ns", "active", "jp", "node", "e", "c", "module", "f", "i", "object", "data", "bus", "iv", "o", "so"], "s": ["js", "b", "scope", "sf", "n", "sl", "secondary", "S", "rs", "os", "ops", "sb", "ssl", "fs", "g", "session", "states", "ts", "l", "service", "p", "m", "sym", "south", "ns", "settings", "e", "sync", "c", "an", "ss", "f", "ds", "services", "sq", "o", "so", "sys"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315, "substitutes": {"opaque": ["copque", "oplacity", "openaques", "oplaques", "opaya", "oaque", "oacity", " opque", "oplaya", " opaques", "oplaque", "paques", "openaque", " opacity", "pque", "openaya", "oaya", "copacity", "paque", "opque", "opacity", "oaques", "copaques", "opaques", "pacity", "copaque", "openacity"], "data": ["coll", "li", "rec", "results", "aa", "alpha", "da", "entry", "child", "error", "state", "writer", "DATA", "info", "op", "cache", "type", "result", "ae", "ready", "reader", "la", "ata", "no", "style", "config", "batch", "code", "change", "ee", "di", "one", "ada", "Data", "init", "input", "po", "comment", "missing", "sync", "dd", "d", "module", "object", "call", "load", "ad", "meta", "cookie", "o", "client", "dat", "a", "as"], "co": ["coll", "ra", "soc", "bc", "ca", "ko", "self", "cc", "ac", "col", "bb", "bo", "mc", "oo", "ck", "coe", "coord", "cycle", "aco", "cf", "cost", "con", "mo", "cl", "company", "rc", "cm", "Co", "po", "cca", "loc", "c", "flo", "pc", "can", "cb", "call", "ci", "cro", "o", "CO", "so", "ob", "oe"]}}
{"project": "qemu", "commit_id": "b224e5e2162a767dd56dbc366f796fbe45ca5baa", "target": 1, "func": "static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n", "idx": 26320, "substitutes": {"mon": ["mini", "plugin", "mun", "un", "mn", "MON", "mut", "monitor", "connection", "tun", "col", "Monitor", "bo", "mat", "mc", "dom", "mons", "type", "master", "boot", "mot", "mu", "pid", "conn", " monitor", "config", "mo", "manager", "lock", "mos", "met", "m", "man", "dm", "amon", "mail", "wan", "mand", "Mon", "an", "meter", "flo", "param", "module", "mor", "mm", "ann", "wat", "mount", "min", "phys", "pm", "mag", "bin", "mi"], "qdict": ["kobj", " qict", " qdetails", "Qdict", "workobj", "querydd", "wict", "qdom", "wictionary", "Qdom", "quict", "workictionary", "qdb", "rydict", "dqict", " qcoll", "bugdd", "qtdetails", "qict", " qdb", "qtcoll", " qdf", "qcoll", "kictionary", "bugictionary", "qudd", "querydict", "rydf", "rydom", "qudict", "Qict", "qucoll", "workdict", "quictionary", "wdd", "qulist", " qlist", " qdom", "qobj", "dqdf", "ryict", "quobj", "workdb", "qudb", "bugdict", "qdetails", "qudetails", "Qdf", "bugict", "querydf", "dqdb", "wdict", "querycoll", "kdb", "kdict", "qdf", "qudf", " qdd", "qictionary", "qlist", "qtlist", "qtdict", "Qdb", "dqdict", "qdd"], "ret_data": ["ret_obj", "ret0class", "reply_class", "reply_data", "ret0map", "ret0data", "ret_class", "retblockobj", "retblockclass", "reply_map", "retblockmap", "retblockdata", "reply_obj", "ret0obj", "ret_map"], "protocol": ["promendor", "proturation", "propotype", "refendor", "prompoint", "cryptotype", "cryptocol", "prot00", "protpoint", "formatocol", "promocol", "Protology", "propocol", "propuration", "prootype", "gold00", "protendor", "proocol", "Protocol", "Prot00", "formatotype", "propology", "refpoint", "refocol", "format00", "goldotype", "cryptology", "proendor", "prototype", "Proturation", "protology", "promotype", "propoint", "crypturation", "Prototype", "goldocol", "refotype"], "fdname": ["fnnam", "fdstr", "ndNAME", "bandname", "fdNAME", "FDname", "fdnam", "bandnames", "fcfor", "fxkey", "handlerkey", "fnnames", "dfsize", "dfkey", "dfname", "cdnfor", "handlerstr", "deckdata", "fdfor", "bandkey", "sdNAME", "sdname", "ndno", "fdame", "dfdata", "cdnname", "handlername", "fddata", "deckname", "deckkey", "bandstr", "fxsize", "fnstr", "fdkey", "fdsize", "sdno", "decksize", "cdnnam", "fxname", "fnname", "cdnnames", "fcnames", "fxdata", "sdame", "ndname", "fdno", "fnfor", "ndame", "fdnames", "FDNAME", "fcname", "fcnam", "handlernames", "fnkey", "FDame", "FDno"], "s": ["js", "b", "sd", "sf", "n", "sl", "status", "state", "S", "j", "sv", "sb", "ssl", "r", "g", "session", "states", "v", "p", "m", "t", "u", "ns", "sg", "si", "settings", "e", "an", "c", "ses", "d", "f", "i", "ind", "ds", "server", "o", "stats", "bis"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "substitutes": {"ioc": ["ioco", "iucc", "tiroc", "tiucc", "atioc", "iroc", " iroc", "tioco", "atioco", "atiucc", " ioco", " iucc", "atiroc"], "condition": [" proc", " block", " interrupt", "parent", "bc", " error", "proc", "func", "self", " exc", "chain", " event", "ruction", " cond", " exception", "null", "container", " thread", "processor", " prec", "tc", "tx", "comp", "block", "ec", "reason", "cond"], "user_data": ["userpooldone", "userpoolclass", "userpooldata", " user_done", "useringdata", "user_class", "custom_device", "user_package", "custom_reader", "useruserdata", "useruserreader", "useringpackage", "user_reader", "userfulldata", "custom_data", "custom_info", "userfulldevice", "useringclass", "userfullreader", "userfullinfo", "user_info", " user_package", "userpoolpackage", "useruserinfo", "useruserdevice", "useringdone", "user_done", "user_device", " user_class"], "task": ["contract", "worker", "key", "child", "course", "source", "message", "piece", "connection", "test", "tag", "image", "slave", "session", "result", "type", "master", "job", "ask", "work", "resource", "conn", "role", "trip", "config", "instance", "app", "route", "t", "channel", "address", "socket", "table", "device", "tx", "target", "process", "Task", "sync", "exec", "transfer", "object", "data", "thread", "event", "content", "server", "client", "tty"], "tioc": [" tiec", "idioci", "siuc", "sioc", "TIoc", " tiuc", "shiroc", "tiocon", "siec", "nioc", "kioc", "kioci", "tiocation", "TIuc", "siroc", "tiec", "TIOC", "niuc", "tioci", "TIec", "idioc", "kiocation", "niocon", "sioci", "siocon", " tiOC", "shiocon", "shioc", "kiocl", "siocation", "niroc", "shiuc", "tiroc", "siocl", "idiocation", "siOC", "tiuc", "tiOC", "tiocl", "idiocl"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26333, "substitutes": {"s": ["js", "site", "qs", "a", "conf", "sv", "S", "gs", "self", "os", "rs", "uns", "sb", "ssl", "fs", "r", "g", "session", "states", "ps", "ts", "es", "is", "sa", "params", "service", "p", "cs", "sym", "m", "t", "args", "u", "ar", "sets", "su", "ns", "sg", "si", "settings", "e", "sync", "c", "ss", "i", "spec", "f", "ds", "ls", "services", "o", "ses", "sys"], "sci_level": ["ci_index", "sci__loc", " sci_line", "sci_layer", "sci__level", "sci__lvl", "sci__layer", "sciworklevel", " sci_vel", "ci_level", " sci_lvl", "ci_lock", " sci_log", "sci_loc", "sci_lvl", " sci_loc", "sci_index", "sci_log", "sciworklog", "sci_vel", "sci_lock", "ci_log", "sciworkline", "sciworkvel", "sci_line", " sci_layer"], "pmsts": ["bmst", "pmares", "premrs", "PMts", "hmsts", "pxares", "wmares", "PMsta", " pmns", "hmns", "PMsts", "pxsts", "PMns", " pmists", "PMds", "pmns", "premsts", "PMstores", "bmds", " pmstores", "pmsta", "PMst", "pxists", "bmsts", "wmists", " pmst", "pmstores", "hmds", "pmts", "pmst", " pmsta", "gmstores", "wmsts", "hmst", "premns", "premts", "pmists", "gmst", " pmares", "pmds", "gmsta", "gmsts", " pmts", "pmrs", "bmns", "PMrs", " pmrs", "wmst", "pxst"]}}
{"project": "FFmpeg", "commit_id": "01e4537f66c6d054f8c7bdbdd5b3cfb4220d12fe", "target": 0, "func": "static void flat_print_key_prefix(WriterContext *wctx)\n\n{\n\n    FlatContext *flat = wctx->priv;\n\n    const struct section *parent_section = wctx->section[wctx->level-1];\n\n\n\n    printf(\"%s\", flat->section_header[wctx->level].str);\n\n\n\n    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n\n        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n\n            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n\n        printf(\"%d%s\", n, flat->sep_str);\n\n    }\n\n}\n", "idx": 26360, "substitutes": {"wctx": ["Wjc", "wca", " wcf", "Wca", "wcv", "wwcmp", "Wcf", "ewcp", "wakb", " wcmp", "ewcf", "wtcontext", " wca", "webcp", "wscv", "wcss", "wwcontext", "Wcss", "ewctx", "wecp", "Wcontext", "rwcm", "rwcmp", "wsctx", "wacontext", "wactx", "wcontext", "Wctx", "kwctx", "Wcmp", "owcmp", "wenctx", "wcp", " wcontext", "wtcmp", "ewcu", "wectx", "wscf", "wscss", "rwcss", "wscu", "wacss", "websci", " wjc", "webcontext", "owcss", "wtctx", "wscmp", "wwctx", "rwctx", "wcmp", "ewcontext", "wacmp", "wsci", "wwkb", "kwcu", "wcu", "wtjc", "wacv", "owctx", "wesci", "wencss", "wkb", "kwcf", "Wcm", "wscontext", "owcm", "ewcmp", "wecontext", "kwcmp", "wcf", "ewca", "ewsci", "wencv", "wencmp", "wjc", "webctx", "wcm", "wskb"], "flat": ["plugin", "fc", "atten", "front", "live", "parent", "base", "normal", "fat", "format", "full", "python", "final", "zip", "layout", "utf", "qt", "template", "single", "dot", "py", "empty", "parse", "multi", "complete", "force", "table", "clean", "folder", "feed", "public", "txt", "small", "fold", "plain", "lat", "module", "f", "standard", "layer", "cat", "global", "future", "form", "fast", "pure", "fl"], "parent_section": ["Parent_data", "Parent_sect", " parent_sector", "parent_table", " parent_group", "Parent_sector", "parent_data", "parent_sect", "parentingsector", "parentingsect", "parentingsection", "Parent_section", "parent_sector", "parentinggroup", "Parent_sections", " parent_sect", "parent_sections", "Parent_table", "parent_group"]}}
{"project": "FFmpeg", "commit_id": "b97d21e4d6813498f458777ff42c7eab1eed3adf", "target": 1, "func": "static int sdp_parse_fmtp_config_h264(AVStream *stream,\n\n                                      PayloadContext *h264_data,\n\n                                      char *attr, char *value)\n\n{\n\n    AVCodecContext *codec = stream->codec;\n\n    assert(codec->codec_id == CODEC_ID_H264);\n\n    assert(h264_data != NULL);\n\n\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n\n        h264_data->packetization_mode = atoi(value);\n\n        /*\n\n         * Packetization Mode:\n\n         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n\n         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n\n         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),\n\n         *                      and 29 (FU-B) are allowed.\n\n         */\n\n        if (h264_data->packetization_mode > 1)\n\n            av_log(codec, AV_LOG_ERROR,\n\n                   \"Interleaved RTP mode is not supported yet.\");\n\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n\n        if (strlen(value) == 6) {\n\n            char buffer[3];\n\n            // 6 characters=3 bytes, in hex.\n\n            uint8_t profile_idc;\n\n            uint8_t profile_iop;\n\n            uint8_t level_idc;\n\n\n\n            buffer[0]   = value[0];\n\n            buffer[1]   = value[1];\n\n            buffer[2]   = '\\0';\n\n            profile_idc = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[2];\n\n            buffer[1]   = value[3];\n\n            profile_iop = strtol(buffer, NULL, 16);\n\n            buffer[0]   = value[4];\n\n            buffer[1]   = value[5];\n\n            level_idc   = strtol(buffer, NULL, 16);\n\n\n\n            av_log(codec, AV_LOG_DEBUG,\n\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n\n                   profile_idc, profile_iop, level_idc);\n\n            h264_data->profile_idc = profile_idc;\n\n            h264_data->profile_iop = profile_iop;\n\n            h264_data->level_idc   = level_idc;\n\n        }\n\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n\n        codec->extradata_size = 0;\n\n        codec->extradata      = NULL;\n\n\n\n        while (*value) {\n\n            char base64packet[1024];\n\n            uint8_t decoded_packet[1024];\n\n            int packet_size;\n\n            char *dst = base64packet;\n\n\n\n            while (*value && *value != ','\n\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n\n                *dst++ = *value++;\n\n            }\n\n            *dst++ = '\\0';\n\n\n\n            if (*value == ',')\n\n                value++;\n\n\n\n            packet_size = av_base64_decode(decoded_packet, base64packet,\n\n                                           sizeof(decoded_packet));\n\n            if (packet_size > 0) {\n\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n\n                                          codec->extradata_size +\n\n                                          FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!dest) {\n\n                    av_log(codec, AV_LOG_ERROR,\n\n                           \"Unable to allocate memory for extradata!\");\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                if (codec->extradata_size) {\n\n                    memcpy(dest, codec->extradata, codec->extradata_size);\n\n                    av_free(codec->extradata);\n\n                }\n\n\n\n                memcpy(dest + codec->extradata_size, start_sequence,\n\n                       sizeof(start_sequence));\n\n                memcpy(dest + codec->extradata_size + sizeof(start_sequence),\n\n                       decoded_packet, packet_size);\n\n                memset(dest + codec->extradata_size + sizeof(start_sequence) +\n\n                       packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n                codec->extradata       = dest;\n\n                codec->extradata_size += sizeof(start_sequence) + packet_size;\n\n            }\n\n        }\n\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\",\n\n               codec->extradata, codec->extradata_size);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26367, "substitutes": {"stream": ["engine", "coll", "context", "loop", "port", "video", "path", "stack", "writer", "valid", "ssl", "ream", "row", "host", "model", "reader", "transform", "raw", "src", "acc", "con", "cl", "stage", "channel", "input", "public", "feed", "view", "uc", "object", "document", "server", "Stream", "client", "form", "length"], "h264_data": ["hcv_di", "h164_config", "hfp_ui", "h264Jclass", "h264_info", "h264Odata", "hmpeg_definition", "h264Oid", "h26400dat", "hfp_info", "h264_DATA", "hwm_data", "h164_data", "h264_definition", "h264_dat", "hwm_body", "hfp_default", "h264Jdi", "h264JDATA", "h164_dat", "h264_class", "hfp_config", "h264_id", "h264_body", "habl_class", "hcv_data", "h26400rec", "h26400body", "hfp_data", "hmpeg_id", "habl_DATA", "hmpeg_message", "h264_config", "hfp_reader", "hcv_rec", "h264_default", "h264_rec", "h264Omessage", "hwm_rec", "h264Odefinition", "h264_ui", "habl_data", "hcv_div", "h264Jdata", "hmpeg_data", "hwm_dat", "h264_reader", "h264_div", "h264_message", "h264_di", "habl_di", "h26400data"], "attr": ["prop", "array", "key", "rel", "expr", "pair", "spr", "format", "property", "writer", "apt", "timeout", "ack", "tag", "header", "option", "r", "feature", "type", "params", "resource", "url", " attribute", "atts", "config", "range", "arr", "atom", "channel", "address", "args", "vr", "attribute", "device", "att", "feat", "rt", "addr", "append", "element", "kr", "layer", "data", "typ", "ann", "rr", "term", "api", "pr", "iv", "opt", "adr", "name"], "value": ["port", "entry", "child", "rule", "description", "function", "type", "result", "request", "complete", "json", "address", "match", "comment", "view", "media", "Value", "xml", "name", "key", "set", "parent", "format", "text", "valid", "end", "python", "info", "feature", "flow", "style", "service", "feed", "val", "index", "pair", "message", "wave", "anything", "test", "response", "current", "selected", "option", "update", "model", "resource", "null", "config", "password", "unit", "w", "attribute", "input", "now", "language", "output", "layer", "data", "values", "server", "video", "member", "source", "property", "reference", "VALUE", "row", "image", "size", "number", "expression", "vector", "v", "command", "go", "version", "variable", "change", "initial", "package", "sample", "element", "padding", "component", "object", "phrase", "content", "memory", "length"], "codec": ["copc", "cdec", "odEC", "Codoc", "pedc", "Coduc", "coduc", "labeca", "codeEC", "callesc", "copuc", "codenc", "Codroc", "labcript", "codesc", "pedEC", "codoc", "odesc", " codrec", "codeesc", "copenc", "labenc", "codrec", "cheect", "pedec", "Codesc", "pedenc", " codpc", " codc", "podenc", "cheec", "podcript", "CodEC", "callc", "Codef", "Codenc", "predesc", "Codect", "odenc", "cdpc", "codroc", "codeec", "peduc", "predec", " codoc", " codenc", "predrec", "Codec", "odect", "callec", "odec", "codpc", "labec", " codcript", "Codrec", "codEC", "codeca", "cheEC", " codesc", " codep", " codEC", "Codc", "codc", "codeuc", " codroc", "copec", "odef", "codef", "predoc", "codcript", "cdep", "codect", "cdesc", " codef", "codep", "predep", "predenc", "cheesc", "callroc", "predpc", "podeca", " codeca", "podec", "pedesc"], "buffer": ["buf", "port", "array", "base", "byte", "shape", "message", "source", "stack", "texture", "wave", "text", "shell", "writer", "loader", "bytes", "timeout", "uffer", "header", "binary", "surface", "program", "row", "window", "info", "board", "image", "cache", "bar", "position", "result", "Buffer", "iter", "reader", "vector", "raw", "resource", "url", "null", "batch", "variable", "queue", "cube", "channel", "read", "profile", "table", "address", "input", "feed", "view", "file", "block", "flash", "transfer", "output", "object", "layer", "data", "document", "phrase", "map", "server", "list", "memory", "length", "bin", "buff"], "profile_idc": ["profile_idi", "profile_idsn", "profile_idec", "profile_Idm", "profile_idecd", "profile_bidc", "profile_Idlc", "profile_inn", "profile_bidx", "profile_iden", "profile_aidci", "profile_ipn", "profile_partlc", "profile_bidlc", "profile_ind", "profile_Idci", "profile_incd", "profile_ided", "profile_Idx", "profile_Idc", "profile_adc", "profile_add", "profile_idlc", "profile_inlc", "profile_idsci", "profile_Idl", "profile_inc", "profile_inm", "profile_Idn", "profile_iplc", "profile_ipx", "profile_inx", "profile_bidi", "profile_idci", "profile_idd", "profile_aidc", "profile_parti", "profile_idl", "profile_aidl", "profile_idsc", "profile_partx", "profile_inl", "profile_adcd", "profile_adn", "profile_idcd", "profile_partc", "profile_idm", "profile_idx", "profile_idn", "profile_idsl", "profile_ipc", "profile_aidn"], "profile_iop": ["mobile_loop", "prof_io", "profile_ori", "profilePiterator", " profile_op", "profile_loop", "profile_ionic", " profile_summary", " profile_io", "profile67op", "profile_iterator", "profile67io", "profile___iop", "profileMiop", "profileMloop", "profilePloop", "profileMori", "profile67summary", "mobile_iterator", " profile_ionic", "profile_iot", "prof_orp", "profile_ip", "profilePiop", "prof_ip", "profile___exp", "profileMiterator", "profile___io", "profile67iop", "mobilePiterator", " profile_ori", "mobilePloop", "mobilePori", "profile_op", "mobilePiop", " profile_exp", "profile_summary", "profile___ori", "profilePori", "profile_io", "profile_exp", "mobile_ori", "prof_iop", "mobile_iop", "profile_orp", " profile_iot"], "level_idc": ["level_dg", "level_aidn", "level_bidc", "level_basec", "level_Idc", "level_Idx", "level_idsce", "level_idx", "level_incode", "level_dl", "level_ipf", "level_ipl", "level_indexce", "level_idscode", "level_idn", "level_idsp", "level_ipc", "level_dx", "level_inc", "level_dc", "level_idg", "level_ipg", "level_ince", "level_bidlc", "level_idi", "level_Idlc", "level_bidl", "level_ipx", "level_indexcode", "level_idslc", "level_idp", "level_Idn", "level_idsn", "level_idsx", "level_indexc", "level_basex", "level_aidx", "level_idf", "level_idl", "level_indexp", "level_ipi", "level_Idl", "level_basei", "level_idcode", "level_aidc", "level_inp", "level_bidx", "level_basef", "level_idlc", "level_aidlc", "level_idce", "level_idsc"], "base64packet": ["base64packacket", "base256packeting", "base8packant", "base8packET", "base256Packacket", "base8compacket", "base64compET", "base256packant", "base64Packant", "base64encet", "base256packet", "base8compet", "base8packet", "base256Packant", "base64decET", "base64compacket", "base64peant", "base64compant", "base64peet", "base8packacket", "base64decet", "base256Packet", "base64peacket", "base64packET", "base64enceting", "base256Packeting", "base64encacket", "base64Packet", "base64peeting", "base64packeting", "base8compET", "base64compet", "base64encant", "base64decacket", "base64Packeting", "base64decant", "base256packacket", "base64Packacket", "base64encET", "base8compant", "base64packant"], "decoded_packet": ["decoded_compet", "decoded_compec", "decoded_packets", "decoded_octets", "decoded_encets", "decoded_packacket", "decoded_encet", "decoded_compacket", "decoded_octec", "decoded_encacket", "decoded_octet", "decoded_encec", "decoded_packec", "decoded_octacket", "decoded_compets"], "packet_size": ["packets_len", "packet_count", "packet_len", "packets_size", "packets_count"], "dst": ["_", "dbl", "instr", "format", "bst", "dsts", "bstr", " dbl", "r", "bsts", "insts", " dstr", "s", " dsts", "channel", "inst", "bbl", "inbl", "length", "dstr"]}}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388, "substitutes": {"filename": ["database", "path", "journal", "dll", "source", "fits", "summary", "metadata", "fil", "fd", "title", "kl", "jpg", "wb", "which", "sequence", "location", "fp", "url", "files", "il", "config", "queue", "processor", "nil", "rl", "username", "prefix", "txt", "file", "directory", "fn", "f", "download", "jl", "phrase", "content", "Filename", "kn", "memory", "selection", "name"], "total_size": ["total_content", "total67scale", "total_scale", " total_content", "total67capacity", " total_scale", " total_capacity", "total67content", "total_capacity", "total67size"], "backing_file": ["backing2table", "backing64table", "backing_image", "backing2file", "backing_table", "backping_files", "backing64image", "backping_table", "backing64file", "backping_image", "backping2table", "backing2files", "backping2files", "backping2file", "backping_file", "backing_files", "backping2image", "backing2image", "backing64files"], "backing_format": ["backing_writer", "backiving_format", "backing_unit", "backiving_writer", "backiving_unit", "backiving_file"], "flags": ["depth", "ips", "lag", "errors", "status", "tops", "bits", "format", "missions", "ops", "Flags", "len", "heads", "fs", "fps", "mods", "fields", "files", "vals", "ints", "features", "args", "alls", "utils", "settings", "links", "types", "versions", "parts", "mask", "plugins", "flag", "groups", "locks", "FLAG", "stats", "ants", "fl"], "cluster_size": ["clusteraltable", "cluster64size", "cluster6number", "cluster6width", "clusters_size", "clusters_count", "clust_count", "clusteraltime", "clinal_time", "cluster64capacity", "cluster2bits", "cluster_table", "clinalalsize", "clinal_count", "clusters_mode", "clust_size", "clinalalcount", "clusteralsize", "cluster_capacity", "cluster_time", "cluster2size", "cluster2count", "cluster_number", "clinal_table", "clust_width", "cluster_mode", "cluster2capacity", "cluster_count", "cluster2mode", "clinalaltime", "cluster6size", "cluster64mode", "cluster64count", "cluster6count", "cluster_width", "clusters_capacity", "clinal_size", "clinalaltable", "cluster2number", "clust_number", "clusteralcount"], "prealloc": ["postxp", " regr", " prexp", " rexp", "pregr", "postgr", " pregr", "prexp", "postalloc"], "options": ["details", "results", "errors", "members", "outs", "ions", "ops", "opens", "ssl", "none", "info", "option", "resources", "caps", "rates", "cache", "session", "params", "ts", "io", "config", "files", "vals", "other", "args", "obj", "properties", "Options", "utils", "settings", "limits", "linux", "types", "object", "values", "global", "als", "opt"], "version": ["depth", "index", "platform", "seed", "product", "plugin", "arch", "ception", "release", "value", "driver", " versions", "mode", "format", "Version", "brand", "tag", "current", "option", "feature", "ip", "size", "position", "image", "type", "build", "update", "number", "serial", "v", "style", "ver", "config", "vision", "level", "stage", "features", "package", "prefix", "currency", "fun", "scale", "target", "support", " ver", "gen", "versions", "server", "section", "generation", "name", "class", "length", "VERSION"], "errp": ["irpre", " errpre", " errfp", " errpc", "erpre", "errorfp", "errorpre", "errfp", "erp", "errorp", "errorpc", "irpc", "errpre", "erfp", "erpc", "errP", "errorP", "errpc", "irp", "erP", "irP"], "cluster_bits": ["cluster_cycles", "cluster6bytes", "cluster32bytes", "cluster__bits", "cluster32pieces", "clancer_bits", "cluster__bytes", "cluster6flags", "cluster_features", "clust_bit", "cluster2bits", "clust_bytes", "closer6cycles", "closer_flags", "cluster2bit", "cluster8bits", "closer_bits", "clust_parts", "closer_cycles", "cluster8pieces", "clust_width", "clust_features", "cluster2bytes", "clust_bits", "cluster_pins", "clancer_bytes", "cluster_bit", "cluster_parts", "closer_bytes", "cluster32bits", "clust_pieces", "closer6bits", "cluster32width", "clancer_parts", "closer6bytes", "cluster_width", "cluster6cycles", "clancer_size", "cluster8features", "cluster_flags", "cluster_pieces", "closer6flags", "cluster6bits", "cluster__size", "cluster8parts", "cluster_bytes", "cluster__parts"], "bs": ["b", "bl", "pb", "base", "vs", "bc", "gs", "bh", "rs", "os", "bb", "bytes", "sb", "ssl", "bid", "bos", "fs", "ba", "bn", "ps", "br", "bi", "gb", "cs", "mb", "bas", "ns", "BS", "utils", "ss", "ls", "ds", "lb", "SB", "ses", "fb"], "header": ["port", "hash", "entry", "driver", "column", "journal", "metadata", "ssl", "final", "cache", "type", "result", "character", "reader", "request", "h", "url", "frame", "line", "table", "comment", "block", "bridge", "hr", "Header", "document", "rr", "cookie", "name", "holder", "headers", "secondary", "kernel", "writer", "connection", "info", "fp", "service", "external", "buffer", "definition", "cover", "builder", "event", "meta", "client", "ext", "index", "later", "offset", "plugin", "status", "error", "forward", "message", "summary", "response", "full", "br", "dr", "master", "config", "queue", "code", "fr", "protected", "head", "player", "extra", "f", "output", "module", "layer", "data", "server", "back", "report", "pillar", "parser", "body", "layout", "number", "tail", "manager", "public", "content", "section"], "refcount_table": ["refCount_master", "refcount2master", "refcount2count", "refcount_cache", "refCount_cache", "refcount_master", "refcount2cache", "refcount_count", "refCount_count", "refCount_table", "refcount2table"], "local_err": ["local7str", "localamerr", "httperresult", "localererr", "loc_result", "remote_exit", "localamError", "local_Error", "local7err", "http_str", "loc_err", "local_exit", "localandinfo", "local_result", "local_info", "local7Error", "http_result", "http_error", "remote_info", "localerresult", "localanderror", "localamexit", "localaminfo", "local7result", "localanderr", "httpererr", "httperstr", "localerstr", "localamerror", "loc_str", "local_str", "loc_Error", "localererror", "remote_err", "local_error", "localamresult", "remote_error", "localamstr", "httpererror", "localandexit", "http_err"], "ret": ["num", "hash", "run", "rf", "status", "error", "reply", "nb", "mt", "RET", "debug", "proc", "end", "let", "len", "red", "info", "nt", " RET", "fin", "alt", "result", "resp", "br", "det", "conn", "ref", "part", "ver", "rets", "arr", "lock", "bad", "rl", "def", "obj", "pub", "ft", "rc", "fun", "match", "fail", "att", "db", "arg", "rt", "sec", "lit", "msg", "bf", "rep", "val", "cat", "ure", "back", "Ret", "reg", "res", " result", "flag", "art", "success", "re"]}}
{"project": "FFmpeg", "commit_id": "3dea28cc2ef22861347918b6740c4c05c46a6614", "target": 0, "func": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= -1;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb= 1<<16;\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n", "idx": 26390, "substitutes": {"h": ["x", "b", "context", "n", "oh", "ch", "ih", "home", "http", "gh", "self", "bh", "hd", "hw", "he", "sh", "ctx", "r", "hi", "host", "eh", "cache", "hl", "g", "l", "work", "v", "hh", "hs", "hm", "p", "m", "history", "rh", "t", "s", "u", "w", "ah", "e", "ph", "c", "d", "hp", "f", "hr", "html", "q", "H", "ht", "o"], "i": ["x", "b", "ai", "index", "oi", "li", "pi", "n", "in", "key", "ji", "z", "id", "j", "yi", "info", "iu", "hi", "ix", "gi", "bi", "l", "v", "ti", "io", "mu", "slice", "uri", "xi", "ini", "multi", "p", "qi", "m", "zi", "t", "I", "di", "u", "ii", "k", "si", "e", "c", "d", "eni", "f", "start", "ui", "phi", "ci", "o", "ni", "ri", "a", "mi"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n", "idx": 26396, "substitutes": {"opaque": [" opec", "OPac", "ipacity", "opace", "OPec", "OPacity", "openaque", " opace", "OPace", "opac", " opacity", "ipaque", "ipec", " opac", "ipac", "openace", "OPaque", "opacity", "openacity", "opec"], "addr": ["x", "index", "align", "inter", "mode", "state", "slot", "ace", "ptr", "fd", "host", "alt", "attr", "amd", "dr", "ref", "src", "enc", "config", "arm", "address", "prefix", "mac", "device", "arg", "rt", "intel", "point", "loc", "ind", "pc", "data", "ad", "pos", "ord", "adr", "pad", "nr", "pointer", "offset"], "val": ["x", "b", "bl", "value", "ret", "base", "bc", "slot", "valid", "eval", "end", "len", "sel", "vol", "mem", "v", "ref", "al", "VAL", "arr", "vals", "grad", "unit", "el", "arg", "loc", "pt", "lit", "data", "Val", "offset"], "d": ["b", "sd", "dc", "dt", "D", "da", "z", "id", "state", "od", "dh", "fd", "r", "g", "dom", "l", "gd", "ded", "bd", "p", "m", "t", "di", "ld", "md", "db", "k", "e", "c", "ind", "f", "i", "ds", "data", "ad", "o", "dat", "cd"], "reg": ["bl", "rec", "mod", "gr", "ret", "win", "err", "debug", "ac", "tag", "r", "g", "mem", "conn", "rg", "acc", "enc", "config", "arr", "eg", "REG", "ld", "rc", "Reg", "arg", "loc", "exec", "ig", "ind", "pc", "sec", "stat", "ad", "res", "dat", "re"]}}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void abort_codec_experimental(AVCodec *c, int encoder)\n\n{\n\n    const char *codec_string = encoder ? \"encoder\" : \"decoder\";\n\n    AVCodec *codec;\n\n    av_log(NULL, AV_LOG_FATAL, \"%s '%s' is experimental and might produce bad \"\n\n            \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",\n\n            codec_string, c->name);\n\n    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);\n\n    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n\n        av_log(NULL, AV_LOG_FATAL, \"Or use the non experimental %s '%s'.\\n\",\n\n               codec_string, codec->name);\n\n    exit(1);\n\n}\n", "idx": 26428, "substitutes": {"c": ["b", "coll", "dc", "n", "ch", "sc", "com", "bc", "ca", "anc", "ac", "cc", "cp", "self", "mc", "cv", "l", "v", "ce", "cf", "enc", "con", "config", "cl", "vc", "p", "code", "cs", "tc", "t", "cr", "u", "C", "ct", "k", "e", "uc", "cod", "ec", "f", "lc", "call", "cat", "ci", "o"], "encoder": ["encater", " encorer", "encoding", "equater", "ecoded", "ecoding", "decoding", "deccer", "encoded", "decater", "encorer", " encater", " enccer", "decoded", "encode", "enccer", "equoder", "ecoder", "equode", "decoder", " encoding", "Encoding", "Enccer", " encode", "decorer", "ecorer", " encoded", "Encoder", "decode", "equoding", "Encoded"], "codec_string": ["codec_number", "codcode_double", "codenc_type", "codcode_strings", "codec_stream", "codec_double", "codcode_number", "codec_str", "codcode_string", "codec_strings", "codcode_str", "codec_type", "codenc_stream", "codenc_string"], "codec": ["predoc", "Codac", "Codesc", "prederc", "capect", "cedoc", "odeca", "codac", "coderc", "odect", "cdec", "codect", "cdesc", "codeenc", "cedef", "odec", "castoc", "Codoc", "castec", " codef", "cedenc", " codect", "coduc", "codeca", "capuc", "cdoc", " codesc", "cedec", " coduc", "Codec", "cdac", " coderc", "castuc", "preduc", " codac", "codenc", "codeec", "capec", "codeoc", "oduc", "codesc", "capeca", " codeca", "codoc", " codoc", "predec", " codenc", "casterc", "codeef", "codef"]}}
{"project": "FFmpeg", "commit_id": "877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1", "target": 1, "func": "static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}", "idx": 26435, "substitutes": {"c": ["b", "context", "n", "dc", "ac", "cc", "r", "cache", "l", "h", "icc", "vc", "p", "m", "cs", "s", "t", "cit", "u", "C", "w", "e", "d", "f", "pc", "lc", "abc", "a"], "dst": ["idconst", "Dconst", "sdconst", "sdst", "dsc", "dstack", "Dstack", " dconst", "sdsc", "dsts", "sdsts", "dconst", "idsts", "Dst", "idst", "fsts", " dstack", " dsts", "fst", "fsc", "Dsts", "fconst", "idstack", " dsc"], "dstWidth": ["dconstwidth", "DSTwidth", "dstackHeight", "DstHeight", "dscwidth", "dSTW", "DSTWidth", "dstwidth", " dstW", " dSTW", "dstHeight", "dconstW", "Dstwidth", "DSTHeight", "DstWidth", " dstwidth", " dSTWidth", "DSTW", "dstackWidth", "dSTwidth", "dstackW", "dstackwidth", "dstW", " dSTwidth", "dscWidth", "dSTWidth", "dscW", "dSTHeight", "dconstWidth", "dconstHeight", "DstW"], "src": ["index", "b", "dist", "front", "sl", "rank", "sc", "split", "cmp", "rob", "source", "proc", "stack", "func", "inf", "text", "lib", "sub", "sb", "secure", "sel", "ssl", "insert", "rb", "size", "cv", "attr", "bin", "url", "sur", "enc", "stream", "config", "rest", "pack", "grad", "conv", "stage", "inst", "rc", "input", "comp", "desc", "loc", "sup", "uc", "sync", "start", "includes", "img", "cb", "data", "sq", "dest", "st", "RC", "support", "cur"], "srcW": [" dstN", "destW", "rcW", "rcN", " dstw", "rcw", " dstH", "srcw", "destN", "srcN", "destw", "srcH", "rcH", " dstW", "destH"], "xInc": ["XInc", "crossSign", "crossIncre", "exInit", "rxInit", " xSign", "XEnc", "xIncre", "xInit", " xEnc", "exEnc", "Xinc", "exInc", "xinc", "rxSign", "xSign", "rxInc", "rxIncre", "XInit", " xinc", "exinc", " xInit", "crossInc", " xIncre", "crossInit", "xEnc"], "i": ["x", "index", "b", "ai", "oi", "li", "pi", "n", "ji", "z", "id", "j", "iu", "ip", "ix", "ei", "gi", "bi", "l", "v", "ti", "io", "uri", "xi", "ini", "multi", "p", "qi", "zi", "di", "I", "t", "u", "it", "ii", "k", "si", "e", "d", "ind", "f", "ui", "ci", "pos", "o", "ni", "ri"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_i_mbs(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    MpegEncContext *s = &v->s;\n\n    int current_mb = 0; /* MB/Block Position info */\n\n    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,\n\n        *p_cbpcy /* Pointer to skip some math */;\n\n\n\n    /* Reset CBPCY predictors */\n\n    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n\n\n\n    /* Select ttmb table depending on pq */\n\n    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];\n\n    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];\n\n    else v->ttmb_vlc = &vc9_ttmb_vlc[2];\n\n\n\n    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)\n\n    {\n\n        /* Init CBPCY for line */\n\n        *((uint32_t*)previous_cbpcy) = 0x00000000;\n\n        p_cbpcy = v->previous_line_cbpcy+4;\n\n\n\n        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)\n\n        {\n\n            /* Get CBPCY */\n\n            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);\n\n\n\n            s->ac_pred = get_bits(gb, 1);\n\n\n\n            /* TODO: Decode blocks from that mb wrt cbpcy */\n\n\n\n            /* Update for next block */\n\n#if TRACE > 2\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,\"\n\n                   \" cbpcy=%i%i%i%i\\n\", current_mb,\n\n                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],\n\n                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],\n\n                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);\n\n#endif\n\n            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);\n\n            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);\n\n            current_mb++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26437, "substitutes": {"v": ["b", "V", "n", "vm", "volt", "vs", "sv", "j", "ve", "lv", "av", "vp", "vt", "nv", "g", "ov", "vim", "vol", "l", "h", "nav", "ver", "version", "vc", "p", "m", "conv", "t", "vert", "ev", "vu", "u", "vd", "we", "k", "e", "c", "vin", "tv", "f", "i", "q", "va", "vi", "uv", "iv", "vv"], "gb": ["b", "gm", "vg", "bm", "abb", "gp", "pg", "vm", "tm", "bc", "mode", "nb", "gs", "lib", "bb", "sb", "ctx", "rb", "g", "gc", "storage", "pm", "cv", "gd", "rg", "hub", "nom", "py", "ym", "GB", "gy", "m", "mb", "rc", "cm", "cfg", "gam", "db", "cod", "gg", "pc", "bridge", "buff", "cb", "bf", "ui", "ci", "kb", "mag", "uv", "mi", "cd"], "s": ["js", "b", "scope", "sc", "S", "rs", "ssl", "sb", "fs", "g", "h", "p", "args", "u", "si", "sync", "sup", "xs", "serv", "sq", "parts", "a", "network", "n", "qs", "secondary", "conf", "gs", "es", "l", "ims", "ks", "share", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "site", "its", "sf", "vs", "j", "self", "session", "get", "ts", "is", "y", "app", "m", "sym", "w", "sg", "f", "ds", "server", "ses", "sys", "sl", "align", "sv", "http", "os", "r", "storage", "ps", "acc", "ins", "ab", "ns", "d", "i", "ls", "services", "us"], "cbpcy": ["cbcpy", "cmdpcy", "cbnpky", "cbpsty", "cblpky", "cbpry", "cbgcr", "cbpcsty", "cbcpcy", "cblpcy", "cblpci", "cbgcy", "cbnpcy", "cbgry", "cbpisy", "cbpcsy", "cbpci", "bcnpsty", "cblpcr", "bcpsty", "cbopcy", "cbpky", "cmdopry", "cbnci", "cbfcr", "dbnpcy", "cmdopcy", "cblppy", "cbopcle", "cbcry", "cbnpcle", "bblpcy", "dbnpci", "cbopci", "cbnpsty", "bcpsy", "bbppy", "cbpsy", "cbpici", "cblpry", "dbpci", "ebpcr", "bblppy", "dbpky", "bcnpcy", "cbtpky", "cbnpci", "cbpcci", "cbppy", "eblpky", "cbccle", "cbopry", "dbpcle", "dbpcy", "eblpcr", "cmdopcle", "cblpcle", "bcnpsy", "cbnry", "ebpcy", "cbgky", "cbccy", "cbfry", "bcnpci", "bblpky", "cbcci", "bcpci", "cbpicy", "cmdopci", "bbpcy", "cbpcr", "cbcppy", "cbncy", "cbfcy", "cbtpci", "cmdpci", "dbnpcle", "cbpcle", "eblpry", "cbtpcy", "cmdpry", "cbpisty", "cbnpsy", "bcpcy", "cbtpcle", "ebpry", "cmdpcle", "cbncle", "dbnpky", "eblpcy", "bbpci", "ebpky", "cbfky", "cbcky", "cbpccy", "bblpci", "cbcpci", "bbpky", "cbcpky"], "previous_cbpcy": ["previous_bcpry", "previous_bbnry", "previous_cbpscy", "previous_cbpzy", "previous_bbpcat", "previous_bclpcy", "previous_bclpky", "previous_cbnty", "previous_cbtry", "previous_cbgym", "previous_cbpcty", "previous_cbwpry", "previous_bbpch", "previous_cblpry", "previous_cbpsry", "previous_cbpcat", "previous_cbwpwy", "previous_cbnky", "previous_cbvpoy", "previous_bbpsty", "previous_cbtcy", "previous_cbvpry", "previous_bbpcy", "previous_cbpty", "previous_cbgry", "previous_bbnky", "previous_bbnke", "previous_cbpycat", "previous_cbtcat", "previous_cbnpry", "previous_cbnwy", "previous_cbprke", "previous_cbPoy", "previous_cbpycy", "previous_bclpzy", "previous_bbpwy", "previous_cbPry", "previous_bbPch", "previous_cbfpcy", "previous_cbpry", "previous_cbpcry", "previous_cblpzy", "previous_bbnty", "previous_cbvpcy", "previous_cbgky", "previous_bbPcy", "previous_cbnpcy", "previous_cblpky", "previous_cbppry", "previous_cbpoy", "previous_cbPch", "previous_bbpym", "previous_cbppcy", "previous_cbprry", "previous_cbpcwy", "previous_cbgcy", "previous_bcpzy", "previous_cbPky", "previous_cbpyry", "previous_bbPsty", "previous_bbPcat", "previous_cbfpry", "previous_bbpky", "previous_cbnpky", "previous_bclpry", "previous_cbppke", "previous_cbprcy", "previous_cbpky", "previous_cblpcy", "previous_bbncy", "previous_cbnpym", "previous_cbnym", "previous_cbpwy", "previous_bbnym", "previous_cbvpch", "previous_cbpsoy", "previous_bcpky", "previous_cbtsty", "previous_cbnke", "previous_bcpcy", "previous_cbpsty", "previous_cbPsty", "previous_cbpsch", "previous_cbfpky", "previous_cbfpzy", "previous_bbPry", "previous_cbppwy", "previous_bbpoy", "previous_bbnwy", "previous_bbpty", "previous_cbPcy", "previous_cbpke", "previous_bbpry", "previous_cbpccy", "previous_cbpym", "previous_cbPzy", "previous_cbpysty", "previous_bbPoy", "previous_cbprwy", "previous_cbwpty", "previous_cbpch", "previous_cbnry", "previous_bbpke", "previous_cbwpcy", "previous_cbPcat", "previous_cbncy"], "predicted_cbpcy": ["predicted_cbpCy", "predicted_debppcy", "predicted_debpcy", "predicted_cbppcy", "predicted_debpiny", "predicted_debppCy", "predicted_debpCy", "predicted_cbpiny", "predicted_cbppiny", "predicted_cbjpcy", "predicted_cbjpCy", "predicted_debppiny", "predicted_cbjpiny", "predicted_cbppCy"], "p_cbpcy": ["p_cbpfy", "p_cbpckee", "p_cbfct", "p_cbfky", "p_bcpky", "p_cbpsty", "p_cvpya", "p_ebpcr", "p_cvfya", "p_cbccy", "p_cbbry", "p_cbfpy", "p_cbprocku", "p_cbnpcr", "p_abbfci", "p_cbfpcr", "p_cbprcy", "p_bbpcy", "p_abbpcr", "p_pbbpcy", "p_cbppry", "p_cbfcor", "p_pbbpky", "p_pbpcy", "p_ebpcy", "p_cbprya", "p_fbpawy", "p_bbpky", "p_abbfcr", "p_bcpcy", "p_cbbya", "p_cbprry", "p_bbppy", "p_cbpry", "p_cbfkee", "p_bcnpfy", "p_abbfcy", "p_cbpci", "p_bcnpky", "p_cblpky", "p_bbfcy", "p_cbpcky", "p_cbfci", "p_cbprocky", "p_cblppy", "p_cbbpsty", "p_cbppcy", "p_cbpccy", "p_cbbct", "p_ebpaky", "p_pbpocy", "p_cbpppy", "p_cvfry", "p_cbnpcy", "p_pbbpsty", "p_cbbpocy", "p_cbpcsty", "p_cbpact", "p_cbfry", "p_cblpye", "p_pbbpocy", "p_cbppku", "p_fbpacy", "p_cbpwy", "p_cbcye", "p_cbproccy", "p_bcnpku", "p_ebpacor", "p_bbfkee", "p_ebpky", "p_cvfcy", "p_cblpcr", "p_cbfya", "p_ebpacr", "p_bcpku", "p_cblpwy", "p_pbpky", "p_cbppky", "p_cvpcy", "p_cvfct", "p_cbcct", "p_cbpcr", "p_cvpry", "p_cbpky", "p_cbfcr", "p_abbpcy", "p_bbpkee", "p_cblpci", "p_cbpawy", "p_cbpacor", "p_ebpacy", "p_cblpocy", "p_cbprct", "p_abbfky", "p_fbpaye", "p_cvpct", "p_cbbpky", "p_cbprocfy", "p_abbpci", "p_bbfpy", "p_bcpfy", "p_cbpcocy", "p_cblpkee", "p_bcnpcy", "p_cbnpfy", "p_cbnpci", "p_cbfpcy", "p_cbpcry", "p_cbppy", "p_cbpacr", "p_fbpwy", "p_fbpact", "p_pbpsty", "p_bbfky", "p_fbpye", "p_cbfpcor", "p_cbfcy", "p_cbpocy", "p_abbpky", "p_fbpcy", "p_cblpct", "p_cbfpky", "p_cbpye", "p_cbcwy", "p_fbpct", "p_cbnpky", "p_cblpsty", "p_cbpya", "p_cbpct", "p_cblpry", "p_bbpry", "p_ebpcor", "p_cbpku", "p_cbpaye", "p_bbfry", "p_cbpkee", "p_cbnpku", "p_cbpcor", "p_cbpaky", "p_cbpacy", "p_cbbpcy", "p_cbppfy", "p_cblpcy", "p_cbbcy"], "mb_y": ["mp_x", "mbFye", "mb_type", "mb_ye", "mbFy", "mp_y", "mb_size", "mbFx", "mb_vy", "mp_yd", "mbFvy", "mbFtype", "mb_w", "MB_ye", "mb_yd", "mp_type", "mp_w", "MB_y", "MB_vy", "mbFsize", "mbFyd", "MB_size"], "mb_x": ["mb11n", "mp_x", "mb_n", "mb11x", "MB_x", "mp_n", "mb_ex", "mp_y", "MB_wx", "mb__y", "mb11gy", "mb_wx", "MB_ex", "mp_ex", "mb_gy", "mb__n", "mb__x", "mb__gy", "mb_z", "mp_gy", "mp_rx", "MB_z", "mb11y", "mp_z", "mb_rx"], "current_mb": [" current_MB", "current_MB", "current_bb", " current_bb", " current_mm", " current_emb", "current_mm", "current_emb"]}}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443, "substitutes": {"dev": ["sd", "mod", "ch", "home", "driver", "fo", "ve", "debug", "self", " Dev", "od", "hw", "rad", "dom", "Device", "DEV", "serial", "gd", "conn", "priv", "tr", "ver", "cam", "app", "p", "grad", "dm", "di", "def", "devices", "ev", "de", "device", "md", "Dev", "w", "die", "gu", "dd", "d", "data", "ad", "development", "dem", "prom", "phy", " device"], "s": ["js", "b", "sd", "n", "sl", "sv", "S", "gs", "self", "os", "rs", "uns", "ops", "ssl", "sb", "r", "g", "storage", "session", "ps", "ts", "es", "is", "l", "v", "service", "p", "cs", "m", "t", "args", "south", "u", "w", "su", "ns", "sg", "si", "settings", "e", "sync", "c", "d", "ss", "f", "i", "spec", "ds", "ls", "services", "sq", "server", "o", "us", "se", "ses", "sys"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n", "idx": 26451, "substitutes": {"ctrl": ["fc", "trl", "dc", "rf", "rx", "xc", "bc", "cmp", "nc", "lr", "ac", "Ctrl", "control", "ctr", "ctx", "ctl", "ssl", "chain", "rb", "wb", "alt", "attr", "bitcoin", "controller", "fp", "io", "ref", "cf", "conn", "con", "config", "icc", "Control", "cl", "oc", "alloc", "controlled", "manager", "ocl", "rl", "cr", "conv", "prefix", "obj", "rc", "cm", "acl", "irc", "ll", "utils", "exec", "lc", "cb", "aux", "ci", "server", "client", "adr"], "c": ["x", "b", "cmd", "coll", "fc", "n", "dc", "ch", "xc", "com", "z", "ac", "count", "self", "cp", " rc", "ctx", "r", "g", "cache", "size", "l", "v", "cont", "conn", "h", "cf", "con", "config", "cl", "vc", "p", "code", "m", "cs", "cr", "channel", "s", "t", "u", "C", "rc", "cm", "ct", "address", "k", "addr", "e", "uc", "d", "i", "f", "pc", "ec", "lc", "co", "cu", "ci", "o", "pointer"]}}
{"project": "qemu", "commit_id": "b0457b69209fca3fb40a85bd54d7f27eb4bad7e7", "target": 0, "func": "static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n", "idx": 26458, "substitutes": {"s": ["js", "b", "its", "native", "a", "qs", "sc", "conf", "com", "S", "gs", "self", "os", "rs", "uns", "ops", "ssl", "fs", "r", "g", "session", "ps", "aws", "ts", "es", "is", "l", "v", "ks", "service", "strings", "p", "cs", "m", "sym", "features", "t", "south", "u", "sets", "su", "ns", "si", "bis", "settings", "e", "sync", "c", "d", "f", "ss", "spec", "ls", "ds", "xs", "sim", "services", "server", "o", "client", "comments", "us", "ses", "sys"], "desc": ["buf", "prop", "dir", "dep", "cd", "rec", "decl", "Desc", "sc", "entry", "vec", "cmp", "bc", "description", "text", "req", "end", "summary", "sub", "disc", "asc", "info", "en", "result", "record", "resp", "ref", "src", "acc", "enc", "stream", "config", "code", "stage", "pro", "def", "des", "de", "rc", "comment", "loc", "doc", "cod", "seq", "uc", "e", "ec", "sec", "sup", "c", "diff", "data", "dest", "esc", "reg", " descriptor", "usc", "name", "ext"], "descptr": [" descpointer", "destr", " descriptorpath", "escPtr", "descriptionpointer", "decval", "secctr", " descriptPtr", "descctr", " descriptptr", " descriptpath", "descpointer", "desPtr", "desctr", " descriptorptr", " descctr", "descriptionvr", "decptr", "descaddr", "descvr", "descpath", "descriptionPtr", "escpointer", "escaddr", "descriptionaddr", "escptr", "Descpointer", "escval", "decPtr", "descPtr", "esctr", "escvr", "declval", "declpointer", " descriptorPtr", "desaddr", "Descaddr", "despointer", " descPtr", "secptr", " descaddr", " descpos", "descriptiontr", "declPtr", "decpointer", "secPtr", "desptr", "descpos", "desvr", "escctr", "Descptr", "descriptionptr", " descriptorpos", " descpath", "descval", "secpointer", " descriptpos", "declptr", "DescPtr"], "i": ["x", "ai", "index", "b", "oi", "li", "pi", "n", "iii", "ie", "in", "id", "j", "abi", "interface", "yi", "info", "r", "iu", "hi", "ip", "ix", "module", "gi", "bi", "l", "is", "ti", "v", "fi", "io", "mu", "y", "uri", "xi", "ini", "multi", "p", "qi", "m", "zi", "ik", "di", "I", "chi", "u", "it", "ii", "inst", "si", "e", "c", "uli", "d", "ind", "f", "eni", "adi", "ami", "cli", "api", "start", "ori", "ui", "ci", "iv", "o", "ni", "ri", "mi"]}}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468, "substitutes": {"bus": ["buf", "b", "plugin", "loop", "parent", "home", "driver", "child", "id", "http", "bc", "self", "abi", "connection", "lib", "board", "group", "cache", "session", "band", "cycle", "Bus", "boot", "serial", "controller", "mot", "l", "conn", "io", "hub", "BUS", "config", "vc", "pass", "lock", "ux", "device", "bug", "machine", "plug", "die", "feed", "sync", "git", "drive", "bridge", "f", "gen", "data", "cat", "mount", "usb", "back", "book", "us", "class"], "fdt": ["dfdt", "fddt", "fdts", "FDt", "FDT", "dsts", "dftm", "dst", "rafT", "FDtm", "rafts", "wdT", "dfts", "dsdt", "rafdt", "wdt", "dft", "wdts", "dfT", "fdT", "FDts", "raft", "dsT", "wdtm", "fdtm"], "qdev": ["qdevice", "qev", "reqapp", "Qdev", "sqdd", "sqdiff", "questdd", "sqdevice", "Qpro", "qudc", "qdiff", "sqdc", "Qdd", "Qdiv", "Qdiff", "quev", "qapp", "reqdc", "sqapp", "questdevice", "qdc", "qupro", "qvar", "questdev", "Qev", "qudev", " qpro", "Qdevice", "qpro", "quapp", " qdiv", "reqvar", "quvar", "qudiv", "sqvar", " qev", "sqdev", "questdiff", "qdiv", "reqdev", "qdd"], "qdevs": ["qpathstates", "qdds", "qpathe", "qdeviced", "Qdeve", "qDevs", "qdepi", "Qdepe", "Qdepd", "qDeve", "qdevd", "qdeve", "kdevos", "qevos", "kdevlines", "qevds", "dqdefsets", "qdepds", " qdds", "dqdeve", "dqdefs", "qdevops", "qevstates", "qgoods", "wevos", "qddstates", "kdevds", "qdivsets", "qDevds", "qdefe", "pdevds", "kevlines", "qDevos", "qsds", "qrados", "qdivs", "wdevops", "qgoodlines", "qdeflines", "qvars", "qevlines", "qdive", " qdevstates", "pevs", "dqdevstates", "dqdevs", "dqdefe", "qdevicee", "kevs", "qdepd", "qdevds", "Qdeps", "qDevses", "pevds", "wdevs", "qddi", "Qdevd", "qdevos", "Qdevs", "dqdevsets", "qdepe", "qdevses", "kdevs", "qevops", "dqdefstates", "qdevices", "qdevi", "qdefds", "qvaros", "qdevstates", "qpathsets", " qdevi", "qdefstates", " qddi", "qdepstates", "qdevlines", " qddstates", "qradses", "qvarops", "qgoodds", "qradds", "qdeviceds", "qDevd", "qsdos", "qrads", "qdivstates", "qevi", "pevses", "pdevs", "qsdops", "qdefs", "kevos", "qdevsets", "qpaths", "qdeps", "Qdevds", "wevs", "pdevos", "Qdepds", "qdefos", "wdevos", "qevs", "qevses", "pevos", "wevops", "pdevses", "qdefsets", "kevds", "qgoodos"], "kid": ["king", "ke", "dc", "quad", "ids", "kin", "da", "tk", "id", "child", "anc", "ko", "od", "chid", "nir", "sid", "dad", "kg", "ck", "isi", "cer", "dk", "ku", "kel", "pid", "conn", "ks", "iden", "sk", "idy", "cand", "kt", "ski", "bug", "kick", "ker", "kids", "feat", "k", "hack", "node", "kind", "sync", "kr", "gen", "ad", "kn", "tick", " kids", "eth", "kb", "Kid", "ki", "wk"], "i": ["x", "index", "b", "ai", "oi", "li", "pi", "n", "ie", "ret", "ji", "z", "id", "j", "yi", "iu", "ip", "hi", "ix", "type", "gi", "ri", "bi", "l", "ti", "mu", "io", "v", "part", "xi", "ini", "multi", "p", "qi", "zi", "di", "I", "chi", "u", "it", "ii", "k", "si", "jp", "e", "c", "start", "ind", "f", "eni", "ui", "ci", "pos", "phi", "o", "ni", "en", "ki", "mi"], "num": ["index", "b", "iq", "span", "n", "mon", "un", "parent", "mult", "ret", "nb", "du", "lim", "id", "net", "mn", "count", "mut", "valid", "end", "lib", "norm", "col", "len", "mom", "lu", "dim", "number", "common", "coord", "dom", "uu", "max", "mu", "Num", "nom", "uni", "con", "sort", "multi", "comb", "om", "unit", "nn", "u", "init", "su", "um", "na", "node", "loc", "inc", "fn", "nu", "f", "ul", "lit", "NUM", "img", "min", "np", "out", "nm", "umi", "ni", "name", "nr", "temp", "sum"], "dev": ["dist", "mod", "dc", "ch", "conf", "pu", "od", "lib", "av", "rad", "info", "dom", "v", "conn", "priv", "ver", "bd", "app", "cand", "di", "def", "pub", "ev", "w", "device", "md", "var", "Dev", "bug", "plug", "de", "kind", "block", "dd", "adv", "data", "ad", "reg", "dem", "pad", "prom"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472, "substitutes": {"env": ["prov", "enable", "engine", "context", "que", "ench", "vm", "status", "dict", "vs", "energy", "eu", "state", "err", "chn", "environment", "er", "exec", "loader", "req", "ctx", "enh", "cache", "model", "esi", "v", "h", "conn", "priv", " environment", "esm", "enc", "erv", "config", "manager", "forest", "queue", "code", "dev", "password", "exc", "stage", "args", "profile", "ev", "him", "init", "console", "forge", "ah", "settings", "e", "export", "eng", "ea", "Environment", "nw", "ec", "eni", "txt", "dat", "c", "event", "server", "fen", "icer", "viron", "her", "gear", "kn", "en", "skin", "ext"]}}
{"project": "qemu", "commit_id": "5d7fd045cafeac1831c1999cb9e1251b7906c6b2", "target": 0, "func": "uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n", "idx": 26480, "substitutes": {"env": ["enable", "engine", "context", "scope", "et", "que", "conf", "energy", "err", "eu", "esp", "environment", "er", "end", "shell", "ctx", "emb", "ne", "enter", "qt", "here", "cal", "conn", "style", "enc", "erv", "config", "code", "dev", "exc", "equ", "args", "ev", "console", "el", "e", "exec", "eng", "ea", "Environment", "export", "ec", "c", "event", "global", "np", "esc", "iv", "en", "her", "vel"], "f1": ["h3", "f01", "v01", "c01", "v1", "F1", "cf01", " fp", "cfone", "h1", "cf2", "vp", "h2", "F2", "F01", "fp", "v3", " fone", "F3", "fone", "cf1", "Fp", "cone", "v2", "h01", " f01", "c1", "f3", "c2"], "f2": ["l0", "p3", "bf2", "p2", "f3", "bf3", "f0", "bf0", "ltwo", "bf256", "l256", "e0", " ftwo", "p4", "f4", "l4", "ftwo", "e2", "e3", "l3", "e256", "l2", " f3", " f4", "f256", "ptwo"]}}
{"project": "FFmpeg", "commit_id": "2f9ca64556cba9a7edcca9a1c55923a60022937d", "target": 0, "func": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    AVDictionary *tmp = NULL;\n\n    const char *proto_name = NULL;\n\n    int ret;\n\n\n\n    av_dict_copy(&tmp, opts, 0);\n\n    av_dict_copy(&tmp, opts2, 0);\n\n\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n\n        if (url[6] == '+' || url[6] == ':')\n\n            proto_name = avio_find_protocol_name(url + 7);\n\n    }\n\n\n\n    if (!proto_name)\n\n        proto_name = avio_find_protocol_name(url);\n\n\n\n    if (!proto_name)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // only http(s) & file are allowed\n\n    if (av_strstart(proto_name, \"file\", NULL)) {\n\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n\n                url);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n\n        ;\n\n    } else\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n\n        ;\n\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n\n        ;\n\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (c->http_persistent && *pb && av_strstart(proto_name, \"http\", NULL)) {\n\n        ret = open_url_keepalive(c->ctx, pb, url);\n\n        if (ret == AVERROR_EXIT) {\n\n            return ret;\n\n        } else if (ret < 0) {\n\n            if (ret != AVERROR_EOF)\n\n                av_log(s, AV_LOG_WARNING,\n\n                    \"keepalive request failed for '%s', retrying with new connection: %s\\n\",\n\n                    url, av_err2str(ret));\n\n            ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n        }\n\n    } else {\n\n        ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n    }\n\n    if (ret >= 0) {\n\n        // update cookies on http response with setcookies.\n\n        char *new_cookies = NULL;\n\n\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n\n\n        if (new_cookies) {\n\n            av_free(c->cookies);\n\n            c->cookies = new_cookies;\n\n        }\n\n\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n\n    }\n\n\n\n    av_dict_free(&tmp);\n\n\n\n    if (is_http)\n\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n\n\n    return ret;\n\n}\n", "idx": 26481, "substitutes": {"s": ["b", "sf", "n", "sl", "sr", "sc", "sv", "S", "self", "os", "rs", "sb", "ctx", "ssl", "r", "bs", "g", "ts", "es", "sa", "v", "ks", "service", "p", "cs", "m", "sym", "t", "su", "ns", "sg", "si", "e", "ss", "f", "spec", "ls", "services", "sq", "sn", "server", "o", "us", "se", "ses"], "pb": ["_", "b", "prop", "plugin", "pg", "fc", "pl", "mp", "path", "bc", "http", "bh", "proc", "cp", "vp", "python", "sb", "ctx", "PB", "ssl", "x", "r", "prot", "rb", "pkg", "type", "fp", "bps", "ib", "pa", "ppa", "p", "parse", "tp", "tc", "apy", "obj", "db", "bp", "pd", "pc", "cli", "lb", "cpp", "uf", "typ", "pm", "lp", "fb"], "url": ["id", "rule", "www", "ssl", "sel", "pull", "type", "result", "request", "ref", "address", "username", "page", "ur", "el", "view", "download", "user", "name", "pl", "key", "path", "rel", "gl", "text", "host", "l", "raw", "email", "buffer", "web", "feed", "api", "use", "error", "bb", "full", "secure", "update", "hl", "location", "resource", "all", "uri", "src", "config", "fr", "route", "rl", "bug", "ll", "f", "str", "q", "server", "date", "sl", "base", "http", "source", "href", "always", "https", "zip", "r", "image", "v", "file", "Url", "loc", "uc", "fl", "URL", "ul", "html", "ls", "length"], "opts": ["otz", "opcs", "optts", "opz", " optz", " optcs", "optters", "opercs", "opertes", "opters", "OPtes", "otcs", "oprs", "otrs", "OPters", "optes", "optrs", "OPts", " optrs", "operts", "optz", "OPcs", "optcs", "opttes", "operters", " optts", "otts"], "opts2": ["opcs2", "opatsSecond", " optt52", " optsSecond", "OPts1", "opoptions52", "opt4", "opcsSecond", "OPt1", "optesSecond", "optt52", "optes2", "opcs4", "optsSecond", "OPt2", "OPt4", "OPts4", "opoptionsSecond", " opts52", " optt2", "optt2", "opttSecond", "opats52", "optes4", "opts1", "opts4", "opats2", "optSecond", " opttSecond", "opt1", "OPts2", "OPtsSecond", "opoptions2", "OPtSecond", "opt2", "optes1", "opcs1", "opts52"], "is_http": [" is_url", "is_url", " is_uri", "is_uri", "is_https", " is_https"], "c": ["b", "coll", "dc", "n", "ch", "sc", "conf", "bc", "ca", "self", "cc", "cp", "cy", "ctx", "g", "mc", "cv", "l", "conn", "ce", "cf", "con", "config", "vc", "p", "cs", "m", "tc", "cn", "t", "cur", "u", "C", "cr", "cm", "ctrl", "ct", "k", "this", "e", "uc", "d", "f", "ec", "lc", "pc", "co", "cu", "ci", "cd"], "tmp": ["buf", "array", "mp", "nb", "cmp", "source", "proc", "cp", "etc", "metadata", "stuff", "ctx", "sb", "vt", "nt", "pkg", "storage", "cache", "rb", "tt", "wb", "cv", "attr", "params", "emp", "bt", "src", "config", "app", "tc", "obj", "properties", "txt", "append", "extra", "copy", "cb", "tab", "api", "data", "meta", "np", "opt", "tp", "temp", "ob", "fb", "buff"], "proto_name": ["proo_type", "proproNname", "protoPn", "proto_date", "proto2key", "propcMnames", "protoJkey", "propc_named", "proco_url", "proboPname", "proto_alias", "protoShortnum", "propc_names", "protofullname", "proto_main", "protoNname", "protop64size", "progo_span", "protoPdate", "proocol_num", "proto64name", "protoJsize", "proocol_len", "propcMnamed", "proto_part", "propcMimage", "protoPName", "proto2info", "protoJnone", "protoShortnm", "proo_Name", "propc_image", "profrom_main", "proto\u00b7span", "protop64name", "proto_image", "proresource_parent", "proto_key", "proo__type", "proto_url", "probo_n", "protoMnamed", "protoJName", "protop64error", "protoJdate", "protoNpart", "proto2type", "proresourceDsearch", "proto_cache", "proto_label", "proto64size", "protoSend", "protoSlength", "proto_type", "proto2string", "proto_layer", "proboPpart", "proprotJlayer", "proto64error", "propro_part", "proprot_name", "proserver_string", "protoFname", "protoJend", "protoJpart", "protoPname", "proresourceDtext", "proprotJname", "proto__type", "proprot_none", "proto_info", "profrom2type", "proto_pass", "protop_size", "propcMname", "proresourceDparent", "proto_size", "proto_Name", "proprot_layer", "proto_end", "proprotJName", "protoFtext", "protoJname", "protoJlength", "protop_error", "proocol_name", "proto_named", "progo_name", "protop64named", "probo_date", "proco_end", "protoDname", "proto_search", "proto_nm", "proto_span", "proboPdate", "protoPlen", "protoDsearch", "proto_num", "protop_name", "proto\u00b7name", "propro_label", "proocol_nm", "proresource_search", "protoShortname", "proco_size", "protoNlabel", "protoUname", "protoFsearch", "proproNlabel", "proto\u00b7version", "protoUlayer", "proto_version", "proto_error", "proresourceDname", "progo_Name", "proto__name", "proto__part", "protoJerror", "proto2main", "protoJlayer", "protop_named", "proproNpart", "proserver_key", "protoDparent", "protoSkey", "proto__Name", "proresource_name", "proo__Name", "proto_string", "protoMname", "protoPversion", "protoJn", "protofullmain", "proto_len", "proserver_name", "protoMimage", "protoMnames", "proto_n", "probo_name", "proo__name", "proto__date", "proto_names", "proo_name", "protoDtext", "profrom_name", "proco_name", "protoFparent", "profrom2name", "proprotJnone", "protoUnone", "proco_key", "protoPalias", "proto_none", "prophy_pass", "protoUName", "proprot_Name", "proto\u00b7Name", "propc_name", "protoJnamed", "proto2name", "proresource_text", "protoPpart", "proto_text", "prophy_cache", "profrom_type", "proto_parent", "proto64named", "protoSname", "probo_part", "proocol_alias", "proco_length", "progo_version", "protofulltype", "propro_name", "protoPspan", "profrom2main", "proserver_info", "proto_length", "prophy_name", "proboPn", "proto__n"], "ret": ["num", "reply", "id", "RET", "j", "len", " RET", "nt", "result", "alt", "resp", "get", "mem", "det", "ref", "rev", "rets", "code", "match", "obj", "def", "rc", "fun", "att", "arg", "rt", " Ret", "lit", "val", "data", "back", "Ret", "res", "bit", "re"]}}
{"project": "qemu", "commit_id": "1dbd2fd9cbf29c74131e439ce80fb2efde56ee32", "target": 0, "func": "static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n\n{\n\n    int ret = -EINVAL, idx;\n\n    struct rdma_cm_id *listen_id;\n\n    char ip[40] = \"unknown\";\n\n    struct rdma_addrinfo *res;\n\n    char port_str[16];\n\n\n\n    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {\n\n        rdma->wr_data[idx].control_len = 0;\n\n        rdma->wr_data[idx].control_curr = NULL;\n\n    }\n\n\n\n    if (rdma->host == NULL) {\n\n        ERROR(errp, \"RDMA host is not set!\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n    /* create CM channel */\n\n    rdma->channel = rdma_create_event_channel();\n\n    if (!rdma->channel) {\n\n        ERROR(errp, \"could not create rdma event channel\");\n\n        rdma->error_state = -EINVAL;\n\n        return -1;\n\n    }\n\n\n\n    /* create CM id */\n\n    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);\n\n    if (ret) {\n\n        ERROR(errp, \"could not create cm_id!\");\n\n        goto err_dest_init_create_listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n", "idx": 26485, "substitutes": {"rdma": ["ldsi", "ldeme", "rnpa", "lrmad", "nderma", "rdda", "rodda", "rdta", "rlsa", "ddma", "rdga", "rdsa", "rtmad", "rtmu", "ddmma", "rostga", "rdmc", "ldka", "frda", "ddta", "rdha", "rlka", "frmma", "rodma", "rnga", "rnsi", "rmda", "rodmma", "lrma", "rostmma", "rdema", "rlpa", "rmmma", "rmema", "dnda", "ldwa", "drha", "rtmas", "rtta", "drmma", "drda", "ndermma", "ldda", "rnmma", "rlea", "ddda", "dnmma", "ldma", "rmma", "rdmma", "ldema", "rdeme", "rdmas", "ddea", "ldta", "rdsi", "ldea", "rnmas", "rdwa", "rnma", "rlmad", "ldha", "nderema", "ddha", "rneme", "ratmas", "rlmeta", "ldmad", "rdpa", "lrwa", "ratma", "rtmar", "rxda", "ldmeta", "drma", "ratda", "rdmeta", "rnka", "ldmma", "frma", "rnmad", "rdmar", "rnda", "rnmeta", "dnma", "rxma", "rnema", "drmar", "rdmad", "rlma", "rostma", "rnta", "ldga", "rdea", "rxmas", "frmas", "rodmu", "rdka", "rtmma", "drmc", "rmsi", "rlda", "rtda", "rmmc", "ratmar", "rostda", "ddsa", "ldmas", "ldpa", "ddema", "drta", "lrda", "nderda", "rxeme", "rtwa", "ldsa", "ldmc", "drmas", "rtma", "rdmu", "dnmu"], "errp": ["ergpe", "ergpp", "erpp", "Erpe", "errpy", "errps", "angerP", "reqpe", "lerpt", "angerp", "orderp", "lerpy", "err", " errpre", "iterfp", " errfp", " erp", "errorc", "verpy", "errpr", "verP", " erpe", "Erc", "iterpp", "verpt", "erpre", "errc", "asterp", "angerpt", "errfp", "ergp", "erp", "erpr", "orderr", " erps", " erpp", "lerP", "errorp", "errpre", "erfp", "ErP", "ergps", "errpt", "errP", "lerp", " errr", "errorP", "asterP", "errpp", "errpe", " errpr", "reqps", "errorpe", "reqpp", " errpp", "errr", "orderfp", "asterc", "iterp", "verp", "angerpy", "Erp", "asterpe", "reqp", "iterpre", "orderpr"], "idx": ["idew", "indxes", "indx", "aidv", "idxes", "IDx", "midv", "idX", "idex", "Idxc", " idy", "idxs", "Idxs", "midy", " idv", "midz", "midx", "aidy", "idef", "idz", "ridf", "aidz", " idxs", "IDX", "indX", "pidxc", "indy", " idX", "idy", "pidxs", "ridw", "idxc", "IDxs", "Idy", " idw", "idv", "ridy", "ridX", "IdX", " idxc", "ridx", " idz", " idxes", "aidx", "idf", "Idw", " idf", "Idx", "pidx", "Idxes", "pidX", "IDy", "idey", "idw"], "listen_id": ["listennid", "listener_name", "listen_type", "liston_base", "listen_name", "listen__type", "listen2id", "listener_index", "liston_start", "listen_ids", "listen2start", "listen__id", "listennbase", "listen_base", "listener_type", "listenxid", "listen_start", "listen_sid", "listennstart", "listenxsid", "listen2base", "listener_sid", "listenxname", "listenntype", "listen2type", "liston_id", "listen_index", "listen__name", "liston_type", "listenxids", "listen__index", "listener_ids", "listener_id"], "ip": ["num", "port", "loop", "ips", "dc", "parent", "proxy", "php", "id", "byte", "net", "source", "cp", "interface", "zip", "op", "host", "up", "field", " IP", "type", "is", "isp", "uri", "ide", "skip", "ib", "pass", "p", "ress", "ic", "route", "ap", "address", "email", "mac", "input", "link", "of", "comp", "IP", "hop", "addr", "block", "seq", "af", "img", "i", "ep", "api", "data", "iv", "im", "name"], "res": ["rec", "remote", "results", "Res", "sr", "rx", "rel", "error", "ret", "gr", "resolution", "err", "reply", "ES", "rs", "rem", "req", "response", "r", "RE", "RS", "result", "RES", "resp", "params", "es", "ref", "rev", "rets", "ras", "pre", "arr", "rest", "ress", "rh", "def", "ex", "rc", "addr", "seq", "val", "rep", "rr", "reg", "ry", "re"], "port_str": ["host_string", "port_div", "portallstring", "portallstr", "host_div", "port2br", "port2Str", " port_string", "portallStr", "port_int", " port_name", "portalldict", "port2dict", "port_dict", "host_Str", " port_br", "port2div", "port_Str", " port_dict", "port2arr", " port_arr", "port2str", "port2int", "port_string", "port_name", " port_Str", "port2name", "port_arr", "port_br", "port2string", " port_int", "host_str"], "e": ["E", "n", "ed", "ie", "eu", "me", "edge", "er", "end", "ele", "ne", "r", "enter", "g", "esi", "en", "ae", "es", "l", "y", "h", "v", "ce", "pe", "be", "p", "ee", "m", "ze", "ell", "ge", "ev", "u", "de", "eve", "je", "el", "eb", "ef", "re", "pse", "ue", "c", "ea", "d", "element", "f", "i", "ec", "fe", "o", "ei", "se", "entity", "oe"]}}
{"project": "qemu", "commit_id": "2d26512b45b5236fa521c4492608fe9fb5bedf46", "target": 0, "func": "int cksum(struct mbuf *m, int len)\n\n{\n\n\tregister uint16_t *w;\n\n\tregister int sum = 0;\n\n\tregister int mlen = 0;\n\n\tint byte_swapped = 0;\n\n\n\n\tunion {\n\n\t\tuint8_t  c[2];\n\n\t\tuint16_t s;\n\n\t} s_util;\n\n\tunion {\n\n\t\tuint16_t s[2];\n\n\t\tuint32_t l;\n\n\t} l_util;\n\n\n\n\tif (m->m_len == 0)\n\n\t   goto cont;\n\n\tw = mtod(m, uint16_t *);\n\n\n\n\tmlen = m->m_len;\n\n\n\n\tif (len < mlen)\n\n\t   mlen = len;\n\n#ifdef DEBUG\n\n\tlen -= mlen;\n\n#endif\n\n\t/*\n\n\t * Force to even boundary.\n\n\t */\n\n\tif ((1 & (long) w) && (mlen > 0)) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\ts_util.c[0] = *(uint8_t *)w;\n\n\t\tw = (uint16_t *)((int8_t *)w + 1);\n\n\t\tmlen--;\n\n\t\tbyte_swapped = 1;\n\n\t}\n\n\t/*\n\n\t * Unroll the loop to make overhead from\n\n\t * branches &c small.\n\n\t */\n\n\twhile ((mlen -= 32) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n", "idx": 26489, "substitutes": {"m": ["x", "b", "gm", "bm", "n", "tm", "mt", "r", "g", "mc", "model", "l", "v", "h", "mu", "y", "mr", "manager", "M", "sm", "p", "man", "t", "dm", "u", "machine", "mac", "ms", "um", "media", "e", "d", "module", "f", "i", "mm", "meta", "o", "a", "mi"], "len": ["_", "x", "num", "bl", "li", "n", "sl", "ie", "lan", "z", "split", "lim", "net", "enn", "fat", "lu", "nt", "size", "hl", "en", "alt", "bin", "l", "mem", "la", "L", "au", "v", "zen", "lon", "line", "lf", "ell", "lin", "el", "ll", "limit", "seq", "fn", "gen", "lc", "ul", "f", "layer", "val", "dl", "lt", "le", "pos", "lp", "Len", "length", "ln", "fl"], "w": ["b", "wp", "www", "sh", "ou", "ww", "g", "way", "kw", "h", "p", "wan", "u", "plus", "k", "wh", "tw", "mit", "x", "fw", "n", "wa", "window", "widget", "l", "raw", "wo", "wd", "t", "oss", "e", "weights", "o", "opt", "rw", "aw", "value", "z", "iw", "ow", "wave", "ew", "wei", "wl", "y", "wx", "wal", " W", "now", "we", "f", "q", "wu", "mm", "am", "weight", "ch", "win", "wt", "hw", "W", "r", "word", "wb", "work", "v", "wm", "nw", "d", "i", "how", "sw", "words", "temp", "sum"], "c": ["x", "b", "n", "dc", "xc", "sc", "z", "ac", "cc", "cp", "r", "g", "cache", "mc", "l", "v", "h", "enc", "con", "config", "oc", "cl", "p", "code", "cs", "ic", "t", "u", "C", "k", "e", "d", "f", "i", "lc", "pc", "ec", "q", "co", "ci", "o", "a"], "s_util": ["l_utils", "s_utils", "s_ui", "s2ut", "l_ut", "s_quant", "g_ut", "s_local", "ws_utils", "slogquant", "s_ut", "slogut", " s_quant", "l_global", "slogutil", " s_ut", "s_mut", "ws_local", "ws_util", "g_mut", "g_util", "s2utils", "g_security", "s2global", "s_global", " s_ui", "s2util", "s_security", "slogui"], "s": ["x", "b", "in", "n", "sl", "sc", "z", "S", "os", "r", "g", "ps", "ans", "ts", "l", "is", "v", "h", "p", "cs", "ms", "ns", "k", "si", "e", "d", "ss", "f", "xs", "ls", "ds", "q", "a"], "l_util": ["l_utils", "ljutil", "l_san", " l_utils", "ljutils", " l_san", "ljsan"], "mlen": ["mlien", "plen", "milener", " mlEN", "mLeng", "sleng", " mlon", "bleng", "llien", "dlhen", "ulen", "linhen", "mlain", "elenn", "mllen", "dleng", "sln", "milen", " mleni", "milent", "slen", "MLenc", "mlened", "milun", "plenn", "lineng", "selhen", "llon", "slain", "ulener", "milzen", "llEN", "plien", "malenn", "mallen", "llen", "mileng", "mlon", "blenn", "selan", " mlenc", "MLon", " mln", "MLeng", "selen", "plan", "slon", "slens", "llain", "mleni", "miladen", "maleni", "eln", "milin", "milhen", " mlent", "mlhen", "mlin", "mlzen", "arleng", "mLaden", "maleng", "llun", "elain", "mLun", "eleni", "mLenn", "blen", "mlening", "llenn", " mleng", " mlens", "ulhen", "elening", "mladen", " mllen", "malener", " mlenn", "mLien", "mlenn", "malened", "mlenc", "malun", " mlened", "blener", "slenn", "mlan", "MLain", "MLEN", "malin", "plain", "elon", "elen", "mln", "mlEN", "malain", "llan", "mlener", " mlan", " mlain", "milenn", "pleng", "mlun", "slening", "lleng", "llenc", "mLen", "plhen", "elened", " mladen", "MLlen", " mlening", "elens", "linenn", "arlen", "llener", "selon", "malen", "dlen", "arlzen", "plin", "mlens", "malon", "linen", "slener", "mlent", "mLent", "MLen", "dlzen", "llhen", "plon", "mleng", "arlhen", "plun", "ulenn"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 26496, "substitutes": {"as": ["pas", "alias", "array", "AS", "was", "base", "As", "os", "er", "nas", "or", "inas", "aws", "asm", "cas", "is", "las", "al", "ras", "at", "ap", "ab", "acs", "ast", "ar", "var", "mac", "aster", "can", "using", "am", "use", "are", "us", "a", "sys"], "buffer": ["buf", "b", "port", "array", "base", "ram", "source", "message", "texture", "shape", "byte", "interface", "seek", "loader", "reference", "header", "binary", "surface", "program", "available", "ptr", "r", "image", "cache", "position", "number", "material", "result", "Buffer", "iter", "reader", "master", "resource", "url", "ref", "null", "pool", "batch", "queue", "code", "address", "read", "callback", "prefix", "input", "comment", "capacity", "addr", "limit", "bridge", "f", "delay", "buff", "transfer", "layer", "data", "uf", "pause", "map", "server", "memory", "length", "uffer"], "len": ["index", "cap", "bl", "lan", "base", "count", "cache", "size", "en", "type", "open", "all", "name", "lock", "db", "addr", "limit", "seq", "start", "ls", "val", "min", "pos", "Len", "length", "offset"], "is_write": ["is_send", "is_sync", "IS_write", "as_writing", "IS_network", "IS_sync", "is_writing", "as_write", "is_network", " is_read", "as_read", "is_read", "IS_writer", "as_sync", "is_writer", " is_send", " is_network"], "access_len": ["ac2len", "ac2data", "accessllen", "access_l", "accessinglen", "access_label", "accessfval", "ac_l", " access_limit", " access_ln", "accesslLen", "access2l", "access_data", "pass_len", "pass_ln", "access_val", " access_count", "access2val", "passingl", "accessenl", "ac_data", "ac2val", " access_Len", "ac_len", "accessenln", "access2size", "passinglabel", "accessenlabel", " access_line", "passingln", "access_lf", "access2data", "accesslval", "pass_label", "accessllf", "accessingln", "accessinglimit", "access_length", "accessflength", "access_ln", "access_line", "access_count", "access_Len", "accessfcount", "access_size", "accessflen", "ac_val", " access_val", "accessinglabel", "accessingline", " access_size", "access2ln", "ac2l", " access_length", "accessingl", "access2len", "passinglen", "access_limit", "accessenlen", "pass_l", "accesslln", " access_lf", "accesslsize"], "l": ["b", "nl", "li", "pl", "n", "sl", "j", "lr", "kl", "lu", "r", "g", "la", "v", "L", "al", "il", "cl", "p", "m", "line", "t", "s", "rl", "lf", "u", "ell", "ld", "lin", "el", "k", "ll", "ol", "e", "lo", "c", "loc", "d", "i", "f", "lc", "ls", "lit", "jl", "dl", "ul", "lb", "le", "o", "lp", "length", "ln", "fl"]}}
{"project": "FFmpeg", "commit_id": "44d854a518f97cb65090420b0b9f55611a0ea932", "target": 1, "func": "static av_cold int atrac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    int version, delay, samples_per_frame, frame_factor;\n\n    const uint8_t *edata_ptr = avctx->extradata;\n\n    ATRAC3Context *q = avctx->priv_data;\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Channel configuration error!\\n\");\n\n\n    }\n\n\n\n    /* Take care of the codec-specific extradata. */\n\n    if (avctx->extradata_size == 14) {\n\n        /* Parse the extradata, WAV format */\n\n        av_log(avctx, AV_LOG_DEBUG, \"[0-1] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown value always 1\n\n        edata_ptr += 4;                             // samples per channel\n\n        q->coding_mode = bytestream_get_le16(&edata_ptr);\n\n        av_log(avctx, AV_LOG_DEBUG,\"[8-9] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  //Dupe of coding mode\n\n        frame_factor = bytestream_get_le16(&edata_ptr);  // Unknown always 1\n\n        av_log(avctx, AV_LOG_DEBUG,\"[12-13] %d\\n\",\n\n               bytestream_get_le16(&edata_ptr));  // Unknown always 0\n\n\n\n        /* setup */\n\n        samples_per_frame    = SAMPLES_PER_FRAME * avctx->channels;\n\n        version              = 4;\n\n        delay                = 0x88E;\n\n        q->coding_mode       = q->coding_mode ? JOINT_STEREO : STEREO;\n\n        q->scrambled_stream  = 0;\n\n\n\n        if (avctx->block_align !=  96 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 152 * avctx->channels * frame_factor &&\n\n            avctx->block_align != 192 * avctx->channels * frame_factor) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown frame/channel/frame_factor \"\n\n                   \"configuration %d/%d/%d\\n\", avctx->block_align,\n\n                   avctx->channels, frame_factor);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else if (avctx->extradata_size == 10) {\n\n        /* Parse the extradata, RM format. */\n\n        version                = bytestream_get_be32(&edata_ptr);\n\n        samples_per_frame      = bytestream_get_be16(&edata_ptr);\n\n        delay                  = bytestream_get_be16(&edata_ptr);\n\n        q->coding_mode         = bytestream_get_be16(&edata_ptr);\n\n        q->scrambled_stream    = 1;\n\n\n\n    } else {\n\n        av_log(NULL, AV_LOG_ERROR, \"Unknown extradata size %d.\\n\",\n\n               avctx->extradata_size);\n\n\n    }\n\n\n\n    /* Check the extradata */\n\n\n\n    if (version != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version %d != 4.\\n\", version);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (samples_per_frame != SAMPLES_PER_FRAME &&\n\n        samples_per_frame != SAMPLES_PER_FRAME * 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of samples per frame %d.\\n\",\n\n               samples_per_frame);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (delay != 0x88E) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown amount of delay %x != 0x88E.\\n\",\n\n               delay);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (q->coding_mode == STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Normal stereo detected.\\n\");\n\n    else if (q->coding_mode == JOINT_STEREO)\n\n        av_log(avctx, AV_LOG_DEBUG, \"Joint stereo detected.\\n\");\n\n    else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown channel coding mode %x!\\n\",\n\n               q->coding_mode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (avctx->block_align >= UINT_MAX / 2)\n\n\n\n\n    q->decoded_bytes_buffer = av_mallocz(FFALIGN(avctx->block_align, 4) +\n\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (q->decoded_bytes_buffer == NULL)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    /* initialize the MDCT transform */\n\n    if ((ret = ff_mdct_init(&q->mdct_ctx, 9, 1, 1.0 / 32768)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        av_freep(&q->decoded_bytes_buffer);\n\n        return ret;\n\n    }\n\n\n\n    /* init the joint-stereo decoding data */\n\n    q->weighting_delay[0] = 0;\n\n    q->weighting_delay[1] = 7;\n\n    q->weighting_delay[2] = 0;\n\n    q->weighting_delay[3] = 7;\n\n    q->weighting_delay[4] = 0;\n\n    q->weighting_delay[5] = 7;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        q->matrix_coeff_index_prev[i] = 3;\n\n        q->matrix_coeff_index_now[i]  = 3;\n\n        q->matrix_coeff_index_next[i] = 3;\n\n    }\n\n\n\n    avpriv_float_dsp_init(&q->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    ff_fmt_convert_init(&q->fmt_conv, avctx);\n\n\n\n    q->units = av_mallocz(sizeof(*q->units) * avctx->channels);\n\n    if (!q->units) {\n\n        atrac3_decode_close(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avcodec_get_frame_defaults(&q->frame);\n\n    avctx->coded_frame = &q->frame;\n\n\n\n    return 0;\n\n}", "idx": 26512, "substitutes": {"avctx": ["avcb", "afcli", "avxc", "akcontext", "ivcot", "afcb", "evconn", "afpkg", "AVlc", "ajpkg", "avecf", "akcf", "varcmp", "afcoll", "avalcomponent", "alctx", "airpkg", "avpkg", "avsci", " avconn", "aveconn", " avcontext", "vercb", "akcomponent", "akcn", "afctrl", "avalcoll", "avectx", " avcf", "avalcontext", "afcontext", "ivctx", "varcb", "avecontext", "afloc", "avalctx", "avesci", "alctl", "ajcontext", "afxc", "afsci", "afcn", "ivcontext", "avecot", "ajcn", "avcli", "avalctl", "AVctl", "avesync", "vercmp", "versync", "verconn", "AVconn", "AVsync", "verlc", "afhw", "ajcdn", "afcf", "AVcoll", "avctl", "aircn", "avalsci", "afconfig", "verctx", "vercf", "avepkg", "verloc", "varctx", "airctx", "alcontext", "aveconfig", "alctrl", "avcdn", "avalcf", " avcmp", "evcontext", "avcf", "avallc", "avectrl", "afctx", "avecmp", "afconn", "avconn", "akcdn", "avsync", "akctx", "afsync", "afcomponent", "afcdn", "akxc", "AVcontext", "afcot", "afctl", "avctrl", "avalconfig", "avalcli", "avcoll", "alcf", "avalhw", "evctx", "varcontext", "aveloc", "avcmp", "avalpkg", "avconfig", "ajctx", "aflc", "avlc", "avalcmp", "vercontext", "avcomponent", "akpkg", "avcot", "ajcli", "avcn", "evpkg", "avalconn", "avecn", "ivpkg", "afcmp", "avcontext", "AVcmp", " avpkg", "avehw", "avloc", "aircontext", "avhw", "avalxc", "avectl", "avelc", "AVctx"], "i": ["index", "b", "ai", "li", "pi", "n", "id", "j", "info", "ip", "ix", "is", "ti", "v", "io", "p", "qi", "di", "I", "ii", "e", "c", "d", "ind", "f", "ui", "ci"], "ret": ["run", "status", "error", "err", "wait", "count", "req", "timeout", "len", "row", "r", "result", "resp", "ver", "code", "dev", "rc", "seq", "val", "event", "server", "res", "success", "re"], "version": ["depth", "date", "seed", "VERSION", "release", "parent", "error", "mode", "id", "progress", "format", "Version", "info", "patch", "feature", "position", "update", "model", "type", "trial", "serial", "sequence", "ver", "vision", "code", "stage", "channel", "package", "unit", "ersion", "scale", "block", "condition", "versions", "event", "server", "min", "grade", "qa", "install", "order", "length", "step"], "delay": ["date", "seed", "dq", "hide", "frequency", "live", "error", "mode", "del", "repeat", "wait", "progress", "timeout", "offset", "ait", "duration", "trial", "type", "rate", "sequence", "sleep", "skip", "range", "priority", "queue", "lock", "stage", "fail", "scale", "sync", "random", "diff", "pause", "load", "server", "grade", "length"], "samples_per_frame": ["samples_per_cycle", "samples_per_time", "samples_per_Frame", "samples_per_image", "samples_per_line"], "frame_factor": [" frame_duration", "frame64tier", "frame_fact", "frame_span", "wave_currency", "framealfrequency", "zone___fact", "framealtier", "frame\u00b7tier", "frame_Factor", "frame_scale", "framelexdimension", "wave_factor", "sample_frequency", "zone___span", "frame___span", "scene_tier", "frame_frequency", "zone_dimension", "frame_tier", "framelexspan", "scene_factor", "framealfactor", "framelexfactor", "frame64size", "frame___scale", "sample_factor", "scene\u00b7factor", " frame_tier", "wave_scale", "frame\u00b7fact", "frame___dimension", "scene_fact", "frame___factor", "frame_duration", "zone_span", "sample_tier", "frame64factor", "zone_fact", " frame_size", "zone___dimension", "frame___fact", "frame_dimension", "zone_factor", "frame_currency", "scene\u00b7fact", "frame\u00b7factor", "zone___factor", "framelexfact", " frame_Factor", "frame_size", "scene\u00b7tier", "frame___currency"], "edata_ptr": ["edata_pt", "edaton_rt", "edata_pert", "eddata_ptr", "edta_addr", "edata67pert", "edata67addr", "edata_dist", "edova_addr", "edataFtip", "edta_cur", "edaton67rt", "edata_rt", "edat_ptr", "edata_ref", "edina_pointers", "edata67rt", "edataFcur", "edataKpert", "edataFptr", "edada_cur", "edata_dr", "edina_ref", "edada_dist", "edada_tip", "edina_pt", "edova_pos", "edata67ptr", "edata_loc", "edata_tip", "edada_dr", "eddata_pointers", "eddata_pur", "edada_ptr", "edada_port", "eddata_dr", "edova_loc", "edata_dest", "edata_addr", "edata_tr", "edaton_pert", "edaton_ptr", "edat_tr", "edataFref", "edata_cur", "edaton67pert", "edta_ref", "edat_pos", "edada_ref", "edata_port", "edaton_addr", "edta_ptr", "edataKaddr", "edada_dest", "edaton67addr", "edina_ptr", "edova_ptr", "edata_pur", "edata_pos", "edata_tty", "edataKptr", "edata_pointers", "edataKrt", "edat_tty", "edaton67ptr"], "q": ["iq", "context", "pg", "dq", "Q", "que", "qs", "quad", "ch", "conf", "z", "j", "self", "req", "qu", "quant", "qq", "ctx", "info", "g", "qt", "cal", "v", "h", "query", "config", "queue", "p", "requ", "m", "t", "u", "w", "rc", "comment", "k", "c", "d", "f", "aq", "sq", "question", "qa", "client"]}}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 26530, "substitutes": {"opaque": ["openv", "Opacity", "OPenv", "Openv", "OPaque", "openenv", "Opec", "Opaque", "openacity", "OPec", "OPacity", "opacity", "opec", "openec", "openaque"], "addr": ["x", "context", "alias", "port", "error", "base", "inter", "slot", "ace", "ptr", "host", "coord", "alt", "amd", "dr", "attr", "asm", "conn", "ref", "src", "config", "code", "p", "arm", "grad", "address", "args", "mac", "md", "buffer", "arg", "target", "node", "point", "ea", "start", "layer", "data", "ad", "pos", "Address", "adr", "pad", "pointer", "offset"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531, "substitutes": {"a": ["x", "ai", "index", "array", "n", "aa", "aj", "alpha", "A", "aw", "z", "parent", "ca", "ac", "audio", "r", "ba", "g", "ae", "root", "sa", "l", "instance", "area", "pa", "app", "p", "m", "s", "ab", "asa", "access", "w", "mac", "an", "e", "c", "d", "f", "aaa", "i", "img", "aux", "api", "data", "am", "abc", "as"], "b": ["x", "abb", "pb", "n", "base", "A", "bc", "ca", "j", "body", "bb", "sb", "binary", "emb", "r", "ba", "rb", "bs", "bar", "g", "wb", "bi", "l", "v", "app", "p", "m", "ab", "s", "obj", "zb", "w", "e", "c", "d", "f", "i", "abc", "B", "bg", "bis", "fb"]}}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535, "substitutes": {"vs": ["js", "pg", "qs", "vm", "css", "env", "blocks", "vers", "sv", "gs", "http", "os", "rs", "ops", "vp", "VS", "verts", "fs", "bs", "ov", "obs", "ps", "points", "ts", "es", "vas", "ims", "v", "vol", "ks", "sk", "ver", "ves", "dev", "cs", "vals", "s", "args", "ports", "alls", "vr", "var", "ms", "ums", "ns", "forces", "ss", "xs", "spec", "ls", "ds", "va", "services", "versions", "views", "pos", "plugins", "iv", "Vs", "stats"], "i": ["index", "b", "x", "ai", "oi", "li", "pi", "in", "n", "ie", "ji", "z", "id", "j", "abi", "iu", "ip", "hi", "type", "gi", "bi", "l", "v", "ti", "fi", "mu", "uri", "xi", "ini", "multi", "p", "qi", "zi", "m", "di", "I", "t", "u", "ii", "k", "si", "e", "c", "d", "f", "ui", "phi", "ci", "o", "ni", "ri", "mi"]}}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538, "substitutes": {"spapr": ["spappr", "spaper", "smatr", "scapm", "spAPr", "SPapsb", "spapenr", "spatrr", "speprs", "spamppr", "scapem", "spatr", "spAPpr", "scapenr", "spapsrs", "spapb", "spAPb", "spaprr", "scapers", "spAPm", "SPapr", "spapnr", "spatpr", "spamprs", "smatrr", "spampr", "spaprs", "spAPrr", "spapm", "spapsar", "smaprr", "spAPrs", "spAPrc", "spamprr", "spatrc", "spAPar", "spapem", "spapers", "scaprs", "spepnr", "spapar", "SPapsr", "scapnr", "SPapb", "SPapsar", "SPapar", "spamprc", "spapsr", "spampb", "spAPnr", "spepm", "SPapsrs", "smaprc", "smapr", "scaper", "spepr", "SPaprs", "scapr", "spapsb", "smatpr", "spampar", "smatrc", "smappr", "spaprc"], "entry": ["index", "Entry", "ie", "key", "parent", "error", "child", "inter", "card", "keeper", "er", "connection", "end", "or", "zip", "row", "info", "enter", "try", "nt", "escape", "cell", "session", "result", "new", "reader", "inner", "cel", "parse", "route", "line", "ent", "ge", "handler", "letter", "feed", "ger", "e", "inc", "element", "archive", "extra", "import", "sec", "next", "data", "event", "server", "expected", "section", "ry", "se", "her"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n", "idx": 26540, "substitutes": {"sccb": ["scentbb", "setsccp", "scfsb", "Sucbb", "sckbc", "cscentsb", "sccabd", "Sckbc", "Suca", "sccf", " sccf", "scfbd", " scca", "Sccb", "scentb", "sckp", "scfbin", "suca", "sCCv", "srcsb", "Sccv", "sclbc", "Sccp", "Sccd", "srcb", "sucfb", "srcfb", "sucsb", "sscf", "sccl", "srcp", "Sckd", "scfbb", " sCCa", " scfa", " sCCbd", "sscp", "sckb", "sCCa", "sccafb", "Sckf", "sccv", "Sckb", "sccfb", "srcbb", "sscbc", "Sccbc", "srcf", "sccap", " sccbb", "sucf", "sckf", "scfa", " sCCf", "sCCbb", "sscb", "sckl", "csccbin", "setsccob", "sccob", "sccabb", "sCCb", "sucbd", "sccbd", "sckob", "Sccf", "sccaf", " scfbb", "scca", "sccbb", "sscd", "Sccasb", "Sucb", "sclb", "sccaa", "Sccaf", "sccab", "Sccfb", "sucv", "Scca", "srca", "sccasb", "Sccab", "cscentbin", "sclf", "sccabin", "setsccb", "sCCf", "csccbb", " sccbd", "scentsb", "scentbin", "scff", "sucb", "Sccap", "srcl", " scfb", "sccp", "sCCbd", "setsscl", "sscob", "scfb", "setsscp", "sccsb", "srcv", "sccd", "sucbb", "cscentbb", "srcob", "csccsb", "csccb", "scld", "sccbc", "Sccsb", "Sccafb", "sccbin", "setsscb", "sckd", " scfbd", "Sucv", "Sccbb", "sscl", "sucp", "cscentb", "setsccl", "setsscob", " sCCb"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n", "idx": 26543, "substitutes": {"json": ["js", "hash", "ja", "key", "value", "ji", "journal", "j", "JSON", "test", "response", "token", "build", "jack", "update", "closure", "result", "son", "parse", "pack", "nil", "javascript", "obj", "plus", "jp", "jc", "ok", "ruby", "jj", "node", "git", "txt", "module", "object", "tree", "java", "data", "api", "server", "xml", "list", "temp", "dj"], "name": ["index", "x", "alias", "n", "key", "path", "parent", "value", "id", "j", "self", "property", "none", "option", "word", "size", "type", "new", "part", "named", "inner", "package", "prefix", "names", "var", "Name", "ns", "comment", "time", "c", "str", "data", "nm", "NAME", "nice"], "val": ["x", "b", "index", "num", "sl", "key", "value", " value", "slot", "count", "func", "valid", "eval", "len", "sel", "alt", "vol", "v", "all", "ref", "part", "VAL", "p", "vals", "arr", "unit", "var", "el", "arg", "doc", "Value", "d", "pt", "f", "lit", "str", "data", "Val", "pos"]}}
{"project": "qemu", "commit_id": "e4f308bbf9f360ee2af5b94b87aef170d8f20dc4", "target": 0, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n", "idx": 26552, "substitutes": {"s": ["js", "b", "site", "sf", "n", "qs", "a", "your", "status", "sites", "conf", "sv", "S", "gs", "state", "self", "rs", "uns", "os", "j", "ssl", "sb", "stats", "fs", "r", "g", "session", "states", "ps", "new", "ts", "params", "is", "request", "service", "sis", "p", "cs", "m", "t", "args", "sym", "u", "ar", "input", "sets", "side", "su", "ns", "sg", "si", "this", "settings", "e", "sync", "c", "f", "ss", "i", "spec", "ls", "ds", "services", "o", "us", "ses", "sys"], "sci_level": ["sci_scale", "science_layer", "ci_scale", "sci_layer", " sci_vel", "sciianpass", "ci_level", " sci_lvl", "ci_lock", "sci_pass", "ci_mode", "sci_lvl", "sci_log", "sciianlog", "sci_vel", "science_pass", "science_level", "sci_lock", "sciianlevel", "science_log", "sciianlayer", "sci_mode", " sci_layer"], "pmsts": ["rpmops", "cmstrings", "cmlines", "pmstrings", "cmns", "hmsts", "PMops", " pmds", "PMstrings", " pmns", "PMsts", "PMns", "cmst", "PMds", "pmns", "fmst", " pmops", "cmrs", "rpmst", "pmops", "PMst", " pmst", "hmds", "fmstrings", "hmstrings", "pmst", "pmlines", "hmst", "rpmlines", " pmlines", "pmds", "fmrs", "pmrs", " pmstrings", "cmsts", "cmops", "fmsts", "rpmsts", " pmrs"]}}
{"project": "FFmpeg", "commit_id": "beefafda639dd53fc59c21d8a7cf8334da9a1062", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n", "idx": 26559, "substitutes": {"s": ["js", "b", "site", "its", "sf", "in", "qs", "a", "conf", "gs", "self", "source", "os", "rs", "less", "ops", "full", "ssl", "sb", "fs", "g", "session", "ps", "aws", "ing", "ts", "es", "l", "request", "is", "v", "new", "ks", "service", "ins", "p", "cs", "m", "t", "args", "sym", "u", "w", "sets", "ns", "sg", "si", "settings", "e", "sync", "c", "d", "ss", "f", "i", "ls", "ds", "spec", "xs", "services", "sq", "server", "als", "o", "ses", "support", "sys", "stats"], "crc": ["rRC", "csrc", "Cbc", "acinc", " cbc", "Crs", "Crc", "cinc", " cfc", "crs", "acrc", "acdc", "ncrc", " crs", "acRC", "ncfc", "CRC", "rdc", " csrc", "acbc", " cdc", " cRC", "cRC", "cbc", "rinc", "ncRC", "ncsrc", "acsrc", "acfc", "cfc", "rrc", "acrs", "cdc", " cinc"], "S": ["SH", "V", "Q", "SR", "Y", "AS", "A", "D", "N", "Source", "TS", "SP", "W", "X", "CS", "RS", "Set", "L", "G", "U", "DS", "M", "Socket", "R", "SN", "K", "WS", "O", "I", "F", "P", "Si", "C", "SS", "PS", "String", "NS", "ss", "SA", "SB", "H", "SI", "SE", "T", "SC", "Sa", "B"], "bit": ["x", "b", "num", "set", "key", "BIT", "quad", "base", "value", "bc", "id", "byte", "slot", "ac", "bits", "tag", "binary", "option", "op", "word", "bar", "ix", "type", "character", "no", "fix", "off", "null", "version", "pass", "unit", "it", "bug", "ct", "comp", "block", "pixel", "f", "i", "sec", "component", "second", "gap", "Bit", "back", "mask", "flag", "digit", "sign", "bin", "offset"]}}
{"project": "FFmpeg", "commit_id": "42f9132218ca11a8e9a3c82a175b46bca092113e", "target": 0, "func": "static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n    MXFContext* mxf = s->priv_data;\n\n    int64_t seekpos;\n\n    int ret;\n\n    MXFIndexTable *t;\n\n\n\n    if (mxf->nb_index_tables <= 0) {\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n\n\n    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)\n\n        return ret;\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    mxf->current_edit_unit = sample_time;\n\n    } else {\n\n        t = &mxf->index_tables[0];\n\n\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n\n         * this also means we allow seeking before the start */\n\n        sample_time = FFMAX(sample_time, 0);\n\n\n\n        if (t->fake_index) {\n\n            /* behave as if we have a proper index */\n\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n\n                return sample_time;\n\n        } else {\n\n            /* no IndexEntryArray (one or more CBR segments)\n\n             * make sure we don't seek past the end */\n\n            sample_time = FFMIN(sample_time, st->duration - 1);\n\n        }\n\n\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)\n\n            return ret;\n\n\n\n        ff_update_cur_dts(s, st, sample_time);\n\n        mxf->current_edit_unit = sample_time;\n\n        avio_seek(s->pb, seekpos, SEEK_SET);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26568, "substitutes": {"s": ["js", "b", "sc", "com", "S", "rs", "ssl", "sb", "fs", "g", "states", "p", "ic", "u", "sets", "si", "sync", "xs", "sq", "sn", "n", "qs", "set", "conf", "gs", "space", "aws", "es", "l", "ks", "service", "cs", "su", "e", "c", "ss", "spec", "stat", "site", "sf", "self", "ops", "session", "ts", "sa", "is", "y", "m", "sym", "w", "sg", "f", "ds", "server", "ses", "sys", "sl", "sv", "http", "os", "r", "storage", "v", "ins", "ns", "d", "i", "ls", "services", "us", "se", "support"], "stream_index": [" stream_base", "transform_thread", "streamlexindex", "stream_base", "transform_prefix", "streamlexint", "streamingticket", "streamlexbase", "stream_ticket", " stream_int", "stream_thread", "transform_index", "transform_ticket", "stream_prefix", "stream_int", "streamingindex", "streamingprefix", "streamingthread"], "sample_time": ["sample_value", "Sample_time", "sampleLtime", "sampleacinfo", "samplexlength", "sampleptime", "samplexhost", "sampleacyear", "sample\u00b7delay", "sample2ime", "site_time", " sample_term", " sample_length", " sample_host", "ample_TIME", "sample_distance", "samplextime", "server_money", "sample_term", "samplextimes", "sample_name", "sample_times", "server_times", "sample2times", "samplepspeed", "sample2time", "Sample_price", " sample_times", "sample_volume", "sample___time", "ample_money", "sea_time", "samplexval", " sample_Time", "servicealtim", "sea_distance", "sample___times", "sampleLtz", "samplextimer", "Sample_times", "sampleLtimes", " sample_money", "sample\u00b7time", "service_tim", "sample_length", "sea_times", "sample_price", "site_rule", "sample_delay", "ample_cost", "servicealtime", "site_rate", "sample_timer", "site_volume", "server_ime", "sampleLdistance", "samplexTime", "samplealmode", "ample_time", "sample_info", "samplealtime", " sample_value", " sample_val", "sample67time", "samplealvalue", " sample_cost", "sampleacTIME", "samplealrate", "sample_year", "sample_rule", "servicealmode", "sample67times", "samplealterm", "service_mode", "sample_val", "sample_Time", "server_date", "samplexspeed", "sample_TIME", " sample_ime", "ample_times", "sample_ime", "sample_host", "samplealtim", "sample_memory", "sea_tz", "samplepTime", "ample_year", "ample_timer", "ample_delay", "sample_rate", "service_rate", "sample_cost", "sample_date", "ample_info", "server_name", "sample_money", "sample_tim", "site_name", "sample___price", "sample67rule", "samplephost", "sample\u00b7times", "sample67volume", "Sample_money", "sampleactime", " sample_speed", "sample_tz", "ample_tim", "sample_speed", "sample2name", "ample_name", "service_time", " sample_timer", "site_memory", "site_times", "servicealrate", " sample_volume", "samplexvolume", "server_time", "sample___money", "sample_mode"], "flags": ["items", "ips", "lag", "sf", "details", "orts", "fo", "bits", "format", "bytes", "ops", "Flags", "faces", "fs", "fps", "ags", "reports", "fields", "reads", "fts", "options", "windows", " Flags", "files", "vals", "ints", "features", "lf", "args", "properties", "fun", "utils", "settings", "types", "frames", "mask", "flag", "ff", "xml", "FLAG", "stats", "ants", "mods"], "st": ["sd", "sf", "n", "sl", "set", "dt", "ut", "ost", "sc", "mt", "sv", "std", "stop", "sth", "end", "sb", "sp", "r", "nt", "sts", "tt", "St", "ts", "sa", "l", "v", "sk", "src", "sta", "p", "rest", "tmp", "m", "stage", "ste", "inst", "stable", "w", "ct", "db", "e", "c", "sync", "start", "d", "ss", "pt", "lc", "td", "ST", "ds", "str", "stat", "data", "sn", "sw", "en", "se", "step"], "seconds": ["flows", "sections", "hours", "sf", "ips", " positions", "abytes", "sites", "outs", "cuts", "timeout", "bytes", "objects", "sid", "sb", "ops", "fee", "fps", "letters", "resses", "ones", "obs", "forms", "states", "years", "scripts", "sleep", "months", "files", "strings", " second", "codes", "times", "charges", " bytes", "sets", "ms", "elt", "lines", "utils", "settings", "sent", "seq", "eps", "sec", "frames", "second", "values", "services", "steps"], "mxf": ["pmxf", "nxc", "pmxb", "pfe", "mfc", "tmfe", "mfx", " mxe", "gxd", "mmcf", "tmxd", " mfe", "nxf", "pxd", " mxc", "Mxd", "pxf", " mfc", "mxc", "mxb", "ncf", "mxd", "pcf", " mxd", "pmfc", "tmcf", "Mcf", "Mfx", "gxf", "gxc", "mmxd", " mxb", "mxe", "mcf", "gcf", "nfx", "mmxc", " mcf", "pxe", "Mxc", "Mfc", "pfc", "mmxf", "Mxb", "mfe", "tmxf", "pmcf", "Mxf", "Mxe", " mfx"], "seekpos": [" seeklen", " seekPOS", "seeklen", "offsetpos", "ekPOS", "givepos", "feedPos", "offsetlen", "boardpos", "ekPos", "boardPos", "ekpos", "seekPOS", "boardPOS", "seekPos", "ekpo", "feedpos", "givepre", "seekpre", "eklen", "feedpo", "ekpre", "offsetposition", " seekPos", "boardlen", "seekposition", "offsetPos", "givepo", " seekposition", "seekpo", "givePos", "ekposition", "feedpre"], "ret": ["reset", "opt", "run", "ut", "error", "base", "reply", "err", "id", "RET", "value", "let", "len", "red", "info", "nt", "result", "alt", "resp", "det", "mem", "url", "ref", "al", "rev", "rets", "pass", "code", "arr", "bad", "match", "obj", "fail", "def", "rc", "fun", "it", "att", "db", "runs", "arg", "rt", "f", "sec", "lit", "af", "bf", "val", "rep", "pet", "replace", "fe", "Ret", "reg", " result", "res", "flag", "back", "en", "out", "success", "re", "art", "fit"], "t": ["x", "b", "ant", "port", "tool", "ot", "et", "n", "ut", "dt", "wt", "tm", "mt", "z", "j", "tz", "the", "tf", "ta", "r", "nt", "tt", "g", "qt", "type", "ts", "l", "template", "v", "y", "bt", "h", "p", "m", "tc", "table", "it", "ct", "att", "rt", "e", "c", "pt", "d", "f", "i", "tn", "tree", "tw", "T", "o", "te", "tp", "unt", "at"]}}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587, "substitutes": {"ifm": [" ifn", "ifh", "incr", "formc", "tifmt", "fortm", "ifmc", "itcm", "endifmt", " ifmi", "ilcm", " iffm", "itgm", "tifcm", "actcm", " ifh", " ifmn", "itmi", "fdm", "iff", "Ifcm", "iffp", "defym", "ifdm", "ity", "itl", "elp", " ifmt", "ifnm", "notp", "ff", "idgm", "Ifmn", "itw", "IfM", "ily", "afcm", "evp", "afp", "opcm", "iffl", "iffmi", "opmt", "incmt", "ifw", "fp", "afmt", "defm", " ifbm", "actr", "iffbm", "frm", "notm", " ifym", "fm", "ifp", "Ifm", "ittm", "Ifbm", "ifc", "idf", "fcm", "ifmt", "afm", "ifrm", "IFm", "tifp", "eld", "endifcm", "ifcm", "itrm", "notcm", "eldm", "notmt", "opp", "iffc", "IFp", " iftm", "ilrm", "IFl", "fc", "ifl", "fnm", "tifm", "ifn", "fh", "actl", "iterm", " ifdm", "actw", "confmn", "actmt", "confm", "itfm", "itn", "ifbm", "actmm", "iffdm", "idm", "itp", "iffh", "iffd", "idc", "IFmt", "iffcm", "ofcm", "ifffm", "iffm", " ifcm", "actm", "evm", " ifl", "ifr", "form", "itercm", " ifr", "evM", "iffrm", "iltm", "defmn", "Ifp", "iterw", "afdm", "itf", "elrm", "incm", "forn", " ifmc", "itm", "evmn", "ifd", "fgm", " ifM", "incmm", "ifmm", "ild", "oftm", " ifd", "Ifn", "itc", "ifmn", "iffnm", "iftm", " ifrm", "itmc", "ifgm", "confcm", "iterl", "Ifmt", "endifm", "elcm", "iffn", "defcm", "endifn", "ofm", "confym", "ifmi", "ify", " ifmm", "ilm", "ifM", " ifnm", " ifp", "afd", "elm", "opm", "IFcm", "ofy", "ifym"], "ifqt": [" ifvt", "Ifq", "ifkt", "lifkt", " ifcit", "afiq", "Ifqt", " ifqq", "lifqt", "ifvt", "ifcit", "tifvt", "fiqq", "fiwx", "incqq", "lifvt", "Ifkt", "lifwx", "tifkt", "inkt", "fiqt", "afiqt", "incvt", "fivt", "fqq", "ifwx", "fikt", "fitk", "fkt", " ifq", "afiqq", "inq", "fqt", "fq", "ifqq", "tifqt", "inqt", "ifq", "incqt", "Ifqq", "inqq", "aficit", "fcit", " iftk", "tifwx", "inctk", "iftk"], "slirp": ["shierpc", "ellirtcp", "shierr", "collirp", "slierg", " slirr", "selirp", "spliarpa", "slirepe", "sliperpc", "sliperp", "ellircp", "collirob", "spliropo", "splirpc", "Slirr", "splirpa", "selyrpi", "slirob", "slireg", "slierpatch", "slirping", "slriscp", "slrip", "spliarpc", "slurp", "spliropc", "slarig", "selirpc", "Sloirpe", "skirip", "ellirp", "slyrp", "slirtl", "sliror", "lairpc", "sliropi", "lairv", "shirg", "collirper", "lairlv", "elirp", "slirper", "slirope", "shirr", "skirpc", "slpirv", "slirg", "shirpc", "blirpc", "slaripc", "selirpi", "quairpc", "slierpc", "slirlv", "slireP", "Slirpe", "sliroper", "slirlb", "slrisp", "blierpc", "sliarpc", "slrispi", "sladrp", "slirepa", "collirop", "slirl", "slyrpad", "slierping", "sloirp", "Slirp", "slirtr", "sliarp", "quairp", "slyrpc", "colliroper", "selyrp", "selirpa", "sladrr", "lairp", "skirib", "slaripi", "slircp", " slircp", "quirpc", "sliverp", "blierpre", "sliverpa", "slirP", "sliripad", "sliarl", "slirlf", "collirb", "sliarpe", "lairf", "shirp", "Sloirr", "slripc", "slurpre", " sliror", "slirpc", "slierp", "splirop", "slirep", "shierp", "quirp", "slirepre", "slripa", "slireping", "slurr", " slirocp", "slirpi", "slirecp", "slierl", "elierr", "slyrpa", "sladrcp", "ellirtpa", "shierg", "shierl", "sliripe", "slirer", "splirl", "slirtf", "sliropa", "elierpc", "sliarpad", "sliropc", "slirpatch", "slirocp", "slierr", "slurpc", "slrisping", "sliropad", "selyrpa", "slirlpatch", "lairlpc", "slirpa", "slirtP", " sliroP", "quirr", "splirpo", "slyrpe", "slirtpa", "quirpa", "slpirpc", "slirop", "slarip", "slricp", "slirpo", "shierpi", "sloirr", "slwerl", "slyrpo", "elierp", "slirf", "slairp", "slairpc", "slrispad", "spliarpad", "sliverpc", "sliripc", "elierping", "ellirpc", "slirpe", "sliperpe", "slpirf", "splirp", "slrispc", "sliripatch", "Slircp", "slirlpc", "slirpre", "slwerpa", "blirpre", "slirr", "slierpi", "slirtv", "slirib", "splirpad", "shirl", "sliperpad", "skiripatch", "slirlp", "collirope", "slwerp", "splirpe", "spliarl", "elirpc", "slirpad", "spliarp", "sliverr", "slairr", "spliropad", "quairpa", "elirping", "ellirtp", "slairpa", "blierp", " slirP", "slirlpi", "slierpre", "elirr", "slpirp", "slyrpi", "slirtpc", "slwerpc", "blirr", "slyrb", " slirop", "slrisr", "sliroP", "spliarpe", "Sloirp", "slirip", "slirtcp", "sloirper", "Sloircp", "blirp", "slirlg", "collirpe", "ellirtpc", "slirv", "slirb", "quairr", "slirtp", "slyrper", "skirpatch", "skirb", "sliarpa", "selyrpc", "sliropo", "skiripc", "blierr", "sloircp", "sloirpe", "slrispa", "slirtg", "sladrpe", "slirel", "ellirpa", "skirp", "slrispo", "slierb", "lairlp", "shirpi", "slirepc", "sloirb", "lairlf"], "if_queued": ["if_queueued", "ifallquemented", "if_continued", "if_quesued", "if_continUE", "if_queueless", "if_que", "if_queueUE", "if_quemented", "if_queUE", "if_queue", "if_queueumed", "if_qaue", "if_qauing", "if_Queued", "if_QueUE", "if_continmented", "ifallqueued", "if_continue", "if_qaued", "ifallcontinue", "ifallcontinmented", "if_queueuing", "if_quesue", "if_quesumed", "if_Quemented", "if_Queumed", "if_queues", "if_clue", "if_clued", "if_queueues", "if_cluing", "ifallqueUE", "ifallcontinUE", "ifallcontinued", "if_Queuing", "if_queuemented", "if_qaueless", "if_quesuing", "if_queueue", "if_queuing", "if_Queue", "if_queueueless", "if_queumed", "if_ques", "if_clueless", "ifallqueue", "if_quing", "if_qued"], "ifq_so": ["ifq__co", "ifp_gone", "ifc_since", "ifp_since", "ifq_while", "ifc_co", "ifp_while", "ifc_so", "ifq_since", "ifq_gone", "ifp_next", "ifq_next", "ifp_lo", "ifp_co", "ifq_lo", "ifq__since", "ifq__so", "ifq_co", "ifp_so"], "so_queued": ["so_quued", "so_queueued", "so_queueue", "so_quurized", "so_scheued", "so_scheues", "so_quues", "so_queueues", "so_queues", "so_queueurized", "so_queurized", "so_quue", "so_scheurized", "so_scheue", "so_queue"], "requeued": ["requmed", "requeused", "refpeuated", "reequeues", "requued", "refqueued", "requuer", "repeuer", "requured", "repeumed", "reequed", "requing", "reequeused", "replmented", "replued", "requed", "reequeued", "remqueued", "reQueused", "requeuing", "remqueuer", "reQueues", "remquured", "remquuer", "repeured", "repeued", "requeured", "requuing", "refqueuated", "reQueuing", "reques", "repeues", "reeques", "refpemented", "reeqused", "refpeumed", "reqused", "requemented", "remqueuing", "remqueured", "requeuer", "requeues", "repluated", "requer", "requeuated", "repeuing", "replumed", "reqmented", "refqueumed", "reQueued", "requred", "requeumed", "repemented", "remquued", "reequeuing", "requated", "refquemented", "refpeued", "repeuated", "remquuing", "repeused", "reequing"]}}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595, "substitutes": {"check": ["num", "set", "key", "by", "error", "search", "id", "project", "rule", "http", "req", "valid", "end", "lib", "test", "control", "ack", "task", "full", "create", "pull", "Check", "info", "add", "update", "ck", "cache", "flow", "type", "build", "common", "get", "work", "fix", "walk", "y", "checking", "off", "query", "cross", "config", "scan", "parse", "pass", "code", "draw", "lock", "pack", "complete", "read", "fail", "match", "now", "clean", "comp", "comment", "checked", "view", "file", "process", "block", "sync", "exec", "start", "ok", "checks", "diff", "load", "call", "name", "post"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n", "idx": 26599, "substitutes": {"STATUS_PARAM": ["STATUS_PARB", "STATUS_KB", "STATUS_PAME", "STATUS_PARAR", "STATUS_PB", "STATUS_KAR", "STATUS_KAM", "STATUS_PAM", "STATUS_VB", "STATUS_VAR", "STATUS_VAM", "STATUS_PARAME", "STATUS_VAME", "STATUS_KAME", "STATUS_PAR"], "zSign": [" zExp", " zRound", " zsign", "tsign", "ZSign", "ZRound", "yMod", " zValue", "ZStep", "zExp", "zSize", "yRound", "zValue", "ySign", "zStep", "ziSign", "ziStep", "gzExp", "gzsign", "tRound", "ZSize", " zSize", "zMod", "zisign", "ZMod", "gzValue", "zRound", " zStep", "Zsign", "zsign", "tSize", "tSign", " zMod", "ZValue", "gzSign", "ZExp"]}}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620, "substitutes": {"intp": ["indp", "indc", "intc", "indpo", "indP", "ippi", "bitpi", "incp", "ircp", "irpo", "ippa", "bitc", "ipc", "inccp", "indpa", "incpo", "indpi", "incP", "ipp", "intP", "irp", "intpa", "intcp", "bitpa", "intpi", "intpo", "bitp", "irP", "indcp"], "ret": ["last", "ext", "et", "ut", "reply", "base", "mt", "RET", "j", "std", "valid", "len", "red", "gt", "nt", "fin", "alt", "result", "det", "ref", "part", "py", "line", "ft", "obj", "match", "rc", "fun", "db", "arg", "active", "rt", "lit", "bf", "str", "val", "data", "cat", "pet", "back", "Ret", "reg", "res", "flag", "pat", "art", "re", "fire", "fit"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642, "substitutes": {"s": ["js", "b", "sf", "in", "n", "qs", "a", "sv", "S", "gs", "ions", "os", "rs", "uns", "ops", "ssl", "gets", "fs", "r", "bs", "g", "ps", "aws", "new", "ts", "es", "is", "l", "v", "h", "ks", "service", "ins", "tests", "cs", "m", "sym", "args", "t", "w", "sets", "ns", "sg", "si", "e", "sync", "c", "d", "ss", "f", "i", "ls", "ds", "data", "services", "sq", "o", "comments", "se", "ses", "sys", "as"], "p": ["b", "pb", "temp", "pi", "n", "a", "j", "cp", "vp", "sp", "op", "ip", "g", "ps", "pp", "l", "fp", "v", "pe", "part", "at", "m", "ap", "t", "P", "u", "po", "jp", "k", "e", "point", "c", "bp", "d", "i", "pc", "f", "data", "np", "pr", "o", "tp", "lp", "pointer", "post", "pa"]}}
{"project": "qemu", "commit_id": "1453e6627d19a8d6d54480c6980f5cef5dfc6833", "target": 0, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n", "idx": 26653, "substitutes": {"errp": ["errps", " errP", "errorc", " errpre", "errproc", "erproc", " errproc", "Erc", "errorps", "errc", "errorpre", "Erpre", "erp", " errc", "errorp", "errpre", "ErP", " errps", "errP", "errorproc", "errorP", "Erp", "erps", "erP"], "cs": ["css", "qs", "sc", "vs", "bc", "ca", "nc", "gs", "ac", "cc", "rs", "cms", "os", "Cs", "ctx", "CS", "cus", "fs", "mc", "cache", "ck", "ics", "ps", "cks", "cas", "ks", "ce", "cf", "sk", "codes", "cells", "tc", "core", "cn", "acs", "rc", "ns", "sync", "c", "cons", "ec", "pc", "lc", "ls", "ds", "spec", "ci"], "cpu": ["bench", "gp", "fc", "vm", "uca", "css", "proxy", "bc", "pu", "ca", "nc", "proc", "cp", "hw", "ctx", "cus", "fps", "gc", "cache", "coe", "px", "nic", "boot", "auc", "conn", "gpu", "roc", "computer", "processor", "core", "uci", "colo", "cn", "cm", "console", "uno", "sync", "c", "clock", "CPU", "pc", "lc", "GPU", "cow", "cli", "cu", "ci", "np", " CPU", "phy"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n", "idx": 26663, "substitutes": {"l2hdr": ["l1phrc", "l2hhrc", "l2phstr", "l3hgt", "l3hst", "l2hgt", "l2frc", "l2fst", "l2phgt", "l2fdr", "l2hdgt", "l2phdr", "l2hstr", "l1phstr", "l3fgt", "l2hhstr", "l2phst", "l2fstr", "l3fdr", "l3hdr", "l1hst", "l3frc", "l1hdr", "l1phdr", "l2hrc", "l2phrc", "l1hstr", "l2hdrc", "l2hst", "l3hrc", "l2hhdr", "l2hddr", "l2fgt", "l2hhst", "l1phst", "l2hdst", "l3fst", "l1hrc"], "iphdr": ["lipder", "ipdi", "apterder", "liprh", "ophrid", "ephrh", "elfder", "ophdi", "efrid", "aphrr", "ephdr", "iprid", "ophrt", "iphrid", "hipdc", "elfrr", "ipdr", "ephdc", "ephder", "aphdc", "ephhr", "iphrh", "iprt", "ophdr", "liphr", "efdr", "iphhr", "efdi", "iphdi", "aphdr", "iphrt", "apterhr", "iphrr", "elfdr", "efrt", "iphdc", "ephrr", "hipdr", "elfrh", "lipdr", "elfhr", "apterrr", "iphder", "apterdr", "hiprr"], "new_ip_off": ["new_ip67low", "new_address_on", "new_ipacon", "new_ip_no", "new_ipaclow", "new_ipfoff", "new_ip_on", "new_ipflen", "new_ip_offset", "new_ipfoffset", "new_ipacoffs", "new_ip67on", "new_ip67off", "new_ip_len", "new_address_low", "new_ipacoff", "new_ip67offs", "new_ipfon", "new_ip__off", "new_ip__on", "new_ip_offs", "new_ip_low", "new_address_offs", "new_address_off", "new_ip__no", "new_ip__offs"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 26671, "substitutes": {"a": ["x", "n", "aa", "alpha", "A", "da", "ca", "ac", "ia", "window", "ba", "ama", "ae", "sa", "la", "ata", "area", "pa", "app", "p", "ab", "s", "active", "an", "c", "d", "f", "i", "aaa", "aux", "api", "va", "data", "ad", "mA", "ga", "as"], "b": ["x", "pb", "aa", "base", "nb", "bb", "sb", "emb", "r", "ba", "bs", "rb", "bar", "wb", "bi", "v", "y", "be", "beta", "bd", "p", "gb", "ab", "mb", "eb", "db", "e", "c", "bp", "d", "f", "i", "bf", "lb", "B", "bis", "fb"], "env": ["scope", "context", "chal", "dict", "conf", "energy", "err", "state", "eu", "environment", "eval", "loader", "v", "conn", "style", "enc", "erv", "config", "p", "ee", "exc", "args", "ev", "console", "el", "db", "ef", "txt", "e", "exec", "eng", "ea", "c", "ec", "ep", "data", "np", "iv", "en"]}}
{"project": "qemu", "commit_id": "c6a6a5e3bb7120e1eb33eca6364a290229c1e72e", "target": 0, "func": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n", "idx": 26673, "substitutes": {"bsum": ["bscan", "bssum", "bsul", "bsub", "sssum", "dssum", "besum", "besub", "ssuc", "psum", "astsam", "dsuc", "BSum", "bsums", "basumm", "issul", "astsub", "lssum", "dsums", "dsum", "pscan", "astsum", "bascan", "besumm", "astsumm", "BSums", "basum", "BSsum", "bsumm", "lsumm", "alsum", "lsam", "lsub", "alsumm", "besuc", "psumm", "pssum", "lsum", "ssums", "alsuc", "bsam", "issum", "besul", "issuc", "issumm", "BSuc", "ssum", "lscan", "bassum", "alsul", "besam", "bsuc"], "i": ["x", "index", "ai", "b", "li", "pi", "n", "id", "j", "iu", "ip", "g", "ix", "bi", "l", "ti", "h", "mu", "v", "y", "xi", "ini", "p", "qi", "zi", "m", "di", "I", "t", "u", "ii", "k", "si", "e", "c", "d", "start", "f", "ind", "eni", "diff", "ami", "phi", "ci", "ni", "mi"], "sum": ["Sum", "b", "index", "num", "weight", "hash", "n", "a", "aa", "alpha", "value", "cmp", "count", "ac", "fat", "summary", "sh", "fee", "sp", "info", "total", "ass", "g", "cache", "size", "add", "cash", "max", "result", "vol", "mem", "sa", "miss", "all", "cost", "dot", "average", "h", "parse", "pass", "match", "cur", "u", "ame", "su", "comment", "scale", "gram", "si", "um", "mean", "gam", "not", "na", "ss", "am", "min", "ad", "out", "mask", "ash", "sha", "sign", "name", "se", "length", "bin"]}}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n", "idx": 26680, "substitutes": {"dev": ["dist", "mod", "dc", "conf", "err", "id", "debug", "der", "req", "od", "test", "rad", "private", "dom", "serial", "gd", "raw", "conn", "priv", "tr", "ver", "grad", "dm", "devices", "def", "pro", "ev", "de", "device", "init", "Dev", "md", "pub", "var", "di", "dd", "d", "stable", "sim", "diff", "ds", "data", "adv", " devs", "ad", "reg", "development", "dem", " device"], "errp": ["rypc", "rrps", "errps", " errP", "erc", "err", "nerp", "ryp", "ryps", "errc", "erp", " errc", "rrr", "rrp", "nerps", "erpc", " errps", "errP", "nerc", "errpc", "errr", "ryr", "rrpc", "erps", "nerP", "erP"], "ics": ["js", "IC", "items", "its", "ips", "ents", "icks", "dc", "qs", "css", "comm", "events", "self", "bits", "ico", "inf", "ops", "ices", "igs", "fs", "cus", "bs", "g", "ix", "states", "px", "nic", "is", "ims", "ks", "rys", "ins", "cases", "icc", "codes", "ic", "cs", "ik", "cells", "devices", "args", "acs", "ex", "irc", "cfg", "rics", "ms", "ats", "ns", "init", "cycles", "ICS", "cons", "xs", "ec", "ls", "ds", "ci", "pic", "plugins", "uses", "icons", "stats", "ars", "sys"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n", "idx": 26701, "substitutes": {"vs": ["icks", "qs", "env", "sv", "state", "gs", "flags", "rs", "os", "ops", "vp", "VS", "vt", "fs", "otes", "bs", "sts", "obs", "ps", "cv", "vas", "es", "v", "ks", "hs", "vc", "ves", "vals", "cs", "asts", "alls", "ums", "ns", "forces", "sync", "eps", "ss", "xs", "ls", "ds", "va", "services", "stats"]}}
{"project": "qemu", "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b", "target": 0, "func": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n", "idx": 26711, "substitutes": {"sch": ["sd", "sf", "sr", "sl", "css", "ch", "soc", "sc", "conf", "gh", "cp", "chn", "chid", "sem", "zh", "cy", "ctr", "ssl", "sh", "sb", "shop", "sp", "ocr", "ich", "cer", "inch", "psych", "conn", "cht", "sk", "service", "icc", "chy", "sm", "sche", "gb", "sky", "cs", "cr", "kh", "Sch", "si", "osh", "c", "ss", "kr", "spec", "sn", "osc", "usc", "se", "her"], "orb": ["obo", "abb", "arb", "orbit", "rob", "http", "iol", "or", "oret", "amber", "rb", "ocr", "obs", "urb", "erb", "ib", "obb", "rub", "xb", "gb", "atom", "om", "ub", "ab", "zb", "ogg", "ur", "eb", "ore", "orf", "ori", "orn", "orc", "umb", "usb", "gob", "osc", "org", "ob"], "s": ["b", "sf", "sl", "sc", "conf", "state", "S", "gs", "self", "sv", "rs", "space", "ssl", "sb", "sh", "sp", "g", "session", "is", "l", "sa", "service", "sis", "p", "sym", "t", "south", "w", "u", "su", "ns", "sg", "si", "sie", "sup", "c", "sync", "f", "i", "spec", "ls", "ds", "services", "sq", "o", "se", "ses", "sys"]}}
{"project": "qemu", "commit_id": "e25cad6921ef78c8e2b7a4f59b03545bd675a9ad", "target": 1, "func": "static int sd_snapshot_delete(BlockDriverState *bs,\n\n                              const char *snapshot_id,\n\n                              const char *name,\n\n                              Error **errp)\n\n{\n\n    unsigned long snap_id = 0;\n\n    char snap_tag[SD_MAX_VDI_TAG_LEN];\n\n    Error *local_err = NULL;\n\n    int fd, ret;\n\n    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;\n\n    uint32_t vid;\n\n    SheepdogVdiReq hdr = {\n\n        .opcode = SD_OP_DEL_VDI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 26725, "substitutes": {"bs": ["b", "bm", "bl", "pb", "Bs", "base", "vs", "bc", "bh", "rs", "os", "bb", "ops", "sb", "bos", "fs", "obs", "rb", "ps", "ts", "bi", "bt", "bps", "las", "ins", "gb", "cs", "iss", "ms", "ns", "BS", "ss", "ls", "ds", "lb", "ses", "bis"], "snapshot_id": ["snapshotPname", "snapshot_ID", "snapshot_name", "snapshot_Id", "snapshotPID", "snapshotPlength", "snapshot_ad", "snapshot_ids", "snapshot_type", "snapshot_length", "snapshotPid", "snapshot_tag"], "name": ["alias", "key", "path", "parent", "home", "search", "base", "id", "description", "filename", "space", "text", "connection", "tag", "info", "host", "image", "group", "size", "type", "secret", "resource", "url", "config", "version", "label", "nam", "package", "prefix", "table", "names", "ame", "Name", "comment", "domain", "desc", "time", "file", "block", "object", "data", "meta", "client", "NAME", "memory"], "errp": [" errpat", "rarfp", "errorjp", " errjp", "err", " errP", " errfp", "errpat", "erjp", "rarr", "errfp", "erp", "errorp", "rarpat", "erfp", " errr", "errP", "errorP", "errorr", "errr", "errjp", "rarp", "erpat", "erP"], "snap_tag": ["Snap_desc", "snap67product", "block_id", "snaplextag", "snaplexdesc", "snap_date", "snaplogid", "snap_id", "snapntag", "snap2tag", "snap2id", "snaplexat", "block_field", "snap___id", "snap_sum", "snap64name", "jump67product", "capt_name", "snapJtag", "snaplogsum", "jump_id", "snap67id", "snap_at", "Snap_log", "snap_desc", "Snap_length", "snap64tag", "snapnid", "jump67tag", "snap_field", "snap_product", "capt_id", "Snap_sum", "snap_name", "snapnlog", "jump_tag", "snap64field", "capt_doc", "snap_log", "snapJfield", "snap_doc", "Snap_tag", "capt64id", "snapJid", "capt64name", "snap64id", "snap___name", "Snap_id", "snaplexid", "block_length", "block_tag", "snaplogtag", "capt64tag", "capt_tag", "snap_bug", "jump_bug", "Snap_Tag", "snapJlength", "snap67bug", "snap64doc", "capt64doc", "snap2Tag", "jump_product", "snap___tag", "snapnsum", "snaploglog", "snap67tag", "snap64length", "snap___doc", "jump67bug", "snap_length", "snap_Tag", "jump67id", "Snap_at", "Snap_date"], "local_err": ["local2errors", "foreign_err", "locxerrors", "local_iter", "localingstatus", "localxerr", "localamerr", "localxerrors", "foreign_cb", "foreignamer", "foreign_er", "localingerr", "loc_err", "foreign_error", "remote_er", "localinger", "locxerr", "foreignamerror", "localiferrors", "loc_code", "remote_iter", "foreignamcb", "remote_status", "local_status", "local_cb", "localamerror", "localiferr", "localamer", "loc_errors", "local_er", "local_ver", "localamcb", "local2err", "localxcode", "remote_err", "local_error", "local2ver", "localifver", "foreignamerr", "locxver", "locxcode", "local_errors", "local2code", "loc_ver", "localifcode", "localingiter", "local_code", "localxver"], "fd": ["dir", "fc", "dc", "dt", "df", "da", "fat", "req", "len", "fs", "fb", "fin", "result", "resp", "fp", "fi", "conn", "ref", "bd", "FD", "def", "rc", "md", "vd", "db", " resp", "fn", "dd", "d", "vir", " ff", "f", "cb", "ds", "bf", "val", "dl", "fa", "wat", "fe", "ff", "nd", " fid", "fl"], "ret": ["num", "et", "reply", "err", "mt", "RET", "id", "count", "fat", "let", "len", "vt", "nt", "fin", "en", "result", "alt", "resp", "det", "mem", "no", "conn", "ref", "part", "rev", "rets", "ben", "pass", "ft", "match", "pub", "def", "rc", "fun", "ur", "att", "feat", "db", "arg", "rt", "f", "lit", "bf", "val", "pet", "cat", "out", "Ret", "reg", "res", "flag", "sil", "bit", "back", "pat", "success", "re", "ext"], "buf": ["cap", "b", "port", "bm", "box", "pb", "array", "prop", "grab", "nat", "bc", "vec", "proc", "ctx", "begin", "ptr", "window", "fb", "ba", "rb", "pkg", "wb", "cv", "br", "Buffer", "cas", "fp", "fi", "src", "bd", "pool", "config", "null", "batch", "queue", "alloc", "tmp", "conv", "ab", "cur", "BU", "rc", "buffer", "fun", "bed", "feat", "desc", "loc", "block", "bag", "seq", "uc", "img", "cb", "data", "uf", "map", "dest", "ff", "pad", "fl", "buff"], "s": ["js", "b", "site", "n", "sl", "qs", "vs", "state", "S", "gs", "sv", "self", "os", "sb", "ssl", "fs", "storage", "g", "session", "states", "ps", "ts", "sa", "is", "ks", "src", "service", "sis", "spot", "p", "cs", "t", "sets", "su", "ns", "sg", "si", "bis", "settings", "sie", "e", "c", "sync", "d", "f", "ss", "spec", "ls", "ds", "services", "sq", "sn", "server", "us", "ses", "sys", "stats"], "vid": ["mid", "dc", "live", "vec", "id", "nc", "format", "aud", "sid", "len", "vt", "nt", "ip", "host", "dr", "gd", "v", "pid", "ref", "ver", "rev", "version", "vc", "tmp", "dev", "vert", "vr", "virt", "rc", "var", "vd", "db", "virtual", "uid", "seq", "lit", "val", "cat", "vis", "nd"], "rsp": ["rtr", "Rpar", "Rsp", "Rtr", "grsc", "Rsc", "rpar", "rsc", "irtr", "irpar", "grpar", "irsp", "grsp", "irsc", "grtr"]}}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726, "substitutes": {"f": ["x", "b", "fw", "fc", "sf", "rf", "df", "fo", "inf", "tf", "fd", "fs", "info", "g", "fac", "l", "fp", "v", "fi", "ref", "cf", "p", "fr", "m", "t", "F", "lf", "fm", "xf", "k", "this", "file", "e", "elf", "c", "fn", "d", "af", "i", "bf", "fore", "fa", "uf", "fx", "fen", "fe", "o", "ff", "form", "fb"], "opaque": ["OPcodes", " opalloc", "operalloc", "opalloc", "opercodes", " opacity", " opcodes", "OPaque", "operaque", "operacity", "OPacity", "OPalloc", "opcodes", "opacity"], "ret": ["reset", "bl", "hash", "run", "sr", "RET", "req", "result", "mem", "url", "ref", "rets", "complete", "match", "hard", "att", "re", "usr", "rep", "art", "pat", "num", "reply", "mt", "err", "debug", "valid", "fab", "let", "gt", "red", "nt", "rb", "info", "job", "rev", "ft", "obj", "rc", "feat", "arg", "bf", "val", "cat", "out", "bit", "ext", "fit", "status", "error", "len", "resp", "code", "rest", "def", "pub", "rt", "rot", "str", "data", "back", "Ret", "reg", "flag", "done", "fin", "alt", "det", "fail", "fun", "db", "active", "lit", "html", "res", "success", "bad"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)\n\n{\n\n    int i, n, n2;\n\n    float alpha;\n\n\n\n    n  = 1 << ln;\n\n    n2 = n >> 1;\n\n\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);\n\n\n\n    for (i = 0; i < n2; i++) {\n\n        alpha     = 2.0 * M_PI * i / n;\n\n        mdct->costab[i] = FIX15(cos(alpha));\n\n        mdct->sintab[i] = FIX15(sin(alpha));\n\n    }\n\n\n\n    return 0;\n\nfft_alloc_fail:\n\n    mdct_end(mdct);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 26730, "substitutes": {"avctx": ["akcontext", "devcmp", "akconn", "avcu", "afctx", "ovctx", "afconn", "avconn", "ovcontext", "devcu", "afcu", "afcmp", "akctx", "avcontext", "AVcmp", "devctx", "devcontext", "AVcontext", "ovcmp", "AVconn", "AVcu", "akcmp", "ovconfig", "AVconfig", "avconfig", "avcmp", "afcontext", "afconfig", "AVctx"], "mdct": ["mdcat", " mdc", "mdc", " mdft", "cmdct", " mdect", "hdlc", "mdrt", "cmdpt", " mdnt", " mdcc", "amdct", "mdCT", "MDCT", "mandxc", "cmdcc", "mandc", " mdlc", "mandcf", "cmdect", "gradc", "cmdlc", "MDrt", "cmdcf", "mdft", "gradct", " mdant", "mdnt", "amdc", "MDcc", "cmdrt", "mdant", "hdCT", "mdxc", "cmdc", " mdcf", " mdpt", "mandct", "mdlc", "MDc", "MDnt", "amdcf", " mdrt", " mdxc", "cmdant", "MDpt", "mdect", "mdcf", "mdpt", "MDft", "amdcat", "cmdft", "mandpt", "hdpt", "hdect", "gradant", "gradect", "hdxc", " mdcat", "mandcat", "MDct", "cmdcat", " mdCT", "cmdCT", "mdcc", "mandect", "hdct", "cmdnt"], "ln": ["nl", "wn", "in", "lan", "nb", "Len", "inn", "N", "mn", " len", "len", " fn", " l", "dn", "l", "L", "lvl", "lon", "rn", "ern", "line", "cn", "nn", "pn", "lin", "ii", "lines", "ll", "loc", "fn", "hn", "lc", "oln", "dl", "NL", "sn", "kn", "ni", "en"], "i": ["x", "ai", "b", "index", "oi", "isin", "li", "pi", "in", "ie", "key", "ji", "z", "id", "j", "abi", "info", "iu", "ip", "esi", "ix", "gi", "bi", "l", "v", "y", "fi", "ti", "io", "slice", "uri", "xi", "ini", "name", "multi", "p", "qi", "m", "zi", "di", "I", "chi", "u", "init", "ii", "k", "si", "e", "c", "ani", "d", "ind", "f", "eni", "adi", "pixel", "lc", "api", "start", "ui", "phi", "ci", "o", "ni", "ri", "a", "mi"], "n": ["x", "b", "network", "num", "in", "ny", "nat", "nb", "z", "j", "nc", "N", "net", "inn", "norm", "nan", "len", "ne", "r", "size", "number", "dn", "l", "y", "name", "p", "m", "t", "s", "cn", "u", "w", "pn", "ii", "nn", "ns", "k", "e", "c", "fn", "d", "f", "nu", "sn", "np", "o", "sign", "ni", "en", "a"], "n2": [" n82", "N02", "i1", "n1", " n4", "na4", "n32", "ne02", "na2", "i2", "na82", "N2", "iTwo", " n32", "i4", "neTwo", "i02", " nTwo", "NTwo", " n62", "nTwo", "N82", "ne2", "n82", "n62", "ne1", "i62", "i32", "N32", " n1", "n4", "naTwo", "ne62", "l02", "n02", "l2", " n02", "lTwo", "N4"], "alpha": ["afi", "\u03b1", "alias", "ra", "aa", "da", "base", "ana", "lambda", "ca", "Alpha", "ac", "lla", "margin", "ace", "ta", "xa", "audio", "ia", "asc", "la", "star", "ma", "acc", "average", "beta", "area", "p", " Alpha", "acid", "pha", "angle", "rc", "acl", "scale", "k", "na", " beta", "si", "amp", "inc", "ph", "igma", "padding", "af", "lc", "aca", "api", "alph", "phi", "qa", "abc", "a"]}}
{"project": "qemu", "commit_id": "ed1dda53d073acdb52889aa30f9d251061b053bd", "target": 1, "func": "static always_inline void gen_intermediate_code_internal (CPUState *env,\n\n                                                          TranslationBlock *tb,\n\n                                                          int search_pc)\n\n{\n\n#if defined ALPHA_DEBUG_DISAS\n\n    static int insn_count;\n\n#endif\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    target_ulong pc_start;\n\n    uint32_t insn;\n\n    uint16_t *gen_opc_end;\n\n    CPUBreakpoint *bp;\n\n    int j, lj = -1;\n\n    int ret;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    ctx.pc = pc_start;\n\n    ctx.amask = env->amask;\n\n#if defined (CONFIG_USER_ONLY)\n\n    ctx.mem_idx = 0;\n\n#else\n\n    ctx.mem_idx = ((env->ps >> 3) & 3);\n\n    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;\n\n#endif\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    for (ret = 0; ret == 0;) {\n\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n                if (bp->pc == ctx.pc) {\n\n                    gen_excp(&ctx, EXCP_DEBUG, 0);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.pc;\n\n                gen_opc_instr_start[lj] = 1;\n\n                gen_opc_icount[lj] = num_insns;\n\n            }\n\n        }\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"pc \" TARGET_FMT_lx \" mem_idx %d\\n\",\n\n                  ctx.pc, ctx.mem_idx);\n\n#endif\n\n        insn = ldl_code(ctx.pc);\n\n#if defined ALPHA_DEBUG_DISAS\n\n        insn_count++;\n\n        LOG_DISAS(\"opcode %08x %d\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n", "idx": 26734, "substitutes": {"env": ["buf", "engine", "context", "nl", "scope", "chal", "que", "dt", "conf", "eu", "bc", "net", "proc", "keeper", "esp", "environment", "req", "header", "emb", "ne", "nv", "inv", "esi", "qt", "cv", "erb", "v", "fp", "conn", "enc", "config", "manager", "fg", "code", "exc", "args", "inst", "ev", "obj", "cfg", "console", "qv", "eb", "jp", "db", "txt", "ea", "eng", "eni", "ec", "gov", "event", "np", "fen", "qa", "viron", "org", "kb", "en", "her", "bg", "ext"], "tb": ["tbs", "tsbl", "Tbr", "tf", " trb", "ptrb", "etb", "ttp", "tsbh", " tp", "trb", "untv", "etp", "Tbl", "untb", " tbr", "stbl", "ptv", "untbr", "Tv", "etf", " tbl", "ttf", "ptp", " tbs", " tbh", "Tb", "Tbh", "ptb", "stp", "tsbs", "etbl", "tbh", "tbl", "etv", "ttb", "stb", "tv", "etrb", "stf", "ttbl", "tbr", "Tbs", "tp", "tsb", "untbs", " tv"], "search_pc": [" search_func", "find_fc", " search_PC", "searchablemc", "searchablePC", "search_fc", " search_mc", "search2func", "search_mc", "searchablefunc", "findablefc", "search2pc", "find_pc", "searchabletc", "findablepc", "find_tc", "search2tc", "findabletc", " searchablemc", "search_PC", "search2PC", "find_PC", "searchablepc", "searchablefc", "search_tc", " searchablefunc", "search_func", " searchablepc", "findablePC", "search2fc", "search2mc", " searchablePC"], "insn_count": ["insns_sum", "insn64sum", "insn64count", "insn64cache", "insns_cache", "insn64length", "insn_cache", "insn_sum", "insn_length", "insns_count", "insns_length"], "ctx": ["fw", "context", "pb", "fc", "zx", "wp", "xc", "sci", "sc", "bc", "cmp", "ca", "nc", "proc", "cc", "cp", "req", "hw", "pkg", "ck", "cv", "cas", "kw", "fp", "conn", "wx", "cf", "Context", "config", " cx", "vc", "gb", "cs", "tc", "conv", "cn", "wcs", "obj", "cmd", "na", "rc", "cfg", "tx", "ctrl", "cm", "acl", "console", "cca", "utils", "txt", "loc", "exec", "c", "sync", "git", "pc", "xs", "lc", "cb", "cli", "cpp", "sq", "cu", "ci", "np", "qa", "btn", "client", "kb", " context"], "ctxp": ["catmb", "CType", "centxp", "cedxp", "CTmb", "cattxt", "CTxp", "catype", "centmb", "cedmb", "CTtxt", "centtxt", "cedype", "catxp", "centype", "cedtxt"], "pc_start": ["pc1end", "pc1start", "pc_id", "PC_offset", "pc__start", "pc_offset", "pc_end", "pc_min", "dc_start", "dc_min", "pc__stop", "dc__start", "pc1offset", "pc__min", "dc__end", "pc_stop", "dc_end", "dc__stop", "dc_stop", "PC_pos", "dc__min", "PC_id", "PC_start", "PC_end", "pc_pos", "pc1pos", "pc__end"], "insn": ["nsns", "ink", "lsnr", "insnr", "inns", "nsnr", "nsk", "insns", "lsn", "inn", "innr", "lsk", "insk", "nsn", "lsns"], "gen_opc_end": ["gen_opci_pos", "gen_opc_ends", "gen_opci_ad", "gen_opci_ends", "gen_opci_id", "gen_opc__ad", "gen_opc__END", "gen_opc__start", "gen_opc__id", "gen_opc_start", "gen_opc__ends", "gen_opc_pos", "gen_opc_END", "gen_opci_END", "gen_opc_id", "gen_opci_end", "gen_opc_ad", "gen_opc__pos", "gen_opci_start", "gen_opc__end"], "bp": ["bm", "pg", "pb", "gp", "wp", "vm", "base", "nb", "bc", "cmp", "esp", "bh", "cp", "proc", "bb", "vp", "sb", "sp", "arp", "px", "pp", "fp", "bps", "bt", "conn", "kb", "py", "p", "gb", "dp", "BP", "eb", "jp", "hp", "pc", "pd", "cb", "bf", "lb", "cpp", "np", "qa", "policy", "tp", "lp", "bg"], "j": ["js", "jet", "index", "num", "last", "adj", "kj", "li", "b", "n", "ja", "key", "ch", "aj", "ji", "z", "err", "note", "jen", "r", "g", " dj", "br", " n", "vol", "job", "l", "v", "jump", "conn", "ij", "p", "fr", "m", " ii", "jp", "k", "jc", " i", "jj", " job", "i", "f", "str", "uj", "jl", "next", "pos", "reg", "section", "ni", " conn", "dj", "J", "offset"], "ret": ["ext", "nat", "mt", "RET", "req", "let", "len", "vt", "nt", "trial", "alt", "result", "det", "miss", "ref", "rev", "rets", "rl", "ft", "match", "def", "pub", "rc", "fun", "att", "feat", "arg", "rt", "pt", "sec", "lit", "val", "cat", "back", "Ret", "reg", "flag", "success", "re", "fit"], "num_insns": ["num_inpires", "num_exxs", "num_exn", "num_vins", "num_vinons", "num_inscs", "num_invs", "num_inspins", "num_vinns", "num_inons", "num_openspires", "num_inss", "num_inn", "num_exsts", "num_inccs", "num_itsvs", "num_itscs", "num_inxs", "num_intscs", "num_incpins", "num_inssts", "num_vincs", "num_opensxs", "num_insvs", "num_linn", "num_inpins", "num_opensn", "num_linns", "num_expires", "num_linvs", "num_inspires", "num_expins", "num_insn", "num_inns", "num_itsn", "num_ins", "num_exns", "num_excs", "num_lincs", "num_insons", "num_incns", "num_intss", "num_intsons", "num_incsts", "num_itsns", "num_opensns", "num_incs", "num_intsns", "num_insts", "num_insxs"], "max_insns": ["max_inscs", "max_outsls", "max_insnes", "max_insnas", "max_inks", "max_inccs", "max_itscs", "max_inls", "max_inns", "max_links", "max_outsns", "max_insks", "max_itsn", "max_insls", "max_itsns", "max_linn", "max_incs", "max_innes", "max_innas", "max_incks", "max_incns", "max_incn", "max_outsnas", "max_insn", "max_linsns", "max_outsnes", "max_incnas", "max_linscs", "max_linsls", "max_inn", "max_outsn", "max_linsn", "max_itsnes", "max_linnas", "max_lincs", "max_linns", "max_outscs"], "lj": ["Lg", " lji", " lk", "linaj", "lv", "lg", "lja", "lz", "ilfr", "lnz", " lz", "laj", " lx", "Lj", "elv", "plbr", "rjs", "lk", "lljp", "ulx", "plji", "lij", "Lk", "Lv", "liz", "ilja", "uljc", "elz", "ulg", " lg", " lv", "lifr", "plj", "eld", "Ljc", "eljp", "elfr", "rz", "lbr", "elj", "lljs", " lbj", "lbj", "linbj", "elji", "Lbj", "Lx", "elja", "Laj", "ilj", "ulj", "eljo", "ilbr", "ljo", "elbr", "lid", "ilz", " laj", "eljs", "lx", "iljo", "lfr", "Lz", "llj", "rj", "linj", "llz", "ulz", "rjp", "lji", "ild", "lnjo", "ilji", "iljc", "ld", "plz", "plv", "link", "ulv", "lnj", "ljs", "lnja", "ljc", "ilv", "ljp"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738, "substitutes": {"vs": ["qs", "env", "sv", "flags", "state", "rs", "ops", "vp", "VS", "verts", "vt", "guards", "fs", "fps", "bs", "obs", "cv", "ps", "params", "es", "v", "fg", "vals", "court", "cs", "ports", "vr", "iss", "ns", "forces", "cover", "ils", "vir", "eps", "ses", "ss", "xs", "ls", "ds", "va", "values", "services", "Vs", "stats"], "job": ["b", "plugin", "jobs", "worker", "OB", "live", "base", "child", "value", "bc", "j", "connection", "function", "row", "image", "build", "obs", "bar", "result", "work", "item", "py", "pool", "config", "manager", "queue", "Job", "route", "runner", "ab", "page", "bug", "fun", "db", "jp", "feed", "node", "baby", "block", "sync", "output", "cb", "object", "layer", "next", "event", "server", "org", "name", "order", "ob"]}}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745, "substitutes": {"client": ["agent", "port", "plugin", "worker", "remote", "parent", "proxy", "child", "id", "self", "connection", "host", "cache", "cell", "session", "request", "command", "resource", "conn", "close", "con", "config", "service", "manager", "container", "core", "cmd", "address", "prefix", "head", "public", "handler", "cod", "c", "pc", "cli", "api", "Client", "call", "server", "name"], "nb_fds": ["nb_Fdds", "nb_rfDS", "nb_Fds", "nb_rfks", "nb_cns", "nb2Fds", "nb_ccs", "nb_cds", "nb_cdds", "nb2Fcs", "nb_Fns", "nb_fdns", "nb_fdcs", "nb_fDS", "nb2Fdds", "nb2fcs", "nb_cDS", "nb_fddds", "nb_rfcs", "nb2fns", "nb_fns", "nb_cks", "nb_Fcs", "nb2fdds", "nb_fdds", "nb_fcs", "nb2Fns", "nb_fks", "nb2fds", "nb_rfds"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749, "substitutes": {"n": ["b", "network", "num", "nl", "un", "nb", "j", "nc", "mn", "N", "self", "net", "or", "none", "ne", "r", "nt", "g", "dn", "l", "y", "v", "conn", "con", "config", "on", "p", "m", "ic", "s", "t", "cn", "u", "w", "ns", "not", "k", "node", "e", "an", "fn", "d", "nw", "f", "nu", "i", "q", "sn", "np", "nm", "o", "en"], "cmd": ["b", "dq", "dc", "Cmd", "comm", "cmp", "nc", "cc", "cp", "req", "qq", "ctr", "ctx", "ctl", "mc", "g", "new", "command", "conn", "cf", "config", "m", "rc", "md", "cfg", "ctrl", "cm", "node", "uc", "d", "cb", "q", "call", "client", "cd"], "sq": ["iq", "eq", "pg", "dq", "ship", "que", "qs", "quad", "ql", "sci", "sc", "supp", "shape", "req", " q", "qu", "qq", " seq", "sub", "sh", "ctx", " square", "ctl", "row", "g", "cv", "sy", "cf", "sk", "query", "pool", "sql", "p", "qi", " SQ", "cs", "qua", "s", "carry", "zz", "sup", "sync", "seq", "squ", "q", "aq", "square", "np", "qa", "client", "scl", "zen", "cur"], "c": ["b", "coll", "dc", "ch", "sc", "conf", "ca", "ac", "cc", "self", "cp", "col", "ctx", "r", "mc", "cache", "l", "v", "h", "conn", "cf", "enc", "con", "oc", "vc", "p", "cl", "cs", "m", "ic", "cn", "u", "C", "cm", "ctrl", "ct", "k", "e", "uc", "d", "f", "i", "lc", "ec", "pc", "q", "call", "cu", "ci", "cur"]}}
{"project": "FFmpeg", "commit_id": "72a6244b5d554d7fdfdeb04c174750c7a2c52f83", "target": 0, "func": "void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,\n\n                                int start, int end, int fast_gain, int is_lfe,\n\n                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,\n\n                                uint8_t *dba_lengths, uint8_t *dba_values,\n\n                                int16_t *mask)\n\n{\n\n    int16_t excite[50]; /* excitation */\n\n    int bin, k;\n\n    int bndstrt, bndend, begin, end1, tmp;\n\n    int lowcomp, fastleak, slowleak;\n\n\n\n    /* excitation function */\n\n    bndstrt = bin_to_band_tab[start];\n\n    bndend = bin_to_band_tab[end-1] + 1;\n\n\n\n    if (bndstrt == 0) {\n\n        lowcomp = 0;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);\n\n        excite[0] = band_psd[0] - fast_gain - lowcomp;\n\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);\n\n        excite[1] = band_psd[1] - fast_gain - lowcomp;\n\n        begin = 7;\n\n        for (bin = 2; bin < 7; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp1(lowcomp, band_psd[bin], band_psd[bin+1], 384);\n\n            fastleak = band_psd[bin] - fast_gain;\n\n            slowleak = band_psd[bin] - s->slow_gain;\n\n            excite[bin] = fastleak - lowcomp;\n\n            if (!(is_lfe && bin == 6)) {\n\n                if (band_psd[bin] <= band_psd[bin+1]) {\n\n                    begin = bin + 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        end1=bndend;\n\n        if (end1 > 22) end1=22;\n\n\n\n        for (bin = begin; bin < end1; bin++) {\n\n            if (!(is_lfe && bin == 6))\n\n                lowcomp = calc_lowcomp(lowcomp, band_psd[bin], band_psd[bin+1], bin);\n\n\n\n            fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n            slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);\n\n        }\n\n        begin = 22;\n\n    } else {\n\n        /* coupling channel */\n\n        begin = bndstrt;\n\n\n\n        fastleak = (s->cpl_fast_leak << 8) + 768;\n\n        slowleak = (s->cpl_slow_leak << 8) + 768;\n\n    }\n\n\n\n    for (bin = begin; bin < bndend; bin++) {\n\n        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n        excite[bin] = FFMAX(fastleak, slowleak);\n\n    }\n\n\n\n    /* compute masking curve */\n\n\n\n    for (bin = bndstrt; bin < bndend; bin++) {\n\n        tmp = s->db_per_bit - band_psd[bin];\n\n        if (tmp > 0) {\n\n            excite[bin] += tmp >> 2;\n\n        }\n\n        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);\n\n    }\n\n\n\n    /* delta bit allocation */\n\n\n\n    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {\n\n        int band, seg, delta;\n\n        band = 0;\n\n        for (seg = 0; seg < FFMIN(8, dba_nsegs); seg++) {\n\n            band = FFMIN(49, band + dba_offsets[seg]);\n\n            if (dba_values[seg] >= 4) {\n\n                delta = (dba_values[seg] - 3) << 7;\n\n            } else {\n\n                delta = (dba_values[seg] - 4) << 7;\n\n            }\n\n            for (k = 0; k < dba_lengths[seg]; k++) {\n\n                mask[band] += delta;\n\n                band++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26774, "substitutes": {"s": ["b", "port", "sf", "in", "n", "a", "secondary", "S", "sb", "r", "g", "size", "session", "ts", "sa", "v", "h", "p", "m", "sym", "u", "w", "scale", "si", "bis", "settings", "e", "small", "c", "ses", "f", "ss", "spec", "sec", "i", "services", "sq", "o", "stats", "sys"], "band_psd": ["bandCpsn", "band_psdt", "band_PSdal", "band_ppds", "band_ssd", "band_tsds", "band_dsp", "band_bst", "band2csds", "band_etsm", "bandCpsds", "band_psdm", "band_apD", "band1psD", "band_epsD", "band_apst", "band_epsd", "band_psl", "band1epsd", "band_portsdk", "band___psdh", "band_ppsdh", "band_ppf", "band_lsu", "band_spdr", "band_vsdr", "band_psn", "band_asesdx", "band_ppsx", "band_pesdh", "bandCppsds", "band_tsn", "band_psf", "band_apsl", "band_ppd", "band_rasdat", "band_psds", "band_rasad", "band_apsds", "band2csl", "band_copdal", "band_ppsf", "band_etsdm", "band_osds", "band_ppsd", "band_epsm", "band2psl", "band_bsd", "band_epdk", "band_PSdh", "band_statsdh", "band_PSds", "band_rasds", "band_etsD", "band2csd", "band_PSf", "band_csds", "band_ppss", "band1psd", "band_pst", "band_ppb", "band_dsd", "band_psad", "band_psdh", "band_epn", "band1psm", "band_pointsm", "band_opsdk", "band1psdm", "band_ysd", "band_ppsst", "band_copd", "band_csdal", "band___statsd", "band_opsdx", "band_sss", "band_ppsD", "band_asesdk", "band_lsx", "band_copl", "band_pesdat", "band_bsx", "band_ppD", "band_psdal", "band_PSd", "band_osdat", "bandCppsx", "band_asesp", "band_apsd", "band_spds", "band_dsdk", "band2psds", "band_ysdk", "band_PSl", "band_psb", "band_pesb", "band_opsd", "band_ssds", "band_vsd", "band_epsdm", "band_asd", "band_yssd", "band_psD", "band_PSt", "band_psdat", "band_psst", "band_pesds", "band___statsdh", "band_ppl", "band___psb", "band_asdr", "band_ppt", "band_ppsu", "band_pointsd", "band_PSD", "band1epsdm", "band_csd", "band_PSs", "band_dsdx", "bandCppsd", "band_apsD", "band_apsx", "band_rasd", "band_ppst", "band_pesd", "band_epd", "band_apsb", "band_psdx", "band_spdt", "band_spd", "band_asds", "band_lst", "band2psb", "band_lsd", "band___statsb", "bandCpsx", "band_tsd", "band___psd", "band_ppsds", "band_portsn", "band_csf", "band_vsdt", "band_ysn", "band_tsx", "band_apsst", "band_copf", "band_psdk", "band_pointsdm", "band1epsD", "band_osd", "band_apd", "band_csb", "band_statsd", "band_csl", "band_portssd", "band_pesdal", "band_ssdh", "band_ppsn", "band_portsd", "band_pesad", "band_pointsD", "band___psdal", "band_psx", "band1epsm", "band_statsb", "band_tsdh", "band_psm", "band_osad", "band_vsds", "band_statsdal", "band2csb", "band_apsn", "band_asdt", "band_pss", "band_apds", "bandCppsn", "band_asesd", "band_psp", "band___statsdal", "band_bsu", "bandCpsd", "band_pssd", "band_tsb", "band_psu", "band_tsdal", "band_psdr", "band_etsd", "band_opsp", "band2psd"], "start": ["x", "in", "mid", "ie", "id", "stop", "shift", "send", "Start", "len", "add", "size", "get", "src", "range", "pre", "scan", "p", "it", "init", "first", "scale", "c", "from", "i", "ind", "d", "min", "ad", "pos", "use", "art", "st", "pad", "se", "offset"], "end": ["x", "index", "b", "ended", "mid", "set", "entry", "z", "id", "edge", "stop", "send", "END", "len", "add", "size", "max", "off", "range", "ending", "End", "head", "ension", "append", "e", "c", "limit", "bound", "pend", "inc", "dest", "use", "en", "order", "length", "offset"], "fast_gain": ["fastianwall", "fastlyrank", "fastiangain", "fast_wall", "mediumianwall", "small_fan", "fast___wall", "fast___thin", "solid___gain", "fast___dim", "fast_rate", "high_rate", "fast_rank", "solid_gain", "fastianthin", "mediumiangain", "small_gain", "fast___winner", "solid___dim", "fastlygain", "medium_gain", "solid_channel", "fast_thin", "fastlyrate", "mediumianthin", "fast___gain", "high_rank", "fastianwinner", "solid___group", "small_rate", "fast___channel", "solid_group", "mediumianwinner", "medium_winner", "medium_thin", "fast_group", "fast_dim", "fast_channel", "fast_winner", "small_grain", "medium_wall", "high_gain", "solid_dim", "fast_fan", "solid___channel", "fast_grain", "fast___group"], "is_lfe": ["is_afed", "is_lvl", "is_lvi", "is_afee", "is_ffes", "is_lfc", "is_lingee", "is_lingc", "is_dfee", "is_lfE", "is_linge", "is_ffae", "is_lowi", "is_lfl", "is_dfae", "is_alfe", "is_ffe", "is_elfg", "is_lvc", "is_ffee", "is_afe", "is_alfE", "is_lve", "is_dfe", "is_dfc", "is_lowe", "is_bfg", "is_ffE", "is_bfc", "is_lowc", "is_elfee", "is_afc", "is_lfg", "is_lfed", "is_lfee", "is_lfes", "is_afE", "is_bfee", "is_alfed", "is_alfes", "is_afes", "is_elfe", "is_lingae", "is_elfc", "is_ffc", "is_ffi", "is_ffed", "is_lfae", "is_afg", "is_lowl", "is_ffl", "is_bfe", "is_lfi"], "dba_mode": ["dba_sort", "dbaOsort", "dna_mode", "dba_depth", "dba_size", "dna_sort", "dna_depth", "dbaOmode", "dbaOsize", "dbaOdepth", "dna_size"], "dba_nsegs": ["dba_nspels", "dba_nprogs", "dba_nproqs", "dba_nseg", "dba_Nseg", "dba_nprog", "dba_npersegs", "dba_nspeqs", "dba_nseqs", "dba_Nseqs", "dba_Nperseg", "dba_nsels", "dba_Npersels", "dba_Nsels", "dba_nspegs", "dba_Npersegs", "dba_nperseqs", "dba_Nperseqs", "dba_nspeg", "dba_nprols", "dba_Nsegs", "dba_npersels", "dba_nperseg"], "dba_offsets": ["dba_offses", "dba_offsizes", "dba_offset", "dba_offsetet", "dba_offsetizes", "dba_offizes", "dba_offet", "dba_poses", "dba_offes", "dba_posets", "dba_offets", "dba_offsetets", "dba_poset", "dba_posizes", "dba_offsetes"], "dba_lengths": ["dba_countes", "dba_lengthits", "dba_widthits", "dba_lenizes", "dba_lenes", "dba_lengthes", "dba_lenits", "dba_countizes", "dba_countits", "dba_widthizes", "dba_lengthizes", "dba_counts", "dba_lens", "dba_widthes", "dba_widths"], "dba_values": ["dfa_values", "dba_bits", "dfa_bits", "dfa_flags", "dba_vals", "dba_flags", "dfa_vals"], "mask": ["depth", "alias", "array", "weight", "filter", "flags", "shape", "bits", "Mask", "patch", "image", "cache", "result", "ask", "batch", "pack", "lock", "prefix", "scale", "gain", "padding", "delay", "spec", "map", "sign", "bit", "pad", "sum"], "excite": ["excile", "Excit", " excited", "exciton", "excide", "occit", "ucite", "occites", "Excited", "ecrite", "ecit", "ucit", "excites", " ExcITE", "Excite", "Excites", "ecited", "excit", "ExcITE", " excITE", "excrite", " excile", "excited", " excide", "Excrite", " Excite", " excites", "occited", "excITE", "ucide", " Excit", "occide", "occiton", "occite", " exciton", " excit", " excrite", "ecite", "Exciton", "occile", "ucile", " Excrite"], "bin": ["b", "border", "seed", "isin", "loop", "in", "bc", "split", "byte", "count", "binary", "type", "ask", "inner", "wan", "socket", "comment", "block", "pixel", "gap", "spin", "fen", "cookie", "user", "order", "bg", "num", "year", "n", "key", "slot", "pin", "gin", "sid", "bid", "bon", "feature", "gi", "fix", "off", "skip", "scan", "nn", "bas", "domain", "brain", "ruby", "kit", "val", "cat", "bit", "site", "index", "chin", "plugin", "nb", "byn", "pal", "inn", "lib", "bb", "len", "token", "vid", "bn", "session", "obin", "root", "boot", "browser", "sort", "channel", "unit", "bug", "min", "flag", "ping", "skin", "bis", "addin", "rec", "ban", "win", "kin", "base", "align", "margin", "fin", "bi", "part", "uni", "batch", "ben", "local", "init", "fun", "db", "gain", "bot", "i", "bat", "pos", "bad"], "k": ["b", "border", "num", "port", "loss", "n", "key", "win", "kin", "kid", "net", "r", "g", "unk", "kw", "sk", "scan", "batch", "p", "K", "channel", "w", "kick", "c", "f", "i", "pos"], "bndstrt": ["bndStrs", "bNDbrs", "bndstp", "bNDbrT", "bndctrt", "bndcrp", "bndsts", "bntstrt", "bNDstrT", "bndStrnt", "bNDstrnt", "bndctrT", "bNDStrp", "bndbrt", "bNDstrs", "bntcrs", "bNDStrs", "bndstrp", "bNDStrt", "bndbrp", "bndstrT", "bndStrp", "bndStrt", "bNDStrT", "bndcrt", "bntcrt", "bntstrp", "bNDbrt", "bndctrnt", "bndbrs", "bNDbrnt", "bntstrs", "bntcrp", "bndstt", "bndcrT", "bndStrT", "bndbrnt", "bndbrT", "bndstT", "bNDstrp", "bntstrT", "bndstrs", "bntcrT", "bndcrs", "bndstrnt", "bNDstrt", "bndctrs"], "bndend": ["brnenc", "bNDEnd", "bntenc", " bNDen", " bNDend", "bindEnd", "bbndmax", "bndenc", "bnnest", "bckenc", "bbindmax", "abndends", "bntend", "bngmax", "bbindend", "bndmax", "bbndEnd", "brnends", "bndends", "bntends", "abndstart", " bNDstart", "bbindest", "bbndest", "bndEnd", "bNDen", "bnnmax", " bNDEnd", "bntEnd", "brnstart", "abntenc", "bindest", "bnnend", "bndstart", "bngest", "bnten", "bckstart", "bNDstart", "abntstart", "bndest", "abndend", "bindend", "bbindEnd", "bnnstart", "abndenc", " bnden", "bnnEnd", "bngend", "abntend", "bnnen", "abntends", "bindmax", "bNDend", " bndEnd", "bckends", "bntstart", "bbndend", "bckend", "bnden", "bngEnd", "brnend", " bndstart"], "begin": ["hide", "run", "filename", "sb", "mem", "url", "chrom", "month", "uid", "en", "order", "ward", "snap", "num", "span", "n", "un", "shape", "pin", "gin", "sub", "bid", "rb", "record", "skip", "see", "scan", "amin", "nn", "web", "bor", "sav", "use", "mid", "pair", "forward", "inn", "don", "wake", "position", "utf", "session", "master", "src", "sort", "until", "min", "Begin", "member", "r", "number", "coord", "range", "batch", "initial", "um", "gain", "uc", "method", "sum"], "end1": ["startOnce", "lenone", "set1", "set5", " end5", "end100", "EndOnce", "endedOne", " end8", "endJ", "end5", "start2", " endone", " endn", "len2", "end2", "startone", "ended1", "ended2", " end100", " end2", "endn", "setone", "endOnce", " endJ", "set8", "EndOne", "endOne", "len100", "endedJ", "end8", "set2", "len1", " endOne", "startOne", "startJ", "start1", "End1", "set100", "endedOnce", "setn", "endone", "ended5", "setOne", "ended8", "endedn"], "tmp": ["buf", "seed", "port", "loop", "num", "nb", "shape", "wait", "bb", "qq", "sb", "binary", "rb", "ip", "duration", "result", "skip", "beta", "batch", "unit", "nn", "buffer", "cb", "pos", "ff", "pad", "temp", "bis"], "lowcomp": ["slowcomp", "lowexp", "quickcomp", "fastcomp", "lowComp", "oldfrac", "slowcomb", "lowfrac", "lowomp", "slowexp", "lowerexp", "lowercon", "Lowcomponent", "oldomp", " lowfrac", " lowcom", "slowpar", " lowcomponent", "highcmp", "slowcon", "ownproc", "owncon", "groundcomp", "groundomp", "quickcmp", " lowprop", "lowercom", " lowcmp", "Lowomp", "slowprop", " lowpar", "quickprop", " lowcomb", "flowomp", "oldcond", "flowcomponent", "flowfrac", "quickomp", "oldcomponent", "smallproc", "quickcomponent", "highcomp", "lowcomb", "highComp", "owncp", "lowcp", "smallcomp", "lowprop", "fastproc", "slowproc", "owncomp", "slowcom", "Lowcom", "groundcond", "lowproc", "lowpar", "lowpos", "fastpos", "oldcmp", "smallcomponent", "flowcmp", "Lowproc", "lowercp", " lowproc", "oldcom", "slowcomponent", " lowomp", "flowpar", "lowcom", "LowComp", "groundcmp", "lowcond", "slowcond", "fastcomponent", "highcomponent", "Lowcmp", "lowcomponent", "lowcmp", "oldcomp", "flowcomp", "lowerproc", "flowcomb", "smallpos", " lowexp", "quickproc", "slowcp", "slowomp", " lowComp", "lowcon", "lowercomp", "slowcmp", "oldproc", "Lowcomp", "slowpos"], "fastleak": ["fastbleak", "fastneake", "fastleaw", "highcleake", "fastLeak", " fastsleak", "fastsleaking", "highleake", "fastpeak", "fastcleak", " fastleaker", "fastoleaw", "fastLeek", "highleak", "highcleak", "fastpeaw", "highleaks", "fastneaker", "fastcleake", "fastleark", "fastsleek", "fastsleak", "fastleake", " fastsleaking", "fastneak", "fastsleark", "fastLeaking", "fastoleak", " fastsleake", " fastleek", " fastsleek", " fastleake", "fastpeake", "fastcleaks", "highcleaw", "fastLeake", "fastleek", "fastsleaker", "fastbleake", "fastneark", "fastsleake", " fastleark", "fastLeark", "fastLeaker", "fastleaking", "fastleaker", "fastoleaks", "fastpeaks", "fastbleek", "highleaw", "fastoleake", " fastsleark", "fastcleaw", "highcleaks", " fastleaking", "fastbleaking", "fastleaks", " fastsleaker"], "slowleak": ["speedpeak", "speedleace", "slowleac", "slowLeaker", "slowsleaker", "slowLeac", "speedleac", "slowoleace", "slowpeake", "lowleaker", "slowoleaker", "lowleake", "slowleaks", "speedpeake", "speedpeace", "slowleake", "slowLeak", "slowleace", "slowpeak", "speedleak", "speedleake", "slowsleak", "slowoleake", "slowpeace", "slowLeaks", "slowpeac", "slowleaker", "lowoleake", "lowoleaks", "lowleaks", "slowoleac", "slowoleak", "slowLeake", "slowLeace", "lowleak", "slowsleake", "lowoleak", "lowoleaker", "speedpeac", "slowsleaks", "slowoleaks"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776, "substitutes": {"s": ["b", "sf", "in", "n", "a", "conf", "state", "S", "sv", "self", "rs", "sb", "private", "ssl", "fs", "r", "series", "session", "states", "new", "v", "src", "service", "submit", "p", "m", "sym", "t", "south", "u", "init", "input", "sets", "side", "ns", "sg", "si", "settings", "e", "sync", "c", "d", "f", "sim", "ss", "spec", "i", "ds", "services", "sq", "o", "ses", "sys"], "x": ["b", "index", "path", "rx", "win", "base", "z", "id", "shape", "X", "image", "position", "size", "ix", "px", "move", "l", "v", "xi", "on", "p", "m", "t", "ex", "u", "e", "c", "d", "i", "f", "data", "pos", "o", "name", "height", "a", "pointer"], "y": ["b", "oy", "vy", "Y", "n", "ny", "z", "j", "cy", "dy", "yi", "ady", "hi", "ye", "ip", "bar", "ys", "sy", "yo", "l", "ery", "p", "lon", "yt", "t", "u", "zy", "c", "ey", "d", "i", "f", "ya", "ay", "yy", "o", "ry", "height", "a", "ty"], "w": ["b", "fw", "weight", "n", "win", "aw", "wt", "z", "wid", "ow", "ew", "sh", "W", "wa", "size", "max", "wb", "l", "work", "v", "wx", "wd", "p", "m", "t", "u", "we", "k", "c", "d", "wh", "length", "q", "sw", "o", "height", "a", "rw"], "h": ["b", "depth", "n", "oh", "ch", "z", "j", "gh", "dh", "th", "dy", "sh", "wa", "hi", "size", "l", "v", "hh", "hm", "p", "m", "t", "u", "k", "e", "c", "ph", "d", "i", "f", "q", "H", "ht", "o", "en", "height", "length"], "rect": ["port", "coll", "dash", "path", "driver", "Rect", "pair", "project", "shape", "tri", "crop", "butt", "text", "quant", "upload", "surface", "row", "RECT", "patch", "dra", "dr", "director", "transform", "cont", "slice", "tr", "ror", "dot", "cross", "config", "draw", "grad", "complete", "json", "select", "rc", "input", "scroll", "ct", "att", "font", "feat", "device", "cover", "txt", "point", "pt", "lat", "tv", "round", "object", "touch", "spec", "arrow", "client"], "redraw_fifo_last": ["redraw_fifo_max", "redraw_fifo__last", "redraw_fifos_max", "redraw_fifo__first", "redraw_fifo_full", "redraw_fifo__max", "redraw_fifos_str", "redraw_fifo_first", "redraw_fifos_full", "redraw_fifos_last", "redraw_fifo_str", "redraw_fifos_first"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n", "idx": 26777, "substitutes": {"dc": ["context", "fc", "rec", "sc", "da", "bc", "anc", "nc", "cc", "enter", "mc", "director", "cf", "config", "oc", "draw", "tc", "cr", "dm", "CD", "de", "rc", " DC", "input", "ct", "jc", "cca", "desc", "doc", "loc", "uc", "exec", "ec", "pc", "td", "DC", "CC", "cdn", "xml", "dat", "ga", "cd"], "d": ["b", "sd", "n", "dt", "D", "df", "da", "z", "dh", "r", "g", "dn", "l", "gd", "v", "y", "bd", "p", "m", "dm", "s", "di", "t", "dx", "de", "w", "md", "u", "db", "k", "e", "dd", "f", "i", "ds", "data", "dl", "q", "ad", "o", "dat", "a", "cd"], "c": ["b", "fc", "n", "ch", "xc", "sc", "z", "bc", "ca", "nc", "ac", "cc", "cy", "col", "r", "g", "mc", "l", "v", "h", "y", "ce", "cf", "con", "cl", "vc", "p", "m", "ic", "cs", "t", "s", "tc", "cn", "u", "C", "w", "ct", "k", "e", "uc", "pc", "f", "ec", "lc", "i", "co", "cu", "ci", "o", "cd"], "x": ["index", "b", "n", "rx", "xc", "ch", "z", "php", "xt", "nc", "cc", "cy", "xxx", "ax", "X", "r", "g", "ix", "l", "xes", "y", "h", "wx", "v", "pe", "xp", "xi", "cross", "con", "config", "cl", "vc", "xx", "p", "ic", "cs", "iz", "exc", "t", "m", "s", "ex", "w", "dx", "C", "tx", "ct", "xy", "u", "k", "e", "xs", "f", "pc", "lc", "i", "q", "fx", "ci", "xe", "o", "yx", "xml"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n", "idx": 26780, "substitutes": {"spapr": ["ppapsar", "spApr", "ppapp", "spapsar", "ppapsp", "ppapr", "ppapsr", "spaxr", "ppapsrar", "spapar", "spapsrar", "spapsp", "spapsr", "spAprar", "ppapar", "spApar", "ppaprar", "spaxp", "spaxar", "spaprar", "spApp", "spaxrar", "spapp"], "token": ["rec", "win", "nat", "reply", "rule", "stop", "os", "ops", "sid", "len", "result", "secret", "serial", "root", "ts", "rev", "oken", "match", "init", "ok", "seq", "gen", "random", "next", "reg", "flag"], "nargs": ["ncArgs", "calt", "rnret", "ncarg", "nparams", "Nargs", "ncargs", "ncparams", "lparams", "nalt", "nArgs", "rnargs", "narg", " narg", " nparams", "rnalt", "cparams", "Nparams", "lalt", " nArgs", "cret", "rnparams", "NArgs", "largs", "cargs", "lret", "Narg"], "args": ["results", "details", "ids", "ret", "reply", "vs", "flags", "gs", "grades", "bits", "yrs", "bytes", "opens", "arn", "len", "axis", "ans", "aws", "params", "years", "Args", "fields", "ras", "ants", "ks", "options", "arms", "atts", "py", "config", "frame", "parse", "ins", "arr", "ints", "vals", "strings", "cmd", "features", "argument", "alls", "mac", "ms", "ns", "arg", "lines", "addr", "limits", "ig", "sec", "spec", "plays", "ds", "stat", "data", "words", "parts", "flag", "orders", "ars"], "nret": [" nalt", "pret", "nbret", "bRET", " nRet", "presult", " nres", "nRET", "nbRet", "nres", "nalt", "bresult", "NRet", "Nres", "balt", "pRET", " nRET", "Nret", "palt", "nresult", "Nresult", " nresult", "nbres", "nbresult", "nRet", "bret"], "rets": ["items", "ents", "details", "results", "errors", "qs", "ids", "ret", "outs", "flags", "rows", "RET", "rs", "fits", "nas", "ops", "opens", "arn", "verts", "fs", "gt", "tails", "alt", "ans", "archives", "ts", "secret", "fields", "ras", "ins", "tests", "strings", "vals", "ints", "tracks", "ails", "features", "def", " secrets", "alls", "ats", "urs", "runs", "ns", "ils", "utils", "stores", "uts", "acks", "seq", "rules", "ls", "aux", "ds", "uments", "uds", "res", "cedes", "uses", "nets", "ants"], "id": ["year", "key", "path", "ids", "base", "kid", "ca", "ID", "end", "sid", "create", "info", "ip", "ix", "type", "max", "root", "no", "is", "pid", "url", "ref", "h", "did", "uri", "ce", "ks", "ins", "code", "core", "address", "oid", "it", "init", "head", "rc", "time", "addr", "c", "uid", "from", "f", "Id", "i", "d", "data", "q", "ad", "aid", "bit", "name"], "start": ["x", "enable", "index", "seed", "span", "in", "mid", "run", "ie", "set", "started", "state", "source", "stop", "ace", "shift", "end", "Start", "len", "starting", "sp", "info", "host", "add", "ip", "size", "type", "get", "is", "y", "sk", "skip", "p", "cur", "it", "init", "time", "d", "from", "ind", "next", "min", "ad", "pos", "tick", "art", "st", "name", "step", "offset"], "r3": [" r2", " r1", "rr03", "rThird", "rr3", " riii", "hr1", "rrThree", "hr3", "R2", "r03", "R03", "r2", "sriii", "R53", " rThird", "ruThird", "ru03", "R1", "rThree", "srThird", "hr2", " rThree", "rr53", "Riii", "ru3", "riii", "r53", "sr03", "sr3", "R3", "RThree", "hriii", " r53", "r1", " r03", "ruiii"], "cs": ["js", "icks", "css", "qs", "sc", "vs", "bc", "cing", "nc", "gs", "ac", "cc", "cp", "rs", "cms", "os", "Cs", "ctx", "CS", "cus", "fs", "ced", "cache", "ck", "bs", "ix", "cer", "ps", "cks", "ics", "ts", "cas", "conn", "ks", "ce", "cf", "sk", "ras", "vc", "core", "cells", "s", "cn", "acs", "wcs", "rc", "ct", "ns", "utils", "sync", "c", "cons", "pc", "ec", "spec", "ls", "ds", "lc", "ci", "ces", "ars", "sys"], "cpu": ["fc", "vm", "css", " CPU", "bc", "pu", "nc", "proc", "cp", "ctx", "CS", "cache", "gc", "px", "conn", "cf", "gpu", "roc", "core", "processor", "cn", "cm", "node", "sync", "c", "clock", "pc", "CPU", "lc", "ec", "eni", "GPU", "cli", "np", "ci", "sys"], "env": ["engine", "agent", "scope", "context", "et", "que", "vm", "conf", "energy", "eu", "state", "err", "inet", "vs", "edge", "environment", "shell", "ctx", "ne", "ass", "cache", "session", "cv", "cal", "conn", "ce", "estate", "cf", "style", "oa", "enc", "config", "core", "exc", "equ", "iss", "ev", "eve", "console", "el", "db", "assets", "settings", "export", "e", "ea", "c", "Environment", "eni", "ec", "np", "viron", "en", "zone", "skin", "ext"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792, "substitutes": {"bus": ["engine", "plugin", "loop", "port", "proxy", "driver", "bc", "http", "proc", "self", "interface", "connection", "test", "board", "info", "cache", "Bus", "boot", "controller", "serial", "io", "BUS", "service", "config", "lock", "dev", "device", "plug", "feed", "this", "block", "drive", "bridge", "f", "data", "mount", "usb", "us"], "address": ["index", "network", "port", "alias", "pair", "mode", "state", "shape", "message", "source", "interface", "end", "connection", "reference", "enter", "host", "ip", "number", "size", "type", "master", "request", "resource", "location", "uri", "code", "route", "channel", "device", "attribute", "capacity", "target", "addr", "node", "transfer", "i", "object", "layer", "account", "event", "content", "server", "Address", "name", "order", "length", "pointer", "localhost", "offset"], "recv": ["RECv", " recq", "recceive", "req", "renb", "RECf", "renv", " recb", "rencv", "respv", "renceive", "ref", "rev", " recV", " recceive", "reV", "respceive", "recb", "RECq", " reccv", "recf", "respb", "reccv", "recV", "RECV", "respcv", "recq", " recf"], "qdev": ["qtsd", "qdevice", "quickdev", "Qdes", "qsd", "Qdev", "qucase", "qtdev", "sqdevice", "sqdef", "sqcase", "quickcase", "qude", "qusd", "qDev", "quickde", "qde", "QDev", "pdevice", "pde", "sqde", "qudev", "Qdevice", "pdef", "qudes", "Qsd", "qdef", "qdes", "Qde", "sqdes", "sqdev", "qtdes", "quDev", "qtDev", "qcase", "pdev", "Qdef", "quickdes"], "slave": ["seed", "port", "loop", "ship", "entry", "driver", "child", "mode", "id", "sh", "sb", "shared", "type", "result", "instance", "ssh", "table", "device", "si", "sync", "bridge", "serv", "seller", "future", "adder", "worker", "parent", "wife", "ve", "connection", "host", "role", " slaves", "node", "copy", "boat", "lane", "owner", "plugin", "proxy", "ace", "shift", "interface", "vid", "session", "master", "root", "slice", "uri", "route", "seat", "ser", "unit", "channel", "attribute", "sett", "player", "stable", "lease", "server", "engine", "sl", "source", "hole", "controller", "command", "fork", "dev", "machine", "link", "missing", "object", "bean", "length"]}}
{"project": "FFmpeg", "commit_id": "8a57ca5c6a1c0ad28afa7ea6f824981e6761cce1", "target": 0, "func": "static int aasc_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    AascContext *s = avctx->priv_data;\n\n    int compr, i, stride;\n\n\n\n    s->frame.reference = 3;\n\n    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &s->frame)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    compr = AV_RL32(buf);\n\n    buf += 4;\n\n    buf_size -= 4;\n\n    switch (avctx->codec_tag) {\n\n    case MKTAG('A', 'A', 'S', '4'):\n\n        bytestream2_init(&s->gb, buf - 4, buf_size + 4);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    case MKTAG('A', 'A', 'S', 'C'):\n\n    switch(compr){\n\n    case 0:\n\n        stride = (avctx->width * 3 + 3) & ~3;\n\n        for(i = avctx->height - 1; i >= 0; i--){\n\n            if(avctx->width*3 > buf_size){\n\n                av_log(avctx, AV_LOG_ERROR, \"Next line is beyond buffer bounds\\n\");\n\n                break;\n\n            }\n\n            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n\n            buf += stride;\n\n            buf_size -= stride;\n\n        }\n\n        break;\n\n    case 1:\n\n        bytestream2_init(&s->gb, buf, buf_size);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n\n        return -1;\n\n    }\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FourCC: %X\\n\", avctx->codec_tag);\n\n        return -1;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 26819, "substitutes": {"avctx": ["avcb", "avxc", "abproc", "akcontext", "afcmd", "afcb", "akcas", "AVlc", "avecf", "afcu", "ajcca", "afcoll", "avalcomponent", "avcmd", "abctx", "ajproc", "aveconn", "avtx", " avcontext", "ajcomponent", "avectx", "ajcb", "avalcontext", "avproc", "afcontext", "ajtx", "avconsole", "avecontext", "afct", "abcontext", "avalctx", "afkb", "aftx", "avaltx", "ajcontext", "afxc", "avca", "afcca", "ajcmp", "abconn", "akcca", "avecca", "navsync", "AVsync", "afcf", "AVconfig", "afproc", "afconfig", "aucoll", "auconn", "afca", "aveconfig", "avalcf", "avekb", "avcu", "abcf", "avcf", "aveca", "afcas", "akcmd", "akcb", "abconfig", "afctx", "avalconsole", "afconn", "avconn", "avsync", "ajxc", "akctx", "afsync", "afcomponent", "aucontext", "abct", "AVcontext", " avcb", "avalconfig", "AVcu", "avcoll", "avcmp", "avconfig", "ajctx", "aflc", "avlc", "avecoll", "navctx", "avalcmp", "avecb", "avcomponent", "ajcmd", "avcas", "akkb", "afcmp", "avcontext", "avalcca", "avecu", "avcca", "navcontext", "ajcas", "abcmp", "avkb", " avxc", "abca", "navlc", "avalct", "auctx", "AVconsole", "afconsole", "avct", "avelc", "AVctx"], "data": ["index", "parent", "alpha", "base", "message", "margin", "connection", "body", "bytes", "response", "offset", "DATA", "window", "image", "cache", "size", "result", "open", "reader", "slice", "config", "frame", "empty", "batch", "queue", "p", "code", "m", "read", "Data", "buffer", "input", "feed", "pad", "media", "block", "d", "padding", "f", "start", "output", "next", "uf", "val", "content", "load", "memory", "dat", "length", "bin", "buff"], "data_size": ["data___count", "data___len", "data_number", "data___number", " data_number", "data___size", " data_len", "data_len", "data_count", " data_count"], "avpkt": ["avvpkt", "avtct", "avpbcf", "avtacket", "afpct", "avcpkt", "avPk", "avPct", "AVvpkt", "AVvpcf", "avppKT", "abcpka", "avpcf", "avpk", "AVpKT", "avfk", "AVpkt", "avpct", "avpKT", "avfacket", "avppkt", "abcpkt", "abcpct", "avppk", "affacket", "abpka", "affkt", "abcpacket", "avpacket", "abpct", "avvpKT", "avvpcf", "affct", "avPkt", "avvpk", "abpkt", "avcpct", "avpbkt", "avpka", "AVvpk", "avcpacket", "afpacket", "affk", "avfkt", "avpbKT", "abpacket", "AVpk", "avppcf", "avfct", "avtkt", "avcpka", "afpk", "avfka", "avcpk", "avPacket", "AVvpKT", "afpkt", "avtka", "avpbk", "AVpcf"], "buf": ["orig", "cap", "b", "port", "prop", "array", "box", "home", "bc", "vec", "proc", "func", "cp", "text", "bb", "ctx", "wa", "fd", "done", "rb", "utf", "wb", "cv", "br", "Buffer", "cas", "la", "v", "fp", "ref", "cf", "src", "bd", "config", "batch", "queue", "alloc", "p", "pack", "tmp", "cmd", "ab", "cur", "rc", "buffer", "feat", "font", "feed", "loc", "block", "bag", "seq", "uc", "c", "f", "img", "cb", "aux", "ru", "uf", "ff", "Buff", "pad", "length", "fb", "buff"], "s": ["js", "its", "context", "in", "qs", "a", "sc", "conf", "sv", "S", "gs", "j", "self", "rs", "os", "ops", "ssl", "fs", "r", "g", "session", "ps", "aws", "ts", "es", "sa", "l", "is", "y", "ks", "service", "ins", "hs", "p", "cs", "sym", "t", "args", "side", "su", "ns", "sg", "si", "ms", "e", "sync", "c", "sup", "d", "ss", "f", "ls", "ds", "spec", "services", "sq", "parts", "o", "us", "ses", "sys", "as"], "compr": ["_", "ocompre", "x", "compPR", " compre", "compPr", "impre", "comppre", "corPR", "combr", "comppro", "comPr", "cumPR", "corpol", "r", "cumpol", "g", "ocompr", " compro", "imPr", " comPr", "all", "impr", "comppol", "ocompro", "comPR", "corbr", "compol", "buffer", "imbr", "corpr", "c", "compbr", " combr", "cumbr", "cumpr", "comppr", "compre", "compro"], "i": ["index", "ai", "x", "b", "li", "pi", "n", "ie", "z", "j", "abi", "r", "iu", "g", "ip", "hi", "dim", "gi", "bi", "l", "ti", "v", "h", "io", "slice", "fi", "uri", "xi", "ini", "mu", "multi", "p", "qi", "zi", "m", "di", "I", "t", "u", "ii", "k", "si", "e", "c", "d", "ind", "f", "lc", "y", "start", "ui", "ci", "vi", "phi", "o", "ni", "ji", "a", "ki", "mi"], "stride": ["STRue", "strince", "strided", "dride", "Strider", " strided", "trince", "strider", " strite", "trided", " strie", "strIDE", "Strite", "strip", "STRide", "divIDE", "strie", "divise", "Stride", "strue", "Strie", "yrided", "drite", " strider", "drider", "trip", "yrip", " strue", "Strided", "STRider", " strip", " strince", "tride", " strIDE", "yride", "Strue", "STRite", "STRise", "drie", "divide", "strite", "STRIDE", " strise", "divite", "yrince", "strise", "STRided"]}}
{"project": "FFmpeg", "commit_id": "de6df46120367b7d49d9d7c0971cbe36368b840a", "target": 1, "func": "int ff_h264_field_end(H264Context *h, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n#if CONFIG_ERROR_RESILIENCE\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        ff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);\n        ff_er_frame_end(&h->er);\n    }\n#endif /* CONFIG_ERROR_RESILIENCE */\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n    h->current_slice = 0;\n    return err;\n}", "idx": 26836, "substitutes": {"h": ["b", "adh", "hash", "oh", "help", "ch", "ih", "prev", "z", "http", "gh", "bh", "self", "hand", "hd", "end", "th", "hw", "he", "sh", "header", "hi", "eh", "hl", "enh", "host", "hist", "g", "han", "l", "work", "v", "hh", "hs", "hm", "ssh", "p", "m", "beh", "history", "rh", "t", "s", "u", "w", "head", "handler", "ah", "ha", "e", "c", "ph", "hp", "d", "f", "i", "hr", "uh", "how", "q", "H", "ht", "auth", "kh"], "in_setup": ["inpsetup", " in_progress", " in_done", "inLogsummary", "in_close", "in1setup", "in_done", " in_summary", "inLogclose", " in_close", "inpprep", "in_summary", "in_prep", "in_ctx", "inpctx", " in_ctx", "inLogsetup", "in1progress", "in1done", "in_progress", " in_prep"], "avctx": ["akcontext", "awcontext", "Avctrl", "evconn", "akconfig", "afci", " avcfg", "akcf", "AVcfg", "awctx", "abctx", "aveconn", "afcfg", " avcontext", "afctrl", "avectx", "afcontext", "afcal", "afbc", "Avcmp", "AVloc", "avecontext", "evcal", "abcontext", "wavbc", "avbc", "avca", "evcf", "AVconn", "avci", "broadloc", "broadcfg", "broadcmp", "evcontext", "abcf", "avcf", "aveca", "abconfig", "evctrl", "avectrl", "afctx", "avecmp", "afconn", "avconn", "akctx", "avebc", "abloc", "awci", "AVcontext", "broadcal", "avctrl", "Avctx", "evctx", "aveloc", "avcmp", "evcmp", "avconfig", "awcfg", "wavcontext", "wavconn", "AVctrl", "AVca", "avcal", "abcfg", "afcmp", "avcfg", "evconfig", "avcontext", "Avloc", "AVcmp", " avci", "abcmp", "broadctx", "avloc", "abca", "wavctx", "broadcontext", "AVctx"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26841, "substitutes": {"s": ["js", "its", "a", "status", "qs", "conf", "changes", "sv", "S", "gs", "state", "self", "rs", "os", "ops", "ssl", "sb", "private", "fs", "g", "rates", "storage", "session", "states", "ps", "new", "ts", "es", "is", "l", "ks", "service", "p", "m", "sym", "t", "cs", "args", "south", "sets", "ms", "ns", "sg", "si", "sie", "e", "sync", "c", "settings", "d", "ss", "f", "ls", "ds", "xs", "services", "sq", "server", "parts", "o", "us", "ses", "sys", "stats"], "value": ["index", "set", "status", "key", "balance", "state", "id", "message", "byte", "shift", "end", "timeout", "fee", "VALUE", "info", "total", "current", "image", "money", "number", "flow", "type", "result", "max", "v", "io", "store", "range", "version", "address", "u", "w", "buffer", "scale", "si", "block", "Value", "d", "start", "val", "values", "data", "memory", "name", "length", "offset"], "size": ["ize", "z", "shift", "timeout", "len", "fee", "g", "type", "six", "ish", "is", "style", "SIZE", "code", "address", "unit", "now", "scale", "capacity", "si", "time", "small", "loc", "c", "from", "sec", "sized", "data", "ui", "ci", "Size", "name", "length", "offset"], "i": ["index", "b", "ai", "x", "oi", "li", "pi", "n", "ie", "child", "id", "j", "ia", "info", "r", "iu", "ip", "ix", "bi", "l", "is", "v", "h", "io", "fi", "ti", "ini", "multi", "p", "m", "zi", "t", "I", "di", "u", "it", "ii", "k", "si", "e", "c", "d", "eni", "f", "length", "data", "ui", "ci", "iv", "o", "ni", "ji", "a", "mi"], "data_count": ["data_data", "data_size", "data\u00b7value", " data_start", "data_type", "data_pool", "dataCstart", " data_list", " data_type", " data_pool", "data\u00b7data", " data_cache", "dataClen", "data_len", "data_value", " data_length", "data\u00b7count", "dataCsize", "data_length", "data\u00b7size", "data_start", " data_data", "dataCcount", " data_value", "data_cache", "data_list", " data_size", " data_len"]}}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848, "substitutes": {"opts": ["copts", "copters", "cattes", "opcs", "operrs", "optts", "opertp", " optp", "copcs", "opercs", " opcs", "opertes", "opters", " opters", "catts", "oprs", "optrs", "optes", "catrs", "coptp", "optp", "operts", "optcs", "catcs", "opttes", "operters"], "filename": ["sf", "unc", "path", "driver", "dll", "func", "fil", "loader", "ssl", "binary", "kl", "fd", "wl", "wb", "params", "which", "fp", "url", "src", "enc", "files", "il", "nil", "rl", "wcs", "username", "prefix", "acl", "file", "directory", "fn", "Filename", "sn", "kn", "name", "tty"], "chr": ["chtr", "ichar", " chrl", "anchrt", "ochar", "coldr", " chrar", "pprb", "gyar", "CHrt", "cherf", " chsr", "colri", "ochrt", "anchrr", "chdr", "shre", "ppru", "Chsr", "chcr", "ichr", " chri", "colre", "cheru", "colcr", "anchra", "phr", "partre", "partrr", "colsr", "cpsr", "colrt", "Chcr", "ichrf", "partrt", "cprar", "chrr", " chdr", "cprl", "CHr", "Chr", "ppr", "shr", "chre", " chra", "phri", "cher", "ichtr", "chri", "gyr", "cherr", "ichrar", "partr", " chcr", "colr", "phrt", "pprf", "colrr", "gyrt", "ichrb", "ichsr", "chrf", "chsr", "chrt", "chrar", "ochri", "chera", "gytr", "chru", "ichrl", "shrr", "chrl", "CHar", "ichrt", "cherb", "Chrr", "ichru", "CHri", "cpr", "shrt", "anchr", "chra", " chtr", "chert", " chrr", "chrb", " chrt", "phdr", "ochr"], "s": ["js", "b", "scope", "sf", "n", "sl", "status", "state", "S", "gs", "rs", "space", "ops", "sid", "sb", "ssl", "fs", "r", "g", "storage", "session", "ps", "aws", "params", "es", "v", "h", "src", "share", "p", "m", "sym", "t", "south", "w", "socket", "u", "ns", "sg", "si", "settings", "e", "c", "ss", "f", "i", "spec", "ds", "services", "sq", "o", "ses", "sys"]}}
{"project": "FFmpeg", "commit_id": "a91d82b5cc7d828ea9779aae1595f60e7e257d29", "target": 1, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n\n    // However the Coding Technologies decoder check uses 6 patches\n\n    if (sbr->num_patches > 6) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26862, "substitutes": {"ac": ["fc", "mic", "dc", "soc", "AC", "bc", "anc", "ca", "acer", "cc", "cms", "aic", "ack", "aut", "Ac", "arc", "mc", "cache", "fac", "auc", "acc", "cam", "jac", "oc", "vc", "ic", "iac", "tc", "acs", "mac", "sac", "acl", "ct", "rc", "doc", "exec", "c", "pc", "am", "ad"], "sbr": ["insbl", "setsbr", "sgr", "ssoper", "confbert", "sfr", " sobi", " sfr", "lshr", "osbert", "dsbl", "esarr", "insbro", "jsbro", " soder", "nsber", "sinbl", "osibr", "gsber", "sber", " sbar", "sbar", "sysbl", "ssbl", "tsbr", "isdiv", "nsbar", "ansfr", "tsoulder", "ansber", "lsher", " soper", "dsbert", "wsbro", "ssarr", "wsbr", "setsbl", " sBR", "fsbar", "ssfr", "wsarr", "esgr", "asdb", "soper", "tsfr", "lsstr", "setsdiv", "setsorb", "sibr", "nsbr", "sbe", "fsbr", "confibr", " sorb", "jsbre", "dshr", " sbre", "lsbert", "gsbl", "isbar", "nsdb", "tsbre", "ssbr", " soulder", "lsbar", "asbr", "tsibr", "psbr", "lsbr", "jshr", "esstr", "confbridge", "sbl", " sler", "chesber", "sesbert", " sher", "sfer", "lsfr", "eshr", "sorb", "singr", " sgr", "wsber", "isbl", "sysibr", "sher", "psdr", "ansbro", "sinbre", "nsbre", "ssBR", "tsBR", "outsbert", "sler", "esbar", " sbert", "lsBR", "asibr", "setsbre", "alsibr", "insbr", "asbl", "chesbr", "gshr", "confbr", "sesbridge", "setsbar", "sysoulder", " shr", "esibr", "shr", "ansarr", "sstr", "confbre", "sbert", "dsbridge", "sbre", "nsstr", " sdiv", "opensarr", "tsbro", "opensbridge", "esorb", "lsbro", "psber", "anshr", "confbar", "sesibr", "ssher", "lsbridge", "tsbl", "wsbl", "gsfer", "sarr", "jsbar", "sysbert", "ansgr", "dsbr", "sinbr", "psbro", "setsbert", "soulder", "ssobi", "setsher", "sesbre", "outsbr", "esber", "jsbr", "osbr", "ansbre", "alsbert", "sobi", "sdb", " sbridge", "opensibr", "sbro", "chesbro", "sshr", "ansbr", "setsgr", "fsbridge", "isbre", "esbl", " sibr", "outsibr", "dsbar", " sarr", "opensbert", "sdiv", " sbl", "sysdr", "gsdr", "lsbl", " sstr", "outsbridge", "psbl", "fsbro", "confbl", "wsfr", "ssibr", "psfer", " sfer", "opensler", "nsbe", "soder", "gsoder", "opensbr", "osbridge", "lsber", "asbre", "sBR", "gsbridge", "sdr", "psbre", "asbe", "fshr", "sbridge", "inshr", " sber", "alsdr", "fsbl", "ssler", "opensobi", "sesbr", "dsBR", "wsBR", "asarr", "esbr", "ssber", "psstr", "ssbridge", "ansBR", "lsbre", " sbro", "ishr", "gsbr", "ansbl", "ssbre", "isher", "alsbr", "isbr", " sdr", "chesbridge", "gsbre", "esbre", "psher", "wsbre", "sysbr", "gsbro", "jsbridge", "dsbre", "jsstr", "lsarr"], "i": ["x", "b", "index", "ai", "oi", "li", "pi", "n", "ie", "id", "j", "yi", "iu", "ix", "gi", "bi", "l", "v", "h", "y", "ti", "io", "xi", "ini", "p", "qi", "m", "ik", "s", "I", "di", "chi", "u", "ski", "it", "ii", "si", "e", "c", "d", "f", "ui", "ci", "phi", "o", "ni", "ri", "a", "ki", "mi"], "k": ["x", "b", "ke", "n", "key", "ch", "kin", "kid", "z", "id", "j", "tk", "ko", "ky", "kat", "ack", "kl", "g", "mc", "ck", "unk", "dk", "ku", "l", "work", "v", "h", "y", "ks", "kw", "ikk", "sk", "isk", "ek", "K", "p", "kt", "m", "ik", "s", "t", "u", "w", "ak", "kick", "uk", "ok", "e", "jj", "c", "ka", "d", "mk", "f", "kr", "km", "spec", "q", "ijk", "kk", "mm", "ad", "kn", "mask", "o", "kb", "kh", "ki"], "num_patches": ["num_aptching", "num_fetchers", "num_catures", "num_pits", "num_patouts", "num_atched", "num_partatches", "num_patchries", "num_pitched", "num_petched", "num_pitchers", "num_patters", "num_patching", "num_patchns", "num_patchters", "num_datche", "num_patchching", "num_patns", "num_atns", "num_pations", "num_pitches", "num_batouts", "num_patries", "num_partched", "num_datters", "num_parries", "num_patctions", "num_fetched", "num_patchhes", "num_patternches", "num_Pats", "num_patatches", "num_batches", "num_patrices", "num_partches", "num_Pations", "num_natches", "num_pats", "num_parches", "num_datches", "num_atencies", "num_petges", "num_patures", "num_apthes", "num_aptched", "num_fetctions", "num_patchs", "num_pitctions", "num_patternters", "num_catches", "num_atures", "num_pathes", "num_partries", "num_natrices", "num_patencies", "num_datched", "num_Patched", "num_patchches", "num_atchers", "num_butched", "num_aptchers", "num_ations", "num_natched", "num_petns", "num_catched", "num_patchched", "num_butries", "num_batched", "num_catrices", "num_catchers", "num_patchchers", "num_aptches", "num_patchctions", "num_patchions", "num_Patches", "num_patche", "num_fetches", "num_petchers", "num_patternche", "num_petions", "num_natges", "num_patchures", "num_butouts", "num_batries", "num_patternched", "num_patched", "num_aptries", "num_petencies", "num_petches", "num_patchers", "num_butches", "num_patchencies", "num_parhes", "num_patchatches", "num_pitries", "num_parching", "num_patges", "num_patchouts", "num_atches", "num_catges", "num_batatches", "num_pitions", "num_patchche", "num_petrices"]}}
{"project": "qemu", "commit_id": "977ec47de06bdcb24f01c93bc125b7c6c221a1c5", "target": 0, "func": "static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 26873, "substitutes": {"p": ["b", "port", "pb", "pi", "wp", "parent", "php", "proc", "cp", "r", "op", "g", "ps", "params", "fp", "y", "pool", "pre", "m", "t", "P", "w", "jp", "process", "e", "c", "param", "d", "i", "pc", "f", "data", "np", "o", "tp", "a", "pointer"], "info": ["index", "b", "fw", "afi", "alias", "worker", "pi", "error", "base", "conf", "inter", "fo", "id", "http", "j", "thin", "proc", "inf", "end", "ignore", "ctx", "function", "r", "op", "hi", "update", "image", "raf", "Info", "type", "gi", "is", "INFO", "work", "io", "slice", "fi", "check", "py", "inner", "config", "parse", "dev", "t", "di", "def", "w", "init", "bug", "handler", "si", "ph", "start", "extra", "f", "i", "ami", "linux", "diff", "data", "api", "offset"]}}
{"project": "FFmpeg", "commit_id": "0de1319ee0109facefe9804ffe0f0d0df36b27ad", "target": 0, "func": "static int http_start_receive_data(HTTPContext *c)\n\n{\n\n    int fd;\n\n\n\n    if (c->stream->feed_opened)\n\n        return -1;\n\n\n\n    /* Don't permit writing to this one */\n\n    if (c->stream->readonly)\n\n        return -1;\n\n\n\n    /* open feed */\n\n    fd = open(c->stream->feed_filename, O_RDWR);\n\n    if (fd < 0) {\n\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    c->feed_fd = fd;\n\n\n\n    if (c->stream->truncate) {\n\n        /* truncate feed file */\n\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n\n        ftruncate(c->feed_fd, FFM_PACKET_SIZE);\n\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n\n    } else {\n\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n\n    lseek(fd, 0, SEEK_SET);\n\n\n\n    /* init buffer input */\n\n    c->buffer_ptr = c->buffer;\n\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n\n    c->stream->feed_opened = 1;\n\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n\n    return 0;\n\n}\n", "idx": 26880, "substitutes": {"c": ["b", "coll", "fc", "rec", "dc", "n", "ch", "xc", "sc", "conf", "bc", "z", "ca", "nc", "anc", "ac", "cc", "cp", "self", "cy", "ctx", "r", "arc", "mc", "g", "cache", "l", "v", "conn", "ce", "cf", "enc", "con", "config", "cl", "vc", "p", "oc", "cs", "ic", "tc", "t", "s", "cr", "u", "C", "w", "cm", "rc", "ct", "ctrl", "k", "e", "uc", "exec", "d", "pc", "ec", "lc", "f", "i", "sec", "call", "co", "cu", "ci", "a", "cur"], "fd": ["buf", "fc", "sf", "sd", "dc", "df", "driver", "du", "hd", "ecd", "dy", "rd", "done", "fs", "dn", "reader", "fp", "pid", "conn", "fed", "fi", "did", "cf", "wd", "bd", "stream", "draw", "FD", "lf", "ln", "ld", "de", "md", "fun", "vd", "db", "handler", "die", "feed", "fff", "file", "fn", "dd", "d", "pd", "f", "fl", "af", "td", "ds", "bf", "dl", "fa", "fx", "ad", "wind", "fe", "xd", "fen", "cond", "ff", "nd", "draft", " fid", "fb", "cd"]}}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884, "substitutes": {"opaque": ["Opica", "compatile", "compacity", "opatile", "Opaque", "opifice", "obacity", "compifice", "opica", "obaque", "compaque", "paque", "patile", "opacity", "copica", "Opifice", "obatile", "pacity", "copaque", "compica", "copifice"], "func": ["b", "loop", "fc", "unc", "worker", "parser", "bc", "lambda", "nc", "proc", "cc", "self", "xxx", "ctx", "function", "wrap", "attr", "asm", "job", "work", "conn", "con", "oc", "code", "util", "rl", "conv", "package", "callback", "fun", "Function", "wrapper", "loc", "exec", "fn", "pc", "lc", "cb", "apply", "layer", "aux", "ln"], "f": ["x", "b", "fw", "fc", "sf", "rf", "df", "fo", "fu", "fd", "fs", "r", "g", "l", "fp", "h", "fi", "v", "cf", "p", "fr", "m", "t", "F", "lf", "fm", "u", "of", "w", "fun", "handler", "feed", "file", "e", "c", "d", "i", "bf", "fa", "fen", "fe", "o", "ff", "fb"], "line": ["run", "lined", "entry", "mode", "id", "byte", "write", "header", "ne", "cell", "url", "frame", "lock", "lf", "ze", "page", "device", "el", "comment", "lines", "block", "sync", "limit", "tick", "user", "name", "ln", "Line", "nl", "key", "path", "err", "text", "end", "connection", "pin", "l", "style", "cl", "look", "lin", "buffer", "e", "c", "lc", "val", "lane", "status", "error", "message", "len", "liner", "board", "ine", "slice", "pass", "code", "route", "unit", "lo", "seq", " lines", "str", "data", "server", "engine", "sl", "cpu", "base", "source", "strip", "stack", "zip", "row", "word", "band", "LINE", "la", "de", "link", "db", "time", "file", "loc", "d", "pos", "list"], "buf": ["b", "port", "loop", "box", "home", "filename", "fd", "cache", "h", "brace", "frame", "gb", "lines", "ha", "block", "bridge", "ff", "fb", "fw", "context", "path", "rx", "aka", "vec", "bang", "text", "rb", "conn", "off", "exc", "buffer", "feat", "desc", "feed", "uno", "c", "msg", "runner", "que", "proc", "ptr", "pkg", "br", "vag", "fi", "src", "config", "queue", "code", "cmd", "seq", "str", "data", "uf", "bus", "gru", "buff", "cap", "uber", "grab", "prof", "stack", "ctx", "r", "band", "cv", "wb", "la", "v", "batch", "file", "loc", "uc", "bag", "cb", "ru"], "bus_num": ["bus_number", "class_num", "bus_info", " bus_name", "bus_name", " bus_number", "class_number", "device_name", "bus_count", " bus_id", "device_id", "bus_loc", "device_info", "device_loc", "class_count", "device_num", "bus_id"], "addr": ["enable", "dist", "alias", "align", "error", "id", "cmp", "nc", "proc", "ace", "ack", "over", "len", "ptr", "host", "ip", "pkg", "attr", "dr", "amd", "url", "advert", "ref", "conn", "src", "oa", "name", "route", "cmd", "address", "access", "vr", "device", "md", "rc", "wrapper", "el", "hop", "desc", "pad", "loc", "amp", "dd", "rt", "start", "layer", "data", "ann", "ad", "pos", "ord", "adr", "en", "nr", "offset"], "speed": ["index", "engine", "seed", "dist", "sex", "weight", "status", "rank", "driver", "mode", "score", "quick", "direction", "source", "id", "state", "send", "peed", "size", "type", "rate", "slow", "slice", "cost", "race", "style", "skip", "service", "power", "sort", "level", "performance", "order", "pass", "unit", "force", "kick", "scale", "powered", "time", "gain", "sync", "effect", "start", "delay", "spec", "reason", "Speed", "sn", "spin", "grade", "sign", "name", "class", "length", "strength", "offset"], "device_count": [" device_num", "driver_id", "device_list", "device_name", "device_id", "product_count", "driver_Count", " device_id", "product_code", " device_list", "device_Count", "driver_count", "device_num", "driver_code", "device_code"], "class_id": ["classalid", "class_num", "class__name", "classalcount", "class_pid", "product_num", "class__id", "class_name", "classalname", "class__code", "product_count", "class_ids", "product_ids", "product_code", "product_pid", "class_count", "product_like", "classallike", "class__ids", "class_code", "class_like"], "product_id": ["product_number", "productapppid", " product_type", "product_type", "class_pid", "class_name", " product_kid", "class_ids", "product_ids", "productappno", "productappname", "product_pid", "productappids", "productapptype", " product_number", " product_no", "product_no", "productappid", "product_kid"], "vendor_id": ["vendor_type", "vendor_name", "vendor__ad", "vendorPoolids", "vender_id", "vender_side", "vendorPoolname", "vendoreetype", "vendor_source", "vendoreelength", "vendor__id", "vendoreename", "vender_type", "vendor_side", "vendorPoolid", "vender_source", "vender_ids", "vendoreeid", "vendor_length", "vender_name", "vender_length", "vendor__name", "vendorPoolside", "vendor_ids", "vendor_ad", "vendor__ids"], "product_name": [" product_list", "product_number", " product_type", "product_type", "productactype", "productacname", "productaclist", " product_number", "productacid", "product_list"]}}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "substitutes": {"oc": ["isc", "coll", "fc", "unc", "oco", "oper", "soc", "ucc", "bc", "anc", "nc", "voc", "ac", "OC", "mc", "ocr", "aco", "acc", "oca", "roc", "alloc", "oci", "ocol", "om", "toc", "oid", "rc", "mac", "ogg", "comp", "cca", "ok", "loc", "uc", "c", "ec", "pc", "co", "o", "usc", "org", "ob"], "data": ["rec", "da", "ac", "func", "DATA", "board", "cache", "raw", "src", "acc", "config", "dev", "tc", "Data", "input", "device", "cm", "rc", "dd", "d", "ds", "load", "co", "ci", "dat"], "pcc": [" pcca", "pxc", " pacc", "ppcf", "Puc", "ppcc", "lpec", " pca", "pCC", "Pca", "cpcc", "cpcci", "lprc", "ppacc", "pca", "Prc", "cpca", "lpcci", "Pacc", "Pcci", "Pec", "prc", "crc", " pec", "pec", "fCC", "ccc", "pcf", "Pcc", "PCC", " pxc", "fcca", "lpcf", " pcf", "Pcca", "facc", "Pcf", " pCC", "puc", "cpcca", "cpCC", "lpcc", "lpcca", "pprc", "cpuc", " puc", "lpCC", "pcca", "pcci", " prc", "fcc", "ccf", "cacc", "Pxc", "pacc", "lpxc"], "cc": ["pg", "fc", "BC", " gcc", "ucc", "xc", "sc", "bc", "cmp", "ca", "nc", "anc", "ac", "self", "bb", "control", "ctx", "ctl", "cus", "mc", "cache", "ck", "cell", "cast", "conn", "ce", "cf", "acc", "cci", "go", "con", "config", "ect", "cel", "vc", "code", "cl", "cs", "ee", "tc", "cmd", "cn", "cur", "rc", "cm", "ctrl", "mac", "ct", "comp", "cca", "uc", "c", "inc", "gg", "ec", "pc", "lc", "CC", "co", "cu", "ci", "bec", "PC", "kk", "client", "RC", "ga", "cd"], "dc": ["fc", "dt", "da", "df", "bc", "duc", "sc", "ca", "nc", "ac", "disc", "mc", "cache", "ck", "director", "auc", "conn", "cf", "cci", "acc", "vc", "cr", "di", "tc", "rc", "mac", "design", "db", "cca", "doc", "uc", "c", "inc", "d", "ec", "pc", "lc", "ds", "DC", "co", "cu", "cdn", "ga", "cd"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "substitutes": {"vc": ["ant", "fc", "dc", "vm", "xc", "vs", "bc", "vec", "iw", "sv", "nc", "voc", "cc", "ga", "cp", "cy", "lv", "ctx", "vt", "ou", "nv", "vid", "wl", "cv", "ku", "dn", "fp", "conn", "ce", "cf", "wx", "cci", "wd", "service", "ic", "cs", "nec", "rl", "cn", "util", "vr", "rc", "ct", "vd", "VC", "ll", "rt", "loc", "c", "pc", "ec", "lc", "cli", "ls", "api", "serv", "cu", "ci", "client", "vv"]}}
{"project": "qemu", "commit_id": "7b62a955047934bab158e84ecb63cb432c193ace", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935, "substitutes": {"env": ["enable", "engine", "context", "scope", "port", "gr", "vs", "conf", "err", "state", "me", "proc", "cp", "environment", "er", "end", "ctx", "window", "enter", "ass", "cache", "cal", "v", "conn", "ce", "cf", "enc", "config", "manager", "queue", "code", "core", "exc", "args", "inst", "ev", "w", "console", "el", "db", "e", "exec", "eng", "export", "ea", "ec", "event", "server", "np", "en"]}}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "substitutes": {"env": ["reset", "req", "vt", "ne", "qt", "core", "address", "args", "ev", "eni", "cot", "uv", "osc", "cdn", "en", "her", "context", "dep", "pg", "conf", "nc", "shell", "end", "exe", "conn", "anne", "enc", "erv", "exc", "obj", "profile", "e", "img", "ext", "site", "que", "vm", "vs", "eur", "inet", "net", "proc", "environment", "loader", "enter", "config", "password", "stage", "jp", "export", "exec", "ea", "ec", "output", "np", "server", "org", "dat", "engine", "et", "chal", "ception", "eu", "energy", "dh", "ctx", "enh", "inv", "esi", "cv", "v", "dev", "init", "eve", "console", "forge", "db", "nw", "eng", "Environment", "global", "gear", "viron", "here"], "intno": ["indnumber", "initNO", "Intno", "structnumber", "intnumber", "idnos", "structnos", "pointname", " intNO", "integerno", "extnum", "integernumber", "integerdo", "idnumber", "uintNO", "argnot", "extdo", " inteno", "pointnum", "indnos", "argno", " intdo", "uintnum", "extno", "intdo", "uintno", " intNo", "intnum", "Intnos", " intnot", "intnr", " intnumber", "argname", "IntNo", "argnum", "indNO", "intnos", " intnum", "indnum", "uinteno", "intname", "pointno", "structna", "intNO", "INTNo", "integernum", "INTnr", "structNo", "structnr", "intNo", "Intna", "idno", "integereno", " intna", "intna", "extnumber", "INTno", "indno", "intnot", "pointNO", "integerNO", "inteno", "initnum", "INTnumber", "structno", " intnr", "idNO", " intname", " intnos", "pointnot", "initno"], "is_int": [" is_integer", "as_ci", "is6nt", "as_nt", "is_ci", " is_nt", "as_inter", " is_ip", "is6ci", "is_nt", "as_int", "as_INT", "is_INT", "is_ip", "is_integer", "is_inner", "is6inner", "is6int", "as_inner", "is_inter"], "error_code": ["error_codes", " error_mode", "errorwavecode", "error_mode", "errorwavemode", "errorwavecodes", "errorwavesize", " error_codes", " error_size", "error_size"], "next_eip": ["next_eips", "next_peip", "next_seep", "next_seip", "next_peep", "next_peIP", "next_eeip", "next_seIP", "next_feep", "next_feip", "next_eeep", "next_feof", "next_eeIP", "next_seof", "next_feIP", "next_peof", "next_eep", "next_eIP", "next_peips", "next_eeips", "next_eof", "next_seips"], "is_hw": ["is_rw", "is_ht", " is_iw", "isAether", "is_fw", "is_ether", " is_ht", "isAiw", " is_fw", "isAhw", " is_rw", "is_iw", " is_ether", "isAfw"], "dt": ["dq", "dc", "ut", "tm", "tk", "mt", "wt", "dh", "tz", "ta", "utm", "ctx", "vt", "tt", "qt", "dr", "bt", "fp", "kt", "tmp", "tc", "dm", "t", "cmd", "adr", "cm", "ct", "elt", "db", "target", "jp", "rt", "txt", "e", "ea", "td", "tn", "ds", "np", "tick", "tu", "tif", "tp", "dat", "uv", "DT"], "ptr": ["index", "reset", "ext", "port", "cmp", "proc", "count", "req", "pointers", "ctr", "len", "sp", "prot", "cache", "br", "attr", "dr", "eger", "fp", "slice", "ref", "tr", "src", "code", "alloc", "p", "address", "inst", "obj", "cur", "rc", "jp", "pad", "addr", "loc", "rt", "seq", "pt", "rot", "start", "Ptr", "td", "str", "pos", "reg", "fe", "memory", " pointer", "length", "pointer"], "ssp": ["assl", "ssl", "csl", "cslp", "sslp", "csm", "csp", "assm", "csslp", "asslp", "assp", "cssp", "ssm", "cssl", "cssm"], "type": ["x", "port", "weight", "key", "parent", "error", "value", "rel", "base", "id", "state", "shape", "count", "format", "test", "col", "ype", "action", "info", "op", "ip", "size", "y", "ref", "pe", "part", "style", "slice", "py", "null", "version", "label", "sort", "code", "p", "t", "address", "unit", "TYPE", "var", "scale", "loc", "block", "kind", "like", "mark", "types", "i", "layer", "typ", "val", "call", "map", "pos", "method", "o", "bit", "name", "class", "length", "ty", "Type"], "dpl": ["dfl", "dcfl", "fpl", " dPL", "dcpl", " dfl", "dPL", " dsl", "dcsl", "dsl", "ffl", "dcPL", "fPL", "fsl"], "selector": ["electors", "selectur", "selectors", "electory", "constructors", "processor", "constructor", "selectory", "constructory", "electur", "constructur", "processors", "processory", "processur", "elector"], "ss_dpl": ["ss_ppe", "ss_rdll", "ss_dpe", "ss_rdbl", "ss_pll", "ss_pbl", "ss_ppl", "ss_fbl", "ss_dll", "ss_fll", "ss_fpe", "ss_rdpe", "ss_rdpl", "ss_dbl", "ss_fpl"], "cpl": ["cps", "ctpy", "cPL", "xcps", "xcPL", " cpy", "xcpl", " cps", "ctpl", "ctPL", "ctps", "xcpy", " cPL", "cpy"], "has_error_code": ["has_error64call", "has_ror_size", "has_error_class", "has_ror_code", "has_active_code", "has_ror_codes", "has_err_code", "has_errorfulclass", "has_errorurecode", "has_error_count", "has_activeuresize", "has_activeureclass", "has_ror_call", "has_errorfulsize", "has_errorifcodes", "has_errorifcode", "has_active_class", "has_error_size", "has_errorurecount", "has_error64codes", "has_error_done", "has_errorfulcode", "has_erroruredone", "has_err_desc", "has_error64code", "has_ror_done", "has_errorurecall", "has_active_count", "has_errorfulcount", "has_erroruresize", "has_erroriferror", "has_errorureclass", "has_error_error", "has_err_codes", "has_err_error", "has_activeurecount", "has_error64size", "has_active_size", "has_activeurecode", "has_error_desc", "has_errorifdesc", "has_ror_count", "has_error_codes", "has_error_call"], "new_stack": ["raw_stack", "raw__window", "new_buffer", "newlstack", "newvalwindow", "newvalbuffer", "newvaltrace", "raw_trace", "new__trace", "new_trace", "new__buffer", "new__window", "newlbuffer", "newltrace", "raw_window", "raw__buffer", "new__stack", "raw_buffer", "raw__trace", "newlwindow", "raw__stack", "new_window", "newvalstack"], "shift": ["index", "dist", "seed", "weight", "align", "error", "cmp", "shape", "count", "ctr", "sh", "pull", "ip", "pop", "slice", "hift", "cost", "skip", "Shift", "address", "init", "push", "scale", "small", "sup", "block", "seq", "ind", "extra", "pos", "ff", "slave", "sum"], "e1": [" eone", "ec9", "p1", "p3", "ec2", "oe1", "ae32", " e9", "p2", "eone", "E6", "E1", " e6", "ec1", " e3", "ae1", "econe", "E2", "p6", "oe3", " e32", "e6", "Eone", "e9", "oe2", "ae3", "oe32", "e3", "e32", "E9", "E3", "ae2"], "e2": ["p8", "p1", "eeTwo", "ee3", "ee2", "p2", "ee8", "E4", "E1", "E32", "E6", "ea2", "ea8", " e6", " e3", "ee32", "e8", "E2", " eTwo", "E8", "ea6", "ea1", " e32", "e6", "ee1", "ee4", " e8", " e4", "ea4", "e3", "e32", "e4", "eTwo", "E3", "ETwo"], "offset": ["index", "alias", "error", "align", "slot", "len", "sp", "op", "ip", "position", "size", "slice", "skip", "address", "loc", "seq", "padding", "adjust", "pos", "order"], "esp": ["gp", "css", "parser", "expr", "ism", "ace", "cp", "eff", "lv", "sb", "sp", "asp", "esi", "pp", "resp", "isp", "xp", "slice", "sk", "py", "rss", "eb", "ef", "sg", "addr", "sup", "eps", "ss", "ep", "sw", "np", "sn", "esc", "yp", "temp", "arp", "ext"], "old_eip": ["old_peep", "old_eeid", "old_eeIP", "old_eid", "old_edid", "old_eeips", "old_peip", "old_peips", "old_peis", "old_eIP", "old_peid", "old_eeep", "old_seips", "old_aeis", "old_edip", "old_aeid", "old_seep", "old_eips", "old_seIP", "old_edIP", "old_seip", "old_eeip", "old_peIP", "old_aeIP", "old_eis", "old_edis", "old_aeip", "old_eep", "old_seid"], "sp_mask": ["sp_delay", "ss_delay", "ss_map", "sp_ask", "ss_ask", "sp_map", "ss_mask"], "mask": ["index", "depth", "alias", "weight", "key", "sum", "filter", "allow", "flags", "shape", "count", "bits", "ace", "header", "pull", "Mask", "info", "patch", "group", "op", "max", "field", "dr", "ask", "fix", "zero", "scan", "arr", "pack", "lock", "match", "args", "bug", "scale", "block", "ph", "data", "map", "flag", "sign", "bit", "class", "mark", "asks"]}}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945, "substitutes": {"env": ["site", "enable", "engine", "context", "scope", "que", "vm", "conf", "eu", "err", "nc", "environment", "er", "end", "req", "loader", "ctx", "gui", "ne", "enter", "window", "cache", "size", "cv", "iter", "v", "conn", " environment", "enc", "config", "app", "empty", "queue", "code", "core", "exc", "stage", "args", "ev", "init", "console", "el", "db", "e", "export", "eng", "exec", "ea", "eni", "ec", "f", "ep", "api", "event", "server", "np", "qa", "viron", "client", "en", "here", "ext"]}}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n", "idx": 26946, "substitutes": {"cpu": ["bench", "platform", "gp", "que", "vm", "pu", "prof", "kernel", "cmp", "proc", "cp", "loader", "hw", "ctx", "prem", "CP", "consumer", "cache", "appa", "module", "boot", "auc", "conn", "fi", "gpu", "roc", "pool", "computer", "config", "processor", "uci", "core", "cn", "socket", "console", "cgi", "process", "c", "linux", "hp", "CPU", "pc", "component", "cli", "cow", "clock", "cpp", "eni", "GPU", "pai", "lc", "gru", "chip", "runner", " CPU"], "hash": ["depth", "index", "reset", "array", "path", "base", "kernel", "count", "header", "host", "image", "cache", "number", "session", "secret", "root", "h", "url", "enc", "pool", "version", "hz", "queue", "empty", "password", "history", "address", "counter", "profile", "addr", "file", "node", "block", "module", "copy", "Hash", "global", "use", "ash", "user", "chip", "memory", "auth", "sum", "handle"], "secondary": ["lower", "protection", "seconds", "general", "remote", "security", "set", "Second", "message", "sub", "ssl", "final", "binary", "optional", "size", "secret", "international", "special", "external", " second", "primary", "ical", "complete", "initial", "south", "attribute", "protected", "small", "export", "transfer", "extra", "sec", "foreign", "second", "negative", "exclusive", "confirmed", "global", "server", "esc", "offset"], "ptem": ["pem", "pteme", "pemi", "apteman", "montem", "peme", "peman", "apteme", "pteman", "apte", "pe", "monteme", "pointe", "pointem", "aptem", "upteme", "ptemi", "upteman", "monte", "montemi", "pointemi", "pointeme", "uptem", "upte"], "pte": ["empte", "portem", "PTem", "ctec", "ptec", "ptel", "octem", "porte", "ctede", "ctee", "portel", "portee", "petem", "octee", "patchel", "petee", "octe", "emptem", "emptee", "cte", "octede", "patche", "PTe", "PTede", "PTee", "ptee", "petec", "ctem", "emptel", "patchee", "pete", "ptede", "PTec", "patchem"], "env": ["engine", "agent", "context", "scope", "chal", "vm", "dict", "conf", "err", "eu", "state", "energy", "visor", "esp", "eur", "net", "environment", "header", "ne", "cache", "v", "conn", "estate", " environment", "oa", "enc", "style", "config", "exc", "stage", "equ", "args", "profile", "ev", "cfg", "forge", "db", "ef", "desc", "settings", "e", "ani", "eng", "ea", "Environment", "eni", "ec", "dat", "np", "viron", "opt", "en", "ext"], "i": ["index", "x", "b", "ai", "mini", "oi", "li", "pi", "n", "key", "ji", "z", "id", "j", "abi", "yi", "iu", "ip", "esi", "ix", "ei", "gi", "bi", "l", "v", "ti", "fi", "mu", "io", "y", "uri", "xi", "ini", "h", "multi", "p", "qi", "zi", "m", "t", "I", "di", "ski", "u", "it", "ii", "k", "si", "e", "c", "start", "eni", "f", "d", "lc", "adi", "ind", "ui", "min", "ci", "vi", "phi", "o", "ri", "mi"], "token": ["seed", "scope", "tool", "KEN", "icon", "rule", "byte", "header", "binary", "function", "cache", "result", "character", "request", "ti", "url", "lock", "username", "socket", "device", "sync", "eni", "document", "fen", "tick", "cookie", "user", "future", "key", "path", "aa", "stop", "connection", "tag", "info", "notice", "service", "theme", "processor", "prefix", "callback", "buffer", "ok", "node", "random", "api", "o", "index", "note", "track", " Token", "timeout", "response", "len", "session", "attr", "secret", "resource", "fi", "uri", "config", "password", "channel", "ski", "target", "fn", "module", "data", "date", "ticket", "wt", "source", "reference", "ctx", "chain", "number", "uu", "oken", "setup", "element", "Token", "auth", "temp"], "pte0": ["pto1", "cte192", "pter1", "pteur080", "pti80", "cte080", "cte00", "ptE1", "pto6", "pte00", "ptee20", "ptoe25", "pti1", "cti0", "ptoe6", "peti80", "pti50", "ctee6", "ptee50", "ctee50", "pti0", "pete10", "pte18", "pte10", "pter0", "pto20", "ptele50", "pete18", "ptoe18", "ptoe0", "ctee080", "ptee0", "ptee6", "cti1", "ctee25", "cte2", "cte7", "peti0", "ptE25", "ctee00", "ptoe192", "ctee2", "pete0", "pete80", "cte6", "pte192", "pto18", "ptE0", "ctee0", "ptee00", "pte6", "pte50", "peti10", "ptee192", "ptea6", "ptE00", "pti18", "ptee080", "pti10", "ptee25", "pto80", "ptoe2", "cte25", "ptoe080", "pto0", "ptE20", "ptee2", "pte7", "pteur1", "ptoe10", "ptE6", "ptele0", "ptee1", "pte25", "pteur192", "cte0", "ptea1", "pte2", "pte20", "pte80", "ptea0", "ptee7", "peti18", "ptea2", "pti7", "pte080", "ctee1", "pto10", "ctee192", "ptoe00", "ctee7", "cte1", "cte20", "ctee20", "ptele7", "cte50", "ptoe80", "ptoe1", "pteur0", "ptele1"], "pte1": ["ptea1", "pointoe1", "pteye0", "pointe100", "pte31", "pteye1", "pte6", "ctee1001", "ptea6", "cteOne", "pointoe100", "pteeOne", "pteye1001", "ptee100", "ptoe0", "pte100", "pteone", "ptoe100", "cteone", "pointoe0", "ptee31", "pointoe31", "ptea0", "ptee0", "ptoe1001", "ptee6", "ptc1", "cteeone", "cteeOne", "cte1001", "pointe0", "ptoeOne", "pointe31", "ptee1001", "pteyeOne", "ptec31", "pteOne", "ptoe31", "ctee6", "ctee1", "pteeone", "pte1001", "ptcone", "cte6", "cte1", "ptec100", "ptc0", "ptec6", "ptee1", "ptec1", "pointe1", "pteaone", "ptoe1", "ctee0", "ptec0", "cte0"], "pte_index": ["pti_index", "pte_align", "pte__value", "pti_inc", "ptee_width", "ptee_offset", "pte_id", "ptee_ini", "pte_inc", "pte2index", "pte__i", "pte__id", "pte_i", "pti__inc", "pte0index", "pti_id", "pte__index", "pte2inc", "pte_width", "pte_value", "ptae_value", "ptae__index", "pte0id", "ptee_index", "pte0i", "pte__ini", "pti__id", "ptae__value", "ptee_align", "pti_i", "pte2i", "pte__inc", "pte2id", "pti__index", "ptae_index", "pte__offset", "ptae_offset", "pte0inc", "pte_offset", "ptae__offset", "pte_ini", "pti__i"]}}
{"project": "FFmpeg", "commit_id": "39f7620d76c7a133535ed7a535f7a74fefa6e435", "target": 0, "func": "static av_cold int dcadec_init(AVCodecContext *avctx)\n\n{\n\n    DCAContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->core.avctx = avctx;\n\n    s->exss.avctx = avctx;\n\n    s->xll.avctx = avctx;\n\n    s->lbr.avctx = avctx;\n\n\n\n    ff_dca_init_vlcs();\n\n\n\n    if (ff_dca_core_init(&s->core) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (ff_dca_lbr_init(&s->lbr) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ff_dcadsp_init(&s->dcadsp);\n\n    s->core.dcadsp = &s->dcadsp;\n\n    s->xll.dcadsp = &s->dcadsp;\n\n    s->lbr.dcadsp = &s->dcadsp;\n\n\n\n    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);\n\n\n\n    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {\n\n    case 0:\n\n        s->request_channel_layout = 0;\n\n        break;\n\n    case AV_CH_LAYOUT_STEREO:\n\n    case AV_CH_LAYOUT_STEREO_DOWNMIX:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT0:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT1:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_WARNING, \"Invalid request_channel_layout\\n\");\n\n        break;\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n\n    avctx->bits_per_raw_sample = 24;\n\n\n\n    return 0;\n\n}\n", "idx": 26947, "substitutes": {"avctx": ["avcb", "avxc", "avcci", "AVcas", "avecf", "afcu", "afci", "navcit", "aucu", "navcmp", "ajcit", "avcmd", " avcn", " avconn", "aveconn", " avcontext", "avectx", "ajcb", "avalcontext", "afcontext", "ajcp", "avcp", " avcci", " avcu", " avcit", "avecontext", "AVloc", "airci", "avecci", "avalctx", "navcas", "ajcontext", "afxc", "afcn", "AVcb", "ajcmp", "AVcmd", "AVconfig", "avci", "afconfig", "auconn", "AVcp", "airctx", "aveconfig", "avalcf", "avcu", "avcf", "afctx", "avalcb", "avecmp", "AVci", "afconn", "avconn", "avcit", "AVcit", "auxc", "aucontext", "AVcontext", "AVcf", "AVcu", "aveloc", "avcmp", "avconfig", "afcci", "aircu", "ajctx", "avecmd", "navctx", "avalcmp", "wavcontext", "avecb", "avcn", "ajcmd", "avcas", "wavcu", "avecn", "afcmp", "avcontext", "avecp", "AVcmp", "avecu", "navcontext", "ajcas", " avxc", "avloc", "wavcmp", "aircontext", "avalloc", "auctx", "afcit", "navloc", "wavctx", "AVctx"], "s": ["js", "b", "S", "rs", "ssl", "sb", "fs", "g", "states", "h", "hs", "p", "features", "args", "u", "sets", "si", "sync", "sq", "a", "as", "n", "qs", "secondary", "conf", "gs", "aws", "es", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "its", "vs", "self", "ops", "session", "ans", "ts", "is", "y", "m", "sym", "w", "side", "sg", "this", "f", "ds", "data", "ses", "sys", "sl", "sv", "os", "r", "bs", "ps", "v", "ins", "ns", "d", "i", "sec", "ls", "services", "us", "sum"]}}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) {\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t i, j;\n\n\n\n    vc->mapping_count=get_bits(gb, 6)+1;\n\n    vc->mappings=(vorbis_mapping *)av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));\n\n\n\n    AV_DEBUG(\" There are %d mappings. \\n\", vc->mapping_count);\n\n\n\n    for(i=0;i<vc->mapping_count;++i) {\n\n        vorbis_mapping *mapping_setup=&vc->mappings[i];\n\n\n\n        if (get_bits(gb, 16)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\");\n\n            return 1;\n\n        }\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->submaps=get_bits(gb, 4)+1;\n\n        } else {\n\n            mapping_setup->submaps=1;\n\n        }\n\n\n\n        if (get_bits1(gb)) {\n\n            mapping_setup->coupling_steps=get_bits(gb, 8)+1;\n\n            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            for(j=0;j<mapping_setup->coupling_steps;++j) {\n\n                mapping_setup->magnitude[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                // FIXME: sanity checks\n\n            }\n\n        } else {\n\n            mapping_setup->coupling_steps=0;\n\n        }\n\n\n\n        AV_DEBUG(\"   %d mapping coupling steps: %d \\n\", i, mapping_setup->coupling_steps);\n\n\n\n        if(get_bits(gb, 2)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%d. mapping setup data invalid. \\n\", i);\n\n            return 1; // following spec.\n\n        }\n\n\n\n        if (mapping_setup->submaps>1) {\n\n            mapping_setup->mux=(uint_fast8_t *)av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));\n\n            for(j=0;j<vc->audio_channels;++j) {\n\n                mapping_setup->mux[j]=get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        for(j=0;j<mapping_setup->submaps;++j) {\n\n            skip_bits(gb, 8); // FIXME check?\n\n            mapping_setup->submap_floor[j]=get_bits(gb, 8);\n\n            mapping_setup->submap_residue[j]=get_bits(gb, 8);\n\n\n\n            AV_DEBUG(\"   %d mapping %d submap : floor %d, residue %d \\n\", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26971, "substitutes": {"vc": ["ant", "fw", "plugin", "fc", "dc", "vm", "wp", "qs", "xc", "bc", "iw", "sv", "http", "voc", "ac", "cc", "ga", "lv", "bb", "vp", "hw", "ctx", "vt", "ou", "gui", "nv", "cache", "qt", "wl", "cv", "dk", "dn", "ku", "v", "wx", "cf", "wd", "service", "config", "ic", "cs", "util", "wcs", "ft", "cit", "vr", "rc", "input", "ctrl", "vd", "VC", "rt", "ll", "sys", "c", "sync", "gg", "lc", "cli", "api", "serv", "cat", "cu", "ci", "uv", "iv", "client", "auth", "vv", "cur"], "gb": ["b", "gz", "bc", "mode", "metadata", "yg", "sb", "binary", "agg", "g", "gc", "gd", "gy", "mb", "ogg", "git", "bridge", "ci", "usb", "bg", "bm", "pg", "gio", "gh", "gs", "cc", "gin", "gt", "rb", "rg", "gpu", "rc", "cgi", "eb", "pc", "gnu", "lc", "bf", "api", "lane", "ui", "kb", "ga", "phy", "gm", "gp", "nb", "gom", "hd", "lib", "bb", "kg", "bo", "bn", "GB", "cfg", "gam", "sg", "gg", "gru", "vg", "gae", "ko", "hw", "ctx", "game", "storage", "wb", "cv", "hub", "multi", "db", "gram", "cb", "lb", "uv"], "i": ["x", "b", "ai", "index", "oi", "li", "pi", "n", "ie", "key", "z", "id", "count", "abi", "yi", "info", "iu", "ip", "ix", "gi", "ri", "bi", "is", "l", "v", "y", "io", "fi", "ti", "uri", "xi", "ini", "multi", "p", "qi", "m", "ik", "zi", "di", "I", "u", "it", "ii", "k", "si", "c", "d", "eni", "f", "ind", "ui", "ci", "phi", "ni", "ji", "ki", "mi"], "j": ["js", "b", "index", "kj", "adj", "jet", "x", "li", "n", "ja", "key", "ch", "aj", "ie", "z", "note", "jo", "sp", "jam", "g", "job", "l", "v", "y", "ij", "xi", "oj", "bj", "p", "m", "fr", "t", "ld", "obj", "el", "jp", "k", "si", "jc", "e", "jj", "d", "f", "jit", "jl", "uj", "pos", "o", "ji", "dj", "J"], "mapping_setup": ["mappingpsync", "mappingMSetup", "mappingallsite", "mapper_layout", "mapping_scale", "mappingtsetup", "mappingpspec", "mippingallsite", "mashing_setup", "mipping_scope", "mapping_layout", "mappingacsetup", "mappingersync", "mappingacscale", "mappingfsetup", "mappingjsetup", "mappings_install", "mippingallscope", "mapped_scale", "mappingerset", "mapping_install", "minding_Setup", "moding_set", "mapping_connect", "matingfinit", "mating_install", "mappingpset", "mappingallscope", "mapping_boot", "mapping_config", "mappingMdatabase", "mappingjreset", "mapping_sync", "mappingsallsetup", "maming_database", "matingfsetup", "mapping___setup", "mapper_setup", "mapping_Setup", "mapping_create", "mapping___connect", "moding_reset", "mippingallsetup", "matching_install", "matingfinstall", "mappingMsetup", "mapping_database", "mapping_site", "mappingfinit", "matingfsite", "mappingpinstall", "matchingfspec", "mapper_reset", "mashing_set", "minding_setup", "mipping_site", "mapper_spec", "mappingjlayout", "matching_spec", "mappings_boot", "mappingtconfig", "mapper_config", "macing_handle", "mashing_sync", "mashing_layout", "mappingfset", "mappingfsite", "mappingtboot", "mapping_root", "mappingsallboot", "mapper_set", "mapping___set", "mappingacerror", "mappingfsync", "mappingallset", "mapper_boot", "mapper_connect", "macing_sett", "mapper_root", "minding_set", "mappingallboot", "mapping_sett", "mapping_scope", "matchingfinstall", "mappingflayout", "mating_setup", "mappingersite", "moding_setup", "mappingerreset", "mipping_setup", "matching_setup", "mapping_error", "moding_sync", "mapping_set", "mappings_setup", "mapping___spec", "mappingerspec", "mapped_setup", "mappingsallinstall", "mappingerconnect", "minding_create", "mappingallinstall", "mating_site", "mappingerhandle", "mippingallset", "maming_setup", "mappingtroot", "mappingersett", "mappingallsetup", "macing_reset", "macing_setup", "mapping_reset", "mappingfspec", "mappingfinstall", "matchingfsetup", "mappingersetup", "mipping_set", "maming_scale", "maming_Setup", "mapped_error", "mappingjset", "mappingMscale", "mapping_spec", "mapping_init", "mapping_handle", "mappingerscope", "mappingpsetup", "mating_init", "mappingplayout"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987, "substitutes": {"dev": ["sd", "mod", "ch", "conf", "proc", "od", "hw", "rad", "private", "info", "attr", "serial", "mem", "gd", "conn", "priv", "ver", "cam", "app", "grad", "pro", "devices", "def", "pub", "ev", "de", "device", "Dev", "var", "link", "w", "die", "dd", "d", "data", "bus", "ad", "reg", "prom", "temp"], "taddr": ["vgrad", "vaddress", "lwork", "tgrad", " twork", " tpointer", " tmac", "Taddr", "tpointer", " taddress", "laddr", "laddress", "vaddr", "twork", "Taddress", " tgrad", "lpointer", "Tmac", "taddress", "Tgrad", "tmac", "vmac", "Twork", "Tpointer"], "val": ["x", "b", "index", "bl", "sl", "key", "value", "base", "slot", "byte", "count", "write", "valid", "eval", "test", "len", "sel", "fee", "bal", "alt", "vol", "cal", "v", "all", "ref", "al", "py", "VAL", "enc", "aval", "pre", "p", "vals", "arr", "grad", "ee", "unit", "fail", "def", "tx", "gold", "el", "db", "arg", "pt", "sec", "data", "Val", "cond", "bin", "fl"]}}
{"project": "FFmpeg", "commit_id": "066fff755a5d8edc660c010ddb08474d208eeade", "target": 0, "func": "static void vp6_parse_coeff_models(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    VP56Model *model = s->modelp;\n\n    int def_prob[11];\n\n    int node, cg, ctx, pos;\n\n    int ct;    /* code type */\n\n    int pt;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    memset(def_prob, 0x80, sizeof(def_prob));\n\n\n\n    for (pt=0; pt<2; pt++)\n\n        for (node=0; node<11; node++)\n\n            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {\n\n                def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            }\n\n\n\n    if (vp56_rac_get(c)) {\n\n        for (pos=1; pos<64; pos++)\n\n            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))\n\n                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);\n\n        vp6_coeff_order_table_init(s);\n\n    }\n\n\n\n    for (cg=0; cg<2; cg++)\n\n        for (node=0; node<14; node++)\n\n            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))\n\n                model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);\n\n\n\n    for (ct=0; ct<3; ct++)\n\n        for (pt=0; pt<2; pt++)\n\n            for (cg=0; cg<6; cg++)\n\n                for (node=0; node<11; node++)\n\n                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {\n\n                        def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    }\n\n\n\n    if (s->use_huffman) {\n\n        for (pt=0; pt<2; pt++) {\n\n            vp6_build_huff_tree(s, model->coeff_dccv[pt],\n\n                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);\n\n            vp6_build_huff_tree(s, model->coeff_runv[pt],\n\n                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);\n\n            for (ct=0; ct<3; ct++)\n\n                for (cg = 0; cg < 6; cg++)\n\n                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n\n                                        vp6_huff_coeff_map, 12,\n\n                                        &s->ract_vlc[pt][ct][cg]);\n\n        }\n\n        memset(s->nb_null, 0, sizeof(s->nb_null));\n\n    } else {\n\n    /* coeff_dcct is a linear combination of coeff_dccv */\n\n    for (pt=0; pt<2; pt++)\n\n        for (ctx=0; ctx<3; ctx++)\n\n            for (node=0; node<5; node++)\n\n                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);\n\n    }\n\n}\n", "idx": 26988, "substitutes": {"s": ["js", "b", "sf", "n", "sl", "qs", "set", "a", "sc", "conf", "sv", "S", "self", "os", "space", "ssl", "sb", "fs", "r", "g", "series", "session", "ps", "states", "ts", "es", "params", "v", "ks", "src", "service", "config", "p", "cs", "m", "t", "args", "u", "su", "ns", "sg", "si", "settings", "e", "d", "f", "sec", "spec", "ss", "i", "services", "sq", "serv", "models", "se", "ses", "sys"], "c": ["x", "b", "coll", "dc", "n", "ch", "sc", "com", "z", "ca", "nc", "ac", "cc", "cy", "chain", "r", "arc", "g", "mc", "cus", "cache", "cell", "cycle", "controller", "l", "v", "h", "ce", "cf", "con", "config", "roc", "cl", "vc", "p", "code", "cs", "m", "ic", "channel", "cn", "t", "u", "C", "rc", "cm", "comp", "center", "k", "e", "uc", "d", "f", "pc", "lc", "ec", "q", "cat", "cu", "ci"], "model": ["engine", "coll", "bm", "scope", "parent", "base", "member", "conf", "mode", "ca", "message", "me", "body", "lib", "Model", "gui", "image", "storage", "cell", "session", "record", "type", "cal", "command", "v", "template", "style", "query", "store", "config", "service", "manager", "instance", "p", "code", "core", "m", "util", "package", "db", "comment", "view", "gu", "block", "module", "f", "sim", "copy", "data", "mm", "ml", "document", "global", "models", "server", "builder", "method", "client", "xml", "form", "ga"], "def_prob": ["def_prop", "def_cobi", "def_propp", "def_propb", "defedprobs", "def_prec", "def_defbs", "def_prebe", "def_preb", "def_defp", "def_priber", "def_Probs", "def_defb", "def_funb", "def_cobs", "def_Probi", "defedcobe", "def_perb", "def_prom", "defedcober", "def_cober", "defedprober", "defedcob", "def_perf", "def_Prop", "def_prep", "def_proc", "def_Probe", "def_prem", "def_perbe", "def_defbe", "defedcobs", "def_funp", "defedprobe", "defedprob", "def_perbs", "def_cobe", "def_perc", "def_cob", "def_pref", "def_pribe", "def_probe", "def_prib", "def_Prob", "def_propbs", "def_propf", "def_prober", "def_prebs", "def_pribs", "def_propm", "def_prof", "def_funbe", "def_probs", "def_funbs", "def_Proc", "def_perm", "def_probi"], "node": ["seed", "dc", "remote", "child", "custom", "id", "ne", "cell", "type", "dn", "ref", "core", "line", "page", "device", "na", "block", "cdn", "ni", "name", "en", "post", "cur", "depth", "ode", "num", "n", "anch", "set", "path", "parent", "live", "nc", "edge", "shape", "cp", "end", "col", "Node", "nt", "host", "conn", "enc", "wd", "callback", "nn", "point", "pc", "msg", "event", "nd", "slave", "index", "site", "note", "od", "full", "len", "op", "position", "session", "no", "location", "src", "config", "route", "stage", "cmd", "peer", "hop", "cod", "fn", "gen", "ng", "layer", "call", "card", "anc", "source", "ko", "row", "day", "word", "image", "coord", "part", "package", "local", "pn", "loc", "nw", "d", "component", "object", "tree", "load", "global", "dest", "nm"], "cg": ["ecgs", "pga", "lcgi", "ecg", "rcg", " cgy", "acgn", "pmg", "nmg", "pgp", "rcgs", "ucgi", " cgu", " cgen", " cga", "pgn", "lcga", "pgc", " cgp", "ecgp", "pgen", "acgi", " cgm", "cgs", "ncgin", "ngc", " cgc", "pg", "cachegu", "ngu", "lcgn", "ecgy", "cgy", "cachegs", "cgi", " cgs", "pgi", "cgen", "ecgn", "acga", "cgc", "ecgen", "rcgi", " cgn", " cgh", "cgm", "rcgu", "cga", "cgin", "cgn", "cacheg", "ucgh", "cgu", "Cg", "ncgy", "ngn", "Cga", "cgh", "Cgu", "ng", "pgm", "ucgu", "lcg", "cachega", "ecgin", "cmg", "acmg", " cgi", " cmg", "acgu", "lcgs", "ucg", "Cgs", "ncg", "cgp", "Cgn", " cgin", "acgs", "ncgs", "ngm", "pgu", "lcgu", "Cgh", "acg", "Cgi"], "ctx": ["dc", "rx", "xc", "bc", "anc", "nc", "ac", "cc", "cp", "gt", "gc", "conn", "cf", "wd", "config", "act", "cmd", "cn", "obj", "rc", "cm", "tx", "init", "cca", "na", "loc", "sq", "ci", "qa"], "pos": ["x", "index", "prop", "num", "port", "coll", "Pos", "pl", "n", "parent", "pose", "j", "slot", "ko", "os", "col", "pot", "len", "sp", "ass", "op", "nt", "position", "vid", "size", "axis", "type", "pp", "ps", "no", "l", "pid", "neg", "slice", "part", "ref", "pass", "p", "act", "def", "unit", "obj", "po", "comp", "pse", "loc", "block", "seq", "doc", "pc", "f", "ind", "i", "val", "pr", "o", "post", "offset"], "ct": ["ant", "et", "ot", "n", "sl", "dc", "dt", "xc", "nat", "bc", "wt", "mt", "nc", "count", "cc", "apt", "sth", "th", "col", "Ct", "cent", "gt", "nt", "qt", "cont", "conn", "wd", "enc", "capt", "ect", "config", "cl", "vc", "kt", "xx", "act", "cr", "t", "cn", "ft", "ld", "unit", "cmd", "CT", "cca", "rt", "loc", "ind", "lat", "pc", "cod", "lit", "val", "pet", "cat", "lt", "ci", "ht", "st", "opt", "post", "cd"], "pt": ["platform", "port", "rect", "ept", "count", "patch", "qt", "type", "px", "station", "p", "yt", "line", " pts", "pty", "thread", "tp", "post", "pg", "pl", "anch", "parent", "mt", "xt", "text", "pot", "col", "gt", "nt", "host", "pid", "cl", "kt", "t", "PT", "ft", "vert", "obj", "pit", "point", "ind", "pc", "val", "pet", "cond", "st", "pm", "j", "apt", "sth", "ptr", "br", "cmd", "peer", "po", "rt", "ot", "et", "sl", "dt", "day", "pp", "ps", "part", "act", "ld", "pn", "tx", "loc", "td", "round", "ht", "lt", "pr", "pa"]}}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n", "idx": 26993, "substitutes": {"opts": ["copts", "copters", "ropts", "opps", "otps", "optts", "hopss", "ppters", "hops", "otss", "optps", "ops", "hopts", "ropents", "opss", "optters", "ots", "hopters", "opls", "opters", " opters", "optls", "opents", "ppts", "copt", "ppps", "copls", "ppls", "otents", "ropps", "optss", " opps", " opt", "ropt", "optt", "opt", "optents", "otts", "ott", "otters", "copps"], "v": ["x", "b", "V", "n", "volt", "vs", "z", "sv", "j", "ve", "lv", "av", "vp", "vt", "g", "ov", "cv", "vol", "l", "h", "p", "m", "conv", "t", "vert", "u", "ev", "vv", "k", "e", "c", "d", "f", "i", "tv", "q", "va", "val", "vi", "iv", "o", "verb", "uv"], "userdef": ["iodefinition", "userDEF", "plugindef", "pluginblock", "Userdf", "userdf", " userdefined", "Userdef", "perdev", "Userdefinition", "personDEF", "userdev", "ioblock", "plugindefinition", "userblock", "iodef", "groupdefinition", "userdefined", "iodf", " userDEF", "groupDEF", "perdef", "userdefinition", " userpass", "groupdef", "persondefined", " userdefinition", "Userdev", "Userblock", "persondefinition", "userpass", "Userpass", "persondef", "plugindf", "groupdefined", " userdev", "perpass"]}}
{"project": "qemu", "commit_id": "67a0fd2a9bca204d2b39f910a97c7137636a0715", "target": 0, "func": "static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n", "idx": 27000, "substitutes": {"bs": ["js", "b", "pb", "bl", "base", "vs", "bc", "blocks", "state", "gs", "bh", "bits", "os", "bb", "ubs", "sb", "bos", "fs", "obs", "ps", "las", "ins", "gb", "cs", "ab", "iss", "acs", "ns", "BS", "ss", "ls", "ds", "cb", "ses", "ob", "bis", "fb"], "sector_num": ["sectorpref", " sector_header", "sector_ref", "section_num", "section_name", " sector_number", "section_ref", "sectorIdnumber", "sectorpnum", " sector_name", "section_number", "sectorIdheader", "sector_number", "sectorIdnum", "sector_header", "sectorIdname", "sector_name", "sectorpnumber", "sectorpname"], "nb_sectors": ["nb_sengments", "nb_severs", "nb_psectors", "nb_veures", "nb_psegments", "nb_seonents", "nb_siures", "nb_senures", "nb_seures", "nb_vevers", "nb_sector", "nb_senctors", "nb_sigments", "nb_gector", "nb_senvers", "nb_sictors", "nb_gectors", "nb_sivers", "nb_veonents", "nb_segments", "nb_pseonents", "nb_gegments", "nb_psector", "nb_vector", "nb_vectors", "nb_vegments", "nb_geonents"], "pnum": ["ynums", "PNUM", "dnum", "pnums", "natom", "lnum", "ynUM", "dnUM", "natums", "pnom", "pnUM", "lnums", "PNumm", "ynum", "PNum", "pnumm", "dnumm", "natum", "lnom", "lnumm", "PNums", "PNom", "ynumm", "natumm", "dnums"], "s": ["js", "b", "scope", "sl", "secondary", "conf", "state", "S", "http", "gs", "rs", "os", "ops", "sb", "ssl", "fs", "g", "session", "states", "ts", "is", "sa", "l", "sk", "service", "hs", "sis", "p", "cs", "sym", "t", "m", "south", "u", "w", "sets", "side", "su", "ns", "si", "bis", "sie", "e", "sync", "c", "settings", "d", "ss", "f", "ds", "stat", "services", "sq", "serv", "server", "o", "ses", "sys", "stats"], "offset": ["index", "adjusted", "alias", "et", "set", "parent", "align", "base", "error", "value", "alpha", "slot", "ace", "shift", "offer", "timeout", "Offset", "len", "fee", "option", "image", "position", "optional", "size", "operation", "number", "notation", "usage", "location", "fp", "url", "slice", "part", "off", "style", "origin", "p", "lock", "address", "attribute", "missing", "addr", "append", "loc", "sync", "limit", "start", "padding", "clock", "i", "data", "pos", "o", "length", "pointer"]}}
{"project": "qemu", "commit_id": "c5b9729ae918b890905e00870ffc08c9b56e6d17", "target": 0, "func": "void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)\n\n{\n\n    ppcemb_tlb_t *tlb;\n\n    target_ulong page, end;\n\n\n\n    LOG_SWTLB(\"%s entry %d val \" TARGET_FMT_lx \"\\n\", __func__, (int)entry,\n\n              val);\n\n    entry &= 0x3F;\n\n    tlb = &env->tlb[entry].tlbe;\n\n    /* Invalidate previous TLB (if it's valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate old TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);\n\n    /* We cannot handle TLB size < TARGET_PAGE_SIZE.\n\n     * If this ever occurs, one should use the ppcemb target instead\n\n     * of the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n", "idx": 27007, "substitutes": {"entry": ["index", "Entry", "sl", "ie", "key", "ticket", "mid", "win", "value", "inter", "parent", "id", "byte", "slot", "count", "write", "sel", "row", "try", "enter", "insert", "image", "nt", "cell", "field", "reader", "ref", "enc", "cel", "line", "ell", "ent", "match", "ge", "rc", "ident", "cur", "si", "feed", "e", "inc", "start", "ind", "element", "sec", "import", "event", "server", "ry", "se", "pointer", "post", "offset"], "val": ["index", "x", "prop", "num", "port", "bl", "sl", "key", "win", "value", "base", "ret", "id", "slot", "valid", "eval", "col", "test", "len", "sel", "pol", "cache", "sol", "vol", "mem", "item", "v", "cal", "all", "ref", "pid", "la", "al", "ver", "py", "VAL", "isal", "aval", "cel", "p", "vals", "def", "vert", "gold", "el", "elt", "arg", "ol", "loc", "e", "doc", "pt", "seq", "start", "ind", "i", "data", "serv", "min", "Val", "vi", "reg", "pos", "pr", "sil", "fl", "offset"], "tlb": ["totalLB", "utdl", "twlp", "untlc", "untdl", " tlbs", "gtlp", "ktdl", " tLB", " tls", " tctrl", "tll", "notlb", "ttlam", "pbl", "lbl", "Trb", "tslp", "notlf", "tlab", "Tlf", " tsb", "utb", "llb", "lls", " tbl", "tLB", "Tlp", "tyb", "twlb", "Tlc", "attb", "testeb", "teb", "tdl", "retb", "ttbl", "attbl", " tlf", "Tll", "atb", "attlb", "tlr", "ttlbs", "tseb", "tlf", "ptlb", "twl", "twlab", "ttll", " tlc", "ktlab", "lacl", "atlc", "Tlab", "ttlb", " tdl", "retlam", "tctrl", "Tls", "totallb", " tl", "Tbl", "ntlb", "ttacl", "ntl", "atdl", "ttrb", "tacl", "testlr", "atwl", "ptlbs", "llab", "ctll", "tlp", "thelab", " tll", " twb", "ctlab", "Tlb", " tlp", "tl", "plab", "ttlr", "ntb", "ntbl", "utacl", "ttb", "untlab", "gtbl", "utlc", "retlb", "tsbl", " tlam", "Tl", "tyacl", "tslr", "tylb", "attsb", "pll", "atlab", "ttls", "ttctrl", "ptbl", "totallab", " tlab", "ttdl", "utLB", "ttLB", "tbl", "gtlab", "totalb", " tb", "thelp", "tslab", "lrb", "ttlab", "theb", "tsacl", "tsb", "ktwl", "atlb", "tb", "utlb", "tls", "tslb", "retlab", "ttlc", "attlab", "attll", "plb", "ctbl", "retlc", "notls", "untlb", "atctrl", "lll", "trb", "testacl", "retsb", "ktlb", "twb", "gtlb", "tlbs", "tteb", "utlab", "ctlb", "ptb", "Tb", "notlc", "tlc", "utwb", "utwl", "Tsb", "ttsb", " tacl", "thelb", "Twb", "testlb", "lb", "tylab", "tlam"], "page": ["site", "num", "port", "pg", "pl", "win", "search", "value", "byte", "net", "edge", "count", "stop", "Page", "ew", "col", "row", "window", "total", "ip", "cache", "number", "size", "image", "field", "record", "result", "session", "pp", "item", "v", "pid", "url", "ref", "skip", "ver", "area", "p", "line", "month", "per", "w", "hop", "feed", "block", "inc", "c", "seq", "limit", "pc", "age", "start", "gap", "pages", "next", "server", "section", "order", "step", "offset"], "end": ["index", "x", "port", "ended", "n", "set", "win", "value", "z", "id", "edge", "stop", "send", "END", "len", "begin", "enter", "r", "update", "size", "tail", "max", "h", "url", "ending", "p", "line", "w", "End", "append", "e", "c", "limit", "start", "inc", "f", "ep", "event", "ad", "pos", "dest", "client", "en", "length", "post", "offset"]}}
{"project": "qemu", "commit_id": "fd563564222f308e1d86847efdec8555fb472536", "target": 1, "func": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n", "idx": 27021, "substitutes": {"private": ["set", "proc", "send", "test", "or", "secret", "new", "priv", "inner", "pass", "gate", "core", "util", "package", "pub", "def", "protected", "init", "public", "Private", "export", "exec", "event", "client"], "global": ["scope", "parent", "gl", "env", "debug", "let", "ctx", "final", "shared", "g", "master", "zero", "Global", "config", "empty", "gate", "util", "args", "local", "arg", "public", "export", "module", "stat", "reg"], "index": ["weight", "key", "set", "value", "len", "window", "info", "fix", "version", "address", "match", "prefix", "access", "scale", "view", "Index", "addr", "block", "seq", "unique", "diff", "val", "data", "pattern", "pos", "bit", "length"], "mask": ["weight", "mod", "allow", "card", "flags", "bits", "shift", "window", "patch", "group", "info", "master", "secret", "ask", "fix", "scan", "gate", "lock", "pack", "match", "comment", "scale", "random", "diff", "pattern", "map", "bit"], "entry": ["plugin", "array", "Entry", "key", "path", "ie", "error", "member", "card", "mode", "id", "source", "connection", "row", "enter", "info", "image", "nt", "cell", "session", "command", "service", "inner", "low", "parse", "pack", "route", "ent", "ge", "def", "de", "package", "match", "comment", "feed", "e", "export", "inc", "element", "module", "archive", "import", "component", "lc", "data", "event", "server", "cat", "section", "list", "ry", "name", "se"], "msg": ["comm", "help", "error", "err", "message", "debug", "gs", "req", "text", "info", "op", "g", "update", "pkg", "result", "get", "mg", "ref", "ma", "fg", "m", "util", "route", "cmd", "ge", "obj", "def", "og", "init", "cfg", "mess", "ms", "console", "comment", "sg", "gram", "md", "db", "node", "e", "doc", "arg", "Msg", "sim", "gen", "str", "data", "out", "nm", "cm", "mag"], "cnt": ["acnt", "crount", "lcount", "crNT", "acount", "Cnt", "ecno", "ncNT", "count", "Count", " count", "ncnt", "ctx", "Cno", " cct", "cNT", "ecount", " ctx", "Ccount", "crnt", "crct", "acNT", "eccount", "acct", "ecnt", "CNT", "nctx", "cno", "ncount", "lccount", "lcno", "Ctx", "ccount", "lcnt", "cct", " cNT"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n", "idx": 27045, "substitutes": {"opaque": ["copque", "OPque", "Opaque", "OPacity", "OPaques", "paques", "Opacity", "Opaques", "pque", "copacity", "operacity", "operaques", "paque", "OPaque", "opque", "Opque", "opacity", "copaques", "opaques", "pacity", "operaque", "copaque", "operque"], "sprn": ["rrn", "sprna", "rrN", " sprna", "Sprnc", "rrnc", " sprN", "sprns", "prn", "rrna", "SprN", "sprnc", " sprns", "sprN", "prN", "prna", "Sprns", "prnc", "Sprn", "Sprna", "prns"], "ctx": ["context", "scope", "unc", "rx", "cmp", "ca", "proc", "func", "cp", "pkg", "cv", "fp", "conn", "ref", "cf", "src", "Context", "config", " cx", "alloc", "tmp", "grad", "wcs", "prefix", "obj", "rc", "cm", "tx", "ctrl", "acl", "jp", "loc", "sync", "c", "exec", "bp", "pc", "lc", "cb", "qa", "abc", " context"]}}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046, "substitutes": {"s": ["js", "in", "S", "rs", "ssl", "sb", "fs", "g", "states", "new", "request", "hs", "tests", "sis", "p", "args", "u", "sets", "si", "sync", "xs", "parts", "a", "as", "qs", "conf", "state", "gs", "es", "l", "ims", "ks", "service", "cs", "t", "su", "sie", "e", "c", "ches", "ss", "spec", "o", "site", "its", "details", "your", "status", "sites", "self", "ops", "session", "ts", "is", "m", "sym", "side", "sg", "f", "ds", "server", "ses", "sys", "sl", "ions", "os", "uns", "ps", "south", "ns", "settings", "d", "i", "ls", "services", "us", "se"], "sector_num": ["section_unit", "section_num", " sector_number", "section_name", "sector_unit", "sector_su", "sector_sum", " sector_sum", " sector_name", "section_n", " sector_su", "sector_number", "sector_n", " sector_n", "sector_name"], "ret": ["nat", "id", "RET", "j", "len", " r", "ne", " RET", "nt", "fin", "g", " fun", "result", "br", "iter", "det", "ner", "conn", "al", "ern", "t", "nn", "fun", "ll", " Ret", "fn", "ind", "f", "sec", "val", "sn", "Ret", " result", "bit", "en", "re"], "n": ["x", "b", "num", "adj", "nl", "in", "un", "nb", "nat", "z", "j", "nc", "N", "mn", "net", "nor", "nan", "none", "ne", "r", "nt", "g", "dn", "l", "no", "y", "v", "conn", "name", "p", "rn", "m", "t", "cn", "nn", "w", "pn", "init", "ns", "k", "na", "an", "c", "fn", "d", "eni", "i", "f", "nu", "sn", "np", "o", "nm", "ni", "en", "nr"], "n1": ["ynif", "dOne", "num81", "ynvar", "na1", "nvar", "enif", "N0", "m0", "d1", "m1", " n0", "naone", "none", "nOne", " nname", "done", "n01", "N2", " n01", "n0", "rnOne", "N01", "d91", "sn1", " nOne", "nif", "n81", " n2", "unone", "numvar", "na91", "rnname", "sn2", "sn01", "num1", "n91", "un1", "rn0", "yn81", "N1", "yn1", "yn0", "ynOne", "n2", "unOne", "nname", "naOne", "un91", "rn1", "en1", "m2", "numif", "ynname", "envar", "en81"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n", "idx": 27048, "substitutes": {}}
{"project": "qemu", "commit_id": "6049f4f831c6f409031dfa09282b38d0cbaecad8", "target": 0, "func": "abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n\n                    abi_long arg2, abi_long arg3, abi_long arg4,\n\n                    abi_long arg5, abi_long arg6)\n\n{\n\n    abi_long ret;\n\n    struct stat st;\n\n    struct statfs stfs;\n\n    void *p;\n\n\n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\", num);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n\n\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef CONFIG_USE_NPTL\n\n      /* In old applications this may be used to implement _exit(2).\n\n         However in threaded applictions it is used for thread termination,\n\n         and _exit_group is used for application termination.\n\n         Do thread termination if we have more then one thread.  */\n\n      /* FIXME: This probably breaks if a signal arrives.  We should probably\n\n         be disabling signals.  */\n\n      if (first_cpu->next_cpu) {\n\n          TaskState *ts;\n\n          CPUState **lastp;\n\n          CPUState *p;\n\n\n\n          cpu_list_lock();\n\n          lastp = &first_cpu;\n\n          p = first_cpu;\n\n          while (p && p != (CPUState *)cpu_env) {\n\n              lastp = &p->next_cpu;\n\n              p = p->next_cpu;\n\n          }\n\n          /* If we didn't find the CPU for this thread then something is\n\n             horribly wrong.  */\n\n          if (!p)\n\n              abort();\n\n          /* Remove the CPU from the list.  */\n\n          *lastp = p->next_cpu;\n\n          cpu_list_unlock();\n\n          ts = ((CPUState *)cpu_env)->opaque;\n\n          if (ts->child_tidptr) {\n\n              put_user_u32(0, ts->child_tidptr);\n\n              sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n\n                        NULL, NULL, 0);\n\n          }\n\n          /* TODO: Free CPU state.  */\n\n          pthread_exit(NULL);\n\n      }\n\n#endif\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        if (arg3 == 0)\n\n            ret = 0;\n\n        else {\n\n            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n                goto efault;\n\n            ret = get_errno(read(arg1, p, arg3));\n\n            unlock_user(p, arg2, ret);\n\n        }\n\n        break;\n\n    case TARGET_NR_write:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(write(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n    case TARGET_NR_open:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(open(path(p),\n\n                             target_to_host_bitmask(arg2, fcntl_flags_tbl),\n\n                             arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n    case TARGET_NR_openat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_openat(arg1,\n\n                                   path(p),\n\n                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),\n\n                                   arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk(arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n\n        break;\n\n#ifdef TARGET_NR_waitpid\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int status;\n\n            ret = get_errno(waitpid(arg1, &status, arg3));\n\n            if (!is_error(ret) && arg2\n\n                && put_user_s32(host_to_target_waitstatus(status), arg2))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_waitid\n\n    case TARGET_NR_waitid:\n\n        {\n\n            siginfo_t info;\n\n            info.si_pid = 0;\n\n            ret = get_errno(waitid(arg1, arg2, &info, arg4));\n\n            if (!is_error(ret) && arg3 && info.si_pid != 0) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &info);\n\n                unlock_user(p, arg3, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_creat /* not on alpha */\n\n    case TARGET_NR_creat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(creat(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_link:\n\n        {\n\n            void * p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(link(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n    case TARGET_NR_linkat:\n\n        {\n\n            void * p2 = NULL;\n\n            if (!arg2 || !arg4)\n\n                goto efault;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n\n            unlock_user(p, arg2, 0);\n\n            unlock_user(p2, arg4, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_unlink:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(unlink(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n    case TARGET_NR_unlinkat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_unlinkat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_execve:\n\n        {\n\n            char **argp, **envp;\n\n            int argc, envc;\n\n            abi_ulong gp;\n\n            abi_ulong guest_argp;\n\n            abi_ulong guest_envp;\n\n            abi_ulong addr;\n\n            char **q;\n\n\n\n            argc = 0;\n\n            guest_argp = arg2;\n\n            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                argc++;\n\n            }\n\n            envc = 0;\n\n            guest_envp = arg3;\n\n            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto efault;\n\n                if (!addr)\n\n                    break;\n\n                envc++;\n\n            }\n\n\n\n            argp = alloca((argc + 1) * sizeof(void *));\n\n            envp = alloca((envc + 1) * sizeof(void *));\n\n\n\n            for (gp = guest_argp, q = argp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            for (gp = guest_envp, q = envp; gp;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp))\n\n                    goto execve_efault;\n\n                if (!addr)\n\n                    break;\n\n                if (!(*q = lock_user_string(addr)))\n\n                    goto execve_efault;\n\n            }\n\n            *q = NULL;\n\n\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto execve_efault;\n\n            ret = get_errno(execve(p, argp, envp));\n\n            unlock_user(p, arg1, 0);\n\n\n\n            goto execve_end;\n\n\n\n        execve_efault:\n\n            ret = -TARGET_EFAULT;\n\n\n\n        execve_end:\n\n            for (gp = guest_argp, q = argp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n            for (gp = guest_envp, q = envp; *q;\n\n                  gp += sizeof(abi_ulong), q++) {\n\n                if (get_user_ual(addr, gp)\n\n                    || !addr)\n\n                    break;\n\n                unlock_user(*q, addr, 0);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_time\n\n    case TARGET_NR_time:\n\n        {\n\n            time_t host_time;\n\n            ret = get_errno(time(&host_time));\n\n            if (!is_error(ret)\n\n                && arg1\n\n                && put_user_sal(host_time, arg1))\n\n                goto efault;\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mknod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mknod(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n    case TARGET_NR_mknodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_chmod:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chmod(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_break\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldstat\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_getxpid\n\n    case TARGET_NR_getxpid:\n\n#else\n\n    case TARGET_NR_getpid:\n\n#endif\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n\t\t{\n\n\t\t\t/* need to look at the data field */\n\n\t\t\tvoid *p2, *p3;\n\n\t\t\tp = lock_user_string(arg1);\n\n\t\t\tp2 = lock_user_string(arg2);\n\n\t\t\tp3 = lock_user_string(arg3);\n\n                        if (!p || !p2 || !p3)\n\n                            ret = -TARGET_EFAULT;\n\n                        else {\n\n                            /* FIXME - arg5 should be locked, but it isn't clear how to\n\n                             * do that since it's not guaranteed to be a NULL-terminated\n\n                             * string.\n\n                             */\n\n                            if ( ! arg5 )\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n\n                            else\n\n                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n\n                        }\n\n                        unlock_user(p, arg1, 0);\n\n                        unlock_user(p2, arg2, 0);\n\n                        unlock_user(p3, arg3, 0);\n\n\t\t\tbreak;\n\n\t\t}\n\n#ifdef TARGET_NR_umount\n\n    case TARGET_NR_umount:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stime /* not on alpha */\n\n    case TARGET_NR_stime:\n\n        {\n\n            time_t host_time;\n\n            if (get_user_sal(host_time, arg1))\n\n                goto efault;\n\n            ret = get_errno(stime(&host_time));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_alarm /* not on alpha */\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldfstat\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_pause /* not on alpha */\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_utime\n\n    case TARGET_NR_utime:\n\n        {\n\n            struct utimbuf tbuf, *host_tbuf;\n\n            struct target_utimbuf *target_tbuf;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n\n                    goto efault;\n\n                tbuf.actime = tswapl(target_tbuf->actime);\n\n                tbuf.modtime = tswapl(target_tbuf->modtime);\n\n                unlock_user_struct(target_tbuf, arg2, 0);\n\n                host_tbuf = &tbuf;\n\n            } else {\n\n                host_tbuf = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utime(p, host_tbuf));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_utimes:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg2) {\n\n                if (copy_from_user_timeval(&tv[0], arg2)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(utimes(p, tvp));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n    case TARGET_NR_futimesat:\n\n        {\n\n            struct timeval *tvp, tv[2];\n\n            if (arg3) {\n\n                if (copy_from_user_timeval(&tv[0], arg3)\n\n                    || copy_from_user_timeval(&tv[1],\n\n                                              arg3 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n                tvp = tv;\n\n            } else {\n\n                tvp = NULL;\n\n            }\n\n            if (!(p = lock_user_string(arg2)))\n\n                goto efault;\n\n            ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_stty\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_gtty\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_access:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(access(path(p), arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n\n    case TARGET_NR_faccessat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_faccessat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_nice /* not on alpha */\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ftime\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sync:\n\n        sync();\n\n        ret = 0;\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(rename(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n    case TARGET_NR_renameat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user_string(arg4);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n\n            unlock_user(p2, arg4, 0);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_mkdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(mkdir(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n    case TARGET_NR_mkdirat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_mkdirat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rmdir:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(rmdir(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        ret = do_pipe(cpu_env, arg1, 0);\n\n        break;\n\n#ifdef TARGET_NR_pipe2\n\n    case TARGET_NR_pipe2:\n\n        ret = do_pipe(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n    case TARGET_NR_times:\n\n        {\n\n            struct target_tms *tmsp;\n\n            struct tms tms;\n\n            ret = get_errno(times(&tms));\n\n            if (arg1) {\n\n                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n\n                if (!tmsp)\n\n                    goto efault;\n\n                tmsp->tms_utime = tswapl(host_to_target_clock_t(tms.tms_utime));\n\n                tmsp->tms_stime = tswapl(host_to_target_clock_t(tms.tms_stime));\n\n                tmsp->tms_cutime = tswapl(host_to_target_clock_t(tms.tms_cutime));\n\n                tmsp->tms_cstime = tswapl(host_to_target_clock_t(tms.tms_cstime));\n\n            }\n\n            if (!is_error(ret))\n\n                ret = host_to_target_clock_t(ret);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_prof\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_signal\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_acct:\n\n        if (arg1 == 0) {\n\n            ret = get_errno(acct(NULL));\n\n        } else {\n\n            if (!(p = lock_user_string(arg1)))\n\n                goto efault;\n\n            ret = get_errno(acct(path(p)));\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_umount2 /* not on alpha */\n\n    case TARGET_NR_umount2:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(umount2(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lock\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        ret = do_fcntl(arg1, arg2, arg3);\n\n        break;\n\n#ifdef TARGET_NR_mpx\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n#ifdef TARGET_NR_ulimit\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_oldolduname\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chroot(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n\n    case TARGET_NR_dup3:\n\n        ret = get_errno(dup3(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getppid /* not on alpha */\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n#ifdef TARGET_NR_sigaction\n\n    case TARGET_NR_sigaction:\n\n        {\n\n#if !defined(TARGET_MIPS)\n\n            struct target_old_sigaction *old_act;\n\n            struct target_sigaction act, oact, *pact;\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n                act._sa_handler = old_act->_sa_handler;\n\n                target_siginitset(&act.sa_mask, old_act->sa_mask);\n\n                act.sa_flags = old_act->sa_flags;\n\n                act.sa_restorer = old_act->sa_restorer;\n\n                unlock_user_struct(old_act, arg2, 0);\n\n                pact = &act;\n\n            } else {\n\n                pact = NULL;\n\n            }\n\n            ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n                old_act->_sa_handler = oact._sa_handler;\n\n                old_act->sa_mask = oact.sa_mask.sig[0];\n\n                old_act->sa_flags = oact.sa_flags;\n\n                old_act->sa_restorer = oact.sa_restorer;\n\n                unlock_user_struct(old_act, arg3, 1);\n\n            }\n\n#else\n\n\t    struct target_sigaction act, oact, *pact, *old_act;\n\n\n\n\t    if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n\n                    goto efault;\n\n\t\tact._sa_handler = old_act->_sa_handler;\n\n\t\ttarget_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n\n\t\tact.sa_flags = old_act->sa_flags;\n\n\t\tunlock_user_struct(old_act, arg2, 0);\n\n\t\tpact = &act;\n\n\t    } else {\n\n\t\tpact = NULL;\n\n\t    }\n\n\n\n\t    ret = get_errno(do_sigaction(arg1, pact, &oact));\n\n\n\n\t    if (!is_error(ret) && arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n\n                    goto efault;\n\n\t\told_act->_sa_handler = oact._sa_handler;\n\n\t\told_act->sa_flags = oact.sa_flags;\n\n\t\told_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n\n\t\told_act->sa_mask.sig[1] = 0;\n\n\t\told_act->sa_mask.sig[2] = 0;\n\n\t\told_act->sa_mask.sig[3] = 0;\n\n\t\tunlock_user_struct(old_act, arg3, 1);\n\n\t    }\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigaction:\n\n        {\n\n            struct target_sigaction *act;\n\n            struct target_sigaction *oact;\n\n\n\n            if (arg2) {\n\n                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n\n                    goto efault;\n\n            } else\n\n                act = NULL;\n\n            if (arg3) {\n\n                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto rt_sigaction_fail;\n\n                }\n\n            } else\n\n                oact = NULL;\n\n            ret = get_errno(do_sigaction(arg1, act, oact));\n\n\trt_sigaction_fail:\n\n            if (act)\n\n                unlock_user_struct(act, arg2, 0);\n\n            if (oact)\n\n                unlock_user_struct(oact, arg3, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sgetmask /* not on alpha */\n\n    case TARGET_NR_sgetmask:\n\n        {\n\n            sigset_t cur_set;\n\n            abi_ulong target_set;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            host_to_target_old_sigset(&target_set, &cur_set);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ssetmask /* not on alpha */\n\n    case TARGET_NR_ssetmask:\n\n        {\n\n            sigset_t set, oset, cur_set;\n\n            abi_ulong target_set = arg1;\n\n            sigprocmask(0, NULL, &cur_set);\n\n            target_to_host_old_sigset(&set, &target_set);\n\n            sigorset(&set, &set, &cur_set);\n\n            sigprocmask(SIG_SETMASK, &set, &oset);\n\n            host_to_target_old_sigset(&target_set, &oset);\n\n            ret = target_set;\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sigprocmask\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_old_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n\n\n            if (arg2) {\n\n                switch(how) {\n\n                case TARGET_SIG_BLOCK:\n\n                    how = SIG_BLOCK;\n\n                    break;\n\n                case TARGET_SIG_UNBLOCK:\n\n                    how = SIG_UNBLOCK;\n\n                    break;\n\n                case TARGET_SIG_SETMASK:\n\n                    how = SIG_SETMASK;\n\n                    break;\n\n                default:\n\n                    ret = -TARGET_EINVAL;\n\n                    goto fail;\n\n                }\n\n                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n\n                    goto efault;\n\n                target_to_host_sigset(&set, p);\n\n                unlock_user(p, arg2, 0);\n\n                set_ptr = &set;\n\n            } else {\n\n                how = 0;\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n\n            if (!is_error(ret) && arg3) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &oldset);\n\n                unlock_user(p, arg3, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigpending\n\n    case TARGET_NR_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_old_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigpending:\n\n        {\n\n            sigset_t set;\n\n            ret = get_errno(sigpending(&set));\n\n            if (!is_error(ret)) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n\n                    goto efault;\n\n                host_to_target_sigset(p, &set);\n\n                unlock_user(p, arg1, sizeof(target_sigset_t));\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigsuspend\n\n    case TARGET_NR_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_old_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigsuspend:\n\n        {\n\n            sigset_t set;\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sigsuspend(&set));\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigtimedwait:\n\n        {\n\n            sigset_t set;\n\n            struct timespec uts, *puts;\n\n            siginfo_t uinfo;\n\n\n\n            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_sigset(&set, p);\n\n            unlock_user(p, arg1, 0);\n\n            if (arg3) {\n\n                puts = &uts;\n\n                target_to_host_timespec(puts, arg3);\n\n            } else {\n\n                puts = NULL;\n\n            }\n\n            ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n\n            if (!is_error(ret) && arg2) {\n\n                if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n\n                    goto efault;\n\n                host_to_target_siginfo(p, &uinfo);\n\n                unlock_user(p, arg2, sizeof(target_siginfo_t));\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n        {\n\n            siginfo_t uinfo;\n\n            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n\n                goto efault;\n\n            target_to_host_siginfo(&uinfo, p);\n\n            unlock_user(p, arg1, 0);\n\n            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_sigreturn\n\n    case TARGET_NR_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_sigreturn(cpu_env);\n\n        break;\n\n#endif\n\n    case TARGET_NR_rt_sigreturn:\n\n        /* NOTE: ret is eax, so not transcoding must be done */\n\n        ret = do_rt_sigreturn(cpu_env);\n\n        break;\n\n    case TARGET_NR_sethostname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(sethostname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n\n                goto efault;\n\n            rlim.rlim_cur = tswapl(target_rlim->rlim_cur);\n\n            rlim.rlim_max = tswapl(target_rlim->rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 0);\n\n            ret = get_errno(setrlimit(resource, &rlim));\n\n        }\n\n        break;\n\n    case TARGET_NR_getrlimit:\n\n        {\n\n            /* XXX: convert resource ? */\n\n            int resource = arg1;\n\n            struct target_rlimit *target_rlim;\n\n            struct rlimit rlim;\n\n\n\n            ret = get_errno(getrlimit(resource, &rlim));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                    goto efault;\n\n                target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n                target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n                unlock_user_struct(target_rlim, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getrusage:\n\n        {\n\n            struct rusage rusage;\n\n            ret = get_errno(getrusage(arg1, &rusage));\n\n            if (!is_error(ret)) {\n\n                host_to_target_rusage(arg2, &rusage);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                if (copy_to_user_timeval(arg1, &tv))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct timeval tv;\n\n            if (copy_from_user_timeval(&tv, arg1))\n\n                goto efault;\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_select\n\n    case TARGET_NR_select:\n\n        {\n\n            struct target_sel_arg_struct *sel;\n\n            abi_ulong inp, outp, exp, tvp;\n\n            long nsel;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n\n                goto efault;\n\n            nsel = tswapl(sel->n);\n\n            inp = tswapl(sel->inp);\n\n            outp = tswapl(sel->outp);\n\n            exp = tswapl(sel->exp);\n\n            tvp = tswapl(sel->tvp);\n\n            unlock_user_struct(sel, arg1, 0);\n\n            ret = do_select(nsel, inp, outp, exp, tvp);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_symlink:\n\n        {\n\n            void *p2;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg2);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(symlink(p, p2));\n\n            unlock_user(p2, arg2, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n    case TARGET_NR_symlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg1);\n\n            p2 = lock_user_string(arg3);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_symlinkat(p, arg2, p2));\n\n            unlock_user(p2, arg3, 0);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_oldlstat\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_readlink:\n\n        {\n\n            void *p2, *temp;\n\n            p = lock_user_string(arg1);\n\n            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n\n            if (!p || !p2)\n\n                ret = -TARGET_EFAULT;\n\n            else {\n\n                if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) {\n\n                    char real[PATH_MAX];\n\n                    temp = realpath(exec_path,real);\n\n                    ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n\n                    snprintf((char *)p2, arg3, \"%s\", real);\n\n                    }\n\n                else\n\n                    ret = get_errno(readlink(path(p), p2, arg3));\n\n            }\n\n            unlock_user(p2, arg2, ret);\n\n            unlock_user(p, arg1, 0);\n\n        }\n\n        break;\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n    case TARGET_NR_readlinkat:\n\n        {\n\n            void *p2;\n\n            p  = lock_user_string(arg2);\n\n            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n\n            if (!p || !p2)\n\n        \tret = -TARGET_EFAULT;\n\n            else\n\n                ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n\n            unlock_user(p2, arg3, ret);\n\n            unlock_user(p, arg2, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_uselib\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_swapon\n\n    case TARGET_NR_swapon:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapon(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_readdir\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_mmap\n\n    case TARGET_NR_mmap:\n\n#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE)\n\n        {\n\n            abi_ulong *v;\n\n            abi_ulong v1, v2, v3, v4, v5, v6;\n\n            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n\n                goto efault;\n\n            v1 = tswapl(v[0]);\n\n            v2 = tswapl(v[1]);\n\n            v3 = tswapl(v[2]);\n\n            v4 = tswapl(v[3]);\n\n            v5 = tswapl(v[4]);\n\n            v6 = tswapl(v[5]);\n\n            unlock_user(v, arg1, 0);\n\n            ret = get_errno(target_mmap(v1, v2, v3,\n\n                                        target_to_host_bitmask(v4, mmap_flags_tbl),\n\n                                        v5, v6));\n\n        }\n\n#else\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mmap2\n\n    case TARGET_NR_mmap2:\n\n#ifndef MMAP_SHIFT\n\n#define MMAP_SHIFT 12\n\n#endif\n\n        ret = get_errno(target_mmap(arg1, arg2, arg3,\n\n                                    target_to_host_bitmask(arg4, mmap_flags_tbl),\n\n                                    arg5,\n\n                                    arg6 << MMAP_SHIFT));\n\n        break;\n\n#endif\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(target_munmap(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(target_mprotect(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_mremap\n\n    case TARGET_NR_mremap:\n\n        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n\n        break;\n\n#endif\n\n        /* ??? msync/mlock/munlock are broken for softmmu.  */\n\n#ifdef TARGET_NR_msync\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync(g2h(arg1), arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlock\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlock\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock(g2h(arg1), arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_mlockall\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_munlockall\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n#endif\n\n    case TARGET_NR_truncate:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(truncate(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n    case TARGET_NR_fchmodat:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_fchmodat(arg1, p, arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getpriority:\n\n        /* libc does special remapping of the return value of\n\n         * sys_getpriority() so it's just easiest to call\n\n         * sys_getpriority() directly rather than through libc. */\n\n        ret = get_errno(sys_getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n#ifdef TARGET_NR_profil\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_statfs:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg2, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs;\n\n#ifdef TARGET_NR_statfs64\n\n    case TARGET_NR_statfs64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(statfs(path(p), &stfs));\n\n        unlock_user(p, arg1, 0);\n\n    convert_statfs64:\n\n        if (!is_error(ret)) {\n\n            struct target_statfs64 *target_stfs;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n\n                goto efault;\n\n            __put_user(stfs.f_type, &target_stfs->f_type);\n\n            __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n\n            __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n\n            __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n\n            __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n\n            __put_user(stfs.f_files, &target_stfs->f_files);\n\n            __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n\n            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n\n            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n\n            __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n\n            unlock_user_struct(target_stfs, arg3, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs64:\n\n        ret = get_errno(fstatfs(arg1, &stfs));\n\n        goto convert_statfs64;\n\n#endif\n\n#ifdef TARGET_NR_ioperm\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_socketcall\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, arg2);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_accept\n\n    case TARGET_NR_accept:\n\n        ret = do_accept(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_bind\n\n    case TARGET_NR_bind:\n\n        ret = do_bind(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_connect\n\n    case TARGET_NR_connect:\n\n        ret = do_connect(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getpeername\n\n    case TARGET_NR_getpeername:\n\n        ret = do_getpeername(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockname\n\n    case TARGET_NR_getsockname:\n\n        ret = do_getsockname(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getsockopt\n\n    case TARGET_NR_getsockopt:\n\n        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_listen\n\n    case TARGET_NR_listen:\n\n        ret = get_errno(listen(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recv\n\n    case TARGET_NR_recv:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvfrom\n\n    case TARGET_NR_recvfrom:\n\n        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_recvmsg\n\n    case TARGET_NR_recvmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_send\n\n    case TARGET_NR_send:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendmsg\n\n    case TARGET_NR_sendmsg:\n\n        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_sendto\n\n    case TARGET_NR_sendto:\n\n        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shutdown\n\n    case TARGET_NR_shutdown:\n\n        ret = get_errno(shutdown(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socket\n\n    case TARGET_NR_socket:\n\n        ret = do_socket(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_socketpair\n\n    case TARGET_NR_socketpair:\n\n        ret = do_socketpair(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setsockopt\n\n    case TARGET_NR_setsockopt:\n\n        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_syslog:\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n\n\n    case TARGET_NR_setitimer:\n\n        {\n\n            struct itimerval value, ovalue, *pvalue;\n\n\n\n            if (arg2) {\n\n                pvalue = &value;\n\n                if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n\n                    || copy_from_user_timeval(&pvalue->it_value,\n\n                                              arg2 + sizeof(struct target_timeval)))\n\n                    goto efault;\n\n            } else {\n\n                pvalue = NULL;\n\n            }\n\n            ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n\n            if (!is_error(ret) && arg3) {\n\n                if (copy_to_user_timeval(arg3,\n\n                                         &ovalue.it_interval)\n\n                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n\n                                            &ovalue.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_getitimer:\n\n        {\n\n            struct itimerval value;\n\n\n\n            ret = get_errno(getitimer(arg1, &value));\n\n            if (!is_error(ret) && arg2) {\n\n                if (copy_to_user_timeval(arg2,\n\n                                         &value.it_interval)\n\n                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n\n                                            &value.it_value))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_stat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st;\n\n\n\n                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n\n                    goto efault;\n\n                memset(target_st, 0, sizeof(*target_st));\n\n                __put_user(st.st_dev, &target_st->st_dev);\n\n                __put_user(st.st_ino, &target_st->st_ino);\n\n                __put_user(st.st_mode, &target_st->st_mode);\n\n                __put_user(st.st_uid, &target_st->st_uid);\n\n                __put_user(st.st_gid, &target_st->st_gid);\n\n                __put_user(st.st_nlink, &target_st->st_nlink);\n\n                __put_user(st.st_rdev, &target_st->st_rdev);\n\n                __put_user(st.st_size, &target_st->st_size);\n\n                __put_user(st.st_blksize, &target_st->st_blksize);\n\n                __put_user(st.st_blocks, &target_st->st_blocks);\n\n                __put_user(st.st_atime, &target_st->target_st_atime);\n\n                __put_user(st.st_mtime, &target_st->target_st_mtime);\n\n                __put_user(st.st_ctime, &target_st->target_st_ctime);\n\n                unlock_user_struct(target_st, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_olduname\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_iopl\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n#ifdef TARGET_NR_idle\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_syscall\n\n    case TARGET_NR_syscall:\n\n    \tret = do_syscall(cpu_env,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0);\n\n    \tbreak;\n\n#endif\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            abi_long status_ptr = arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            abi_ulong target_rusage = arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr) {\n\n                    status = host_to_target_waitstatus(status);\n\n                    if (put_user_s32(status, status_ptr))\n\n                        goto efault;\n\n                }\n\n                if (target_rusage)\n\n                    host_to_target_rusage(target_rusage, &rusage);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_swapoff\n\n    case TARGET_NR_swapoff:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(swapoff(p));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_sysinfo:\n\n        {\n\n            struct target_sysinfo *target_value;\n\n            struct sysinfo value;\n\n            ret = get_errno(sysinfo(&value));\n\n            if (!is_error(ret) && arg1)\n\n            {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n\n                    goto efault;\n\n                __put_user(value.uptime, &target_value->uptime);\n\n                __put_user(value.loads[0], &target_value->loads[0]);\n\n                __put_user(value.loads[1], &target_value->loads[1]);\n\n                __put_user(value.loads[2], &target_value->loads[2]);\n\n                __put_user(value.totalram, &target_value->totalram);\n\n                __put_user(value.freeram, &target_value->freeram);\n\n                __put_user(value.sharedram, &target_value->sharedram);\n\n                __put_user(value.bufferram, &target_value->bufferram);\n\n                __put_user(value.totalswap, &target_value->totalswap);\n\n                __put_user(value.freeswap, &target_value->freeswap);\n\n                __put_user(value.procs, &target_value->procs);\n\n                __put_user(value.totalhigh, &target_value->totalhigh);\n\n                __put_user(value.freehigh, &target_value->freehigh);\n\n                __put_user(value.mem_unit, &target_value->mem_unit);\n\n                unlock_user_struct(target_value, arg1, 1);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_ipc\n\n    case TARGET_NR_ipc:\n\n\tret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_semget\n\n    case TARGET_NR_semget:\n\n        ret = get_errno(semget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semop\n\n    case TARGET_NR_semop:\n\n        ret = get_errno(do_semop(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_semctl\n\n    case TARGET_NR_semctl:\n\n        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgctl\n\n    case TARGET_NR_msgctl:\n\n        ret = do_msgctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgget\n\n    case TARGET_NR_msgget:\n\n        ret = get_errno(msgget(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgrcv\n\n    case TARGET_NR_msgrcv:\n\n        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_msgsnd\n\n    case TARGET_NR_msgsnd:\n\n        ret = do_msgsnd(arg1, arg2, arg3, arg4);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmget\n\n    case TARGET_NR_shmget:\n\n        ret = get_errno(shmget(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmctl\n\n    case TARGET_NR_shmctl:\n\n        ret = do_shmctl(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmat\n\n    case TARGET_NR_shmat:\n\n        ret = do_shmat(arg1, arg2, arg3);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_shmdt\n\n    case TARGET_NR_shmdt:\n\n        ret = do_shmdt(arg1);\n\n        break;\n\n#endif\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_clone:\n\n#if defined(TARGET_SH4)\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n\n#elif defined(TARGET_CRIS)\n\n        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n\n#else\n\n        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n\n#endif\n\n        break;\n\n#ifdef __NR_exit_group\n\n        /* new thread calls */\n\n    case TARGET_NR_exit_group:\n\n#ifdef TARGET_GPROF\n\n        _mcleanup();\n\n#endif\n\n        gdb_exit(cpu_env, arg1);\n\n        ret = get_errno(exit_group(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR_setdomainname:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(setdomainname(p, arg2));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        {\n\n            struct new_utsname * buf;\n\n\n\n            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n\n                goto efault;\n\n            ret = get_errno(sys_uname(buf));\n\n            if (!is_error(ret)) {\n\n                /* Overrite the native machine name with whatever is being\n\n                   emulated. */\n\n                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n\n                /* Allow the user to override the reported release.  */\n\n                if (qemu_uname_release && *qemu_uname_release)\n\n                  strcpy (buf->release, qemu_uname_release);\n\n            }\n\n            unlock_user_struct(buf, arg1, 1);\n\n        }\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n\n        break;\n\n#if !defined(TARGET_X86_64)\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86:\n\n        ret = do_vm86(cpu_env, arg1, arg2);\n\n        break;\n\n#endif\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_create_module\n\n    case TARGET_NR_create_module:\n\n#endif\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n#ifdef TARGET_NR_get_kernel_syms\n\n    case TARGET_NR_get_kernel_syms:\n\n#endif\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n#ifdef TARGET_NR_bdflush /* not on x86_64 */\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_sysfs\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(personality(arg1));\n\n        break;\n\n#ifdef TARGET_NR_afs_syscall\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR__llseek /* Not on alpha */\n\n    case TARGET_NR__llseek:\n\n        {\n\n#if defined (__x86_64__)\n\n            ret = get_errno(lseek(arg1, ((uint64_t )arg2 << 32) | arg3, arg5));\n\n            if (put_user_s64(ret, arg4))\n\n                goto efault;\n\n#else\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            if (put_user_s64(res, arg4))\n\n                goto efault;\n\n#endif\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_getdents:\n\n#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n\n        {\n\n            struct target_dirent *target_dirp;\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n\t    dirp = malloc(count);\n\n\t    if (!dirp) {\n\n                ret = -TARGET_ENOMEM;\n\n                goto fail;\n\n            }\n\n\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n\t\tstruct target_dirent *tde;\n\n                int len = ret;\n\n                int reclen, treclen;\n\n\t\tint count1, tnamelen;\n\n\n\n\t\tcount1 = 0;\n\n                de = dirp;\n\n                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                    goto efault;\n\n\t\ttde = target_dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n\t\t    treclen = reclen - (2 * (sizeof(long) - sizeof(abi_long)));\n\n                    tde->d_reclen = tswap16(treclen);\n\n                    tde->d_ino = tswapl(de->d_ino);\n\n                    tde->d_off = tswapl(de->d_off);\n\n\t\t    tnamelen = treclen - (2 * sizeof(abi_long) + 2);\n\n\t\t    if (tnamelen > 256)\n\n                        tnamelen = 256;\n\n                    /* XXX: may not be correct */\n\n                    pstrcpy(tde->d_name, tnamelen, de->d_name);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                    tde = (struct target_dirent *)((char *)tde + treclen);\n\n\t\t    count1 += treclen;\n\n                }\n\n\t\tret = count1;\n\n                unlock_user(target_dirp, arg2, ret);\n\n            }\n\n\t    free(dirp);\n\n        }\n\n#else\n\n        {\n\n            struct linux_dirent *dirp;\n\n            abi_long count = arg3;\n\n\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct linux_dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n#endif\n\n        break;\n\n#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n\n    case TARGET_NR_getdents64:\n\n        {\n\n            struct linux_dirent64 *dirp;\n\n            abi_long count = arg3;\n\n            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n\n                goto efault;\n\n            ret = get_errno(sys_getdents64(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct linux_dirent64 *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = de->d_reclen;\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = tswap16(reclen);\n\n                    tswap64s((uint64_t *)&de->d_ino);\n\n                    tswap64s((uint64_t *)&de->d_off);\n\n                    de = (struct linux_dirent64 *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n            unlock_user(dirp, arg2, ret);\n\n        }\n\n        break;\n\n#endif /* TARGET_NR_getdents64 */\n\n#ifdef TARGET_NR__newselect\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, arg2, arg3, arg4, arg5);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_poll\n\n    case TARGET_NR_poll:\n\n        {\n\n            struct target_pollfd *target_pfd;\n\n            unsigned int nfds = arg2;\n\n            int timeout = arg3;\n\n            struct pollfd *pfd;\n\n            unsigned int i;\n\n\n\n            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n\n            if (!target_pfd)\n\n                goto efault;\n\n            pfd = alloca(sizeof(struct pollfd) * nfds);\n\n            for(i = 0; i < nfds; i++) {\n\n                pfd[i].fd = tswap32(target_pfd[i].fd);\n\n                pfd[i].events = tswap16(target_pfd[i].events);\n\n            }\n\n            ret = get_errno(poll(pfd, nfds, timeout));\n\n            if (!is_error(ret)) {\n\n                for(i = 0; i < nfds; i++) {\n\n                    target_pfd[i].revents = tswap16(pfd[i].revents);\n\n                }\n\n                ret += nfds * (sizeof(struct target_pollfd)\n\n                               - sizeof(struct pollfd));\n\n            }\n\n            unlock_user(target_pfd, arg1, ret);\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_flock:\n\n        /* NOTE: the flock constant seems to be the same for every\n\n           Linux platform */\n\n        ret = get_errno(flock(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n\n                goto efault;\n\n            ret = get_errno(readv(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 1);\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(writev(arg1, vec, count));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n\n    case TARGET_NR_fdatasync:\n\n        ret = get_errno(fdatasync(arg1));\n\n        break;\n\n#endif\n\n    case TARGET_NR__sysctl:\n\n        /* We don't implement this, but ENOTDIR is always a safe\n\n           return value. */\n\n        ret = -TARGET_ENOTDIR;\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg2, 0);\n\n            ret = get_errno(sched_setparam(arg1, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getparam:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            ret = get_errno(sched_getparam(arg1, &schp));\n\n            if (!is_error(ret)) {\n\n                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n\n                    goto efault;\n\n                target_schp->sched_priority = tswap32(schp.sched_priority);\n\n                unlock_user_struct(target_schp, arg2, 1);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_setscheduler:\n\n        {\n\n            struct sched_param *target_schp;\n\n            struct sched_param schp;\n\n            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n\n                goto efault;\n\n            schp.sched_priority = tswap32(target_schp->sched_priority);\n\n            unlock_user_struct(target_schp, arg3, 0);\n\n            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n\n        }\n\n        break;\n\n    case TARGET_NR_sched_getscheduler:\n\n        ret = get_errno(sched_getscheduler(arg1));\n\n        break;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n        ret = get_errno(sched_get_priority_max(arg1));\n\n        break;\n\n    case TARGET_NR_sched_get_priority_min:\n\n        ret = get_errno(sched_get_priority_min(arg1));\n\n        break;\n\n    case TARGET_NR_sched_rr_get_interval:\n\n        {\n\n            struct timespec ts;\n\n            ret = get_errno(sched_rr_get_interval(arg1, &ts));\n\n            if (!is_error(ret)) {\n\n                host_to_target_timespec(arg2, &ts);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_nanosleep:\n\n        {\n\n            struct timespec req, rem;\n\n            target_to_host_timespec(&req, arg1);\n\n            ret = get_errno(nanosleep(&req, &rem));\n\n            if (is_error(ret) && arg2) {\n\n                host_to_target_timespec(arg2, &rem);\n\n            }\n\n        }\n\n        break;\n\n#ifdef TARGET_NR_query_module\n\n    case TARGET_NR_query_module:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_nfsservctl\n\n    case TARGET_NR_nfsservctl:\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_prctl:\n\n        switch (arg1)\n\n            {\n\n            case PR_GET_PDEATHSIG:\n\n                {\n\n                    int deathsig;\n\n                    ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n\n                    if (!is_error(ret) && arg2\n\n                        && put_user_ual(deathsig, arg2))\n\n                        goto efault;\n\n                }\n\n                break;\n\n            default:\n\n                ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n\n                break;\n\n            }\n\n        break;\n\n#ifdef TARGET_NR_arch_prctl\n\n    case TARGET_NR_arch_prctl:\n\n#if defined(TARGET_I386) && !defined(TARGET_ABI32)\n\n        ret = do_arch_prctl(cpu_env, arg1, arg2);\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_pread\n\n    case TARGET_NR_pread:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite:\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n            arg4 = arg5;\n\n#endif\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite(arg1, p, arg3, arg4));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_pread64\n\n    case TARGET_NR_pread64:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n\n            goto efault;\n\n        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, ret);\n\n        break;\n\n    case TARGET_NR_pwrite64:\n\n        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n\n            goto efault;\n\n        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n    case TARGET_NR_getcwd:\n\n        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n\n            goto efault;\n\n        ret = get_errno(sys_getcwd1(p, arg2));\n\n        unlock_user(p, arg1, ret);\n\n        break;\n\n    case TARGET_NR_capget:\n\n        goto unimplemented;\n\n    case TARGET_NR_capset:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigaltstack:\n\n#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\\n\n    defined(TARGET_M68K)\n\n        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUState *)cpu_env));\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sendfile:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_getpmsg\n\n    case TARGET_NR_getpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_putpmsg\n\n    case TARGET_NR_putpmsg:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_vfork\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n\n                        0, 0, 0, 0));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_ugetrlimit\n\n    case TARGET_NR_ugetrlimit:\n\n    {\n\n\tstruct rlimit rlim;\n\n\tret = get_errno(getrlimit(arg1, &rlim));\n\n\tif (!is_error(ret)) {\n\n\t    struct target_rlimit *target_rlim;\n\n            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n\n                goto efault;\n\n\t    target_rlim->rlim_cur = tswapl(rlim.rlim_cur);\n\n\t    target_rlim->rlim_max = tswapl(rlim.rlim_max);\n\n            unlock_user_struct(target_rlim, arg2, 1);\n\n\t}\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_truncate64\n\n    case TARGET_NR_truncate64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n\tret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n\n        unlock_user(p, arg1, 0);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_ftruncate64\n\n    case TARGET_NR_ftruncate64:\n\n\tret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_stat64\n\n    case TARGET_NR_stat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(stat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_lstat64\n\n    case TARGET_NR_lstat64:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lstat(path(p), &st));\n\n        unlock_user(p, arg1, 0);\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fstat64\n\n    case TARGET_NR_fstat64:\n\n        ret = get_errno(fstat(arg1, &st));\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg2, &st);\n\n        break;\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n\n#ifdef TARGET_NR_fstatat64\n\n    case TARGET_NR_fstatat64:\n\n#endif\n\n#ifdef TARGET_NR_newfstatat\n\n    case TARGET_NR_newfstatat:\n\n#endif\n\n        if (!(p = lock_user_string(arg2)))\n\n            goto efault;\n\n#ifdef __NR_fstatat64\n\n        ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n\n#else\n\n        ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n\n#endif\n\n        if (!is_error(ret))\n\n            ret = host_to_target_stat64(cpu_env, arg3, &st);\n\n        break;\n\n#endif\n\n#ifdef USE_UID16\n\n    case TARGET_NR_lchown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(high2lowuid(getuid()));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(high2lowgid(getgid()));\n\n        break;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(high2lowuid(geteuid()));\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(high2lowgid(getegid()));\n\n        break;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n\n                if (!target_grouplist)\n\n                    goto efault;\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap16(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 2);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_setgroups:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint16_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap16(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n\n        break;\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n\n    case TARGET_NR_fchownat:\n\n        if (!(p = lock_user_string(arg2))) \n\n            goto efault;\n\n        ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid\n\n    case TARGET_NR_setresuid:\n\n        ret = get_errno(setresuid(low2highuid(arg1),\n\n                                  low2highuid(arg2),\n\n                                  low2highuid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid\n\n    case TARGET_NR_getresuid:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowuid(ruid), arg1)\n\n                    || put_user_u16(high2lowuid(euid), arg2)\n\n                    || put_user_u16(high2lowuid(suid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_setresgid:\n\n        ret = get_errno(setresgid(low2highgid(arg1),\n\n                                  low2highgid(arg2),\n\n                                  low2highgid(arg3)));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid\n\n    case TARGET_NR_getresgid:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u16(high2lowgid(rgid), arg1)\n\n                    || put_user_u16(high2lowgid(egid), arg2)\n\n                    || put_user_u16(high2lowgid(sgid), arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n    case TARGET_NR_chown:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(low2highuid(arg1)));\n\n        break;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(low2highgid(arg1)));\n\n        break;\n\n    case TARGET_NR_setfsuid:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n    case TARGET_NR_setfsgid:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif /* USE_UID16 */\n\n\n\n#ifdef TARGET_NR_lchown32\n\n    case TARGET_NR_lchown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(lchown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getuid32\n\n    case TARGET_NR_getuid32:\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxuid:\n\n         {\n\n            uid_t euid;\n\n            euid=geteuid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n\n         }\n\n        ret = get_errno(getuid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n\n   /* Alpha specific */\n\n    case TARGET_NR_getxgid:\n\n         {\n\n            uid_t egid;\n\n            egid=getegid();\n\n            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n\n         }\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_getsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_GSI_IEEE_FP_CONTROL:\n\n            {\n\n                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n\n\n                /* Copied from linux ieee_fpcr_to_swcr.  */\n\n                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n\n                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n\n                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n\n                                        | SWCR_TRAP_ENABLE_DZE\n\n                                        | SWCR_TRAP_ENABLE_OVF);\n\n                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n\n                                        | SWCR_TRAP_ENABLE_INE);\n\n                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n\n                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n\n\n\n                if (put_user_u64 (swcr, arg2))\n\n                        goto efault;\n\n                ret = 0;\n\n            }\n\n            break;\n\n\n\n          /* case GSI_IEEE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel.\n\n             case GSI_UACPROC:\n\n             -- Retrieves current unaligned access state; not much used.\n\n             case GSI_PROC_TYPE:\n\n             -- Retrieves implver information; surely not used.\n\n             case GSI_GET_HWRPB:\n\n             -- Grabs a copy of the HWRPB; surely not used.\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n\n    /* Alpha specific */\n\n    case TARGET_NR_osf_setsysinfo:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        switch (arg1) {\n\n          case TARGET_SSI_IEEE_FP_CONTROL:\n\n          case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n\n            {\n\n                uint64_t swcr, fpcr, orig_fpcr;\n\n\n\n                if (get_user_u64 (swcr, arg2))\n\n                    goto efault;\n\n                orig_fpcr = cpu_alpha_load_fpcr (cpu_env);\n\n                fpcr = orig_fpcr & FPCR_DYN_MASK;\n\n\n\n                /* Copied from linux ieee_swcr_to_fpcr.  */\n\n                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n\n                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n\n                                  | SWCR_TRAP_ENABLE_DZE\n\n                                  | SWCR_TRAP_ENABLE_OVF)) << 48;\n\n                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n\n                                  | SWCR_TRAP_ENABLE_INE)) << 57;\n\n                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n\n                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n\n\n\n                cpu_alpha_store_fpcr (cpu_env, fpcr);\n\n                ret = 0;\n\n\n\n                if (arg1 == TARGET_SSI_IEEE_RAISE_EXCEPTION) {\n\n                    /* Old exceptions are not signaled.  */\n\n                    fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n\n\n\n                    /* If any exceptions set by this call, and are unmasked,\n\n                       send a signal.  */\n\n                    /* ??? FIXME */\n\n                }\n\n            }\n\n            break;\n\n\n\n          /* case SSI_NVPAIRS:\n\n             -- Used with SSIN_UACPROC to enable unaligned accesses.\n\n             case SSI_IEEE_STATE_AT_SIGNAL:\n\n             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n\n             -- Not implemented in linux kernel\n\n          */\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_osf_sigprocmask\n\n    /* Alpha specific.  */\n\n    case TARGET_NR_osf_sigprocmask:\n\n        {\n\n            abi_ulong mask;\n\n            int how = arg1;\n\n            sigset_t set, oldset;\n\n\n\n            switch(arg1) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -TARGET_EINVAL;\n\n                goto fail;\n\n            }\n\n            mask = arg2;\n\n            target_to_host_old_sigset(&set, &mask);\n\n            sigprocmask(arg1, &set, &oldset);\n\n            host_to_target_old_sigset(&mask, &oldset);\n\n            ret = mask;\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef TARGET_NR_getgid32\n\n    case TARGET_NR_getgid32:\n\n        ret = get_errno(getgid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_geteuid32\n\n    case TARGET_NR_geteuid32:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getegid32\n\n    case TARGET_NR_getegid32:\n\n        ret = get_errno(getegid());\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setreuid32\n\n    case TARGET_NR_setreuid32:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setregid32\n\n    case TARGET_NR_setregid32:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getgroups32\n\n    case TARGET_NR_getgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            ret = get_errno(getgroups(gidsetsize, grouplist));\n\n            if (gidsetsize == 0)\n\n                break;\n\n            if (!is_error(ret)) {\n\n                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n\n                if (!target_grouplist) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                for(i = 0;i < ret; i++)\n\n                    target_grouplist[i] = tswap32(grouplist[i]);\n\n                unlock_user(target_grouplist, arg2, gidsetsize * 4);\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgroups32\n\n    case TARGET_NR_setgroups32:\n\n        {\n\n            int gidsetsize = arg1;\n\n            uint32_t *target_grouplist;\n\n            gid_t *grouplist;\n\n            int i;\n\n\n\n            grouplist = alloca(gidsetsize * sizeof(gid_t));\n\n            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n\n            if (!target_grouplist) {\n\n                ret = -TARGET_EFAULT;\n\n                goto fail;\n\n            }\n\n            for(i = 0;i < gidsetsize; i++)\n\n                grouplist[i] = tswap32(target_grouplist[i]);\n\n            unlock_user(target_grouplist, arg2, 0);\n\n            ret = get_errno(setgroups(gidsetsize, grouplist));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_fchown32\n\n    case TARGET_NR_fchown32:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresuid32\n\n    case TARGET_NR_setresuid32:\n\n        ret = get_errno(setresuid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresuid32\n\n    case TARGET_NR_getresuid32:\n\n        {\n\n            uid_t ruid, euid, suid;\n\n            ret = get_errno(getresuid(&ruid, &euid, &suid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(ruid, arg1)\n\n                    || put_user_u32(euid, arg2)\n\n                    || put_user_u32(suid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setresgid32\n\n    case TARGET_NR_setresgid32:\n\n        ret = get_errno(setresgid(arg1, arg2, arg3));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_getresgid32\n\n    case TARGET_NR_getresgid32:\n\n        {\n\n            gid_t rgid, egid, sgid;\n\n            ret = get_errno(getresgid(&rgid, &egid, &sgid));\n\n            if (!is_error(ret)) {\n\n                if (put_user_u32(rgid, arg1)\n\n                    || put_user_u32(egid, arg2)\n\n                    || put_user_u32(sgid, arg3))\n\n                    goto efault;\n\n            }\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_chown32\n\n    case TARGET_NR_chown32:\n\n        if (!(p = lock_user_string(arg1)))\n\n            goto efault;\n\n        ret = get_errno(chown(p, arg2, arg3));\n\n        unlock_user(p, arg1, 0);\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setuid32\n\n    case TARGET_NR_setuid32:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setgid32\n\n    case TARGET_NR_setgid32:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsuid32\n\n    case TARGET_NR_setfsuid32:\n\n        ret = get_errno(setfsuid(arg1));\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setfsgid32\n\n    case TARGET_NR_setfsgid32:\n\n        ret = get_errno(setfsgid(arg1));\n\n        break;\n\n#endif\n\n\n\n    case TARGET_NR_pivot_root:\n\n        goto unimplemented;\n\n#ifdef TARGET_NR_mincore\n\n    case TARGET_NR_mincore:\n\n        {\n\n            void *a;\n\n            ret = -TARGET_EFAULT;\n\n            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n\n                goto efault;\n\n            if (!(p = lock_user_string(arg3)))\n\n                goto mincore_fail;\n\n            ret = get_errno(mincore(a, arg2, p));\n\n            unlock_user(p, arg3, ret);\n\n            mincore_fail:\n\n            unlock_user(a, arg1, 0);\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_arm_fadvise64_64\n\n    case TARGET_NR_arm_fadvise64_64:\n\n\t{\n\n\t\t/*\n\n\t\t * arm_fadvise64_64 looks like fadvise64_64 but\n\n\t\t * with different argument order\n\n\t\t */\n\n\t\tabi_long temp;\n\n\t\ttemp = arg3;\n\n\t\targ3 = arg4;\n\n\t\targ4 = temp;\n\n\t}\n\n#endif\n\n#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n\n#ifdef TARGET_NR_fadvise64_64\n\n    case TARGET_NR_fadvise64_64:\n\n#endif\n\n#ifdef TARGET_NR_fadvise64\n\n    case TARGET_NR_fadvise64:\n\n#endif\n\n#ifdef TARGET_S390X\n\n        switch (arg4) {\n\n        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n\n        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n\n        case 6: arg4 = POSIX_FADV_DONTNEED; break;\n\n        case 7: arg4 = POSIX_FADV_NOREUSE; break;\n\n        default: break;\n\n        }\n\n#endif\n\n        ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n\n\tbreak;\n\n#endif\n\n#ifdef TARGET_NR_madvise\n\n    case TARGET_NR_madvise:\n\n        /* A straight passthrough may not be safe because qemu sometimes\n\n           turns private flie-backed mappings into anonymous mappings.\n\n           This will break MADV_DONTNEED.\n\n           This is a hint, so ignoring and returning success is ok.  */\n\n        ret = get_errno(0);\n\n        break;\n\n#endif\n\n#if TARGET_ABI_BITS == 32\n\n    case TARGET_NR_fcntl64:\n\n    {\n\n\tint cmd;\n\n\tstruct flock64 fl;\n\n\tstruct target_flock64 *target_fl;\n\n#ifdef TARGET_ARM\n\n\tstruct target_eabi_flock64 *target_efl;\n\n#endif\n\n\n\n\tcmd = target_to_host_fcntl_cmd(arg2);\n\n\tif (cmd == -TARGET_EINVAL)\n\n\t\treturn cmd;\n\n\n\n        switch(arg2) {\n\n        case TARGET_F_GETLK64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    if (ret == 0) {\n\n#ifdef TARGET_ARM\n\n                if (((CPUARMState *)cpu_env)->eabi) {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) \n\n                        goto efault;\n\n                    target_efl->l_type = tswap16(fl.l_type);\n\n                    target_efl->l_whence = tswap16(fl.l_whence);\n\n                    target_efl->l_start = tswap64(fl.l_start);\n\n                    target_efl->l_len = tswap64(fl.l_len);\n\n                    target_efl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_efl, arg3, 1);\n\n                } else\n\n#endif\n\n                {\n\n                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) \n\n                        goto efault;\n\n                    target_fl->l_type = tswap16(fl.l_type);\n\n                    target_fl->l_whence = tswap16(fl.l_whence);\n\n                    target_fl->l_start = tswap64(fl.l_start);\n\n                    target_fl->l_len = tswap64(fl.l_len);\n\n                    target_fl->l_pid = tswap32(fl.l_pid);\n\n                    unlock_user_struct(target_fl, arg3, 1);\n\n                }\n\n\t    }\n\n\t    break;\n\n\n\n        case TARGET_F_SETLK64:\n\n        case TARGET_F_SETLKW64:\n\n#ifdef TARGET_ARM\n\n            if (((CPUARMState *)cpu_env)->eabi) {\n\n                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_efl->l_type);\n\n                fl.l_whence = tswap16(target_efl->l_whence);\n\n                fl.l_start = tswap64(target_efl->l_start);\n\n                fl.l_len = tswap64(target_efl->l_len);\n\n                fl.l_pid = tswap32(target_efl->l_pid);\n\n                unlock_user_struct(target_efl, arg3, 0);\n\n            } else\n\n#endif\n\n            {\n\n                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) \n\n                    goto efault;\n\n                fl.l_type = tswap16(target_fl->l_type);\n\n                fl.l_whence = tswap16(target_fl->l_whence);\n\n                fl.l_start = tswap64(target_fl->l_start);\n\n                fl.l_len = tswap64(target_fl->l_len);\n\n                fl.l_pid = tswap32(target_fl->l_pid);\n\n                unlock_user_struct(target_fl, arg3, 0);\n\n            }\n\n            ret = get_errno(fcntl(arg1, cmd, &fl));\n\n\t    break;\n\n        default:\n\n            ret = do_fcntl(arg1, arg2, arg3);\n\n            break;\n\n        }\n\n\tbreak;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_cacheflush\n\n    case TARGET_NR_cacheflush:\n\n        /* self-modifying code is handled automatically, so nothing needed */\n\n        ret = 0;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_security\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n#endif\n\n#ifdef TARGET_NR_getpagesize\n\n    case TARGET_NR_getpagesize:\n\n        ret = TARGET_PAGE_SIZE;\n\n        break;\n\n#endif\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n#ifdef TARGET_NR_readahead\n\n    case TARGET_NR_readahead:\n\n#if TARGET_ABI_BITS == 32\n\n#ifdef TARGET_ARM\n\n        if (((CPUARMState *)cpu_env)->eabi)\n\n        {\n\n            arg2 = arg3;\n\n            arg3 = arg4;\n\n            arg4 = arg5;\n\n        }\n\n#endif\n\n        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n\n#else\n\n        ret = get_errno(readahead(arg1, arg2, arg3));\n\n#endif\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_setxattr\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        ret = -TARGET_EOPNOTSUPP;\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_set_thread_area\n\n    case TARGET_NR_set_thread_area:\n\n#if defined(TARGET_MIPS)\n\n      ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n\n      ret = 0;\n\n      break;\n\n#elif defined(TARGET_CRIS)\n\n      if (arg1 & 0xff)\n\n          ret = -TARGET_EINVAL;\n\n      else {\n\n          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n\n          ret = 0;\n\n      }\n\n      break;\n\n#elif defined(TARGET_I386) && defined(TARGET_ABI32)\n\n      ret = do_set_thread_area(cpu_env, arg1);\n\n      break;\n\n#else\n\n      goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_get_thread_area\n\n    case TARGET_NR_get_thread_area:\n\n#if defined(TARGET_I386) && defined(TARGET_ABI32)\n\n        ret = do_get_thread_area(cpu_env, arg1);\n\n#else\n\n        goto unimplemented_nowarn;\n\n#endif\n\n#endif\n\n#ifdef TARGET_NR_getdomainname\n\n    case TARGET_NR_getdomainname:\n\n        goto unimplemented_nowarn;\n\n#endif\n\n\n\n#ifdef TARGET_NR_clock_gettime\n\n    case TARGET_NR_clock_gettime:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_gettime(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_getres\n\n    case TARGET_NR_clock_getres:\n\n    {\n\n        struct timespec ts;\n\n        ret = get_errno(clock_getres(arg1, &ts));\n\n        if (!is_error(ret)) {\n\n            host_to_target_timespec(arg2, &ts);\n\n        }\n\n        break;\n\n    }\n\n#endif\n\n#ifdef TARGET_NR_clock_nanosleep\n\n    case TARGET_NR_clock_nanosleep:\n\n    {\n\n        struct timespec ts;\n\n        target_to_host_timespec(&ts, arg3);\n\n        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n\n        if (arg4)\n\n            host_to_target_timespec(arg4, &ts);\n\n        break;\n\n    }\n\n#endif\n\n\n\n#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n\n    case TARGET_NR_set_tid_address:\n\n        ret = get_errno(set_tid_address((int *)g2h(arg1)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n\n    case TARGET_NR_tkill:\n\n        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n\n    case TARGET_NR_tgkill:\n\n\tret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n\n                        target_to_host_signal(arg3)));\n\n\tbreak;\n\n#endif\n\n\n\n#ifdef TARGET_NR_set_robust_list\n\n    case TARGET_NR_set_robust_list:\n\n\tgoto unimplemented_nowarn;\n\n#endif\n\n\n\n#if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n\n    case TARGET_NR_utimensat:\n\n        {\n\n            struct timespec *tsp, ts[2];\n\n            if (!arg3) {\n\n                tsp = NULL;\n\n            } else {\n\n                target_to_host_timespec(ts, arg3);\n\n                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n\n                tsp = ts;\n\n            }\n\n            if (!arg2)\n\n                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n\n            else {\n\n                if (!(p = lock_user_string(arg2))) {\n\n                    ret = -TARGET_EFAULT;\n\n                    goto fail;\n\n                }\n\n                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n\n                unlock_user(p, arg2, 0);\n\n            }\n\n        }\n\n\tbreak;\n\n#endif\n\n#if defined(CONFIG_USE_NPTL)\n\n    case TARGET_NR_futex:\n\n        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\n    case TARGET_NR_inotify_init:\n\n        ret = get_errno(sys_inotify_init());\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n\n    case TARGET_NR_inotify_add_watch:\n\n        p = lock_user_string(arg2);\n\n        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n\n        unlock_user(p, arg2, 0);\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n\n    case TARGET_NR_inotify_rm_watch:\n\n        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n\n        break;\n\n#endif\n\n\n\n#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n\n    case TARGET_NR_mq_open:\n\n        {\n\n            struct mq_attr posix_mq_attr;\n\n\n\n            p = lock_user_string(arg1 - 1);\n\n            if (arg4 != 0)\n\n                copy_from_user_mq_attr (&posix_mq_attr, arg4);\n\n            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n\n            unlock_user (p, arg1, 0);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_unlink:\n\n        p = lock_user_string(arg1 - 1);\n\n        ret = get_errno(mq_unlink(p));\n\n        unlock_user (p, arg1, 0);\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedsend:\n\n        {\n\n            struct timespec ts;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_send(arg1, p, arg3, arg4));\n\n            unlock_user (p, arg2, arg3);\n\n        }\n\n        break;\n\n\n\n    case TARGET_NR_mq_timedreceive:\n\n        {\n\n            struct timespec ts;\n\n            unsigned int prio;\n\n\n\n            p = lock_user (VERIFY_READ, arg2, arg3, 1);\n\n            if (arg5 != 0) {\n\n                target_to_host_timespec(&ts, arg5);\n\n                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n\n                host_to_target_timespec(arg5, &ts);\n\n            }\n\n            else\n\n                ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n\n            unlock_user (p, arg2, arg3);\n\n            if (arg4 != 0)\n\n                put_user_u32(prio, arg4);\n\n        }\n\n        break;\n\n\n\n    /* Not implemented for now... */\n\n/*     case TARGET_NR_mq_notify: */\n\n/*         break; */\n\n\n\n    case TARGET_NR_mq_getsetattr:\n\n        {\n\n            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n\n            ret = 0;\n\n            if (arg3 != 0) {\n\n                ret = mq_getattr(arg1, &posix_mq_attr_out);\n\n                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n\n            }\n\n            if (arg2 != 0) {\n\n                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n\n                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n\n            }\n\n\n\n        }\n\n        break;\n\n#endif\n\n\n\n#ifdef CONFIG_SPLICE\n\n#ifdef TARGET_NR_tee\n\n    case TARGET_NR_tee:\n\n        {\n\n            ret = get_errno(tee(arg1,arg2,arg3,arg4));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_splice\n\n    case TARGET_NR_splice:\n\n        {\n\n            loff_t loff_in, loff_out;\n\n            loff_t *ploff_in = NULL, *ploff_out = NULL;\n\n            if(arg2) {\n\n                get_user_u64(loff_in, arg2);\n\n                ploff_in = &loff_in;\n\n            }\n\n            if(arg4) {\n\n                get_user_u64(loff_out, arg2);\n\n                ploff_out = &loff_out;\n\n            }\n\n            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n", "idx": 27056, "substitutes": {"cpu_env": ["cpu_environment", " CPU_scope", "proc_environment", " CPU_list", "gpu_env", " CPU_env", "cpu2env", "gpu_environment", "cpu__np", "cpuwproc", "cpujloader", "cpu__env", "cpu_scope", "proc_env", "cpu2desc", "cpuwenv", "cpu_desc", "cpu2proc", "proc_proc", "cpu_ext", "cpu2environment", "cpu_np", "gpu_context", "cpu_list", "cpujenv", "cpu_context", "core_dep", "gpu_loader", "core_np", "cpu_loader", "cpu_proc", "cpu__environment", "cpu_dep", "cpujenvironment", " CPU_ext", "core_environment", "core_env", "cpu__dep", "cpuwenvironment", "proc_desc", "cpuwdesc", "cpujcontext"], "num": ["orig", "index", "n", "run", "nat", "nb", "id", "nc", "mn", "proc", "count", "valid", "test", "final", "binary", "len", "program", "number", "dim", "dom", "type", "coord", "alt", "Num", "off", "uni", "con", "multi", "code", "termin", "nam", "unit", "prefix", "init", "ident", "su", "um", "node", "loc", "param", "fn", "nu", "gnu", "gen", "NUM", "thread", "sn", "np", "nm", "method", "umi", "name", "bin", "offset"], "arg1": ["args3", " arg01", "Arg2", "ar2", "args2", "Arg01", "args0", "ar3", "argsone", "ar0", "Arg3", "args1", "ar4", "arg0", "ax01", "ar1", "Arg1", " argone", "args4", " arg0", "ax2", "ax1", "axone", "args01", "arg01", "argone", "Arg4"], "arg2": ["param02", "param3", "argument3", "argument02", "param2", "Arg2", "ar2", "ax4", "argument4", "arg02", "param4", "args2", "argument2", "ar3", "ax62", "Arg3", "arg62", "ar4", "ar1", " arg02", "Arg1", "ax02", "args4", "ax2", "args62", "param62", "Arg4", "args02"], "arg3": [" arg203", "args3", "inc1", "argument3", "argument03", "inc03", "ArgThree", "ar2", "Arg2", "itemThree", "item3", "inc5", "ag5", " arg03", "argument2", "ag3", "ag2", "inc3", "ar3", "agg3", "Arg3", "args5", "args1", "args03", "ar03", "ar1", "Arg1", "item1", "args203", "item2", "agg03", "argument1", " argThree", "args4", "arg03", "Arg5", "argThree", "ag1", "arg203", "agg203", "agg4"], "arg4": ["ax44", "ar5", "argument3", "ax5", "argument5", "ar2", "ax4", "argument4", " arg8", "argument8", "argument2", "ar3", "arg8", "ar4", "ax8", "arg44", "argument44", " arg44"], "arg5": ["args3", "args6", "enc5", "enc8", " arg8", "enc4", "arg8", "Arg3", "args4", "enc6", "args8", "Arg5", "Arg6", "args5", "Arg4"], "arg6": ["ar5", "args6", "argument64", "ar2", " arg8", "ar6", "args2", "argument8", "arg8", "ar4", "arg64", "arg56", "agg64", " arg56", "agg56", "args4", "argument56", " arg64", "argument6", "args5", "agg6", "agg8"], "ret": ["x", "last", "ext", "hash", "sr", "reply", "id", "RET", "net", "debug", "proc", "format", "xt", "eval", "let", "len", "function", "gt", "nt", "Return", "gc", "max", "result", "alt", "get", "mem", "no", "det", "fi", "ref", "part", "al", "rets", "arr", "code", "rl", "def", "ft", "fun", "sat", "arg", "desc", "rt", "rot", "output", "lit", "str", "val", "data", "cat", "out", "Ret", "reg", "back", "opt", "success", "re", "sum"], "st": ["bl", "ist", "ost", "sc", "std", "net", "stack", "r", "nt", "sts", "St", "stab", "ust", "store", "rest", "est", "ft", "inst", "ct", "istic", "c", "ss", "ST", "str", "sw"], "stfs": ["strfunc", "strf", "stf", "strfs", "ctfs", "strfi", "stabfi", "stfunc", "ctf", "stabf", "stabfunc", "stabfs", "ctfi", "stfi", "ctfunc"], "p": ["b", "port", "pg", "pb", "pi", "n", "mp", "wp", "pl", "pu", "j", "proc", "cp", "pin", "vp", "sp", "r", "op", "ip", "cache", "g", "pm", "ps", "pp", "l", "fp", "pid", "h", "y", "pe", "part", "pre", "m", "ap", "t", "s", "P", "per", "w", "u", "po", "jp", "process", "e", "c", "pt", "bp", "hp", "pc", "f", "d", "api", "press", "np", "pr", "o", "tp", "lp", "pa"], "ts": ["aps", "its", "qs", "outs", "state", "gs", "tes", "TS", "rs", "tz", "ta", "sp", "tt", "pers", "lets", "sts", "bs", "ics", "ps", "points", "ims", "ks", "tr", "hs", "tests", "Ts", "cs", "ters", "tc", "t", "s", "ports", "acs", "times", "args", "ats", "tx", "ms", "ns", "eps", "pt", "tips", "pc", "types", "ss", "ls", "ds", "xs", "trans", "T", "als", "tp", "stats"], "lastp": ["lastpc", "prevp", "prevP", "firstc", " lastc", "lastep", " lastep", "lastjp", "finalP", " lastjp", "finalp", "prevpc", "finalep", "finalpart", "lastcp", " lastP", "firstp", "Lastp", "Lastjp", "finalcp", "firstjp", "prevm", "firstep", "lastc", "lastpart", "firstm", "firstP", "firstcp", "lastf", " lastcp", " lastm", "lastP", " lastf", "firstpc", "finalf", " lastpc", "firstpart", "lastm", "LastP", " lastpart", "firstf", "Lastc"]}}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058, "substitutes": {"sys_type_name": ["sys_type2type", "sys_type_code", "sys_name2id", "sys_name_type", "sys_name_id", "sys_name_name", "sys_type2id", "sys_type2name", "sys_name2type", "sys_name2code", "sys_type_type", "sys_type_id", "sys_type2code", "sys_name_code", "sys_name2name"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)\n\n{\n\n    int i;\n\n    INIT_CLIP\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride /= sizeof(pixel);\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n}\n", "idx": 27081, "substitutes": {"_dst": ["_dsbl", "_rdsts", "_fst", "_fput", "_rdput", " _dput", "_lput", "_rdst", "_fbl", "_dsst", " _lst", "_lsts", " _dbl", "_lst", "_dsput", "_Dput", "_Dst", "_Dsts", "_dsconst", "_rdbl", "_Dbl", "_Dconst", "_dconst", " _lbl", "_dsts", "_fconst", " _dsts", " _lsts", "_lbl", "_dbl", "_dput", " _lput"], "_block": [" _keep", " _filter", "_filter", "_frame", "_keep", " _frame", " _lock", "_image", "_Block", "_lock", " _Block", " _image"], "stride": ["shrided", "strride", "ctrride", "strided", "Strip", "Strider", "trride", " strided", "striided", "stip", "dride", "drip", "shridi", "ctrider", "strider", "drride", "striride", "strip", "Stridi", "yrride", "stridi", "ctrise", "Strend", "stance", "Strance", "Stride", "yrend", "striiding", " stridi", "ctride", "hrride", "yrider", " strider", "trip", "drider", "Strided", "yrip", " strip", "shrider", "strance", "striding", "hrip", "hrider", "tride", "Striding", " strend", "yride", "strend", "shride", "stide", "Strise", " striding", " strride", " strance", "trider", " strise", "striide", "hrance", "hride", "Strride", "strise"], "i": ["li", "in", "ie", "split", "id", "iu", "g", "type", "ti", "mu", "ini", "inner", "p", "lock", "line", "I", "u", "k", "si", "eni", "adi", "phi", "ci", "ni", "mi", "x", "oi", "iii", "n", "key", "err", "me", "abi", "info", "hi", "gi", "l", "qi", "zi", "ii", "e", "c", "cli", "api", "ui", "ri", "index", "j", "ix", "is", "y", "fi", "slice", "uri", "config", "m", "di", "my", "f", "q", "ai", "mini", "pi", "source", "ip", "image", "bi", "v", "io", "xi", "multi", "chi", "it", "d", "vi", "list", "temp"], "dst": ["dsc", "dsset", "dsbl", "dput", "wset", "bdst", " dbl", "drest", "dsl", "Dbl", "xdst", "adrest", "dstream", "odput", "Dset", "Dput", "idstream", "dsst", "nput", "dssc", "ldsc", " dsl", "rdbl", "odst", "ldbl", "idbl", "ldsl", " drest", "wst", "ddstore", "adst", "Dst", "dST", "rdsc", "bdput", "fst", " dstream", "xdsts", " dput", "idsc", "dbl", "ldput", "bdbl", "dset", "rdst", "wput", "adput", "odset", "ddput", "ddset", "ldst", "Dsl", "nset", " dsts", " dset", "xdbl", "Dsc", "xdST", "fbl", "bdrest", " dsc", "ldrest", " dST", "dsts", "nstore", "dstore", "ddst", "odrest", "idst", "fsc", "nst", "rdput", "wstore", "adset"], "block": ["bl", "box", "blocks", "byte", "keep", "rule", "pull", "patch", "cache", "type", "down", "frame", "p", "lock", "line", "rock", "month", "page", "device", "comment", "view", "pixel", "sync", "map", "mask", "tick", "name", "post", "array", "flow", "record", "check", "style", "off", "large", "cl", "buffer", "clean", "point", "condition", "event", "bit", "join", "plugin", "error", "wave", "full", "none", "board", "option", "group", "session", "label", "channel", "unit", "wall", "BL", "ban", "filter", "ack", "chain", "row", "layout", "image", "Block", "ip", "number", "word", "work", "panel", "batch", "pack", "link", "um", "loc", "object", "square", "section", "list"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n", "idx": 27083, "substitutes": {"s": ["js", "b", "context", "native", "sf", "qs", "a", "S", "gs", "ions", "rs", "os", "ops", "ssl", "ctx", "sb", "g", "session", "states", "es", "is", "request", "h", "ks", "ges", "service", "tests", "p", "m", "cs", "t", "south", "u", "sets", "ns", "sg", "si", "settings", "e", "c", "ches", "d", "f", "i", "ds", "services", "sq", "server", "o", "groups", "us", "ses", "sys"], "insn": ["outsnl", " inssn", " insne", "issl", "inns", "issb", "innt", "incnt", "outsns", "inn", "outsnt", "incb", "consnc", "idsnt", "insnt", "incn", "issp", "incl", "inl", "inssn", "esnl", "exb", "issnc", "incnc", "intssn", "consb", "innl", "esl", "issnt", "isssn", "idssn", "issn", "outsn", "inp", " insns", "consn", "incN", "ksl", "exl", "intsnt", "esn", "insp", "intsne", "insb", "insnl", "insl", "incns", "issN", "esb", "exn", "insnc", "idsn", "insne", "outssn", "outsp", "exsn", "issnl", " insnt", "ksns", "inb", "insns", "insN", "ksn", "consN", "ksnt", "incsn", "intsn", "esnt", "idsne"], "mos": ["coll", "oise", "oi", "mon", "mp", "proxy", "phase", "mode", "os", "cp", "mol", "tz", "Mos", "mx", "omo", "ros", " mo", "mc", "cas", "no", "rom", "la", "mot", "mis", "las", "mo", "oc", "m", "om", "oid", "cm", "ms", "po", "hop", "na", "loc", "asio", "osa", "mm", "co", "pos", "qa", "o", "pm", "pa", "oshi"], "type": ["ro", "port", "box", "weight", "year", "mon", "key", "rel", "mode", "id", "state", "shape", "test", "col", "ype", "info", "ony", "r", "position", "size", "field", "y", "pe", "part", "style", "py", "cross", "pre", "order", "sort", "p", "area", "code", "cl", "t", "unit", "po", "comp", "hop", "time", "loc", "block", "acy", "types", "min", "pos", "o", "art", "method", "form", "name", "class", "ty", "Type"], "rm": ["prop", "rf", "rx", "rel", "err", "cmp", "mode", "lr", "rem", "cp", "col", "dy", "RM", "r", "rb", "dim", "rom", "ref", "role", "mr", "range", "pre", "order", "arm", "route", "cr", "cmd", "rc", "md", "rt", "loc", "fn", "ore", "cb", "min", "rr", "reg", "res", "ro", "pm", "name", "nr", "re"], "cond": ["xc", "df", "cmp", "mode", "count", "cc", "cp", "id", "success", "col", "control", "non", "crit", "len", "bid", "zip", "red", "day", "cod", "resp", "cas", "no", "close", "cont", "ref", "prep", "config", "bool", "pre", "cl", "label", "code", "ress", "act", "cr", "cmd", "lf", "def", "fail", "unit", "init", "ct", "comp", "clean", "na", "fact", "loc", "inc", "ind", "condition", "seq", "dd", "reason", "sec", "Cond", "lc", "cb", "ann", "co", "pos", "reg", "circ", "fl", "cd"], "rn": ["orig", "ril", "coll", "ron", "n", "rf", "rx", "rin", "err", "cmp", "anc", "nc", "lr", "mn", "keep", "norm", "col", "nor", "arn", "rd", "len", "ne", "r", "rb", "raf", "br", "dr", "rom", "rg", "roc", "cross", "nz", "rh", "cn", "nn", "rc", "na", "rt", "hn", "fn", "ann", "rr", "rar", "cdn", "ro", "adr", "nr", "unn", "rw"], "op": ["prop", "upp", "mp", "opa", "oper", "Op", "cmp", "cp", "eff", "ops", "ort", "r", "ip", "rol", "rb", "pop", "option", "pp", "fp", "anne", "off", "oc", "order", "p", "opus", "lock", "vert", "operator", "comp", "hop", "jp", "ok", "loc", "block", "rot", "OP", "rop", "co", "opp", "o", "opt", "cop", "ob", "ope"], "nzcv": ["czqu", "expnv", "ncnv", "squc", "zzcv", "nzCV", "ezuc", "ezvv", "tznv", "cznv", "ezqu", "ezcv", "eznv", "nzqu", "nznv", "tzCV", "nzvm", "expCV", "sqnv", "expcv", "NZnv", "NZvv", "zzCV", "tzvm", "zznv", "NZcv", "czvv", "nccv", "ncqu", "sqcv", "tzcv", "sqvv", "expvm", "NZuc", "ncvv", "nzvv", "nzuc", "czcv", "zzvm"], "tcg_flags": ["tcp_flag", "tcG_roots", "tcG_args", "tcg__lins", "tcg_flag", "tcg_roots", "tcg_Flags", "tcg__mods", "tcgi_mods", "tcp__Flags", "tcg__types", "tcg__flag", "tcg_bits", "tcp__flag", "tcp_Flags", "tcG_bits", "tcg_mods", "tcG_mods", "tcp__flags", "tcg__flags", "tcgi_lins", "tcg67flags", "tcG_types", "tcg_types", "tcp_flags", "tcg__bits", "tcg_args", "tcg67args", "tcg__Flags", "tcg_lins", "tcg67types", "tcG_flags", "tcg__args", "tcg67bits", "tcgi_flags", "tcg__roots"]}}
{"project": "qemu", "commit_id": "ea6c5f8ffe6de12e04e63acbb9937683b30216e2", "target": 0, "func": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n", "idx": 27088, "substitutes": {"bit": ["index", "key", "BIT", "error", "base", "child", "value", "filter", "id", "byte", "slot", "count", "bits", "ac", "pin", "tag", "op", "patch", "word", "number", "feature", "type", "part", "off", "lock", "big", "it", "bug", "feat", "sync", "block", "limit", "lit", "and", "load", "val", "Bit", "pattern", "mask", "flag", "length", "bin", "offset"], "map": ["cap", "array", "mp", "set", "dict", "rule", "shape", "func", "test", "MAP", "op", "image", "cache", "max", "master", "cast", "Map", "app", "arr", "pack", "lock", "comb", "ap", "code", "complete", "table", "buffer", "scale", "block", "module", "maps", "co", "use", "mask", "list", "pad"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100, "substitutes": {"ctx": ["fw", "coll", "context", "fc", "css", "xc", "sc", "bc", "cmp", "anc", "nc", "ca", "cc", "cp", "cms", "connection", "cus", "pkg", "ck", "cv", "cas", "kw", "conn", "ce", "cf", "Context", "config", "cam", "instance", "cl", "vc", "kt", "cs", "util", "tc", "cmd", "cn", "rc", "cm", "tx", "ctrl", "ct", "comp", "cgi", "jp", "cca", "loc", "sync", "c", "pc", "lc", "component", "cb", "cli", "event", "co", "cu", "ci", "qa", "client", "kb", "support", "ga"], "blocking": ["bl", "locking", "blocks", "bc", "testing", "http", "wait", "including", "rising", "full", "ssl", "starting", "regular", "rolling", "loading", "no", "sleep", "successful", "working", "background", "locked", "cl", "running", "complete", "quiet", "calling", "restricted", "prefix", "protected", "buffer", "enabled", "block", "exec", "padding", "using", "limited", "exclusive", "ocking", "client", "partial", "interrupted"]}}
{"project": "qemu", "commit_id": "563890c7c7e977842e2a35afe7a24d06d2103242", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107, "substitutes": {"id": ["index", "iq", "key", "path", "parent", "ids", "error", "ID", "end", "bid", "fd", "info", "ip", "image", "type", "request", "pid", "h", "ref", "code", "p", "address", "it", "input", "d", "i", "Id", "f", "data", "q", "event", "ad", "aid", "name", "temp"], "response": ["site", "array", "results", "ception", "dict", "status", "error", "reply", "parent", "entry", "description", "message", "format", "os", "valid", "connection", "body", "reference", "answer", "r", "image", "cache", "model", "result", "resp", "secret", "request", "respond", "resource", "v", "collection", "complete", "json", "def", "page", "my", "feed", "view", "output", "object", "Response", "data", "tree", "api", "server", "xml", "success", "female"], "ret": ["x", "et", "ut", "status", "reply", "RET", "xt", "success", "let", "len", "nt", "result", "alt", "resp", "get", "det", "mem", "v", "fi", "ref", "part", "py", "rev", "rets", "code", "t", "match", "obj", "fun", "arg", "rt", "seq", "f", "lit", "bf", "val", "data", "pet", "Ret", "reg", "res", "flag", "bit", "temp", "re", "ext"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129, "substitutes": {"env": ["buf", "context", "proc", "environment", "ptr", "qt", "cv", "conn", "priv", "src", "enc", "config", "exc", "inst", "ev", "obj", "cfg", "tx", "db", "impl", "ea", "ec", "cb", "np", "viron", "en", "bg"], "ctx": ["buf", "context", "scope", "cpu", "ch", "xc", "sci", "sc", "bc", "cmp", "nc", "cc", "cp", "connection", "qq", "hw", "mc", "pkg", "ck", "qt", "cv", "cas", "kw", "fp", "conn", "wx", "cf", "gpu", "Context", "src", "config", "vc", "grad", "cs", "tc", "cmd", "wcs", "conv", "obj", "rc", "cm", "tx", "ctrl", "cfg", "jp", "cca", "utils", "txt", "loc", "exec", "c", "sync", "linux", "xs", "component", "cli", "cb", "lc", "sq", "ci", "np", "qa", "gru", "client", "kb", " context", "chan"], "op2": ["hopTwo", " op52", "oper2", "hop2", "ip2", "op1", "hop4", "OP4", "opt4", " op1", "oper1", "oper3", "hop1", "ip4", "OP1", "hop02", "OPTwo", " opTwo", " op4", "OP2", "hop52", "op52", "opt3", "op3", "op02", "ip3", "OP02", "OP52", "opt1", "opTwo", " op02", "oper4", "opt2", "op4"], "r1": [" r61", " r2", "R4", "v1", "r3", "ur2", "l61", "r2", "r61", "r0", "R0", " r4", "R1", "v0", "ur61", "r4", " r0", "ur3", "v4", "l3", "l2", "ur1", " r3"], "l1": ["el2", "l9", "rl1", "p1", "L8", "l11", " l8", "lone", "el1", "p2", " l2", "l7", "r2", "l8", "r8", "rl7", "el9", "p11", "rl2", "r7", "rone", "r11", "r9", "nl11", "L2", "L1", " lone", "l2", "rl9", "nl1", "nl2", "Lone", "el7"], "tmp": ["buf", "pb", "front", "mp", "vm", "xc", "nb", "TB", "cmp", "proc", "cp", "tf", "test", "bb", "sb", "vt", "fb", "rb", "storage", "cache", "session", "cv", "result", "lab", "job", "emp", "bt", "v", "wx", "fp", "slice", "src", "obb", "config", "app", "tc", "obj", "now", "cm", "input", "su", "handler", "jp", "txt", "timer", "sup", "bag", "mk", "bp", "Temp", "output", "img", "cb", "tab", "cpp", "appy", "kk", "data", "np", "api", "tp", "temp", "bg"]}}
{"project": "qemu", "commit_id": "80e1eea37a25a7696137e680285e36d0bfdc9f34", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148, "substitutes": {"dev": ["dist", "sd", "mod", "dc", "ch", "conf", "driver", "err", "ve", "debug", "gh", "der", "self", "req", "od", "hw", "rad", "g", "cache", "DEV", "gd", "v", "conn", "priv", "sk", "ver", "cam", "app", "grad", "di", "def", "ev", "w", "device", "bug", "Dev", "var", "de", "comment", "md", "die", "gu", "dd", "d", "ds", "adv", "data", "ad", "development", "dem", "prom", "cd"], "qs": ["iq", "dq", "Q", "comm", "ch", "quad", "vs", "quick", "rows", "gs", "events", "self", "os", "req", " q", "qu", "qq", "ctx", "fs", "ksh", "g", "ck", "qt", "states", "ps", "params", "ts", "gd", "conn", "ks", "query", "tests", "vc", "qi", "cs", "s", "cmd", "args", "rc", "ns", "exec", "c", "eks", "sync", "f", "checks", "ds", "ls", "q", "sq", "views", "qa", "sys"], "arch": ["orig", "ch", "parent", "gr", "prev", "id", "ac", "der", "ace", "os", "r", "arc", "host", "patch", "build", "Arch", "h", "cf", "ror", "enc", "ver", "app", "p", "arr", "arm", "car", "ar", "rc", "var", "mac", "ph", "c", "ARCH", "str", "q", "rr", "archs", "pr", "qa", "art", "form", "auth", "a", "ga", "cur"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static unsigned long iv_decode_frame(Indeo3DecodeContext *s, \n                                     unsigned char *buf, int buf_size) \n{\n  unsigned int hdr_width, hdr_height,\n    chroma_width, chroma_height;\n  unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;\n  unsigned char *hdr_pos, *buf_pos;\n  buf_pos = buf;\n  buf_pos += 18;\n  fflags1 = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  fflags3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  fflags2 = *buf_pos++;\n  buf_pos += 3;\n  hdr_height = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  hdr_width = le2me_16(*(uint16_t *)buf_pos);\n  buf_pos += 2;\n  chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;\n  chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;\n  offs1 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs2 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  offs3 = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 8;\n  hdr_pos = buf_pos;\n  if(fflags3 == 0x80) return 4;\n  if(fflags1 & 0x200) {\n    s->cur_frame = s->iv_frame + 1;\n    s->ref_frame = s->iv_frame;\n  } else {\n    s->cur_frame = s->iv_frame;\n    s->ref_frame = s->iv_frame + 1;\n  }\n  buf_pos = buf + 16 + offs1;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width, \n    hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(hdr_width, 160));\n  if (!(s->avctx->flags & CODEC_FLAG_GRAY))\n  {\n  buf_pos = buf + 16 + offs2;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  buf_pos = buf + 16 + offs3;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  }\n  return 8;\n}", "idx": 27151, "substitutes": {"s": ["js", "b", "its", "qs", "a", "set", "conf", "sv", "S", "gs", "ions", "self", "rs", "ops", "full", "sb", "fs", "g", "bs", "rates", "session", "ps", "states", "new", "ts", "es", "is", "ks", "service", "ins", "ges", "p", "cs", "sym", "t", "m", "sets", "su", "ns", "sg", "bis", "this", "e", "c", "ss", "f", "xs", "ls", "ds", "spec", "services", "sq", "parts", "us", "se", "ses", "sys", "as"], "buf": ["orig", "num", "port", "pb", "bc", "vec", "text", "ffff", "av", "ctr", "ctx", "len", "fd", "rb", "max", "cv", "result", "Buffer", "fp", "wav", "src", "off", "cf", "queue", "alloc", "bu", "cmd", "ab", "cur", "rc", "buffer", "feed", "block", "uc", "seq", "uint", "img", "msg", "cb", "aux", "data", "uf", "ff", "Buff", "length", "fb", "buff"], "buf_size": ["buf_position", " buf_position"], "hdr_width": ["hdr___height", "hdr_name", "hdr_capacity", "hdr_ws", "hdr6class", "hdr___size", "hdr___lon", "hdr6name", "hdr___capacity", "hdr6width", "hdr___ws", "hdr_lon", "hdr_size", "hdr6height", "hdr___width", "hdr_class"], "hdr_height": ["hbr_volume", "hder_width", "hdr_max", "hdr_cap", "hdr__length", "hdr_length", "hder_height", "hder_length", "hdr_volume", "hdr__height", "hder_cap", "hbr_height", "hbr_quality", "hdr_quality", "hdr__width", "hbr_width", "hdr__max"], "chroma_width": ["chroma_pool", "chroma_name", "chroma_wide", "chromla_height", "chroma_size", "chromla_width", "chromla_name", "chromla_pool", "chromla_size", "chromla_wide"], "chroma_height": ["chroman_direction", "chroma_cap", "chromla_dim", "chromla_height", "chroman_height", "chroman_width", "chromla_cap", "chroma_direction", "chroma_dim", "chromla_width", "chroma_length", "chroman_length"], "fflags1": ["fflats2", "fflats3", "fflugs1", "fflages1", "fflaggedOne", "ffdlags1", "fflagg1", "ffllag2", "fflagged1", "ffllags1", "fflacksOne", "ffllags2", "fflag1", "fflags0", "fflugs0", "ffLugs3", "fflagg2", "fflats5", "ffLagsOne", "fflags9", "fflag3", "fflag5", "ffLugs0", "fflagsOne", "ffdlagg1", "ffLags0", "ffdlags3", "fflagged3", "fflugs3", "fflacks3", "ffdlagg5", "fflags5", "ffdlags5", "fflages9", "fflacks0", "fflugsOne", "ffllag3", "fflagg5", "ffLags1", "ffLugsOne", "ffllags9", "fflages3", "fflacks1", "ffLags3", "fflages2", "ffllag9", "ffdlags2", "ffLugs1", "fflagg3", "ffdlagg3", "fflats1", "fflagged0", "fflag9", "ffllag1", "ffdlagg2", "fflats9", "ffllags3", "fflag2"], "fflags2": ["ffdlages1", "fflats3", "fflugs1", "fflages1", "ffdlags1", "ffllags1", "fflarsTwo", "ffllags2", "fflag1", "fflars2", "fflars22", "fflag3", "fflugsTwo", "ffllarsTwo", "ffdlags3", "fflags22", "fflugs2", "fflars1", "fflatsTwo", "fflagsTwo", "ffllars2", "fflats22", "ffllars22", "fflages3", "fflages2", "ffdlags2", "ffdlages2", "ffdlages3", "ffllagsTwo", "fflugs22", "fflats1", "fflats2", "ffllars1", "ffllags22", "fflag2"], "fflags3": ["fflats2", "ffklages0", "fflags23", "fflats3", "fflats93", "ffflags1", "ffflags2", "fflugs1", "ffflags3", "fflages1", "ffklags3", "fflag6", "ffflugs23", "fflagged1", "ffllags1", "ffklags1", "ffflugs1", "fflag1", "fflags0", "ffllats1", "fflager23", "fflag23", "fflager1", "fflagged93", "fflag0", "fflagged23", "ffklags6", "ffklags0", "fflages6", "fflag3", "fflager3", "fflags93", "fflags6", "ffflugs2", "ffflugs3", "fflagged3", "fflugs3", "fflats6", "fflats23", "ffllags93", "ffllats3", "fflugs2", "ffklages6", "fflages3", "ffklages1", "fflages0", "fflugs23", "ffllats23", "ffklages3", "fflager93", "ffllags23", "fflats1", "ffllats93", "ffflags23", "ffllags3", "fflats0", "fflag2"], "offs1": ["opens3", "offs01", "hands01", "opens01", "hands3", "ops1", "outs3", "outs0", "sets01", "setsur", "ops0", "sets1", "offsur", "off0", "setsone", "outsur", "opensone", "off01", "outs01", "ops2", "offs0", "off3", "ops3", "outs1", "off2", "sets3", "handsone", "outs2", "offur", "offsone", "off1", "sets2", "opens1", "hands1"], "offs2": ["downsTwo", "times2", "ups4", "downs2", "offTwo", "ups02", "times02", "downs02", "times62", "downs4", "offs02", "offs62", "off02", "offs4", "off2", "off4", "outs02", "outs2", "off62", "outsTwo", "outs4", "offsTwo", "times4", "ups2", "ups62"], "offs3": ["eventsthree", "ands3", "offs03", "offs23", "downsthree", " offsets3", "ands15", "off15", " offsets15", " offsetsthird", "andsthird", "offsthree", "offthird", "events3", "downs3", "events23", "off3", "sets23", "sets3", "offs15", " offsets03", "setsthree", "ands03", "downs23", "events15", "downs15", "sets15", "offsthird", "off03"], "offs": ["unks", "ents", "outs", "blocks", "overs", "flags", "cuts", "bits", "ops", "bytes", "opens", "gets", "heads", "ups", "pres", "ows", "powers", "ones", "Off", "loads", "off", "options", "uni", "empty", "SIZE", "styles", "times", "args", "sets", "pieces", "lines", "utils", "hands", "OFF", "tips", "xs", "frames", "ands", "values", " off", "opp", "nos", "ff", "sticks", "offset"], "hdr_pos": ["hrc_loc", "hder_pos", "hdr64position", "hder64Pos", "hdr64pos", "hder64pos", "hder64po", "hder_po", "hdr64po", "hder_Pos", "hdr2loc", "hdrDocpos", "hdr2Pos", "hdr_po", "hdr_pointer", "hdrDocpointer", "hdr2pos", "hrc_pos", "hdr64Pos", "hdr_position", "hdr2position", "hder64position", "hdr2po", "hdr2pointer", "hdr_Pos", "hder_position", "hdrDocloc", "hdr_loc", "hrc_position", "hrc_pointer", "hdrDocposition"], "buf_pos": ["buffer__pos", "fbPspec", "buf67position", "usr2pose", "bufsos", "queue_pos", "bufsport", "cb_pos", "buf__Pos", "fb_position", "buf_doc", "fb_loc", "bu_Pos", "buflexindex", "usr2loc", "buff_po", " buf2position", "fbJnos", "buf2supp", "buff_position", "buf2doc", "buf_loc", "buffer_port", "bu_pose", "buf_nos", "buf0nos", "buf2Pos", "ctx_pos", "buf67pid", "buf_len", "grab_base", "buf00pos", "bufacpo", "buf64pres", "bufacpush", "cmd_pass", "bufCos", "buff_pid", "bufJpose", "buf64loc", "buf_position", "buf2position", "buff_push", "bufCpos", "buflexnum", "buf48min", "buff_pose", "buf2len", "fb00loc", "buffer__point", "ctx6Pos", "fb_spec", "buf48num", "bufacnos", "buf00ss", "fb00position", "buf_base", "buf_pid", "box_pres", "buflexpres", "buflexnos", "bufPspec", "buff_unit", "buf_pres", "buflexss", "buf00push", "buffer__os", " buf_pose", "grab2pos", "buf_supp", "grab2base", "buf_pose", " buf_loc", "bufspoint", "buf_spec", "bufCpoint", "usr_loc", "ctx6loc", "buffer_pos", "bufPdoc", "fb_pres", "buf_po", "bufCport", "fb_neg", "buffer_os", "fb00ss", "fb_pos", "buf_os", "buff_Pos", "buf64pos", "usr_pos", "buf0loc", "usr2pres", "buflexmin", "buf_Pos", "buf_ss", "fb_supp", "cmd_pos", "buflexpid", "buf_push", "buf2base", "cb_num", "bu_pos", " buf2nos", "usr_pose", "bufPpres", "buf_neg", "bufacpos", "buf_unit", "bufPpass", "buf48position", "cb2min", "ctx_loc", "buf6Pos", "buf00po", "cmdPpos", "buffer_point", "buff_loc", "cmdPpass", "cb2num", "buflexposition", "grab2pose", "grab_pos", "buf__point", " buf2loc", "grab_pose", "bufspos", "buf_pass", "bufPpose", "queue_index", "box_pose", "cb2pos", "buf0pos", "buflexlen", "queue_pose", "ctx6pos", "bufJpres", "buf6position", " buf_pres", "bufdloc", "buf2nos", "buf48pos", "fbPneg", "buf__position", "ctx_position", "bu_nos", " buf2pos", "buf2pass", "bufacos", "fb_nos", "buf0po", "buff_nos", "buff_os", "buflexpos", "bu_position", "buf64os", "buf2os", "fbJpos", "cb_min", "usr_pres", "cmd_pose", "grab_loc", "bufdbase", "bufacunit", "buflexpass", "buf2num", "buf2min", "buf__nos", "buf67nos", "bufJsupp", "bufPneg", "cmdPpose", "buf2pose", "fb_ss", "fbJsupp", "buf_min", "bufJloc", "fbPpres", "buf64pose", " buf_os", "bu_po", "box_pass", "cb_position", "buf__pos", "usr2pos", "bufJpass", "grab2loc", "bufdpose", "buf00loc", "buf6pos", "buf2pres", "bufJnos", " buf_len", "buf__port", "buf_num", "box_pos", "ctx6position", "buf00nos", "buf67pos", "bu_loc", "cb2position", "buflexpose", "buf00position", "buf_index", "bufdpos", "cmdPdoc", "buf__loc", "cmd_doc", "buf6loc", "buf_point", "buf__os", "fb00pos", "buffer__port", "buf2loc", "buf2pos", "queue_position", "ctx_Pos", "bufPpos", "buflexsupp", " buf_nos", "fbPpos", "bu_os", "buff_pos", "bufJpos", "buf_port", "fbJloc", " buf_position", "buflexloc", "buf64nos"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n\n                                    int search_pc)\n\n{\n\n    DisasContext ctx, *ctxp = &ctx;\n\n    opc_handler_t **table, *handler;\n\n    target_ulong pc_start;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj = -1;\n\n\n\n    pc_start = tb->pc;\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n    nb_gen_labels = 0;\n\n    ctx.nip = pc_start;\n\n    ctx.tb = tb;\n\n    ctx.exception = EXCP_NONE;\n\n    ctx.spr_cb = env->spr_cb;\n\n#if defined(CONFIG_USER_ONLY)\n\n    ctx.mem_idx = msr_le;\n\n#else\n\n    ctx.supervisor = 1 - msr_pr;\n\n    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n\n#endif\n\n    ctx.fpu_enabled = msr_fp;\n\n    ctx.singlestep_enabled = env->singlestep_enabled;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr_se = 1;\n\n#endif\n\n    /* Set env in case of segfault during code fetch */\n\n    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n\n        if (unlikely(env->nb_breakpoints > 0)) {\n\n            for (j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == ctx.nip) {\n\n                    gen_op_update_nip(ctx.nip); \n\n                    gen_op_debug();\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (unlikely(search_pc)) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n                gen_opc_pc[lj] = ctx.nip;\n\n                gen_opc_instr_start[lj] = 1;\n\n            }\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"----------------\\n\");\n\n            fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\",\n\n                    ctx.nip, 1 - msr_pr, msr_ir);\n\n        }\n\n#endif\n\n        ctx.opcode = ldl_code(ctx.nip);\n\n        if (msr_le) {\n\n            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n\n                ((ctx.opcode & 0x00FF0000) >> 8) |\n\n                ((ctx.opcode & 0x0000FF00) << 8) |\n\n                ((ctx.opcode & 0x000000FF) << 24);\n\n        }\n\n#if defined PPC_DEBUG_DISAS\n\n        if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n            fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\",\n\n                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n\n                    opc3(ctx.opcode), msr_le ? \"little\" : \"big\");\n\n        }\n\n#endif\n\n        ctx.nip += 4;\n\n        table = env->opcodes;\n\n        handler = table[opc1(ctx.opcode)];\n\n        if (is_indirect_opcode(handler)) {\n\n            table = ind_table(handler);\n\n            handler = table[opc2(ctx.opcode)];\n\n            if (is_indirect_opcode(handler)) {\n\n                table = ind_table(handler);\n\n                handler = table[opc3(ctx.opcode)];\n\n            }\n\n        }\n\n        /* Is opcode *REALLY* valid ? */\n\n        if (unlikely(handler->handler == &gen_invalid)) {\n\n            if (loglevel > 0) {\n\n                fprintf(logfile, \"invalid/unsupported opcode: \"\n\n                        \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                        opc1(ctx.opcode), opc2(ctx.opcode),\n\n                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            } else {\n\n                printf(\"invalid/unsupported opcode: \"\n\n                       \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\",\n\n                       opc1(ctx.opcode), opc2(ctx.opcode),\n\n                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n\n            }\n\n        } else {\n\n            if (unlikely((ctx.opcode & handler->inval) != 0)) {\n\n                if (loglevel > 0) {\n\n                    fprintf(logfile, \"invalid bits: %08x for opcode: \"\n\n                            \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                            ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                            opc2(ctx.opcode), opc3(ctx.opcode),\n\n                            ctx.opcode, ctx.nip - 4);\n\n                } else {\n\n                    printf(\"invalid bits: %08x for opcode: \"\n\n                           \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\",\n\n                           ctx.opcode & handler->inval, opc1(ctx.opcode),\n\n                           opc2(ctx.opcode), opc3(ctx.opcode),\n\n                           ctx.opcode, ctx.nip - 4);\n\n                }\n\n                RET_INVAL(ctxp);\n\n                break;\n\n            }\n\n        }\n\n        (*(handler->handler))(&ctx);\n\n#if defined(DO_PPC_STATISTICS)\n\n        handler->count++;\n\n#endif\n\n        /* Check trace mode exceptions */\n\n        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n\n                     /* Check in single step trace mode\n\n                      * we need to stop except if:\n\n                      * - rfi, trap or syscall\n\n                      * - first instruction of an exception handler\n\n                      */\n\n                     (msr_se && (ctx.nip < 0x100 ||\n\n                                 ctx.nip > 0xF00 ||\n\n                                 (ctx.nip & 0xFC) != 0x04) &&\n\n                      ctx.exception != EXCP_SYSCALL &&\n\n                      ctx.exception != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 27169, "substitutes": {"env": ["engine", "scope", "context", "que", "dt", "conf", "eu", "net", "keeper", "environment", "req", "end", "loader", "hw", "ette", "header", "vt", "emb", "ne", "qt", "esi", "org", "cv", "cal", "erb", "v", "conn", "ce", "esm", "enc", "config", "manager", "fg", "sche", "dev", "exc", "cmd", "args", "obj", "ev", "cfg", "console", "db", "ef", "qv", "utils", "txt", "e", "settings", "eng", "ea", "Environment", "eni", "ec", "exec", "inc", "gov", "cli", "event", "np", "qa", "viron", "cookie", "cdn", "runner", "en", "her", "bg", "ext"], "tb": ["ltc", "tsp", "pb", "intc", "ptba", "nb", " tbb", "ptab", "ptrb", "ltb", " tp", "tbody", "tsbe", "ltrb", "pp", "trb", "ptc", "tgb", "pbe", "intb", "untb", "ptgb", "tsba", "untbh", "tbe", "pba", "itbody", "tba", "itp", "untrb", "ttrb", "intab", "tc", "itb", "ptp", "itbb", "ptbe", "nbody", "intrb", "ptb", "ttgb", "ltab", "tbh", " tbody", "ptbh", "nbb", "tab", "tbb", "np", "tsb", "ttbh", "tp", "ttb", "untgb"], "search_pc": ["searchuremc", "search_arc", "searchingpb", " search_PC", " search2pc", " search2mc", "search_fc", " search2pb", "search_pb", " search2PC", " search_mc", "search_mc", "searchingmc", "searchingPC", "search2pc", "searchurepb", "searchablepb", " search_pb", "Search_arc", "Search_pc", "search_PC", "searchingpc", "search2PC", "searchurePC", "searchurepc", "Search_pb", "Search_fc", "searchablearc", "searchablepc", "searchablefc", "search2fc", "search2mc", "search2pb", "search2arc"], "ctx": ["scope", "dc", "wp", "sc", "bc", "ca", "req", "kw", "Context", "na", "txt", "sync", "xs", "co", "cu", "ci", "sq", " context", "fw", "coll", "context", "rx", "xc", "nc", "cc", "cp", "crit", "fp", "conn", "service", "cl", "cs", "conv", "wcs", "obj", "prefix", "rc", "c", "pc", "lc", "cli", "qa", "client", "kb", "fc", "que", "css", "cmp", "lib", "pkg", "ck", "wx", "cf", "config", " cx", "util", "cmd", "cn", "cfg", "cm", "acl", "jp", "utils", "exec", "fn", "abc", "sys", "sci", "hw", " c", "cus", "cv", "cas", "vc", "tc", "ctrl", "tx", "console", "cca", "setup", "loc", "cb", "cpp", "support"], "ctxp": ["mdfile", "cfbg", "cfxp", "ettxt", "etfile", "nttxt", "cffile", "cftxt", "etbg", "ntfile", "ntbg", "ntxp", "mdxp", "mdbg", "etxp", "mdtxt"], "table": ["engine", "port", "database", "conf", "source", "TABLE", "lib", "test", "col", "cache", "session", "query", "app", "batch", "queue", "tmp", "Table", "buffer", "console", "db", "file", "node", "fn", "event", "global", "server", "client", "sys"], "handler": ["parser", "path", "source", "writer", "connection", "response", "function", "host", "reader", "command", "controller", "manager", "queue", "code", "Handler", "processor", "route", "channel", "callback", "buffer", "file", "node", "fn", "event", "server", "client", "handle"], "pc_start": ["pc_get", "PC_offset", "pc_id", "pc__comp", "pc__start", "pc7size", "pc_offset", "pc67start", "pc67limit", "pc_end", "pc__get", "fc_id", "fc_size", "fc_start", "pc_comp", "fc_end", "pc67end", "fc_get", "pc7id", "pc7start", "pc2start", "pc_size", "fc_comp", "pc67offset", "pc2limit", "pc7end", "pc2end", "PC_limit", "PC_start", "pc2offset", "pc_limit", "PC_end", "pc__end"], "gen_opc_end": ["gen_opc_ends", "gen_opci_buf", "gen_opc2buf", "gen_opcu_ends", "gen_opc2max", "gen_opcu_END", "gen_opci_def", "gen_opc__size", "gen_opc__END", "gen_opc___max", "gen_opcamstart", "gen_opc2end", "gen_opc_buf", "gen_opcamdef", "gen_opc_start", "gen_opc__ends", "gen_opc___buf", "gen_opcu__size", "gen_opc_max", "gen_opcu__END", "gen_opc_END", "gen_opc_def", "gen_opcu__ends", "gen_opcamend", "gen_opci_end", "gen_opcu_size", "gen_opc___end", "gen_opcu__end", "gen_opci_start", "gen_opc_size", "gen_opcu_end", "gen_opc__end", "gen_opci_max"], "j": ["js", "kj", "jet", "b", "adj", "num", "x", "li", "index", "n", "ja", "key", "ie", "aj", "z", "note", "shift", " index", "jen", "end", "dy", "jo", "r", "g", " dj", "br", "job", "l", "y", "v", "jump", "ij", "name", "oj", "area", "vision", "bj", "p", "fr", "m", "obj", "it", "ii", "el", "jp", "jc", "k", " i", "jj", "e", "c", "d", "i", "f", "fl", "jit", "jl", "uj", "pr", "o", "ni", "im", "ji", "length", "step", "dj", "J"], "lj": ["li", "Lg", " lji", "fljp", " lk", "lg", "lbl", "lja", "lz", "slj", "milaj", "elje", "ulji", " lz", "laj", "Lj", "ulje", "ulk", "lk", "flaj", "slbl", "ln", "yln", "slji", "lij", "liaj", "Lk", "milj", " li", "lijp", "llja", "elz", "ulg", "ulbl", " lg", "miljo", "uljs", " ljs", "elj", "Lji", "lbj", "lnji", "Li", " ljp", "lija", " lja", "elja", "ulj", "ljo", "uln", "lnn", "lbi", " lbl", " laj", "sljo", "flja", "Lz", "llje", "llj", "ylji", "milji", " ljo", "flj", "slaj", "lnje", "lje", "llz", "lbji", "ylj", "ulz", "lji", "ulaj", "sljs", "flje", "lnj", "ljs", "flz", "lbz", "ylje", "ljp"]}}
{"project": "qemu", "commit_id": "2c8f86961b6eaac705be21bc98299f5517eb0b6b", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171, "substitutes": {"argv": ["argvs", " argf", "argf", "argsl", "agv", "agk", "argsc", "argV", "argh", "argsp", " argk", "angc", "arkv", "tagvt", "argvt", "Argf", "Argh", "argumentc", "agc", "passc", "tagc", "argsf", "passvs", " argl", " argp", "arkl", "argumentv", "angb", "tagk", "argl", " argvs", "argk", "passv", "argumenth", "argsb", " argh", "passV", "Argv", " argvt", "agV", "angvs", " argV", "argp", "arkvs", "angv", "argsv", " argb", "argsvs", "agvs", "tagv", "argumentf", "argb", "Argc", "arkc", "agvt", "Argp"], "argc": [" arglc", " argf", "argf", "arnp", "arkf", "argsl", "env", "argsc", "Arglc", "arklc", "arni", "axc", "arnc", "arkv", "Argf", "Argl", "arnv", "axv", "enc", "enf", "axp", "argsf", " argl", " argp", "argl", "argi", "Argv", "axi", " argi", "argp", "arglc", "enlc", "argsv", "Argc", "arkc"], "ide_idx": ["ide_endX", "idexendx", "ide__idexs", "idexendX", "ide_IDxs", "ide_endx", "ide__endz", "ide_idr", "ide_indxs", "ide_ipct", "ide__ipx", "ide_inxs", "ide_ipxs", "ide__ipct", "ide_idex", "ide__idct", "ide__idex", "ide_pidct", "ide_idexs", "ide_idy", "ide_ipy", "ide_IDx", "ide_pidxs", "ide__idect", "ide__idy", "ide_endc", "ide__endx", "ide_iny", "idexendxs", "ide_idxs", "ide_endy", "idexendy", "ide_pidx", "ide_idxe", "ide__ipxs", "ide_idc", "ide_idct", "idexidxs", "ide__idx", "ide_endxe", "ide__idc", "ide_aidc", "ide__endxe", "ide_idey", "ide_aidx", "ide_indct", "ide_indx", "idexidx", "ide_pidy", "ide_indr", "ide__idxs", "idexidy", "ide_idX", "ide__idr", "ide_ider", "ide__idxe", "ide_inX", "ide_IDr", "ide_inx", "ide_ipx", "ide_aidxe", "ide__idz", "idexidX", "ide_endz", "ide_ideX", "ide_IDct", "ide_idect", "ide_idz", "ide__endc", "ide__ipy", "ide_aidz", "ide__ider", "ide_endxs"], "i": ["index", "b", "ai", "x", "li", "pi", "n", "ie", "z", "id", "j", "abi", "yi", "r", "iu", "ip", "ix", "ei", "type", "gi", "bi", "l", "ti", "v", "io", "fi", "mu", "y", "uri", "xi", "ini", "name", "h", "multi", "p", "qi", "zi", "m", "di", "I", "t", "u", "ii", "k", "si", "e", "c", "gu", "d", "eni", "f", "lc", "adi", "start", "ui", "ci", "ni", "ri", "a", "mi"]}}
{"project": "FFmpeg", "commit_id": "e13f860ac8a5a7d803059d1553773cf2a446d3f2", "target": 0, "func": "static int decode_vol_header(MpegEncContext *s, GetBitContext *gb){\n\n    int width, height, vo_ver_id;\n\n\n\n    /* vol header */\n\n    skip_bits(gb, 1); /* random access */\n\n    s->vo_type= get_bits(gb, 8);\n\n    if (get_bits1(gb) != 0) { /* is_ol_id */\n\n        vo_ver_id = get_bits(gb, 4); /* vo_ver_id */\n\n        skip_bits(gb, 3); /* vo_priority */\n\n    } else {\n\n        vo_ver_id = 1;\n\n    }\n\n//printf(\"vo type:%d\\n\",s->vo_type);\n\n    s->aspect_ratio_info= get_bits(gb, 4);\n\n    if(s->aspect_ratio_info == FF_ASPECT_EXTENDED){\t    \n\n        s->aspected_width = get_bits(gb, 8); // par_width\n\n        s->aspected_height = get_bits(gb, 8); // par_height\n\n    }else{\n\n        s->aspected_width = pixel_aspect[s->aspect_ratio_info][0];\n\n        s->aspected_height= pixel_aspect[s->aspect_ratio_info][1];\n\n    }\n\n\n\n    if ((s->vol_control_parameters=get_bits1(gb))) { /* vol control parameter */\n\n        int chroma_format= get_bits(gb, 2);\n\n        if(chroma_format!=1){\n\n            printf(\"illegal chroma format\\n\");\n\n        }\n\n        s->low_delay= get_bits1(gb);\n\n        if(get_bits1(gb)){ /* vbv parameters */\n\n            get_bits(gb, 15);\t/* first_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_bitrate */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* first_half_vbv_buffer_size */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 3);\t/* latter_half_vbv_buffer_size */\n\n            get_bits(gb, 11);\t/* first_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */\n\n            get_bits(gb, 15);\t/* latter_half_vbv_occupancy */\n\n            skip_bits1(gb);\t/* marker */               \n\n        }\n\n    }else{\n\n        // set low delay flag only once so the smart? low delay detection wont be overriden\n\n        if(s->picture_number==0)\n\n            s->low_delay=0;\n\n    }\n\n\n\n    s->shape = get_bits(gb, 2); /* vol shape */\n\n    if(s->shape != RECT_SHAPE) printf(\"only rectangular vol supported\\n\");\n\n    if(s->shape == GRAY_SHAPE && vo_ver_id != 1){\n\n        printf(\"Gray shape not supported\\n\");\n\n        skip_bits(gb, 4);  //video_object_layer_shape_extension\n\n    }\n\n\n\n    skip_bits1(gb);   /* marker */\n\n    \n\n    s->time_increment_resolution = get_bits(gb, 16);\n\n    \n\n    s->time_increment_bits = av_log2(s->time_increment_resolution - 1) + 1;\n\n    if (s->time_increment_bits < 1)\n\n        s->time_increment_bits = 1;\n\n    skip_bits1(gb);   /* marker */\n\n\n\n    if (get_bits1(gb) != 0) {   /* fixed_vop_rate  */\n\n        skip_bits(gb, s->time_increment_bits);\n\n    }\n\n\n\n    if (s->shape != BIN_ONLY_SHAPE) {\n\n        if (s->shape == RECT_SHAPE) {\n\n            skip_bits1(gb);   /* marker */\n\n            width = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            height = get_bits(gb, 13);\n\n            skip_bits1(gb);   /* marker */\n\n            if(width && height){ /* they should be non zero but who knows ... */\n\n                s->width = width;\n\n                s->height = height;\n\n//                printf(\"width/height: %d %d\\n\", width, height);\n\n            }\n\n        }\n\n        \n\n        s->progressive_sequence= get_bits1(gb)^1;\n\n        if(!get_bits1(gb)) printf(\"OBMC not supported (very likely buggy encoder)\\n\");   /* OBMC Disable */\n\n        if (vo_ver_id == 1) {\n\n            s->vol_sprite_usage = get_bits1(gb); /* vol_sprite_usage */\n\n        } else {\n\n            s->vol_sprite_usage = get_bits(gb, 2); /* vol_sprite_usage */\n\n        }\n\n        if(s->vol_sprite_usage==STATIC_SPRITE) printf(\"Static Sprites not supported\\n\");\n\n        if(s->vol_sprite_usage==STATIC_SPRITE || s->vol_sprite_usage==GMC_SPRITE){\n\n            if(s->vol_sprite_usage==STATIC_SPRITE){\n\n                s->sprite_width = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_height= get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_left  = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n                s->sprite_top   = get_bits(gb, 13);\n\n                skip_bits1(gb); /* marker */\n\n            }\n\n            s->num_sprite_warping_points= get_bits(gb, 6);\n\n            s->sprite_warping_accuracy = get_bits(gb, 2);\n\n            s->sprite_brightness_change= get_bits1(gb);\n\n            if(s->vol_sprite_usage==STATIC_SPRITE)\n\n                s->low_latency_sprite= get_bits1(gb);            \n\n        }\n\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        \n\n        if (get_bits1(gb) == 1) {   /* not_8_bit */\n\n            s->quant_precision = get_bits(gb, 4); /* quant_precision */\n\n            if(get_bits(gb, 4)!=8) printf(\"N-bit not supported\\n\"); /* bits_per_pixel */\n\n            if(s->quant_precision!=5) printf(\"quant precission %d\\n\", s->quant_precision);\n\n        } else {\n\n            s->quant_precision = 5;\n\n        }\n\n        \n\n        // FIXME a bunch of grayscale shape things\n\n\n\n        if((s->mpeg_quant=get_bits1(gb))){ /* vol_quant_type */\n\n            int i, v;\n\n            \n\n            /* load default matrixes */\n\n            for(i=0; i<64; i++){\n\n                int j= s->dsp.idct_permutation[i];\n\n                v= ff_mpeg4_default_intra_matrix[i];\n\n                s->intra_matrix[j]= v;\n\n                s->chroma_intra_matrix[j]= v;\n\n                \n\n                v= ff_mpeg4_default_non_intra_matrix[i];\n\n                s->inter_matrix[j]= v;\n\n                s->chroma_inter_matrix[j]= v;\n\n            }\n\n\n\n            /* load custom intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n                    \n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->intra_matrix[j]= v;\n\n                    s->chroma_intra_matrix[j]= v;\n\n                }\n\n            }\n\n\n\n            /* load custom non intra matrix */\n\n            if(get_bits1(gb)){\n\n                int last=0;\n\n\t\tfor(i=0; i<64; i++){\n\n                    int j;\n\n                    v= get_bits(gb, 8);\n\n                    if(v==0) break;\n\n\n\n                    last= v;\n\n                    j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= v;\n\n                    s->chroma_inter_matrix[j]= v;\n\n                }\n\n\n\n                /* replicate last value */\n\n                for(; i<64; i++){\n\n\t\t    int j= s->dsp.idct_permutation[ ff_zigzag_direct[i] ];\n\n                    s->inter_matrix[j]= last;\n\n                    s->chroma_inter_matrix[j]= last;\n\n                }\n\n            }\n\n\n\n            // FIXME a bunch of grayscale shape things\n\n        }\n\n\n\n        if(vo_ver_id != 1)\n\n             s->quarter_sample= get_bits1(gb);\n\n        else s->quarter_sample=0;\n\n\n\n        if(!get_bits1(gb)) printf(\"Complexity estimation not supported\\n\");\n\n\n\n        s->resync_marker= !get_bits1(gb); /* resync_marker_disabled */\n\n\n\n        s->data_partitioning= get_bits1(gb);\n\n        if(s->data_partitioning){\n\n            s->rvlc= get_bits1(gb);\n\n            if(s->rvlc){\n\n                printf(\"reversible vlc not supported\\n\");\n\n            }\n\n        }\n\n        \n\n        if(vo_ver_id != 1) {\n\n            s->new_pred= get_bits1(gb);\n\n            if(s->new_pred){\n\n                printf(\"new pred not supported\\n\");\n\n                skip_bits(gb, 2); /* requested upstream message type */\n\n                skip_bits1(gb); /* newpred segment type */\n\n            }\n\n            s->reduced_res_vop= get_bits1(gb);\n\n            if(s->reduced_res_vop) printf(\"reduced resolution VOP not supported\\n\");\n\n        }\n\n        else{\n\n            s->new_pred=0;\n\n            s->reduced_res_vop= 0;\n\n        }\n\n\n\n        s->scalability= get_bits1(gb);\n\n\n\n        if (s->scalability) {\n\n            GetBitContext bak= *gb;\n\n            int ref_layer_id;\n\n            int ref_layer_sampling_dir;\n\n            int h_sampling_factor_n;\n\n            int h_sampling_factor_m;\n\n            int v_sampling_factor_n;\n\n            int v_sampling_factor_m;\n\n            \n\n            s->hierachy_type= get_bits1(gb);\n\n            ref_layer_id= get_bits(gb, 4);\n\n            ref_layer_sampling_dir= get_bits1(gb);\n\n            h_sampling_factor_n= get_bits(gb, 5);\n\n            h_sampling_factor_m= get_bits(gb, 5);\n\n            v_sampling_factor_n= get_bits(gb, 5);\n\n            v_sampling_factor_m= get_bits(gb, 5);\n\n            s->enhancement_type= get_bits1(gb);\n\n            \n\n            if(   h_sampling_factor_n==0 || h_sampling_factor_m==0 \n\n               || v_sampling_factor_n==0 || v_sampling_factor_m==0){\n\n               \n\n//                fprintf(stderr, \"illegal scalability header (VERY broken encoder), trying to workaround\\n\");\n\n                s->scalability=0;\n\n               \n\n                *gb= bak;\n\n            }else\n\n                printf(\"scalability not supported\\n\");\n\n            \n\n            // bin shape stuff FIXME\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 27201, "substitutes": {"s": ["js", "b", "S", "rs", "ssl", "fs", "g", "h", "hs", "p", "features", "u", "sets", "ms", "si", "sync", "xs", "sq", "parts", "n", "qs", "conf", "gs", "less", "es", "l", "ks", "service", "cs", "t", "su", "e", "c", "ss", "spec", "o", "its", "sf", "sites", "vs", "self", "ops", "full", "rates", "session", "ts", "is", "m", "sym", "w", "sg", "this", "f", "ds", "ses", "bis", "sys", "sl", "os", "r", "bs", "storage", "ps", "ges", "ins", "ns", "settings", "d", "ls", "services", "us"], "gb": ["gow", "b", "gm", "che", "bm", "gp", "gio", "gae", "sl", "big", "bc", "Gb", "gh", "gs", "gom", "ko", "gin", "lib", "igh", "bb", "sb", "bo", "game", "g", "gc", "rb", "storage", "cell", "jpg", "wb", "bn", "gi", "boot", "gd", "rg", "hub", "go", "py", "ym", "range", "GB", "gy", "mb", "ge", "bug", "cfg", "cgi", "gam", "db", "eb", "ged", "phy", "gu", "sync", "cod", "git", "bp", "gg", "gnu", "cb", "bf", "lb", "gal", "google", "ui", "usb", "gru", "kb", "bs", "ga", "bg", "buff"], "height": ["depth", "dist", "stroke", "alpha", "resolution", "png", "id", "shape", "crop", "Height", "pull", "window", "quality", "volume", "slice", "density", "def", "input", "padding", "inches", "gap", "diff", "bottom", "length", " heights", "ty"], "vo_ver_id": ["vo_verxident", "vo_version_type", "vo_version_id", "vo_version_ref", "vo_ver_length", "vo_veracid", "vo_verxtype", "vo_ver_bit", "vo_ver_ident", "vo_ver_ref", "vo_version_name", "vo_veraclength", "vo_ver_name", "vo_version_info", "vo_ver_type", "vo_verxid", "vo_version_bit", "vo_verxref", "vo_version_length", "vo_veracinfo", "vo_veracname", "vo_ver_info", "vo_ver_head", "vo_version_head", "vo_version_ident"]}}
{"project": "FFmpeg", "commit_id": "155ec6edf82692bcf3a5f87d2bc697404f4e5aaf", "target": 0, "func": "void ff_init_me(MpegEncContext *s){\n\n    MotionEstContext * const c= &s->me;\n\n    c->avctx= s->avctx;\n\n\n\n    ff_set_cmp(&s->dsp, s->dsp.me_pre_cmp, c->avctx->me_pre_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_cmp, c->avctx->me_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.me_sub_cmp, c->avctx->me_sub_cmp);\n\n    ff_set_cmp(&s->dsp, s->dsp.mb_cmp, c->avctx->mb_cmp);\n\n    \n\n    c->flags    = get_flags(c, 0, c->avctx->me_cmp    &FF_CMP_CHROMA);\n\n    c->sub_flags= get_flags(c, 0, c->avctx->me_sub_cmp&FF_CMP_CHROMA);\n\n    c->mb_flags = get_flags(c, 0, c->avctx->mb_cmp    &FF_CMP_CHROMA);\n\n\n\n/*FIXME s->no_rounding b_type*/\n\n    if(s->flags&CODEC_FLAG_QPEL){\n\n        c->sub_motion_search= qpel_motion_search;\n\n        c->qpel_avg= s->dsp.avg_qpel_pixels_tab;\n\n        if(s->no_rounding) c->qpel_put= s->dsp.put_no_rnd_qpel_pixels_tab;\n\n        else               c->qpel_put= s->dsp.put_qpel_pixels_tab;\n\n    }else{\n\n        if(c->avctx->me_sub_cmp&FF_CMP_CHROMA)\n\n            c->sub_motion_search= hpel_motion_search;\n\n        else if(   c->avctx->me_sub_cmp == FF_CMP_SAD \n\n                && c->avctx->    me_cmp == FF_CMP_SAD \n\n                && c->avctx->    mb_cmp == FF_CMP_SAD)\n\n            c->sub_motion_search= sad_hpel_motion_search; // 2050 vs. 2450 cycles\n\n        else\n\n            c->sub_motion_search= hpel_motion_search;\n\n    }\n\n    c->hpel_avg= s->dsp.avg_pixels_tab;\n\n    if(s->no_rounding) c->hpel_put= s->dsp.put_no_rnd_pixels_tab;\n\n    else               c->hpel_put= s->dsp.put_pixels_tab;\n\n\n\n    if(s->linesize){\n\n        c->stride  = s->linesize; \n\n        c->uvstride= s->uvlinesize;\n\n    }else{\n\n        c->stride  = 16*s->mb_width + 32;\n\n        c->uvstride=  8*s->mb_width + 16;\n\n    }\n\n\n\n    // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it\n\n    if((c->avctx->me_cmp&FF_CMP_CHROMA) && !s->dsp.me_cmp[2]){\n\n        s->dsp.me_cmp[2]= zero_cmp;\n\n    }\n\n    if((c->avctx->me_sub_cmp&FF_CMP_CHROMA) && !s->dsp.me_sub_cmp[2]){\n\n        s->dsp.me_sub_cmp[2]= zero_cmp;\n\n    }\n\n    c->hpel_put[2][0]= c->hpel_put[2][1]=\n\n    c->hpel_put[2][2]= c->hpel_put[2][3]= zero_hpel;\n\n\n\n    c->temp= c->scratchpad;\n\n}\n", "idx": 27203, "substitutes": {"s": ["js", "b", "site", "x", "sf", "in", "n", "qs", "sc", "conf", "S", "gs", "os", "rs", "ctx", "sb", "ssl", "fs", "r", "g", "session", "ps", "aws", "ts", "es", "is", "l", "y", "h", "ks", "service", "p", "cs", "m", "t", "sym", "ic", "u", "w", "sets", "su", "ns", "sg", "si", "this", "settings", "e", "k", "sync", "d", "ss", "f", "spec", "ls", "xs", "i", "ds", "sec", "services", "sq", "o", "comments", "us", "se", "ses", "sys", "as"], "c": ["x", "b", "coll", "fc", "dc", "n", "ch", "xc", "sc", "conf", "bc", "com", "ca", "nc", "ac", "cc", "self", "cp", "cy", "ctx", "r", "cus", "mc", "cache", "g", "es", "l", "y", "h", "v", "ce", "cf", "cont", "enc", "con", "config", "cl", "vc", "p", "core", "cs", "ic", "cr", "t", "m", "cur", "u", "C", "rc", "cm", "w", "ct", "ctrl", "k", "e", "uc", "d", "pc", "f", "lc", "ec", "i", "q", "co", "cu", "ci", "o", "us", "cd"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void filter(MpegAudioContext *s, int ch, short *samples, int incr)\n\n{\n\n    short *p, *q;\n\n    int sum, offset, i, j, norm, n;\n\n    short tmp[64];\n\n    int tmp1[32];\n\n    int *out;\n\n\n\n    //    print_pow1(samples, 1152);\n\n\n\n    offset = s->samples_offset[ch];\n\n    out = &s->sb_samples[ch][0][0][0];\n\n    for(j=0;j<36;j++) {\n\n        /* 32 samples at once */\n\n        for(i=0;i<32;i++) {\n\n            s->samples_buf[ch][offset + (31 - i)] = samples[0];\n\n            samples += incr;\n\n        }\n\n\n\n        /* filter */\n\n        p = s->samples_buf[ch] + offset;\n\n        q = filter_bank;\n\n        /* maxsum = 23169 */\n\n        for(i=0;i<64;i++) {\n\n            sum = p[0*64] * q[0*64];\n\n            sum += p[1*64] * q[1*64];\n\n            sum += p[2*64] * q[2*64];\n\n            sum += p[3*64] * q[3*64];\n\n            sum += p[4*64] * q[4*64];\n\n            sum += p[5*64] * q[5*64];\n\n            sum += p[6*64] * q[6*64];\n\n            sum += p[7*64] * q[7*64];\n\n            tmp[i] = sum >> 14;\n\n            p++;\n\n            q++;\n\n        }\n\n        tmp1[0] = tmp[16];\n\n        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];\n\n        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];\n\n\n\n        /* integer IDCT 32 with normalization. XXX: There may be some\n\n           overflow left */\n\n        norm = 0;\n\n        for(i=0;i<32;i++) {\n\n            norm |= abs(tmp1[i]);\n\n        }\n\n        n = av_log2(norm) - 12;\n\n        if (n > 0) {\n\n            for(i=0;i<32;i++) \n\n                tmp1[i] >>= n;\n\n        } else {\n\n            n = 0;\n\n        }\n\n\n\n        idct32(out, tmp1, s->sblimit, n);\n\n\n\n        /* advance of 32 samples */\n\n        offset -= 32;\n\n        out += 32;\n\n        /* handle the wrap around */\n\n        if (offset < 0) {\n\n            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), \n\n                    s->samples_buf[ch], (512 - 32) * 2);\n\n            offset = SAMPLES_BUF_SIZE - 512;\n\n        }\n\n    }\n\n    s->samples_offset[ch] = offset;\n\n\n\n    //    print_pow(s->sb_samples, 1152);\n\n}\n", "idx": 27237, "substitutes": {"s": ["js", "b", "sf", "sl", "a", "sc", "conf", "sv", "S", "http", "gs", "self", "space", "os", "rs", "ssl", "sb", "sp", "fs", "r", "g", "session", "ps", "aws", "ts", "es", "sa", "l", "v", "is", "ks", "service", "cs", "m", "t", "u", "sets", "su", "ns", "sg", "si", "e", "sup", "c", "sync", "f", "xs", "spec", "ls", "ds", "ss", "services", "server", "o", "ses", "sys"], "ch": ["che", "b", "ach", "com", "conf", "bh", "count", "cp", "chn", "th", "zh", "col", "cy", "sh", "ctx", "ich", "Ch", "h", "conn", "cor", "sk", " chunk", "range", "cl", "code", "change", "cs", "fr", "CH", "channel", "chrom", "chi", "cm", "k", "c", "ches", "cher", "ph", "f", "ht", "chip", "sch", "chan"], "samples": ["ssizes", "Samps", " says", "Sources", "ssamps", "psizes", "psmodels", "insans", "samps", "insamples", "spamples", " sizes", " samps", "ssources", " sources", "sources", "spays", "sizes", "ssamples", "Says", "ssmodels", "psamps", "insamps", "sans", "spources", " sans", "insources", "spamps", "ssans", "smodels", " smodels", "says", "Samples", "psamples"], "incr": ["inferr", "incur", "uprs", " incl", "incp", "incl", " incerr", "infrs", "upl", "upur", "incerr", "discr", "circr", " incp", "discl", "infp", "circrs", "incrs", "infr", "discp", "discerr", "infl", "upr", "infur", "circur", "circl"], "p": ["x", "b", "pg", "pi", "mp", "wp", "a", "pu", "http", "cp", "er", "vp", "private", "sp", "r", "op", "g", "ip", "pm", "ps", "pp", "l", "fp", "h", "v", "y", "pe", "py", "pre", "app", "m", "ap", "t", "P", "u", "per", "it", "po", "jp", "k", "e", "point", "c", "hp", "f", "pc", "api", "np", "pr", "o", "tp", "pad", "cop", "lp", "at", "pa"], "q": ["x", "b", "iq", "eq", "dq", "Q", "qs", "quad", "z", "id", "count", "ac", "charge", "req", "qu", "quant", "qq", "sh", "secure", "r", "g", "qt", "quality", "get", "l", "v", "h", "y", "query", "config", "app", "queue", "qi", "m", "t", "u", "w", "comment", "k", "view", "sync", "c", "like", "d", "ph", "f", "sq", "co", "qa", "question", "form"], "sum": ["Sum", "index", "num", "loss", "weight", "mass", "un", "key", "alpha", "sc", "conf", "error", "err", "count", "ac", "fat", "summary", "sub", "sh", "cum", "sp", "total", "ass", "g", "up", "size", "cache", "add", "vol", "mem", "cal", "mu", "miss", "mix", "sam", "cost", "ma", "average", "part", "skip", "pass", "m", "unit", "cur", "u", "gam", "comment", "scale", "su", "si", "mean", "um", "gram", "f", "sim", "ul", "stat", "ho", "ann", "min", "cu", "am", "pos", "use", "sign", "mit", "name", "se"], "offset": ["index", "ai", "reset", "anch", "set", "align", "base", "entry", "error", "phase", "shift", "ace", "end", "timeout", "Offset", "info", "image", "position", "size", "attr", "fp", "part", "off", "range", "origin", "area", "annot", "address", "prefix", "ii", "si", "addr", "amp", "start", "padding", "f", "output", "length", "api", "ui", "adjust", "pos", "o", "order", "pointer"], "i": ["b", "in", "li", "ie", "id", "iu", "g", "ti", "mu", "ini", "inner", "ik", "I", "u", "k", "si", "eni", "ami", "phi", "ci", "ni", "ei", "ji", "mi", "x", "oi", "info", "gi", "l", "qi", "zi", "ii", "e", "c", "start", "api", "ui", "o", "ri", "at", "index", "z", "anti", "ix", "is", "y", "fi", "uri", "m", "di", "my", "f", "ai", "mini", "pi", "yi", "ip", "bi", "v", "io", "xi", "multi", "it", "init", "d", "ori"], "j": ["x", "b", "js", "jet", "num", "li", "ja", "ie", "aj", "z", "r", "g", "br", "l", "y", "v", "h", "ij", "qi", "m", "t", "u", "it", "ii", "jp", "k", "jc", "si", "jj", "c", "d", "ind", "f", "jl", "ui", "pos", "o", "ji", "J"], "norm": ["orig", "index", "dist", "num", "coll", "loss", "weight", "dc", "normal", "err", "mn", "len", "mom", "color", "ov", "common", "max", "flat", "root", "mem", "raw", "transform", "neg", "nom", "beta", "bd", "draw", "dev", "core", "chrom", "unit", "nn", "radius", "init", "fun", "scale", "carry", "mean", "desc", "small", "loc", "sync", "Norm", "ind", "d", "f", "orm", "diff", "ng", "term", "ann", "global", "pos", "mask", "den", "sign", "form", "im", "ord"], "n": ["x", "b", "num", "adj", "un", "ny", "nat", "nb", "z", "nc", "N", "net", "count", "nor", "nan", "non", "len", "none", "ne", "r", "nt", "g", "number", "bn", "dn", "no", "l", "v", "y", "conn", "m", "t", "cn", "nn", "u", "pn", "ns", "not", "k", "na", "nw", "c", "fn", "d", "e", "nu", "f", "sn", "o", "ni", "en"], "tmp": ["x", "buf", "b", "seed", "front", "mp", "wp", "nb", "cmp", "source", "proc", "crop", "cp", "test", "audio", "bb", "zip", "current", "sp", "nt", "storage", "cache", "up", "cv", "pp", "params", "fp", "v", "bt", "slice", "src", "py", "config", "app", "area", "pre", "batch", "m", "code", "t", "page", "now", "po", "flat", "jp", "amp", "media", "txt", "sup", "sample", "c", "bp", "extra", "output", "img", "cb", "data", "mm", "cpp", "meta", "sq", "np", "map", "tp", "pad", "temp", "uv", "buff"], "tmp1": ["p1", "p3", "cmp0", "mp1", "mp3", " tmp2", "zip0", "temp1", " tmpone", "temp3", "zip2", "temp2", " tmp0", "cmp1", "zipone", "mp0", "cmp2", "tmp3", "tmp2", "tmpone", "tempone", "mpone", "cmpone", "tmp0", "zip1", "mp2", " tmp3", "temp0", "pone"], "out": ["x", "b", "orig", "num", "in", "a", "parent", "outs", "err", "source", "ac", "op", "image", "Out", "cache", "result", "new", "no", "v", "io", "part", "OUT", "inner", "code", "m", "again", "conv", "cmd", "channel", "obj", "w", "input", "flat", "amp", "doc", "sync", "output", "img", "data", "qa", "pos", "o", "bit", "opt", "temp", "bin", "at"]}}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254, "substitutes": {"cs": ["js", "css", "qs", "sc", "cing", "cc", "rs", "ace", "nas", "ctx", "CS", "cus", "fs", "ced", "ck", "ics", "ps", "ys", "cas", "ce", "ks", "cf", "sk", "ras", "vc", "cr", "wcs", "acs", "rc", "sync", "c", "acks", "cons", "ss", "ec", "lc", "ls", "ds", "spec", "ses", "ars"], "run": ["ro", "un", "Run", "ran", "row", "r", "build", "result", "boot", "job", "work", "resource", "go", "con", "pass", "man", "cmd", "unit", "rc", "fun", "ur", "clean", "runs", "process", "view", "exec", "sync", "block", "rm", "mor", "output", "ru", "call", "thread", "min", "execute", "use", "reg", "runner", "name", "re", "play"], "cpu": ["bench", "vm", "css", "lan", "bc", "pu", "cmp", "anc", "nc", "proc", "cp", "hw", "ctx", "board", "cache", "gc", "boot", "conn", "gpu", "roc", "config", "computer", "core", "uci", "processor", "cn", "unit", "android", "mac", "uno", "process", "node", "sync", "c", "linux", "clock", "CPU", "pc", "lc", "cli", "cow", "lb", "component", "cu", "gru", "chip", "runner", "phy"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n", "idx": 27256, "substitutes": {"dev": ["mod", "dc", "driver", "conf", "self", "der", "req", "develop", "test", "rad", " def", "info", "dom", "DEV", "serial", "v", "ver", "wd", "app", "pack", "grad", "cmd", "nov", "def", "obj", "ev", "de", "device", "md", "Dev", "bug", "var", "plug", "die", "comment", "block", "dd", "d", "diff", "data", "user", "development", "dem", " device"], "bus": ["dir", "b", "plugin", "port", "disk", "loop", "base", "driver", "bc", "pu", "home", "http", "self", "os", "lib", "tag", "board", "host", "bs", "cache", "band", "Bus", "boot", "controller", "serial", "hub", "BUS", "name", "config", "pass", "pack", "lock", "def", "force", "prefix", "bug", "device", "plug", "die", "feed", "block", "sync", "drive", "bridge", "cat", "mount", "usb", "dest", "back", "user", "bit", "us", "length", "bin"], "iommu_bus": ["iommnu_bin", "iommru_bin", "iommuit_cat", "iommru_bus", "iommuit_bus", "iommnu_bug", "iommui_lib", "iommus_bus", "iommu__dev", "iommu_block", "iommu_plug", "iommo_bus", "iommo_pass", "iommo_block", "iommu_pass", "iommu_boot", "iommus_boot", "iommo_BUS", "iommuit_lib", "iommu2plug", "iommu_BUS", "iommu__usb", "iommru_band", "iommnu_BUS", "iommus_BUS", "iommo_plug", "iommu_usb", "iommui_boot", "iommu__BUS", "iommo_us", "iommu_controller", "iommus_pass", "iommui_BUS", "iommu_dev", "iommu_cat", "iommu_lib", "iommnu_bus", "iommo_usb", "iommu_bin", "iommu_bug", "iommu__block", "iommui_bus", "iommru_BUS", "iommuit_plug", "iommu_us", "iommu2lib", "iommo_controller", "iommu2bus", "iommo_dev", "iommu__bus", "iommu2cat", "iommu_band"]}}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257, "substitutes": {"dst": ["idbl", " dsp", "sdstop", "pdrc", "idsc", "fsrc", "sdST", "dbl", "idste", "sdst", "dsc", "dste", "idST", "fdost", " dST", "sdsc", "pdst", "dsp", "edST", "ddest", "dput", "dsrc", "pst", "fdest", "fdbl", "dsts", "cdST", " dbl", "sdsts", "prc", "Dst", "dost", "idst", "fdste", "drc", "cdsrc", "pST", " dsrc", "pddest", " dste", "dST", "sdsp", "DST", "edstop", " drc", " ddest", "isdsts", "frc", "dstop", "fst", "pdsrc", "nST", " dsts", "idstop", "fdst", "pput", "isdsc", "isdst", "nst", "isdsp", "edst", "Dsc", " dput", "nrc", "edsc", "Dsrc", "nput", " dost", "cdst", "idost", "cdsc", " dsc"], "src": ["b", "dist", "fc", "rec", "sr", "sl", "rin", "sc", "rib", "bc", "cmp", "source", "lib", "sub", "sb", "ctx", "sel", "ssl", "rb", "stab", "attr", "url", "sur", "config", "sta", "vc", "rl", "conv", "rss", "inst", "vr", "rc", "loc", "uc", "sup", "sync", "img", "cb", "stat", "sn", "dest", "obl", "st", "sys", "cur"], "fcc_offset": ["fccsoff", "fcc_ref", "fct_position", "fct_ref", "fck_off", "fct_adjusted", "fCC_off", "fccsoffset", "fccsref", "fccsOffset", "fCC_ref", "fcc2offset", "fcc2ref", "fcc_Offset", "fck_offset", "fct_offset", "fCCsoffset", "fcc_adjusted", "fCCsoff", "fcc2off", "fcc_off", "fCCsref", "fck_Offset", "fcc_position", "fCC_offset"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_decode(AVCodecContext *avctx,\n\n                         void *data, int *data_size,\n\n                         AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    AVSubtitle *sub = data;\n\n    const uint8_t *p, *p_end;\n\n    int segment_type;\n\n    int page_id;\n\n    int segment_length;\n\n    int i;\n\n\n\n    av_dlog(avctx, \"DVB sub packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    if (buf_size <= 6 || *buf != 0x0f) {\n\n        av_dlog(avctx, \"incomplete or broken packet\");\n\n        return -1;\n\n    }\n\n\n\n    p = buf;\n\n    p_end = buf + buf_size;\n\n\n\n    while (p_end - p >= 6 && *p == 0x0f) {\n\n        p += 1;\n\n        segment_type = *p++;\n\n        page_id = AV_RB16(p);\n\n        p += 2;\n\n        segment_length = AV_RB16(p);\n\n        p += 2;\n\n\n\n        if (p_end - p < segment_length) {\n\n            av_dlog(avctx, \"incomplete or broken packet\");\n\n            return -1;\n\n        }\n\n\n\n        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||\n\n            ctx->composition_id == -1 || ctx->ancillary_id == -1) {\n\n            switch (segment_type) {\n\n            case DVBSUB_PAGE_SEGMENT:\n\n                dvbsub_parse_page_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_REGION_SEGMENT:\n\n                dvbsub_parse_region_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_CLUT_SEGMENT:\n\n                dvbsub_parse_clut_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_OBJECT_SEGMENT:\n\n                dvbsub_parse_object_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAYDEFINITION_SEGMENT:\n\n                dvbsub_parse_display_definition_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAY_SEGMENT:\n\n                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);\n\n                break;\n\n            default:\n\n                av_dlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\",\n\n                        segment_type, page_id, segment_length);\n\n                break;\n\n            }\n\n        }\n\n\n\n        p += segment_length;\n\n    }\n\n\n\n    return p - buf;\n\n}\n", "idx": 27261, "substitutes": {"avctx": ["afpkg", "abcc", "AVcas", "afcu", "afci", "avecf", "ajpkg", "AVcn", "airpkg", "avpkg", "aviactx", "abctx", "avalkb", "aviaconfig", "afvoc", " avcontext", "aviacontext", "avalcn", "avectx", "avalcontext", "afcontext", " avcu", "avefw", "avecontext", "AVloc", "AVkb", "abcontext", "avalctx", "avalsync", "ajcontext", "ajcot", "avalfw", "afcca", "ajcn", "avesync", "aircot", "Avcu", "navconn", "AVconfig", "avci", "avepkg", "airctx", "avfw", "avalcf", "avekb", "avcu", "avcf", "abcf", "afctx", "Avcontext", "afconn", "avconn", "avsync", "abpkg", "afsync", "avcc", "avvoc", "afcot", "AVcontext", "avecc", "Avci", "abcu", "affw", "avalconfig", "AVcf", "Avctx", "aveloc", "avconfig", "navcca", "ajctx", "ajwcs", "avalwcs", "navctx", "avalcas", "avcot", "avcn", "avcas", "avalconn", "avcontext", "avalcca", "avalcc", "avecu", " avci", "avcca", "navcontext", "avkb", "AVvoc", "aviacas", "avloc", "avalloc", "aircontext", "avevoc", "AVwcs", "avwcs", "avalvoc", "AVctx"], "data": ["context", "rec", "ra", "results", "parent", "value", "base", "da", "message", "text", "body", "bytes", "response", "DATA", "window", "board", "image", "cache", "size", "result", "root", "reader", "au", "config", "frame", "batch", "primary", "channel", "package", "Data", "rc", "buffer", "input", "sample", "media", "block", "d", "padding", "aux", "next", "val", "load", "map", "content", "meta", "api", "cat", "client", "umi", "dat", "length", "buff"], "data_size": ["buffer_width", "data_width", "buffer_start", "datablocklength", "buffer_length", "datablockstart", "datablockwidth", "data_length", "datablocksize", "data_start", "buffer_size"], "avpkt": ["AVfkt", "AVpkn", "AVPkt", "avlputo", "avcpkt", "avPct", "AVfke", "AVcpkn", "avhacket", "AVpkt", "AVPuto", "avhkt", "avfacket", "avpct", "avspct", "AVpke", "avpkn", "avpbacket", "AVPke", "AVpct", "AVPacket", "avpacket", "avputo", "AVcpacket", "avcpkn", "avpbke", "avlpke", "AVfct", "avPkt", "avlpacket", "AVcpkt", "avcpct", "avpbkt", "avpke", "avPke", "avfkn", "avlpkt", "avcpacket", "avPuto", "AVfacket", "avfkt", "avfke", "avfct", "avhct", "AVpacket", "avpbuto", "avPacket", "avspacket", "AVputo", "avspkt", "AVcpct", "avhke", "avspkn"], "buf": ["b", "cap", "port", "num", "array", "box", "pb", "prop", "front", "grab", "home", "bc", "vec", "cp", "rb", "cache", "wb", "cv", "br", "cas", "mem", "h", "v", "fp", "cf", "src", "large", "pool", "config", "batch", "queue", "alloc", "pack", "conv", "cmd", "ab", "cur", "buffer", "rc", "feat", "loc", "block", "bag", "seq", "uc", "padding", "f", "img", "c", "cb", "bp", "uf", "back", "ff", "pad", "length", "fb", "buff"], "ctx": ["fw", "context", "fc", "remote", "wp", "xc", "parent", "bc", "aka", "cmp", "ca", "anc", "nc", "cc", "cp", "connection", "lib", "hw", "pkg", "ck", "cv", "cas", "fp", "conn", "wx", "cf", "config", "cam", "vc", "cmd", "cn", "rc", "cm", "tx", "ctrl", "jp", "cca", "txt", "loc", "sync", "c", "git", "ha", "media", "exec", "lc", "cb", "cli", "component", "sq", "cu", "ci", "np", "qa", "co", "communication", "client", "concept", "support", "pa", "chan"], "sub": ["rec", "pl", "path", "ch", "sc", "child", "summary", "text", "sp", "job", "sam", "part", "config", "app", "ub", "pub", "desc", "uc", "sup", "Sub", "seq", "sec", "meta", "reg", "section", "form", "name"], "p": ["x", "b", "port", "pb", "pi", "n", "mp", "wp", "pl", "parser", "parent", "j", "proc", "cp", "vp", "sp", "r", "patch", "ip", "op", "up", "g", "pp", "ps", "l", "fp", "v", "y", "pe", "part", "h", "py", "pre", "at", "m", "ap", "dp", "t", "s", "P", "u", "page", "per", "po", "jp", "e", "point", "c", "pt", "bp", "d", "pc", "f", "api", "q", "np", "pr", "pos", "o", "client", "lp", "tp", "a", "post", "pa"], "p_end": ["pixbegin", "P_start", "p_ending", "p___ident", "dataIPpost", "ap_end", "p__start", "pIPend", "p___post", "data_offset", "p_begin", "p_ends", "lp___en", "p__ends", "P__start", "P__ends", "lp_end", "p_offset", "p___id", "pIPoffset", "lp_en", "p___range", "lp_id", "pixcenter", "P_ends", "data_end", "p_en", "P__end", "ap_ending", "data_post", "p___end", "P__get", "P_end", "p_range", "dataIPend", "p___en", "p_start", "pixend", "dataIPoffset", "ap_begin", "p___offset", "lp___end", "pIPpost", "lp_range", "p_post", "p_id", "p__end", "p__get", "p_get", "p_center", "dataIPident", "P_get", "pixending", "data_ident", "lp___id", "ap_center", "lp___range", "p_ident", "pIPident"], "segment_type": ["sement_style", "sement_type", "sement_id", "segment_style", "segment_id", "sement_name", "sement_length", "segment_name"], "page_id": ["page_type", "pageCsize", "page_no", " page_no", "page_uri", "page___id", "section_case", " page_uri", "page_sid", "page_case", " page_type", "page_num", "page_iden", "pageCid", " page_size", "page___num", "page___no", " page_num", "pageCiden", "page___type", " page_iden", "section_id", "section_ids", "section_iden", "page_ids", "pageCtype", "page_size", " page_sid"], "segment_length": ["pe\n", "segmentlenid", "segment_size", "seend", "sedata", "segmentaltype", "pedata", "segmentlenlength", "asedata", "segment_text", "segmentalltype", "segments_number", "segmentaltext", "sement_length", "segmentallength", "segments_count", "segmentalltext", " se\n", "se\n", "sement_base", "segments_type", "segmentalend", "peend", "segmentitynumber", "segmentlenlen", "segments_size", "segmentlenbase", "segmentityend", "sement_text", "sement_id", "segmentitytype", "segment_id", "segment_end", "segment_count", "sement_type", "segments_end", "aseend", "segmentalllength", "segments_length", "segment_len", "segmentallend", "segment_base", "segment_number", "ase\n", " sedata", "sement_end", "segmentitylength", " seend", "sement_len"], "i": ["x", "ai", "b", "mini", "index", "oi", "li", "pi", "n", "id", "j", "end", "yi", "info", "r", "hi", "ip", "iu", "gi", "bi", "l", "v", "ti", "mu", "fi", "io", "uri", "xi", "ini", "multi", "qi", "m", "zi", "s", "I", "t", "di", "u", "ii", "si", "e", "c", "d", "start", "f", "eni", "adi", "lc", "api", "ui", "phi", "ci", "vi", "o", "ri", "a", "mi"]}}
{"project": "qemu", "commit_id": "04088adbe0c5adca66adb6022723362ad90ed0fc", "target": 0, "func": "static void *mpc8544_load_device_tree(target_phys_addr_t addr,\n\n                                     uint32_t ramsize,\n\n                                     target_phys_addr_t initrd_base,\n\n                                     target_phys_addr_t initrd_size,\n\n                                     const char *kernel_cmdline)\n\n{\n\n    void *fdt = NULL;\n\n#ifdef CONFIG_FDT\n\n    uint32_t mem_reg_property[] = {0, ramsize};\n\n    char *filename;\n\n    int fdt_size;\n\n    int ret;\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);\n\n    if (!filename) {\n\n        goto out;\n\n    }\n\n    fdt = load_device_tree(filename, &fdt_size);\n\n    qemu_free(filename);\n\n    if (fdt == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    /* Manipulate device tree in memory. */\n\n    ret = qemu_devtree_setprop(fdt, \"/memory\", \"reg\", mem_reg_property,\n\n                               sizeof(mem_reg_property));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n", "idx": 27266, "substitutes": {"addr": ["cap", "ext", "base", "ace", "len", "ptr", "host", "ip", "type", "amd", "ock", "conn", "part", "oa", "config", "arr", "arm", "address", "args", "endor", "db", "seq", "ad", "pos", "ord", "name", "arp", "offset"], "ramsize": ["RAMclass", "gramname", "ramaddress", "mmsize", "gramaddress", " ramSIZE", "memaddress", "memclass", "RAMSize", "memname", "RAMsize", " ramclass", "ramclass", "memsize", "gramsize", "mmname", "RAMSIZE", "gramSize", "ramSIZE", "memSIZE", "ramSize", "ramname", "mmSize", "memSize", "mmaddress", " ramSize"], "initrd_base": ["initrd01start", "initrn_start", "initrd_scale", "initrn_base", "initrd_area", "initrdMlength", "initrd2unit", "initrdMbase", "initrdMsize", "initrd01base", "initrn01source", "initrt_scale", "initrdvstart", "initrd_source", "initrdvunit", "initrt_base", "initrn_source", "initrn_unit", "initrid_name", "initrid_base", "initrd2start", "initrd2base", "initrd_unit", "initrt_size", "initrn01base", "initrd_name", "initrdvbase", "initrt_length", "initrdMscale", "initrd_length", "initrn01start", "initrd_start", "initrid_area", "initrd2source", "initrd01source", "initrd01unit", "initrid_size", "initrdvsource", "initrn01unit"], "initrd_size": ["initrd_scale", "initrt_adjust", "initrd_align", "initrt_scale", "initrt_base", "initrt_size", "initrd_SIZE", "initrt_align", "initrt_SIZE", "initrd_adjust"], "kernel_cmdline": ["kernel_mainlines", "kernel_commandlic", "kernel_mainlink", "kernel_cmdLine", "kernel_hardlink", "kernel_Cmdline", "kernel_hardlines", "kernel_cmdlink", "kernel_commandlines", "kernel_hardline", "kernel_cmdlic", "kernel_commandLine", "kernel_cmdlines", "kernel_CmdLine", "kernel_commandlink", "kernel_commandline", "kernel_mainline", "kernel_Cmdlic"], "fdt": ["vdt", "fdtt", "fcnt", "ldtr", "fedtr", "ddc", "vdT", "fxt", "fedt", "vdta", "FDt", "dbtf", "fxtf", "dlnt", "dlc", "sdt", "FDT", "cdte", "fxnt", "sdtt", "dbT", "dfta", "ddtr", "FDtt", "dbt", "dlT", "fxtt", "fdp", "ddte", "FDc", "cdt", "dfte", "vdc", "fctf", "fdnt", "fctt", "dftf", "cdtt", "ldte", "sdp", "windtr", "windt", "fedte", "windte", "windnt", "dlte", "fdtf", "FDtf", "dltr", "dftr", "fct", "dlt", "dfnt", "FDp", "fdc", "fdte", "cdtr", "dltt", "sdc", "dft", "dltf", "fdta", "dfT", "fdT", "dftt", "fdtr", "fedtf", "ddtt", "ddt", "ldtf", "ddp", "dfc", "dbtt", "ldt", "dlta"], "mem_reg_property": ["mem_reg_info", "mem_rg_attribute", "mem_rg_data", "mem_reg_prop", "mem_reg_string", "mem_rec_info", "mem_rg_properties", "mem_reg__info", "mem_reg__property", "mem_reg_attribute", "mem_rec_properties", "mem_rec_string", "mem_reg_properties", "mem_reg_data", "mem_rg_property", "mem_rec_property", "mem_rec_prop", "mem_reg__prop"], "filename": ["jet", "b", "database", "nl", "sf", "path", "journal", "dll", "source", "lua", "fil", "dyl", "binary", "fd", "kl", "utf", "wl", "sheet", "wb", "jpg", "there", "which", "location", "fp", "mil", "url", "uri", "files", "il", "successfully", "bj", "lace", "nil", "rl", "json", "username", "prefix", "subject", "til", "feat", "directory", "file", "txt", "fn", "loc", "actual", "f", "SourceFile", "download", "jl", "document", "phrase", "bf", "Filename", "kn", "name", "length", "offset"], "fdt_size": ["fdT_len", "fdT_length", "fdT_name", "fdtlenbase", "fdtf_cap", "fdt_cap", "fdtf_base", "fdtlenlength", "fdT_size", "fdt_len", "fdtf_size", "fdt_name", "fdt_length", "fdtf_length", "fdtlencap", "fdt_base", "fdtlensize"], "ret": ["num", "hash", "rf", "ut", "key", "error", "reply", "search", "mt", "id", "RET", "format", "valid", "let", "len", "gt", " RET", "nt", "result", "alt", "resp", "det", "url", "ref", "part", "py", "rev", "rets", "ben", "pass", "rl", "match", "ft", "obj", "def", "fun", "att", "feat", "arg", "true", "rt", " Ret", "lit", "bf", "str", "val", "cat", "lt", "back", "Ret", "reg", "res", "flag", "bit", "opt", "art", "success", "re", "post"], "dirp": ["_", "airpc", "num", "Dirp", "dirc", "descpc", " directorys", "dbp", " dirs", "path", "id", "proc", "func", "write", "Dirpi", "DIRp", "dbc", "function", "urlpc", "g", " dirpi", "DIRd", "type", "airc", " dirc", "new", "dbd", "Dirs", " dirpart", "airp", "Dirc", "dirpc", "config", "dirpi", "descp", "dird", "dbpart", "dev", "dircp", "urlc", "device", "aircp", "DIRpart", "urlcp", "desccp", "c", "linux", "d", " directoryp", " dird", "descc", " directoryc", " directorypi", "urlp", "DIRc", "dirpart", "dirs"], "dp": ["dir", "dep", "pg", "gp", "pb", "dq", "dc", "dos", "wp", "DP", "port", "df", "cp", "dh", "vp", "rpm", "pkg", "dim", "dra", "pm", "pp", "dr", "director", "dn", "fp", "pid", "iper", "dB", "p", "tmp", "tp", "dm", "di", "adr", "db", "jp", "d", "pd", "hp", "ep", "dl", "np", "deb", "lp"], "buf": ["cap", "fw", "box", "array", "bc", "vec", "bh", "text", " buffers", "bb", "sb", "ctx", "fd", "ptr", "rb", "bs", "utf", "bn", "wb", "br", "cv", "Buffer", "cas", "fp", "bt", "cf", "src", "bd", "config", "batch", "queue", "alloc", "conv", "cmd", "ab", "rc", "buffer", "desc", "loc", "block", "bag", "seq", "output", "img", "cb", "bf", "lb", "data", "uf", "ff", " buffer", "uv", "fb", "buff"]}}
{"project": "FFmpeg", "commit_id": "3a25c707fae3c6e99fdda40474c3d74be24cc4c3", "target": 0, "func": "static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = av_new_stream(c->fc, c->fc->nb_streams);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = CODEC_TYPE_DATA;\n\n    st->start_time = 0; /* XXX: check */\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if(sc->chunk_count && (!sc->stts_count || !sc->sample_to_chunk_sz ||\n\n                           (!sc->sample_size && !sc->sample_count))){\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        sc->sample_count = 0; //ignore track\n\n        return 0;\n\n    }\n\n    if(!sc->time_rate)\n\n        sc->time_rate=1;\n\n    if(!sc->time_scale)\n\n        sc->time_scale= c->time_scale;\n\n    av_set_pts_info(st, 64, sc->time_rate, sc->time_scale);\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_AUDIO &&\n\n        !st->codec->frame_size && sc->stts_count == 1)\n\n        st->codec->frame_size = av_rescale(sc->time_rate, st->codec->sample_rate, sc->time_scale);\n\n\n\n    if(st->duration != AV_NOPTS_VALUE){\n\n        assert(st->duration % sc->time_rate == 0);\n\n        st->duration /= sc->time_rate;\n\n    }\n\n    sc->ffindex = st->index;\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR, \"stream %d, error opening file %s: %s\\n\",\n\n                   st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));\n\n    } else\n\n        sc->pb = c->fc->pb;\n\n\n\n    switch (st->codec->codec_id) {\n\n#ifdef CONFIG_H261_DECODER\n\n    case CODEC_ID_H261:\n\n#endif\n\n#ifdef CONFIG_H263_DECODER\n\n    case CODEC_ID_H263:\n\n#endif\n\n#ifdef CONFIG_MPEG4_DECODER\n\n    case CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width= 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n#ifdef CONFIG_VORBIS_DECODER\n\n    case CODEC_ID_VORBIS:\n\n#endif\n\n        st->codec->sample_rate= 0; /* let decoder init parameters properly */\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->sample_to_chunk);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n\n\n    return 0;\n\n}\n", "idx": 27272, "substitutes": {"c": ["b", "coll", "fc", "dc", "ch", "xc", "conf", "bc", "anc", "nc", "ca", "ac", "cc", "cp", "cy", "ctx", "cus", "r", "mc", "cache", "g", "l", "ce", "cf", "con", "icc", "config", "vc", "p", "cs", "ic", "tc", "m", "cn", "cur", "cit", "s", "C", "rc", "cr", "ctrl", "ct", "k", "this", "e", "uc", "cod", "pc", "ec", "lc", "f", "cat", "co", "cu", "ci", "cd"], "pb": ["b", "platform", "bm", "abb", "fc", "pl", "mp", "plugin", "arb", "wp", "bc", "rob", "bh", "proc", "cp", "summary", "bb", "sb", "PB", "prot", "rb", "pm", "wb", "auc", "bps", "fp", "pid", "pool", "icc", "pa", "p", "xb", "gb", "ub", "tc", "ab", "cm", "eb", "db", "uc", "param", "bp", "prototype", "pc", "cb", "lb", "cpp", "typ", "api", "client", "abc", "orp", "tp", " eb", "lp", "fb"], "atom": ["prop", "plane", "arch", " atoms", "com", "tm", "mol", "orb", "monitor", "fam", "mom", "mat", " Atom", "chem", "dom", "attr", "asm", "article", "item", "tom", "ym", "atomic", "config", "app", "om", "sym", "tc", "ab", "node", "param", "orm", "alog", "object", "tab", "typ", "account", "am", "abc", "org", " com", "at"], "st": ["scope", "sr", "bc", "Sc", "sb", "sh", "St", "inst", "ast", "sync", "co", "sn", "ci", "osc", "post", "cur", "pg", "ist", "pl", "set", "std", "stop", "cc", "nt", "sta", "cl", "cs", "t", "ft", "rc", "pt", "start", "pc", "ss", "lc", "fe", "client", "nd", "step", "sd", "fc", "ost", "ace", "sth", "sp", "tt", "ust", "ts", "sa", "src", "sk", "capt", "config", "rest", "est", "fr", "stage", "ST", "str", "esc", "sl", "ut", "sci", "stack", "sts", "storage", "cr", "ste", "ld", "ct", "uc", "sec", "td", "sw", "dest", "SC", "se"], "sc": ["isc", "contract", "scope", "fc", "sd", "dc", "pl", "ch", "sci", "com", "bc", " Sc", "ca", "nc", "anc", "Sc", "cc", "cp", "cy", "sem", "test", "sub", "ctx", "sb", "asc", "sh", "crit", "sp", "ced", "cv", "cont", "ce", "cf", "src", "sk", "enc", "capt", "acc", "config", "scan", "cl", "sche", "core", "cs", "cr", "tc", "access", "rc", "ct", "desc", "loc", "uc", "inc", "sync", "sup", "ec", "pc", "lc", "spec", "ss", "sec", "sq", "sw", "esc", "SC", "osc", "usc", "scl", "ga", "cur"], "ret": ["ut", "status", "reply", "value", "mt", "RET", "aud", "len", "red", "nt", " RET", "gc", "result", "alt", "resp", "det", "ner", "no", "url", "ref", "al", "rets", "pass", "arr", "ft", "def", "fail", "rc", "fun", "att", "feat", "desc", "rt", "lit", "str", "val", "rep", "data", "pet", "back", "Ret", "reg", "res", "en", "success", "re", "ext"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int libschroedinger_encode_init(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroVideoFormatEnum preset;\n\n\n\n    /* Initialize the libraries that libschroedinger depends on. */\n\n    schro_init();\n\n\n\n    /* Create an encoder object. */\n\n    p_schro_params->encoder = schro_encoder_new();\n\n\n\n    if (!p_schro_params->encoder) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unrecoverable Error: schro_encoder_new failed. \");\n\n        return -1;\n\n    }\n\n\n\n    /* Initialize the format. */\n\n    preset = ff_get_schro_video_format_preset(avctx);\n\n    p_schro_params->format =\n\n                    schro_encoder_get_video_format(p_schro_params->encoder);\n\n    schro_video_format_set_std_video_format(p_schro_params->format, preset);\n\n    p_schro_params->format->width  = avctx->width;\n\n    p_schro_params->format->height = avctx->height;\n\n\n\n    if (set_chroma_format(avctx) == -1)\n\n        return -1;\n\n\n\n    if (avctx->color_primaries == AVCOL_PRI_BT709) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_HDTV;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_625;\n\n    } else if (avctx->color_primaries == AVCOL_PRI_SMPTE170M) {\n\n        p_schro_params->format->colour_primaries = SCHRO_COLOUR_PRIMARY_SDTV_525;\n\n    }\n\n\n\n    if (avctx->colorspace == AVCOL_SPC_BT709) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_HDTV;\n\n    } else if (avctx->colorspace == AVCOL_SPC_BT470BG) {\n\n        p_schro_params->format->colour_matrix = SCHRO_COLOUR_MATRIX_SDTV;\n\n    }\n\n\n\n    if (avctx->color_trc == AVCOL_TRC_BT709) {\n\n        p_schro_params->format->transfer_function = SCHRO_TRANSFER_CHAR_TV_GAMMA;\n\n    }\n\n\n\n    if (ff_get_schro_frame_format(p_schro_params->format->chroma_format,\n\n                                  &p_schro_params->frame_format) == -1) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This codec currently supports only planar YUV 4:2:0, 4:2:2\"\n\n               \" and 4:4:4 formats.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p_schro_params->format->frame_rate_numerator   = avctx->time_base.den;\n\n    p_schro_params->format->frame_rate_denominator = avctx->time_base.num;\n\n\n\n    p_schro_params->frame_size = avpicture_get_size(avctx->pix_fmt,\n\n                                                    avctx->width,\n\n                                                    avctx->height);\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (!avctx->gop_size) {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"gop_structure\",\n\n                                         SCHRO_ENCODER_GOP_INTRA_ONLY);\n\n\n\n        if (avctx->coder_type == FF_CODER_TYPE_VLC)\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"enable_noarith\", 1);\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"au_distance\", avctx->gop_size);\n\n        avctx->has_b_frames = 1;\n\n        p_schro_params->dts = -1;\n\n    }\n\n\n\n    /* FIXME - Need to handle SCHRO_ENCODER_RATE_CONTROL_LOW_DELAY. */\n\n    if (avctx->flags & CODEC_FLAG_QSCALE) {\n\n        if (!avctx->global_quality) {\n\n            /* lossless coding */\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_LOSSLESS);\n\n        } else {\n\n            int quality;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_CONSTANT_QUALITY);\n\n\n\n            quality = avctx->global_quality / FF_QP2LAMBDA;\n\n            if (quality > 10)\n\n                quality = 10;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"quality\", quality);\n\n        }\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"rate_control\",\n\n                                         SCHRO_ENCODER_RATE_CONTROL_CONSTANT_BITRATE);\n\n\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"bitrate\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_INTERLACED_ME)\n\n        /* All material can be coded as interlaced or progressive\n\n           irrespective of the type of source material. */\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"interlaced_coding\", 1);\n\n\n\n    schro_encoder_setting_set_double(p_schro_params->encoder, \"open_gop\",\n\n                                     !(avctx->flags & CODEC_FLAG_CLOSED_GOP));\n\n\n\n    /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger\n\n     * and libdirac support other bit-depth data. */\n\n    schro_video_format_set_std_signal_range(p_schro_params->format,\n\n                                            SCHRO_SIGNAL_RANGE_8BIT_VIDEO);\n\n\n\n    /* Set the encoder format. */\n\n    schro_encoder_set_video_format(p_schro_params->encoder,\n\n                                   p_schro_params->format);\n\n\n\n    /* Set the debug level. */\n\n    schro_debug_set_level(avctx->debug);\n\n\n\n    schro_encoder_start(p_schro_params->encoder);\n\n\n\n    /* Initialize the encoded frame queue. */\n\n    ff_schro_queue_init(&p_schro_params->enc_frame_queue);\n\n    return 0;\n\n}\n", "idx": 27296, "substitutes": {"avctx": ["afcmd", "ovmc", "avscope", "ajpkg", "avalcmd", "AVtx", "avecms", "avcmd", "avpkg", "abctx", "avtx", "aveconn", " avcontext", "afcam", "ajscope", "avalscope", "avectx", "aveqa", "avalcontext", "afcontext", "ajvoc", "avecontext", "AVloc", "abcontext", "avalctx", "navpkg", "ovcontext", "avaltx", "ajcontext", "afcn", "afcca", "ajcmp", "ajcms", "ajcn", "avemc", "avecca", "AVconn", "navconn", "AVconfig", "Avtx", "ajcam", "avqa", "avcam", "avetx", "afconfig", "avescope", "Avconfig", "aveconfig", "abconfig", "afctx", "Avcontext", "avconn", "AVcca", "aucca", "avvoc", "avcms", "aucontext", "AVcontext", "ovcms", "avalconfig", "Avctx", "afmc", "afscope", "ajqa", "aveloc", "avcmp", "afcms", "avalpkg", "afqa", "avconfig", "navcca", "ajctx", "AVcam", "navctx", " avtx", "AVpkg", "ovctx", " avconfig", "aucmp", "avcn", "ajcmd", "avecn", "afcmp", "avcontext", "ajloc", "AVcmp", "avcca", "navcontext", "abcmp", "AVvoc", "avloc", "avalloc", "auctx", "avevoc", "navloc", "avmc", "auconfig", "AVctx"], "p_schro_params": ["p_schro_data", "p_schro2params", "p_schro__parser", "p_schrojmanager", "p_schro_private", "p_schrob_parser", "p_schrobmanager", "p_schro_spec", "p_schrob_manager", "p_schroPparam", "p_schroJresources", "p_schrob_members", "p_schrob_ams", "p_schrom_params", "p_schro_ams", "p_schro_resources", "p_schrob_private", "p_schrob_spec", "p_schrobparam", "p_schla_ams", "p_schro2manager", "p_schro_reader", "p_schroJreader", "p_schro__param", "p_schrojams", "p_schro2param", "p_schros_params", "p_schrom_nas", "p_schros_nas", "p_schrob_settings", "p_schroJparams", "p_schro__nas", "p_schrothesettings", "p_schrob_args", "p_schros_param", "p_schro_args", "p_schros_video", "p_schrojmodel", "p_schrobams", "p_schro_nas", "p_schro_master", "p_schrob_loss", "p_schrob_service", "p_schla_model", "p_schro_loss", "p_schroPparams", "p_schrotheprefix", "p_schro__params", "p_schro_service", "p_schro_param", "p_schrom_master", "p_schrob_resources", "p_schla_manager", "p_schroPams", "p_schrotheresources", "p_schro_video", "p_schro_prefix", "p_schros_ams", "p_schrob_prefix", "p_schro_model", "p_schro_manager", "p_schro__master", "p_schro_members", "p_schro__ams", "p_schrobparams", "p_schro_settings", "p_schro_parser", "p_schros_data", "p_schla_params", "p_schro2settings", "p_schrob_params", "p_schrob_reader", "p_schroJprivate", "p_schroPvideo", "p_schrojparams", "p_schrotheparams", "p_schrom_param", "p_schrob_param"], "preset": ["presets", "PRESeting", " presette", "presET", " preseting", "presetting", " presET", "framET", " presets", " Preset", "PRESET", "PresET", "pretet", "PRESette", " PresET", "frametting", "presett", "PRESetting", "pretette", "Presets", "Preset", "PRESett", "PRESet", "preseting", " presett", " presat", "framat", "Presett", "presat", " Presets", " presetting", " Presett", "preteting", "PRESat", "pretett", "presette", "framet"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311, "substitutes": {"system_memory": ["system_network", " system_media", "system_storage", " system_network", "system_connection", "module_image", "module_network", "system_media", "system_image", " system_storage", "module_memory", "module_connection"], "base": ["b", "du", "byte", "net", "ace", "ape", "end", "full", "mx", "info", "r", "ba", "ip", "fs", "unk", "us", "ix", "bi", "root", "la", "work", "is", "be", "au", "null", "area", "p", "gb", "weak", "core", "Base", "ada", "prefix", "address", "u", "buffer", "bas", "scale", "e", "c", "padding", "pc", "f", "i", "bf", "bro", "data", "server", "name"], "txirq": ["rxpirque", "txigrque", "txpirp", "tyirp", "txirqs", "txidq", "txigrq", "txirtq", "txirp", "txidp", "txdrq", "txirque", "txirk", "txpirq", "rxpirqs", "tyirce", "tyirqu", "rxirk", "tyirap", "rxirque", "txirtque", "txiraq", "tyiraq", "txidque", "tyirq", "txigrk", "txpirqs", "txiraqu", "rxpirp", "txpirqu", "txidqs", "txirtp", "rxpirk", "rxirqu", "txirqu", "txpirque", "txirap", "rxirp", "txdrk", "txdrque", "rxpirqu", "txpirk", "tyiraqu", "rxirqs", "rxpirq", "txdrqu", "txpirce", "txigrqu", "tyirace", "txirace", "txirtqs", "txirce"], "rxirq": ["rxdrqs", "rhirqa", "rhirq", "rxirisquest", "rdirtw", "rxirw", "rxdrw", "rxirisqs", "rxrinqs", "rxirc", "rdirtque", "rxrinquest", "rxdrquest", "rxirk", "rxirtc", "rxirtk", "rxdrqu", "rxirque", "rxirtw", "rhdrquest", "rdirc", "rxrinqa", "rxirqa", "rxdrq", "rhirquest", "rxierque", "rdirq", "rxirisq", "rpmirque", "rhirqs", "rdirw", "rpmirtque", "rxirtq", "rxirtque", "rpmirk", "rxirqu", "rxidq", "rxirquest", "rpmirqu", "rxrinq", "rhdrq", "rdirque", "rxirqs", "rpmirtqu", "rpmirtq", "rxdrc", "rxierc", "rxidqu", "rxierw", "rxdrk", "rxirisqa", "rhdrqs", "rxidque", "rxierq", "rxirtqu", "rxdrqa", "rpmirtk", "rxdrque", "rdirtq", "rdirtc", "rxidk", "rpmirq", "rhdrqa"], "dma": ["dhwa", "ndwa", " dme", "ndmas", "dmas", "dwa", " dwa", "pga", "dtmma", " dmma", " dga", "dhpa", "dmma", "ndma", "xdma", "dhma", " dpa", "xdme", "pma", "ndpa", "pmas", "fma", "dtga", "dga", "dpa", "dtmas", "fmma", "dtma", "fmas", "dme", "pme", "xdga", "xdmas", " dmas", "dhmas", "fga"], "clk": ["mlw", "plK", "clks", "plks", "mlk", "plk", " clw", " clks", "clw", "mlks", "plw", "mlK", "clK", " clK"], "s": ["js", "b", "in", "S", "rs", "ssl", "sb", "fs", "g", "states", "ing", "new", " is", "p", "args", "u", "sets", "si", "sync", "sq", "a", "x", "ures", "n", "qs", " values", "secondary", "conf", "gs", "es", "l", "service", "cs", "t", "izes", "su", "e", "c", "ches", "ss", "spec", " parts", "o", "stats", "site", "its", "status", "z", "self", "or", "session", "ts", "is", "y", "null", "m", "sym", "w", "side", "sg", "f", "ds", "ses", "sys", " returns", "sl", "ions", "os", "ows", "r", "ps", " shares", " args", "v", "ves", "south", "ns", "settings", "d", "i", "ls", "services"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[subblock_no];\n\n    int c_off = part_sizes_w[block_type];\n\n\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n\n    if(subblock_no == 3)\n\n        c_off = -1;\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n", "idx": 27317, "substitutes": {"r": ["x", "b", "ra", "sr", "n", "rf", "err", "self", "rs", "er", "ir", "nor", "rb", "g", "result", "dr", "br", "l", "v", "h", "rg", "tr", "mr", "R", "p", "m", "fr", "rss", "rh", "t", "w", "rc", "ar", "ur", "k", "rt", "this", "e", "c", "d", "kr", "f", "hr", "ru", "rr", "pr", "re", "as"], "block_type": ["blockworktype", "block_key", "blockingtype", "block_lock", "block_name", " block_lock", "blockworklock", "block_number", "blockworkname", "blockworkkey", " block_pos", "block_no", "blockingname", "blockingkey", " block_no", " block_key", "blockinglock", " block_number", " block_name", "block_pos"], "subblock_no": ["subblock_nr", "subblock2num", "subblock1No", "subblock2No", "subblockIDbo", "subblock2nos", "subblock_po", "subblock2number", "subBlock_nr", "subBlock_No", "subblock_code", "subblock1num", "subblock1number", "subblockIDnu", "subblock2nr", "subblock_No", "subblock1nr", "subblockIDpos", "subblock2no", "subblock_bo", "subBlock_no", "subBlock_po", "subBlock_nu", "subblock1nos", "subblock_nu", "subblock_num", "subBlock_number", "subblock1no", "subblock_nos", "subblockIDno", "subblock2pos", "subBlock_num", "subblock_number", "subBlock_bo", "subBlock_pos", "subBlock_nos", "subblock_pos", "subBlock_code", "subblock2po", "subblock1pos"], "dmv_no": ["dmv_nos", "dmf_number", "dmv2no", "dmf_no", "dmv2from", "dmf2no", "dmvdfrom", "dmvblocknumber", "dmvblockno", "dmvdnumber", "dmvblockfrom", "dmf_from", "dmv_number", "dmv2number", "dmf2number", "dmvblocknos", "dmvdnos", "dmf2from", "dmv_from", "dmf_nos", "dmv2nos", "dmf2nos", "dmvdno"], "s": ["js", "b", "in", "sc", "S", "rs", "sb", "ssl", "fs", "g", "h", "p", "u", "lines", "si", "sync", "sq", "a", "x", "native", "n", "conf", "gs", "er", "es", "l", "share", "service", "t", "su", "e", "c", "sports", "ss", "sim", "spec", "o", "client", "opt", "stats", "site", "sf", "self", "current", "session", "ts", "sy", "is", "y", "m", "sym", "w", "side", "sg", "f", "ds", "server", "ses", "sys", "sl", "http", "os", "storage", "v", "multi", "one", "south", "ns", "setup", "settings", "an", "d", "ls", "services", "us", "se"], "A": ["AB", "E", "AV", "V", "API", "Ar", "Y", "a", "AT", "Am", "D", "AC", "At", "AS", "MA", "S", "N", "Alpha", "As", "AU", "Va", "W", "X", "An", "AM", "IA", "This", "GA", "Ab", "Array", "L", "G", "CA", "U", "None", "M", "F", "I", "P", "AR", "NA", "AW", "All", "And", "AP", "AD", "SA", "AF", "H", "File", "T", "mA", "LA", "AA", "Ca"], "B": ["b", "AB", "E", "V", "Q", "Y", "OB", "Bs", "D", "Bar", "TB", "S", "N", "NB", "W", "PB", "X", "Both", "Block", "WB", "L", "G", "BR", "MB", "BE", "U", "M", "R", "GB", "K", "Z", "O", "F", "I", "P", "Base", "BG", "IB", "VB", "LB", "BS", "UB", "QB", "BF", "BA", "AP", "SB", "H", "T", "EB", "BB", "J", "DB"], "C": ["E", "Cons", "V", "Q", "CW", "Y", "Code", "D", "AC", "CNN", "S", "N", "CE", "Sc", "KC", "Cu", "Con", "CP", "W", "X", "Config", "CS", "GC", "EC", "Ch", "Cl", "L", "G", "CA", "U", "CL", "M", "R", "O", "F", "CI", "P", "CT", "MC", "YC", "VC", "c", "DC", "CC", "Cache", "CV", "T", "CN", "CU", "Ca"], "i": ["x", "b", "ai", "index", "li", "pi", "n", "z", "iu", "ip", "y", "h", "p", "m", "I", "it", "ii", "k", "si", "e", "c", "d", "f", "phi", "ci", "mi"], "j": ["kj", "b", "x", "n", "aj", "z", "g", "l", "y", "v", "h", "ij", "p", "m", "w", "ii", "je", "jp", "k", "q", "mm", "pos", "o", "em", "ji", "J"], "mx": ["rx", "mn", " mc", "me", " m", "px", "max", "mu", "hh", "wx", "xp", "ma", "ij", "cl", "nz", "m", "ap", "avier", "cm", "ms", "jp", "ng", "mm", "ml", " mm", "nm", "ga", "mi"], "my": ["mic", "mon", "mid", "me", "mn", "th", "micro", "yo", "mis", "hh", "MY", "mo", "hz", "nz", "mos", "sym", "md", "ms", "mmm", "ng", "MM", "mm", "am", "nm", "pm", "Mi", "My"]}}
