{"project": "FFmpeg", "commit_id": "08a747afb98c11da48b89339c2f1c5fdc56ced7e", "target": 0, "func": "static void count_frame_bits_fixed(AC3EncodeContext *s)\n\n{\n\n    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };\n\n    int blk;\n\n    int frame_bits;\n\n\n\n    /* assumptions:\n\n     *   no dynamic range codes\n\n     *   bit allocation parameters do not change between blocks\n\n     *   no delta bit allocation\n\n     *   no skipped data\n\n     *   no auxilliary data\n\n     *   no E-AC-3 metadata\n\n     */\n\n\n\n    /* header */\n\n    frame_bits = 16; /* sync info */\n\n    if (s->eac3) {\n\n        /* bitstream info header */\n\n        frame_bits += 35;\n\n        frame_bits += 1 + 1 + 1;\n\n        /* audio frame header */\n\n        frame_bits += 2;\n\n        frame_bits += 10;\n\n        /* exponent strategy */\n\n        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)\n\n            frame_bits += 2 * s->fbw_channels + s->lfe_on;\n\n        /* converter exponent strategy */\n\n        frame_bits += s->fbw_channels * 5;\n\n        /* snr offsets */\n\n        frame_bits += 10;\n\n        /* block start info */\n\n        frame_bits++;\n\n    } else {\n\n        frame_bits += 49;\n\n        frame_bits += frame_bits_inc[s->channel_mode];\n\n    }\n\n\n\n    /* audio blocks */\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        if (!s->eac3) {\n\n            /* block switch flags */\n\n            frame_bits += s->fbw_channels;\n\n\n\n            /* dither flags */\n\n            frame_bits += s->fbw_channels;\n\n        }\n\n\n\n        /* dynamic range */\n\n        frame_bits++;\n\n\n\n        /* spectral extension */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* exponent strategy */\n\n            frame_bits += 2 * s->fbw_channels;\n\n            if (s->lfe_on)\n\n                frame_bits++;\n\n\n\n            /* bit allocation params */\n\n            frame_bits++;\n\n            if (!blk)\n\n                frame_bits += 2 + 2 + 2 + 2 + 3;\n\n        }\n\n\n\n        /* converter snr offset */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* delta bit allocation */\n\n            frame_bits++;\n\n\n\n            /* skipped data */\n\n            frame_bits++;\n\n        }\n\n    }\n\n\n\n    /* auxiliary data */\n\n    frame_bits++;\n\n\n\n    /* CRC */\n\n    frame_bits += 1 + 16;\n\n\n\n    s->frame_bits_fixed = frame_bits;\n\n}\n", "idx": 8181, "substitutes": {"s": ["changes", "sb", "ses", "ls", "aws", "comm", "sv", "as", "sam", "js", "sys", "c", "t", "series", "state", "se", "ms", "w", "ins", "ns", "less", "h", "ats", "sw", "qs", "ps", "http", "parts", "sq", "a", "set", "sg", "stats", "ds", "vs", "cs", "ims", "p", "i", "its", "l", "ops", "b", "is", "g", "eps", "os", "y", "hs", "e", "sql", "r", "ts", "self", "rs", "v", "args", "ss", "z", "als", "es", "gs", "sts", "n", "details", "bs", "m", "S", "spec", "sports"], "frame_bits_inc": ["frame_bytes_INC", "frame_bits_inf", "frame_bits_INC", "frame_bits_ins", "frame_bit_inc", "frame_bit_ins", "frame_bytes_inf", "frame_bytes_enc", "frame_bits_enc", "frame_bit_INC", "frame_bit_enc", "frame_bytes_inc"], "blk": ["blkw", "jluk", "blkid", "trk", "Blks", "btk", "belak", "Blak", " blak", "blmk", "arrk", "bltk", "lockmk", " blck", "lbkid", "iblck", " bltk", "djmk", "blck", "blogker", " brark", "abelark", "Blk", " blkw", "BLkw", "BLk", "lockkg", " blijk", "btko", "blks", "blker", " blkid", "blogk", " blko", "abelkid", "lockck", "lockuk", " blark", "blark", "lockk", "lockak", " brkid", "blogkg", "arrkg", "blijk", "abelk", "jlk", "abelkg", "arrker", "iblk", "blogkr", "lbak", "iblijk", "bluk", "replak", "replk", " brkg", "locktk", " blks", "djuk", "replko", "djk", "belk", "Blkw", "lbck", "BLck", "lbk", "jlkg", "jlmk", "btck", "Blck", "BLks", "trker", "blkr", "Blkid", "trkg", " brk", "bttk", "iblko", "arrkr", "blkg", " blkg", "btak", "blak", "btijk", "trkr", "belko", "blko", "djkg"], "frame_bits": ["frame_ints", "versionletnets", "frame_fits", "frame_its", " frame_bs", " frame_tests", "component64its", "frame___pins", "component_rates", "frame___nets", "Frame_stats", "request_sets", "version_bits", "version_nets", "frame___bits", "queue___its", "frameThefixes", "frame__its", "frame7bit", "frameThebits", "queue_bits", " frame_its", "frameThreadbits", "frame___stats", " frame2bits", "frame24plugins", "frame00sets", "frame64vals", "frameThelocks", "point_jobs", "frame_sets", "Frame_bits", "zone_weights", "frameThreaddetails", "fake_devices", "frame64stats", "frameTimedetails", "Frame_its", " frame_notes", "frame__bits", "request00outs", "frame_bs", "frameTimestats", "frameerbugs", "frame__jobs", "queue_files", "frame_bis", " frame_outs", "versionletits", "frame64sets", "frame_devices", " frame_words", "frame64bits", "component_bits", "queue_plugins", "frame____bits", "frame64its", "point_notes", "request_outs", "frame____pins", "queue24bits", "frame_notes", "frame_tags", "frame_locks", "frame_pins", " frame_pins", "request00stats", "frame_fixes", " frame_ids", "frame_ids", " frame_plugins", "frame_rates", "frame2bits", " frame_values", "component64rates", "request00bits", "frameTimetools", "zone_ints", "frame__bit", "version_rates", "frame_values", "Frame_fits", " frame_abilities", "request_stats", "frameThreadits", "frame____tools", " frame_bit", "frameletnets", "queue_nets", "component_pieces", "component64pieces", "frame_outs", "queue24files", "frame_bugs", "frame64jobs", "fake_bits", "fake_its", "frame_weights", "frame64outs", "frame___outs", "frame2devices", "frame2vals", "component64bits", " frame2vals", "queue_vals", " frame_locks", "frame_tests", "queue___nets", "frame_pieces", "frameerbits", "request00sets", "version_its", " frame_tools", " frame2stats", " frame_fixes", "frameThreadtags", "frame_abilities", "frameerits", "frame7nets", "frame7outs", "frame67its", "frame_vals", "frame67bits", "frame____its", "frame_ads", "frame_bit", "frame___its", "frame_nets", "frame___fits", "frame24vals", " frame_stats", "frame64rates", "point_bits", "versionletrates", "frame2its", "zone_abilities", "frameTimebits", "frameletrates", "frame24bits", "frame64bit", " frame_jobs", "point_bit", "versionletbits", "frame2stats", " frame_keys", "frame64nets", "frame_jobs", "zone_bits", "queue24vals", " frame2its", "frame__ads", "request_bits", "queue_its", " frame_ads", "frame67rates", "frame_keys", " frame_details", "frameletits", "frame7bits", "queue24plugins", "frame_files", "frame___tests", "frame64notes", "frame_details", "frame00bits", "component_its", "frameletbits", "frame_plugins", " frame_tags", " frame_bugs", " frame_vals", "queue___bits", "frame00outs", "frame64ads", "frameerplugins", "frame_stats", "frameTheits", "frame00stats", "frame7bis", " frame_bis", " frame_nets", "frame7values", "frame__notes", "frame64pieces", "frame24files", "frame_words", "frame_tools", "fake_stats", "frame67pieces"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 8197, "substitutes": {"pix": ["cpct", " px", "pIX", "pixel", "px", "vpixel", "Pct", "npixel", "pct", "vpix", "cpx", "vpx", "npixels", "Pixels", "PIX", "npIX", "npx", " pct", "vpIX", " pixels", "pixels", "Pix", " pixel", "npix", "cpIX", "cpix", "cpixels", " pIX", "Px"], "stride": ["strend", "strine", "glope", " strite", "stine", "strider", " strider", " strend", "Strite", "divime", "scheider", "strride", "strope", "scheide", "strade", "Strider", "stope", "glide", "divide", "Strade", "strime", " strride", "scheite", "stide", " strope", " strade", "Stride", " strime", " strine", "strite", "scheade", "glride", "stime", "stade", "glade", "divend", "divine", "stend"], "bS": ["bbNS", "bUS", "bSS", "sbV", "nbINS", "bINS", "bV", "fbS", "bJS", " bUS", "bP", "ibP", " bFS", "nbJS", " bJS", " bVS", " bA", "bgS", "cbSS", "bSeries", "sbS", "cbS", " bNS", "fbSeries", "sbA", "bFS", "bbV", "bbSS", "bbFS", "sbBS", "bVS", "bbA", "nbVS", "nbR", "bN", "bNS", " bP", "bbN", "ibSeries", "bR", "bbS", " bN", " bV", "nbS", "baJS", "bBS", "ibUS", "bbP", " bBS", " bINS", "baN", "bgR", "bgINS", "bbBS", "cbP", "baS", "baNS", "nbFS", "bbJS", "bbR", " bSeries", " bSS", "bA", "fbUS", "bgVS", "fbP", " bR", "ibS"], "qp": [" qpad", "QP", "qqpc", " qpc", "qup", "Qpad", " qP", "qupa", "iqnp", "qpc", "qwp", "qqp", "quwp", "reqwp", "iqpc", "Qpa", "qP", " qpa", "qnp", "qqpad", "qpad", "reqnp", "qqP", "qupc", "Qp", "qpa", "quP", "reqp", "iqp", "reqpc", "iqwp", "qunp", "Qpc"], "h": ["p", "hp", "v", "ih", "pp", "hm", "sh", "rh", "l", "hd", "comm", "hz", "th", "http", "host", "n", "H", "help", "bh", "a", "b", "g", "oh", "history", "ht", "he", "s", "kh", "handle", "ah", "ch", "cache", "ph", "dh", "hl", "hh", "q", "hash", "ctx", "hs", "it", "m", "c", "t", "hal", "e", "k", "hw", "php", "w"], "tc": ["ui", "tic", "ts", "dc", "cus", "cf", "cm", "ic", "pb", "fc", "fee", "bc", "tt", "uc", "lc", "cu", "unc", "cc", "rc", "cv", "ctl", "uca", "cas", "temp", "tif", " TC", "cca", "tmp", "td", "tu", "tim", "ec", "cache", "etc", "TC", "times", "LC", "asc", "tx", "css", "tf", "toc", "currency", "ctx", "aco", "mc", "c", "ci", "ctrl", "https", "cot", "t", "sc", "ta", "oc", "cs", "pc", "gc", "ctr", "cci", "icc"]}}
{"project": "FFmpeg", "commit_id": "ac66834c759b7130fb5be51f63cb6dff9b294cba", "target": 0, "func": "int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,\n\n                         int *frame_size_ptr,\n\n                         uint8_t *buf, int buf_size)\n\n{\n\n    int ret;\n\n\n\n    *frame_size_ptr= 0;\n\n    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){\n\n        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,\n\n                                buf, buf_size);\n\n        avctx->frame_number++;\n\n    }else\n\n        ret= 0;\n\n    return ret;\n\n}\n", "idx": 8199, "substitutes": {"avctx": ["wavctx", "afgc", "wavtx", "avego", "cvctx", "cvconn", " avconn", "avtx", "afsys", "afctx", "Avpkg", "wavcv", "AVgc", "evpkg", "avesys", "devreq", "AVcontext", "avecv", " avcv", "Avctx", "avecontext", "cvcontext", " avcontext", "wavcontext", " avgo", "avsys", "evreq", "avgc", "devpkg", "devcontext", "evctx", "Avconn", "AVctx", "avcv", "avegc", "cvpkg", "avgo", "afgo", "Avcontext", "avetx", "avpkg", "aftx", " avtx", "afcontext", "avreq", "avcontext", "evcontext", "avectx", "devctx", " avsys", " avreq", "avconn", "AVtx", " avpkg"], "samples": ["camples", "ssamples", " sources", "cources", "jsamples", "damps", "camps", "jsamps", "ssamps", "samps", "sample", "cample", "jsample", "ssample", "sources", "ssources", "dources", "dample", "damples", "jsources", " sample", " samps"], "frame_size_ptr": ["frame_name_ptr", "frame_size_ref", "frame_name_pointer", "frame_Size_tr", "frame_name_obj", "frame_sizemmptr", "frame_sizemmaddr", "frame_size_addr", "frame_size_map", "frame_Size_ref", "frame_size_pointer", "frame_size_obj", "frame_Size_pointer", "frame_name_addr", "frame_name_tr", "frame_Size_ptr", "frame_sizemmmap", "frame_size_tr", "frame_sizemmpointer", "frame_name_map"], "buf": ["p", "func", "cb", "bf", "np", "proc", "cap", "wav", "pb", "data", "cur", "bc", "uf", "map", "good", "fb", "raw", "cv", "bar", "bound", "buff", "b", "bytes", "mk", "etc", "arr", "queue", "box", "br", "wb", "vec", "buffer", "db", "rb", "block", "msg", "mu", "doc", "orig", "bs", "img", "cmd"], "buf_size": ["buf_len", "buf_count", "buf_number", "queue_len", "buf1ize", "buf_length", "uf_length", "box_number", "uf_size", "box1size", "uf_count", "buf1index", "buf_Size", "box_index", "box1ize", "buf1size", "queue_size", "box1number", "box1index", "uf_Size", "box_size", "buf1number", "buf_ize", "box_ize", "queue_length", "buf_index"], "ret": ["r", "att", "pret", "flag", "RET", "final", "ft", "red", "cat", "rev", "err", "repl", "cont", "xt", "re", "result", "gt", "Ret", "val", "ert", "reply", "rem", "rm", "after", "out", "nt", "rets", "iter", "back", "print", "mt", "virtual", " alt", "def", "tr", "ext", "desc", "elt", "rt", "reset", "ort", "t", "et", "len", "res", "cert", "ll", "resp", "det", "alt", "ctr", "ptr", "ter", "cmd"], "frame_number": ["frames_span", "frame_volume", "frame_span", "frames_number", "frames_num", "frame_num", "frames_volume"]}}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n\n                    int mb_x, int mb_y, int layout)\n\n{\n\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n\n                                  mb - 1 /* left */,\n\n                                  0      /* top-left */ };\n\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n\n    int idx = CNT_ZERO;\n\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n\n    int8_t *sign_bias = s->sign_bias;\n\n    VP56mv near_mv[4];\n\n    uint8_t cnt[4] = { 0 };\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n\n        mb_edge[0] = mb + 2;\n\n        mb_edge[2] = mb + 1;\n\n    } else {\n\n        mb_edge[0] = mb - s->mb_width - 1;\n\n        mb_edge[2] = mb - s->mb_width - 2;\n\n    }\n\n\n\n    AV_ZERO32(&near_mv[0]);\n\n    AV_ZERO32(&near_mv[1]);\n\n    AV_ZERO32(&near_mv[2]);\n\n\n\n    /* Process MB on top, left and top-left */\n\n#define MV_EDGE_CHECK(n)                                                      \\\n\n    {                                                                         \\\n\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n\n        int edge_ref = edge->ref_frame;                                       \\\n\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n\n            if (mv) {                                                         \\\n\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n\n                    /* SWAR negate of the values in mv. */                    \\\n\n                    mv = ~mv;                                                 \\\n\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n\n                }                                                             \\\n\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n\n                cnt[idx] += 1 + (n != 2);                                     \\\n\n            } else                                                            \\\n\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n\n        }                                                                     \\\n\n    }\n\n\n\n    MV_EDGE_CHECK(0)\n\n    MV_EDGE_CHECK(1)\n\n    MV_EDGE_CHECK(2)\n\n\n\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n\n        mb->mode = VP8_MVMODE_MV;\n\n\n\n        /* If we have three distinct MVs, merge first and last if they're the same */\n\n        if (cnt[CNT_SPLITMV] &&\n\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n\n            cnt[CNT_NEAREST] += 1;\n\n\n\n        /* Swap near and nearest if necessary */\n\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n\n        }\n\n\n\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n", "idx": 8208, "substitutes": {"s": ["r", "ts", "p", "less", "self", "h", "sb", "conf", "ses", "rs", "i", "v", "f", "ss", "its", "es", "z", "l", "ps", "gs", "sts", "space", "n", "sq", "sm", "fs", "sv", "sl", "b", "is", "g", "as", "a", "app", "sym", "bs", "ins", "os", "sac", "sg", "js", "sys", "scl", "hs", "ds", "m", "S", "t", "spec", "asm", "e", "ims", "ms", "w", "ns"], "mb": ["mm", "GB", "nob", "bf", "sb", "fps", "ab", "ma", "um", "mem", "orb", "mg", "pb", "mph", "emb", "ob", "gov", "meta", "mac", "vm", "bb", "arb", "sbm", "org", "ml", "ib", " MB", "img", "sm", "nm", "bound", "md", "b", "fm", "orm", "mt", "kb", "gm", "gb", "ref", "mount", "ym", "umb", "mc", "m", "mp", "ghost", "mx", "db", "rb", "mop", "memory", "ram", "lb", "ms", "MB", "bm", "mn", "conv", "cmd"], "mb_x": ["emb_y", "mb_rx", "emb_rx", "emb_z", "mb_z", "emb_x"], "mb_y": ["mb_w", "MB_w", "MB_x", "MB_top", "MB_y", "mb11top", "mb11x", "mb11y", "mb_top", "mb11w"], "layout": ["hidden", "sync", "update", "lay", "np", "slot", "center", "location", "height", "l", "padding", "layer", "position", "scroll", "lc", "parent", "label", "config", "margin", "loop", "Layout", "border", "unknown", "shape", "display", "style", "mount", "offset", "math", "draw", "background", "buffer", "block", "mask", "base", "normal", "mode", "gc"], "mb_edge": ["mb_element", "mb___element", "mp_face", "mb_ge", "mb___edge", "mb_connect", "ambJedge", "mb0entity", "amb_se", "mt_element", "mb__edge", "ib_connect", "mb___ee", "mb8element", "mb__ge", "mb0ende", "amb0se", "mbJsource", "mb__face", "mb___entity", "mb__link", "amb0ende", "amb_entity", "mt_ee", "amb_edge", "mb_ee", "mb8see", "mb8edge", "mb_entity", "mb_see", "mbJconn", "mp_link", "ambJextra", "mb0edge", "mb_face", "mb___see", "amb_conn", "mp_ge", "mb_se", "mb0se", "ib_ee", "mb_extra", "mb8ee", "mb_ende", "amb0entity", "mb_link", "ib_ge", "mt_edge", "mb___ende", "mp_edge", "mb___se", "ambJconn", "amb0edge", "ib_edge", "ambJsource", "mt_see", "amb_extra", "mb_conn", "mb_source", "mbJextra", "amb_source", "amb_ende", "mbJedge"], "sign_bias": ["sign_labaid", "sign___rbuster", "sign___bali", "sign_rbuster", "sign_gali", "sign_embuster", "sign_broom", "sign_labius", "sign_rbali", "sign_loom", "sign_bgases", "sign_labias", "sign___rbases", "sign_brases", "sign_gaid", "sign_bius", "sign___rbali", "sign_vaid", "sign_gases", "sign_embias", "sign_gias", "sign_bgias", "sign_lis", "sign_bases", "sign_brias", "sign_boom", "sign_bali", "sign_lias", "sign___buster", "sign_buster", "sign_lases", "sign_bgoom", "sign_vases", "sign_rbias", "sign_embases", "sign_gius", "sign_embali", "sign_bgis", "sign_labases", "sign___rbias", "sign_vias", "sign_baid", "sign_guster", "sign_rbases", "sign_bis", "sign___bias", "sign___bases", "sign_vius", "sign_bris"], "near_mv": ["nearingmms", "near______fmim", "near_vmim", "near_rmv", "near_mm", "near_mdvr", "near_mmval", "near_mq", "near______mv", "near_metq", "near_pv", "near______mpi", "near_mim", "near_nmtv", "near_mtm", "near_Mw", "near______fmval", "near_metval", "near_mtms", "near2pw", "near_nmv", "near_nmms", "nearablemval", "near______mval", "nearablemetq", "near_mttv", "nearablemvr", "near2pvs", "near_mvs", "nearingmv", "near_Mq", "nearingmtm", "near_rmw", "near______mim", "near_mtv", "near_nmm", "near_fmpi", "nearingmtms", "near_mw", "near_vmv", "nearablemetv", "near_mval", "near_mmpi", "near_mdq", "near_mdv", "near_metvr", "near_mms", "nearablemetval", "near2pv", "near_mims", "near2mv", "near_mpi", "near_fmim", "near_Mv", "near_pvs", "nearingmttv", "near______fmpi", "near_Mvr", "near_fmval", "near_Mval", "nearablemq", "near_vmval", "near_vmpi", "near_rmvs", "nearablemv", "near_mmv", "near_miv", "near_mvr", "near_mmim", "near______fmv", "near2mw", "near_mdval", "near_mitv", "near_metv", "nearablemetvr", "near_fmv", "nearingmm", "near_pw", "nearingmtv", "near_Mvs", "near2mvs"], "cnt": ["Cnt", "pcnt", "CNT", "npt", "nn", "pcNT", "nNT", "pcpt", "cNT", "nnt", "Cpt", "cpt", "pcn", "Cn", "cn"], "c": ["r", "p", "dc", "h", "co", "C", "tc", "f", "v", "cm", "fc", "bc", "l", "ct", "cl", "lc", "cc", "u", "n", "cv", "cp", "a", "g", "b", "cache", "ch", "ec", "ca", "ctx", "mc", "m", "t", "sc", "xc", "cs", "pc", "e", "w", "ac"]}}
{"project": "qemu", "commit_id": "29851ee7c8bd3fb8542e21cd0270c73132590350", "target": 1, "func": "int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n", "idx": 8209, "substitutes": {"rd": ["r", "ld", "rod", "dr", "nd", "hr", "nder", "ard", "rs", "rr", "dd", "ri", "vr", "rh", "rf", "cd", "fr", "lr", "ran", "rob", "rect", "rm", "rc", "sr", "ru", "rl", "td", "d", "fd", "ro", "dra", "rar", "adr", "rn", "rx", "db", "rb", "rw", "RD", "rid", "erd"], "rt": ["r", "art", "ot", "pr", "RT", "dr", "hr", "rs", "rr", "ret", "ri", "vr", "tp", "rec", "rf", "pt", "fr", "tt", "dt", "rc", "sr", "rm", "nt", "mt", "tr", "ro", "irt", "tx", "reg", "adr", "rn", "rx", "txt", "t", "res", "rb", "rid", "ptr"], "dsp": ["ddsw", " dSp", "ddspe", "sdisp", "ddSP", "nsp", "dnSP", "disp", "sdSP", "fdsp", "dspe", "fdsw", "DSP", " dSP", " dwp", "dosp", "dsw", "sdsp", "ddosp", "dnwp", "Disp", "Dspe", "nSp", "dwp", "dnSp", "Dsw", " dspe", " disp", "nisp", "ddsp", "dSP", "Dosp", "dSp", "Dwp", "sdSp", "DSp", "ddSp", "Dsp", "dnsp", "fdosp"], "result": ["r", "report", "pr", "np", "final", "red", "su", "err", "ret", "success", "test", "sp", "number", "vr", "rf", "Result", "fr", "lr", "other", "new", "root", "rc", "total", "complete", "ful", "d", "relation", "match", "tr", "def", "term", "br", "rn", "res", "db", "status", "table", "valid", "message", "description", "results", "ter", "error"], "resultdsp": [" resultlsh", "resultdSp", "Resultdsp", " resultdsh", " resultdisp", "resultlSp", "Resultdop", " resultDisp", "resultdp", "resultpip", "resultdip", "resultpSp", "resultDip", " resultlp", " resultdp", " resultdsw", "resultpisp", "resultpop", "resultdsh", " resultlsp", "resultDsp", " resultDsw", " resultlSp", "resultnsw", "ResultdSp", "resultlsp", "resultDSp", "resultnisp", "resultDsw", "resultDop", "resultpsw", "resultDisp", "resultdisp", " resultdSp", "Resultdip", "resultlsh", "resultdsSp", "resultdssh", "resultnsp", " resultDSp", "resultlp", "resultdop", "resultpsp", "resultdsw", " resultDsp", "resultnSp", "resultdssp"]}}
{"project": "FFmpeg", "commit_id": "eb24fd64589b7eea91fa752861f0c6f07e5a48a8", "target": 0, "func": "int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n\n{\n\n    int count, x;\n\n    uint8_t *out;\n\n\n\n    out = outbuf;\n\n\n\n\n\n        for(x = 0; x < w; x += count) {\n\n            /* see if we can encode the next set of pixels with RLE */\n\n            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n\n                if(out + bpp + 1 > outbuf + out_size) return -1;\n\n                *out++ = (count ^ xor) + add;\n\n                memcpy(out, ptr, bpp);\n\n                out += bpp;\n\n            } else {\n\n                /* fall back on uncompressed */\n\n                count = count_pixels(ptr, w-x, bpp, 0);\n\n                *out++ = count - 1;\n\n\n\n                if(out + bpp*count > outbuf + out_size) return -1;\n\n                memcpy(out, ptr, bpp * count);\n\n                out += bpp * count;\n\n        }\n\n\n\n        ptr += count * bpp;\n\n    }\n\n\n\n    return out - outbuf;\n\n}\n", "idx": 8211, "substitutes": {"outbuf": ["OUTbuf", "inbar", "inqueue", "outBuffer", " outbuff", "outputbuffer", "inBuffer", "outdb", "outputqueue", "Outbuff", "savefb", "outputBuffer", "outputdb", "savebuf", "inbuff", " outqueue", " outBuffer", "Outcap", " outbar", "outcap", " outfb", "outputbuf", "outbuffer", "OUTBuffer", "outbar", " outcap", "outqueue", "savedb", "Outqueue", "OUTbuffer", "outputbar", "outputfb", "Outbuf", "inbuffer", "outfb", "inbuf", "outbuff", "savequeue", "incap", " outbuffer", " outdb", "Outbuffer"], "out_size": ["result_Size", "out_Size", " out_SIZE", "out8width", "outabletype", "result_width", "resultabletype", "out_width", "resultptwidth", "outjtype", "out_SIZE", " out_Size", "resultableSize", "resultptsize", "outptwidth", "result_size", "out8size", "outableSize", "outpttoo", "result_type", "out_type", "outjtoo", "resultablesize", "resultpttoo", "out8too", "resultableheight", "outjwidth", "result_height", "outptsize", "outpttype", "out_height", "outjsize", "out_too", "outablesize", "resultpttype", "outableheight", "out8type", "result_too"], "ptr": ["r", "ts", "p", "pr", "pointers", "dr", "np", "proc", "coord", "pre", "addr", "alloc", "xt", "sp", "vr", "tp", "ind", "pad", "pt", "ps", "fr", "start", "deg", "ix", "shift", "rect", "th", "inters", "iter", "pointer", "src", "Ptr", "mt", "index", "expr", "dh", "handle", "tr", "copy", "iv", "arr", "desc", "tx", "rt", "ref", "sys", "offset", "ctx", "fp", "inter", "br", "adr", "req", "pos", "buffer", "per", "point", "prime", "pc", "ctr", "hw", "address", "rel", "cmd"], "bpp": ["blff", "bgphp", "bbph", " bff", " bPP", " bpps", "dbphp", "bbphp", " bpped", " bpg", "sbpps", "bbipp", "bcc", " bgp", "mbps", " bphp", "bbps", "bgpper", "bppe", "bph", " bppe", "zPP", "sbph", "mbpp", "dbps", "bgppe", "bpps", "bPP", "zppe", "bbmm", "bbcc", "blpg", "blphp", " bppy", " bpl", "zpp", "blgp", "bbpl", "blppy", " bmm", "mbphp", "bbpp", "rbps", "bgp", "bbpo", "sbpp", "sbmm", "binpl", "bmm", "bpper", "bff", "bbfx", "bamp", " bph", "dbipp", " bpper", "sbcc", "bphp", "rbphp", "bbpps", "blpp", "bpo", " bcc", "dbpp", "bbamp", "bgfx", "bppy", " bpo", "bpl", "bipp", "bbppy", "bgpp", "sbpo", " bfx", "bbPP", "bps", "bgpped", "binPP", "zpper", "bpped", "bpg", " bps", "binphp", "bbpg", "sbpl", "bbgp", "bgpps", "sbamp", " bamp", "rbpp", "bbff", "mbipp", "binpp", "rbpped", "bfx", "bgps", "bgPP", "bgppy"], "w": ["r", "p", "wd", "h", "sw", "wp", "v", "wr", "z", "wi", "end", "W", "widget", "window", "wk", "n", "ew", "wx", " W", "wl", "b", "wm", "win", "wh", "iw", "y", "q", "wt", "wid", "m", "wb", "wa", "weight", "nw", "kw", "rw", "wind", "we", "aw", "hw", "wal"], "add": ["att", "extra", "update", "acc", "i", "Add", "ADD", "mult", "addr", "end", "pad", "start", "mix", "new", "ads", "ix", "inc", "create", "n", "make", "adder", "plus", "rad", "a", "diff", "d", "act", "ext", "q", "grow", "added", "adv", "append", "ract", "ad", "sum", "base", "alpha", "attach", "mod", "apply", "ac"], "xor": ["Xors", "ixor", " xOR", "xort", "ixOR", "xorst", "axors", " xors", "ixort", "XOR", "ixors", " xort", " xorst", "fxors", "fxOR", "Xor", "axorst", "fxor", "xOR", "Xorst", "axor", "axOR", "xors", "fxort"], "count": ["found", "wd", "flag", "err", "number", "ind", "total", "history", "index", "cache", "first", "force", "mount", "now", "find", "c", "t", "sum", "current", "len", "child", "cmd", "h", "conf", "comment", "cont", "test", "cd", "code", "all", "temp", "a", "core", "match", "ach", "info", "q", "hash", "max", "counter", "status", "p", "amount", "entry", "result", "only", "process", "nt", "size", "ount", "try", "each", "ctx", "weight", "con", "gc", "e", "ctr", "length", "att", "cycle", "list", "C", "v", "z", "ct", "call", "cond", "val", "Count", "cc", "n", "check", "num", "base", "message"], "x": ["p", "step", "X", "h", "dx", "xy", "px", "i", "f", "v", "xt", "z", "ind", "xf", "l", "xs", "ox", "xi", "j", "ix", "ey", "ex", "u", "xd", "n", "xp", "wx", "item", "ax", "el", "inx", "index", "y", "tx", "fx", "q", "lat", "lex", "ux", "rx", "c", "yx", "m", "t", "num", "mx", "batch", "xc", "e", "xml", "k", "xx"], "out": ["update", "no", "co", "end", "gt", "external", "over", "remote", "print", "index", "cache", "to", "go", "sys", "c", "io", "t", "sum", "batch", "up", "cmd", "ent", "on", "ret", "output", "name", "pt", "code", "new", "raw", "all", "obj", "a", "serv", "handle", "set", "it", "target", "res", "block", "port", "inner", "msg", "cn", "p", "off", "conn", "outs", "i", "soft", "ou", "result", "parent", "at", "ex", "nt", "o", "tmp", "server", "g", "b", "copy", "y", "user", "chain", "con", "can", "conv", "ac", "att", "ot", "list", "opt", "v", " Out", "ion", "in", "n", "pool", "net", "ch", "ext", "bit", "Out", "check", "unt", "point", "alt", "OUT", "client"]}}
{"project": "FFmpeg", "commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "target": 1, "func": "static int vdpau_frames_init(AVHWFramesContext *ctx)\n\n{\n\n    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;\n\n    VDPAUFramesContext        *priv = ctx->internal->priv;\n\n\n\n    int i;\n\n\n\n    switch (ctx->sw_format) {\n\n    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;\n\n    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;\n\n    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported data layout: %s\\n\",\n\n               av_get_pix_fmt_name(ctx->sw_format));\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {\n\n        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {\n\n            priv->chroma_idx  = i;\n\n            priv->pix_fmts    = device_priv->pix_fmts[i];\n\n            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];\n\n            break;\n\n        }\n\n    }\n\n    if (!priv->pix_fmts) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported chroma type: %d\\n\", priv->chroma_type);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (!ctx->pool) {\n\n        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,\n\n                                                            vdpau_pool_alloc, NULL);\n\n        if (!ctx->internal->pool_internal)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    priv->get_data = device_priv->get_data;\n\n    priv->put_data = device_priv->put_data;\n\n\n\n    return 0;\n\n}\n", "idx": 8217, "substitutes": {"ctx": ["wd", "co", "np", "tc", "cm", "cfg", "cam", "ind", "nc", "comm", "unc", "rc", "cp", "cas", "history", "sys", "iat", "kw", "loc", "xc", "pkg", "wcs", "ptr", "jp", "cmd", "conf", "addr", "tm", "abc", "cd", "cu", "org", "ctl", "obj", "act", "etc", "mk", "working", "tx", "desc", "aco", "mc", "ctrl", "req", "sc", "anc", "cpu", "msg", "ack", "p", "conn", "cf", "wp", "ck", "sp", "cur", "exec", "crit", "tk", "window", "xp", "nt", "tmp", "phys", "cmp", "gc", "pc", "ctr", "comp", "hw", "conv", "func", "cb", " cx", "alloc", "fc", "pg", "bc", "ct", "cz", "jac", "cc", "wx", "cv", "pool", "ce", "check", "kt", "nw", "resp", "context"], "device_priv": ["device_vt", "device_gen", "deviceptPriv", "device0riv", " device_vt", "device_auth", "device_caps", "resource_riv", "device2Priv", "device_pkg", "device_ptr", "deviceptadmin", "devicepyPriv", "devicepypub", "dev_private", " device_Priv", "resource_pkg", " device_pub", "device0ptr", "device2private", " device_admin", "device2priv", "devicepypriv", " device_auth", "dev_gen", "dev_priv", "device0priv", "device0pkg", "device_admin", "dev_Priv", "device_pub", "device_Priv", "device_riv", "devicepyvt", "deviceptpriv", "device_private", "resource_priv", "devicepyauth", "devicepycaps", "resource_ptr", " device_caps", "devicepyadmin", "deviceptcaps"], "priv": ["ev", "trust", "err", "cfg", "pub", "rc", "ib", "cp", "riv", "rest", "def", "urg", "Priv", "loc", "pkg", "ptr", "rel", "pri", "caps", "public", "conf", "prov", "mem", "attr", "private", "stat", "auth", "rep", "env", "org", "notice", "obj", "Pub", "serv", "cer", "expr", "info", "eas", "gr", "stats", "req", "decl", "aux", "conn", "deb", "cap", "perm", "exec", "pb", "prot", "rob", "Pri", "sec", "eps", "push", "cmp", "prop", "pi", "doc", "pol", "pro", "func", "dev", "pr", "proc", "rev", "alloc", " Priv", "por", "access", "debug", "policy", "admin", "prof", "soc", "rib", "adv", "resp", "lib"], "i": ["ui", "di", "p", " pi", "cli", "x", "span", "yi", "uri", " ti", "v", "gi", "ri", "ic", "ai", " ii", "iq", "ind", "ei", "ii", "j", " ki", "sim", "I", "xi", "phi", "ji", "ix", "iu", "oi", "key", "ex", "multi", "slice", "bi", "me", "in", "o", "n", "qi", "is", "g", "hi", "si", "index", "try", "li", "y", "ini", "q", "it", "\u0438", "ci", "m", "c", "io", "t", "ip", "mi", "zi", " j", "chain", "batch", "ti", "base", "im", "ij", "pi", "ki", "ims", " si"]}}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}", "idx": 8221, "substitutes": {"state": ["or", "list", "init", "next", "type", "request", "job", "rule", "json", "test", "data", "STATE", "stat", "name", "result", "call", "start", "code", "lock", "thread", "run", "policy", "out", "in", "config", "store", "size", "State", "event", "post", "resource", "zone", "st", "copy", "info", "local", "it", "states", "power", "this", "check", "t", "status", "port", "message", "spec", "show", "msg", "cmd"]}}
{"project": "FFmpeg", "commit_id": "801c39e1e3058fc4ba822bfb5d8612d777111e32", "target": 0, "func": "static int dca_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    AVFrame *frame     = data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    int lfe_samples;\n\n    int num_core_channels = 0;\n\n    int i, ret;\n\n    float  **samples_flt;\n\n    DCAContext *s = avctx->priv_data;\n\n    int channels, full_channels;\n\n    int core_ss_end;\n\n\n\n\n\n    s->xch_present = 0;\n\n\n\n    s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer,\n\n                                                  DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE);\n\n    if (s->dca_buffer_size == AVERROR_INVALIDDATA) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Not a valid DCA frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8);\n\n    if ((ret = dca_parse_frame_header(s)) < 0) {\n\n        //seems like the frame is corrupt, try with the next one\n\n        return ret;\n\n    }\n\n    //set AVCodec values with parsed data\n\n    avctx->sample_rate = s->sample_rate;\n\n    avctx->bit_rate    = s->bit_rate;\n\n\n\n    s->profile = FF_PROFILE_DTS;\n\n\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        if ((ret = dca_decode_block(s, 0, i))) {\n\n            av_log(avctx, AV_LOG_ERROR, \"error decoding block\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* record number of core channels incase less than max channels are requested */\n\n    num_core_channels = s->prim_channels;\n\n\n\n    if (s->ext_coding)\n\n        s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr];\n\n    else\n\n        s->core_ext_mask = 0;\n\n\n\n    core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8;\n\n\n\n    /* only scan for extensions if ext_descr was unknown or indicated a\n\n     * supported XCh extension */\n\n    if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) {\n\n\n\n        /* if ext_descr was unknown, clear s->core_ext_mask so that the\n\n         * extensions scan can fill it up */\n\n        s->core_ext_mask = FFMAX(s->core_ext_mask, 0);\n\n\n\n        /* extensions start at 32-bit boundaries into bitstream */\n\n        skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n\n\n        while (core_ss_end - get_bits_count(&s->gb) >= 32) {\n\n            uint32_t bits = get_bits_long(&s->gb, 32);\n\n\n\n            switch (bits) {\n\n            case 0x5a5a5a5a: {\n\n                int ext_amode, xch_fsize;\n\n\n\n                s->xch_base_channel = s->prim_channels;\n\n\n\n                /* validate sync word using XCHFSIZE field */\n\n                xch_fsize = show_bits(&s->gb, 10);\n\n                if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) &&\n\n                    (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1))\n\n                    continue;\n\n\n\n                /* skip length-to-end-of-frame field for the moment */\n\n                skip_bits(&s->gb, 10);\n\n\n\n                s->core_ext_mask |= DCA_EXT_XCH;\n\n\n\n                /* extension amode(number of channels in extension) should be 1 */\n\n                /* AFAIK XCh is not used for more channels */\n\n                if ((ext_amode = get_bits(&s->gb, 4)) != 1) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"XCh extension amode %d not\"\n\n                           \" supported!\\n\", ext_amode);\n\n                    continue;\n\n                }\n\n\n\n                /* much like core primary audio coding header */\n\n                dca_parse_audio_coding_header(s, s->xch_base_channel);\n\n\n\n                for (i = 0; i < (s->sample_blocks / 8); i++)\n\n                    if ((ret = dca_decode_block(s, s->xch_base_channel, i))) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error decoding XCh extension\\n\");\n\n                        continue;\n\n                    }\n\n\n\n                s->xch_present = 1;\n\n                break;\n\n            }\n\n            case 0x47004a03:\n\n                /* XXCh: extended channels */\n\n                /* usually found either in core or HD part in DTS-HD HRA streams,\n\n                 * but not in DTS-ES which contains XCh extensions instead */\n\n                s->core_ext_mask |= DCA_EXT_XXCH;\n\n                break;\n\n\n\n            case 0x1d95f262: {\n\n                int fsize96 = show_bits(&s->gb, 12) + 1;\n\n                if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96)\n\n                    continue;\n\n\n\n                av_log(avctx, AV_LOG_DEBUG, \"X96 extension found at %d bits\\n\",\n\n                       get_bits_count(&s->gb));\n\n                skip_bits(&s->gb, 12);\n\n                av_log(avctx, AV_LOG_DEBUG, \"FSIZE96 = %d bytes\\n\", fsize96);\n\n                av_log(avctx, AV_LOG_DEBUG, \"REVNO = %d\\n\", get_bits(&s->gb, 4));\n\n\n\n                s->core_ext_mask |= DCA_EXT_X96;\n\n                break;\n\n            }\n\n            }\n\n\n\n            skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n        }\n\n    } else {\n\n        /* no supported extensions, skip the rest of the core substream */\n\n        skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb));\n\n    }\n\n\n\n    if (s->core_ext_mask & DCA_EXT_X96)\n\n        s->profile = FF_PROFILE_DTS_96_24;\n\n    else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH))\n\n        s->profile = FF_PROFILE_DTS_ES;\n\n\n\n    /* check for ExSS (HD part) */\n\n    if (s->dca_buffer_size - s->frame_size > 32 &&\n\n        get_bits_long(&s->gb, 32) == DCA_HD_MARKER)\n\n        dca_exss_parse_header(s);\n\n\n\n    avctx->profile = s->profile;\n\n\n\n    full_channels = channels = s->prim_channels + !!s->lfe;\n\n\n\n    if (s->amode < 16) {\n\n        avctx->channel_layout = dca_core_channel_layout[s->amode];\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            /*\n\n             * Neither the core's auxiliary data nor our default tables contain\n\n             * downmix coefficients for the additional channel coded in the XCh\n\n             * extension, so when we're doing a Stereo downmix, don't decode it.\n\n             */\n\n            s->xch_disable = 1;\n\n        }\n\n\n\n#if FF_API_REQUEST_CHANNELS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        if (s->xch_present && !s->xch_disable &&\n\n            (!avctx->request_channels ||\n\n             avctx->request_channels > num_core_channels + !!s->lfe)) {\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#else\n\n        if (s->xch_present && !s->xch_disable) {\n\n#endif\n\n            avctx->channel_layout |= AV_CH_BACK_CENTER;\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode];\n\n            } else {\n\n                s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode];\n\n            }\n\n        } else {\n\n            channels = num_core_channels + !!s->lfe;\n\n            s->xch_present = 0; /* disable further xch processing */\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe[s->amode];\n\n            } else\n\n                s->channel_order_tab = dca_channel_reorder_nolfe[s->amode];\n\n        }\n\n\n\n        if (channels > !!s->lfe &&\n\n            s->channel_order_tab[channels - 1 - !!s->lfe] < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            channels = 2;\n\n            s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO;\n\n            avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n            /* Stereo downmix coefficients\n\n             *\n\n             * The decoder can only downmix to 2-channel, so we need to ensure\n\n             * embedded downmix coefficients are actually targeting 2-channel.\n\n             */\n\n            if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO ||\n\n                                    s->core_downmix_amode == DCA_STEREO_TOTAL)) {\n\n                int sign, code;\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][0] & 0x0FF;\n\n                    s->downmix_coef[i][0] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                    sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][1] & 0x0FF;\n\n                    s->downmix_coef[i][1] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                }\n\n                s->output = s->core_downmix_amode;\n\n            } else {\n\n                int am = s->amode & DCA_CHANNEL_MASK;\n\n                if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"Invalid channel mode %d\\n\", am);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                if (s->prim_channels + !!s->lfe >\n\n                    FF_ARRAY_ELEMS(dca_default_coeffs[0])) {\n\n                    avpriv_request_sample(s->avctx, \"Downmixing %d channels\",\n\n                                          s->prim_channels + !!s->lfe);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    s->downmix_coef[i][0] = dca_default_coeffs[am][i][0];\n\n                    s->downmix_coef[i][1] = dca_default_coeffs[am][i][1];\n\n                }\n\n            }\n\n            av_dlog(s->avctx, \"Stereo downmix coeffs:\\n\");\n\n            for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                av_dlog(s->avctx, \"L, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][0]);\n\n                av_dlog(s->avctx, \"R, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][1]);\n\n            }\n\n            av_dlog(s->avctx, \"\\n\");\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Non standard configuration %d !\\n\", s->amode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = channels;\n\n\n\n    /* get output buffer */\n\n    frame->nb_samples = 256 * (s->sample_blocks / 8);\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples_flt = (float **)frame->extended_data;\n\n\n\n    /* allocate buffer for extra channels if downmixing */\n\n    if (avctx->channels < full_channels) {\n\n        ret = av_samples_get_buffer_size(NULL, full_channels - channels,\n\n                                         frame->nb_samples,\n\n                                         avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        av_fast_malloc(&s->extra_channels_buffer,\n\n                       &s->extra_channels_buffer_size, ret);\n\n        if (!s->extra_channels_buffer)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL,\n\n                                     s->extra_channels_buffer,\n\n                                     full_channels - channels,\n\n                                     frame->nb_samples, avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    /* filter to get final output */\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        int ch;\n\n\n\n        for (ch = 0; ch < channels; ch++)\n\n            s->samples_chanptr[ch] = samples_flt[ch] + i * 256;\n\n        for (; ch < full_channels; ch++)\n\n            s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256;\n\n\n\n        dca_filter_channels(s, i);\n\n\n\n        /* If this was marked as a DTS-ES stream we need to subtract back- */\n\n        /* channel from SL & SR to remove matrixed back-channel signal */\n\n        if ((s->source_pcm_res & 1) && s->xch_present) {\n\n            float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]];\n\n            float *lt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]];\n\n            float *rt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]];\n\n            s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256);\n\n            s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256);\n\n        }\n\n    }\n\n\n\n    /* update lfe history */\n\n    lfe_samples = 2 * s->lfe * (s->sample_blocks / 8);\n\n    for (i = 0; i < 2 * s->lfe * 4; i++)\n\n        s->lfe_data[i] = s->lfe_data[i + lfe_samples];\n\n\n\n    /* AVMatrixEncoding\n\n     *\n\n     * DCA_STEREO_TOTAL (Lt/Rt) is equivalent to Dolby Surround */\n\n    ret = ff_side_data_update_matrix_encoding(frame,\n\n                                              (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ?\n\n                                              AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_frame_ptr = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 8241, "substitutes": {"avctx": ["afconn", "wavctx", "averctl", "cvctx", " avconn", "avtx", "afctx", "avecp", "avecmp", "avercp", "evtx", "afcp", "avcp", "avercmp", " avcp", "avepkg", "avcmp", "averctx", "avercontext", "svctx", "avecontext", "afcmp", "cvcontext", " avcontext", "svctl", "aveconn", "wavcontext", "wavconn", "ovcontext", " avpkg", "evctl", "ovctx", "svcontext", "afpkg", "ovconn", "evctx", "wavcp", "afctl", "ovctl", " avtx", "aftx", "avctl", "svconn", "avpkg", "afcontext", "avcontext", "evcontext", " avctl", "avectx", "averconn", " avcmp", "avconn", "cvcmp", "cvctl"], "data": ["p", "init", "DATA", "bin", "value", "next", "f", "type", "read", "ata", "format", "name", "pad", " DATA", "padding", "Data", "sample", "map", "feed", "window", "raw", "record", "out", "in", "o", "obj", "size", "area", "pointer", "d", "video", "form", "bytes", "dat", "def", "to", "empty", "package", "first", "input", "offset", "text", "t", "body", "buffer", "batch", "block", "table", "message", "image", "length", "zero", "response"], "got_frame_ptr": ["got_fr_handle", "got_frametpointers", "got_fr_pointers", "got_framethandle", "got_fr_pointer", "got_frame2pointers", "got_frame_pointers", "got_frametptr", "got_frame_handle", "got_frame2pointer", "got_fr_ptr", "got_frametpointer", "got_frame2ptr", "got_frame_pointer", "got_frame2handle"], "avpkt": ["avespgt", "avspct", "afpacket", "avepkt", "avcpmt", "afpstat", "avpekl", "avpett", "avppacket", "afpmt", "avcpkt", "avpstat", "avepgt", "avwacket", "avespkt", "avepct", "avPkt", "avepkg", "avpgt", "afpett", "avcpacket", "afpkt", "avcpstat", "afcpstat", "avpemt", "avjpgt", "avwkt", "avpadkt", "avjpct", "avcpkl", "afcpkl", "avspkg", "avpadett", "avpadstat", "avppstat", "avpekt", "avjpkt", "avpadacket", "avwmt", "avespkg", "avpeacket", "avpkl", "avpct", "avpacket", "avspkt", "avPgt", "avPkg", "avpkg", "avppett", "avpmt", "avppkt", "avespct", "avjpkg", "afcpett", "afcpkt", "afcpacket", "afpkl", "avcpett", "afcpmt", "avspgt", "avwkl", "avPct"], "frame": [" response", "feature", " message", "f", " sequence", " df", "ata", " chunk", " t", "name", "window", " output", "channel", " frames", " image", "Frame", " video", "def", " info", " window", " res", "base", " command", " packet", "image", "cmd"], "buf": ["r", "p", "cb", "np", "seq", "mem", "ff", "v", "cur", "cam", "bc", "uf", "window", "raw", "bl", "rc", "cv", "tmp", "buff", "b", "bytes", "arr", "queue", "ref", "Buff", "vec", "br", "txt", "t", "buffer", "db", "rb", "pkg", "xff", "doc", "vp", "orig", "img", "cmd"], "lfe_samples": ["lfe_samps", "lfe_dannels", "lfe_gsamps", "lfe_Sannels", "lfe_damps", "lfe_Sents", "lfe_sannels", "lfe_sents", "lfe_gsents", "lfe_Samps", "lfe_gsamples", "lfe_damples", "lfe_Samples", "lfe_dents", "lfe_gsannels"], "i": ["r", "di", "p", "ui", "cli", "x", "ims", "v", "gi", "id", "ai", "ic", " ii", "ind", "ei", "ii", "j", "xi", "sim", "I", "depth", "ix", "iu", "multi", "u", "bi", "n", "me", "in", "o", "iter", "b", "is", "si", "index", "li", "y", "ini", "gu", "it", "\u0438", "ci", "m", "c", "t", "ip", "mi", "zi", "ij", "qi", "ti", "im", "pi", "ki", "k"], "ret": ["r", "report", "dr", "flag", "RET", "mel", "final", "ft", "mem", "fun", "red", "value", "err", " Ret", "cont", "rr", "re", "format", "str", "result", "gt", "Ret", "deg", "usr", "val", "reply", "rem", "rm", "summary", "nl", "out", "nt", "rets", "not", "back", "print", "mt", "def", "tr", "try", "elt", "rt", "ref", "tf", "reset", "last", "it", "fin", "txt", "body", "ber", "status", "res", "ll", "det", "resp", "alt", "gc", "aux", "jp"], "samples_flt": ["samples2filt", "samples_dflt", "samples_Filt", "samples_Fmt", "samples2Fmt", "samples2Fld", "samples2fld", "samples_dfld", "samples_Fld", "samples2Filt", "samples_dlt", "samples2fmt", "samples_filt", "samples_Flt", "samples_dld", "samples_dmt", "samples_dilt", "samples2flt", "samples_fld", "samples2Flt", "samples_dfilt", "samples_fmt", "samples_dfmt"], "s": ["changes", "sb", "sets", "ls", "aws", "comm", "sv", "as", "d", "bis", "js", "sys", "c", "source", "se", "ms", "w", "ins", "ns", "less", "h", "ats", "sw", "ies", "qs", "settings", "ps", "parts", "sq", "obj", "fs", "a", "set", "stats", "ds", "services", "vs", "cs", "ims", "tes", "ports", "p", "ar", "its", "l", "ops", "tests", "store", "b", "is", "g", "eps", "os", "y", "hs", "so", "spec", "e", "self", "ts", "rs", "v", "args", "ss", "es", "als", "gs", "j", "sts", "n", "details", "m", "S", "bits", "bs", "sports", "ants"], "channels": ["camps", "champs", "chunks", "Chunks", "Champs", "chaos", "Chaos", "caos", "cunks", "Channels", " chaos", " champs", "cannels", " chunks"], "full_channels": ["full_nunks", "full_nannels", "full_lannels", "full_nats", "full_Chans", "full_lunks", "full_nans", "full_lats", "full_Chats", "full_lans", "full_Channels", "full_chans", "full_chunks", "full_Chunks", "full_chats"], "core_ss_end": ["core_ss_ends", "core_ss_start", "core_rss_end", "core_ss_stop", "core_rss_stop", "core_ss_begin", "core_rss_begin", "core_rss_start", "core_rss_ends"]}}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    const unsigned long *features = cpu->model->features;\n\n    unsigned max_bit = 0;\n\n    S390Feat feat;\n\n\n\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n\n\n\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n\n        /* z/Architecture is always active if around */\n\n        words[0] = 1ull << (63 - 2);\n\n    }\n\n\n\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n\n         feat < S390_FEAT_MAX;\n\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n\n        const S390FeatDef *def = s390_feat_def(feat);\n\n        if (def->type == S390_FEAT_TYPE_STFL) {\n\n            unsigned bit = def->bit;\n\n            if (bit > max_bit) {\n\n                max_bit = bit;\n\n            }\n\n            assert(bit / 64 < MAX_STFL_WORDS);\n\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n\n        }\n\n    }\n\n\n\n    return max_bit / 64;\n\n}\n", "idx": 8247, "substitutes": {"env": ["ack", "dev", "init", "pres", "proc", "mem", "eng", "ev", "conn", "v", "sp", "environment", "neck", "gov", "en", "code", "window", "org", "qt", "config", "ew", "cv", "buf", "server", "serv", "net", "viron", "eu", "tx", "js", "ctx", "et", "anc", "nv", "vs", "context", "e", "hw"], "words": ["Words", "wd", "vals", "games", "images", "pointers", " w", "windows", "pins", "workers", "args", " weights", "frames", "works", "pages", "lists", "ows", "rows", "W", "papers", "tags", " docs", "terms", "buf", "flags", "maps", "docs", "views", "blocks", "posts", "values", "bytes", "s", "names", "weights", "bits", "pieces", "rw", "items", "locks", "vs", "we", "wcs", "word", "doc", "ms", "w", " keywords", "wal"], "cpu": ["util", "np", "proc", "conn", "CPU", "mem", "gpu", "alloc", "ck", "cam", "stat", "ct", "mac", "xi", "cum", "vm", "cu", "process", "cv", "cp", "prof", "lif", "core", "serv", "os", "phys", "pu", "node", "sys", "ctx", "hog", "aco", "mx", "nu", "ork", "clock", "mu", "hw", "linux", "us"], "features": ["ports", "reports", "images", "vals", "types", "events", "feature", "pins", "users", "workers", "mas", "frames", "forms", "its", "settings", "lists", " feats", "rows", "jobs", "fts", "xs", "papers", "issues", "tags", "terms", "tests", " Features", "fixes", "properties", "nets", "flags", "abilities", "modules", "ATURES", "actions", "acts", "names", "facts", "files", "finals", "keys", "stats", "ints", "states", "fields", "eatures", "weights", "bits", "products", "faces", "pieces", "items", "results", "Features", "fits", "classes", "versions"], "feat": ["cat", "fact", "tag", " cond", "wit", "mit", "hit", "cas", "lu", " doc", "fn", "focus", "miss", " lat", "fac", "eat", "month", "flat", "fat", "pict", "stat", "supp", "bug", "lt", "mut", "act", "rt", "lat", "ffff", "it", " frag", " mat", "word", "man", "seq", " fe", " seq", " feats", "crit", " fmt", "apt", "capt", "ex", "vec", "prop", " win", "dit", "doc", "mod", " threat", "list", "feature", "mat", " plat", "format", "wi", "fc", " fi", " feature", "week", "kat", "wx", "cheat", " vec", " fut", "lit", "bit", "fe", "fg", " sect", "kt", " wid", "spec"], "def": ["pro", "defined", "dev", "list", "conf", "tag", "df", "du", "de", "DEF", "fc", "ef", "crit", "cond", "val", "des", "da", "dep", "d", "form", "definition", "act", "info", "lit", "tx", "desc", "fg", "Def", "ds", "vec", "prop", "define", "pos", "fam", "block", "decl", "doc", "spec"]}}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 8254, "substitutes": {"bs": ["asis", "ts", "sb", "ats", "ses", "aos", "bos", "ls", "BS", "ss", "its", "als", "bp", "bc", "obs", "cks", "gs", "acs", "bb", "ubs", "iss", "bi", "ils", "fs", "bh", "b", "lbs", "is", "bis", "js", "bes", "hs", "ds", "bits", "vs", "cs", "bm", "ns"], "s": ["ts", "less", "p", "changes", "h", "sb", "ats", "ses", "ies", "rs", "se", "i", "v", "ls", "args", "ears", "qs", "ss", "its", "als", "es", "l", "ps", "gs", "acs", "aws", "comm", "sts", "n", "sq", " ss", "des", "sv", "fs", "sl", "b", "is", "g", "a", "details", "eps", "ins", "ms", "os", "pers", "y", "bis", "js", "sys", "bes", "stats", "ds", "hs", "m", "S", "c", "https", "t", "bits", "vs", "cs", "e", "ims", "w", "gets", "sports", "ns"], "sock": ["tock", "hoy", "nock", "sice", "sinock", "tocket", " sip", "socked", "salock", "sender", "jsck", "nsink", "wsocked", "tsocked", "nix", "svcp", "lsck", "sOCK", "tsocket", "soy", "sinocket", "jsock", "scp", "sck", "cock", "hcp", "hox", "desock", "dsock", "hock", "socketocked", "cip", "salocket", "sek", "nsig", "socket", " sox", "jsek", "wsocket", "saloy", "cOCK", "dsess", "servock", "lsip", "salOCK", "cocket", "tocks", "desocket", "Sock", "sinek", "Sck", "sink", "hot", "ssock", "sinip", "nsck", "socketender", " socks", "nsess", "sig", "sox", "dsck", "lsocket", "nip", "hocket", "svock", "Sig", "six", "sinOCK", "jsip", "rsocked", "servocked", "sip", "rsocket", "tsock", "salot", "dsig", "tocked", "svOCK", "hOCK", " socked", "wsice", "desice", "nink", "sot", "jsocks", "tsender", " sOCK", "jsocket", "sinocks", "rsocks", "ssocket", "nsix", "Sess", " sck", " scp", "sinocked", "nsip", "ssender", "wsock", "svox", "ssocked", "socketock", " socket", " soy", "jsink", "service", "salip", "socks", "nsock", "socketocket", "sess", " sot", "desocked", "jsix", "lsock", "jsocked", "rsock", "servocket"], "ret": ["att", "pas", "flag", "RET", "red", "ft", "fun", "sat", "rev", "err", "git", "cont", "re", "result", "prot", "gt", "Ret", " RET", "deg", "usr", "val", "rem", "rm", "out", "nl", "nt", "rets", "count", "back", "mt", "def", "tr", "ext", "elt", "rt", "tf", "reset", "inter", "pat", "t", "ber", "len", "res", "status", "det", "resp", "ll", "alt", "ctr", "del", "arg", "cmd"], "size": ["equal", "send", "news", "sync", "timeout", "mem", "city", "type", "addr", "args", "data", "format", "izes", "fee", "name", "needed", "capacity", "code", "shell", "window", "owner", "space", "notice", "store", "count", "use", "area", "time", "sym", "sized", "since", "scale", "Size", "bytes", "address", "dim", "shape", "info", "empty", "sn", "set", "offset", "export", "ize", "power", "body", "num", "status", "len", "sum", "memory", "description", "message", "mode", "used", "SIZE", "ms", "length", "storage", "scope"], "blocksize": ["ksization", "idsize", "ksized", "blocksIZE", "ksizer", "idsizer", "locksization", "idsiz", "keyside", "minsization", "bsize", "minside", "bsIZE", "msized", "msization", "keysization", "locksizer", "ksize", "blocksized", "linesizer", "bytesization", "lockside", "blocksization", "blockside", "bsizer", "msize", "bsiz", "linesization", "idsization", "minsiz", "minsize", "bytesizer", " blocksIZE", "linesize", "bytesiz", " blocksiz", "blocksiz", "msizer", "keysiz", "locksiz", "blocksizer", " blocksizer", "keysize", "linesized", "locksIZE", "bytesize", "locksize"]}}
{"project": "FFmpeg", "commit_id": "b52b398c30a729dda38c0dd5a0cdeef160c4ca54", "target": 0, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, please add a -strict -1 flag to use it\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 8271, "substitutes": {"avctx": ["afconn", "wavtx", "averctl", "cvctx", "avecfg", "avjac", "avecp", "vrcontext", "ajpid", "avcmd", "afcfg", "avercontext", "ajaddr", "avecontext", "Avtx", "afmsg", "aveaddr", "ajctx", "varaddr", "avermsg", "avegc", "vartmp", "avcas", "avercf", "averkw", "averkt", "wavctx", "afgc", "avecf", "avergc", "vrtx", "avercu", "avercfg", "avtx", "cvtx", "ravctx", "avercp", "wavcmp", "avcp", "wavcmd", "navcp", "avcmp", "averctx", "ravpid", "avkw", "wavcf", "ravcas", "ravkt", "wavcontext", "avekt", "varctl", "ravcmd", "afconf", "vrctx", " avtx", "ajtmp", "ajcmd", "avaddr", "ravsys", "avectx", "avconn", "cvcmp", "averpid", "avercas", "afcu", "wavctl", "navcu", "ajjac", "averjac", "afctx", "ajprop", "avesys", "varctx", "avectl", "Avctx", "avconf", "cvcontext", "aveconn", "navctx", "wavcu", "vrkt", "ajsys", "avgc", "avcfg", "ajcontext", "avkt", "avercmd", " avjac", "Avcontext", "avctl", "navkw", "aveconf", "avprop", "ravprop", "avcontext", "averprop", "averconn", " avsys", " avcmp", "Avconn", "avekw", "avetmp", "avcu", " avconn", " avkt", "avcf", "avecas", "ajctl", "avpid", "averconf", " avcontext", "wavconn", "avsys", "avertx", "aversys", "avemsg", "avetx", "avtmp", "avmsg", "avecu", "avecmd"], "p": ["pr", "pl", "v", "pp", "sp", "pe", "l", "pt", "pn", "n", "cp", "P", "a", "pa", "ph", "m", "c", "part", "t", "ap", "pi", "pc", "jp"], "b": ["r", "sb", "f", "v", "z", "bp", "bc", "l", "bi", "n", "a", "g", "d", "B", "y", "m", "c", "t", "base", "ba", "e", "sub", "bs"], "i": ["r", "di", "ui", "ami", "cli", "x", "init", "ims", "json", "v", "gi", "ri", "id", "ai", "ic", " ii", "ind", "l", "ei", "ii", "xi", "ji", "I", "ix", "iu", "oi", "key", "u", "multi", "bi", "in", "n", "remote", "is", "g", "hi", "si", "index", "li", " bi", "y", "ini", "info", "go", "gu", "it", "\u0438", "ci", "m", "c", "t", "ip", "mi", "zi", "ij", "cgi", "ti", "qi", "batch", "asi", "pi", "ki", "me", "ori", "ish"], "j": ["aj", "oj", "jj", "jc", "v", "jump", "z", "ind", "l", "bj", "ji", "rel", "n", "g", "index", "q", "js", "J", "m", "pos", "ij", "dj", "uj", "k", "jp"], "level": ["report", "limit", "coll", "dev", "strength", "high", "where", "levels", "tag", "type", "member", "Level", "pe", "pri", "version", "location", "title", "l", "group", "interface", "depth", "lock", "lc", "family", "val", "key", "debug", "label", "time", "count", "size", "loop", "community", "scale", "index", "dim", "fl", "goal", "lvl", "local", "lo", "offset", "priority", "half", "profile", "stage", "pos", "len", "status", "stable", "loc", "quality", "mode", "cost", "vel", "le", "color", "length", "state", "low", "scope", "rel", "score"], "o": ["ot", "O", "off", "iso", "ou", "om", "op", "l", "ox", "fo", "oa", "out", "ao", "n", "oo", "os", "ok", "lo", "go", "offset", "oe", "m", "po", "mode", "e"], "shift": ["dr", "Shift", "dq", "sh", "sup", "seed", "ul", "ii", "start", "depth", "align", "share", "channel", "slice", "sq", "seek", "scale", "shr", "si", "push", "shape", "set", "offset", "hift", "pos", "sc", "ap", "sch"], "fmt": [" ftm", "vMT", "ftm", "finglux", "funolt", "ferformat", "Ftm", "wformat", "flt", "fingformat", "ftx", "formt", "volt", "fMT", "fingMT", "hMT", "vfm", " ffm", "ffm", "fformat", "flux", "formmt", "vlux", "funMT", "frtm", "forlux", " folt", "wancy", "funformat", "dfm", "forett", "Fformat", "wmt", "vmt", "fett", "Fmt", "hformat", "fingmt", "ferMT", " fancy", " fett", "dtm", "fermt", "frlux", "vlt", "formpt", " flux", " fformat", "pmt", "htx", "dformat", " fpt", "formancy", "frmt", "formformat", "Ffm", "folt", " flt", "funmt", "vtx", " ftx", " fMT", "frett", "ptx", "vtm", "dmt", "ptm", "wpt", "fpt", "fancy", "ferlux", "plt", "hmt", "vformat", "frformat", "forformat", "frfm"], "s": ["changes", "sb", "sets", "ses", "ls", "comm", "sv", "er", "as", "d", "bis", "js", "sys", "c", "t", "ms", "ns", "ins", "less", "ats", "ies", "qs", "ers", "settings", "ps", "terms", "parts", "sq", "obj", "a", "fs", "set", "stats", "ds", "comments", "status", "res", "locks", "services", "vs", "cs", "ims", "ports", "its", "tests", "g", "is", "eps", "os", "hs", "styles", "spec", "e", "r", "ts", "self", "rs", "v", "args", "ss", "es", "als", "uploads", "gs", "sts", "n", "actions", "details", "pers", "m", "S", "bits", "mods", "bs", "sports", "ants"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)\n\n{\n\n    int y;\n\n    uint8_t * fcode_tab= s->fcode_tab;\n\n\n\n    // RAL: 8 in MPEG-1, 16 in MPEG-4\n\n    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);\n\n\n\n    /* clip / convert to intra 16x16 type MVs */\n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= (y+1)* (s->mb_width+2)+1;\n\n        int i= y*s->mb_width;\n\n        for(x=0; x<s->mb_width; x++)\n\n            {\n\n            if (s->mb_type[i] & type)    // RAL: \"type\" test added...\n\n                {\n\n                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][0]>0) \n\n                        mv_table[xy][0]=  range-1;\n\n                    else\n\n                        mv_table[xy][0]= -range;\n\n                    }\n\n                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][1]>0) \n\n                        mv_table[xy][1]=  range-1;\n\n                    else                  \n\n                        mv_table[xy][1]= -range;\n\n            }\n\n            }\n\n            xy++;\n\n            i++;\n\n        }\n\n    }\n\n}\n", "idx": 8273, "substitutes": {"s": ["r", "ts", "p", "less", "h", "sb", "ats", "conf", "sw", "ses", "se", "rs", "v", "ls", "ss", "its", "es", "als", "ps", "gs", "aws", "comm", "ops", "sts", "http", "parts", "space", "n", "sq", "sv", "a", "sl", "b", "is", "as", "fs", "app", "ins", "ms", "bis", "js", "sys", "hs", "ds", "stats", "m", "c", "sis", "S", "t", "spec", "vs", "cs", "e", "ims", "bs", "w", "qs", "ns"], "mv_table": ["mv_map", "mvv___storage", "mv_tab", "mV_entry", "mv_storage", "mvistcollection", "mvisttab", "mvisttable", "mvactable", "mcv_table", "mv__table", "mv_size", "mvPsize", "mv__map", "mvv___size", "mvt_collection", "mvPstorage", "mvv_table", "mv2table", "mv__found", "mv_database", "mvPtable", "mvptentry", "mv___tab", "mV_stable", "mvPtab", "mv___table", "mV_map", "mv2db", "mV_database", "mV_count", "mv___database", "mV_index", "mv2buffer", "mvv___tab", "mv_queue", "mvisttmp", "mv_index", "mv5stable", "mv5encrypted", "mv_buffer", "mvv_tab", "mV_buffer", "mvt_table", "mvc_database", "mvptcount", "mvc_tab", "mV_tab", "mvt_tab", "mV_encrypted", "mv_list", "mv___tmp", "mek_table", "mv_entry", "mv2index", "mV_db", "mV_list", "mvv_storage", "mv_desc", "mcv_queue", "mv___storage", "mvc_tmp", "mv_tmp", "mv_record", "mv_stable", "mv_encrypted", "mcv_desc", "mV_table", "mv2list", "mvactab", "mcv_tab", "mv_collection", "mvistdatabase", "mek_tab", "mvv_size", "mek_record", "mv__tab", "mv___size", "mvt_tmp", "mvpttable", "mvv___table", "mv_found", "mvc_table", "mvacqueue", "mv5table", "mV_found", "mv_count", "mvpttab", "mv_db", "mvacdesc", "mv2tab", "mv5tab"], "f_code": ["fmycode", "f8codes", "f_tag", "fliccase", "fphptype", "fjcase", "flichello", "fmyCode", "f__Code", "sf_code", "fm_code", "f_codes", "f5go", "f_coe", "fjcode", "f_Code", "f5code", "sf__Code", "fphpCode", "f__codes", "fphpcodes", "f_go", "fmlicpage", "sf__code", "f8code", "f8type", "sf_type", "f5hello", "fliccoe", "f_hello", "rf5go", "f_page", " f__type", "rf5case", " f_Code", "fm_tag", "fphpcode", "f5case", "fmliccoe", "sf_Code", "rf_case", "sf_codes", "fmcode", "fmyversion", "f8Code", "fjhello", "fm_coe", "rf5hello", " f__version", "flictag", " f_type", "f__version", "fliccode", "flicgo", "rf_code", "rf_go", "rf_hello", " f__Code", "fmversion", "sf__type", "fjgo", " f_version", "fm_page", "f__code", "fmtype", " f__code", "f_type", "rf5code", "fmlictag", "sf__codes", "f_case", "f__type", "fmCode", "fmliccode", "flicpage", "fmytype", "f_version"], "type": ["r", "p", "types", "ype", "feature", "unit", "tag", "f", "test", "typ", "role", "pe", "name", "ver", "angle", "ty", "range", "size", "count", "time", "index", "TYPE", "field", "to", "info", "Type", "bit", "style", "kind", "t", "status", "color", "state", "length", "error"], "y": ["p", "ny", "ot", "py", "fy", "ky", "yi", "ies", "uy", "yr", "vy", "dy", "wy", "hy", "z", "yer", "asy", "oy", "kit", "height", "sky", "ys", "ty", "ey", "ady", "key", "iy", "n", "b", "my", "yy", "icy", "axy", "Y", "iny", "ry", "ay", "ya", "ym", "ly", "yt", "yx", "cy", "t", "yl", "sy", "aily", "row", "ye", "e", "yo", "gy", "by", "ley"], "fcode_tab": ["fcode___tab", "fcode_cart", "fcode_tx", "fcode32tab", "fmap_stab", "fcode_bt", "fcode_fab", "fcodeopTab", "fcode___Tab", "fode_cart", "fclose_name", "fcode__bag", "fcode7tab", "fode_Tab", "fcode__table", "fco_map", "fcode__cache", "fcode__stab", "fcode2bag", "fmap__bag", "fcode_bag", "flinkoptab", "fcode_abs", "fclose_tab", "fmap__bt", "fcode_tool", "fcode___tx", "fcode_name", "fclose_tool", "fco_table", "fcode_cache", "fcode__map", "fcc2fab", "flinkopTab", "fcode_tag", "fcode32tag", "fmap_bag", "fcode7tool", "fcodetbag", "fcodettag", "fmap__stab", "fcodeoptx", "fmap__tab", "fcode7name", "fcode__tab", "fcode7abs", "fcode_Tab", "fcode_map", "fcc_tag", "fcode2tag", "fmap_tab", "fcode_stab", "flink_Tab", "flink_bt", "fcc_fab", "fcodettab", "fcode__bt", "fco_cache", "fcode2fab", "fcodetfab", "fcode32fab", "fclose_abs", "flinkoptx", "fcc2bag", "fcode2tab", "fcodeopbt", "fcodeoptab", "flinkopbt", "fcc_bag", "fcode___bt", "fcc2tag", "fcc_tab", "fode_table", "fode_tab", "fcode32bag", "fcode_table", "flink_tx", "fcc2tab", "fmap_bt", "flink_tab", "fco_tab"], "x": ["p", "X", "on", "dx", "nex", "px", "zx", "xes", "v", "xt", "z", "xe", "xf", "l", "ox", "xi", "j", "ix", "key", "ex", "at", "xd", "n", "ice", "o", "wx", "xp", "a", "ax", "el", "inx", "index", "ext", "tx", "fx", "q", "lat", "xxx", "ux", "m", "rx", "xa", "yx", "mx", "im", "xc", "iz", "e", "php", "k", "w", "xx"], "xy": ["py", "fy", "oxy", "qq", "np", "zx", "json", "iso", "chan", "xe", "fo", "zie", "hello", "dt", "zip", "index", "te", "bis", "io", "batch", "xc", "sync", "dx", "zy", "yz", "sky", "phi", "ey", "ie", "my", "ay", "ry", "note", "yout", "mop", "yo", "linux", "XY", "peer", "zz", "coord", "dy", "wy", "oy", "xi", "scroll", "ex", "xp", "o", "tif", "pei", "yy", "try", "axy", "mie", "xxxx", "ym", "oe", "gay", "yx", "iz", "bo", "xx", "timeout", "px", "uxe", "gone", "ox", "ji", "yk", "key", "iy", "wx", "hi", "yt", "xxx", "phy", "ele", "mx", "ye", "xxxxxxxx"], "i": ["p", "f", "v", "id", "ic", "ai", " ii", "l", "ii", "j", "xi", "I", "phi", "ix", "iy", "u", "bi", "n", "o", "is", "g", "si", "index", "li", "it", "ci", "m", "io", "c", "mi", "ij", "ti", "pi", "e"]}}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu;\n\n    Error *err = NULL;\n\n\n\n    cpu = cpu_s390x_create(cpu_model, &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 8291, "substitutes": {"cpu_model": [" cpu_link", " cpu_type", "cpu_link", "cpu2model", "cpu2type", "pu_models", "cpu_models", "cpu2link", " cpu_Model", "pu_link", "cpu_Model", "cpu_type", "pu_model", "pu_Model", "cpu2Model"], "core_id": ["ore_ref", "core_ref", "ore_id", "core_ip", "core__id", "core__type", "cpu_ids", "ore_ip", "cpu_type", "core_ids", "core__ip", "ore_ids", "core_type", "core__ref", "core__ids", "cpu_id"], "errp": ["derP", "arrpb", " errP", " errpc", "derpc", "derp", "errbp", "arrm", "derbp", "errorpkg", "errpc", "errorm", " errbp", "errorp", "arrp", "scorem", "arrbp", "scorepkg", "errP", "errorpb", "scorepb", "arrpc", "arrpkg", "errm", "errpkg", "scorep", "arrP", "errpb"], "cpu": ["cli", "runner", "instance", "np", "pid", "ka", "thread", " cp", "ni", "cp", "met", "cache", "que", "sys", "c", "current", "pkg", "mu", "jp", "cmd", "util", "mem", "gpu", "boot", "ps", "cu", "uma", "bench", "obj", "core", "uu", "foo", "ach", "pu", "aco", "bean", "clock", "aux", "cs", "cn", "linux", "p", "CPU", "lp", "pause", "ck", "frame", "result", "cum", "process", "out", "setup", "copy", "node", "ctx", "memory", "gc", "pc", "bo", "comp", "hw", " pc", " CPU", "proc", "du", "alloc", "tp", "processor", "rpm", "device", "ilo", "cv", "prof", "gb", "queue", "phy", "po", "hz"], "err": ["cli", "dr", "ev", "cfg", "fr", " Err", "exc", "rm", "buf", "errors", "er", "empty", "arr", "sys", "mr", "js", "kr", "ger", "later", "rb", "timer", "wcs", "ptr", "eor", "rel", "ns", "conf", "attr", "test", "fee", "ef", "lr", "good", "Error", "order", "notice", "obj", "cer", "gz", "eas", "it", "txt", "res", "inner", "msg", "peer", "p", "aaa", "Er", "coord", "i", "warn", "l", "str", "result", "ex", "out", "iter", "try", "elt", "ctx", "br", "here", "e", "erd", "error", "r", "cb", "die", "rev", "rr", "der", "norm", "usr", "n", " terr", "term", "rn", "oc", "resp", "drm"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n", "idx": 8296, "substitutes": {"deadline": ["Deadlong", "DeadLine", "Deadzone", "daylined", "dayliner", "deadLine", "faceline", "faclock", "deadlong", "offLine", "deadlock", "facliner", "redlong", "deadlined", " deadlong", "dayline", "offlock", "newLine", "whenLine", "Deadline", "whenline", "redzone", " deadlock", "dayLine", "newliner", "offeline", "redLine", "newline", "whenlined", " deadLine", "offline", "offlined", "offliner", " deadeline", " deadzone", " deadlined", "facline", " deadliner", "deadeline", "redline", "whenliner", "newlined", "deadzone", "deadliner"], "bh": ["cb", "h", "sb", "bf", "hr", "gh", "FH", "eth", "ih", "sh", "nb", "pb", "bp", "rh", "bc", "bj", "broad", "phi", "bb", "bol", "sbm", "rob", "eb", "bl", "hw", "hole", "bt", "b", "forth", "zh", "history", "ht", "hub", "kh", "dh", "ah", "handle", "hold", "nil", "hl", "hh", "bis", "lo", "uh", "ctx", "hs", "ubb", "ssl", "br", "abb", "body", "bang", "batch", "hal", "bn", "bg", " inh", "bo", "bel", "lb", "profile", "bs", "hz", "bm", "hab"]}}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)\n\n{\n\n    int n=0, x, y, i;\n\n\n\n    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));\n\n\n\n    /* Map to the ROQ quadtree order */\n\n    for (y=0; y<enc->height; y+=16)\n\n        for (x=0; x<enc->width; x+=16)\n\n            for(i=0; i<4; i++) {\n\n                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;\n\n                tempData->cel_evals[n++].sourceY = y + (i&2)*4;\n\n            }\n\n}\n", "idx": 8313, "substitutes": {"enc": ["ren", "ack", "att", "ens", "ENC", "ent", "coll", "pres", "conn", "proc", "eng", "acc", "voc", "cont", "nec", "fc", "crypt", "rec", "nc", "bc", "lang", "rh", "en", "env", "inc", "rc", "exc", "nt", "sec", "alg", "ec", "act", "etc", "desc", "ctx", "c", "et", "kt", "anc", "ang", "kw", "con", "Enc", "oc", "pc", "conv", "ac"], "tempData": [" tempQuery", " tempDec", "tempDec", "empRecord", "empQuery", "tempMemory", "empBu", "publicAppData", " tempDo", "publicData", "tempQuery", "templateBu", "tempFile", " tempDat", "tmpDat", "publicDo", "tempDo", "publicDec", "empMemory", "templateRecord", "tempAppData", "empData", "empAppData", "empFile", "tempDat", "tmpData", " tempMemory", " tempFile", "publicQuery", "tempRecord", "templateData", " tempAppData", " tempRecord", "empDo", "tmpAppData", "publicFile", "empDat", "tempBu", "empDb", "publicMemory", "empDec", " tempDb", " tempBu", "tmpDb", "tempDb"], "x": ["att", "p", "X", "on", "dx", "xy", "px", "zx", "f", "v", "column", "rex", "xt", "xe", "xf", "l", "ct", "xs", "ox", "xi", "pt", "axis", "ix", "key", "ex", "at", "xd", "wx", "xp", "o", "ax", "g", "el", "inx", "try", "ext", "tx", "fx", "q", "lat", "ce", "rx", "m", "yx", "xa", "text", "mx", "xc", "pi", "e", "xml", "php", "w", "xx"], "y": ["ny", "ot", "py", "fy", "yn", "yi", "ies", "xy", "uy", "yr", "vy", "dy", "wy", "hy", "yer", "asy", "oy", "height", "sky", "ey", "ty", "ady", "iy", "n", "my", "yy", "axy", "yet", "Y", "iny", "ay", "ry", "yt", "ya", "ly", "ym", "sys", "yx", "cy", "yl", "sy", "aily", "ye", "yo", "gy", "by"], "i": ["ui", "di", "ami", "cli", "v", "gi", "ri", "ic", "ai", "id", "jp", "iq", "ind", "ei", "ii", "xi", "j", "sim", "I", "ji", "phi", "ix", "iu", "multi", "bi", "n", "in", "ni", "is", "hi", "si", "index", "s", "li", "info", "ini", "fi", "it", "\u0438", "ci", "m", "io", "mc", "qi", "ip", "mi", "ij", "zi", "status", "ti", "im", "asi", "pi", "ki", "me", "conv"]}}
{"project": "FFmpeg", "commit_id": "273e6af47b38391f2bcc157cca0423fe7fcbf55c", "target": 0, "func": "static int ea_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    EaDemuxContext *ea = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    int packet_read = 0;\n\n    unsigned int chunk_type, chunk_size;\n\n    int key = 0;\n\n    int av_uninit(num_samples);\n\n\n\n    while (!packet_read) {\n\n        chunk_type = avio_rl32(pb);\n\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n\n\n        switch (chunk_type) {\n\n        /* audio data */\n\n        case ISNh_TAG:\n\n            /* header chunk also contains data; skip over the header portion*/\n\n            avio_skip(pb, 32);\n\n            chunk_size -= 32;\n\n        case ISNd_TAG:\n\n        case SCDl_TAG:\n\n        case SNDC_TAG:\n\n        case SDEN_TAG:\n\n            if (!ea->audio_codec) {\n\n                avio_skip(pb, chunk_size);\n\n                break;\n\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n\n                       ea->audio_codec == CODEC_ID_MP3) {\n\n                num_samples = avio_rl32(pb);\n\n                avio_skip(pb, 8);\n\n                chunk_size -= 12;\n\n            }\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->audio_stream_index;\n\n\n\n            switch (ea->audio_codec) {\n\n            case CODEC_ID_ADPCM_EA:\n\n            case CODEC_ID_ADPCM_EA_R1:\n\n            case CODEC_ID_ADPCM_EA_R2:\n\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n                pkt->duration = AV_RL32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_EA_R3:\n\n                pkt->duration = AV_RB32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n                pkt->duration = ret * 2 / ea->num_channels;\n\n                break;\n\n            case CODEC_ID_PCM_S16LE_PLANAR:\n\n            case CODEC_ID_MP3:\n\n                pkt->duration = num_samples;\n\n                break;\n\n            default:\n\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n\n            }\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        /* ending tag */\n\n        case 0:\n\n        case ISNe_TAG:\n\n        case SCEl_TAG:\n\n        case SEND_TAG:\n\n        case SEEN_TAG:\n\n            ret = AVERROR(EIO);\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case MVIh_TAG:\n\n        case kVGT_TAG:\n\n        case pQGT_TAG:\n\n        case TGQs_TAG:\n\n        case MADk_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MVIf_TAG:\n\n        case fVGT_TAG:\n\n        case MADm_TAG:\n\n        case MADe_TAG:\n\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n\n            chunk_size += 8;\n\n            goto get_video_packet;\n\n\n\n        case mTCD_TAG:\n\n            avio_skip(pb, 8);  // skip ea dct header\n\n            chunk_size -= 8;\n\n            goto get_video_packet;\n\n\n\n        case MV0K_TAG:\n\n        case MPCh_TAG:\n\n        case pIQT_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MV0F_TAG:\n\nget_video_packet:\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->video_stream_index;\n\n            pkt->flags |= key;\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            avio_skip(pb, chunk_size);\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8340, "substitutes": {"s": ["ts", "p", "less", "sb", "ats", "ses", "rs", "v", "ls", "ss", "es", "ps", "xs", "gs", "aws", "sts", "n", "sq", "a", "fs", "as", "b", "has", "ec", "ins", "os", "set", "sg", "js", "sys", "hs", "ds", "c", "S", "t", "cs", "e", "bs", "ns"], "pkt": ["wkl", "pelt", "pakt", " pett", " pwk", "pst", "pingkt", "Pkg", " pux", " pt", "prokg", "hkt", "wwk", "pawk", "pmsg", "pingacket", "proacket", "pkg", "prconn", "pingtt", "pingelt", "npkt", "ptt", "pux", "ppt", "ppqt", "pt", " pkl", "promsg", "pracket", "ppacket", "npmsg", "npacket", "epacket", "patkl", "paacket", "pkl", "packet", "patett", "tpwk", "paux", "cpqt", "pnt", "pwk", "ppkg", "tpacket", " ptt", " pnt", "cpkg", " pelt", "cpkt", "npkg", "wkt", "Pkt", "epelt", "pqt", "Pnt", "patwk", "prokt", " packet", "patkt", "perkt", "wett", "hkg", "tpkt", "prkt", " pmsg", "ppkt", "permsg", "prkg", "eptt", "pett", " pconn", "pconn", "hacket", "hconn", "pskt", "psacket", "ppnt", " pqt", "perkg", "pernt", "cpnt", "tpux", " pkg", "Pmsg", "psnt", "epkt"], "ea": ["eta", "cb", "aaa", "ace", "ma", "deb", "ra", "anza", "ae", "eur", "ar", "sa", "ega", "ata", "exec", "ean", "eric", "eni", "ef", "ei", "na", "era", "rep", "ez", "eg", "hd", "eb", "gp", "oa", "qa", "ota", "ew", "cp", "ne", "fa", "ja", "za", "ie", "el", "chart", "area", "pa", "ec", "eu", "eeee", "eas", "raf", "gae", "elt", "ca", "note", "eval", "af", "iera", "ctx", "ia", "ele", "enda", "EA", "je", "et", "eh", "aria", "ee", "ta", "apache", "exe", "au", "e", "ena", "adata", "ze", "aa", "jp"], "pb": ["p", "cb", "pl", "sb", "snap", "span", "np", "wp", "tc", "proc", "lp", "px", "pp", "pid", "typ", "sp", "ng", "tm", "tp", "dp", "pg", "bp", "ob", "emb", "pt", "bj", "tk", "uf", "erb", "apy", "eb", "gp", "ub", "oa", "patch", "buf", "PB", "cp", "tmp", "obj", "pool", "td", "soc", "pa", "mb", "mt", "pan", "tx", "gb", "sys", "fp", "ctx", "pm", "tf", "tg", "uv", "wb", "mp", "orp", "txt", "bps", "rb", "resp", "ap", "pkg", "gc", "pc", "vp", "bs", "jp"], "chunk_type": ["chunk___type", "chunkairtemplate", "chunkTypesize", "chunkTypetype", "chunk___typ", "chunk_tag", "chunkitytype", "chunks_size", "chunkTypetag", "chunk_Type", "chunkTypeid", "chunkairtype", "chunks_template", "chunkitytyp", "chunk_id", "chunk_template", "chunkityType", "chunk_set", "chunk___Type", "chunks_type", "chunkairsize", "chunkairstart", "chunkityset", "chunk___set", "chunk_typ", "chunk_start", "chunks_start"], "chunk_size": ["chachment_term", "chunk_number", "chunk_num", "chachment_len", "chunk64name", "chunk8size", "chunks_capacity", "chunks_Size", "chrain_body", "chunk8data", "chunk_depth", "chachment_size", "chunklexsize", "chunk64Size", "chachment_type", "chunk64size", "chunk64type", "chunks_type", "chunk_body", "chrain_size", "chunk8Size", "chunk_Size", "chunklexSize", "chunk8num", "chunklexcapacity", "chunk_string", "chunk_capacity", "chunks_size", "chunk_data", "chunk_len", "chunklexstring", "chunks_name", "chunks_string", "chrain_depth", "chunk_name", "chunk_term", "chrain_Size"]}}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n", "idx": 8357, "substitutes": {"ti": ["di", "ami", "tto", "yi", "i", "ri", "ai", "tm", "wi", "tp", "sci", "uti", "ei", "tip", "ii", "tk", "tt", "fo", "ty", "qt", "tis", "bi", "ni", "iti", "tif", "vt", "ite", "hi", "si", "tv", "te", "tre", "li", "iat", "fi", "wt", "vi", "TI", "tile", "ci", "ita", "t", "mi", "ta", "pi", "ki", "cci", "ati", "ski"], "parent": ["self", "p", "list", "snap", "instance", "via", "ma", "paren", "public", "value", "unit", "Parent", "master", "type", "pid", "sp", "id", "by", "name", "tip", "parents", "global", "mother", "family", "root", "owner", "out", "help", "origin", "pool", "server", "g", "prefix", "form", "file", "mt", "max", "path", "to", "shape", "term", "cmp", "ref", "father", "iat", "ctx", "home", "gr", "module", "m", "target", "txt", "t", "ip", "part", "port", "source", "point", "template", "pc", "class", "child", "client", "spec", "scope", "peer"], "new_iface": ["new_Ifaces", "new_iac", "new_Ifac", "new_iaces", "new_ifest", "new__itac", "new_ipface", "new_ifaces", "new_ipac", "new_ilaces", "new_Iface", "new_ipace", "new_ilacket", "new_ifacket", "new_interface", "new__ifac", "new__itace", "new_itac", "new__ifaces", "new_itface", "new__ifface", "new_itace", "new_itest", "new_interace", "new_interest", "new_itaces", "new_ilace", "new_iace", "new__itaces", "new__itface", "new_Ifface", "new_ilac", "new_ifac", "new__iface", "new_interac", "new_iacket", "new_ipaces", "new_ifface", "new_ipacket"], "iface_impl": ["ifinterface2Impl", "ifrace_impl", "iface____imp", "ifinterface_im", "iface2impl", "ifac_rel", "ifinterface2im", "iface_pl", "ifinterface2impl", "iface_expl", "iface2im", "iface2Impl", "ifrace_obj", "iface_obj", "ifac_impl", "iface_Impl", "iframe_impl", "ifrace_imp", "iface____Impl", "ifinterface_impl", "iface_im", "ifac_inner", "ifinterface_inner", "iface_inner", "iframe_ind", "iface_imp", "iface____impl", "ifinterface2inner", "iface2inner", "iface_ind", "iframe_Impl", "ifac_expl", "ifrace_Impl", "ifrace_pl", "iface_rel", "ifinterface_Impl"]}}
{"project": "FFmpeg", "commit_id": "c97f54020d5d55511e28622551f13233bd8ceb56", "target": 0, "func": "static int video_open(VideoState *is){\n\n    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    int w,h;\n\n\n\n    if(is_full_screen) flags |= SDL_FULLSCREEN;\n\n    else               flags |= SDL_RESIZABLE;\n\n\n\n    if (is_full_screen && fs_screen_width) {\n\n        w = fs_screen_width;\n\n        h = fs_screen_height;\n\n    } else if(!is_full_screen && screen_width){\n\n        w = screen_width;\n\n        h = screen_height;\n\n    }else if (is->video_st && is->video_st->codec->width){\n\n        w = is->video_st->codec->width;\n\n        h = is->video_st->codec->height;\n\n    } else {\n\n        w = 640;\n\n        h = 480;\n\n    }\n\n#ifndef SYS_DARWIN\n\n    screen = SDL_SetVideoMode(w, h, 0, flags);\n\n#else\n\n    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */\n\n    screen = SDL_SetVideoMode(w, h, 24, flags);\n\n#endif\n\n    if (!screen) {\n\n        fprintf(stderr, \"SDL: could not set video mode - exiting\\n\");\n\n        return -1;\n\n    }\n\n    SDL_WM_SetCaption(\"FFplay\", \"FFplay\");\n\n\n\n    is->width = screen->w;\n\n    is->height = screen->h;\n\n\n\n    return 0;\n\n}\n", "idx": 8370, "substitutes": {"is": ["ports", "or", "does", "ims", "rs", "i", "was", "ls", "ri", "id", "isl", "ss", "Is", "ais", "IS", "ois", "its", "isin", "sim", "iss", "terms", "tis", "parts", "in", "ris", "isi", "fs", "isal", "plays", "ics", "details", "s", "has", "are", "bs", "os", "isa", "times", "info", "isp", "iris", "bis", "js", "lis", "oss", "dis", "it", "sis", "ists", "bits", "mi", "ips", "num", "ires", "ist", "any", "im", "us", "ms", "mis", "isc", "ins"], "w": ["r", "p", "wd", "x", "wall", "sw", "wp", "i", "f", "v", "wy", "wr", "z", "wi", "W", "l", "widget", "wn", "en", "window", "raw", "ex", "wx", "ew", "xp", "wl", "g", "d", "el", "wm", "wh", "win", "ow", "s", "iw", "q", "max", "wt", "wid", "m", "wb", "wa", "weight", "t", "rew", "nw", "kw", "rw", "words", "we", "ww", "aw", "word", "hw", "wal", "fw"], "h": ["p", " H", "hr", "high", "html", "em", "i", "f", "ih", "v", "sh", "hm", "history", "z", "length", "rh", "height", "l", "j", "en", "hd", "window", "hz", "th", "host", "H", "bh", "a", "b", "g", "hi", "oh", "d", "ht", "he", "ch", "dh", "kh", "wh", "ah", "ph", "s", "y", "hl", "hh", "hash", "q", "uh", "max", "it", "m", "c", "t", "eh", "hang", "k", "ish"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n", "idx": 8380, "substitutes": {"opaque": ["OPatile", "opatile", "opca", " opacity", "opsatile", "OPacity", "opdoor", " opatile", " opdoor", "opsaque", "pca", "oacity", "olay", "oaque", "opsdoor", "OPaque", "popaque", "oca", "OPdoor", "play", "poplay", "popca", "oplay", "opsacity", "opacity", "paque", "popacity", "pacity"], "addr": ["ack", "dr", "on", "eth", "attr", "coord", "err", "alloc", "id", " address", "add", "pad", "ix", "at", "obj", "store", "src", "a", "work", "mt", "dh", "act", "var", "to", "tx", "Address", "ref", "offset", "ctx", "inter", "adr", "kt", "pos", "ad", "asm", "ord", "ptr", "hw", "address", "msg", "cmd"], "size": [" offset", "h", "mem", "type", "args", "id", "z", "name", "l", " length", "align", "n", "count", "area", "Size", "shape", "offset", "ize", "weight", "num", "len", "message", "w", "SIZE", "address", "length"], "s": ["ts", "p", "less", "self", "h", "sb", "conf", "ses", "sol", "rs", "ls", "sp", "ss", "es", "ps", "gs", "comm", "ops", "sts", "space", "n", "sq", "sm", " ss", "store", "sv", "fs", "sl", "is", "a", "b", "sam", "bs", "y", "set", "js", "sys", "stats", "ds", "hs", "S", "c", "t", "status", "spec", "asm", "state", "se", "qs", "ns"], "r": ["p", "or", "pr", "cr", "dr", "h", "x", "rs", "i", "rr", "err", "ar", "v", "vr", "re", "rf", "l", "result", "str", "R", "lr", "nr", "rc", "sr", "rm", "u", "out", "n", "er", "b", "d", "g", "rt", "q", "mr", "rar", " rg", "it", "rn", "rx", "c", "t", "res", "rb", "rw", "e", "ptr", " R", "w", "rd"], "rdy": ["rwy", "bindY", "rdY", "ndey", "ndry", "rwdy", "rddy", "ndi", "irdey", "rwey", "bindyn", "ldey", "redx", "bindy", "irdi", "rdry", "rdi", "rody", "rodi", "rowni", "rdx", "redy", "rwyn", "roddy", "rowny", "ldy", "rownyn", "ndy", "irdy", "rodyn", "rwi", "ridx", "ridy", "irdry", "ridi", "rwY", "ridey", "ldx", "ldi", "rowndy", "bindey", "redey", "redi", "rdey", "ldry", "rdyn", "ridY", "ridyn"]}}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n", "idx": 8409, "substitutes": {"value": ["limit", "ue", "unit", " Value", "type", "json", "v", "save", "test", "pain", "data", "number", "speed", "fee", "function", "version", "command", "name", "VALUE", "position", "new", "hello", "val", "key", "create", "Value", "total", "initial", "size", "use", "please", "area", "time", " voltage", "property", "sv", "values", "index", "scale", " v", "maximum", "efficiency", "unknown", "field", "attribute", "input", "max", "sequence", "now", "priority", "power", "weight", "volume", "operator", "current", "description", "we", "php", "state", "expression", "length", "zero"], "errp": ["Erp", "errps", "errP", "erP", "ErP", "erps", "Erps", " errps", " errP", "erp"], "s": ["ts", "p", "session", "sync", "h", "sb", "ats", "ses", "su", "rs", "se", "sa", "v", "ls", "save", "sp", "ss", "es", "stat", "l", "ps", "gs", "aws", "sports", "comm", "sts", "sq", "sm", "store", "south", "sv", "fs", "sl", "serv", "is", "service", "b", "sam", "bs", "eps", "os", "info", "set", "sys", "js", "stats", "ds", "hs", "states", "m", "S", "so", "c", "t", "status", "services", "state", "spec", "qs", "ns"]}}
{"project": "qemu", "commit_id": "3d5d319e1221082974711af1d09d82f0755c1698", "target": 1, "func": "void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 8412, "substitutes": {"job": ["pro", "session", "runner", "name", "brain", "jj", "em", "build", "grab", "member", "json", "exec", "jump", "op", "emb", "ob", "obs", "kick", "entry", "command", "gov", "game", "j", "cell", "JO", "sim", "call", "lock", "rob", "bot", "run", "process", "worker", "bug", "out", "config", "bar", "cp", "journal", "event", "b", "serv", "work", "anim", "jo", "try", "tab", "unknown", "com", "info", "user", "one", "node", "Job", "task", "ann", "bing", "status", "block", "batch", "row", "normal", "base", "up", "msg", "state", "item", "jp", "cmd"], "aio_context": ["aaoaccontext", "aync_condition", "aiooppath", "aio_ctx", "aiotcondition", "aio_config", "aync_client", "aync_context", "aiao_handle", "aiotclient", "aiao_client", "aao_config", "aio_path", "aync_work", "aio_condition", "aioopclient", "aioophandle", "aioacconfig", "aioopcontext", "aio_handle", "aiao_context", "aao_context", "aio_work", "aio_history", "aaoachistory", "aio_client", "aioacctx", "aiao_path", "aioachistory", "aiotcontext", "aiotwork", "aaoacconfig", "aioaccontext", "aaoacctx", "aao_history", "aao_ctx"]}}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n\n                        const char *arg)\n\n{\n\n    /* new-style options contain an offset into optctx, old-style address of\n\n     * a global var*/\n\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n\n    int *dstcount;\n\n\n\n    if (po->flags & OPT_SPEC) {\n\n        SpecifierOpt **so = dst;\n\n        char *p = strchr(opt, ':');\n\n\n\n        dstcount = (int *)(so + 1);\n\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n\n        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : \"\");\n\n        dst = &(*so)[*dstcount - 1].u;\n\n    }\n\n\n\n    if (po->flags & OPT_STRING) {\n\n        char *str;\n\n        str = av_strdup(arg);\n\n        av_freep(dst);\n\n        *(char **)dst = str;\n\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n\n    } else if (po->flags & OPT_INT64) {\n\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n\n    } else if (po->flags & OPT_TIME) {\n\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n\n    } else if (po->flags & OPT_FLOAT) {\n\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n\n    } else if (po->flags & OPT_DOUBLE) {\n\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n\n    } else if (po->u.func_arg) {\n\n        int ret = po->u.func_arg(optctx, opt, arg);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR,\n\n                   \"Failed to set value '%s' for option '%s'\\n\", arg, opt);\n\n            return ret;\n\n        }\n\n    }\n\n    if (po->flags & OPT_EXIT)\n\n        exit_program(0);\n\n\n\n    return 0;\n\n}\n", "idx": 8425, "substitutes": {"optctx": ["optcontext", "optionctx", "optioncontext", "opctx", " optpkg", "opcontext", "optpkg", "optx", "oppkg", "optobj", " opttx", "optiontx", " optobj", "opobj", " optcontext", "optionobj", "optionpkg", "opttx"], "po": ["pro", "odo", "hea", "O", "co", "pr", "py", "no", "ote", "opa", "quote", "pp", "roo", "pre", "pe", "pg", "pt", "flo", "pot", "ano", "apo", "fo", "PO", "mo", "cu", "ico", "policy", "ho", "ao", "gro", "ota", "o", "obj", "pd", "pa", "jo", "ko", "cro", "oo", "pty", "mot", "go", "lo", "pm", "Po", "ctx", "aco", "oe", "yes", "vo", "pos", "ta", "pi", "bo", "pc", "yo", "cho", "ppo"], "opt": ["pr", "init", "off", "timeout", "cat", "attr", "tag", "ret", "op", "sp", "stat", "riot", "pot", "pt", "tip", "j", "usr", "OP", "crit", "other", "org", "lt", "feat", "buf", "obj", "nt", "img", "iter", "ost", "oop", "grad", "anon", "expr", "def", "lit", "ext", "var", "info", "urg", "term", "tx", "Opt", "ref", "rt", "og", "it", "oss", "prop", "pred", "txt", "t", "text", "kw", "option", "pkg", "alt", "orig", "spec", "msg", "jp", "cmd"], "arg": ["r", "ack", "conf", "mem", "tag", "attr", "ar", "v", "ret", "addr", "args", "vol", "op", "pack", "call", "mac", "j", "gt", "usr", "other", "agg", "val", "org", "help", "ax", "g", "event", "alg", "par", "parse", "ext", "param", "var", "arp", "urg", " targ", "arr", "asc", "ref", "reg", "argument", "Arg", "pat", "it", "req", " larg", "target", "ad", "star", "aux", "doc", "word", "orig", "ag", "msg", "cmd"], "dst": ["doost", "ddest", " dest", "edst", "dsp", "dosts", "Dnet", "dssrc", "duport", "dint", "dednd", "dssts", "Dint", "dast", "dbst", "Dist", "dnd", "duST", "dasts", "edost", "dnet", "Dnd", "dudest", "dbST", "diddest", "doST", "Dsts", "wdest", " dbl", " dstr", "didst", "dost", "dbirst", "Dsp", "daport", "dust", "delst", "Dest", "dlas", " dist", "dosp", "Dsrc", "dsbl", "dadest", "dsts", "dsstr", "didnd", "daost", "daynamic", "edST", " dirst", " dST", "didnet", "dolas", "dalas", "Dpt", "wist", "DST", "dstr", "dsest", "edlas", "dynamic", "dsst", "deirst", " dynamic", "dedst", " ddest", "dedest", "dirst", "dednet", "dbl", "daST", "delest", "dist", " dport", "delsts", "dsdest", "deddest", "dsrc", " dsrc", "daest", " dsp", "Dstr", "Dbl", "Dst", "wpt", "delynamic", "dpt", "deST", "dport", "dbdest", "wst", " dpt", "dST", " dint", "dest", "Ddest", " dsts", "daint"], "dstcount": ["dputlength", "dconstcount", " dstlength", "dsplength", "Dstlength", "dintlength", "dndcount", "dputpage", "destlength", " dconstCount", "dstreamctr", "destcount", "dstscount", " dstCount", "dsetctr", "dputcount", "dstrCount", "Dstrcount", "destamount", "dspCount", "DdestCount", "dstsCount", "Dstsamount", "dstCount", "ddestCount", "dstctr", "DstrCount", "dstpage", "Dstoffset", "dstreamCount", " dconstcount", "dstslength", "ddestoffset", "Dstsfind", "dsetCount", "Dstamount", "dndount", "distCount", "dstsamount", "dstreamoffset", "dstreamcount", "dcoslength", "dcoscount", "dconstCount", "dstoffset", "dintinfo", "dstsfind", "distfind", "destCount", "dcosCount", "dputCount", "dsetoffset", "dstrcount", "Ddestcount", "dconstpage", "Dstsinfo", "distcount", " dconstlength", "DstCount", "Dstscount", "dstamount", " dstpage", "Ddestctr", "dspcount", "Dstslength", "Dstount", "ddestpage", "Ddestoffset", "ddestlength", "dstsount", "Dstinfo", "Dstfind", "ddestcount", "Dstctr", "dndfind", "DstsCount", "dstfind", "Dstrlength", "dconstlength", "ddestctr", "dintCount", "dsetcount", "dstrlength", "Dstsount", "dstount", " dconstpage", "Dstcount", "dintcount", "dstlength", "distount", "dcosinfo", "dstinfo", "dndCount", "dspamount", "dstsinfo"], "so": ["pro", "sync", "co", "sw", "sty", "su", "goo", "iso", "sa", "ls", "sh", "sel", "sp", "pb", "oid", "sky", "fo", "mo", "cu", "ico", "SO", "sq", "o", "sm", "tmp", "sels", "sl", "soc", "since", "ost", "si", "st", "s", "sam", "bs", "os", "sie", "igh", "set", "lo", "So", "js", "go", "ssl", "yes", "ism", "mi", "sk", "sc", "loc", "stro", "osp", "cs", "bo", "se", "ski", "stri"], "p": ["r", "np", "wp", "imp", "lp", "i", "f", "pp", "v", "sp", "pb", "op", "tp", "dp", "pe", "l", "ps", "j", "u", "n", "xp", "o", "cp", "P", "a", "g", "b", "pa", "pun", "s", "ph", "q", "fp", "it", "c", "m", "t", "ip", "ping", "pkg", "ap", "vp", "php", "jp"], "str": ["r", "coll", "x", "pr", "dr", "sw", "cat", "f", "err", "v", "ret", "cont", "vol", "sp", "data", "name", "ps", "fr", "rep", "STR", "bl", "out", "n", "obj", "String", "buf", "enc", "print", "st", "s", "Str", "tr", "var", "arr", "set", "ns", "c", "txt", "text", "t", "star", "cs", "ctr", "spec", "w"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 8431, "substitutes": {"f": ["r", "p", "h", "bf", "conf", "cf", "elf", "i", "df", "fc", "ef", "l", "lf", "fr", "uf", "fb", "a", "fs", "b", "g", "file", "form", "d", "fm", "fd", "q", "af", "fe", "fp", "tf", "fi", "F", "m", "c", "t", "ile", "e", "fac", "w", "fw"], "pv": ["Pj", "pbvt", "Pvr", " pj", "ppvt", "pvr", "pbV", "ppV", "mpvt", "mpvr", "pV", "ppj", " pV", "mpV", "pbvr", "Pv", "mpv", "ppv", " pvt", "pbv", "pvt", "PV", "pj", "Pvt"], "size": [" offset", " space", " scale", " shr", " sh", " st", "length", " sized", "fee", " len", " sizes", " count", "space", "SIZE", " unused", " Size", "Size", "s", "_", "shape", " notice", "ize", "len", " enc", "e"], "v": ["r", "p", "av", "inv", "ev", "value", "i", "vol", "vr", "l", "j", "vm", "u", "n", "cv", "sv", "vt", "ov", "b", "g", "tv", "s", "iv", "y", "q", "vi", "V", "uv", "m", "c", "wire", "t", "nv", "vs", "lv", "vp", "w"]}}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 8435, "substitutes": {"cpu": ["util", "cli", "np", "proc", "CPU", "conn", "mem", "gpu", "docker", "upt", "onet", "jp", "cam", "tp", "stat", "processor", "nc", "gnu", "rpm", "cn", "vm", "ka", "cu", "dt", "cc", "java", "process", "bench", "device", "pai", "ctl", "cp", "pool", "core", "dh", "phys", "pu", "sys", "ctx", "hog", "aco", "bean", "c", "kernel", "disk", "nu", "ork", "apache", "xc", "clock", "gc", "pc", "hw", "socket", "linux", "cmd"], "ptex": ["onettex", "petEX", " ptpex", " ptEx", " uptx", "PTex", "PTtex", "ptonex", "iptex", "apttex", "ustex", "ptx", "countex", "ptexp", "petEx", "ipttex", "plrex", "ptpex", "ctEx", "pointEX", "pltex", "eptex", "countel", "aptEX", "counttex", "plex", "ctex", "ctEX", "ptexe", "PTexp", "iptEx", "countexp", "aptEx", "petexe", "ptontex", "pointEx", "onetex", " ptx", "PTel", "ptonrex", "usttex", "iptEX", "ptel", "ustEX", " uptpex", "iptpex", " uptEx", "aptex", "eptel", "ptEX", "ustEx", "iptx", "pttex", "ptEx", " uptex", "onetrex", "petex", "eptexp", "epttex", "pointex", "ctexe", "pointexe", "ptrex"], "avpn": ["avpa", "avp", "averpa", "ajpn", "abpc", "vrisen", "abpn", "vpn", "abPN", "ovpc", " avn", "ajpa", "Avpn", "svpc", " avpa", "Avp", "visen", "avisen", "avn", "averpc", "ajPN", "averpn", "vrpn", "ovpa", "svn", "svpn", "avpc", "vrPN", "avPN", "svpa", "ovpn", "AvPN", "ovPN", "abpa", "avern", "vPN", "ajpc", "Avisen", "vrp", " avpc"], "flags": ["options", "ts", "fps", "vals", "sets", "flag", "aps", "atts", "rs", "ff", "pins", "allows", "args", "settings", "pages", "ps", "heads", "fr", "tags", "lag", " Flags", "parts", "checks", "links", "abilities", "fs", "buff", "actions", "Flags", "values", "fl", "goal", "files", "ffff", "limits", "fields", "txt", "weights", "bits", "res", "mask", "features", "locks", "members", "ags", "wind", "vs", "wcs", "words", "assets", "cmd"], "vp": ["p", "av", "vim", "pr", "wp", "ev", "lp", "pb", "vr", "tp", "vP", "vg", "qv", "vert", "vm", "avi", "cv", "ve", "buf", "sv", "vt", "ov", "vv", "pes", "fp", "VP", "uv", "nv", "vu", "vs", "vc", "lv"], "rp": ["vrpc", " rpa", "rerpc", "rerpi", "rerp", "nrpc", "vrpa", "nrc", " rc", "rpa", "rc", "erp", " rpi", "vrsp", "nrp", "rerc", " rpc", "erpa", "nrpi", "ersp", "erpc", "rpi", "vrp", "rsp", "rpc", " rsp"], "env": ["ent", "dev", "conf", "ote", "conn", "proc", "ev", "eng", "next", "pe", "eni", "environment", "ef", "end", "entry", "priv", "ei", "en", "window", "lock", "ka", "dt", "worker", "org", "cv", "config", "buf", "obj", "server", "vt", "er", "net", "viron", "ec", "ext", "goal", "node", "EN", "set", "reset", "ctx", "home", "open", "ten", "target", "et", "buffer", "desktop", "db", "con", "den", "pkg", "context", "e", "ptr", "hw", "scope", "cmd"], "token": ["flag", "vector", "type", "json", "number", "seed", "lock", "trigger", "worker", "channel", "fn", "index", "to", "empty", "ok", "sid", "t", "template", "timer", "k", "factor", "util", "session", "value", "tree", "an", "WT", "handle", "field", "oken", "txt", "buffer", " Token", "table", "word", "annot", "or", "prototype", "span", "typ", "id", "tool", "TO", "at", "oin", "label", "o", "ak", "time", "pointer", "mt", "s", "tick", "node", "error", "ts", "ens", "list", "KEN", "next", "kn", "ion", "tn", "key", "Token", "event", "offset", "wt", "kt", "normal", "message", "ant", "zero"], "v": ["p", "av", "h", "inv", " ov", "x", "pr", " w", "ev", "value", "rev", "f", "i", "vr", " av", "version", "vP", "l", "ver", "j", "qv", "vert", "vm", "val", "va", "u", " tv", "ve", "cv", "n", " V", "sv", " sv", "vt", "vv", "ov", "b", "values", "tv", "iv", "vi", "V", "uv", "m", "c", "t", "vo", "nv", "vu", "vs", "lv", "vc", "e", "w", "conv"], "r": ["p", "h", "pr", "cr", "hr", "rs", "i", "rr", "ar", "vr", "re", "rf", "l", "R", "j", "nr", "reb", "sr", "rc", "rm", "u", "rg", "ru", "n", "b", "er", "d", "ur", "tr", "ro", "rt", "q", "mr", "rar", "br", "rn", "rx", "c", "res", "rw", "e", "w", "rd"], "rb": ["RB", "p", "cb", "sb", "bin", "rs", "lp", "rr", "nb", "pb", "vr", "re", "rh", "rf", "erb", "lr", "bb", "nr", "reb", "rob", "fb", "rc", "rm", "rg", "ru", "rl", "xb", "rub", "b", "ro", "rt", "gb", "mr", "br", "wb", "binary", "db", "rw", "ruby", "lb", " RB", "rd"]}}
{"project": "qemu", "commit_id": "33848ceed79679b5c9e558b768447af2614b8db2", "target": 1, "func": "int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size)\n\n{\n\n    PCIExpressDevice *exp;\n\n\n\n    pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER,\n\n                        offset, size);\n\n    exp = &dev->exp;\n\n    exp->aer_cap = offset;\n\n\n\n    /* log_max is property */\n\n    if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) {\n\n        dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT;\n\n    }\n\n    /* clip down the value to avoid unreasobale memory usage */\n\n    if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) {\n\n        return -EINVAL;\n\n    }\n\n    dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] *\n\n                                        dev->exp.aer_log.log_max);\n\n\n\n    pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SEVERITY_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS,\n\n                               PCI_ERR_COR_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_MASK_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_SUPPORTED);\n\n\n\n    /* capabilities and control. multiple header logging is supported */\n\n    if (dev->exp.aer_log.log_max > 0) {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC |\n\n                     PCI_ERR_CAP_MHRC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE |\n\n                     PCI_ERR_CAP_MHRE);\n\n    } else {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\n    }\n\n\n\n    switch (pcie_cap_get_type(dev)) {\n\n    case PCI_EXP_TYPE_ROOT_PORT:\n\n        /* this case will be set by pcie_aer_root_init() */\n\n        /* fallthrough */\n\n    case PCI_EXP_TYPE_DOWNSTREAM:\n\n    case PCI_EXP_TYPE_UPSTREAM:\n\n        pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL,\n\n                                   PCI_BRIDGE_CTL_SERR);\n\n        pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS,\n\n                                   PCI_SEC_STATUS_RCV_SYSTEM_ERROR);\n\n        break;\n\n    default:\n\n        /* nothing */\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8447, "substitutes": {"dev": ["wd", "DEV", "ev", "vision", "de", "pack", "data", "cam", "end", "ver", "stick", "buf", "des", "d", "history", "def", "var", "go", "sys", "Device", "ad", "db", "den", "w", "cmd", "util", "av", "develop", "conf", "prov", "Dev", "mem", "comment", "dd", "tech", "priv", "env", "raw", "ve", "serv", "app", "scan", "info", "package", "desc", "req", "draw", "port", "van", "off", "conn", "serial", "pad", "window", "nt", "server", "cast", "dem", "ow", "unknown", "gu", "ctx", "home", "prop", "prom", "any", "hw", "pro", "watch", "feature", "eng", "v", "usb", "debug", "device", "devices", "form", "adv", "disk", "normal", "spec"], "offset": ["snap", "metadata", "data", "seed", "shift", "align", "buf", "count", "index", "crop", "ref", "batch", "loc", "pkg", "ptr", "item", "cmd", "pixel", "attr", "addr", "offer", "env", "order", "config", "seek", "bound", "handle", "attribute", "set", "trace", "Offset", "req", "port", "p", "init", "off", "slot", "job", "hop", "id", "location", "entry", "pad", "padding", "start", "scroll", "position", "slice", "out", "pointer", "prefix", "offs", "style", "header", "ctx", "alias", "mask", " offsets", "length", "timeout", "from", "alloc", "origin", "pool", "encrypted", "queue", "reset", "pos", "point", "option", "client", "image", "address", "delay"], "size": ["send", "no", "mem", "amount", "sh", "sp", "z", "fee", "padding", "capacity", "scroll", "ose", "shift", "space", "total", "count", "seek", "gz", "Size", "bytes", "dim", "what", "shape", "empty", "sn", "set", "ize", "body", "sum", "len", "fit", "SIZE", "length"]}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 8457, "substitutes": {"cpu": ["cli", "runner", "instance", "np", "tc", "program", "thread", "total", "cp", "remote", "cache", "parse", "que", "c", "current", "panic", "ruby", "pkg", "mu", "jp", "cmd", "util", "sync", "mem", "gpu", "docker", "python", "boot", "cu", "nic", "bench", "core", "uu", "efficiency", "performance", "pu", "aco", "kernel", "coin", "clock", "aux", "cn", "linux", "CPU", "lp", "ck", "frame", "cow", "command", "gnu", "cum", "component", "process", "execute", "prefix", "copy", "phys", "cmp", "ctx", "currency", "chip", "gc", "pc", "profile", "hw", "computer", " CPU", "proc", "du", "tp", "crypt", "processor", "mac", "ilo", "pool", "prof", "net", "goal", "queue", "reset", "ip", "num", "console", "po", "lib"], "thread_name": ["thread_Name", "template_names", "thread_str", "thread_names", "template_size", "threaditysize", "threadNamenames", "template_class", "thread1Name", "thread1info", "threadNameclass", "thread_info", "threaditynames", "template_url", "threadityurl", "thread1name", "thread_url", "template_name", "threadNamestr", "threadNamename", "threadityname", "thread_class", " thread_info", "template_str", " thread_Name", "thread_size"], "tcg_halt_cond": ["tcg_hall_compl", "tcg_hatal_cond", "tcg_halt_Cond", "tcg_hall___compl", "tcg_halt_pos", "tcg_halt___Cond", "tcg_halt___compl", "tcg_halt_condition", "tcg_hatal_func", "tcg_hall___cond", "tcg_hall_cond", "tcg_halt_func", "tcg_halt__compl", "tcg_halt2lock", "tcg_hall___Cond", "tcg_halt2cond", "tcg_halt___cond", "tcg_hal_lock", "tcg_hall___condition", "tcg_halt__condition", "tcg_hal_condition", "tcg_halt2condition", "tcg_hatal_compl", "tcg_hatal_pos", "tcg_halt_lock", "tcg_halt___condition", "tcg_hall_Cond", "tcg_hall_condition", "tcg_hal_Cond", "tcg_halt__cond", "tcg_halt_compl", "tcg_hal_cond", "tcg_halt__Cond", "tcg_halt2Cond"], "tcg_cpu_thread": ["tcg_core___loop", "tcg_cpu__process", "tcg_processor___thread", "tcg_processor___host", "tcg_pu_type", "tcg_cpu_ready", "tcg_cpu___host", "tcg_pu_ready", "tcg_processor_host", "tcg_pu_process", "tcg_processor___old", "tcg_pu_port", "tcg_cpu___task", "tcg_processor_loop", "tcg_cpu_type", "tcg_core_process", "tcg_cpu2lock", "tcg_cpu_task", "tcg_cpu_host", "tcg_cpu_process", "tcg_cpu2port", "tcg_cpu_old", "tcg_cpu_lock", "tcg_core___process", "tcg_cpu___loop", "tcg_cpu2process", "tcg_cpu__type", "tcg_cpu__thread", "tcg_processor_old", "tcg_cpu___thread", "tcg_cpu__ready", "tcg_processor___loop", "tcg_pu_thread", "tcg_processor_thread", "tcg_cpu___old", "tcg_core___thread", "tcg_cpu_port", "tcg_core___task", "tcg_cpu___process", "tcg_core_loop", "tcg_core_task", "tcg_cpu2thread", "tcg_cpu_loop", "tcg_core_thread", "tcg_pu_lock"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n", "idx": 8466, "substitutes": {"vs": ["ts", "ports", "lines", "changes", "caps", "inv", "vals", "ses", "rs", "blogs", "v", "ls", "vr", "ss", "es", "lists", "pages", "settings", "obs", "vers", "ps", "xs", "gs", "vm", "VS", "sts", "links", "sv", "vt", "fs", "values", "s", "ms", "times", "ks", "js", "Vs", "ds", "verts", "stats", "vd", "vc", "cs", "vp", "wcs", "bs", "qs", "ns"], "data": ["p", "DATA", "bin", "mem", "ata", "end", " DATA", "str", "Data", "trans", "map", " Data", "window", "new", "ops", "error", "raw", "device", "out", "buf", "obj", "size", "as", "d", "form", "file", "bytes", "cache", "dat", "def", "empty", "bus", "box", "text", "buffer", "ad", "rew", "batch", "block", "base", "table", "res", "len", "message", "aw", "mu", "msg", "rel"], "datalen": [" dallize", " dalen", "dallist", "Datalength", "datalize", "dalist", "datalist", "dalen", "datalim", "dallyen", " dalength", "dalize", "dalloc", "davalim", "davaloc", " dalah", "datlength", "davalen", " datalah", "dallim", "Datalen", "dalength", " datalize", "Datalim", " dallen", " dallist", "datlen", "daloc", "datalah", "Dalen", "dallyah", "davalength", "Dalength", "dallen", "dulun", "datalun", "dallyength", " dallength", " dalun", "dalun", "dataloc", " datalun", "dallyun", "dalim", "dulen", "dulah", " datalength", "Dalim", "datlist", "datlize", "datalength", " datalist", "dulength", "Daloc", "Dataloc", "dallize", "dalah", "dallength"], "ret": ["r", "ts", "done", "limit", "pas", "no", "RET", "flag", "red", "mem", "cat", "rs", "f", "err", " Ret", "read", "sp", "re", "__", "result", "j", "gt", "Ret", " RET", "ert", "val", "run", "rem", "out", "nt", "buf", "rets", "back", "print", "mt", "st", "match", "def", "tr", "info", "rt", "ref", "reset", "ort", "fi", "fin", "txt", "t", "num", "status", "res", "port", "sum", "len", "got", "resp", "db", "alt", "gc", "Return", "arg"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static av_cold int decode_init(AVCodecContext * avctx)\n\n{\n\n    MPADecodeContext *s = avctx->priv_data;\n\n    static int init=0;\n\n    int i, j, k;\n\n\n\n    s->avctx = avctx;\n\n\n\n    ff_mpadsp_init(&s->mpadsp);\n\n\n\n    avctx->sample_fmt= OUT_FMT;\n\n    s->error_recognition= avctx->error_recognition;\n\n\n\n    if (!init && !avctx->parse_only) {\n\n        int offset;\n\n\n\n        /* scale factors table for layer 1/2 */\n\n        for(i=0;i<64;i++) {\n\n            int shift, mod;\n\n            /* 1.0 (i = 3) is normalized to 2 ^ FRAC_BITS */\n\n            shift = (i / 3);\n\n            mod = i % 3;\n\n            scale_factor_modshift[i] = mod | (shift << 2);\n\n        }\n\n\n\n        /* scale factor multiply for layer 1 */\n\n        for(i=0;i<15;i++) {\n\n            int n, norm;\n\n            n = i + 2;\n\n            norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1);\n\n            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRAC_BITS);\n\n            av_dlog(avctx, \"%d: norm=%x s=%x %x %x\\n\",\n\n                    i, norm,\n\n                    scale_factor_mult[i][0],\n\n                    scale_factor_mult[i][1],\n\n                    scale_factor_mult[i][2]);\n\n        }\n\n\n\n        RENAME(ff_mpa_synth_init)(RENAME(ff_mpa_synth_window));\n\n\n\n        /* huffman decode tables */\n\n        offset = 0;\n\n        for(i=1;i<16;i++) {\n\n            const HuffTable *h = &mpa_huff_tables[i];\n\n            int xsize, x, y;\n\n            uint8_t  tmp_bits [512];\n\n            uint16_t tmp_codes[512];\n\n\n\n            memset(tmp_bits , 0, sizeof(tmp_bits ));\n\n            memset(tmp_codes, 0, sizeof(tmp_codes));\n\n\n\n            xsize = h->xsize;\n\n\n\n            j = 0;\n\n            for(x=0;x<xsize;x++) {\n\n                for(y=0;y<xsize;y++){\n\n                    tmp_bits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j  ];\n\n                    tmp_codes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++];\n\n                }\n\n            }\n\n\n\n            /* XXX: fail test */\n\n            huff_vlc[i].table = huff_vlc_tables+offset;\n\n            huff_vlc[i].table_allocated = huff_vlc_tables_sizes[i];\n\n            init_vlc(&huff_vlc[i], 7, 512,\n\n                     tmp_bits, 1, 1, tmp_codes, 2, 2,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_vlc_tables));\n\n\n\n        offset = 0;\n\n        for(i=0;i<2;i++) {\n\n            huff_quad_vlc[i].table = huff_quad_vlc_tables+offset;\n\n            huff_quad_vlc[i].table_allocated = huff_quad_vlc_tables_sizes[i];\n\n            init_vlc(&huff_quad_vlc[i], i == 0 ? 7 : 4, 16,\n\n                     mpa_quad_bits[i], 1, 1, mpa_quad_codes[i], 1, 1,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_quad_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_quad_vlc_tables));\n\n\n\n        for(i=0;i<9;i++) {\n\n            k = 0;\n\n            for(j=0;j<22;j++) {\n\n                band_index_long[i][j] = k;\n\n                k += band_size_long[i][j];\n\n            }\n\n            band_index_long[i][22] = k;\n\n        }\n\n\n\n        /* compute n ^ (4/3) and store it in mantissa/exp format */\n\n\n\n        int_pow_init();\n\n        mpegaudio_tableinit();\n\n\n\n        for (i = 0; i < 4; i++)\n\n            if (ff_mpa_quant_bits[i] < 0)\n\n                for (j = 0; j < (1<<(-ff_mpa_quant_bits[i]+1)); j++) {\n\n                    int val1, val2, val3, steps;\n\n                    int val = j;\n\n                    steps  = ff_mpa_quant_steps[i];\n\n                    val1 = val % steps;\n\n                    val /= steps;\n\n                    val2 = val % steps;\n\n                    val3 = val / steps;\n\n                    division_tabs[i][j] = val1 + (val2 << 4) + (val3 << 8);\n\n                }\n\n\n\n\n\n        for(i=0;i<7;i++) {\n\n            float f;\n\n            INTFLOAT v;\n\n            if (i != 6) {\n\n                f = tan((double)i * M_PI / 12.0);\n\n                v = FIXR(f / (1.0 + f));\n\n            } else {\n\n                v = FIXR(1.0);\n\n            }\n\n            is_table[0][i] = v;\n\n            is_table[1][6 - i] = v;\n\n        }\n\n        /* invalid values */\n\n        for(i=7;i<16;i++)\n\n            is_table[0][i] = is_table[1][i] = 0.0;\n\n\n\n        for(i=0;i<16;i++) {\n\n            double f;\n\n            int e, k;\n\n\n\n            for(j=0;j<2;j++) {\n\n                e = -(j + 1) * ((i + 1) >> 1);\n\n                f = pow(2.0, e / 4.0);\n\n                k = i & 1;\n\n                is_table_lsf[j][k ^ 1][i] = FIXR(f);\n\n                is_table_lsf[j][k][i] = FIXR(1.0);\n\n                av_dlog(avctx, \"is_table_lsf %d %d: %x %x\\n\",\n\n                        i, j, is_table_lsf[j][0][i], is_table_lsf[j][1][i]);\n\n            }\n\n        }\n\n\n\n        for(i=0;i<8;i++) {\n\n            float ci, cs, ca;\n\n            ci = ci_table[i];\n\n            cs = 1.0 / sqrt(1.0 + ci * ci);\n\n            ca = cs * ci;\n\n            csa_table[i][0] = FIXHR(cs/4);\n\n            csa_table[i][1] = FIXHR(ca/4);\n\n            csa_table[i][2] = FIXHR(ca/4) + FIXHR(cs/4);\n\n            csa_table[i][3] = FIXHR(ca/4) - FIXHR(cs/4);\n\n            csa_table_float[i][0] = cs;\n\n            csa_table_float[i][1] = ca;\n\n            csa_table_float[i][2] = ca + cs;\n\n            csa_table_float[i][3] = ca - cs;\n\n        }\n\n\n\n        /* compute mdct windows */\n\n        for(i=0;i<36;i++) {\n\n            for(j=0; j<4; j++){\n\n                double d;\n\n\n\n                if(j==2 && i%3 != 1)\n\n                    continue;\n\n\n\n                d= sin(M_PI * (i + 0.5) / 36.0);\n\n                if(j==1){\n\n                    if     (i>=30) d= 0;\n\n                    else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0);\n\n                    else if(i>=18) d= 1;\n\n                }else if(j==3){\n\n                    if     (i<  6) d= 0;\n\n                    else if(i< 12) d= sin(M_PI * (i -  6 + 0.5) / 12.0);\n\n                    else if(i< 18) d= 1;\n\n                }\n\n                //merge last stage of imdct into the window coefficients\n\n                d*= 0.5 / cos(M_PI*(2*i + 19)/72);\n\n\n\n                if(j==2)\n\n                    mdct_win[j][i/3] = FIXHR((d / (1<<5)));\n\n                else\n\n                    mdct_win[j][i  ] = FIXHR((d / (1<<5)));\n\n            }\n\n        }\n\n\n\n        /* NOTE: we do frequency inversion adter the MDCT by changing\n\n           the sign of the right window coefs */\n\n        for(j=0;j<4;j++) {\n\n            for(i=0;i<36;i+=2) {\n\n                mdct_win[j + 4][i] = mdct_win[j][i];\n\n                mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1];\n\n            }\n\n        }\n\n\n\n        init = 1;\n\n    }\n\n\n\n    if (avctx->codec_id == CODEC_ID_MP3ADU)\n\n        s->adu_mode = 1;\n\n    return 0;\n\n}\n", "idx": 8482, "substitutes": {"avctx": ["avecb", "averctl", "avecfg", "AVcontext", " avcp", "vrcontext", "auxctx", "avcmd", "avercontext", "vrobj", "vctx", "avecontext", "devcu", " avcm", "avercb", "afcontext", " avtmp", "vrcm", "abcb", "afcmd", "abctx", "avercfg", "avtx", "avercp", "abdata", "avcp", "abcontext", "averctx", "afobj", "AVjp", "vrctx", "AVctx", " avtx", "avectx", "devctx", "avdata", "avjp", "afctx", "AVdata", "abjp", "avectl", "avobj", " avobj", "avercm", "averobj", "averjp", "abtx", "avcfg", "avercmd", "avcb", "avctl", "airjp", "avcontext", " avctl", "vdata", "vcontext", "avetmp", "avcu", "avertmp", " avcfg", "vjp", " avcu", "devtx", " avcontext", "airctx", "aircontext", " avcb", "aircp", "devcontext", " avjp", "auxcu", "avcm", "avetx", " avcmd", "avtmp", "auxtx", "auxcontext"], "s": ["self", "ts", "p", "sb", "ats", "rs", "ls", "ss", "its", "es", "ps", "gs", "aws", "sts", "sq", "sv", "fs", "is", "b", "bs", "os", "set", "js", "sys", "ctx", "stats", "ds", "ssl", "hs", "m", "S", "c", "t", "utils", "spec", "services", "vs", "ms", "ns"], "i": ["ami", "cli", "ind", "ix", "iu", "u", "bi", "print", "history", "index", "to", "li", "go", "iat", "\u0438", "c", "this", "io", "t", "ti", "iii", "gi", "ic", "name", "ei", "I", "phi", "ik", "ie", "info", "q", "it", "qi", "mi", "ij", "status", "ki", "ims", "me", "ui", "p", "span", "yi", "uri", "id", "l", "xi", "sim", "oi", "at", "multi", "slice", "o", "is", "b", "g", "ini", "ia", "chain", "pi", "r", "di", "list", "ri", "ai", "ii", "ji", "key", "in", "hi", "si", "module", "m", "zi", "ip", "point", "im"], "j": ["p", "aj", "jj", "jc", "jump", "z", "l", "ji", "jac", "bi", "o", "b", "kj", "g", "q", "js", "J", "m", "c", "pos", "jl", "ij", "uj", "jp"], "k": ["p", "km", "z", "l", "ka", "ik", "key", "u", "o", "ak", "g", "ko", "mk", "kk", "q", "ok", "max", "K", "it", "m", "c", "sk", "kw", "ki", "w"], "offset": ["ui", "limit", "skip", "off", "slot", "id", "location", "pad", "padding", "ii", "seed", "command", "start", "window", "lock", "position", "align", "ix", "key", "origin", "o", "size", "seek", "pointer", "load", "si", "index", "scale", "info", "attribute", "ian", "reset", "Offset", "ip", "pos", "buffer", "mask", "loc", "base", "point", "table", "option", "address", "error"], "shift": ["p", "step", "off", "Shift", "fix", "sh", "sup", "z", "seed", "tip", "trans", "command", "start", "small", "mix", "ix", "align", "share", "sq", "size", "seek", "diff", "load", "transform", "scale", "shr", "index", "push", "tr", "sign", "set", "q", "hash", "hift", "ize", "m", "power", "mask", "prime", "w"], "mod": ["r", "step", "mm", "od", "off", "fun", "med", "mult", "cm", "perm", "modified", " Mod", "z", "add", "pad", "trans", "sim", "deg", "Mod", "mix", "small", "md", "scale", "MOD", "sign", "min", "tr", "bit", "set", "lex", "module", "m", "sum", "mask", "loc", "mods", "im", "prime", "mode", "sub", "ms", "rot"], "n": ["p", "nn", "on", "np", "nb", "ng", "z", "N", "l", "na", "en", "pn", "all", "u", "out", "nl", "ni", "nt", "o", "ne", "nm", "nan", "size", "gn", "g", "sn", "note", "dn", "nor", "m", "c", "t", "num", "len", "nu", "w", "mn", "cn", "ns"], "norm": ["orth", "lim", "sync", "dist", "common", "nom", " norms", "inv", "nd", "dev", "np", "fun", "mem", "unit", "Norm", "err", "iso", "known", "loss", "nb", "NOR", "str", "low", "na", "deg", "non", "raw", "all", "nt", "nm", "ne", "diff", "net", "form", "orm", "scale", "none", "Normal", "adj", "vec", "prop", "ann", "req", "num", "sum", "res", "nu", "loc", "normal", "base", "nv", "iz", "orig", "nor", "mn", "rel"], "h": ["r", "p", "hp", "l", "u", "o", "H", "a", "g", "b", "oh", "ht", "cache", "ch", "q", "hash", "header", "m", "c", "t", "w"], "xsize": ["rxSize", "txsize", "xSIZE", "Xcount", "rxcount", "txcount", "XSIZE", "txSize", "xcount", "rxSIZE", "txSIZE", "Xsize", "xSize", "XSize", "rxsize"], "x": ["p", "X", "dx", "xy", "px", "z", "l", "height", "xs", "xi", "ix", "ex", "o", "size", "index", "tx", "rx", "m", "c", "w"], "y": ["p", "py", "yi", "xy", "z", "height", "l", "ey", "key", "iy", "o", "b", "yy", "ch", "Y", "yt", "m", "c", "t", "yl", "sy", "col"], "tmp_bits": ["tmp_batch", "tmpablebatch", "mp_keys", "tmp2its", "tmpablebytes", "tmp___bit", "tmp___bytes", "tmp_bytes", "tmp_tops", "mp_bits", " tmp_tops", "tmp2codes", "tmp2bytes", "mp_codes", "mp_batch", "mp_bytes", "tmp2bits", "mp_its", "tmp___keys", "tmpablekeys", "tmp___tops", " tmp_bit", "tmpablebits", "tmp_keys", "tmp___bits", "tmp___batch", " tmp_bytes", "tmp_bit", "tmp_its"], "tmp_codes": ["tmp_code", "tmp8code", "tmp_xy", "tmp8names", "mp_names", "mp_code", "tmp8codes", "mp_xy", "mp_codes", "tmp8xy", "tmp5xy", "tmp5names", "tmp_names", "tmp5code", "tmp5codes"]}}
{"project": "FFmpeg", "commit_id": "480324e7ca0b87105fd7ee168292a0d5692af128", "target": 0, "func": "static int libgsm_decode_frame(AVCodecContext *avctx,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt) {\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);\n\n\n\n    if (*data_size < out_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (buf_size < avctx->block_align) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch(avctx->codec_id) {\n\n    case CODEC_ID_GSM:\n\n        if(gsm_decode(avctx->priv_data,buf,data)) return -1;\n\n        break;\n\n    case CODEC_ID_GSM_MS:\n\n        if(gsm_decode(avctx->priv_data,buf,data) ||\n\n           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;\n\n    }\n\n\n\n    *data_size = out_size;\n\n    return avctx->block_align;\n\n}\n", "idx": 8487, "substitutes": {"avctx": ["wavtx", "avecfg", "avjac", "avecp", "aveparams", "vrcmp", "AVcontext", "wavstate", "avepkg", " avcp", "avercontext", "avecontext", "avparams", "avejp", "wavctr", "ajctx", "ajconf", "avercb", "afcontext", "avertxt", "AVctl", "afcb", "averkw", "ajjp", "wavctx", "wavconf", "avercfg", "avtx", "avecmp", "wavcmp", "avcp", "afstate", "averctx", "avcmp", "avkw", "avstate", "wavcontext", "afjac", "vrctx", "AVctx", "wavjac", " avtx", "avpkg", "avectx", "wavctl", "ajjac", "averjac", "afctx", "avjp", "avesys", "avercand", "avconf", "averjp", "ajtxt", "averparams", "wavcu", "ajsys", "avectr", "afctr", "avejac", "avctr", "airjac", "avetxt", "avcfg", " avjac", "aftx", "avcb", "avctl", "aveconf", "avcontext", "wavcand", " avctl", "AVtx", "avekw", "avcu", "averstate", "vrpkg", "wavcfg", "averconf", "avecand", "wavpkg", " avcontext", "avsys", "airctx", "avertx", "ajparams", "aircontext", "vrcu", " avcb", "avtxt", "aversys", "aircp", "avetx", "avcand", "avecu", "wavkw"], "data": ["done", "p", "extra", "no", "DATA", "bin", "value", "type", "addr", "ata", "id", "frame", "name", "pad", "str", " DATA", "Data", "sample", "result", "padding", "feed", "window", "ops", "new", "content", "raw", "error", "size", "da", "nt", "area", "d", "bytes", "cache", "win", "dat", "def", "one", "empty", "package", "input", "none", "offset", "m", "this", "text", "t", "buffer", "len", "res", "batch", "block", "any", "action", "message", "valid", "mid", "mu", "aw", "image", "results", "length", "zero", "msg", "rel"], "data_size": ["dataptpath", "dataptsize", "data_scale", "dataptsent", "dataaxypath", "data_count", "block_len", "block_path", "block_Size", "data_path", "dataaxysent", "data_len", "dataaxyscale", "data_sent", "block_count", "dataptscale", "block_scale", "block_size", "block_sent", "data_Size", "dataaxysize", " data_align", "data_SIZE", " data_SIZE", "data_align", "data_length", " data_length"], "avpkt": ["avenpkt", "avepkt", "avwpct", "avPacket", "avnpft", "avpck", "avepdt", "avewpkt", "avcpkt", "avenpft", "avbpkt", "avvpk", "avbpacket", "ajvpk", "ajvpacket", "avcpacket", "avepct", "avPkt", "avvpkt", "avewpdt", "avwpkt", "avepacket", "avepck", "avcpdt", "avenpct", "avbpk", "avewpacket", "avPkat", "avepft", "ajvpkat", "avpft", "avpkat", "avnpck", "avpk", "avvpkat", "avewpct", "ajpk", "avPk", "avpdt", "ajpkt", "ajpkat", "ajpacket", "avenpck", "avwpdt", "avnpkt", "avnpct", "avvpacket", "avPdt", "avpct", "avpacket", "avwpacket", "avPft", "avPck", "avbpkat", "ajvpkt", "avcpct", "avPct"], "buf": ["p", "func", "limit", "done", "cb", "aka", "seq", "mem", "xy", "coord", "cap", "err", "ff", "ata", "alloc", "cur", "bc", "uf", "map", "window", "good", "broad", "raw", "pipe", "cv", "temp", "pool", "tmp", "bh", "buff", "b", "dat", "empty", "queue", "ctx", "Buff", "home", "br", "vec", "wb", "box", "buffer", "batch", "block", "loc", "db", "rb", "pkg", "xff", "msg", "doc", "orig", "water", "ptr", "Buffer", "img", "cmd"]}}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "func": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n", "idx": 8518, "substitutes": {"mr": ["r", "MT", "rer", "pr", "hr", "yr", "rs", "irm", "rr", "hm", "vr", "Mr", "fr", "Rs", "lr", "rpm", "usr", "nr", "ml", "rm", "sr", "rg", "rl", "rd", "older", "nm", "RM", "md", "fm", "mt", "gm", "rar", "kr", "adr", "rn", "mc", "m", "br", "rb", "ocr", "MR", "asm", "wcs", "ctr", "ims", "ms", "bm", "mn", "drm"], "l": ["r", "p", "limit", "ld", "tl", "list", "h", "x", "pl", "lp", "f", "i", "v", "ls", "z", "ul", "j", "ln", "lr", "dl", "lc", "val", "ml", "u", "nl", "lt", "n", "lam", "las", "lu", "sl", "g", "b", "d", " L", "el", "s", "lit", "li", "hl", "lis", "ly", "m", "c", "t", "len", "loc", "ll", "L", "lv", "e", "le", "length", "il"], "addr": ["r", "ld", "x", "h", "dr", "init", "rs", "eth", "i", "err", "v", " address", "z", "__", "add", "name", "pad", "map", "lr", "align", " ptr", "at", "nl", "size", "a", "src", "work", "mb", "mt", "dh", "ext", "act", "ha", "arr", "hl", "Address", "hash", "ref", "max", "offset", "inter", "adr", " r", "gate", "wire", "ip", "alias", "len", "res", "asm", "ord", "ptr", "address", "w"]}}
{"project": "qemu", "commit_id": "d6b6abc51dda79a97f2c7bd6652c1940c068f1ec", "target": 1, "func": "void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,\n\n                              FWCfgCallback select_cb,\n\n                              FWCfgWriteCallback write_cb,\n\n                              void *callback_opaque,\n\n                              void *data, size_t len, bool read_only)\n\n{\n\n    int i, index, count;\n\n    size_t dsize;\n\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n\n    int order = 0;\n\n\n\n    if (!s->files) {\n\n        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);\n\n        s->files = g_malloc0(dsize);\n\n        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);\n\n    }\n\n\n\n    count = be32_to_cpu(s->files->count);\n\n    assert(count < fw_cfg_file_slots(s));\n\n\n\n    /* Find the insertion point. */\n\n    if (mc->legacy_fw_cfg_order) {\n\n        /*\n\n         * Sort by order. For files with the same order, we keep them\n\n         * in the sequence in which they were added.\n\n         */\n\n        order = get_fw_cfg_order(s, filename);\n\n        for (index = count;\n\n             index > 0 && order < s->entry_order[index - 1];\n\n             index--);\n\n    } else {\n\n        /* Sort by file name. */\n\n        for (index = count;\n\n             index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;\n\n             index--);\n\n    }\n\n\n\n    /*\n\n     * Move all the entries from the index point and after down one\n\n     * to create a slot for the new entry.  Because calculations are\n\n     * being done with the index, make it so that \"i\" is the current\n\n     * index and \"i - 1\" is the one being copied from, thus the\n\n     * unusual start and end in the for statement.\n\n     */\n\n    for (i = count + 1; i > index; i--) {\n\n        s->files->f[i] = s->files->f[i - 1];\n\n        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);\n\n        s->entries[0][FW_CFG_FILE_FIRST + i] =\n\n            s->entries[0][FW_CFG_FILE_FIRST + i - 1];\n\n        s->entry_order[i] = s->entry_order[i - 1];\n\n    }\n\n\n\n    memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n\n    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n\n\n\n    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n\n    for (i = 0; i <= count; i++) {\n\n        if (i != index &&\n\n            strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n\n            error_report(\"duplicate fw_cfg file name: %s\",\n\n                         s->files->f[index].name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,\n\n                              select_cb, write_cb,\n\n                              callback_opaque, data, len,\n\n                              read_only);\n\n\n\n    s->files->f[index].size   = cpu_to_be32(len);\n\n    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);\n\n    s->entry_order[index] = order;\n\n    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);\n\n\n\n    s->files->count = cpu_to_be32(count+1);\n\n}\n", "idx": 8522, "substitutes": {"s": ["changes", "sb", "ses", "events", "ls", "sh", "aws", "comm", "sv", "d", "bis", "js", "sys", "t", "state", "ms", "se", "w", "ns", "ins", "less", "h", "ats", "sw", "qs", "ges", "settings", "ps", "parts", "sq", "fs", "sl", "stats", "ds", "ssl", "utils", "services", "vs", "cs", "ims", "gets", "ports", "p", "sa", "sp", "its", "l", "tests", "store", "is", "b", "os", "y", "hs", "styles", "ares", "spec", "results", "r", "ts", "these", "rs", "f", "v", "ss", "es", "als", "gs", "j", "sts", "n", "service", "actions", "views", "details", "states", "S", "items", "bs", "sports"], "filename": ["ren", "p", "ames", "til", "directory", "Filename", "fil", "f", "subject", "v", "typ", "name", "title", "location", "jpg", "fr", "username", "family", "sbm", "key", "n", "buf", "o", "nm", "src", "prefix", "fn", "file", "kj", "fd", "path", "nil", "files", "fp", "fle", "ame", "txt", "text", "t", "buffer", "nu", "wcs", "ename", "length", "cmd"], "select_cb": ["selectingcallback", "select_cmd", "select_callback", "selectingcv", " select_callback", "selectingcb", "selectingcmd", " select_cv", "select_cv", " select_cmd"], "write_cb": [" write_CB", "writeolycb", "writeolyinfo", "write_callback", "write_CB", "write_info", " write_callback", "writeolycallback", "writeolyCB", " write_info"], "callback_opaque": ["callback___epaque", "callback___opened", "callback___opaque", "callback___epen", "callback_epula", "callback_epen", "callback_openened", "callback_popula", "callback_openen", "callback___epula", "callback___epened", "callback_opened", "callback_popened", "callback_epaque", "callback_opula", "callback___opula", "callback_epened", "callback_openula", "callback_popaque", "callback___open", "callback_openaque", "callback_popen", "callback_open"], "data": ["done", "writer", "extra", "DATA", "bin", "value", "next", "ata", "format", "name", "result", "Data", "window", "out", "buf", "size", "area", "d", "cache", "info", "buffer", "batch", "block", "memory", "message", "image"], "len": ["h", "seq", "fun", "bin", "ls", "addr", "args", "Len", "length", "name", "l", "ln", "en", "buf", "size", "file", "bytes", "path", "cmp", "ref", "offset", "fin", "vec", "pos", "ll", "lib"], "read_only": ["readonlyonly", "readonlyenabled", "load_only", "read_enabled", "readonlywrite", "load_Only", "readableOnly", "readonlyOnly", "read_Only", "load_enabled", "readableenabled", "load_write", "readablewrite", "read_write", "readableonly"], "i": ["r", "di", "p", "ui", "cli", "x", "init", "instance", "span", "f", "v", "gi", "ri", "id", "ai", "ic", " ii", "iq", "ind", "name", "ei", "ii", "xi", "j", "sim", "I", "phi", "ix", "iu", "all", "order", "multi", "slice", "u", "bi", "n", "ice", "me", "in", "iter", "b", "is", "si", "li", "info", "y", "ini", "iat", "fi", "it", "ci", "c", "m", "t", "ile", "mi", "qi", "ip", "status", "ti", "point", "im", "ij", "pi", "ims", "zi"], "index": ["update", "x", "no", "instance", "condition", "rank", "number", "when", "ind", "end", "axis", "capacity", "interface", "mix", "ix", "Index", "thread", "create", "total", "print", "scale", "to", "empty", "find", "loc", "row", "level", "sort", "search", "value", "iterator", "test", "pe", "name", "connect", "I", "all", "order", "seek", "act", "info", "shape", "max", "it", "draw", "action", "fail", "init", "id", "location", "command", "start", "position", "scroll", "ex", "inc", "slice", "out", "label", "size", "time", "iter", "is", "prefix", "try", "node", "input", "ci", "can", "e", "length", "dimension", "error", "active", "di", "list", "timeout", "success", "ai", "z", "connection", "version", "ii", "j", "key", "n", "ice", "in", "initial", "loop", "si", "local", "offset", "check", "ip", "num", "pos", "point", "address", "zero"], "count": ["cycle", "limit", "found", "collection", "common", "h", "list", "coll", "cap", "amount", "type", "v", "cont", "nb", "number", "z", "ind", "name", "l", "call", "cd", "start", "code", "depth", "Count", "cc", "order", "consider", "process", "n", "total", "nt", "size", "iter", "core", "cache", "ch", "ount", "try", "act", "handle", "info", "hash", "max", "offset", "now", "more", "currency", "ctx", "find", "c", "counter", "t", "num", "cart", "buffer", "sum", "current", "chain", "ctr", "length", "zero"], "dsize": [" dci", "ddsw", "mSize", "wtype", "dci", "tsize", "dimize", "tize", "wci", "dimsize", "dSize", "dsw", "wize", " dsum", "DSize", "Dsum", "ddoffset", "doffset", "dsum", "ttype", "wsize", "msum", "msize", "dimscore", " dtype", "dscore", "tci", "dize", "djsw", "Dsize", "msw", " dize", "ddsize", "Dscore", " dscore", "ddscale", "Dize", "moffset", "mscale", "djoffset", "dtype", " dSize", "djsize", "mize", "dimSize", "dscale", "djscale"], "mc": ["MT", "mm", "dc", "ma", "tc", "cm", "tm", "cam", "MC", "fc", "bc", "mac", "vm", "lc", "cc", "md", "g", "mb", "mt", " MC", "ctx", "mic", "m", "mp", "c", "mi", "mx", "Mc", "pc", "ms", "bm", "mn", "isc"]}}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n", "idx": 8526, "substitutes": {"f": ["p", "bf", "x", "conf", "off", "um", "cf", "ft", "ff", "v", "ret", "df", "fc", "xf", "rf", "l", "lf", "fr", "uf", "fo", "new", "fb", "out", "through", "fa", "sf", "tif", "fs", "fab", "b", "fn", "file", "d", "fm", "ac", "g", "fl", "fd", "of", "ut", "y", "full", "fx", "af", "q", "tf", "fp", "fi", "F", "c", "t", "e", "fac", "w", "fw"], "opaque": ["iopula", "iopiera", "pque", " oplay", " opaques", "bolay", "iopaque", "OPiera", "pula", "Oplay", "opque", "opiera", "boaque", "boula", "OPaque", "opaques", "Opaques", "opula", "piera", "iopque", "boaques", " opula", "oplay", "Opula", "Opaque", "OPque", "paque", "OPula"], "s": ["ts", "p", "changes", "sb", "conf", "ats", "sw", "ims", "ses", "ies", "rs", "se", "events", "ls", "args", "params", "ss", "its", "als", "es", "ps", "gs", "aws", "an", "comm", "ops", "sts", "parts", "ess", "sq", "des", "sv", "sl", "serv", "is", "as", "b", "details", "has", "bs", "ins", "os", "bis", "sys", "js", "stats", "ds", "hs", "S", "sis", "so", "bits", "results", "spec", "vs", "us", "ms", "qs", "ns"], "i": ["ami", "cli", "x", " ti", " m", " ii", "ind", "ix", "iu", "u", "bi", " I", "remote", "print", "index", " my", "li", "MI", "\u0438", "t", "batch", "ti", "ms", " pi", "gi", "ic", " index", "iq", "ei", "I", "my", "info", " bi", "it", "qi", "mi", "status", "asi", "ki", "me", "ui", "p", " l", "init", "uri", "id", "xi", "sim", "oi", "ex", "multi", "slice", "g", "is", "y", "ini", "ci", "chain", "pi", "us", "di", " multi", " x", "v", "ri", "ai", "ii", "j", "ji", " mi", "iy", "in", "hi", "si", " v", "m", " p", "zi", " j"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static void exit_program(void)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        avfilter_graph_free(&filtergraphs[i]->graph);\n\n        for (j = 0; j < filtergraphs[i]->nb_inputs; j++) {\n\n            av_freep(&filtergraphs[i]->inputs[j]->name);\n\n            av_freep(&filtergraphs[i]->inputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->inputs);\n\n        for (j = 0; j < filtergraphs[i]->nb_outputs; j++) {\n\n            av_freep(&filtergraphs[i]->outputs[j]->name);\n\n            av_freep(&filtergraphs[i]->outputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->outputs);\n\n        av_freep(&filtergraphs[i]->graph_desc);\n\n        av_freep(&filtergraphs[i]);\n\n    }\n\n    av_freep(&filtergraphs);\n\n\n\n    /* close files */\n\n    for (i = 0; i < nb_output_files; i++) {\n\n        AVFormatContext *s = output_files[i]->ctx;\n\n        if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)\n\n            avio_close(s->pb);\n\n        avformat_free_context(s);\n\n        av_dict_free(&output_files[i]->opts);\n\n        av_freep(&output_files[i]);\n\n    }\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters;\n\n        while (bsfc) {\n\n            AVBitStreamFilterContext *next = bsfc->next;\n\n            av_bitstream_filter_close(bsfc);\n\n            bsfc = next;\n\n        }\n\n        output_streams[i]->bitstream_filters = NULL;\n\n        avcodec_free_frame(&output_streams[i]->filtered_frame);\n\n\n\n        av_freep(&output_streams[i]->forced_keyframes);\n\n        av_freep(&output_streams[i]->avfilter);\n\n        av_freep(&output_streams[i]->logfile_prefix);\n\n        av_freep(&output_streams[i]);\n\n    }\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        avformat_close_input(&input_files[i]->ctx);\n\n        av_freep(&input_files[i]);\n\n    }\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        av_frame_free(&input_streams[i]->decoded_frame);\n\n        av_frame_free(&input_streams[i]->filter_frame);\n\n        av_dict_free(&input_streams[i]->opts);\n\n        av_freep(&input_streams[i]->filters);\n\n        av_freep(&input_streams[i]);\n\n    }\n\n\n\n    if (vstats_file)\n\n        fclose(vstats_file);\n\n    av_free(vstats_filename);\n\n\n\n    av_freep(&input_streams);\n\n    av_freep(&input_files);\n\n    av_freep(&output_streams);\n\n    av_freep(&output_files);\n\n\n\n    uninit_opts();\n\n\n\n    avfilter_uninit();\n\n    avformat_network_deinit();\n\n\n\n    if (received_sigterm) {\n\n        av_log(NULL, AV_LOG_INFO, \"Received signal %d: terminating.\\n\",\n\n               (int) received_sigterm);\n\n        exit (255);\n\n    }\n\n}\n", "idx": 8534, "substitutes": {"i": ["ami", "cli", "x", "json", " ii", "ind", "depth", "ix", "iu", "bi", "ni", "remote", "er", "history", "index", "to", "li", "\u0438", "io", "this", "batch", "ti", "series", "iii", "gi", "ic", "iq", "ei", "I", "phi", "ik", "iti", "ie", "info", "q", "it", "qi", "mi", "ij", "status", "ki", "me", "ims", "ui", "loading", "init", "uri", "id", "l", "xi", "sim", "parent", "oi", "multi", "is", "y", "ini", "fi", "ia", "ci", "chain", "associated", "pi", "e", "us", "di", "list", "ir", "v", "ri", "ai", "ii", "ji", "in", "hi", "si", "m", "zi", "ip", "iri", "im", "ish"], "j": ["p", "aj", "pr", "oj", "ev", "xy", "jj", "jc", "job", "v", "json", "err", "jump", "jit", "z", "jack", "pt", "bj", "str", "fr", "ji", "jac", "other", "ix", "at", "ijk", "bi", "n", "obj", "jas", "ja", "g", "kj", "b", "er", "kid", "my", "d", "jo", "kh", "y", "q", "note", "js", "adj", "J", "br", "m", "it", "Ja", "jl", "je", "ij", "dj", "res", "uj", "bo", "col", "k", "el", "msg", "jp"], "s": ["self", "ts", "less", "p", "h", "sb", "ats", "rs", "ls", "es", "ss", "als", "its", "l", "ps", "xs", "gs", "acs", "aws", "sports", "sts", "n", "sq", "a", "fs", "sl", "is", "g", "sv", "as", "has", "sam", "os", "ms", "js", "ctx", "hs", "ds", "m", "S", "c", "vs", "cs", "us", "bs", "qs", "ns"], "bsfc": ["bitslc", "jscf", "utscf", "ubsfp", "oscf", "bisFC", "gsfc", "utsfc", "csdc", "osf", "bitsdc", "bpsfc", "bsFC", "psfc", "utsmc", "lscf", "gscf", "cscf", "pslc", "lsac", "osfc", "ubsfc", "bsac", "bpsfp", "lsfc", "bisf", "bsf", "psac", "bisfc", "psfp", "bsfp", "ubscf", "bitsfc", "bitsfp", "cslc", "bpslc", "gsf", "csfp", "ubsmc", "osFC", "gsFC", "bitscf", "utsfp", "lsfp", "bsdc", "biscf", "psmc", "jslc", "bitsac", "jsdc", "pscf", "bsmc", "bslc", "bpscf", "bscf", "jsfc", "csfc"], "next": ["secondary", "aj", "dev", "inv", "nd", "nn", "follow", "seq", "soft", "link", "head", "primary", "z", "dot", "Next", "tech", "entry", "again", "gt", "env", "other", "new", "future", "parent", "front", "after", "prev", "nl", "n", "pool", "join", "sec", "def", "get", "eq", "ext", "behind", "desc", "first", "big", "adj", "sys", "sequence", "last", "ctx", "max", " Next", "append", "chain", "current", "foreign", "later", "inner", "context", "ptr", "child", "gen", "nz", "jp"]}}
{"project": "qemu", "commit_id": "091b1108ca6d6e3bfaea5f095f219bf5ea8c316b", "target": 1, "func": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n", "idx": 8543, "substitutes": {"bs": ["ts", "bf", "sb", "blog", "bd", "rs", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "ps", "gs", "bb", "ubs", "sts", "bl", "bi", "cms", "las", "fs", "bh", "bt", "b", "lbs", "s", "bas", "bis", "js", "hs", "ds", "ubis", "bps", "bn", "vs", "cs", "bm", "ns"], "sector_num": ["sector_nm", "sector2mon", "sector2num", "sector_mon", "row_nm", "sector_id", "sector_n", "sector_nam", " sector_number", "row_id", "sector2nm", "sector__mon", "sector2id", "sector2n", " sector_nam", "sector__number", "row_n", "sector2number", "sector__nam", "row_num", "sector__num", "sector_number", " sector_mon", "sector2nam"], "nb_sectors": ["nb_secs", "nb_vevers", "nb_vectors", "nb_bectors", "nb_severs", "nb_specs", "nb_iterards", "nb_vecs", "nb_iterctors", "nb_seivers", "nb_evers", "nb_seors", "nb_iterors", "nb_veards", "nb_seards", "nb_spectors", "nb_itervers", "nb_speors", "nb_veors", "nb_veivers", "nb_speivers", "nb_beors", "nb_ectors", "nb_eors", "nb_becs", "nb_beivers", "nb_eards"], "num_same": ["num_shared", "num_Same", "num00repeat", "num_good", "nb00repeat", "nb00unique", "num__same", "nb_good", "num__unique", " num_Same", " num_each", "num__repeat", "num_unique", "num00good", "nb_unique", "nb00good", "num00same", "num_each", " num_shared", "nb_repeat", "num__good", "num00unique", "nb_same", "nb00same", "num_repeat"], "bitmap": [" bitMap", "bytemask", "bitslist", "lockbuffer", "hexblock", "binMap", "blocknum", "basemaps", "bitsmap", "bitlist", " bitbuffer", "Bitmask", " bitmask", "lockmaps", "bitnum", "bitset", "bytemap", "blockblock", "binset", "Bitblock", "Bitnum", "bytemaps", "bitbuffer", " bitnum", "hexmap", "bitsmaps", "hexnum", " bitlist", "lockcode", "lockmap", "binmap", "bitcode", "Bitbuffer", "binnum", "basebuffer", " bitcode", "bugnum", "bitmaps", "bugMap", "bitsmask", "bitmask", "blockmask", "bitblock", "bitMap", "basemap", " bitmaps", "bytelist", "blockbuffer", " bitset", "Bitmap", "bugmap", "basecode", "blockmap", "bugset"], "ret": ["found", "pert", "flag", "RET", "red", "fun", "rev", "f", "err", "repl", " Ret", "git", "cont", "url", "re", "result", "prot", "j", "gt", "Ret", "deg", " RET", "code", "val", "rem", "after", "out", "nt", "rets", "not", "print", "mt", "def", "tr", "lit", "desc", "elt", "rt", "ref", "eret", "reset", "txt", "t", "status", "res", "checked", "det", "resp", "pent", "alt", "ter", "jp", "cmd"], "changed": ["hidden", "found", "changes", "confirmed", "started", "failed", "colored", "different", "disabled", "modified", "jump", "tested", "joined", "written", "new", "created", " updated", "wired", "change", "n", "broken", "count", "diff", "aligned", "ended", "forced", "rendered", "adjusted", "index", "required", "updated", "anged", "initialized", "Changed", "bool", "set", "ref", "added", "connected", "ed", "len", "checked", "rolled", "edited", "locked", "used", "loaded", " unchanged"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "substitutes": {"timer_list": ["timeristalist", "timeracname", "timeritytree", "timer_alist", "coordistlist", "timeraclist", "imer_li", "coord_list", "ter_list", "coordistnet", "timer_table", "timeracadd", "timeritycollection", "imer_alist", "timer_tree", "imer_link", "timeristname", "coord_alist", "timeristlist", "timerPLIST", "wrapperistcollection", "timer_LIST", "timeritylists", "imer_list", "timer_add", "timerricalist", "timeritylist", "timeristlink", "wrapper_name", "Timer_list", "wrapper_collection", "timeristcollection", "coordistalist", "timer_lists", "timerPleft", "timer_int", "timer_link", "ter_LIST", "timerricint", "timer_listed", "imer_module", "wrapperistadd", "timeritytable", "timer_left", "timeristadd", "ter_left", "timerPlisted", "wrapperistname", "timer_List", "timeraccollection", "timer_module", "coord_int", "timer_li", "timerPlist", "timeristnet", "imer_collection", "timer_name", "Timer_List", "imer_lists", "Timer_tree", "coordistint", "wrapperistlist", "timerriclist", "wrapper_list", "ter_listed", "timeristlists", "wrapper_add", "timer_collection", "timeristint", "timerricnet", "Timer_table", "timer_net", "coord_net", "imer_listed", "timeristlisted", "timerityList"], "expire_time": ["expirematime", "expire_start", "expirexTime", "expirexcount", "expiretimestart", "expireptstart", "exiry_ime", "expirezsequence", "expireUtime", "expireztime", "expiretimetime", "exiryUime", "exiryUno", "expiration_count", "expirezlock", "expireThetime", "expiration_delay", "expireUime", "expire_no", "expire_Time", "expireThelock", "expire_sequence", "expiretimeTime", "expire_delay", "exiry_time", "expireptlock", "exiryUtime", "expire_count", "expireThestart", "exiryztime", "expireptsequence", "expirepttime", "exiry_no", "expiration_time", "exiry_lock", "expiration_start", "exiry_sequence", "exiryzstart", "exiryzsequence", "expiremattime", "expirextime", "exiry_start", "expire_ime", "expireThesequence", "exiryzlock", "expirematno", "expiration_Time", "expireUno", "expirezstart", "expirexdelay", "expire_lock"]}}
{"project": "qemu", "commit_id": "e97fc193e1c65deb51643d5251e98affe07c59ca", "target": 0, "func": "static void check_refcounts(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n\n\n    size = bdrv_getlength(s->hd);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  0, s->cluster_size);\n\n\n\n    check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                           sn->l1_table_offset, sn->l1_size, 0);\n\n    }\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->refcount_table_offset,\n\n                  s->refcount_table_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        int64_t offset;\n\n        offset = s->refcount_table[i];\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, refcount_table, nb_clusters,\n\n                          offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2)\n\n            fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\",\n\n                   i, refcount1, refcount2);\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n}\n", "idx": 8568, "substitutes": {"bs": ["ts", "boxes", "irms", "fps", "uses", "sb", "ats", "blog", "rs", "aos", "outs", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "cks", "gs", "acs", "jac", "ops", "ubs", "sts", "iss", "bl", "bi", "las", "bh", "fs", "bt", "b", "lbs", "is", "bles", "bsp", "os", "ms", "bas", "bis", "css", "js", "bes", "hs", "ds", "ubis", "oss", "bits", "bps", "aus", "vs", "cs", "ims", "hz", "bm", "ns"], "s": ["ts", "p", "less", "changes", "h", "sb", "ats", "conf", "ses", "rs", "v", "ls", "args", "ss", "its", "settings", "stat", "als", "es", "ps", "gs", "aws", "comm", "ops", "sts", "parts", "n", "sq", "sv", "fs", "sl", "b", "is", "a", "as", "g", "details", "irs", "sam", "ins", "os", "ms", "y", "scripts", "js", "sys", "hs", "ds", "stats", "states", "m", "S", "c", "ashes", "bits", "spec", "vs", "cs", "state", "ims", "w", "gets", "qs", "ns"], "size": ["options", "resolution", "no", "mem", "type", "v", "sp", "number", "z", "data", "id", "fee", "name", "needed", "l", "height", "network", "capacity", "start", " sizes", "small", "space", "n", "total", "count", "south", "zone", "area", "time", "scale", "Size", "si", "dim", "os", "shape", "empty", "set", "max", "ize", "m", "t", "num", "len", "sum", "base", "memory", "pi", "SIZE", "length", "storage", "scope"], "nb_clusters": ["nb_lonents", "nbortexplusters", "nb_clususters", "nb2cluster", "nb_transusters", "nb_transuers", "nb_combusters", "nb_combances", "nb_slUsers", "nb_cessions", "nb2clusters", "nb_locows", "nb_clows", "nb_cliques", "nb_custers", "nb2clients", "nb_shusters", "nb_clroups", "nb_lances", "nb2clroups", "nb_cluers", "nbortclusters", "nb_volosures", "nb_relords", "nb__clutions", "nbortclosures", "nb_archutions", "nb_decistries", "nb_glroups", "nb_blocksodes", "nb_Cluster", "nb_sclblocks", "nb_caosures", "nb_clores", "nb_caocks", "nb_blroups", "nb_blusters", "nb2cessions", "nb_sclutions", "nbortclistries", "nb_locuers", "nb_explograms", "nb_transows", "nb_cluster", "nb_clonents", "nb_caanches", "nb_Clessions", "nb_closures", "nb_decusters", "nb_glodes", "nb_cnients", "nb_explosures", "nb_clocks", "nb_cnusters", "nb2blodes", "nb_glusters", "nb_CLores", "nb_CLients", "nb2blusters", "nbortexplograms", "nb_caances", "nb_Clients", "nb_clusodes", "nb2blroups", "nb_clayers", "nb_blodes", "nb_lients", "nb_clusayers", "nb_descators", "nbortexplosures", "nb_cients", "nb_clutions", "nb_clograms", "nb_shblocks", "nb_archUsers", "nb_clients", "nb_decograms", "nbortexplistries", "nb_explistries", "nb_shores", "nb_volonents", "nb_Cliques", "nb_slutions", "nb2clessions", "nb_decosures", "nb_losures", "nb_lodes", "nb_clblocks", "nb_custer", "nb_sclanches", "nb__clusters", "nb_explusters", "nb_relusters", "nb_combuster", "nb_relayers", "nb_Clusters", "nb_descows", "nb_lusters", "nb__clanches", "nb_transators", "nb_causters", "nb_clusutions", "nb2custer", "nb_relodes", "nb_clusistries", "nb_locusters", "nb_voliques", "nb_blocksords", "nb_blients", "nb_blocksusters", "nb_clusocks", "nb__clocks", "nb_clanches", "nb_locators", "nb_clUsers", "nb_CLblocks", "nb_clators", "nb_clusanches", "nb_descusters", "nb_sclUsers", "nb_clusords", "nb2custers", "nb_clistries", "nb_volances", "nb_clusograms", "nb_slanches", "nb2clodes", "nb_glients", "nb_combiques", "nb_cnessions", "nb_cnuster", "nb_caonents", "nb_sclores", "nb_archanches", "nb_Clances", "nb_clusosures", "nb_clodes", "nb_clessions", "nbortclograms", "nb_cautions", "nb_shients", "nb_blocksayers", "nb_sclients", "nb2blients", "nb_CLusters", "nb_slusters", "nb_clords", "nb2cients", "nb_voluster", "nb_archusters", "nb_clances", "nb_sclusters", "nb_volusters", "nb_lroups", "nb_descuers"], "refcount1": ["relountOne", "refsum0", "defount0", "reffilterOnce", "refount1", "reffilter001", "refcore2", "refcore0", " refount_", "refount3", "refcore9", "refount9", "refount0", "defcount1", "relcount2", "refcore11", "refcoreOne", " refount001", "defount8", "fcount01", "fcount2", "reffilter1", " refount1", "fount2", "refcount_", "refsum11", "defount11", "defcount8", "refount01", " refcount001", "relount9", "refsum8", "refcount8", "refount001", "refCount3", "refempt1", "refcache1", "relcountOne", "refemptOnce", "refCount9", "defcount0", "relcount1", "fount1", "refcount11", "refempt_", "refcache01", " refountOnce", "refcache2", "refcount3", "refCount1", "refcore1", " refcountOnce", "refcount001", "refountOnce", "refCount01", "refcountOne", "refount_", "refountOne", "relcount9", "refcache3", "fcount3", "refcount0", "refcore8", "refCountOne", "relount1", "refcount01", "relount2", "refount11", "refount2", "refempt001", "refCount2", "reffilter_", "defount1", "fount3", "defcount11", "fount01", "refcount9", "refount8", "refsum1", "refcountOnce", " refcount_", "fcount1"], "refcount2": ["refcmd0", "refchild2", "refcache02", "relcount4", "refcount0", "refounttwo", "refcmd2", "refcycle4", "refcount02", "refcoretwo", "refcore2", "refount1", "refCounttwo", "relount2", "relounttwo", "refcount256", "refcore0", "refchild256", "relount4", " refcount0", "memcount2", "refCount0", "refcache2", "refcycletwo", "refcounttwo", "refchild02", "refount2", " refCount1", "refCount1", " refCount2", "refount0", "refcount4", "relcount02", "refCount2", "refc2", "relcounttwo", "refcache0", "refcore1", " refCount0", "relcount2", "refc256", "memcount02", "refcycle02", "refount02", "refcachetwo", "memcount256", "refcache4", "refount256", "refcycle2", "memount2", "refcmd1", "memount02", "refcache1", "relount02", " refcounttwo", " refCounttwo", "refc02", "memount256", "refount4"], "i": ["ami", "cli", "x", "err", "ind", "ix", "iu", "bi", "remote", "er", "print", "index", "li", "MI", "\u0438", "this", "batch", "ti", "gi", "ic", "ei", "I", "phi", "ik", "info", "it", "mc", "qi", "mi", "ij", "status", "ki", "ims", "me", "by", "ui", "p", "init", "span", "yi", "um", "id", "xi", "sim", "parent", "oi", "multi", "o", "iter", "g", "y", "ini", "fi", "inter", "ci", "chain", "pi", "e", "us", "di", "f", "v", "ri", "ai", "ii", "j", "ji", "key", "n", "in", "hi", "si", "m", "ip", "zi", "iri", "point", "im"], "sn": ["ny", "snap", "sb", "nn", "span", "sw", "nex", "sol", "sa", "kn", "Sn", "sh", "sp", "ss", "syn", "stat", "eni", "ln", "wn", "tn", "sbm", "pn", "bl", "SN", "sr", "nl", "n", "sq", "sm", "sf", "nt", "gn", "sv", "sl", "serv", "fn", "si", "sam", "sd", "dn", "rn", "sc", "bn", "cs", "ski", "cn", "ns"], "refcount_table": ["refcount32iterator", "refcount8t", "refountttable", "refstore_table", "refcountplepool", "refcount_scope", "refcountsdatabase", "refstatus_point", "refcodestable", "refcountstrace", "refcountsTABLE", "refrefstable", "refstatus2cache", "refcount32Table", "refrefst", "refounttscope", "refcount_t", "refstore_term", "refstorepledatabase", "refcount_database", "refstatus2point", "refcode_database", "refcount_TABLE", "refrefspool", "refstorepletable", "refcount8tab", "refstore_pool", "refount_scope", "refcount2point", "refcountpleiterator", "refcodestab", "refrefstab", "refcountingpool", "refcount_list", "refcount8pool", "refstatus_try", "refcount_trace", "refount_container", "refref_table", "refcount_container", "refcountpletable", "refcountst", "refcountspool", "refcodestrace", "refcache_table", "refcount2table", "refcountstable", "refcount_pool", "refcount_term", "refstore_database", "refattribute32source", "refcache_type", "refattribute_iterator", "refcountsTable", "refref_tab", "refref_pool", "refcountplesource", "refCount_list", "refcountdscope", "refcount_cache", "refCount_map", "refcountingtable", "refcount_Table", "refcode_trace", "refounttcontainer", "refref_t", "refcount_try", "refcount2TABLE", "refcountingterm", "refcount2tab", "refCount_TABLE", "refcount_source", "refcache_buffer", "refcount2cache", "refcount_tab", "refstoreplepool", "refcountingdatabase", "refcountdtable", "refount_table", "refcountplecache", "refcount_buffer", "refcount_db", "refcounttscope", "refstatus2table", "refcodesdatabase", "refcode_table", "refcount8table", "refcache_list", "refcountttable", "refCount_tab", "refattribute32table", "refCount_db", "refattribute32Table", "refcountpletry", "refcountpleTable", "refstatus_cache", "refcount2db", "refcountstab", "refcount2try", "refcountplepoint", "refattribute_Table", "refCount_table", "refcountpleterm", "refcounttcontainer", "refcount_type", "refcountpledatabase", "refstatus2try", "refcount_iterator", "refstorepleterm", "refattribute32iterator", "refcountdcontainer", "refattribute_table", "refcount32table", "refattribute_source", "refcode_tab", "refstatus_table", "refcount_map", "refcount32source", "refcount_point"], "offset": ["options", "extra", "ace", "instance", "off", "timeout", "slot", "iterator", "link", "end", "needed", "location", "entry", "height", "padding", "missing", "start", "angle", "window", "position", "shift", "key", "balance", "slice", "origin", "o", "total", "tmp", "seek", "pointer", "prefix", "index", "cache", "field", "attribute", "set", "trace", "fp", "oe", "Offset", "tile", "frequency", "volume", "pos", "alias", "port", "source", "point", "option", "unk", "ptr", "address", "length", "zero", "error"]}}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 8577, "substitutes": {"ip": ["p", "wp", "imp", "ipp", "iso", "addr", "pp", "sp", "ic", " sip", "inet", "ipop", "mac", "ep", "ix", "zip", "pipe", "cp", "net", "arp", "phys", "ipe", "isp", "lip", "phy", "ock", "it", "io", "mp", "ips", "port", "chip", "ap", "up", "host", "address", "hip", "IP"], "s": ["self", "ts", "p", "r", "h", "sb", "ats", "conf", "ses", "rs", "v", "ls", "sp", "ss", "es", "ps", "gs", "aws", "sts", "n", "sq", "ess", "sm", "o", "sv", "fs", "a", "is", "as", "g", "b", "sam", "bs", "os", "js", "sys", "hs", "ds", "ssl", "m", "S", "sis", "c", "t", "bits", "so", "e", "ims", "se", "ns"], "i": ["ui", "di", "p", "x", "list", "init", "f", "v", "gi", "ri", "ic", "ai", "id", "z", " ii", "ind", "name", "l", "ii", "interface", "j", "xi", "sim", "I", "ix", "iu", "ex", "multi", "out", "bi", " I", "n", "in", "me", "count", "is", "g", "d", "print", "si", "li", " bi", "y", "ini", "info", "mount", "it", "ci", "c", "m", "t", "mi", "zi", " j", "chain", "qi", "ti", "point", "im", "ij", "pi", "ki", "ims"], "ch": ["p", "cb", "h", "x", "cr", "cha", "conf", "ot", "ech", "cmd", "gh", "ev", "v", "cm", "chan", "sh", "qu", "z", "l", "ct", "cand", "j", "sky", "cl", "comm", "th", "channel", "tch", "range", "cht", "chn", "cp", "chart", "form", "zh", "history", "ht", "che", "kh", "ah", "ach", "mk", "wh", " Ch", "mot", "hl", "y", "gr", "ctx", "och", "kr", "br", "ctrl", "c", "hand", "check", "cod", "sc", "loc", "arch", "CH", "chu", "Ch", "cs", "col", "sch", "cho", "ich"], "chr_name": ["chp2name", "chp2names", "char_attr", "chp2Name", "chp_name", "chp_names", "chr_names", "chrl_len", "chr_num", "chr_len", "char_name", "chrl_num", "chrl_names", "chr2Name", "chr2names", "chr_Name", "chp_Name", "chr2name", "char_names", "chr_attr", "chrl_name"], "label": ["lab", "layout", "list", "span", "leader", "comment", "slot", "type", "link", "id", "data", "NAME", "ind", "cell", "name", "l", "str", "title", "group", "els", "Label", "dl", "align", "key", "summary", "nl", "line", "EL", "abel", " Label", "prefix", "ID", "handle", "field", "path", "tab", "LAB", "display", "desc", "node", "local", "button", "LI", "text", "alias", "len", "ell", "loc", "description", "message", "L", "tex", "color", "class", "state", "address", "el", "sort", "msg", "error"], "index": ["x", "list", "instance", "condition", "insert", "from", "f", "success", "id", "number", "data", "z", "speed", "ind", "name", "axis", "j", "position", "Index", "new", "slice", "n", "size", "count", "is", "d", "si", "path", "node", "offset", "find", "num", "pos", "status", "loc", "point", "row", "IND", "context", "state", "level", "address", "length", "zero", "dimension"]}}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n", "idx": 8592, "substitutes": {"r1": ["mr3", "w01", "r4", "r001", " rFirst", "grOne", "gr001", "rc1", "br01", "rOne", " r01", "r3", "rt01", " r4", "rt3", "mr01", " r001", "w001", "rt1", "rc001", "rcFirst", "rFirst", "w1", "rt4", "rcOne", " rOne", "br1", " r3", "grFirst", "mr4", "r01", "mr1", "br001", "gr1"], "r2": ["res2", "rc1", "rt2", " rTwo", "r3", "restwo", "wtwo", "rc6", "R6", "r02", "rt3", "s3", "R2", "rg", "R1", " r6", "r6", "w2", "rtg", "rcTwo", "rtwo", " rtwo", "R02", " r02", "sg", "w3", "RTwo", "stwo", "s2", "rTwo", "wg", "res02", "rc2", "rttwo", "res1", "Rtwo"]}}
{"project": "FFmpeg", "commit_id": "7fffc879798bbbad647ad2b1b30f26855bf2abda", "target": 0, "func": "static int wc3_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    Wc3DemuxContext *wc3 = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    unsigned int fourcc_tag;\n\n    unsigned int size;\n\n    AVStream *st;\n\n    unsigned char preamble[WC3_PREAMBLE_SIZE];\n\n    int ret = 0;\n\n    int current_palette = 0;\n\n    int bytes_to_read;\n\n    int i;\n\n    unsigned char rotate;\n\n\n\n    /* default context members */\n\n    wc3->width = WC3_DEFAULT_WIDTH;\n\n    wc3->height = WC3_DEFAULT_HEIGHT;\n\n    wc3->palettes = NULL;\n\n    wc3->palette_count = 0;\n\n    wc3->pts = 0;\n\n    wc3->video_stream_index = wc3->audio_stream_index = 0;\n\n\n\n    /* skip the first 3 32-bit numbers */\n\n    url_fseek(pb, 12, SEEK_CUR);\n\n\n\n    /* traverse through the chunks and load the header information before\n\n     * the first BRCH tag */\n\n    if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n        WC3_PREAMBLE_SIZE)\n\n        return AVERROR(EIO);\n\n    fourcc_tag = AV_RL32(&preamble[0]);\n\n    size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    do {\n\n        switch (fourcc_tag) {\n\n\n\n        case SOND_TAG:\n\n        case INDX_TAG:\n\n            /* SOND unknown, INDX unnecessary; ignore both */\n\n            url_fseek(pb, size, SEEK_CUR);\n\n            break;\n\n\n\n        case _PC__TAG:\n\n            /* need the number of palettes */\n\n            url_fseek(pb, 8, SEEK_CUR);\n\n            if ((ret = get_buffer(pb, preamble, 4)) != 4)\n\n                return AVERROR(EIO);\n\n            wc3->palette_count = AV_RL32(&preamble[0]);\n\n            if((unsigned)wc3->palette_count >= UINT_MAX / PALETTE_SIZE){\n\n                wc3->palette_count= 0;\n\n                return -1;\n\n            }\n\n            wc3->palettes = av_malloc(wc3->palette_count * PALETTE_SIZE);\n\n            break;\n\n\n\n        case BNAM_TAG:\n\n            /* load up the name */\n\n            if ((unsigned)size < 512)\n\n                bytes_to_read = size;\n\n            else\n\n                bytes_to_read = 512;\n\n            if ((ret = get_buffer(pb, s->title, bytes_to_read)) != bytes_to_read)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case SIZE_TAG:\n\n            /* video resolution override */\n\n            if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n                WC3_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            wc3->width = AV_RL32(&preamble[0]);\n\n            wc3->height = AV_RL32(&preamble[4]);\n\n            break;\n\n\n\n        case PALT_TAG:\n\n            /* one of several palettes */\n\n            if ((unsigned)current_palette >= wc3->palette_count)\n\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = get_buffer(pb,\n\n                &wc3->palettes[current_palette * PALETTE_SIZE],\n\n                PALETTE_SIZE)) != PALETTE_SIZE)\n\n                return AVERROR(EIO);\n\n\n\n            /* transform the current palette in place */\n\n            for (i = current_palette * PALETTE_SIZE;\n\n                 i < (current_palette + 1) * PALETTE_SIZE; i++) {\n\n                /* rotate each palette component left by 2 and use the result\n\n                 * as an index into the color component table */\n\n                rotate = ((wc3->palettes[i] << 2) & 0xFF) |\n\n                         ((wc3->palettes[i] >> 6) & 0xFF);\n\n                wc3->palettes[i] = wc3_pal_lookup[rotate];\n\n            }\n\n            current_palette++;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\\n\",\n\n                preamble[0], preamble[1], preamble[2], preamble[3],\n\n                preamble[0], preamble[1], preamble[2], preamble[3]);\n\n            return AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n            WC3_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n        fourcc_tag = AV_RL32(&preamble[0]);\n\n        /* chunk sizes are 16-bit aligned */\n\n        size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    } while (fourcc_tag != BRCH_TAG);\n\n\n\n    /* initialize the decoder streams */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_XAN_WC3;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = wc3->width;\n\n    st->codec->height = wc3->height;\n\n\n\n    /* palette considerations */\n\n    st->codec->palctrl = &wc3->palette_control;\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->audio_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n    st->codec->codec_id = CODEC_ID_PCM_S16LE;\n\n    st->codec->codec_tag = 1;\n\n    st->codec->channels = WC3_AUDIO_CHANNELS;\n\n    st->codec->bits_per_sample = WC3_AUDIO_BITS;\n\n    st->codec->sample_rate = WC3_SAMPLE_RATE;\n\n    st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n        st->codec->bits_per_sample;\n\n    st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS;\n\n\n\n    return 0;\n\n}\n", "idx": 8617, "substitutes": {"s": ["ts", "p", "h", "sb", "ats", "rs", "v", "f", "sp", "ss", "ps", "gs", "comm", "sts", "n", "in", "o", "a", "fs", "as", "b", "g", "ins", "os", "js", "sys", "hs", "ds", "m", "c", "S", "t", "sc", "cs", "e", "w", "ns"], "ap": ["att", "al", "aps", "cap", " ip", "pp", "ar", "sp", " sap", "op", "tp", "bp", " sp", " pu", "ps", "ep", " op", "tap", " cp", " mp", " par", "pa", " pac", " p", "mp", "ip", " af", "ac"], "wc3": ["wlc7", "wcp9", "warcion", "weightxcuster", "winec15", "wayc4", "wecion", "wcat003", "winecat03", "wcuster", "exc03", "wac3", "wcanust", "wayc15", "wcatThree", "wciwd", "wearcma", "wcachedef", "wvcThree", "wcat2", "wpcache3", "wavc3", "winecat15", "rewcoard", " wc2", "wavcThree", "wcoThree", "wcache3", "wcon3", "wayci3", "wci4", "wacred", "wearc9", "wcc03", "wccuster", "wlcThree", "wcu3", "exlc03", "memlcent", "writerc33", "wcanent", "wacm3", "exlc3", "wrc15", "winec03", " wcc2", "wcpware", "warcdef", "exlc9", "wcu9", "memc3", "wcgent", "wci5", "wallcThree", "wcache03", "wpcdef", "wec9", "wtcust", "wcs3", "memcent", "wccry", "memcware", "wc15", "wcp03", "wecma", "wlc4", "rewco5", "wayc7", "writercust", "wciion", "weightc03", "wcsred", "wconred", "exlcware", "wcmred", "wgc3", "excware", "rewcard", "wcon2", "exc9", "wc03", "rewcwd", "weightxc03", "wcam7", "wpc7", "wcard", "wcmant", "wacmred", "wvc03", "warcware", "wcoard", "wcam3", "wcion", "wvcgent", "exc3", "wc003", "wcatry", "wcware", "wecThree", "wearcion", "wgc4", "wayc3", "wxc3", "wc9", "wlc03", "wlcent", "wpcache7", "wcan03", "wrc7", " wccred", "wcat03", "wcc003", "wallcgent", "wcust", "wconard", "writercry", "rewco3", "wcmThree", "wc7", "winecat3", " wcry", "wcma", "wcm3", "writercanust", "memc03", "wxc003", "rewcowd", "warc3", "wcuion", "wcache15", "wlcware", " wcred", "weightxc003", "wcowd", "wacmant", "winecdef", "wgc7", "wlc3", "wcima", "wpc15", "wayci4", "wc33", "wrcdef", "winec3", "rewc5", "wconry", "wlc15", "wcatred", "wco3", "weightc003", "wcant", "wcwd", "warc9", "wc2", "wcan3", "warcent", "wlc9", "writercanry", "wvc7", "wec3", "wcuust", "writercan33", " wcc3", "wci7", "wcp3", "wcsant", "wcamdef", "wac03", "wxc03", "wtc3", "wcanware", "wcThree", "wallcoThree", "wearc3", "wacant", "memlcware", "wallcogent", "wcan33", "weightc3", "memlc3", "wci9", "wtc03", "wcc2", "wcred", "wcatdef", "weightcuster", "wrc3", "wcon5", "wpc3", "wc5", "wcat3", "wconwd", "writerc3", "wavc03", "wci15", "wcent", "wlcgent", "wtcry", "wayci7", "wallco3", "warcma", "warc03", "wcat15", "wcc3", "wacThree", "wcanry", "wcry", "wvc3", "wcogent", "wpcache15", "wallco7", "wcu33", "wcam15", "writercan3", "wcatant", "wtcThree", "wcsThree", "wciard", "wtc33", "wayci15", "wcuma", "wc4", "wcdef", "wcache7", "wgc15", " wccry", "wco7", "wccred", "rewc3", "wcatuster", "wxcuster", "wallc3", "winecatdef", "wci3", "wco5", "wpcachedef", "wacmThree", "wec03", "memlc03", "wallc7", "wcury", "warc15", "weightxc3"], "pb": ["appy", "p", "cb", "snap", "sb", "amp", "pl", "np", "wp", "tc", "proc", "lp", "um", "pp", "typ", "tp", "dp", "pg", "bp", "pt", "uf", "tk", "erb", "bb", "ub", "fb", "ib", "cv", "buf", "PB", "cp", "tmp", "bh", "buff", "td", "pa", "mb", "pm", "fp", "ctx", "phy", "wb", "mp", "buffer", "stab", "bps", "rb", "resp", "pkg", "asm", "pc", "vp", "lb", "bs", "jp"], "fourcc_tag": ["fourcc_flag", "fourck2tag", "fourCC_tag", "fourcc__type", "fourcc__count", "fourck__tag", "fourCC_flag", "fourck__type", "fourcc2type", "fourcc2tag", "fourck_type", "fourcc_count", "fourck2TAG", "fourck2type", "fourcc_type", "fourck_count", "fourCC_TAG", "fourck_tag", "fourcc2TAG", "fourck__TAG", "fourcc__tag", "fourck__count", "fourcc__TAG", "fourcc_TAG", "fourck_TAG", "fourCC_type"], "size": ["number", "data", "capacity", "shift", "count", "sv", "scale", "empty", "ize", "c", "len", "sum", "mem", "settings", "fee", "name", "small", "notice", "set", "general", "buffer", "SIZE", "storage", "ui", "p", "sp", "position", "space", "bytes", "false", "sn", "style", "grow", "pi", "iz", "use", "length", "password", "timeout", "v", "z", "height", "sized", "si", "Size", "offset", "message"], "st": ["sw", "std", "sp", "ss", "ste", "ct", "ST", "str", "fr", "pt", "bl", "tmp", "sv", "src", "St", "sl", "serv", "inst", "mt", "sam", "rest", "sn", "lo", "so", "sc", "est", "ist", "se"], "preamble": ["Pambler", "repramBLE", "repreamBLE", "sprambler", " parmble", "repreambles", "prambled", " parmbles", "probbles", "Pamment", "Preambled", "spreamBLE", "preamstring", "reprambl", "repreamble", "parmbles", " preambler", "pambler", "Preambler", "pipherBLE", " preamBLE", "parmbl", "spreamble", "reparmbled", "repreambled", "repramble", " parmBLE", "Pambles", "parmment", "pramble", "spreamstring", "preamBLE", "parmbled", "parmBLE", "Pamble", "prombles", "parmstring", "pamBLE", "preambled", "prambler", "Preamment", "probbler", "reparmble", "preambl", "reprambles", "parmble", "preambles", "parmbler", "reparmbl", "pamble", "pipherble", "probment", "spramstring", "pambles", "repreambl", " parmbler", "pramBLE", "Preambles", " preambles", "prambl", "pipherbler", "reparmbles", "preambler", "pramstring", "pamment", "spreambler", "probble", "Preamble", "pambl", "Pambled", "promBLE", "pipherstring", "prambles", "preamment", "spramble", "promble", "pambled", "spramBLE", "prombl"], "bytes_to_read": ["bytes_to_load", "bytes_to_write", "bytes_to_Read"], "i": ["di", "p", "f", "v", "ii", "j", "I", "n", "iter", "is", "si", "index", "li", "iat", "it", "ci", "m", "io", "c", "t", "ip", "mi", "pos", "ti", "im", "pi", "ati"], "rotate": ["rotation", "validator", "Rotator", "rotated", "rotator", "validated", "Rotation", " rotationator", "validation", "Rotate", " rotationation", " rotationate", "validate", "Rotated", " rotationated"], "current_palette": ["current_Pallete", "current_reallette", "current_Palette", "current_palettes", "current_pallete", "current_realettes", "current_Pallette", "current_reallete", "current_fillette", "current_filettes", "current_fillete", "current_filette", "current_pallette", "current_realette", "current_Palettes"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 8673, "substitutes": {"nptr": ["snpt", "snptr", "endaddr", " nPtr", "snPtr", " npointer", "nnPtr", "ncpt", "nPtr", "nnptr", "dnptr", "npt", "endpt", " npt", "Nptr", "dnpad", "nnpt", "dnaddr", "NPtr", "endpad", "Ntr", "dnpt", "npointer", " naddr", "dnPtr", "ncptr", "nntr", "npad", "ncpointer", " npad", "ntr", "naddr", "dntr", "snpointer", "ncPtr", "Npt"], "end": ["cend", "pod", "hend", "send", "ent", "ending", "except", "nd", "END", "bind", "eng", "ff", "id", "add", "ender", "rend", "pend", "pad", "stop", "start", "en", "ep", "close", "out", "bound", "begin", "post", "event", "ended", "End", "st", "rest", "endif", "reset", "gate", "append", "chain", "ad", "est", "wind", "client", "use", "edge", "pay"], "default_suffix": ["default_suprefix", "default_sideixed", "default_prefixix", "default_suffixed", "default_sideIX", "default_affIX", "default___affix", "default___suffixed", "default_suffendix", "default_suix", "default___suffendix", "default_affendix", "default_prefixIX", "default_affix", "default_sideendix", "default_affixed", "default_sideix", "default_prefixendix", "default_supix", "default_suixed", "default_sufix", "default_supixed", "default_subfix", "default___affendix", "default___suffIX", "default___affIX", "default_sufffix", "default___suffix", "default_subprefix", "default_subix", "default_subixed", "default_suffIX", "default_supprefix", "default_suffprefix", "default_prefixixed", "default___affixed", "default_supfix"], "unit": ["util", "units", "p", "comment", "value", "cat", "tc", "type", "un", "norm", "format", "version", "name", "Unit", "lang", "command", "root", "key", "device", "u", "out", "size", "domain", "prefix", "dir", "file", "scale", "dim", "term", "bit", "rt", "style", "note", "it", "io", "unt", "weight", "t", "chain", "sum", "stable", "block", "base", "normal", " units", "option", "nu", "doc", "mu", "mod"], "retval": ["exteval", "RetVAL", "extval", "retVal", "altvalid", "reteval", " retVAL", "altvalue", " returnVAL", "Retvalid", " retserv", " reteval", "reval", " returnVal", "resultvalue", "resultval", "Retserv", "RETval", " retvalue", "altserv", " retVal", "alteval", "retserv", "altVAL", "Retval", "revalue", "RETdata", " returnval", "extv", "altval", "RETvalue", "resulteval", "retvalid", " retdata", "RETVAL", "retv", "printval", "RETvalid", "RETeval", "retvalue", "printVAL", "resultv", "reeval", "retdata", "reVAL", "printvalue", "printeval", "Reteval", "altVal", "RETVal", " returneval", "retVAL", "redata", "extvalue", "Retv", "RetVal", "Retvalue"], "endptr": ["oldptr", "endaddr", "starttr", "ENDpointer", " endpad", "ndpad", "entpointer", "startPtr", "ENDPtr", "startptr", "ndptr", " endsp", "endctr", " endctr", "endedaddr", "entctr", "ENDtr", "endpt", "endingpointer", "startpointer", "oldpt", "ENDaddr", "startreq", "startaddr", "endingaddr", "endedpointer", "ndpt", " endtr", " endcoord", " endPtr", "ENDctr", "outptr", "endpad", "ENDpad", " endreq", "endsp", "endedptr", "outpt", "endedsp", "outpointer", "endpointer", "ENDptr", "ENDsp", " endpt", "endedtr", " endpointer", "endedPtr", "endedpt", "oldpad", "ndpointer", "endedctr", "endingptr", "endcoord", " endaddr", "endingcoord", "startctr", "startpad", "entptr", "startcoord", "endtr", "endPtr", "ENDreq", "outtr", "endreq", "enttr", "ENDpt", "oldpointer"], "c": ["p", "dc", "cb", "cr", "co", "C", "tc", "cf", "cat", "f", "v", "cont", "fc", "l", "ct", "cd", "uc", "cn", "lc", "cu", "cc", "unc", "rc", "u", "n", "cv", "cp", "g", "b", "cache", "ec", "ca", "ctx", "ce", "ci", "t", "chain", "sc", "con", "cs", "gc", "col", "k", "ac"], "val": ["update", "x", "ev", "oval", "data", "ul", " el", " ty", "u", " ret", "sv", "def", "var", "li", " ver", "ref", " delta", "len", "loc", "valid", "el", "util", " ov", "mem", "value", "ret", "test", "bal", "stat", "pt", "aval", " ptr", " sv", "vt", " oval", "act", "tx", " err", "it", "VAL", "res", "au", "al", "p", " old", "xy", "vol", "sel", "l", "crit", " aval", " vel", " interval", " vol", "elt", "eval", "ctx", "cal", " tx", " valid", " arg", "pol", "func", "dev", "pr", "pl", "vals", "Val", " x", "f", "v", " num", "call", " eval", "grad", " al", " vec", " v", " value", " resp", "pos", "num", " res", "point"], "mul": ["mall", "mulate", " mcul", "mult", "emul", "Mulate", "mmular", "tmult", "mmull", "smUL", "mcul", "imul", " mular", "umul", "lemuls", "cmul", "mau", "mmula", "imau", "mmul", "mmil", "vau", "muls", "vular", "mula", "imular", "mlu", "tmull", "smular", "smule", " muls", "smula", "lemul", "mil", "Mau", "Mul", "lemulate", "Mall", "smol", "mular", "mmcul", "smul", "vul", "mmau", "Mular", " mall", "mmUL", "tmol", "Mula", "tmul", "umular", "emular", "Muls", "MUL", "mmult", "mule", "imUL", "Mule", " mau", "lemUL", " mulate", "mUL", "mol", "mull", "emula", "emlu", " mula", "smull", "smult", "umil", "mmall", "smlu", "vil", "umcul", "cmular", "mmol", "cmUL", " mUL", " mil", "cmule", " mlu"], "integral": ["integra", "fration", "integrum", "integraction", "intraction", " Integrix", "integration", "fral", " Integra", "frum", "Integration", "contral", "intrix", " Integral", " Integraction", "integrix", " integrum", "Integraction", "Integrum", "intra", "contrix", "contraction", " integration", "Integral", "intral", " integraction", "contra"], "fraction": ["affraction", " fract", "fration", "vertility", "fant", "vitness", "Fractions", "extraction", "Fant", "infract", "infraction", "traction", "fractions", "vration", "affitness", "fract", "extant", "fertility", "infterm", "fterm", " fertility", "affration", "fral", "tral", "tractions", "tant", "vraction", "affertility", "Fract", " fration", "extract", "infral", " fterm", " fitness", "tract", "tterm", " fral", "fitness", "extractions", "Fraction"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 8707, "substitutes": {"bs": ["ts", "rys", "boxes", "fps", "sb", "blog", "rs", "aos", "outs", "bos", "ls", "BS", "its", "obs", "bc", "ps", "cks", "gs", "ubs", "sts", "bl", "bi", "fs", "bh", "b", "lbs", "bles", "irs", "os", "ms", "bis", "css", "js", "sys", "bes", "hs", "ds", "ubis", "bits", "bps", "aus", "locks", "vs", "cs", "hz", "bm", "ns"], "res": ["r", "rys", "pas", "cons", "resolution", "response", "inv", "vals", "pres", "red", "rs", "rev", "der", "vol", "rek", "re", "its", "ps", "result", "cond", "resources", "Rs", "usr", "comm", "rez", "rem", "rc", "rss", "summary", "out", "RES", "resh", "des", "ress", "expr", "details", "ch", "rest", "os", "Res", "ro", "ms", "ins", "css", "sys", "gr", "reg", "reset", "js", " Res", "req", "bits", "ber", "resp", "wcs", "aux", "us", "results", "scope", "rel", "ns"], "refcount_table": ["refcountpletab", "refcountttab", "refcountingmaster", "refstartpletable", "refcountttable", "refstatingmap", "refstart_table", "refval_binary", "refstatingtable", "refvalplebinary", "refcount_binary", "refstartpleTABLE", "refstatingmaster", "refvalpleTABLE", "refstat_map", "refstatingtab", "refstart_tab", "refcountingmap", "refval_table", "refcountingtable", "refcountpleterm", "refstat_tab", "refcalltdb", "refcounttdb", "refcountpletable", "refcall_tab", "refstat_master", "refcountationtable", "refcallttab", "refcountationmap", "refcall_table", "refstart_TABLE", "refcountpleTABLE", "refvalpletable", "refcountationtab", "refcountplebinary", "refcount_TABLE", "refstartpleterm", "refcount_term", "refcall_db", "refcount_tab", "refstartpletab", "refval_TABLE", "refstart_term", "refcountingtab", "refcount_master", "refstat_table", "refcallttable", "refcount_db", "refval_tab", "refcount_map", "refcountationmaster", "refvalpletab"], "refcount_table_size": ["refcount_tab_scale", "refcount_tab_size", "refcount_table_SIZE", "rel_", "refcount_tab_SIZE", "refcount_TABLE_SIZE", "refcount_table_Size", "refcount_table_scale", "refcount_TABLE_scale", "refcount_table_length", "refcount_TABLE_size", "refcount_TABLE_Size", " ref_", "refcount_TABLE_length", "col_", "ref_"], "l1_table_offset": ["l1_TABLE_index", "l1_Table_position", "l1_table_off", "l1_table_index", "l1_TABLE_offset", "l1_TABLE_Offset", "l1_TABLE_off", "l1_Table_off", "l1_table_Offset", "l1_Table_Offset", "l1_table_position", "l1_Table_offset"], "l1_size": ["l11toffset", "l1_member", "l1dscore", "lOne_ize", "l1_no", "l1_ize", "l11tspeed", "l11_size", "l1dno", "l1ptsize", "l1_time", "l1_Size", "l1tmember", "l1_speed", "l1_length", "l11_speed", "l1ptoffset", "l1dize", "lOne_score", "l1ptlength", "l1_s", "lOne_size", "l2_length", "l11tsize", "l11_member", "l1ptSize", "l1_score", "l11tmember", "l2_Size", "l2_s", "l2_time", "l1tspeed", "lOne_no", "l1tsize", "l1dsize", "l2_size", "l11_offset", "l1_offset", "l1toffset"], "flags": ["options", "func", "vals", "flag", "cf", "args", "cond", " fmt", "ents", "lag", " Flags", " options", " unused", "FLAG", " flag", "fs", "Flags", "files", "kind", "fields", " f", "bits", "status", "mask", "faces", " af", "ags", "Flag"], "s": ["r", "ts", "p", "less", "h", "sb", "ats", "rs", "ls", "sp", "ss", "its", "es", "ps", "gs", "aws", "sts", "sq", "fs", "sv", "is", "b", "ins", "os", "js", "sys", "stats", "ds", "hs", "states", "S", "c", "ashes", "bits", "vs", "cs", "ims", "ns"], "l1_table": ["l87_size", "l0_buffer", "l2_Table", "l3_batch", "l87_table", "l1actable", "l3tbatch", "l2_TABLE", "l2_container", "l1ttable", "l3_session", "l1tbatch", "l3tTABLE", "l1_session", "l1TTABLE", "l3ttable", "l1_tab", "l1_batch", "l3_TABLE", "l1_buffer", "l0_TABLE", "l0_table", "l1_container", "l87_available", "l1tbuffer", "l3_size", "l3_table", "l3tbuffer", "l1_Table", "l1acbuffer", "l87_buffer", "l1__tab", "l1__table", "l2_table", "l1Ttable", "l1_TABLE", "l1acsession", "l1Tcontainer", "l1__TABLE", "l1tsize", "l3_buffer", "l1TTable", "l1_available", "l0_tab", "l1tTABLE", "l1acTABLE", "l1__buffer"], "l2_offset": ["l2_address", "l2_shift", "l7_off", "l2__index", "l7__Offset", "l21ptwindow", "l1_error", "l21_entry", "l2ptindex", "l7__off", "l2_position", "l2__off", "l2__shift", "l1_lock", "l2ptwindow", "l21ptoffset", "l6__error", "l7__error", "l2_lock", "l2_pos", "l7_Offset", "l1_bit", "l1_window", "l2_off", "l1_Offset", "l2__offset", "l6__index", "l6_index", "l2_error", "l2ptaddress", "l2ptlock", "l6__shift", "l2pterror", "l2ptbit", "l2__Offset", "l6_offset", "l21_offset", "l2_index", "l1_position", "l2_window", "l2_bit", "l2ptoffset", "l2ptentry", "l1_off", "l21_window", "l1_pos", "l6_shift", "l6__offset", "l21ptentry", "l2ptshift", "l2ptOffset", "l7__offset", "l6_error", "l2_Offset", "l21_address", "l21ptaddress", "l2_entry", "l2__error", "l7_offset", "l1_offset", "l7_error"], "l1_size2": ["l1_body5", "l1_nametwo", "l1_shape1", "l1_Size02", "l1_size25", "l1_body2", "l1_ize2", "l1_cache1", "l1_size5", "l1_SIZE1", "l1_sizetwo", "l1_SIZE3", "l1_shape5", "l1_shape3", "l1_SIZE2", "l1_body1", "l1_storage2", "l1_Size2", "l1_ize3", "l1_storage3", "l1_name02", "l1_Size3", "l1_Sizetwo", "l1_name1", "l1_storage25", "l1_size02", "l1_Size25", "l1_storage1", "l1_Size5", "l1_size1", "l1_cachetwo", "l1_cache2", "l1_shape2", "l1_name2", "l1_ize5", "l1_cache02", "l1_SIZE5", "l1_name3", "l1_Size1", "l1_size3"], "i": ["ui", "di", " pi", "ami", "cli", "x", "dr", "init", "ims", "uri", " ti", " m", "gi", "ri", "ic", "ai", "id", " ii", "iq", "ind", "l", "ei", "ii", "chain", "j", "xi", "sim", "I", "ji", "ix", "iu", " mi", "oi", "multi", "bi", " I", "in", "iter", "si", "index", "li", " bi", "y", "ini", "info", "gu", "fi", "it", " ni", "ci", "m", "this", "\u0438", "qi", "ip", "mi", "zi", " j", "ij", "batch", "ti", "status", "im", "point", "pi", "ki", "me", " si", "us"], "ret": ["flag", "err", "gt", "Ret", "dt", "rm", "arm", "vet", "print", "def", "ref", "tf", "reg", "t", "backed", "len", "ll", "magic", "ter", "jp", "cmd", "red", "mem", "sat", "git", "after", "rt", "RE", "hash", "txt", "status", "ben", "fun", " Ret", "result", "deg", " RET", "rem", "at", "out", "nt", "tmp", "mt", "try", "tr", "elt", "gc", "att", "opt", "RT", "RET", "ft", "mat", "rev", "success", "re", "format", "j", "usr", "val", "rets", "net", "back", "get", "ext", "reset", "fin", "ber", "cert", "det", "resp", "alt", "response"], "check_errors": ["check_error", " check_error", " check_notes", " check_rors", "check_notes", "check_rors"], "corruptions": ["orruptures", "corrotors", "corrotitions", "corruptedions", "orruptedors", "corrotures", "orruptedions", "corruptures", "corconnectures", "corconnectitions", "corruptitions", "orruptitions", "corruptors", "orruptors", "orruptedures", "corconnections", "orruptions", "corrupteditions", "corconnectors", "corruptedors", "orrupteditions", "corruptedures", "corrotions"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8720, "substitutes": {"opaque": ["opubis", "obque", "ogubis", "sphole", "obaque", " ophole", "ankque", " opsole", "spaques", " opaques", "spaque", "ankubis", "ankaque", "opque", "obaques", "oplhole", "ophole", "obubis", "ogaque", "opaques", "oplaques", "ogque", "spsole", "opsole", "ogaques", "ankaques", "oplsole", "oplaque"], "dcrn": ["dcrl", "dcrm", "docrn", "dprdn", "dprr", "dcrmn", "dncrdn", "dCrl", "dncrl", "dnCrn", " dcrb", " dctrr", "dprb", "dctrn", "docrl", "dCrmn", "dkrn", "dCrb", " dctrdn", "dnkrdn", " dcrr", "dgrdn", "dncrm", "dnkrr", " dcrdn", "dprn", "dgrr", "dkrdn", "dctrl", "dnkrn", "dctrb", "docrmn", "dCrn", "docrr", "dkrm", "dncrn", "dnkrm", "dctrmn", "dctrdn", "dnCrr", "dCrdn", "dcrdn", "dgrn", "dcrr", "dnCrl", "dctrr", "dnCrmn", "dCrr", "dncrr", " dctrn", "dcrb", " dctrb", "dncrmn", "dgrm", "dkrr", "dctrm"], "pob": ["pingrobe", " pobe", "paobe", "Pob", " pobb", "paome", "paob", "pingobs", "porp", "hoby", "phob", " pobs", "polobs", "polorp", "pobs", " poby", "poby", "paobs", "Pobb", "propob", " post", " probe", "pobb", "phobs", "pub", "pog", "phpub", "phpob", "propoby", "Pub", "post", "pingorp", "polob", "propog", "pingob", " pome", "hobb", "phome", "phpost", "probe", "pobe", "hog", "phobe", " pub", "hob", "phpobb", "propobb", "Post", "pome", " porp", "polrobe", " pog"], "ret": ["att", "oret", "pas", "pret", "pert", "flag", "RET", "ft", "cat", " Ret", "cont", "xt", "re", "__", "result", "uf", "gt", "Ret", " RET", "val", "ert", "rem", "at", "rm", "out", "liber", "nt", "des", "rets", "iter", "quad", "back", "print", "mt", " alt", " fut", "ext", "tr", "def", "get", "rest", "arr", "rt", "ref", "sys", "reset", "last", "it", "txt", "t", "res", "det", "ll", "alt", "aux", "nz", "arg", "jp", "cmd"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_erase(OneNANDState *s, int sec, int num)\n\n{\n\n    uint8_t *blankbuf, *tmpbuf;\n\n    blankbuf = g_malloc(512);\n\n    if (!blankbuf) {\n\n        return 1;\n\n    }\n\n    tmpbuf = g_malloc(512);\n\n    if (!tmpbuf) {\n\n        g_free(blankbuf);\n\n        return 1;\n\n    }\n\n    memset(blankbuf, 0xff, 512);\n\n    for (; num > 0; num--, sec++) {\n\n        if (s->bdrv_cur) {\n\n            int erasesec = s->secs_cur + (sec >> 5);\n\n            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n\n            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            if (sec + 1 > s->secs_cur) {\n\n                goto fail;\n\n            }\n\n            memcpy(s->current + (sec << 9), blankbuf, 512);\n\n            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n\n                   blankbuf, 1 << 4);\n\n        }\n\n    }\n\n\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 1;\n\n}\n", "idx": 8755, "substitutes": {"s": ["r", "ts", "less", "p", "h", "sb", "conf", "sw", "ses", "rs", "v", "ls", "qs", "ss", "its", "als", "es", "ps", "gs", "sim", "aws", "comm", "ops", "sts", "http", "ex", "n", "sq", "sm", "south", "sv", "fs", "b", "g", "is", "details", "bs", "has", "sam", "ms", "os", "ins", "y", "ysis", "bis", "js", "sys", "hs", "ds", "ssl", "stats", "states", "S", "c", "t", "status", "spec", "vs", "ims", "se", "sports", "ns"], "sec": ["secondary", "sync", "conf", "seq", "proc", "ses", "next", "sector", "esc", "sel", "Sec", "exec", "sect", "cur", "syn", "sup", "ser", "sic", "priv", "rec", "bc", "ct", "stat", "cond", "year", "j", "deg", "scroll", "SEC", "day", "th", "sen", "security", "ex", "inc", "sent", "sq", "nt", "secure", "size", "us", "src", "time", "enc", "seconds", "scan", "ec", "ss", "sd", "desc", "second", "sys", "reg", "max", "c", "https", "sc", "loc", "row", "con", "sub", "se", "isec", "isc", "pri"], "num": ["al", "uni", "nom", "x", "no", "span", "np", "um", "final", "proc", "mult", "un", "nb", "number", "__", "iq", "add", "ul", "en", "ju", "NUM", "cum", "comm", "th", "rem", "run", "multi", "quant", "n", "mun", " nu", "nm", "sym", "tim", "umi", "ums", " nm", "m", "cal", "nam", "Num", "nu", "sum", "con", "us", "mon", "msg"], "blankbuf": ["blankbuff", "boltprop", "birdbuf", "boldbuffer", " blankprop", "ankcmd", "blinddb", "birduf", "blackcap", "blankcap", "ankbox", "boltbuf", " blankbytes", " blankdb", "newbuf", "bridgefont", "blindbuf", "ankcap", "blackbuff", "blbuf", "boltbox", "boltuf", "blindbytes", "blankbox", " blankbuffer", "ankfont", "nullbuff", "blankdb", "ankbytes", "blankcmd", "blankfont", "nullbox", "blindcap", "boldbuf", "blackbox", "ankvec", "blankvec", "blackcmd", "blankbuffer", "birdbuff", "blankprop", "blackbuf", "newcap", "boltfont", "blindbox", "blankfb", "boltvec", "rainfb", "nullcap", "newbox", "bridgebuf", "blindbuff", "nullbuf", " blankuf", "ankuf", "newbuff", "blcap", "ankbuf", "boltdb", "blackmu", "blankbytes", "blackbuffer", "ankfb", " blankcap", "blinduf", "boldmu", "ankbuffer", "bridgevec", "blcmd", "boltbuff", "rainbuf", "blankmu", "blankuf", "ankdb", "ankbuff", "blackuf", "blackfb", " blankbuff", "rainbuff", "raindb", "boldbuff", "ankmu", " blankcmd", "bridgebox", "bldb", "blindcmd", "birdprop", "boltcmd", "blackdb"], "tmpbuf": ["blankbuff", "imguf", "tmpbuffer", "blankcb", "tmpcv", "tempcv", "tempbr", "imgcmd", "tmpcmd", "tmpuf", "tempvec", "tempuf", "blankbuffer", "tgcb", "tmpvec", "tabuf", "mpbr", "txtbuffer", "tmpcb", " tmpdata", "mpbuf", "mpbuffer", "txtbuf", "tmpdata", "imgbuffer", "mpcmd", "tempcb", "imgbuff", "tgbuff", " tmpbr", "mpuf", "tempbuffer", "imgbuf", "imgdata", "tgbuf", "tempbuf", "mpcv", "tempbuff", "tabcv", "txtuf", "mpbuff", " tmpvec", "tmpbr", "tabbuff", "tempdata", " tmpcmd", "blankdata", "tabbuf", " tmpuf", "tgdata", "txtbuff", " tmpbuff", "mpvec", " tmpbuffer", "blankuf", "tmpbuff"]}}
{"project": "qemu", "commit_id": "ff74f33c310892c90c4439d963a6ce67f47ce18c", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, Error **errp)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (ret == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 8793, "substitutes": {"desc": ["dc", "dist", "Desc", "seq", "comment", "err", "cont", "esc", "cur", "rec", "cd", "disc", "phrase", "lc", "raw", "rc", "des", "obj", "enc", "ext", "path", "asc", "ref", "pat", "req", "txt", "sc", "res", "resp", "description", "doc", "sub", "sort", "cmd"], "bs": ["ts", "cb", "bf", "sb", "rs", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "gs", "acs", "ubs", "bl", "fs", "bh", "b", "os", "bis", "sys", "js", "bes", "hs", "ds", "bits", "vs", "cs", "bm", "ns"], "desc_file_path": ["desc_file_pointer", "desc_File_length", "desc_file_name", "desc_file__path", "desc_File_name", "desc_file__name", "desc_file_Path", "desc_File_path", "desc_File_Path", "desc_File_pointer", "desc_file__length", "desc_file_length", "desc_file__pointer"], "errp": ["diepa", "dieP", "ermphp", "errpat", "erphp", "testpa", "ererpat", " errm", "nerping", "strping", "err", "errr", " errP", "erup", "erping", "riskpat", "errg", "strr", "diep", "errping", "errorpc", "invp", "invpat", " errpc", "Erp", "testphp", "ererpost", "errpc", "riskp", "errpa", "erp", " errpa", "errorm", "errphp", "Erm", "errorp", "ermp", "nerup", "invg", "ererg", "nerr", "testr", "errP", "ermr", "testp", "nerpa", "ererp", "errpost", "nerp", "erpa", "errup", "invpost", " errpb", "riskpost", "errorP", "Erpc", "errm", "nerpb", "riskg", "ermpa", "strup", "diepb", "strp", "nerP", "errpb", "ErP"], "ret": ["x", "flag", "err", "gt", "Ret", "dt", "print", "def", "ref", "tf", "t", "backed", "len", "ll", "ter", "cmd", "red", "sat", "cont", "code", "after", "lt", "rt", "hash", "it", "txt", "status", "res", "locked", "ben", "final", "fun", " Ret", "gov", "result", "prot", " RET", "deg", "rem", "out", "nt", "iter", "mt", "try", "tr", "bool", "elt", "inter", "gc", "rot", "r", "att", "cb", "RET", "ft", "rev", "v", "success", "re", "j", "usr", "tn", "val", "run", "rets", "net", "back", " alt", "get", "lit", "reset", "det", "resp", "alt"], "access": ["att", "usage", "ace", "sha", "acl", "seq", "acc", "rs", "attr", "accept", "read", "request", "esc", "test", "exec", "id", "url", "data", "stat", "pri", "ast", "priv", "Access", "str", "code", "ex", "array", "range", "config", "cast", "area", "a", "ax", "scan", "index", "act", "ext", "path", "ha", "asc", "view", "ref", "max", "escape", "open", "req", "alias", "accessible", "sc", "status", "exclusive", "est", "arch", "row", "mode", "aw", "use", "pass", "length", "error", "ac"], "type": ["types", "ype", "tag", "link", "test", "typ", "op", "id", "role", "pe", "tp", "version", "name", "title", "ver", "code", "ty", "key", "all", "change", "space", "null", "time", "size", "use", "area", "file", "te", "index", "address", "TYPE", "field", "shape", "Type", "info", "view", "otype", "style", "ref", "sys", "rage", "kind", "ped", "ime", "t", "buffer", "port", "table", "action", "description", "ping", "e", "color", "class", "lib", "length", "sort", "error"], "fname": [" fnames", "bfName", " fno", " fpath", "bfname", "vnames", "vName", "bfno", "Fpath", "fno", "vname", "Fname", "fpath", "bfnames", "FName", "fName", "vpath", "Fno", " fName", "fnames", "Fnames"], "p": ["r", "h", "pr", "np", "wp", "proc", "lp", "f", "i", "v", "pp", "perm", "pid", "pre", "op", "pb", "sp", "tp", "pg", "bp", "l", "ps", "pt", "j", "rep", "progress", "n", "o", "cp", "P", "a", "post", "b", "g", "d", "pa", "q", "fp", "pm", "ctx", "pat", "c", "m", "t", "ip", "port", "point", "resp", "ap", "ping", "pkg", "e", "pc", "vp", "jp"], "flat_offset": ["flat64Offset", "flat_slice", "flatxpointer", "full_slice", "flat_Offset", "flat_shift", " flat_Offset", "flatlyfield", " flatxpointer", "flat_set", "alt_pad", "flatlyindex", "flat_off", "flat_origin", "flattOffset", "flat_field", " flatxOffset", "full_offset", "flat_offs", "flat_pad", " flat_set", "flattorigin", "flattslice", " flat_pointer", " flat_index", "flat64offs", "flatlyOffset", "flat64offset", "flatlyoffset", " flatxset", "flattoffset", "flatxoffset", " flat_field", "flat_pointer", "full_origin", "alt_Offset", "flat64off", " flatxoffset", " flat_offs", "full_Offset", "flatxOffset", "flat_index", "alt_shift", " flat_off", "flatxset", "alt_offset"], "extent_path": ["extend_name", "extent2file", "extent_Path", "extend_Path", "extent2path", "extents_name", "extent___path", "extend_entry", "extent_name", "extend_path", "extents_path", "extentxentry", "extents_Path", "extent_info", "extent_entry", "extents_dir", "extentxpath", "extentxPath", "extend_file", "extentxname", "extent2info", "extend_info", "extent___file", "extent___info", "extent_dir"], "extent_file": ["extent2file", "extent_File", "extend_line", "extent2path", "extent_line", "extents_file", "extent2dir", "extents_path", "extents_dir", "extend_files", "extent_files", "extend_data", "extend_file", "extents_File", "extent_data", "extents_files", "extent2files", "extent_dir"], "s": ["ts", "h", "sb", "ats", "rs", "i", "v", "ls", "ries", "f", "sp", "ss", "es", "name", "ps", "str", "gs", "xs", "j", "ix", "ess", "n", "fs", "sv", "sym", "b", "is", "os", "ms", "times", "sd", "set", "js", "sys", "stats", "ds", "S", "t", "sum", "vs", "cs", "e", "stream", "us", "ns"], "extent": ["Extents", "Extent", "xtents", "extnt", "contents", "extend", "xtend", "content", "xtent", "contnt", "extents", "Extend", "xtnt", "contend", "Extnt"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 8794, "substitutes": {"arg": ["ack", "p", "ma", "mem", "attr", "ar", "v", "ret", "args", "alloc", "pack", "emb", "pg", "call", "mac", "val", "inc", "exc", "in", "obj", "bar", "ax", "g", "mb", "par", "act", "param", "arp", "arr", "ref", "reg", "argument", "Arg", "loc", "ig", "doc", "aw", "ag"], "op": ["ack", "update", "opt", "rop", "proc", "xy", "type", "hop", "oper", "perm", "typ", "wo", "sp", "ob", "pop", "OP", "Op", "ops", "ep", "xp", "obj", "par", "push", "what", "rol", "bit", "cmp", "ok", "oe", "it", "operator", "cod", "top", "ip", "mop", "up", "opp", "k", "spec", "operation", "jp", "cmd"], "mutex": ["munEx", "petEx", "mandix", " mutext", "mutry", "mobux", " mutEx", "matect", "mobsex", "mandax", " mutax", "Mutex", " mutry", "mobEx", " mutact", "metix", "metax", "pirex", "cmdex", "matx", "munact", "metx", "muntx", "matEx", " mutx", " mutsex", "matact", "mitix", "cmdexclusive", "mandEX", "Mutgex", "MutEx", "mutw", "munw", " mutix", "mtexclusive", "mutact", "mandex", "cmdtex", "muthex", "pirix", "mttex", "Mutax", "cmdx", "matw", "Mutect", "Mutact", "mtext", "mutext", "mobex", "mtact", "muttex", "mutux", "mutect", "mandext", "munx", "mutress", "mutix", "mutEx", " mutect", "mithex", "mutexclusive", "munex", "mutgex", "metexclusive", "mitgex", "mandhex", "mutsex", "mandact", "Mutw", "metex", "mitry", "pirx", " mutress", " mutux", "petsex", "matex", "munexclusive", "mtEX", "muttx", "mutax", "Mutexclusive", "petex", "mtex", "Mutry", "mutx", "mitex", "petux", " muthex", "pirress", "mutEX", "munect", " muttx", " mutexclusive", "mitEx", " mutgex", "muntex", "mitax", " mutEX", "mtx", "metress", "mattx", "metEx"], "err": ["r", "or", "extra", "dev", "cr", "pr", "init", "die", "aaa", "conf", "dr", "Er", "ev", "yr", "rev", "attr", "coord", "rr", "test", "cfg", "norm", "fee", "warn", "str", "fr", "usr", "good", "nr", "Error", "hz", "raw", "order", "exc", "notice", "cor", "obj", "buf", "errors", "peer", "iter", "er", "cer", "gz", "my", "ner", "try", "ach", "arr", "elt", "sys", "mr", "rar", "kr", "oe", "br", "rn", "req", "here", "ger", "ns", "later", "res", "rb", "inner", "resp", "timer", "state", "eor", "msg", "error", "cmd"], "tmp": ["appy", "p", "mm", "snap", "aaa", "init", "np", "proc", "xy", "attr", "v", "perm", "alloc", "nb", "sp", "stuff", "tm", "tar", "data", "cur", "test", "priv", "tp", "tt", "vm", "null", "nt", "obj", "temp", "buf", "src", "buff", "emp", "mut", "vt", "cp", "app", "mb", "sam", "mk", "mint", "etc", "gm", "var", "tab", "tty", "arr", "copy", "cmp", "rt", "empty", "ctx", "m", "mp", "txt", "t", "pkg", "template", "msg", "orig", "ptr", "comp", "imm", "img"]}}
{"project": "FFmpeg", "commit_id": "aacc6615f8e3863cd930d3a1ab2cd28d9838f0f5", "target": 1, "func": "static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){\n\n    MotionEstContext * const c= &s->me;\n\n    Picture *p= s->current_picture_ptr;\n\n    int mb_xy= mb_x + mb_y*s->mb_stride;\n\n    int xy= 2*mb_x + 2*mb_y*s->b8_stride;\n\n    int mb_type= s->current_picture.mb_type[mb_xy];\n\n    int flags= c->flags;\n\n    int shift= (flags&FLAG_QPEL) + 1;\n\n    int mask= (1<<shift)-1;\n\n    int x, y, i;\n\n    int d=0;\n\n    me_cmp_func cmpf= s->dsp.sse[0];\n\n    me_cmp_func chroma_cmpf= s->dsp.sse[1];\n\n    \n\n    assert(p_type==0 || !USES_LIST(mb_type, 1));\n\n    assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1));\n\n    \n\n    if(IS_INTERLACED(mb_type)){\n\n        int xy2= xy  + s->b8_stride;\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n        c->stride<<=1;\n\n        c->uvstride<<=1;\n\n        init_interlaced_ref(s, 2);\n\n        \n\n        assert(s->flags & CODEC_FLAG_INTERLACED_ME);\n\n\n\n        if(USES_LIST(mb_type, 0)){\n\n            int field_select0= p->ref_index[0][xy ];\n\n            int field_select1= p->ref_index[0][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            if(p_type){\n\n                s->p_field_select_table[0][mb_xy]= field_select0;\n\n                s->p_field_select_table[1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->p_field_mv_table[0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->p_field_mv_table[1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER_I;\n\n            }else{\n\n                s->b_field_select_table[0][0][mb_xy]= field_select0;\n\n                s->b_field_select_table[0][1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->b_field_mv_table[0][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->b_field_mv_table[0][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_FORWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[0][xy ][0]; \n\n            y= p->motion_val[0][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[0][xy2][0]; \n\n            y= p->motion_val[0][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1, 1, cmpf, chroma_cmpf, flags);\n\n        }\n\n        if(USES_LIST(mb_type, 1)){\n\n            int field_select0= p->ref_index[1][xy ];\n\n            int field_select1= p->ref_index[1][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            s->b_field_select_table[1][0][mb_xy]= field_select0;\n\n            s->b_field_select_table[1][1][mb_xy]= field_select1;\n\n            *(uint32_t*)s->b_field_mv_table[1][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[1][xy ];\n\n            *(uint32_t*)s->b_field_mv_table[1][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[1][xy2];\n\n            if(USES_LIST(mb_type, 0)){\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BIDIR_I;\n\n            }else{\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BACKWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[1][xy ][0]; \n\n            y= p->motion_val[1][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0+2, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[1][xy2][0]; \n\n            y= p->motion_val[1][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1+2, 1, cmpf, chroma_cmpf, flags);\n\n            //FIXME bidir scores\n\n        }\n\n        c->stride>>=1;\n\n        c->uvstride>>=1;\n\n    }else if(IS_8X8(mb_type)){\n\n\n        cmpf= s->dsp.sse[1];\n\n        chroma_cmpf= s->dsp.sse[1];\n\n        init_mv4_ref(s);\n\n        for(i=0; i<4; i++){\n\n            xy= s->block_index[i];\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chroma_cmpf, flags);\n\n        }\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER4V;\n\n    }else{\n\n        if(USES_LIST(mb_type, 0)){\n\n            if(p_type){\n\n                *(uint32_t*)s->p_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER;\n\n            }else if(USES_LIST(mb_type, 1)){\n\n                *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR;\n\n            }else{\n\n                *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD;\n\n            }\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags);\n\n        }else if(USES_LIST(mb_type, 1)){\n\n            *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD;\n\n           \n\n            x= p->motion_val[1][xy][0]; \n\n            y= p->motion_val[1][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags);\n\n        }else\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n    }\n\n    return d;\n\n}", "idx": 8815, "substitutes": {"s": ["changes", "sb", "ses", "ls", "aws", "comm", "sv", "as", "bis", "js", "sys", "https", "source", "se", "ms", "w", "ins", "ns", "less", "h", "ats", "conf", "sw", "params", "settings", "ps", "acs", "http", "parts", "sq", "fs", "a", "app", "set", "sg", "stats", "ds", "comments", "sc", "services", "vs", "asm", "cs", "ims", "storage", "ports", "its", "ops", "ex", "space", "is", "b", "g", "os", "ctx", "hs", "spec", "conv", "self", "ts", "rs", "ss", "es", "als", "csv", "gs", "sts", "service", "details", "css", "m", "S", "bs", "qs", "ants"], "mb_x": ["emb_y", "mbaxyx", "mb00x", "emb_image", "emb_wx", " MB08x", " MB_wx", "emb_xx", "mbjyx", "mb00xx", "mb_xx", "mbaxyimage", "mb08x", "mbaxyex", "mbjy", "mb_ex", " MB08ex", " MB_x", "mb_wx", "mbaxywx", "mb08ex", "mbjx", "mb00y", " MB08image", "mb_image", "mbjwx", "mb08wx", "mb08image", "mb_yx", " MB08wx", " MB_image", "emb_x", "mb00image", "emb_yx", " MB_ex"], "mb_y": ["ob_x", "mb08ye", "mb_ym", "mb68gy", "mb__Y", "mb_ey", "ram68gy", "mb_Y", "ram68Y", "ob_Y", "mb2ey", "ram68y", "mb2gy", "ob_xy", "mb08y", "mb68y", "mb_xy", "ebin_yd", "ram_y", "mb08yd", "mb_ye", "ram_ey", "mb68Y", "ram_Y", "ob_y", "ebin_ym", "ebin_y", "mb__x", "mb_gy", "mb68ey", "mb2Y", "mb__y", "mb08ym", "mb2y", "ram_gy", "mb__xy", "ebin_ye", "ram68ey", "mb_yd"], "p_type": ["P_types", "p__type", "pb_kind", "pb_type", "P__ype", "p_Type", "p__Type", "m_name", "pairtype", "P_type", "P_ype", "pairype", "p__ype", "p__types", "pairkind", "P__type", "pairtypes", "pb_types", "p_port", "p_types", "m_type", "m_port", "m_Type", "P__Type", "pbairtypes", "P_Type", "pbairype", "p_kind", "pb_ype", "pbairkind", "p_name", "P__types", "p_ype", "pbairtype"], "c": ["r", "dc", "coll", "h", "co", "conf", "C", "cf", "tc", "f", "v", "cm", "cont", "cam", "csv", "bc", "abc", "ct", "comm", "lc", "cu", "cc", "rc", "config", "o", "cp", "cv", "a", "b", "g", "d", "cache", "ec", "com", "ca", "ctx", "ce", "m", "mc", "t", "sc", "con", "can", "cs", "e", "gc", "pc", "w", "ac"], "p": ["r", "pro", "pic", "pr", "h", "wp", "proc", "lp", "f", "pp", "v", "sp", "pb", "op", "pe", "tp", "bp", "l", "pt", "ps", "j", "o", "cp", "P", "g", "b", "app", "pa", "ph", "fp", "pm", "m", "mp", "t", "ip", "ap", "pi", "pkg", "pc", "e", "php", "jp"], "x": ["r", "X", "on", "dx", "xy", "px", "f", "v", "z", "l", "xs", "ox", "xi", "ix", "ex", "o", "a", "ax", "index", "tx", "rx", "m", "e", "w"], "y": ["ny", "py", "yn", "yi", "xy", "v", "dy", "vy", "hy", "oy", "j", "ys", "ey", "iy", "o", "b", "yy", "Y", "ay", "ry", "ym", "m", "cy", "sy", "ye", "gy"], "i": ["r", "f", "v", "id", "l", "j", "I", "bi", "n", "in", "o", "a", "b", "g", "d", "index", "q", "it", "m", "t", "mi", "ij", "pi", "e", "k", "w"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "void ff_estimate_p_frame_motion(MpegEncContext * s,\n\n                                int mb_x, int mb_y)\n\n{\n\n    UINT8 *pix, *ppix;\n\n    int sum, varc, vard, mx, my, range, dmin, xx, yy;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    int mb_type=0;\n\n    uint8_t *ref_picture= s->last_picture[0];\n\n\n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[0];\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + 2         ][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + 2         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x = P[4][0];\n\n                pred_y = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x= P[1][0];\n\n                pred_y= P[1][1];\n\n            }\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_4MV){\n\n        int block;\n\n\n\n        mb_type|= MB_TYPE_INTER4V;\n\n\n\n        for(block=0; block<4; block++){\n\n            int mx4, my4;\n\n            int pred_x4, pred_y4;\n\n            int dmin4;\n\n            static const int off[4]= {2, 1, 1, -1};\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[block];\n\n            const int block_x= mb_x*2 + (block&1);\n\n            const int block_y= mb_y*2 + (block>>1);\n\n\n\n            const int rel_xmin4= xmin - block_x*8;\n\n            const int rel_xmax4= xmax - block_x*8 + 8;\n\n            const int rel_ymin4= ymin - block_y*8;\n\n            const int rel_ymax4= ymax - block_y*8 + 8;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + off[block]][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + off[block]][1];\n\n                if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift);\n\n                if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift);\n\n                if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift);\n\n                if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x4 = P[4][0];\n\n                pred_y4 = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x4= P[1][0];\n\n                pred_y4= P[1][1];\n\n            }\n\n            P[5][0]= mx - mb_x*16;\n\n            P[5][1]= my - mb_y*16;\n\n\n\n            dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture);\n\n\n\n            halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, \n\n                                   pred_x4, pred_y4, block_x, block_y, ref_picture);\n\n     \n\n            s->motion_val[ s->block_index[block] ][0]= mx4;\n\n            s->motion_val[ s->block_index[block] ][1]= my4;\n\n        }\n\n    }\n\n\n\n    /* intra / predictive decision */\n\n    xx = mb_x * 16;\n\n    yy = mb_y * 16;\n\n\n\n    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    sum = pix_sum(pix, s->linesize);\n\n#if 0\n\n    varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS;\n\n    vard = pix_abs16x16(pix, ppix, s->linesize);\n\n#else\n\n    sum= (sum+8)>>4;\n\n    varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8);\n\n    vard = (pix_norm(pix, ppix, s->linesize)+128)>>8;\n\n#endif\n\n\n\n    s->mb_var[s->mb_width * mb_y + mb_x] = varc;\n\n    s->avg_mb_var+= varc;\n\n    s->mc_mb_var += vard;\n\n\n\n    \n\n#if 0\n\n    printf(\"varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\\n\",\n\n\t   varc, s->avg_mb_var, sum, vard, mx - xx, my - yy);\n\n#endif\n\n    if(s->flags&CODEC_FLAG_HQ){\n\n        if (vard*2 + 200 > varc)\n\n            mb_type|= MB_TYPE_INTRA;\n\n        if (varc*2 + 200 > vard){\n\n            mb_type|= MB_TYPE_INTER;\n\n            halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n        }else{\n\n            mx = mx*2 - mb_x*32;\n\n            my = my*2 - mb_y*32;\n\n        }\n\n    }else{\n\n        if (vard <= 64 || vard < varc) {\n\n            mb_type|= MB_TYPE_INTER;\n\n            if (s->me_method != ME_ZERO) {\n\n                halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n            } else {\n\n                mx -= 16 * mb_x;\n\n                my -= 16 * mb_y;\n\n            }\n\n#if 0\n\n            if (vard < 10) {\n\n                skip++;\n\n                fprintf(stderr,\"\\nEarly skip: %d vard: %2d varc: %5d dmin: %d\", \n\n                                skip, vard, varc, dmin);\n\n            }\n\n#endif\n\n        }else{\n\n            mb_type|= MB_TYPE_INTRA;\n\n            mx = 0;//mx*2 - 32 * mb_x;\n\n            my = 0;//my*2 - 32 * mb_y;\n\n        }\n\n    }\n\n\n\n    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    set_p_mv_tables(s, mx, my);\n\n}\n", "idx": 8825, "substitutes": {"s": ["changes", "sb", "ses", "ls", "aws", "comm", "sm", "sv", "sym", "as", "er", "sam", "bis", "js", "sys", "c", "t", "source", "se", "ms", "w", "ins", "ns", "less", "h", "ats", "sw", "qs", "settings", "ps", "an", "http", "sq", "a", "fs", "set", "stats", "ds", "vs", "cs", "ims", "p", "i", "its", "ties", "l", "ops", "b", "g", "is", "os", "times", "hs", "webkit", "so", "spec", "e", "us", "r", "ts", "rs", "f", "v", "ss", "es", "z", "gs", "j", "sts", "n", "details", "m", "S", "bits", "bs", "sports"], "mb_x": ["mb_X", "mp_yx", "mboxx", "mbFx", "mb__rx", "mb___key", "MB__x", "mb_rx", "mboxX", "mp_y", "mb_key", "mp_xy", "MB__X", "mb__ex", "MB_x", "MB_ex", "mbFxy", "mp_xi", "mb_xy", "mboxex", "MB_X", "mb_ex", "mp_x", "mb__X", "MB_rx", "mb__x", "mb___yx", "mb___x", "mbFxi", "MB__rx", "mb_yx", "mb_xi", "MB__ex", "mboxrx", "mp_key", "mb___y"], "mb_y": ["mm_ey", "mb3yo", "mb__my", "mm_y", "mb3sy", "mm_Y", "mb__Y", "mb_ey", "mb_yo", "mb_Y", "mp_y", "mm_x", "mp_yo", "mb_sy", "mb__x", "mb3Y", "mp_Y", "emb_my", "mb__y", "mb_my", "mp_sy", "emb_Y", "mb3y", "emb_x", "emb_y"], "pix": ["ppixels", "piix", " pci", "piixels", "pIX", "pici", "pci", "pixels", " pixels", " pIX", "ppci", "ppIX", "piIX"], "ppix": ["spw", "ppw", "dpix", "spx", "spIX", "mpw", "spix", "dpx", "mpix", "dpw", "mpx", "ppIX", "ppx", "dpIX", "mpIX"], "sum": ["um", "mem", "vol", "sup", "hum", "add", "sim", "cum", "total", "count", "mean", "post", "scale", "si", "sam", "Sum", "hash", "cal", "volume", "num", "sc", "sun", "frac", "star", "doc", "score", "ram", "fac"], "varc": [" vasc", "vparm", "vpasc", "vpip", "varm", " vip", "vip", "evip", " varm", "vparc", "vasc", "evasc", "evarm", "evarc"], "vard": ["av", "fps", "cap", "std", "vol", "sp", "ss", "hd", "mix", "sex", "cv", "src", "zh", "scale", "tv", "act", "dim", "var", "box", "uv", "cal", "vd", "cod", "num", "sc", "base", "au", "aux", "vid", "comp"], "mx": ["mm", "x", "fax", "nox", "xy", "windows", "px", "MX", "xes", "mas", "mph", "yz", "xs", "ox", "mac", "vm", "ml", "wx", "cp", "ax", "mt", "mb", "mk", "axy", "mie", "phys", "mot", "tx", "mouse", "fx", "max", "mr", "pm", "ctx", "lex", "ux", "mic", "mc", "rx", "mp", "yx", "mi", "mort", "xml", "me", "ms", "nz", "mn"], "my": ["ny", "mm", "ami", "py", "where", "ery", "mem", "xy", "MY", "colm", "les", "wi", "mph", "My", "dds", "maybe", " My", "mmm", "thing", "ys", "vm", "ty", " MY", "multi", "sym", "mt", "mk", "try", "mis", "mie", "axy", "y", "mn", "mouse", "ym", "pm", "mic", "mc", "mp", "cy", "ody", "mi", "memory", "Mi", "mys", "their", "ms", "your", "gy"], "range": ["r", "lim", "usage", "conf", "span", "feature", "type", "rang", "args", "frame", "re", "radius", "call", "angle", "release", "window", "arg", "route", "rate", "multiple", "progress", "slice", "change", "space", "size", "bound", "area", "diff", "resource", "remote", "domain", "ange", "scale", "history", "ranging", "ch", "transform", "get", "ANGE", "path", "ro", "term", "rage", "ref", "max", "gb", "force", "reg", "view", "move", "m", "cal", "spread", "req", "chain", "filter", "ge", "res", "batch", "base", "race", "row", "loc", "mode", "Range", "ram", "use", "length", "edge", "scope"], "dmin": ["dMIN", " dminute", "dmn", "tdmins", "tdmid", "ddmins", "Dni", "domin", "ddrain", "dMin", "Dmins", " drain", "didinit", "drain", "rdmin", "tdmin", "dinit", "drainit", "rdinit", "ddmn", "ddmin", "doneinit", "didmin", "draminute", "didMIN", "Dmin", "rdlower", "dni", "domins", "dxmin", " dmid", " dMIN", " dmn", "dlower", "doni", "ddim", " ddim", "dxrain", "dmid", "rdMIN", "DMin", "didlower", "dramin", "Dmid", " dni", "doMin", "dminute", "tdMin", " dMin", "dmins", "dxmins", "donedim", "doneminute", " dmins", "dxmn", " dlower", " dinit", "donemin", "dradim"], "xx": ["mm", "zz", "fy", "nn", "dx", "xy", "zx", "dd", "ss", "cross", "yz", "xs", "ox", "xi", "sky", "mix", "xp", "wx", "phot", "mk", "foo", "xxxx", "fx", "xxx", "ux", "yx", "XX"], "yy": ["py", "fy", "yn", "xy", "uy", "yr", "vy", "dy", "YY", "yu", "oy", "ys", "ey", "dt", "yk", "iy", "yd", "sym", "axy", "y", "Y", "yt", "xxx", "ym", "yx", "yl", "gy"], "xmin": ["exmin", "xMIN", "xadmin", "xstart", "xmid", "atmins", "xaadmin", "ixmax", "exstart", "Xmin", " xMin", " xbegin", "xamin", "ixmon", "xmins", " xadmin", "atmin", " xmins", "xamax", "XMin", "lexmin", "ypre", "lexmax", " xMIN", "atminute", "rxmins", " xminute", "lexmid", "rxadmin", "xaMin", "Xmax", "fxmin", "fxMIN", "exmon", "XMIN", "txmax", "txstart", "rxmax", "xmon", "xminute", "exmax", " xpre", "txmin", "txmon", "xMin", "xbegin", " xmid", "xxxxbegin", "xxxxmin", "yMin", "ixmin", "ymins", "xxxxmax", "lexbegin", "fxMin", "atmax", "fxmax", "xamins", "xpre", "ixstart", "rxmin", "xxxxmid", "yminute", "xapre"], "ymin": ["axymax", "uymin", "nymin", "lyfirst", "oxmax", "erymind", "xMIN", " yname", " ymind", "ypath", "nyfirst", " ylocal", "Ymax", "axymain", "uypath", "ymain", "ymind", "lypath", "iymin", "xax", "nyMIN", "erymin", "symins", "erylocal", "lystore", " ymain", "oxax", "xname", "symin", "axylocal", "nymins", "uyfirst", "oxmin", "iyname", "yname", "axymin", "nyax", "erymax", "cymin", "ystore", "ylocal", "nypath", "iymain", "yax", "nystat", "erymain", "yMIN", "nymax", "Ymins", "uystore", "Ymin", "iymax", "systat", "cymax", "yfirst", "ymins", "oxMIN", "lymin", "nystore", "symax", "cymind", "ystat", "Ystat", "xmain"], "xmax": [" xMax", "xMax", " xMAX", "oxmax", "ylast", "exmin", "Xax", "xstart", "xMAX", "exax", "yMAX", "exMax", "xmlMAX", " xhost", "Xmin", "ixmax", "ixview", "oxview", "exlast", "XMAX", "xax", "eyhost", "yMax", "xmlax", "xhost", "xview", "xend", "oxstart", "Xmax", "fxmin", "fxax", "pxmin", "xmlstart", "yax", "yhost", "oxend", "xmlend", "exmax", "eymax", "pxmax", " xax", "xmlmax", "xlast", "fxMAX", "ixend", "xmlview", "fxmax", "ixstart", "eyax", "pxlast", "eymin"], "ymax": ["ypaxy", "ypAX", "irmax", "iemaz", "ymmag", "iemaxy", "ymmAX", "ymAX", "ydmax", "ermart", "ymask", "ymmaxy", "ymmain", "ermame", "ymmaz", "ypask", "ypame", "ymmart", "yask", "ymain", "ymmask", "iemmax", "hyain", "ypart", "ymmas", "ymmax", "irmmax", "ypag", "ymas", "ypmax", "ypake", "irmAX", "ymaz", "iemax", "symas", "hyax", "ymmake", "hyas", "ymart", "ypax", "ypaz", "yake", "ymame", "ymag", "hyap", "ydax", "ermag", "iemand", "ermax", "yax", "symap", "ymmame", "ymmap", "irmaz", "ymaxy", "iemake", "ymand", "ydand", "ydake", "ymap", "ypand", "ymake", "symax", "symain", "ymmmax", "yaz"], "rel_xmin": ["rel_zmod", "rel_xname", "rel_xpath", "rel_xfirst", "rel_ixname", "rel_onmin", "rel_yname", "rel_onfirst", "rel_ixpath", "rel_ixmax", "rel_xmod", "rel_onmax", "rel_zmax", "rel_onmod", "rel_ixmin", "rel_zfirst", "rel_ymod", "rel_yfirst", "rel_zmin", "rel_ypath"], "rel_ymin": ["rel_xmind", "rel_symind", "rel_cyleft", "rel_cmap", "rel_cymin", "rel_symin", "rel_cmin", "rel_symap", "rel_ymap", "rel_trymin", "rel_symax", "rel_yleft", "rel_cymax", "rel_xmon", "rel_trymon", "rel_cmind", "rel_cymon", "rel_ymon", "rel_xleft", "rel_cmax", "rel_tryleft", "rel_trymax", "rel_xmap", "rel_ymind"], "rel_xmax": ["rel_yxmin", "rel_Xmax", "rel_oxmin", "rel_xax", "rel_xmed", "rel_exmax", "rel_yxax", "rel_exax", "rel_yxmax", "rel_exmed", "rel_exmin", "rel_xcross", "rel_oxmax", "rel_oxax", "rel_yax", "rel_ycross", "rel_Xmin", "rel_yxcross", "rel_Xax", "rel_Xcross", "rel_ymed", "rel_oxmed"], "rel_ymax": ["rel_nmax", "rel_ymmaj", "rel_ymmap", "rel_yymax", "rel_wyagic", "rel_nmap", "rel_ymagic", "rel_ymmax", "rel_ymmmax", "rel_yagic", "rel_yyaj", "rel_ymask", "rel_ymap", "rel_yyap", "rel_wyask", "rel_nmmax", "rel_ymmask", "rel_yask", "rel_ymmagic", "rel_yyax", "rel_wyax", "rel_wyaj", "rel_ymaj", "rel_yax", "rel_yaj", "rel_nmaj"], "P": ["p", "GP", "X", "O", "Q", "PRE", "PIN", "C", "PT", "D", "SCP", "M", "AP", "PP", "T", "TP", "N", "PR", "W", "G", "vP", "Z", "R", "PUT", "PU", "I", "PO", "PM", "Ps", "PI", "Pro", "H", "SP", "CP", "Array", "B", "BP", "DP", "Y", "K", "Progress", "PS", "F", "J", "V", "PC", "S", "PE", "E", "PA", "L", "IP"], "ref_picture": ["ref2profile", "refptpolicy", "ref2Picture", "refptmanager", "ref_Picture", "ref_media", " ref_manager", " ref_Picture", "ref_profile", "ref2image", " ref_image", " ref_profile", "rel_picture", "refptmedia", "ref_pict", "rel_policy", " ref_policy", "ref_image", "ref_manager", "rel_memory", " ref_pict", "ref2picture", "refptpicture", "ref2pict", "ref_policy", " ref_media", "ref_memory"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAAPIEncodePicture *pic, *next;\n\n\n\n    for (pic = ctx->pic_start; pic; pic = next) {\n\n        next = pic->next;\n\n        vaapi_encode_free(avctx, pic);\n\n    }\n\n\n\n    if (ctx->va_context != VA_INVALID_ID) {\n\n        vaDestroyContext(ctx->hwctx->display, ctx->va_context);\n\n        ctx->va_context = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->va_config != VA_INVALID_ID) {\n\n        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);\n\n        ctx->va_config = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->codec->close)\n\n        ctx->codec->close(avctx);\n\n\n\n    av_buffer_pool_uninit(&ctx->output_buffer_pool);\n\n\n\n    av_freep(&ctx->codec_sequence_params);\n\n    av_freep(&ctx->codec_picture_params);\n\n\n\n    av_buffer_unref(&ctx->recon_frames_ref);\n\n    av_buffer_unref(&ctx->input_frames_ref);\n\n    av_buffer_unref(&ctx->device_ref);\n\n\n\n    av_freep(&ctx->priv_data);\n\n\n\n    return 0;\n\n}\n", "idx": 8835, "substitutes": {"avctx": ["wavctx", "cvreq", "avqt", "cvctx", "avtx", "cvtx", " avqt", " avcfg", " avcc", "vcfg", "avcc", "vreq", "AVcontext", "AVcmd", "vqt", "wavcfg", "avcmd", "vctx", "cvcontext", " avcontext", "wavcontext", "navctx", "navqt", "avcfg", "wavcc", "navcontext", "AVctx", "vcc", " avtx", " avcmd", "avreq", "avcontext", "vtx", "navtx", " avreq", "AVtx", "vcontext", "vcmd"], "ctx": ["co", "np", "tc", "err", "cm", "cfg", "ind", "compl", "nc", "xs", "comm", "ka", "progress", "cp", "fn", "history", "pa", "iat", "ann", "batch", "kw", "loc", "xc", "pkg", "wcs", "ppo", "jp", "ns", "cmd", "conf", "addr", "std", "ic", "tm", "lc", "ctl", "obj", "config", "expr", "kl", "act", "mk", "etc", "shape", "tx", "desc", "rt", "mc", "ctrl", "req", "txt", "anc", "msg", "scope", "today", "cons", "conn", "cf", "wp", "ck", "exec", "warn", "crit", "tk", "parent", "quit", "xp", "nt", "tmp", "prefix", "mt", "cmp", "checked", "gc", "doc", "ctr", "comp", "hw", "func", "cb", "timeout", "proc", " cx", "px", "args", "tp", "fc", "pg", "reason", "ct", "cond", "cl", "jac", "dl", "val", "cc", "wx", "cv", "td", "inst", "work", "lex", "check", "kt", "resp", "context"], "pic": ["p", "pas", "pr", "py", "pl", "snap", "np", "pres", "px", "pp", "sp", "pb", "ic", "pict", "eric", "syn", "cam", "sci", "bc", "pot", "ps", "Pic", "pg", "shot", " nic", "picture", "capt", "nic", "pn", "spr", "prev", "pipe", "pick", "piece", "peg", "icon", "feat", "tmp", "photo", "phot", "ics", "pa", "png", "par", "Picture", "pse", "pers", "li", "pan", "tx", "pin", "pat", "mc", "pen", "txt", "fig", "anc", "ping", "pi", "pc", "ig", "image", "img", "jp"], "next": ["p", "step", "pr", "nd", "nn", "span", "np", "seq", "link", "pp", "head", "ng", "pb", "data", "pict", "Next", "sp", "end", "z", "frame", "nc", "gov", "j", "gt", "start", "nr", "new", "future", "pn", "inc", "after", "prev", "nl", "n", "config", "nt", "peer", "ne", "size", "fn", "png", "sec", "ner", "path", "li", "info", "big", "first", "desc", "sys", "max", "adj", "sequence", "last", "txt", "nw", "inner", "ping", "pc", "ptr", "gen", "msg", "jp", "ns"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n", "idx": 8846, "substitutes": {"sockfd": ["sockspid", "sinkf", "sackf", "sinkpid", " sinkfile", "sockptr", "sinkfp", "socksfd", " sinkfin", " sockfp", "tsocksptr", "tsockpid", "sinkptr", "tsockfd", "sackfin", "sackptr", "sockfile", "sackfp", "sackfile", "sickfp", "sickfd", "sockf", "tsockptr", "sickfin", "sockfp", " sockfile", " sinkfd", "socksf", "sockpid", "sinkfile", "tsocksf", "sickfile", "tsocksfd", "sinkfd", "sockfin", " sockfin", "socksptr", "sackpid", "sackfd", "sinkfin", "tsockspid", "tsockf", " sinkfp"], "buff": ["p", "cb", "bf", "nd", "off", "mem", "bin", "ff", "f", "v", "read", "pb", "data", "ob", "ind", "butt", "uf", "fr", "cond", "bb", "raw", "quit", "bl", "buf", " buf", "obj", "tmp", "bound", "b", "form", "bytes", "hold", "ext", "tab", "ref", "grow", "Buff", "txt", "t", "text", "buffer", "batch", "orig", "bs", "msg", "uff", "cmd"], "size": ["done", "equal", "send", "news", "no", "timeout", "type", "read", "sh", "args", "success", "sp", "z", "speed", "function", "name", "needed", "fee", "capacity", "year", "code", "good", "ose", "small", "global", "scroll", "all", "sent", "total", "complete", "count", " Size", "zone", "g", "scale", "Size", "index", "si", "required", "shape", "term", "empty", "full", "sn", "set", "style", "max", "offset", "ize", "c", "t", "buffer", "body", "len", "sum", "status", "num", "table", "valid", "iz", "e", "state", "SIZE", "length", "zero", "scope"], "retval": ["rtVal", "exteval", "RetVAL", "extval", "retVal", "reteval", " retVAL", "rev", "rVAL", " retvals", " returnVAL", "returnvalue", "returnval", "eltVal", " returnvalue", "altvalue", "pretvals", "reval", " reteval", "retvals", "Retvals", " returnVal", "rtVAL", "interVal", "returneval", " retvalue", "rtvalue", " retVal", "alteval", "returnVal", "altVAL", "Retval", " returnval", "pretval", "eltvalue", "altval", "preteval", "extVAL", "retv", "elteval", "retvalue", "eltval", "reeval", "rVal", "Reteval", "rtval", "rv", "intereval", "retVAL", "extvalue", "rval", " retv", "RetVal", "interval", "pretVal", "reVal"]}}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n", "idx": 8855, "substitutes": {"blk": ["Blck", "BlK", " blK", "Blj", "slck", "brkt", "blkt", "brck", "slK", " blkt", "Blak", " blak", "Blkt", " blck", "slak", "blK", "blak", "slk", " blj", "blck", "brj", "brk", "Blk", "blj"]}}
{"project": "qemu", "commit_id": "6f864e6ec8812d5a5525a7861ca599c6bcabdebe", "target": 0, "func": "static int vfio_load_rom(VFIODevice *vdev)\n\n{\n\n    uint64_t size = vdev->rom_size;\n\n    char name[32];\n\n    off_t off = 0, voff = vdev->rom_offset;\n\n    ssize_t bytes;\n\n    void *ptr;\n\n\n\n    /* If loading ROM from file, pci handles it */\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n\n        return 0;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n\n    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n\n    memset(ptr, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->fd, ptr + off, size, voff + off);\n\n        if (bytes == 0) {\n\n            break; /* expect that we could get back less than the ROM BAR */\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            memory_region_destroy(&vdev->pdev.rom);\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);\n\n    vdev->pdev.has_rom = true;\n\n    return 0;\n\n}\n", "idx": 8858, "substitutes": {"vdev": ["vercomment", "uvserial", "svdev", "avdiv", " vdat", "svobj", "svDev", " vserial", "valdevice", "varcomment", "vcstat", "vreq", "vmpad", "vardd", "vctry", "vev", " vpriv", "vccomment", "uvrad", " vver", "viewdev", "vtgu", "evdes", "uvcast", "vmgu", "vpad", "vdiv", "vstore", " vdd", "vdat", "vvalid", "pstat", "wdev", "wdevice", "Vdev", "hev", "svdevice", " vval", "verDEV", " vcomment", "uvpriv", "ivDEV", "hgo", "verdev", "pev", "fcmd", "uvgu", "varpriv", "enwd", "vcev", "vardev", "valdiv", "vDEV", "vcdes", "convpad", "svcomment", " vDev", "wstat", "uvdev", "vtvalid", "ovgo", "vergo", "convval", " vobj", "vcDEV", "ivcomment", "evgo", " vDEV", "vvdev", "ovdev", "avcast", "avdev", "vardiv", "ivpad", "wev", "nvcast", "vver", "vdevice", "nvdev", "vcver", "pdev", "vtdev", "verstore", "pdevice", "endev", "valdev", "vtry", " vgo", "valcast", "vcpay", " vstore", "ovDev", "fdev", "vserv", " vdiv", "vartry", "vcmd", "svdef", "evdevice", "vwd", "vstat", "uvdevice", " vconn", "vcserv", "convdev", "svgo", "evdef", "vdes", "uvstore", "ivtry", "evobj", "vvDev", "avpad", "avver", "vcconn", "vcdev", "avDev", "vcomment", "vercast", "verwd", " vdef", "valver", "vDev", " vserv", "avval", "nvdiv", " vpad", "enDev", "vve", "vmpay", "ivdiv", "vcreq", "hdev", "vobj", "verdevice", "varDev", "vcve", "uvcmd", "evev", "vserial", "svev", "valcmd", "vcdat", "vvtry", "valrad", " vwd", "endiv", "Vve", "vgu", "viewtry", "ivdev", "vcdiv", " vdevice", "vval", "uvdiv", "vgo", "svserv", "Vver", "uvvalid", " vve", "frad", "fdevice", " vpay", " vcast", "ivreq", "vcast", "vargo", "verreq", "varconn", "uvpad", "vcdevice", "nvver", "avwd", "vvdiv", "uvconn", "vtpad", "svdes", "viewdiv", "verdiv", "vmdat", "varpad", "vpriv", "vvpad", "uvtry", " vtry", "vmdev", "vmvalid", "vvdd", "vpay", "vdd", "vconn", "vvcomment", "vmconn", "vcwd", "vdef", "evserv", "verserial", "evdev", "hdevice", "vrad", "ovcomment", "Vserv"], "name": ["r", "x", "no", "init", "off", "mem", "comment", "type", "v", "id", "data", "z", "format", "NAME", "title", "str", "l", "start", "code", "key", "order", "space", "n", "label", "o", "nm", "size", "time", "a", "b", "prefix", "resource", "names", "path", "info", "local", "m", "ame", "Name", "part", "c", "len", "base", "spec", " names", "e", "word", "address", "w", "item", "error"], "bytes": ["ones", "units", "lines", "vals", "ies", "outs", "points", "ries", "ls", "users", "es", "ows", "les", "izes", "ges", "rows", "frames", "xs", "eros", "gs", "new", "loads", "terms", "fixes", "parts", "maps", "size", "oms", "errors", "odes", "blocks", "seconds", "values", "mb", "os", "ms", "Bytes", "files", "elt", "gb", "zero", "cells", "byte", "io", "bits", "ips", "abytes", "len", "items", "bps", "results", "steps", "eds", "cs", "strings", "tes", "bs", "words", "gets", "ns"], "ptr": ["r", "ts", "p", "pr", "pointers", "dr", "off", "proc", "mem", "ff", "err", "ret", "addr", "sh", "alloc", "sp", "tp", "ind", "pad", "pt", "ps", "prot", "fr", "rep", "code", "ix", "rect", "pipe", "buf", "obj", "inters", "pointer", "Ptr", "index", "handle", "tr", "arr", "set", "ref", "offset", "fp", "ctx", "inter", "br", "t", "pos", "buffer", "port", "loc", "prime", "pi", "pc", "ctr", "hw", "address", "tty"]}}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n", "idx": 8866, "substitutes": {"errp": ["Erp", "Err", "rP", "rror", "errror", "Error", "errP", "erP", "err", "rp", "rr", "errr", "ErP", "error", "erp"], "info": ["report", "options", "list", "no", "conf", " information", "off", " hello", "comment", "f", "type", "json", "job", "ret", "success", "from", "id", "data", "entry", "Info", "group", "query", "fo", "ion", " Info", "lock", " INFO", "order", " tv", "obj", "bar", "time", "total", "o", "event", "details", "recent", "cache", "def", " inf", "unknown", " error", "user", "one", "sys", "about", "fi", "it", "open", "INFO", "information", "check", "inf", "status", "current", "row", "up", "state", "show", "ready", "error"], "uuid": ["cuId", "uuin", "uufile", " bufile", "cufile", "duid", "ugstring", " cufrom", "uuId", "cuid", "uustring", "custr", "uul", " buid", "uvid", "uvl", "uId", "uvstring", "duname", " cuid", "ugin", "cuin", "uid", " bufrom", "cud", "uvin", "uidid", "uustr", " cuId", " buId", "ustr", "duend", "cuname", "ugl", "cufrom", "uidId", "ugid", "duId", "uidstr", "uidend", "cuend", "custring", "uud", "ud", "uufrom", "uidname", " cufile", "uidd", "uuname", "uuend", "cul"]}}
{"project": "FFmpeg", "commit_id": "d7eabd50425a61b31e90c763a0c3e4316a725404", "target": 0, "func": "static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n\n                             int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb;\n\n    int i, ch;\n\n    int mb = -1;\n\n    Band *bands = c->bands;\n\n    int off, ret, last_frame, skip;\n\n    int bits_used, bits_avail;\n\n\n\n    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n\n\n\n    buf_size = avpkt->size & ~3;\n\n    if (buf_size <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet size is too small (%i bytes)\\n\",\n\n               avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf_size != avpkt->size) {\n\n        av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n\n               \"extra bytes at the end will be skipped.\\n\");\n\n    }\n\n\n\n    skip       = buf[0];\n\n    last_frame = buf[1];\n\n    buf       += 4;\n\n    buf_size  -= 4;\n\n\n\n    /* get output buffer */\n\n    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;\n\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    av_fast_padded_malloc(&c->bits, &c->buf_size, buf_size);\n\n    if (!c->bits)\n\n        return AVERROR(ENOMEM);\n\n    c->dsp.bswap_buf((uint32_t *)c->bits, (const uint32_t *)buf, buf_size >> 2);\n\n    init_get_bits(&gb, c->bits, buf_size * 8);\n\n    skip_bits_long(&gb, skip);\n\n\n\n    /* read subband indexes */\n\n    for(i = 0; i <= c->maxbands; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            int t = 4;\n\n            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;\n\n            if(t == 4) bands[i].res[ch] = get_bits(&gb, 4);\n\n            else bands[i].res[ch] = bands[i-1].res[ch] + t;\n\n        }\n\n\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            mb = i;\n\n            if(c->MSS) bands[i].msf = get_bits1(&gb);\n\n        }\n\n    }\n\n    /* get scale indexes coding method */\n\n    for(i = 0; i <= mb; i++)\n\n        for(ch = 0; ch < 2; ch++)\n\n            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);\n\n    /* get scale indexes */\n\n    for(i = 0; i <= mb; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(bands[i].res[ch]){\n\n                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];\n\n                bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]);\n\n                switch(bands[i].scfi[ch]){\n\n                case 0:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 1:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n\n                    break;\n\n                case 2:\n\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 3:\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    break;\n\n                }\n\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n\n            }\n\n        }\n\n    }\n\n    /* get quantizers */\n\n    memset(c->Q, 0, sizeof(c->Q));\n\n    off = 0;\n\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n\n        for(ch = 0; ch < 2; ch++)\n\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n\n\n    bits_used = get_bits_count(&gb);\n\n    bits_avail = buf_size * 8;\n\n    if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n\n        return -1;\n\n    }\n\n    if(c->frames_to_skip){\n\n        c->frames_to_skip--;\n\n        *got_frame_ptr = 0;\n\n        return avpkt->size;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = c->frame;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 8878, "substitutes": {"avctx": ["wavctx", "wavtx", "avcu", "vrtx", "avercu", "aptx", "averctl", "wavctl", "averkl", "avtx", "apctx", "averjac", "avjp", "avjac", "afctx", "apctl", "ovtx", "avkl", "averfx", "vrjac", "vrconn", "avectl", "averctx", "averpkg", "avecontext", "apcontext", "afjp", "avejp", " avcontext", "wavpkg", "aveconn", "averreq", "avertx", "avfx", "wavkl", "vrcu", "avejac", "ovctx", "afpkg", "avereq", " avjp", "vrctx", "ovjp", "afkl", "vrjp", "wavjac", "afctl", " avjac", " avtx", "avetx", "avctl", "affx", "avefx", "avpkg", "avconn", "afcontext", "avreq", "avcontext", " avctl", "avectx", "avecu", "averconn", "afreq", "ovjac", " avpkg"], "data": ["r", "p", "DATA", "bin", "value", "next", "f", "read", "ata", "frame", "output", "name", "pad", "str", "padding", "Data", "window", "align", "raw", "out", "o", "size", "a", "d", "video", "bytes", "dat", "def", "empty", "input", "sequence", "text", "t", "bits", "buffer", "batch", "block", "message", "mu", "image", "w"], "got_frame_ptr": ["got_fr_handle", "got_frametpointers", "got_fr_pointers", "got_framethandle", "got_fr_pointer", "got_frame2pointers", "got_frame_pointers", "got_frametptr", "got_frame_handle", "got_frame2pointer", "got_fr_ptr", "got_frametpointer", "got_frame2ptr", "got_frame_pointer", "got_frame2handle"], "avpkt": ["afppkt", "avrespacket", "avproux", "avppnt", "wavopkt", "wavpix", " avpKT", "avrespKT", "avproet", "avcpacket", "avproct", "avpKT", "avprokt", "avpptx", "afopmsg", "avjpkt", "avptx", "afppct", "avcpmsg", "averpkt", "avpct", "avjpacket", "avpacket", "avcpix", "avopkt", "averpct", "avopix", "avPct", "afptx", "avopet", "avPet", " avpct", "wavopct", " avPct", "avopmsg", "wavpct", "avopacket", "afpmsg", "avjpct", "avcpet", "afopacket", "avjpix", "avcpKT", "wavopacket", "averprokt", "averpet", "afpacket", " avPacket", " avpacket", "avPux", "avcpkt", "afpnt", "afopet", "averproct", "wavpkt", "wavopix", "avrespct", "avPtx", "wavpacket", "avpix", "avcmsg", "avpbtx", "avrespkt", "avckt", " avPkt", "avPacket", "avpux", "avpbkt", "averproux", "avpet", "averpux", "avpbnt", "avPkt", "avopct", "afpkt", "avcacket", "averproet", "afpct", "avppct", "avpmsg", "avcpux", "avPKT", "afpet", "afpptx", "afppnt", "avpbct", "avPnt", "avpnt", "avppkt", "afopkt", "avcet", "avcpct", " avPKT"], "buf": ["p", "boxes", "func", "lim", "cb", "done", "limit", "seq", "np", "mem", "bin", "ff", "err", "v", "read", "pause", "jump", "pb", "emb", "wait", "str", "keep", "uf", "map", "stop", "deg", "good", "window", "shift", "fb", "mates", "progress", "cv", "nm", "tmp", "cast", "seek", "buff", "b", "mb", "bytes", "tr", "foo", "late", "arr", "queue", "ref", "Buff", "vec", "br", "wb", "uv", "txt", "pos", "buffer", "len", "db", "rb", "batch", "bps", "block", "pkg", "xff", "msg", "doc", "orig", "hz", "img", "cmd"], "buf_size": ["buf_set", " buf_ize", "buf2num", "buf_se", " buf_unit", " buf_length", "buff_se", " buf_Size", "uf_ize", "buff_size", "buf_length", "uf_length", "buftnum", "uf_size", " buf_len", "buff_Size", "buf2set", "buf_ize", "buf_len", "buf_count", "buff_len", "buf_num", "buf_SIZE", "uf_time", "buf_unit", "uf_name", "buf2size", "buf2length", "buff_SIZE", "buff_length", " buf_count", "uf_num", " buf_SIZE", "buf_Size", "buftset", "buftlength", "buftsize", "buf_name", "buf_sum", "uf_SIZE", " buf_sum", "uf_len", "buf_time", "uf_set"], "c": ["p", "dc", "cb", "coll", "co", "cr", "h", "conf", "C", "tc", "cf", "f", "v", "cm", "cont", "cam", "fc", "abc", "bc", "l", "ct", "call", "cl", "comm", "lc", "cu", "cc", "rc", "cv", "config", "cp", "a", "enc", "b", "g", "d", "cache", "ec", "etc", "com", "cmp", "ca", "ctx", "ce", "ci", "mc", "m", "t", "chain", "con", "xc", "cs", "e", "pc", "k", "vc", "lib", "conv", "ac"], "gb": [" GB", "GB", "cb", "bf", "sb", " eg", "py", "bd", "xy", "gif", "git", "nb", "tm", "cfg", "gd", "pg", " db", "tk", "gt", "gs", "eg", " kb", " thumb", " pg", " np", "ubs", "eb", "vm", "fb", "ib", "rg", "cv", "bt", "g", "Gb", " ng", "bm", "kb", "gm", "gin", " td", " cz", "bridge", "gu", "fg", " rg", "tg", "wb", "bits", "ge", "cgi", "db", "rb", "yg", "bg", "gc", " ssh", "gg", "storage", "by"], "i": ["r", "di", "p", "ui", "ami", "x", "h", "v", "gi", "id", "ai", "ic", "wi", "ind", "l", "ii", "ei", "xi", "j", "sim", "I", "phi", "ix", "at", "multi", "bi", "in", "ni", "n", "o", "b", "ie", "hi", "er", "si", "is", "index", "li", "y", "ini", "it", "ci", "m", "io", "chain", "ip", "mi", "zi", "t", "ti", "im", "pi", "e", "ki", "ims", "us"], "ch": ["cb", "h", "cha", "qq", "high", "ech", "ih", "k", "v", "chan", "sh", "qu", "l", "height", "sky", "sub", "an", "th", "channel", "tch", "qt", "cht", "cor", "chn", "cp", "count", "hi", "zh", "ht", "kh", "mk", "ph", "ach", "yet", "y", "mot", "hl", "chid", "q", "och", "chain", "sc", "chip", "CH", "cs", "pc", "Ch", "sch", "cho", "el", "ich"], "bands": ["units", "orders", "lines", "objects", "fps", "codes", "images", "types", "metadata", "annels", "points", "phones", "pins", "photos", "rooms", "bys", "frames", "pages", "cats", "band", "heads", "amps", "Bs", "cards", "tags", "hz", "books", "dos", "parts", "rings", "bright", "devices", "b", "blocks", "plugins", "mb", "bytes", "videos", "kb", "ks", "files", "missions", "ints", "waves", "ands", "hands", "products", "bits", "banks", "balls", "pieces", "chains", "planes", "artifacts", "groups", "classes", "words", "versions"], "off": [" offset", "on", "ff", "f", "from", "op", "j", "start", "new", "raw", "out", "o", "obj", "load", "offs", "Off", "of", "def", "ok", "ref", "set", "offset", "eff", "it", "pos", " af", "error", "cmd"], "ret": ["dr", "flag", "RET", "mel", "mem", "fun", "f", "err", "success", "re", "str", "result", "gt", "Ret", "deg", "dt", "val", "rem", "progress", "rm", "out", "lt", "nt", "rets", "net", "back", "print", "mt", "def", "tr", "bool", "nil", "empty", "elt", "rt", "ref", "reset", "last", "it", "fin", "txt", "bits", "len", "res", "fit", "got", "det", "resp", "ll", "alt", "jp"], "last_frame": ["last_image", "last___channel", "last_sample", "last___image", " last_image", " last_frames", "last_channel", "last___frames", "last_Frame", "Last_channel", "last___frame", " last_channel", "last___Frame", "last_frames", "Last_frame", "last___sample", "Last_Frame", " last_sample"], "skip": ["step", "send", "snap", "mem", "slot", "next", "ipp", "addr", "sp", "jump", "syn", "missing", "wait", "ps", "seed", "stop", "start", "seek", "iter", "need", "strip", "scan", "index", "eps", "push", "sleep", "copy", "tr", "cmp", "sys", "offset", "miss", "move", "fin", "Skip", "ip", "pos", "sk", "prep", "status", "ips", "hide", "mask", "pkg", "clip", "pass", "zero", "rel"], "bits_used": ["bitsunavailable", "bits_read", "bytes2used", "bits2used", "bytes_available", "bytes_used", "bits2available", "bits2read", "bitsunused", "bitsunread", "bytes2read", "bytes2available", "bytes_read", "bits_available"], "bits_avail": ["bits_averil", "bits_abile", "bits_averail", "bits_averile", "bits_overil", "bits_averag", "bits_overail", "bits_abil", "bits_abail", "bits_avile", "bits_abag", "bits_overag", "bits_avil", "bits_avag", "bits_overile"]}}
{"project": "FFmpeg", "commit_id": "35cb6854bb76b4a5b6f2aea2dce81e18d7ab61cd", "target": 1, "func": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n", "idx": 8900, "substitutes": {"src": ["sync", "dist", "sb", "init", "seq", "proc", "bin", "rs", "sur", "addr", "sel", "ser", "std", "cur", "pack", "syn", "pri", "ind", "trans", "result", "usr", "start", "rob", "cc", "supp", "rc", "sr", "out", "origin", "in", "null", "buf", "rl", "tmp", "comp", "iter", "inst", "gz", "st", "rest", "impl", "gin", "copy", "input", "rt", "sys", "target", "txt", "sc", "source", "loc", "lb", "bg", "ipl", "stream", "msg", "ptr", "sub", "ctr", "img", "rel", "ins"], "src_len": ["src_lit", "source_len", "src_l", " src_line", "source_length", "source_lit", "source_list", "src_length", "src_list", " src_list", "src_line", " src_l"], "src_count": ["src2length", "rc_Count", "src_Count", " src_Count", " src_cache", "src_cache", " src_size", "src2cache", "src2count", "src_size", "rc_count", " src_length", "src2len", "rc_len", "src_length", "rc_length"], "dest": ["pro", "pas", "dist", "dev", "opt", "master", "type", "v", "std", "Dest", "pid", "sp", "end", "priv", "gov", "trans", "result", "usr", "phi", "out", "origin", "pipe", "dep", "cp", "temp", "tmp", "st", "rest", "win", "lit", "to", "desc", "home", "prop", "target", "txt", "gate", "pos", "est", "port", "source", "loc", "decl", "way", "ptr", "gen", "del"], "dest_len": ["destzline", "target_l", "destzlength", "target_le", "dest_line", "dest_l", "src_lim", "dest_le", "target_length", "dest_length", "src_length", "destzlen", "src_line", "dest_lim", "destzlim", "target_len"], "ps": ["changes", "py", "pins", "ls", "pid", "amps", "Ps", "cp", "maps", "as", "pes", "pa", "js", "pkg", "ptr", "ms", "jp", "ins", "ns", "ats", "pp", "params", "pe", "pt", "parts", "checks", "ress", "fs", "posts", "pu", "stats", "ds", "res", "vs", "cs", "ims", "ppa", "ports", "p", "pres", "lp", "places", "outs", "points", "sp", "pb", "its", "ops", "parent", "s", "eps", "os", "times", "hs", "PS", "ips", "bps", "pi", "pc", "ts", "pas", "fps", "pr", "pl", "vals", "aps", "proc", "pps", "rs", "px", "es", "ss", "tp", "als", "pg", "gs", "sts", "plays", "ph", "pse", "pers", "css", "mp", "pos", "po", "ping", "bs"], "ps_end": ["pp_end", "psiplast", "peopend", "ps_append", "psseqend", "peopgate", "ps_begin", "prJends", "pr_fin", "ts_ended", "psopappend", "pe_end", "pr_end", "pszsend", "prJend", "pszend", "peopmax", "ps2start", "ps___range", "pp_edge", "pe_max", "psipended", "eps_add", "ppzend", "eps_end", "pr_ended", "psseqends", "pr_ends", "ps2ended", "ps___ord", "pr___range", "psipstart", "ps_start", "ts_last", "ps___end", "ps_range", "peopappend", "ps_gate", "ps_edge", "ts_end", "prJhead", "ps_fin", "psopmax", "ps___ended", "ps_head", "pr_range", "pszedge", "pslenedge", "ps_ord", "ps_last", "pr___end", "pr_head", "psseqmax", "psseqhead", "ps_ended", "ps_add", "eps_start", "psJends", "pr_ord", "pr___ord", "pslensend", "psJfin", "psJend", "prJfin", "pe_append", "psopend", "ppzsend", "psseqgate", "pslenend", "ps_max", "psseqappend", "psJhead", "pp_send", "psopgate", "psseqfin", "ps_send", "pr___ended", "ppzedge", "ps2end", "ps2last", "ps_ends", "psipend", "pe_gate", "ts_start", "eps_begin"], "pd": ["pod", "p", "ld", "pic", "pr", "py", "pl", "np", "bd", "PD", "px", "lp", "pp", "ls", "dd", "pid", "id", "pb", "pe", "dp", "tp", "por", "pt", "cd", "lf", "phi", "hd", "dl", "dt", "pn", "xd", "cp", "md", "td", "d", "ph", "fd", "sd", "pu", "pdf", "pm", "ds", "pat", "ped", "vd", "ud", "po", "ping", "pi", "pkg", "pc", "jp", "ppa"], "i": ["ui", "di", "p", "cli", "x", "v", "pp", "gi", "pid", "ic", "ai", " ii", "ind", "ii", "ei", "j", "xi", "sim", "I", "phi", "ix", "iu", "oi", "u", "multi", "bi", "n", "in", "o", "iter", "a", "is", "b", "hi", "d", "si", "index", "print", "s", "pa", "li", "y", "ini", "g", "fi", "it", "\u0438", "ci", "m", "c", "qi", "zi", "mi", "ip", "ij", "status", "ti", "im", "pi", "e", "ki", "me"], "l": ["p", "limit", "ld", "tl", "pl", "list", "h", "lay", "lp", "f", "v", "ls", "isl", "z", "ul", "ln", "j", "dl", "lc", "ml", "u", "like", "nl", "lt", "n", "o", "lu", "sl", "g", "el", "d", "b", "s", "kl", "fl", "lit", "li", "hl", "lo", "lis", "ol", "it", "m", "c", "la", "t", "jl", "lin", "len", "loc", "ll", "pi", "L", "lv", "le", "length", "il"], "dest_end": ["src_end", "dest0dest", "dest0est", "src_start", "dest_stop", "prop_est", " dest_stop", "dest_dest", "dest_est", " dest_length", "dest0ended", "dest_ended", "prop_end", "prop_dest", "src_stop", "dest_start", "dest_length", "prop_ended", " dest_start", "dest0end"]}}
{"project": "FFmpeg", "commit_id": "4f00519d9508e07aac58a00a9b514dae8ad95723", "target": 1, "func": "int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)\n\n{\n\n    av_log(avctx, AV_LOG_DEBUG, \"Header: %0X\\n\", show_bits(gb, 32));\n\n    v->profile = get_bits(gb, 2);\n\n    if (v->profile == PROFILE_COMPLEX)\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"WMV3 Complex Profile is not fully supported\\n\");\n\n    }\n\n\n\n    if (v->profile == PROFILE_ADVANCED)\n\n    {\n\n        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;\n\n        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;\n\n        return decode_sequence_header_adv(v, gb);\n\n    }\n\n    else\n\n    {\n\n        v->zz_8x4 = wmv2_scantableA;\n\n        v->zz_4x8 = wmv2_scantableB;\n\n        v->res_y411   = get_bits1(gb);\n\n        v->res_sprite = get_bits1(gb);\n\n        if (v->res_y411)\n\n        {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Old interlaced mode is not supported\\n\");\n\n            return -1;\n\n        }\n\n        if (v->res_sprite) {\n\n            av_log(avctx, AV_LOG_ERROR, \"WMVP is not fully supported\\n\");\n\n        }\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->s.loop_filter = get_bits1(gb); //common\n\n    if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"LOOPFILTER shall not be enabled in Simple Profile\\n\");\n\n    }\n\n    if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL)\n\n        v->s.loop_filter = 0;\n\n\n\n    v->res_x8 = get_bits1(gb); //reserved\n\n    v->multires = get_bits1(gb);\n\n    v->res_fasttx = get_bits1(gb);\n\n    if (!v->res_fasttx)\n\n    {\n\n        v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;\n\n        v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add;\n\n    }\n\n\n\n    v->fastuvmc =  get_bits1(gb); //common\n\n    if (!v->profile && !v->fastuvmc)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"FASTUVMC unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->extended_mv =  get_bits1(gb); //common\n\n    if (!v->profile && v->extended_mv)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Extended MVs unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->dquant =  get_bits(gb, 2); //common\n\n    v->vstransform =  get_bits1(gb); //common\n\n\n\n    v->res_transtab = get_bits1(gb);\n\n    if (v->res_transtab)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"1 for reserved RES_TRANSTAB is forbidden\\n\");\n\n        return -1;\n\n    }\n\n\n\n    v->overlap = get_bits1(gb); //common\n\n\n\n    v->s.resync_marker = get_bits1(gb);\n\n    v->rangered = get_bits1(gb);\n\n    if (v->rangered && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_INFO,\n\n               \"RANGERED should be set to 0 in Simple Profile\\n\");\n\n    }\n\n\n\n    v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); //common\n\n    v->quantizer_mode = get_bits(gb, 2); //common\n\n\n\n    v->finterpflag = get_bits1(gb); //common\n\n\n\n    if (v->res_sprite) {\n\n        v->s.avctx->width  = v->s.avctx->coded_width  = get_bits(gb, 11);\n\n        v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11);\n\n        skip_bits(gb, 5); //frame rate\n\n        v->res_x8 = get_bits1(gb);\n\n        if (get_bits1(gb)) { // something to do with DC VLC selection\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported sprite feature\\n\");\n\n            return -1;\n\n        }\n\n        skip_bits(gb, 3); //slice code\n\n        v->res_rtm_flag = 0;\n\n    } else {\n\n        v->res_rtm_flag = get_bits1(gb); //reserved\n\n    }\n\n    if (!v->res_rtm_flag)\n\n    {\n\n//            av_log(avctx, AV_LOG_ERROR,\n\n//                   \"0 for reserved RES_RTM_FLAG is forbidden\\n\");\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\");\n\n        //return -1;\n\n    }\n\n    //TODO: figure out what they mean (always 0x402F)\n\n    if(!v->res_fasttx) skip_bits(gb, 16);\n\n    av_log(avctx, AV_LOG_DEBUG,\n\n               \"Profile %i:\\nfrmrtq_postproc=%i, bitrtq_postproc=%i\\n\"\n\n               \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\"\n\n               \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\"\n\n               \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\",\n\n               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,\n\n               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,\n\n               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,\n\n               v->dquant, v->quantizer_mode, avctx->max_b_frames\n\n               );\n\n    return 0;\n\n}\n", "idx": 8901, "substitutes": {"avctx": ["averContext", "Avcmd", "avecp", "avepkg", "averpkg", "avcmd", "avercontext", "savconn", "avecontext", "Avcmp", "savctx", "afpkg", "avercf", "vccf", "svcmp", "averkt", "wavctx", "avecf", "avercu", "avecmp", "avercp", "wavcmp", "avcp", "navcp", "avcmp", "averctx", "avenp", "averhandle", "avercpu", "avcpu", "wavcontext", "avekt", "vchandle", "avpkg", "avectx", "svcmd", "avecpu", "avconn", "vcnp", "afcu", "afctx", "aveContext", "vcctx", "avesys", "avercmp", "avernp", "svctx", "Avctx", "aveconn", "navctx", "svcontext", "avnp", "avkt", "Avcontext", "avcontext", "averconn", " avcmp", "vcsys", "avcu", "vccpu", "savcp", "navkt", "avcf", "afcmp", " avcontext", "avsys", "savcu", "aversys", "avehandle", "avContext", "avhandle", " avcmd", "navconn", "avecu", "wavContext"], "v": ["p", "av", "dev", "x", "h", "ev", "value", "rev", "vector", "f", "i", "qu", "vr", "data", "version", "l", "ver", "j", "query", "env", "qv", "window", "vm", "val", "cv", "ve", "sv", "vt", "ov", "vv", "g", "er", "video", "b", "tv", "cache", "s", "ch", "d", "get", "var", "iv", "q", "view", "max", "vi", "it", "V", "uv", "c", "m", "wire", "t", "current", "nv", "vs", "pi", "vc", "vp", "lv", "k", "w", "conv"], "gb": ["GB", "cb", "bf", "sb", "py", "um", "html", "goo", "xy", "attr", "gif", "gy", "args", "nb", "pb", "cfg", "tm", "gd", "emb", "csv", "bc", "vg", "gov", "gnu", "uf", "gs", "gt", "deg", "erb", "eg", "bb", "vm", "eb", "rect", "fb", "range", "rg", "rl", "bt", "g", "Gb", "gz", "b", "mb", "hub", "bytes", "ch", "bs", "storage", "kb", "gm", "bridge", "sys", "hog", "ctx", "tg", "phy", "gam", "wb", "bits", "binary", "verified", "db", "rb", "yg", "bn", "bg", "ruby", "gc", "pc", "gg", "bm", "img"]}}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 8903, "substitutes": {"s390_dev": ["s390__ve", "slet_ve", "slet_dev", "s390_device", "s390_conn", "s390xdev", "slet__ve", "s390_ve", "s390jdev", "s390xev", "s390__spec", "s390_spec", "s390_ev", "s390_Dev", "saddle_ev", "slet__Dev", "s380_conn", "s390__device", "s390jDev", "saddle_dev", "s390__dev", "s390xconn", "s380_ver", "slet__dev", "s390_conf", "slet_conf", "s390jve", "saddle_spec", "s380_ev", "s390__ev", "slet_Dev", "saddle_device", "s390xver", "s390_ver", "s380_dev", "s390__Dev"], "dev": [" Dev", "av", "develop", "DEV", "Dev", "mem", "ev", " device", "eng", "conn", "build", "comment", "v", "dd", "de", "test", "cur", "pack", "cam", "serial", "priv", "ver", "sky", "val", "raw", "rem", "debug", "device", "ve", "des", "nt", "rad", "enc", "serv", "d", "ac", "form", "def", "dem", "ow", "var", "tr", "sd", "desc", "go", "gu", "dis", "prop", "ad", "res", "det", " dw", "doc", "hw", "w", "del", "cmd"], "vdev": ["evdevice", "udiv", "cvev", "udev", " vpriv", "vpro", " vDev", " vdesc", "wobj", "evvar", " vobj", " vvar", "cvde", "vdesc", "vstable", "vev", "cvdev", " vde", "qpriv", "qev", "uDev", "udesc", "vde", " vstable", "cvstable", "wev", "qobj", "qdesc", " vev", "vdevice", "evDev", "vcdev", "qdevice", "kev", " vpro", "vDev", "vdiv", "vobj", "hdev", "vcev", "kdev", "qdev", "qDev", "qvar", "wdev", "vvar", "wdevice", "vcpro", "wde", "kpro", "kde", "wstable", "evdev", "vpriv", "hdevice", "hDev", "qdiv", "hpriv", "vcde", " vdiv", " vdevice"]}}
{"project": "qemu", "commit_id": "0fbfbb59a9766247be20023b17eb7872e7b29323", "target": 0, "func": "static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n", "idx": 8927, "substitutes": {"s": ["r", "ts", "p", "h", "sb", "ats", "ses", "rs", "v", "ls", "ss", "es", "its", "als", "z", "ties", "l", "ps", "gs", "aws", "an", "comm", "sts", "ex", "n", "sq", "fs", "sv", "a", "is", "b", "d", "details", "bs", "os", "bis", "js", "hs", "ds", "ns", "m", "c", "sis", "S", "t", "source", "spec", "cs", "ms", "sports", "ins"], "irrv": ["interrvi", "irrsvp", "irvrved", "irrdq", "irerrview", "irrsv", "ircrvi", "ironrvt", "irrdv", "irrvt", "irtrbved", "irrnq", "irrova", "irrnf", "outerrxv", "ironrdq", "irrdf", "irrva", "irrbve", "irrxview", "ironrv", "irvrvt", "irrxv", "irrnv", "irrvi", "irerrvp", "outerrxvp", "irtrbv", "irtrbve", "irrview", "irrcva", "irrbved", "irrq", "irrvp", "irrovi", "irrnvt", "irtrve", "interrcv", "irrrv", "interrcve", "ironrq", "irrcvi", "interrva", "irerrvr", "irtrbvr", "irrdvt", "irrcve", "irrvr", "irtrved", "irvrvr", "outerrv", "irrov", "irrved", "irerrv", "irrove", "irvrve", "irtrv", "irrcv", "outerrxvr", "irrsview", "ironrdf", "interrv", "ircrv", "irvrq", "irrbvr", "irvrf", "irrxvr", "irrve", "interrcvi", "outerrvr", "ircrve", "ironrf", "ironrdv", "irvrv", "irrsvr", "ircrva", "outerrvp", "outerrxview", "irrrved", "ironrdvt", "irrf", "irrrve", "irtrvr", "irrrvr", "interrve", "irrxvp", "interrcva", "outerrview", "irrbv"], "ppr": ["padr", "PPr", "padrc", "plr", "pkgpr", "ampro", "ipppr", "padpr", "PPR", "ippr", "PPrc", "arpsr", "pkgr", "plx", "PPvr", " ppx", "ampsr", "amppr", "ippro", " pprs", "apppr", "ppx", "arppr", "PPx", "ppro", "upprs", "ippsr", " ppR", "pkgrc", "ppvr", "appres", "apprs", "pprc", "ppsr", "ppres", "pkgvr", "ampr", "uppr", "pprs", "plrs", "PPres", "uppres", "ppR", "PPrs", "arpr", "plR", "PPpr", "padvr", "appr", "arpro", "upppr", "pppr"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,\n\n\t\t CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)\n\n{\n\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n\n    int err = 0;\n\n    uint16_t magic;\n\n\n\n\t/* already locked in setup_frame() */\n\n    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);\n\n    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);\n\n    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);\n\n    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);\n\n    __put_user(env->regs[R_EDI], &sc->edi);\n\n    __put_user(env->regs[R_ESI], &sc->esi);\n\n    __put_user(env->regs[R_EBP], &sc->ebp);\n\n    __put_user(env->regs[R_ESP], &sc->esp);\n\n    __put_user(env->regs[R_EBX], &sc->ebx);\n\n    __put_user(env->regs[R_EDX], &sc->edx);\n\n    __put_user(env->regs[R_ECX], &sc->ecx);\n\n    __put_user(env->regs[R_EAX], &sc->eax);\n\n    __put_user(cs->exception_index, &sc->trapno);\n\n    __put_user(env->error_code, &sc->err);\n\n    __put_user(env->eip, &sc->eip);\n\n    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);\n\n    __put_user(env->eflags, &sc->eflags);\n\n    __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);\n\n\n\n        cpu_x86_fsave(env, fpstate_addr, 1);\n\n        fpstate->status = fpstate->sw;\n\n        magic = 0xffff;\n\n    __put_user(magic, &fpstate->magic);\n\n    __put_user(fpstate_addr, &sc->fpstate);\n\n\n\n\t/* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n    __put_user(env->cr[2], &sc->cr2);\n\n\treturn err;\n\n}\n", "idx": 8931, "substitutes": {"sc": ["dc", "sync", "cr", "sw", "scrib", "tc", "esc", "sel", "sh", "qu", "pb", "ss", "cam", "sci", "sic", "fc", "irc", "bc", "sche", "mac", "env", "cl", "uc", "sim", "comm", "lc", "capt", "cu", "cc", "rc", "tch", "sq", "cv", "ctl", "sv", "cle", "scan", "sec", "ec", "osc", "asc", "desc", "ca", "scl", "ctx", "mic", "ci", "c", "mc", "check", "usc", "Sc", "anc", "decl", "pc", "gc", "sch", "SC", "scope", "isc"], "cs": ["ts", "ats", "cus", "cf", "tc", "rs", "err", "ls", "esc", "ck", "ces", "ss", "es", "fc", "csv", "ps", "cks", "gs", "acs", "ys", "cc", "rc", "cp", "cas", "CS", "sv", "fs", "as", "ics", "si", "esp", "ec", "s", "os", "ks", "css", "js", "sys", "ctx", "ds", "c", "Cs", "spec", "vs", "pc", "wcs", "bs", "qs", "isc", "ns"], "magic": ["caps", "init", "flag", "red", "mem", "type", " maj", "addr", "alloc", "obar", "start", "Count", "count", " erase", "oo", "field", "os", "empty", "ok", "ogo", "fields", " zero", "base", "asm", "ctr", "length"]}}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n", "idx": 8946, "substitutes": {"acb": ["Acbs", "jacwb", " acbd", "Acb", "pacrb", "mcB", "sacbe", "acB", "aicx", "ancsb", "actbb", "accbs", "jacx", "Acwb", " acbb", "sacb", "ancr", "acnb", "jacb", "acbs", "ancd", "absrb", "absbb", "accd", "accwb", "ocB", "aicbc", "pacsb", "accr", "acr", "ancbr", "ancB", "iacwb", "sacB", "accrb", "accB", "acx", "actrb", "ancb", "pacd", " acr", "mcnb", "ocw", " cacB", "acsb", "acwb", "acbb", "accbr", "ocbd", "ocv", "acbr", "achb", " acbr", "accb", "ancbb", "actb", "ancw", "achbs", "accbb", "accv", "acbd", "jacbc", "achwb", "absb", "acv", "aicb", "accw", "accsb", "ocb", "actbs", "mcb", "iacx", "achsb", "absbs", " cacbe", "mcbe", "acd", "acbc", "aicwb", "ancrb", "Acsb", "acw", "acbe", "pacb", "accbd", "iacb", "sacnb", "iacbc", " acv", " cacb", "ocr", "acrb", " cacnb"], "s": ["r", "ts", "p", "sync", "changes", "h", "sb", "ims", "ats", "sw", "ses", "sol", "rs", "ies", "v", "ls", "ears", "params", "qs", "ss", "es", "als", "ps", "uns", "gs", "j", "aws", "comm", "sts", "sq", "sm", "fs", "sv", "sl", "is", "b", "g", "sam", "has", "ins", "os", "bis", "sys", "js", "bes", "hs", "ds", "ssl", "stats", "S", "sis", "ares", "spec", "services", "vs", "cs", "state", "tes", "bs", "sports", "ns"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "substitutes": {"vtd_as": ["vbd_AS", "vtd___as", "vtdptcs", "vbd_las", "vtd___AS", "vbd_as", "vsd_am", "vtd___s", "vtd_AS", "vtd_bs", "vsd_s", "vsd_as", "vsd_AS", "vtd___am", "vtd_las", "vtd_cs", "vtd___ast", "vcd_as", "vtd___las", "vtd__las", "vcd_a", "vtdptbs", "vtd_am", "vtd__AS", "vtd_ast", "vtd_a", "vbd_ast", "vtd_s", "vtd__as", "vtd__ast", "vtdpta", "vcd_cs", "vtdptas", "vcd_bs"], "bus": ["al", "dev", "bf", " buses", "type", "ck", "bc", "boot", "bug", "host", "buf", "loop", "b", "dir", "as", "os", "phys", "board", "clus", "sys", "ctx", "ux", "box", "Bus", "chain", "kt", "block", "BUS", "way", "vc", "us", "hw", "bs", "ac"], "devfn": ["Devfn", "evdn", "patchfun", "Devfun", "varfilename", "varnm", "evfun", "Devln", "evfin", "devln", "devfin", "Devnm", " devdn", " devln", "devfilename", " devfin", "evfn", "Devpath", "evFN", "devicefn", "devnm", "devFN", "patchfin", "devdn", "devicedn", "devicefilename", " devpath", "devicefun", "patchFN", "patchfn", " devfun", "evln", "varfn", "Devfilename", " devFN", "devicenm", "devpath", "evpath", "devfun", "varfun"], "addr": ["r", "ack", "x", "ace", "dr", "ag", "cmd", "rs", "eth", "coord", "err", "hop", "dd", "id", " address", "add", "ash", "name", "pad", "str", "mac", "map", "route", "ix", "at", "rc", "ress", "src", "prefix", "handle", "ha", "arp", "phys", "arr", "tx", "Address", "rt", "ref", "elt", "hash", "ctx", "inter", "pat", "adr", "ip", "alias", "ad", "res", "loc", "alt", "ptr", "host", "hw", "address", "w", "ord", "msg", "ac"], "is_write": ["isPwrite", "is_read", "isPwrit", " is_read", "isPread", "isPwritten", " is_writ", "is_writ", "is_written", " is_written"], "entry": ["or", "ent", "list", "enter", "ries", "cur", "cell", "result", "rent", "record", "rance", "nt", "event", "er", "see", "ry", "set", "inter", "ence", "row", "Entry", "e", "RY", "ptr", "doc", "se", "xml"], "s": ["r", "ts", "p", "h", "sb", "conf", "sw", "ses", "rs", "sa", "v", "ls", "sp", "ss", "es", "its", "ps", "gs", "sts", "space", "n", "fs", "sv", "service", "is", "g", "b", "as", "a", "bs", "os", "set", "sys", "js", "hs", "ds", "m", "S", "c", "t", "sc", "source", "e", "se", "w", "ns"], "ce": ["cue", "ine", "ent", "ace", " Ce", " eg", "co", "ue", " cc", " ke", "ced", " fe", "cf", "enter", "ae", "ck", "ces", "cur", "pe", "ze", "cell", "ct", "cel", " ie", " ex", "ade", "cand", "wife", " ne", "CE", "cc", " cle", " CE", "ense", "ect", "ve", "ane", " pe", "ke", "ice", "cle", "event", "ie", "cer", "ance", "er", "te", " ace", " ge", " sense", "com", "see", "ca", "ci", " ice", "c", "cy", " che", "ence", "ate", "ge", "ere", "kee", "e", " msg", "le", "se", " car", " ele"], "cc_entry": ["dc_entry", "cc_try", "cc__enter", "ccedentry", "dc_enter", " cc_ent", "dc__system", "ccedinstance", "cc_element", "dc__enter", "cc14pair", "cc_info", "cc_match", "ccmodset", "dc__entry", "ccmodentry", "ck2member", "cc_ent", "ccgentry", "ctledpair", "cc14instance", "cc2enter", "ctledentry", "ck2try", "ctx_info", "dc_system", "ccptenter", "ccmodmatch", "cc__entry", "cc2entry", "ccmexit", "cc_ry", "cc_member", "cell_match", "ck_member", "ccipentry", "cc_system", "cell_set", "cell_entry", "cc2try", "ccipinfo", "ccgtry", "ck_enter", "ccedpair", "ctledinstance", "ck2enter", "ctl_entry", "ck_entry", "ctx_entry", "ccptsystem", "ctl_pair", "ccgmember", "cc__system", "ccgenter", "cc_exit", "cc_pair", "cc_enter", "ccptentry", "cc14entry", "ccmentry", "ctx_ry", "ctl_instance", " cc_exit", "cc_set", "ccipry", "cc2member", "ccipelement", "ccment", "ck_try", "cc_instance", "ctx_element", "ck2entry"], "slpte": ["sslpte", "slntes", " slpetes", "slapte", "slptd", "slpetd", "slpten", " slptea", "slptea", "slporte", "slntee", "slptonen", "sslportest", "sslported", "Slptee", "slvanted", "slpeten", "sslptest", "sliptee", "sslportE", "Slpporte", " slptee", " slpetea", "slften", "sslptE", "slportest", "slppaee", "slpetea", "slpetes", "slnte", "slpporting", "slvantest", "slvantE", "slported", " slpete", " slptes", "slpportd", "slpporten", "slpporte", "slpete", "slptE", "slptonee", "Slpporting", " slpetee", "Slpting", "slptoning", "slaptE", "slppae", "sliptd", "Slpportd", "slptest", "slvante", "Slptd", "Slpportee", "slipte", "sslpted", "slpted", "sslporte", "Slpporten", "slportE", "Slpte", "slptone", "slppaes", "slfte", "slpportee", "slntea", "slfting", "slptes", "slppaea", "slpting", "slptee", "slipten", "slftee", "slaptest", "Slpten", "slpetee", "slapted"], "page_mask": ["page_flags", "page_cover", " page_flag", "pagelymask", "pagelyfee", "pagelyflags", "page_fee", " page_cover", " page_flags", "pagelycover", "page_flag", " page_lock", "page_lock", "page_id", " page_fee", " page_id"], "level": ["limit", "lay", "high", "flag", "acl", "levels", "tag", "link", "Level", "height", "lang", "layer", "oom", "depth", "lock", "debug", "loop", "scale", "index", "lvl", "local", "lan", "priority", "weight", "status", "len", "fac", "scope"], "ret_fr": ["ret0fr", "ret0ly", "Ret_sim", "ret_ly", "ret2fr", "_", "retfulfr", "ret0fin", "retfulsim", "ret2dr", "ret_br", "ret_lr", "ret2lr", "ter_Fr", "ret2br", "ret_dr", "ret2ly", "ret2fin", "retfulFR", "Ret_fin", "ret_sim", "ter_fr", "ret_Fr", " ret_dr", "ret_fin", "func", "dll", "retfulbr", "ret_FR", "ter_fin", "Ret_FR", " ret_br", "Ret_lr", "Ret_br", "ret0Fr", " ret_fin", "Ret_fr", "ter_ly", "ret2Fr"], "access_flags": ["accessionflags", "connect_fields", "access_rates", "access2fs", "access_mask", " access_flag", "accessencefields", "accessionevents", "accessingrates", " access_mask", "access_events", "connect_times", "connectetyfields", "connectetyweights", "accessetyweights", "connectencelevels", "access_levels", "accessetyfields", "connectetyflags", "accessencetimes", "accessetyrates", "access2flags", "access_times", "connect_events", "connect_flags", "connect_weights", "accessingweights", " access_fs", "access2mask", "accessetyflags", "connectenceflags", "accessenceflags", "access2flag", "access_fields", "accessionlevels", "connectencetimes", "access_weights", "connectetyrates", "access_fs", "accessingflags", "access_flag", "accessencelevels", "accessencerates", "accessingfields", "accessenceweights", "accessenceevents", "connectenceevents", "accessiontimes", "connect_levels", "connect_rates"], "iotlb_entry": ["iotlbptresult", "iotlb2member", "iotlb__entry", "iotlb_ent", "iotl_entry", "iotlab_member", "iotl_enter", "iotlbptentry", "iotlbsptresult", "iotlb_result", "iotlab2entry", "iotlbs_Entry", "iotlbptEntry", "iotlbsptEntry", "iotlb_ry", "iotl_member", "iotlb__member", "iotl_ent", "iotlas_Entry", "iotlb__ent", "iotlbs_entry", "iotlab2Entry", "iotlb2entry", "iotlb__ry", "iotlas_member", "iotlab_Entry", "iotlb__data", "iotl_data", "iotlb_data", "iotl_row", "iotlab_entry", "iotlb_member", "iotl_ry", "iotlb_row", "iotlas_entry", "iotlb_Entry", "iotlb_enter", "iotlbsptentry", "iotlab2member", "iotlbs_result", "iotlb2Entry", "iotl_Entry"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int load_multiboot(void *fw_cfg,\n\n                   FILE *f,\n\n                   const char *kernel_filename,\n\n                   const char *initrd_filename,\n\n                   const char *kernel_cmdline,\n\n                   int kernel_file_size,\n\n                   uint8_t *header)\n\n{\n\n    int i, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    MultibootState mbs;\n\n    uint8_t bootinfo[MBI_SIZE];\n\n    uint8_t *mb_bootinfo_data;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n\n    memset(bootinfo, 0, sizeof(bootinfo));\n\n    memset(&mbs, 0, sizeof(mbs));\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        uint64_t elf_low, elf_high;\n\n        int kernel_size;\n\n        fclose(f);\n\n\n\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_low, &elf_high, 0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = elf_low;\n\n        mb_kernel_size = elf_high - elf_low;\n\n        mh_entry_addr = elf_entry;\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                  mb_kernel_size, (size_t)mh_entry_addr);\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n        uint32_t mb_load_size = 0;\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n\n\n        if (mh_load_end_addr) {\n\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n\n        } else {\n\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n\n            mb_load_size = mb_kernel_size;\n\n        }\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                 mb_load_size, mh_load_addr);\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n\n            fprintf(stderr, \"fread() failed\\n\");\n\n            exit(1);\n\n        }\n\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n\n        fclose(f);\n\n    }\n\n\n\n    mbs.mb_buf_phys = mh_load_addr;\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n\n\n\n    /* Calculate space for cmdlines and mb_mods */\n\n    mbs.mb_buf_size += strlen(kernel_filename) + 1;\n\n    mbs.mb_buf_size += strlen(kernel_cmdline) + 1;\n\n    if (initrd_filename) {\n\n        const char *r = initrd_filename;\n\n        mbs.mb_buf_size += strlen(r) + 1;\n\n        mbs.mb_mods_avail = 1;\n\n        while (*(r = get_opt_value(NULL, 0, r))) {\n\n           mbs.mb_mods_avail++;\n\n           r++;\n\n        }\n\n        mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n\n    }\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n\n\n\n    /* enlarge mb_buf to hold cmdlines and mb-info structs */\n\n    mbs.mb_buf          = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n    mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n\n\n\n    if (initrd_filename) {\n\n        char *next_initrd, not_last;\n\n\n\n        mbs.offset_mods = mbs.mb_buf_size;\n\n\n\n        do {\n\n            char *next_space;\n\n            int mb_mod_length;\n\n            uint32_t offs = mbs.mb_buf_size;\n\n\n\n            next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename);\n\n            not_last = *next_initrd;\n\n            *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename);\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n            mb_debug(\"multiboot loading module: %s\\n\", initrd_filename);\n\n            mb_mod_length = get_image_size(initrd_filename);\n\n            if (mb_mod_length < 0) {\n\n                fprintf(stderr, \"Failed to open file '%s'\\n\", initrd_filename);\n\n                exit(1);\n\n            }\n\n\n\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n            load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs);\n\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n\n\n\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n\n                     (char *)mbs.mb_buf + offs,\n\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n\n            initrd_filename = next_initrd+1;\n\n        } while (not_last);\n\n    }\n\n\n\n    /* Commandline support */\n\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n\n             kernel_filename, kernel_cmdline);\n\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n\n\n\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n\n\n\n    /* the kernel is where we want it to be now */\n\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                                | MULTIBOOT_FLAGS_CMDLINE\n\n                                | MULTIBOOT_FLAGS_MODULES\n\n                                | MULTIBOOT_FLAGS_MMAP);\n\n    stl_p(bootinfo + MBI_MEM_LOWER,   640);\n\n    stl_p(bootinfo + MBI_MEM_UPPER,   (ram_size / 1024) - 1024);\n\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n\n\n\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n\n\n\n    /* save bootinfo off the stack */\n\n    mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n\n    memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n\n                     mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n\n                     sizeof(bootinfo));\n\n\n\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n\n    option_rom[nb_option_roms].bootindex = 0;\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 8955, "substitutes": {"fw_cfg": ["framework_fg", "framework_config", "fw_fg", "fw_config", "framework_conf", "fw2fg", "fw2conf", "framework_cfg", "fw_conf", "fw2cfg", "fw2config"], "f": ["p", "h", "cf", "v", "fc", "rf", "l", "fr", "uf", "j", "feed", "fb", "u", "o", "fs", "b", "g", "file", "d", "fn", "fd", "fp", "fi", "F", "m", "c", "t", "buffer", "e", "fac", "w", "fw"], "kernel_filename": ["ernel_filename", "kernel_file", "ernel_fn", "kernel_username", "kernel_fn", " kernel_file", "ernel_username", "kernel_directory", " kernel_directory", " kernel_location", "ernel_file", "kernel_location"], "initrd_filename": ["initrd_name", "initrdffilename", "initrdfname", "initrdjfilename", "initrd_dll", "initrnjname", "initrn_filename", "initrdjfn", "initrdfdll", "initrdjname", "initrd_fn", "initrn_name", "initrdffn", "initrdjdll", "initrn_fn", "initrnjfilename", "initrnjfn", "initrn_dll", "initrnjdll"], "kernel_cmdline": ["kernel_hostlines", "kernel_cmdLine", "kernel_paylines", "kernel_cmdlines", "kernel_commandline", "kernel_commandLine", "kernel_commandlist", "kernel_payLine", "kernel_hostlist", "kernel_hostline", "kernel_cmdlist", "kernel_paylist", "kernel_hostLine", "kernel_commandlines", "kernel_payline"], "kernel_file_size": ["kernel_file2name", "kernel_data_name", "kernel_data_length", "kernel_file2size", "kernel_file_name", "kernel_data_size", "kernel_data_Size", "kernel_file_length", "kernel_file_Size", "kernel_file2Size", "kernel_file2length"], "header": ["hea", "p", "h", "list", "dr", "metadata", "cmd", "tag", "head", "frame", "format", "tar", "version", "entry", "title", "padding", "meta", "prot", "fr", "layer", "code", "window", "hd", "th", "holder", "line", "Header", "n", "config", "server", "event", "er", "prefix", "file", "history", "index", "handle", "headers", "info", "term", "hl", "hh", "hash", "heading", "queue", "offset", "hawk", "body", "buffer", "eh", "len", "block", "table", "ptr", "magic", "profile", "address", "peer", "drm"], "i": ["ui", "di", "p", "cli", "x", "ims", "yi", "uri", "v", "gi", "ic", "ai", " ii", "ind", "ei", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "multi", "u", "slice", "bi", "n", " I", "in", "hi", "si", "index", "rest", "li", "info", "y", "ini", "it", "ci", "m", "c", "io", "t", "ip", "mi", "zi", " j", "ij", "batch", "ti", "qi", "im", "point", "pi", "me"], "mh_entry_addr": ["func", "mh_add_addr", "dll", "cont", "mh_entry__offset", "fat", "new", "mh_entry__add", "bl", "mh_entry_address", "mh_add_add", "mh_entry__address", "mh_entry_add", "def", "_", "info", "mh_add_address", "mh_add_offset", "mh_entry__addr", "ptr", "mh_entry_offset", "cmd"], "mh_load_addr": ["mh_load_attr", "mh_loader_attr", "mh_load_address", "mh_loader_add", "mh_load_add", "mh_loader_addr", "mh_loader_address"], "mb_kernel_size": ["mb_kernel_storage", "mb_total_offset", "mb_kernel_offset", "mb_ernel_SIZE", "mb_kernel__size", "mb_kernel_name", "mb_total_name", "mb_kernel_data", "mb_ernel_storage", "mb_kernel__offset", "mb_ernel_size", "mb_total_SIZE", "mb_kernel_SIZE", "mb_total_size", "mb_kernel__name", "mb_ernel_data", "mb_kernel__SIZE"], "mbs": ["embs", "nbs", "mfs", "nts", "amubs", "hmbi", "ymbits", " mws", "ncs", "mcs", "hmubs", "mubs", "ambs", "emcs", "nbits", " mts", "ambi", " mBS", "mbits", "emts", " mvs", " mbi", "amws", " mubs", " mbits", "mvs", "mws", " mfs", "mts", " mcs", "emvs", "nfs", "hmbs", "ymbs", "hmws", "ymBS", "mbi", "nvs", "nBS", "ymfs", "mBS"], "bootinfo": [" bootinformation", "buildinfo", "businfo", "bootinformation", "busfo", "buildfo", "busstat", "buginformation", "ootfo", " bootInfo", "bootInfo", "bootdata", "busInfo", "bugInfo", " bootdata", "buginfo", "buildstat", "buildInfo", "bootstat", "ootinfo", "ootstat", "bugdata", "ootinformation", "businformation", "ootdata", "buildinformation", "ootInfo", "bootfo"], "mb_bootinfo_data": ["mb_bootinfo_table", "mb_bootinfo_size", "mb_bootdata_table", "mb_bootdata_bytes", "mb_bootinfo_bytes", "mb_bootdata_data", "mb_bootdata_size"], "elf_entry": ["lf_entry", "lf_list", "elf2row", "elf2entry", "elf_ent", "lf_row", "elf_name", "lf_ent", "elf_row", "elf2name", "lf_low", "elf2low", "elf_list", "lf_name"], "elf_low": ["elf_lower", "ELF_entry", "elf___diff", "ELF_size", "lf_diff", "lf_low", "ELF_low", "lf_lower", "elf_diff", "ELF_lo", "elf_size", "lf_high", "lf_left", "ELF_left", "elf___high", "elf___li", "elf_left", "elf_li", "ELF_small", "elf___low", "ELF_old", "elf_old", "elf_lo", "lf_li", "elf_small"], "elf_high": ["lf_large", "elf__no", "elf_large", "elfachigher", "elfachigh", "lf_no", "lf_high", "elfaclow", "lf_low", "elf__high", "ELF_low", "elf_no", "lf_hi", "lf_higher", "elf_hi", "elf_higher", "ELF_high", "elfacno", "elf__low", "elf__higher", "ELF_hi"], "kernel_size": [" kernel_Size", "kernel___size", " kernel64ize", "kernelitytime", "kernel_index", " kernel64size", "ernel_SIZE", " kernel_time", "kernel64ize", "kernel_len", "kernel_ize", "kernel___speed", "kernel10size", "kernel64Size", "kernel10index", "kernel_time", "ernel_index", "kernel___SIZE", "kernelitySIZE", "kernel_speed", " kernel_SIZE", "kernel_Size", "kernel10SIZE", "kernel64size", "kernel___index", "ernel_speed", "ernel_size", "kernel_SIZE", "kernelitylen", " kernel_ize", " kernel_len", "kernel10speed", " kernel64Size", "kernelitysize"]}}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,\n\n                                          int *beta, int *tc, uint8_t *no_p,\n\n                                          uint8_t *no_q)\n\n{\n\n    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),\n\n                                beta, tc, no_p, no_q);\n\n}\n", "idx": 8963, "substitutes": {"pix": ["cpixt", "jpixels", " pich", "pIX", "vik", "ppich", "vix", "ppIX", "jpich", "pich", "vixt", " pik", "ppix", "cpik", "jpIX", " pixels", "ppixels", "pixels", "jpix", "cpix", "cpixels", " pixt", " pIX", "pik", "pixt", "vixels"], "stride": ["stue", "trride", "stides", "sprides", "strl", "trides", "sprue", " strl", " strue", "strride", "stl", "trl", " strride", "strides", "stide", "tride", "spride", " strides", "strue", "sprride"], "beta": ["fine", "pro", "cb", "bil", "nda", "pixel", "dust", "texture", "nb", "bet", "fee", "\u03b2", "broad", "phi", "lambda", "boost", "margin", "diff", "b", "scale", "mie", "Beta", "late", "bis", "gam", "t", "filter", "buffer", "ta", "db", "base", "bps", "ba", "mu", "alpha", "bs", "confidence"], "tc": ["ts", "dc", "cb", "cus", "cm", "tm", "tar", "fc", "bc", "tk", "tt", "dt", "cu", "cc", "cv", "cas", "uca", " TC", "td", "tu", "tv", "tim", "ec", "TC", " TTC", "tf", "currency", "ci", "c", "mc", "t", "sc", "ta", "cs", "cci", "tty"], "no_p": ["no_P", "No_p", "no_pp", "No_m", " no_pp", "No_P", " no_m", "no_pt", "No_pt", "no_m"], "no_q": ["nojw", "no___qs", "No_p", "No_qs", "nojp", "no___p", "nojqs", " no_r", "no_w", "No_q", " no_b", "no___q", "no___b", "No_w", "no_b", "nojq", "no_r", "no_qs", "no___w", "no___r"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n", "idx": 8970, "substitutes": {"s": ["x", "sb", "ses", "ls", "xs", "ix", "u", "south", "sv", "as", "js", "sys", "t", "source", "se", "ms", "w", "ns", "session", "sync", "h", "ats", "sw", "ies", "ps", "pt", "sq", "fs", "sl", "q", "sg", "stats", "ds", "sc", "status", "vs", "cs", "ims", "p", "i", "its", "ties", "ex", "o", "g", "is", "eps", "os", "y", "ctx", "hs", "spec", "us", "sql", "r", "ts", "self", "rs", "f", "v", "ss", "es", "z", "als", "gs", "sts", "n", "local", "m", "S", "bs", "qs"], "ext": ["r", "p", "extra", "cb", "x", "ab", "off", "f", "v", "cont", "test", "xt", "ic", "esc", "exec", "end", "ind", "str", "ix", "ex", "at", "out", "lt", "external", "xp", "obj", "temp", "tmp", "enc", "g", " Ext", "Ext", "ec", "tx", "ref", "tf", "ctx", "fp", "inter", "EXT", "text", "txt", "t", "e", "ptr", "tex", "w", "cmd"], "c": ["r", "p", "dc", "cb", "co", "C", " cc", "tc", "cf", "f", "v", "cont", "ic", "cur", "z", "fc", "abc", "bc", "ct", "uc", "lc", "cu", "cc", "unc", "rc", "n", "cp", " cr", "g", "d", "enc", "cache", "ec", "cmp", "ca", "ce", "m", "chain", "t", "cation", " ec", "sc", "con", "loc", "can", "cs", "vc", "e", "gc", "fac", "w", "ac"], "a": ["p", "al", "sta", "A", "sha", "ab", "ma", "ae", "i", "sa", "v", "ar", "ata", " sa", " A", "am", "na", "j", "an", "oa", "at", "u", "ao", "o", "ea", "area", "as", "pa", "index", "ach", "ca", "ia", "m", "part", "t", "la", "ta", "ba", "alpha", "aa", "ac"], "b": ["r", "p", "cb", "bf", "sb", "be", "ab", "i", "f", "v", "nb", "bp", "bc", "j", "bb", "eb", "ub", "fb", "u", "ib", "bi", "n", "o", "g", "d", "B", "to", "y", "m", "t", "db", "base", "rb", "ba", "beta", "e", "bs", "by"], "b_const": [" b_conf", " b_Const", "b___const", "b___Const", "a_const", " b_con", "b__con", "b___cur", "b__const", " b__const", "b_con", "b__conf", " b__con", "a_con", "b_conf", "b___con", "b_cur", " b__conf", "a_cur", "b_Const", "a_Const"], "l": ["r", "p", "tl", "h", "lp", "i", "f", "v", "ls", "z", "lang", "ln", "j", "dl", "lc", "ml", "u", "nl", "lt", "n", "label", "o", "rl", "lu", "sl", "g", "le", "kl", "li", "ol", "m", "t", "jl", "la", "lin", "len", "loc", "ll", "L", "lv", "e", "lb", "el", "il"], "offset": ["usage", "limit", "metadata", "url", "data", "seed", "shift", "range", "count", "index", "adjusted", "to", "t", "len", "loc", "row", "ptr", "payment", "addr", "onto", "angle", "balance", "path", "attribute", "hl", "set", "trace", "Offset", "translation", "top", "buffer", "p", "skip", "off", "final", "slot", "amount", "sp", "frame", "id", "needed", "location", "pad", "padding", "entry", "start", "position", "lag", "slice", "o", "size", "time", "pointer", "offs", "address", "embed", "fp", "alias", "relative", "e", "length", "frequency", "error", "step", "timeout", "next", "online", "f", "origin", "pos", "point", "reference", "zero"], "need_cmp": ["need_quick", "need__different", "needs_omp", "Need_cmp", "Need_conn", "Need_conv", "Need_omp", "need__comp", "needs_tmp", "needfulcomp", "neededcomp", "needfulquick", "need2omp", "Need_comp", "need2cmp", "needs_comp", "need_tmp", "need__quick", "need_comp", "need2tmp", "Need_cp", "needfuldifferent", "neededtmp", "Need_quick", "need__cmp", "need_conn", "need_conv", "Need_different", "need_cp", "need_omp", "needfulcmp", "need2comp", "neededomp", "needs_cmp", "need_different", "neededcmp"]}}
{"project": "qemu", "commit_id": "3736cc5be31f0399999e37d8b28ca9a3ed0b4ccb", "target": 0, "func": "static int nbd_negotiate_options(NBDClient *client, Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    trace_nbd_negotiate_options_flags();\n\n    be32_to_cpus(&flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        trace_nbd_negotiate_options_newstyle();\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        trace_nbd_negotiate_options_no_zeroes();\n\n        client->no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EIO;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n\n\n        trace_nbd_negotiate_options_check_option(option);\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                tioc = nbd_negotiate_handle_starttls(client, length, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_TLS_REQD,\n\n                                                 option, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                ret = nbd_negotiate_handle_list(client, length, errp);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8988, "substitutes": {"client": ["self", "util", "cli", "public", "conn", "plugin", "master", "request", "handler", "connection", "cell", "entry", "connect", "network", "call", "command", "query", "cl", "window", "lock", "google", "code", "application", "http", "component", "channel", "close", "admin", "policy", "api", "config", "patch", "complete", "store", "secure", "server", "Client", "remote", "service", "core", "prefix", "net", "app", "cache", "pattern", "attribute", "local", "force", "wrapper", "c", "manager", "chain", "buffer", "current", "port", "con", "ping", "product", "context", "pc", "response", "cmd"], "errp": ["errprogress", "eorp", "addrpp", "ezp", "errpad", "derpid", "acerp", " errps", "errorpy", "ezping", "errorps", "errpoint", "errorp", "nerpad", "herpg", "eorprogress", "devpa", "lrpoint", "lrpid", "eorpa", "errord", "errper", "derpy", "errorpg", "ptrp", "derping", "errorping", "lrp", "errorpid", "errorn", "errping", "derps", "lrpress", "errpg", "nerv", "rrpad", " errpa", "addrp", "devping", "ezpa", " errpid", "rrpoint", "lrps", "eorper", "ezpg", "errv", "testpp", "devP", "rrv", "ptrpa", "testpa", "arrpa", "herpa", "addrping", "erping", "rerp", "reqping", "errpy", "acerper", "rerping", "derpress", "errpa", "rern", "errn", "herping", "errP", "lrpad", "erpa", "rerpy", "addrP", "reqP", "reqpa", "errd", "errpp", "errpress", "nerpoint", "acerprogress", " errpp", "derP", "errps", " errP", "ptrP", "lrv", "derp", "derpa", "rrps", "rrpid", "rrp", "devp", "testP", "rerpid", "erp", "dern", "rerpg", "rrpress", "arrp", "derpp", "ptrpp", "erP", "testp", "arrprogress", "derpg", "nerp", "reqp", "acerpa", "arrper", "derd", " errping", "errpid", "rerd", "herp"], "flags": ["options", "bugs", "packages", "flag", "opens", "ants", "alf", "amps", "issues", "finals", "ints", "grades", "features", "faces", "ags", "planes", "ms", "rates", "reports", "types", "levels", "phones", "settings", "fee", "ps", "terms", "parts", "properties", "fs", "acts", "posts", "stats", "fields", "weights", "utils", "comments", "locks", "fits", "orts", "cs", "ports", "lines", "doms", "atts", "marks", "cf", "points", "lag", "links", "FLAG", "Flags", "values", "facts", "aints", "styles", "limits", "products", "mask", "members", "ts", "fps", "vals", "aps", "allows", "args", "heads", "tags", "mates", "actions", "details", "goal", "xxx", "states", "bits", "words", "lands"], "ret": ["opt", "flag", "RET", "mem", "cat", "result", "usr", "Ret", " RET", "lock", "val", "lag", "line", " alt", "try", "ry", "reset", " resp", "resp", "ruby", "valid", "alt", "Return"], "option": ["options", "opt", "flag", "timeout", "feature", "slot", "condition", "comment", "tag", "ption", "column", "dimension", "op", "pair", "optional", "connection", "entry", "command", "mod", "question", "lock", "position", "example", "holder", "TION", "key", "archive", "order", "label", "item", "event", "prefix", "trial", "index", "field", "term", "attribute", "section", "bit", "category", "package", "variable", "offset", "argument", "byte", "weight", "volume", "alias", "point", "table", "Option", "action", "operation", "error"], "length": ["options", "p", "limit", "Length", "ength", "type", "json", "test", "number", "data", "location", "l", "padding", "capacity", "angle", "lock", "window", "position", "th", "all", "line", "label", "delay", "total", "count", "size", "time", "loop", "prefix", "partial", "maximum", "path", "field", "var", "impl", "term", "display", "full", "style", "tail", "offset", "sequence", "weight", "text", "volume", "buffer", "len", "block", "loc", "row", "ll", "lv", "level", "duration", "error"], "magic": ["session", "pic", "mm", "flag", "metadata", "comment", "slot", "feature", "vector", "tag", "type", "modified", "id", "handler", "eric", "mag", "format", "serial", "version", "random", "tech", "padding", "meta", "mmm", "interface", "code", "special", "holder", "policy", "bug", "notice", "origin", "config", "icon", "size", "zone", "prefix", "generic", "mini", "script", "encrypted", "info", "machine", "hash", "style", "xxx", "header", "offset", "kind", "module", "mic", "volume", "alias", "status", "Magic", "mask", "action", "cookie", "mode", "mid", "mobile", "spec", "agic", "error", "cmd"]}}
{"project": "qemu", "commit_id": "f21126df5f81797486eb3bd628da8e2ad5fae12e", "target": 1, "func": "static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { /* write */\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n", "idx": 9025, "substitutes": {"s": ["changes", "sb", "ses", "events", "ls", "aws", "comm", "sv", "as", "er", "d", "bis", "js", "sys", "c", "t", "series", "state", "se", "ms", "w", "ns", "less", "search", "h", "ats", "conf", "sw", "ies", "ps", "terms", "parts", "sq", "obj", "fs", "sl", "serv", "set", "stats", "ds", "ssl", "comments", "services", "vs", "cs", "ims", "ports", "p", "sol", "i", "its", "ties", "sports", "ex", "tests", "store", "is", "g", "b", "os", "y", "hs", "so", "spec", "results", "r", "ts", "self", "rs", "request", "v", "args", "es", "ss", "als", "gs", "sts", "in", "service", "details", "m", "S", "bs", "qs"], "bits": ["options", "ports", "airs", "units", "changes", "ts", "vals", "ats", "dates", "tools", "outs", "points", "pins", "ls", " flags", "cats", "its", "als", "settings", "obs", "jobs", "xs", "issues", "tags", "tests", "fixes", "parts", "nets", "checks", "flags", "abilities", "actions", "plugins", "values", "bytes", "details", "ions", "bit", "keys", "stats", "ds", "limits", "fields", "tops", "weights", "status", "mask", "features", "items", "locks", "bps", "vs", "ims", "bs", "versions", "ns"], "value": ["update", "x", "vector", "unit", "type", "json", "number", "data", "end", "hello", "total", "sv", "scale", "index", "cache", "this", "t", "current", "sum", "description", "vp", "mem", "test", "function", "name", "new", "field", "attribute", "package", "max", "sequence", "power", "VAL", "buffer", "status", "port", "we", "element", "p", "ue", "entry", "result", "VALUE", "position", "Value", "label", "size", "values", "variable", "V", "memory", "expression", "length", "save", "f", "v", "format", "version", "widget", "val", "key", "initial", "see", "bit", "message", "address"], "n": ["ren", "p", "ot", "x", "no", "nn", "yn", "on", "np", "next", "i", "f", "v", "un", "nb", "ng", "number", "z", "norm", "N", "name", "network", "nc", "l", "inn", "na", "j", "en", "ln", "an", "nr", "tn", "new", "pn", "all", "after", "nl", "ni", "nt", "o", "ne", "nm", "nan", "count", "gn", "g", "fn", "d", "net", "names", "y", "sn", "node", "note", "dn", "it", "m", "c", "t", "num", "len", "nor", "w", "mn", "cn", "ns"], "is_read": [" is_import", "is___import", "is_mix", "Is_write", "isplaceread", "is___read", "is___write", "ais_watch", "isplacemix", "is___mix", " is_reader", "isplaceimport", "is_import", "Is_readable", " is_mix", "is_readable", "is_watch", "is_current", " is_write", "ais_read", "ais_write", "is_write", "Is_current", "Is_read", "is_reader", " is_readable", "ais_readable", "isplacewrite"], "datacnt": ["catacentnc", "mutacounter", "dtacnt", "mutacent", "dataicent", "catacfg", "dataconounter", "dataccnt", "datainNT", "datacost", "datacnc", "datacentent", "catacct", "datecfg", "catainnc", "datcnc", "mutaconnt", "datacentust", "datactn", "placct", "dataconost", "datainounter", "catainno", "dataconNT", "dtacentnc", "mutocot", "catainfg", "datcct", "datactot", "dtacentost", "datecno", "datacentrowd", "catacentust", "dtacnc", "dataccct", "mutacot", "datainct", "daticnt", "mutocent", "mutocnc", "catacentnt", "daticct", "dataicot", "Datacnt", "placcnt", "datacentnc", "dataconno", "plactn", "datainnt", "Datacct", "datocnc", "catacust", "datacentnt", "mutocnt", "daticnc", "datainnc", "catainnt", "catacentct", "dataicnt", "datcust", "datacenttn", "datacounter", "daticrowd", "datocost", "mutacnt", "datacot", "placnt", "placnc", "mutacnc", "dtacentent", "datacfg", "dataccnc", "dataicnc", "placcct", "datecnt", "datacent", "datacentost", "mutacct", "mutacNT", "mutaconct", "mutaconounter", "dtacentnt", "dataconnt", "datecnc", "dataconct", "dataconent", "Datacrowd", "datactnt", "placcnc", "dtacent", "dataconfg", "placctn", "dtacost", "datainno", "datocent", "datacct", "datocot", "datacust", "datacno", "Datacnc", "datactnc", "mutaconNT", "datacentct", "datocnt", "datactent", "datacNT", "datacrowd", "catacnc", "datcnt", "catacno", "datacctn", "catacnt", "datainfg", "dataconnc"]}}
{"project": "FFmpeg", "commit_id": "93c04e095dc37ebdab22174e88cfa91e24940866", "target": 0, "func": "static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)\n\n{\n\n    AMFDataType type;\n\n    AVStream *stream, *astream, *vstream;\n\n    AVIOContext *ioc;\n\n    int i;\n\n    // only needs to hold the string \"onMetaData\".\n\n    // Anything longer is something we don't want.\n\n    char buffer[11];\n\n\n\n    astream = NULL;\n\n    vstream = NULL;\n\n    ioc     = s->pb;\n\n\n\n    // first object needs to be \"onMetaData\" string\n\n    type = avio_r8(ioc);\n\n    if (type != AMF_DATA_TYPE_STRING ||\n\n        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)\n\n        return -1;\n\n\n\n    if (!strcmp(buffer, \"onTextData\"))\n\n        return 1;\n\n\n\n    if (strcmp(buffer, \"onMetaData\"))\n\n        return -1;\n\n\n\n    // find the streams now so that amf_parse_object doesn't need to do\n\n    // the lookup every time it is called.\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        stream = s->streams[i];\n\n        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n            astream = stream;\n\n        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            vstream = stream;\n\n    }\n\n\n\n    // parse the second object (we want a mixed array)\n\n    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)\n\n        return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 9036, "substitutes": {"s": ["self", "ts", "p", "less", "x", "sb", "h", "ats", "conf", "ses", "rs", "se", "v", "ls", "f", "ss", "es", "als", "ps", "gs", "aws", "comm", "sts", "http", "ex", "space", "n", "sq", "fs", "sv", "sl", "b", "g", "ins", "os", "q", "scl", "js", "sys", "stats", "hs", "ds", "m", "c", "S", "t", "sc", "source", "spec", "series", "cs", "e", "bs", "w", "socket", "qs", "ns"], "next_pos": ["nextrowpos", "next_Pos", " next_offset", " next_POS", " next_loc", "nextrowloc", "next_loc", "next_POS", "next_pc", "next_offset", "nextrowoffset", " next_pc", "nextrowPos", " next_Pos"], "type": ["p", "types", "ype", "um", "tag", "rule", "test", "typ", "id", "role", "tar", "tp", "pe", "format", "name", "ver", "tool", "family", "ty", "error", "key", "at", "o", "time", "size", "area", "mt", "index", " TYPE", " family", "TYPE", "what", "to", "TY", "Type", "info", "tr", "style", " kind", "kind", "oe", "m", "t", "status", "ping", "message", "e", "class"], "stream": ["instance", "follow", "Stream", "data", "sample", "channel", "load", "transform", "ream", "iver", "stage", "filter", "batch", "source", "row", "socket", "sync", "sw", "iterator", "dd", "cont", "download", "test", "http", "stack", "archive", "line", "temp", "sl", "path", "package", "open", "draw", "sc", "port", "table", "host", "peer", "send", "window", "component", "record", "pipe", "o", "reflect", "time", "video", "tr", "embed", "wrapper", "track", "chain", "bo", "length", "pod", "present", "engine", "runtime", "v", "version", "sche", "pool", "loop", "form", "REAM", "display", "local", "view", "driver", "console", "message", "context", "spec"], "astream": [" astiver", "asream", "asstream", "astiver", "astingream", "estroy", "mastream", "astsstream", "astsob", "astroy", "mastore", " astem", "ASTrom", "eststream", "astsiver", " astob", " astrom", "estream", "astob", "asroy", "astrom", "asrom", "atream", "astem", "mastrom", "astsrom", "astingstream", "ASTream", "astore", "ASTstream", " astroy", "estrom", "atrom", " aststream", "astsem", "astsream", "astingob", "atstream", "maststream", "atore", "estore", "aststream", "astingem", "ASTiver"], "vstream": ["evpod", "evcomponent", "evstream", "svcomponent", "evloop", " vclean", "avthread", " vswitch", "vloop", " vserial", "svloop", "vpcontext", "vream", "vcomponent", "svpod", "svstream", "vcstream", "avconst", "vpthread", "vrcontext", " vream", "avclean", "avswitch", "vpstream", "cvswitch", "vconst", "vthread", "vcclean", " vconst", "vcserial", "cvconst", "vswitch", "avdebug", "vclean", "cvcomponent", "cvloop", "avream", "vrdebug", "cvream", "cvpod", "vserial", "avserial", "vcream", "cvstream", "avcontext", "vdebug", "vrstream", "vpdebug", "vrthread", "vpod", "vcontext", "avstream"], "ioc": ["iiOC", "liot", "uiog", "lioc", "liocl", " iocl", "liod", "biroc", "ioco", "piod", " iog", "piOC", "iog", "dioci", " iod", "dioca", "uioc", "liOC", " iot", "lioco", " ioco", "ioca", " ioca", " iocon", "iot", "biog", "dioc", "piot", "pioc", "iioca", "iioci", "uiroc", "biOC", "uiOC", "liocon", " iroc", "iocon", "piocon", "ioci", "iioc", "piocl", "diOC", "bioc", "iOC", "iocl", "pioco", " ioci", "iroc", "iod", " iOC"], "i": ["ui", "di", " pi", "cli", "x", " multi", "span", "uri", " ti", " m", " init", "gi", "ri", "ic", "ai", "id", " ii", " index", "ind", "ei", "ii", "j", " iter", "sim", "I", "xi", " vi", "phi", "ix", "ji", " mi", "multi", "u", "bi", " I", "in", "g", "my", "print", "si", "index", " my", " bi", "li", "ini", " li", "y", "info", "gu", " err", "it", " ni", "ci", "m", "\u0438", " di", "qi", "ip", "mi", "ij", " j", "batch", "ti", "im", "pi", "ki", "me", " si"], "buffer": ["limit", "extra", "font", "password", "comment", "document", "paste", "Buffer", "read", "never", "data", "reason", "command", "result", "padding", "uf", "page", "window", "position", "bb", "new", "phrase", "raw", "available", "stack", "database", "fb", "line", "null", "buf", "total", "temp", "size", "iter", "buff", "b", "history", "mb", "bytes", "cache", "empty", "queue", "button", "bridge", "sequence", "header", "blank", "byte", "check", "text", "binary", "batch", "source", "row", "table", "memory", "message", "context", "length", "zero"]}}
{"project": "qemu", "commit_id": "2e2aa31674444b61e79536a90d63a90572e695c8", "target": 0, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n\n        ret = msi_init(dev, 0, 1, true, false, &err);\n\n        /* Any error other than -ENOTSUP(board's MSI support is broken)\n\n         * is a programming error */\n\n        assert(!ret || ret == -ENOTSUP);\n\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n\n            /* Can't satisfy user's explicit msi=on request, fail */\n\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n\n                    \"msi=off with this machine type.\\n\");\n\n            error_propagate(errp, err);\n\n            s->msi_in_use = false;\n\n            return;\n\n        } else if (ret) {\n\n            /* With msi=auto, we fall back to MSI off silently */\n\n            error_free(err);\n\n            s->msi_in_use = false;\n\n        } else {\n\n            s->msi_in_use = true;\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 9038, "substitutes": {"dev": ["pro", "p", "av", "develop", "h", "conf", "DEV", "off", "Dev", "conn", "ev", " device", "proc", "mem", "v", "dd", "test", "de", "pack", "data", "serial", "cam", "tech", "priv", "usb", "pad", "pt", "ver", "sky", "env", "window", "raw", "device", "out", "stick", "ve", "nt", "des", "buf", "devices", "md", "er", "serv", "app", "scan", "def", "dem", "os", "tr", "handle", "var", "sd", "desc", "go", "sys", "driver", "ctx", "adv", "ds", "Device", "disk", "draw", "ad", "det", "pi", "vp", "hw", "spec", "w", "cmd"], "errp": ["diepa", "dieP", "derP", "errps", " errP", "diep", "derp", "derpa", "derps", "rpa", " errps", "errpa", " errpa", "errorps", "errorp", "errorpa", "errP", "rp", "errorP", "rP"], "d": ["r", "di", "p", "h", "dr", "D", "i", "f", "v", "dm", "data", "j", "dt", "n", "o", "g", "b", "dh", "sd", "dn", "ds", "m", "c", "t", "ad", "db", "e", "w"], "s": ["changes", "sb", "ses", "ls", "shared", "aws", "comm", "des", "south", "sv", "er", "as", "sam", "def", "_", "go", "js", "sys", "t", "source", "se", "w", "ms", "cmd", "ns", "less", "session", "h", "ats", "conf", "sw", "test", "params", "settings", "ps", "new", "all", "sq", "fs", "serv", "info", "sd", "set", "stats", "ds", "ssl", "res", "services", "vs", "cs", "ims", "scope", "p", "sa", "sp", "its", "sing", "ties", "l", "sim", "sports", "tests", "store", "is", "g", "b", "st", "os", "times", "y", "hs", "so", "results", "self", "ts", "func", "rs", "f", "v", "args", "ss", "es", "z", "gs", "j", "sts", "n", "details", "bs", "m", "S", "spec", "qs"], "err": ["r", "DERR", "p", "or", "aaa", "cr", "Er", "ev", "rs", "attr", "coord", "rr", "der", "cfg", "ers", "l", "str", "usr", "erb", "lr", "Error", "ex", "exc", "out", "buf", " terr", "errors", "obj", "iter", "er", "gz", "ec", "ch", "nil", "eas", "arr", "elt", "rt", "ref", "sys", "mr", "kr", "lex", "ras", "rn", "it", "txt", "t", "res", "rb", "ocr", "resp", "e", "erd", "msg", "error"], "ret": ["att", "x", "flag", "RET", "mem", "fun", "sat", "rev", "f", " Ret", "cont", "test", "success", "re", "l", "result", "j", "gt", "Ret", " RET", "deg", "usr", "val", "rem", "rm", "out", "nt", "rets", "iter", "ne", "not", "back", "mt", " alt", " fut", "try", "tr", "bool", "lit", "def", "ary", "arr", "elt", "rt", "ref", "ry", "reset", "reg", "txt", "t", "num", "backed", "len", "res", " res", "cert", "verified", "ll", "det", "resp", "got", "locked", "alt", "status", "ptr", "ter", "nz", "jp", "cmd"]}}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    int i;\n\n    GICState *s = KVM_ARM_GIC(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n\n\n\n    kgc->parent_realize(dev, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    i = s->num_irq - GIC_INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n", "idx": 9039, "substitutes": {"dev": ["pro", "p", "av", "h", "DEV", "Dev", "mem", "ev", "conn", "proc", "v", "de", "test", "dd", "data", "cam", "serial", "priv", "pad", "pt", "ver", "sky", "window", "hd", "debug", "device", "out", "ve", "buf", "des", "nt", "g", "serv", "d", "scan", "def", "dem", "os", "sd", "sys", "adv", "home", "ds", "Device", "dis", "disk", "t", "ad", "hw", "w", "cmd"], "errp": ["errorping", "nerping", "errorbp", "errr", "lerp", " errr", "diep", "errping", "errbp", "lerpb", "lerpar", "errpar", "dier", "diebp", "dieping", "errpa", " errpa", " errbp", " errpar", "errorp", "errorr", "diepar", "nerr", "errorpa", "lerr", "nerpa", "nerp", " errpb", " errping", "diepb", "errpb"], "i": ["x", " ti", " m", " ii", "ix", "iu", "u", "bi", " I", "remote", "print", "index", "to", "li", "\u0438", "c", "t", "batch", "ti", " n", "ms", " pi", "gi", "ic", "I", "phi", " e", "it", "mc", "qi", "mi", "asi", "ki", "me", "ims", "ui", "p", " l", "init", "uri", "id", "xi", "sim", "oi", "ex", "multi", "is", "y", "ini", "fi", "ci", "chain", "pi", "us", "di", " x", "f", "ri", "ai", "z", " t", "ii", "j", " mi", "iy", "in", "n", "hi", "si", " v", " p", "m", "ip", "zi", " j", "point", "im", "client"], "s": ["changes", "sb", "ses", "ls", "aws", "comm", "des", "sv", "as", "d", "sam", "has", "sys", "js", "c", "t", "ms", "se", "w", "ns", "cmd", "less", "h", "ats", "conf", "sw", "params", "ps", "parts", "sq", "obj", "a", "fs", "sl", "serv", "sd", "stats", "ds", "status", "services", "vs", "cs", "ims", "p", "its", "sing", "l", "store", "is", "g", "st", "os", "hs", "sis", "results", "self", "ts", "r", "rs", "f", "v", "args", "ss", "es", "gs", "j", "sts", "n", "details", "m", "S", "bits", "spec", "qs"], "sbd": [" sbc", "asdb", "csbo", "isdd", "rsbt", "lsbc", "sbo", "rsdd", "sbt", "rsbd", " sbt", "wsdd", "wsbr", "sysbr", "csbb", "sysbd", "wsbc", "sbb", "sbr", " sbo", " sdb", "csdb", "isbd", "lsbt", "jsbd", "sysdd", "jsdd", "sdb", "sdd", "csbd", "jsbr", "jsbc", "sbc", "asbb", "lsdb", "asbo", "lsbd", "wsbt", "rsbc", "rsdb", "sysbc", " sbb", "wsbd", "isbt", "asbd", "isbc"], "kgc": ["unkc", " kgpc", "pkgpc", "unkcc", "kgcc", "cmdc", "unkpc", "pkgc", "workci", "cmdpc", "pkgcc", "pkgci", "cmdl", " kgci", "kgci", "kgl", "kgpc", "workc", "pkgl", "workpc", " kgl", "cmdcc", "unkl", "workl"]}}
{"project": "FFmpeg", "commit_id": "ebea370dc3909aa182bae4c728b83516a904beca", "target": 0, "func": "static int write_fragments(struct Tracks *tracks, int start_index,\n\n                           AVIOContext *in)\n\n{\n\n    char dirname[100], filename[500];\n\n    int i, j;\n\n\n\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n\n        struct Track *track = tracks->tracks[i];\n\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n\n        mkdir(dirname, 0777);\n\n        for (j = 0; j < track->chunks; j++) {\n\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n\n                     dirname, type, track->offsets[j].time);\n\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n\n            write_fragment(filename, in);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9047, "substitutes": {"tracks": ["reports", "orders", "packages", "objects", "sets", "notes", "sections", "metadata", "events", "pps", "storms", "rs", "stones", "points", "phones", "photos", "workers", "tracking", "frames", "forms", "lists", "works", "jobs", "rows", "uploads", "amps", "acks", "tags", "roads", "projects", "tests", "maps", "docs", "modules", "errors", "plays", "shots", "reads", "videos", "tr", "times", "shows", "files", "keys", "stats", "styles", "needs", "cases", "hands", "fields", "hops", "features", "trak", "steps", "cycles", "series", "runs", "groups", "clips", "thumbnails"], "start_index": ["start_value", "startPointposition", " start_value", "startPointlevel", " start_slice", " start_Index", "start_level", " start_level", "start_slice", "start_position", "startPointvalue", "start_Index", " start_position", "startPointindex"], "in": ["rin", "mm", "or", "cb", "conn", "bin", "cm", "ic", "rec", "inn", "isin", "window", "new", " out", "inc", "ex", "out", "config", "serv", "ac", "din", "scan", "file", "vin", "IN", "In", "gin", "tx", "input", "ctx", "m", "mc", "c", "nin", "req", "current", "con", "inner", " din", "up", "stream", "doc", "context", "pc", "conv", "ins"], "dirname": ["logname", "folderName", "directoryname", "dirparent", "relname", "DIRprefix", "directoryparent", "dirName", "DIRpath", "relparent", "DIRparent", "dirroot", "diskName", "logName", "directoryroot", "dirprefix", "dirno", "folderprefix", "folderpath", "directorypath", " dirno", "folderno", "directorydir", "logNAME", "foldername", "reldir", "folderroot", "relbase", " dirprefix", "logdir", "DIRName", " dirpath", "diskname", "DIRname", "diskpath", "dirpath", " dirdir", "directoryName", "directorybase", "directoryno", "dirNAME", " dirNAME", "diskroot", "directoryNAME", "dirbase", "DIRbase", " dirName", "DIRdir", "dirdir"], "filename": ["ren", "writer", "ames", "via", "metadata", "np", "directory", "Filename", "fil", "json", "f", "wav", "NAME", "name", "title", "jpg", "location", "result", "csv", "username", "unc", "archive", "n", "nm", "tmp", "journal", "seek", "figure", "prefix", "fn", "file", "kj", "png", "fd", "path", "files", "sys", "fp", "fle", "ame", "text", "txt", "jl", "lua", "source", "FN", "description", "river", "ename", "length", "println"], "i": ["ui", "di", "ami", "x", "instance", "gi", "ri", "ic", "id", "ai", " ii", "iq", "ind", "name", "ii", "xi", "sim", "I", "ji", "phi", "ix", "iu", "ex", "multi", "u", "bi", " I", "o", "n", "me", "is", "g", "my", "hi", "si", "ie", "index", "ms", "li", "info", "y", "ini", "iat", "inter", "it", "\u0438", "ci", "m", "qi", "zi", "mi", "ip", "ij", "ti", "point", "im", "pi", "e", "ki", "ims", "ori", "ski", "us"], "j": ["r", "att", "aj", "oj", "jj", "next", "jc", "job", "v", "f", "json", "err", "jump", "jit", "z", "by", "ng", "ind", "pt", "bj", "fr", "ji", "sim", "other", "nr", "bot", "key", "at", "n", "obj", "ja", "ax", "b", "kj", "g", "kid", "index", "jet", "jo", "mn", "y", "q", "note", "js", "J", "br", "m", "it", "req", "je", "jl", "ij", "dj", "uj", "im", "bo", "k", "bs", "msg", "jp"], "track": ["ack", "report", "search", "step", "toggle", "skip", "sync", "ace", "follow", "fire", "comment", "job", "tag", "rank", "rule", "save", "tracking", "add", "trip", "rack", "kick", "rec", "tt", "component", "stack", "order", "process", "record", "Track", "bar", "store", "tmp", "complete", "form", "trial", "transform", "match", "tr", "tab", "field", "info", "note", "mount", "project", "trace", "task", "tf", "song", "move", "find", "claim", "t", "check", "play", "batch", "train", "row", "race", "profile", "sort"], "type": ["ack", " typ", "types", "ype", "tag", "typ", "test", "id", "pack", "format", "pe", " Type", " t", "name", "title", "ver", "ty", "error", "owner", "time", "file", "te", " TYPE", "TYPE", "info", "Type", "y", "rage", "style", "kind", "ime", "t", "buffer", "color", "length"]}}
{"project": "qemu", "commit_id": "31783203c3b74c11015b20194d57dada559940cf", "target": 0, "func": "char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n", "idx": 9049, "substitutes": {"type": ["types", "ype", "test", "typ", "op", "id", "role", "format", "pe", "tp", "ver", "year", "start", "lock", "family", "ty", "key", "like", "range", "rel", "size", "time", "area", "file", "TYPE", "what", "info", "Type", "y", "style", "otype", "kind", "m", "t", "ping", "class", "state", "error"], "name": ["search", "news", "x", "no", "ma", "on", "comment", "tree", "read", "id", "data", "NAME", "version", "title", "filename", "missing", "str", "start", "code", "named", "new", "root", "parent", "error", "raw", "key", "run", "order", "old", "admin", "out", "n", "null", "in", "size", "time", "not", "nm", "prefix", "dir", "file", "names", "path", "one", "local", "tx", "none", "lat", "now", "ame", "Name", "nam", "t", "part", "base", "normal", "up", "word", "item", "rel"], "len": ["gl", "lim", " clen", " l", "coll", "ld", "mem", "lp", "cap", "un", "ls", "Len", " dist", "sp", "z", "compl", " bl", " num", " el", "l", "str", " le", "en", "ln", "lf", "end", " length", "dl", "val", "bl", "ind", "nl", "lt", "n", "nt", "size", "comp", "sl", "el", "gz", " Len", "kl", "fl", " ans", "li", "cmp", "elt", "offset", "lan", "fin", "wid", "gen", "vec", "pos", "cod", "num", "loc", "ll", "resp", " n", "le", " mem", "length"], "subdir": ["subgroup", "Subpackage", " subdomain", "dataDir", "subdiv", "subpath", "Subparent", "subpackage", "Subgroup", "datadir", " subparent", "datadirectory", " subdirectory", "superdir", "ubdirectory", "ubgroup", "ubpackage", "superDir", "subDir", "Subpath", "subparent", "secdir", " subDir", "subdomain", "Subdomain", "ubparent", "secDir", "secpath", "superdiv", "ubdir", "datadomain", "superdirectory", "ubDir", "Subdiv", "secdirectory", " subgroup", " subpath", " subdiv", "Subdir", "SubDir", "Subdirectory", "subdirectory", " subpackage"], "buf": ["aka", "np", "bin", "cat", "err", "data", "cam", "broad", "rc", "cp", "buff", "cache", "var", "arr", "ref", "Buff", "text", "db", "rb", "Buffer", "cmd", "mem", "uffy", "ret", "ob", "bed", "code", "raw", "bl", "temp", "nm", "wb", "txt", "buffer", "port", "block", "bn", "msg", "seq", "cap", "cur", "str", "result", "uf", "out", "nt", "tmp", "b", "bytes", "ctx", "vec", "br", "doc", "func", "cb", "ff", "read", "v", "alloc", "pg", "bc", "n", "cv", "fd", "queue", "box", "uv", "bs", "gen", "img"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_flush(void)\n\n{\n\n}\n", "idx": 9055, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n", "idx": 9067, "substitutes": {"opaque": ["ipacity", "OPlay", " oplay", "cataque", " opacity", " opaques", " opque", "ipaques", "OPoid", "ipaque", "opque", "Oplay", "catoid", "opoid", " opoid", "OPaque", "opacity", "cataques", "opaques", "Opque", "oplay", "catacity", "Opaque", "OPque", "ipoid", "Opoid"], "addr": ["dr", "eth", "attr", "coord", "cap", "alloc", "add", "name", "start", "ix", "src", "dh", "handle", "var", "hash", "ref", "offset", "ctx", "adr", "br", "kt", "ad", "loc", "ptr", "state", "ctr", "address"], "size": ["password", "IZE", "mem", "type", "amount", "params", "number", "fee", "name", "command", "align", "n", "count", "Size", "shape", "offset", "ize", "weight", "body", "num", "len", "sum", "message", "SIZE", "address", "length"], "s": ["r", "ts", "p", "h", "sb", "rs", "ls", "ss", "es", "its", "ps", "gs", "ops", "sts", "n", "sq", "o", "fs", "a", "b", "as", "is", "d", "os", "js", "sys", "hs", "stats", "ssl", "states", "m", "S", "c", "ds", "t", "status", "cs", "e", "state", "w", "ns"]}}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9072, "substitutes": {"bs": ["ts", "sb", "rs", "aos", "bos", "ls", "BS", "ss", "its", "als", "obs", "bc", "ps", "cks", "gs", "bb", "ubs", "fs", "b", "lbs", "bles", "os", "bis", "js", "hs", "ds", "ubis", "bits", "bps", "vs", "cs", "ns"], "res": ["r", "ack", "pas", "cons", "resolution", "pr", "response", "vals", "pres", "red", "rs", "err", "ret", "rek", "ours", "re", "als", "result", "crit", "sim", "comm", "rez", "rem", "terms", "rc", "rss", "RES", "resh", "ress", "expr", "details", "rest", "def", "pers", "Res", "ro", "gr", "js", "reg", "results", "resp", "wcs", "ms", "scope", "rel", "ins"], "refcount_table": ["refcountsTable", "refcount_total", "refcount_index", "refcountstab", "refcountingtable", "refcount2total", "refcount_Table", "refcode2index", "refcode2total", "refcode_index", "refcode2table", "refcount2table", "refcountstable", "refcount2tab", "refcountingTable", "refcount2Table", "refcount_tab", "refcode_total", "refcode2tab", "refcount2index", "refcountingtab", "refcode_tab", "refcode_table"], "refcount_table_size": ["refcount_table2size", "refcount_list_size", "refcount_table2number", "refcount_tab_size", "refcount_table_SIZE", "refcount_table2name", "refcount_tab_SIZE", "refcount_table_name", "refcount_tab_number", "refcount_tab_name", "refcount_list_number", "refcount_table_number", "refcount_table2SIZE", "refcount_list_SIZE"], "offset": ["init", "off", "slot", "addr", "oid", "end", "location", "seed", "padding", "original", "stop", "window", "position", "shift", "align", "key", "slice", "origin", "o", "peer", "count", "seek", "pointer", "prefix", "index", "attribute", "first", "set", "ref", "reset", "trace", "Offset", "tile", "et", "top", "buffer", "pos", "alias", "block", "base", "point", "row", "address", "length", "error"], "size": ["resolution", "timeout", "type", "number", "gravity", "z", "name", "height", "padding", "capacity", "window", "small", "position", "shift", "scroll", "range", "space", "total", "count", "south", "since", "sized", "scale", "Size", "bytes", "shape", "empty", "sn", "zero", "style", "ize", "sum", "len", "message", "state", "SIZE", "length", "storage", "dimension", "error"], "s": ["ts", "p", "less", "h", "sb", "ats", "ses", "rs", "ls", "sp", "ss", "its", "als", "ps", "xs", "gs", "aws", "comm", "sts", "http", "sq", "abilities", "south", "sv", "fs", "sl", "b", "is", "g", "a", "sam", "eps", "os", "sn", "bis", "js", "bes", "hs", "ds", "stats", "S", "c", "cs", "ims", "qs", "ns"], "start": ["art", "step", "init", "next", "started", "from", "rank", "pre", "head", "id", "op", "end", "entry", "Start", "position", "shift", "root", " Start", "range", "origin", "starting", "store", "count", "iter", "pointer", "begin", "seek", "time", "index", "st", "get", "info", "first", "set", "max", "it", "arts", "part", "check", "top", "base", "row", "ist", "wind", "before", "use", "ish", " starting"], "last": ["nd", "final", "show", "bottom", "next", "vol", "ast", "end", "l", "stop", "query", "good", "old", "close", "after", "prev", "reverse", "total", "las", "count", "since", "latest", "local", "st", "largest", "rest", "full", "first", "highest", "tail", "max", "scope", "best", "stable", "est", "most", "base", "table", "length", "Last"], "cluster_offset": ["cluster___addr", "cliqueptoffset", "clust_index", "clocker_point", "clust_size", "cluster_shift", "cluster_addr", "clocker_start", "clust_Offset", "clusterixpoint", "cluster__pointer", "clique_Offset", "cluster___size", "clusterixstart", "clist_length", "clique_point", "cluster_address", "cluster___offset", "cluster___length", "clust_offset", "clusterixoffset", "clist_shift", "cluster_pointer", "clique_type", "cluster_type", "clusters_point", "clusterptoffset", "clusters_offset", "cliqueptOffset", "clusterixvalue", "clocker_offset", "clist_point", "clust_point", "clusterpttype", "cliqueptpoint", "clusterptOffset", "clusters_Offset", "cluster_start", "cluster___Offset", "cluster_point", "clist_offset", "clust_addr", "cluster___point", "cluster_Offset", "clocker_value", "cluster_size", "cluster_value", "cluster___shift", "clique_offset", "cliquepttype", "cluster_length", "clust_pointer", "cluster__address", "clust_address", "cluster__offset", "clusterptpoint", "cluster_index"], "k": ["ack", "p", "km", "acc", "i", "kn", "v", "ck", "z", "uk", "ek", "ikk", "j", "isk", "ka", "ik", "key", "u", "wk", "n", "ak", "ke", "g", "kj", "kid", "kh", "ko", "mk", "kl", "kk", "ks", "q", "kan", "K", "kr", "ku", "kind", "m", "c", "sk", "kw", "unk", "ac"], "check_errors": ["read_rors", "checkingrors", "read_results", "check_error", "checkingerrors", "checkingresults", "checkingerror", "check_results", "read_error", "check_rors", "read_errors"], "corruptions": ["cruptions", "cruptories", "crition", "corredion", "corruptories", "critories", "corression", "corredories", "corressories", "critions", "corruption", "corritions", "corredions", "corritories", "corruptations", "corredations", "corritations", "corressions", "cruptations", "corressations", "cruption", "corrition", "critations"]}}
{"project": "qemu", "commit_id": "f140e3000371e67ff4e00df3213e2d576d9c91be", "target": 1, "func": "static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n", "idx": 9087, "substitutes": {"bs": ["bid", "ts", "boxes", "cb", "cli", "sb", "blog", "cus", "ses", "aos", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "gs", "bb", "sts", "bl", "bi", "bh", "fs", "bt", "b", "lbs", "is", "ks", "bis", "js", "sys", "ds", "bits", "bps", "socket", "bn", "vs", "cs", "hz", "bm", "qs", "ns"], "request": ["QUEST", "instance", "condition", "pack", "hello", "worker", "change", "create", "transform", "index", "first", "now", "quest", "this", "requ", "current", "delete", "item", "session", "enter", "rule", "rate", "root", "new", "raw", "config", "begin", "package", "attribute", "open", "req", "buffer", "word", "report", "require", "pair", "frame", "command", "import", "position", "phrase", "record", "setup", "execute", "complete", "store", "server", "push", "each", "header", "claim", "use", "art", "list", "document", "re", "version", "object", "reason", "call", "query", "question", "run", "initial", "post", "form", "work", "get", "local", "have", "reset", "forward", "Request", "point", "message", "xml", "reference", "response"], "qiov": ["qqmom", "quiov", "oxiov", "qnox", "qualnox", " qnox", "qvoice", "oxiop", "qilo", "quiev", "quiop", "quj", "qqiev", "oxuj", "quvoice", "questiov", " qvoice", " qivic", "qiop", "qualiev", "qiv", "sqiov", " quj", "qqkov", "quuj", "quilo", " qkov", "qualivic", "eqilo", "qualmom", "sqiv", "qmom", "sqiev", "oxivic", "qukov", " qiv", " qiop", "qualiop", "qualiv", "eqiop", "eqiov", "qiev", "qqiv", "qkov", "quiv", "sqkov", "questilo", "questvoice", "qunox", "quivic", " qilo", "qumom", "qqiov", "questkov", "qqiop", "qivic", "eqkov", " qiev", "qualiov"], "client": ["util", "session", "cli", "co", "conn", "web", "ic", "handler", "correct", "connection", "cell", "cl", "window", "parent", "at", "api", "null", "store", "server", "remote", "bound", "Client", "net", "app", "cache", "local", "browser", "ca", "ctx", "box", "c", "bolt", "manager", "sc", "con", "pc", "lib", "response", "ac"], "ret": ["r", "pret", "no", "RET", "red", "ft", "fun", "rev", "err", " Ret", "cont", "re", "str", "result", "gt", "Ret", "deg", "en", "usr", "code", "val", "rem", "rm", "out", "lt", "nt", "rets", "back", "print", "mt", " alt", "ext", "tr", "def", "arr", "elt", "rt", "ref", "tf", "reset", "reg", "unt", "t", "num", "status", "res", "cert", "len", "det", "ll", "alt", "ord", "ctr", "ter", "nz", "arg"]}}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091, "substitutes": {"ctx": ["dc", "wd", "cb", "via", "np", "conn", "tc", " cx", "mem", "voc", "cf", "cm", "jp", "ck", "sp", "cfg", "tm", "bc", "nc", "ct", "xs", "crit", "window", "jac", "ka", "cu", "cc", "qt", "wx", "ctl", "obj", "cp", "xp", "tmp", "cas", "bh", "cv", "nt", "prefix", "grad", "history", "act", "handle", "kb", "tx", "cmp", "rt", "ca", "iat", "ci", "mc", "req", "rx", "this", "kt", "sc", "ij", "batch", "kw", "Context", "xc", "pkg", "context", "gc", "ctr", "cci", "hw", "pc", "cn", "cmd"], "insn": ["risnm", "insnin", "insnm", "tspn", "itsnm", "tssn", "linssn", "itsn", "tsn", "actsns", "insgn", "csgn", "actssn", "csns", "innin", "besn", "inn", "pinsn", "outsns", " insnm", " inspn", "insns", "inspn", "pinsl", "bespn", "rsns", "pinsns", "itsgn", "psl", "rissn", "psns", "tss", "insl", "csn", "outsgn", "itsns", " inssn", "risn", "actsnin", "rsnin", "pssn", "itspn", "outssn", "bessn", "rssn", "rispn", "actsn", "rsn", "cssn", "bess", "inssn", "itssn", "inss", "inns", "linss", "outsn", "psn", "linspn", "linsn", "rsl", "pinssn"], "di": ["dc", "yi", "idi", " Di", "i", "gi", "ai", "chi", "ei", "ii", "xi", "phi", "ani", "ali", "bi", "ni", "da", "si", "li", "ini", "fi", "ci", "dis", "adi", "zi", "Di", "DI", "mi", "ti", "det", "asi", "pi", "ki", "cci"], "tcg_r1": ["tcg_gr2", "tcg_g1", "tcg_h0", "tcg_l1", "tcg_h1", "tcg_rOne", "tcg_erOne", "tcg__l1", "tcg_h2", "tcg_m2", "tcg_g01", "tcg_rone", "tcg_er1", "tcg__r01", "tcg_gr1", "tcg_g2", "tcg_lon", "tcg_l2", "tcg_grone", "tcg__rOne", "tcg_p4", "tcg_l4", "tcg_l01", "tcg_er01", "tcg__r2", "tcg_er2", "tcg_r4", "tcg_p1", "tcg_l0", "tcg__r1", "tcg_p0", "tcg_r0", "tcg__l01", "tcg_mon", "tcg_p2", "tcg__l2", "tcg_ron", "tcg_mone", "tcg_r01", "tcg_lOne", "tcg__lOne", "tcg_h4", "tcg_gOne", "tcg_m1", "tcg_gron", "tcg_lone"], "tcg_r2": ["tcg_err02", "tcg_R4", "tcg_w0", "tcg_rtwo", "tcg_l1", "tcg_err0", "tcg_m2", "tcg_R2", "tcg_r02", "tcg_l02", "tcg_wpl", "tcg_err1", "tcg_g2", "tcg_m4", "tcg_wtwo", "tcg_t1", "tcg_t02", "tcg_l2", "tcg_m0", "tcg_l4", "tcg_err2", "tcg_r4", "tcg_l0", "tcg_w2", "tcg_r0", "tcg_Rtwo", "tcg_R1", "tcg_R0", "tcg_t2", "tcg_gpl", "tcg_rpl", "tcg_Rpl", "tcg_t0", "tcg_gtwo", "tcg_m1", "tcg_g0"], "ret": ["r", "pret", "RT", "RET", "ft", "rev", "err", " Ret", "std", "re", "result", "gt", "Ret", " RET", "tn", "val", "dt", "rm", "out", "lt", "nt", "des", "rets", "ne", "vt", "bt", "mt", "ext", "tr", "def", "try", "elt", "rt", "ref", "ry", "it", "txt", "t", "status", "res", "det", "resp", "ll", "alt", "nz"]}}
{"project": "FFmpeg", "commit_id": "f27b22b4974c740f4c7b4140a793cac196179266", "target": 0, "func": "static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,\n\n                                            uint8_t *src_cb, uint8_t *src_cr,\n\n                                            int linesize, int uvlinesize,\n\n                                            int xchg, int chroma444,\n\n                                            int simple, int pixel_shift)\n\n{\n\n    int deblock_topleft;\n\n    int deblock_top;\n\n    int top_idx = 1;\n\n    uint8_t *top_border_m1;\n\n    uint8_t *top_border;\n\n\n\n    if (!simple && FRAME_MBAFF(h)) {\n\n        if (h->mb_y & 1) {\n\n            if (!MB_MBAFF(h))\n\n                return;\n\n        } else {\n\n            top_idx = MB_MBAFF(h) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    if (h->deblocking_filter == 2) {\n\n        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;\n\n        deblock_top     = h->top_type;\n\n    } else {\n\n        deblock_topleft = (h->mb_x > 0);\n\n        deblock_top     = (h->mb_y > !!MB_FIELD(h));\n\n    }\n\n\n\n    src_y  -= linesize   + 1 + pixel_shift;\n\n    src_cb -= uvlinesize + 1 + pixel_shift;\n\n    src_cr -= uvlinesize + 1 + pixel_shift;\n\n\n\n    top_border_m1 = h->top_borders[top_idx][h->mb_x - 1];\n\n    top_border    = h->top_borders[top_idx][h->mb_x];\n\n\n\n#define XCHG(a, b, xchg)                        \\\n\n    if (pixel_shift) {                          \\\n\n        if (xchg) {                             \\\n\n            AV_SWAP64(b + 0, a + 0);            \\\n\n            AV_SWAP64(b + 8, a + 8);            \\\n\n        } else {                                \\\n\n            AV_COPY128(b, a);                   \\\n\n        }                                       \\\n\n    } else if (xchg)                            \\\n\n        AV_SWAP64(b, a);                        \\\n\n    else                                        \\\n\n        AV_COPY64(b, a);\n\n\n\n    if (deblock_top) {\n\n        if (deblock_topleft) {\n\n            XCHG(top_border_m1 + (8 << pixel_shift),\n\n                 src_y - (7 << pixel_shift), 1);\n\n        }\n\n        XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);\n\n        XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);\n\n        if (h->mb_x + 1 < h->mb_width) {\n\n            XCHG(h->top_borders[top_idx][h->mb_x + 1],\n\n                 src_y + (17 << pixel_shift), 1);\n\n        }\n\n    }\n\n    if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n        if (chroma444) {\n\n            if (deblock_topleft) {\n\n                XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n            }\n\n            XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n\n            XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n\n            if (h->mb_x + 1 < h->mb_width) {\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n\n            }\n\n        } else {\n\n            if (deblock_top) {\n\n                if (deblock_topleft) {\n\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n                }\n\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9094, "substitutes": {"h": ["p", "dev", "hr", "dr", "np", "mem", "hp", "f", "v", "ih", "k", "sh", "hm", "pp", "z", "rh", "l", "j", "hd", "comm", "hz", "th", "http", "ho", "H", "o", "obj", "bh", "a", "b", "g", "oh", "history", "zh", "ht", "he", "kh", "ph", "handle", "ah", "ch", "dh", "info", "cache", "hl", "hh", "hash", "q", "each", "header", "uh", "hs", "it", "m", "c", "here", "t", "eh", "hhh", "hal", "hi", "host", "hw", "w"], "src_y": ["src_ey", "src___yy", " src_yy", "src_yy", " src_xy", "src__yy", "source_ey", "src__ey", "src___Y", "src_Y", "src_xy", "src__Y", "src___y", " src_Y", "source_y", "source_Y", "src__xy", "src___ey", "source_yy", "src__y"], "src_cb": ["source_rb", " src_xy", "src___rb", "src___cb", "src_gb", "src_rb", " src_rb", "source_gb", "src_xy", "source_cf", "source_cb", "src___xy", "src_cf", "src_db", " src_db", "src___db"], "src_cr": ["source_vr", "src_r", "src__cr", "rc__r", "src_rc", "src__r", "rc__rc", "rc_rc", "source_cr", "source_ctr", "src_rx", "src_vr", "source_cb", "src_ctr", "rc__rx", "src__rx", "rc_rx", "rc__cr", "src__rc", "rc_cr", "rc_r"], "linesize": ["linksIZE", "insized", "pagesime", "linksizer", "pagesze", "inesizer", "inesize", " linesizer", "insIZE", "linesime", "pagesizer", "linksize", "linesizer", " linesime", "inesIZE", "insize", "linesIZE", "insizer", "facesizer", "facesize", "facesime", "pagesize", "inesized", " linesze", "linesized", "linesze", "linksized", "facesze"], "uvlinesize": ["UVlinesite", "UVpointssize", "uvworkszie", "uvlineize", "UVlinesized", "uzlinksizer", "uvlineze", "uvworkssize", "uvringsite", "uzlinesizer", "uzlineszie", "uvvalszie", "uvlocksite", "uvlinksization", "uvvalsize", "uvlsization", "UVlinesze", "uvlinessize", "uvlszie", "UVblocksize", "uvpointsize", "UVlinessize", "uzlinesization", "uvlinesization", "uzlinksization", "UVblocksite", "uvringsized", "UVlinesize", "uvlinesite", "uzlinksize", "uvworksze", "uvlineszie", "UVpointszie", "uzlinesize", "uvlinksize", "uvlinesze", "uvlinesized", "uvworksize", "UVlineszie", "uvlocksize", "uvvalsizer", "uvpointsze", "uzlinkszie", "uvlsize", "uvblocksized", "uvvalsization", "uvblocksite", "uvpointszie", "uvlocksized", "uvlinkszie", "uvlinksizer", "uvlinezie", "uvlinesizer", "uvpointssize", "UVblocksized", "uvblocksizer", "UVpointsize", "uvlsizer", "uvringsize", "uvlocksizer", "UVpointsze", "UVblocksizer", "UVlinesizer", "uvblocksize", "uvringsizer"], "xchg": ["xchngm", "xchegd", " xChgd", " xChgg", "xhyg", "xChgd", "xachg", " xchgg", " xchgm", "xachge", " xChg", "maxcheg", "maxchge", "xChgm", "xChg", "maxchege", "xchgd", "xchegm", "maxcheyg", "xchyg", "maxchgg", "xchngd", "maxchyg", "xachgg", "xchgg", "xchege", "xchge", "xchng", "xchegg", "xachyg", "maxchegg", "xchgm", "xhgg", "xcheyg", "maxchg", "xChgg", " xchgd", "xcheg", " xChgm", "xhge", "xhg", "xchngg"], "chroma444": ["lora95", "chromoa3", "chroma3", "chromoaue", "loraa95", "chromiuses", "chromauses", "chromiue", "lorauses", "chromi95", "chromaue", "loraauses", "chromaauses", "chroma95", "chromoa95", "chromaa95", "loraa3", "chromoauses", "lora3", "chromaa3", "loraaue", "chromaaue", "chromi3", "loraue"], "simple": ["less", "Basic", "common", "id", "clear", "quiet", "lower", "low", "classic", "sim", "special", "small", "only", "dirty", "minute", "tiny", "solid", "slow", "details", "strip", "partial", "min", "Simple", "empty", "quick", "full", "basic", "standard", "thin", "spread", "easy", "normal", "same", "valid", "mode", "single", "ply", "mid", "friendly", "complex"], "pixel_shift": ["pixel_transfer", "border_transfer", "pixel67shift", "chip_shift", "pixel_pull", "pixel_size", "pixel8size", "pixel2diff", "pixel2offset", "pixel2size", "pixel67pull", "cache_shift", "chip_hift", "chip_history", "pixel8shift", " pixel_size", "pixel8diff", "cache_sh", "pixel_offset", "pixel_vector", "pixel_history", "cache67shift", "cache67sh", "pixel_diff", "border_vector", "pixel2shift", "pixel_hift", "pixel67sh", "cache_pull", "cache67pull", "pixel8offset", "pixel_sh", " pixel_offset", "border_shift", " pixel_diff"], "deblock_topleft": ["deblock_tplevel", "deblock_toleft", "deblock_toplekt", "deblock_Totheest", "deblock_topleist", "deblock_teloft", "deblock_tplect", "deblock_toovel", "deblock_toplect", "deblock_Totheft", "deblock_teloct", "deblock_tpleft", "deblock_totheist", "deblock_tpleest", "deblock_stopleleaf", "deblock_tpleff", "deblock_todoreist", "deblock_toeft", "deblock_Topleest", "deblock_Topleff", "deblock_toleaft", "deblock_stoplekt", "deblock_Teloist", "deblock_Teloff", "deblock_todoreest", "deblock_todorevel", "deblock_tooct", "deblock_tooist", "deblock_Toplect", "deblock_topleest", "deblock_teloff", "deblock_Topleist", "deblock_Teloft", "deblock_Tplevel", "deblock_Tothevel", "deblock_teloist", "deblock_tolekt", "deblock_teloaft", "deblock_stelokt", "deblock_teloleaf", "deblock_totheft", "deblock_Toplevel", "deblock_stopleaft", "deblock_toplevel", "deblock_Tpleft", "deblock_Telovel", "deblock_topleff", "deblock_steloaft", "deblock_Topleft", "deblock_Totheist", "deblock_telovel", "deblock_totheff", "deblock_toeaft", "deblock_topleaft", "deblock_tpleist", "deblock_steloleaf", "deblock_tothevel", "deblock_Tpleist", "deblock_toeleaf", "deblock_todoreft", "deblock_toleleaf", "deblock_toekt", "deblock_steloft", "deblock_totheest", "deblock_Tplect", "deblock_tooft", "deblock_stopleft", "deblock_telokt", "deblock_topleleaf"], "deblock_top": ["debli_high", "deblock_target", "deblock___pop", "debock_TOP", "debock_top", "deblock_enabled", "debload_parent", "deblock_parent", "debli_bottom", "deblock___top", "deblocked_master", "deblock_bottom", "deblock_high", "debload___pop", "debli_top", "debock_Top", "deblocked_top", "debload_top", "debli_type", "deblock___enabled", "deblock_TOP", "debload_enabled", "deblock_tops", "debload_pop", "deblock___TOP", "deblockertop", "deblock_master", "deblock___parent", "debload___top", "deblocked_TOP", "debock_target", "debload___parent", "debload___enabled", "debock___Top", "debock___target", "deblock_type", "deblock___Top", "deblockerbottom", "deblock_Top", "deblockerhigh", "debock___top", "deblock_pop", "debock___TOP", "deblocked_tops", "deblock___target", "deblockertype"], "top_border_m1": ["top_border_p7", "top_border_p3", "top_border_m7", "top_border_p2", "top_border_l0", "top_border_v1", "top_border_l3", "top_border_m2", "top_border_M2", "top_border_M3", "top_border_l1", "top_border_M1", "top_border_M0", "top_border_m3", "top_border_v0", "top_border_v2", "top_border_v7", "top_border_l7", "top_border_l2", "top_border_v3", "top_border_m0", "top_border_p1"], "top_border": ["top_buffer", "topopcross", "first_bridge", "topopfilter", " top___Border", "first_border", "firstopcross", " top_buffer", " top___border", "top_Border", "top___border", "top_cross", "firstopfilter", "firstopborder", "firstopbridge", " top_prefix", "topopborder", " top_Border", "top___prefix", "top_filter", "first_cross", "first_filter", " top___prefix", "topopbridge", " top___buffer", "top_bridge", "top___Border", "top_prefix", "top___buffer"]}}
{"project": "FFmpeg", "commit_id": "c56e71309ec1a585ed4d4dc11ae0ba3ca7d19618", "target": 1, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint8_t *buf, int linesize)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len, height;\n\n    const uint8_t *ptr;\n\n    /* image block */\n\n\n\n    bytestream_put_byte(bytestream, 0x2c);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, avctx->width);\n\n    bytestream_put_le16(bytestream, avctx->height);\n\n    bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    /* no local clut */\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf;\n\n    for (height = avctx->height; height--;) {\n\n        len += ff_lzw_encode(s->lzw, ptr, avctx->width);\n\n        ptr += linesize;\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    bytestream_put_byte(bytestream, 0x3b);\n\n    return 0;\n\n}\n", "idx": 9095, "substitutes": {"avctx": ["aveca", "wavctx", "abctx", "avecb", "avecfg", "avtx", "ajjac", "avecmd", "afctx", "avjac", "Avpkg", "wavcmp", "averca", " avcfg", "Avcfg", "avercmp", "avepkg", "abcontext", "ajtx", "avcmp", "devcmp", "ajctl", "averctx", "avcmd", "wavcb", "avobj", " avobj", "avercontext", "devctl", "Avctx", "avecontext", " avcontext", "avca", "wavcontext", "abtx", " avca", "aveobj", "ajcmp", "ajobj", "ajctx", " avcb", "avejac", "abcmd", "abpkg", "devcontext", "afpkg", "avcfg", "abcmp", "ajcontext", " avjac", "Avcontext", " avtx", "avpkg", "avctl", "avcb", "avercb", "avetx", " avcmd", "afcontext", "aftx", "avcontext", " avctl", "avectx", "devctx", " avcmp", " avpkg"], "bytestream": [" bytestord", "ingtestingrum", "bygestrog", "byestorage", "bystestREAM", "byportREAM", "byparentdem", "bygeststream", "bysettroy", "trytestingstream", "byteststream", "bytestREAM", "ingtestrog", "byestream", "lytestREAM", "bytestrown", "bytestep", "Byestrown", "ingteststream", "bytestdem", "byportream", "bytestsstream", " byestod", "bytestagram", "tryteststream", "yteragram", "trytestream", "byparentstream", "byterreen", "ingtestingstream", " byestorage", "trytestreen", "bytestsream", "Bygeststream", "bytemprar", "byportorage", "Bytestep", "Bygestream", "bytestrip", " bygeststream", "byfreshep", "bytestreen", "bygestrown", "bytestingreen", "lysettep", "byserverream", "bytestrog", "trytestingreen", "thisparentroy", "byestriber", "byterream", "byparentep", "byestod", "byvestorage", "trytestob", " bygestep", "Byestream", " byeststream", "yterream", "thistestdem", "bystestorage", "byeststream", "bytestroy", "Byeststream", "yteststream", "ytestrum", " bytestep", "byestrown", "byestrum", "byportrum", "ingtestingrog", " byestep", "trytestingream", "trytestingob", "byterram", "bysettream", "lysettREAM", "bytestingod", "byfreshream", "byvestep", "lysettream", "bytestingrown", "byseedstream", "byestep", "bygestreen", "byportrar", "bytestord", "bytestingrog", "byserverram", "byestREAM", "bygestram", "bysettREAM", "byserverrip", "ytestream", "Bytestream", "bytestingob", "bysteststream", "bytempream", "thistestroy", "bygestep", "bygestrar", " bygestream", "byscriptagram", "ingtestrum", "byvestrown", "byvestREAM", "byveststream", "thisparentrog", "byvestream", "bytestod", "bytestrum", "bysportream", "bystestream", " bytestrip", "Byestep", "yterrum", "bytestingream", " bytestriber", "yterstream", "thistestream", " bygestrar", "byportep", "byportrog", " bytestod", " bygestram", " bytestrar", "bysettrown", "Bygestep", " byestream", "byscriptstream", "bytestob", "thisparentdem", "bysettrog", "bytestram", "byestrog", "bytempep", "lytestream", "bytestingep", "bytestrar", "byportriber", "byterrum", "byfreshriber", "thistestrog", "byestrar", "bytestingstream", "ingtestingream", "bytempstream", "byparentroy", " bytestram", "ingtestream", "byterstream", "bytestriber", "bytestingord", "byseedrar", "lytestrown", "byterob", "byscriptrum", "byteragram", "byestord", "Bytestrog", "ytestagram", " bytestorage", " bygestrip", "byseedorage", "byparentream", " byestriber", "bygestob", " byteststream", "lysettrown", "bygestrip", "bytestorage", "byseedream", " byestord", "byscriptream", "Bygestrog", "byparentrog", "Byteststream", "byterrip", "byserverstream", "bytestsod", "byportstream", "bysportorage", " byestrar", "bytestingrum", "Bytestrown", "byestagram", "bysettep", "lytestep", "bysportREAM", "byfreshrar", "thisparentream", "bytestsord", "bysettdem", "bygestream", "bysportstream", "bygestrum"], "end": ["hend", "send", "ent", "ending", "h", "nd", "END", "eng", "id", "add", "ender", "pend", "rend", "pad", "start", "stop", "en", "all", "close", "size", "begin", "bound", "post", "ended", "End", "to", "set", "max", "offset", "last", "ed", "buffer", " End", "e", "length"], "buf": ["p", "limit", "cb", "np", "mem", "bin", "cap", "err", "ff", "alloc", "pb", "data", "cur", "bc", "pad", "str", "result", "uf", "window", "raw", "fb", "out", "bag", "cv", "img", "tmp", "temp", "src", "buff", "b", "bytes", "tx", "queue", "ref", "ctx", "br", "bu", "wb", "vec", "txt", "text", "buffer", "block", "rb", "db", "bg", "stream", "doc", "orig", "Buffer", "msg"], "linesize": ["elinesIZE", "elinesize", "odesIZE", "odesize", "lsize", "elinesization", "elinesizing", "blocksization", "odesizing", "setsizes", "linesIZE", "linesization", "setsizable", "linesizes", "elinesizes", "setsization", "blocksize", "blocksizes", "lsizing", "linesizing", "setsize", "lsIZE", "elinesized", "linesized", "elinesizable", "lsized", "blocksizable", "odesized", "linesizable"], "s": ["r", "ts", "p", "less", "self", "h", "sb", "ats", "conf", "sw", "rs", "i", "v", "ls", "ss", "es", "its", "ps", "gs", "j", "aws", "comm", "ops", "sts", "ex", "n", "sq", "sv", "fs", "a", "is", "g", "b", "as", "os", "set", "js", "sys", "ctx", "hs", "ds", "ns", "stats", "m", "c", "S", "t", "bits", "spec", "vs", "cs", "ims", "bs", "w", "qs", "ins"], "len": ["gl", "p", "lim", "ld", " l", "limit", "list", "coll", "seq", "mem", "fun", "lp", "v", "ls", "ret", "addr", "Len", "sp", "z", "length", "data", "l", "lf", "ln", "en", "els", "val", "all", "nl", "n", "label", "nt", "SIZE", "size", "count", "iter", "total", "el", "mil", "kl", "fl", "li", "elt", "cmp", "ref", "max", "lan", "wid", "vec", "t", "pos", "cod", "loc", "ell", "ll", "lon", "L", "le", "fac", "msg"], "height": ["x", "rank", "type", "data", "radius", "rows", "ul", "capacity", "en", "depth", "total", "count", "d", "history", "crop", "t", "kw", "row", " Height", "k", "level", "h", "ows", "title", "seek", "shape", "hash", "lat", "max", "wid", "buffer", "block", "table", "host", "resolution", "html", "id", "location", "padding", "window", "th", "size", "zh", "y", "above", "grow", "style", "memory", "mode", "alpha", " size", "length", "Height", "high", "bottom", "v", "gravity", "widget", "week", "wh", "ch", "dim", "visible", "display", "view", "offset", "half", "check", "volume", "num", "hei", "hang", "context", "density"], "ptr": ["r", "ts", "p", "pr", "pointers", "dr", "off", "np", "proc", "mem", "red", "next", "coord", "pp", "addr", "alloc", "xt", "sp", "vr", "cur", "jp", "tp", "perm", "ind", "butt", "pend", "pad", "pt", "ps", "rep", "rect", "th", "dep", "peer", "inters", "seek", "pointer", "buff", "Ptr", "iter", "expr", "mt", "index", "push", "tr", "handle", "hl", "ref", "offset", "ctx", "fp", "inter", "trace", "br", "adr", "pos", "buffer", "loc", "row", "point", "prime", "cut", "pc", "ctr", "address", "rel", "cmd"]}}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"stbl\");\n\n    mov_write_stsd_tag(pb, track);\n\n    mov_write_stts_tag(pb, track);\n\n    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&\n\n        track->has_keyframes && track->has_keyframes < track->entry)\n\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        track->flags & MOV_TRACK_CTTS && track->entry)\n\n        mov_write_ctts_tag(pb, track);\n\n    mov_write_stsc_tag(pb, track);\n\n    mov_write_stsz_tag(pb, track);\n\n    mov_write_stco_tag(pb, track);\n\n    return update_size(pb, pos);\n\n}\n", "idx": 9101, "substitutes": {"pb": ["p", "func", "cb", "pr", "sb", "pl", "amp", "np", "wp", "tc", "proc", "lp", "px", "pac", "job", "pp", "typ", "nb", "pack", "tp", "dp", "pg", "bp", "bc", "emb", "pt", "bj", "uf", "tk", "rpm", "bb", "eb", "ub", "fb", "patch", "ib", "xp", "cv", "buf", "cp", "PB", "bh", "td", "b", "mb", "mt", "obb", "gm", "package", "pan", "sys", "pm", "fp", "wb", "mp", "orp", "stab", "bps", "batch", "aus", "rb", "resp", "pkg", "asm", "pc", "vp", "lb", "bs", "msg", "jp", "cmd"], "track": ["follow", "fire", "tag", "rank", "json", "tracking", "pack", "ek", "progress", "rm", "roll", "met", "transform", "tf", "task", "move", "find", "adr", "batch", "trak", "row", "pkg", "sort", "jp", "cmd", "search", "sync", "ace", "round", "comment", "attr", "tm", "stat", "rack", "kick", "acks", "stack", "seek", "scan", "hold", "match", "rt", "trace", "req", "txt", "review", "port", "word", "ack", "report", "skip", "btn", "require", "wp", "job", "ck", "tk", "consider", "record", "summary", "Track", "store", "complete", "reflect", "stall", "mt", "try", "tr", "each", "claim", "stab", "train", "gc", "bind", "ac", "sound", "rr", "tp", "add", "trip", "call", "tn", "agg", "rl", "form", "work", "tab", "token", "check", "tracks", "race"]}}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    if (nb_needed > nb_available) {\n\n        nb_needed = nb_available;\n\n    }\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 9106, "substitutes": {"bs": ["ts", "sb", "rs", "aos", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "cks", "gs", "ubs", "bl", "fs", "bh", "b", "lbs", "os", "bas", "ks", "bis", "js", "bes", "hs", "ds", "ubis", "bits", "bps", "vs", "cs", "lb", "bm", "ns"], "offset": ["off", "timeout", "slot", "vector", "amount", "addr", "op", "url", "onto", "id", "location", "seed", "padding", "pad", "start", "window", "scroll", "position", "shift", "key", "order", "range", "origin", "o", "time", "size", "seek", "pointer", "mt", "index", "offs", "cache", "set", "reset", "trace", "Offset", "fp", "tile", "frequency", "kernel", "pos", "top", "buffer", "et", "ip", "block", "base", "point", "alt", "image", "address", "length", "error"], "num": ["uni", "nom", "snap", "common", "no", "np", "um", "unit", "gpu", "mult", "un", "nb", "om", "number", "add", "missing", "NUM", "non", "other", "rem", "n", "nm", "dim", "cmp", "note", "cal", "nam", "Num", "nu", "sum", "con", "kw", "unique", "valid", "mu", "mon"], "s": ["self", "ts", "less", "p", "changes", "dev", "h", "sb", "ats", "conf", "sw", "ses", "rs", "v", "ls", "sp", "ss", "its", "als", "es", "settings", "ps", "gs", "j", "aws", "comm", "sts", "http", "parts", "sq", "sv", "fs", "sl", "b", "is", "as", "g", "a", "details", "ins", "ms", "os", "y", "bis", "js", "sys", "stats", "ds", "ssl", "hs", "m", "S", "sis", "states", "bits", "spec", "vs", "cs", "ims", "qs", "ns"], "l1_index": ["l1_num", "l1_unit", "l2_id", "l1____alias", "l1_result", "l2_result", "l1__alias", "l1Paddress", "l1__index", "l1PIndex", "l1_Index", "l1Punit", "l2_alias", "l1_alias", "l2_num", "l1__ind", "l1____index", "l1_ind", "l1_id", "l1_address", "l1____ind", "l2_Index", "l1__Index", "l1Pindex", "l2_ind", "l1____Index"], "l2_index": ["l14_offset", "l2__slice", "l14_index", "l2_slice", "l2__index", "l2___offset", "l2_page", "l2___Index", "l22Index", "l1_length", "l2_key", "l3_number", "l3_Index", "l2_value", "l2_number", "l2__offset", "l14_slice", "l2_length", "l3_ind", "l14_key", "l3_index", "l2___index", "l2_ind", "l2___page", "l2__key", "l22number", "l1_Index", "l22ind", "l1_ind", "l2___value", "l2_Index", "l2___length", "l22index", "l1_value"], "l2_offset": ["l14_offset", "l2_address", "l1_slice", "l2ptslice", "l2Pflag", "l14_index", "l2_slice", "ltwo_address", "l2___offset", "l1_error", "l2ptindex", "l14_location", "l1_set", "l3_Offset", "l3_address", "ltwojaddress", "l2_flag", "ltwo_flag", "l2_slot", "l2jflag", "l2_location", "l2joffset", "l2Pindex", "l2__offset", "ltwo_offset", "l2_error", "ltwojflag", "ltwojindex", "l1_url", "l2__Offset", "l2Poffset", "l2___url", "l3_offset", "l2jaddress", "l2__address", "l2jindex", "ltwojoffset", "l2___index", "l3_slot", "l2ptoffset", "ltwo_index", "l2__slot", "l2ptset", "l2___error", "l14_Offset", "l2_url", "l2_Offset", "l2Paddress", "l2_set", "l1_offset"], "l2_table": ["l2_trace", "l2_map", "l2_Table", "l52_map", "loderJtable", "l42ptcache", "l42_table", "l2Jbuffer", "l2_level", "loder_system", "l022Table", "l42_interface", "l2ptinterface", "l2_TABLE", "l2pinterface", "l2ptcache", "l22Table", "l22_level", "l22xtable", "l52_table", "l2pttable", "l2ttab", "l2__internal", "l022tree", "l2Pinternal", "l2Jlevel", "l2tbuffer", "l52Tinternal", "l2ptable", "l2__table", "l2thesystem", "l1_tab", "l2xlevel", "l2tTABLE", "l2Ttable", "l1_buffer", "l2Jstable", "l2_tab", "loder_tab", "l2__module", "l2Jtmp", "l2Tmap", "loder_stable", "l2Ptable", "l1_table", "l42ptinterface", "l2Pmodule", "l2Jsystem", "l02_table", "l52_module", "loderJstable", "l2_tmp", "l2Tmodule", "l22_tmp", "l2xtmp", "l2_system", "l2Pmap", "l2__map", "l22TABLE", "l02_TABLE", "l2Tinternal", "l22table", "l42_cache", "l022TABLE", "loderJsystem", "loderJtab", "l2_interface", "l42pttable", "l22tree", "l02_tree", "l1_TABLE", "l2_tree", "l022table", "l02_Table", "l22xlevel", "l2pttrace", "l2Jtable", "l22_table", "l52Ttable", "l2_module", "l42pttrace", "l42_trace", "l2_cache", "l2Jtab", "l2xtable", "loder_table", "l52Tmodule", "l2xbuffer", "l2thestable", "l2ttable", "l22xtmp", "l52_internal", "l52Tmap", "l2_buffer", "l2thetable", "l2pcache", "l22xbuffer", "l2thetab", "l22_buffer", "l2_stable", "l2_internal", "l2ptrace"], "cluster_offset": ["clider2offs", "cluster_count", "clider_offs", "cluster_error", "clider2shift", "clression_Offset", "cluster_shift", "cluster1offset", "clider2offset", "cluster_position", "cluster___prefix", "cluster___count", "cluster1error", "cluster67position", "cluster2off", "clignment_offset", "cluster_prefix", "clression67Offset", "clider2off", "cluster2offs", "clider_off", "clression_offset", "cluster___offset", "cluster____offset", "clression67shift", "clignment_point", "clusterListcount", "clignment_prefix", "clression_shift", "cluster_offs", "cluster2offset", "clression_position", "clusterListprefix", "cluster1size", "clusterListoffset", "clression67position", "clression67offset", "cluster_point", "cluster67shift", "cluster___point", "clusterListpoint", "cluster2shift", "clider_offset", "cluster____offs", "cluster_Offset", "cluster_size", "clignment_count", "clider_index", "cluster67offset", "cluster____shift", "clider_size", "cluster67Offset", "cluster____off", "cluster1index", "cluster_off", "clider_shift", "cluster_index", "clider_error"], "l1_bits": ["l1_bps", "l2_bits", "l1__bits", "l1_bytes", "l1___bytes", "l1_its", "l100_bs", "laxy_bs", "l2_bis", "l1___bits", "l1_caps", "l2_its", "l1___its", "l2_bytes", "l100_bits", "l1_planes", "l8_obs", "l1_obs", "l1__bps", "laxy_bytes", "l100_bytes", "l100_nuts", "l8_bits", "l1__bs", "l1_nuts", "l1_bs", "l2_bps", "l8_planes", "laxy_bits", "l8_bugs", "l1_bis", "laxy_caps", "l1___bis", "l2_bs", "l1_bugs"], "c": ["p", "dc", "h", "co", "conf", "C", "tc", "f", "i", "v", "cm", "cont", "z", "fc", "bc", "l", "ct", "lc", "cu", "cc", "unc", "rc", "n", "cp", "count", "b", "g", "d", "cache", "ch", "ca", "ci", "m", "mc", "t", "chain", "comments", "con", "cs", "cut", "pc", "k", "e", "gc", "cn", "ac"], "index_in_cluster": ["index_in_acluster", "index_in_plusters", "index_in_chusters", "index_in_plause", "index_in_Clause", "index_in_clust", "index_in_changer", "index_in_flusters", "index_in_aclusters", "index_in_clusters", "index_in_Clusters", "index_in_fluster", "index_in_pluster", "index_in_clause", "index_in_flause", "index_in_Clanger", "index_in_flust", "index_in_Clust", "index_in_chust", "index_in_clanger", "index_in_aclause", "index_in_Cluster", "index_in_aclust", "index_in_planger", "index_in_plust", "index_in_chuster"], "nb_available": ["uni67required", "nb_ready", "nb_present", "uni67available", "nbjavailability", "nrjdefined", "nz_loaded", "nr_external", "nbwfree", "nb____availability", "nb67required", "nz_free", "uni_required", "clifaware", "nbjinitialized", "nz___available", "nb____available", "ln_needed", "nrjinstalled", "nrjexternal", "nblaware", "nr_available", "nbFneeded", "cli_aware", "nblpresent", "cli_available", "n_available", "nbFrequired", "nb67installed", "nblrequired", "nbjdefined", "uni_available", "nbfavailable", "nbjinstalled", "nb_loaded", "uni67found", "nbfpresent", "nbwavailable", "n_initialized", "nbfaware", "nb_defined", "nb67aware", "nb____found", "nbjplayed", "nb67found", "nb___free", "uni67availability", "nbFavailable", "nb_initialized", "cli_required", "nb67present", "ln_available", "ln_played", "n_availability", "uni_availability", "nb___loaded", "nz___loaded", "nr_defined", "nb_installed", "n_loaded", "nbjrequired", "cli_present", "clifrequired", "nb_played", "nbFplayed", "uni_found", "nrjavailable", "nb___availability", "nb67availability", "nb____installed", "nz___ready", "nb67defined", "nz___free", "clifpresent", "nb____external", "clifavailable", "nbjexternal", "nb67external", "nb_found", "nb_free", "nbjavailable", "nb67available", "nb_external", "nbfrequired", "nb_aware", "nb___ready", "nb_availability", "nbwloaded", "nb___available", "nbjneeded", "nb____defined", "nb___initialized", "nbjloaded", "nr_installed", "nbwready", "nz_available", "nz_ready", "nb____required", "ln_required", "nb_required", "nblavailable"], "nb_needed": ["nb2necessary", "nbJavailable", "nbWneeded", "span7needed", "nb_dirty", "nb_want", "nn_required", "nn2required", "nbPneed", "nb_necessary", "niJallowed", "nbJexpected", "span7available", "nb_missing", "span_available", "cli_found", "nn_dependent", "nb___need", "nbWrequired", "ni_necessary", "NB_want", "nn_needed", "nb7expected", "niJneeded", "span_loaded", "nbznecessary", "nb___needed", "nb_loaded", "niJnecessary", "NB_needed", "nbzneeded", "span7loaded", "nb2dependent", "nbLneed", "nb_expected", "ni_dirty", "nbzdependent", "nbWdependent", "nballdirty", "cli_forced", "nbLneeded", "nb2required", "nballnecessary", "span_expected", "nb_dependent", "nballallowed", "ni_needed", "nbJnecessary", "nn_necessary", "nb___loaded", "nb___expected", "nbLmissing", "nb___forced", "nbPneeded", "nbJneeded", "span_needed", "ni_allowed", "nbLwant", "nb_need", "nbJloaded", "nbPmissing", "nb_found", "nbPwant", "nn2necessary", "nb7available", "niJdirty", "nb7loaded", "cli_needed", "nn2dependent", "nballneeded", "nbJdirty", "nb2needed", "cli_need", "nb___available", "nbWnecessary", "nb_forced", "nb7needed", "nbzrequired", "nb_allowed", "nb_required", "nbJallowed", "nb___found", "NB_missing", "nn2needed", "span7expected", "NB_need"], "nb_clusters": ["nb_bloses", "nb_clients", "nb_continusters", "nb_chroups", "nb_gliques", "nb_chusters", "nb_chators", "nb_contiques", "nb_bluster", "nb_clators", "nb_plroups", "nb_glusters", "nb_chuster", "nb_lores", "nb_ciques", "nb_chores", "nb_cliques", "nb_custers", "nb_canches", "nb_glanches", "nb_clroups", "nb_ploses", "nb_lodes", "nb_glients", "nb_closes", "nb_chodes", "nb_contusters", "nb_calusters", "nb_continators", "nb_caluster", "nb_lroups", "nb_clodes", "nb_cluster", "nb_clores", "nb_lusters", "nb_contients", "nb_pluster", "nb_blroups", "nb_plusters", "nb_cients", "nb_luster", "nb_caloses", "nb_blusters", "nb_calroups", "nb_contanches", "nb_continodes", "nb_continores", "nb_plores", "nb_clanches", "nb_lators"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;\n\n\n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n//printf(\"%X %X %X %X %X %X %X %X %X %X\\n\", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],\n\n//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\tb5Dither= dither8[y&1];\n\n\tg6Dither= dither4[y&1];\n\n\tg5Dither= dither8[y&1];\n\n\tr5Dither= dither8[(y+1)&1];\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\n/* no speed diference on my p3@500 with prefetch,\n\n * if it is faster for anyone with -benchmark then tell me\n\n\t\t\tPREFETCH\" 64(%0) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%1) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%2) \\n\\t\"\n\n*/\n\nYUV2RGB\n\n\n\n#ifdef DITHER1XBPP\n\n\t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\"\n\n\t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\"\n\n\t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\"\n\n#endif\n\n\t\t     /* mask unneeded bits off */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm0;\" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_grnmask)\", %%mm2;\" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm1;\" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */\n\n\n\n\t\t     \"psrlw $3,%%mm0;\" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */\n\n\t\t     \"pxor %%mm4, %%mm4;\" /* zero mm4 */\n\n\n\n\t\t     \"movq %%mm0, %%mm5;\" /* Copy B7-B0 */\n\n\t\t     \"movq %%mm2, %%mm7;\" /* Copy G7-G0 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpcklbw %%mm4, %%mm2;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpcklbw %%mm1, %%mm0;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm2;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"por %%mm2, %%mm0;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\n\n\t\t     \"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t     MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpckhbw %%mm4, %%mm7;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm7;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t     \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\t\t     \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\n\n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */\n\n\n\n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n\n\n    return srcSliceH;\n\n}\n", "idx": 9109, "substitutes": {"c": ["p", "dc", "coll", "h", "co", "conf", "C", "tc", "cf", "f", "v", "cm", "cont", "fc", "bc", "l", "ct", "cd", "lc", "cu", "cc", "rc", "n", "cv", "cp", "enc", "b", "d", "ch", "s", "ec", "etc", "ca", "ctx", "ce", "ci", "m", "mc", "t", "con", "cs", "e", "ac"], "src": ["sb", "via", "init", "proc", "bin", "rs", "sur", "sh", "ser", "cur", "fc", "str", "usr", "supp", "rc", "sr", "in", "sq", "obj", "rl", "secure", "iter", "sv", "sl", "comp", "inst", "scan", "st", "s", "iv", "hl", "sn", "input", "sys", "it", "req", "usc", "sc", "stab", "source", "rb", "spec", "bg", "dest", "pkg", "stream", "ptr", "sub", "ctr", "bs", "sort", "img", "lib", "conv", "ins"], "srcStride": ["srcStope", "srcSlride", "rcStrip", "srcEstro", "rcStide", "srcSTride", "srcSTrib", "srcSlrip", "rcStrrobe", "rcStrub", "srcstide", "srcStrope", "rcStride", "srcRestrip", "srcSlro", "srcStrro", "srcSlide", "srcStro", "srcStrr", "rcStrrib", "srcRestide", "srcSTrobe", "srcStrrip", "rcStrrip", "srcSlrib", "srcRestride", "srcSTrip", "srcStrrib", "srcStide", "srcSlrub", "srcEstope", "rcStrr", "srcOptide", "srcRestr", "rcStrro", "srcStr", "srcStrip", "rcStrobe", "rcStrrub", "srcStrrub", "srcstride", "srcEstide", "rcStrib", "srcRestope", "srcStrub", "srcRestrobe", "rcStrride", "srcStrride", "srcRestro", "srcOptride", "srcSlrobe", "srcEstride", "srcOptro", "srcstrip", "rcStro", "rcStrope", "srcStrrobe", "rcStope", "srcstr", "srcStrobe", "srcOptrub", "rcStr", "srcStrib", "srcSTide"], "srcSliceY": ["srcSlidey", "srcPlICEX", "srcSLiceY", "srcSlideW", "srcSLidey", "srcPliceX", "srcSlsliceH", "srcSliceW", "srcSlICEX", "srcSLiceH", "srcSlireY", "srcSlireH", "srcSlideH", "srcSlslicey", "srcSLiceX", "srcSLideH", "srcSlICEH", "srcSlideX", "srcSlireX", "srcSlireW", "srcPliceW", "srcSlideY", "srcSlICEY", "srcPlICEH", "srcSlsliceY", "srcSLicey", "srcSlsliceX", "srcSliceX", "srcPliceH", "srcSlICEy", "srcPliceY", "srcSLideX", "srcPlICEY", "srcSLideY", "srcPlICEW", "srcSlicey", "srcSlICEW"], "srcSliceH": ["srcSlideW", "srcSliceW", "srcSlaceY", "srcSlideH", "srcSlICEHH", "srcSliceHT", "srcSlICEN", "srcSlideHH", "srcSlICEH", "srcSliceHH", "srcPliceW", "srcSlideY", "srcSlICEY", "srcSlICEHT", "srcSlideHT", "srcPliceH", "srcSliceN", "srcPliceY", "srcSlaceHT", "srcSlaceHH", "srcSlaceH", "srcSlideN", "srcPliceN", "srcSlICEW"], "dst": ["dset", "dsset", "dslt", " dST", "ddest", "Dset", "Dlt", "dssts", "rsts", " dlt", "Dst", "DST", " dset", "rST", "Ddest", "dsst", "dlt", "rst", "dsts", "Dsts", "dST", " ddest", "rdest", " dsts"], "dstStride": ["dsrcStrrub", "dstSlride", "dststide", "dsrcStrrat", "dsrcStro", "destStride", "dstSyrat", "dststack", "dststride", "dstSlide", "destStack", "dstStrat", "dstSlro", "dsrcStrip", "dstSyide", "dsrcStide", "destSlride", "destStide", "dsrcStrro", "dstRestrip", "dstDestide", "dstStro", "dstRestack", "dstDestrat", "dstStrro", "dststrip", "dstDestride", "destStro", "dstRestide", "dstSyrub", "dsrcStrrip", "dsrcStrub", "dstSyride", "dstStrrip", "dsrcStride", "destSlide", "dstDestrub", "dstStide", "dstStrrat", "dstStrrub", "dsrcStrride", "dstStrip", "dstRestride", "dstSlack", "destSlack", "dstStrride", "dststro", "dstStack", "destSlro", "dstStrub", "dstRestro", "dsrcStrat"], "y": ["p", "ny", "ot", "x", "py", "h", "ky", "yi", "ies", "uy", "yr", "xy", "i", "vy", "dy", "wy", "z", "yer", " ay", " ye", "oy", "kit", "height", " ty", "j", "sky", "ys", "scroll", "ey", "ty", "ady", "yk", "key", " py", "iy", "hey", "n", " ly", "yd", "yle", "b", "my", "yy", "ch", "icy", "try", "axy", "Y", "ay", "ry", "ya", "yt", "ym", "ly", "iley", "m", "cy", "t", "yl", " j", "sy", "aily", "ye", " busy", "yo", " ya", "gy", "ley"], "h_size": ["H_scope", "H2group", "h_value", "h_start", " h2Size", "H_capacity", "H2size", " h2size", "h_general", "h_SIZE", "h67Size", "h_group", "hi_value", "hi_start", "h2scope", "h_capacity", "h2Size", " h_Size", "h2number", "hbufSize", "hbufsize", "h67size", "h2size", "h67group", "H_group", "H2scope", "H_size", "hi_size", "h2scroll", " h_number", "h67SIZE", "H_general", "hbufnumber", "h_number", "h_scroll", "h67general", "H_Size", "h67capacity", " h2number", "h2group", "h_sum", "h_Size", "H_SIZE", "H2Size", "h2SIZE", "hi_sum", "h_scope", "H_scroll", "h67scope"], "_image": ["_pixel", "jimage", "_img", " _img", "jpng", "__pixel", "jpixel", "_png", "__image", " _png", " _pixel", "jimg", "__img", "__png"], "_py": [" _px", "_po", " _ps", " _po", "_ps", "_px"], "_pu": [" _pt", " _mp", "_pe", "_mp", " _pe", "_pt"], "_pv": ["_prx", "_rw", "_Pj", "_pj", "_pw", "_Pw", "_rv", "_px", "_Pv", "_prj", "_prv", "_rj", "_Px", "_rx", "_prw"]}}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 9122, "substitutes": {"mr": ["r", "MT", "mm", "rer", "pr", "hr", "dr", "km", "rs", "rr", "cm", "hm", "vr", "Mr", "wr", "tm", "mmm", "usr", "lr", "rpm", "nr", "ml", "rm", "sr", "rg", "rl", "older", "wm", "mt", "shr", "mk", "tr", "gm", "arry", "rt", "gr", "rar", "pm", "kr", "adr", "rn", "m", "mc", "br", "mx", "rb", "ocr", "MR", "asm", "mid", "wcs", "ctr", "ms", "bm", "mn", "drm"], "addr": ["r", "ack", "ace", "dr", "off", "np", "conn", "mem", "attr", "coord", " ip", "alloc", "id", " address", "url", "add", "pad", "str", " mac", "start", "map", "env", "ix", "align", "oad", " ptr", " dst", "store", "a", "src", "net", " amp", "work", "act", " tid", "arp", "phys", "tx", "desc", "elt", "ref", " ref", "offset", "iat", "inter", "adr", "wid", "gate", "ip", "et", "pos", "ad", "res", " af", "loc", "alias", "len", "pkg", "alt", "dest", "ord", "ptr", "host", "hw", "address", "aux", "ag", "rel", "cmd"], "size": ["limit", "send", "mem", "eng", "next", "type", "sh", "sp", "z", "serial", "fee", "name", "end", "height", "capacity", "start", "small", "window", "device", "range", "space", "count", "area", "zone", "since", " Size", "g", "si", "Size", "scale", "index", "bytes", "min", "ms", "shape", "empty", "sn", "set", "max", "offset", "last", "ize", "m", "pos", "len", "sum", "sy", "mode", "message", "SIZE", "address", "length", "storage"], "match_data": ["matchxdev", "matchdbData", "matched_bytes", "Match_dat", "Match_type", "Match_data", "match_table", "matchorData", " match_Data", "matchordat", "matchordata", "matchableData", "matchxdata", "matched_data", " matchableData", "Matchabletype", "match_Data", "matchabledata", "matched_table", "match_dat", "matchabledat", " matchabledata", "MatchableData", "matchxbytes", "matchxtable", "matchdbdat", "matchortype", "Match_Data", " matchabledat", "match_bytes", "matchdbdata", " match_dat", "matched_dev", "match_type", "match_dev", "matchabletype", "Matchabledata", "Matchabledat"], "data": ["di", "p", "done", "al", "dev", " d", "timeout", "DATA", "bin", "value", "next", "type", "f", "ata", "length", "format", "name", " DATA", "str", "Data", "image", "map", " Data", "window", "align", "dt", "only", "raw", "device", "n", "buf", "da", "ne", "a", "area", "flags", "d", "bytes", "cache", "dat", "def", "fd", "tx", "bus", "offset", "m", "t", "pos", "buffer", "ad", " dat", "ta", "len", "batch", "table", "any", "block", "mode", "mu", "aw", "address", "w", "zero"], "e": ["r", "p", "x", "h", "ue", "ev", "f", "v", "es", "re", "ei", "l", "eg", "eb", "u", "n", "o", "ne", "a", "er", "b", "d", "g", "s", "eu", "ec", "y", "oe", "m", "c", "t", "et", "E", "ed", "ee", "w", "el"], "i": ["ui", "di", "p", "ami", "cli", "h", "x", "init", "uri", "f", "v", "gi", "ri", "id", "ai", "z", "ic", " ii", "ind", "l", "ei", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "multi", "bi", "n", "me", "o", "in", "iter", "is", "b", "ie", "g", "si", "index", "li", "info", "y", "ini", "q", "fi", "it", "\u0438", "m", "ci", "c", "io", "t", "ip", "mi", "ij", " j", "zi", "qi", "ti", "im", "pi", "us", "ms"], "ioeventfd_nb": ["ioeventf_nb", "ioeventFD_ns", "ioeventfp_nb", "ioeventf_nr", "ioeventf_db", "ioeventfp_cb", "ioeventfd_nn", "ioeventfd_nr", "ioeventfd__nr", "ioeventfd__nb", "ioeventf_nn", "ioeventFD_nr", "ioeventfd__nn", "ioeventf_cb", "ioeventFD_nb", "ioeventfd_db", "ioeventFD_cb", "ioeventfp_db", "ioeventf_nc", "ioeventfd_ns", "ioeventfp_nr", "ioeventfd__db", "ioeventfd_cb", "ioeventfd_nc"]}}
{"project": "FFmpeg", "commit_id": "c3778df2d4c05e76d28d77a2d740e435393046c9", "target": 0, "func": "enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)\n\n{\n\n    if (codec && codec->pix_fmts) {\n\n        const enum AVPixelFormat *p = codec->pix_fmts;\n\n        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;\n\n        enum AVPixelFormat best= AV_PIX_FMT_NONE;\n\n        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,\n\n                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };\n\n            }\n\n        }\n\n        for (; *p != AV_PIX_FMT_NONE; p++) {\n\n            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);\n\n            if (*p == target)\n\n                break;\n\n        }\n\n        if (*p == AV_PIX_FMT_NONE) {\n\n            if (target != AV_PIX_FMT_NONE)\n\n                av_log(NULL, AV_LOG_WARNING,\n\n                       \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\",\n\n                       av_get_pix_fmt_name(target),\n\n                       codec->name,\n\n                       av_get_pix_fmt_name(best));\n\n            return best;\n\n        }\n\n    }\n\n    return target;\n\n}\n", "idx": 9134, "substitutes": {"st": ["step", "sta", "h", "nd", "sw", "se", "std", "sh", "sp", "ast", "ss", "cont", "ste", "stat", "esc", "stru", "ct", "ST", "str", "fr", "irst", "start", "ust", "stop", "sts", "th", "stack", "sv", "src", "St", "ost", "sl", "inst", "mt", "rest", "sam", "ch", "tr", "ut", "spect", "sn", "set", "t", "stage", "sc", "est", "ist", "ocr", "stream", "sth"], "codec": ["pedec", "codEc", " codenc", "odeco", "payeco", " codeco", " codEC", "odEC", "pedEC", "codeec", "payec", "Codocol", "codEC", "Codeco", "Coderer", "oddec", "buckec", "codesc", "cedec", "codeth", "cedEC", "paydec", "preddec", "CodEc", "Codeth", "payEC", "Codec", "CodEC", "cedisc", "buckEC", "predec", "buckdec", " coderer", "odisc", "Codisc", " codeca", "codeEC", "odeca", "codedec", " coddec", "codisc", "predocol", " codEc", "Codesc", "codocol", "Codenc", "predEC", "odesc", "codeerer", "codeenc", "odec", "Coddec", "codeca", "codeeth", "pedeco", " codeth", "codenc", "pedeca", "codeocol", "codeco", "buckEc", "coddec", "cedesc", "coderer"], "target": ["self", "h", "np", "arget", "master", "next", "type", "v", "test", "op", "pb", "output", "format", "primary", "sp", "original", "padding", "result", "ARGET", "gt", "wrong", "stop", "global", "root", "parent", "error", "expected", "debug", "Target", "peg", "null", "total", "pointer", "g", "png", "transform", "mt", "match", "to", "goal", " targ", "local", "set", "max", "standard", "this", "t", "best", "top", "buffer", "alias", "current", "port", "base", "source", "table", "point", "compatible", "dest", "ptr", "native", "arg", "peer"], "p": ["pro", "pod", "pr", "x", "h", "pl", "np", "imp", "wp", "proc", "lp", "f", "i", "pp", "v", "pid", "sp", "pb", "pair", "tp", "bp", "pad", "pt", "ps", "l", "j", "gp", "patch", "u", "xp", "cp", "peer", "P", "conv", "b", "g", "d", "pa", "par", "pers", "y", "q", "fp", "pat", "m", "c", "part", "t", "ip", "port", "point", "ping", "pkg", "ap", "pc", "vp", "php", "w", "jp"]}}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "static void gic_set_irq(void *opaque, int irq, int level)\n\n{\n\n    /* Meaning of the 'irq' parameter:\n\n     *  [0..N-1] : external interrupts\n\n     *  [N..N+31] : PPI (internal) interrupts for CPU 0\n\n     *  [N+32..N+63] : PPI (internal interrupts for CPU 1\n\n     *  ...\n\n     */\n\n    GICState *s = (GICState *)opaque;\n\n    int cm, target;\n\n    if (irq < (s->num_irq - GIC_INTERNAL)) {\n\n        /* The first external input line is internal interrupt 32.  */\n\n        cm = ALL_CPU_MASK;\n\n        irq += GIC_INTERNAL;\n\n        target = GIC_TARGET(irq);\n\n    } else {\n\n        int cpu;\n\n        irq -= (s->num_irq - GIC_INTERNAL);\n\n        cpu = irq / GIC_INTERNAL;\n\n        irq %= GIC_INTERNAL;\n\n        cm = 1 << cpu;\n\n        target = cm;\n\n    }\n\n\n\n    assert(irq >= GIC_NR_SGIS);\n\n\n\n    if (level == GIC_TEST_LEVEL(irq, cm)) {\n\n        return;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        gic_set_irq_11mpcore(s, irq, level, cm, target);\n\n    } else {\n\n        gic_set_irq_generic(s, irq, level, cm, target);\n\n    }\n\n\n\n\n    gic_update(s);\n\n}", "idx": 9150, "substitutes": {"opaque": ["OPos", "OPaques", "boque", "opute", "Opute", "compaques", " opaques", " opque", " opute", "opque", "boaque", "boute", "boula", "OPaque", "compaque", "opaques", "compos", "opos", "opula", "compque", "Opque", " opula", " opos", "Opula", "Opaque", "OPque"], "irq": ["irtquest", "virquery", "driq", "rircharge", "irque", "irtquire", "iraque", "drq", "Irq", "portq", "irtqu", "irqa", "ibrqu", "ironqi", "rirdq", "iraqt", "frq", "IRq", "rirquery", "virqu", "ibrch", "iraqq", "irQ", "iriq", "irrequ", "irqq", "portch", "iraqi", "irqu", "irtqi", "iraity", " irquest", "IRqi", "pirqi", "iroqa", "Irque", "iroq", "frqu", "Irrequ", "pirch", "Irqu", " irqu", "iroqu", "ironcharge", "iraqu", "drquery", "yrq", "drqq", "rirquire", "iriqq", "nirquire", "irquant", "ironqq", "irdq", "virQ", "ibrqq", "irorequ", "irtq", "irqt", "iroque", "portqu", "irtrequ", "irch", "nirqu", "ririq", "virq", " irquery", "ibrq", "yrqq", "rirqq", "virqi", "IRqu", "ircharge", "irquery", "virqt", "ironq", "iraq", "ironquant", "iraqa", "nirQ", "ibrcharge", "yrquant", " irity", "nirq", "yrcharge", "frqi", "nirqi", "frdq", " irqt", "rirqi", " irqq", "irtque", "iriqa", "rirq", "irique", "virity", "portqi", "pirquery", "rirqu", "iradq", "irquire", "pirqu", "pirquest", "iroqq", "ibrquant", "irqi", "viriq", "IRQ", "virqq", "ibrqi", "irtquery", "irity", "pirq", "irquest"], "level": ["limit", "coll", "where", "high", "tc", "levels", "tag", "type", "test", "Level", "VEL", "pe", "density", "l", "cond", "code", "depth", "lc", "cc", "key", "label", " lvl", "time", "file", "scale", "mt", "LE", "ec", "index", "goal", "lvl", "local", "LC", "style", "priority", "module", "m", "counter", "stage", "sc", "status", "point", "mode", "message", "cost", "mid", "vel", "le", "color", "length", "score", "low", "scope", "state"], "s": ["self", "ts", "p", "less", "or", "changes", "a", "h", "sb", "r", "sw", "ses", "rs", "se", "f", "ls", "ains", "qs", "ss", "syn", "als", "es", "its", "z", "l", "ps", "gs", "comm", "sts", "ex", "mos", "n", "sq", "obj", " ss", "store", "us", "sv", "fs", "sl", "g", "is", "b", "as", "d", "details", " self", "os", "y", "bis", "set", "sys", "js", "bes", "hs", "ds", "stats", "m", "S", "c", "t", "bits", "vs", "series", "cs", "ims", "bs", "w", "sports", "ns"], "cm": ["fine", "mm", "dc", "cr", "rom", "conf", "pixel", "km", "um", "tc", "em", "cont", "dm", "cam", "fc", "ct", "cum", "comm", "lc", "broad", "cc", "rem", "rm", "multi", "cv", "cp", "arm", "core", "fm", "wm", "mb", "mt", "form", "ch", "mk", "gm", "com", "term", "cmp", "ca", "pu", "pm", "ctx", "mr", "module", "ym", "mc", "ci", "c", "m", "mp", "mi", "sc", "mx", "cy", "mask", "CM", "im", "asm", "gc", "pc", "cs", "imm", "cut", "ctr", "bm", "mn", "cn", "cmd"], "target": ["limit", "tc", "slot", "arget", "next", "type", "member", "jump", "output", "tp", "location", "height", "ARGET", "mac", "trap", "gt", "window", "root", "dt", "parent", "thread", "Target", "device", "process", "range", "origin", "rel", "label", "total", "obj", "size", "mt", "scan", "path", "goal", "term", "user", "local", "node", "scope", "iat", "offset", "ctx", "trace", "home", "m", "prop", "weight", "t", "top", "sc", "buffer", "port", "mask", "source", "table", "memory", "cut", "ptr", "screen", "arg", "peer", "cmd"], "cpu": ["pixel", "np", " CPU", "CPU", "mem", "proc", "gpu", "tp", "processor", "nc", "mac", "cum", "nice", "cu", "nic", "component", "hw", "thread", "process", "u", "device", "total", "cp", "pool", "core", "phys", "pu", "cmp", "ctx", "c", "num", "mx", "memory", "clock", "gc", "pc", "mu", "ram", "linux", "us"]}}
{"project": "FFmpeg", "commit_id": "366ac22ea5a8bab63c7f46cdad2ddb2ff22cdbed", "target": 1, "func": "static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n                          IVITile *tile, AVCodecContext *avctx)\n{\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n                mv_scale, blks_per_mb;\n    IVIMbInfo   *mb, *ref_mb;\n    int         row_offset = band->mb_size * band->pitch;\n    mb     = tile->mbs;\n    ref_mb = tile->ref_mbs;\n    offs   = tile->ypos * band->pitch + tile->xpos;\n    /* scale factor for motion vectors */\n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n    mv_x = mv_y = 0;\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n        mb_offset = offs;\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n            mb->xpos     = x;\n            mb->ypos     = y;\n            mb->buf_offs = mb_offset;\n            if (get_bits1(&ctx->gb)) {\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n                    return -1;\n                }\n                mb->type = 1; /* empty macroblocks are always INTER */\n                mb->cbp  = 0; /* all blocks are empty */\n                mb->q_delta = 0;\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                           IVI_VLC_BITS, 1);\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                }\n                mb->mv_x = mb->mv_y = 0; /* no motion vector coded */\n                if (band->inherit_mv){\n                    /* motion vector inheritance */\n                    if (mv_scale) {\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                    } else {\n                        mb->mv_x = ref_mb->mv_x;\n                        mb->mv_y = ref_mb->mv_y;\n                    }\n                }\n            } else {\n                if (band->inherit_mv) {\n                    mb->type = ref_mb->type; /* copy mb_type from corresponding reference mb */\n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    mb->type = 0; /* mb_type is always INTRA for intra-frames */\n                } else {\n                    mb->type = get_bits1(&ctx->gb);\n                }\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n                mb->q_delta = 0;\n                if (band->qdelta_present) {\n                    if (band->inherit_qdelta) {\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n                                           (ctx->frame_flags & 8))) {\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                               IVI_VLC_BITS, 1);\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                    }\n                }\n                if (!mb->type) {\n                    mb->mv_x = mb->mv_y = 0; /* there is no motion vector in intra-macroblocks */\n                } else {\n                    if (band->inherit_mv){\n                        /* motion vector inheritance */\n                        if (mv_scale) {\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                        } else {\n                            mb->mv_x = ref_mb->mv_x;\n                            mb->mv_y = ref_mb->mv_y;\n                        }\n                    } else {\n                        /* decode motion vector deltas */\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_y += IVI_TOSIGNED(mv_delta);\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_x += IVI_TOSIGNED(mv_delta);\n                        mb->mv_x = mv_x;\n                        mb->mv_y = mv_y;\n                    }\n                }\n            }\n            mb++;\n            if (ref_mb)\n                ref_mb++;\n            mb_offset += band->mb_size;\n        }\n        offs += row_offset;\n    }\n    align_get_bits(&ctx->gb);\n    return 0;\n}", "idx": 9162, "substitutes": {"ctx": ["dc", "cb", "conf", "conn", "tc", " cx", "cf", "voc", "mem", "cm", "std", "ck", "jp", "cfg", "cam", "tz", "abc", "bc", "ct", "crit", "tk", "jac", "comm", "lc", "cu", "cc", "ctl", "cv", "cp", "obj", "config", "setup", "cas", "act", "handle", "kb", "info", "tx", "cmp", "ca", "sys", "iat", "ia", "ci", "c", "mc", "req", "txt", "kt", "ann", "sc", "anc", "kw", "loc", "resp", "Context", "xc", "pkg", "context", "gc", "wcs", "hw", "conv", "cmd"], "band": ["flag", "bin", "tag", "cm", "broad", "range", "through", "piece", "d", "bor", "byte", "filter", "amber", "db", "batch", "ring", "cmd", "gain", "amp", "pixel", "beam", "link", "pp", "dom", "cell", "cd", "bed", "group", "day", "bar", "bound", " bands", "bus", "bank", "power", "ud", "block", "port", "iband", "product", "word", "and", "mm", "library", "plugin", "bd", "brand", "member", "brid", "pair", "command", "pipe", "b", "mt", "bool", "kb", "node", "style", "bridge", "road", "chain", "mode", "bo", "bind", "frequency", "bf", "feature", "mg", "country", "bands", "bb", "key", "device", "service", "chrom", "form", "tab", "phase", "Band", "bit", "disk", "part", "binary", "raid", "grid", "image", "bm"], "tile": ["fine", "metadata", "unit", "sector", "mate", "site", "league", "tip", "game", "iled", "progress", "piece", "skill", "tiny", "domain", "ite", "player", "te", "bor", "reg", "TI", "byte", "t", "db", "ti", "template", "via", "pixel", "tree", "link", "test", "cell", "sky", "map", "line", " Tile", "vt", "note", "tle", "trace", "target", "ile", "draw", "buffer", "port", "table", "ray", "peer", "brand", "sel", "tool", "slice", "store", "complete", "tif", "tu", "mt", "embed", "node", "inter", "Tile", "chip", "feature", "mat", "texture", "mg", "tar", "query", "shot", "ty", "debug", "device", "feat", "service", "file", "details", "detail", "term", "live", "bit", "offset", "phy", "module", "kt", "binary", "raid", "det", "bat", "entity", "grid", "image"], "avctx": ["avecfg", "avtx", "avdc", " avcfg", "AVcontext", "averctx", "avercontext", "awctx", "avecontext", " avdc", " avcontext", "avertx", "averdc", "awtx", "avcfg", "AVctx", " avtx", "avetx", "AVdc", "avcontext", "avectx", "awcfg", "AVtx", "awcontext"], "x": ["att", "p", "X", "on", "dx", " w", "nex", "xy", "px", " cx", " xx", "i", "zx", "v", "xt", "z", "xe", "xf", "l", "xs", "ox", " ex", "xi", "j", "ix", "ex", "at", "u", "xd", "wx", "xp", "o", "ax", "el", " dx", "inx", "index", " i", "ext", "path", "tx", "fx", "lat", "xxx", "ux", "rx", "m", " tx", "yx", "c", "xa", "text", "mx", "ip", "lon", "xc", "ord", "xml", "w", "xx"], "y": ["p", "ny", "ot", "py", "fy", "yn", "h", "ery", "ies", "xy", "uy", "yr", "i", "v", "dy", "vy", "wy", "yer", "asy", "oy", "kit", "height", "sky", "ys", "ey", "ty", "ady", "key", "hey", "iy", "n", "b", "my", "yy", "ht", "icy", "axy", "yet", "ay", "yt", "ya", "sys", "ym", "ry", "m", "yx", "cy", "t", "yout", "yl", "ip", "sy", "aily", "ye", "e", "yo", "gy", "by", "ley"], "mv_x": ["muv_xs", "mv2width", "mv2x", "mv2y", "mv_rx", "mv__px", "mv2xs", "mvc2x", "mvc2xs", "mov_xi", "mva2y", "mv____start", "muv_dx", "mov_x", "mvc_width", "mv__dx", "mvc2start", "mvc_start", "mv__x", "mva_x", "mv__ex", "mov_rx", "mva_y", "mv2rx", "mv____x", "mv____width", "mv_dx", "mov_ex", "mv_width", "mv_xs", "mva2x", "mva2rx", "mvc_x", "mov_px", "mv__rx", "muv_ex", "muv_x", "mv__y", "mv_start", "mvc2width", "mvc_xs", "mv_xi", "mv____xs", "mv_px", "mv_ex", "mv2start", "mv__xs", "mva_rx"], "mv_y": ["mv__b", "mvt_h", "mov_x", "mv2v", "mv_yt", "mvJd", "mva_ye", "mv_h", "mv_i", "mv2y", "mvt_y", "mov_b", "mvt_d", "mvJv", "mv__x", "mv__i", "mv__y", "mv__ey", "mv_ye", "mov_yt", "mv2h", "mv_v", "mvt_v", "mv_d", "mv_ey", "mva_ey", "mv_b", "mv2d", "mvJh", "mov_y", "mvJy", "mva_i", "mva_y", "mv__ye", "mv__yt"], "mv_delta": ["mv_delt", "mv_dDelta", "mv_Delt", "mv_Dota", "mv_Delta", "mv_lota", "mv_DDelta", "mv_lelt", "mv_dota", "mv_lelta", "mv_lDelta"], "offs": ["ones", "ts", "vals", "sets", "ats", "off", "aps", "xy", "outs", "points", "ows", "obs", "ps", "xs", "gs", "amps", "ops", "oa", "origin", "inters", "blocks", "posts", "bs", "eps", "ins", "os", "s", "times", "ks", "offset", "keys", "ds", "cells", "limits", "tops", "bits", "pos", "cs", " offsets", "ims", "ms", "ns"], "mb_offset": ["kb_position", "mbsorigin", "mb64offset", "mbsoffset", "mb__origin", "mb_timeout", "emb_offset", "mb_index", "mb_translation", "mb64shift", "mb__position", "mb_position", "mb___translation", "kbsorigin", "kbsposition", "mbsposition", "mb___timeout", "mb64translation", "mb_shift", "emb_Offset", "mb___offset", "mb_origin", "mb___shift", "mbsindex", "mb64timeout", "bb_translation", "mb_info", "mb_Offset", "bb_offset", "mb__offset", "emb_info", "kb_offset", "bb_shift", "kbsoffset", "bb_timeout", "kb_origin", "kbsindex", "kb_index", "mb__index"], "mv_scale": ["mv_cale", "mvarpysize", "mv_info", "mv_transform", "mav_transform", "mv_size", "mvar_size", "mvar_status", "mv_base", "mov_size", "mv2cale", "mov_scale", "mvp_size", "mvarpydevice", "mv2size", "mvar_device", "mvarpyscale", "mv2scale", "mvp_cale", "mvarpystatus", "mvp_scale", "mv_rate", "mvp_save", "mvpyscale", "mav_info", "mov_base", "mv_save", "mov_rate", "mvpysize", "mvpydevice", "mav_size", "mv_device", "mv_status", "mvpystatus", "mvar_scale", "mv2save", "mav_scale"], "blks_per_mb": ["blks_per_byte", "blks_per_MB", "blks_PER_mm", "blks_PER_byte", "blks_per_mm", "blks_PER_MB", "blks_PER_mb"], "mb": ["mm", "GB", "nob", "bf", "sb", "amp", "nom", "ab", "erm", "orb", "mem", "bd", "irm", "um", "brain", "job", "em", "mg", "ebin", "mor", "pb", "norm", "emb", "ob", "bp", "mar", "abc", "gov", "meta", "bb", "arb", "vm", "ub", "eb", "bl", "rm", "management", "ib", "amb", "boost", "sm", "bar", "nm", "xb", "bound", "md", "fm", "orm", "mt", "obb", "hub", "kb", "bor", "gb", "ym", "umb", "m", "mp", "byte", "iam", "manager", "mx", "fam", "db", "mob", "mop", "lb", "ms", "MB", "bm", "mn"], "ref_mb": [" ref2MB", "ref2mem", " ref_mor", "ref_emb", "ref___mb", "ref___MB", "Ref_band", "ref2MB", " ref2mb", "ref___mor", "ref_MB", " ref_emb", "ref_band", "Ref_MB", "Ref_mi", "ref_mor", "ref___emb", "ref2mb", " ref_MB", "ref2mor", " ref2mor", "ref_mi", " ref2mem", " ref_mem", "Ref_mb", "ref_mem"]}}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 9172, "substitutes": {"vty_lookup": ["vty_cleanUp", "vty_listups", "vty_listUp", "vty_Lookup", "vty_cleanup", "vty_lookups", "vty_lookify", "vty_cleanify", "vty_listup", "vty_lookUp", "vty_cleanups", "vty_listify", "vty_LookUp", "vty_Lookify", "vty_Lookups"], "sPAPRMachineState": ["sPAPROMasterStates", "sPAPRMasterInfo", "sPAPRMotionState", "sPAPROMachineSTATE", "sPAPRMotorSTATE", "sPAPRMachineSTATE", "sPAPROMasterState", "sPAPRMachineInfo", "sPAPROMachineInfo", "sPAPRMotionStates", "sPAPROMachineState", "sPAPRMachineStates", "sPAPRMotionInfo", "sPAPRMotorState", "sPAPRMasterSTATE", "sPAPROMasterInfo", "sPAPRMasterStates", "sPAPRMotionSTATE", "sPAPRMotorStates", "sPAPRMotorInfo", "sPAPROMasterSTATE", "sPAPRMasterState", "sPAPROMachineStates"], "spapr": [" spapor", "spaptz", " spcaprs", "spaxr", "spapsar", "spapprs", "spapsir", " spcapor", "aspamper", "aspampir", "sparprar", "spampz", "spapz", "sparpr", "spappor", "aspaper", "spipR", "spcappr", "spapir", "spaptr", "spampr", "spcapr", " spipr", "spaxpr", "spipr", "spapR", "spiprar", "aspapir", "spappr", "spapter", " spipar", " spapR", "spaprar", "spapser", " spcappr", "spapppr", " spappr", "sparpar", "spipar", " spaprar", "spaptir", "spaper", "aspapr", "spapsrar", "spcaprs", "sparpR", " spcapr", "spaxrs", "spapsz", "spaprs", " spapar", "spaxor", "spapsR", "spampir", "spapar", " spaprs", "spamper", "aspampr", " spipR", "spcapor", "aspapz", "spapor", "spapsr", "aspampz", " spiprar"], "target_ulong": ["target_ULong", "target_longng", "target_ULng", "target_uong", "target_ung", "target_ulng", "target_ullong", "target_longong", "target_longue", "target_ULue", "target_uue", "target_longlong", "target_ulue", "target_ULlong"], "reg": ["r", "red", "mem", "eng", "tag", "region", " registry", "ret", " REG", "addr", "rr", "re", "cell", "rec", "rep", "map", "code", "eg", "org", "rem", "key", " addr", "config", "ru", "g", "sec", "rest", "Reg", " region", "urg", "ro", "arr", "ref", " rg", "br", "req", "res", "REG", "registered", "any", "gc", "grid", " mem", "mod"], "sdev": ["svar", " sDev", "simpledevice", "sdem", "gesDev", "tsDev", "Sdev", "vdev", "tsdev", "gesdiv", "tsvar", "Sdem", "sDev", " sdevice", " sdem", "sesdev", "sdiv", " sdiv", "lsvar", "lsdev", "SDev", "vDev", "gesdev", "vdiv", "sesdevice", "simplevar", "simpledev", "sesDev", " svar", "Sdevice", "vvar", "lsDev", "simpleDev", "Svar", "lsdevice", "sdevice", "tsdevice", "sesdem", "gesvar"]}}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n", "idx": 9174, "substitutes": {"job": ["no", "flag", "tag", "json", "failed", "obs", "lock", "program", "worker", "cp", "remote", "hub", "cache", "to", "task", "manager", "batch", "db", "row", "item", "jp", "cmd", "session", "comment", "mem", "build", "jj", "link", "test", "op", "ob", "function", "cell", "name", "meta", "group", "layer", "good", "org", "bug", "cor", "line", "config", "resource", "info", "package", "Job", "trace", "req", "block", "word", "sub", "low", "msg", "plugin", "member", "pause", "entry", "gov", "command", "image", "sim", "position", "process", "out", "store", "server", "b", "trial", "try", "user", "node", "project", "error", "pro", "jam", "request", "jump", "connection", "version", "j", "policy", "event", "work", "jo", "tab", "com", "module", "message", "client", "some"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}", "idx": 9176, "substitutes": {"bs": ["ts", "bf", "sb", "blog", "rs", "aos", "uts", "bos", "ls", "BS", "ss", "its", "bp", "bc", "obs", "ps", "cks", "gs", "bb", "ubs", "iss", "bl", "fs", "bh", "b", "lbs", "bles", "bytes", "bsp", "ms", "bas", "ks", "bis", "css", "js", "bes", "hs", "ds", "ubis", "bits", "bps", "aus", "vs", "cs", "gc", "hz", "bm", "qs", "ns"], "offset": ["bf", "off", "slot", "coord", "addr", "offer", "sp", "oid", "location", "pad", "command", "ano", "esi", "start", "position", "scroll", "at", "range", "origin", "o", "buf", "count", "size", "seek", "bound", "area", "pointer", "index", "offs", "article", "set", "Offset", "oss", "pos", "buffer", "et", "base", "loc", "unk", " offsets", "address", "zero"], "buf1": [" buf0", "buffer2", " buf3", "bag3", "buffer3", "buf0", "uf0", "buf2", " bufOne", "bag1", " bufA", "bagA", "bagOne", "buff1", "bag0", "buffer1", "buf3", "buffOne", "buff2", "uf2", "bufOne", "buff0", "uf1", "uf3", "bufA", "buff3", "buffer0", "ufA"], "count1": ["comment1", "counter1", "cache9", "ount2", "countone", "Count1", "count7", "comment2", "ount0", "countPar", "counterPar", "ountPar", "count0", " count2", "count9", " countone", "ount1", "ount7", "Count2", "commentone", " count9", " count7", "comment9", "Count0", " count0", "cacheone", "count2", "counter2", "cache2", "Count7", " countPar", "cache1"], "drv": ["grr", "rrj", "DRp", " drvr", "drj", "rrvd", "drp", "Drav", "drve", " drvd", "rdf", "rdj", "rrr", "drr", "crf", "crV", "drav", "DRw", " drw", "trvd", " drve", "drw", "drvd", "rdvd", "trf", "DRav", "trve", " drf", "crvd", "rdr", " drp", "Drvr", "Drp", "parf", "DRh", "parv", "parvd", "drV", "grvd", "DRv", "crv", "drvr", " drav", "trv", "grj", "Drv", "rdv", "Drh", "parve", "DRvr", " drV", "Drw", "drh", "drf", " drh", "rrv", "rdV", "grv"]}}
{"project": "FFmpeg", "commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "target": 1, "func": "int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n\n                             int max_size)\n\n{\n\n    uint32_t mrk;\n\n    int i, tmp;\n\n    const uint16_t *ssrc = (const uint16_t *) src;\n\n    uint16_t *sdst = (uint16_t *) dst;\n\n    PutBitContext pb;\n\n\n\n    if ((unsigned) src_size > (unsigned) max_size)\n\n        src_size = max_size;\n\n\n\n    mrk = AV_RB32(src);\n\n    switch (mrk) {\n\n    case DCA_SYNCWORD_CORE_BE:\n\n        memcpy(dst, src, src_size);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_LE:\n\n        for (i = 0; i < (src_size + 1) >> 1; i++)\n\n            *sdst++ = av_bswap16(*ssrc++);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_14B_BE:\n\n    case DCA_SYNCWORD_CORE_14B_LE:\n\n        init_put_bits(&pb, dst, max_size);\n\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n\n            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n\n            put_bits(&pb, 14, tmp);\n\n        }\n\n        flush_put_bits(&pb);\n\n        return (put_bits_count(&pb) + 7) >> 3;\n\n    default:\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n}\n", "idx": 9178, "substitutes": {"src": ["r", "sync", "pl", "sb", "proc", "bin", "rs", "sur", "cont", "sel", "ser", "addr", "cur", "sup", "syn", "pri", "ind", "str", "usr", "start", "tn", "rob", "raw", "supp", "th", "rc", "sr", "sq", "nt", "rl", "comp", "sl", "ost", "obj", "inst", "scan", "sec", "st", "s", "ur", "impl", "rol", "iv", "hl", "sn", "input", "rt", "sys", "rx", "txt", "usc", "sc", "source", "rb", "loc", "inner", "dest", "ipl", "RC", "ctr", "sub", "ptr", "img", "ins"], "src_size": ["rc_size", " src2size", "src09ize", "src0name", " src_send", "src_name", "source_length", "src09to", " src_start", "ptr_loc", "src_width", "ctr_ize", "src_shift", "source_name", "src2status", "ctr09to", "src_loss", "src2scale", " src2scale", "ptr_width", " src2send", "src_scale", "ptr_pos", "src10scale", "src10size", "src2size", "source_size", "src0send", "src2length", "src10length", "source2status", "src_start", "ctr09ize", "src8ize", "source2length", "ptr_size", "rc_shift", "src_ize", "ctr09size", "src_send", "source_status", "src09size", "src2name", "source2size", "src2send", "src_pos", "source_to", "ctr_size", " src_name", "ptr_loss", "src_to", "src_loc", "src_status", "src0size", " src_scale", "ptr_ize", "src_len", "ctr_to", "src8size", " src_len", "src8to", "src_length", "src10status", "source_scale", " src2name", "rc_length", "src0scale", "source2scale"], "dst": [" dv", "dist", "dsbr", "sdsts", "ddest", "sddest", " dest", "Dest", " dist", "dsrest", "dsrc", "dssrc", " dsrc", "dspt", "jest", "sdnt", "Dbr", "sdbr", "Dst", "dsist", "sdist", "sdrest", "sdest", " dnt", "dpt", "jdest", "dsst", "pdv", " drest", "dsv", "dsts", "drest", " dbr", "pdpt", "jst", " dpt", "dnt", "sdsrc", "pdst", "pdbr", "jnt", "Dsts", "dbr", " ddest", "dest", " dsts", "dv"], "max_size": ["maxCapSize", "maxLengthsize", "MAX_size", "MAX_Size", "maxmaxrange", "maxingsample", "max2SIZE", "maxLengthgo", "max_go", "max_send", "restCapsize", "maxCapsize", "rest_size", "max_length", "restCapdepth", "max2length", " max_Size", "max_SIZE", "max_range", "maxCapsample", "rest_depth", "max2size", "max_Size", " max_range", "MAX_send", "maxingSize", "maxmaxsize", "max2Size", "maxLengthSize", "maxmaxgo", "maxmaxSize", "rest_sample", "rest_Size", "max_sample", "maxingsize", "maxingdepth", "max_depth", "maxCapdepth", "restCapsample", "restCapSize", "maxLengthrange", " max_go", " max_SIZE", " max_length", "MAX_SIZE"], "mrk": ["MRkid", "rk", " yrkm", "trkid", "vrkk", " yrijk", "rke", "mnkid", "mnke", "krkk", "sprkid", "trke", " hrkm", "krkid", "mrK", "rijk", " yrk", "trk", "mnck", "Mrck", "MRkt", " hrk", "vrkid", "Mrkt", "vrK", "mnkt", "krK", "sprk", "Mrke", " yrke", "krk", "sprkk", "mrkm", "rkm", "MRck", "mrijk", "mrck", "mrkk", "sprK", "mrkid", " hrijk", " hrke", "mrkt", "MRke", "mrke", "Mrk", "vrk", "mnk", "MRk", "trck"], "i": ["ui", "di", "cli", "x", "ir", "dr", "ims", "err", "v", "f", "gi", "ic", "ai", " ii", "ind", "l", "ei", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", "oi", "multi", "bi", " I", "in", "PI", "ni", "is", "b", "g", "hi", "si", "index", "print", "uli", "li", "info", "y", "ini", "q", "fi", "it", " ni", "m", "ci", "io", "\u0438", "t", "ip", "mi", "zi", " j", "ij", "chain", "ti", "qi", "im", "pi", "e", "ki", "me"], "tmp": ["appy", "p", "mm", "cb", "snap", "nd", "np", "proc", "tc", "acc", "attr", "pp", "v", "cont", "test", "nb", "sp", "perm", "tm", "tk", "tt", "wx", "cv", "nt", "obj", "temp", "img", "buf", "buff", "emp", "mut", "vt", "td", " mp", "mb", "cache", "mk", "cmp", "tf", "uv", "prop", "mp", "txt", "MP", "rb", "resp", "vp", "ptr", "orig", "msg", "uff"], "ssrc": [" sssrc", "ssync", "sesync", " ssync", "cssrc", "rsssrc", "cssRC", "sssrc", "rssync", "sesub", "SSrc", "sessrc", "srt", "rssrc", "sRC", "sr", "SSr", "SSRC", "cssr", "ssr", "sesrc", "ssRC", "ssub", "SSrt", "ssrt", "cssrt", " ssub", "rssub"], "sdst": ["dsp", "SDsc", "rdST", "sdsp", "rdsc", "adsp", "dsest", "sdest", "sdost", "dsst", "adst", "SDST", "dssp", "adest", "rdst", "dsost", "SDest", "dST", "sdST", "dsc", "sdsc", "dost", "dest", "adost", "SDst", "rdest"], "pb": ["p", "pas", "cb", "pl", "sb", "amp", "np", "wp", "proc", "lp", " outp", "px", "pp", "nb", "sp", "tp", "dp", "pg", "bp", "pad", "pt", "bj", "ps", "uf", " np", "tap", "cv", "cp", "PB", "xb", "pd", "vt", "pa", "mt", "gb", "fp", "pm", " xp", "wb", "mp", "orp", "rb", "resp", "ap", "pkg", "gc", "pc", "vp", "lb", "jp"]}}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189, "substitutes": {"xhci": ["Xheci", "xhlmi", "xhwci", "xhlcu", " xhcs", "xhsmi", " xhmi", "xhtci", "xbhiti", "xwcm", "Xhcci", "xhiti", "fxhuci", "wxhtpi", "xhco", "xbhci", "wxhci", "xhtco", "xheni", "xwcu", "fxhlci", "Xhecu", "wxhtcli", "xhmi", "xhlpi", "xhcs", "Xhcu", "xhni", "xwcci", "xhdci", "xhlci", "xhemi", "xhtni", "xheiti", "wxhpi", " xhiti", "xhecci", "xhecli", "xahci", "xhuci", "xahiti", "xhecs", "xhdcu", "xheci", " xhlpi", " xheiti", "xhlco", "xhecm", " xhuci", "xhecu", "xhtcu", "xahuci", "xahpi", "xhdcm", " xhepi", "xhspi", "xhwcli", " xhlmi", "Xhecm", "xhlcs", "xbhpi", " xheuci", "wxhcli", " xheci", " xhlcs", "xhcci", "wxhni", "wxhtni", "xhcu", "xhscs", "xhsci", "Xhecci", "Xhci", "xhluci", "xhcli", "fxhcu", "xhpi", "xhdcci", "fxhci", "fxhluci", "xheco", "fxhlco", "wxhtci", "xhtuci", "fxhco", "Xhcm", "xhwni", " xhlci", "xhepi", "xhcm", "xhtpi", "fxhlcu", " xhpi", "xwci", "xhwpi", "xbhuci", "xheuci", "xhtcli"], "slotid": ["spotID", "shotlen", "lotid", "lotno", "sloth", "spotmd", "lotId", "lotd", " sloth", "spotId", "snapno", "snapId", "snapname", "slotd", "slotID", "shotno", "lotmd", "spoth", "slotoid", " slotId", "snapid", "loth", " slotname", "spotname", "spotno", "shotname", "shotid", "shotmd", " slotno", " slotd", "spotid", "slotId", "shotId", " slotID", "spotlen", "lotlen", "slotmd", "slotno", "slotlen", " slotoid", "spotd", "spotoid", "shotoid", "lotoid", "lotname", "lotID", "slotname"], "epid": ["EPID", "ipID", "Epid", "expmid", "eppid", "eknum", "mpno", "egend", "egid", "epkid", "esphide", "Epnum", "pehide", "epcode", "mpID", "ekend", "EPId", "eghide", "lipid", " epkey", "espend", "egcode", "epty", "eqtry", "ekty", "estID", "EPid", "espid", "estension", "eqid", " epno", "eqide", "lipcode", "espkind", "ekid", "ekhide", "epno", "ecid", "epend", "ekcode", "expkid", "peide", "epkey", " epnum", "egty", "epID", "epkind", " epend", " eppid", " epId", "ippid", "escide", "epId", "ipend", "escid", "esctry", "ekension", "espID", " epID", "eeension", "eeid", "mpId", "ekkid", "ecend", "eeide", "ectry", "epension", "epnum", "epmid", "ephide", "ekkey", "eptry", "ecID", "ipid", "escID", "esthide", "ekID", "ekkind", "liphide", "egpid", "eehide", "lipty", "peid", "espension", "epide", "mpid", "Epkey", "egID", "estid", "peension", "ecide", "expid", "EpID", " epmid", " epkid", "eqID", "eckind", "ekmid", "EPno", "estide", "expID"], "slot": ["pod", "p", "usage", "session", "spot", "snap", "timeout", "plugin", "unit", "sector", "job", "vol", "ser", "sp", "site", "role", "entry", "pot", "pt", "ct", "boot", "shot", "hit", "scroll", "share", "slice", "space", "piece", "label", "nt", "null", "pool", "zone", "loop", "sl", "soc", "zo", "service", "pointer", "storage", "tab", "binding", "bit", "section", "second", "set", "sid", "module", "part", "pos", "Slot", "batch", "point", "table", "port", "option", "profile", "lot", "zero", "scope", "room"], "epctx": ["lipcfg", "EPcmd", "apectx", "lipcmp", "Eptx", "apetx", "epcontext", "esptx", "epscmp", "epfunc", "liptx", "apcmd", "apctx", "EPtx", "Epctx", "ethtx", "ethctx", "evtx", "epscontext", "eqctx", "ekcmp", "Epcfg", "eqcontext", "espkw", "apefunc", "espcmp", "apecmp", "ektx", "apcontext", "epcmd", "epscmd", "epcmp", "eqtx", "evkw", "eptx", "epsctx", "EPcontext", "ekctx", " epcmp", "eqcmd", "apcmp", "espcontext", "espfunc", "Epcmp", "epstx", "EPctx", "evctx", "epkw", "epsfunc", "epscfg", " eptx", "epskw", " epcfg", "lipctx", "ekcfg", "ekcmd", "evcontext", "ethcmd", "ethcontext", "eqcmp", "epcfg", "espctx"], "i": ["di", "p", " pi", " ti", "v", "ai", " ii", "ei", "ii", "j", "I", "phi", "bi", " I", "si", " v", "li", " bi", "fi", "ci", "m", "io", "ip", "mi", " j", "ti", "pi", "ki"]}}
{"project": "qemu", "commit_id": "bc3e6a0d6c8ab6cd7cd4b576ed567756f1dcabd2", "target": 1, "func": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n", "idx": 9193, "substitutes": {"bus": ["ack", "controller", "uses", "cus", "cat", "jack", "bc", "usb", "boot", "lock", "bug", "piece", "buf", "bar", "card", " BUS", "US", "back", " board", "board", "mount", "driver", "bridge", "bank", "box", "hand", "Bus", "chain", "book", "block", "port", "BUS", "way", "us", "bs", "bur"]}}
{"project": "qemu", "commit_id": "679aa175e84f5f80b32b307fce5a6b92729e0e61", "target": 0, "func": "static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            /* Interrupt Controller Type Register */\n\n            return ((s->num_irq / 32) - 1)\n\n                    | ((NUM_CPU(s) - 1) << 5)\n\n                    | (s->security_extn << 10);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            /* Interrupt Group Registers: these RAZ/WI if this is an NS\n\n             * access to a GIC with the security extensions, or if the GIC\n\n             * doesn't have groups at all.\n\n             */\n\n            res = 0;\n\n            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {\n\n                /* Every byte offset holds 8 group status bits */\n\n                irq = (offset - 0x080) * 8 + GIC_BASE_IRQ;\n\n                if (irq >= s->num_irq) {\n\n                    goto bad_reg;\n\n                }\n\n                for (i = 0; i < 8; i++) {\n\n                    if (GIC_TEST_GROUP(irq + i, cm)) {\n\n                        res |= (1 << i);\n\n                    }\n\n                }\n\n            }\n\n            return res;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Set/Clear Enable.  */\n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Set/Clear Pending.  */\n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (gic_test_pending(s, irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target.  */\n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            /* For uniprocessor GICs these RAZ/WI */\n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_EDGE_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xf10) {\n\n        goto bad_reg;\n\n    } else if (offset < 0xf30) {\n\n        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n            goto bad_reg;\n\n        }\n\n\n\n        if (offset < 0xf20) {\n\n            /* GICD_CPENDSGIRn */\n\n            irq = (offset - 0xf10);\n\n        } else {\n\n            irq = (offset - 0xf20);\n\n            /* GICD_SPENDSGIRn */\n\n        }\n\n\n\n        res = s->sgi_pending[irq][cpu];\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    qemu_log_mask(LOG_GUEST_ERROR,\n\n                  \"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9210, "substitutes": {"opaque": ["OPatile", "opatile", "obressed", "obaque", "opce", "OPce", " opacity", "iopatile", "oplressed", " opque", "iopaque", " opatile", "opque", "obacity", " opce", "OPaque", "opressed", "iopce", "iopque", "oplacity", "obatile", "oplaque", "opacity", "OPque", "oplatile", " opressed"], "offset": ["usage", "flag", "err", "url", "data", "shift", "dt", "range", "notation", "index", "adjusted", "empty", "ref", "now", "tile", "filter", "batch", "loc", "row", "ptr", "item", "layout", "h", "addr", "offer", "output", "tz", "esi", "meta", "after", "seek", "bound", "handle", "attribute", "set", "button", "Offset", "kernel", "et", "buffer", "ta", "table", "always", "operation", "p", "off", "slot", "OFF", "amount", "id", "location", "entry", "pad", "padding", "command", "start", "window", "position", "scroll", "o", "pointer", "prefix", "mt", "offs", "style", "fp", "error", "frequency", "timeout", "atomic", "next", "original", "topic", "key", "origin", "pool", "zone", "article", "term", "queue", "reset", "module", "pos", "base", "point", "option", "message", "alt", "image", "address"], "attrs": ["attsrs", "attsRS", " attRS", "attr", "Attrd", "matributes", "attRS", "attsrd", "matrs", "attsributes", "Attributes", "Attls", "Attr", "attls", "matr", " attr", "Attrs", " attls", "attrd", "matls", " attributes", "AttRS", "attributes", " attrd"], "s": ["changes", "x", "sb", "sets", "ses", "ls", "xs", "aws", "comm", "sm", "sv", "sam", "bis", "js", "sys", "c", "t", "source", "state", "ms", "se", "ins", "ns", "less", "h", "ats", "sw", "settings", "ps", "sq", "obj", "fs", "a", "sl", "serv", "set", "stats", "ds", "ssl", "status", "vs", "cs", "ims", "p", "sa", "its", "l", "sports", "store", "g", "is", "b", "os", "hs", "spec", "r", "ts", "self", "rs", "v", "ss", "es", "z", "als", "gs", "sts", "n", "details", "states", "m", "S", "bits", "bs", "qs"], "res": ["r", "pas", "resolution", "cons", "response", "vals", "conf", "pres", " results", "red", "sol", "rs", "rev", "ret", "re", "__", "ps", "result", "resources", "fr", "cond", "rep", "rez", "val", "rem", "rss", "out", "RES", "resh", " ret", "ress", "conv", "expr", "details", "rest", "bs", "Res", "ms", "arr", "hash", "ref", "js", "reset", "reg", "gr", " Res", "req", "vec", "bits", "ires", "resp", "results", "msg", "rel", "ins"], "irq": ["ircu", "ieraq", "irque", "rircharge", "rirqs", "arqi", " irque", "arqu", "ironke", "ironcu", "pirqual", "irtqu", "iriquery", "ibrqu", "ibrqueue", "irqa", " irforce", "virke", "rirquery", "iraqq", "pirquer", "irtcache", "iriq", "rirresh", "rirf", "iterq", "ardq", "yrqu", "mirq", "iracache", "irqq", "pirqq", "ironiq", "rircache", "irqu", "irf", " irdq", "irtqi", "arq", "rrg", "pirqa", "pirqi", "iroq", "yrqueue", "arque", "mrqi", "mrq", "pirch", "ierqueue", "rirqueue", " irqu", "iroqu", "pirresh", "irqueue", "rrq", "rirch", "irqs", "yrq", "mirqi", "mrqu", "pirqueue", "iorquery", "irke", "pirquire", "rrqu", "iraf", "virtq", "iterqu", "irtqueue", "ierqa", "ierforce", "irdq", "ircache", "irtg", "iorq", "irtq", "pirf", "irch", "irtqq", "ironch", "virq", " irquery", "ibrq", "iorqs", "irg", "rrque", "rirqq", "iorquest", "pirg", "ircharge", "irquery", "irtcharge", "ironq", "iraq", "rirqa", "ironqu", "mirqu", "arch", "irforce", "rirquest", "iriquire", "mrch", "ierq", "rirqi", " irch", "irtque", "rirq", "iriforce", "iracharge", "pirque", "virtke", "irich", "yrqi", "pirquery", "iterdq", "vircu", "iterque", "rirqu", " iraq", "ierquire", "iroqi", "mirqueue", "virtcu", "irquire", "pirqu", "pirquest", "ironresh", "irresh", "ierquer", "pirqs", "irqi", "viriq", " irquire", "irqual", "ibrqi", "irquer", "iraqual", "iroqueue", "pirq", "rirquer", "iriaq", "irquest", "rirqual", "virtiq"], "i": ["ui", "r", "p", "di", "ami", "cli", "x", "init", "ims", "yi", "uri", "docker", "v", "gi", "id", "ai", "ic", "ind", "l", "ei", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "ico", "oi", "ex", "u", "multi", "bi", "in", "ni", "o", "my", "si", "index", "ms", "li", "y", "ini", "q", "MI", "fi", "it", "\u0438", "ci", "m", "c", "io", "qi", "ip", "mi", "zi", "this", "ti", "im", "pi", "php", "ki", "me", "ori", "ter", "us"], "cpu": ["util", "p", " CPU", "proc", "CPU", "mem", "gpu", "tp", "processor", "l", "ct", "cum", "nice", "cu", "nic", "process", "u", "device", "ilo", "n", "total", "cp", "count", "core", "pu", "ctx", "m", "c", "ile", "num", "buffer", "mx", "current", "nu", "base", "memory", "clock", "cs", "pc", "mu", "ram", "gc", "cn", "us"], "cm": ["fine", "mm", "cr", "co", "rom", "conf", "km", "mem", "tc", "mult", "perm", "cam", "fr", "comm", "lc", "rem", "cp", "nm", "cms", "chrom", "fm", "cache", "ch", "gm", "com", "cmp", "ca", "mr", "ctx", "pm", "module", "mic", "mc", "m", "c", "mi", "mx", "batch", "CM", "memory", "mode", "asm", "cs", "pc", "ram", "gc", "ms", "cut", "bm", "mn", "ctr", "cmd"], "mask": ["ack", "conf", "aps", "final", "clear", "ps", "map", "lock", " bits", "share", "key", "RES", "resh", "flags", "ress", "fs", "cache", "bit", "hash", "reset", "weight", "bits", "sk", "locks", "ms", "zero", "ask"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                      target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret;\n\n    target_ulong sr, pgidx;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n\n\n    sr = env->sr[eaddr >> 28];\n\n    ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n    ds = sr & 0x80000000 ? 1 : 0;\n\n    ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n    vsid = sr & 0x00FFFFFF;\n\n    target_page_bits = TARGET_PAGE_BITS;\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx\n\n            \" nip=\" TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n            \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n    hash = vsid ^ pgidx;\n\n    ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            qemu_log_mask(CPU_LOG_MMU, \"htab_base \" TARGET_FMT_plx\n\n                    \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            /* Software TLB search */\n\n            ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_loglevel_mask(CPU_LOG_MMU)) {\n\n                CPUState *cs = ENV_GET_CPU(env);\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", env->htab_base, env->htab_mask + 0x80);\n\n                for (curaddr = env->htab_base;\n\n                     curaddr < (env->htab_base + env->htab_mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(cs->as, curaddr);\n\n                    a1 = ldl_phys(cs->as, curaddr + 4);\n\n                    a2 = ldl_phys(cs->as, curaddr + 8);\n\n                    a3 = ldl_phys(cs->as, curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            qemu_log_mask(CPU_LOG_MMU, \"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        qemu_log_mask(CPU_LOG_MMU, \"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log_mask(CPU_LOG_MMU, \"ERROR: instruction should not need \"\n\n                          \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 9215, "substitutes": {"env": ["dev", "inv", "init", "conf", "np", "conn", "proc", "eng", "ev", "v", "esc", "eni", "environment", "network", "end", "ef", "ei", "neck", "era", "en", "map", "window", "ez", "vm", "worker", "org", "exc", "config", "obj", "setup", "ew", "cv", "vt", "enc", "net", "esp", "te", "ner", "ec", "kh", "ah", "ext", "param", "tx", "desc", "node", "equ", "open", "disk", "manager", "here", "uv", "et", "Environment", "eh", "db", "den", "nv", "context", "e", "doc", "erd", "hw", "cmd"], "ctx": ["p", "func", "dc", "cb", "x", "co", "init", "conf", "np", "conn", "tc", " cx", "cf", "proc", "coord", "cm", "alloc", "ck", "tz", "fc", "bc", "nc", "ct", "crit", "tk", "j", "jac", "ka", "cu", "worker", "cc", "qt", "wx", "cv", "obj", "cp", "cas", "tmp", "buf", "ctl", "event", "conv", "fw", "index", "cache", "kh", "act", "mk", "tx", "cmp", " context", "ca", "rt", "req", "c", "ctrl", "this", "check", "kt", "txt", "kw", "loc", "resp", "Context", "xc", "pkg", "context", "gc", "aux", "k", "msg", "jp", "cmd"], "eaddr": ["awdr", "ezdriver", "ezder", "oadder", "inalr", "expressstr", "adstr", "ezdr", "addr", "awder", " dwDR", "awr", "ewDR", "eadder", "expressdr", "inaldr", "expressder", "eddDR", "ellder", "ewstr", "edddriver", " dwdr", "oaddr", "oadDR", " xDR", " dwder", " dwptr", "ekder", "ekDr", " xdr", "oadDr", "eddstr", "eadptr", "ekhr", "edddr", "oadstr", "ewptr", "ewder", "elldr", "ewdr", "ekdr", "ezstr", "eadhr", "eddder", "adr", "ellDR", "ellDr", "adDr", "ellstr", " xder", "eaddriver", "eadstr", "awhr", "eadDr", "oadr", "eddDr", " xptr", "expressdriver", "inalhr", "eddr", "ekr", "inalder", "eadDR", "eadr"], "rw": ["writer", "write", "wd", "hr", "dx", "sw", "wp", "dq", "dd", " wr", "wr", "writ", "vr", "wn", "usr", "nr", "dt", "raw", "wx", "ew", "rl", "RW", "tw", "dir", "ow", "rt", "mr", "rx", "wb", "rn", "rew", "nw", "rb", "kw", "row", "aw", "hw", "w", "rd"], "type": ["r", "pro", " typ", "p", "types", "ype", "rule", "test", "typ", "op", "sp", "role", "pe", "tp", "name", " ty", "ver", "ty", "dt", "ico", "like", "time", "size", "count", "er", "mt", "try", "TYPE", "info", "Type", "y", "rt", "style", "sys", "kind", "t", "top", "status", "ping", "pc", "state", "ptr", "error"], "hash": ["r", "h", "sha", "hr", "dr", "mem", "tag", "err", "Hash", "addr", "sh", "id", "data", "ash", "name", "str", "usr", "hd", "her", "shift", "key", "size", "bh", "md", "oh", "shr", "index", "ch", "kh", "dh", "tr", "has", "ah", "handle", "ha", "tx", "ref", "alias", "sum", "res", "chip", "alt", "ptr", "host", "hz"], "vsid": ["vskid", "rsids", "lsID", "rskid", "dsid", "fsId", "obsip", "rsident", "rsmid", " vskid", "imsid", "valsID", "nsident", "vsID", "valsId", "obsmid", "vsident", "rsid", "rsId", "lsId", "fsip", "VsID", "valsids", "imsID", "rsID", "valsid", "obsid", "imside", "nsID", "vsip", "tskid", "vsId", "obskid", "rsip", "vside", "vsids", "nsId", "nsid", "fsid", " vsID", "nskid", "imskid", "obsident", "tsid", " vside", "tside", "VsId", "vsmid", "lsids", "lsid", "obsId", "dsID", "fsmid", "Vsid", "tsID", "dsId"], "ds": ["ts", "dc", "dev", "dr", "dx", "conn", "rs", "dq", "ls", "dd", "addr", "der", "dp", "rows", "ps", "xs", "gs", "ys", "dl", "hd", "Ds", "dt", "DS", "pd", "des", "src", "d", "bytes", "uds", "s", "dh", "eps", "fd", "os", "sd", "ks", "js", "sys", "keys", "db", "eds", "ptr", "bs", "ns"], "pr": ["r", "pol", "p", "pro", "rer", "cr", "dr", "hr", "pl", "rs", "price", "rr", "repl", "typ", "ser", "vr", "wr", "PR", "por", "pt", "ps", "ver", "fr", "rep", "lr", "spr", "pir", "expr", "pa", "tr", "mr", "kr", "pat", "per", "po", "Pr", "pc", "ptr"], "target_page_bits": ["target_page__points", "target_pool_points", "target_page_bit", "target_pool__bit", "target_page_bytes", "target_pool__bits", "target_Page_flags", "target_pool__points", "target_page__bits", "target_Page_bits", "target_pool_bits", "target_page_locks", "target_Page_its", "target_pool_bit", "target_page_points", "target_Page_bytes", "target_page__bytes", "target_pool__bytes", "target_page_its", "target_pool_bytes", "target_page_flags", "target_Page_locks", "target_page__bit"], "ret": ["att", "ts", "flag", "RET", "mem", "ft", "rev", "err", "read", " Ret", "re", "pt", "result", "gt", "Ret", "val", "dt", "out", "lt", "nt", "mt", "try", "lit", "def", "get", "elt", "ry", "ref", "rt", "set", "t", "len", "res", "alt", "rel"], "sr": ["r", "rin", "cr", "hr", "sb", "dr", "ir", "sol", "rs", "ear", "rr", "sur", "sa", "ar", "ser", "sp", "vr", "radius", "rf", "fr", "usr", "lr", "nr", "sts", "spr", "rm", "rc", "rg", "rl", "sv", "src", "sl", "serv", "shr", "tr", "sn", "rt", "gr", "mr", "rar", "kr", "SR", "ssl", "rn", "rx", "adr", "rb", "sy", " sy", "ctr"], "pgidx": ["pgIdx", "pghideX", "pegidd", "pgIdxs", "pgidz", "pegidn", "pghidex", " pgidix", "pgIdn", "pgpidxc", "pgdz", "pgidxc", "PGIdxc", "PGidxs", "pgpidx", "pgIdex", "PGidX", "pgpidxs", "PGidx", "pgmidex", "PGidex", "pgmidX", "pgpidix", "pgidxs", "pgpidX", "pgdx", "pegsidx", "pgidentxs", "pgdn", "pegidz", "pgIdxc", "PGIdx", "pgIdd", " pgidX", "pgdex", "pgsidn", "pgdX", "PGIdz", "pgmidz", " pgidz", "pgidentxc", " pghidez", "PGIdex", " pghidex", "pgpidz", "pgidex", "pgidix", "pghideix", "PGIdX", "pgsidd", "pgIdX", "pgsidz", "pgmidx", "pgidX", "pegsidd", "pghidez", "pegidx", "pgsidx", "pgidentx", "pginz", "pegsidn", "PGidxc", "pgidd", "pgidn", "PGIdxs", "pegsidz", "PGidz", "pgdd", "pgidentz", "pginix", "pgIdz", " pghideix", "pginX", " pghideX", "pginx"]}}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void slirp_socket_save(QEMUFile *f, struct socket *so)\n\n{\n\n    qemu_put_be32(f, so->so_urgc);\n\n    qemu_put_be16(f, so->so_ffamily);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_faddr.s_addr);\n\n        qemu_put_be16(f, so->so_fport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_faddr and so_fport\\n\");\n\n    }\n\n    qemu_put_be16(f, so->so_lfamily);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_laddr.s_addr);\n\n        qemu_put_be16(f, so->so_lport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_laddr and so_lport\\n\");\n\n    }\n\n    qemu_put_byte(f, so->so_iptos);\n\n    qemu_put_byte(f, so->so_emu);\n\n    qemu_put_byte(f, so->so_type);\n\n    qemu_put_be32(f, so->so_state);\n\n    slirp_sbuf_save(f, &so->so_rcv);\n\n    slirp_sbuf_save(f, &so->so_snd);\n\n    slirp_tcp_save(f, so->so_tcpcb);\n\n}\n", "idx": 9225, "substitutes": {"f": ["p", "bf", "x", "h", "conf", "off", "um", "cf", "ft", "ff", "v", "z", "fc", "xf", "l", "lf", "rf", "fr", "uf", "fo", "new", "fb", "out", "through", "o", "sf", "fs", "fab", "b", "g", "file", "d", "fm", "ac", "fn", "form", "fd", "field", "of", "y", "full", "fx", "af", "q", "fff", "fp", "tf", "fi", "F", "it", "c", "t", "ile", "e", "k", "fac", "w", "fw"], "so": ["pro", "sync", "ld", "dev", "no", "py", "sw", "su", "iso", "sa", "problem", "sh", "sel", "ss", "sing", "ste", "rh", "usr", "mo", "ka", "ico", "th", "SO", "ho", "whe", "ve", "o", " co", "ne", "sl", "soc", "since", "inho", "stone", "oh", "si", "lah", "sam", "esh", "ko", "ow", "os", "one", "ro", "oso", "sie", "wh", "oooo", " se", "lo", "So", "go", "ku", "ssl", "yes", "oto", " fo", "je", "ge", "sum", "stro", "sy", "cho", "hi", "bo", " o", "shi", "se", "tw", "ski"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n", "idx": 9231, "substitutes": {"obj": ["self", "od", "Obj", "attr", "typ", "id", "op", "data", "ob", "obs", "object", "ox", "o", "nt", "tmp", "src", "ie", "inst", "elt", "ref", "js", "ctx", "pos", "db", "pkg", " ob", "cmd"], "name": ["p", "no", "mem", "attr", "type", "read", "data", "NAME", "str", "old", "key", "n", "nt", "nm", "names", "def", "var", "ns", "prop", "ame", "Name", "nam", "len", "word", "col", "w", "cmd"], "val": ["pr", "vals", "seq", "Val", "value", "mem", "ret", "v", "test", "sel", "data", "buf", "serv", "values", "def", "lit", "var", "tx", "eval", "ref", "ctx", "txt", "res", "lib", "el", "item", "rel"], "errp": ["irps", " errps", "irP", "irpa", "errps", "errP", "erP", " errpa", "erps", "erpa", "irp", " errP", "errpa", "erp"]}}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n", "idx": 9238, "substitutes": {"ctx": ["cpp", "dc", "cb", "conn", "tc", " cx", "cf", "ck", "abc", "bc", "nc", "ct", "xs", "jac", "lc", "cc", "wk", "mom", "wx", "obj", "cp", "kh", "kl", "mk", "tx", "cmp", "ca", "req", "c", "mc", "kt", "ij", "sc", "anc", "kw", "loc", "Context", "pkg", "context", "pc", "gc", "k", "hw", "jp", "cmd"], "i": ["ami", "cli", "x", " ti", " m", " y", " key", " ii", "ind", "ix", "iu", "bi", " I", " bit", "print", "li", "\u0438", "this", " c", "ti", " n", "ms", " pi", "gi", "ic", " index", "ei", "I", "phi", " bi", " err", "it", "qi", "mi", "ij", "asi", "ki", "me", "ui", "p", " l", "init", " wi", "span", " axis", " all", "uri", "id", "xi", " iter", "sim", "ex", "multi", "g", "is", "y", "gu", "fi", "ci", "pi", "us", "di", " multi", " x", "ri", "ai", "ii", "ji", " mi", "si", "m", "ip", "zi", " j", "point", "im"], "output": ["hidden", "write", "collection", "update", "list", "blue", "public", "no", "document", "web", "next", "four", "column", "Output", "success", "rule", "op", "dot", "connection", "network", "command", "result", "dict", "page", "position", "new", "other", "error", "component", "all", "out", "config", "o", "put", "temp", "store", "total", "net", "print", "work", "cache", "see", "display", "bit", "input", "view", "queue", "control", "export", "module", "console", "buffer", "filter", "outer", "coin", "block", "current", "batch", "option", "message", "product", "client", "answer", "results", "sort", "operation", "response"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n", "idx": 9246, "substitutes": {"dstU": ["ddestUI", "dndV", "rstU", "dndU", "dsrcP", "dsrcC", "DstU", "DndP", "dstUV", "DstV", "rptV", "rstV", "rptUV", "dsrcV", "rptU", "DstP", "dptV", "dndUV", "ddestV", "dsrcU", "rptC", "DstUI", "dptC", "dstUI", "dndP", "dstP", "ddestP", "dndC", "dptU", "dndUI", "dptUV", "DndUI", "ddestU", "DndU", "rstUV", "DndV", "rstC", "dsrcUV", "dstC", "dsrcUI"], "dstV": ["dstVC", "dndV", "dndU", " dsrcU", "DstU", " dsrcG", "dstUV", "DestV", "DstV", " dsrcV", "distU", "dndG", "dsrcV", "DestVC", "dnaU", "dvV", "destU", "dvU", "dsrcU", "dnaV", "dvG", "dsrcG", "DstVC", "dndI", "dnaVC", "dstI", "DstUV", " dsrcI", "dnaUV", "DestUV", "dstG", "destV", "dsrcI", "DestU", "destUV", "distVC", " dstI", "distV", "dvI", " dstG", "distUV", "destVC"], "src1": ["source1", "usr01", "rc1", "src01", "rc01", "src0", " src01", "usr0", "usr2", " src0", "source01", "usr1", "rc0", "source0", "rc2", "source2"], "src2": ["rc1", "source3", "src3", " src3", "source1", "srcB", "sourceB", "rc2", "rcB", "source2", " srcB", "rc3"], "unused": ["unuse", " unavailable", " unUsed", "unavailable", "Unavailable", " unuse", "UnUsed", "unaluse", "Unuse", "unalused", "unalavailable", "unalUsed", "unUsed", "Unused"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lan9118_readl(void *opaque, target_phys_addr_t offset,\n\n                              unsigned size)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n\n\n    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);\n\n    if (offset < 0x20) {\n\n        /* RX FIFO */\n\n        return rx_fifo_pop(s);\n\n    }\n\n    switch (offset) {\n\n    case 0x40:\n\n        return rx_status_fifo_pop(s);\n\n    case 0x44:\n\n        return s->rx_status_fifo[s->tx_status_fifo_head];\n\n    case 0x48:\n\n        return tx_status_fifo_pop(s);\n\n    case 0x4c:\n\n        return s->tx_status_fifo[s->tx_status_fifo_head];\n\n    case CSR_ID_REV:\n\n        return 0x01180001;\n\n    case CSR_IRQ_CFG:\n\n        return s->irq_cfg;\n\n    case CSR_INT_STS:\n\n        return s->int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9255, "substitutes": {"opaque": ["pque", " opaques", "paco", " opque", "oppaque", "iopaque", "opque", "iopaques", "opaco", "oppque", " opade", "opaques", "oppade", "iopaco", "oplaques", "iopque", "oplaco", "oplque", "oppaques", "opade", "oplade", "paques", "oplaque", "paque"], "offset": ["off", "timeout", "slot", "from", "transfer", "addr", "alloc", "sp", "oid", "data", "op", "tz", "location", "object", "pad", "padding", "command", "start", "window", "position", "shift", "align", "slice", "range", "origin", "o", "count", "seek", "pointer", "area", "bound", "tif", "index", "offs", "kh", "os", "empty", "attribute", "set", "ref", "into", "style", "Offset", "pos", "buffer", "len", "block", "base", "point", "row", "SIZE", "address", "length", "operation"], "size": ["mem", "type", "amount", "sp", "z", "fee", "name", "start", "window", "shift", "align", "n", "SIZE", "count", "Size", "set", "ize", "num", "len", "sum", "message", "e", "address", "length"], "s": ["changes", "sb", "dates", "ses", "ls", "ains", "rows", "xs", "aws", "comm", "sm", "des", "south", "sv", "as", "sam", "bis", "sys", "js", "bes", "grades", "c", "ists", "t", "ests", "eds", "ms", "ords", "rates", "ins", "ns", "less", "h", "ats", "conf", "ies", "ables", "ries", "ers", "ps", "an", "parts", "ess", "sq", "fs", "a", "sl", "acts", "ches", "umps", "stats", "ds", "comments", "vs", "cs", "ims", "tes", "ports", "p", "erences", "itions", "sol", "sa", "sp", "its", "ties", "ments", "tests", "store", "is", "b", "ions", "resses", "os", "hs", "sis", "spec", "ing", "ts", "rs", "alls", "args", "ials", "ss", "es", "als", "izes", "gs", "j", "sts", "details", "aces", "states", "ands", "S", "bits", "ations", "im", "bs", "qs", "ants"]}}
{"project": "FFmpeg", "commit_id": "c94d551ea7b39c4e467e146cd347c407e8eb38ee", "target": 0, "func": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride)\n\n{\n\n    PixletContext *ctx = avctx->priv_data;\n\n    GetBitContext *b = &ctx->gbit;\n\n    unsigned cnt1, nbits, k, j = 0, i = 0;\n\n    int64_t value, state = 3;\n\n    int rlen, escape, flag = 0;\n\n\n\n    while (i < size) {\n\n        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);\n\n\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 < 8) {\n\n            value = show_bits(b, nbits);\n\n            if (value <= 1) {\n\n                skip_bits(b, nbits - 1);\n\n                escape = ((1 << nbits) - 1) * cnt1;\n\n            } else {\n\n                skip_bits(b, nbits);\n\n                escape = value + ((1 << nbits) - 1) * cnt1 - 1;\n\n            }\n\n        } else {\n\n            escape = get_bits(b, 16);\n\n        }\n\n\n\n        value = -((escape + flag) & 1) | 1;\n\n        dst[j++] = value * ((escape + flag + 1) >> 1);\n\n        i++;\n\n        if (j == width) {\n\n            j = 0;\n\n            dst += stride;\n\n        }\n\n        state = 120 * (escape + flag) + state - (120 * state >> 8);\n\n        flag = 0;\n\n\n\n        if (state * 4 > 0xFF || i >= size)\n\n            continue;\n\n\n\n        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;\n\n        escape = av_mod_uintp2(16383, nbits);\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 > 7) {\n\n            rlen = get_bits(b, 16);\n\n        } else {\n\n            value = show_bits(b, nbits);\n\n            if (value > 1) {\n\n                skip_bits(b, nbits);\n\n                rlen = value + escape * cnt1 - 1;\n\n            } else {\n\n                skip_bits(b, nbits - 1);\n\n                rlen = escape * cnt1;\n\n            }\n\n        }\n\n\n\n        if (i + rlen > size)\n\n            return AVERROR_INVALIDDATA;\n\n        i += rlen;\n\n\n\n        for (k = 0; k < rlen; k++) {\n\n            dst[j++] = 0;\n\n            if (j == width) {\n\n                j = 0;\n\n                dst += stride;\n\n            }\n\n        }\n\n\n\n        state = 0;\n\n        flag = rlen < 0xFFFF ? 1 : 0;\n\n    }\n\n\n\n    align_get_bits(b);\n\n    return get_bits_count(b) >> 3;\n\n}\n", "idx": 9258, "substitutes": {"avctx": ["afcmd", "camctx", "avtx", "afctx", "Avcmd", "AVcontext", "avcmp", "avcmd", "Avctx", "Avtx", "Avcmp", " avcontext", "camcontext", "camcmp", "AVcmp", "camtx", "AVctx", "Avcontext", " avtx", "aftx", "afcontext", " avcmd", "avcontext", "AVtx"], "dst": ["dut", "dwidth", "Dut", "dset", "ddest", "sst", "dstop", "dLstop", " dest", "Dest", "dsp", "dsrc", " dstop", " dsrc", "Dwidth", " dsp", "sset", "dbsrc", "dbst", "Dst", "Dsrc", " dset", "sdest", "rest", "dbut", "dsts", "rst", "Dsts", "dLdest", " dwidth", " dut", "rwidth", " ddest", "dLset", "dLst", "dest", "dbsts", "rsp", "Dsp", "sstop", " dsts"], "size": ["grade", "limit", "send", "sw", "sp", "z", "settings", "name", "height", "padding", "capacity", "start", "window", "shift", "range", "SIZE", "count", "g", "file", "si", "Size", "scale", "s", "win", "shape", "sn", "set", "max", "offset", "ize", "m", "body", "num", "len", "e", "w", "length", "zero"], "stride": ["STRice", "bride", "swice", "swid", "STRid", "brid", "brice", "Strride", "strride", "brride", "strade", "Strides", "Strade", "brade", "strid", "STRride", " strride", "swide", "strides", "Stride", " strade", "brides", "strice", "STRide", "swride", " strides"], "ctx": ["dc", "cb", "conf", "np", "conn", "tc", "cf", "cm", "cfg", "cam", "bc", "ct", "jac", "comm", "cc", "cv", "obj", "cp", "config", "nt", "setup", "ac", "tx", "cmp", "ca", "ctrl", "c", "txt", "sc", "kw", "loc", "xc", "pkg", "context", "gc", "jp", "cmd"], "b": ["p", "cb", "bf", "sb", "h", "be", "ab", "bin", "f", "v", "nb", "ob", "emb", "bp", "bc", "l", "j", "bb", "eb", "fb", "bl", "ib", "bi", "buf", "a", "bh", "bt", "g", "as", "B", "buff", "ch", "y", "gb", "bis", "it", "br", "c", "wb", "t", "bits", "buffer", "db", "rb", "base", "ba", "bg", "bo", "bs", "w"], "cnt1": ["ucncOne", " cnt001", "Count1", "cntP", "cnd0", "Cnt1", "contP", " ccount001", "cnd1", "ccountOne", "ucnt0", "ccount001", "ctxtOne", "countL", "cncOnce", "ucnc1", "ctxt001", "Cnt0", "_", "Count0", "cnt001", "cret8", "cOUNTOne", "cct1", " cntOnce", "cont0", "ucntOne", "cNT1", "countOnce", "cmd", " ccount0", "ccount1", " cntn", " count1", "ucnt1", "ucnc001", "Count8", "crc4", "cnt7", " cnt0", "crc1", "new", "count1", " ccount2", "ccount0", "cnd7", "cncOne", " ccount7", "cOUNT4", "ecntOne", "cust7", " cntL", "ucnc0", "count2", "countn", "ccountL", "cct001", "Cnt8", "ctxt1", "ccount7", "cnc1", "be", "crcOne", " ccount1", "cNTOne", " cntP", "cont1", "ecnt1", "count7", "custOnce", "ecNT1", "countP", "cnc001", "ucnt001", "contn", " count2", "ecNT4", "cnt0", "cnt2", " countP", " countn", " countL", " countOne", "ccount2", "cndOne", "cndL", "count8", "cndP", "Cnt2", " cnt2", " ccountOne", " count0", "ecnt4", "cct2", "cctOne", "gc", " cntOne", "cret1", "cust1", "cnd2", "cndn", "cnt8", "cntn", "cnc0", "count0", "cret0", "cntOne", "cOUNT1", "cust0", "cct8", "Count2", "ecNTOne", "countOne", "cret2", " count7", "ctxt0", "cNT4", "cntL", " cnt7", "cntOnce", "cct0", "cnt4", "cnc7", " countOnce"], "nbits": ["Nbits", "nlines", "nbytes", "uncodes", "cncodes", "anbytes", "anpins", "cntags", "untags", "npoints", "nparts", "unrows", "nbis", " nchanges", "nits", "lparts", " nbps", "cnbps", " nparts", "nops", " nframes", "cnbytes", "cnbits", "lits", "numbytes", "nfields", "anfields", "nchanges", "cnrows", " nbs", "onpoints", "cnits", "onints", " nbytes", "ntags", "nbs", "unframes", "ncodes", "numits", " npins", "unops", " nits", "lbytes", "unints", "numbits", "Nbps", "cits", "nblocks", "scanops", "anflags", "cbs", "onops", "anbits", "lbs", "ontops", "unblocks", "cbytes", "unflags", "spanlines", "lbits", "anints", "nbps", "scanbis", "cbits", "unlines", "anparts", "Npins", "nflags", "onbis", " ntops", "scanbits", "cnframes", "onbs", "nframes", "anits", "unbis", " nfields", "untops", "onbytes", " nblocks", "ntops", "Nits", "onbits", "onits", "numbs", "units", " ntags", " nints", "unpoints", "anchanges", "Nbs", "spanrows", "nints", " nflags", "scanpoints", "spanbits", "Nbytes", "anblocks", "nrows", "unbits", "unfields", "npins", "spancodes", "lchanges", "cnlines"], "k": ["p", "x", "v", "name", "ek", "start", "key", "u", "n", "ak", "count", "seek", "g", "ok", "q", "max", "K", "set", "offset", "kind", "it", "m", "ip", "alias", "e", "w", "ac"], "value": ["limit", "vector", "unit", "type", "json", "number", "data", "sample", "hello", "create", "change", "null", "total", "transform", "scale", "index", "parse", "itness", "byte", "text", "current", "description", "vp", "state", "itude", "python", "function", "name", "code", "new", "rue", "raw", "all", "field", "attribute", "package", "sequence", "power", "buffer", "port", "action", "we", "ue", "commit", "pair", "entry", "command", "result", "start", "VALUE", "position", "multiple", "process", "Value", "label", "values", "sign", "try", "unknown", "style", "variable", "weight", "ence", "checked", "expression", "length", " Value", "save", "v", "success", "format", "version", "random", "widget", "val", "key", "initial", "see", "view", "operator", "base", "quality", "option", "message", "image", "address"], "rlen": ["rtlength", "rtlimit", "rmsg", "rrlong", "rlim", "dLen", "rtls", "plimit", "rlength", "rtlim", " rLen", "rrlen", "rls", "Rlength", "dlim", " rlim", "rrmsg", "RLen", "rrLen", " rls", "plen", "dlen", "rlimit", "dlength", "rLen", "rrlength", " rlong", "pls", "Rlen", " rmsg", "plength", "rlong", "rrls", "rtLen", " rlimit", " rlength", "rtlong", "rrlimit", "rtlen", "Rmsg"], "escape": ["limit", "scape", "flag", "condition", "json", "pack", "lock", "shift", "close", "change", "edge", "secure", "guard", "scale", "parse", "force", "echo", "slave", "apache", "ssh", "se", "cmd", "layout", "comment", "link", "esc", "speed", "esi", "APE", "code", "safe", "seek", "ie", "aped", "expr", "match", "attribute", "sequence", "control", "export", "ctrl", "cape", "ape", "buffer", "aw", "pair", "scroll", "label", "execute", "email", "sign", "stroke", "eval", "style", "ignore", "alias", "ase", "e", "expression", "bind", "error", "quote", "save", "success", "illegal", "access", "route", "key", "secret", "forge", "event", "esp", "rage", "view", "offset", "check", "ee", "axe", "address", "delay"], "i": ["ui", "di", "p", "x", "jj", "f", "v", "id", "ai", "ind", "ii", "ei", "j", "I", "phi", "ix", "iu", "bi", "n", "o", "iter", "a", "is", "si", "index", "s", "li", "info", "y", "ini", "it", "ci", "m", "t", "ip", "mi", "ij", " j", "zi", "ti", "im", "pi", "e"]}}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(s, &request);\n\n    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {\n\n        reply.error = errno;\n\n    } else {\n\n        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);\n\n    }\n\n    nbd_coroutine_end(s, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 9260, "substitutes": {"bs": ["ts", "sb", "blog", "rs", "aos", "bos", "ls", "BS", "ss", "its", "als", "bp", "bc", "obs", "ps", "cks", "gs", "ys", "ubs", "bi", "fs", "bh", "b", "lbs", "is", "os", "bis", "js", "bes", "hs", "ds", "bing", "bits", "aus", "vs", "cs", "bm", "ns"], "sector_num": ["sector_Num", "sector2num", "sector2um", "sectoretynum", "sectoretynumber", "ector_number", "sector2Num", "sector00set", "sectoretyset", "sectoretymu", "sector_um", "sector00number", " sector_Num", " sector_number", " sector_um", "ector_set", "sector_mu", "sector00num", "ector_mu", "sector2number", "sector00mu", "sector_number", "ector_num", "sector_set"], "nb_sectors": ["nb_serors", "nb_secs", "nb_vevers", "nb_vectors", "nb_pevers", "nb_serivers", "nb_bectors", "nb_pecs", "nb_severs", "nb_peors", "nb_specs", "nb_vecs", "nb_servers", "nb_seivers", "nb_bevers", "nb_serctors", "nb_seors", "nb_spectors", "nb_speors", "nb_veors", "nb_veivers", "nb_spevers", "nb_beors", "nb_pectors", "nb_beivers"], "qiov": ["quiov", "qoco", " Qconv", "quoco", "quiop", " qoco", "quiour", "sqiour", "qiour", "qiop", " Qiour", "qiv", "sqiov", " Qoco", "sqiv", " qiv", " qiop", "sqiop", "quiv", "quconv", " Qiov", " qconv", " qiour", "qconv"], "offset": ["off", "timeout", "slot", "from", "ff", "addr", "number", "oid", "location", "pad", "padding", "seed", "layer", "start", "position", "shift", "origin", "o", "size", "seek", "pointer", "prefix", "index", "set", "Offset", "pos", "top", "et", "len", "point", " offsets", "ptr", "address", "length", "error"], "s": ["r", "ts", "p", "less", "sync", "h", "sb", "conf", "sw", "ses", "rs", "sa", "i", "ls", "ss", "z", "es", "its", "l", "ps", "gs", "j", "an", "comm", "sts", "http", "ex", "n", "sq", "sm", " ss", "south", "fs", "sv", "sl", "b", "is", "g", "a", "os", "y", "sn", "q", "js", "sys", "stats", "ds", "m", "S", "so", "t", "w", "ns"], "request": ["QUEST", "art", "report", "search", "public", "select", "ire", "police", "condition", "document", "type", "accept", "transfer", "rank", " requisite", "pair", "frame", "ask", "trip", "command", "call", "import", "query", "question", "new", "worker", "order", "record", "create", "change", "setup", "config", "store", "complete", " query", " requesting", "begin", "join", "print", "address", "match", "push", "suggest", "copy", "param", "attribute", "package", "input", "q", "have", "project", "reset", "task", "quest", "forward", "req", "find", "claim", "requ", "Request", "est", " req", "point", "message", "xml", "child", "reference", "response", "cmd"], "reply": ["r", " response", "report", "respond", "write", "send", "sync", " Reply", "ror", "comment", "rev", "next", "rr", "repl", "ret", "err", "transfer", "link", "bill", "related", "output", "role", "jp", "reason", "command", "result", "query", "proxy", "bb", "route", "error", "process", "record", "nl", "out", "ve", "des", "place", "relation", "apply", "detail", "sett", "echo", "replace", "translation", "part", "body", "status", "resp", "message", "ply", "onse", "Reply", "answer", "results", "ish", "lib", "response"]}}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int request_frame(AVFilterLink *link)\n\n{\n\n    AVFilterContext *ctx = link->src;\n\n    IDETContext *idet = ctx->priv;\n\n\n\n    do {\n\n        int ret;\n\n\n\n        if (idet->eof)\n\n            return AVERROR_EOF;\n\n\n\n        ret = ff_request_frame(link->src->inputs[0]);\n\n\n\n        if (ret == AVERROR_EOF && idet->cur) {\n\n            AVFrame *next = av_frame_clone(idet->next);\n\n\n\n            if (!next)\n\n                return AVERROR(ENOMEM);\n\n\n\n            filter_frame(link->src->inputs[0], next);\n\n            idet->eof = 1;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (!idet->cur);\n\n\n\n    return 0;\n\n}\n", "idx": 9282, "substitutes": {"link": ["ld", "sync", "ink", "let", "lay", "mail", "Link", "sh", "flow", "frame", "pack", "connect", "l", "command", "call", "ln", "tool", "lock", "dl", "lc", "route", "thread", "linked", "slice", "line", "label", "links", "ctl", "loop", "sl", "load", "light", "handle", "match", "parse", "li", "def", "local", "task", "lex", "open", "check", "mark", "play", "block", "ick", "ping", "fail", "le", "hip"], "ctx": ["wd", "cb", "co", "init", "conn", "tc", "cf", "cm", "ck", "ic", "nc", "ct", "crit", "cc", "wx", "cv", "nt", "cp", "config", "tmp", "obj", "ac", "act", "tx", "cmp", "sys", "iat", "mc", "ctrl", "kt", "sc", "anc", "kw", "loc", "xc", "context", "hw", "msg", "conv", "cmd"], "idet": [" idET", " idote", "initot", "ridect", "pidet", " idot", "identetic", "uidot", "idec", "uidel", "identot", "idetter", "idpt", "Idpt", "ridet", "Idec", "pidET", "uidET", "Idnet", "ident", "aidet", "Ident", "indote", "pidel", "identET", " idpt", "Idet", " idel", "identiet", "initet", "idET", "idiet", "aidote", "uidet", "idot", "identel", "pidnet", "indet", "aidnet", " idnet", "idect", "idote", "initetic", " idetter", "identet", "identent", "initent", "Idetic", "ridpt", "IdET", "idel", "identetter", "uidiet", "Idel", " idect", "Idot", " idec", "idetic", " idiet", "ridec", "idnet", "Idect", "uidetter", "indnet"], "ret": ["att", "done", "pret", "RET", "final", "ft", "fun", "mem", "rev", "err", "cont", "success", "xt", "test", "re", "end", "vers", "result", "prot", "j", "gt", "Ret", "deg", "usr", "code", "tn", "val", "rem", "rm", "out", "lt", "nt", "rets", "back", "print", "mt", " fut", "ext", "tr", "def", "try", "elt", "rt", "hash", "sys", "reset", "ref", "reg", "inter", "fin", "txt", "t", "num", "len", "res", "cert", "status", "ll", "resp", "det", "alt", "state", "ter", "nz", "jp", "cmd"], "next": ["self", "extra", "dev", "nd", "be", "nn", "seq", "rev", "err", "v", "sel", "xt", "ng", "cur", "then", "dot", "Next", "frame", "data", "z", "gov", "ver", "j", "gt", "fr", "other", "new", "future", "inc", "prev", "nl", "n", "nt", "ne", "obj", "tmp", "buf", "net", "fn", "sec", " NEXT", "ext", "to", "nil", "info", "big", "first", "desc", "ref", "adj", "max", "gr", "last", "now", "br", "js", "txt", "current", "batch", "normal", "valid", "ptr", "gen", "msg", "jp", "pri"]}}
{"project": "FFmpeg", "commit_id": "a2085a7e9d83d99aca58bfb385f6db1afa5673dd", "target": 1, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n                             void *data, int *data_size,\n                             uint8_t *buf, int buf_size)\n{\n    DPCMContext *s = avctx->priv_data;\n    int in, out = 0;\n    int predictor[2];\n    int channel_number = 0;\n    short *output_samples = data;\n    int shift[2];\n    unsigned char byte;\n    short diff;\n    if (!buf_size)\n        return 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ROQ_DPCM:\n        if (s->channels == 1)\n            predictor[0] = AV_RL16(&buf[6]);\n        else {\n            predictor[0] = buf[7] << 8;\n            predictor[1] = buf[6] << 8;\n        }\n        SE_16BIT(predictor[0]);\n        SE_16BIT(predictor[1]);\n        /* decode the samples */\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n            predictor[channel_number] += s->roq_square_array[buf[in]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_INTERPLAY_DPCM:\n        in = 6;  /* skip over the stream mask and stream length */\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0])\n        output_samples[out++] = predictor[0];\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1])\n            output_samples[out++] = predictor[1];\n        }\n        while (in < buf_size) {\n            predictor[channel_number] += interplay_delta_table[buf[in++]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_XAN_DPCM:\n        in = 0;\n        shift[0] = shift[1] = 4;\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0]);\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1]);\n        }\n        while (in < buf_size) {\n            byte = buf[in++];\n            diff = (byte & 0xFC) << 8;\n            if ((byte & 0x03) == 3)\n                shift[channel_number]++;\n            else\n                shift[channel_number] -= (2 * (byte & 3));\n            /* saturate the shifter to a lower limit of 0 */\n            if (shift[channel_number] < 0)\n                shift[channel_number] = 0;\n            diff >>= shift[channel_number];\n            predictor[channel_number] += diff;\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_SOL_DPCM:\n        in = 0;\n        if (avctx->codec_tag != 3) {\n            if(*data_size/4 < buf_size)\n            while (in < buf_size) {\n                int n1, n2;\n                n1 = (buf[in] >> 4) & 0xF;\n                n2 = buf[in++] & 0xF;\n                s->sample[0] += s->sol_table[n1];\n                 if (s->sample[0] < 0) s->sample[0] = 0;\n                if (s->sample[0] > 255) s->sample[0] = 255;\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n                s->sample[s->channels - 1] += s->sol_table[n2];\n                if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0;\n                if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255;\n                output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8;\n            }\n        } else {\n            while (in < buf_size) {\n                int n;\n                n = buf[in++];\n                if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F];\n                else s->sample[channel_number] += s->sol_table[n & 0x7F];\n                s->sample[channel_number] = av_clip_int16(s->sample[channel_number]);\n                output_samples[out++] = s->sample[channel_number];\n                /* toggle channel */\n                channel_number ^= s->channels - 1;\n            }\n        }\n        break;\n    }\n    *data_size = out * sizeof(short);\n    return buf_size;\n}", "idx": 9283, "substitutes": {"avctx": ["vrtx", "avtx", "avecmd", "avjp", "vrcv", "AVcontext", "avecv", "avectl", "AVcmd", "avcmd", "vctx", "avecontext", "vctl", "AVcv", " avcontext", "avejp", "vcontext", "vpkg", "AVpkg", " avjp", "AVjp", "vrctx", "AVctx", "avcv", "avetx", "avpkg", "avctl", "vrcmd", "avcontext", " avctl", "avectx", "AVctl", "AVtx", " avpkg"], "data": ["p", "DATA", "value", "bin", "next", "ata", "frame", "pad", "str", "Data", "feed", "window", "raw", "channel", "size", "a", "d", "bytes", "dat", "to", "empty", "input", "ref", "m", "this", "text", "t", "pos", "buffer", "batch", "block", "table", "message", "w", "image", "length"], "data_size": ["buf_length", "buf_send", "buf_SIZE", "data_send", "data_SIZE", "data_length"], "buf": ["wd", "aka", "np", "err", "pack", "cam", "fb", "docs", "buff", "mus", "cache", "arr", "Buff", "fam", "db", "rb", "batch", "pkg", "Buffer", "cmd", "mem", "wav", "good", "raw", "bench", "config", "bar", "nm", "bh", "etc", "tx", "desc", "wb", "txt", "buffer", "msg", "p", "boxes", "seq", "cap", "pb", "cur", "bp", "str", "uf", "deg", "window", "bag", "tmp", "b", "bytes", "late", "ctx", "vec", "br", "prop", "doc", "conv", "func", "cb", "proc", "mat", "ff", "v", "args", "nb", "hz", "cv", "tab", "queue", "box", "bits", "bs", "words", "img"], "buf_size": ["bufptSIZE", " buf5offset", " bufptSIZE", "bufJsize", "buf5number", "buf1sent", "bufptsum", "buf5offset", " buf5len", " buf_offset", "queue_ize", " bufpttoo", "buf_length", "buf1ize", " buf_len", "buf5SIZE", "bufJSIZE", "buftoffset", "buf_too", "buf_offset", "bufJsum", "buf5len", "buf_ize", " buf5number", "buf_len", "buf_SIZE", "bufpttoo", "buf1size", "bufJtoo", "buftnumber", "buf_sent", "queue_length", "buf1length", "buf5size", "queue_sent", "buf_number", " buf5size", " buf_SIZE", "queue_size", " bufptsum", " bufptsize", " buf_too", "bufptsize", " buf_number", "buftsize", "buf_sum", "buftlen", " buf_sum"], "s": ["r", "ts", "p", "less", "changes", "h", "ats", "conf", "sw", "rs", "i", "v", "ls", "ss", "its", "z", "es", "ps", "gs", "aws", "comm", "ops", "sts", "ex", "ess", "sq", "sv", "a", "b", "g", "d", "is", "as", "bs", "os", "sys", "js", "ctx", "hs", "ds", "ssl", "stats", "m", "c", "S", "t", "sk", "sc", "vs", "cs", "ims", "spec", "sports", "ns"], "in": ["rin", "update", "x", "pid", "ind", "end", "inn", "en", "ix", "as", "d", "index", "min", "pin", "c", "row", "up", "el", "ins", "on", "ic", "name", "new", "raw", "all", "after", "win", "IN", "act", "In", "it", "inner", "pass", "by", "p", "al", "init", "um", "i", "id", "l", "isin", "start", "window", "inc", "ex", "at", "record", "oin", "o", "time", "iter", "ax", "is", "gin", "ini", "input", "inter", "con", "e", "doc", "r", "from", "v", "ai", "add", "call", "old", "loop", "din", "local", "m", "check", "pos", "ee", "im"], "predictor": ["pictger", "pictionoring", "pctor", "predictoral", "ppectoral", "pingessorcer", "picteduser", "psuppetor", "predictuser", "pessorcer", "psuppetur", "pictionior", "xpictionor", "posterory", "wpictOR", "compictionior", " predictutor", "pictionicator", "pitnessator", "pictedider", "proppredor", "prpectcer", "prredictor", "pderrar", "pessoror", "tpredictior", "pocoloral", "ppredutor", "ppectutor", "postered", "pingredictcer", "priptoral", "pctur", "wppredor", "prredictur", "predictractor", "ppredator", "psivotessor", " ppectutor", "prpectger", " predictori", "predictur", "prosterrator", "compredictior", "pointutor", "xpredictuser", "peterminOR", "wpredictur", "predicteur", "pculor", "predictutor", "padaptger", "prosteror", "ppredor", "wpredictessor", "proppredractor", "tpriptant", "peterminoral", "padaptOR", "pictutor", "priptor", " ppector", "pictionant", " padaptbor", "posterider", "ppredion", "pocolori", "pointor", "psivotrar", "priptractor", "xpictionider", "pessoreur", "prredictutor", "pingredictoring", "ppector", "pictter", "pingredicteur", "wppredator", "predictory", "posteruser", "pjector", "pveyior", "predictoring", "compictionutor", "prredictlor", "psivotor", "ppictter", "predictrator", "ppredori", "predictator", "pription", "pingredictor", "ppreded", "pjectore", "pjectori", "parsonor", "padaptor", "pveyicator", "ppredore", "pinguppetator", "pictionory", "prjectur", "ppectger", "pictbor", "proppredore", "compredictutor", "pictractor", "padaptbor", "predictbor", "pictedor", "pictessor", "pderessor", "padaptutor", "pderitor", "psertlor", "prpectutor", "predicted", "pictionur", "pictedory", "ppredrator", "prredictrator", "pennori", "pictionter", "ppredter", "psredictrar", "ppredictbor", "ppredur", "prosterutor", "pderlor", "wppredbor", "prredictcer", "wpredictolder", "pessorion", " padaptor", "pointur", "prjectactor", "pinguppetoral", "psuppetcer", "tpredictoring", "pitnessoring", "ppectessor", " ppectior", "pingredictoral", "pconstructor", "puppetator", "ppredictutor", "psredictor", "pveyant", "pingrediction", "pictolder", "pctator", "predictior", "ppredcer", "priptcer", "petermincer", "pitnessoral", "propredictori", " padaptutor", "ppredbor", "prredictger", "pictionider", "pennractor", "wpredictbor", "priptoring", "padaptori", "prictor", "peterminor", "xpredictory", "psredictutor", "ppecter", "pderutor", "compictionicator", "propredictractor", "puppetor", "pensoror", "posterutor", "wpictor", "pjectractor", "predictlor", "pictedori", "pictori", "pingredictator", "predicticator", "predictessor", "pingessorion", "ppectolder", "pveyor", "prpectOR", "wpictolder", "psertor", "xpictionuser", "ppictor", "puppetcer", "psertutor", "puppetur", "pertutor", "ppectcer", "pointitor", "pivotor", "pivotrar", "prjector", "pictcer", "pocoloring", "priptur", "tpredictor", "puppetoral", "predictore", "puppetractor", "pictionuser", "xpredictider", "propredictore", "predictactor", "pennor", "psredictlor", "posterrator", "pictlor", "ppectOR", "pertor", "pictionolder", "ppictbor", "prediction", "tpriptior", "psredictitor", "compictionor", "tpredictant", "predictOR", "pensorutor", " ppecter", "prredictactor", "pocolator", "psuppetractor", " padaptori", "pictionutor", "prjectutor", "compredicticator", "puppetoring", "priptOR", "pivotessor", "psredictractor", "pingessoror", "ppecticator", "prredictOR", "prpector", "priptior", "psertitor", "xpredictor", "pictionor", "pictionactor", "prictori", "proppredori", "pensored", "pinguppetoring", "pocolor", "parsonbor", "compredictor", " predictior", "pconstructur", "psredictur", "prpectoral", "pictur", "pensorrator", "ppredictter", "wppredur", "parsonori", "pctbor", "prredictoral", "predictolder", "pictOR", "pveyutor", "posteror", "pitnessor", "prictlor", "pertitor", "ppredractor", "pictionessor", "ppredictor", "pinguppetor", "pingessoreur", "predictori", "pictionbor", "pjectutor", "wpredictator", "tpriptoring", "wpictessor", "pictor", " predictbor", "predictrar", "pocolutor", "psredictcer", "pripteur", "predictitor", "pointlor", "prictutor", "pertlor", "pconstructbor", "pictioner", "pconstructator", "xpictionory", "prredictori", "wpredictOR", "pculrar", "propredictor", "pictedlor", "pocollor", "parsonutor", "predictcer", "predictider", " predicter", "pderor", "pointactor", "pictedutor", "predictter", "predicter", "pictionOR", "wpredictor", "ppredeur", "tpriptor", "pjectactor", "prostered", "pjectur", "psredictessor", "predictant", "pveyoring", "priptant", "prredicted", "ppectior", "predictger", "ppictutor", "pculessor", "pennore"], "output_samples": ["outputfulsourses", "output_sets", "outputMemstatusiders", "outputMemsiders", "output_tsiders", "outputfulsnapamples", "output_esutes", "output_snapessions", "outputMemsamples", "output_sents", "output_examples", "output_snapamples", "output_sourses", "output_sannels", "output_esiders", "output_genresses", "output_consamples", "output_siders", "output_sages", "output_genessions", "outputfulsessions", "output_namples", "output_tsples", "output_sples", "outputfulsresses", "outputfulsnapresses", "output_sutes", "output_samps", "outputfulsnapourses", "output_tsutes", "output_Sets", "output_Samples", "outputfulsamples", "output_statages", "output_statusples", "output_statamples", "output_namps", "output_statets", "output_consannels", "output_statusutes", "output_statamps", "output_esples", "output_camples", "output_statents", "output_statusiders", "outputMemstatusples", "output_consages", "output_esamples", "output_courses", "output_cresses", "output_cessions", "output_tsamples", "output_statusamples", "output_sessions", "output_genourses", "outputMemsutes", "output_nets", "output_snapresses", "output_snapourses", "outputfulsnapessions", "outputMemsples", "output_sresses", "output_genamples", "output_exages", "output_exents", "output_statannels", "output_Samps", "outputMemstatusutes", "output_consents", "output_exannels", "outputMemstatusamples"], "shift": ["step", "send", "skip", "Shift", "next", "head", "pack", "version", "pad", "seed", "start", "align", "slice", "count", "size", "scale", "index", "push", "hash", "set", "ref", "offset", "last", "hift", "pos", "mask"], "byte": ["bin", "unit", "value", "transfer", "pair", "command", "code", "bb", "channel", "b", "bytes", "field", "bit", "cmp", "io", "buffer", "binary", " bytes", "base", "mode", "word", "Byte", "address"], "diff": [" differences", "sb", " change", " difference", " reward", "err", " leftover", " dist", " direction", "command", "result", "mix", " seed", "Diff", " Diff", " remaining", " distance", "cmp", " dev", "Delta", " err", " delta", " differential", " desc", " step", "iff", " compare", "error"], "out": ["or", "ot", "no", "co", "x", "list", "on", "off", "timeout", "high", "course", "cmd", "outs", "i", "ou", "id", "output", "end", "ind", "ver", "obj", "vert", "new", "all", "ex", "at", "after", "o", "over", "size", "ne", "external", "nt", "pool", "bound", "iter", "net", "server", "index", "ch", "to", "set", "max", "sys", "oe", "it", "Out", "t", "num", "pos", "chain", "outer", "status", "batch", "con", "point", "port", "up", "OUT", "client", "by", "ins"], "channel_number": [" Channel_document", "connectionitynumber", "batch_number", " channel_position", "connectionitystatus", "channel_class", "secondationnumber", "channel_Number", "batch_integer", "channel_reference", "channelxversion", "chatennumber", "chatendocument", "channelityclass", "channelationclass", "byteitynumber", "channel_integer", "resourceynumber", "channel_index", "channelennumber", "byteityindex", "channelitydevice", "channelitystatus", "byte_reference", "channel_device", "channel_note", " Channel_number", "channelygroup", "channelendocument", "resource_group", "channelendevice", "second_number", "channel_status", "chatendirectory", "channelernumber", "chat_number", "channelityindex", "connection_class", "connection_status", "batchityinteger", "byteityreference", "channelynumber", "secondationversion", "batch_negative", "resource_variable", " Channel_volume", "connection_number", "channelxnumber", "button_cmp", " channel_Number", "channel_version", "channelitymaximum", "channelxNumber", "channel_variable", "channel_group", "channel00collection", "channelxposition", "second_collection", "channelitynumber", "channelitydirectory", "connectionityclass", "channelitydocument", "channel_collection", "chat_device", " Channel_class", "byte_index", "channelityname", "resource_number", "channelationversion", "chat_directory", "second_version", "byteityname", "resourceynote", "channelityreference", "channelationstatus", "connection_maximum", "byte_name", "channel_cmp", "channelationcollection", "channel00version", "channel00class", "channelendirectory", "resourceygroup", "batchitynegative", "byte_number", "channel_negative", "connectionitymaximum", "chat_document", "channelyvariable", "channelationnumber", "batch_reference", "channelernegative", "channelationmaximum", "channelitynegative", "channel_position", "resource_note", "secondationclass", "secondationcollection", "channel_document", "second_class", "batchitynumber", "channelerreference", "batchityreference", "channelynote", "channel_volume", "button_raw", "channelityinteger", "channel_raw", "channel_maximum", "channelerinteger", " channel_version", "channel_name", "channel00number", "channel_directory", "chatendevice", "resourceyvariable"]}}
{"project": "FFmpeg", "commit_id": "03abf55f252945c70f4a79eaf4d609cee4d98710", "target": 1, "func": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n\n                              AVStream *st, RMStream *rst,\n\n                              unsigned int codec_data_size, const uint8_t *mime)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    if (codec_data_size > INT_MAX)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n\n\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n\n        int number_of_streams = avio_rb16(pb);\n\n        int number_of_mdpr;\n\n        int i;\n\n        for (i = 0; i<number_of_streams; i++)\n\n            avio_rb16(pb);\n\n        number_of_mdpr = avio_rb16(pb);\n\n        if (number_of_mdpr != 1) {\n\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n\n        }\n\n        avio_rb32(pb);\n\n        v = avio_rb32(pb);\n\n    }\n\n\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n\n        int stream_count, rule_count, property_count, i;\n\n        ff_free_stream(s, st);\n\n        if (avio_rb16(pb) != 0) {\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n\n            goto skip;\n\n        }\n\n        stream_count = avio_rb16(pb);\n\n        avio_skip(pb, 6*stream_count);\n\n        rule_count = avio_rb16(pb);\n\n        avio_skip(pb, 2*rule_count);\n\n        property_count = avio_rb16(pb);\n\n        for(i=0; i<property_count; i++){\n\n            uint8_t name[128], val[128];\n\n            avio_rb32(pb);\n\n            if (avio_rb16(pb) != 0) {\n\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n\n                goto skip; //FIXME skip just this one\n\n            }\n\n            get_str8(pb, name, sizeof(name));\n\n            switch(avio_rb32(pb)) {\n\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n\n                av_dict_set(&s->metadata, name, val, 0);\n\n                break;\n\n            default: avio_skip(pb, avio_rb16(pb));\n\n            }\n\n        }\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        if (fps > 0) {\n\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n\n                      0x10000, fps, (1 << 30) - 1);\n\n#if FF_API_R_FRAME_RATE\n\n            st->r_frame_rate = st->avg_frame_rate;\n\n#endif\n\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 9301, "substitutes": {"s": ["ts", "p", "h", "sb", "ats", "rs", "sa", "ls", "sp", "ss", "es", "ps", "gs", "sts", "sq", "src", "sv", "a", "b", "fs", "ans", "os", "sn", "scl", "sg", "sys", "ctx", "stats", "ds", "m", "c", "t", "sc", "pkg", "cs", "e", "bs", "w", "ns"], "pb": ["p", "cb", "pl", "sb", "snap", "span", "np", "wp", "proc", "tc", "lp", "um", "pp", "typ", "nb", "sp", "tp", "ob", "pg", "bp", "emb", "pt", "ps", "bj", "uf", "tk", "erb", "bb", "eb", "ub", "rob", "fb", "patch", "ib", "cv", "buf", "cp", "PB", "tmp", "peer", "pool", "buff", "b", "td", "pa", "tab", "pm", "ctx", "wb", "mp", "txt", "stab", "sc", "db", "rb", "resp", "pkg", "asm", "pc", "vp", "lb", "bs", "jp"], "st": ["r", "ts", "p", "step", "art", "sta", "sb", "nd", "sw", "ft", "std", "sh", "sp", "ast", "stat", "ste", "stan", "stru", "pt", "ST", "ct", "str", "usr", "start", "stop", "ust", "tt", "interface", "sts", "th", "nt", "store", "put", "sv", "src", "St", "ost", "sl", "inst", "td", "mt", "rest", "act", "ut", "tx", "sn", "rt", "set", "ctx", "so", "t", "stage", "stab", "sc", "et", "stable", "est", "ist", "se", "storage"], "rst": ["arsw", "mst", "rstable", "rsw", "lST", "lstable", " rsw", "arss", "arsp", "rss", "msp", "arst", "lst", "lnd", "rST", " rss", "wnd", "rrnd", "wST", "rrST", "rnd", "wst", "msw", "rrst", "wstable", "mss", "rrstable", "rsp", " rsp"], "codec_data_size": ["codec_data_len", "codec_dataitylength", "codec_no_len", "codec_data_ize", "codec_no_size", "codec_dataitycode", "codec_data_SIZE", "codec_dataitysize", "codec_no_SIZE", "codec_data_length", "codec_data_code", "codec_no_ize"], "mime": ["cmimes", "nmixed", "mIME", "emIME", "mesh", " mip", "emimes", "MIME", "cmIME", "mimes", "Mime", "cmesh", "nmesh", "Mim", " mesh", "Mimes", "cmip", "Mip", " mIME", "cmixed", "mim", "cmime", "emim", "mip", "emime", "nmIME", "mixed", "nmime", " mixed", " mimes", " mim"], "v": ["p", "av", "h", "inv", "ev", "value", "rev", "f", "vol", "qu", "vr", " av", "version", "l", "ver", "j", "env", "qv", "vert", "vm", "va", "u", "cv", "ve", " V", "sv", "vt", "ov", "b", "vv", "g", "tv", "mint", "var", "iv", "y", "q", "vi", "V", "m", "uv", "c", "t", "nov", "nv", "valid", "vs", "lv", "vp", "vc", "k", "w", "conv"], "size": ["mem", "type", "sp", "format", "l", "n", "total", "count", "area", "g", "si", "Size", "scale", "sn", "set", "offset", "ize", "c", "m", "t", "len", "sum", "message", "e", "SIZE", "length"], "codec_pos": ["codoc_ref", "codEC_position", "codec__pos", "codEC_loc", "codec__loc", "codEC_pos", "codec_ref", "codec_pose", "codec_position", "codec_offset", "codoc_pos", "codec__pose", "codec_Pos", "codec__position", "codEC_pose", "codoc_Pos", "codec_loc", "codoc_offset"], "ret": ["pret", "RET", "mel", "final", "mem", "value", "ft", "rev", "f", "err", "cont", "success", " Ret", "re", "ef", "result", "gt", "Ret", "ez", "rem", "out", "nt", "over", "rets", "not", "back", "print", "mb", "def", "tr", "elt", "rt", "ref", "tf", "inter", "it", "txt", "t", "ber", "len", "res", "status", "ll", "resp", "alt", "ter"], "number_of_mdpr": ["number_of_mdPR", "number_of_MDpr", "number_of_dPr", "number_of_ndpr", "number_of_dpr", "number_of_mdps", "number_of_mpr", "number_of_mbr", "number_of_mdPr", "number_of_dps", "number_of_ndbr", "number_of_mmpr", "number_of_mondporter", "number_of_ndporter", "number_of_mdporter", "number_of_MDporter", "number_of_MDPR", "number_of_dPR", "number_of_mdbr", "number_of_mPR", "number_of_mmPr", "number_of_mmps", "number_of_MDbr", "number_of_mondpr", "number_of_mondPR", "number_of_ndPR", "number_of_ndps", "number_of_mmPR", "number_of_ndPr"], "i": ["ui", "di", "p", "cli", "x", "init", "f", "gi", "ic", "ai", "ind", "l", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", "ex", "multi", "bi", "n", "in", "is", "g", "hi", "print", "si", "uu", "li", "info", "y", "ini", "q", "gu", "it", "ci", "m", "c", "chain", "zi", "mi", "ip", "qi", "ti", "im", "pi", "e", "me", "sql", "us"]}}
{"project": "qemu", "commit_id": "abda1f37eed86f3501db2e5439c1a7b97171ea22", "target": 1, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status &= ~COM_CRC_ERROR;\n\n        return 0;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n    if (sd->card_status & ILLEGAL_COMMAND)\n\n        rsplen = 0;\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 9330, "substitutes": {"sd": ["sb", "nd", "sh", "gd", "ind", "sm", "des", "south", "sv", "d", "sam", "def", "sys", "js", "reg", "ad", "db", "se", "sw", "ard", "dd", "std", "cd", "sky", "ess", "sl", "sg", "ds", "ssl", "draw", "sc", "sk", "decl", "san", "and", "send", "sta", "bd", "sa", "sp", "sing", "rh", "sim", "store", "server", "md", "sec", "s", "sn", "style", "vd", "sql", "mod", "di", "ld", "dist", "dev", "od", "ma", "df", "dll", "ss", "SD", "cond", "dl", "hd", "pd", "service", "td", "form", "si", "dk", "fd", "amd", "dis", "ell", "sy"], "req": ["r", "ack", "pro", "dist", "inv", "qq", "conf", "seq", "proc", "request", "exec", "iq", "ind", "compl", "rec", "needed", "ps", "crit", "j", "query", "fr", "cond", "usr", "comm", "qt", "sq", "config", "md", "need", "sec", "esp", "rest", "push", "required", "ext", "urg", "tx", "desc", "q", "ref", "js", "reset", "reg", "ctx", "quest", "this", "requ", "Request", "res", "rb", "resp", "pkg", "aux", "client", "spec", "msg", "jp", "cmd"], "response": ["r", "send", "no", "sol", "vector", "value", "next", "tree", "request", "v", "amount", "json", "success", "de", "sp", "frame", "output", "data", "connection", "then", "entry", "command", "result", "image", "question", "window", "respons", "Response", "application", "error", "reply", "all", "example", "rss", "out", "ve", "des", "service", "form", "relation", "def", "definition", "style", "sequence", "reset", "yes", "pos", "res", "block", "given", "resp", "memory", "description", "message", "onse", "e", "answer"], "rtype": ["rtry", "righttype", "rmtype", "arype", "dTYPE", "ertry", "rpe", "erype", "Rpart", "rcolor", "erTYPE", "aircolor", "rmtyp", "mrpart", "erpe", "dtyp", "rightype", "rtyp", "Rrule", "RType", "dcolor", "airtype", "rype", "rmTYPE", "ertype", "Rtype", "mrtype", "rmpart", "artype", "Rype", "rpart", "righttry", "rrule", "rightpe", " rrule", " rype", "rType", "airTYPE", "RTYPE", "arType", "Rtyp", "ercolor", " rType", " rtry", "mrtyp", "arrule", "dtype", "rTYPE", " rpe", "ertyp", "airtyp", "mrTYPE"], "rsplen": ["rospluglen", "rossplel", "rspelen", "rsipllen", "rsplugatten", "rospllen", "gessplenc", "rsiplun", "rsplerest", "ricsplerlen", "rspleren", "upsplen", "rosspln", "rsplure", "rsreplen", "upssplresh", "upsplest", "csplenum", "rsplerresh", "rsplree", "rssplenum", "rsprens", "ricsplree", "rsreplef", "rspalure", "adssplenum", "rspleruf", "rsPln", "adssplef", "adssplure", "rsplef", "rsPlah", "rossplen", "rspalest", "rsplener", "rsplerenum", "versplerens", "rsclun", "gesploen", "rosplugen", "gesplen", "rspalenc", "gesplenc", "rssplure", "rsplerener", "rspalen", "rosplen", "rsimplener", "rsplest", "rspln", "rsplereng", "rssplen", "rsplend", "rsplugen", "upssplen", "upspleng", "rsprend", "rssplatten", "ricspleruf", "adsplef", "rsPlel", "rosplenum", "rsprel", "versplen", "verspleren", "rsimplens", "adssplen", "rsplun", "versplener", "rosplugatten", "rsplerend", "gessploen", "rspaloen", "gessplen", "rsplerens", "cspalun", "rspleroen", "rspleratten", "versplens", "rsplerenc", "rspalef", "rsplatten", "rsplerree", "ricsplen", "csplen", "rsclenum", "rspluglen", "rspluf", "adsplen", "rsperee", "rsprn", "rssploen", "rspalatten", "upsplresh", "rspeen", "rsplel", "rspeuf", "adsplure", "rsplens", "rosplugenum", "rspaleng", "versplerener", "rsiplenum", "gessplatten", "csplun", "gesplatten", "rsclen", "rsprener", "versplend", "versplerend", "rsspln", "rspalenum", "rspallen", "cspalen", "rspersen", "rsplah", "rssplef", "rsplresh", "rosplatten", "rsspleng", "rsplenc", "rsreplenum", "rsperslen", "upsspleng", "rssplest", "rsPlen", "cspallen", "rspllen", "rssplresh", "rsplerlen", "cspalenum", "rsimplend", "cspllen", "rossplah", "ricspllen", "rspalresh", "ricspluf", "rsploen", "rssplel", "upssplest", "rspersree", "ricsplerree", "rospln", "rspleng", "rssplah", "rosplah", "rsprah", "rspren", "rspalun", "rsimplen", "rsplugenum", "rsplenum", "rsiplen", "rosplel", "ricspleren", "rsreplure", "rscllen", "rspeatten", "rspersuf", "rspeenum", "adsplenum", "rssplenc"]}}
{"project": "FFmpeg", "commit_id": "76db17dc7d4f19f9a03bdd6de79c2ea37b76888f", "target": 0, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DPCMContext *s = avctx->priv_data;\n\n    int in, out = 0;\n\n    int predictor[2];\n\n    int ch = 0;\n\n    int stereo = s->channels - 1;\n\n    short *output_samples = data;\n\n    int shift[2];\n\n    unsigned char byte;\n\n    short diff;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    // almost every DPCM variant expands one byte of data into two\n\n    if(*data_size/2 < buf_size)\n\n        return -1;\n\n\n\n    switch(avctx->codec->id) {\n\n\n\n    case CODEC_ID_ROQ_DPCM:\n\n        if (stereo) {\n\n            predictor[0] = buf[7] << 8;\n\n            predictor[1] = buf[6] << 8;\n\n        } else {\n\n            predictor[0] = AV_RL16(&buf[6]);\n\n        }\n\n        SE_16BIT(predictor[0]);\n\n        SE_16BIT(predictor[1]);\n\n\n\n        /* decode the samples */\n\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n\n            predictor[ch] += s->roq_square_array[buf[in]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n\n\n    case CODEC_ID_INTERPLAY_DPCM:\n\n        in = 6;  /* skip over the stream mask and stream length */\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0])\n\n        output_samples[out++] = predictor[0];\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1])\n\n            output_samples[out++] = predictor[1];\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            predictor[ch] += interplay_delta_table[buf[in++]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n\n\n        break;\n\n\n\n    case CODEC_ID_XAN_DPCM:\n\n        in = 0;\n\n        shift[0] = shift[1] = 4;\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0]);\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1]);\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            byte = buf[in++];\n\n            diff = (byte & 0xFC) << 8;\n\n            if ((byte & 0x03) == 3)\n\n                shift[ch]++;\n\n            else\n\n                shift[ch] -= (2 * (byte & 3));\n\n            /* saturate the shifter to a lower limit of 0 */\n\n            if (shift[ch] < 0)\n\n                shift[ch] = 0;\n\n\n\n            diff >>= shift[ch];\n\n            predictor[ch] += diff;\n\n\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n    case CODEC_ID_SOL_DPCM:\n\n        in = 0;\n\n        if (avctx->codec_tag != 3) {\n\n            if(*data_size/4 < buf_size)\n\n                return -1;\n\n            while (in < buf_size) {\n\n                int n1, n2;\n\n                n1 = (buf[in] >> 4) & 0xF;\n\n                n2 = buf[in++] & 0xF;\n\n                s->sample[0] += s->sol_table[n1];\n\n                if (s->sample[0] < 0)   s->sample[0] = 0;\n\n                if (s->sample[0] > 255) s->sample[0] = 255;\n\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n\n                s->sample[stereo] += s->sol_table[n2];\n\n                if (s->sample[stereo] < 0)   s->sample[stereo] = 0;\n\n                if (s->sample[stereo] > 255) s->sample[stereo] = 255;\n\n                output_samples[out++] = (s->sample[stereo] - 128) << 8;\n\n            }\n\n        } else {\n\n            while (in < buf_size) {\n\n                int n;\n\n                n = buf[in++];\n\n                if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F];\n\n                else s->sample[ch] += s->sol_table[n & 0x7F];\n\n                s->sample[ch] = av_clip_int16(s->sample[ch]);\n\n                output_samples[out++] = s->sample[ch];\n\n                /* toggle channel */\n\n                ch ^= stereo;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    *data_size = out * sizeof(short);\n\n    return buf_size;\n\n}\n", "idx": 9343, "substitutes": {"avctx": ["wavctx", "wavtx", "vrtx", "wavctl", "avtx", " avconn", "avecmp", "Avpkg", "wavcmp", "vrcc", "vrcmp", "AVcontext", "AVconn", "avcc", "avectl", "avcmp", "Avctx", " avcontext", "AVcc", "AVpkg", "AVcmp", "wavcc", "Avconn", "vrctx", "AVctx", "Avcontext", "avetx", "avpkg", "avctl", "avcontext", "avectx", "AVctl", "avconn", "AVtx", " avpkg"], "data": ["p", "DATA", "value", "bin", "next", "type", "ata", "frame", "frames", "pad", "padding", "Data", "sample", "map", "feed", "window", "content", "raw", "array", "size", "a", "area", "d", "video", "values", "bytes", "cache", "dat", "to", "empty", "package", "input", "ref", "text", "t", "bits", "buffer", "body", "pos", "batch", "block", "table", "message", "stream", "mu", "w", "image", "length", "zero"], "data_size": ["data_ize", "buf_length", "buf_SIZE", " data_ize", "buf_Size", " data_Size", "buf_size", "data_Size", "data_SIZE", " data_SIZE", "data_length"], "avpkt": [" avpacket", "avnpnt", "avPacket", "avppnt", "avPac", "afcpck", " avcpcmd", "avpck", "avppacket", " avpct", "avcpkt", "avbpkt", "afcpdu", "avbpacket", "avcpacket", "avcompct", "avPkt", "afpkt", " avcpac", " avpix", "afpnt", "avcpnt", "avbpcmd", " avcpix", "avnpck", "avcompkt", "avcpck", "avpix", "avppdu", " avcpkt", "avppcmd", " avcpacket", "avcompacket", "avcpdu", "avpdu", "avnpkt", "avpac", "avppix", "afcpnt", "avcompac", "avpct", "avpacket", " avpcmd", "avnpdu", "avpcmd", "avcpac", "avcpix", "avpnt", " avcpct", "avbpix", "avppkt", "avppck", "afpck", "avcpcmd", " avpac", "afcpkt", "avcpct", "avPct", "afpdu"], "buf": ["r", "p", "func", "boxes", "cb", "font", "vals", "aka", "seq", "proc", "mem", "mat", "cap", "ff", "v", "args", "pb", "cam", "pack", "emb", "cur", "uf", "map", "deg", "window", "bl", "mates", "bag", "cv", "docs", "tmp", "config", "bh", "buff", "b", "bytes", "cache", "dat", "tr", "tab", "var", "late", "arr", "que", "tx", "queue", "desc", "fx", "Buff", "ctx", "vec", "br", "req", "wb", "txt", "prop", "buffer", "batch", "rb", "db", "pkg", "words", "aux", "doc", "bs", "Buffer", "img", "conv", "cmd"], "s": ["r", "ts", "p", "h", "sb", "rs", "i", "v", "ls", "ss", "ps", "gs", "j", "sts", "sq", "a", "sv", "g", "b", "d", "is", "os", "set", "sys", "js", "ctx", "hs", "ds", "ssl", "stats", "m", "c", "S", "t", "sc", "vs", "cs", "spec", "w", "ns"], "in": ["rin", "update", "x", "no", "bin", "ind", "inn", "en", "ix", "index", "min", "pin", "c", "t", "len", "row", "up", "k", "el", "w", "ins", "on", "head", "ic", "name", "new", "all", "scan", "win", "IN", "act", "In", "it", "mi", "inner", "p", "al", "init", "um", "i", "id", "l", "isin", "window", "inc", "ex", "at", "inside", "oin", "o", "iter", "is", "gin", "ini", "input", "chain", "con", "r", "from", "v", "ai", "add", "loop", "din", "local", "m", "pos", "im"], "predictor": ["priptory", "pictoring", "posteriler", "pictionler", "pictionoring", "puppetoring", "pictedOR", "spredictori", "pingredictoring", "predictors", "predictive", "pocolorb", "ppector", "prosteriler", "priptOR", "predictior", "posterion", "patredictor", "putecor", "practoring", "ppecticator", "prredictOR", "ppredicator", "tpredictlor", "prpector", "pocoling", " predictorb", "prictionoring", "pointOR", " predictcor", "ppredier", "predictuser", "prpectator", "predicting", "paramprioring", "predictory", "propredictable", "tpictor", "prredictable", "pictionor", "posteruser", "ppriorable", "peterminiler", "puppetlor", "pjector", "pingredictter", "pointors", "ppredOR", "pveyior", "predictoring", "ppriOR", "expprioring", "puppetler", "spredictcer", "exppriator", "practator", "patriptory", "tpictoring", "spuppetcer", "predictee", "pocolor", "propointor", "prredicting", "posterory", "ppectmor", "predictmor", "peterminor", "potator", "puteors", "prpectee", "predictator", "expredictor", "predictiler", "puppetori", "paramprior", "propointior", "propointOR", "pingredictor", "postercer", "propointicator", "patriptler", "puppetor", "puppetier", "tpredictler", "prictionor", "tpictler", "pjectori", "spuppetor", "proppredor", "patredicticator", "posterutor", "prredictor", "pveyicator", "pointori", "predictlor", "posteroring", "posterive", "pictOR", "posteror", "pveyutor", "ppredory", "expredictator", "exppredractor", "pingpriter", "predictable", "ppredractor", "propredictior", "ppricer", "ppectier", "predicticator", "ppredutor", "potor", "predictessor", "pprioring", "pictioning", "postericator", "propredictutor", "prpectier", "ppectee", " ppectored", "sprediction", "expredictoring", "puteor", "predictori", "prpectOR", "pveyor", "proppredable", " predictessor", "potutor", "pointior", "prpecticator", "pjectutor", "pictionive", "pjectoring", "predictractor", "pocolOR", "practor", "expredictutor", "ppredessor", "exppredator", "exppredor", "ppredator", "puteori", "spuppetion", " ppectmor", "pictor", " ppectorb", "puppetutor", "prictionable", "peterminive", "pingosteroring", "pocolutor", "ppredee", "predictorable", "puppetcer", "ppriter", "ppredable", "puppetion", "prictioning", "puppetee", "paramredictcer", "propredictessor", " predictmor", "pjectessor", "patriptor", "paramredictor", "priptessor", "posterori", "prredictessor", "pictedor", "pictessor", "pveycer", "pingredictutor", "pictedmor", "expprior", "pjectorable", "spuppetori", "peterminuser", " predictori", " ppectOR", "pictionmor", "pveyOR", "potractor", "paramredictOR", "ppectored", "paramredictoring", "pictcer", "ppriator", "pocolable", "pjectable", "spredictor", "pprior", "pjectter", "priptorb", "pocoloring", "pingprior", "exppriorable", "pjectcer", "pictioniler", "pictionored", "tpredictor", "pectable", "predictier", "pingosterutor", "propredictor", "prosterive", "pingosteror", " ppectessor", "pictionuser", "prredictator", "pveyter", "posteressor", "parampricer", " predictOR", "tpictlor", "predictler", "pingredictOR", "predictcer", "pjection", "pecting", "pictionable", "pictlor", "pictator", "predictutor", "predictcor", "pocolractor", "proppredessor", "pingpriOR", "priptler", "ppredler", "ppectOR", "prosteror", "ppriutor", "posterator", "pictler", "ppredor", "propredicticator", "prredictee", "pingredictior", "pingpriutor", "predictter", "prredictoring", "prredicticator", "proppredutor", "ppectorb", "pictionOR", "exppredutor", "pjectOR", "prredictier", "prediction", "patripticator", " predictored", "pointicator", "pocolessor", "picticator", "patredictler", "pjectator", "prredictuser", "puppetOR", "priptor", "prredictiler", "tpredictoring", "patredictory", "expredictractor", "predictorb", "ppectator", " ppector", "pictedored", "prpectessor", "predictored", "ppectessor", "pveyoring", "pripticator", " predictors", "ppectior", "predictOR", "propredictOR", "pictionlor", "pector", "pingosterior", "puppetior", "posterler", "prosteruser", "expredictorable", "posterior", "pocolator", "pectoring", "parampriOR", "pointcor", "practorable", "pointor", "prredictive"], "output_samples": ["output_nsamples", "output_exonents", "output___sonents", "output_insonents", "output___itsages", "output___insns", "output_sents", "output_examples", "output_itsonents", "output_itsages", "output_nources", "output___sages", "output_consamples", "output_nents", "output_swamples", "output_sages", "output_namples", "output_swages", "output_swides", "output_sonents", "output_itsides", "output_samps", "output_Samples", "output_timesessions", "output_statns", "output_swonents", "output_consonents", "output_namps", "output_statamples", "output_timesams", "output___sides", "output___insents", "output___sents", "output_sns", "output_sams", "output_sources", "output___sns", "output_scamples", "output_nsources", "output_Sams", "output_statents", "output_consages", "output_insns", "output_exns", "output___samples", "output_statonents", "output_timesamples", "output_Sessions", "output_scessions", "output_consides", "output___insonents", "output_nsents", "output_sessions", "output_sides", "output___itsonents", "output___itsamples", "output_insamples", "output_itsamples", "output_insents", "output___itsides", "output_exents", "output_nsamps", "output___insamples", "output_scams"], "shift": ["step", "send", "Shift", "next", "pack", "version", "seed", "map", "start", "align", "slice", "count", "pointer", "scale", "transform", "index", "push", "set", "hash", "ref", "offset", "hift", "power", "pos", "ptr"], "byte": ["pixel", "bin", "link", "transfer", "de", "version", "command", "code", "bb", "channel", "b", "bytes", "field", "attribute", "bit", "cmp", "io", "buffer", "binary", " bytes", "base", "iff", "mode", "word", "Byte"], "diff": [" differences", " change", " difference", "err", " dist", " mix", " direction", "command", "mix", "Diff", " Diff", " difficulty", "change", " remaining", "d", " distance", "desc", "cmp", " dev", " err", " delta", " differential", " desc", " step", "iff", " mismatch", " compare", "error"], "out": ["p", "or", "ot", "x", "co", "no", "list", "off", "timeout", "conn", "course", "outs", "i", "ou", "v", "un", "chan", "id", "output", "ind", "end", "l", "inn", "j", "boot", "vert", "new", "parent", "all", "ex", "at", "o", "nt", "size", "over", "pool", "obj", "bound", "external", "b", "net", "index", "to", "bit", "set", "max", "it", "dis", "Out", "io", "t", "pos", "chain", "outer", "batch", "point", "can", "up", "OUT", "client", "cmd"], "ch": ["p", "cb", "h", "x", "ot", "cha", "cr", "high", "ech", "gh", "cmd", "i", "v", "cm", "ih", "chan", "sh", "ck", "cur", "z", "chi", "cell", "l", "height", "j", "cl", "th", "key", "channel", "tch", "cht", "cor", "chn", "cp", "count", "b", "chrom", "history", "ht", "kh", "wh", "ach", "y", "q", "och", "br", "c", "sch", "cy", "chain", "sc", "batch", "chip", "CH", "cho", "row", "Ch", "cs", "col", "k", "vc", "ich"]}}
{"project": "FFmpeg", "commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 9347, "substitutes": {"s": ["r", "ts", "p", "less", "session", "fps", "h", "span", "ses", "rs", "se", "i", "f", "v", "ls", "ss", "es", "ps", "gs", "sim", "comm", "ops", "sts", "space", "n", "sq", "sf", "fs", "sv", "service", "is", "b", "eps", "ins", "os", "js", "sys", "ctx", "hs", "ds", "m", "c", "S", "t", "sc", "spec", "cs", "e", "ims", "ms", "qs", "scope", "ns"], "frame": ["scene", "ace", "show", "feature", "f", "type", "frames", "object", "sample", "fr", "window", "rame", "picture", "movie", "process", "slice", "line", "zone", "Frame", "load", "file", "form", "video", "render", "one", "stroke", "view", "set", "sequence", "face", "ce", "c", "profile", "iframe", "t", "ence", "framework", "source", "point", "context", "word", "state", "image", "screen", "ze"], "value": ["r", "p", "ue", "vector", "type", "v", "number", "data", "function", "name", "version", "command", "map", "VALUE", "position", "window", "shift", "val", "key", "array", "Value", "total", "size", "time", "values", "scale", "index", "field", "view", "set", "variable", "sequence", "m", "weight", "text", "buffer", "sum", "memory", "action", "message", "vp", "expression", "state", "image", "length"], "run": ["r", "cycle", "step", "seq", "running", "fun", "job", "un", "flow", "pair", "z", "name", "call", "image", "lock", "ran", "thread", "order", "process", "record", "range", "n", "line", "loop", "work", "index", "ur", "plot", "try", "set", "q", "go", "force", "task", "draw", "num", "len", "batch", "block", "row", "con", "runs", "pass", "length", "Run", "ride", "error", "cmd"], "x": ["p", "step", "al", "X", "dx", "xy", "px", "i", "v", "id", "data", "z", "length", "l", "axis", "xs", "ox", "xi", "height", "position", "depth", "ix", "ex", "line", "n", "wx", "size", "ax", "index", "path", "tx", "pan", "q", "lat", "offset", "m", "yx", "t", "pos", "mask", "row", "e", "client", "k", "image", "grid", "w", "color", "xx"], "y": ["p", "ny", "py", "h", "ies", "xy", "uy", "i", "type", "v", "vy", "z", "height", "sky", "page", "ys", "angle", "ey", "ty", "key", "iy", "n", "o", "size", "a", "b", "my", "yy", "ch", "try", "axy", "Y", "iny", "ya", "yt", "ay", "lat", "sys", "m", "c", "cy", "t", "hot", "base", "sy", "table", "row", "ye", "entity", "rot", "gy"], "plane": ["p", "limit", "layout", "spin", "flat", "cube", "type", "mate", "flow", "id", "pose", "pe", "axis", "angle", "depth", "shift", "key", "slice", "line", "piece", "ane", "ve", "zone", "panel", "cone", "plot", "dim", "goal", "board", "stroke", "late", "offset", "sequence", "pin", "pen", "half", "gate", "mask", "port", "side", "mode", "planes", "cut", "profile", "se", "scope", "lane"], "bits_per_plane": ["bits_per_planes", "bits_per__plane", "bits_per__pen", "bits_PER_planes", "bits_PER_factor", "bits_per__planes", "bits_PER_position", "bits_per_pen", "bits_PER_plan", "bits_per_factor", "bits_per__position", "bits_per_position", "bits_PER_panel", "bits_per_panel", "bits_per_pose", "bits_PER_plane", "bits_PER_pen", "bits_PER_pose", "bits_per_plan"], "d": ["r", "di", "p", "dc", "h", "dr", "bd", "D", "f", "i", "v", "du", "dd", "dm", "data", "z", "l", "dict", "dt", "u", "n", "o", "da", "b", "g", "dh", "dat", "dim", "fd", "q", "ds", "m", "c", "t", "ad", "db", "w"], "j": ["r", "p", "step", "aj", "oj", "jj", "i", "jc", "v", "json", "job", "jump", "jit", "z", "ind", "l", "bj", "ji", "other", "shift", "at", "out", "n", "o", "obj", "ja", "b", "g", "kj", "jo", "ch", "_", "q", " jump", "js", "J", "it", "m", "t", "jl", "ij", "dj", "uj", "k", "el", "jp"]}}
{"project": "FFmpeg", "commit_id": "aaf78e4d14b4875e4cff30e979421a1087337b9f", "target": 1, "func": "mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){\n\n    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));\n\n  mp_image_t* mpi=NULL;\n\n  int w2;\n\n  int number = mp_imgtype >> 16;\n\n\n\n  av_assert0(vf->next == NULL); // all existing filters call this just on next\n\n\n\n  //vf_dint needs these as it calls vf_get_image() before configuring the output\n\n  if(vf->w==0 && w>0) vf->w=w;\n\n  if(vf->h==0 && h>0) vf->h=h;\n\n\n\n  av_assert0(w == -1 || w >= vf->w);\n\n  av_assert0(h == -1 || h >= vf->h);\n\n  av_assert0(vf->w > 0);\n\n  av_assert0(vf->h > 0);\n\n\n\n  av_log(m->avfctx, AV_LOG_DEBUG, \"get_image: %d:%d, vf: %d:%d\\n\", w,h,vf->w,vf->h);\n\n\n\n  if (w == -1) w = vf->w;\n\n  if (h == -1) h = vf->h;\n\n\n\n  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;\n\n\n\n  // Note: we should call libvo first to check if it supports direct rendering\n\n  // and if not, then fallback to software buffers:\n\n  switch(mp_imgtype & 0xff){\n\n  case MP_IMGTYPE_EXPORT:\n\n    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.export_images[0];\n\n    break;\n\n  case MP_IMGTYPE_STATIC:\n\n    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[0];\n\n    break;\n\n  case MP_IMGTYPE_TEMP:\n\n    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.temp_images[0];\n\n    break;\n\n  case MP_IMGTYPE_IPB:\n\n    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:\n\n      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n      mpi=vf->imgctx.temp_images[0];\n\n      break;\n\n    }\n\n  case MP_IMGTYPE_IP:\n\n    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];\n\n    vf->imgctx.static_idx^=1;\n\n    break;\n\n  case MP_IMGTYPE_NUMBERED:\n\n    if (number == -1) {\n\n      int i;\n\n      for (i = 0; i < NUM_NUMBERED_MPI; i++)\n\n        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)\n\n          break;\n\n      number = i;\n\n    }\n\n    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;\n\n    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h);\n\n    mpi = vf->imgctx.numbered_images[number];\n\n    mpi->number = number;\n\n    break;\n\n  }\n\n  if(mpi){\n\n    mpi->type=mp_imgtype;\n\n    mpi->w=vf->w; mpi->h=vf->h;\n\n    // keep buffer allocation status & color flags only:\n\n//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);\n\n    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;\n\n    // accept restrictions, draw_slice and palette flags only:\n\n    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);\n\n    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;\n\n    if(mpi->width!=w2 || mpi->height!=h){\n\n//      printf(\"vf.c: MPI parameters changed!  %dx%d -> %dx%d   \\n\", mpi->width,mpi->height,w2,h);\n\n        if(mpi->flags&MP_IMGFLAG_ALLOCATED){\n\n            if(mpi->width<w2 || mpi->height<h){\n\n                // need to re-allocate buffer memory:\n\n                av_free(mpi->planes[0]);\n\n                mpi->flags&=~MP_IMGFLAG_ALLOCATED;\n\n                mp_msg(MSGT_VFILTER,MSGL_V,\"vf.c: have to REALLOCATE buffer memory :(\\n\");\n\n            }\n\n//      } else {\n\n        } {\n\n            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;\n\n        }\n\n    }\n\n    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);\n\n    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){\n\n\n\n        av_assert0(!vf->get_image);\n\n        // check libvo first!\n\n        if(vf->get_image) vf->get_image(vf,mpi);\n\n\n\n        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){\n\n          // non-direct and not yet allocated image. allocate it!\n\n          if (!mpi->bpp) { // no way we can allocate this\n\n              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,\n\n                     \"vf_get_image: Tried to allocate a format that can not be allocated!\\n\");\n\n              return NULL;\n\n          }\n\n\n\n          // check if codec prefer aligned stride:\n\n          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){\n\n              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&\n\n                         mpi->flags&MP_IMGFLAG_YUV) ?\n\n                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME\n\n              w2=((w+align)&(~align));\n\n              if(mpi->width!=w2){\n\n#if 0\n\n                  // we have to change width... check if we CAN co it:\n\n                  int flags=vf->query_format(vf,outfmt); // should not fail\n\n                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,\"??? vf_get_image{vf->query_format(outfmt)} failed!\\n\");\n\n//                printf(\"query -> 0x%X    \\n\",flags);\n\n                  if(flags&VFCAP_ACCEPT_STRIDE){\n\n#endif\n\n                      mpi->width=w2;\n\n                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n//                  }\n\n              }\n\n          }\n\n\n\n          mp_image_alloc_planes(mpi);\n\n//        printf(\"clearing img!\\n\");\n\n          vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);\n\n        }\n\n    }\n\n    av_assert0(!vf->start_slice);\n\n    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)\n\n        if(vf->start_slice) vf->start_slice(vf,mpi);\n\n    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){\n\n            mp_msg(MSGT_DECVIDEO,MSGL_V,\"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\\n\",\n\n                  \"NULL\"/*vf->info->name*/,\n\n                  (mpi->type==MP_IMGTYPE_EXPORT)?\"Exporting\":\n\n                  ((mpi->flags&MP_IMGFLAG_DIRECT)?\"Direct Rendering\":\"Allocating\"),\n\n                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?\" (slices)\":\"\",\n\n                  mpi->width,mpi->height,mpi->bpp,\n\n                  (mpi->flags&MP_IMGFLAG_YUV)?\"YUV\":((mpi->flags&MP_IMGFLAG_SWAPPED)?\"BGR\":\"RGB\"),\n\n                  (mpi->flags&MP_IMGFLAG_PLANAR)?\"planar\":\"packed\",\n\n                  mpi->bpp*mpi->width*mpi->height/8);\n\n            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\",\n\n                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],\n\n                mpi->stride[0], mpi->stride[1], mpi->stride[2],\n\n                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);\n\n            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;\n\n    }\n\n\n\n  mpi->qscale = NULL;\n\n  }\n\n  mpi->usage_count++;\n\n//    printf(\"\\rVF_MPI: %p %p %p %d %d %d    \\n\",\n\n//      mpi->planes[0],mpi->planes[1],mpi->planes[2],\n\n//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);\n\n  return mpi;\n\n}\n", "idx": 9349, "substitutes": {"vf": ["verma", "avp", "servaf", "svf", "ovfa", "wireg", "vef", "nvma", "svaf", "vfl", "viv", "vma", "vrf", "convfa", "vrfx", "ovF", "uvcf", "varf", "ffo", "vz", "vvcf", " vcf", "vev", "uvf", "vfg", "vmj", "invf", "ivF", "vfac", "wirecf", "vcz", "invfx", "vv", "vpfo", "vff", "convff", "visj", "uvfr", "vvfl", "vifo", "vfr", "uvxf", "vcaf", "servfl", "vp", "cvfx", "visf", "vccf", " vg", "vislf", "svl", "devfac", " vconf", "vcfl", "devxf", "vrv", "cvfa", "nvff", "vcr", "vfo", "nvf", "vframe", "envf", "vmlf", "vcl", "ivf", "ivxf", "svcf", " vl", "avfo", "verof", "vl", " vv", "uvfa", "devfg", "vvconf", "invr", "vb", "ivff", "vif", "vcfc", "vvff", "vfs", "vcframe", "varfac", " vaf", "varfr", "vof", " vxf", "verfl", "servfg", "vpconf", "nvfo", "vcb", " vz", "vfc", "envaf", "vvma", "ovma", "devff", "wirev", "vvxf", " vff", "ivof", "vifa", " vfo", "vrfc", "vF", "vaf", "vcxf", "wirefo", "vj", "invxf", " vr", "envfl", "vcfr", "wirefa", "servf", "uvF", "ivfr", " vfs", "uvma", "ivfo", "vrcf", "avfx", "wiref", "convf", "verf", "vcj", "vrz", "vvfo", "vcv", "cvcf", "vvf", "vmframe", "versionfx", "ivfc", "vrfo", "ivg", "vcfx", "uvv", "ovfo", "ivfs", "verfo", "avf", "ivfac", "visframe", "avfs", "cvfs", "cvp", "vfa", "wirefc", "versionf", "fcf", "ffc", "ovf", "vcff", "svfx", " vb", "vpcf", "devfr", "devfa", "wireff", "vcconf", "ff", "avcf", " vfx", "vlf", "vr", "cvf", "uvfc", "devf", "vmf", "ivfa", "nvaf", "versionconf", "vg", "versionxf", "vcf", "ovxf", "invconf", "nvfr", "vcfo", "vvfa", "vcma", "cvfo", "vefa", "uvfo", "envfg", "nvfa", "verfc", "devaf", " vp", "vpf", "cvv", "vcfa", "avfc", "avxf", "uvof", "vclf", " vfc", "invfc", "convaf", "verff", "uvfx", "vfx", "invb", "varxf", "svfo", "wirefs", "devfl", "vecf", " vfa", "vxf", "vconf"], "outfmt": ["out_lt", "outtno", "out_format", "out_no", "outtformat", "_flt", "outdmt", "_fno", "outfno", "outtlt", "outdformat", "outflt", "_dno", "out_mt", "_fmt", "outdno", "outfformat", "_dmt", "_fformat", "_dlt", "_dformat", "outdlt", "outtmt"], "mp_imgtype": ["mp_imagety", "mp_imagstyle", "mp_imageflag", "mp_imagtype", "mp_imgType", "mp_imgty", "mp_imtype", "mp_imtag", "mp_imagty", "mp_imagflag", "mp_imagtag", "mp_imagestyle", "mp_pgstyle", "mp_imty", "mp_imageType", "mp_imagetype", "mp_imgtag", "mp_imgstyle", "mp_imflag", "mp_pgType", "mp_pgtype", "mp_pgflag", "mp_imagetag", "mp_imagType", "mp_imType"], "mp_imgflag": ["mp_bglag", "mp_bgtype", "mp_alglag", "mp_imagFlag", "mp_imgFlag", "mp_imageflag", "mp__imagflags", "mp_imagtype", "mp__imgflag", "mp_bgflags", "mp__imagflag", "mp__imgtype", "mp__imgtag", "mp__imgflags", "mp_imaglag", "mp_imglag", "mp_imgflags", "mp_imagflag", "mp_imagtag", "mp_bgFLAG", "mp__imagtype", "mp_bgflag", "mp_imagetype", "mp_algFlag", "mp_imgtag", "mp__imagtag", "mp_imagFLAG", "mp_imgFLAG", "mp_bgFlag", "mp_bgtag", "mp_algflag", "mp_imagetag", "mp_algFLAG", "mp_imageflags", "mp_imagflags"], "w": ["r", "p", "wd", "x", "wall", "wp", "sw", "html", "f", "v", "wy", "wr", "z", "wi", "W", "l", "widget", "height", "ln", "wn", "en", "deg", "window", "th", "ex", "wx", "ew", " W", "a", "wl", "g", "d", "tw", "work", "ht", "b", "wh", "win", "iw", "ow", "ch", "y", "q", "wt", "wid", "wb", "wa", "weight", "power", "c", "rew", "nw", "kw", "rw", "ww", "we", "way", "aw", "word", "hw", "wal", "fw"], "h": ["r", "p", "hr", "high", "his", "html", "hp", "f", "v", "ih", "k", "sh", "hm", "pp", "z", "length", "end", "rh", "height", "l", "j", "hd", "phi", "depth", "hz", "th", "hw", "u", "n", "H", "count", "size", "bh", "b", "g", "oh", "hi", "history", "ht", "he", "wh", "ch", "ah", "ph", "kh", "ha", "y", "hl", "hh", "hash", "q", "uh", "hs", "it", "br", "c", "t", "eh", "hang", "hei", "hal", "zh", "host", "ho"], "m": ["r", "p", "mm", "em", "M", "v", "cm", "f", "k", "perm", "dm", "tm", "l", "am", "j", "n", "o", "sm", "tmp", "mut", "g", "b", "d", "fm", "gm", "pm", "ctx", "c", "mp", "mc", "t", "mi", "im", "man", "bm", "mn"], "mpi": ["pmit", "ppi", "mpci", "mta", "cpi", "mappi", "mapit", "mto", "mapci", "cmpi", "mpo", "pppi", "mppi", "mapo", "cmpit", "cmpis", "cpis", "pmis", "mti", "pmi", "capi", "pmI", "mpis", "ppit", "cmpa", "mapa", "cpI", "cmpI", "mpI", "mtit", "mapi", "mpa", "cmpo", "cappi", "ppci", "capci", "capit", "mpit", "cpit"], "w2": ["wt4", "rwlet", "rw4", "hw2", "wt2", " w4", "vSecond", "w4", "W1", "ew1", "wSecond", " w02", "w0", "wlet", " wlet", "wayTwo", "word2", "w02", "wtlet", "W02", "rw02", "ew0", "hw0", "waySecond", "vTwo", "v2", "w1", "W2", "wordTwo", "hw02", "wTwo", "wt0", "wordSecond", " w1", "W0", "ew02", "rw0", "rw2", "way2", "ew2", " w0"]}}
{"project": "FFmpeg", "commit_id": "e630ca5111077fa8adc972fe8a3d7e2b3e8dc91f", "target": 1, "func": "static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)\n\n{\n\n    Mp4Descr *descr = d->active_descr;\n\n    int predefined;\n\n    if (!descr)\n\n        return -1;\n\n\n\n    predefined = avio_r8(&d->pb);\n\n    if (!predefined) {\n\n        int lengths;\n\n        int flags = avio_r8(&d->pb);\n\n        descr->sl.use_au_start       = !!(flags & 0x80);\n\n        descr->sl.use_au_end         = !!(flags & 0x40);\n\n        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);\n\n        descr->sl.use_padding        = !!(flags & 0x08);\n\n        descr->sl.use_timestamps     = !!(flags & 0x04);\n\n        descr->sl.use_idle           = !!(flags & 0x02);\n\n        descr->sl.timestamp_res      = avio_rb32(&d->pb);\n\n                                       avio_rb32(&d->pb);\n\n        descr->sl.timestamp_len      = avio_r8(&d->pb);\n\n\n\n\n\n\n        descr->sl.ocr_len            = avio_r8(&d->pb);\n\n        descr->sl.au_len             = avio_r8(&d->pb);\n\n        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);\n\n        lengths                      = avio_rb16(&d->pb);\n\n        descr->sl.degr_prior_len     = lengths >> 12;\n\n        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;\n\n        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;\n\n    } else {\n\n        avpriv_report_missing_feature(d->s, \"Predefined SLConfigDescriptor\");\n\n\n    return 0;\n", "idx": 9351, "substitutes": {"d": ["r", "di", "p", "done", "dc", "ld", "dev", "dr", "nd", "dx", "bd", "D", "i", "v", "du", "dd", "de", "dm", "ind", "l", "cd", "j", "dl", "new", "dt", "debug", "n", "o", "pd", "da", "md", "b", "g", "did", "details", "s", "dh", "dat", "fd", "dim", "sd", "q", "dn", "ds", "m", "c", "t", "ed", "ad", "db", "e", "ord", "w", "rd", "mod"], "off": [" coff", " offset", " clen", "bf", "OFF", "ff", "from", "uts", " pos", "offer", "head", "uf", "oa", "obj", "begin", "ov", "offs", "Off", "of", "set", "ref", "offset", " start", " fo", "pos", " af", "ap", " Off"], "len": ["Length", "h", "seq", "ength", "cap", "ls", "Len", "sp", "length", "l", "lf", "ln", "en", " length", "val", "ail", "nl", "n", "size", "count", "enc", "bytes", "ref", "fin", "ll", "L", "el"], "descr": ["condral", "drawrer", "desrar", "derer", "descriptioncr", "descriptionr", "Descr", "scheadr", "descar", "descriptionpair", "regr", "portr", "colmr", "reflectral", " descrer", "commentrer", "escrs", "scher", "relR", "descrc", "descrer", "descpair", "escor", "ecr", "escrt", "portrb", "condric", "schemr", " descer", "descriptionrb", " descric", "descriptionric", " descri", " descadr", "descer", "colric", "derbr", "congadr", "reflectric", "descriptionrs", "drawrar", "descrb", "distrs", "distrc", "escer", "commentnr", "escar", "distr", "reflectrr", "descri", "descnr", "reler", "esccr", "escrb", "criptrr", "descriptionrate", "reflectr", "distsr", " descbr", "descour", "schecr", " descpair", "descsr", "escbr", "escrc", "condrr", "drawrb", "descriptionR", " desccr", "descre", " descour", "regadr", " descrar", "digr", "descriptionral", "criptnr", "drawour", "Descrc", "distrer", "ecrer", "desric", "criptrb", "desr", "desor", "escro", "distnr", "colrate", "descral", "congr", "descadr", "Descar", "derr", "riptr", "riptric", "digral", "commentcr", "condr", "descbr", "relnr", " descor", "escr", "drawri", "escric", "criptral", "descrs", "digre", "scherate", "descrar", "ecrar", "commentsr", "Descrs", "porter", "descrt", "commentre", "drawr", "scheor", "scheral", "commentrs", "criptr", "portrt", "descR", "distar", "derric", "escadr", "digpair", "relro", "descriptionre", "scheric", "descric", "schepair", "regn", "descriptionnr", " descR", "ecri", " descnr", "relrer", "descn", "descriptionmr", "ecrb", "commentr", "escre", " descrt", "colpair", "congric", "escR", " descral", " descrb", "descrate", "colR", "schere", "descor", "descrr", " descro", "criptric", "regric", "relr", "ecour", "colr", "riptor", "congn", "relsr", "descro", " descrate", " descn", "desccr", "descmr", "riptrar"], "predefined": ["predef", "predocumented", "Predef", " predacted", "peddefined", "Preddefined", " preddefined", "Predacted", "prediscovered", "pedocumented", "redocumented", "pediscovered", "redacted", " predocumented", "Predocumented", " prediscovered", "pedefined", "reddefined", "Predefined", "redef", "preddefined", "rediscovered", "predacted", "redefined", " predef"], "lengths": [" lengtht", "engthls", "engthals", "ENGTHerences", "lengthals", "lengthrs", "lengtherences", "lengthies", "libments", "lengtht", "historys", "rollrs", " Lengthss", "alignrs", "aligns", "rolls", "engthjs", "rollies", " lengthts", " Lengthjs", " lengthances", "widthls", "ENGTHs", "alignals", "countjs", "engthies", "Lengthls", " Lengths", "historyments", "lengthances", "engthts", "rollls", "widthals", "widths", "widthances", "liberences", "historyerences", "engtht", "lengthss", "countss", "widtht", "widthies", "widthjs", "alignjs", "engthances", "lengthts", "Lengths", "engthrs", "widthts", "Lengthss", "countls", "libs", " Lengthls", "lengthments", "engths", "Lengthjs", "lengthjs", "widthrs", "counts", "ENGTHments", "lengthls"]}}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 9352, "substitutes": {"env": ["dev", "h", "sb", "conf", "np", "conn", "mem", "ev", "eng", "enter", "sw", "v", "sp", "environment", "entry", "end", "en", "map", "window", "shell", "code", "policy", "config", "buf", "cv", "server", "vt", "er", "viron", "te", "ec", "ah", "ctx", "ce", "ten", "manager", "sc", "nv", "vs", "context", "e", "vp", "me", "hw", "ptr", "scope"], "r1": ["ROne", "arfirst", "r001", "ar01", "dr001", "rfirst", " r0", "drfirst", "array001", "ar1", "r0", "ar001", "rOne", "arrayfirst", "R2", "R0", "R1", "dr01", " rOne", "ar2", "dr1", "r01", "ar0", "array01", "array1", "arOne"], "r2": ["r4", "R4", " rsec", " r0", "m0", "r0", "ar1", "rad0", "rsec", "radTwo", " rTwo", "mTwo", "ar4", " r4", "R2", "R1", "rad2", "rtwo", " rtwo", "ar2", "msec", "m2", "radsec", "artwo", "rTwo", "Rtwo"]}}
{"project": "FFmpeg", "commit_id": "ec79b1fc88b2cc6a9ab6cd953efcdbaebedde233", "target": 1, "func": "static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr)\n\n{\n\n    WtvContext *wtv = s->priv_data;\n\n    AVIOContext *pb = wtv->pb;\n\n    while (!url_feof(pb)) {\n\n        ff_asf_guid g;\n\n        int len, sid, consumed;\n\n\n\n        ff_get_guid(pb, &g);\n\n        len = avio_rl32(pb);\n\n        if (len < 32)\n\n            break;\n\n        sid = avio_rl32(pb) & 0x7FFF;\n\n        avio_skip(pb, 8);\n\n        consumed = 32;\n\n\n\n        if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) {\n\n            if (ff_find_stream_index(s, sid) < 0) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 28);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, 0, sid, mediatype, subtype, formattype, size);\n\n                consumed += 92 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_stream2_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size);\n\n                consumed += 76 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t buf[258];\n\n                const uint8_t *pbuf = buf;\n\n                int buf_size;\n\n\n\n                avio_skip(pb, 8);\n\n                consumed += 8;\n\n                if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                    !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) {\n\n                    avio_skip(pb, 6);\n\n                    consumed += 6;\n\n                }\n\n\n\n                buf_size = FFMIN(len - consumed, sizeof(buf));\n\n                avio_read(pb, buf, buf_size);\n\n                consumed += buf_size;\n\n                ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL);\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                int audio_type;\n\n                avio_skip(pb, 8);\n\n                audio_type = avio_r8(pb);\n\n                if (audio_type == 2)\n\n                    st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n\n                else if (audio_type == 3)\n\n                    st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                consumed += 9;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 12);\n\n                if (avio_rl32(pb))\n\n                    av_log(s, AV_LOG_WARNING, \"DVB scrambled stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n                consumed += 16;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t language[4];\n\n                avio_skip(pb, 12);\n\n                avio_read(pb, language, 3);\n\n                if (language[0]) {\n\n                    language[3] = 0;\n\n                    av_dict_set(&st->metadata, \"language\", language, 0);\n\n                    if (!strcmp(language, \"nar\") || !strcmp(language, \"NAR\"))\n\n                        st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                }\n\n                consumed += 15;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_timestamp_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 8);\n\n                wtv->pts = avio_rl64(pb);\n\n                consumed += 16;\n\n                if (wtv->pts == -1)\n\n                    wtv->pts = AV_NOPTS_VALUE;\n\n                else {\n\n                    wtv->last_valid_pts = wtv->pts;\n\n                    if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch)\n\n                        wtv->epoch = wtv->pts;\n\n                if (mode == SEEK_TO_PTS && wtv->pts >= seekts) {\n\n                    avio_skip(pb, WTV_PAD8(len) - consumed);\n\n                    return 0;\n\n                }\n\n                }\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_data_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (mode == SEEK_TO_DATA && stream_index >= 0 && len > 32 && s->streams[stream_index]->priv_data) {\n\n                WtvStream *wst = s->streams[stream_index]->priv_data;\n\n                wst->seen_data = 1;\n\n                if (len_ptr) {\n\n                    *len_ptr = len;\n\n                }\n\n                return stream_index;\n\n            }\n\n        } else if (!ff_guidcmp(g, /* DSATTRIB_WMDRMProtectionInfo */ (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0)\n\n                av_log(s, AV_LOG_WARNING, \"encrypted stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n        } else if (\n\n            !ff_guidcmp(g, /* DSATTRIB_CAPTURE_STREAMTIME */ (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PBDATAG_ATTRIBUTE */ (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PicSampleSeq */ (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_TRANSPORT_PROPERTIES */ ff_DSATTRIB_TRANSPORT_PROPERTIES) ||\n\n            !ff_guidcmp(g, /* dvr_ms_vid_frame_rep_data */ (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelChangeSpanningEvent */ (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelInfoSpanningEvent */ (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelTypeSpanningEvent */ (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) ||\n\n            !ff_guidcmp(g, /* EVENTID_PIDListSpanningEvent */ (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) ||\n\n            !ff_guidcmp(g, /* EVENTID_SignalAndServiceStatusSpanningEvent */ (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) ||\n\n            !ff_guidcmp(g, /* EVENTID_StreamTypeSpanningEvent */ (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) ||\n\n            !ff_guidcmp(g, ff_index_guid) ||\n\n            !ff_guidcmp(g, ff_sync_guid) ||\n\n            !ff_guidcmp(g, ff_stream1_guid) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) {\n\n            //ignore known guids\n\n        } else\n\n            av_log(s, AV_LOG_WARNING, \"unsupported chunk:\"FF_PRI_GUID\"\\n\", FF_ARG_GUID(g));\n\n\n\n        avio_skip(pb, WTV_PAD8(len) - consumed);\n\n    }\n\n    return AVERROR_EOF;\n\n}\n", "idx": 9366, "substitutes": {"s": ["r", "ts", "p", "h", "sb", "ats", "conf", "aps", "proc", "ses", "aunts", "rs", "events", "ies", "i", "v", "ls", "sp", "ss", "its", "es", "ps", "xs", "gs", "aws", "ops", "sts", "parts", "n", "sq", "fs", "sv", "src", "b", "is", "a", "ins", "os", "ms", "sg", "js", "scl", "sys", "hs", "ds", "stats", "ssl", "m", "c", "S", "t", "bits", "sc", "aus", "vs", "cs", "ims", "bs", "w", "qs", "ns"], "mode": ["ode", "opt", "flag", "timeout", "proc", "tag", "perm", "de", "format", "pad", "command", "code", "key", "flags", "fm", "form", "scale", "te", "dim", "kind", "m", "Mode", "status", "mask", "mid", "state", "mod", "cmd"], "seekts": ["ektes", "arets", "_tes", "aretimes", "ektp", "ekts", "ektimes", "_tp", "_times", "aretes", "aretp", "_ts"], "len_ptr": ["len2pointer", "len_pointer", "l_pointer", "len_ref", "l_ref", "len_pointers", "len2ref", "len2pointers", "l_ptr", "len2ptr", "l_pointers"], "wtv": ["webtv", "Wtv", "Wvt", "wti", "wttv", "wpTV", "webnews", "webTV", "WTV", "wtk", " wti", "wtTV", "wpvt", "wdvt", "webti", "wtti", " wnews", "Wtk", "wTV", "wnews", " wTV", "wtnews", "wptk", "wptv", "wdtk", "wvt", "wdtv", "wdTV"], "pb": ["snap", "sb", "py", "np", "tc", "pid", "erb", "eb", "ub", "fb", "ib", "cp", "sys", "tf", "pm", "rb", "pkg", "vp", "jp", "amp", "pp", "pt", "apy", "oa", "bot", "obj", "tg", "req", "wb", "msg", "peer", "p", "prototype", "span", "wp", "um", "lp", "asp", "typ", "sp", "bp", "bj", "prot", "uf", "tk", "gp", "tmp", "b", "prefix", "kb", "fp", "ctx", "stab", "pc", "pro", "func", "cb", "pl", "proc", "px", "tp", "dp", "pg", "emb", "bb", "cv", "PB", "pool", "td", "obb", "tab", "pan", "phy", "mp", "resp", "ap", "bs"], "g": ["r", "p", "gain", " eg", "ga", "f", "i", "v", "gi", "cfg", "gd", "pg", "G", "vg", "j", "gt", "gs", "group", "eg", "gp", "rg", "n", "gn", "gz", "alg", " gp", "gm", "gin", "sg", "og", "gu", "fg", "go", "tg", "ger", "m", "c", "gate", "ug", "t", "ge", "ang", "bg", "gc", "ig", " msg", "fac", "gg", "ag", "msg"], "len": ["limit", "coll", "seq", "mem", "fun", "v", "ls", "Len", "sp", "z", "length", "syn", "compl", "l", "trans", "lf", "ln", "en", "dl", "val", "nl", "n", "count", "enc", "fn", "fl", "full", "elt", "set", "ref", "offset", "lan", "fin", "vec", "gen", "t", "pos", "num", "loc", "lon", "ll", "L", "lib", "el", "il"], "sid": ["bid", "sb", "pid", "site", "data", "seed", "buff", "sym", "sam", "_", "uint", "sys", "t", "source", "ti", "pkg", "rid", "session", "sat", "addr", "ser", "stat", "iq", "lang", "esi", "uid", "notice", "src", "since", "kid", "sit", "sd", "desc", "hash", "ds", "ssl", "buffer", "msg", "p", "sta", "sha", "seq", "uri", "sa", "typ", "id", "sil", "sp", "sing", "ident", "sim", "uin", " Sid", "sec", "bytes", " tid", "sn", "elt", "fp", "song", "vid", "mid", "gc", "login", "ts", "si", "token", "sal", "zi", "side"], "consumed": [" reconserved", "resumption", "Consume", "consume", "Consumed", " reconsocated", " consocated", "Consumption", " consumption", "consumption", "Consuming", " consum", " conserved", "fillederved", " consuming", "cosum", " reconsumption", "presumption", "presume", "consocated", "cosumed", "filledumed", "consum", "cosuming", "reserved", "presuming", "resumed", "filledum", "filleduming", "coserved", "resocated", "consuming", "cosume", " reconsumed", "conserved", "cosumption", "presumed"], "mediatype": ["framiatyp", "mediiaty", " mediattype", "medatypes", "mediantype", "mediiatyp", "mediantypes", "medatyp", "mediantpe", "medietype", "medatotype", "mediatyp", "mediiattype", "medattyp", "medattime", "framanttype", "mediattotype", "mediatypes", "framatpe", "framaty", " mediattyp", " mediatyp", "mediiatypes", " mediattime", "mediactotype", "medimatime", "medimatyp", "mediiatype", "medietyp", "mediatty", "mediantyp", "framiatpe", "mediatttype", "mediantime", "mediattypes", "framattype", "framatype", "framantype", "framanty", "medimatype", "medietpe", "mediattype", "mediatime", "mediattime", " mediatime", "mediiatpe", "framiatype", "mediatotype", "framiattype", "medattype", "medimatotype", "framatyp", "framatime", " mediatypes", "mediactype", "mediatpe", "mediactyp", "mediaty", "mediactime", " mediattypes", "mediiatime", "medattotype", "medatime", "mediattyp", "framantime", "mediettype", "medatype", "medianty", "medianttype"], "subtype": ["singtag", "regype", "subrole", "formatterm", "ubstyle", " subtag", " subType", "substyle", "tagype", "filype", "filty", "perpe", "subclass", "subty", " subty", "subype", " subclass", "subtime", "tagty", "formatrole", "subcondition", "tagtype", "Subclass", "singstyle", "subpe", " subtime", "ubterm", "regtype", "ubtype", "singcondition", "subname", " substyle", "subtag", "ubty", "regrole", "Subtype", "filrole", "filtype", "ubname", "subType", "regterm", "singclass", "ubype", "singType", "subterm", "Subcondition", "perty", "formatype", "SubType", "tagrole", " subcondition", "singtype", "pertime", "ubpe", "ubtime", "ubrole", "pertype", " subpe", "singname", " subname", "ubtag"], "formattype": ["featerror", "subcomment", "filtererror", " formaterror", "flattemplate", "formaterror", "feattemplate", "filterunit", "formatstyle", "flatype", "formrole", "feattype", "repeattype", "featfield", "mediarole", "filtertag", "featgroup", "formatrole", "filterfield", " formatunit", "formatoption", "formtype", " formatoption", "mediastyle", "formType", "flatType", "formstyle", "featype", "mediaType", "subtag", "transformype", "formatcomment", "flatstyle", "formatunit", "formatfield", "filtertype", "formatgroup", "featunit", "repeatoption", " formatype", "flatgroup", "transformtemplate", "formatType", "formattemplate", "formatype", "flattype", "filtercomment", " formatfield", "formattag", "subfield", "repeatype", "initoption", "inittype", " formatcomment", "transformgroup", "transformtype", "flatrole", "initype", " formattag", "initunit", "repeatunit"], "size": ["limit", "send", "resolution", "sha", "timeout", "mem", "type", "amount", "member", "loss", "id", "number", "z", "format", "speed", "data", "fee", "needed", "name", "height", "window", "small", "ose", "large", "sent", "space", "SIZE", "notice", "owner", "count", "time", "area", "diff", "sized", "gz", "scale", "Size", "bytes", "dim", "fd", "ms", "shape", "term", "empty", "sn", "set", "style", "hash", "offset", "ize", "body", "num", "alias", "sum", "any", "description", "score", "length", "storage", "duration"]}}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "func": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n", "idx": 9399, "substitutes": {"klass": ["knls", "ikkls", "ktlass", "knlasses", "sklas", "mklas", "skclass", " kase", "klas", "ktclass", "ikkclass", " klas", "knlass", "kls", " kclass", "knla", "skls", "ktase", "Kls", " kla", "kla", "ktls", "mklass", "ikklass", "klasses", " klasses", "ikkase", "kclass", "Klass", "mkclass", "Klasses", "Kla", "kase", "mkls", " kls", "sklass"], "data": ["di", "dev", "init", "DATA", "bin", "value", "attr", "json", "ata", "params", "name", "result", "Data", "resources", "device", "d", "bytes", "cache", "dat", "def", "info", "bus", "kind", "module", "ds", "res", "mu"], "dc": ["di", "iac", "cr", "dr", "tc", "DC", "dq", "df", "cm", "dd", "dm", "cam", "dp", "fc", "bc", "nc", "cd", "disc", "uc", "lc", "dt", "cu", "cc", "rc", "cp", "da", " DC", "td", "d", "drm", "ec", "dim", "desc", "ca", "mc", "c", "ctrl", "gc", "pc", "vc", "cs", "cca", "ac"], "vdc": ["ivdi", " vdi", " vdisc", "verdisc", "wirecca", "Vdesc", " vcca", " vdesc", "vtc", " vmc", "wireadr", "ivdr", "VDC", "vermc", "verDC", "Vcca", "Vdr", "zdesc", "portcca", "vdp", "ivdc", "Vdc", "fdc", "vdesc", "Vdp", " vdr", "zDC", "vcca", "fdisc", "maxtc", "vadr", "wiredc", "vdr", "maxfc", " vdp", "portdi", "maxdc", "zdc", " vfc", "maxdisc", "vdi", "Vmc", "ivdp", "portdc", "zcca", "ftc", "Vdi", " vadr", " vtc", "vdisc", "verdc", "wiredi", "Vdisc", "vfc", "portadr", "ffc", "vDC", "vmc", " vDC"]}}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "substitutes": {"smp_cpus": ["smp_cpuus", "smp_cpu", "smp_cponents", "smp_compores", "smp_gpos", "smp_gpus", "smp_cpors", "smp_pors", "smp_gponents", "smp_cpuonents", "smp_pu", "smp_pus", "smp_gps", "smp_cs", "smp_compos", "smp_compus", "smp_conents", "smp_cps", "smp_cu", "smp_pores", "smp_cpores", "smp_gpores", "smp_gpu", "smp_cpuu", "smp_compu", "smp_gpors", "smp_cpos", "smp_cus", "smp_pos"], "s": ["changes", "sb", "ses", "ls", "still", "ys", "aws", "comm", "sm", "south", "sv", "sym", "as", "sam", "js", "sys", "c", "t", "https", "source", "state", "ms", "se", "w", "ns", "less", "search", "sync", "h", "ats", "conf", "sw", "ps", "new", "http", "parts", "sq", "obj", "fs", "sl", "set", "stats", "ds", "sc", "res", "vs", "cs", "ims", "tes", "gets", "ports", "p", "sa", "sp", "its", "l", "sports", "ex", "tests", "store", "server", "is", "b", "g", "st", "os", "copy", "y", "hs", "spec", "r", "ts", "self", "rs", "f", "v", "args", "ss", "es", "als", "uns", "gs", "j", "sts", "n", "rets", "details", "m", "S", "bs", "qs"], "ret": ["dr", "let", "flag", "cat", "err", "url", "compl", "gt", "Ret", "dt", "ert", "rm", "nl", "vet", "print", "def", "ref", "t", "len", "ll", "ter", "del", "jp", "cmd", "red", "sat", "git", "cont", "addr", "lt", "obj", "expr", "desc", "rt", "ry", "it", "txt", "et", "res", "aux", "Return", "ben", "pret", "final", "fun", " Ret", "str", "result", "prot", " RET", "deg", "rem", "sr", "nt", "ne", "iter", "mt", "try", "tr", "elt", "fi", "gc", "nz", "arg", "r", "att", "cb", "RET", "ft", "rev", "z", "re", "j", "usr", "tn", "val", "not", "rets", "net", "back", "get", "ext", "reset", "cert", "got", "det", "resp", "alt"], "i": ["ui", "di", "p", "ami", "x", "spin", "fire", " ti", " m", "v", "gi", "id", "ai", "ic", " ii", "ind", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", " mi", "oi", "key", "multi", "bi", " I", "in", "o", "ni", "n", "g", "is", "si", "index", "li", " bi", "y", "ini", "fi", "it", " ni", "ci", "m", "t", "zi", "mi", "ip", " j", "qi", "iri", "ti", "inner", "im", "point", "pi", "client", "ki", "us", "ori", " si"]}}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "substitutes": {"client": ["util", "p", "collection", "cli", "list", "co", "public", "acl", "conn", "hunt", "web", "plugin", "document", "problem", "connection", "contact", "cell", "network", "command", "call", "sim", "cl", "window", "code", "application", "http", "component", "qualified", "channel", "close", "config", "cv", "store", "secure", "server", "Client", "remote", "service", "core", "prefix", "app", "form", "cache", "pattern", "local", "force", "view", "hog", "wrapper", "ctx", "ci", "c", "manager", "open", "chain", "cod", "current", "batch", "con", "context", "grid", "man", "response"], "filename": ["ren", "ername", "ames", "bf", "til", "directory", "Filename", "fil", "folder", "url", "vr", "FIL", "location", "title", "original", "name", "wrong", "username", "family", "sbm", "nm", "journal", "prefix", "fn", "kj", "path", "kan", "fp", "fle", "ame", "txt", "source", "FN", "ename"], "flags": ["options", "ts", "vals", "flag", "args", "cond", "tags", "ents", "ensions", "lag", "nl", "links", "FLAG", " flag", "fs", "Flags", "details", "fd", "files", "kind", "fields", "bits", "status", "mask", "features", "ags", "mode", "ns"], "errp": ["errorpar", "errpat", "riskpar", "warnap", "hlpid", "orpost", "aerpost", "errorap", "errorpy", "riskp", "arrpy", "errphp", " errpar", "errorp", "hljp", "errpoint", "aerpid", "arrpat", "aerpre", "warnpy", "ierpy", "errpost", "orp", "errjp", "testper", "errord", "errper", "strphp", "outerpost", "strpid", "strpy", "errorpid", "errping", "testphp", "outerpoint", "orping", "hlp", "testpost", " errpid", "aerpa", "rerpost", "testpre", "hlphp", "aerjp", "testpat", "testpa", "noticeper", "rerp", "errpar", "errpy", "errpa", "aerpat", "noticep", "orpoint", "arrap", "rerphp", "rerper", "aerphp", "errd", "strd", "aerpoint", "strpkg", "warnp", "errap", "ierpkg", "ierp", "aerping", "noticepost", "warnpat", "errorpre", "errorpkg", "noticephp", "outerping", "aerp", "arrp", "riskpid", "errorpa", "strjp", "testp", "errorpat", "errpre", "ierd", "errpid", "outerp", "errpkg"], "i": ["ui", "di", "p", "gl", "ami", "cli", "x", "ir", "ims", "f", "v", "gi", "ri", "id", "ai", "ic", "ind", "l", "ei", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "ex", "multi", "bi", "n", "me", "g", "b", "hi", "is", "si", "index", "my", "li", "info", "y", "ini", "q", "go", "gu", "it", "\u0438", "m", "ci", "c", "io", "t", "ip", "mi", "zi", "chain", "ij", "batch", "ti", "qi", "pi", "series", "ki", "k", "ori"], "st": ["r", "func", " ST", "f", "stat", "name", "str", "ST", "usr", "sts", " dst", "n", "nt", "St", "mt", "os", " structure", "et", "status", " desc", "ist", "stream", "ptr", "sth"], "uri": ["ui", "p", "util", "uni", "RI", "cli", "ir", "via", "ue", "directory", "URI", "iterator", "subject", "du", "mate", "ri", "url", "folder", "connection", "location", "uno", "query", "sim", "username", "phi", "picture", "http", "direction", "u", "range", "origin", " ur", "ouri", "server", "domain", "resource", "prefix", "doi", "form", "umi", "ur", "uu", "definition", "path", "nil", "term", "ini", "browser", "node", "general", "fp", "basic", "urate", "volume", "ip", "mi", "qi", "nu", "ori", "iri", "sofar", " URI", "description", "message", "bo", "ugi", "address"], "qp": [" qm", "qum", "qpm", "checkpm", "checkp", "eqlp", "qualpn", "queryp", "eqp", "aqP", " qn", "qualwp", "sqP", "qP", "questp", "aqtp", "qcp", "ekpa", "ekp", "quallp", "checkm", "ckp", "questlp", "qpa", "qpn", "sqlp", "questm", "qucp", "questup", "ryp", "qap", "querycp", " qr", " qP", "qupa", "aqwp", "aqcp", "qpr", "qupn", "sqm", "qualpa", "qqp", " qcp", "sqwp", " qap", "qualcp", "querypn", "qphp", "qvp", "qqpr", "qqphp", "sqr", "questpa", "queryn", "sqtp", "ryvp", "qur", "qun", "cktp", "ekpkg", "qtp", "rypr", "qqvp", "qm", "qup", "querym", " qtp", "aqpkg", "eqpr", "aqpa", "qualvp", "qwp", "ryphp", " qpa", "querypm", "cklp", "qualphp", "sqpa", "qualpr", "aqp", "quP", "questpr", "aqap", "quap", "questtp", "ekcp", "qpkg", "sqcp", "quup", "quwp", "checkcp", "ckpa", "qr", "qualp", "sqp", "squp", "qlp", "querywp", "qupkg", "questP", "questap", "aqm", "eqpa", "qn", "sqap", "qutp", "sqpm"], "file": ["bf", "File", "fil", "f", "ret", "read", "data", "format", "name", "str", "progress", "channel", "il", "dir", "handle", "path", "user", "local", "files", "full", "bit", "fp", "offset", "fi", "F", "fin", "io", "part", "ile", "t", "buffer", "byte", "len", "status", "port", "db", "table", "base", "arg", "error"], "strp": ["Strpat", "Strr", "divP", "sprlp", "divp", "strir", "sprP", "Strpa", "strping", "strpos", "Strp", "strlp", "Strlp", "strr", "divpat", "StrP", "sprp", "srpat", "stringP", " strr", "strig", "Strvp", "arrpos", "stringvp", "strP", "arrp", "Strping", "stripa", "strip", "strps", "strivp", " strpos", " strpa", "strpa", "srp", "srlp", "stringps", "strips", "sprpat", "Strg", "srP", "Strpos", "divvp", "arrping", "strvp", "striP", " strvp", "stringp", " strP", "strg", " strping", "strpat", "Strps", " strpat", "arrP", " strg"]}}
{"project": "FFmpeg", "commit_id": "6f7f2396049575fcf2054b4dafa19ca01381638e", "target": 1, "func": "static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {\n\n    NUTContext * priv = avf->priv_data;\n\n    AVIOContext * bc = avf->pb;\n\n    nut_demuxer_opts_tt dopts = {\n\n        .input = {\n\n            .priv = bc,\n\n            .seek = av_seek,\n\n            .read = av_read,\n\n            .eof = NULL,\n\n            .file_pos = 0,\n\n        },\n\n        .alloc = { av_malloc, av_realloc, av_free },\n\n        .read_index = 1,\n\n        .cache_syncpoints = 1,\n\n    };\n\n    nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts);\n\n    nut_stream_header_tt * s;\n\n    int ret, i;\n\n\n\n    if ((ret = nut_read_headers(nut, &s, NULL))) {\n\n        av_log(avf, AV_LOG_ERROR, \" NUT error: %s\\n\", nut_error(ret));\n\n\n        return -1;\n\n\n\n\n    priv->s = s;\n\n\n\n    for (i = 0; s[i].type != -1 && i < 2; i++) {\n\n        AVStream * st = avformat_new_stream(avf, NULL);\n\n        int j;\n\n\n\n        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);\n\n\n\n        st->codec->has_b_frames = s[i].decode_delay;\n\n\n\n        st->codec->extradata_size = s[i].codec_specific_len;\n\n        if (st->codec->extradata_size) {\n\n            st->codec->extradata = av_mallocz(st->codec->extradata_size);\n\n\n\n\n\n            memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);\n\n\n\n\n        avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den);\n\n        st->start_time = 0;\n\n        st->duration = s[i].max_pts;\n\n\n\n        st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag);\n\n\n\n        switch(s[i].type) {\n\n        case NUT_AUDIO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag);\n\n\n\n            st->codec->channels = s[i].channel_count;\n\n            st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom;\n\n            break;\n\n        case NUT_VIDEO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);\n\n\n\n            st->codec->width = s[i].width;\n\n            st->codec->height = s[i].height;\n\n            st->sample_aspect_ratio.num = s[i].sample_width;\n\n            st->sample_aspect_ratio.den = s[i].sample_height;\n\n            break;\n\n\n        if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n\n\n\n    return 0;\n", "idx": 9435, "substitutes": {"avf": ["avg", "avecf", "iverfab", "ovm", "wavv", "averfc", "iverv", "ivercf", "averfr", "avcf", "aveg", "wavfo", "afv", "avfo", "avefo", "ovfs", "avc", "avef", "wavf", "affr", "averm", "iverf", "avfab", "avercf", " avfi", "avefr", " avfab", "avm", "avfr", "iverc", "affs", " avc", "afc", "avev", "averf", "avem", " avfc", "avefs", "avfc", "avefab", "ovfc", "avfi", "aff", "affi", "averfs", "afcf", " avcf", "avefc", "affo", "avfs", "avec", "iverfi", "avv", " avv", "afg", "wavg", "averc", "ovf"], "ap": ["att", "al", "pl", "amp", "aps", "prov", "np", "cap", "ar", "pp", "AP", "ata", " sap", "sp", "op", "tp", "bp", " sp", "am", "apt", "tap", "dat", " p", "mp", "ip", "ape", "ad", "ac"], "priv": ["pro", "util", "dev", "pr", "conf", "proc", "conn", "mem", "deb", "attr", "cap", "private", "alloc", "exec", "sp", "cfg", "auth", "access", "usr", "env", "sub", "pub", "rc", "admin", "ib", "obj", "cp", "buf", "nt", "vt", "riv", "serv", "core", "soc", "sec", "mint", "tr", "iv", "tx", "sys", "ctx", "Priv", "ctrl", "req", "txt", "cot", "prep", "loc", "rw", "pkg", "pi", "ptr", "rot", "rel", "pri"], "bc": ["dc", "cb", "bf", "tc", "bd", "cf", "voc", "ic", "pb", "fc", "bp", "nc", "bb", "rc", "ib", "bi", "bt", "soc", "ec", "BC", "ca", "CBC", "ctx", "mc", "c", "sc", "db", "con", "ba", "bg", "gc", "pc", "bo", "bs", "ac"], "nut": ["or", "ot", "snap", "cb", "nit", "np", "orb", "tub", "nuts", "uts", "fat", "nat", "Nut", "tar", "norm", "six", "pot", "ox", "tn", "tap", "n", "nt", "tmp", "orn", "gob", "vt", "core", "fn", "net", "anon", "mint", "cro", "ut", "etc", "node", "rt", "box", "bolt", "critical", "cot", "stab", "roy", "tube", "prep", "nv", "utt", "cut", "chest", "san", "nor", "rot"], "s": ["changes", "objects", "sb", "ses", "ls", "xs", "ys", "aws", "abilities", "sv", "as", "sam", "ings", "scripts", "js", "sys", "bes", "c", "t", "ags", "eds", "ms", "w", "socket", "ids", "ins", "ns", "h", "ats", "sw", "qs", "ps", "parts", "sq", "a", "fs", "sl", "stats", "ds", "locks", "services", "vs", "cs", "ims", "gets", "ports", "p", "aunts", "sa", "sp", "its", "ties", "b", "g", "is", "os", "hs", "us", "ts", "rs", "v", "ss", "es", "als", "uploads", "gs", "sts", "n", "rings", "actions", "views", "details", "bs", "states", "m", "S", "mods", "strings", "spec", "sports"], "ret": ["r", "RET", "mel", "red", "ft", "mem", "err", "v", "cont", "re", "gt", "Ret", "deg", "val", "rem", "out", "n", "nt", "rets", "bt", "vet", "back", "print", "mt", "bad", "def", "tr", "elt", "rt", "ry", "ref", "reset", "tf", "it", "txt", "t", "et", "len", "res", "status", "got", "det", "resp", "alt", "aux", "ter"], "i": ["ui", "di", "p", "ami", "cli", "x", "h", "list", "uri", "f", "v", "gi", "ri", "id", "ic", "ai", "iq", "ind", "l", "ii", "ei", "xi", "sim", "I", "phi", "ji", "ix", "iu", "oi", "multi", "bi", "n", "me", "ni", "in", "o", "is", "g", "hi", "si", "index", "li", "info", "y", "ini", "it", "\u0438", "ci", "m", "io", "qi", "ip", "mi", "ij", "zi", "status", "iri", "ti", "im", "asi", "pi", "e", "ki", "ims"], "st": ["ts", "art", "step", "ot", "sta", "dist", "nd", "sw", "ft", "sty", "std", "sh", "sp", "ast", "stan", "ste", "stat", "stru", "str", "ST", "ct", "pt", "tt", "stop", "ust", "usr", "irst", "stra", "start", "sts", "th", "nt", "put", "store", "obj", "cast", "src", "tra", "ost", "td", "net", "inst", "St", "mt", "form", "rest", "tr", "ut", "sn", "set", "it", "so", "t", "et", "stage", "sc", "sum", "stable", "est", "stab", "ist", "mont", "se"], "j": ["att", "p", "aj", "x", "h", "oj", "off", "on", "jj", "json", "v", "jc", "job", "jump", "ng", "z", "by", "jit", "jack", "str", "bj", "fr", "ji", "ju", "other", "jac", "ix", "bot", "key", "u", "n", "obj", "o", "ja", "b", "g", "kj", "kid", "ch", "_", "y", "q", "js", "max", "J", "br", "it", "c", "t", "jl", "ij", "dj", "uj", "k", "msg", "jp"]}}
{"project": "qemu", "commit_id": "41264b385c2b324fea026204e5de9bef980733b1", "target": 1, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n    Error *local_err = NULL;\n#if !defined(CONFIG_USER_ONLY)\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n#endif\n#if !defined(CONFIG_USER_ONLY)\n    if (smp_threads > max_smt) {\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n    if (!is_power_of_2(smp_threads)) {\n        error_setg(errp, \"Cannot support %d threads on PPC with %s, \"\n                   \"threads count must be a power of 2.\",\n                   smp_threads, kvm_enabled() ? \"KVM\" : \"TCG\");\n#endif\n    cpu_exec_init(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n#if !defined(CONFIG_USER_ONLY)\n    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt\n        + (cs->cpu_index % smp_threads);\n#endif\n    if (tcg_enabled()) {\n        if (ppc_fixup_cpu(cpu) != 0) {\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n#if defined(TARGET_PPCEMB)\n    if (!ppc_cpu_is_valid(pcc)) {\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n                   \"or choose another CPU model.\");\n#endif\n    create_ppc_opcodes(cpu, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    init_ppc_proc(cpu);\n    if (pcc->insns_flags & PPC_FLOAT) {\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n                                 33, \"power-fpu.xml\", 0);\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n                                 34, \"power-altivec.xml\", 0);\n    if (pcc->insns_flags & PPC_SPE) {\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n                                 34, \"power-spe.xml\", 0);\n    if (pcc->insns_flags2 & PPC2_VSX) {\n        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,\n                                 32, \"power-vsx.xml\", 0);\n    qemu_init_vcpu(cs);\n    pcc->parent_realize(dev, errp);\n#if defined(PPC_DUMP_CPU)\n    {\n        CPUPPCState *env = &cpu->env;\n        const char *mmu_model, *excp_model, *bus_model;\n        switch (env->mmu_model) {\n        case POWERPC_MMU_32B:\n            mmu_model = \"PowerPC 32\";\n            break;\n        case POWERPC_MMU_SOFT_6xx:\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_74xx:\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx:\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx_Z:\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n                \"and zones protections\";\n            break;\n        case POWERPC_MMU_REAL:\n            mmu_model = \"PowerPC real mode only\";\n            break;\n        case POWERPC_MMU_MPC8xx:\n            mmu_model = \"PowerPC MPC8xx\";\n            break;\n        case POWERPC_MMU_BOOKE:\n            mmu_model = \"PowerPC BookE\";\n            break;\n        case POWERPC_MMU_BOOKE206:\n            mmu_model = \"PowerPC BookE 2.06\";\n            break;\n        case POWERPC_MMU_601:\n            mmu_model = \"PowerPC 601\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_MMU_64B:\n            mmu_model = \"PowerPC 64\";\n            break;\n#endif\n        default:\n            mmu_model = \"Unknown or invalid\";\n            break;\n        switch (env->excp_model) {\n        case POWERPC_EXCP_STD:\n            excp_model = \"PowerPC\";\n            break;\n        case POWERPC_EXCP_40x:\n            excp_model = \"PowerPC 40x\";\n            break;\n        case POWERPC_EXCP_601:\n            excp_model = \"PowerPC 601\";\n            break;\n        case POWERPC_EXCP_602:\n            excp_model = \"PowerPC 602\";\n            break;\n        case POWERPC_EXCP_603:\n            excp_model = \"PowerPC 603\";\n            break;\n        case POWERPC_EXCP_603E:\n            excp_model = \"PowerPC 603e\";\n            break;\n        case POWERPC_EXCP_604:\n            excp_model = \"PowerPC 604\";\n            break;\n        case POWERPC_EXCP_7x0:\n            excp_model = \"PowerPC 740/750\";\n            break;\n        case POWERPC_EXCP_7x5:\n            excp_model = \"PowerPC 745/755\";\n            break;\n        case POWERPC_EXCP_74xx:\n            excp_model = \"PowerPC 74xx\";\n            break;\n        case POWERPC_EXCP_BOOKE:\n            excp_model = \"PowerPC BookE\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_EXCP_970:\n            excp_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            excp_model = \"Unknown or invalid\";\n            break;\n        switch (env->bus_model) {\n        case PPC_FLAGS_INPUT_6xx:\n            bus_model = \"PowerPC 6xx\";\n            break;\n        case PPC_FLAGS_INPUT_BookE:\n            bus_model = \"PowerPC BookE\";\n            break;\n        case PPC_FLAGS_INPUT_405:\n            bus_model = \"PowerPC 405\";\n            break;\n        case PPC_FLAGS_INPUT_401:\n            bus_model = \"PowerPC 401/403\";\n            break;\n        case PPC_FLAGS_INPUT_RCPU:\n            bus_model = \"RCPU / MPC8xx\";\n            break;\n#if defined (TARGET_PPC64)\n        case PPC_FLAGS_INPUT_970:\n            bus_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            bus_model = \"Unknown or invalid\";\n            break;\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n               \"    MMU model        : %s\\n\",\n               object_class_get_name(OBJECT_CLASS(pcc)),\n               pcc->pvr, pcc->msr_mask, mmu_model);\n#if !defined(CONFIG_USER_ONLY)\n        if (env->tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif", "idx": 9437, "substitutes": {"dev": ["att", "conf", "DEV", "conn", "Dev", "ev", "mem", "proc", "link", "v", "de", "test", "data", "cam", "pad", "boot", "ver", "sky", "cu", "device", "ve", "nt", "des", "cp", "serv", "def", "dem", "os", "sd", "pu", "sys", "gu", "ctx", "ds", "Device", "c", "ad", "nv", "vs", "pc", "vc", "hw", "spec", "w", "ac"], "errp": ["errorwp", "rrwp", "rrP", " errm", "traceP", "errpart", "ererm", "errbp", "attrpart", " errps", "errorps", "errphp", "errpoint", "errorp", "attrm", "errorr", "ererp", "orderpoint", "errm", "errper", "rrping", "ererping", "errorpress", "errorpoint", "errorping", "attrj", "errping", "orderr", "errorm", "ererpart", "ererj", "errorP", "attrper", "ererper", "errorper", "attrpoint", "rrbp", "erert", "rrm", "rrpart", "rrphp", "errwp", "orderp", "traceping", "errorj", "attrt", "attrpress", "errP", "attrp", "solpoint", "ererwp", " errpoint", "errt", "solp", "solpress", "errpress", "errps", "errorphp", "errr", " errP", " errr", "rrps", "rrp", "attrping", "rrt", " errbp", "attrps", "solps", "tracep", "tracebp", "errj", "ererphp", " errping"], "cs": ["ts", "caps", "cus", "tc", "cf", "rs", "ls", "ck", "ces", "ps", "cks", "gs", "cu", "sts", "cc", "rc", "checks", "cp", "cas", "CS", "cms", "fs", "core", "ics", "s", "os", "ms", "ks", "cmp", "css", "ca", "sys", "js", "ctx", "ds", "c", "bits", "sc", "vs", "pc", "gc", "wcs", "bs", "cn", "ns"], "cpu": ["pro", "util", "p", "sync", "runner", "np", "proc", "CPU", "tc", "linux", "gpu", "mem", "alloc", "ck", "stat", "tp", "cow", "nc", "boot", "cum", "vm", "lc", "cu", "nic", "cc", "component", "dt", "process", "device", "hw", "n", "cv", "cp", "core", "cache", "os", "copy", "phys", "local", "pu", "cmp", "sys", "ctx", "c", "kernel", "target", "sc", "clock", "pc", "gc", "spec", "hz", "cn"], "pcc": [" pcci", "pppc", "hCC", "ppcc", "penc", "ppcci", "ppCC", "PCC", "peCC", "tpcc", "pnc", "hcc", "ppc", "hcci", "Pvc", "pvc", "tpcci", "pcci", "pCC", "Pcc", "tpvc", "pepc", "Ppc", "Pnc", "pecc", "tpCC", "Pcs", " pCC", "Pcci", "hvc", "pcs", "ppnc", " pcs", "ppcs"], "local_err": ["personal_exc", "personalmyfee", "local_loc", "local7err", "localederr", "inner___notice", "localedtek", "personal_elt", "local_res", "localedloc", " local_ev", "personal_err", "localmyerr", "personal_loc", "local_css", "local7rr", "personalmyerr", "localjerr", "local___rr", "localedelt", "localityelt", "local___err", "error_tek", "local_elt", "local_fee", "local_ev", "inner_notice", "localedcss", "localingerr", "errorjerr", "local_exc", "personal_fee", "inner___err", "localmyloc", "local___norm", "local_rr", "localedfee", "personalmyexc", "error_elt", "local_log", "localjcss", "localingloc", "local_notice", "local7notice", "local___ev", "local_er", "inner___norm", "localingfee", "localedexc", "localmyexc", "error_css", "localityer", "local___res", " local_res", "local7norm", "local_tek", "inner_rr", "errorjtek", "localmyfee", "inner_err", "local_norm", "errorjelt", "localityerr", "personalmyloc", "personal_er", "inner___rr", "errorjcss", "localjtek", "localjelt", "error_err", "localitylog", "localingexc", "local___notice", "personal_log", "inner_norm"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 9443, "substitutes": {"addr": ["r", "x", "dr", "on", "rs", "eth", "i", "err", "v", "alloc", "id", " address", "add", "ash", "name", "pad", "map", "oad", "at", "nl", "store", "a", "g", "mt", "dh", "act", "to", "arp", "Address", "set", "ref", "offset", "now", "ctx", "adr", "t", "ad", "res", "ptr", "host", "hw", "address", "state", "cmd"], "RAM_size": ["AM_Size", "AM_len", "RAM_len", "AM_size", "RAM_Size", "RAM_name", "RAM_SIZE", "AM_name", "AM_SIZE"], "dev": ["di", "p", "av", "h", "die", "be", "DEV", "Dev", "mem", "ev", "conn", "v", "de", "sh", "dd", "data", "cam", "priv", "pad", "ver", "new", "th", "hw", "device", "out", "n", "ve", "nt", "des", "obj", "g", "def", "dem", "tr", "info", "iv", "sd", "go", "sys", "gu", "ds", "t", "ad", "db", "ptr", "cho", "w", "cmd"], "s": ["r", "ts", "p", "h", "sb", "rs", "se", "sa", "v", "ls", "i", "sh", "sp", "ss", "es", "sing", "l", "ps", "gs", "sts", "n", "sq", "des", "fs", "sv", "sl", "g", "is", "a", "si", "b", "st", "sam", "bs", "sd", "set", "js", "sys", "ds", "S", "so", "c", "cs", "e", "state", "ms", "ns"], "d": ["r", "di", "p", "ld", "h", "dr", "dx", "bd", "D", "dq", "i", "v", "der", "dd", "dm", "data", "gd", "device", "out", "n", "pd", "da", "o", "md", "g", "b", "dat", "dh", "fd", "sd", "dn", "ds", "m", "c", "t", "dj", "ad", "db", "e", "ded", "w", "del"]}}
{"project": "qemu", "commit_id": "49aa4058ac6dd0081aaa45776f07c98df397ca5e", "target": 1, "func": "QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n\n{\n\n    char host[65], port[33], width[8], height[8];\n\n    int pos;\n\n    const char *p;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n\n\n    opts = qemu_opts_create(qemu_find_opts(\"chardev\"), label, 1, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        return NULL;\n\n    }\n\n\n\n    if (strstart(filename, \"mon:\", &p)) {\n\n        filename = p;\n\n        qemu_opt_set(opts, \"mux\", \"on\");\n\n        if (strcmp(filename, \"stdio\") == 0) {\n\n            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n\n             * but pass it to the guest.  Handle this only for compat syntax,\n\n             * for -chardev syntax we have special option for this.\n\n             * This is what -nographic did, redirecting+muxing serial+monitor\n\n             * to stdio causing Ctrl+C to be passed to guest. */\n\n            qemu_opt_set(opts, \"signal\", \"off\");\n\n        }\n\n    }\n\n\n\n    if (strcmp(filename, \"null\")    == 0 ||\n\n        strcmp(filename, \"pty\")     == 0 ||\n\n        strcmp(filename, \"msmouse\") == 0 ||\n\n        strcmp(filename, \"braille\") == 0 ||\n\n        strcmp(filename, \"stdio\")   == 0) {\n\n        qemu_opt_set(opts, \"backend\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"vc\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"vc\");\n\n        if (*p == ':') {\n\n            if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) {\n\n                /* pixels */\n\n                qemu_opt_set(opts, \"width\", width);\n\n                qemu_opt_set(opts, \"height\", height);\n\n            } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) {\n\n                /* chars */\n\n                qemu_opt_set(opts, \"cols\", width);\n\n                qemu_opt_set(opts, \"rows\", height);\n\n            } else {\n\n                goto fail;\n\n            }\n\n        }\n\n        return opts;\n\n    }\n\n    if (strcmp(filename, \"con:\") == 0) {\n\n        qemu_opt_set(opts, \"backend\", \"console\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"COM\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"serial\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"file:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"file\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"pipe:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"pipe\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"tcp:\", &p) ||\n\n        strstart(filename, \"telnet:\", &p)) {\n\n        if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1)\n\n                goto fail;\n\n        }\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == ',') {\n\n            if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n\n                goto fail;\n\n        }\n\n        if (strstart(filename, \"telnet:\", &p))\n\n            qemu_opt_set(opts, \"telnet\", \"on\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 9445, "substitutes": {"label": ["lab", "layout", "comment", "value", "type", "link", "err", "id", "format", "version", "cell", "title", "l", "name", "group", "Label", "family", "val", "error", "bl", "key", "line", "abel", "prefix", "index", "lit", "path", "LAB", "local", "desc", "section", "kind", "alias", "loc", "description", "color", "bind", "rel"], "filename": ["ren", "metadata", "np", "directory", "json", "oval", "url", "data", "folder", "lower", "fr", "family", "unc", "fn", "mpeg", "pdf", "sys", "text", "source", "description", "vp", "println", "til", "fil", "download", "output", "rather", "name", "title", "jpg", "ammy", "username", "root", "temp", "src", "latest", "license", "path", "wikipedia", "nil", "files", "txt", "lua", "minimum", "asm", "jing", "final", "location", "position", "size", "tmp", "prefix", "b", "none", "without", "fp", "ename", "length", "r", "fps", "Filename", "f", "v", "whatever", "format", "tp", "original", "j", "n", "file", "png", "partial", "amd", "wine", "xxx", "phy", "message", "their", "il"], "host": ["search", "present", "be", "localhost", "link", "addr", "head", "role", "proxy", "family", "http", "store", "server", "domain", "src", "cast", "ost", "prefix", "begin", "binding", "ca", "weight", "base", "bind", "address", "Host", " Host"], "port": ["ports", "password", "value", "type", "link", "url", "dp", "page", "position", "key", "channel", "range", "line", "cp", "server", "domain", "prefix", "file", "path", "priority", "ip", "row", "table", "address", "length", "socket"], "height": ["resolution", "h", "Height", "high", "bottom", "html", "rank", "read", "gravity", "radius", "padding", "capacity", "widget", "tight", "sky", "angle", "upper", "window", "depth", "ty", "family", "range", "SIZE", "count", "size", "time", "history", "scale", "hold", "dim", "border", "crop", "headers", "shape", "hash", "above", "grow", "power", "volume", "buffer", "hang", "memory", "important", "alpha", "density", "length", "dimension"], "pos": ["pro", " loc", "no", "proc", "type", "op", "data", "name", " position", " len", "Pos", "start", "position", "val", "n", "os", "ref", "offset", " start", "top", "POS", "len", "loc", "base", "row", "col"], "p": ["r", "pr", "h", "wp", "lp", "f", "i", "v", "pp", "perm", "pid", "op", "pb", "sp", "pe", "tp", "bp", "l", "pt", "ps", "j", "pn", "u", "n", "cp", "peer", "P", "a", "b", "g", "d", "prefix", "pa", "s", "path", "y", "q", "fp", "pard", "pm", "m", "c", "part", "t", "point", "ping", "pkg", "e", "vp", "k", "pc", "w", "jp"], "opts": ["options", "optTS", " opits", "optTs", "iopTS", "OPtions", "Opps", "opcs", "OPps", " copTs", "opsrs", " oprs", "opsters", "Opcs", "opsps", "obts", "ott", "opfs", "opters", "optends", "ioprs", " opTS", "optters", "opends", "ropps", "optths", "opTS", "obpt", " opths", "opsems", "opsends", "ropts", "opTs", "optls", " opcs", " opmt", "opths", "OPTs", "opps", " copts", "obTS", " opjs", "opits", " options", "opsths", "imTS", "optits", "iopts", "opouts", "optts", " opTs", " oppt", "oputs", "ropters", "roptions", "imrs", " opters", "iopcs", "otps", "Opjs", "imts", "opsfs", "OPtes", "OPs", "imouts", "opstions", "Opfs", "optfs", "imters", "optjs", " ops", "droptions", "oprs", "opsmt", "ops", "optps", "otts", "OPrs", "imls", "opems", "optes", "obters", " oputs", "opsits", "ioppt", "Oputs", "opsts", " opfs", "iopt", "optrs", "Opends", "opls", "opt", "dropts", "ioptions", "copps", "obouts", "optouts", "roprs", "opsuts", "dropems", "copts", " cops", " opps", "oppt", "opsTs", "coptes", "obt", "iopps", "Opts", "cops", "optmt", " opt", "optems", "opjs", "optuts", "OPt", "opmt", "ropTS", "OPts", "obls", "opttions", " optes", "otrs", "Options", "rops"], "local_err": [" local_plain", "local_eas", "global_msg", "localingrr", "local_cfg", " local_er", "local__rr", "global_err", "locallypriv", "local____fee", "localpyplain", " local_error", "locallyerr", "local____error", "local_fee", "local__err", "local__priv", "localpyerr", "localingerr", "local_rr", "local____eas", " local_state", "local_error", "locallyer", "locallyerror", "local_er", " local_msg", "locallyeas", "local__msg", "local____err", "locallystate", "local_priv", "local_msg", "local_plain", " local_fee", "localpyrr", "locallyfee", " local_priv", " local_eas", "global_cfg", " local_rr", "localingplain", "local_state", "global_er"]}}
{"project": "qemu", "commit_id": "c73860803f8f8f56ee01b6e796507bfb4ea073ec", "target": 1, "func": "POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER8\";\n\n    dc->desc = \"POWER8\";\n\n    pcc->pvr = CPU_POWERPC_POWER8_BASE;\n\n    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;\n\n    pcc->init_proc = init_proc_POWER7;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;\n\n    pcc->msr_mask = 0x800000000284FF36ULL;\n\n    pcc->mmu_model = POWERPC_MMU_2_06;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER7;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n}", "idx": 9457, "substitutes": {"oc": ["ot", "co", "tc", "voc", "oco", "alloc", "ic", "oid", "ob", "bc", "ocation", "nc", "oci", "uc", "org", "cc", "unc", "rc", "arc", "o", "cp", "soc", "ec", "osc", "ok", "roc", "og", "PC", "toc", "oe", "mc", "c", "orp", "loc", "ocr", "OC", "vc", "pc", "ac"], "data": ["di", "dev", "DATA", "bin", "dll", "ata", "output", "fee", "rec", " DATA", "result", "Data", "raw", "device", "rc", "des", "da", "d", "cache", "dat", "def", "res", "mu", "doc", "image"], "dc": ["di", "iac", "dr", "tc", "DC", "bd", "cat", "dd", "dm", "fc", "dp", "bc", "rec", "cd", "disc", "mac", "uc", "lc", "dt", "cc", "rc", "admin", "cp", "da", "d", "ec", "dat", "etc", "asc", "ca", "ds", "mc", "c", "loc", "vc", "pc", "doc", "gc", "cca", "ac"], "pcc": ["ptc", "pac", "P_", "pfc", "pertc", "rcca", "fpc", "ppCC", "pacc", " pck", "phpuc", " pcoin", "pp_", "attct", "puc", "pcon", " pct", "attcoin", "pcca", "cuc", "PC", "Pcc", "procca", "pck", "cacc", "apcc", "rpc", "probb", "phpcca", "fCC", " ptc", "pcoin", "ipcca", "nck", "muc", "ipcc", "macc", "rCC", "pct", "cptc", "attcc", "percon", "cpcca", "apcca", " pC", "ppC", "procp", "ncon", "attcca", "Ppc", "percca", " p_", "apck", "nct", "rcc", "mcc", "fcc", "pcp", "pbb", "Pct", "Pcca", "phpcc", " pcca", "ccc", "mcca", "mcoin", "ncca", "pC", "pCC", " pfc", "p_", "percc", " pac", "mcp", "cpcc", "procc", " pCC", "cbb", "mCC", "mfc", "cpct", "cpfc", "fcca", "ipCC", "apuc", " pcon", "mac", "cpac", "PCC", "perct", "ccca", "ncc", "ppc", "apacc", "ccp", " puc", "ipuc", "mct", "mbb", "apct", "phpCC"]}}
{"project": "FFmpeg", "commit_id": "842e98b4d83d8cf297e2bc2761f1f47eb89e49e4", "target": 0, "func": "static int parse_object_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n    PGSSubObject *object;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n    int id;\n\n\n\n    if (buf_size <= 4)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 4;\n\n\n\n    id = bytestream_get_be16(&buf);\n\n    object = find_object(id, &ctx->objects);\n\n    if (!object) {\n\n        if (ctx->objects.count >= MAX_EPOCH_OBJECTS) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Too many objects in epoch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        object = &ctx->objects.object[ctx->objects.count++];\n\n        object->id = id;\n\n    }\n\n\n\n    /* skip object version number */\n\n    buf += 1;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > object->rle_remaining_len)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        memcpy(object->rle + object->rle_data_len, buf, buf_size);\n\n        object->rle_data_len += buf_size;\n\n        object->rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    if (buf_size > rle_bitmap_len) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Buffer dimension %d larger than the expected RLE data %d\\n\",\n\n               buf_size, rle_bitmap_len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height || !width || !height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions (%dx%d) invalid.\\n\", width, height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    object->w = width;\n\n    object->h = height;\n\n\n\n    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!object->rle)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(object->rle, buf, buf_size);\n\n    object->rle_data_len = buf_size;\n\n    object->rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "idx": 9482, "substitutes": {"avctx": ["avjac", "Avcmd", "AVcontext", "vrcontext", "averpkg", "ajkw", "avcmd", "avercontext", "vartx", "Avtx", "avecontext", " avcpp", "varcf", "ajctx", "savctx", " avcm", "AVconf", "savjac", "afcontext", " avcss", "navtx", "avcss", "navcm", "averkw", "wavctx", "afcmd", "vrtx", "abctx", "averkl", "avtx", "abcontext", "averctx", "avkw", "avwcs", "wavcontext", "wavkl", "avercss", "vrctx", " avkw", "AVctx", " avcf", " avtx", "avpkg", "avectx", "varcm", "ajjac", "afctx", "avewcs", "ivercss", "avkl", " avkl", "varctx", "Avctx", "avconf", "ajwcs", "abtx", "navctx", "avecpp", " avpkg", "navcf", "avejac", "afcpp", "Avcontext", "aveconf", "vrconf", "avcontext", "AVtx", "ivercontext", "avekw", "avcpp", "savwcs", "avcf", "iverctx", "iverkw", " avcontext", "wavpkg", "savkw", "abcmd", "avcm", "avetx", " avcmd", "avecmd"], "buf": ["cb", "bf", "off", "proc", "mem", "eng", "mat", "coord", "cap", "v", "ff", "err", "read", "nb", "args", "pb", "pack", "cam", "emb", "end", "ob", "bc", "pad", "uf", "usr", "window", "shift", "eb", "ered", "fb", "bag", "cv", "bar", "obj", "cast", "begin", "buff", "iter", "b", "tmp", "pool", "config", "arr", "desc", "queue", "ref", "Buff", "br", "vec", "wb", "box", "txt", "prop", "pos", "buffer", "gen", "len", "batch", "rb", "rw", "db", "block", "msg", "doc", "aw", "orig", "Buffer", "img", "conv", "cmd"], "buf_size": ["uf_sent", "burstval0", "queue_len", "buf_fee", "buf_se", "bufvalstorage", "buf_0", "cv_length", "cv_scale", "burstvallength", "uf2len", "uf2sent", "port_fee", "port_Size", "uf2scale", "bufDlen", "burstvalsize", "bu_engine", "burst_0", "uf_sum", "bufDsize", " buf_space", " buf_Size", "bu_SIZE", "wav_len", "br_loc", "buf_loc", "buf_start", "buf_length", "burst_storage", "uf_size", "buf00loss", "wav_se", "buf00Size", "burst_size", "buf2count", "port00size", "buflengthlen", "buf00fee", "bu_size", "uf_dev", "buflengthdev", "bu_scale", "buf2space", "port_loss", "wav_size", "br_scope", "buf_ize", "port_size", "queue_SIZE", "buf_len", "buf_count", "buf_dev", "buf_SIZE", "buf_scale", "buf00len", "port00fee", "br_size", "buf2sent", "buf2Size", "buf2size", "uf_now", "queue_start", "buf00scope", "bufvalsize", "bufval0", "buf2len", "buf_sent", "br_len", "uf2size", "bufvallength", "buf00size", "buflengthsize", "port00Size", " buf_count", "uf_scale", "bufDscope", "buf2scale", "buf_scope", "buf_Size", "buf_now", "queue_size", "buf_space", "port00loss", "buf00loc", "buf_storage", "burst_length", "wav_ize", "buf_engine", "buflengthSIZE", "buf_sum", "uf_SIZE", "bufDloc", "buf_loss", "uf_len", "cv_size", "burstvalstorage"], "ctx": ["func", "cb", "caps", "nd", "np", "conn", "tc", " cx", "cf", "px", "voc", "acl", "cm", "args", "jp", "cfg", "cam", "fc", "abc", "bc", "nc", "ct", "cd", "window", "cc", "unc", "cv", "obj", "cp", "config", "ctl", "nt", "conv", "fw", "prefix", "act", "tx", "local", "cmp", " context", "ca", "sys", "ns", "mc", "c", "ctrl", "txt", "check", "kt", "req", "kw", "loc", "po", "xc", "pkg", "context", "gc", "wcs", "aux", "hw", "cs", "cn", "cmd"], "object": ["no", "instance", "metadata", "directory", "unit", "condition", "type", "subject", "onet", "number", "data", "thing", "interface", "other", "thread", "external", "null", "relation", "index", "empty", "source", "delete", "child", "item", "ent", "comment", "value", "model", "ob", "order", "archive", "obj", "resource", "package", "attribute", "target", "buffer", "status", "block", "element", "operation", "or", "Object", "library", "job", "identified", "member", "commit", "actor", "environment", "entry", "result", "position", "parent", "component", "at", "array", "out", "o", "complete", "os", "unknown", "user", "node", "associated", "ase", "profile", "error", "art", "document", "oid", "connection", "version", "account", "key", "device", "owner", "event", "service", "file", "detail", "article", "offset", "module", "part", "volume", "operator", "author", "normal", "point", "option", "message", "entity", "context", "image", "address", "zero"], "sequence_desc": ["sequence2description", "sequenceureDesc", "sequence___Desc", "sequence_description", "sequence___des", "sequence_Desc", "sequence___desc", "sequence___dist", " sequence_dist", "sequence2des", "ence_description", "sequence_des", "sequenceureenc", "ence_desc", "sequence_enc", " sequence_Desc", "sequence_dist", "sequenceuredes", "sequenceuredesc", "sequence2Desc", "ence_enc", " sequence_des", "sequence2desc", "ence_Desc", "ence_des"], "rle_bitmap_len": ["rle_bitmap2lib", "rle_bitmap2len", "rle_bitmap3len", "rle_bitmap2l", "rle_bitmap_lib", "rle_bitmap3l", "rle_bitmap_size", "rle_bitmap_Len", "rle_bitmap_vec", "rle_bitmap3Len", "rle_bitmap3vec", "rle_bitmap_el", "rle_bitmap2Len", "rle_bitmap2el", "rle_bitmap_l", "rle_bitmap2size"], "height": ["resolution", "distance", "h", "Height", "dist", "high", "show", "gh", "html", "bottom", "docker", "huge", "rank", "type", "xy", "gravity", "ows", "radius", "rows", "padding", "title", "capacity", "tight", "sky", "angle", "depth", "window", "ty", "through", "host", "total", "size", "count", "history", "ht", "wh", "dim", "border", "crop", "shape", "hash", "style", "grow", "max", "lat", "power", "volume", "background", "hei", "hang", "row", "pi", "density", "alpha", "w", "length", "dimension"], "id": ["bid", "h", "no", "init", "aid", "tag", "type", "link", "i", "iden", "addr", "pid", "oid", "url", "tar", "data", "iq", "name", "ident", "start", "val", "uid", "key", "Id", " fid", "obj", " ID", "iter", "b", "did", "kid", "ID", "index", " tid", "one", "path", "info", "hash", "ref", "offset", "sid", "kind", "it", "ip", "num", "alias", "ad", "status", "base", "vid", "rid", "mid", "k", "ids"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,\n\n        RDMALocalBlock *block, uintptr_t host_addr,\n\n        uint32_t *lkey, uint32_t *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9508, "substitutes": {"rdma": ["rodma", "rdml", "ddma", "ridman", "ldmas", "drml", "rdmas", "ridmic", "ddca", "ndmic", "rcmodel", "hrmic", "redma", "ndma", "rtm", "rdman", "ndm", "rdmu", "redca", "rdmodel", "ndman", "ddmas", "ldmodel", "ldm", "rtma", "rodmu", "rdca", "ddmodel", "rtmu", "rodml", "ddsa", "rtla", "drm", "ddla", "ddm", "ldma", "rtsa", "hrma", "rdsa", "ridma", "drmu", "rcmas", "redla", "rdla", "rtca", "rdmic", "redsa", "rcma", "drma", "ridm", "hrman", "rodm", "rcm", "rtml", "hrm", "rdm"], "block": ["snap", "x", "instance", "inv", "co", "no", "unit", "condition", "tag", "type", "transfer", "pack", "number", "lock", "other", "channel", "blocking", "load", "cache", "def", "ref", "byte", "book", "row", "sync", "link", "model", "group", "map", "raw", "bl", "all", "line", "obj", "join", "blocks", "set", "bus", "open", "draw", "buffer", "word", "p", "wall", "Block", "library", "plugin", "commit", "ck", "rock", "frame", "window", "record", "BL", "store", "b", "prefix", "none", "chain", "profile", "dev", "list", "request", "network", "object", "bc", "cl", "device", "event", "work", "bit", "local", "view", "module", "box", "disk", "part", "check", "ip", "raid", "base", "point", "client", "image", "address", "zero"], "host_addr": ["hostingptr", " host_address", " host_ptr", "host_host", "hostingaddr", "hostingaddress", "host_ptr", "host_address", " host_host"], "lkey": ["plquery", " lmax", "nlmax", "mkey", "lccheck", "l123", "llock", "leport", "slkey", "lclock", "lclient", "olport", "nl123", "ullock", "lequery", "dlentry", "lstr", "olcase", " lchar", "nlice", "lquery", "lbmax", "dlkey", "lbchar", "lchar", " lentry", "lc123", "dlmax", "rchar", "slnote", "ellchar", "rice", "rentry", "mclient", "slchar", "ulKEY", "plport", "nlowner", "lcowner", "lecache", "lestr", "nlentry", "ellnote", "nlkey", "lpKEY", "lentry", "lce", "lice", "lplock", "rstr", "lbce", "dlce", "lcchar", "ellowner", "plcase", "lpcheck", "lecase", "r123", "rclient", "lekey", "olquery", "lcheck", "olkey", "lbentry", "ellkey", "lowner", "lcache", "rowner", "lcase", "ulkey", "lckey", "lcKEY", "plkey", "leclient", "nlce", "rcache", "lport", "lnote", "lpkey", "lcnote", "lKEY", "slowner", "lcice", "lbkey", "mstr", "rmax", "ulcheck", "lmax", "mcache"], "rkey": ["mkey", "rKEY", "rtrule", "rbcond", "srmatch", "vrkey", "rbmatch", "rstart", "lflag", "mrule", "vrlock", "lrule", "erseed", "dKEY", "mno", "drkey", " rflag", "rflag", "mowner", "rfield", "mprint", "wecho", "rcond", " rcond", "srkey", "lchar", "wkey", "lrfield", "drule", "lfield", " rKey", "errule", "rrcode", "wcode", "sronly", "rchar", "drecho", "srstart", "rtkey", " rstart", "drprint", "rbonly", "lseed", "drowner", "rrecho", "rcprint", "rrule", "rno", "vrrule", " rfield", "rseed", "rprint", "rcchar", "rrcond", "erlink", "rtlink", "srKey", "rlock", "srcond", "rtseed", "vrKEY", "wcond", "rbkey", "srrule", "drchar", "rcowner", "mchar", "rckey", "lKey", "drcode", " rmatch", "lrrule", "mfield", "rrkey", "rowner", "lstart", "rKey", "srflag", "rmatch", "llink", "lrno", " ronly", "srlock", "erkey", "lno", "ronly", " rrule", "drcond", "dkey", "srKEY", "lrkey", "recho", "dlock", " rchar", "rlink", "rcode"], "chunk": ["Chunk", "achow", "chork", "chunc", "tchart", "achom", "chedunc", "echack", " chundle", " chimp", "Chunc", "chunks", "Choke", " chunker", "achoice", "chow", " chork", "achart", "chnruck", " choice", "chimp", "chnack", "achace", "chace", "achunks", " choke", "chanch", "achunker", "chnace", "chnunk", "chnunker", "shork", "tchunk", " chom", "shundle", "archruck", "chunker", "echank", "choke", "chank", "chnank", " chanch", "archunk", "chnart", "chruck", "chedunk", "achank", "chnork", "chom", " chunc", "chundle", "achack", "chedoke", "choice", "achunk", "achundle", "chnow", "achimp", "Chunks", "chack", "archanch", "chedunks", "shoice", "echace", " chruck", "tchunker", "chart", "chnanch", "shunk", "chnom", "archom", " chunks", "achork", "Chimp", "tchow", "echunk", "achunc"], "chunk_start": ["chunks_first", "chunks_st", "chunktend", "chunks_end", "chunk_first", "chunker_part", "chunks_len", "chunker_end", "chart_index", "chunktstart", "chart_start", "chunk_begin", "chunk_st", "chunk_size", "chart_end", "chunktpart", "chunktorigin", "chunk_offset", "chart_begin", "chunk_part", "chunks_size", "chunks_start", "chunk_len", "chunks_from", "chunker_start", "chunk_origin", "chunks_offset", "chunker_origin", "chunk_from", "chunk_index"], "chunk_end": ["chimp_ends", "chimp_ending", "chulk_start", "chimp_end", "chulk_offset", "chunk_ending", "chunks_end", "chimp_start", "chunk_offset", "chunks_en", "chunk_ends", "chunk32line", "chunk32end", "chunk_line", "chunk32start", "chunk_stop", "chunks_line", "chulk_end", "chunk32en", "chunk_en", "chunks_start", "chulk_stop"], "total_registrations": ["total_regibration", "total_regestration", "total_regibrations", "total_regibries", "total_resistsrations", "total_resistsrators", "total_registsrations", "total_registries", "total_registsries", "total_resistries", "total_remistrations", "total_registrators", "total_resistsration", "total_regdistrators", "total_remistration", "total_registration", "total_remistsations", "total_regdistrations", "total_regisrations", "total_regdistration", "total_remistsrations", "total_remistries", "total_regestrations", "total_regdistries", "total_regestries", "total_registsations", "total_remistsration", "total_registsrators", "total_remistations", "total_regestations", "total_resistration", "total_regisries", "total_regisrators", "total_resistrators", "total_registations", "total_regisration", "total_remistsries", "total_resistrations", "total_resistsries", "total_registsration", "total_regibations"]}}
{"project": "qemu", "commit_id": "e3697092228770c3b23d0bf524e18b508b109932", "target": 1, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n        if (depth == 16 || depth == 32) {\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds->surface);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 9509, "substitutes": {"s": ["changes", "sb", "ses", "events", "ls", "aws", "comm", "sm", "sv", "er", "as", "sam", "bis", "js", "sys", "c", "t", "source", "state", "se", "w", "rates", "cmd", "ns", "ins", "less", "h", "conf", "ats", "sw", "ies", "settings", "stat", "ps", "an", "http", "sq", "obj", "fs", "a", "sl", "serv", "set", "stats", "ds", "status", "services", "cs", "ims", "p", "i", "sa", "its", "sim", "sports", "ops", "ex", "is", "g", "b", "eps", "os", "hs", "sis", "so", "spec", "r", "ts", "rs", "ss", "es", "z", "als", "gs", "j", "sts", "n", "in", "service", "details", "states", "m", "S", "bs", "qs"], "full_update": ["inner67update", "fullyeredit", "fulllyup", "full_n", " full__UPDATE", "fulllystart", " full__updated", "full_result", "fullernew", " full_n", "full_diff", "fullystart", "full_edit", "fullyup", "fullthebatch", "full__updated", "fully_update", "full__edit", "fulllyupdated", "fullerbatch", "ful_run", "fullthediff", "full_start", "fully_run", "fullerapply", "full_batch", "fullamUPDATE", "ful_up", "full67UPDATE", "full_run", " full_touch", "full1touch", "ful_result", "fullyerupdate", "full67update", "inner_update", "full_up", "fullerdiff", "fullamupdate", "fullyupdated", "full__UPDATE", "fully_edit", "full67apply", "fullyernew", "inner67batch", "full___n", "full_new", "fullamupdated", "fulleredit", "ful_update", " full_updated", "ful_updated", "fullpren", "fulltheapply", "ful_start", "full1edit", "full__new", "full1update", "inner_batch", "full__update", "inner67diff", "full67touch", "full__run", "fullerupdate", "full1updated", "fullyupdate", "fullerrun", "fulltheupdate", " full_UPDATE", " full__update", "full67batch", "fullyerrun", "full67diff", " full_edit", "full_UPDATE", "full67edit", " full__edit", "full_touch", "full_apply", "inner_apply", "inner_diff", "fulllyupdate", "full67updated", "fullamedit", "fully_new", "full_updated", "inner67apply"], "y1": ["Y0", "Y3", "y3", "y0", " y0", " y3", "xy1", "Y2", "xy3", "Y1", " y2", "xy0", "xy2", "y2"], "y": ["p", "x", "xy", "i", "dy", "z", "j", "sky", "page", "scroll", "ey", "iy", "o", "b", "g", "my", "Y", "ym", "offset", "m", "cy", "t", "draw", "k", "w", "gy"], "update": ["init", "id", "add", "version", "end", "start", "window", "date", "new", "val", "dirty", "out", "create", "o", "updated", "bit", "set", "offset", "m", "num", "status", "batch", "up", "image", "w"], "page_min": ["page__start", "row_max", "row_min", "page_start", "page__min", "page_1", "row_1", "row_start", "page__max", "page__1"], "page_max": ["page_end", " page_ax", "page_ax", " page_end"], "linesize": ["linessize", " linesz", " linesizes", "blocksz", "linesz", "blockssize", "linz", "blocksizes", " linessize", "linize", "linesizes", "blocksize", "linsize", "linizes"], "y_start": ["line_range", "line_end", "ymmend", "y_range", "ymmoffset", "line_start", "ymmrange", "ymmstart", "y_offset", "y_end"], "double_scan": ["single_index", "double_read", "double42sc", "doubleplescan", "double42stat", "doublelyindex", "double__scan", "doubleptscan", "single_scan", "doubleJindex", "multi_sc", "multi_reach", "double_scale", "single_run", "double\u0648read", " double_can", "double_can", "doublelyscale", " double_index", "double__scroll", " double_write", "doubleptrun", "doubleJscan", "double_plan", "double2can", "double42run", "double__can", "double\u0648run", "single_send", "double2scroll", "double__scale", "doubleogscan", "double_sc", "double_fan", "double2scale", "doubleplesc", "multi_scale", "double42scan", "doubleptpass", "multi_stat", "single_fan", "doubleogsend", "single_get", " double_scroll", "doubleogplan", "doubleJget", " double_run", "doublelyget", "double_run", "doublelyrun", "doubleplestat", "double\u0648scan", "double_write", "doubleplerun", " double_scale", "double_send", "double_get", "single_plan", "double\u0648fan", "single_read", " double_pass", "double_scroll", "double_pass", "doubleogrun", "doublelyscan", "double_reach", "doubleptwrite", "doubleJrun", "double2scan", "double_stat", "double_index"], "mask": ["hidden", "skip", "flag", "id", "clear", "pad", "map", "lock", "key", "label", "flags", "is", "scale", "hold", "black", "Mask", "shape", "q", "box", "m", "weight", "hide", "ip", "filter", "batch", "mode", "ms"], "depth": ["skip", "dist", "dr", "dq", "deep", "ind", "pad", "ps", "padding", "parent", "stack", "debug", "progress", "patch", "order", "count", "dir", "scale", "details", "dim", "shape", "q", "focus", "orient", "tips", "mode", "density", "level"], "height": ["resolution", "inches", "h", "Height", "high", "gh", "ows", "radius", "rows", "padding", "capacity", "sky", "angle", "window", "ty", "host", "total", "size", "history", "scale", "ht", "ch", "dim", "shape", "view", "max", "volume", "buffer", "hei", "row", "w", "density", "length"], "shift_control": ["shift64flow", "shifterflow", "shift_co", " shift_flag", "shift__ctrl", " shift_score", "hift_cut", "hift_controlled", "shift_cut", "shifterscroll", " shift_length", "shiftingscore", "shiftingcontrol", "hifterctrl", "scale_control", "shiftercontrol", "shift__control", "shift_score", "hift_rate", "hift_scroll", "shift64score", "shift_flag", "shift_controlled", "shift64controller", "hiftercontrol", "shift__controlled", "shiftistctrl", "shift_output", "hift_Control", "shiftablecontrolled", "shifterscore", "push_control", "shift_Control", "hift_controller", "shifterctrl", "push_ctrl", "shiftablecontrol", "hift_control", "shiftablecut", "hift_flag", "hift_left", "shift_number", "shiftingco", "hifterControl", "scale_controller", "shifterControl", " shift_ctrl", "shift_length", "shift_rate", "shiftablecontroller", "shiftercontroller", "shiftistoutput", "shift64control", "hift_ctrl", "shift_left", " shift_number", "push_length", "shift_flow", "hifterscroll", "scale_score", "shift_scroll", "hift_length", " shift_co", "push_output", "shift_ctrl", "shift__flag", "shiftistcontrol", " shift_controlled", "shiftistlength", "shift_controller", "scale_flow"], "line_offset": ["line1position", "link_offset", "line1start", "link_position", "link_start", "line1offset", "link_set", "line1set", "line_start", "line_position", "line_set"], "page0": ["Page1", "page2", "Page2", "p2", "p1", "Page0", "p0", " page2"], "page1": ["phrase0", " page6", "phrase1", "line0", "line1", "page6", "phrase6", "line6"], "bwidth": ["lbcount", "nbcount", "bdist", "nbdim", "lbwidth", " bcount", "bcount", "lbdim", "lbdist", " bdist", "nbwidth", "bdim", "nbdist", " bdim"], "bits": ["ports", "bugs", "units", "reports", "fps", "codes", "ats", "dates", "outs", "points", "pins", "frames", "its", "cats", "bands", "settings", "rows", "jobs", "ps", "issues", "ads", "terms", "fixes", "parts", "flags", "abilities", "fs", "plugins", "bytes", "details", "bs", "bit", "files", "bis", "ints", "keys", "limits", "tops", "weights", "ips", "comments", "pieces", "chains", "locks", "fits", "planes", "ms", "words", "ants"], "disp_width": ["disp2length", "disp_data", "disp2data", "disp___length", "disP_path", "disp___height", "disP_size", "disp_filename", "disp_size", "disp_height", "disp32position", "disp_amount", "disp_left", "disP_width", "disP_left", "disP_length", "disP_data", "disp32width", "disP_amount", "disp___width", "disp_position", "disP_height", "disp_path", "disp2path", "disP_filename", "disp32height", "disp_length", "disP_position", "disp___left", "disp32amount", "disp2width"], "multi_scan": ["multiplepass", "multiaccan", "multiplerun", "multi_check", "multiaxyscan", "multiacgen", "double_check", "multiacpass", "multiacrun", "single_scan", "multi_runner", "single_can", "single_pass", "multiplegen", "multiaxyreach", "multi_reach", "multi_pass", "single_run", "double_pass", "multiplescan", "multiacscan", "multi_gen", "single_gen", "double_runner", "multiaxyrun", "multi_can", "single_reach", "double_run", "double_gen", "multiacreach", "multiaxypass"], "multi_run": ["single_rate", "multi_rate", "multiletscan", "single_out", "single_running", "multi_out", "multiewscan", "multiewupdate", "single_scan", "multiletout", "multiewrun", "multi_update", "multiletrunning", "single_run", "multi__running", "multi_running", "multi__out", "multi__run", "multiletrun", "multiewrate", "multi__scan", "single_update"], "d": ["di", "p", "dc", "dr", "dx", "bd", "D", "f", "dd", "dm", "z", "gd", "dp", "dict", "dt", "da", "g", "dh", "dat", "dim", "fd", "ds", "m", "c", "ad", "db", "e", "w"], "v": ["r", "p", "h", "inv", "value", "vector", "rev", "f", "i", "vr", "format", "version", "function", "ver", "j", "qv", "va", "all", "u", "cv", "ve", "sv", "vt", "ov", "b", "vv", "g", "values", "tv", "var", "iv", "view", "q", "vi", "V", "m", "uv", "c", "wire", "nv", "vs", "message", "vc", "vp", "lv", "w", "conv"], "addr1": ["address1", "address2", " addr0", " addr2", "addr2", "address0", "add2", "addr0", "add1", "add0"], "addr": ["att", "dr", "off", "attr", "err", "dd", "id", "add", "pad", "ii", "ix", "at", "order", "dh", "act", "arr", "Address", "ref", "offset", "adr", "ip", "pos", "alias", "alt", "ptr", "address", "cmd"], "vga_draw_line": ["vga_draw___lines", "vga_clear_lines", "vga_draw___function", "vga_draw_function", "vga_draw_lines", "vga_clear_function", "vga_draw___line", "vga_clear_Line", "vga_draw_Line", "vga_draw___Line", "vga_clear_line"]}}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n", "idx": 9510, "substitutes": {"mask": ["ack", "allow", "flag", "ma", "conf", "comment", "tag", "type", "fix", "perm", "id", "pack", "fee", "warn", "map", "query", "code", "window", "lock", "key", "patch", "in", "config", "flags", "label", "dir", "form", "mb", "transform", "win", "mt", "match", "Mask", "black", " masked", "gray", "bit", "cmp", "set", "hash", "max", "miss", "box", "open", "m", "weight", "check", "bits", "filter", "buffer", "sum", "sk", "block", "mark", "message", "mode", "xml", "image", "ms", "msg", "ask", "cmd"], "attr": ["att", "r", "imm", "ack", "func", "pr", "opt", "dr", "atts", "acc", "cmd", "tag", "err", "rr", "addr", "perm", "typ", "alloc", "vr", "params", "stat", "priv", "str", "tk", "tt", "apt", "key", "rm", "obj", "ak", "temp", "tmp", "md", "emp", "mt", "ext", "tr", "gm", "var", "fd", "attribute", "arr", "cmp", "rt", "hash", "gr", "ctx", "kr", "m", "ctrl", "prop", "txt", "t", "rb", "kw", "pkg", "alt", "ptr", "fac", "msg", "ac"], "tid": ["tempid", "Tid", "tId", "TId", "npid", "nID", "tempId", " tpid", " tId", "tbid", "nId", "Tpid", " tbid", "TID", "tID", "tempbid", " tID", "tpid", "nid", "nbid"], "info": ["update", "no", "json", "type", "iso", "pack", "data", "ind", "fo", " Info", "lock", "other", "zip", "close", "count", "history", "index", "cache", "def", "ok", "about", "now", "sum", "ist", "state", "conf", "mem", "comment", "link", "op", "stat", "auth", "meta", "map", "order", "help", "config", "bar", "note", "trace", "stats", "it", "open", "txt", "buffer", "inf", "status", "inner", "msg", "report", "ack", "init", "conn", "i", "id", "entry", "warn", "Info", "import", "size", "time", "iter", "try", "fi", "error", "list", "where", "f", "debug", "in", "si", "details", "bit", "local", "m", "information", "check", "ip", "num", "image", "INFO"], "fds": [" fDs", "fpdos", "fdcs", "Frs", " fcs", "cfrs", "fdos", "tfys", "fcs", "fifdds", "fdds", "fys", "fpds", "fdDS", "frs", " fns", "tfds", "fuds", "fcd", "tfdos", "tfDs", " fdos", "Fds", " fd", "fcuds", " fys", "fdns", "fifuds", " fuds", "fpys", " frs", "fifds", "fcdds", "cfys", "fwcs", "cfuds", "fd", "fns", "fwDS", "fwds", "Fuds", "fDs", "Fys", "fifd", "fcds", "fDS", " fdds", "fpDs", "fwns", "cfds", " fDS"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n", "idx": 9516, "substitutes": {"vs": ["ts", "caps", "sb", "inv", "ses", "rs", "blogs", "v", "ls", "vr", "ss", "settings", "es", "obs", "ps", "gs", "ys", "vm", "VS", "sts", "iss", "ils", "fs", "vt", "sv", "serv", "is", "values", "s", "bs", "js", "ctx", "Vs", "ds", "stats", "hs", "vd", "cs", "vc", "vp", "lv", "ms", "qs", "ns"], "data": ["r", "p", "dr", "nd", "DATA", "bin", "next", "v", "read", "ata", "pad", " DATA", "str", "Data", "fr", "window", "in", "buf", "size", "d", "bytes", "cache", "dat", "def", "to", "input", "bus", "reg", "ds", "box", "text", "t", "buffer", "ad", "block", "batch", "table", "mid", "mu", "image", "rel"], "len": ["ld", "h", "bin", "lp", "type", "args", "Len", "id", "z", "name", "l", "lf", "str", "en", " length", "dl", "bl", "ail", "lan", "fin", "db", "ll", "lib", "length"]}}
{"project": "FFmpeg", "commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "target": 1, "func": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n", "idx": 9528, "substitutes": {"h": ["r", "p", "hr", "his", "hp", "f", "v", "ih", "hm", "sh", "rh", "l", "comm", "hz", "host", "H", "o", "g", "oh", "history", "hi", "ht", "he", "s", "ch", "ah", "kh", "ha", "dh", "cache", "hl", "hh", "q", "each", "hash", "ctx", "hs", "it", "m", "c", "here", "t", "eh", "hal", "context", "k", "hw", "w"], "pmv_fw": ["pmval7ht", "pmval_fb", "pmw_rf", "pmvi_urg", "pmval7fw", "pmv5fw", "pmv_iw", "pmv_hw", "pmw_fw", "pmV_FW", "pmq_wo", "pmv____fb", "pmv2rw", "pmvi_obj", "pmv_urg", "pmv7tails", "pmw_hw", "pmvp_tf", "pmv____ht", "pmv_rw", "pmvp_flo", "pmv_wo", "pmv___flo", "pmV_wu", "pmv_ld", "pmv___FW", "pmvpyfd", "pmv_wu", "pmvpyfw", "pmvght", "pmq_iw", "pml_def", "pmvp_fd", "pmvpyflo", "pmw_FW", "pmv____fw", "pmv2lb", "pmv2wo", "pmv___obj", "pmv____tails", "pmv_flo", "pmval7fb", "pmvp_fw", "pmv7ht", "pml_lb", "pmv_FW", "pmq_fw", "pmv_tails", "pmvgfw", "pmvi_ld", "pmv_tf", "pmval_ht", "pmval_fw", "pmv5wr", "pmv_fd", "pmv7fb", "pmv_obj", "pmV_fw", "pmv_final", "pmvi_flo", "pml_fw", "pmv2fw", "pmvi_fw", "pmv_fb", "pmv___fw", "pmvi_final", "pmvgfb", "pmv_wr", "pmvgtails", "pmv2def", "pml_rf", "pmv_ht", "pmvi_FW", "pmv2rf", "pmv_rf", "pmq_rw", "pmv7fw", "pmval_tails", "pmv2iw", "pmv___ld", "pmv___final", "pmvpytf", "pmv_lb", "pmv5FW", "pmv___urg", "pmV_wr", "pmv5wu", "pmval7tails", "pmv_def"], "col_mv": ["col_nmtv", "col_mve", "col_vw", "col_pav", "col_mth", "col_Mv", "col_Mve", "col_rvc", "col_rmv", "col_vpr", "col_ymw", "colObjmvc", "col_pw", "col_mvc", "col_mav", "col_mtth", "col_pV", "col___vtv", "col___vv", "colObjmth", "col_ymv", "col___mw", "col_ymvc", "col_pve", "colObjmvert", "colObjmnth", "col_cve", "col___vpr", "col___rmw", "col_rve", "col_tvc", "col_rmvt", "col_numvc", "col_buv", "col_numv", "col_vmvt", "col_vmve", "col_lvc", "col_rmw", "col___mpr", "col_vmv", "col___mve", "col_tth", "col_ymvl", "col_puv", "col_mvd", "col_bve", "col_mV", "col_muv", "col___rmv", "col_cV", "col_nmw", "col_mtv", "col_numvm", "col_lvd", "col_cv", "col_mvl", "col_cw", "col_pvc", "col_mvert", "col_mpr", "col_rvt", "col_lv", "col_numvd", "col_Mw", "col_rpr", "col_Mav", "col___mv", "col___rmvt", "col_mtvc", "col_movd", "col_movc", "col_mnv", "col_mnvc", "col_mov", "colObjmnvc", "colObjmnvert", "col___mvt", "col_movm", "col___vw", "col_mnth", "col_vmw", "col_bv", "col_mnvert", "col_vtv", "col_rw", "col_nmv", "col_ruv", "colObjmnv", "col_mvm", "col_nmpr", "col_rmve", "col_lvm", "col_pv", "colObjmv", "col_rv", "col_rvl", "col_mvt", "col_MV", "col_bvc", "col_tvert", "col_mtvert", "col_mw", "col_vv", "col_tv", "col___rmve", "col_Mvc", "col___mtv", "col_rtv"], "pmv_bw": ["pmv___nbwx", "pmv_lbkw", "pmv_bust", "pmv_cbexp", "pmv_pwl", "pmv_basesw", "pmv_bwe", "pmv_bwl", "pmv_tkw", "pmv_pbw", "pmv3cbwe", "pmv_uwb", "pmv___nbw", "pmv_bbust", "pmv_dwx", "pmv_abwd", "pmv_psw", "pmv_bbkw", "pmv_basew", "pmv_nbsw", "pmv_biwx", "pmv_uew", "pmv_bws", "pmv_fbw", "pmv_nbag", "pmv3cbag", "pmv_nbwl", "pmv_pbag", "pmv_bbwk", "pmv_twk", "pmv_cbag", "pmv_basewl", "pmv_bbew", "pmv_fW", "pmv2gwx", "pmv_gw", "pmv_bkw", "pmv5bf", "pmv_nbw", "pmv2gw", "pmv_biws", "pmv_biwh", "pmv3cbexp", "pmv_pf", "pmv5basesw", "pmv_lbw", "pmv_nbexp", "pmv_bwk", "pmv_abwl", "pmv_dws", "pmv___nbwb", "pmv2bwx", "pmv2gwd", "pmv___nbew", "pmv_fwx", "pmv_gwd", "pmv_mws", "pmv5bsw", "pmv_bexp", "pmv_nbwe", "pmv_uwx", "pmv5bwl", "pmv_lbwk", "pmv_mwx", "pmv_pw", "pmv_basef", "pmv_fbwl", "pmv___bwb", "pmv_cbwe", "pmv_bf", "pmv_bwh", "pmv3bag", "pmv5basef", "pmv2bw", "pmv3bwe", "pmv___bw", "pmv_tust", "pmv_bwd", "pmv_nbwb", "pmv_bW", "pmv_dw", "pmv3bw", "pmv_gwx", "pmv_bwb", "pmv_abw", "pmv_bwx", "pmv2gW", "pmv5basewl", "pmv_fbsw", "pmv_lbust", "pmv2bW", "pmv_bbw", "pmv5basew", "pmv_bbwx", "pmv_gW", "pmv_nbf", "pmv_bsw", "pmv_tw", "pmv2bwd", "pmv_cbw", "pmv_fwd", "pmv_uw", "pmv_sbwd", "pmv_pbwe", "pmv_biw", "pmv_nbwx", "pmv_dwh", "pmv_bag", "pmv_absw", "pmv3bexp", "pmv_sbw", "pmv_bbwb", "pmv_nbew", "pmv_sbwl", "pmv_fbwd", "pmv___bew", "pmv_mwh", "pmv_pbexp", "pmv3cbw", "pmv_sbsw", "pmv_mw", "pmv_nbW", "pmv_bew", "pmv5bw", "pmv_nbwd", "pmv___bwx"]}}
{"project": "FFmpeg", "commit_id": "22fa38f0c85fb31cddbb0bc22a2df5953c702b95", "target": 0, "func": "static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n", "idx": 9533, "substitutes": {"temp": ["ts", "p", "or", "tem", "tc", "mem", "med", "attr", "type", "v", "pre", "test", "tm", "tar", "pt", "ps", "new", "volt", "out", "null", "total", "tmp", "time", "mean", "pool", "emp", "prefix", "index", "tim", "cache", "mint", "tr", "to", "term", "empty", "local", "Temp", "offset", "perature", "average", "mp", "txt", "t", "unt", "buffer", "current", "sum", "ta", "base", "memory", " temperatures", "ptr", "zero"], "uncliped": ["unmasked", "unalmapted", "unalmapisted", "guncamated", "unpixeled", "unalcliped", " uncliping", "unstripd", "unclipisted", "unshapeeds", "unmapisted", "gunclipated", "unapeed", "uncliping", "unpixelied", "unstripeds", "unstriping", " unstripeds", " unclipeds", "uncameded", " unstriping", "uncropied", "unmask1", " unclip1", "unmaped", "unclipied", "unclipeds", "unclipted", "gunclipeded", "unapeeded", "unmasking", "unalclipied", "unshape1", "guncliped", "unmapted", "uncropisted", "unclipeded", "unstrip1", "unclipd", " unstriped", "uncamd", "guncameded", "unshapeed", "unalclipisted", "unalclipted", "unstriped", "uncroped", "unmapied", "unalmaped", "guncamed", " unstrip1", "unaped", "guncamd", "uncamed", "unclipated", "uncamated", "gunclipd", "unpixelted", "unclip1", "unalmapied", "unshapeing", "unapeated", "unstripated", "unstripeded", "unmaskeds", "uncropted", "unpixelisted"], "ones": ["ts", "lines", "codes", "vals", "onents", "aps", "ies", "ices", "points", "phones", "icks", "als", "oses", "ps", "ients", "eros", "amps", "oned", "ads", "wise", "ias", "ONES", "terms", "tes", "flags", "ples", "inters", "oms", "devices", "des", "odes", "values", "offs", "s", "names", "ions", "os", "ms", "times", "one", "tones", "cells", "ases", "weights", "bits", "ips", "mods", "locks", "eds", "cs", "ims", "bs", "zero", "ids", "ins"], "max": ["r", "step", "x", "co", "nd", "on", "Max", "ma", "h", "inv", "med", "master", "v", "MAX", "cur", "norm", "end", "map", "root", "parent", "created", "out", "range", "n", "plus", "size", "ax", "net", "st", "mad", "rest", "maximum", "act", "recent", "full", "view", "last", "box", "m", "top", "mx", "base", "up", "cut", "k", "mod"], "min": ["p", "skip", "mm", "minus", "emin", "mem", "med", "master", "member", "v", "lower", "l", "mit", "start", "MIN", "lock", "small", "only", "Min", "lt", "minute", "n", "in", "size", "tmp", "mean", "mini", "s", "mad", "mint", "mn", "mind", "local", "q", "m", "mp", "part", "pos", "mi", "mask", "base", "beta", "minimum", "mins", "mid", "sort", "mod"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,\n\n                                target_ulong pc2, TCGv r_cond)\n\n{\n\n    int l1;\n\n\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);\n\n\n\n    gen_goto_tb(dc, 0, pc2, pc1);\n\n\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);\n\n}\n", "idx": 9546, "substitutes": {"dc": ["di", "dr", "tc", "DC", "df", "cm", "dd", "dm", "tm", "dp", "fc", "bc", "nc", "ct", "cd", "disc", "mac", "dl", "lc", "dt", "cc", "rc", "arc", "cp", "da", "td", "d", "ec", "ds", "ci", "c", "mc", "sc", "xc", "cs", "pc", "vc", "gc", "cca"], "pc1": ["arcOne", "lc1", "pc4", "pc0", "arc1", " pcOne", "lOne", " pc4", "lc4", "l4", "PC1", "PC2", "arc2", "l2", "arc0", "pcOne", "lcOne", "PC0", " pc0", "lc2", "PCOne"], "pc2": ["fc1", "PC5", "fc256", "PC256", "fc4", "vc1", "PC02", "pc4", "vc4", " pc5", " pc4", "PC8", "isc1", "pc256", " pc8", "PC1", "fc2", "PC2", "mc2", "mc8", "pctwo", "mc1", " pc02", "PC4", "pc02", "mc5", "vc02", " pc256", "PCtwo", "isctwo", "isc2", "vc2", "isc4", "pc5", "pc8", " pctwo"], "r_cond": ["r2crit", " r__condition", " r_condition", "r2Cond", "r__con", "r__cond", " r2cond", " r_con", " r__Cond", "r_condition", "r2cond", "r__Cond", " r2crit", " r__cond", " r_Cond", "r2con", "r2condition", " r2condition", " r2con", " r_crit", " r__con", "r_Cond", "r_con", "r__condition", "r_crit"], "l1": ["LId", "llone", "lc9", " l0", "lc0", "l0", "sl81", "l81", "lc1", " l9", "ll11", "slOne", "lOne", "L11", "Lone", "sl9", "nl1", "L1", "tl9", " lId", "nl81", "lcId", "lc81", "tl1", "lone", "l11", "l2", "nlOne", "tl81", "ll2", "nl9", " l11", " l2", "l9", "sl1", "lcOne", "tl2", "lId", "ll1", " lone", "L2", "L0", " l81", "lc2"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "substitutes": {"bs": ["ts", "bf", "sb", "rs", "aos", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "cks", "gs", "ubs", "bl", "bi", "fs", "bh", "b", "lbs", "os", "ms", "ks", "bis", "js", "hs", "ds", "ubis", "bits", "bps", "aus", "vs", "cs", "bm", "ns"], "offset": ["off", "um", "slot", "xy", "id", "url", "onto", "oid", "end", "location", "padding", "start", "scroll", "shift", "align", "unc", "o", "seek", "pointer", "index", "offs", "kh", "os", "attribute", "set", "ref", "fp", "reset", "Offset", "oss", "tile", "t", "et", "top", "base", "row", " offsets", "ptr", "address", "rot", "error"], "n_start": ["n___start", " n_first", "n___since", "n_first", "n_since", "n___first", " n_since", "nPend", "nPfirst", "nPstart", "n___end", "nPsince"], "n_end": ["nipstart", " n_fin", "n___fin", " n_target", "n___start", "n_target", "n_ends", "nipends", " n_ends", "niptarget", "n_fin", "nipend", "n___end"], "num": ["uni", "nom", "no", "common", "nn", "off", "np", "um", "final", "mult", "un", "nb", "om", "number", "na", "NUM", "n", "nt", "nm", "begin", "dim", "node", "set", "Num", "con", " n", "mu", "mon"], "m": ["r", "p", "mm", "h", "metadata", "mem", "M", "v", "cm", "dm", "tm", "meta", "j", "vm", "rm", "n", "sm", "nm", "b", "g", "mt", "mb", "mint", "gm", "mn", "mr", "module", "mc", "c", "mp", "this", "mi", "spec", "man", "ms", "w", "bm", "msg"], "s": ["ts", "p", "changes", "sb", "ats", "ses", "rs", "sa", "i", "ls", "sp", "ss", "its", "als", "ps", "xs", "gs", "aws", "sts", "sv", "fs", "b", "is", "si", "sam", "os", "ms", "sn", "bis", "js", "sys", "stats", "ds", "hs", "S", "bits", "spec", "vs", "cs", "state", "ims", "ns"], "l2_index": ["l2_list", "l1_inc", "l1_index", "l2___path", "l2erindex", "l2__slice", "l2_slice", "lTwo_ind", "latterptprefix", "l2__index", "l22path", "latter_alias", "l2___set", "l3_start", "l2jstart", "l2ptindex", "l2ptprefix", "l2ptalias", "l56erpath", "l2_seed", "l2___second", "l2_default", "ltwo_set", "l2_pos", "l56_default", "l2erpath", "l2___status", "l3_Index", "l2_path", "l20_status", "l2_i", "l3_list", "l20_index", "l2__ind", "l2ptsecond", "latterptalias", "l2___prefix", "latter_second", "latterptsecond", "l2___i", "l2dlist", "l3_ind", "latter_index", "l2_prefix", "l56erdefault", "l2_inc", "l2dIndex", "l2erdefault", "l2__Index", "l56_index", "l2___seed", "l20_path", "l2_start", "l56_second", "l2jindex", "l2jIndex", "l2ersecond", "l3_index", "latter_prefix", "l2___index", "ltwo_index", "l22default", "l2jlist", "latterptindex", "l56_path", "l2_ind", "l56erindex", "l22second", "l56ersecond", "l1_Index", "ltwo_pos", "lTwo_slice", "l2dindex", "l2dstart", "lTwo_index", "l2_alias", "l2_set", "ltwo_i", "l2_second", "l20_seed", "l2___alias", "l1_ind", "l2_status", "l1_start", "l2_Index", "l1_offset", "l2___pos", "l22index", "lTwo_Index"], "ret": ["r", "flag", "RET", "final", "mem", "ft", "rev", "f", "err", "cont", "success", "jp", "re", "result", "prot", "j", "gt", "Ret", "deg", "val", "rem", "after", "nt", "total", "count", "ne", "rets", "tmp", "mt", "ext", "tr", "bit", "elt", "rt", "ref", "tail", "reset", "tf", "inter", "t", "ber", "len", "res", "true", "ll", "det", "alt", "ter", "conv"], "l2_offset": ["l2_address", "ltwotheattr", "l2faddress", "l2fpointer", "l2theattr", "l2foffset", "l2ftable", "ltwothename", "ltwo_name", "l3_table", "l2_attr", "l3_offset", "l2theoffset", "l3_pointer", "ltwo_table", "ltwo_attr", "l2_name", "ltwo_offset", "ltwothetable", "l2thetable", "l3_address", "l2_pointer", "ltwotheoffset", "l2thename"], "l2_table": ["l2_list", "l2_trace", "l2istbuffer", "lapping_table", "lappingibpoint", "l2Ppoint", "l2Jbuffer", "l2Dtrace", "l2ptqueue", "lapping_point", "lappingibtable", "l2_TABLE", "l2_point", "l2ptpoint", "l2pttable", "l2ptinternal", "l21isttable", "l2istname", "l2Pinternal", "l2ptterm", "l2ptwindow", "l3_server", "l2__table", "l2___window", "l3_module", "l2_collection", "l2___table", "l3_TABLE", "l2jtab", "l2mtmp", "l2Dserver", "lapping_tmp", "l2mname", "l2_tab", "l2mtable", "l2mbuffer", "l132Jtab", "l10_point", "ltwo_window", "l3_list", "l2Ptable", "l21_tmp", "l2_name", "l2Dpoint", "l21_table", "l10_tab", "l132Jcollection", "l2Dtable", "l132Jtable", "l21isttmp", "l2_tmp", "l2thebuffer", "l2_server", "l10_table", "l132_collection", "l3_table", "l3_tab", "l2_term", "l2_window", "l2___queue", "ltwo_table", "l2Jcollection", "l132_tab", "l2jmodule", "l2jtable", "l2isttrace", "l10Dtab", "l2isttab", "l2isttable", "l2___term", "l132Jbuffer", "l2ibtable", "l2_queue", "l21_buffer", "l10Dpoint", "l2ibinternal", "l2pttmp", "l2ibtmp", "l2Jtable", "lapping_internal", "l132_buffer", "lappingibinternal", "l2_module", "l2jserver", "ltwo_term", "l2Jtab", "l10Dtable", "l10Dtrace", "l132_table", "l2__tab", "l2__list", "l2themodule", "l3_buffer", "l2isttmp", "l21istbuffer", "l2Dtab", "l21istname", "l2Dmodule", "l21_name", "ltwo_queue", "l2Ptmp", "lappingibtmp", "l2_buffer", "l2thetable", "l10_trace", "l2thetab", "l2__TABLE", "l2ibpoint", "l2istpoint", "l2_internal"], "cluster_offset": ["cluster_seek", "cluster2seek", "clluster_offset", "cluster_base", "cluber_attribute", "clbuster_value", "cluster2done", "cluber0pointer", "clusterIPoffer", "clusterIPpoint", "cluster____address", "cluster___table", "cluster_style", "cluster_attribute", "cluber0off", "cluster_location", "cluster2off", "clust2location", "cluster_range", "clbuster____value", "cluster____value", "clbuster____info", "cluster0attribute", "cluster_info", "cluster_table", "clust_done", "cluster___address", "cluster_address", "cluster___offset", "clause_offset", "clust_offset", "clusteripbase", "cluster___value", "cluster____offset", "clause_Offset", "cluster_pointer", "cluster32off", "clusterEaddress", "clluster_table", "clusterEoffset", "clust_point", "cluster0off", "cluster2offset", "clusterIPoffset", "cluber_pointer", "clluster___offset", "clbuster_offset", "clust_location", "cluster____info", "cluster2offer", "cluster0pointer", "cluster_not", "clusterEvalue", "clust_seek", "clust_offer", "cluster_point", "clbuster____offset", "clause_length", "cluster___base", "cluster32location", "cluster_offer", "clbuster____address", "clluster_base", "clust_style", "cluster2location", "clluster___base", "cluster_Offset", "cluber0offset", "cluster_value", "clust2done", "cluster_size", "clusteriptable", "clusteripoffset", "clbuster_address", "cluster___info", "clust2offset", "clusterIPseek", "clumn_not", "cluber_off", "cluber0attribute", "clumn_size", "clust2off", "cluster0offset", "clust_off", "cluster_length", "clluster___table", "clause_index", "cluster32offset", "cluster32done", "clbuster_info", "cluber_offset", "clusterEinfo", "cluster_off", "cluster_done", "cluster2point", "cluster_index", "clumn_range", "clumn_offset"], "nb_clusters": ["nb_declograms", "nbJcontancers", "nb_execograms", "nb_clususters", "nb2cluster", "nb_combusters", "nb_histues", "nb2clusters", "nb2collients", "nb_allusters", "nb_cliques", "nb_custers", "nb_coci", "nb2clients", "nb_clroups", "nb2declusters", "nb2clroups", "nb_cloudroups", "nb_decliders", "nb_contusters", "nb_declodes", "nb_plodes", "nb_glograms", "nb_cooses", "nb_clusicas", "nbJcontodes", "nb_execroups", "nb_combubes", "nb_colusters", "nb2declroups", "nb_Cluster", "nb_clores", "nb_pluster", "nb_combients", "nbJcontuster", "nb_clicas", "nb_cograms", "nbJclodes", "nb_contores", "nb_cluster", "nb_clonents", "nb_constograms", "nbofclusters", "nb_consticas", "nb_cloudusters", "nb_glodes", "nbofclonents", "nb_glusters", "nb_cliders", "nbJclusters", "nb11scliders", "nbofclients", "nb_CLients", "nb_histores", "nb_plients", "nb_coonents", "nb_Clonents", "nb_CLroups", "nb11clgroups", "nb_gallients", "nbaxyclicas", "nb_chues", "nb_Clients", "nb11cliders", "nb_colancers", "nb_cloci", "nb_croups", "nb2cliques", "nballclusters", "nb_chograms", "nb__contresses", "nb2declanguages", "nb_coients", "nb_collients", "nb2colliques", "nb2declients", "nb_plusters", "nb_declusters", "nb_cients", "nbJcluster", "nb_clograms", "nb_histusters", "nbaxyconstubes", "nb__clores", "nb_declubes", "nb_contodes", "nb_declicas", "nbaxyconsticas", "nbofslusters", "nb11sclients", "nb_clients", "nballclroups", "nb_chusters", "nb_allograms", "nb_sclgroups", "nb_scliders", "nbofslients", "nballclusroups", "nb_Closes", "nb11clients", "nb__clues", "nbofcloses", "nb_chores", "nb_declgroups", "nb_contresses", "nbaxyclusters", "nb2cloci", "nb_Cliques", "nb_colluster", "nbofsloses", "nballclususters", "nb_clues", "nb11clusters", "nb_constusters", "nb__contusters", "nb_cloudanguages", "nb_ploci", "nb_closes", "nb_custer", "nb__clusters", "nb_clgroups", "nbJcontusters", "nb_clusroups", "nballclusograms", "nb_declroups", "nb_combuster", "nb_sloses", "nb_collusters", "nb_clusubes", "nb_constubes", "nb_Clusters", "nb_contuster", "nb_cloudients", "nb2collusters", "nballclograms", "nbaxyclubes", "nb_gallograms", "nb__contores", "nb_combicas", "nb_gallusters", "nb_allicas", "nbJclancers", "nb_contancers", "nb_colloci", "nb2pluster", "nb_slients", "nb_colliques", "nb_coluster", "nb_chubes", "nb2ploci", "nb_chicas", "nb_CLanguages", "nb11sclgroups", "nb_gallodes", "nb_contues", "nb_chresses", "nb_clusograms", "nb_plancers", "nb2plients", "nb_clanguages", "nbofslonents", "nb_glients", "nb_combiques", "nb_slonents", "nb_execusters", "nb_declients", "nb_clodes", "nb_combroups", "nb11sclusters", "nb_declanguages", "nb__clresses", "nb__contues", "nbaxyclograms", "nb_sclients", "nb_colodes", "nb2clanguages", "nb_clubes", "nb_CLusters", "nb_slusters", "nbaxyconstusters", "nb_collgroups", "nb_cousters", "nb_colliders", "nb_clresses", "nb2colluster", "nbaxyconstograms", "nb_histresses", "nb2plusters", "nb_clancers", "nb_sclusters", "nb_allubes"], "old_alloc": ["oldMarch", "oldobjarch", "oldMalloc", "oldobjmem", "newMmem", "old_arch", "oldMoc", "old___arch", "old_oc", "old___alloc", "new_alloc", "old___oc", "newMalloc", "old___mem", "oldobjoc", "new_oc", "oldobjalloc", "new_mem", "new_arch", "newMoc", "oldMmem", "newMarch", "old_mem"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static int tx_consume(Rocker *r, DescInfo *info)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    char *buf = desc_get_buf(info, true);\n\n    RockerTlv *tlv_frag;\n\n    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\n\n    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\n\n    uint32_t pport;\n\n    uint32_t port;\n\n    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;\n\n    uint16_t tx_l3_csum_off = 0;\n\n    uint16_t tx_tso_mss = 0;\n\n    uint16_t tx_tso_hdr_len = 0;\n\n    int iovcnt = 0;\n\n    int err = ROCKER_OK;\n\n    int rem;\n\n    int i;\n\n\n\n    if (!buf) {\n\n        return -ROCKER_ENXIO;\n\n    }\n\n\n\n    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\n\n\n\n    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\n\n    if (!fp_port_from_pport(pport, &port)) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {\n\n        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);\n\n    }\n\n\n\n    switch (tx_offload) {\n\n    case ROCKER_TX_OFFLOAD_L3_CSUM:\n\n        if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    case ROCKER_TX_OFFLOAD_TSO:\n\n        if (!tlvs[ROCKER_TLV_TX_TSO_MSS] ||\n\n            !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n        tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_MSS]) {\n\n        tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n        tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]);\n\n    }\n\n\n\n    rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) {\n\n        hwaddr frag_addr;\n\n        uint16_t frag_len;\n\n\n\n        if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        if (iov[i].iov_base) {\n\n            g_free(iov[i].iov_base);\n\n        }\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 9574, "substitutes": {"r": ["self", "p", "cr", "h", "dr", "hr", "ra", "rs", "rr", "v", "err", "ri", "vr", "re", "reader", "rec", "rf", "R", "usr", "nr", "rc", "o", "er", "b", "d", "g", "s", "ro", "rt", "mr", "rar", "kr", "br", "m", "c", "rx", "t", "rb", "rw", "e", "w", "rd"], "info": ["self", "report", "conf", "mem", "f", "json", "from", "op", "data", "when", "re", "tm", "entry", "rec", "auth", "Info", "fo", "nr", "http", "config", "o", "is", "hi", "history", "details", "recent", "te", "def", "try", "os", "user", "full", "isu", "rt", "about", "now", "it", "with", "information", "text", "check", "inf", "current", "res", "description", "context", "INFO", "zero", "error"], "dev": ["pro", "DEV", "Dev", "conn", "ev", " device", "attr", "addr", "pack", "cam", "priv", "ver", "device", "nt", "obj", "er", "ch", "def", "iv", "tx", "Device", "kr", "ad", "ptr", "hw", "w", "rel"], "buf": ["cb", "off", "proc", "mem", "bin", "cap", "ff", "v", "err", "Buffer", "alloc", "pb", "data", "bc", "str", "uf", "raw", "bl", "rc", "cv", "img", "tmp", "obj", "buff", "b", "bytes", "arr", "queue", "Buff", "vec", "br", "box", "txt", "text", "buffer", "block", "rb", "rw", "pkg", "xff", "w", "msg", "conv", "cmd"], "tlv_frag": ["tlv_flig", "tlv_pragg", "tlv_brig", "tlv_flagg", "tlv_brags", "tlv_brag", "tlv_frags", "tlv_fragg", "tlv_prag", "tlv_flags", "tlv_bragg", "tlv_prags", "tlv_flag", "tlv_prig", "tlv_frig"], "tlvs": ["tvvses", "tvvns", "hvvs", "tlfts", "txto", "Tlvts", "tlegses", "tpkgts", "tlfls", "tpools", " tlvz", " tcfs", "tlfb", "tlvgs", "vxto", "tvvis", "tlfs", " tcfis", "tpkgrs", "vxts", "tvvds", "tlfS", "tvls", " tlfls", "Tlfis", "txtds", "itlvd", "hlvs", " tlfs", "tvses", "tlvb", "Tlvl", "tlvds", "tcfses", " tlvb", "tvvS", "tlvses", "tlogses", "tlics", " tlvis", "vlvo", "tlvts", "tlfns", "tilds", "Tlfrs", "Tlvrs", "itvgs", "tlvl", "tvvz", "tufs", "tlegz", "itlvgs", "vlvs", "tlvz", "tlvis", "tvb", "tlvS", "tvvs", "txts", "tloggs", "tvs", "tlvd", " tlvgs", "twll", "tlvls", "vxtds", "tpoolS", "tvgs", "tvvo", "tvvl", "tcfis", "Tlfs", "tvd", "tengs", "tlogd", "tcfz", "tlfl", "tlvrs", "vlvds", "Tlvs", "hvvns", "twlis", "tufb", "itvs", " tlfgs", "tildds", "hlvns", "tengd", "itlvses", "tlicrs", " tcfz", "Tlfl", "tlvns", "Tlvis", "tufgs", "hvvS", "tlfrs", "itlvs", "tufls", "tpoolns", " tlfb", "tildo", "itvses", " tlvls", "tlicts", "tlegis", " tcfses", " tlvses", "tcfs", "tengses", "tlvo", "tenggs", "tlogs", "itvd", "tlfgs", "Tlfts", "twls", "hlvS", "tpkgs", "tlegs", "tlfis"], "ROCKER_TLV_TX_MAX": ["ROCKER_TLV_TRIDMIN", "ROCKER_TLV_TR_Max", "ROCKER_TLV_TX_MIN", "ROCKER_TLV_TXIDmax", "ROCKER_TLV_TX__MIN", "ROCKER_TLV_TRIDMAX", "ROCKER_TLV_TX__SIZE", "ROCKER_TLV_TX__MAX", "ROCKER_TLV_TRIDMax", "ROCKER_TLV_TR_MIN", "ROCKER_TLV_TR_max", "ROCKER_TLV_TR_SIZE", "ROCKER_TLV_TXIDMax", "ROCKER_TLV_TXIDMIN", "ROCKER_TLV_TX_Max", "ROCKER_TLV_TXIDMAX", "ROCKER_TLV_TR_MAX", "ROCKER_TLV_TX_max", "ROCKER_TLV_TX_SIZE", "ROCKER_TLV_TRIDSIZE", "ROCKER_TLV_TXIDSIZE", "ROCKER_TLV_TX__Max"], "iov": ["iol", "ors", "sw", "iao", "ih", "mg", "isl", "vr", "ipher", "oys", "ii", "iph", "sels", "ibl", "ibe", "ov", "ortex", "iv", "og", "js", "vec", "ogo", "isco", "io", "argo", "ip", "ensor", "mn"], "pport": ["pro", "p", "ports", "pas", "pl", "opt", "rs", "cap", "pp", "addr", "support", "vr", "pe", "phil", "pg", "mph", "pt", "prot", "supp", "Port", "policy", " sport", "cp", "tif", "sl", "serv", "eport", "vet", "act", "pit", "arp", "rog", "ort", "fi", "lex", "phy", "ctx", "pen", "mp", "pos", "ip", "per", "upp", "iff", "PORT", "ping", "orts", "vp", "ptr", "pet", "socket", "jp"], "port": ["ports", "p", "limit", "ORT", "tag", "type", "fat", "pid", "format", "pe", "version", "pt", "prot", "import", "key", "Port", "channel", "cp", "count", "size", "server", "serv", "eport", "offset", "ort", "export", "priority", "pos", "ip", "point", "PORT", "pc", "ptr", "host", "address", "length", "socket"], "rem": ["rom", "mem", "pack", "re", "rec", "warn", "Rem", "val", "raw", "progress", "rm", "rel", "xp", "REM", "par", "rest", "cmp", "fin", "rx", "req", "iam", " resp", "num", "res", " res", "im", "resp", "conv"], "i": ["di", "p", "ir", "v", "ri", "l", "ii", "xi", "j", "I", "phi", "bi", "b", "iat", "fi", "it", "ia", "ci", "m", "io", "ip", "mi", "ij", "ti", "im", "pi", "ki"], "iovcnt": ["iovCpt", "iovcpt", "lvCnd", "lvCnt", "lvcct", "iovCnd", "iovdcpt", "iovlcnd", "lvcnt", "iovcct", "lvcnd", "iovdcnd", "iovdcct", "iovCct", "lvcpt", "lvCpt", "lvCct", "iovCnt", "iovdcnt", "iovlcnt", "iovlcpt", "iovlcct", "iovcnd"]}}
{"project": "FFmpeg", "commit_id": "bd8ae4885b905415f0e86d4e348c4b72be81e6e6", "target": 0, "func": "AVFilterFormats *avfilter_all_colorspaces(void)\n\n{\n\n    return avfilter_make_format_list(35,\n\n                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,\n\n                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,\n\n                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,\n\n                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,\n\n                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,\n\n                PIX_FMT_RGB32,    PIX_FMT_BGR32,\n\n                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,\n\n                PIX_FMT_RGB24,    PIX_FMT_BGR24,\n\n                PIX_FMT_RGB565,   PIX_FMT_BGR565,\n\n                PIX_FMT_RGB555,   PIX_FMT_BGR555,\n\n                PIX_FMT_RGB8,     PIX_FMT_BGR8,\n\n                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,\n\n                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,\n\n                PIX_FMT_GRAY8,    PIX_FMT_PAL8,\n\n                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK\n\n                PIX_FMT_NV12,     PIX_FMT_NV21);\n\n}\n", "idx": 9576, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n", "idx": 9584, "substitutes": {"base": ["r", "p", "bf", "se", "quote", "master", "from", "type", "i", "f", "id", "data", "re", "bp", "name", "l", "new", "root", "parent", "shadow", "out", "bi", "null", "bar", "use", "server", "domain", "bound", "b", "prefix", "file", "back", "scale", "pa", "address", "super", "bas", "local", "set", "reset", "Base", "m", "check", "t", "buffer", "block", "source", "ase", "socket", "based", " b", "template", "state", "lb", "bs", "bm"], "irqA": ["iriquAR", "irqqAs", "irquestA", "iriqAs", "irqqE", "irquD", "iriqAN", "irwareE", "irqqA", "irtqE", "irquA", "irqqAR", "irtwareA", "iriqAB", "irqqAB", "iriquA", "irtwareAN", "iriqA", "irqqD", "irquestAR", "irqqAN", "irquestAB", "irqE", "irwareAs", "irwareA", "irqD", "irtqA", "irqAR", "irtwareE", "iriquAB", "irquAR", "iriqAR", "iriqD", "iriquD", "irtqAN", "iriqE", "irqAs", "irtwareAs", "irqAN", "irquAB", "irqAB", "irtqAs", "irquestD", "irwareAN"], "irqB": ["irqBB", "irqqB", "iriqB", "irq1", "ioriqT", "iriqT", "irqqE", "\u00edqiB", "iriq1", "iorqT", "irqiE", "irqT", "irquB", "ioriqB", "irqu1", "\u00edqE", "irqqL", "iorqV", "irqE", "irceB", "irqL", "irqq1", "\u00edqBB", "irceL", "iriqV", "\u00edqL", "iorq1", "irqiB", "irqiL", "irqqBB", "irqV", "\u00edqiE", "\u00edqB", "\u00edqiL", "iorqB", "irqqT", "irceE", "irqqV", "irqiBB", "irquV", "irquT", "\u00edqiBB", "ioriq1", "ioriqV", "irceBB"], "chrA": ["chrcA", "chmB", "shrcA", "chrL", " chdrAn", "shrcP", "chrP", "shrL", "chmrU", "chrtA", "chrtB", "chmrB", "chrtU", "chrsA", "chdrB", "chrcP", "chrtAn", "shrcB", "chdrA", " chrU", "chmA", " chdrA", "chmP", " chdrB", "chrcL", "chrsP", "shrcL", "shrA", "shrP", "chrsL", "chdrU", "chmrA", " chdrU", "chrU", "chrcB", "chdrAn", "chrsB", "chrAn", "chmrAn", "shrB", " chrAn", "chmL"], "chrB": ["corr2", "chtG", "chrcG", " chrAB", "chrtA", "corrC", "chrtB", "chrcC", " chtA", "chrarA", "chrar2", "corrB", "corrA", "corrtC", "chrarC", "chrG", "chrt2", "chr2", "corrt2", "chtB", "chrAB", "chtAB", " chrG", "chrtG", "chtA", "chrc2", " chtAB", "chrcB", "chrarB", "chrcAB", "corrtB", "corrtA", "chrtAB", "chrtC", "chrC", "chrcA", " chtG", " chtB"], "clock": ["cker", "watch", "step", "sync", "timeout", "vector", "addr", "ser", "ck", "version", "seed", "boot", "ver", "start", "lock", "hello", "bot", "cc", "change", "cor", "Clock", "ctl", "time", "server", "loop", "serv", "olar", "acter", "tick", "sleep", "node", "set", "sys", "mr", "offset", "poll", "c", "counter", "check", "ber", "block", "timer", "ctr", "frequency"], "it_shift": ["itfshift", "IT_push", "IT_shift", "it_push", "IT_hift", "it_load", "it_hift", "t_shift", "t_hift", "t_load", "itfhift", "itfload"], "dev": ["DEV", "ev", "de", "sh", "data", "cam", "stick", "des", "def", "var", "go", "Device", "t", "ad", "db", "state", "w", "del", "cmd", "av", "develop", "h", "sw", "Dev", "mem", "dd", "test", "priv", "pt", "env", "raw", "ve", "obj", "temp", "a", "vt", "enc", "serv", "app", "scan", "sd", "desc", "ds", "p", "off", "conn", "cur", "serial", "pad", "out", "slow", "dem", "tr", "gu", "att", "pro", "eng", "v", "add", "val", "debug", "device", "n", "ch", "dat", "adv", "dis", "disk", "det", "spec"], "s": ["self", "ts", "p", "r", "h", "sb", "sw", "ses", "rs", "sa", "v", "ls", "i", "sh", "sp", "ss", "its", "ps", "gs", "j", "ys", "comm", "sts", "n", "us", "south", "fs", "sv", "a", "g", "b", "sl", "is", "bs", "sam", "ins", "os", "sd", "sys", "js", "hs", "ds", "m", "S", "so", "c", "t", "sc", "spec", "cs", "sub", "se", "w", "socket", "qs", "ns"], "d": ["r", "di", "p", "ld", "h", "dr", "dx", "bd", "D", "dq", "f", "v", "du", "dd", "de", "dm", "z", "l", "dict", "j", "dt", "n", "o", "pd", "da", "b", "g", "did", "td", "dh", "dat", "fd", "sd", "dn", "ds", "m", "c", "t", "dj", "ad", "db", "e", "w"]}}
{"project": "FFmpeg", "commit_id": "a744064c4155bde063b9e8a47699542be3b8e5eb", "target": 1, "func": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}", "idx": 9598, "substitutes": {"s": ["ts", "less", "erences", "h", "sb", "sets", "ats", "sw", "ses", "rs", "ls", "args", "ss", "settings", "es", "its", "als", "csv", "ps", "xs", "gs", "acs", "aws", "comm", "ops", "sts", "parts", "sq", "sf", "a", "fs", "sv", "is", "serv", "b", "st", "os", "set", "sg", "js", "sys", "hs", "ds", "c", "S", "txt", "t", "services", "vs", "cs", "ims", "bs", "qs", "ants", "conv", "ns"], "i": ["ami", "x", " ti", " m", " ii", "ind", "ix", "iu", "bi", " I", "remote", "index", "li", " my", "\u0438", "c", "io", "t", "batch", "ti", "mu", "ms", " pi", "gi", "ic", "iq", "ei", "I", "phi", "info", " bi", "q", "it", "qi", "mi", "ij", "ki", "me", "ims", "ui", "p", "init", "yi", "uri", "id", "xi", "sim", "oi", "ex", "multi", "is", "y", "ini", "fi", "ci", "chain", "pi", "us", "di", " multi", "v", "ri", "ai", "ii", "j", "ji", " mi", "in", "hi", "si", " li", " ni", "m", "ip", "zi", " j", "base", "im", "ski"]}}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "func": "void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n", "idx": 9607, "substitutes": {"block": ["sync", "list", "Block", "bin", "link", "pre", "pack", "frame", "model", "cell", "bc", "group", "map", "cl", "lock", "raw", "bl", "record", "BL", "array", "line", "event", "load", "blocks", "bit", "tx", "hash", "ref", "view", "set", "box", "c", "byte", "check", "chain", "ip", "buffer", "base", "row", "point"], "i": ["cli", "x", " ti", " m", "err", "json", " ii", "ind", " vi", "ix", "iu", "bi", " I", "ni", "PI", "print", "index", "li", "\u0438", "io", "this", " c", "ti", "ms", " pi", "gi", "ic", " index", "iq", "ei", "I", "phi", "my", "info", " bi", "q", "set", "it", "qi", "mi", "asi", "ki", "me", "ims", "ui", "p", " l", "init", " wi", "span", "uri", "xi", " ki", " iter", "sim", "oi", "at", "ex", "multi", "slice", "g", "is", "y", "ini", "fi", "ci", "chain", "pi", "us", "di", " multi", "v", "ri", "ai", " t", "ii", "mac", "j", " mi", "key", "in", "loop", "si", " li", " ni", "m", " di", "ip", "zi", " j", "base", "point", "im", "life", " si"], "temp": ["ts", "p", "tem", "tc", "mem", "type", "cap", "v", "pre", "stem", "sp", "output", "data", "tm", "tar", "pt", "result", "map", "lock", "zip", "out", "null", "tmp", "pool", "emp", "form", "mt", "cache", "mint", "tr", "tab", "term", "tx", "Temp", "set", "m", "mp", "txt", "t", "buffer", "current", "base", "template", "alt", "ptr", "w", "mod"]}}
{"project": "qemu", "commit_id": "603987488c61ca02ee99890d07cdaecdb118a659", "target": 1, "func": "PCIBus *pci_pmac_init(qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    UNINState *d;\n\n\n\n    /* Use values found on a real PowerMac */\n\n    /* Uninorth main bus */\n\n    dev = qdev_create(NULL, \"Uni-north main\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(UNINState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_unin_set_irq, pci_unin_map_irq,\n\n                                         pic, 11 << 3, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 11 << 3, \"Uni-north main\");\n\n\n\n    sysbus_mmio_map(s, 0, 0xf2800000);\n\n    sysbus_mmio_map(s, 1, 0xf2c00000);\n\n\n\n    /* DEC 21154 bridge */\n\n#if 0\n\n    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */\n\n    pci_create_simple(d->host_state.bus, 12 << 3, \"DEC 21154\");\n\n#endif\n\n\n\n    /* Uninorth AGP bus */\n\n    pci_create_simple(d->host_state.bus, 13 << 3, \"Uni-north AGP\");\n\n\n\n    /* Uninorth internal bus */\n\n#if 0\n\n    /* XXX: not needed for now */\n\n    pci_create_simple(d->host_state.bus, 14 << 3, \"Uni-north internal\");\n\n#endif\n\n\n\n    return d->host_state.bus;\n\n}\n", "idx": 9616, "substitutes": {"pic": ["p", "py", "i", "ic", "sp", "eric", "pict", "cam", "fc", "Pic", "xi", "picture", "capt", "nic", "peg", "ican", "phot", "picked", "ics", "png", "pa", "script", " Pic", "style", "fi", "pin", "phy", "mic", "mc", "sc", "anc", "pi", "pc", "ig", "php", "doc", "magic", "icc", "lib", "jp"], "dev": ["pro", "p", "av", "h", "DEV", "Dev", "mem", "ev", "conn", "eng", "v", "de", "dd", "sh", "data", "priv", "pad", "device", "out", "n", "ve", "o", "nt", "des", "devices", "a", "g", "def", "dem", "os", "tr", "iv", "sd", "go", "sys", "gu", "ds", "Device", "disk", "DE", "ad", "db", "hw", "w"], "s": ["r", "ts", "p", "h", "sb", "x", "ats", "sw", "ses", "rs", "se", "sa", "v", "ls", "i", "sh", "sp", "ss", "ps", "gs", "sts", "n", "des", "south", "fs", "sv", "sl", "g", "b", "is", "si", "a", "sam", "os", "sd", "set", "sys", "js", "ds", "m", "S", "c", "t", "cs", "us", "bs", "w", "qs", "ns"], "d": ["r", "di", "p", "done", "ld", "dc", "h", "dr", "nd", "dx", "od", "bd", "D", "f", "v", "dd", "de", "id", "dm", "z", "gd", "ind", "end", "l", "dict", "result", "cd", "j", "dl", "new", "dt", "debug", "n", "o", "pd", "da", "des", "md", "b", "g", "did", "td", "dh", "dat", "fd", "y", "sd", "dn", "ds", "m", "c", "t", "ed", "dj", "ad", "db", "e", "doc", "w", "rd"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 9619, "substitutes": {"lexer": ["coder", "marker", "scaniter", "lexeme", "scaner", "lexener", "mailer", "marke", "moditer", " lexe", "eyeder", "lexeder", "maile", "code", "eyer", "mailener", "markeme", "coditer", "scane", "markiter", " lexiter", "modeme", "lexiter", "lexe", "mailiter", " lexeder", "moder", "eye", "mode", " lexener", " lexeme", "codeder", "eyiter", "scanener"], "input": ["active", "instance", "select", " inputs", "feature", "document", "from", "accept", "request", "output", "format", "data", "add", "command", "query", "start", "feed", "raw", "qa", "in", "config", "initial", "event", "form", "history", "pattern", "get", "script", "unknown", "attribute", "local", "view", "lat", "token", "Input", "argument", "it", "text", "check", "ip", "buffer", "current", "source", "context", "client", "xml", "expression", "image", "response"], "type": ["types", "ype", "rule", "test", "typ", "id", "op", "role", "format", "pe", "by", "version", "name", "title", "tp", "result", "ver", "start", "code", "ty", "error", "key", "at", "change", "count", "time", "file", "relation", "index", "pattern", "match", "TYPE", "what", "Type", "set", "style", "token", "kind", "inter", "part", "t", "top", "status", "action", "ping", "word", "state", "class", "level", "color", "length"], "x": ["p", "X", "on", "dx", " cx", "px", "xes", "i", " xx", "xy", "xt", "xf", "l", "xs", "ox", "xi", "ix", "ex", "wx", "xp", "ax", " dx", "index", " i", "tx", "fx", "lat", "lex", "rx", "xa", "yx", "t", "mx", "xc", "k", "xx"], "y": ["ny", "py", "fy", "ery", "ies", "xy", "vy", "yer", " ay", "oy", "asy", " ty", "sky", "year", "sim", "ys", "ey", "ady", " py", "iy", "yd", "my", "yy", "axy", "Y", "ay", "yt", "ya", "sys", "ym", "ly", "cy", "hot", "sy", "ye", " sy", "yo", " ya", "gy", "by"], "parser": ["runner", "instance", "metadata", "json", "bird", "handler", "number", "reader", "builder", "program", "worker", "upload", "er", "player", "processing", "parse", "now", "manager", "this", "book", "timer", "class", "state", "loader", "could", "rer", "ard", "iterator", "private", "rule", "dd", "params", "python", "yer", "function", "layer", "upper", "http", "parts", "adder", "older", "arser", "finder", " scanner", "package", "bank", "kernel", "buffer", "true", "inner", "table", "man", "peer", "p", "language", "plugin", "job", "primary", "jack", "command", "parent", "component", "process", "store", "server", "unknown", "node", "wrapper", "php", "self", "pro", "student", "writer", "func", "password", "proc", "document", "master", "der", "format", "tp", "processor", "policy", "pool", "event", "file", "ner", "local", "token", "driver", "container", "disk", "part", "volume", "operator", "oder", "message", "context", "client", "Parser"], "dict": ["di", "defined", "ld", "func", "wd", "list", "nd", "dr", "conf", "metadata", "bd", "D", "df", "json", "dd", "vol", "pair", "data", "dot", "direct", "add", "ct", "cd", "map", "cond", "str", "window", "hd", "result", "key", "debug", "nt", "pd", "da", "count", "make", "obj", "md", "tmp", "dir", "d", "details", "dat", "def", "local", "hash", "set", "container", "ds", "part", "draw", "ud", "ad", "sum", "db", "inf", "decl", "table", "det", "pkg", "ict", "doc", "client", "del", "cmd"], "brace_count": ["brace64total", "brace64len", "brace64counter", "brace64force", "bracemingsum", "braceletconst", "brace_found", "quote_counter", "quote64number", "applyfulweight", "case_counter", "bracefulcycle", "bracelesum", "apply_cycle", "aliascesum", "apply_only", "style_type", "braceityweight", "casececount", "brace_weight", "brace64count", "brace_total", "aliascefound", "brace64type", "braceitycounter", "brace_const", "bracecesum", "brace_counter", "trackingconst", "braceptforce", "apply_weight", "case_count", "braceletcount", "braceingsum", "style64total", "braceitycycle", "brace64sum", "braceletotal", "bracepttype", "casececounter", "trackingcount", "applyfulonly", "braceitynumber", "braceletsum", "track_const", "bracemingtype", "braceceforce", "brace_only", "quote64count", "caseceforce", "brace8const", "case_type", "brace_cycle", "bracecefound", "style64count", "alias_count", "trackingsum", "braceitysum", "bracececount", "bracecetype", "braceitycount", "brace8check", "alias_found", "bracelecount", "applyfulcount", "brace_sum", "braceingconst", "brace64number", "style_total", "bracefulonly", "brace_check", "casecetype", "brace8count", "brace_len", "bracelefound", "aliascetotal", "quote64sum", "brace8sum", "braceptcount", "quote_number", "style_len", "bracemingfound", "braceityonly", "brace_force", "braceminglen", "bracececounter", "bracefulweight", "braceingcheck", "style_count", "quote_sum", "apply_count", "braceptcounter", "bracemingcount", "alias_total", "bracemingtotal", "brace_number", "style64len", "alias_sum", "bracefulcount", "quote64counter", "braceletcheck", "bracecetotal", "brace_type", "trackingcheck", "quote_count", "braceingcount", "track_count", "aliascecount", "style64type", "case_force", "applyfulcycle", "track_sum", "track_check"], "bracket_count": ["bracket9count", "bracketCountcounter", "brucket_close", "bracketCountlength", "bracketCountinfo", "brucket_code", "bracket9code", "brucket9close", "brucket9code", "brucket9filter", "bratchCountinfo", "bracket_filter", "brucker_length", "brackets_count", "bratch_length", "bracketCountcount", "brucker_count", "brink_count", "brink_mount", "bratchCountcount", "bracket_code", "bracket32count", "bracket_length", "brackets_cache", "bracket_amount", "brucker32number", "brack_cache", "brucker32status", "brucker32count", "bracket_cache", "bratch_info", "bratch_counter", "brucker_status", "brackets_Count", "bracket_status", "bracket9close", "bracket_size", "bracket9filter", "brucker32length", "bracket32length", "brucket9count", "bracket_counter", "bracketTimecounter", "bracket32status", "bracketTimeinfo", "bracket_info", "bracket_Count", "brink_amount", "brucket_count", "brack_Count", "brucket_filter", "brack_count", "bratch_count", "bratchCountlength", "bratchCountcounter", "bracketTimecount", "brack_size", "bracket_close", "bracketTimelength", "bracket_mount", "bracket_number", "brucker_number", "bracket32number"]}}
{"project": "qemu", "commit_id": "041d95f42e39ed1d3a029332cab9966889f0aeb3", "target": 0, "func": "static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n", "idx": 9629, "substitutes": {"env": ["ens", "dev", "sb", "pres", "conn", "proc", "ev", "eng", "enter", " ens", "v", "esc", "sp", "cur", "pe", "environment", "ef", "nc", "gov", "en", "window", "shell", "org", "eve", "forge", "rc", "cv", "ew", "ve", "obj", "server", "sv", "vt", "enc", "er", "ov", "config", "viron", "esp", "sec", "st", "ec", "ch", "ah", "desc", "esm", "ctx", "equ", "ds", "ce", "uv", "here", "et", "sc", "Environment", "db", "nv", "vs", "context", "e", "vp", "cmd"], "eaddr": [" lldr", "ayDR", "edddress", "eadder", "eddDR", "oaddr", "oadDR", "oaddress", " lldress", "aydress", "aydr", "ayr", " eddr", " llder", "edddr", " edder", " eddress", "eddder", " edmd", "eaddress", "eddmd", "eadmd", "oadr", " llmd", "eddr", "eadDR", "eadr"], "pid": ["p", "pr", "proc", "id", "oid", "por", "pt", "ps", "kill", "parent", "uid", "key", "process", "qt", "post", "pa", "dh", "pty", "fd", " tid", "path", "phase", "pan", " PID", "pm", "sid", "wid", " p", "pos", "kt", "port", " ps", "po", "ping", "pi", "pkg", "vid", "rid", "ptr", "pc", "mid", "pri"], "cs": ["ts", "cons", "cus", "aps", "rs", "ls", "ck", "nc", "ps", "cks", "gs", "acs", "ys", "sts", "cc", "cas", "cms", "CS", "fs", "ac", "ec", "bs", "ks", "css", "js", "sys", "ctx", "ds", "c", "sc", "vs", "pc", "wcs", "ms", "ns"], "tlb": ["atlr", "tenbl", "atlb", "latlp", "tzb", "tslr", "ttlb", "llp", "latzb", "terb", "tlp", " tlam", " tmb", " tlp", "telbs", "ttlr", "itlbs", " tpl", "Tlbs", "tenlb", "ktmb", "itlb", "entpl", "tslb", "ttlp", "itbl", " tzb", "lbl", "atlbs", "ttzb", "tli", "entlb", "tbl", "attmb", "enterb", "ptbl", "otlab", "atlp", " tli", " tlbs", " trb", "telp", "ktrb", "ptlbs", "tslbs", "trb", "llbs", "tpl", " terb", "otbl", "tenlp", "mtlab", "mtpl", "Tlb", "otlbs", "tmb", "Tbl", "ttlab", "mterb", "ptlam", "tslp", "attrb", "tlbs", "tlab", "attlab", "itlam", "mtlb", "ptlb", "otlb", "Tli", "telb", "Tlp", "ktlab", "tlam", "ktlb", " tlab", "entlab", " tbl", "tterb", "ttlbs", "otlp", "tlr", "telab", "laterb", "tenli", "llb", "attlb", "latlb"], "raddr": ["rdaddress", " rloc", "Raddr", "Raddress", "Radr", "vrloc", "rdaddr", " raddress", "rfaddr", "rfadr", " rarp", "rfaddress", " radr", " rhash", "vraddr", "vrarp", "vraddress", "rdarp", "rfhash", "Rhash", "rhash", "rarp", "rloc", "radr", "raddress", "rdloc"], "page": ["p", " offset", " pi", "step", "update", "pl", " pc", "x", "instance", "pixel", "next", "request", "pp", "site", "sp", "url", "number", "pages", "pe", "pg", "entry", " port", "pad", "pt", " row", "j", " count", "window", "phrase", " pg", "route", " pointer", "order", "out", "line", " Page", "ice", " pe", "count", "peer", "server", "loop", "g", " PAGE", " pages", "index", "ph", "node", "age", "ref", "go", "fe", "offset", " p", " r", "ip", " window", "ge", " req", "PA", "row", "point", "port", "batch", "table", "message", "block", "pc", "me", "address", "aa", "Page"], "end": ["p", "limit", "hend", "ent", "ending", "wall", "send", "nd", "except", "END", "final", "next", "ff", "id", "add", "ender", "pad", "start", "stop", "en", "org", "close", "size", "begin", "bound", "ended", "End", "rest", "ext", "max", "offset", "last", "eff", "it", "fin", "until", "gate", "append", "check", "len", "est", " End", "e", "length"], "i": ["ui", "di", "p", "ami", "x", "v", "k", "gi", "ic", "ai", "id", " ii", "iq", "ind", "ei", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "iy", "multi", "bi", " I", "n", "o", "me", "in", "is", "print", "si", "index", "li", "y", "ini", "it", "\u0438", "ci", "m", "io", "t", "ip", "mi", "zi", "qi", "ij", "batch", "ti", "im", "asi", "pi", "e", "ki", "ims"]}}
{"project": "qemu", "commit_id": "9cd1e97a7ae2856ec00b5682db0dea17f42fc734", "target": 0, "func": "void pci_bridge_initfn(PCIDevice *dev, const char *typename)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = PCI_BRIDGE(dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_word_test_and_set_mask(dev->config + PCI_STATUS,\n\n                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * TODO: We implement VGA Enable in the Bridge Control Register\n\n     * therefore per the PCI to PCI bridge spec we must also implement\n\n     * VGA Palette Snooping.  When done, set this bit writable:\n\n     *\n\n     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,\n\n     *                            PCI_COMMAND_VGA_PALETTE);\n\n     */\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, OBJECT(br), \"pci_bridge_pci\", UINT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, OBJECT(br), \"pci_bridge_io\", 65536);\n\n    br->windows = pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n}\n", "idx": 9630, "substitutes": {"dev": ["wd", "DEV", "ev", "de", "pack", "data", "cam", "ver", "buf", "des", "remote", "er", "d", "def", "var", "go", "task", "db", "loc", "w", "cmd", "av", "develop", "conf", "Dev", "comment", "test", "priv", "boot", "pt", "env", "nav", "raw", "ve", "obj", "serv", "app", "scan", "info", "sd", "desc", "bus", "it", "block", "van", "p", "conn", "exec", "serial", "disc", "rem", "nt", "dem", "os", "ow", "tr", "ctx", "any", "hw", "att", "pro", "watch", "die", "eng", "v", "val", "debug", "device", "admin", "event", "ch", "adj", "driver", "adv", "dis", "normal", "det"], "typename": ["TYpename", "tylenename", "TYlename", "tyternew", "tyrenAME", "Tyrenamed", "TYpenew", "tyternAME", "tymenew", "tymenAME", "Tyrename", "tylenew", "tyrenname", "TYlenname", "typenname", "tyternamed", "tyternename", "TyrenAME", "TYpenename", "TYlenename", "tylenname", "tyrenamed", "tymenname", "tyternname", "TYpenname", "Typenname", "tylename", "tymenename", "Tyrenname", "typenename", "tytername", "typenamed", "TypenAME", "tyrename", "tymename", "typenew", "Typenamed", "typenAME", "TYlenew", "Typename", "tymenamed"], "parent": ["self", "p", "unit", "master", "Parent", "tree", "fat", "test", "sp", "map", "parents", "root", "host", "cp", "pool", "server", "remote", "g", "par", "local", "node", "cmp", "ref", "container", "task", "home", "reg", "ctx", "m", "last", "t", "chain", "block", "base", "port", "child"], "br": ["dr", "ev", "err", "ver", "fr", "broad", "comm", "buf", "var", "arr", "bor", "browser", "mr", "reg", "kr", "adr", "batch", "rb", "ptr", "el", "jp", "rel", "av", "cr", "nah", "bed", "lr", "bro", "bl", "obj", "bar", "bh", "bt", "shr", "gr", "bolt", "block", "bn", "bg", "bern", "Br", "hr", "bd", "sp", "bp", "str", "rem", "ov", "b", "mt", "bsp", "tr", "bridge", "prop", "ctr", "r", "aj", "pr", "BR", "repl", "v", "mg", "nb", "vr", "bc", "j", "usr", "bre", "n", "form", "ch", "ber", "resp", "roller", "bs", "bm"], "sec_bus": ["secure1driver", "secitybus", "sec_block", "sec___mount", "sec_project", "esc_boot", " sec_machine", "seq_block", "secure_driver", "esc_BUS", "esc___Bus", "sec_box", "secessionblock", "secure___us", "esc___dev", "esc___bus", "secure___Bus", "esc_block", "sec___dev", "esc___sync", "seccitysync", "secure_box", "sec_boot", "sec___box", "sec___bridge", "sec_sync", "Sec_box", "secure_bus", "Sec_block", "seccitybus", "sec___us", "sec_machine", "sec2block", "secure_us", "seq_project", "Sec_bus", "secure_Bus", "esc_box", " sec_mount", "secure___box", "sec___host", "esc_board", "sec1driver", "sec2bridge", "sec_bridge", "esc_Bus", "sec_pipe", "sec___BUS", " sec_Bus", "sec_board", "sec___sync", "esc_bus", "sec1us", "sec___boot", "sec1bus", "Sec_bridge", "esc___BUS", "seccityblock", "sec_us", "sec___bus", "esc___block", "esc_sync", "seccityBus", "seq_boot", "sec3bus", "sec3mount", "sec___block", "sec___Bus", "secure___bus", " sec_box", "esc_host", "secessionboot", "sec_mount", "sec2box", "sec___machine", "secure1box", "esc___box", "esc_dev", "sec_BUS", "sec2bus", "sec_book", "seq_bus", "secityboard", "sec_driver", "sec3machine", "esc___host", "sec3BUS", "sec_Bus", " sec_pipe", "esc___boot", " sec_BUS", "secessionproject", "sec_host", "secure1bus", "sec_dev", "secitybook", "esc_book", "secure1us", "secessionbus", "sec1box"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n", "idx": 9639, "substitutes": {"linebuf": ["inebuf", "linebuffer", "linkbuffer", "linkb", " linebuffer", "inevar", "linecache", "linvar", "linbuf", "linequeue", "linevar", "linbuffer", "Linebuf", "inebuffer", " linequeue", " linevar", " linecache", "linkbuf", " lineb", "Linebuffer", "lineb", "linkqueue", "Lineb", "lincache", "Linequeue", "inecache"], "fb": ["cb", "bf", "sb", "f", "ff", "grab", "nb", "pb", "fc", "rf", "uf", "fr", "erb", "hd", "bb", "eb", "sbm", "ib", "buf", "rl", "facebook", "b", "bt", "obb", "fd", "fx", "gb", "fg", "bridge", "fp", "fi", "abb", "wb", "rb", "lb", "FB", "bs", "bm"], "y": ["p", "ny", "x", "h", "ity", "ery", "xy", "bottom", "i", " height", "v", "type", "dy", "id", "ind", "height", "j", "ty", "ey", "iy", "out", "o", "a", "b", "yy", "index", "ch", "axy", " dy", "Y", "ay", "yt", "offset", "ly", "ym", "c", "t", "top", "sy", "w", "gy", "by"]}}
{"project": "qemu", "commit_id": "30b8b68eb574fd68060eebcc4da790fdfe18d668", "target": 0, "func": "static inline abi_long target_to_host_cmsg(struct msghdr *msgh,\n\n                                           struct target_msghdr *target_msgh)\n\n{\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);\n\n    abi_long msg_controllen;\n\n    abi_ulong target_cmsg_addr;\n\n    struct target_cmsghdr *target_cmsg;\n\n    socklen_t space = 0;\n\n    \n\n    msg_controllen = tswapal(target_msgh->msg_controllen);\n\n    if (msg_controllen < sizeof (struct target_cmsghdr)) \n\n        goto the_end;\n\n    target_cmsg_addr = tswapal(target_msgh->msg_control);\n\n    target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);\n\n    if (!target_cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = tswapal(target_cmsg->cmsg_len)\n\n                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));\n\n\n\n        space += CMSG_SPACE(len);\n\n        if (space > msgh->msg_controllen) {\n\n            space -= CMSG_SPACE(len);\n\n            gemu_log(\"Host cmsg overflow\\n\");\n\n            break;\n\n        }\n\n\n\n        if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) {\n\n            cmsg->cmsg_level = SOL_SOCKET;\n\n        } else {\n\n            cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level);\n\n        }\n\n        cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type);\n\n        cmsg->cmsg_len = CMSG_LEN(len);\n\n\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(data, target_data, len);\n\n        } else {\n\n            int *fd = (int *)data;\n\n            int *target_fd = (int *)target_data;\n\n            int i, numfds = len / sizeof(int);\n\n\n\n            for (i = 0; i < numfds; i++)\n\n                fd[i] = tswap32(target_fd[i]);\n\n        }\n\n\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, 0);\n\n the_end:\n\n    msgh->msg_controllen = space;\n\n    return 0;\n\n}\n", "idx": 9643, "substitutes": {"msgh": ["Mshr", " msgr", "mesgh", "masgh", "csgh", "msche", "masGH", "tsche", "mesGH", "MsGH", "Msgh", " msche", "csche", "csgr", "Msge", "tsgr", "csht", "masgo", "csg", "mesge", "mashr", "msge", "masht", "mshr", "meshr", "msgr", "msGH", "msht", "msgo", "csgo", "tsgh", " msge", "csge", " msgo", "tsg", " msg", "masge", "msg", " msht"], "target_msgh": ["target___mashr", "target_msrh", "target_mesgr", "target_mmgr", "target_machr", "target_msgr", "target_tsgs", "target_tsgr", "target_mmph", "target_mmgh", "target___masha", "target_mcg", "target_mchr", "target_mcph", "target_mcrh", "target_masg", "target_tsph", "target_tsgh", "target_masgh", "target_mashr", "target_macg", "target_msgs", "target_msg", "target___masgh", "target_mcha", "target___msha", "target___masg", "target_mcgr", "target_masha", "target_macha", "target_mmrh", "target_mesgh", "target_mcgh", "target_msha", "target_tsrh", "target_tsg", "target_msph", "target___mshr", "target_mcgs", "target___msg", "target_mesg", "target_mshr", "target_mesgs", "target___msgh", "target_macgh"], "cmsg": ["confget", "coarg", "acmessage", "cget", "cachemsg", " cgm", "gcsum", "cammsg", "constat", "pcMsg", "curmsg", "abcsend", "pcmessage", "xcmsg", "csend", "curgm", "cdomain", "arcattr", "ecmsg", "ancmsg", "rcgm", "confmsg", "gcog", "lcMsg", "acmess", "cmd", "lcgm", "decurl", "arcurl", "confsum", "cachemessage", "acpkg", "cusum", "cachecmd", "arcmail", "rcog", "ccsend", "csum", "cumsg", "rcmsg", "abcpkg", "lcmg", "ccommand", "arcmessage", "lcmsg", "lgm", "cocommand", "concommand", " cmessage", "ancurl", "curl", "rcmd", "lcmd", "cuget", "decattr", "Cog", "acsend", "cmg", " cmd", "camget", "camsum", "lcmessage", "arcmess", "ccmsg", "ccmessage", "lccmd", "camdomain", " cMsg", "confdomain", "curmd", "acmsg", "lmsg", "costat", "abcmsg", "cgm", "cachemess", "cpkg", "csg", "decmail", "conarg", "Cgm", "cmail", "lmessage", "pcmsg", "accmd", "decmsg", "uncarg", "cMsg", "xcsg", "arccmd", "ancmail", "cudomain", "cmess", "cstat", " cmg", " cog", "ccpkg", "curog", "ccmd", "cattr", "ancattr", "gcmsg", "ecsg", "ecmd", "carg", "Cmsg", "conmsg", "cog", "comsg", "lcog", "xcmd", "uncmsg", "pcmg", "lcsum", "unccommand", " ccmd", "Cmd", " csum", "gcgm", "arcmsg", "cmessage", "uncstat", " csg", "abcmessage"], "msg_controllen": ["msg_introllnum", "msg_controle", "msg_ontrolan", "msg_controllingener", "msg_introlEN", "msg_controllednum", "msg_introller", "msg_controlEN", "msg_introllEN", "msg_controllede", "msg_controllingen", "msg_contillen", "msg_ontrollEN", "msg_ontrollener", "msg_controlleran", "msg_contvalun", "msg_introllen", "msg_contcolle", "msg_controlen", "msg_contvalen", "msg_ontrollan", "msg_controllinglen", "msg_introllens", "msg_introllun", "msg_controlleder", "msg_controllEN", "msg_ontrole", "msg_controllun", "msg_ontroller", "msg_contvalle", "msg_controlleren", "msg_controllerens", "msg_controlledlen", "msg_controlnum", "msg_contcontlen", "msg_controlun", "msg_controlllen", "msg_ontrolener", "msg_introlen", "msg_introllle", "msg_controllens", "msg_ontrollen", "msg_controlledens", "msg_introlleden", "msg_introlle", "msg_introler", "msg_controllle", "msg_ontrolen", "msg_controllerEN", "msg_controlleden", "msg_introllednum", "msg_ontroler", "msg_contillEN", "msg_controllerer", "msg_ontrolle", "msg_controllinger", "msg_ontrolens", "msg_controlledEN", "msg_introlllen", "msg_controller", "msg_introlledens", "msg_controlle", "msg_contillens", "msg_contillan", "msg_contconten", "msg_controllan", "msg_controllnum", "msg_controler", "msg_contcolun", "msg_contcontens", "msg_ontrolllen", "msg_ontrollens", "msg_contvallen", "msg_contcontnum", "msg_contcolen", "msg_introlun", "msg_controlens", "msg_controllerener", "msg_controllerlen", "msg_controlener", "msg_controllinge", "msg_ontrolEN", "msg_contcollen", "msg_introlledlen", "msg_controlan", "msg_controllener"], "target_cmsg_addr": ["target_cmsg_order", "target_cmsg__dr", "target_cmsg__addr", "target_cmsg_ptr", "target_cg_add", "target_cmsg_add", "target_cmsg_address", "target_cmsg__order", "target_cg_address", "target_cmsg__address", "target_cg_addr", "target_cg_ptr", "target_cmsg_dr"], "target_cmsg": ["targetablecurg", "target_gcgl", "target_encundle", "target_cgame", "target_rcog", "target_mmd", "target_cg", "targetablecmsg", "targetableancurl", "target_cacheundle", "target_cpgame", "targetablecurl", "target_ancmessage", "target_gcmn", "target_acurl", "target_cosmessage", "target_curg", "target_arcmn", "target_mcmd", "target_vcimg", "target_arcmsg", "target_lcmd", "target_acog", "target_CMsg", "target_Cog", "target_curl", "target_vcmn", "targetableancurg", "target_xctx", "target_tmsg", "target_lcmsg", "target_cacheurl", "target_commmessage", "target_xcg", "target_rcg", "target_cacheog", "target_tgame", "target_lcmessage", "target_lcurl", "target_camerg", "target_cmn", "target_cimg", "target_commsm", "target_rctx", "target_lcog", "target_cmd", "target_mMsg", "target_tmessage", "target_acmessage", "target_arcimg", "target_ancmsg", "target_lcMsg", "target_xcmsg", "target_encog", "target_encurl", "target_acmsg", "target_lcdr", "target_lcurg", "target_commmsg", "target_ctx", "target_gcimg", "target_Cmsg", "target_mcmsg", "target_cpmessage", "target_cachemsg", "target_vcmsg", "target_cundle", "target_acundle", "target_rcerg", "target_camog", "target_cammsg", "target_ancurl", "target_acMsg", "target_mmsg", "target_acmd", "target_xcmessage", "target_cpmsg", "target_cMsg", "target_commgame", "target_gcmsg", "target_mcMsg", "target_cerg", "target_lcerg", "target_cosmsg", "target_arcgl", "target_mog", "target_acmg", "target_cammessage", "target_mcdr", "targetableancmessage", "target_csm", "targetableancmsg", "target_tsm", "target_rcmsg", "target_vcgl", "targetablecmessage", "target_cpsm", "target_ancurg", "target_cmg", "target_rcmg", "target_mcog", "target_acdr", "target_lctx", "target_cmessage", "target_cdr", "target_lcg", "target_encmsg", "target_cosurl", "target_cosurg", "target_cgl", "target_rcmessage", "target_Cmd", "target_cog"], "data": ["options", "done", "extra", "no", "DATA", "type", "ATA", "ata", "name", "trans", "Data", "map", "window", "space", "size", "area", "cache", "def", "info", "hash", "pos", "len", "mode", "mu", "zero", "msg", "rel", "ns"], "target_data": [" target_info", "target_info", " target_addr", "target___info", " target_len", "target_addr", "target___data", "target___len", "target___addr", "target_len"]}}
{"project": "qemu", "commit_id": "9d6f1b73f83a02fb28438fa9a487f5c7d245e4af", "target": 0, "func": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n", "idx": 9647, "substitutes": {"pidfile": ["logname", "pinfile", " pidtree", "pingblock", "pfile", "pinlist", "pinFile", " pidname", "proclist", "pfilename", "proctree", " pidblock", "pidel", "pingfile", "pingel", " pidel", "logFile", " pidf", "logfilename", "pinblock", "pingf", "pidFile", "pintree", " pidlist", "procFile", "pFile", " pidfilename", "logfile", "pname", " pidFile", "pidname", "pinel", "pidlist", "procfile", "pinf", "pidf", "pidblock", "pidfilename", "pidtree"], "pidfd": ["pidfe", "ptyd", "cpfin", "pfc", "pf", " pofp", "condd", "reqf", "prdir", "panf", " pidFD", " pidfc", "panfd", "procfd", " pidfn", "pidfi", "phyfc", "panfp", "pidfunc", "pinfin", "ptyfd", "phyfi", "pidld", "pidstream", "pindir", "pidfc", "reqfd", "reqFD", "panstream", "procdd", "prfd", "pinfd", "pinfn", "killf", "killFD", "pidfin", "panfc", " pidf", "pfi", "procld", "ptyFD", "conddb", " piddd", "pinFD", " pidfp", "pinfp", " pidd", "ptyfin", "pfunc", " pidfin", "pinfi", "procfc", "cpfd", "panfin", "pinstream", "killfd", " pidfe", "panfunc", "piddb", "pinfc", "reqfc", "phyfd", "condFD", " piddb", "condfd", " pof", " pidfunc", "cpFD", "killfc", "pidf", "piddd", " pofd", " pidld", "pidFD", "pfd", "prFD", "piddir", " pofin", "pinfe", "ptyfe", "cpdir", "prld", "pidfn", "phyfp", "ptyfc", "pfp", " pidstream", "prdd", "ptydb", "prfin", "pidd", "panfn", "pidfp", "prfc"], "pidstr": ["pinghex", " pidst", "msgtr", "pinvol", " piddata", "pantr", "pst", "pinhex", " psstr", "panstring", " pidSTR", "pstring", " pidname", "msgvol", " piddef", "pSTR", "pinfr", "panfile", "pingfr", "pidstring", " pidfr", "psfile", "pidfr", "pidSTR", "pidst", " pidstring", "psstr", "panvol", "pinstr", "pintr", "psstring", "pidtr", "msgstr", " pidtr", "pidhex", "piddata", "piddef", "pindef", "pname", "pingSTR", "pingstring", "panSTR", " psname", "pidname", "pingstr", "msgSTR", " psstring", "pstr", " pidhex", " psdata", "pidvol", "pdata", "pingdef", "panstr", "pingst", "pinSTR"]}}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "static void handle_pending_signal(CPUArchState *cpu_env, int sig)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_ulong handler;\n\n    sigset_t set, old_set;\n\n    target_sigset_t target_old_set;\n\n    struct target_sigaction *sa;\n\n    struct sigqueue *q;\n\n    TaskState *ts = cpu->opaque;\n\n    struct emulated_sigtable *k = &ts->sigtab[sig - 1];\n\n\n\n    trace_user_handle_signal(cpu_env, sig);\n\n    /* dequeue signal */\n\n    q = k->first;\n\n    k->first = q->next;\n\n    if (!k->first)\n\n        k->pending = 0;\n\n\n\n    sig = gdb_handlesig(cpu, sig);\n\n    if (!sig) {\n\n        sa = NULL;\n\n        handler = TARGET_SIG_IGN;\n\n    } else {\n\n        sa = &sigact_table[sig - 1];\n\n        handler = sa->_sa_handler;\n\n    }\n\n\n\n    if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) {\n\n        /* Guest has blocked SIGSEGV but we got one anyway. Assume this\n\n         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info\n\n         * because it got a real MMU fault), and treat as if default handler.\n\n         */\n\n        handler = TARGET_SIG_DFL;\n\n    }\n\n\n\n    if (handler == TARGET_SIG_DFL) {\n\n        /* default handler : ignore some signal. The other are job control or fatal */\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n        } else if (sig != TARGET_SIGCHLD &&\n\n                   sig != TARGET_SIGURG &&\n\n                   sig != TARGET_SIGWINCH &&\n\n                   sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        }\n\n    } else if (handler == TARGET_SIG_IGN) {\n\n        /* ignore sig */\n\n    } else if (handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* block signals in the handler using Linux */\n\n        do_sigprocmask(SIG_BLOCK, &set, &old_set);\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &old_set);\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n    if (q != &k->info)\n\n        free_sigqueue(cpu_env, q);\n\n}\n", "idx": 9650, "substitutes": {"cpu_env": ["cpupyvm", "cpu_state", "cpuacconn", "cpu___env", "cpu_conn", "cpu_vm", "cpupyenv", "cpu___en", "pu_en", "cpu_server", "pu_conn", "cpupyen", " cpu_state", "pu_vm", "cpuacenv", "pu_server", "cpu_en", "pu_env", "cpuacserver", "cpuacen", "cpuacstate", "cpu___conn", "cpu___server", " cpu_en"], "sig": ["vick", "design", "insigh", "getsig", "opensigma", "insigma", "Sick", "gesigen", "unsig", "asick", "vsigen", "isiger", "esature", "dsign", "dsIG", "fsig", "lsig", "jsec", "esigen", "nIG", "atsiger", "csig", "vsick", "ssig", "Sature", "insign", "sigh", "unsigs", " sature", "esig", "fsigen", "jsick", "jsig", "alsigen", "ssigma", "atsag", "desiger", "asigo", "asif", " sign", "vsig", "nig", "dsature", "asig", "unsiger", "sag", "SIG", "vigma", " sigma", "gesig", "vsign", "alsiger", " sIG", "csign", "getsIG", "Sigh", "Sag", "ssigs", "nigs", "insIG", "vsigma", "Sign", "fsigma", "jsigen", "unsIG", "lsigen", "sIG", "getsiger", "sigo", "isigen", "esigma", "sigen", "isigh", "lsIG", "vsigh", "isig", "alsig", "nigma", "vigen", "seg", "unsigma", "sigs", "alsIG", " sigen", "asIG", "Sig", "insature", "gesiger", "dsigen", "sif", " sag", "desig", "unsigen", " sif", "sec", "dsig", "sign", "desIG", "ssag", "ssigh", "unsign", "Sigen", "jsIG", "Sigs", " sigo", "atsigen", "lsif", " sigs", "isIG", "atsig", "csIG", "opensigo", "getsature", "gesag", "unsature", "asigma", "jseg", "sature", "csigen", "sick", "Sigma", "ssign", "sigma", "jsigma", "asigen", "insig", "dsigma", "fsIG", "opensig", "vsiger", "siger", "insigen", "isign", "ssIG", "opensif", "ssec", "sseg", "vig", "insiger", "Sif", " siger"], "cpu": ["p", "np", "proc", "CPU", "conn", "tc", "gpu", "linux", "onet", "pid", "ck", "frame", "tp", "processor", "ct", "boot", "mac", "vm", "ka", "cu", "thread", "process", "cp", "pool", "core", "net", "os", "phys", "pu", "sys", "ctx", "aco", "c", "t", "mx", "nu", "gc", "pc", "cs", "hw", "mu", "socket", "cn", "us"], "handler": ["controller", "usage", "err", "sh", "folder", "when", "interface", "LER", "worker", "te", "index", " sched", "manager", "magic", "cmd", "h", " handlers", " Handler", "rule", "test", "function", "lr", " handle", "older", "handle", " error", "package", "hash", " err", "priority", "hand", " hook", "storage", "or", "then", "command", " h", "trap", "holder", "size", "server", "node", "style", "wrapper", "here", "callback", "mode", "mid", "profile", "error", "func", "high", "timeout", "format", "connection", "processor", "sche", " hand", " signal", "ler", "lambda", "hd", "key", "direction", "policy", "event", "loop", "Handler", "hi", "hander", " value", "driver", "behavior", "message", "handled"], "set": ["sync", "sets", "save", "read", "sh", "clear", "stat", "add", "name", "sche", "map", "start", "en", "lock", "new", "root", "SET", "change", "sm", "store", "size", "cast", "mut", "Set", "index", "st", "ch", "get", "match", "handle", "parse", "ha", "hash", "reset", "ctx", "m", "target", "check", "et", "sc", "loc", "base", "sub", "gen", "mod", "apply"], "old_set": ["old_SET", " old_Set", " old_gen", "old_Set", "old_gen", " old_SET"], "target_old_set": ["target_OLD_Set", "target_old_SET", "target_OLD_SET", "target_old_Set", "target_OLD_set"], "sa": ["al", "ama", "session", "ami", "sta", "sb", "sha", "ma", "sw", "asa", "ga", "aos", "sh", "ai", "ais", "auth", "sche", "am", "na", "acs", "ain", "ka", "va", "ao", "SA", "da", "a", "ja", "za", "as", "si", "pa", "cache", "sam", "s", "act", "ha", "sd", "ca", "sg", "ssl", "sama", "ia", "wa", "so", "la", "sc", "ta", "apa", "ba", "asi", "ray", "au", "ua", "aw", "se", "Sa", "storage", "aa"], "q": ["r", "p", "Q", "qq", "ue", "seq", "ql", "dq", "i", "f", "v", "ck", "qu", "z", "iq", "l", "ek", "j", "query", "qv", "qt", "u", "qa", "sq", "o", "g", "b", "d", "er", "ch", "s", "eq", "y", "que", "queue", "ok", "ctx", "c", "t", "requ", "qi", "kw", "aq", "w", "qs"], "ts": ["ports", "tl", "vals", "tur", "ats", "tc", "Ts", "uts", "ls", "tm", "tz", "tp", "als", "ps", "pt", "gs", "tt", "acs", "tk", "tn", "ops", "sts", "tis", "nt", "fs", "mt", "te", "bs", "tr", "times", "ks", "tx", "TS", "hs", "ds", "tops", "t", "ta", "vs", "cs", "wcs", "ms", "ns"], "k": ["ack", "p", "km", "tc", "i", "v", "ck", "z", "uk", "kick", "ek", "ikk", "tk", "j", "ka", "ik", "th", "key", "wk", "n", "ke", "ak", "kj", "kh", "ko", "mk", "ch", "kl", "kk", "ks", "ok", "K", "ctx", "kr", "ku", "c", "t", "sk", "kw", "pkg", "unk", "pc", "ki"]}}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n", "idx": 9651, "substitutes": {"d": ["r", "di", "p", "done", "dc", "ld", "dev", "send", "dr", "dx", "bd", "D", "dq", "v", "dd", "de", "dm", "data", "ind", "l", "dict", "new", "debug", "dos", "out", "pd", "da", "md", "b", "details", "dh", "dat", "fd", "sd", "q", "dn", "ds", "dis", "c", "t", "draw", "ad", "db", "e", "w", "del"], "address": ["ace", "build", "eth", "i", "link", "addr", "id", "add", "location", "command", "interface", "position", "route", "order", "at", "device", "create", "range", "execute", "store", "event", "service", "prefix", "index", "act", "handle", "shape", "attribute", "Address", "each", "offset", "trace", "reference", "inter", "gate", "chain", "alias", "ad", "port", "block", "point", "description", "message", "ptr", "host", "length"], "val": ["pol", "al", "util", "dev", "pl", "vals", "Val", "value", "sol", "v", "ret", "vol", "sel", "bal", "aval", "bl", "buf", "vt", "sl", "grad", "ival", "serv", " v", "lit", "var", " value", "tx", "eval", "ref", " bin", "ctx", "vec", "abl", "cal", "VAL", "loc", "resp", "valid", "vc", "fail", "msg", "lib", "el", " arg", "item"], "len": [" l", "coll", "seq", "mem", "fun", "mat", "fil", "ret", "ls", "vol", "Len", "length", "syn", "compl", "l", "lf", "ln", "en", " length", "nl", "n", "nt", "count", "size", "el", "bytes", "kl", "fl", "lit", "elt", "offset", "lan", "fin", "ann", "pos", "num", "den", "ll", "alt", "level", "lib", "fac", "rel"]}}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 9670, "substitutes": {"size": ["limit", "send", "news", "mem", "type", "from", "number", "length", "z", "fee", "name", "ze", "padding", "capacity", "start", "code", " count", "position", "small", "window", "global", "shift", "range", "space", "n", "sent", "total", "count", "time", "zone", "area", "si", "Size", "scale", "bytes", "s", "index", "shape", "empty", "sn", "node", "set", "max", "offset", "now", "ize", "body", "buffer", "sum", "len", "memory", "message", "state", "SIZE", "address", "storage", "dimension"], "block": ["sync", "list", "Block", "snap", "mem", "bin", "type", "link", "frame", "pack", "object", "group", "map", "start", "cl", "lock", "bl", "all", "device", "record", "BL", "line", "piece", "space", "label", "event", "join", "b", "load", "prefix", "blocks", "def", "bit", "tx", "node", "hash", "bus", "header", "box", "byte", "check", "chain", "part", "buffer", "ip", "batch", "row", "base", "point", "word", "image", "address", "length", "zero"], "next_block": [" next_byte", "next_piece", "entry_Block", "prev_lock", "next_line", " next_image", "next_object", "prev_tx", "next_bl", "entry_piece", "next_byte", "entry_block", " next_object", "prev_block", "next_tx", "next_image", "next_lock", "next_blocking", "prev_bl", " next_line", "next_Block", "entry_blocking"], "end": ["ment", "limit", "send", "ent", "ending", "dev", "hend", "nd", "END", "off", "ue", "eng", "next", "ff", "head", "id", "z", "add", "ender", "pend", "ind", "pad", "entry", "name", "start", "stop", "en", "env", "all", "ex", "order", "after", "out", "n", "edge", "obj", "ne", "begin", "event", "enc", "bound", "ended", "back", "End", "index", "st", "eu", "ext", "term", "set", "max", "offset", "last", "eff", "enable", "ension", "append", "pos", "ed", "len", "est", "point", "east", "wind", "entity", "ord", "e", "se", "length"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n", "idx": 9683, "substitutes": {"chr": ["achrc", " chbar", "schrc", "anchr", "achr", "achar", "schr", "schsr", "echrb", "Chrs", "chrs", "chres", " chrb", "echdr", "Chbar", "chrb", "chsr", " chsr", "chdr", "anchrs", " chres", "anchar", "chedr", " chrs", " chrc", "cherb", "cheres", "Char", "Chr", "schar", "echr", "chbar", "chrc", "cher", "achsr", "anchbar", "echres", " chdr"]}}
{"project": "qemu", "commit_id": "fdaef06917100d97782df550c1807a1da054e27e", "target": 0, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int buflen = 0;\n\n    int ret;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        if (!bdrv_is_inserted(s->bs))\n\n            goto not_ready;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        if (req->cmd.xfer < 4)\n\n            goto illegal_request;\n\n        buflen = scsi_device_get_sense(&s->qdev, outbuf, req->cmd.xfer,\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case START_STOP:\n\n        if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) {\n\n            /* load/eject medium */\n\n            bdrv_eject(s->bs, !(req->cmd.buf[4] & 1));\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        bdrv_set_locked(s->bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->bs, &nb_sectors);\n\n        if (!nb_sectors)\n\n            goto not_ready;\n\n        nb_sectors /= s->cluster_size;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX)\n\n            nb_sectors = UINT32_MAX;\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->cluster_size * 2;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case SYNCHRONIZE_CACHE:\n\n        ret = bdrv_flush(s->bs);\n\n        if (ret < 0) {\n\n            if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        memset(outbuf, 0, 8);\n\n        /* ??? This should probably return much more information.  For now\n\n           just return the basic header indicating the CD-ROM profile.  */\n\n        outbuf[7] = 8; // CD-ROM\n\n        buflen = 8;\n\n        break;\n\n    case SERVICE_ACTION_IN:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == 0x10) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->bs, &nb_sectors);\n\n            if (!nb_sectors)\n\n                goto not_ready;\n\n            nb_sectors /= s->cluster_size;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->cluster_size * 2;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case REPORT_LUNS:\n\n        if (req->cmd.xfer < 16)\n\n            goto illegal_request;\n\n        memset(outbuf, 0, 16);\n\n        outbuf[3] = 8;\n\n        buflen = 16;\n\n        break;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    return buflen;\n\n\n\nnot_ready:\n\n    if (!bdrv_is_inserted(s->bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n    } else {\n\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n    }\n\n    return -1;\n\n\n\nillegal_request:\n\n    scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    return -1;\n\n}\n", "idx": 9706, "substitutes": {"r": ["p", "or", "cr", "hr", "rs", "i", "rr", "err", "v", "vr", "re", "rec", "rf", "R", "sr", "rc", "rg", "er", "b", "d", "rt", "q", "ry", "mr", "kr", "m", "c", "requ", "res", "rb", "rw", "e", "w", "rd"], "outbuf": ["OUTbuf", "outputbag", "Outvec", " outbuff", "outputbuffer", "Outbuff", "infb", "offbag", "inbuff", "upbuf", "outcmd", "outputbr", "outputprop", " outcmd", "upbag", " outfb", "upcmd", "OUTbuff", "inprop", "outbuffer", "outvec", "outbr", "outputbuf", " outvec", "offbr", "taskbuff", "offbuf", "upbuffer", "OUTvec", "offbuffer", "outprop", "outputcmd", "taskbuffer", "outbag", "taskbuf", " outbr", "outputbuff", "Outbuf", "inbuffer", "outfb", "inbuf", "outbuff", " outbag", " outbuffer", " outprop", "taskfb"], "req": ["inv", "qq", "err", "ind", "compl", "fr", "comm", "progress", "qt", "range", "buf", " cir", "eq", "urg", "ref", "reg", "quest", "rx", "requ", "rb", "pkg", "rel", "jp", "cmd", "conf", "mem", "attr", "pp", "stat", "good", "org", "http", "raw", "rss", "sq", "gz", "expr", "required", "tx", "desc", "q", "gr", "res", "aux", "rd", "msg", "p", "mm", "init", "seq", "conn", "dq", "perm", "exec", "needed", "rh", "crit", "rem", "sr", "nt", "tek", "md", "prefix", "ctx", "ctr", "comp", "pro", "dev", "pr", " q", "proc", "rs", "request", "rr", "alloc", "rec", "j", "query", "usr", "rpm", "debug", "wx", "esp", "ext", "term", " res", "resp"], "s": ["ts", "p", "h", "sb", "ats", "sw", "ses", "sol", "rs", "ies", "ls", "sp", "ss", "es", "its", "ps", "str", "gs", "ys", "sts", "space", "n", "sq", "fs", "sv", "sl", "is", "serv", "g", "b", "st", "sam", "os", "y", "set", "sys", "js", "hs", "ds", "m", "S", "sis", "so", "t", "c", "sc", "spec", "vs", "cs", "bs", "ns"], "nb_sectors": ["nb_secs", "nb_belements", "nb_vectors", "nb_beves", "nb_bectors", "nb_lectors", "nb_vecs", "nb_velements", "nb_lecs", "nb_lelements", "nb_selements", "nb_leves", "nb_veves", "nb_becs", "nb_seves"], "ret": ["flag", "RET", "final", "mem", "sel", "re", "result", "Ret", " RET", "val", "rem", "out", "nt", "net", "def", "set", "sys", " resp", "et", "res", "ll", "resp", "alt", "Return"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "static void flush_queued_work(CPUState *cpu)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (cpu->queued_work_first == NULL) {\n\n        return;\n\n    }\n\n\n\n    while ((wi = cpu->queued_work_first)) {\n\n        cpu->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n        if (wi->free) {\n\n            g_free(wi);\n\n        }\n\n    }\n\n    cpu->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9707, "substitutes": {"cpu": ["p", "sync", "cli", "runner", "library", "np", "proc", "CPU", "conn", " CPU", "gpu", "px", "alloc", "jp", "pause", "cam", "tp", "processor", "nc", "boot", "rpm", "cum", "cu", "program", "hw", "java", "process", "bench", "device", "pai", "cp", "prof", "core", "net", "cil", "parse", "os", "phys", "pu", "cmp", "sys", "hog", "aco", "phy", "c", "kernel", "computer", "ork", "aq", "apache", "ruby", "clock", "pkg", "cs", "pc", "gc", "mu", "php", "hz", "nz", "ram", "aux", "linux"], "wi": ["ui", "hirt", "yi", "wig", "wp", "WI", "hus", "gi", "wy", "wit", "yu", "xe", "wr", "Wi", "ei", "esi", "xi", "wiki", "wife", "iu", "wei", "wk", "wx", "feat", "ni", "pai", "isi", "bi", "ushi", "igi", "wl", "innie", "hi", "wm", "mie", "wine", "lis", "hog", "fi", "pie", "wid", "wa", "qi", "mi", "hei", "wu", "cgi", "wen", "ti", "rw", "ye", "dit", "we", "ki", "hip", "wic", "wal", "rus"]}}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n", "idx": 9709, "substitutes": {"guest_base": ["guestingid", "guess0base", "guest_prefix", "guests_Base", "guester_prefix", "guest0buffer", "guest_name", "guestingprefix", "guest_Base", "guester_space", "guess_size", "guest2start", "guests_name", "guesteringprefix", "guest_start", "guest_based", "guesteringid", "guess0size", "guest2buffer", "guests_base", "guess0start", "guest2size", "guest_space", "guess_start", "guest_buffer", "guestingbase", "guest0base", "guester_base", "guess_area", "guestingspace", "guest_id", "guest_area", "guest0size", "guess0buffer", "guester_id", "guest_len", "guess_len", "guest0start", "guess_based", "guesteringspace", "guesteringbase", "guess_base", "guess_buffer", "guest2base"], "guest_size": ["guest_space", "guess_length", "guest_SIZE", "guest_count", "guEST_count", "guEST_SIZE", "guess_size", "guest_sum", "guEST_space", "guEST_size", "guest_length", "guess_sum"], "real_start": ["real_stop", " real_int", "realitymatch", "absoluteitylast", "Real_Start", "absoluteitymatch", "absolute_last", "real_last", "Real_start", "real___index", "absolute_start", "real_end", "realitystart", " real_stop", "real_int", "real_Start", "absolute_open", "real_open", "real_data", "realityindex", "absoluteityopen", "realitytype", "real_index", "real___type", "real_type", " real_end", "real_match", "real___start", " real_st", "realityopen", "Real_data", "real_st", " real_type", "realityint", "absolute_match", "absoluteitystart", " real_index", "real___int", "realitylast", "Real_end"], "test_page_addr": ["test_port_start", "test_row_ptr", "test_page_end", "test_pageekaddress", "test_page_address", "test_page2address", "test_page_block", "test_row_block", "test_page__addr", "test_pageekblock", "test_pagelyaddr", "test_page_start", "test_page_ptr", "test_page__address", "test_page_res", "test_page__ptr", "test_port_addr", "test_port_address", "test_pagelyend", "test_row_addr", "test_page_attr", "test_pagelyaddress", "test_row_res", "test_page2addr", "test_row_address", "test_pageekaddr", "test_page2start"]}}
{"project": "qemu", "commit_id": "f5f601afcec6c1081128fe5a0f831788ca9f56ed", "target": 1, "func": "long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 9721, "substitutes": {"env": ["self", "dev", "h", "cb", "conn", "ev", "enter", "err", "v", "esc", "addr", "environment", "end", "entry", "en", "code", "window", "vm", "stack", "exc", "ew", "obj", "buf", "cv", "server", "enc", "er", "viron", "ec", "eq", "hl", "queue", "ctx", "uv", "open", "ten", "txt", "here", "buffer", "eh", "db", "rb", "nv", "vs", "pkg", "context", "e", "ptr", "erd", "hw", "vp", "w", "state", "scope"], "frame": ["step", "scene", "send", "reset", "ace", "init", "proc", "cf", "feature", "next", "f", "link", "flow", "frames", "role", "connection", "fc", "function", "version", "fram", "call", "fr", "code", "window", "lock", " Frame", "rame", "stack", "process", "channel", "range", "line", "close", "feat", "zone", "Frame", "event", "load", "file", "tick", "def", "push", "info", "term", "package", "ref", "style", "header", "ctx", "fi", "face", "trace", "ce", "sequence", "module", "profile", "t", "chain", "draw", "hide", "framework", "block", "base", "row", "point", "context", "doc", "state", "image", "scope", "cmd"], "frame_addr": ["frame_arm", "frameingadr", "frame_nr", "frame9ord", " frame_nr", "component9addr", "component9ord", "component_arm", "frame_id", "frameingaddr", "frame_ptr", "frame9arm", "frame_ord", " frame_id", "component_oa", "frameingoa", "component_adr", " frame_ptr", "frame_address", "frameingptr", "frame9addr", "frame__ptr", "frame_oa", "frame__addr", "frame2addr", "frame2address", "frame9ptr", "frame_adr", "component_ptr", "component_ord", "frame__id", "frame__nr", "component9ptr", "frame2id", "component_addr", "frame2ptr", "component9arm", " frame_address"], "target_set": ["source_session", "target_group", "current_tree", "Target_sc", "targetingset", "current2tree", "targetingSet", "current_sets", "target2base", "source_set", "targetvalbase", "target2sets", "target_subject", "target2set", "targetetsubject", "targetingsc", "targetThebase", "Target_set", "target_sets", "current_set", "current2base", "targetTheset", "targetThesets", "targetetset", "current2set", "target_sc", "Target_Set", "target2tree", "targetvalsets", "current2sets", " target_type", "targetvalset", "target_tree", "targetetsc", "target_base", "targetetSet", "Target_subject", "targetvaltree", "targetingsubject", " target_se", "target_Set", "source_group", "target_session", "targetThetree", "target_type", "current_base", "target_se"], "set": ["util", "step", "session", "equal", "sets", "flag", "se", "sh", "op", "clear", "settings", "format", "add", "id", "sche", "result", "lang", "group", "map", "mod", "wrap", "global", "en", "new", "SET", "setup", "store", "cast", "g", "arg", "Set", "setting", "st", "ch", "match", "script", "parse", "ext", "get", "sign", "package", "section", "local", "hash", "reset", "export", "open", "check", "et", "sc", "mask", "san", "cut", "spec", "gen", "msg", "scope", "error"], "i": ["ui", "di", "p", "cli", "x", "uri", " x", " ti", " m", "v", "gi", "ic", "ai", "z", " ii", "ind", "l", "ii", "j", "xi", "sim", "I", "phi", "ix", "oi", "multi", "u", "bi", " I", "me", "o", "n", "in", "g", "is", "hi", "si", " k", " v", "index", "li", " bi", "y", "ini", "q", "fi", "it", "\u0438", "ci", "m", "t", "zi", "mi", "qi", " j", "ip", "ti", "im", "pi", "mu", "ki", "ims", "e", "ms"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n", "idx": 9722, "substitutes": {"priv": ["pro", "pr", "conf", "DEV", "proc", "conn", "ev", "deb", "mem", "attr", "private", "disabled", "auth", "pad", "access", "env", "org", "pub", "rc", "vt", "riv", "serv", "tr", "path", "info", "iv", "phys", "Priv", "prop", "pi", "pkg", "ptr", "pri"], "id": ["p", "h", "aid", "eth", "tag", "i", "type", "iden", "addr", "pid", "oid", "sp", "end", "name", "ident", "str", "start", "ep", "uid", "key", "Id", " fid", " rid", " pid", "size", "event", "kid", "ID", " tid", "path", "info", "ref", "sid", "wid", "ip", "ad", "status", "mid", "rid", "vid", "ide", "ids"], "interrupt_packet": ["interrupt_checkant", "interrupt_paykt", "interrupt_signeter", "interrupt_linkET", "interrupt_packetter", "interruptingpackacket", "interrupt_packageett", "interrupt_packsett", "interrupt_signets", "interrupt_presant", "interrupt_signetter", "interrupt_signET", "interrupt_packett", "interrupt_packer", "interrupt_packacket", "interrupt_parseetter", "interrupt_payet", "interrupt_pET", "interrupt_signett", "interrupt_linker", "interrupt_octets", "interrupt_picker", "interruptingpet", "interrupt_packser", "interruptingpackET", "interruptingpicker", "interrupt_checket", "interrupt_packageant", "interrupt_signer", "interruptingpET", "interrupt_acketer", "interruptingpicket", "interrupt_acketter", "interrupt_packageet", "interrupt_payacket", "interrupt_packET", "interrupt_packageET", "interrupt_packingoint", "interrupt_packkt", "interrupt_ackacket", "interrupt_packsET", "interrupt_packsetter", "interruptingpackkt", "interrupt_packageoint", "interrupt_presacket", "interrupt_octett", "interrupt_parseacket", "interrupt_checkoint", "interrupt_packsacket", "interrupt_octetter", "interruptingpickett", "interrupt_packageetter", "interrupt_linketter", "interrupt_payET", "interrupt_packoint", "interrupt_packant", "interrupt_picket", "interrupt_presET", "interrupt_octacket", "interrupt_packingET", "interrupt_packageacket", "interrupt_packeter", "interruptingpacker", "interrupt_signacket", "interrupt_parseet", "interrupt_pickacket", "interrupt_packets", "interrupt_octet", "interruptingpickacket", "interruptingpkt", "interrupt_packinget", "interrupt_pet", "interruptingpackett", "interrupt_acket", "interrupt_presoint", "interrupt_packageets", "interrupt_preset", "interrupt_linket", "interrupt_octET", "interrupt_signoint", "interrupt_pkt", "interrupt_packsoint", "interrupt_parseeter", "interrupt_packingacket", "interrupt_pickett", "interrupt_octer", "interrupt_checkET", "interrupt_signet", "interruptingpacket", "interrupt_preskt", "interrupt_packset"], "data": ["p", "extra", "snap", "off", "DATA", "bin", "mem", "ata", "sp", "length", "end", "rec", "pad", "str", "trans", "Data", "map", "window", "dl", "new", "raw", "all", "device", "out", "n", "buf", "nt", "size", "obj", "d", "form", "bytes", "dat", "def", "empty", "tx", "bus", "text", "t", "pos", "buffer", "len", "ad", "rew", "res", "table", "resp", "mu", "w", "rel"], "data_len": ["data36Len", "data_length", "len2Len", "len2len", "data36lang", "data2length", "data36len", "data_lim", "data_fil", "data2len", "data36length", "len_lang", "byte_pos", "byte_lim", "len2lang", "len_length", "len2length", "data_lang", "data2Len", "data_pos", "byte_len", "byte_Len", "data_lon", " data_fil", "data2lang", "len_len", " data_lon", " data_Len", "data_Len", "len_Len"], "dev": [" Dev", "pro", "p", "av", "wd", "conf", "DEV", "conn", "Dev", "ev", "mem", "proc", "link", "v", "test", "cam", "tech", "serial", "pad", "pt", "ver", "access", "env", "window", "val", "school", "pub", "debug", "device", "api", "ve", "nt", "des", "obj", "server", "md", "er", "serv", "d", "app", "def", "tr", "ow", "var", "local", "desc", "sd", "go", "sys", "adv", "ctx", "home", "prom", "db", "block", "den", "pkg", "pi", "doc", "ptr", "hw", "w"], "aurb": ["urchl", "aurbd", "urdbar", "averv", "augb", "aucbase", "urchbase", "ravbc", "afferxb", "urchu", "urchbs", "augrb", "thurr", "aurbc", "aurcb", "urchB", "aurbs", "urchr", "averbe", "arB", "urchv", "arbe", "urbe", "urerbd", "urB", "aucb", "urerl", "urd", "auru", "ard", "urchd", "aurbase", "afferv", "aurba", "ravbar", "aurl", "averxb", "thurb", "urdbs", "aurB", "urchb", "ravl", "aurd", "aurr", "aversb", "averba", "augcb", "urdl", "afferb", "urdrb", "urb", "urdbc", "averbc", "urchbe", "urdcb", "urchbody", "averbase", "aurbody", "arb", "thurbs", "aurbe", "ravb", "thurl", "aucsb", "urchba", "thuru", "averb", "averl", "aucba", "urchrb", "urchbd", "afferbe", "urchcb", "aurbar", "aurxb", "urdbd", "urdb", "aurv", "urerbody", "averbar", "urchxb", "urchsb", "thurbd", "urerb", "aursb", "urdu", "augbd", "thurbody", "aurrb", "urdr"]}}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "void mpeg1_encode_mb(MpegEncContext *s,\n\n                     DCTELEM block[6][64],\n\n                     int motion_x, int motion_y)\n\n{\n\n    int i, cbp;\n\n    const int mb_x = s->mb_x;\n\n    const int mb_y = s->mb_y;\n\n    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;\n\n\n\n    /* compute cbp */\n\n    cbp = 0;\n\n    for(i=0;i<6;i++) {\n\n        if (s->block_last_index[i] >= 0)\n\n            cbp |= 1 << (5 - i);\n\n    }\n\n    \n\n    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && \n\n        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||\n\n        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |\n\n        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {\n\n        s->mb_skip_run++;\n\n        s->qscale -= s->dquant;\n\n        s->skip_count++;\n\n        s->misc_bits++;\n\n        s->last_bits++;\n\n        if(s->pict_type == P_TYPE){\n\n            s->last_mv[0][1][0]= s->last_mv[0][0][0]= \n\n            s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0;\n\n        }\n\n    } else {\n\n        if(first_mb){\n\n            assert(s->mb_skip_run == 0);\n\n            encode_mb_skip_run(s, s->mb_x);\n\n        }else{\n\n            encode_mb_skip_run(s, s->mb_skip_run);\n\n        }\n\n        \n\n        if (s->pict_type == I_TYPE) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n        } else if (s->mb_intra) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 6, 0x01, 0, 0);\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 5, 0x03, 0, 0);\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n            memset(s->last_mv, 0, sizeof(s->last_mv));\n\n        } else if (s->pict_type == P_TYPE) { \n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp != 0) {\n\n                    if ((motion_x|motion_y) == 0) {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern & quant */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                    } else {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                        mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                        mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                        s->mv_bits+= get_bits_diff(s);\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->misc_bits+= get_bits_diff(s);\n\n                    mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                    mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                    s->qscale -= s->dquant;\n\n                    s->mv_bits+= get_bits_diff(s);\n\n                }\n\n                s->last_mv[0][1][0]= s->last_mv[0][0][0]= motion_x;\n\n                s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y;\n\n            }else{\n\n                assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD);\n\n\n\n                if (cbp) {\n\n                    if(s->dquant){\n\n                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    }else{\n\n                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits+= get_bits_diff(s);\n\n                for(i=0; i<2; i++){\n\n                    put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                    s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                    s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                }\n\n                s->mv_bits+= get_bits_diff(s);\n\n            }\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n            s->f_count++;\n\n        } else{  \n\n            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi\n\n\n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 0);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); \n\n                    mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); \n\n                    s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0];\n\n                    s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1];\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); \n\n                    mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); \n\n                    s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0];\n\n                    s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1];\n\n                    s->b_count++;\n\n                }\n\n            }else{\n\n                assert(s->mv_type == MV_TYPE_FIELD);\n\n                assert(!s->frame_pred_frame_dct);\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 1);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                        s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                    }\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[1][i]);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);\n\n                        s->last_mv[1][i][0]=   s->mv[1][i][0];\n\n                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];\n\n                    }\n\n                    s->b_count++;\n\n                }\n\n            }\n\n            s->mv_bits += get_bits_diff(s);\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n        }\n\n        for(i=0;i<6;i++) {\n\n            if (cbp & (1 << (5 - i))) {\n\n                mpeg1_encode_block(s, block[i], i);\n\n            }\n\n        }\n\n        s->mb_skip_run = 0;\n\n        if(s->mb_intra)\n\n            s->i_tex_bits+= get_bits_diff(s);\n\n        else\n\n            s->p_tex_bits+= get_bits_diff(s);\n\n    }\n\n}\n", "idx": 9727, "substitutes": {"s": ["changes", "sb", "sets", "ses", "events", "ls", "ains", "xs", "aws", "comm", "sv", "as", "bis", "js", "sys", "c", "https", "eds", "se", "ms", "w", "ins", "ns", "less", "ats", "conf", "sw", "ies", "qs", "ges", "settings", "ps", "acs", "ads", "terms", "parts", "sq", "fs", "app", "stats", "ds", "comments", "vs", "mys", "cs", "ims", "tes", "gets", "p", "aunts", "ar", "its", "l", "ops", "ex", "tests", "is", "g", "eps", "os", "times", "hs", "ares", "e", "us", "ts", "rs", "v", "args", "ss", "es", "als", "z", "gs", "sts", "n", "plays", "details", "pers", "states", "m", "S", "bits", "bs", "sports", "ants"], "block": ["p", "Block", "type", "frame", "data", " bl", "media", "map", "window", "lock", "bl", "record", "config", "obj", "size", "b", "blocks", "OCK", "info", "view", "ref", "m", "buffer", "base", " b", "ram", "image", "bm"], "motion_x": ["motion12yx", "mission___ox", "motion67yx", "motion_ix", "motion67x", "ori67x", "motion_yx", "motion_xc", "ori67yx", "mission_ox", "mission___id", "motion67ix", "motion08ox", "ori_X", "motion08id", "motion___id", "ori_x", "ori67ix", "motion_X", "mission___x", "ori67X", "motion___x", "mission_xc", "motion12x", "motion_ox", "ori_yx", "motion08xc", "motion12X", "motion___xc", "motion08x", "mission___xc", "mission_x", "motion_id", "motion___ox", "ori_ix", "mission_id", "motion12ix", "motion67X"], "motion_y": ["motion___h", "movie_y", " motion_cy", "motion67yl", "movie___yl", " motion2cy", "motion_yl", "motion___y", "motion___yl", "movie___y", "motion67Y", " motion_yl", " motion2Y", "motion___lon", "motion2Y", "motion______y", "movie___lon", "motion2cy", "motion67y", "motion2y", "movie_yl", "movie_h", "motion2yl", "movie___h", "motion______lon", " motion_Y", "movie_lon", "motion_lon", "motion_Y", "motion_h", " motion2y", "motion______yl", " motion2yl", "motion67cy", "motion______h", "motion_cy"], "i": ["ui", "di", "p", "x", "list", "init", " ti", "f", "v", "gi", "ic", "ai", " ii", "iq", "ind", "ii", "j", "sim", "I", "ix", "iu", "oi", "at", "multi", "bi", " I", "in", "o", "n", "is", "si", "index", "li", " bi", "y", "ini", "info", "bis", "fi", "it", "\u0438", "ci", "m", "c", "qi", "zi", "mi", "ip", " j", "batch", "ti", "im", "pi", "series", "e", "me", "ish", "ski", "conv", "us"], "cbp": ["kbpc", "cvpb", "nbcp", "bcp", "cbpn", "cfpn", "nbpb", "rbphp", "bcv", "cvpa", "bcpb", "cvpp", "cfphp", "cfpp", "callbackpc", "rbpp", "erbpp", "erbp", "cbv", "erbphp", "cvpc", "callbackpp", "bccp", "cbpp", "kbp", "cfps", "sbps", "callbackpa", "cbpa", "cfpa", "rbp", "cvv", "kbps", "rbps", "sbp", "sbpc", "erbps", "sbpn", "callbackp", "cbcp", "cbphp", "cfp", "kbpn", "cbpb", "nbp", "cfpc", "cvp", "cbps", "cbpc", "nbv", "cvcp"], "mb_skip_run": ["mb_skip__runs", "mb_miss_out", "mb_skip__out", "mb_skip__run", "mb_miss_run", "mb_skip_runs", "mb_skip_skip", "mb_miss_skip", "mb_skip_out", "mb_miss_runs", "mb_skip__skip"], "skip_count": ["passseqbits", "skipseqcount", "skipseqprogress", "skipseqbits", "skip_bits", "pass_count", "pass_bits", "passseqcount", "pass_progress", "skip_progress", "passseqsteps", "passseqprogress", "pass_steps", "skip_steps", "skipseqsteps"], "misc_bits": ["first_bits", "static_parts", "static_bits", "static_bit", "first_parts", "first_bit"], "last_bits": ["next_bytes", "last_fps", "last_bytes", "last_bit", "next___bytes", "last___bit", "last___bits", "last___fps", "next_bit", "next___bit", "next_fps", "next___fps", "last___bytes", "next___bits", "next_bits"]}}
{"project": "qemu", "commit_id": "fb846a094fdee7bb6a88b48aeed0d97a8080a20d", "target": 0, "func": "static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)\n\n{\n\n    unsigned int cssid = 0;\n\n    unsigned int ssid = 0;\n\n    unsigned int schid;\n\n    unsigned int devno;\n\n    bool have_devno = false;\n\n    bool found = false;\n\n    SubchDev *sch;\n\n    int num;\n\n    DeviceState *parent = DEVICE(dev);\n\n    Error *err = NULL;\n\n    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);\n\n    VirtIODevice *vdev;\n\n\n\n    sch = g_malloc0(sizeof(SubchDev));\n\n\n\n    sch->driver_data = dev;\n\n    dev->sch = sch;\n\n\n\n    dev->indicators = NULL;\n\n\n\n    /* Initialize subchannel structure. */\n\n    sch->channel_prog = 0x0;\n\n    sch->last_cmd_valid = false;\n\n    sch->thinint_active = false;\n\n    /*\n\n     * Use a device number if provided. Otherwise, fall back to subchannel\n\n     * number.\n\n     */\n\n    if (dev->bus_id) {\n\n        num = sscanf(dev->bus_id, \"%x.%x.%04x\", &cssid, &ssid, &devno);\n\n        if (num == 3) {\n\n            if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) {\n\n                error_setg(errp, \"Invalid cssid or ssid: cssid %x, ssid %x\",\n\n                           cssid, ssid);\n\n                goto out_err;\n\n            }\n\n            /* Enforce use of virtual cssid. */\n\n            if (cssid != VIRTUAL_CSSID) {\n\n                error_setg(errp, \"cssid %x not valid for virtio devices\",\n\n                           cssid);\n\n                goto out_err;\n\n            }\n\n            if (css_devno_used(cssid, ssid, devno)) {\n\n                error_setg(errp, \"Device %x.%x.%04x already exists\",\n\n                           cssid, ssid, devno);\n\n                goto out_err;\n\n            }\n\n            sch->cssid = cssid;\n\n            sch->ssid = ssid;\n\n            sch->devno = devno;\n\n            have_devno = true;\n\n        } else {\n\n            error_setg(errp, \"Malformed devno parameter '%s'\", dev->bus_id);\n\n            goto out_err;\n\n        }\n\n    }\n\n\n\n    /* Find the next free id. */\n\n    if (have_devno) {\n\n        for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n            if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                sch->schid = schid;\n\n                css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"No free subchannel found for %x.%x.%04x\",\n\n                       cssid, ssid, devno);\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"user-configured\");\n\n    } else {\n\n        cssid = VIRTUAL_CSSID;\n\n        for (ssid = 0; ssid <= MAX_SSID; ssid++) {\n\n            for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n                if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                    sch->cssid = cssid;\n\n                    sch->ssid = ssid;\n\n                    sch->schid = schid;\n\n                    devno = schid;\n\n                    /*\n\n                     * If the devno is already taken, look further in this\n\n                     * subchannel set.\n\n                     */\n\n                    while (css_devno_used(cssid, ssid, devno)) {\n\n                        if (devno == MAX_SCHID) {\n\n                            devno = 0;\n\n                        } else if (devno == schid - 1) {\n\n                            error_setg(errp, \"No free devno found\");\n\n                            goto out_err;\n\n                        } else {\n\n                            devno++;\n\n                        }\n\n                    }\n\n                    sch->devno = devno;\n\n                    css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"Virtual channel subsystem is full!\");\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"auto-configured\");\n\n    }\n\n\n\n    /* Build initial schib. */\n\n    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\n\n\n\n    sch->ccw_cb = virtio_ccw_cb;\n\n\n\n    /* Build senseid data. */\n\n    memset(&sch->id, 0, sizeof(SenseId));\n\n    sch->id.reserved = 0xff;\n\n    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;\n\n\n\n    if (k->realize) {\n\n        k->realize(dev, &err);\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n\n        goto out_err;\n\n    }\n\n\n\n    /* device_id is only set after vdev has been realized */\n\n    vdev = virtio_ccw_get_vdev(sch);\n\n    sch->id.cu_model = vdev->device_id;\n\n\n\n    /* Only the first 32 feature bits are used. */\n\n    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                         dev->host_features[0]);\n\n\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    dev->sch = NULL;\n\n    g_free(sch);\n\n}\n", "idx": 9744, "substitutes": {"dev": ["wd", "DEV", "ev", "de", "data", "cam", "ver", "buf", "des", "d", "def", "var", "go", "ad", "db", "den", "w", "cmd", "av", "h", "conf", "sw", "Dev", "mem", "dd", "test", "priv", "pt", "env", "nav", "raw", "ve", "obj", "serv", "app", "scan", "info", "sd", "desc", "ds", "port", "p", "conn", "vol", "exec", "out", "nt", "server", "md", "dem", "os", "ow", "ctx", "doc", "hw", "att", "pro", "die", "v", "dm", "val", "device", "grad", "form", "ch", "iv", "local", "driver", "adv", "dis", "disk", "normal", "det"], "errp": ["ierp", "ierP", "derpb", "eorP", " errpp", "rarpun", "rerpa", "derP", "eorp", "derpoint", " errP", "eorpad", " errpad", "terpoint", "derp", "rerp", "errpad", "ererpp", "errpun", "erbpun", "derpa", "erbp", "terpp", "errpe", "erbphp", "ererpe", "rerpb", "eorpun", "errpa", " errpa", "eorpoint", "errphp", "errpoint", "arrp", "terP", "derpad", "rarphp", "terp", "eorphp", "errP", "ererp", "rarpad", "arrpp", "ierpp", " errpe", " errpb", "rarp", " errpoint", "erbpad", "errpp", "rerP", "ierpoint", "arrpe", "errpb"], "schid": ["kroid", "khident", "schtype", "skaid", "chanid", " schkey", "schide", "skybid", "kride", "krbid", " schmid", " schID", " schpid", "skide", "chin", "kraid", "skno", "krId", " schids", "chId", "chanId", "chanID", "schno", " schoid", "scID", "ssin", "schbid", "schident", "sknew", "schpid", "khnew", "khkey", "sktype", "scheid", "scheids", "schmid", "schID", "chid", "schemid", "skId", "schin", "chanoid", "schdef", "schkey", "skid", "scpid", "shdef", "khids", "chtype", "chID", "scId", "ssId", "skdef", "skbid", "skoid", "kh_", "sch_", "shnew", "schoid", "skin", "skyide", "scin", "krid", "khid", "khID", "khmid", "khId", "sstype", "chanpid", "chident", "khdef", "scoid", " schin", " schId", "skyin", "sk_", "schnew", "ssaid", "scid", "sh_", "schids", "chanident", "ssoid", "schekey", "schId", "chno", "ssno", "schaid", "skyid", "krin"], "devno": [" devo", "devnum", "evni", "divNo", " devyes", "testnos", "Devno", "divo", " devnos", "devyes", "DevNo", "evNo", "devnos", "evo", "devn", "divn", "evyes", "diffo", "deviceNo", "devNo", "devicenos", "diffNo", "diffno", "evn", "evno", "deviceno", " devNo", "divno", "diffni", "testno", "evnos", "testNo", "divni", "divyes", " devn", "divnum", "Devnum", "devni", "testn", "devo", "evnum"], "sch": ["cr", "conf", "sw", "conn", "gh", "sol", "gross", "sh", "chan", "sp", "ss", "cfg", "hed", "priv", "rh", "usb", "sche", "disc", "sky", "sim", "Sch", "th", "school", "channel", "rss", "cht", "shop", "sm", "chn", "cms", "sl", "soc", "serv", "sym", "zh", "sec", "ch", "kh", "ah", "hess", "ach", "mk", "osc", "isch", "mot", "sd", "cmp", "css", "sg", "gr", "go", "hs", "kr", "ssl", "mc", "https", "chain", "sk", "sc", "sum", "chip", "sy", "chu", "arch", "ksh", "ssh", "cs", "Ch", "hz", "scope", "ich"], "num": ["nom", "no", "snap", "off", "um", "final", "coord", "mult", "un", "typ", "number", "add", "end", "ul", "ver", "en", "good", "NUM", "comm", "non", "cum", "old", "rem", " NUM", "n", "lam", "nm", "count", "index", "tim", "dim", "zero", "go", "max", " remain", "m", "cal", "nam", "t", "Num", "sum", "len", "ta", "con", "alph", " number", "ord", "mon", "msg"], "parent": ["self", "instance", "conf", "Parent", "master", "attr", "pid", "params", "id", "cfg", "data", "name", "parents", "root", "obj", "cp", "pool", "g", "def", "shape", "cmp", "task", "chain", "pos", "child", "ram", "spec", "cmd"], "err": ["cr", "pr", "conf", "Er", "proc", "ev", "attr", "rr", "cfg", "usr", "Error", "exc", "buf", "obj", "er", "ch", "ec", "eas", "arr", "cmp", "kr", "req", "resp", "msg", "error", "cmd"], "k": ["p", "v", "ck", "kit", "ek", "tk", "j", "sky", "ka", "ik", "key", "n", "kid", "kh", "mk", "kk", "ks", "ok", "K", "kr", "kind", "m", "c", "kernel", "kt", "sk", "kw", "pkg"], "vdev": ["Vdev", "vdevice", "svdevice", "svdev", " vdef", "Vdevice", "Vdef", "vdef", " vdevice", "svdef"], "ssid": ["ysside", "rssest", "statsid", "statshide", "ssest", "rssolid", "csify", "ssids", "hessida", "cssify", "sspid", "snpid", "cssy", "essin", "ysspart", "rssid", "skide", "rssidy", "yssid", "esside", "hessidy", "ssy", "ksoid", "snida", "rssida", "wsmid", "wsy", "csolid", "ssin", "hessid", "wsids", "cssmid", "csida", "ssie", "wsie", "snide", "cssin", "ssida", "csin", "ksid", "hessify", "kspart", "hesside", "kside", "ssify", "ssidy", "wsid", "cssids", "csmid", "sspart", "cspid", "yssoid", "skid", "skit", "wsd", "rsside", "csid", "cssd", "ssd", "wsest", "csie", "rsspart", "hessmid", "rssoid", "wside", "csshide", "ssolid", "rssy", "csside", "rssids", "csit", "cssida", "cssest", "cssie", "ssit", "cside", "sside", "essids", "hesshide", "hessd", "skolid", "rssit", "statsida", "csids", "rssd", "cssidy", "ssoid", "ssmid", "statside", "sshide", "essid", "cssid", "rsspid", "snid"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 9754, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tunsigned i;\n\n#ifdef HAVE_MMX\n\n\tlong mmx_size= 23 - src_size;\n\n\tasm volatile (\n\n\t\t\"test %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\"jns 2f\t\t\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 32(%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq  2(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // R BGR BGR B\n\n\t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR\n\n\t\t\"pand %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq  6(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\tMOVNTQ\" %%mm1,   (%2, %%\"REG_a\")\\n\\t\" // RGB RGB RG\n\n\t\t\"movq  8(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // R BGR BGR B\n\n\t\t\"movq 10(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // GR BGR BGR\n\n\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq 14(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // R BGR BGR B\n\n\t\tMOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n", "idx": 9761, "substitutes": {"src": ["earth", "sync", "dist", "sb", "sw", "imp", "proc", "rs", "seq", "sur", "cont", "sh", "ser", "sel", "cur", "std", "syn", "sup", "ind", "obs", "rec", "ul", "str", "usr", "sts", "rob", "supp", "rc", "sr", "in", "sq", "rl", "tmp", "iter", "secure", "sl", "comp", "sv", "inst", "sec", "scan", "st", "s", "tr", "lit", "iv", "sn", "input", "rt", "desc", "sys", "rx", "txt", "usc", "sc", "source", "loc", "dest", "alt", "RC", "ctr", "sub", "bs", "sort", "img", "lib", "ins"], "dst": [" dpi", "nst", "send", "ddstr", "nput", "dpi", "nsrc", "ddest", " dest", "adstr", "sst", "udcp", "Dest", "dsp", "dtr", "dsrc", "dcp", " dsrc", " dsp", "dssts", "dmt", "Dstr", "Dst", "ddend", "adsp", "udpi", "admt", "dend", "dstr", "dsput", "nend", "udst", "addest", " dtr", "sput", "dsst", "npi", "adst", "Dmt", "scp", "dput", "dsts", "adest", " dmt", "ddsp", "ddput", "udsrc", "ddsts", "ddcp", "adsts", "ntr", " dstr", " ddest", "dest", "ncp", "Ddest", " dput", "nsts", " dsts", " dcp", "ddst"], "src_size": ["src_Size", "rc_size", "src_count", "src_name", "rc_count", " src_Size", "src_shape", "rc_SIZE", "src_dimension", " src_shape", "rl_height", "rc_dimension", " src_length", "src_SIZE", " src_SIZE", "rc_ize", "src2size", "src_dim", " src_space", "src_ize", "src2name", "rc_group", "src_height", " src_name", "rl_size", "src_len", "src_space", "rl_dim", " src_len", "src_group", "src_length", "rc_name", "src2space"], "i": ["ui", "di", " pi", " l", "cli", "list", "init", "ami", " ti", " m", "v", " pos", "gi", "id", "ai", "ic", " index", " ii", "ind", "ei", "ii", "j", "xi", "sim", "I", "ix", "iu", " mi", "at", "multi", "slice", "bi", " I", "in", "this", "is", "si", " k", "index", "try", "li", " bi", "y", "ini", "info", "go", "it", "\u0438", "m", " p", "ci", " di", "t", "c", "mi", "zi", " j", "chain", "batch", "qi", "status", "ip", "im", "ij", "ti", "pi", "me"], "memory": ["write", "library", "metadata", "mem", "directory", "vector", "integer", "function", "location", "media", "command", "javascript", "device", "record", "Memory", "pointer", "history", "attribute", "mouse", "variable", "sequence", "reference", "module", "disk", "information", "buffer", "binary", "message", "gc", "statement", "address", "storage"], "x": ["r", "p", "X", "dx", "xy", "zx", " xx", "px", "v", " y", "xt", "z", "xe", "xf", "ox", "xi", " ex", "ix", "ex", "u", "wx", "xp", "g", " dx", "s", "y", "tx", "fx", " xp", "ux", " err", "rx", "c", " tx", "m", "t", " X", "mx", " ax", "xc", "w", "xx"]}}
{"project": "FFmpeg", "commit_id": "ffd7fd79441f97f1edb25181af0603ff6ea9b342", "target": 1, "func": "static int vda_h264_end_frame(AVCodecContext *avctx)\n{\n    H264Context *h                      = avctx->priv_data;\n    struct vda_context *vda_ctx         = avctx->hwaccel_context;\n    AVFrame *frame                      = &h->cur_pic_ptr->f;\n    struct vda_buffer *context;\n    AVBufferRef *buffer;\n    int status;\n    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)\n    status = vda_sync_decode(vda_ctx);\n    frame->data[3] = (void*)vda_ctx->cv_buffer;\n    if (status)\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);", "idx": 9772, "substitutes": {"avctx": ["avdyl", "cvctx", "avtx", "cvtx", "avedyl", "afctx", "afdyl", " avcc", "avcc", "AVcontext", "avcmp", "averctx", "avekb", "avkw", "cvkw", "avercontext", "Avcc", "Avctx", "avecontext", " avdyl", " avkb", "Avcmp", "cvcontext", " avcontext", "AVcc", "avkb", "avertx", "AVcmp", " avkw", "AVctx", "Avcontext", " avtx", "avetx", "aftx", "afcontext", "avcontext", "avectx", " avcmp", "AVkb", "AVtx", "averkw"], "h": ["r", "p", "hp", "f", "ih", "v", "sh", "hm", "hum", "l", "hd", "help", "H", "bh", "b", "oh", "history", "hi", "ht", "he", "ph", "ah", "hl", "hash", "ctx", "hs", "m", "c", "here", "t", "eh", "ptr", "host", "hw", "w"], "vda_ctx": ["vta_txt", "vta_cmp", "vda_cfg", "vda____nt", "vdaingjp", "vda_tx", "vda_jp", "vda_cmp", "vda__tx", "vda__ctx", "vda____ns", "vda____ctx", "vda2txt", "vDA_tx", "vda____tx", "vda_nt", "vda__cfg", "vda_history", "vta_context", "vda_ns", "vta_cfg", "vda_txt", "vDA_ctx", "vta_ctx", "vda_tz", "vda__tz", "vdainghistory", "vda_msg", "vta_tz", "vda2tx", "vda2ctx", "vDA_ns", "vDA_nt", "vta_msg", "vta_history", "vda2context", "vdaingtx", "vta_jp", "vta_tx", "vda_context", "vdaingctx"], "frame": ["r", "f", "request", " df", "data", "frames", "version", "entry", "object", "command", "call", "result", "fr", "image", "window", "component", "channel", " fr", "line", "feat", "zo", "Frame", "event", "file", "def", "one", "info", "board", "header", "sequence", "ce", "ence", "base", "row", "point", "message", "e", "state", "profile", "response"], "context": ["metadata", "document", "format", "connection", "command", "map", "window", "content", "channel", "config", "event", "history", "index", "cache", "path", "shape", "tx", "header", "ctx", "c", "text", "filter", "Context", "message", "template", "reference"], "buffer": ["document", "v", "Buffer", "data", "command", "uf", "map", "window", "channel", "cv", "buf", "buff", "b", "cache", "view", "ref", "queue", "header", "filter", "batch", "source", "message", "stream", "profile", "reference", "length"], "status": ["usage", "sync", "uses", "flag", "pres", "sw", "iso", "err", "i", "success", "args", "id", "Status", "ss", "stat", "atus", "compl", "result", "reason", "wait", "str", "code", "progress", "ex", "summary", "sex", "flags", "US", "g", "prefix", "esp", "details", "s", "ms", "negative", "stats", "ssl", "states", "yes", "check", "comments", "sc", "res", "valid", "ping", "message", "gc", "e", "state", "score", "spec", "msg", " Status", "error"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data,\n\n                        int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    Picture *out;\n\n    int i, out_idx;\n\n    int ret;\n\n\n\n    h->flags  = avctx->flags;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\n    if (buf_size == 0) {\n\n out:\n\n\n\n        h->cur_pic_ptr = NULL;\n\n        h->first_field = 0;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f.key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            out->reference &= ~DELAYED_PIC_REF;\n\n            ret = output_frame(h, pict, &out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n\n        int cnt= buf[5]&0x1f;\n\n        const uint8_t *p= buf+6;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n        cnt = *(p++);\n\n        if(!cnt)\n\n            goto not_extra;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n\n    }\n\nnot_extra:\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n\n    if (buf_index < 0)\n\n        return -1;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        av_assert0(buf_index <= buf_size);\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n\n            return buf_size;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        field_end(h, 0);\n\n\n\n        /* Wait for second field. */\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n            if (CONFIG_MPEGVIDEO) {\n\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n\n                                    &h->low_delay,\n\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(pict->data[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 9781, "substitutes": {"avctx": [" avconn", "apctx", "averjac", "avjac", "avecp", "navjac", "avcp", "avertc", "navcmp", "avercmp", " avcp", "auxctx", "navcv", "avcmp", "auxcp", "averctx", " avcv", "navtc", "avercontext", "avecontext", "apjac", " avcontext", "aveconn", "navctx", "aptc", " avtc", "avercv", "auxconn", "apcmp", "navcontext", "avcv", "avcontext", "avectx", "avconn", "avtc", "auxcontext"], "data": ["snap", "images", "DATA", "bin", "value", "next", "read", "ata", "id", "frame", "name", "media", "pad", "padding", "Data", "start", "window", "picture", "content", "raw", "device", "obj", "size", "pointer", "a", "area", "d", "video", "form", "bytes", "dat", "def", "to", "empty", "package", "input", "first", "into", "ctx", "text", "t", "buffer", "res", "batch", "block", "table", "action", "message", "mu", "doc", "image", "length", "zero", "img", "rel"], "got_frame": ["kept_channel", "received__error", "received_sequence", "received_error", "received__sequence", "got_sequence", "got_state", "got_channel", "got__state", "kept_frames", "kept_frame", "received__state", "received_frame", "received_state", "got_frames", "got_error", "kept_point", "got__frame", "got_point", "got__error", "received__frame", "got__sequence"], "avpkt": ["avpskat", "avpretxt", "afpacket", "avepkt", "afptxt", "avprekt", "avcpkt", "afcpdu", "avdpkg", "avnpacket", "avpsct", "afpdat", "avcpacket", "avepct", "avPkt", "avepsct", "avepkg", "afpkt", "afcptxt", "avdpdu", "avpreacket", "avepskt", "avepskat", "avPkat", "avcpkg", "avdpkt", "avpkat", "avdpacket", "avpdat", "avpskt", "avpskg", "avepkat", "avepskg", "avpingct", "avpingkat", "avcpdu", "afcpkg", "afcpdat", "avpdu", "afpkg", "avnpkt", "avdpdat", "avpct", "avpacket", "avpingkt", "avnpdu", "avPkg", "avprekg", "avcpdat", "avpkg", "avnpdat", "avptxt", "avdptxt", "avcptxt", "afcpkt", "afcpacket", "avpingkg", "avPct", "afpdu"], "buf": ["aka", "bin", "cat", "err", "pack", "cam", "fb", "rc", "count", "buff", "cache", "def", "empty", "ref", "Buff", "c", "len", "packed", "batch", "rb", "db", "pkg", "ptr", "fac", "Buffer", "w", "cmd", "font", "mem", "good", "raw", "bl", "nm", "begin", "enc", "desc", "txt", "buffer", "block", "port", "msg", "off", "seq", "cap", "pb", "bp", "pad", "str", "uf", "deg", "size", "tmp", "cast", "b", "bytes", "late", "ctx", "vec", "br", "doc", "ctr", "conv", "cb", "mat", "BU", "ff", "read", "v", "alloc", "emb", "pg", "bc", "n", "cv", "pool", "dat", "queue", "box", "uv", "pos", "used", "xff", "words", "img"], "h": ["self", "HH", "high", "gh", "his", "hp", "f", "v", "ih", "hm", "sh", "rh", "l", "hook", "j", "hd", "comm", "phi", "hz", "http", "th", "n", "host", "H", "o", "bh", "b", "g", "oh", "hi", "history", "ht", "he", "ch", "dh", "ah", "ph", "hold", "handle", "kh", "y", "hl", "ha", "hh", "hash", "go", "q", "uh", "ctx", "hs", "m", "c", "here", "t", "eh", "cache", "hal", "zh", "k", "hw", "w"], "pict": ["pas", "pic", "ot", "np", "pres", " picture", "fat", "cam", "ct", "Pic", "uf", "image", "picture", "capt", "avi", "piece", "feat", "oin", "obj", "photo", "buff", "fn", "png", "ht", "Picture", "act", "phys", "fp", "ctx", "fi", "phy", "txt", " pic", "kt", "fig", "doc", "vp", "Pict", "img"], "out": ["no", "co", "aos", "err", "chan", "cfg", "cam", "end", "u", "null", "cache", "to", "empty", "c", "t", "up", "w", "jp", "cmd", "ent", "conf", "comment", "op", "output", "again", "new", "after", "obj", "serv", "ht", "one", "note", "set", "it", "status", "res", "msg", "by", "pic", "init", "off", "conn", "outs", "ou", "result", "at", "ex", "o", "tmp", "g", "b", "copy", "ctx", "can", "doc", "conv", "pas", "ot", "opt", "timeout", "f", "v", "j", "in", "n", "net", "png", "ch", "full", "Out", "check", "OUT", "image", "img"], "i": ["ami", "cli", "x", " ii", "ind", "ix", "iu", "bi", "remote", "index", "li", "go", "\u0438", "io", "batch", "ti", "series", "k", "gi", "ic", "them", "ei", "I", "phi", "my", "tim", "info", "q", "it", "mc", "qi", "mi", "ij", "status", "cgi", "ki", "ims", "me", "ori", "ui", "init", "span", "uri", "id", "l", "xi", "sim", "oi", "multi", "record", "is", "g", "try", "y", "ini", "gu", "fi", "ci", "chain", "pi", "di", "list", "v", "ri", "ai", "ii", "j", "ji", "iy", "in", "n", "hi", "si", "vi", "m", "zi", "ip", "point", "im", "ski"], "out_idx": ["out_idex", "out_midz", "out_Idy", "out_indx", "out_Idix", "out_ndz", "out_Idex", "out_Idn", "out_idez", "out_prz", "out_prct", "out_ndxs", "out_midct", "out_Idx", "out_idct", "out_idz", "out_midxs", "out_midx", "out_idxs", "out_idy", "out_ndix", "out_ideex", "out_Idxs", "out_prxs", "out_indy", "out_idey", "out_Idz", "out_prx", "out_index", "out_idn", "out_ndx", "out_idix", "out_indn"], "ret": ["r", "pret", "flag", "RET", "ft", "mem", "cat", "rev", "fun", "value", "v", " Ret", "cont", "re", "format", "str", "result", "j", "tt", "Ret", "gt", "deg", "usr", "val", "rem", "nt", "rets", "tmp", "net", "back", "print", "mt", "def", "tr", "ext", "try", "arr", "elt", "ry", "rt", "tf", "it", "txt", "t", "len", "res", "status", "ll", "resp", "alt", "gc", "Return", "nz", "msg", "arg", "cmd"], "p": ["r", "pro", "pic", "x", "pr", "np", "wp", "lp", "f", "pp", "v", "pre", "pid", "sp", "pb", "tp", "dp", "pg", "bp", "l", "pt", "ps", "j", "page", "n", "cp", "P", "a", "b", "g", "d", "pa", "par", "y", "q", "pat", "c", "m", "part", "t", "pos", "per", "ping", "ap", "pkg", "pc", "vp", "jp"], "cnt": ["acNT", " counter", "cnd", " c_", "acount", "ncnt", "nounter", "n_", " count", "Ccount", "account", "Count", "cNT", "nnt", " cnd", "count", "c_", "ncnd", "ccount", "acnt", "Cnt", "counter", " ccount", "CNT", "ncNT", "nNT", "nnd", "count_", " cNT", "ncounter"]}}
{"project": "qemu", "commit_id": "e853ea1cc68716c3d9c22d04578020c6dd743306", "target": 1, "func": "GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n", "idx": 9787, "substitutes": {"c": ["r", "p", "dc", "cb", "cr", "C", "cf", "cat", "f", "v", "cm", "cont", "fc", "l", "comm", "lc", "cu", "cc", "channel", "cor", "cp", "a", "g", "b", "d", "ch", "etc", "com", "ce", "t", "sc", "con", "cs", "e", "k", "w", "ac"], "buf": ["p", "cb", "aka", "seq", "bin", "cap", "coord", "v", "addr", "nb", "pb", "data", "cur", "length", "end", "bc", "uf", "window", "new", "shift", "raw", "bag", "cv", "bar", "tmp", "iter", "buff", "b", "mb", "bytes", "tab", "queue", "q", "ref", "Buff", "br", "vec", "wb", "box", "t", "pos", "buffer", "len", "block", "rb", "batch", "w", "ctr", "Buffer", "msg", "cmd"], "size": ["done", "equal", "send", "present", "type", "read", "args", "sp", "data", "z", "speed", "fee", "name", "needed", "height", "capacity", "start", "code", "global", "small", "all", "out", "sent", "space", "null", "total", "complete", "use", "zone", "time", "n", "g", "scale", "index", "Size", "required", "see", "shape", "empty", "sn", "set", "max", "offset", "ctx", "ize", "body", "chain", "pos", "buffer", "sc", "status", "len", "sum", "any", "valid", "message", "state", "SIZE", "w", "length", "zero", "number"], "count": ["found", "flag", "comment", "type", "amount", "read", "err", "cont", "test", "id", "number", "data", "z", "stat", "add", "ind", "needed", "ct", "result", "code", "Count", "cc", "th", "all", "at", "expected", "created", "n", "total", "nt", "temp", "index", "cache", "try", "info", "empty", "set", "max", "now", "ctx", "ize", "check", "t", "num", "counter", "buffer", "status", "sum", "base", "gc", "state", "ctr", "ptr", "length", "zero", "cmd"]}}
{"project": "FFmpeg", "commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "target": 1, "func": "static int channelmap_query_formats(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n\n\n    ff_set_common_formats(ctx, ff_planar_sample_fmts());\n\n    ff_set_common_samplerates(ctx, ff_all_samplerates());\n\n    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);\n\n    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);\n\n\n\n    return 0;\n\n}\n", "idx": 9789, "substitutes": {"ctx": ["p", "km", "np", "tc", "mem", "jj", "cm", "std", "ck", "ic", "cfg", "cam", "bc", "nc", "ct", "xs", "crit", "gs", "cl", "window", "jac", "dl", "lc", "comm", "cu", "cc", "qt", "wx", "ctl", "setup", "cp", "kg", "cv", "nt", "xp", "cas", "kj", "gz", "history", "fn", "kh", "kl", "act", "kb", "tx", "cmp", "ca", "go", "hs", "ns", "ia", "mc", "c", "req", "kt", "sc", "anc", "kw", "aus", "loc", "xc", "pkg", "context", "pc", "gc", "k", "hw", "wcs", "jp", "cmd"], "s": ["ts", "p", "sb", "sets", "ats", "rs", "ls", "sp", "ss", "its", "es", "settings", "ps", "gs", "ess", "sq", "fs", "sv", "sl", "is", "g", "actions", "b", "os", "sn", "set", "sg", "sys", "js", "scl", "hs", "ds", "ssl", "S", "c", "cs", "bs", "ns"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9805, "substitutes": {"env": ["buf", "engine", "dev", "extra", "cb", "conn", "eng", "ev", "enter", "v", "esc", "addr", "exec", "vr", "tp", "eni", "environment", "end", "pe", "nc", "ei", "esi", "era", "en", "code", "window", "shell", "org", "forge", "policy", "estate", "ew", "bar", "ve", "config", "server", "sv", "vt", "ov", "er", "enc", "viron", "expr", "te", "ec", "eu", "ah", "ext", "eas", "desc", "elt", "equ", "oe", "uv", "ten", "here", "manager", "txt", "gate", "eh", "Environment", "et", "nw", "rb", "console", "nv", "gear", "vs", "e", "vp", "erd"], "wi": ["ui", "qq", "yi", "wig", "wp", "WI", "hus", "gi", "wy", "wit", "Wi", "ei", "esi", "xi", "wiki", "phi", "wife", "iu", "fif", "wei", "wk", "wx", "ni", "pai", "feat", "isi", "bi", "ushi", "wl", "innie", "hi", "wm", "dim", "mie", "wine", "lis", "hog", "fi", "pie", "wid", "wa", "qi", "mi", "wu", "wik", "wen", "ti", "rw", "ye", "dit", "we", "wcs", "hip", "wic", "wal", "rus"]}}
{"project": "qemu", "commit_id": "477830727821e4bc337f4ac1fd222ffe0b900e1a", "target": 0, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret < 0) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    socket_set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, s);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n", "idx": 9817, "substitutes": {"s": ["r", "ts", "p", "self", "less", "sync", "h", "sb", "conf", "sw", "ses", "rs", "i", "v", "ls", "f", "sp", "qs", "ss", "syn", "es", "ps", "gs", "j", "sub", "comm", "sts", "http", "ex", "n", "sq", "o", "store", "sv", "fs", "sl", "is", "b", "a", "serv", "er", "g", "st", "bs", "soc", "os", "sd", "set", "scl", "js", "sys", "hs", "ds", "stats", "ssl", "m", "S", "c", "so", "t", "spec", "cs", "e", "ims", "se", "w", "socket", "sports", "conv", "ns"], "aio_req": ["aIO_requ", "aive_req", "aio_request", "aive___res", "aie_rec", "aive_res", "aive_err", "aioptreq", "aio___rr", "aIO_grab", "aio___resp", "aioptcmd", "aio____rec", "aio_res", "aiopterr", "aio_err", "aie_err", "aio_resp", "aive___resp", "aie_res", "aio____req", "aio2err", "aive___req", "aio_obj", "aio_requ", "aio_grab", "aio___request", "aio_rr", "aio2req", "aio2comp", "aio___req", "aio___res", "aio_urg", "aie_req", "aio_seq", "aive_cmd", "aio___comp", "aio_comp", "aie_urg", "aive_resp", "aio___seq", "aio____urg", "aio_rec", "aio2requ", "aive___requ", "aie_obj", "aio_cmd", "aio___err", "aive_requ", "aio___rec", "aIO_req", "aioptrequ", "aIO_request", "aio____err", "aio___urg", "aio___requ"], "iov": ["ovi", "ih", "wo", "vr", "iq", "version", "ef", "nc", "uart", "uns", "uf", "ilo", "cv", "icon", "ov", "ival", "oo", "iv", "ux", "vec", "uv", "isco", "io", "river", "xff", "ucc", "wcs", "conv"], "niov": ["iiob", "niom", "nuovi", "niob", "iiovi", "tiov", "tiob", "iiom", "niovi", "nuov", "nuob", "tiovi", "iiov", "tiom", "nuom"], "create": ["equal", "write", "send", "update", "Create", "cre", "build", "insert", "save", "ise", "clear", "add", "code", "raise", "new", "only", "created", "destroy", "close", "ify", "change", "make", "complete", "execute", "ite", "creation", "copy", "one", "see", "late", "creator", "force", "activate", "drop", "enable", "ce", "open", "ize", "ure", "check", "ulate", "creat", "delete", "use", "ready"], "aiocb_type": ["aiocb__TYPE", "aiocb_state", "aiocb_TYPE", "aiocrb_type", "aiocrb_ype", "aiocrbamtype", "aiocB_style", "aiocB_typ", "aiocrbamype", "aiocbamype", "aiocb_ype", "aiocB_Type", "aiocbamstate", "aiocb__state", "aiocrbamstate", "aiocb_typ", "aiocb__ype", "aiocb_Type", "aiocbamtype", "aiocbamTYPE", "aiocB_type", "aiocb__type", "aiocb_style", "aiocrb_state", "aiocrb_TYPE", "aiocrbamTYPE"], "hdr": ["phcmd", " hdef", " hdel", " hadr", "Husr", "hDR", "Hder", "ohrr", "hhll", "ihstr", "hll", "phstr", " hder", "Hll", "hhr", "shheader", "hmdr", "haddr", "held", "hadr", "Hadr", "ohder", "heDR", " hfr", "hld", "ihdr", "hemsg", "ohfr", "Hdr", "ohll", "husr", "hrd", "Hheader", "Hdel", "hmsg", "phmsg", "hbr", "Hstr", "phaddr", "hheader", "HDR", "ohDR", "Hvr", "ohheader", "hpr", "historyusr", " hcmd", " hheader", " hrr", "shstr", "hmpr", "hmrd", "historyDR", "httpdr", "historydr", "shdr", "ohdr", "hr", " hstr", "hpar", "thvr", "ihheader", "phbr", "phdef", "ohstr", "Hmsg", "phDR", " hpr", "Hpar", "Hbr", "ihpar", "hedr", "Hld", "hdel", "hstr", "headr", "ohr", "hdef", "phdr", " husr", " hr", "hmcmd", "thdr", "phheader", "Hr", "historydel", "hrr", "hebr", "httprd", "hcmd", "hmpar", " haddr", "thDR", " hDR", "httpheader", "hder", "heheader", " hrd", "hhdr", "httppr", " hbr", "Hrr", "thbr", " hpar", " hvr", "phpar", "hfr", " hld", "ohaddr", "hmheader", "shpar", " hmsg", "hhDR", "hvr", "hmdef", "phrr", "phfr"], "wlen": ["hlen", " wdl", " wlength", "waitlr", " welt", "whll", " wls", "waitlen", "hwlen", "wlength", "wln", "Wls", "hlength", "wLen", "wtll", " wln", "wcompl", "swln", "Wlen", " wlr", "waitdl", "whelt", " wll", "hwlr", "hLen", "swlen", " wcompl", "wls", "hln", "swlength", " wfun", "hwcompl", "wlr", "WLen", " wLen", "whcompl", "wtlen", "waitcompl", "hls", "wtelt", "wtcompl", "hfun", "swfun", "whlen", "hwdl", "Wlength", "welt", "wfun", "wll", "wdl"], "ret": ["vals", "RET", "off", "final", "rs", "rev", "trust", "success", "fee", "ef", "uns", "Ret", "val", "nt", "rets", "ext", "os", "af", "ref", "et", "status", "res", " af", "alt", "cmd"]}}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_write_packet(AVFormatContext *s, int stream_index,\n\n                            UINT8 *buf, int size)\n\n{\n\n    VideoData *img = s->priv_data;\n\n    AVStream *st = s->streams[stream_index];\n\n    ByteIOContext pb1, *pb;\n\n    AVPicture picture;\n\n    int width, height, ret, size1;\n\n    char filename[1024];\n\n\n\n    width = st->codec.width;\n\n    height = st->codec.height;\n\n\n\n    switch(st->codec.pix_fmt) {\n\n    case PIX_FMT_YUV420P:\n\n        size1 = (width * height * 3) / 2;\n\n        if (size != size1)\n\n            return -EIO;\n\n        \n\n        picture.data[0] = buf;\n\n        picture.data[1] = picture.data[0] + width * height;\n\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n\n        picture.linesize[0] = width;\n\n        picture.linesize[1] = width >> 1; \n\n        picture.linesize[2] = width >> 1;\n\n        break;\n\n    case PIX_FMT_RGB24:\n\n        size1 = (width * height * 3);\n\n        if (size != size1)\n\n            return -EIO;\n\n        picture.data[0] = buf;\n\n        picture.linesize[0] = width * 3;\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (get_frame_filename(filename, sizeof(filename), \n\n                           img->path, img->img_number) < 0)\n\n        return -EIO;\n\n\n\n    if (!img->is_pipe) {\n\n        pb = &pb1;\n\n        if (url_fopen(pb, filename, URL_WRONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        pb = &s->pb;\n\n    }\n\n    switch(img->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_save(&picture, width, height, pb, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_save(&picture, width, height, pb, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_save(&picture, width, height, filename);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_save(&picture, width, height, pb);\n\n        break;\n\n    }\n\n    if (!img->is_pipe) {\n\n        url_fclose(pb);\n\n    }\n\n\n\n    img->img_number++;\n\n    return 0;\n\n}\n", "idx": 9842, "substitutes": {"s": ["r", "ts", "p", "h", "sb", "conf", "ats", "rs", "i", "v", "ls", "f", "sh", "sp", "ss", "l", "ps", "gs", "j", "aws", "sts", "n", "sq", "sm", "fs", "a", "sv", "is", "b", "as", "g", "src", "ins", "os", "set", "sg", "js", "q", "sys", "stats", "ds", "m", "c", "S", "t", "cs", "e", "spec", "ns"], "stream_index": ["stream__handle", "stream_num", "stream__number", "channel_handle", "channel_number", "channel_ind", "stream_ind", "stream_Index", "stream_number", "channel_index", "stream_key", "channel_Index", "channel_num", "stream_handle", "channel_key", "stream__index", "stream__num"], "buf": ["r", "p", "cb", "bf", "np", "seq", "mem", "paste", "cap", "err", "v", "read", "nb", "data", "cam", "cur", "bp", "result", "uf", "fb", "raw", "rc", "cv", "tmp", "begin", "buff", "b", "queue", "ref", "Buff", "ctx", "vec", "br", "wb", "buffer", "block", "rb", "batch", "bg", "pkg", "xff", "msg", "orig", "Buffer", "cmd"], "size": ["send", "IZE", "unit", "type", "loss", "sp", "number", "format", "fee", "name", "en", "ose", "small", "global", "share", "space", "count", " Size", "area", "file", "scale", "Size", "bytes", "dim", "shape", "empty", "set", "style", "max", "offset", "note", "ize", "c", "num", "len", "sum", "status", "fit", "message", "iz", "e", "w", "SIZE", "length", "storage", "scope"], "img": ["att", "p", "util", "av", "pic", "amp", "utm", "imp", "um", "html", "attr", "f", "gif", "v", "ng", "data", "cam", "gd", "imgur", "ob", "pg", "jpg", "emb", "am", "str", "uf", "j", "feat", "obj", "tmp", "upload", "src", "g", "inst", "mt", "png", "anim", " im", "dat", "ext", "gm", "imag", "info", "def", "aug", "og", "it", "m", "uv", "mp", "iam", "im", "animate", "pkg", "doc", "image"], "st": ["p", "step", "sta", "h", "list", "sw", "sty", "sh", "std", "sp", "ast", "ss", "z", "ste", "ct", "ST", "pt", "str", "start", "ust", "sim", "sts", "th", "ess", "sm", "sv", "sl", "St", "ost", "inst", "td", "ie", "d", "rest", "ch", "tr", "ut", "sam", "spect", "sn", "rt", "set", "style", "ctx", "so", "t", "stage", "sc", "est", "ist", "se", "lib"], "pb1": ["cb01", "pb2", "cb0", "jp0", "cb3", "p01", "p1", "jp1", "p0", "sb1", "p2", "pb01", "p3", "cb2", "sb3", "jp2", "pb3", "sb0", "sb2", "jp01", "cb1", "pb0"], "pb": ["pod", "p", "func", "pas", "cb", "pl", "sb", "snap", "np", "wp", "tc", "proc", "lp", "pp", "typ", "nb", "tp", "dp", "pg", "bp", "ob", "emb", "pt", "bj", "uf", "erb", "bb", "eb", "ub", "fb", "patch", "ib", "cv", "cp", "PB", "tmp", "pool", "conv", "buff", "b", "td", "pa", "mb", "tab", "sys", "pm", "ctx", "fp", "tg", "wb", "mp", "orp", "apa", "rb", "db", "resp", "ping", "pkg", "gc", "pc", "vp", "lb", "bs", "jp"], "picture": ["camera", "data", "imgur", "family", "database", "closure", "secure", "figure", "print", "history", "def", " pic", "description", "statement", "public", "comment", "private", "rule", "pict", "stat", "function", "jpg", "username", "like", "config", " profile", "join", "brush", "Picture", "definition", "path", "info", "attribute", "performance", "sequence", "bank", "power", " portrait", "before", "professional", "proof", "p", "pic", "library", "support", "frame", "pair", "import", "sharp", "person", "summary", " perspective", "photo", "video", "try", "iture", "pty", "style", "pen", "foreign", "associated", "pi", "knife", "profile", "error", "password", "feature", "whatever", "network", "media", "widget", "Pic", "query", "share", "policy", "peg", "remember", "feat", "file", "png", "details", "fortunately", "volume", "point", "important", "friendly", "image"], "height": ["instance", "rank", "type", "number", "data", "radius", "density", "capacity", "depth", "family", "through", "range", "total", "count", "history", "index", "def", "crop", "cy", "kw", "confidence", "square", "h", "huge", "build", "docker", "ows", "name", "angle", "shape", "hash", "buffer", "host", "SIZE", "resolution", "windows", "html", "xy", "padding", "command", "window", "th", "times", "y", "stroke", "style", "grow", "above", "chain", "alpha", "length", "Height", "password", "high", "bottom", "gravity", " heights", "ty", "png", "ch", "dim", "headers", "yt", "half", "volume", "hang", "quality", "image"], "ret": ["att", "limit", "pas", "cb", "RET", "mem", "ft", "rev", " Ret", "id", "url", "re", "result", "gt", "Ret", "dt", "val", "rem", "at", "rm", "summary", "out", "nl", "nt", "rets", "not", "back", "print", "mt", "ext", "try", "def", "desc", "elt", "rt", "tail", "full", "sys", "ref", "box", "body", "t", "len", "res", "status", "det", "resp", "ll", "alt", "aux", "Return", "gc", "arg", "rel"], "size1": ["SIZE0", "Size1", "size0", " size2", "size3", "scaleone", "scoreOne", "sizeOne", "zeroOne", "ize2", "Size_", "zero001", "sum3", "zero1", " size3", "size_", "SizeOne", "scale001", "size2", " size_", " size0", "SIZE2", " sizeone", "sizeone", "Size0", "ize1", "Size61", "size001", "score001", "score2", " size61", "score1", "scaleOne", "sum1", " size001", "size61", "SIZE1", "izeOne", "zero3", " sizeOne", "Size2", "SIZE_", "zeroone", "ize61", "sum001", "scale1", "Size001"], "filename": ["r", "ames", "np", "final", "Filename", "fil", "f", "v", "url", "folder", "name", "title", "jpg", "original", "result", "location", "username", "new", "fb", "n", "nm", "tmp", "src", "bh", "b", "fn", "prefix", "file", "png", "kl", "names", "path", "nil", "files", "fp", "ame", "txt", "text", "buffer", "bn", "FN", "pkg", "word", "w", "ename", "image", "length", "fw"], "img_number": ["img_no", "image_num", "imgnindex", "image_no", "img_index", "imgnno", "image_number", "image_index", "imgnnumber", "imgnnum", "img_num"]}}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n", "idx": 9845, "substitutes": {"mon": ["mm", "chron", "tem", "mons", "on", " man", "mat", "MON", "onet", "om", "dm", "dom", "hum", " monitor", "an", "admin", "mun", "monkey", "monitor", "mut", "met", "tim", "sam", "mir", "min", "mic", "m", "ann", "Mon", "mi", "mx", "den", "mont", "san", "mu", "man", "mn"], "qdict": [" qmap", "sqict", " qict", "dqdict", "qict", "qd", "dqd", " qd", "sqd", "dqict", "dqmap", "sqdict", "sqmap", "qmap"], "dinfo": [" dinformation", " dInfo", "drki", "lconf", "dconf", " dconf", "lInfo", "linf", "drinf", "linfo", "Dconf", "DInfo", "adinf", "adki", "drinformation", "Dinf", " dki", "dki", "drinfo", "dInfo", "adinfo", "dinformation", "dinf", "Dinfo", "adinformation", " dinf"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {\n\n  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;\n\n  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );\n\n  uint8_t *ysrc = src[0];\n\n  uint8_t *usrc = src[1];\n\n  uint8_t *vsrc = src[2];\n\n  const int width = c->srcW;\n\n  const int height = srcSliceH;\n\n  const int lumStride = srcStride[0];\n\n  const int chromStride = srcStride[1];\n\n  const int dstStride = dstStride_a[0];\n\n  const vector unsigned char yperm = vec_lvsl(0, ysrc);\n\n  const int vertLumPerChroma = 2;\n\n  register unsigned int y;\n\n\n\n  if(width&15){\n\n    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);\n\n    return srcSliceH;\n\n  }\n\n\n\n  /* this code assume:\n\n\n\n  1) dst is 16 bytes-aligned\n\n  2) dstStride is a multiple of 16\n\n  3) width is a multiple of 16\n\n  4) lum&chrom stride are multiple of 8\n\n  */\n\n\n\n  for(y=0; y<height; y++)\n\n    {\n\n      int i;\n\n      for (i = 0; i < width - 31; i+= 32) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_yA = vec_ld(i, ysrc);\n\n\tvector unsigned char v_yB = vec_ld(i + 16, ysrc);\n\n\tvector unsigned char v_yC = vec_ld(i + 32, ysrc);\n\n\tvector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);\n\n\tvector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);\n\n\tvector unsigned char v_uA = vec_ld(j, usrc);\n\n\tvector unsigned char v_uB = vec_ld(j + 16, usrc);\n\n\tvector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));\n\n\tvector unsigned char v_vA = vec_ld(j, vsrc);\n\n\tvector unsigned char v_vB = vec_ld(j + 16, vsrc);\n\n\tvector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_uv_b = vec_mergel(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);\n\n\tvector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n\tvec_st(v_yuy2_2, (i << 1) + 32, dst);\n\n\tvec_st(v_yuy2_3, (i << 1) + 48, dst);\n\n      }\n\n      if (i < width) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_y1 = vec_ld(i, ysrc);\n\n\tvector unsigned char v_u = vec_ld(j, usrc);\n\n\tvector unsigned char v_v = vec_ld(j, vsrc);\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n      }\n\n      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t{\n\n\t  usrc += chromStride;\n\n\t  vsrc += chromStride;\n\n\t}\n\n      ysrc += lumStride;\n\n      dst += dstStride;\n\n    }\n\n\n\n  return srcSliceH;\n\n}\n", "idx": 9846, "substitutes": {"c": ["p", "dc", "h", "cr", "co", "conf", "C", "tc", "cf", "f", "v", "cm", "cont", "fc", "bc", "ct", "lc", "cc", "rc", "cv", "cp", "a", "b", "g", "d", "cache", "s", "ch", "ec", "com", "ca", "ctx", "ce", "ci", "m", "mc", "t", "sc", "con", "cs", "e", "w", "ac"], "src": ["sync", "dist", "sb", "via", "sw", "bin", "split", "sur", "sh", "ser", "sup", "cur", "sp", "fc", "seed", "height", "trans", "usr", "sub", "supp", "rc", "sr", "slice", "in", "sq", "rl", "iter", "bh", "sl", "b", "tmp", "inst", "scale", "transform", "st", "ch", "tr", "nil", "iv", "hl", "sn", "sys", "sc", "source", "loc", "bg", "dest", "ctr", "comp", "sort", "ins"], "srcStride": ["srcStope", "srcSlride", "rcStrip", "rcStide", "srcSTride", "srcStri", "srcstide", "rcstride", "srcStrope", "rcStride", "srcRestrip", "sourceStrride", "srcSTro", "srcSlro", "srcStrro", "srcStro", "rcStri", "sourceStride", "rcstro", "srcRestide", "sourceStide", "sourceStro", "srcRestride", "srcSTrip", "srcStide", "sourceStrro", "rcStrri", "rcStrro", "srcStrip", "srcStrri", "srcstride", "sourceStope", "srcSlri", "srcstro", "rcStrride", "sourceStrope", "srcStrride", "srcRestro", "srcRestri", "rcstrip", "srcstrip", "rcStro", "srcSlide", "srcSlope", "rcstide", "srcSTide"], "srcSliceY": ["srcSLaceB", "srcSLiceY", "srcSLiceB", "srcSlaceY", "srcSLaceH", "srcSlideYY", "srcSLiceH", "srcSllicH", "srcSllicYY", "srcSLiceX", "srcSlideH", "srcSlideX", "srcSLaceY", "srcSllicY", "srcSllicB", "srcSlideY", "srcSliceB", "srcSlaceB", "srcSliceX", "srcSLaceX", "srcSliceYY", "srcSlaceX", "srcSlaceH", "srcSlideB"], "srcSliceH": ["srcSlgeh", "srcSluceH", "srcSlizeH", "srcSlgeHeight", "srcSlideW", "srcSlsliceH", "srcSliceW", "srcSliceh", "srcSluceHH", "srcSlideH", "srcSlizeY", "srcSliceHT", "srcSluceW", "srcSlideHH", "srcSlipW", "srcSliceHeight", "srcSlICEH", "srcSlgeH", "srcSlsliceHH", "srcSliceHH", "srcSlipH", "srcSlideY", "srcSlICEY", "srcSlsliceY", "srcSlICEHT", "srcSluceY", "srcSlizeB", "srcSliceB", "srcSlideHT", "srcSlICEB", "srcSlICEHeight", "srcSlipHT", "srcSlipY", "srcSluceB", "srcSlICEh", "srcSluceHT", "srcSlizeHT", "srcSlideB", "srcSlsliceB"], "dstParam": ["DstsPar", " dndConf", "ddestMode", "dndParam", "dstrParameter", " dndPar", "dndPar", "DstParam", "dstsParameter", "DstParameter", "DstsParam", " dstPar", "dstsPar", "dndConf", "destPar", " dndParameter", "dstsMode", "dndParameter", " dstConf", " dndParam", "dstMode", "dstrPar", "dstConf", "ddestParam", "DstsMode", " dstParameter", "drdParam", "DstMode", "dstsParam", "dstrParam", "dstPar", "destConf", "drdPar", "destParameter", "dstrMode", "dstParameter", "ddestPar", "DstsParameter", "destParam", "DstPar", "ddestParameter", "drdConf", "drdParameter"], "dstStride_a": ["dstStride_e", "dstStride_o", "dstStride_t", "dstStrip_o", "dstStride_b", "dstStide_e", "dstStri_b", "dstStide_t", "dstStride_A", "dstStide_a", "dstStri_a", "dstStri_t", "dstStide_b", "dstStri_A", "dstStrip_e", "dstStrip_a"], "dst": ["tdest", "sdot", "sdst", "dsdest", " dST", "ddest", "sst", "tst", "sddest", "dsrc", "dssrc", " dsrc", "dot", "tost", "sdest", " dot", "dsst", "dsot", "sST", "sdsrc", " dost", "dST", " ddest", "tST", "dost", "sost"], "ysrc": ["owsRC", "iessrc", "bysrt", "owsr", "ysrs", "mysrc", "insource", "ysack", "sysource", "iesrec", "iesrt", "yscack", "yssrc", "ysrec", "owsrc", "sysr", "iesack", "owsirc", "yssource", "myssrc", "iesirc", "iesrc", "ysrt", "ysource", "yscore", "iesusc", "yscusc", "yssRC", "ysrin", "insrc", "sysRC", "mysrt", "iesource", "iesRC", "owscore", "iesrin", "sysrin", "yscrc", "ynRC", "owsrec", "ysusc", "bysrc", "syscore", "ynrs", "sysirc", "yssusc", "yssrec", "ysirc", "insirc", "yssirc", "sysrs", "yscource", "ynrin", "ynrc", "iesr", "iesrs", "mysrs", "insRC", "iescore", "ysRC", "bysrs", "yssack", "ysr", "sysrc", "byssrc"], "usrc": ["osr", " usRC", "usource", "usarc", "ussrc", " ussrc", "cusirc", "sysource", " usrl", "usRC", "usesrs", "usrl", "tssrc", "usr", "usirc", "cussrc", "USsrc", "ausrl", "psrc", "usesrc", "osource", "USrc", "usrs", "pssrc", "cusr", "cusource", "usesrl", "tsarc", "tsRC", " usarc", "aussrc", "sysirc", "USource", "syssrc", "cusrc", "ossrc", "ausRC", "psr", "ausarc", "psource", " usrs", "usessrc", "tsrc", "ausrs", "USirc", "osrc", "sysrc", "ausrc"], "vsrc": ["qvsettings", "wsource", "vsettings", "Vsource", " vsource", "qvsrc", "vrc", " vsettings", "Vaddr", " vaddr", "wrc", " vcur", "qvsource", "vaddr", "waddr", "vsource", "Vcur", "Vrc", "Vsrc", " vrc", "Vsettings", "wsrc", "qvcur", "vcur"], "y": ["p", "ny", "ot", "h", "py", "ity", "yi", "ery", "ies", "xy", "html", "v", "vy", "dy", "wy", "z", "height", "j", "sky", "ys", "ey", "ty", "ady", "key", "iy", "o", "my", "b", "g", "yy", "ht", "ch", " Y", "axy", "Y", "ay", "yt", "ry", "ya", "ym", "m", "cy", "yout", "yl", "status", "sy", "aily", "row", "any", "ye", "w", "gy", "by"], "i": ["ui", "di", "p", "ami", "x", "h", "init", "v", "gi", "ri", "ic", "ai", "z", "id", "iq", "ind", "ii", "l", "j", "xi", "ji", "I", "ei", "ix", "iu", "oi", "ex", "multi", "u", "bi", "n", "origin", "o", "in", "a", "b", "is", "hi", "si", "index", "try", "li", "info", "ini", "it", "ia", "ci", "m", "this", "t", "mi", "ij", "qi", "zi", "ip", "ti", "point", "im", "pi", "e"]}}
{"project": "qemu", "commit_id": "338c858c946017cd3ec8c2be06d817e001d94bc3", "target": 0, "func": "void cpu_loop(CPUAlphaState *env)\n\n{\n\n    CPUState *cs = CPU(alpha_env_get_cpu(env));\n\n    int trapnr;\n\n    target_siginfo_t info;\n\n    abi_long sysret;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_alpha_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        /* All of the traps imply a transition through PALcode, which\n\n           implies an REI instruction has been executed.  Which means\n\n           that the intr_flag should be cleared.  */\n\n        env->intr_flag = 0;\n\n\n\n        switch (trapnr) {\n\n        case EXCP_RESET:\n\n            fprintf(stderr, \"Reset requested. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MCHK:\n\n            fprintf(stderr, \"Machine check exception. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_SMP_INTERRUPT:\n\n        case EXCP_CLK_INTERRUPT:\n\n        case EXCP_DEV_INTERRUPT:\n\n            fprintf(stderr, \"External interrupt. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MMFAULT:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID\n\n                            ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR);\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_UNALIGN:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGBUS;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_BUS_ADRALN;\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_OPCDEC:\n\n        do_sigill:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_ILLOPC;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_ARITH:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGFPE;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_FPE_FLTINV;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_FEN:\n\n            /* No-op.  Linux simply re-enables the FPU.  */\n\n            break;\n\n        case EXCP_CALL_PAL:\n\n            env->lock_addr = -1;\n\n            switch (env->error_code) {\n\n            case 0x80:\n\n                /* BPT */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x81:\n\n                /* BUGCHK */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x83:\n\n                /* CALLSYS */\n\n                trapnr = env->ir[IR_V0];\n\n                sysret = do_syscall(env, trapnr,\n\n                                    env->ir[IR_A0], env->ir[IR_A1],\n\n                                    env->ir[IR_A2], env->ir[IR_A3],\n\n                                    env->ir[IR_A4], env->ir[IR_A5],\n\n                                    0, 0);\n\n                if (trapnr == TARGET_NR_sigreturn\n\n                    || trapnr == TARGET_NR_rt_sigreturn) {\n\n                    break;\n\n                }\n\n                /* Syscall writes 0 to V0 to bypass error check, similar\n\n                   to how this is handled internal to Linux kernel.\n\n                   (Ab)use trapnr temporarily as boolean indicating error.  */\n\n                trapnr = (env->ir[IR_V0] != 0 && sysret < 0);\n\n                env->ir[IR_V0] = (trapnr ? -sysret : sysret);\n\n                env->ir[IR_A3] = trapnr;\n\n                break;\n\n            case 0x86:\n\n                /* IMB */\n\n                /* ??? We can probably elide the code using page_unprotect\n\n                   that is checking for self-modifying code.  Instead we\n\n                   could simply call tb_flush here.  Until we work out the\n\n                   changes required to turn off the extra write protection,\n\n                   this can be a no-op.  */\n\n                break;\n\n            case 0x9E:\n\n                /* RDUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0x9F:\n\n                /* WRUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0xAA:\n\n                /* GENTRAP */\n\n                info.si_signo = TARGET_SIGFPE;\n\n                switch (env->ir[IR_A0]) {\n\n                case TARGET_GEN_INTOVF:\n\n                    info.si_code = TARGET_FPE_INTOVF;\n\n                    break;\n\n                case TARGET_GEN_INTDIV:\n\n                    info.si_code = TARGET_FPE_INTDIV;\n\n                    break;\n\n                case TARGET_GEN_FLTOVF:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case TARGET_GEN_FLTUND:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case TARGET_GEN_FLTINV:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case TARGET_GEN_FLTINE:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case TARGET_GEN_ROPRAND:\n\n                    info.si_code = 0;\n\n                    break;\n\n                default:\n\n                    info.si_signo = TARGET_SIGTRAP;\n\n                    info.si_code = 0;\n\n                    break;\n\n                }\n\n                info.si_errno = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            default:\n\n                goto do_sigill;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (info.si_signo) {\n\n                env->lock_addr = -1;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_STL_C:\n\n        case EXCP_STQ_C:\n\n            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 9864, "substitutes": {"env": ["inv", "ev", "err", "en", "vm", "worker", "qt", "buf", "sv", "vv", "er", "te", "cache", "eu", "js", "manager", "outer", "db", "timer", "door", "vp", "cmd", "ent", "conf", "enter", "esc", "addr", "pe", "shell", "org", "estate", "ve", "ew", "obj", "config", "vt", "ja", "enc", "ah", "eas", "desc", "dn", "ds", "et", "sc", "anc", "vs", "scope", "init", "pres", "conn", "actor", "environment", "entry", "era", "window", "server", "viron", "ctx", "here", "nv", "e", "doc", "erd", "engine", "dev", "cb", "die", "eng", "v", "usr", "query", "origin", "cv", "event", "esp", "ner", "ec", "term", "box", "console", "Environment", "context", "ener"], "cs": ["ts", "cus", "tc", "cf", "rs", "ls", "ck", "ces", "ss", "fc", " cis", "cks", "ps", "gs", "acs", "ys", "ix", "sts", "cc", "rc", "cv", "cp", "CS", "fs", "ec", "s", "ms", "css", "sys", "js", "ctx", "hs", "ds", "c", "sc", "Cs", "vs", "pc", "gc", "wcs", "vc", "bs", "qs", "ns"], "trapnr": ["dropNR", " trapnor", "tapnb", "dropnr", "testNR", "tapno", " trapr", " trapNR", "tapr", "rrNR", "dropnb", "wrapnr", " trapnb", "wrapnb", "trapNR", "testnr", "testnb", " trapno", "trapno", "rrnb", "testno", "trapnor", "tapNR", "trapnb", "tapnr", "wrapnor", "dropr", "rrnor", "trapr", "wrapNR", "rrnr"], "info": ["update", "no", "tag", "type", "json", "pack", "data", "fo", " Info", "history", "index", "cache", "def", "to", "ref", "now", "about", "ti", "kw", "sort", "conf", "comment", "value", "addr", "stat", "settings", "name", "auth", "dict", "good", "http", "notice", "help", "config", "one", "tx", "desc", "note", "trace", "it", "txt", "utils", "inf", "status", "inner", "action", "by", "init", "ote", "off", "xy", "id", "frame", "entry", "Info", "summary", "time", "iter", "diff", "try", "unknown", "user", "fi", "ci", "alias", "doc", "error", "list", "f", "rec", "reason", "query", "debug", "admin", "si", "details", "information", "check", "base", "image", "INFO"], "sysret": ["ysresult", "procret", "procRet", "sysRet", "ysRet", "procarg", "sysarg", "ysret", "ysarg", "sysresult", " sysarg", "procresult", " sysresult", " sysRet"]}}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (!target) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(pbdev->target, target)) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 9870, "substitutes": {"target": ["select", "selected", "cmd", "arget", "tag", "type", "v", "enabled", "test", "success", "primary", "output", "format", "native", "version", "name", "title", "command", "trap", "ARGET", "gt", "stop", "root", "expected", "available", "debug", "Target", "component", "device", "label", "null", "host", "specified", "remote", "event", "pointer", "arg", "that", "transform", "match", "required", "field", "path", "nil", "term", "handle", "to", "hash", "project", "trace", "supported", "blank", "focus", "bolt", "t", "this", "buffer", "alias", "true", "source", "normal", "base", "table", "valid", "dest", "template", "state", "address", "length", "scope", "peer"], "i": ["ui", "di", " pi", "cli", "x", "init", " multi", " wi", "span", " ti", " m", "gi", "ri", "ic", "ai", "fi", "z", " ii", " index", "iq", "ind", "ei", "ii", "xi", " iter", "sim", "I", "ji", "phi", "j", "ix", "iu", " mi", "multi", "bi", " I", "in", "me", "n", "iter", "hi", "si", "index", " my", " bi", "li", "ini", " li", "y", " err", "it", " ni", "m", "ci", "\u0438", " di", "qi", "zi", "mi", "ij", " j", "batch", "ti", "im", "asi", "pi", "e", "ki", "ims", "ori", " si", "us"], "pbdev": ["cbval", "PBdev", "pbdevice", "tpDEV", "ppDev", "fbserv", "bpgu", "bpserv", "pbgu", "ppDEV", "pbDEV", "bjdev", "ebDEV", "PBdec", "ebDev", "cbev", "bpcmd", "cbcmd", "ppdev", "tpdevice", "PBev", "bpdevice", "bpdev", "fbdev", "pbval", "PBgu", "sbdev", "ebconn", "PBdevice", "pbdec", "bjconn", "PBDev", "sbDEV", "ppdec", "sbDev", "pbconn", "tpdev", "pbev", "cbDev", "sbval", "ppval", "PBDEV", "pbcmd", "pbDev", "sbdevice", "sbev", "pbserv", "ebev", "fbdevice", "bpev", "bjDev", "PBconn", "fbgu", "PBserv", "bjdevice", "tpdec", "ebdevice", "cbdev", "PBcmd", "ppdevice", "cbdevice", "ebdev"], "s": ["self", "ts", "p", "r", "session", "less", "h", "ses", "rs", "v", "ss", "syn", "es", "ps", "gs", "sts", "n", "sq", "sm", "store", "south", "sv", "fs", "is", "b", "bs", "local", "set", "js", "hs", "stats", "ssl", "S", "c", "t", "se", "ns"]}}
{"project": "FFmpeg", "commit_id": "c95fefa0420be9cc0f09a95041acf11114aaacd0", "target": 0, "func": "static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n\n{\n\n    uint16_t cmd;\n\n    int i, sz, offset, code;\n\n    unsigned char *dst_end = dst + dst_size;\n\n    const unsigned char *src_end = src + src_size;\n\n\n\n    while (src < src_end && dst < dst_end) {\n\n        code = *src++;\n\n        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {\n\n            if (code & (1 << i)) {\n\n                *dst++ = *src++;\n\n            } else {\n\n                cmd = AV_RL16(src); src += 2;\n\n                offset = cmd >> 4;\n\n                sz = (cmd & 0xF) + 2;\n\n                /* don't use memcpy/memmove here as the decoding routine (ab)uses */\n\n                /* buffer overlappings to repeat bytes in the destination */\n\n                sz = FFMIN(sz, dst_end - dst);\n\n                while (sz--) {\n\n                    *dst = *(dst - offset - 1);\n\n                    ++dst;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9896, "substitutes": {"src": ["sb", "sur", "url", "ind", "ix", "rc", "urg", "sys", "stock", "source", "loc", "rb", "pkg", "ptr", "rel", "ins", "sync", "via", "attr", "addr", "cont", "ser", "stat", "raw", "sq", "config", "ctl", "obj", "sl", "nil", "hl", "desc", "rt", "req", "txt", "sc", "aux", "sub", "ack", "init", "seq", "imp", "sel", "cur", "str", "start", "rob", "inc", "sr", "tmp", "iter", "sec", "st", "copy", "sn", "input", "cmp", "RC", "ctr", "comp", "func", "proc", "rs", "syn", "tp", "bc", "rec", "usr", "cc", "rl", "inst", "lit", "iv", "gb", "usc", "dest", "ipl", "bs", "img"], "src_size": ["st_name", "st_size", "src_range", "st_range", "src_len", "src_scope", "src_name", "st_len", "st_scope", "src_SIZE", "st_SIZE"], "dst": ["Dct", "sest", "dslt", " dest", "ddest", "dobj", "dsnd", "ddtd", "dnd", "dstd", " dnd", "didpend", "dupt", "fct", "Dnd", "diddest", "duct", "Dsts", "dpend", "dult", "didst", "dost", " dtd", "snd", "sst", "dust", "delst", "idst", "Dest", "gput", "dusts", "dutd", "idnd", "fnd", "sct", "lput", "dsts", "idost", "desst", "ddobj", " Dsts", "gobj", "dsct", "dtd", "fst", "desct", "Dpt", "dsest", "gtd", "lst", " Dnd", " dct", "dsst", "dlt", " Dst", "lobj", "Dpend", "ddput", "didest", "dct", " ddest", "desdest", "ddst", "delest", "idsts", " Dost", "delsts", "dsdest", "ssts", "desnd", " dpend", "Dst", " dlt", "duest", "dpt", "delpt", "fest", "gst", "dput", "ltd", " dost", "dest", "Ddest", " dsts"], "dst_size": ["dst8scale", "dst0start", "dnd_scale", "dst_scale", "dst0name", "dst0size", "dset_name", "dst_start", "dset0name", "dset_start", "dnd_size", "dset0start", "dst0sum", "dst_name", "dnd_Size", "dset0size", "dnd_end", "dset_size", "dset0sum", "dst8size", "dset_sum", "dst8end", "dst_sum", "dst_Size", "dst8Size"], "cmd": ["cli", "cr", "cb", "opt", "init", "MD", "cf", "xy", "cat", "attr", "cont", "ck", "cur", "cfg", "command", "ct", "cd", "qt", "rc", "ect", "config", "nt", "cp", "ctl", "obj", "buff", "md", "Cmd", "ch", "mk", "ext", "def", "cmp", "control", "ctx", "awk", "kind", "ctrl", "req", "c", "text", "check", "cod", "kt", "pkg", "cut", "ctr", "comp", "msg"], "i": ["ui", "di", "p", "x", "v", "k", "id", "ai", "z", "ic", " ii", "iq", "ind", "l", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", "multi", "u", "bi", "n", "o", "is", "ie", "b", "si", "index", "s", "li", "info", "y", "ini", "fi", "it", "\u0438", "ci", "m", "io", "c", "qi", "zi", "mi", "ip", " j", "ij", "batch", "ti", "t", "im", "asi", "pi", "me", "ish"], "sz": ["jsq", "suz", "szi", "agszi", " sq", "agsz", " szi", "idsiz", "jszi", "alsld", "idszi", "dszek", "jsz", "Sz", "jsuz", " szek", "Szi", "alsiz", "alszi", "Sq", "dsq", "bitsz", "alsz", " siz", "idszek", " sld", "Sld", "bitsiz", "sq", "Siz", "dszi", "jsiz", "bitszi", " suz", "sld", "dsiz", "bitszek", "idsz", "dsz", "siz", "Szek", "agszek", "agsiz", "szek", "Suz"], "offset": ["ui", "skip", "ot", "init", "off", "timeout", "oint", "slot", "attr", "iso", "addr", "id", "output", "end", "location", "pad", "start", "window", "scroll", "position", "shift", "align", "order", "out", "origin", "o", "obj", "size", "item", "seek", "bound", "count", "prefix", "pointer", "index", "info", "aff", "set", "ref", "reset", "trace", "Offset", "pos", "et", "len", "loc", "alt", "rot", "ptr", "address", "sort", "delay", "error"], "code": ["cycle", "ack", "ode", "x", "co", "codes", "comment", "xy", "type", "cont", "test", "coe", "id", "data", "name", "ct", "command", "cd", "str", "map", "content", "cc", "rc", "close", "config", "obj", "count", "tmp", "ch", "copy", "info", "bit", "go", "xxx", "Code", "control", "ce", "c", "text", "check", "cod", "body", "status", "source", "mode", "msg", "magic", "comp", "xx", "error"], "dst_end": ["dst_env", "dst___begin", "dest_all", "dst_len", "dst__all", "dnd_start", "dct_name", "dnd_last", "dct_last", "dst__env", "dst_iter", "dest_start", "dot_size", "dst__start", "dest_end", "dst__end", "dst_all", "dest_env", "dst___last", "dst___size", "dst_name", "dot_iter", "dst___iter", "dct_begin", "dot_end", "dst_start", "dct_end", "dnd_len", "dst_last", "dst___name", "dnd_end", "dst___end", "dst_begin"], "src_end": ["src00edge", "rc_start", "rc_off", "rc_origin", "src_start", "srcLenEND", "src00head", "rc_end", "src00end", "rc_END", "srcLenend", "src_off", "srcLenorigin", "src00start", "src_END", "src_head", "src_origin", " src_head", " src_start", "src_edge", "srcLenstart", " src_edge"]}}
{"project": "FFmpeg", "commit_id": "84f0aba18dc8815c5cd408238909e4dc8b60684f", "target": 1, "func": "ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,\n\n                  void *priv_data, RTPDynamicProtocolHandler *handler)\n\n{\n\n    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->ic = ic;\n\n    s->streams = &ic->streams[first_stream_of_set_idx];\n\n    do {\n\n        s->n_streams++;\n\n    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&\n\n             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);\n\n    s->prev_set_id    = -1;\n\n    s->prev_stream_id = -1;\n\n    s->prev_timestamp = -1;\n\n    s->parse_packet = handler->parse_packet;\n\n    s->dynamic_protocol_context = priv_data;\n\n\n\n    return s;\n\n}\n", "idx": 9913, "substitutes": {"s": ["changes", "sb", "ses", "ls", "ears", "aws", "comm", "sm", "sv", "has", "js", "sys", "c", "t", "ags", "se", "ms", "w", "ids", "ins", "ns", "less", "h", "ats", "sw", "his", "ies", "qs", "ows", "ps", "acs", "terms", "parts", "ess", "sq", "obj", "fs", "a", "sl", "sd", "set", "scl", "sg", "stats", "ds", "comments", "sc", "services", "vs", "cs", "ims", "gets", "ports", "p", "i", "its", "l", "ops", "is", "b", "g", "reads", "eps", "os", "sn", "hs", "so", "ares", "results", "gc", "conv", "self", "ts", "rs", "v", "args", "ss", "es", "als", "uploads", "gs", "j", "tags", "sts", "n", "plays", "details", "pers", "states", "S", "bs", "sports", "ants"], "n_streams": ["n_streamers", "n_streamats", "n_Streams", "n__streams", "ngrfollowers", "n_trs", "ngrstreamS", "n_threadS", "n_hostd", "ngrfollows", "n_columns", "n_columnd", "n_pathds", "n_pathats", "n_streamds", "n__streami", "n__streamd", "ngrfollowls", "n_streami", "n_threads", "n_followS", "n_trls", "n_follows", "ngrstreams", "ngrstreamers", "n__hosti", "n_streamries", "n__streamats", "n_pathries", "n_paths", "n_StreamS", "n_hosti", "n_Streamds", "n_poolries", "n__hostd", "n_poolds", "n_pathS", "n_streamls", "ngrstreamls", "n_streamd", "n_pools", "n_Streamries", "n_trS", "ngrfollowS", "n_hostats", "n_hosts", "n__hostats", "n_threadls", "n_pathi", "n_columni", "n_threaders", "n_columnats", "n__hosts", "n_followls", "n_trers", "n_poolS", "n_pathd", "n_streamS", "n_followers"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    QCowL2Meta l2meta;\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    l2meta.nb_clusters = 0;\n\n    qemu_co_queue_init(&l2meta.dependent_requests);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        cluster_offset = l2meta.cluster_offset;\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buffer(&hd_qiov, cluster_data);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_link_l2(bs, &l2meta);\n\n\n\n        run_dependent_requests(s, &l2meta);\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 9922, "substitutes": {"bs": ["ts", "fps", "sb", "blog", "ses", "rs", "aos", "outs", "bos", "ls", "BS", "ss", "its", "obs", "bc", "bp", "gs", "ubs", "fs", "bh", "bt", "b", "lbs", "os", "ms", "bis", "js", "sys", "bes", "hs", "ds", "ubis", "bits", "bps", "aus", "vs", "cs", "lb", "bm", "qs", "ns"], "sector_num": ["sector_orig", "sector_nm", "sector2mon", "sector2num", "driver_num", " sector_nm", "driver_nb", "sector_mon", "sector_family", "ector_number", "sector_NUM", "ector_mon", "sectorNamemon", " sector_NUM", "ector_orig", "sectoripcon", " sector_number", "sectorNamenb", "sector2nm", "sectoripfamily", "driver_con", "sectorNamenumber", "sectoripnb", "sectorNamenum", "sector2NUM", "sector_nb", "sector2number", "sectorNamefamily", "sector2orig", "sectoripnum", "driver_family", "sectorNamecon", "sector_number", "sectorNameorig", "sector_con", "ector_num"], "remaining_sectors": ["remaining_severs", "remaining_perseors", "remaining_psectors", "remaining_vevisors", "remaining_vectors", "remaining_suors", "remaining_speors", "remaining_sors", "remaining_sgments", "remaining_svisors", "remaining_velements", "remaining_pselements", "remaining_veonents", "remaining_weors", "remaining_pellers", "remaining_spevers", "remaining_spellers", "remaining_selements", "remaining_sellers", "remaining_wectors", "remaining_persegments", "remaining_segments", "remaining_pevers", "remaining_suctors", "remaining_pseors", "remaining_veors", "remaining_sevisors", "remaining_sctors", "remaining_peors", "remaining_spectors", "remaining_sullers", "remaining_weonents", "remaining_suvers", "remaining_seonents", "remaining_seors", "remaining_vegments", "remaining_pectors", "remaining_persevisors", "remaining_persectors", "remaining_welements", "remaining_pseonents"], "qiov": ["ckiop", " qveh", "iqrolet", "quiov", "kiour", "iqiov", "kiov", "ckiv", "qveh", "quiev", "qurolet", "quiop", "quiour", "quveh", "qqiev", "iqiop", " qrolet", "qiour", "qiop", "ckiov", "qiv", "sqiov", "sqrolet", "qrolet", "sqiev", "kveh", "sqiop", " qiop", "qiev", "ckrolet", "quiv", "qqiov", "qqiop", "iqiv", "qqrolet", " qiev", " qiour", "kiev"], "s": ["changes", "sb", "sets", "ses", "ls", "aws", "comm", "abilities", "sv", "as", "sam", "has", "bis", "js", "sys", "bes", "c", "t", "series", "ms", "w", "ns", "less", "h", "ats", "conf", "qs", "settings", "ps", "parts", "sq", "fs", "a", "sl", "set", "stats", "ds", "ssl", "services", "vs", "cs", "ims", "p", "i", "sp", "its", "is", "b", "g", "eps", "os", "sn", "hs", "so", "ares", "ts", "rs", "v", "args", "ss", "es", "als", "gs", "j", "tags", "sts", "details", "m", "S", "bits", "spec", "sports"], "index_in_cluster": ["index_in_acluster", "index_in_glusters", "index_in_plusters", "index_in_plorum", "index_in_glust", "index_in_Closer", "index_in_plause", "index_in_Clause", "index_in_scust", "index_in_clust", "index_in_aclusters", "index_in_clusters", "index_in_Clusters", "index_in_scoser", "index_in_clorum", "index_in_aclorum", "index_in_pluster", "index_in_clause", "index_in_closer", "index_in_gluster", "index_in_Clust", "index_in_scuster", "index_in_ploser", "index_in_aclause", "index_in_Clorum", "index_in_Cluster", "index_in_aclust", "index_in_acloser", "index_in_scusters", "index_in_plust", "index_in_gloser"], "n_end": ["nm___conn", "N_length", "n_pad", "n__ended", "n_length", "nm_end", "newconn", "n_min", "n_ended", "nm___pad", "n__nd", "nn_ends", " n_ended", "N_END", "n___pad", "nn_end", "n_conn", "N_until", "newend", " n_nd", "n_ends", "n_offset", "n_until", "n__end", "newpad", "n_nd", "N_next", "n_next", "n___end", "nm___end", "n_END", "N_end", "n___conn", "nn_offset", "N_min", "nm_pad", "nm_conn"], "ret": ["flag", "RET", "mel", "ft", "mem", "rev", "job", "cont", "success", "re", "tech", "gt", "Ret", " RET", "tt", "deg", "val", "ert", "rm", "out", "lt", "nt", "rets", "quad", "print", "mt", "virtual", "def", "tr", "lit", "try", "ext", "encrypted", "elt", "rt", "ref", "reset", "del", "it", "t", "len", "res", "cert", "status", "ll", "alt", "Return", "ctr", "ptr", "terror", "nz", "jp", "cmd"], "cur_nr_sectors": ["cur_nr_SEors", "cur_nr_spegments", "cur_nr_speors", "cur_nr_vectors", "cur_nr_secs", "cur_nr_pegments", "cur_nr_mections", "cur_nr_mectors", "cur_nr_sections", "cur_nr_pectors", "cur_nr_pellers", "cur_nr_segments", "cur_nr_SEctors", "cur_nr_sekers", "cur_nr_vekers", "cur_nr_peors", "cur_nr_shkers", "cur_nr_vellers", "cur_nr_vegments", "cur_nr_pecs", "cur_nr_seors", "cur_nr_pekers", "cur_nr_sellers", "cur_nr_spectors", "cur_nr_spections", "cur_nr_shllers", "cur_nr_SEcs", "cur_nr_megments", "cur_nr_vections", "cur_nr_meors", "cur_nr_veors", "cur_nr_vecs", "cur_nr_shors", "cur_nr_shctors", "cur_nr_SEgments"], "l2meta": ["l5meta", "l_metadata", "L2meta", "fl2met", "l5met", "l2met", " l3meta", "fl5eta", "l3Meta", "l6mu", "l42metadata", " l3Meta", " l_mu", " l_meta", "l4perm", "l42meta", " l2mu", "L2Meta", "l42perm", "l3meta", "l4metadata", "fl2eta", "l6met", " l3options", "l22options", "l2options", " l2metadata", "L3metadata", "l2metadata", "l3options", "l4dirty", "l42Meta", " l2options", "l3perm", " l2Meta", " l_eta", "l3metadata", "l22Meta", "l_mu", "l3eta", "l5mu", "l5eta", "l2perm", "fl5metadata", "fl5met", "l5metadata", "l6eta", "l6meta", "l_options", " l4Meta", "l22metadata", " l_metadata", " l4metadata", " l2eta", "L3meta", "l_Meta", "fl2meta", "l22meta", "L3perm", " l4dirty", "l6metadata", " l2dirty", "l2dirty", "l2eta", "l_eta", "l3dirty", "l2Meta", " l3metadata", "fl5meta", " l4meta", "L2perm", "l4meta", "L2metadata", "l2mu", "l3met", "fl2metadata", "l4Meta", "L3Meta", "l_meta"], "cluster_offset": ["cluster_count", "clluster_offset", "cluster_error", "clluster_size", "clluster___position", "cluster_cache", "cluster_position", "cluster___count", "cluster_style", "clust_start", "cluster67off", "cluster67position", "cluster2position", "clluster_ptr", "clluster___off", "cluster___size", "cluster2size", "cluster___offset", "clusterableoffset", "clusters_key", "clust_offset", "cluster_ptr", "clusters_cache", "cluster2count", "clusters_offset", "clluster___ptr", "cluster2offset", "cluster_key", "cluster___position", "clusters_size", "clluster___offset", "cluster_start", "cluster___key", "clusterablekey", "clust_style", "cluster67ptr", "cluster_size", "cluster___off", "clusterablesize", "clluster_off", "cluster67offset", "cluster___ptr", "clluster_position", "clust_error", "cluster_off", "clluster_count", "clusterablecache", "cluster___cache"], "hd_qiov": ["hd_quiv", "hd___quovi", "hd_quiev", "hd_quversive", "hd_ckiv", "hd_qdyl", "hd_qovi", "hd_qurolet", "hd_sqiov", "hd_aqovi", "hd_giov", "hd_aqiov", "hd_eqiov", "hd_kiour", "hd___qiour", "hd___kiour", "hd_iqiv", "hd_qiev", "hd_kiov", "hd_iqiev", "hd___qiv", "hd_kiev", "hd_giour", "hd_qiour", "hd_ckovi", "hd_eqversive", "hd___qiov", "hd___qiev", "hd_quiov", "hd_quovi", "hd_eqovi", "hd_kovo", "hd___quiev", "hd_iqiov", "hd_iqiour", "hd_qiv", "hd___quiv", "hd___quiov", "hd_kiv", "hd___qovo", "hd_iqovo", "hd_aqversive", "hd_iqovi", "hd_govo", "hd_aqiev", "hd___qovi", "hd_sqrolet", "hd_qudyl", "hd___kiov", "hd_kdyl", "hd_qrolet", "hd_krolet", "hd_qversive", "hd___kiv", "hd_qovo", "hd_eqiev", "hd_sqdyl", "hd_ckiov", "hd_ckiev", "hd___kovo", "hd_giv", "hd_sqiev"], "cluster_data": ["cluster2data", "clusters_step", "cluster_next", "cluster_supported", "clructureistnext", "cluster2cache", "clusters_data", "cluster____cache", "cluster_cache", "clusterablenext", "clructure_len", "clructureistbuffer", "cluster2step", "clusterlistdata", "cluster____step", "clusterlistoffset", "clusterablebuffer", "cluster_step", "clusterlistDATA", "cluster_ops", "cluster_DATA", "clusteristbuffer", "clructure_next", "clusters_ops", "clute_supported", "clusterablelen", "cluster____data", "clructureistdata", "clructureistlen", "clusteristdata", "clusters_cache", "clusterabledata", "clusterlistsupported", "cluster_len", "clute_offset", "clusteristnext", "clructure_buffer", "cluster_buffer", "clute_data", "clusteristlen", "cluster2ops", "clute_DATA", "clructure_data", "cluster____ops"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n\n                   VhostBackendType backend_type, bool force)\n\n{\n\n    uint64_t features;\n\n    int i, r;\n\n\n\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -1;\n\n    }\n\n\n\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -errno;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->migration_blocker = NULL;\n\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n\n        error_setg(&hdev->migration_blocker,\n\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n\n        migrate_add_blocker(hdev->migration_blocker);\n\n    }\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    hdev->memory_changed = false;\n\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n\n    hdev->force = force;\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n\n    }\n\nfail:\n\n    r = -errno;\n\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n\n    return r;\n\n}\n", "idx": 9929, "substitutes": {"hdev": [" hdef", "chdevice", "htdevice", "hmdevice", " hhandle", "handleDEV", "Hev", " hpro", "ohDev", "htdata", "ohgo", " hev", "ehgo", " hgu", "hmvar", "vev", " hdes", "hhdev", "vpad", "haddr", "ehaddr", "hev", "ohdevice", "ohdata", "hgo", "hhhandle", "ehDEV", "chDEV", "Hdevice", "vDEV", "handlepro", "shgu", "ohdev", "ehhandle", "hhev", "hhandle", "ehpro", "Hdev", "vdevice", "hpad", "hdata", "chdev", "hobj", "hmDev", "hostdevice", "Haddr", "hdes", "htdev", "hvar", "ohpad", " hpad", " hvar", " hcast", "vdev", "hmdev", "hDev", "hgu", "HDev", "hmdata", "hostDEV", "vDev", "chDev", "hDEV", "handledev", "shev", "Hdata", "hostdev", "HDEV", "hmDEV", "ehdevice", "ohcast", "hdef", "ohdes", "handledevice", "vdata", "Hvar", "ehobj", "hhgu", "hhdevice", " hgo", " hdata", "vpro", "shdev", " hobj", "ohpro", "hhobj", " haddr", "ehev", "Hdef", " hDev", "ehdev", "hpro", "hcast", "htpad", " hdevice", "ehgu", "hostev", "vdef", "shdevice", "hhdes", "hdevice", "Hcast", " hDEV", "ehdes"], "opaque": ["obque", "oaco", "opatile", "OPaques", " opent", "obaque", " opaco", "pque", "ogane", " opacity", "opane", " opaques", "boatile", " opque", "obane", "oaques", "appoid", "oppaque", "oppatile", "iopaque", "iopacity", "OPaco", "appatile", "opque", "obacity", "obaques", "iopaques", "boaque", "oppoid", "opoid", "oaque", "appaque", "booid", "ogaque", "opaco", "appener", " opane", "OPaque", "opener", "opaques", "ogque", "iopque", "ogacity", "opent", "OPent", "paques", "oppener", "oent", "boener", "opacity", "paque", "pacity"], "backend_type": ["backlineTyowner", "backendTytype", "backline_Type", "backend_name", "backend_family", "backendTyowner", "backrend_Type", "backlineTykey", "backendetytype", "backrend_type", "backline_type", "backlineTyType", "backendetyType", "backend_Type", "backline_owner", "backlineTytype", "backendetyowner", "backendetykey", "backrend_family", "backend_key", "backendTyType", "backline_key", "backendTykey", "backrend_name", "backend_owner"], "force": ["write", " suppress", " ignore", " fake", "quiet", "raise", "Force", " defer", "fork", " overwrite", "dirty", "ground", "fast", "secure", "remote", "forced", " permanent", " persistent", " quiet", "enable", "hide", " refresh", " forced", " confirm", "apply"], "features": ["reports", "ports", "options", "changes", "vals", "sections", "types", "feature", "events", "effects", "pins", "ributes", "frames", "settings", "its", "fc", "forms", "fts", "format", "addons", "rows", "tags", "ensions", "ops", " Features", "fixes", "tests", "properties", "feat", "flags", "abilities", "devices", "fs", "modules", "actions", "acts", "plugins", "details", "names", "facts", "files", "performance", "relations", "players", "ints", "stats", "states", "fields", "eatures", "weights", "bits", "faces", "results", "items", "services", "Features", "orts", "wcs", " feat", "classes", "words", "versions"], "i": ["di", "p", "ui", "ami", "cli", "x", "err", "v", "f", "gi", "id", "ai", "ic", " ii", "iq", "ind", "ii", "l", "j", "xi", "sim", "I", "phi", "ix", "iu", "multi", "u", "bi", "n", "in", "is", "ie", "hi", "b", "si", "index", "s", "li", "info", "y", "ini", "q", "it", "ia", "ci", "m", "chain", "ip", "mi", "zi", "qi", "batch", "ti", "port", "im", "asi", "pi", "e", "mu", "me"], "r": ["ren", "p", "or", "rer", "h", "ir", "cr", "dr", "pr", "hr", "rs", "attr", "rr", "err", "ar", "repl", "ret", "re", "entry", "radius", "rf", "result", "R", "fr", "lr", "nr", "error", "run", "rem", "rc", "sr", "rm", "record", "rel", "rg", "g", "er", "d", "ur", "tr", "ro", "arr", "q", "rt", "ry", "mr", "rar", "kr", "br", "rn", "m", "c", "res", "rb", "row", "rw", "e", "rd", "response"]}}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        int r, g, b;\n\n\n\n        switch (pix_fmt) {\n\n        case AV_PIX_FMT_RGB8:\n\n            r = (i>>5    )*36;\n\n            g = ((i>>2)&7)*36;\n\n            b = (i&3     )*85;\n\n            break;\n\n        case AV_PIX_FMT_BGR8:\n\n            b = (i>>6    )*85;\n\n            g = ((i>>3)&7)*36;\n\n            r = (i&7     )*36;\n\n            break;\n\n        case AV_PIX_FMT_RGB4_BYTE:\n\n            r = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            b = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_BGR4_BYTE:\n\n            b = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            r = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_GRAY8:\n\n            r = b = g = i;\n\n            break;\n\n        default:\n\n            return AVERROR(EINVAL);\n\n        }\n\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9934, "substitutes": {"pal": ["pol", "att", "al", "p", "Pal", "pl", "list", "vals", "pixel", "pac", "mem", "bin", "mat", "px", "pp", "pack", " PAL", "data", "phil", "als", "ul", "phal", " Pal", "val", " pl", "all", "bl", "out", "mal", "isal", "el", "dat", "ph", "pill", "li", "late", "pu", "pat", "ele", "jl", "ette", "ell", "table", "ap", "le", "cel", "ass"], "pix_fmt": ["pix_mdr", "pix_mmt", "pix_fdr", "pix_vgt", "pix_Fnt", "pix_fcmt", "pix_cnt", "pix_vdr", "pix_Ftype", "pix_mlt", "pix_fnt", "pix_vlt", "pix_Fformat", "pix_vmt", "pix_mgt", "pix_fcnt", "pix_cmt", "pix_Fmt", "pix_ctype", "pix_fformat", "pix_ftype", "pix_fctype", "pix_fgt", "pix_cformat", "pix_flt", "pix_fcformat"], "i": ["ami", "cli", "x", " ti", " m", "err", " ii", "ind", " is", "ix", " out", "iu", "u", "bi", "print", "index", "li", " my", "mount", "go", "c", "io", "t", "batch", "ti", "k", " pi", "gi", "ic", " index", "name", "ei", "I", "phi", "ik", " bi", "it", "qi", "mi", "ij", "status", "ki", "me", "ims", "ui", "p", "init", "id", "l", "xi", " iter", "sim", "oi", "ex", "at", "multi", "out", "o", "is", "s", "y", "ini", "ia", "ci", "adi", "pi", "e", "di", "list", " multi", "v", "ri", "ai", "ii", "mac", "j", "ji", " mi", "key", "in", "n", "si", " li", "m", "ip", "zi", " j", "iri", "point", "im"], "r": ["p", "h", "ir", "dr", "x", "cr", "pr", "ra", "rs", "ar", "v", "err", "rr", "f", "ri", "ret", "vr", "re", "l", "R", "fr", "lr", "j", "sr", "u", "rc", "rm", "rg", "a", "d", "er", "s", "ur", "ro", "rt", "mr", "reg", "rar", "it", "br", "m", "c", "t", "res", "rb", "e", "k", "w", "rd"], "g": ["gl", "p", "h", "dr", "ga", "f", "v", "gi", "mg", "z", "gd", "pg", "G", "l", "gs", "gt", "group", "j", "eg", "gp", "u", "rg", "gz", "er", "d", "gm", "gray", "gb", "fg", "go", "gu", "reg", "gr", "og", "tg", "ger", "m", "c", "ge", "bg", "gc", "ig", "msg", "erg", "gg", "ag", "gy"], "b": ["p", "cb", "h", "sb", "bf", "be", "ab", "bin", "f", "v", "nb", "ob", "bp", "bc", "l", "j", "bb", "eb", "ub", "fb", "bl", "u", "ib", "bi", "n", "o", "bh", "a", "er", "B", "mb", "s", "y", "gb", "br", "c", "binary", "db", "rb", "base", "ba", "bg", "bo", "e", "lb", "bs", "bm", "by"]}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "void qmp_transaction(TransactionActionList *dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n", "idx": 9943, "substitutes": {"dev_list": [" dev_lists", "devactlist", "dev_def", " dev__lists", " dev_def", "dev2lists", "dev_List", "dev_table", "dev__entry", "devactList", "dev__list", "DEV_table", "DEV_type", "devacttype", "dev2List", "dev2type", "dev2table", "DEV_List", " dev__list", "dev2list", "dev__def", " dev__entry", "DEV_list", "dev_lists", "dev2def", "dev_type", " dev__def", "devacttable", "dev__lists", "dev2entry"], "errp": ["errnp", "rrP", " errm", "warnnp", "arrP", "rrm", "errr", " errP", " errr", "rrr", "arrm", " errnp", "rrp", "errpa", " errpa", "arrp", " erP", "errP", "warnpa", "arrr", "errm", "warnp", " erp", " ernp", "warnP", " erpa"], "dev_entry": ["ev_entry", "dev8search", " dev2member", " dev2entry", "dev_cue", " dev2search", "dev8member", "devixstart", "dev8entry", "devrowstart", "dev_search", "ev_Entry", "devrowentry", " dev_search", "devixry", "ev_list", "devrowry", "devixentry", "dev_Entry", "dev2search", "dev2member", "dev_member", " dev_member", "devixcue", "devrowcue", " dev_ry", "dev_start", "dev2Entry", "dev_row", "ev_row", " dev_cue", "dev2row", "dev_ry", "ev_info", " dev_Entry", " dev_start", "dev2entry"], "state": ["update", "runner", "instance", "tag", "type", "data", "lock", "close", "range", "count", "monitor", "remote", "er", "print", "index", "cache", "to", "reg", "task", "this", "t", "current", "db", "batch", "row", "session", "public", "value", "private", "rule", "test", "output", "stat", "name", "ps", "dict", "new", "root", "config", "resource", "core", "handle", "path", "info", "ry", "trace", "stats", "it", "power", "draw", "buffer", "status", "port", "inner", "storage", "scope", "al", "init", "conn", "job", "commit", "STATE", "entry", "result", "start", "future", "parent", "component", "out", "store", "size", "that", "st", "try", "user", "memory", "self", "art", "step", "list", "city", "request", "connection", "version", "trans", "call", "run", "key", "policy", "n", "area", "State", "loop", "zone", "event", "back", "post", "form", "see", "local", "queue", "module", "states", "m", "check", "base", "context", "client"], "next": ["self", "step", "ent", "inv", "seq", "value", "link", "pre", "success", "head", "ng", "data", "Next", "end", "entry", "name", "result", "gt", "start", "new", "future", "parent", "key", "owner", "prev", "bi", "nl", "nt", "ne", "er", "sec", "index", "ner", "path", "asc", "node", "set", "first", "adj", "max", "sequence", "last", "this", "chain", "current", "inner", "action", "ptr", "child", "response"], "local_err": ["self_notice", "loc_err", "local_eas", " local_buf", "self___rr", "personal___error", "local___er", "personal_err", "local2rr", "local_buf", "loc_er", "local___rr", "local___err", "local___buf", "local___cr", "loc_msg", "localpyerr", "self___buf", "local_rr", "loc_eas", " local_cr", "local_error", "local___error", "self___notice", "local_notice", "local2buf", "local2notice", "local_er", "local_cr", "self___err", "personal___notice", "self_rr", "local_msg", "localpybuf", "personal_er", "local2err", "localpyrr", "self_buf", "personal_notice", "personal_error", "self_err", "personal___err", "personal___er", "local___notice", "localpynotice"], "dev_info": ["ev_entry", " dev_kind", "Dev_no", "dev_Info", "dev_kind", "devPInfo", " dev_INFO", "ev_kind", "devPinfo", "ev_Info", "dev_inf", "devPinf", " dev__inf", "dev_INFO", "dev__fo", " dev_inf", "devPkind", " dev__info", "dev_no", "dev_fo", "dev__INFO", "dev__info", "Dev_fo", "Dev_info", "dev__no", "ev_info", "dev__inf", " dev__INFO", " dev_Info", "ev_fo", "devPINFO", "Dev_INFO"], "ops": ["options", "orders", "changes", "asts", "tools", "events", "opa", "opens", "uts", "oper", "obs", "vers", "xs", "flags", "docs", "abilities", "names", "apps", "tops", "hops", "groups", "ms", "ins", "caps", "Ops", "op", "params", "ows", "settings", "ps", "checks", "obj", "oms", "posts", "oops", "stats", "ds", "utils", "services", "vs", "orts", "ims", "ports", "cons", "outs", "its", "ils", "modules", "values", "eps", "os", "times", "ips", "OPS", "ts", "vals", "ots", "aps", "pps", "rs", "args", "forms", "als", "sts", "nets", "actions", "opers", "ups", "ands", "arts", "bits", "items"]}}
{"project": "qemu", "commit_id": "d15fda639ba356148fc7161bba863866fd2797ef", "target": 0, "func": "static int intel_hda_init(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n    uint8_t *conf = d->pci.config;\n\n\n\n    d->name = d->pci.qdev.info->name;\n\n\n\n    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(conf, 0x2668);\n\n    pci_config_set_revision(conf, 1);\n\n    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);\n\n    pci_config_set_interrupt_pin(conf, 1);\n\n\n\n    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */\n\n    conf[0x40] = 0x01;\n\n\n\n    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,\n\n                                          intel_hda_mmio_write, d,\n\n                                          DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);\n\n    if (d->msi) {\n\n        msi_init(&d->pci, 0x50, 1, true, false);\n\n    }\n\n\n\n    hda_codec_bus_init(&d->pci.qdev, &d->codecs,\n\n                       intel_hda_response, intel_hda_xfer);\n\n\n\n    return 0;\n\n}\n", "idx": 9956, "substitutes": {"pci": ["gcci", "ippi", "pcki", "cpi", "ppmi", "apki", "fpdu", "cpci", "mcm", " pct", "gki", "hpi", " pcm", "Ppi", "mmi", "pmi", "ipki", " pda", "hki", "Pci", "opmi", "gci", "mpi", "hcm", "ppci", "pcda", "perscci", " pki", "ppi", "mci", "ipcm", "Pki", "gcm", "Pdu", "cpda", "pct", "opki", "mki", "ccm", "ccci", "fpci", "pcct", "appi", "hci", "ppki", "ppcm", "fpct", "cpcm", "cci", " pcci", "fpcci", "perscm", "Pct", "apoci", "persci", "Poci", "pki", "apc", " ppi", "opcm", "cppi", "ipci", "cpcci", "poci", "apci", "Pcci", "pc", "cpki", "cpct", " pc", " pdu", "pdu", "perspi", "cpc", "hoci", "pcm", "pcci", "pda", "opci"], "d": ["r", "di", "p", "done", "ld", "send", "dc", "h", "dev", "nd", "dr", "dx", "bd", "D", "i", "f", "v", "dd", "de", "dm", "z", "data", "cfg", "dp", "ind", "l", "dict", "j", "dl", "new", "dt", "debug", "n", "config", "o", "pd", "da", "des", "md", "g", "b", "did", "td", "dh", "dat", "s", "fd", "y", "sd", "q", "dn", "ds", "m", "c", "t", "ed", "dj", "ad", "db", "ord", "e", "w", "rd"], "conf": ["att", "func", "cb", "opt", "init", "Conf", "conn", "acc", "cf", "comment", "um", "irm", "f", "confirmed", "cm", "nb", "pb", "cfg", "priv", "auth", "map", "query", "sub", "comm", "cn", "cc", "Con", "rc", "Config", "config", "cp", "fab", "app", "scan", "sec", "cache", "ch", "def", "try", "com", "info", "aff", "gb", "fg", "ca", "ref", "q", "ns", "c", "inf", "con", "plan", "sch", "spec", "msg", "conv", "cmd"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n\n        raw_aio_remove(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 9961, "substitutes": {"bs": ["irms", "sb", "blog", "ses", "aos", "bos", "ls", "BS", "pb", "its", "bp", "bc", "obs", "cks", "gs", "ys", "bb", "iss", "bi", "fs", "bh", "b", "lbs", "bas", "bis", "js", "bes", "bits", "bps", "aus", "locks", "bn", "cs", "bm", "qs", "ns"], "sector_num": ["sector9pos", "sector9enum", "sectorNamepos", "sector_mon", "ector_number", "sectorNameenum", "ector_mon", "ector_no", " sector_number", "sector_no", "sector_pos", "sectorNamenumber", "sector_enum", "sectorNamenum", "sector9number", " sector_pos", "sector9num", "sector_number", " sector_enum", "ector_num"], "qiov": ["chkov", "qovi", "Qiop", "Qiour", "kiour", "Qiov", "kiov", "chiour", "xiop", " qovi", "kkov", "chiev", "qiour", "qiop", "chiov", "xiour", " qkov", " qiop", "qiev", "qkov", "xiov", "Qovi", " qiev", " qiour", "kiev", "xovi"], "nb_sectors": ["nb_serors", "nb_secs", "nb_vevers", "nb_vectors", "nb_pevers", "nb_sercs", "nb_severs", "nb_peors", "nb_specs", "nb_vecs", "nb_pelements", "nb_serctions", "nb_sections", "nb_serctors", "nb_seors", "nb_velements", "nb_vections", "nb_spectors", "nb_speors", "nb_nectors", "nb_veors", "nb_neors", "nb_selements", "nb_spections", "nb_pectors", "nb_nelements", "nb_nevers"], "cb": ["func", "bf", "sb", "cf", "tc", "fun", "nb", "ck", "pb", "ob", "fc", "bp", "bc", "nc", "cd", "erb", "eb", "dt", "ub", "fb", "cc", "rob", "rc", "cv", "cp", "bt", "b", "fn", "obb", "gb", "ctx", "ctrl", "c", "wb", "abb", "db", "rb", "CB", "callback", "lb"], "opaque": ["ocaque", "ocacity", "mopute", "hopaques", "opute", "pque", " opacity", " opaques", " opque", "hopaque", "ocaques", "hopica", "iopaque", "mopica", "opque", "mopaque", "iopaques", "iopute", "opaques", "ocque", "mopaques", "iopica", "hopute", "opica", "paques", "opacity", "paque", "pacity"], "acb": [" acrb", "acc", " lacbc", "aclzb", " acbe", "cacheb", "iacrb", "agb", "ocob", "cacherb", "agzb", "acab", "ascbb", "acob", "aicrb", " acbb", "sacb", "icrb", "ocsb", "icc", "adbr", "awrb", "achbc", " lacb", "achrb", "cachebc", "aicbc", "acbt", "ocbb", "agbc", "awbc", "adb", "acsb", "acbb", "ascob", "accbr", " laczb", " acbc", "acbr", "adbc", "achb", "accb", "sacc", "aclbc", "aicbe", "awc", "accbc", "ocbr", "awb", "accbb", "icbt", "iacbt", "agab", "icb", " acsb", " acob", "adbb", "aicb", "ocb", " lacab", "sacbc", "icbc", "aclb", "ocbc", "cachebt", "sacrb", "acbc", "achbe", "acbe", "ascb", "iacb", "ascsb", "iacbc", "aczb", "acrb", "aclab"]}}
{"project": "FFmpeg", "commit_id": "3622988f2162e502727da476a70f5e4f48cd19c5", "target": 0, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n    \n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 &&\n\n                ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n    \n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n    \n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*h->b8_stride] == 0){\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        /* FIXME assumes that L1ref0 used the same ref lists as current frame */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1mv0[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n    \n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n    \n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9977, "substitutes": {"h": ["r", "p", "sw", "his", "rs", "hp", "f", "ih", "v", "k", "sh", "hm", "pp", "rh", "l", "ct", "hd", "comm", "cc", "http", "th", "help", "H", "bh", "b", "g", "oh", "history", "ht", "he", "ch", "dh", "ph", "ah", "kh", "enh", "cache", "handle", "hl", "hh", "hash", "q", "each", "ctx", "hs", "m", "c", "here", "t", "eh", "hal", "ssh", "context", "host", "hw", "hz", "conv"], "mb_type": ["MB_type", "mb8ype", "mbetricType", "vm_family", "mp_Type", "mp_order", "mblyfamily", "mp_name", "MB_test", "mblytype", "mbricname", "mb_ype", "mb_order", "mb_model", "emb_Type", "mbricstyle", "mbetrictest", "mb8TYPE", "mbricblock", "MB_block", "mb___type", "mb_Type", "mblystyle", "vm_type", "emb_TYPE", "mp_ype", "mbrictest", "emb_type", "vm_model", "mb_family", "mb8Type", "mbetrictype", "mbricorder", "mb_test", "mb8type", "MB_Type", "mb_block", "emb_style", "mbetricblock", "mp_type", "mb_TYPE", "mp_TYPE", "mbricmodel", "mb_style", "mb___col", "vmricfamily", "mblymodel", "mb___name", "mp_col", "mb_name", "mbriccol", "mb___order", "mb_col", "mbricType", "vm_style", "mbrictype", "mbricfamily", "vmrictype", "vmricstyle", "vmricmodel"], "s": ["cpp", "ts", "p", "ports", "session", "changes", "sb", "sections", "ats", "sw", "rs", "se", "i", "v", "ls", "f", "sh", "ss", "its", "als", "shared", "l", "ps", "xs", "gs", "an", "comm", "sts", "http", "parts", "n", "sq", "south", "fs", "a", "sl", "is", "b", "g", "as", "sv", "bs", "ins", "os", "y", "css", "js", "sys", "hs", "ds", "stats", "styles", "m", "c", "S", "t", "mods", "spec", "ssh", "cs", "e", "wcs", "ims", "ms", "w", "qs", "conv", "ns"], "l1mv0": ["l1Mv1", "l1mf1", "l1mj1", "l1mvals", "l1mvp_", "l1mf0", "l1mf_", "l1mv_", "l1Mvp_", "l1mfals", "l1Mvals", "l1mvpals", "l1Mv0", "l1mvp0", "l1Mvp1", "l1mj_", "l1mj0", "l1mjals", "l1Mvp0", "l1mvp1", "l1Mv_", "l1Mvpals", "l1mv1"], "l1ref0": ["l1Ref2", "l2ref2", "l2reference1", "l1reference1", "l1Ref0", "l2reference0", "l1Ref1", "l1reference2", "l1mem0", "l2ref1", "l1mem2", "l1mem1", "l1ref1", "l1ref2", "l2reference2", "l2ref0", "l1reference0"], "sub_mb_type": ["sub_MB_type", "sub_MB_class", "sub_mblykey", "sub_mblyType", "sub_mb_lock", "sub_mb_key", "sub_MB_part", "sub_mb_class", "sub_MB_TYPE", "sub_mb_TYPE", "sub_MB_name", "sub_MB_lock", "sub_mb_name", "sub_mbdpart", "sub_MB_key", "sub_mb_types", "sub_mb_part", "sub_mbdtype", "sub_mbdname", "sub_mb_Type", "sub_mbdType", "sub_mblyTYPE", "sub_MB_Type", "sub_MB_types", "sub_mblytype"], "i8": ["l8", "l9", "pi6", "pi08", "l08", "pi8", "b9", "b6", "i08", "b08", "pi9", "b8", "l6", "i9", "i6"], "i4": ["I04", "pi4", "pi8", "pi04", "I4", "i04", "I8", " i04"]}}
{"project": "qemu", "commit_id": "e3af7c788b73a6495eb9d94992ef11f6ad6f3c56", "target": 0, "func": "static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)\n\n{\n\n    uint32_t ret;\n\n\n\n    switch (ot) {\n\n    case MO_8:\n\n        ret = cpu_ldub_code(env, s->pc);\n\n        s->pc++;\n\n        break;\n\n    case MO_16:\n\n        ret = cpu_lduw_code(env, s->pc);\n\n        s->pc += 2;\n\n        break;\n\n    case MO_32:\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n#endif\n\n        ret = cpu_ldl_code(env, s->pc);\n\n        s->pc += 4;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n    return ret;\n\n}\n", "idx": 10000, "substitutes": {"env": ["self", "ts", "engine", "cb", "h", "sb", "conf", "conn", "ev", "enter", "v", "esc", "sp", "environment", "ef", "end", "nc", "en", "window", "shell", "sen", "bench", "n", "config", "buf", "cv", "ve", "server", "sv", "vt", "ja", "er", "net", "viron", "te", "ner", "ec", "queue", "esm", "ctx", "ds", "ger", "gate", "here", "txt", "et", "console", "sc", "Environment", "outer", "den", "vs", "him", "context", "e", "ptr", "state", "vp", "w", "erd"], "s": ["self", "ts", "p", "session", "h", "sb", "span", "sw", "ses", "rs", "sa", "sp", "ss", "stat", "als", "es", "syn", "ps", "gs", "j", "sim", "an", "sts", "space", "n", "sq", "ess", "store", "south", "sv", "src", "sl", "serv", "is", "d", "b", "scan", "sam", "bs", "st", "os", "pers", "eps", "set", "sg", "js", "stats", "ds", "S", "sis", "so", "source", "vs", "asm", "cs", "client", "spec", "socket", "qs", "scope", "ns"], "ot": ["or", "ots", "ote", "slot", " got", "oot", "dot", "iet", " ol", "pot", "ct", "ox", "tt", "gt", " et", "bot", "OT", "Mot", " quot", "iot", "ota", " oy", "not", "o", "bt", " blot", "ott", "os", "mot", "rt", "og", "iat", "ol", "ort", " tot", "oto", "cot", "et", "hot", "oc", "rot", "ant", " mot"], "ret": ["r", "oret", "att", "al", "pas", "pret", "flag", "RET", "red", "ft", "cat", "v", "cont", " Ret", "std", "xt", "url", "re", "alf", "result", "uf", "gt", "Ret", "rep", " RET", "ert", "val", "rem", "rm", "erey", "out", "liber", "lt", "nt", "des", "rets", "back", "print", "mt", "rest", "match", "lit", "get", "tr", "def", "ext", "rt", "ref", "reset", "ort", "reg", "txt", "t", "res", "cert", "det", "ll", "resp", "alt", "Return", "ter", "rel", "cmd"], "pc": ["pod", "p", "pro", "dc", "pic", "sync", "chron", "amp", "pr", "co", "proc", "tc", "conn", "pp", "pid", "pb", "cam", "tp", "fc", "priv", "bc", "pad", "pt", "nc", "bp", "disc", "page", "nic", "cc", "pn", "cp", "pointer", "post", "pa", "pers", "pan", "asc", "pu", "PC", "pm", "ctx", "mic", "mc", "c", "mi", "point", "ping", "pi", "pkg", "cs", "ptr", "cpu", "vc", "client", "doc", "isc"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n", "idx": 10026, "substitutes": {"opaque": ["obaque", " Opacity", "opois", " opacity", "opliphany", " opque", "popque", "iopaque", "iopacity", "iopois", "obacement", "opque", "obacity", "opiphany", " Opaque", "popaque", " opois", " Opiphany", "obiphany", "iopque", "oplacity", "oplacement", "oplaque", "opacement", "opacity", "popois", " Opacement", "popacity"], "bs": ["ts", "sb", "ots", "ab", "ats", "blog", "aos", "uts", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "cks", "gs", "acs", "bb", "ubs", "sts", "bl", "fs", "bh", "lbs", "has", "os", "ks", "bis", "bing", "bits", "bps", "aus", "vs", "cs", "bm", "ns"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,\n\n                      int rw, int type, int target_page_bits)\n\n{\n\n    hwaddr pteg_off;\n\n    target_ulong pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);\n\n    for (i = 0; i < 8; i++) {\n\n        if (env->external_htab) {\n\n            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));\n\n            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);\n\n        } else {\n\n            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));\n\n            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);\n\n        }\n\n        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);\n\n        LOG_MMU(\"Load pte from %08\" HWADDR_PRIx \" => \" TARGET_FMT_lx \" \"\n\n                TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n", "idx": 10049, "substitutes": {"env": ["dev", "inv", "init", "conf", "sw", "conn", "np", "eng", "ev", "v", "esc", "sp", "cfg", "eni", "environment", "network", "end", "nc", "era", "en", "code", "window", "vm", "ka", "org", "worker", "qt", "config", "obj", "cv", "setup", "server", "ew", "vt", "event", "net", "viron", "te", "kh", "ec", "ah", "act", "param", "info", "desc", "equ", "uv", "disk", "req", "et", "operator", "eh", "sc", "kw", "con", "nv", "vs", "pkg", "context", "hw", "w", "msg", "cmd"], "ctx": ["p", "func", "cb", "x", "co", "dev", "wd", "conf", "timeout", "np", "conn", "tc", " cx", "cf", "addr", "std", "ck", "exec", "handler", "cfg", "pg", "bc", "nc", "ct", "tk", "window", "jac", "vm", "cn", "ka", "cu", "org", "cc", "qt", "rc", "mom", "wx", "cv", "obj", "cp", "fw", "setup", "nt", "tmp", "ctl", "conv", "config", "that", "history", "kh", "act", "mk", "kb", "etc", "nil", "tx", "cmp", "rt", "ca", "ann", "txt", "kt", "sc", "ork", "kw", "loc", "nv", "xc", "pkg", "context", "gc", "hw", "jp", "cmd"], "h": ["p", "x", "hr", "f", "v", "ih", "sh", "rh", "l", "height", "window", "hd", "hz", "n", "host", "H", "o", "bh", "b", "g", "hi", "oh", "history", "ht", "he", "dh", "kh", "handle", "ha", "y", "hl", "hh", "q", "hash", "hs", "home", "m", "c", "t", "hal", "k", "hw", "w"], "rw": ["write", "writer", "wd", "hr", "sw", "wp", "mem", "rs", "rr", "ng", "wr", "writ", "vr", "rh", "W", "rf", "wn", "usr", "window", "rc", "wx", "ew", "ru", "buf", "vt", "RW", "ht", "wh", "iw", "ro", "rt", "mr", "wt", "wb", "wa", "rew", "nw", "rb", "kw", "row", "wind", "ww", "we", "ptr", "hw", "w", "rd", "wal"], "type": ["p", "types", "ype", "unit", "f", "v", "typ", "id", "op", "sp", "pe", "name", "ver", "lock", "ty", "dt", "error", "time", "size", "er", "try", "TYPE", "ro", "Ty", "Type", "y", "info", "rt", "style", "ref", "kind", "weight", "t", "ping", "pc", "state", "ptr"], "target_page_bits": ["target_hash64pages", "target_page64bits", "target_page2size", "target_hash64size", "target_page_size", "target_hash64points", "target_hash_size", "target_hash_bits", "target_page2pages", "target_page64pages", "target_page2points", "target_page_points", "target_page64points", "target_hash64bits", "target_page2bits", "target_hash_points", "target_page64size", "target_page_pages", "target_hash_pages"], "pteg_off": ["pteng_down", "pteg_old", "pterm67off", "pteg2offs", "pteg0over", "pterm67err", "ptejoff", "pterm_on", "pteg2o", "pteg_err", "ptag_offset", "ptegldoff", "ptpeg_info", "pteg48no", "pteret_off", "pteg_Off", "ptag_Off", "pterm_OFF", "ptag_on", "pteg_over", "ptegjdev", "ptegldOff", "pteret_no", "ptegldinfo", "pterm67on", "ptig_o", "pteg_offset", "pteg_info", "pteglerr", "ptig_offs", "pteg48off", "pteg67off", "pteng_over", "ptejov", "pterm_err", "pteg_left", "pterm67OFF", "pteng_old", "pteng_off", "pteg0down", "pte_off", "pteg67OFF", "pteglddev", "pteglOFF", "pteg_no", "ptpeg_Off", "pteg2off", "pte_ov", "pteg0off", "pterm_off", "ptejdev", "pte_dev", "ptig_off", "pteg_ov", "pteg_offs", "ptegjov", "ptpeg_off", "pteg48left", "pteg_o", "ptpeg_dev", "pteg0old", "pteg_down", "pteg_on", "ptag_off", "ptegjoff", "pteglon", "pteg67err", "pteg_OFF", "pteret_left", "ptegloff", "pteg_dev", "pteg67on"], "pte0": ["pteg195", "ptoe1", "ptoe_", "porte195", "nte3", "ptezero", "ptxe1", "ptoe7", "ptee15", "ptel0", "ptme1", "ptele0", "ptoe8", "porte30", "pte_", "ptelzero", "ptoe2", "pte8", "ptede0", "ptxe_", "portee30", "ptede8", "pte15", "ptye0", "ptele30", "nteezero", "porte8", "ptje1", "ptje8", "ptyezero", "pteezero", "ptoe3", "ptee1", "porte0", "pteg0", "pte3", "portezero", "portee1", "ptel1", "ptje0", " pte7", "ptme0", "portee195", "ptxe0", "portee15", "ptec1", "ptele1", " pte2", "porte15", "ptye195", "ptoezero", "ptye3", "ptte1", " ptoe2", "pte30", "ntee1", "ptme2", "nte1", "portee0", "ptoe0", "ptte2", "porte_", "ptxe8", "ntee0", " ptoe1", "ptte0", "ptee0", "ptee30", "pteczero", "ptee8", "porte1", "ptee_", "ntezero", "portee_", "ptede1", "ptede15", "ptee195", "ptje15", " ptoe7", "pteg1", "ptee3", " ptoe0", "ptte7", "ptme7", "ptye1", "ptec0", "pte195", "pte7", "nte0", "portee8", "ntee3", "porteezero", "ptoe30", "pte2"], "pte1": ["ptoe1", "ptE1", "ptea100", "ptee9", "pter2", "ptea1", "ptoe7", "ntee100", "ptae0", "ptoe8", "pointoe4", "portee2", "ptae8", "pte4", "pter0", "pointe2", "ptoe2", "pter1", "ptea0", "pte8", "pointe8", "ntee7", "porte2", "ptee100", "pointe1", "pointoe0", "pointoe2", "ptE2", "ptee2", "pte100", "ptoe3", "ptee1", "pter4", "porte0", "nte2", "pte3", "portee1", "ptE7", "ptoe9", "portee9", "ptae2", "pointoe3", "ptte1", "ntee2", "ntee1", "porte9", "nte1", "portee0", "ptoe0", "ptea2", "ptte2", "ntee0", "pointe3", "ptte0", "ptee0", "ptee8", "porte1", "ptoe4", "ptee7", "pte9", "pointe4", "nte7", "pointoe8", "pointe0", "ptee4", "ptae1", "ptee3", "ptE3", "ptte100", "nte100", "ptE0", "nte0", "pte7", "pointoe1", "pte2"], "i": ["ami", "x", " ii", "ind", "ix", "iu", "bi", "index", "li", "c", "io", "this", "t", "ti", "gi", "ic", "iq", "name", "ei", "I", "phi", "my", "info", " bi", "it", "qi", "mi", "status", "asi", "ki", "ims", "me", "ui", "p", "init", "id", "l", "xi", "sim", "oi", "ex", "multi", "o", "b", "is", "g", "s", "y", "ini", "ia", "ci", "pi", "e", "di", "ma", "f", "v", "ri", "ai", "z", "ii", "j", "ji", "key", "n", "in", "hi", "si", "m", "ip", "zi", " j", "im"], "ret": ["done", "found", "pert", "dr", "flag", "RET", "red", "ft", "mem", "rs", "rev", "f", "rr", "read", "addr", "err", "re", "alf", "rf", "result", "gt", "Ret", "deg", "usr", "val", "dt", "ert", "reply", "rm", "rc", "out", "lt", "nt", "store", "rets", "des", "buf", "nz", "vt", "back", "print", "bad", "mt", "def", "desc", "elt", "ry", "rt", "ref", "reg", "fi", "it", "io", "txt", "t", "et", "len", "res", "status", "rew", "ll", "resp", "alt", "ptr", "rit", "ter", "rd", "arg", "cmd"], "r": ["p", "cr", "dr", "hr", "red", "rs", "rr", "err", "v", "ri", "re", "rf", "l", "result", "R", "j", "nr", "reb", "rc", "rm", "sr", "rg", "n", "b", "g", "er", "d", "ro", "rt", "q", "mr", "rar", "kr", "br", "m", "c", "t", "res", "rb", "e", "w", "rd"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    xcrs.nr_xcrs = 1;\n\n    xcrs.flags = 0;\n\n    xcrs.xcrs[0].xcr = 0;\n\n    xcrs.xcrs[0].value = env->xcr0;\n\n    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 10055, "substitutes": {"env": ["dev", "h", "conf", "proc", "conn", "ev", "eng", "next", "enter", "v", "esc", "sp", "cur", "pe", "environment", "entry", "end", "en", "code", "window", "eg", "vm", "worker", "va", "config", "ew", "ve", "buf", "obj", "tmp", "vt", "sv", "cv", "server", "esp", "ec", "ah", "info", "desc", "node", "project", "container", "ctx", "uv", "req", "kernel", "manager", "sc", "po", "nv", "vs", "context", "e", "vp", "w"], "xcrs": ["xcrc", "apacheributes", "cvros", " concs", "xyRS", "wxrs", "lcras", "xcrics", "xcubs", "xrs", " conrs", "ccrs", "apacheredits", "xprs", "cfrys", " cxrs", "convros", "pcributes", "xcarts", "apacherics", "funcrys", "xcredits", "abccs", "coers", "coeributes", "convributes", "wxres", "cfras", "xyres", "abcrs", "pcros", "cacheras", "pcrs", "coerics", "convrs", "xcears", "cvrs", "xcros", "funcarts", "xdrs", "ccards", "ancras", "cvubs", "chestsels", "xcards", "abcrys", "xcRS", "xdrc", "cfributes", "pcredits", "ancarts", "funcrs", "ancears", "chestrs", "ccrys", "xcres", "xdres", "xcrys", "cacheears", "xcsels", "funcears", " cxcs", "xyrc", "cccs", "xcs", "lcrs", "xres", "pcrics", "coverrys", "xrc", "funcras", "cvributes", "coversels", "coverdes", "xpcs", "wxRS", "lcributes", "xdRS", "ancrs", "xccs", " cxrc", "xprys", "xcributes", "ccsels", "coeredits", "cachers", "cfrs", "ccdes", " cxres", "cachearts", "xyrs", "chestdes", "pcubs", " conres", " conrc", "coverrs", "xcdes", "xcras", "funcributes", "wxrc", "chestrys", "xpards", "convubs", "lcrys", "apachers", "abcards"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n", "idx": 10064, "substitutes": {"ctx": ["self", "p", "cb", "conf", "timeout", "np", "conn", "tc", "mem", "today", "cm", "std", "pause", "ck", "exec", "handler", "cfg", "bc", "nc", "ct", "care", "jac", "cc", "unc", "rc", "wx", "ctl", "obj", "cp", "cas", "tmp", "pool", "conv", "config", "xp", "prefix", "history", "work", "act", "handle", "phys", "tx", "sys", "ctrl", "mc", "req", "txt", "this", "sc", "anc", "kw", "loc", "Context", "xc", "pkg", "context", "gc", "ctr", "cpu", "hw", "cv", "jp", "cmd"], "cond": ["func", " pred", "co", "init", "conf", "bind", "condition", "Cond", "pre", "cont", "ck", "ind", "compl", "dict", " comp", "crit", " ex", "ct", "cd", "map", "lock", "cum", " prep", " com", " val", "cc", "obj", " cont", " compress", " cred", "expr", " sched", " lock", "def", " inf", "act", " compl", "com", " exc", "adj", "reg", " cop", "pred", " conditional", " con", "cod", "pos", " pref", " def", "con", "loc", "resp", "xc", " trap", "comp", "imm", " condition", " control", "cmd"], "cmp": ["Comp", "p", "dc", "cb", "co", "conf", "np", "tc", "attr", "test", "op", " comp", "cc", "rc", " cp", "prev", "rel", "cv", "cp", "tmp", "diff", "emp", " mp", "par", "etc", "eq", "phys", "desc", "ctrl", "c", "mp", "mc", "cod", "sc", " c", "loc", "con", "resp", "xc", "pkg", "vp", "comp", "omp", "conv", "cmd"], "disp": [" dispa", "Dispa", "Disps", "disps", "dispa", "dispar", "Dispar", " disP", "dispat", "disP", "Disp", " dispar", "dupat", "dispatch", " dispatch", "Dispatch", "lyp", "lyps", " dispat", "lypatch", "Dispat", "DisP", "dupar", "duP", " disps", "lypa", "dup"]}}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)\n\n{\n\n    uint32_t val = pci_default_read_config(d, address, len);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 10081, "substitutes": {"d": ["r", "di", "p", "dc", "dev", "dr", "dx", "D", "dq", "f", "i", "v", "dd", "de", "dm", "l", "cd", "n", "pd", "da", "o", "md", "b", "g", "fd", "sd", "dose", "dn", "ds", "dis", "c", "m", "t", "ad", "e"], "address": ["ace", " Address", "region", "addr", "add", "location", "pad", "command", "interface", "position", "device", "process", " addr", "size", "seek", "pointer", "event", "prefix", "resource", "index", "shape", "attribute", "Address", "ay", "each", "variable", "offset", "reference", "buffer", "ad", "port", "base", "point", "memory", "description", "message", "pc", "ptr", "length"], "len": ["ld", "Length", "seq", "mem", "fun", "fil", "un", "vol", "Len", "length", "syn", "lf", "l", "ln", "en", " length", "align", "nl", "n", "nt", "count", "size", "load", "el", "bytes", "elt", "offset", "lan", "fin", "t", "pos", "ll", "cmd"]}}
{"project": "qemu", "commit_id": "bbade20633a6b4ed7333e03a76038eda98950946", "target": 1, "func": "static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n", "idx": 10104, "substitutes": {"cpu": ["cli", "pixel", " CPU", "proc", "CPU", "conn", "mem", "gpu", "jp", "cow", "processor", "gnu", "cu", "gp", "process", "cp", "core", "pu", "ctx", "nu", "chip", " proc", "clock", "pc", "hw", "computer", "linux", "cmd"], "spapr": ["spappp", " spaprb", " spipp", "spiprc", "spAPrs", "spampp", "spamprc", "spapp", "spipR", "spampr", "spapsrs", "spapsrb", " spipr", "spaprb", "spipr", "spapR", "spappr", "spAPr", "spampR", " spapR", "spAPR", "spaprs", "spapsR", " spapp", "spaprc", " spiprc", "spapprc", " spaprs", "spipp", " spipR", " spaprc", "spapsr", "spappR", "spAPrb"], "token": ["ens", "session", "json", "tree", "result", "aws", "raw", "secret", "Token", "nt", " ret", "info", "input", "ok", "sys", "oken", "reset", "wt", "fields", "et", "kt", "features", "alt", "state", "ants", "response"], "nargs": ["targ", "tnarg", "nrets", " narg", "targs", " nrets", "narg", "tnret", "tnargs", "tret", "tnrets", "trets"], "args": ["ts", "arms", "ens", "extra", "vals", "atts", "rs", "ret", "params", "uments", "data", "uns", "gs", "terms", "ams", "Args", "flags", "fs", "ins", "ints", "ras", "fields", "ars", "res", "ms", "arg", "ns"], "nret": [" nRET", "NRet", "nrets", "Nrets", "nnrets", "nRET", "nvreset", "nreturn", "Nreturn", "nnreturn", "NRET", "nvrets", " nreturn", "nnret", " nRet", "nRet", "nnRET", "Nreset", " nrets", "Nret", "nreset", "nvRet", "nvret", " nreset"], "rets": ["ts", "ens", "vals", "sets", "ats", "RET", "events", "rs", "outs", "uts", "ret", "ls", "unts", "uments", " secrets", "es", "its", "als", "lists", "ces", "fts", "uns", "ails", "Ret", "acs", "els", "aws", "gt", "ads", "sts", "ils", "checks", "fal", "des", " ret", "cas", "fs", "vt", "ets", "bt", "nt", "values", "details", "uds", "mt", " returns", "mits", "ins", "def", "rises", "rt", "iris", "sys", "ards", "ints", "utes", "ds", "states", "ips", "res", "ires", "fits", "runs", "alt", "cs", "tes", "results", "gets", "qs", "ants", "ns"], "tm": ["tl", "tc", " ti", " m", "hm", " te", "mmm", "rm", "sm", "cms", "te", "sam", " mm", " tim", " mt", "tf", "t", "ti", "timer", "utt", "ms", "TM", "mem", "em", "amm", "htm", " rm", "tt", "temp", "nm", "fm", " ts", "tim", "mint", " td", "tx", " tem", "esm", "trace", " mc", "txt", "mi", "ims", "mm", "tem", "tk", "sim", "tis", "time", "tmp", "tif", "wm", "mt", "tu", "tv", "tr", "gm", "ym", " tmp", " template", "mobile", "hw", " mem", "att", "ts", " TM", "utm", "dm", "tp", " t", "tn", "td", " tc", "dim", "wt", "m", "mp", "mx", "ram", "him"]}}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n", "idx": 10128, "substitutes": {"device": ["pod", "controller", "engine", "dev", "DEV", "directory", "link", "test", "id", "number", "serial", "connection", "model", "network", "name", "pad", "ident", "command", "location", "query", "lock", "position", "component", "pipe", "stick", "label", "devices", "remote", "server", "event", "index", "handle", "path", "display", "node", "project", "driver", "Device", "module", "kind", "drive", "disk", "slave", "port", "block", "spec", "description", "product", "template", "mode", "address", "edge"], "speed": ["shock", "powered", "limit", "gain", "strength", "Speed", "rank", "loss", "species", "spe", "wage", "kick", "command", "capacity", "interface", "start", "rate", " speeds", "peed", "sex", "config", " sport", "size", "seek", "slow", "scale", "efficiency", "EED", "set", "phy", "power", "priority", "weight", "status", "percent", "port", "spec", "length", "delay", "frequency"], "errp": [" errpl", "usrpa", "rerpc", "rrP", "rrpl", "usrr", "errr", " errP", " errr", "rrr", " errpc", "errping", "rerp", "rrd", "rrpb", "rrp", "usrp", "rerpb", "errpe", "errpc", "rrpa", "errpa", " errpa", " errd", " erP", " erping", "errP", " errpe", "rrpe", " errpb", "rrpc", " erpl", "errd", " erp", "errpl", " errping", "usrpe", "rerd", "rrping", "errpb"], "job": ["pro", "util", "runner", " hub", "build", "jj", "vision", "jump", "mor", "cam", "cell", "obs", "jobs", "gov", "command", "name", "j", "group", "sim", "good", "lock", "bot", "worker", "thread", "bug", "cor", "bar", "tmp", "photo", "journal", "work", "mb", "com", "user", "local", "node", "queue", "project", "Job", "task", "phy", "manager", " jobs", "batch", "block", "mob", "db", "row", "client", "sub", "image", "item", "jp", "cmd"]}}
{"project": "FFmpeg", "commit_id": "e8c4db0d4d07738fed716b1d2f20c85aac944641", "target": 0, "func": "static int create_stream(AVFormatContext *s)\n\n{\n\n    XCBGrabContext *c = s->priv_data;\n\n    AVStream *st      = avformat_new_stream(s, NULL);\n\n    xcb_get_geometry_cookie_t gc;\n\n    xcb_get_geometry_reply_t *geo;\n\n    int ret;\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = av_parse_video_size(&c->width, &c->height, c->video_size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000);\n\n\n\n    gc  = xcb_get_geometry(c->conn, c->screen->root);\n\n    geo = xcb_get_geometry_reply(c->conn, gc, NULL);\n\n\n\n    c->width      = FFMIN(geo->width, c->width);\n\n    c->height     = FFMIN(geo->height, c->height);\n\n    c->time_base  = (AVRational){ st->avg_frame_rate.den,\n\n                                  st->avg_frame_rate.num };\n\n    c->time_frame = av_gettime();\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width      = c->width;\n\n    st->codec->height     = c->height;\n\n    st->codec->time_base  = c->time_base;\n\n\n\n    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);\n\n\n\n    free(geo);\n\n\n\n    return ret;\n\n}\n", "idx": 10161, "substitutes": {"s": ["r", "ts", "p", "x", "h", "ats", "ses", "rs", "f", "v", "ls", "i", "ss", "es", "its", "l", "ps", "gs", "acs", "aws", "sts", "cc", "n", "sq", "o", "fs", "a", "sv", "b", "as", "g", "is", "ec", "os", "y", "js", "hs", "ds", "S", "t", "sc", "spec", "cs", "bs", "w", "qs", "ns"], "c": ["p", "dc", "cb", "cr", "co", "coll", "conf", "C", "cus", "tc", "cf", "f", "v", "cm", "cont", "k", "ic", "cur", "fc", "abc", "bc", "nc", "ct", "l", "cd", "call", "csv", "cl", "uc", "comm", "lc", "cu", "content", "cc", "rc", "n", "cv", "config", "cp", "enc", "g", "b", "d", "ec", "cache", "etc", "com", "cmp", "ca", "ctx", "ce", "mc", "ci", "t", "chain", "sc", "anc", "con", "can", "xc", "cs", "pc", "comp", "vc", "col", "e", "cn", "ac"], "st": ["ts", "art", "step", "ent", "ot", "sta", "co", "nd", "cr", "sw", "ft", "pt", "sat", "std", "cont", "sp", "ast", "sh", "stat", "ste", "end", "ct", "ST", "str", "fr", "tt", "irst", "ust", "start", "cl", "stop", "usr", "sts", "stack", "th", "at", "sm", "store", "nt", "put", "sv", "ost", "St", "sl", "inst", "net", "mt", "sec", "rest", "ch", "td", "tr", "ut", "etc", " est", "sn", "rt", "set", "ctx", "it", "stage", "t", "et", "sc", "est", "stable", "ist", "state", "se", "w"], "gc": ["dc", "cb", "co", "tc", "ga", "gpu", "cm", " g", " GC", "fc", "pg", "bc", "nc", "disc", "cz", "eg", "lc", "gp", "nic", "cc", "cu", "gui", "rg", "ctl", "gn", "gor", "g", "gz", "ec", "gm", "gb", "sg", "go", "wt", " dc", "mc", " mc", "sc", "pc", "cs", "ig", "gg", "icc", "GC", "ac"], "geo": ["eonet", "veonet", "geof", "leom", "maology", "genoto", "memo", "veos", "seonet", "jebo", "ideos", " geot", "Geos", "ideot", "Geology", "seos", "memoa", " geos", "Geoa", " geoe", "seoe", "geonet", "genof", "Geo", "seom", "jeology", "gebo", "gerof", "seot", "geoto", "memom", "memos", "eo", "ideof", "GEonet", "sebo", "Gebo", "geroto", "eom", "seology", "geology", "mao", "geot", "ideoe", "GEom", "ideology", "Geom", "GEology", "gero", "genology", "veom", "veo", "geos", "geno", "maonet", "seo", "geoe", "leo", "geoa", " geoa", "jeos", "geom", "jeo", "GEo", "ideo", " geom", "eos", "ideoto", "leonet", "gerology", "maom", "leology"], "ret": ["no", "flag", "err", "url", "gt", "Ret", "rm", "nl", "print", "rest", "def", "arr", "ref", "sys", "reg", "t", "len", "ll", "ruby", "ter", "cmd", "oret", "red", "value", "cont", "addr", "ral", "rep", "erey", "lt", "rt", "ry", "it", "status", "res", "report", "al", "pret", "final", "fun", " Ret", "nat", "result", "prot", "uf", "deg", " RET", "rect", "rem", "at", "out", "nt", "mt", "try", "tr", "elt", "error", "att", "pas", "RET", "ft", "rev", "success", "virt", "re", "usr", "val", "not", "rets", "net", "back", " alt", " fut", "ext", "reset", "ber", "det", "resp", "alt"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc)\n\n{\n\n    unsigned cb;\n\n    uint8_t  *tmp_vlc_bits;\n\n    uint32_t *tmp_vlc_codes;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t *codebook_multiplicands;\n\n    int ret = 0;\n\n\n\n    vc->codebook_count = get_bits(gb, 8) + 1;\n\n\n\n    av_dlog(NULL, \" Codebooks: %d \\n\", vc->codebook_count);\n\n\n\n    vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks));\n\n    tmp_vlc_bits  = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits));\n\n    tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes));\n\n    codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands));\n\n\n\n    for (cb = 0; cb < vc->codebook_count; ++cb) {\n\n        vorbis_codebook *codebook_setup = &vc->codebooks[cb];\n\n        unsigned ordered, t, entries, used_entries = 0;\n\n\n\n        av_dlog(NULL, \" %u. Codebook\\n\", cb);\n\n\n\n        if (get_bits(gb, 24) != 0x564342) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook setup data corrupt.\\n\", cb);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        codebook_setup->dimensions=get_bits(gb, 16);\n\n        if (codebook_setup->dimensions > 16 || codebook_setup->dimensions == 0) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook's dimension is invalid (%d).\\n\",\n\n                   cb, codebook_setup->dimensions);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        entries = get_bits(gb, 24);\n\n        if (entries > V_MAX_VLCS) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook has too many entries (%u).\\n\",\n\n                   cb, entries);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        ordered = get_bits1(gb);\n\n\n\n        av_dlog(NULL, \" codebook_dimensions %d, codebook_entries %u\\n\",\n\n                codebook_setup->dimensions, entries);\n\n\n\n        if (!ordered) {\n\n            unsigned ce, flag;\n\n            unsigned sparse = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" not ordered \\n\");\n\n\n\n            if (sparse) {\n\n                av_dlog(NULL, \" sparse \\n\");\n\n\n\n                used_entries = 0;\n\n                for (ce = 0; ce < entries; ++ce) {\n\n                    flag = get_bits1(gb);\n\n                    if (flag) {\n\n                        tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n                        ++used_entries;\n\n                    } else\n\n                        tmp_vlc_bits[ce] = 0;\n\n                }\n\n            } else {\n\n                av_dlog(NULL, \" not sparse \\n\");\n\n\n\n                used_entries = entries;\n\n                for (ce = 0; ce < entries; ++ce)\n\n                    tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n            }\n\n        } else {\n\n            unsigned current_entry  = 0;\n\n            unsigned current_length = get_bits(gb, 5) + 1;\n\n\n\n            av_dlog(NULL, \" ordered, current length: %u\\n\", current_length);  //FIXME\n\n\n\n            used_entries = entries;\n\n            for (; current_entry < used_entries && current_length <= 32; ++current_length) {\n\n                unsigned i, number;\n\n\n\n                av_dlog(NULL, \" number bits: %u \", ilog(entries - current_entry));\n\n\n\n                number = get_bits(gb, ilog(entries - current_entry));\n\n\n\n                av_dlog(NULL, \" number: %u\\n\", number);\n\n\n\n                for (i = current_entry; i < number+current_entry; ++i)\n\n                    if (i < used_entries)\n\n                        tmp_vlc_bits[i] = current_length;\n\n\n\n                current_entry+=number;\n\n            }\n\n            if (current_entry>used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \" More codelengths than codes in codebook. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n        }\n\n\n\n        codebook_setup->lookup_type = get_bits(gb, 4);\n\n\n\n        av_dlog(NULL, \" lookup type: %d : %s \\n\", codebook_setup->lookup_type,\n\n                codebook_setup->lookup_type ? \"vq\" : \"no lookup\");\n\n\n\n// If the codebook is used for (inverse) VQ, calculate codevectors.\n\n\n\n        if (codebook_setup->lookup_type == 1) {\n\n            unsigned i, j, k;\n\n            unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions);\n\n\n\n            float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32));\n\n            float codebook_delta_value   = vorbisfloat2float(get_bits_long(gb, 32));\n\n            unsigned codebook_value_bits = get_bits(gb, 4) + 1;\n\n            unsigned codebook_sequence_p = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" We expect %d numbers for building the codevectors. \\n\",\n\n                    codebook_lookup_values);\n\n            av_dlog(NULL, \"  delta %f minmum %f \\n\",\n\n                    codebook_delta_value, codebook_minimum_value);\n\n\n\n            for (i = 0; i < codebook_lookup_values; ++i) {\n\n                codebook_multiplicands[i] = get_bits(gb, codebook_value_bits);\n\n\n\n                av_dlog(NULL, \" multiplicands*delta+minmum : %e \\n\",\n\n                        (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value);\n\n                av_dlog(NULL, \" multiplicand %u\\n\", codebook_multiplicands[i]);\n\n            }\n\n\n\n// Weed out unused vlcs and build codevector vector\n\n            codebook_setup->codevectors = used_entries ? av_mallocz(used_entries *\n\n                                                                    codebook_setup->dimensions *\n\n                                                                    sizeof(*codebook_setup->codevectors))\n\n                                                       : NULL;\n\n            for (j = 0, i = 0; i < entries; ++i) {\n\n                unsigned dim = codebook_setup->dimensions;\n\n\n\n                if (tmp_vlc_bits[i]) {\n\n                    float last = 0.0;\n\n                    unsigned lookup_offset = i;\n\n\n\n                    av_dlog(vc->avctx, \"Lookup offset %u ,\", i);\n\n\n\n                    for (k = 0; k < dim; ++k) {\n\n                        unsigned multiplicand_offset = lookup_offset % codebook_lookup_values;\n\n                        codebook_setup->codevectors[j * dim + k] = codebook_multiplicands[multiplicand_offset] * codebook_delta_value + codebook_minimum_value + last;\n\n                        if (codebook_sequence_p)\n\n                            last = codebook_setup->codevectors[j * dim + k];\n\n                        lookup_offset/=codebook_lookup_values;\n\n                    }\n\n                    tmp_vlc_bits[j] = tmp_vlc_bits[i];\n\n\n\n                    av_dlog(vc->avctx, \"real lookup offset %u, vector: \", j);\n\n                    for (k = 0; k < dim; ++k)\n\n                        av_dlog(vc->avctx, \" %f \",\n\n                                codebook_setup->codevectors[j * dim + k]);\n\n                    av_dlog(vc->avctx, \"\\n\");\n\n\n\n                    ++j;\n\n                }\n\n            }\n\n            if (j != used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \"Bug in codevector vector building code. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n            entries = used_entries;\n\n        } else if (codebook_setup->lookup_type >= 2) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \"Codebook lookup type not supported. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n// Initialize VLC table\n\n        if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Invalid code lengths while generating vlcs. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        codebook_setup->maxdepth = 0;\n\n        for (t = 0; t < entries; ++t)\n\n            if (tmp_vlc_bits[t] >= codebook_setup->maxdepth)\n\n                codebook_setup->maxdepth = tmp_vlc_bits[t];\n\n\n\n        if (codebook_setup->maxdepth > 3 * V_NB_BITS)\n\n            codebook_setup->nb_bits = V_NB_BITS2;\n\n        else\n\n            codebook_setup->nb_bits = V_NB_BITS;\n\n\n\n        codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits;\n\n\n\n        if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits,\n\n                            entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits),\n\n                            sizeof(*tmp_vlc_bits), tmp_vlc_codes,\n\n                            sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes),\n\n                            INIT_VLC_LE))) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Error generating vlc tables. \\n\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return 0;\n\n\n\n// Error:\n\nerror:\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return ret;\n\n}\n", "idx": 10175, "substitutes": {"vc": ["att", "av", "wd", "coll", "inv", "fax", "ev", "irm", "VC", "voc", "px", "v", "pp", "vy", "vol", "vr", "wr", "fc", "vl", "bc", "csv", "ct", "vine", "ver", "vg", "sky", "vert", "vm", "lc", "cc", "hw", "ib", "wx", "cv", "ve", "xp", "fw", "sv", "vt", "vv", "vet", "serv", "form", "ac", "ht", "tv", "act", "ow", "etc", "iv", "rt", "ctx", "vi", "uv", "c", "vd", "ctrl", "vo", "ud", "ee", "nv", "vs", "xc", "vp", "lv", "pc", "cs", "vid", "wcs", "ant", "conv", "cmd"], "cb": [" coff", "func", "bf", "conf", " cc", "CV", "tc", "conn", "cf", "job", "coord", "ebin", "nb", "ck", "cur", "cfg", "pb", "ob", "fc", "bp", "bc", "nc", "gov", "bj", "cd", "abc", " count", "uc", " rc", "bb", "eb", "ub", "tn", "cc", "unc", " eb", "rc", "org", "dt", "cv", "buf", "cp", "count", "conv", "obb", "etc", "kb", "kk", "crop", "fp", "ctx", "ctrl", "c", "wb", "abb", "cod", "db", "rb", "CB", "callback", "bn", "bg", "kw", "xc", "gc", "ctr", "lb", "cn", "cmd"], "tmp_vlc_bits": ["tmp_vlc__its", "tmp_vlc__codes", "tmp_vlci_its", "tmp_vlc_parts", "tmp_vlc_its", "tmp_vlc__bytes", "tmp_vlc_tops", "tmp_vlc__parts", "tmp_vlci_tops", "tmp_vlcs_bytes", "tmp_vlcs_codes", "tmp_vlcs_bits", "tmp_vlci_parts", "tmp_vlci_bytes", "tmp_vlci_codes", "tmp_vlc__tops", "tmp_vlc_data", "tmp_vlc_bytes", "tmp_vlcs_data", "tmp_vlc__bits", "tmp_vlci_bits"], "tmp_vlc_codes": ["tmp_vlc_cats", "tmp_vlp_codes", "tmp_vlc__codes", "tmp_vlc32mods", "tmp_vlc32objects", "tmp_vlcs_mods", "tmp_vlcs_objects", "tmp_vlc_mods", "tmp_vlcs_names", "tmp_vlcs_cats", "tmp_vlp_code", "tmp_vlc32codes", "tmp_vlp__bits", "tmp_vlcs_ints", "tmp_vlp_objects", "tmp_vlc_objects", "tmp_vlcs_codes", "tmp_vlcs_bits", "tmp_vlc_names", "tmp_vlp_bits", "tmp_vlc5bits", "tmp_vlc_code", "tmp_vlc5ints", "tmp_vlc__mods", "tmp_vlc__objects", "tmp_vlp__code", "tmp_vlc__cats", "tmp_vlc5names", "tmp_vlc_ints", "tmp_vlc__code", "tmp_vlc5codes", "tmp_vlc__bits", "tmp_vlc32cats", "tmp_vlp__objects", "tmp_vlp__codes"], "gb": ["GB", "bf", "sb", "py", "gh", "html", "goo", "gpu", "px", "gif", "git", "nb", "cfg", "gd", "pg", "csv", "vg", "gov", "jpg", "gnu", "gs", "gt", "deg", "eg", "vm", "eb", "ub", "fb", "ib", "rg", "cv", "buf", "img", "g", "Gb", "mb", "bytes", "hub", "storage", "kb", "gm", "ha", "bridge", "gu", "ctx", "sys", "hog", "tg", "wb", "vd", "db", "rb", "yg", "got", "bg", "ruby", "pi", "gc", "hw", "gg", "bm", "gy"], "codebook_multiplicands": ["codebook_multICates", "codebook_ipliccates", "codebook_multiplicants", "codebook_multiplistands", "codebook_multiplicates", "codebook_multiccand", "codebook_iplicants", "codebook_multiplICants", "codebook_multiplICates", "codebook_multiccands", "codebook_iplicates", "codebook_iplicents", "codebook_multiplicoand", "codebook_ipliccants", "codebook_multiccases", "codebook_ipliccands", "codebook_multICanded", "codebook_multiplICases", "codebook_multiplistants", "codebook_multiplicoands", "codebook_multicants", "codebook_multiccants", "codebook_multiplICand", "codebook_multiplacand", "codebook_multiplistates", "codebook_multicanded", "codebook_multiplicents", "codebook_multiplicoanded", "codebook_multiplicityand", "codebook_multipliccates", "codebook_multICands", "codebook_multiplicityanded", "codebook_multiplacands", "codebook_multipliccases", "codebook_multiplicityands", "codebook_multICand", "codebook_multiplicand", "codebook_multicates", "codebook_multiplistents", "codebook_multiplacants", "codebook_multicases", "codebook_multicands", "codebook_multiplICands", "codebook_multiplicases", "codebook_multiplacases", "codebook_iplicands", "codebook_multipliccand", "codebook_multiplicityents", "codebook_multiplICanded", "codebook_multipliccants", "codebook_ipliccents", "codebook_multiplicityants", "codebook_multiplicoates", "codebook_multiplicityates", "codebook_multiplicanded", "codebook_multipliccands", "codebook_multipliccents", "codebook_multicand"], "codebook_setup": ["codebooks_upload", "codebook_upload", "codebook_store", "codebook_settings", "codebook_prep", "codebooks_prep", "codecell_set", "codebook_info", "codecell_info", "codebooks_store", "codebook2info", "codebooks_handle", "codebook_set", "codecell_setup", "codebooks_info", "codebooks_Setup", "codebook2settings", "codebooks_settings", "codebook2Setup", "codebook_Setup", "codebook2setup", "codebooks_setup", "codebook_init", "codecell_init", "codebooks_init", "codebook_handle"], "ordered": ["r", "done", "cf", "coord", "f", "err", "id", "version", "rows", "cd", "bb", "order", "cv", " unused", "count", "g", "index", "bytes", " tid", "ref", "box", "c", "checked", "db", "CB", "row", "rb", "ord", "cmd"], "t": ["ts", "p", "tc", "f", "type", "typ", "tm", "T", "tp", "tz", "tt", "tn", "dt", "tap", "n", "total", "tmp", "bt", "td", "tu", "tf", "wt", "tg", "m", "c", "txt", "ta", "ti", "ptr"], "entries": ["Entries", "rentrs", "entsrance", "ntry", "ntries", "enties", "entrs", "Entrys", "entsrys", "rentries", "entsrs", "ntrys", " Entrys", "centies", "entry", "Entrance", "entrys", "rentrys", "entsried", " Entries", "centencies", " Entrance", " entrys", " enties", "entsry", "Entried", " Entried", "rentures", "entsries", "Entencies", "centrys", "Enties", "Entlements", "ntlements", "entures", "Entures", "entencies", "entslements", "entlements", "centries", "Entry", "entrance", "entried", " entencies", "Entrs", "entsures"], "used_entries": ["used2enties", "used_ntrys", "used_Entries", "used2pentrys", "used_Entrys", "used2penties", "used_ntries", "used_pentrys", "used2pentrs", "used_pentrs", "used_Entrs", "used2entrs", "used_enties", "used_nties", "used2entries", "used_entrys", "used_entrs", "used_ntrs", "used_pentries", "used2entrys", "used2pentries", "used_Enties", "used_penties"]}}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "substitutes": {"f": ["r", "p", "bf", "h", "x", "conf", "cf", "ft", "ff", "v", "z", "fc", "xf", "rf", "lf", "l", "uf", "fr", "fo", "window", "fb", "out", "o", "sf", "fs", "b", "file", "ac", "fm", "fd", "full", "fx", "q", "af", "tf", "fp", "fi", "F", "m", "c", "t", "base", "e", "fac", "w", "fw"], "spapr": ["expaprer", "spapsreq", "ispapperr", "Spopr", "pseaprt", "pseaprd", "ispaprr", "sparpry", "scopeapereq", "spapri", "spapeerr", "exprapra", "ispapr", "espapsR", "expamprar", "spraplr", "sprapren", "espapren", "spabren", "spamprov", "expamppr", "exprapr", "expamprer", "spapart", "spapperfr", "spacherov", "sprapror", " spapR", "spaprar", "expapr", "spaphrb", "spapppr", "spapperr", "spaparu", "spipry", "spapra", "sparmra", "scopeapelr", "Spaprel", "sparpR", "spapperner", "pseapr", "scopeapr", "spoprel", "spamner", "ispamppr", "spamprar", "ispapperrr", " spipR", "spcapR", "spapery", "espapsr", "spapyr", " spaperr", "spaphrel", " spaprb", "ispapdr", "spaceamfr", "spapry", "spipprb", "spapdr", "sparmror", "spachepr", "espaprer", "spacher", "spapereq", "spaprel", "spapperrel", "spabrer", "spartrt", "spartr", "spcappr", " spaplr", "scopeaper", "ispappr", "spapard", "spaprb", "spabr", "spapR", "spcapro", "spappr", "spippr", "Spapr", "spapperpr", "spaprer", "spcaperr", "spamr", "spaphr", " spcappr", "spapreq", "spaceapr", "spapsrar", "spaprt", "spapyror", "spapyra", "spraprt", "spaceapfr", "espapsren", "spapelr", "ispapperdr", "spaprov", "sparmr", "expaprar", "spaprd", "spapru", "spapror", "scopeapeer", " spipry", "expapra", "ispapcr", " spapro", "spartru", "ispapri", "spapeR", "spcapdr", "spapprar", "sprappr", " spiprb", "spaceamr", "spapperrr", "spacheri", "spapyrd", "pserapru", "scopeaplr", " spapren", "sparpr", " spapry", " spcaperr", "pserapr", "spapperri", " spcapro", "sparmner", "spamrel", " spcapren", "spapeer", "expaprd", "spaptlr", "scopeapreq", "sprapra", " spipr", "spipr", " spcaplr", "espapr", "spapter", "spartrd", "spaceaprel", "spiprb", " spappr", "spapero", "spcaprr", "ispampr", "spapro", "spaperr", "spoprb", "spabR", "spappcr", "espapR", "spapsR", "spaceapner", "spapspr", "spapar", "spapner", "ispappercr", "spcapcr", "spapsr", " spcapR", "spaceamner", "spraprd", "expampr", "pseapru", "spaperb", "spaceamrel", "spapsren", "spcaplr", "spapperrov", "pseraprd", "spachelr", "spapprer", "spapren", "spacheren", "sparmfr", "spaplr", "sprapr", "spapfr", "Spoprel", "spamprer", "spopr", "sprapru", "spampri", "spaptreq", "spipR", "ispaprov", "spaptr", "spampr", "exprapror", "spcapr", "expappr", "sparmrel", "expraprd", "espapsrer", "ispampri", "Spaprb", "spapsrer", "spipro", "spappdr", "spiperr", "sparmrd", "spaprr", "spappren", "spapser", "spamppr", "spapcr", "spapperdr", "spapprr", "spaper", " spcapr", "spappercr", "expapror", "Spoprb", "ispamprov", "spipprel", "spamfr", "spappR", "pseraprt", "spcapren", "sparprb", "spapslr"], "max_ns": [" max2mins", "max__ns", "max_mins", " max_ts", "max_ts", "max2mins", " max_mins", " max_sts", "maxNsts", "max_sts", "max2ns", "max2ts", "maxNms", "max2ms", " max_fs", "max__ts", " max2ts", "maxNfs", "max__mins", "max_fs", " max_ms", "maxNns", " max2ns", " max2ms", "max_ms", "max__ms"], "chunkstart": ["chunkslength", "achunkstart", "chunksoffset", "achuncoffset", "chuncstart", "achuncpad", "chunkstop", "chnightstart", "chartstep", "chunkpad", "chreamsize", "ichunkstart", "chramstart", "chunkentry", "achuncstart", "chunksshift", "chunksize", "chblockstart", "chunksend", "thackend", "frunkStart", "chunksstop", "chartentry", "Chunkentry", "ChunkStart", "ichblockspace", "chartinit", "chankstart", "chulkend", "chackstart", "thunkstart", "thunksize", "ichblockstart", "Chunkend", "chowend", "ichunkStart", "frankstart", "chulkstart", "chreamStart", "chunkspad", "Chunksize", "chanklength", "chblockspace", "ichblockst", "chairstart", "thackstart", "chartStart", "franklength", "thackStart", "chblockst", "Chunksstart", "Chunksstop", "chackspace", "chairstop", "chnightsize", "chackst", "achartstop", "thunkend", "chreamentry", "chackend", "chreamstart", "chankshift", "chnightoffset", "chacklength", "chartstart", "chunkst", "chraminit", "achunkstep", "chunksentry", "chuncoffset", "achuncsize", "thunkStart", "chunksStart", "frankshift", "Chunkstop", "achartinit", "chankspace", "chramstep", "chartstop", "ichunkspace", "ChunksStart", "chunkoffset", "achunkstop", "chunkspace", "chackshift", "chunkinit", "chowStart", "chuncsize", "ichunkst", "chunkStart", "Chunksentry", "achunkinit", "frankStart", "Chunkssize", "chairinit", "chulkstop", "achartstep", "chairstep", "frunkshift", "chunkstep", "chramstop", "chackStart", "frunkstart", "achartstart", "thacksize", "chunklength", "chowstart", "chartsize", "chunksstart", "chnightpad", "frunklength", "chblockStart", "chunkssize", "Chunkstart", "ichblockStart", "achunksize", "chowsize", "achunkpad", "chankst", "chulkStart", "chunkshift", "chunkend", "achunkoffset", "chacksize", "chankStart", "Chunksend", "chuncpad"], "invalidstart": ["incompleteStart", "INvalidStart", "invalwindow", "inunkwindow", "invalStart", " invalidwind", "infumentpart", "INvalstop", "initerStart", "invertend", "infumentstop", "invertstart", "inqualstart", "INvalidstart", "invalidpart", "inqualStart", "initerstop", "incompleteend", "invalpart", "invalidend", "incompleteslice", "INvalstart", "infvalidpart", "INvalStart", "initerpart", " invalidst", "INvalidend", "infumentStart", "invalidstop", "invalwind", "invalidslice", "inumentstart", "inumentstop", "INvalend", "inumentpart", "invalslice", "invalidStart", "invalidst", "incompletewind", " incompletestart", " invalidend", "infvalidstart", "invalstart", "invertwind", "invalidwindow", "invalstop", "inunkend", "invertst", "initerstart", "inumentStart", "invalend", "infvalidStart", "INvalidwindow", "inunkstart", "incompletestart", "INvalslice", "infvalidstop", "INvalidslice", "invalidwind", "inunkstop", "INvalwindow", " incompleteend", " incompletest", "incompletest", "inqualslice", "invertwindow", "invalst", " incompletewind", "INvalidstop", "invertstop", "infumentstart"], "index": ["update", "x", "instance", "localhost", "condition", "unit", "subject", "number", "ind", "seed", "capacity", "mix", "ix", "Index", "thread", "close", "create", "count", "remote", "d", "now", "find", "loc", "row", "valid", "level", "item", "search", "select", "value", "insert", "tree", "link", "test", "speed", "name", "connect", "new", "root", "raw", "seek", "scan", "act", "handle", "path", "info", "tx", "set", "open", "draw", "status", "block", "port", "action", "fail", "host", "init", "i", "id", "location", "command", "position", "scroll", "parent", "ex", "process", "slice", "size", "iter", "is", "prefix", "try", "ctx", "IND", "doc", "length", "dimension", "active", "present", "engine", "list", "timeout", "eng", "document", "request", "read", "connection", "add", "version", "reason", "height", "page", "ion", "query", "date", "val", "example", "available", "key", "n", "in", "initial", "loop", "event", "si", "get", "see", "local", "offset", "connected", "check", "pos", "num", "point", "context", "address", "zero"], "examined": ["Examied", "exagied", "exachmented", "exAMinated", "exumine", "exAMine", "eximided", "exumining", "exomered", "examided", "eximined", " exachined", "expmmented", "exAMided", "sexamined", "sexamided", "eximinated", "exagined", "exachining", "exAMined", "examlied", "exAMination", "exachined", "exumination", "exammented", "seximided", "examinated", " examlied", "Examined", "exomied", "Expmied", "Expmined", "exfamided", "seximined", "sexumining", " exammented", " exachining", "expmining", "exfamined", " exachlied", "exomining", "sexamination", "Examining", "examining", "expmlied", "expmied", "exAmlied", "seximmented", "sexamine", "sexumined", "sexaminated", "expmered", "exumined", "exAmined", "Examered", "Expmining", " exachmented", "exAmmented", "examered", "sexamining", "sexumination", "expmined", "exfammented", "exAmining", "sexammented", "exagining", "exAMmented", "sexumine", "examine", "exAMining", " examining", "eximmented", "examination", "Expmered", "examied", "seximinated", "exfaminated", "exomined", "exachlied", "exagered"]}}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 10190, "substitutes": {"domain": ["controller", "where", "uri", "unit", "rank", "rule", "de", "site", "url", "dom", "country", "folder", "handler", "role", "network", "name", "command", "bound", "group", "date", "family", "root", "topic", "example", "channel", "policy", "owner", "origin", "change", "range", "label", "server", "Domain", "zone", "prefix", "net", "property", "resource", "email", "index", "pattern", "term", "y", "ca", "dn", "module", "m", "target", "gate", "chain", "status", "db", "base", "port", "table", "plain", "cookie", "client", "magic", "host", "AIN", "address", "scope"], "type": ["no", "month", "where", "types", "ype", "feature", "value", "tag", "link", "rule", "test", "typ", "id", "handler", "role", "country", "pe", "method", "version", "name", "tp", "format", "command", " Type", "function", "page", "date", "family", "ty", "error", "key", "policy", "range", "origin", "owner", "change", "time", "count", "size", "resource", "file", "index", " TYPE", "handle", "TYPE", "what", "field", "try", "Type", "y", "attribute", "none", "style", "kind", "module", "ime", "t", "part", "status", "port", "table", "description", "message", "ping", "class", "state", "address", "socket", "scope"], "protocol": ["proticle", "prototype", "phyocol", "cryptocol", "portension", "rotocol", "propicle", "Protprot", "protport", "tocol", "propotype", "phyprot", "extocol", " protport", "extport", "cryptprot", "tport", "portotype", "phyotype", "protprot", "scheocol", "Protol", " protol", "porticle", "totype", "rotension", "portport", "protol", "extotype", "cryptol", "protension", " protprot", "cryptport", "Protocol", "Prototype", "portocol", "tension", "Protport", "rotport", "scheotype", "rototype", "propocol", "phyport", "scheicle", "extprot"], "ret": ["dr", "flag", "cat", "err", "url", "gt", "Ret", "dt", "rm", "nl", "total", "print", "def", "arr", "ref", "reg", "t", "backed", "len", "ter", "cmd", "mem", "value", "cont", "tech", "code", "expr", "nil", "desc", "ry", "rt", "set", "hash", "it", "txt", "status", "res", "Return", "report", "pret", "off", " Ret", "gov", "result", "str", " RET", "deg", "reply", "rem", "lag", "out", "nt", "reflect", "tmp", "iter", "mt", "try", "tr", "bool", "elt", "prop", "nz", "arg", "error", "r", "ts", "att", "cb", "RET", "ft", "rev", "f", "success", "re", "j", "usr", "val", "rets", "back", "ext", "lit", "get", "detail", "reset", "num", "cert", "det", "resp", "alt"]}}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n", "idx": 10192, "substitutes": {"env": ["dev", "conf", "pres", "proc", "conn", "eng", "ev", "v", "environment", "gov", "en", "code", "window", "eg", "org", "qt", "ew", "cv", "cp", "server", "enc", "serv", "net", "viron", "ec", "eu", "def", "js", "ctx", "ds", "et", "sc", "anc", "nv", "vs", "context", "e", "vp", "scope"], "buf": ["cb", "seq", "mem", "ff", "err", "v", "read", "alloc", "pb", "data", "str", "result", "uf", "map", "raw", "fb", "cv", "bar", "cast", "buff", "b", "bytes", "arr", "queue", "ref", "Buff", "br", "vec", "wb", "txt", "text", "buffer", "batch", "rb", "rw", "block", "bn", "db", "xff", "msg", "doc", "ptr", "Buffer", "img", "cmd"], "buf_len": ["buf2fin", " buf_fin", "buf_length", " buf2length", " buf2elt", "buf_en", "Buffer_length", " buf_elt", " buf_length", "buf2elt", "buf5length", "Buffer_len", "buf5fin", " buf2len", "buf2length", "Buffer_en", "buf_fin", "buf_elt", "buf5elt", "buf2len", "buf5len", " buf2fin"], "cpu": ["p", "np", "proc", "CPU", "gpu", "px", "alloc", "ck", "cow", "processor", "nc", "uc", "cum", "cn", "cu", "nic", "process", "cp", "CP", "prof", "core", "uu", "pu", "ctx", "aco", "nu", "anc", "ork", "clock", "pkg", "gc", "pc", "mu", "hw", "nz", "jp", "us"], "cs": ["ts", "cons", "caps", "cus", "tc", "cf", "rs", "ls", "nc", "ps", "ct", "cks", "gs", "acs", "ys", "lc", "cu", "sts", "cc", "cv", "cp", "cms", "CS", "fs", "ics", "acts", "ac", "ec", "s", "bs", "ins", "act", "ms", "ks", "ca", "css", "sys", "js", "ctx", "hs", "ds", "c", "sc", "Cs", "vs", "wcs", "ctr", "spec", "qs", "cn", "ns"], "hc": ["strac", " hcc", "hco", "oht", "Hdc", "thco", "ohlc", "htac", "hhlc", "thac", " hco", " hlc", "llcod", "htci", "hlc", "hhc", " ht", "hcod", " hci", " hcod", "ohc", "strc", "Hc", "htc", "llc", "hht", "strcc", " hdc", "hce", "thce", "eachc", "hcc", "Hcc", "Hci", "handac", "ht", "ohcache", "hac", " hac", "strdc", "handgc", " hcache", "hci", "eachac", "hhcache", "Hac", "llac", "llgc", "handcod", "htdc", "eachce", "handc", "hdc", "thc", " hce", " hgc", "hgc", "hcache", "eachco"], "pvinfo": ["pvinato", "pvinfty", "Pvinfo", "pvise", "pvanato", "Pvinato", "pcinato", "pbine", "pcinco", "pvyfo", "pvaninfo", "pisenfo", "pginf", " pginfty", "pvinmo", "pginato", "pisenmo", "pcinfo", "pbinf", "pvisinfo", " pgininfo", "Pvinco", "pvanfo", "Pginato", "piseninfo", " pvine", "pvanco", "pvinf", "pginfty", "Pginfo", "pbininfo", " pvinf", "pvymo", "pginfo", "pvyinfo", "pvininfo", "pvine", " pvinmo", " pginmo", "pcininfo", "pvisfo", "Pvininfo", "pvinco", "pisenfty", "Pgininfo", "pginco", "pbinfo", "pgininfo", " pginfo", " pvinfty", "pvyfty", "pvisf", " pginf", "Pginco", " pvininfo", " pgine", "pginmo", "pgine"]}}
{"project": "qemu", "commit_id": "1bcef683bf840a928d633755031ac572d5fdb851", "target": 0, "func": "void process_incoming_migration(QEMUFile *f)\n\n{\n\n    if (qemu_loadvm_state(f) < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        exit(0);\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    incoming_expected = false;\n\n\n\n    if (autostart) {\n\n        vm_start();\n\n    } else {\n\n        runstate_set(RSTATE_PRE_LAUNCH);\n\n    }\n\n}\n", "idx": 10194, "substitutes": {"f": ["r", "p", "bf", "h", "cf", "fc", "rf", "lf", "l", "fr", "fb", "fa", "sf", "fs", "fab", "b", "fn", "file", "fm", "d", "fd", "af", "fp", "tf", "fi", "F", "m", "c", "t", "e", "fw"]}}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv40_decode_mb_info(RV34DecContext *r)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int q, i;\n\n    int prev_type = 0;\n\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n\n    int blocks[RV34_MB_TYPES] = {0};\n\n    int count = 0;\n\n\n\n    if(!r->s.mb_skip_run)\n\n        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;\n\n\n\n    if(--r->s.mb_skip_run)\n\n         return RV34_MB_SKIP;\n\n\n\n    if(r->avail_cache[6-1])\n\n        blocks[r->mb_type[mb_pos - 1]]++;\n\n    if(r->avail_cache[6-4]){\n\n        blocks[r->mb_type[mb_pos - s->mb_stride]]++;\n\n        if(r->avail_cache[6-2])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;\n\n        if(r->avail_cache[6-5])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;\n\n    }\n\n\n\n    for(i = 0; i < RV34_MB_TYPES; i++){\n\n        if(blocks[i] > count){\n\n            count = blocks[i];\n\n            prev_type = i;\n\n        }\n\n    }\n\n    if(s->pict_type == AV_PICTURE_TYPE_P){\n\n        prev_type = block_num_to_ptype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for P-frame\\n\");\n\n    }else{\n\n        prev_type = block_num_to_btype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for B-frame\\n\");\n\n    }\n\n    return 0;\n\n}\n", "idx": 10213, "substitutes": {"r": ["ren", "p", "or", "rer", "h", "cr", "dr", "ra", "rs", "attr", "ar", "v", "rr", "f", "err", "ret", "vr", "z", "re", "rec", "l", "rh", "result", "R", "j", "fr", "usr", "nr", "rem", "run", "sr", "rc", "u", "n", "rg", "o", "obj", "er", "g", "d", "b", "resource", "ur", "tr", "ro", "rt", "gr", "mr", "rar", "kr", "it", "br", "m", "c", "t", "res", "rb", "rw", "e", "w", "rd", "rel"], "s": ["options", "sb", "ls", "sh", "sv", "as", "er", "d", "has", "scripts", "sys", "js", "c", "t", "series", "state", "ms", "w", "se", "sort", "ins", "ns", "less", "session", "ats", "conf", "sw", "qs", "settings", "ps", "parts", "sq", "a", "src", "sl", "fs", "app", "set", "stats", "ds", "sc", "res", "services", "vs", "cs", "ims", "tes", "p", "span", "ar", "its", "sr", "tests", "space", "o", "is", "g", "b", "st", "ions", "os", "times", "y", "sn", "ctx", "hs", "styles", "ed", "spec", "e", "ts", "self", "rs", "f", "v", "ss", "es", "als", "j", "gs", "sts", "n", "css", "m", "S", "bs", "words", "sports"], "gb": ["boxes", "GB", "cb", "bf", "sb", "py", "bd", "rs", "goo", "gif", "cm", "nb", "cfg", "gd", "pg", "csv", "vg", "gs", "gg", "gt", "eg", "bb", "ib", "rg", "cv", "buf", "img", "sv", "bt", "g", "b", "gz", "Gb", "mb", "bytes", "ch", "storage", "kb", "gm", "ctx", "tg", "phy", "gam", "wb", "ubis", "db", "rb", "yg", "bg", "ruby", "gc", "bs", "bm", "gy", "by"], "q": ["p", "limit", "h", "Q", "qq", "ue", "conf", "ql", "qual", "comment", "seq", "dq", "quote", "v", "qu", "z", "iq", "entry", "l", "query", "question", "qv", "lock", "quit", "qt", "u", "qa", "quant", "sq", "buf", "count", "g", "b", "cache", "ch", "que", "quick", "queue", "quer", "quest", "it", "c", "qi", "t", "requ", "quality", "aq", "pkg", "k", "qs"], "i": ["ui", "di", "p", "cli", "x", "list", "init", "instance", "ma", "uri", "f", "v", "gi", "ri", "id", "ic", "ai", "ind", "ei", "ii", "l", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "multi", "bi", "in", "n", "o", "count", "iter", "sym", "b", "hi", "si", "index", "li", "y", "ini", "it", "ci", "m", "c", "qi", "ip", "mi", "ij", "zi", "t", "batch", "ti", "pi", "series", "ki", "me"], "blocks": ["boxes", "units", "lines", "uses", "images", "games", "types", "aps", "pres", "outs", "stones", "pins", "users", "workers", "qs", "frames", "data", "pages", "days", "bys", "rows", "jobs", "iques", "heads", "uploads", "amps", "Blocks", "ensions", "bl", "loads", "books", "builders", "mates", "maps", "modules", "fs", "actions", "views", "plugins", "values", "bytes", "offs", "stores", "asks", "ms", "times", "flows", "guards", "finals", "keys", "styles", "limits", "masters", "bits", "banks", "ocks", "block", "items", "chains", "locks", "vs", "usters", "groups", "bs", "assets", "versions", "ins"], "mb_skip_run": ["mb_skip_pos", "mb_skip__runs", "mb_skiphasruns", "mb_no_round", "mb_skiphasrun", "mb_skip_cycle", "mb_no_cycle", "mb_skip__play", "mb_skiphasround", "mb_no_play", "mb_skip_runner", "mb_skip__run", "mb_no_runs", "mb_skip_runs", "mb_skiphasplay", "mb_no_run", "mb_no_runner", "mb_skip_play", "mb_skip__pos", "mb_skip_round", "mb_no_pos"], "mb_type": ["mblicformat", "mb_format", "mbixerror", " MB_type", "mb_time", "mb_model", "mbixrel", "bb_types", "mg_types", "emb_error", "mblicname", "emb_type", "mb_types", "mblictype", "mbixname", "mb_buffer", "mg_model", "mbixtype", "mb_tag", " MB_name", " MB_format", "bb_buffer", " MBlictag", "mb_rel", " MB_tag", " MBlictype", " MBlicname", "mbttype", "mblictag", "mb_error", "mb_name", "mbttime", "emb_rel", "bb_type", "mbtbuffer", "emb_name", "mbttypes", "bb_time", " MBlicformat", "mg_type"], "mb_pos": ["mb2loc", "bb2loc", "mbacPos", "bb_loc", "emb_pro", "mb_cond", "mbPopos", "mb2type", "mb_px", "emb_loc", "emb_pat", "mbactype", "mb_mon", "mb_pat", "mb__po", "mb_po", "jpg_mon", "emb_pi", "mb_post", "bb2pos", "mb_pro", "mb__pos", "emb_px", "emb_pos", "bb_pos", "mb__loc", "mbPoloc", "mbobjpose", "mb__pat", "jpg_pos", "mb_loc", "bb2type", "mb2pos", "mbobjmon", "emb_po", "mbobjpos", "emb_cond", "bb_Pos", "mbPopi", "mbacloc", "mbobjpost", "bb_type", "mb_pi", "mbPopro", "mb2Pos", "jpg_pose", "jpg_post", "mb_Pos", "mbacpos", "bb2Pos", "mb_pose"], "mb_stride": ["mb_strise", "mb_lenime", "mb_drride", "mbgstride", "mb_lenide", "mb_strim", "mbgstrides", "mb_lenride", "mb_sysise", "mb_brime", "mb_strime", "mb_sprad", "mb_fride", "mb_lenim", "mb_Strride", "mb_frim", "mb_Strides", "mb_Stride", "mb_suspad", "mb_syside", "mb_brise", "mb_brpace", "mb_spride", "mbgstides", "mb_stid", "mb_Strid", "mb_brim", "mb_drid", "mb_strid", "mb_STRide", "mb_brad", "mb_brider", "mb_STRider", "mb_sysride", "mb_susppace", "mb_strride", "mbgstrride", "mb_suspide", "mb_strides", "mbgstid", "mb_sprride", "mbgstide", "mb_stide", "mb_STRride", "mb_drides", "mb_stides", "mb_frride", "mb_suspride", "mb_strpace", "mb_sysider", "mb_brride", "mbgstrid", "mb_strad", "mb_frime", "mb_STRise", "mb_dride", "mb_bride", "mb_strider", "mb_sprpace"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,\n\n                                        uint8_t *dst,\n\n                                        long width, long height,\n\n                                        long srcStride1, long srcStride2,\n\n                                        long srcStride3, long dstStride)\n\n{\n\n    x86_reg x;\n\n    long y,w,h;\n\n    w=width/2; h=height;\n\n    for (y=0;y<h;y++) {\n\n        const uint8_t* yp=src1+srcStride1*y;\n\n        const uint8_t* up=src2+srcStride2*(y>>2);\n\n        const uint8_t* vp=src3+srcStride3*(y>>2);\n\n        uint8_t* d=dst+dstStride*y;\n\n        x=0;\n\n#if COMPILE_TEMPLATE_MMX\n\n        for (;x<w-7;x+=8) {\n\n            __asm__ volatile(\n\n                PREFETCH\"   32(%1, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%2, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%3, %0)          \\n\\t\"\n\n                \"movq      (%1, %0, 4), %%mm0   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq         (%2, %0), %%mm1   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq         (%3, %0), %%mm2   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"movq            %%mm0, %%mm3   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq            %%mm1, %%mm4   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq            %%mm2, %%mm5   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"punpcklbw       %%mm1, %%mm1   \\n\\t\" /* U0U0 U1U1 U2U2 U3U3 */\n\n                \"punpcklbw       %%mm2, %%mm2   \\n\\t\" /* V0V0 V1V1 V2V2 V3V3 */\n\n                \"punpckhbw       %%mm4, %%mm4   \\n\\t\" /* U4U4 U5U5 U6U6 U7U7 */\n\n                \"punpckhbw       %%mm5, %%mm5   \\n\\t\" /* V4V4 V5V5 V6V6 V7V7 */\n\n\n\n                \"movq            %%mm1, %%mm6   \\n\\t\"\n\n                \"punpcklbw       %%mm2, %%mm1   \\n\\t\" /* U0V0 U0V0 U1V1 U1V1*/\n\n                \"punpcklbw       %%mm1, %%mm0   \\n\\t\" /* Y0U0 Y1V0 Y2U0 Y3V0*/\n\n                \"punpckhbw       %%mm1, %%mm3   \\n\\t\" /* Y4U1 Y5V1 Y6U1 Y7V1*/\n\n                MOVNTQ\"          %%mm0,  (%4, %0, 8)    \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 8(%4, %0, 8)    \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm2, %%mm6   \\n\\t\" /* U2V2 U2V2 U3V3 U3V3*/\n\n                \"movq     8(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U2 Y V2 Y U2 Y V2*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U3 Y V3 Y U3 Y V3*/\n\n                MOVNTQ\"          %%mm0, 16(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 24(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"movq            %%mm4, %%mm6   \\n\\t\"\n\n                \"movq    16(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm5, %%mm4   \\n\\t\"\n\n                \"punpcklbw       %%mm4, %%mm0   \\n\\t\" /* Y U4 Y V4 Y U4 Y V4*/\n\n                \"punpckhbw       %%mm4, %%mm3   \\n\\t\" /* Y U5 Y V5 Y U5 Y V5*/\n\n                MOVNTQ\"          %%mm0, 32(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 40(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm5, %%mm6   \\n\\t\"\n\n                \"movq    24(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/\n\n                MOVNTQ\"          %%mm0, 48(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 56(%4, %0, 8)   \\n\\t\"\n\n\n\n                : \"+r\" (x)\n\n                : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d)\n\n                :\"memory\");\n\n        }\n\n#endif\n\n        for (; x<w; x++) {\n\n            const long x2 = x<<2;\n\n            d[8*x+0] = yp[x2];\n\n            d[8*x+1] = up[x];\n\n            d[8*x+2] = yp[x2+1];\n\n            d[8*x+3] = vp[x];\n\n            d[8*x+4] = yp[x2+2];\n\n            d[8*x+5] = up[x];\n\n            d[8*x+6] = yp[x2+3];\n\n            d[8*x+7] = vp[x];\n\n        }\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n#endif\n\n}\n", "idx": 10233, "substitutes": {"src1": ["sr2", "source1", "sr1", "srcOne", "srOne", "sourceOne", "sr0", "rc1", " srcOne", "src0", "rcOne", " src0", "rc0", "rc2", "source2"], "src2": ["sr2", "src4", "rc4", "source1", "sr1", "rc3", "rc1", "source3", "sr3", " src4", "src0", "source4", " src0", "rc0", "source0", "rc2", "source2"], "src3": ["src4", "rc4", "rc03", "source1", "src03", "rc3", "rc1", "source3", " src4", " src03", "source4", "source03", "rc2", "source2"], "dst": ["ddstr", "ttr", "rth", "ddest", "tst", "rtr", "tth", "dtr", "dth", "lsts", " dth", "dddest", "dcr", "dstr", " dcr", "lst", " dtr", "tcr", "lstr", "rst", "dsts", "rcr", "ddsts", "ldest", " dstr", " ddest", " dsts", "ddst"], "height": ["inches", "Height", "high", "gh", "html", "bottom", "ih", "gravity", "length", "radius", "padding", "capacity", "sky", "window", "depth", "ty", "th", "H", "total", "size", "count", "history", "zh", "ht", "he", "ch", "wh", "kh", "crop", "headers", "shape", "stroke", "grow", "volume", "hei", "hang", "density"], "srcStride1": ["srcStrip1", "srcStride11", "srcStrip11", "srcstride2", "srcStrid0", "srcStrip0", "srcstide2", "srcStrip2", "srcStrid2", "srcStrride0", "srcstide0", "srcstride11", "srcStrib2", "srcstide1", "srcStrib1", "srcstide11", "srcStrid1", "srcStide0", "srcStide2", "srcStrride2", "srcStide11", "srcStide1", "srcStride0", "srcstride1", "srcStrride1", "srcstride0", "srcStrib0"], "srcStride2": ["srcStrip1", "srcStr1", "srcStride8", "srcStr2", "srcStrideTwo", "srcSterve2", "srcStrride3", "srcstride2", "srcStr3", "srcstide2", "srcSterve4", "srcStideTwo", "srcStoe2", "srcStrip2", "srcstride4", "srcStide4", "srcStrip4", "srcStride4", "srcStoe1", "srcStide8", "srcStrride8", "srcstideTwo", "srcStide3", "srcStoe8", "srcstide1", "srcStripTwo", "srcStide2", "srcStoe3", "srcStrride2", "srcstide4", "srcSterveTwo", "srcStide1", "srcstrideTwo", "srcstride1", "srcStrride1", "srcStr8", "srcSterve1"], "srcStride3": ["srcStrib8", "srcStrib43", "srcStrip1", "srcStr1", "srcStride8", "srcStend3", "srcStrride3", "srcStride43", "srcStrip3", "srcStr3", "srcSlride4", "srcSlrip1", "srcStide43", "srcSlride8", "srcStrib4", "srcStr4", "srcStrip4", "srcStride4", "srcStide03", "srcStride03", "srcStrib2", "srcStide3", "srcStrib1", "srcStrip8", "srcStrib3", "srcSlrip4", "srcStend03", "srcSlride1", "srcStide2", "srcStrride43", "srcStrib03", "srcSlrip3", "srcStend43", "srcStrride2", "srcStrride03", "srcSlride3", "srcSlrip8", "srcStr8", "srcStend2"], "dstStride": ["dstSlride", "dstSTrip", "dstrStrip", "dstSlrip", "dstSTide", "dstSlide", "dstrRestrip", "dstrStrat", "dstStrat", "dndStrride", "dstSTrobe", "dndStrrobe", "dstRestrip", "dndStrrip", "dstSlrat", "dstrRestide", "dstrStride", "dstSTride", "dstrRestride", "dstStrobe", "dstRestrobe", "dstRestide", "dstStrrip", "dstrStide", "dstStide", "dstStrrat", "dstStrip", "dndStide", "dstRestride", "dndStride", "dstrRestrat", "dstRestrat", "dndStrobe", "dndStrip", "dstStrride", "dstStrrobe"], "x": ["no", " key", "xf", "axis", "ix", "u", "index", "_", "crop", "fx", "rx", "c", "t", "batch", " ax", "row", "xc", "k", "el", "X", "on", "dx", " xx", "xt", " index", "ey", " dx", " k", " i", "tx", " e", "lat", "max", "xa", "p", "xy", "xes", "i", "column", "ident", "l", "xi", "ex", "at", "xd", "xp", "o", "ax", "ctx", "ux", " tx", "yx", " X", "any", "e", "xx", "r", "step", " cx", "px", "f", "v", "z", "ct", "ox", "j", "wx", "n", "inx", "ext", "xxx", "m", "check", "mx"], "y": ["p", "ny", "py", "ky", "yi", "ery", "ies", "xy", "uy", "yr", "i", "dy", "vy", "wy", "yu", "yer", "asy", "oy", "j", "sky", "ys", "ey", "ty", "ady", "key", "hey", "iy", "yd", "my", "b", "yy", "ch", "icy", "axy", "Y", "ay", "yt", "ya", "ry", "ym", "ly", "cy", "t", "yl", "sy", "aily", "any", "ye", "yo", "gy", "by", "ley"], "w": ["r", "p", "wd", "wp", "sw", "v", "wr", "wi", "W", "l", "en", "wn", "Width", "window", "ex", "wk", "wx", "ew", "n", "wl", "tw", "wh", "win", "iw", "wt", "m", "wb", "wa", "weight", "nw", "kw", "rw", "ww", "we", "e", "hw", "fw"], "h": ["p", "hr", "high", "i", "v", "ih", "hm", "sh", "z", "length", "l", "en", "hd", "n", "H", "o", "bh", "b", "oh", "zh", "ht", "he", "ch", "wh", "ph", "kh", "ha", "hl", "hh", "q", "hs", "m", "c", "t", "hei", "hang", "hal", "k", "hw", "ish"], "yp": ["py", "yn", "uper", "ype", "wp", "lp", "px", "ipp", "pp", "typ", "sp", "pb", "tp", "dp", "bp", "rpm", "ty", "ep", "xp", "cp", "pa", "esp", "yy", "iw", "Typ", "lip", "ym", "fp", "mp", "orp", "ip", "RP", "YP", "osp", "ept", "hip", "jp"], "up": ["ui", "ue", "um", "upt", "ou", "uph", "UP", "op", "ul", "uf", "uc", "ub", "u", "out", "lu", "ump", "ur", "ups", "ow", "mp", "ip", "Up", "upp", "im", "ua", "au", "ap", "omp", "hip"], "vp": ["np", "imp", "wp", "lp", "pp", "hm", "vr", "dm", "tm", "tp", "dp", "bp", "vg", "rpm", "qv", "vm", "rm", "xp", "vt", "vv", "pm", "fp", "VP", "mp", "nv", "vs", "vc", "lv", "jp"], "d": ["r", "di", "p", "dc", "dr", "dx", "bd", "D", "dq", "df", "v", "dd", "dm", "data", "z", "dp", "l", "dict", "j", "dt", "out", "n", "o", "pd", "da", "g", "b", "dh", "s", "dn", "ds", "m", "c", "t", "db", "dL", "e"]}}
{"project": "FFmpeg", "commit_id": "381e195b46d080aee1d9b05ef2b6b140e9463519", "target": 0, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n, i;\n\n    uint8_t *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    int32_t *dst_int32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n\n        /* we process 40-bit blocks per channel for LXF */\n\n        sample_size = 5;\n\n\n\n    if (sample_size == 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid sample_size\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        if (buf_size < n) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n            return -1;\n\n        }else\n\n            buf_size -= buf_size % n;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] +\n\n                           (av_reverse[v & 0xff] << 8));\n\n          samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++) {\n\n                AV_WN16A(samples, bytestream_get_le16(&src2[c]));\n\n                samples += 2;\n\n            }\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            *samples++ = *src++ + 128;\n\n        }\n\n        break;\n\n#if HAVE_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(64, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(64, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* HAVE_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples += n * sample_size;\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            AV_WN16A(samples, x << 8);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            AV_WN16A(samples, s->table[*src++]);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n        }\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    case CODEC_ID_PCM_LXF:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        //unpack and de-planerize\n\n        for (i = 0; i < n; i++) {\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract low 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n\n            }\n\n\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract high 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n\n            }\n\n        }\n\n        src += n * avctx->channels * 5;\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 10244, "substitutes": {"avctx": ["afconn", "ajcfg", "avconfig", "wavtx", "wavconfig", "avecfg", "avegp", "cvctx", "avjac", "navjac", "evtx", "aveparams", "verctx", "evpkg", " avmk", "AVcontext", "vrcontext", "avepkg", "ajkw", "avcmd", "afcfg", "avercontext", "vartx", "avecontext", "avparams", "ajctx", "ajcas", "afpkg", "afhandle", "auctx", "AVkw", "avcas", "afcontext", "vanctx", "vancu", "vrhw", "auparams", "navtx", "ajcu", "ajtx", "averkw", "ajjp", "wavctx", "vercontext", "vrtx", "avercu", "abctx", "vercas", "averfc", "avtx", "cvconn", "avecmp", "wavcmp", "afconfig", "wavcmd", "abcontext", "averctx", "avcmp", "avkw", "AVcfg", "afjp", "navca", " avca", "cvcmd", "vrctx", " avkw", "AVctx", "wavjac", " avtx", "avpkg", "afmk", "avmk", "vercu", "ajgp", "avectx", "aucas", "wavjp", "vancfg", "avconn", "cvcmp", "afcu", "ajjac", "ajca", "avecmd", "afctx", "avjp", "avhw", "avesys", "abconf", "varctx", "vancas", "avconf", "averhw", "aveconn", "navctx", "ajsys", "wavca", "avcfg", "evctx", "aftx", "aveconf", " avconf", "ajhandle", "avcontext", "aveconfig", "AVtx", "aveca", "avekw", "avcu", "afcas", "varmk", " avconn", "averca", " avcfg", "varconn", "avecas", "vrcfg", " avcu", "wavcfg", "vercfg", "avgp", " avcontext", "avca", "avsys", "wavpkg", "avertx", "vrcas", "ajparams", "augp", "wavconn", "vrcu", "vertx", " avfc", "aversys", "avfc", "avehandle", "abca", " avhw", "avhandle", "avefc", "avetx", "evcontext", "avecu", " avpkg"], "data": ["p", "dev", "DATA", "bin", "value", "next", "f", "type", "read", "ata", "id", "frame", "name", "pad", "padding", "Data", "sample", "map", "feed", "window", "raw", "out", "in", "size", "a", "area", "d", "video", "bytes", "dat", "to", "empty", "package", "input", "ref", "m", "text", "t", "bits", "buffer", "pos", "batch", "block", "message", "stream", "mu", "w", "image", "length"], "data_size": ["data2range", "data2Size", "data6size", "data2length", "data6range", " data_Size", " data_range", "data_range", "data6length", "data_Size", "data_SIZE", " data_SIZE", "data6Size", "data2size", "data_length", " data_length"], "avpkt": ["ajpbck", "avtptx", "avPacket", " avPtx", "avtpmsg", "avpbuc", "averlpk", "avlpkt", " avpct", "avpck", "avopuc", "avpbkt", "avlpacket", " avPct", "avopck", "avopmsg", "avtpkt", "avPkt", "ajpck", "averpkg", "avwpkt", " avPmsg", "ajpuc", "averlpkg", "avpbmsg", " avptx", "avpk", "avPtx", "averlpkt", "avPk", "avPuc", "ajpkt", "averlpacket", "avpptx", "avppct", "avpmsg", "avptx", "ajpbkt", "averpkt", "avpbck", "ajpbmsg", "averpk", "avpct", "avpacket", "avtpct", "avPmsg", "avwpk", "avwpkg", "avwpacket", "avPkg", "avlpk", "avpkg", "avopkt", "ajpmsg", "avlpkg", "averpacket", "avPck", "avppkt", " avPkt", "avpuc", "avppmsg", " avpmsg", "ajpbuc", "avPct"], "buf": ["r", "p", "cb", "np", "mem", "bin", "cap", "v", "alloc", "uf", "map", "raw", "cv", "img", "tmp", "bh", "buff", "b", "bytes", "cache", "queue", "ref", "ctx", "box", "vec", "br", "wb", "txt", "t", "pos", "buffer", "db", "rb", "pkg", "orig", "Buffer", "msg", "cmd"], "s": ["r", "p", "h", "sb", "rs", "v", "ss", "ps", "gs", "j", "sq", "o", "a", "g", "b", "d", "sys", "ds", "m", "S", "e", "spec", "w", "conv", "ns"], "sample_size": ["site_group", "site_sized", "sample10global", " sample_Size", " sample_speed", "sample_sized", "frame_global", "sample_sum", "samplelyfunction", "sampleletsize", "frame_size", " sample_sum", "sampleYfunction", "site67Size", "ample_count", "frame67speed", "sample_weight", "sample67global", "sampleYSIZE", " sample_function", "site67size", " sample_sized", "sampleYtype", " sample_description", "frame_function", "sample_SIZE", "sample2count", "sampleletspeed", "sample_description", "site_Size", "sampleletSize", "sampleYsize", "ample_type", "sample67speed", "sample2Size", "sample_speed", "ample_Size", "sample1Size", "site67group", " sample_type", "sample_function", "sample67function", "sample_global", "sampleYdescription", "sample67Size", "frame67function", "sample2size", "sampleletsum", " sample_SIZE", "frame_speed", "sample_count", "samplelySIZE", "sample1sized", "sample1size", "sampleYSize", "sampleYsized", "samplelydescription", "samplelysize", "sample1group", "site67sized", "sample_Size", "sample_group", "sample67group", "ample_size", "samplelettype", "sample67size", "frame67global", "sample_type", "site_size", "sample67sized", "sampleletweight", "frame67size", "sample10speed", "sample10size", "sampleletSIZE", "ample_weight", "sample10function"], "c": ["p", "dc", "cb", "h", "co", "x", "C", "f", "v", "cm", "bc", "nc", "lc", "cc", "cp", "count", "b", "g", "d", "ch", "ci", "m", "t", "cs", "e", "k", "cn"], "n": ["r", "p", "h", "x", "no", "nn", "np", "v", "un", "nb", "ng", "number", "z", "N", "name", "l", "nc", "na", "j", "en", "ln", "an", "nr", "new", "pn", "u", "after", "nl", "ni", "o", "nt", "nm", "count", "nia", "a", "ne", "nan", "size", "net", "d", "fn", "b", " N", "Ni", "y", "sn", "dn", "m", "rn", "t", "num", "pos", "len", "nu", "nw", "normal", "nv", "k", "w", "mn", "cn", "ns"], "i": ["di", "p", "x", "ir", "v", "ic", "id", "l", "ii", "j", "I", "ix", "bi", "o", "b", "d", "si", "li", "y", "it", "ci", "m", "t", "ip", "mi", "pi"], "samples": ["ssamples", " sources", "insamps", "insources", "rsamples", "jsamples", "damps", "ssizes", "jsamps", "ssamps", "Samps", " sizes", "samps", "Sources", "rsamps", "tamples", "insamples", "Sents", "tources", "Sizes", "sources", "tents", "sizes", "Samples", "dents", "ssources", "rsources", "sents", "insizes", "rsizes", "dources", "jsizes", "damples", "jsources", "tamps", " samps"], "src": ["r", "cb", "sb", "via", "np", "proc", "seq", "bin", "rs", "attr", "addr", "cont", "cur", "its", "bc", "filename", "trans", "usr", "rect", "rc", "sr", "rel", "sq", "comp", "tmp", "rl", "sl", "b", "inst", "st", "ur", "iv", "sn", "input", "sys", "fp", "req", "txt", "sc", "source", "loc", "dest", "xff", "stream", "ptr", "sub", "img", "conv", "ins"], "src8": ["source16", "input24", "rc24", "src16", "input2", "source24", "input8", "rc2", "source2", "input16", "rc16", "source8", "src24", "rc8"], "src2": ["rc1", "src1", " src1", "source1", "rc2", "source2", "source8", "rc8"], "MAX_CHANNELS": ["MAX_CHINEL", "MAX_CHINES", "MAX_CHANNES", "MAX_ChANEL", "MAX_CHANKEL", "MAX_CHANNDS", "MAX_CHANETS", "MAX_CHACEL", "MAX_CHANES", "MAX_ChANNDS", "MAX_ChANNETS", "MAX_CHANNETS", "MAX_ChANNEL", "MAX_ChANELS", "MAX_CHANEL", "MAX_CHACELS", "MAX_CHANDS", "MAX_CHANKES", "MAX_CHANKELS", "MAX_CHACES", "MAX_CHABELS", "MAX_ChANES", "MAX_CHANKETS", "MAX_CHABEL", "MAX_ChANNES", "MAX_CHANNEL", "MAX_CHINDS", "MAX_ChANNELS", "MAX_CHABETS", "MAX_CHACDS", "MAX_CHINELS", "MAX_CHABES", "MAX_CHANELS", "MAX_ChANDS", "MAX_ChANETS"], "dst_int32_t": ["dst_int32_T", "dst_int32_ts", "dst_int32_type", "dst_int8_ts", "dst_int8_T", "dst_int8_type", "dst_int8_t"]}}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static int parse_presentation_segment(AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size,\n\n                                      int64_t pts)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    int x, y, ret;\n\n\n\n    int w = bytestream_get_be16(&buf);\n\n    int h = bytestream_get_be16(&buf);\n\n\n\n    ctx->presentation.pts = pts;\n\n\n\n    av_dlog(avctx, \"Video Dimensions %dx%d\\n\",\n\n            w, h);\n\n    ret = ff_set_dimensions(avctx, w, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Skip 1 bytes of unknown, frame rate? */\n\n    buf++;\n\n\n\n    ctx->presentation.id_number = bytestream_get_be16(&buf);\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     state\n\n     *     palette_update_flag (0x80),\n\n     *     palette_id_to_use,\n\n     */\n\n    buf += 3;\n\n\n\n    ctx->presentation.object_number = bytestream_get_byte(&buf);\n\n    ctx->presentation.composition_flag = 0;\n\n    if (!ctx->presentation.object_number)\n\n        return 0;\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     object_id_ref (2 bytes),\n\n     *     window_id_ref,\n\n     */\n\n    buf += 3;\n\n    ctx->presentation.composition_flag = bytestream_get_byte(&buf);\n\n\n\n    x = bytestream_get_be16(&buf);\n\n    y = bytestream_get_be16(&buf);\n\n\n\n    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/\n\n\n\n    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);\n\n\n\n    if (x > avctx->width || y > avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",\n\n               x, y, avctx->width, avctx->height);\n\n        x = 0; y = 0;\n\n    }\n\n\n\n    /* Fill in dimensions */\n\n    ctx->presentation.x = x;\n\n    ctx->presentation.y = y;\n\n\n\n    return 0;\n\n}\n", "idx": 10253, "substitutes": {"avctx": ["ajcfg", "wavtx", "avecb", "wavfc", "AVcontext", " avcp", "avcmd", "avercontext", "avecontext", "ajctx", "afpkg", "AVcmp", "wavcp", "navcontext", "afcf", "avercb", "afcontext", "navtx", "ajcu", "ajtx", "wavctx", "avecf", "avercu", "abctx", "avercfg", "averfc", "avtx", "avecmp", "wavcmp", "avcp", "wavcmd", "abcontext", "navcp", "avcmp", "averctx", "awctx", "ovcp", "wavcontext", "ovcontext", "wavkl", "AVctx", " avcf", " avtx", "avpkg", "ajtmp", "ajcmd", "navkl", "avectx", "navcu", "afctx", "avesys", "avkl", "avercmp", "navctx", "abtx", "ajsys", "awtx", "avcfg", "ajcontext", "aftx", "AVcp", "avcb", "avcontext", " avcmp", "AVtx", "avetmp", "avcu", "avcf", "avertmp", " avcfg", " avcu", "ovcu", "afcmp", " avcontext", "wavpkg", "avsys", "avertx", "ajcb", "navpkg", "abpkg", "ovctx", "aversys", "avfc", "awcp", "afkl", "awcmp", "avefc", "avetx", " avcmd", "avtmp", " avpkg"], "buf": ["aka", "pack", "data", "cam", "keep", "broad", "comm", "progress", "buff", "arr", "ref", "Buff", "len", "fam", "batch", "rb", "db", "kw", "pkg", "ptr", "fac", "Buffer", "cmd", "mem", "ob", "good", "raw", "bar", "begin", "mb", "desc", "wb", "buffer", "block", "bg", "aw", "msg", "p", "seq", "far", "cf", "cap", "coord", "pb", "cur", "bp", "uf", "window", "bag", "cast", "b", "bytes", "vec", "br", "prop", "rw", "doc", "ctr", "length", "conv", "func", "cb", "bf", "vals", "proc", "mat", "ff", "v", "read", "alloc", "args", "emb", "bc", "usr", "uffer", "cv", "pool", "tab", "queue", "alph", "xff", "bs", "gen", "img"], "buf_size": ["buf_len", "buffer_scale", "buf_scale", "buffer_size", "buffer_name", "buf_name", "buffer_len"], "pts": ["ports", "ptps", "ptts", "aptps", "portps", "nts", "ptt", "prns", "ctls", "ntns", "colts", " PTs", "prs", " ptS", " ptt", "ntids", " PTt", "apts", "ntls", "ntts", "prls", "cts", " PTids", "portts", "ptids", "ptS", "colns", "colls", "ptls", " ptids", "prts", "ctts", "ctps", "aptts", "cols", "portls", "aptls", "ntt", " PTS", "ntS", "ptns"], "ctx": ["func", "iac", "dc", "cb", "co", "init", "np", "acl", "tc", " cx", "cf", "conn", "proc", "cm", "addr", "ck", "exec", "cfg", "tm", "fc", "abc", "bc", "ct", "crit", "tk", "cond", "cl", "jac", "comm", "lc", "cc", "qt", "wx", "cv", "config", "cp", "nt", "pool", "cas", "ctl", "xp", "conv", "prefix", "ac", "history", "expr", "kl", "mk", "act", "etc", "tx", "local", "cmp", " context", "ca", "ia", "mc", "c", "ctrl", "req", "check", "kt", "anc", "kw", "loc", "xc", "pkg", "context", "gc", "hw", "jp", "cmd"], "x": ["p", "mm", "X", "h", "on", "dx", "xy", "px", "zx", "i", "value", "v", " xx", "xt", "id", "data", "length", "xf", "l", "xs", "ox", "xi", "height", "position", "ix", "ex", "at", "xd", "n", "xp", "o", "wx", "size", "ax", "el", "index", "tx", "fx", "lat", "ux", "lex", "rx", "xa", "yx", "m", "mx", " ax", "lon", "im", "xc", "xml", "w", "xx"], "y": ["p", "ny", "ot", "py", "fy", "yn", "h", "ity", "yi", "ery", "ies", "uy", "xy", "i", "v", "dy", "vy", "wy", "hy", "z", "yer", "asy", "oy", "kit", "height", "j", "sky", "ys", "scroll", "ey", "ty", "ady", "key", "iy", "o", "b", "my", "er", "yy", "index", "ch", "axy", "Y", "ay", "yt", "ya", "ry", "ym", "sys", "lat", "it", "c", "cy", "t", "yl", "hot", "sy", "table", "ye", "yo", "gy", "by"], "ret": ["r", "p", "pret", "cb", "no", "dr", "RET", "red", "ft", "fun", "value", "rev", "final", "f", "err", "v", "git", "repl", "xt", " Ret", "re", "result", "j", "gt", "Ret", "deg", "usr", "val", "rem", "after", "out", "nt", "rets", "vt", "back", "mt", "def", "tr", "elt", "rt", "ref", "zero", "reset", "tf", "it", "txt", "t", "num", "len", "res", "status", "got", "ll", "resp", "det", "alt", "ter", "nz"]}}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "void qemu_coroutine_delete(Coroutine *co_)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);\n\n\n\n    if (s->pool_size < POOL_MAX_SIZE) {\n\n        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);\n\n        co->base.caller = NULL;\n\n        s->pool_size++;\n\n        return;\n\n    }\n\n\n\n    g_free(co->stack);\n\n    g_free(co);\n\n}\n", "idx": 10266, "substitutes": {"co_": ["coe_", "fo_", "ico_", "CO_"], "s": ["self", "ts", "r", "p", "h", "sb", "ats", "sw", "rs", "i", "v", "ls", "sa", "sp", "ss", "ps", "gs", "sts", "n", "sq", "o", "store", "fs", "sv", "a", "g", "is", "b", "serv", "sl", "os", "q", "js", "sys", "hs", "ds", "m", "S", "c", "so", "t", "cs", "state", "ims", "se", "qs", "ns"], "co": [" Co", "cons", "coll", "no", "coord", "wo", "coe", "fc", " CO", "nc", "ano", "flo", "fo", "circ", "mo", "cu", "ico", "cc", "cv", "o", "ne", "obj", "soc", "CO", "ko", "cro", "oo", "copy", "ro", "local", "cmp", "fe", "none", "lo", "oe", "aco", "ce", "ci", "c", "cal", "so", "ctrl", "cod", "ee", "con", "po", "oc", "can", "row", "Co", "xc", "gc", "bo", "col", "yo"], "pool_size": ["pool__size", "pool_name", "pool64count", "pool_max", "pool__value", "Pool_SIZE", "pool64len", "pool_SIZE", "Pool_value", "pool_value", "Pool_size", "pool64max", "pool__name", "Pool_name", "thread_count", "thread_len", "thread_max", "pool_len", "pool__SIZE", "pool_count", "pool64size", "thread_size"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 10268, "substitutes": {"a": ["r", "att", "al", "p", "aj", "x", "aaa", "A", "h", "ma", "ab", "aka", "ga", "ae", "f", "sa", "ar", "i", "ata", "l", "am", "era", "na", "apt", "an", "oa", "va", "at", "out", "ao", "o", "ak", "da", "ea", "b", "as", "s", "ach", "isa", "eas", "y", "ca", "ia", "la", "t", "ba", "aq", "au", "e", "alpha", "w", "aa", "ac"], "STATUS_PARAM": ["STATUS_PEM", "STATUS_PAMS", "STATUS_PARam", "STATUS_ARAM", "STATUS_FAMS", "STATUS_Fam", "STATUS_ARAMS", "STATUS_Pam", "STATUS_PAM", "STATUS_PAREM", "STATUS_PARAMS", "STATUS_ARam", "STATUS_FEM", "STATUS_FAM", "STATUS_AREM"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10269, "substitutes": {"tpm_fd": ["tmm_handle", "tpm__fd", "tmm_pid", "tcm_cond", "tcm_dir", "tcm_fp", "tcm_fd", "tpm_handle", "tpm_cond", "tpm__pid", "tmm_fd", "tpm_fp", "tmm_fp", "tpm_pid", "tpm__cond", "tpm__handle", "tpm_dir", "tcm_handle", "tcm_pid"], "in": ["p", "rin", "or", "init", "on", "conf", "bin", "i", "f", "data", "add", "ind", "inn", "en", "old", "inc", "ex", "as", "is", "ac", "din", "vin", "s", "IN", "gin", "info", "input", "it", "c", "t", "inf", "inner", "con", "doc", "ins"], "in_len": ["in55lit", "oin_len", "txetylength", "intlen", "in55en", "intlim", "txetylen", "in_lim", "in_ls", "in_lis", "tx_lim", " in_ls", "inetylt", "in_en", "tx_length", "tx_len", "oin_lit", " in_length", "inetylen", "inetylim", "txetylt", "in55lis", "oin_lis", "oin_en", "txetylim", "tx_lt", "intlt", "inetylength", "intlength", "in_lit", "in_length", "in_lt", "in55len"], "out": ["p", "or", "ot", "list", "no", "on", "off", "conn", "bin", "OU", "aos", "outs", "err", "ou", "chan", "op", "data", "output", "end", "name", "str", "gt", "other", "new", "old", "at", "ex", "n", "o", "obj", "null", "nt", "b", "net", "file", "cache", "ch", "ext", "copy", "to", "set", "sys", "it", "Out", "c", "io", "t", "txt", "res", "con", "up", "OUT", "client", "w", "msg", "by"], "out_len": [" out2le", "out64lf", "conn64Len", "conn_len", "out_le", " out_ln", "conn_lf", "out2lan", "out_vec", "out_gl", " out_gl", "out2gl", "out64len", "conn_vec", "out_del", " out2gl", " out_del", "conn_Len", " out_lan", " out2lan", "out_lf", "out2len", " out_Len", "conn64lf", " out_le", "out2le", "conn64vec", "out_lan", "conn64len", "out64vec", "out_Len", " out2len", "out_ln", "out64Len"], "ret": ["flag", "cat", "err", "url", "gt", "Ret", "rm", "buf", "vet", "print", "def", "empty", "arr", "ref", "reg", "t", "len", "db", "row", "ll", "ter", "jp", "cmd", "oret", "round", "mem", "cont", "addr", "code", "lt", "mb", "desc", "rt", "ry", "set", "ort", "buffer", "status", "res", "aux", "pret", "final", "fun", " Ret", "result", "deg", "rect", "reply", "rem", "sr", "nt", "store", "tmp", "iter", "mt", "sec", "try", "tr", "elt", "inter", "arg", "r", "att", "ts", "opt", "RET", "ft", "re", "format", "add", "j", "usr", "val", "rets", "net", "back", " fut", "get", "ext", "lit", "gb", "reset", "ber", "cert", "det", "resp", "alt"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10278, "substitutes": {"env": ["cb", "conf", "sw", "conn", "eng", "ev", "v", "site", "sp", "pe", "environment", "end", "ei", "nc", "en", "map", "shell", "window", "vm", "org", "exc", "config", "vt", "viron", "te", "ah", "desc", "set", "ctx", "uv", "txt", "eh", "ee", "rb", "nv", "vs", "context", "e", "ptr", "doc"], "addr": ["r", "art", "p", "ld", "x", "dr", "sha", "mem", "lp", "rev", "attr", "i", "err", "link", "ar", "coord", "id", "url", "sp", "add", "pg", "pad", "start", "map", "ix", "align", "lag", "key", "order", "rc", "store", "a", "g", "load", "mt", "index", "arr", "elt", "hash", "node", "max", "offset", "ref", "adj", "adr", "req", "t", "ip", "pos", "alias", "ad", "res", "loc", "arch", "row", "ap", "ord", "ptr", "address", "ag", "msg", "rel", "cmd"], "buf": ["p", "cb", "h", "seq", "mem", "cap", "v", "pb", "data", "length", "bc", "pad", "str", "uf", "map", "raw", "fb", "bl", "out", "bag", "cv", "img", "iter", "buff", "b", "mb", " buff", "bytes", "cache", "arr", "queue", "ref", "offset", "Buff", " buffer", "vec", "br", "wb", "bu", "txt", "text", "buffer", "block", "batch", "rw", "rb", "doc", "Buffer", "msg", "cmd"], "len": ["gl", "limit", "ld", "lim", "list", "pl", "h", "seq", "mem", "lp", "err", "v", "ls", "Len", "data", "length", "lf", "lang", "ln", "en", "dl", "lc", "val", "all", "nl", "lt", "n", "size", "iter", "d", "kl", "fl", "lit", "li", "late", "hl", "elt", "offset", "lan", "vec", "m", "t", "pos", "la", "ll", "lon", "L", "le", "el", "msg", "rel"], "is_write": ["iswebwrite", "is_add", " is_connect", "is2written", "is_connect", "iswebwritten", " is_only", "is_only", " is_add", "iswebwrit", "is2write", " is_writer", "iswebadd", "is2writ", "is_writer", "is_weight", " is_writ", "is_writ", "is_written", " is_written", " is_weight", "is2add"], "l": ["r", "gl", "p", "al", "ld", "tl", "x", "h", "pl", "limit", "list", "lay", "lp", "i", "f", "v", "ls", "z", "length", "lf", "ln", "en", "j", "dl", "lc", "ml", "lic", "nl", "lt", "n", "lam", "o", "line", "lu", "sl", "b", "g", "d", " L", "kl", "fl", "lit", "li", "hl", "lo", "lis", "ly", "lan", "m", "c", "t", "la", "ell", "ll", "lb", "L", "lv", "w", "le", "el", "il"], "phys_addr": ["physipaddr", "physptaddr", "magptarea", "phys2addr", "mag_sta", "las_addr", "physptarea", "phys__addr", "phys__ord", "phys___port", "las_adr", "physikpage", "cpu_addr", "physical_addr", "physikaddr", "healthnetaddr", "mag_addr", "cpuikpage", "healthnetvr", "physical_adr", "physistaddress", "physistport", "las___addr", "phy_ref", "healthnetoffset", "phys___addr", "phys_port", "physiptab", "physipref", "physipptr", "phys___address", "phys_ref", "physnetoffset", "physptack", "mag_ack", "phys_mt", "phys_area", "health_addr", "phys2adr", "phys_sta", "physnetmt", "phys_offset", "physnetvr", "phy_tab", "healthnetmt", "phys___adr", "physacaddr", "phys_page", "cpuikaddr", "physnetaddr", "phys2page", "physacpage", "las___address", "las___port", "physikadr", "health_offset", "phys_vr", "magptack", "phys_ack", "mag_area", "physistaddr", "phys_address", "phys_tab", "cpu_page", "phys_ord", "physical_ord", "phys_adr", "phy_ptr", "physical_address", "physacadr", "phys__adr", "magptsta", "las___adr", "physptsta", "las_address", "cpu_adr", "magptaddr", "phy_addr", "physistadr", "health_vr", "phys_ptr", "health_mt", "phys__address", "cpuikadr", "las_port"], "page": ["r", "p", "step", "limit", "pl", "slot", "i", "link", "pp", "v", "pid", "site", "id", "sp", "url", "number", "pages", "perm", "pg", "bp", "j", "window", "phrase", "key", "order", "line", "size", "pool", "pointer", "load", "net", "le", "pa", "index", "phase", "node", "age", "ref", "offset", "disk", "ip", "num", "PA", "block", "point", "base", "port", "row", "ptr", "me", "image", "address", "Page"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq dma, omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 10282, "substitutes": {"system_memory": [" system_storage", "system_media", " system_media", "System_media", "System_storage", "System_mem", " system_mem", "System_memory", "system_storage", "system_mem"], "base": ["self", "p", "eta", "h", "x", "ma", " bound", " from", " bas", "bal", " address", "data", "id", "re", "bp", "name", " db", "root", "out", "space", "size", "server", " erase", "bound", "domain", "b", "prefix", "bs", "bas", "ASE", "sys", "Base", "m", " BASE", "buffer", " bases", " basis", "ase", "memory", " b", "based", "e", "address", "zero", " Base"], "irq": ["interq", "iraqi", " irqq", "pirv", "interqq", " irqi", "prq", "ireqq", "irv", "prqq", "ibrv", "prquick", "irtq", "irev", "pircharge", "irtqq", "iraqs", "ibrq", "ireq", "irquick", "intereq", "irqi", "irtquick", "ircharge", " irv", "irqs", " ircharge", "iraq", "ibrqi", "irecharge", "irteq", "ibrqs", " irqs", "pirq", "preq", "irav", "irqq", "pirqq", "interquick"], "dma": ["dnhma", "Dpa", "Dma", "dmma", "sdma", " Dpa", " dmas", "dmmas", "dnmas", "dnmac", " Dma", "sdmac", "dmmac", "dmac", "dmas", " dpa", "sdmas", "Dmas", "dpa", " Dmas", "dnma", "dmhma", "sdhma", "dhma"], "clk": ["CLk", "clks", "CLj", "clj", "blks", " clks", "blz", " clz", " clj", "CLks", "CLz", "blk", "clz", "blj"], "s": ["changes", "sb", "ls", " is", "aws", "comm", "sv", "d", "sam", "has", "js", "sys", "c", "t", "state", "se", "ms", "w", "ns", "ins", "less", "sync", "h", "ats", "ies", "settings", "ers", "ps", "parts", "sq", "fs", "a", "sl", "set", "stats", "ds", "services", "vs", "ims", "ports", "p", "i", "sa", "its", "l", "out", "space", "o", "store", "g", "is", "b", "os", "y", "hs", "e", "r", "ts", "rs", "save", "v", "ss", "es", "z", "als", "izes", "gs", "j", "sts", "n", "service", "details", "bs", "states", "m", "S", "bits", "spec"]}}
{"project": "qemu", "commit_id": "66668d197fa40747e835e15617eda2f1bc80982f", "target": 0, "func": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    VncPalette *palette = &color_count_palette;\n\n    uint32_t bg = 0, fg = 0;\n\n    int colors;\n\n    int ret = 0;\n\n#ifdef CONFIG_VNC_JPEG\n\n    bool force_jpeg = false;\n\n    bool allow_jpeg = true;\n\n#endif\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n\n\n    vnc_tight_start(vs);\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vnc_tight_stop(vs);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n\n\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n\n            allow_jpeg = false;\n\n        }\n\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n\n            force_jpeg = true;\n\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n\n        }\n\n    }\n\n#endif\n\n\n\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n\n                                 force_jpeg);\n\n    } else {\n\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n    }\n\n#else\n\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 10291, "substitutes": {"vs": ["changes", "sb", "inv", "ues", "dates", "blogs", "ls", "ears", "lists", "obs", "vers", "xs", "otes", "docs", "sv", "as", "uds", "names", "js", "sys", "ints", "tops", "vp", "ms", "ins", "ns", "forces", "caps", "ps", "terms", "fs", "vt", "lbs", "posts", "helps", "ks", "stats", "ds", "verts", "cs", "ims", "gets", "versions", "ports", "boxes", "lines", "atts", "its", "ops", "VS", "s", "videos", "eps", "os", "hs", "styles", "ts", "fps", "vals", "pps", "rs", "v", "iffs", "vy", "vr", "ss", "es", "heads", "gs", "sts", "ams", "views", "details", "bs", "uv", "bits", "vc", "Vs", "qs"], "x": ["r", "p", "search", "mm", "X", "on", "dx", "xy", "px", "i", "v", "xt", "op", "ic", "z", "xf", "l", "ct", "xs", "ox", "xi", "ix", "ex", "at", "xd", "create", "wx", "xp", "ax", "el", "get", "act", "try", "xxxx", "tx", "fx", "ry", "lat", "lex", "it", "rx", "c", "m", "xa", "ip", "mx", "im", "xc", "xml", "xx"], "y": ["p", "ny", "ot", "py", "fy", "yn", "ery", "ies", "xy", "uy", "i", "v", "vy", "wy", "hy", "asy", "yer", "oy", "j", "ys", "ey", "ty", "key", "iy", "b", "my", "er", "yy", "icy", "ch", "try", "get", "axy", "Y", "ay", "ry", "yt", "ya", "ym", "sys", "it", "ia", "cy", "et", "yl", "hot", "sy", "any", "ye", "client", "gy", "by"], "w": ["r", "p", "wd", "sw", "wp", "f", "v", "wr", "z", "W", "l", "str", "wn", "window", "th", "ex", "n", "ew", "wl", "b", "tw", "d", "wh", "win", "iw", "ow", "ch", "now", "wt", "m", "wb", "wa", "weight", "t", "rew", "nw", "kw", "rw", "ww", "we", "way", "aw", "word", "hw", "wal", "fw"], "h": ["r", "p", "or", "hr", "no", "html", "has", "ih", "v", "sh", "head", "hm", "z", "length", "ash", "rh", "height", "l", "window", "hd", "hz", "th", "http", "ho", "H", "o", "size", "count", "bh", "b", "as", "oh", "hi", "history", "ht", "he", "ch", "wh", "ph", "ah", "kh", "ha", "cache", "hl", "ow", "hh", "hash", "each", "info", "hs", "it", "m", "c", "t", "hei", "hal", "k", "hw", "ish"], "palette": ["palors", "plors", "prolette", "palet", "localette", "pallete", "allette", "colestyle", "colet", "schete", " pallette", "Palet", "alettes", "fillette", " palgorithm", "packettes", "plorset", "collette", "alestyle", "pallette", "palettes", "localorset", "scheestyle", "localors", "palorset", "collete", "Palette", "schelette", "proette", "palte", "locallette", "scheette", "pllette", "proet", "packgorithm", "alte", "packte", "colette", "filte", "packette", "plette", " palte", " palestyle", "algorithm", "filestyle", "filette", "palestyle", "colorset", "colte", " palettes", "prolete", "Pallete", "Pallette", "palgorithm", "alette"], "colors": ["palors", "colororset", "colients", "colores", " colorset", "palals", "Colers", "icolours", "actners", "paluers", "icolor", "icolograms", " colients", " coluers", " colners", "filorset", "colograms", " colores", "palners", "icolals", "palorset", "colers", "palours", "colals", "colorors", "filor", "palor", " colers", "actors", "palograms", "Colors", "icolors", "colorers", "colours", "filores", "palores", " color", "colorset", "palers", " colours", "Colores", "icolorset", "actuers", "actorset", "Colients", "icolores", "colners", "filors", "Color", "icolers", "colorals", "palients", "color", " colograms", "coluers", "Colorset"]}}
{"project": "qemu", "commit_id": "5238c88657d751e3acf3e953a9b11f5f24262f75", "target": 0, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    uint32_t palcode;\n\n    int32_t disp21, disp16;\n\n#ifndef CONFIG_USER_ONLY\n\n    int32_t disp12;\n\n#endif\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit;\n\n    uint8_t lit;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = insn >> 26;\n\n    ra = (insn >> 21) & 0x1F;\n\n    rb = (insn >> 16) & 0x1F;\n\n    rc = insn & 0x1F;\n\n    real_islit = islit = (insn >> 12) & 1;\n\n    if (rb == 31 && !islit) {\n\n        islit = 1;\n\n        lit = 0;\n\n    } else\n\n        lit = (insn >> 13) & 0xFF;\n\n    palcode = insn & 0x03FFFFFF;\n\n    disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11;\n\n    disp16 = (int16_t)(insn & 0x0000FFFF);\n\n#ifndef CONFIG_USER_ONLY\n\n    disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20;\n\n#endif\n\n    fn11 = (insn >> 5) & 0x000007FF;\n\n    fpfn = fn11 & 0x3F;\n\n    fn7 = (insn >> 5) & 0x0000007F;\n\n    LOG_DISAS(\"opc %02x ra %2d rb %2d rc %2d disp16 %6d\\n\",\n\n              opc, ra, rb, rc, disp16);\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, palcode);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n    case 0x08:\n\n        /* LDA */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x09:\n\n        /* LDAH */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x0A:\n\n        /* LDBU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0D:\n\n        /* STW */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x10:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_cmpbge(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                       tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_addlv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_sublv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_addqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_subqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x11:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            if (likely(rc != 31)) {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask);\n\n                } else {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask);\n\n                }\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            if (rc != 31) {\n\n                tcg_gen_movi_i64(cpu_ir[rc], ctx->implver);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x12:\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            gen_zap(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            gen_zapnot(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x13:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            {\n\n                TCGv low;\n\n                if (unlikely(rc == 31)){\n\n                    break;\n\n                }\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                    break;\n\n                }\n\n                low = tcg_temp_new();\n\n                if (islit) {\n\n                    tcg_gen_movi_tl(low, lit);\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low);\n\n                } else {\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n                tcg_temp_free(low);\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_mullv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_mulqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x14:\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_s(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtf(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrts(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_f(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtg(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtt(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_faddf(ra, rb, rc);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_fsubf(ra, rb, rc);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_fmulf(ra, rb, rc);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_fdivf(ra, rb, rc);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG */\n\n#if 0 // TODO\n\n            gen_fcvtdg(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_faddg(ra, rb, rc);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_fsubg(ra, rb, rc);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_fmulg(ra, rb, rc);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_fdivg(ra, rb, rc);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_fcmpgeq(ra, rb, rc);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_fcmpglt(ra, rb, rc);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_fcmpgle(ra, rb, rc);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            gen_fcvtgf(rb, rc);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD */\n\n#if 0 // TODO\n\n            gen_fcvtgd(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            gen_fcvtgq(rb, rc);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            gen_fcvtqf(rb, rc);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            gen_fcvtqg(rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_fadds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_fsubs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_fmuls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_fdivs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_faddt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_fsubt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_fmult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_fdivt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_fcmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_fcmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_fcmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_fcmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_fcvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_fcvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            gen_fcvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            gen_fcvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            gen_fcvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            gen_fcvtlq(rb, rc);\n\n            break;\n\n        case 0x020:\n\n            if (likely(rc != 31)) {\n\n                if (ra == rb) {\n\n                    /* FMOV */\n\n                    if (ra == 31) {\n\n                        tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]);\n\n                    }\n\n                } else {\n\n                    /* CPYS */\n\n                    gen_fcpys(ra, rb, rc);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            gen_fcpysn(ra, rb, rc);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            gen_fcpyse(ra, rb, rc);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_store_fpcr(cpu_env, cpu_fir[ra]);\n\n            } else {\n\n                TCGv tmp = tcg_const_i64(0);\n\n                gen_helper_store_fpcr(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_load_fpcr(cpu_fir[ra], cpu_env);\n\n            }\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            gen_fcvtql(rb, rc);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            gen_fcvtql_v(ctx, rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            if (ra != 31) {\n\n                if (use_icount) {\n\n                    gen_io_start();\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                    gen_io_end();\n\n                    ret = EXIT_PC_STALE;\n\n                } else {\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                }\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mfpr(ra, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        if (rb != 31) {\n\n            tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3);\n\n        } else {\n\n            tcg_gen_movi_i64(cpu_pc, 0);\n\n        }\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr;\n\n\n\n            if (ra == 31) {\n\n                break;\n\n            }\n\n\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1C:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit));\n\n                } else {\n\n                    tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit));\n\n                    } else {\n\n                        tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit));\n\n                    } else {\n\n                        gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x31:\n\n            /* PERR */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_perr(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], clz64(lit));\n\n                    } else {\n\n                        gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit));\n\n                    } else {\n\n                        gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbw(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbl(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x36:\n\n            /* PKWB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pkwb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x37:\n\n            /* PKLB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pklb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x70:\n\n            /* FTOIT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x78:\n\n            /* FTOIS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (rc != 31) {\n\n                TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                if (ra != 31) {\n\n                    gen_helper_s_to_memory(tmp1, cpu_fir[ra]);\n\n                } else {\n\n                    TCGv tmp2 = tcg_const_i64(0);\n\n                    gen_helper_s_to_memory(tmp1, tmp2);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1);\n\n                tcg_temp_free_i32(tmp1);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mtpr(ctx, rb, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            if (rb == 31) {\n\n                /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n                   address from EXC_ADDR.  This turns out to be useful for our\n\n                   emulation PALcode, so continue to accept it.  */\n\n                TCGv tmp = tcg_temp_new();\n\n                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n                gen_helper_hw_ret(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            } else {\n\n                gen_helper_hw_ret(cpu_env, cpu_ir[rb]);\n\n            }\n\n            ret = EXIT_PC_UPDATED;\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr, val;\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            if (ra != 31) {\n\n                val = cpu_ir[ra];\n\n            } else {\n\n                val = tcg_temp_new();\n\n                tcg_gen_movi_i64(val, 0);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            if (ra == 31) {\n\n                tcg_temp_free(val);\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10295, "substitutes": {"ctx": ["cb", "wd", "conf", "np", "conn", "tc", "mem", "cm", "jp", "cfg", "fc", "ct", "jac", "cc", "setup", "obj", "cp", "cas", "tmp", "cv", "work", "KC", "act", "tx", "req", "kt", "sc", "kw", "loc", "Context", "xc", "pkg", "context", "hw", "conv", "cmd"], "insn": ["outsne", "resner", "linson", "intersn", "intsm", "itsn", "linsz", "ainsne", "csns", "insz", "esne", " insz", "insner", "bitsn", " insgn", "intersnan", "itssn", "bitsns", "linsn", "itsnan", "pinssn", "intsn", "alssn", "itsz", "insnm", "stsan", "mssn", "csm", " insns", "statsn", "esan", "pinsnn", "pinsn", "insan", " insnm", "pinsns", "INSsn", "outsgn", "linsgn", "statssn", "INSner", "stsne", "outssn", "alsv", "stsn", "msnm", "resnm", "msner", "linsns", "statsne", "linsner", "interssn", "insgn", "insnan", "ainssn", "intsns", "timesgn", "csh", "essn", "resn", " inssn", "timesn", "esn", "intssn", "ainsan", "alsner", " insner", "pinsner", "itsh", "alsn", "inssn", "insnn", "insh", "linsv", "ason", "asn", "bitsnn", "insm", "timessn", "linssn", "assn", "pinsv", "bitssn", "INSn", "itsner", "intersh", "itsv", "insns", "ainsns", "stssn", "itsgn", " inson", "csn", "csnan", "msn", "itsns", "insv", "INSns", "linsnn", "insne", "linsm", "statsgn", "ainsn", "inson", "cssn", "timesne", "asgn", "ressn", "ainsv", "outsn"], "palcode": ["Palmode", "palpage", " palode", "pacCode", "rolcode", "palcat", "plancode", "PalCode", "rolCode", "rolcat", "planpage", " palcod", "calcod", "plance", "palcod", "Palode", " palcat", "palode", "calCode", "plcycle", "palmode", "palcycle", "pacpage", " palmode", "pacmode", "paccode", "plpage", "plcode", "Palcode", "paccycle", "plce", "palce", " palCode", "calcode", "calcat", "palCode", "pacce", "rolcod", "pacode", "plancycle"], "disp21": ["disp31", "dispa203", "desp203", " disjp31", "desp20", "disp32", " disp32", " disjp11", "disnp11", "dispa21", " disjp32", "disnp20", "desjp11", "disop31", "disnp21", "dispa20", "disnp203", "disop32", "disjp21", " disp31", "disp20", "disop21", "desjp21", "desjp203", "disp203", "dispp11", "disjp32", " disjp21", "dispp31", "desp21", "disjp11", "dispa11", "desjp20", "dispp21", "dispp32", "disjp20", "disjp203", "desp11", " disp11", "disjp31", "disp11", "disop11"], "disp16": ["DisP156", "disp162", "desp16", "dislp21", "discp162", "desp162", "disvp156", "DisP12", "disperm156", "disp22", "disvp22", "disjp12", "dislp12", "disperm20", "disP15", "descp12", "DisP16", "disP162", "disperm16", "disvp15", "DisP15", "disp20", "disP12", "discp16", "descp16", "disjp22", "disP21", "disperm12", "DisP20", "disp156", "dislp16", "discp12", "desp21", "desp12", "Disp16", "disjp16", "disp15", "disvp16", "Disp12", "disvp20", "disjp15", "Disp15", "disvp12", "descp21", "disP22", "disP16", "Disp20", "descp162", "Disp156", "dislp162", "discp21", "DisP22", "Disp22", "disP156", "disP20"], "disp12": ["desp16", "discp72", "DisP72", "disp17", "discp22", "desp17", "dispData", "disrep17", "DisP12", "disp22", "Disp72", "desP17", "desP12", "dispat22", "desP16", "desPData", "dispp17", "Disp22", "disrep16", "dispat16", "DisP16", "disp72", "dispp16", "disP12", "discp16", "disP17", "discp12", "desp12", "disppData", "dispat12", "disrep12", "Disp16", "dispp12", "Disp12", "disPData", "dispat72", "disP22", "disP16", "despData", "disP72", "DisP22", "disrepData"], "fn11": ["dn31", "cn101", "fc11", " fn2011", "cn2011", "fn101", "fl11", "fc12", "dn11", "dn101", " fn101", "fl12", "tnair", "pnair", "dn2011", "cn31", "fnair", "fc7", "tn11", " fnair", "pn11", "fn2011", "fl7", "cn11", "tn7", " fn31", "fn12", " fn12", "pn7", "fn31"], "opc": ["oppc", "optc", " opcache", "opC", "ppf", " opac", " opci", " opcs", "plf", "opac", "opercache", " oppc", "iopc", "operc", "pf", "oplc", "plct", "optch", "opf", "pct", "plc", "apc", "ppct", " opf", "ppc", "iopC", "pllc", " opC", " optci", "opcs", "opcache", "optf", "appc", "OPcs", " opch", "pplc", "operch", "OPC", " optac", "apci", "opch", "apac", " optpc", "opct", "optcache", "iopcs", "iopci", "OPci", " optc", "OPc", "pc", "opci", "operf"], "ra": ["r", "cr", "ir", "co", "rom", "pr", "ror", "rs", "rr", "ar", "ri", "ria", "re", "tar", "rf", "usr", "gra", "ran", "sr", "ru", "ara", "rap", "rl", "area", "as", "ur", "ro", "eas", "raf", "dra", "rt", "rage", "mr", "rar", "reg", "ras", "rn", "rx", "RA", "la", "aria", "ta", "loc", "ruby", "au", "orig", "rou", "rd", "ring"], "rb": ["r", "RB", "rab", "cb", "sb", "ab", "rs", "rr", "nb", "vr", "pb", "re", "ob", "rf", "usr", "erb", "bb", "reb", "rob", "fb", "rm", "ib", "rg", "ru", "rl", "src", "rub", "b", "rib", "ro", "raf", "gb", "rage", "br", "wb", "db", "rw", "ruby", "rid", "lb", "rd", "ring"], "rc": ["r", "cb", "cr", "tc", "rs", "rr", "irc", "ck", "cur", "re", "fc", "rec", "rf", "bc", "uc", "arc", "sr", "rg", "cv", "ru", "rl", "src", "ec", "ro", "raf", "rt", "roc", "ry", "ras", "rn", "rx", "c", "sc", "cs", "pc", "RC", "lb", "rd"], "fpfn": ["lpconn", "fpfc", "bpfn", "fpbn", "vpjack", "lpfc", "bpconn", "bpjack", "vpfn", "lpf", "vpbn", "vpf", "vpconn", "bpbn", "fpjack", "lpbn", "ulpbn", "ulpf", "ulpfc", "lpjack", "vpfc", "ulpfn", "lpfn", "fpf", "fpconn"], "fn7": ["nm11", "dn6", "pn7", "dn5", " fn6", " fn709", "dn11", "nm5", "fn6", "nm6", "nm7", "dn7", "pn709", "tn11", "fn5", "pn11", "tn7", "tn709", " fn5", "fn709"], "islit": ["iplitted", "selit", "isalit", "sellit", "ineliter", "sslic", "islitted", "snitt", "iplite", "illitter", "iollit", "islitt", "sslitt", "islim", "inelitt", "inelit", "islite", "isalite", "slit", "snic", "iplitter", "ioliter", "sllit", "slim", "illit", "inelmit", "iplit", "inelitted", "isliter", "islic", "selim", "snite", "isalitted", "isalitter", "inelic", "snit", "islmit", "isllit", "selmit", "sslit", "sslite", "sliter", "inellit", "illite", "slitted", "islitter", "slmit", "iolitted", "inelim", "inelite", "iolit", "illitted"], "real_islit": ["real_solit", "real_flite", "real_flit", "real_islic", "real_islist", "real_ilit", "real_ilip", "real_ilist", "real_flist", "real_slic", "real_slite", "real_ilic", "real_islite", "real_ilite", "real_slit", "real_solite", "real_flip", "real_islip", "real_solist", "real_slip", "real_solic", "real_slist"], "lit": ["limit", "lim", "tl", "cb", "opt", "init", "let", "slot", "sat", "lp", "nat", "sel", "sil", "id", "l", "lang", "tip", "mit", "at", "lt", "iter", "lu", "lif", "def", "late", "hl", "eval", "ref", "fi", "it", "abl", "sal", "la", "len", "loc", "eral", "alt", "fail", "col", "lite", "lib", "gen", "rot"], "ret": ["att", "pas", "pret", "opt", "flag", "RET", "fun", "sat", "rev", "err", " Ret", "test", "re", "gt", "Ret", " RET", "uf", "out", "lt", "nt", "rets", "vt", "bt", "mt", " fut", "try", "def", "elt", "rt", "ref", "it", "txt", "status", "res", "resp", "alt", "gc", "nz", "jp"]}}
{"project": "FFmpeg", "commit_id": "53e5462040f6f7273fb6b0d7592eea1f5d26829f", "target": 0, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, int flags, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   int srcFormat, uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n    int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos;\n\n    int16_t av_unused *mmx2Filter    = c->chrMmx2Filter;\n\n    int     av_unused canMMX2BeUsed  = c->canMMX2BeUsed;\n\n    void    av_unused *mmx2FilterCode= c->chrMmx2FilterCode;\n\n\n\n    if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE)\n\n        return;\n\n\n\n    if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) {\n\n        src1 += ALT32_CORR;\n\n        src2 += ALT32_CORR;\n\n    }\n\n\n\n    if (srcFormat==PIX_FMT_RGB48LE) {\n\n        src1++;\n\n        src2++;\n\n    }\n\n\n\n    if (c->hcscale_internal) {\n\n        c->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n#if COMPILE_TEMPLATE_MMX\n\n    // Use the new MMX scaler if the MMX2 one can't be used (it is faster than the x86 ASM one).\n\n    if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed))\n\n#else\n\n    if (!(flags&SWS_FAST_BILINEAR))\n\n#endif\n\n    {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n#if ARCH_X86 && CONFIG_GPL\n\n#if COMPILE_TEMPLATE_MMX2\n\n        int i;\n\n#if defined(PIC)\n\n        DECLARE_ALIGNED(8, uint64_t, ebxsave);\n\n#endif\n\n        if (canMMX2BeUsed) {\n\n            __asm__ volatile(\n\n#if defined(PIC)\n\n                \"mov          %%\"REG_b\", %6         \\n\\t\"\n\n#endif\n\n                \"pxor             %%mm7, %%mm7      \\n\\t\"\n\n                \"mov                 %0, %%\"REG_c\"  \\n\\t\"\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\"\n\n                \"mov                 %2, %%\"REG_d\"  \\n\\t\"\n\n                \"mov                 %3, %%\"REG_b\"  \\n\\t\"\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                \"mov                 %5, %%\"REG_c\"  \\n\\t\" // src\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\" // buf1\n\n                \"add              $\"AV_STRINGIFY(VOF)\", %%\"REG_D\"  \\n\\t\"\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n\n\n#if defined(PIC)\n\n                \"mov %6, %%\"REG_b\"    \\n\\t\"\n\n#endif\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (mmx2Filter), \"m\" (mmx2FilterPos),\n\n                \"m\" (mmx2FilterCode), \"m\" (src2)\n\n#if defined(PIC)\n\n                ,\"m\" (ebxsave)\n\n#endif\n\n                : \"%\"REG_a, \"%\"REG_c, \"%\"REG_d, \"%\"REG_S, \"%\"REG_D\n\n#if !defined(PIC)\n\n                ,\"%\"REG_b\n\n#endif\n\n            );\n\n            for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) {\n\n                //printf(\"%d %d %d\\n\", dstWidth, i, srcW);\n\n                dst[i] = src1[srcW-1]*128;\n\n                dst[i+VOFW] = src2[srcW-1]*128;\n\n            }\n\n        } else {\n\n#endif /* COMPILE_TEMPLATE_MMX2 */\n\n            x86_reg xInc_shr16 = (x86_reg) (xInc >> 16);\n\n            uint16_t xInc_mask = xInc & 0xffff;\n\n            __asm__ volatile(\n\n                \"xor %%\"REG_a\", %%\"REG_a\"               \\n\\t\" // i\n\n                \"xor %%\"REG_d\", %%\"REG_d\"               \\n\\t\" // xx\n\n                \"xorl    %%ecx, %%ecx                   \\n\\t\" // xalpha\n\n                ASMALIGN(4)\n\n                \"1:                                     \\n\\t\"\n\n                \"mov        %0, %%\"REG_S\"               \\n\\t\"\n\n                \"movzbl  (%%\"REG_S\", %%\"REG_d\"), %%edi  \\n\\t\" //src[xx]\n\n                \"movzbl 1(%%\"REG_S\", %%\"REG_d\"), %%esi  \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, (%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"movzbl    (%5, %%\"REG_d\"), %%edi       \\n\\t\" //src[xx]\n\n                \"movzbl   1(%5, %%\"REG_d\"), %%esi       \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, \"AV_STRINGIFY(VOF)\"(%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"addw       %4, %%cx                    \\n\\t\" //xalpha += xInc&0xFFFF\n\n                \"adc        %3, %%\"REG_d\"               \\n\\t\" //xx+= xInc>>16 + carry\n\n                \"add        $1, %%\"REG_a\"               \\n\\t\"\n\n                \"cmp        %2, %%\"REG_a\"               \\n\\t\"\n\n                \" jb        1b                          \\n\\t\"\n\n\n\n/* GCC 3.3 makes MPlayer crash on IA-32 machines when using \"g\" operand here,\n\n   which is needed to support GCC 4.0. */\n\n#if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n\n                :: \"m\" (src1), \"m\" (dst), \"g\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#else\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#endif\n\n                \"r\" (src2)\n\n                : \"%\"REG_a, \"%\"REG_d, \"%ecx\", \"%\"REG_D, \"%esi\"\n\n            );\n\n#if COMPILE_TEMPLATE_MMX2\n\n        } //if MMX2 can't be used\n\n#endif\n\n#else\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n#endif /* ARCH_X86 */\n\n    }\n\n    if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) {\n\n        int i;\n\n        //FIXME all pal and rgb srcFormats could do this convertion as well\n\n        //FIXME all scalers more complex than bilinear could do half of this transform\n\n        if(c->srcRange) {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (dst[i     ]*1799 + 4081085)>>11; //1469\n\n                dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; //1469\n\n            }\n\n        } else {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n                dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10308, "substitutes": {"c": ["p", "dc", "cb", "h", "co", "cr", "conf", "C", "tc", "cf", "f", "v", "cm", "cont", "cam", "fc", "abc", "bc", "nc", "ct", "call", "cd", "cn", "lc", "comm", "cu", "cc", "unc", "rc", "cv", "config", "cp", "enc", "b", "d", "cache", "ec", "ch", "etc", "com", "cmp", "ca", "ctx", "ce", "ci", "m", "cal", "t", "mc", "sc", "anc", "con", "cs", "pc", "vc", "gc", "w", "conv", "ac"], "dst": ["drST", " dST", "ddest", " dest", "delt", "Dest", "brc", "grc", "drdest", "adST", "blt", "Dst", "DST", "Dnt", " dnt", "derc", "dlt", "glt", "adst", "gst", "adest", "bsc", "gsc", "drest", "desc", "adnt", "dnt", "dST", "dsc", "drst", " ddest", "drc", "bst", "dest", "Ddest"], "dstWidth": [" destWidth", " dstH", "dstwidth", "dndW", "dvSize", " dstHeight", " destHeight", " dSTWidth", "destH", "dStHeight", "dstW", "dSTSize", "dSTH", "dstHeight", "dmtWidth", "dStWidth", "dStSize", "dStH", " dSTSize", "dstSize", "dmtHeight", "dSTWidth", "dSTwidth", "dvW", " dSTH", "dndWidth", "destwidth", "destWidth", " destSize", "destW", "dmtwidth", "destHeight", "destSize", "dvHeight", "dSTHeight", " destwidth", "dndSize", "dndHeight", " destW", " dstwidth", " dstW", "dstH", "dvWidth", " dstSize", " dSTHeight"], "src1": ["servOne", "src3", "sys01", " src3", "source1", "srcOne", "src001", " src001", "rc3", "sysOne", "sourceOne", "rc1", " srcOne", "source3", "src01", "sys2", "sys1", "rc01", "src0", "rc001", "serv1", " src01", "locOne", "loc1", "rcOne", "source001", "loc2", " src0", "source01", "loc3", "rc0", "source0", "rc2", "source2", "serv2"], "src2": ["sr2", "src3", "usrtwo", "rctwo", " src3", "source1", "srcTwo", "ser02", "sourceTwo", "srctwo", "rc3", "src02", "rc1", " srctwo", "source3", "src256", "sr02", "rc02", "sr3", "srTwo", "sc2", "sc02", "ser2", "rcTwo", "usr2", "rc256", "source02", "sc1", " src02", "ser1", " src256", "usr1", " srcTwo", "rc2", "source2", "scTwo", "usr256"], "srcW": ["rcSize", "sr2", "src3", " src3", "sourceSize", "rcN", "source1", "sr1", "srcH", "srW", " srcN", "rc3", " srcw", "rc1", "sr3", "rcW", "sourceW", "rcH", "rcw", "sourceN", "srcN", "loc1", " srcH", "sourcew", "srcw", "locN", "locW", "rc2", "source2", "srcSize", "locH", " srcSize"], "xInc": ["wxIncre", "exExc", "wxInc", "XInc", "xtINC", "xtInc", "wxIns", "yxInc", "xtIncre", "dxIncre", "xtExc", "xIns", " xINC", "xINC", "XINC", "wxINC", "exIncre", "dxINC", "yxExc", "XIncre", "exINC", "yxIncre", "xExc", "yxINC", " xExc", " xIns", "dxExc", "xIncre", "exInc", " xIncre", "dxInc", "wxExc", "XIns"], "flags": ["options", "ts", "ports", "reports", "cons", "bugs", "packages", "fps", "vals", "flag", "ats", "types", "aps", "cf", "points", "pins", "args", "params", "frames", "pages", "heads", "cond", "tags", "lag", "terms", "parts", "FLAG", "fs", "actions", "acts", "Flags", "posts", "goal", "ints", "kind", "limits", "fields", "weights", "bits", "comments", "products", "mask", "faces", "features", "members", "locks", "ags", "wcs", "ants"], "hChrFilter": ["hCorrFrame", "func", "hCHrcFrame", "hChrcFilter", "hChlFrame", "hCoroQuery", "hChdrFilter", "hChrbSearch", "hChlFilter", "hChdrCode", "hChrFrame", "hCHrcCode", "hChoQuery", "hChrtFilter", "hCoroFilter", "hCHrFilter", "hChdrFrame", "hChrtSearch", "hChrQuery", "hCHrcFilter", "hChoSearch", "hChoFilter", "hChrSearch", "hChlCode", "conv", "hCHrcImage", "hChrcCode", "hCoroSearch", "hCorrQuery", "hChrbQuery", "WC", "_", "hChrImage", "hChrCode", "hCHrCode", "hCorrSearch", "hCorrFilter", "hCoroFrame", "hCHrFrame", "hCHrImage", "hChrtFrame", "hChrbFrame", "hChrtQuery", "hChrbFilter", "hChoFrame", "hChrcImage", "hChdrImage", "hChlImage", "hChrcFrame"], "hChrFilterPos": ["hChrFormatPos", "hChrFilterCode", "hChrHeaderPos", "hChlFilterPos", "hChrfilterPosition", "hChrfilterSize", "hCharFilterSize", "hChlfilterPosition", "hChrfilterUser", "hChrHandlerPos", "hChlFilterSize", "hChrFormatPosition", "hChlFilterPosition", "hCharHandlerPos", "hChlfilterUser", "hChlfilterPos", "hChrHandlerUser", "hChrfilterPos", "hChrSortSize", "hChrFormatUser", "hChrSortCode", "hChrFilterPosition", "hChrFormatSize", "hChrHandlerCode", "hChrHandlerSize", "hCharHandlerCode", "hChrFilterUser", "hCharHandlerSize", "hChrSortPos", "hCharFilterCode", "hChrHeaderSize", "hChlfilterSize", "hCharFilterPos", "hChrHandlerPosition", "hChrHeaderCode", "hChlFilterUser"], "hChrFilterSize": ["hChrBufferStyle", "hChrBlockData", "hChrtFilterCode", "hChrFilterCount", "hChrtFilSize", "hChrtFilType", "hChrBufferType", "hChrFilterCode", "hChrtFilStyle", "hChrFilCode", "hChrtFilterSize", "hChrTransformData", "hChcFilterCode", "hChrtFilterType", "hChrBufferSize", "hChcFilterData", "hChrFilStyle", "hChcBufferCode", "hChcBufferData", "hChrTransformCode", "hChrtFilterStyle", "hChrBlockCount", "hChcFilterSize", "hChrBufferCount", "hChrBlockSize", "hChrFilSize", "hChrFilterStyle", "hChrBlockCode", "hChrBufferCode", "hChcFilterCount", "hChcBufferSize", "hChrBufferData", "hChrFilterType", "hChrTransformSize", "hChcBufferCount", "hChrBlockType", "hChrBlockStyle", "hChrFilterData", "hChrtFilCode", "hChrTransformCount", "hChrFilType"], "srcFormat": ["scType", "rcFormat", "rcPattern", "sourcePlan", "srcFilter", " srcStyle", "rcFilter", "sqPattern", "srcPath", "stockPlan", "rcPlan", "rcVersion", "sourceName", " srcCard", "srcVersion", "rcPath", "rcCard", "rcStyle", " srcWidth", "funcVersion", "sqName", "sourceType", "srcformat", "rcformat", "srcPlan", "scWidth", "rcWidth", "stockType", "syncCard", "srcWidth", "sourceFormat", "rcType", "stockformat", "scName", "rcName", "sqFormat", "srcType", "srStyle", "srFormat", "srcStyle", "srcPattern", "stockFormat", "srForm", "srcForm", " srcFilter", " srcName", "srcName", "funcForm", "syncName", "srName", "rcForm", "funcFilter", "syncFormat", "sqFilter", "sourceformat", "funcFormat", "scFormat", "syncPath", " srcPath", " srcForm", " srcVersion", "sourceVersion", " srcPattern", "srcCard", " srcType"], "formatConvBuffer": ["formatconvtBuffer", "formatEnVBuff", "formatRenvBuff", "formatConvertBuff", "formatConvertBytes", "formatConuvBuff", "formatConvtPort", "formatConvBytes", "formatEnVBytes", "formatConvtBuffer", "formatConuvBuffer", "formatConvArray", "formatEnvBuff", "formatconvBuffer", "formatEnjAttribute", "formatRenvArray", "formatConVBytes", "formatConjBuffer", "formatConvPort", "formatConnvArray", "formatConnvFlow", "formatEnnvFlow", "formatConvtBytes", "formatConvFlow", "formatConvtBuff", "formatEnnvBuff", "formatEnnvBuffer", "formatEnvBuffer", "formatEnjBuffer", "formatConvFilter", "formatConnvBuff", "formatConvtAttribute", "formatconvBuff", "formatRenvBuffer", "formatConvertFlow", "formatEnvBytes", "formatConVBuffer", "formatconvtBuff", "formatConvBuff", "formatConuvAttribute", "formatConvertArray", "formatConVBuff", "formatConjAttribute", "formatConjPort", "formatConvAttribute", "formatEnvFlow", "formatConVArray", "formatConVFilter", "formatconvPort", "formatconvtPort", "formatConvertFilter", "formatRevBuffer", "formatConnvBuffer", "formatRevBuff", "formatConjBuff", "formatEnvAttribute", "formatEnvFilter", "formatConvertBuffer", "formatEnVBuffer", "formatConuvFlow", "formatConvtFilter", "formatEnjBuff", "formatRevArray", "formatEnVFilter"], "pal": ["pol", "al", "pas", "Pal", "font", "pl", "vals", "conf", "qq", "qual", "flat", "mat", "sav", "pp", "pid", "pack", " PAL", "als", "padding", "white", "ps", "val", "qt", "quant", "buff", "isal", "scale", "png", "wh", "ph", "what", "pill", "local", "skin", "theme", "cal", "sal", "pos", "mask", "bat", "color", "alpha", "ass"], "mmx2FilterPos": ["mmx2BufferPos", "mmx4BufferInfo", "mmx2ChannelInfo", "mmx2ChannelSize", "mmx2FilterInfo", "mmx4BufferPosition", "mmx2HandlerPos", "mmx2HandlerPosition", "mmx2ChannelPos", "mmx2BufferInfo", "mmx2ChannelPosition", "mmx4BufferPos", "mmx2HandlerInfo", "mmx2FilterPosition", "mmx4FilterInfo", "mmx2FilterSize", "mmx4FilterPosition", "mmx2HandlerSize", "mmx2BufferPosition", "mmx4BufferSize", "mmx2BufferSize", "mmx4FilterSize", "mmx4FilterPos"], "mmx2Filter": ["mmX4Filter", "mmx2Block", "mmx42filter", "mmx022filter", "mmX4Block", "mmx2filter", "mmx4Block", "mmX2filter", "mmx4Filter", "mmx2Rule", "mmx42Filter", "mmX4filter", "mmX2Block", "mmx022Filter", "mmx4Rule", "mmx4filter", "mmX2Rule", "mmx022Block", "mmx42Block", "mmx42Rule", "mmx022Rule", "mmX2Filter", "mmX4Rule"], "mmx2FilterCode": ["mmx2FilterStyle", "mmx2BufferCode", "mmx2TestStyle", "mmx2ChannelSize", "mmx2ChannelMode", "mmx2FilterMode", "mmx2BufferMode", "mmx02FilterMode", "mmx2TestSize", "mmx02BufferStyle", "mmx02FilterSize", "mmx2TestMode", "mmx02BufferMode", "mmx2FilterSize", "mmx02BufferCode", "mmx2ChannelCode", "mmx2BufferStyle", "mmx02FilterStyle", "mmx02FilterCode", "mmx2ChannelStyle", "mmx2BufferSize", "mmx02BufferSize", "mmx2TestCode"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n", "idx": 10316, "substitutes": {"a": ["r", "p", "or", "aaa", "sta", "A", "ma", "ae", "sa", "v", "ata", "data", "z", "l", "na", "ana", "an", "oa", "va", "at", "n", "o", "da", "ea", "area", "b", "as", "d", "isa", "ca", "ia", "m", "c", "t", "la", "ta", "ba", "au", "alpha", "w", "aa", "ac"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n", "idx": 10322, "substitutes": {"thread1": ["comment1", "record2", "comment2", " thread10", "taskone", "threadone", "Thread2", " threadOne", "task10", " thread001", "Thread001", "thread10", "task1", "thread001", "recordone", "commentOne", "ThreadOne", "Thread1", "comment001", "record1", " threadone", "threadOne", "record10", "task2"], "thread2": ["system2", "TH1", "system4", "TH2", "condition1", "TH02", "process1", "threadTwo", "process2", " threadTwo", "conditionTwo", "system02", "process4", "process02", "THTwo", " thread02", "system1", "thread4", "condition02", "condition2", "thread02", " thread4"]}}
{"project": "qemu", "commit_id": "1b27d7a1e8609b2eeb6238f2c629eb82217523f6", "target": 0, "func": "static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,\n\n                                                            uint32_t val)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint64_t write_one = 1;\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if ((dest < 0) || (dest > s->max_peer)) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {\n\n                IVSHMEM_DPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\",\n\n                                                    write_one, dest, vector);\n\n                if (write(s->peers[dest].eventfds[vector],\n\n                                                    &(write_one), 8) != 8) {\n\n                    IVSHMEM_DPRINTF(\"error writing to eventfd\\n\");\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n", "idx": 10327, "substitutes": {"opaque": ["OPatile", "opatile", "OPaques", "opca", "obaque", " opacity", " opaques", "opc", "iopaque", "iopacity", "Opatile", " opatile", " opc", "obacity", "iopca", "iopoid", " opoid", "opoid", "OPaque", "opacity", " opca", "opaques", "Opaques", "Opc", "OPc", "obca", "Opaque", "oboid"], "addr": ["r", "att", "x", "dr", "flag", "mem", "rs", "rev", "attr", "coord", "ar", "v", "ret", "alloc", "tag", "err", "url", "data", "id", "add", "pad", "trans", "map", "code", "align", "rc", "host", "obj", "src", "prefix", "ac", "mt", "dh", "act", "tr", "var", "arp", "arr", "tx", "Address", "rt", "hl", "hash", "offset", "ctx", "cmp", "inter", "adr", "gate", "pos", "ad", "res", "len", "loc", "dest", "alt", "ord", "ptr", "state", "address", "cmd"], "val": ["pol", "al", "p", "dev", "x", "vals", "conf", "Val", "value", "vector", "xy", "mem", "sol", "slot", "v", "ret", "vol", "sel", "bal", "data", "stat", "pt", "aval", "range", "buf", "vt", "grad", "ival", "serv", "values", "index", "def", "lit", "var", "tx", "bit", "elt", "eval", "ctx", "it", "vec", "cal", "VAL", "num", "resp", "valid", "alt", "state", "address", "item", "arg"], "s": ["r", "ts", "p", "changes", "h", "sb", "conf", "ats", "sw", "aunts", "ses", "ies", "rs", "i", "ls", "sp", "ss", "its", "als", "ties", "ps", "gs", "j", "aws", "an", "comm", "sts", "ess", "n", "sm", "sq", "store", "sv", "fs", "sl", "is", "serv", "sam", "bs", "ins", "os", "y", "sn", "bis", "q", "js", "sys", "hs", "ds", "ssl", "stats", "m", "S", "sis", "c", "t", "bits", "vs", "ims", "se", "qs", "ns"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n", "idx": 10333, "substitutes": {"s": ["r", "ts", "p", "h", "rs", "i", "v", "ls", "sa", "ss", "its", "es", "ps", "gs", "sts", "n", "sq", "o", "a", "is", "g", "as", "b", "os", "ms", "js", "sys", "stats", "ds", "m", "c", "S", "so", "t", "sc", "cs", "bs", "w", "ns"], "ot": ["r", "p", "or", "opt", "ots", "ote", "ou", "onet", "oot", "op", "oid", "ic", "dot", "iet", " ol", "pot", "pt", "ox", "tt", "gt", "OT", "at", "out", "iot", "o", " os", "ota", "nt", " dot", "net", "mt", "ott", "os", "ut", "y", "mot", "rt", "og", "iat", "sys", "it", "oss", "t", "et", "cot", " net", "hot", "oc", "ant", "rot"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "void test_fcmp(double a, double b)\n\n{\n\n    long eflags, fpus;\n\n\n\n    fpu_clear_exceptions();\n\n    asm(\"fcom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fcom(%f %f)=%04lx \\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    fpu_clear_exceptions();\n\n    asm(\"fucom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fucom(%f %f)=%04lx\\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    if (TEST_FCOMI) {\n\n        /* test f(u)comi instruction */\n\n        fpu_clear_exceptions();\n\n        asm(\"fcomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n        fpu_clear_exceptions();\n\n        asm(\"fucomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n    }\n\n    fpu_clear_exceptions();\n\n    asm volatile(\"fxam\\n\"\n\n                 \"fstsw %%ax\\n\"\n\n                 : \"=a\" (fpus)\n\n                 : \"t\" (a));\n\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n\n    fpu_clear_exceptions();\n\n}\n", "idx": 10338, "substitutes": {"a": ["ami", "x", "aka", "am", "en", "ao", "da", "as", "er", "d", "index", "c", "ann", "t", "el", "w", "ace", "ab", "name", "abc", "an", "new", "oa", "obj", "app", "ah", "ach", "eas", "au", "aux", "aw", "p", "al", "aaa", "sta", "A", "ga", "i", "ar", "sa", "era", "apt", "at", "out", "o", "ea", "g", "ow", "y", "ca", "af", "ia", "ed", "apa", "ing", "e", "aa", "ac", "r", "att", "active", "aj", "ma", "ae", "f", "v", "ai", "admin", "n", "area", "aff", "m", "la", "ba", "ap"], "b": ["r", "p", "x", "sb", "h", "be", "ab", "bin", "f", "i", "v", "nb", "pb", "z", "ob", "bc", "l", "j", "erb", "other", "bb", "new", "eb", "reb", "fb", "u", "ib", "bi", "n", "out", "o", "bar", "amb", "g", "d", "B", "back", "to", "y", "bis", "it", "br", "m", "c", "wb", "abb", "t", "body", "db", "rb", "base", "ba", "e", "bs", "w"], "eflags": ["eflpats", "efinedlenates", "explcacks", "eflcacks", "efinedlugs", "eflpales", "eflcag", "efhlinks", "eflcales", "efdlag", "eflinks", "elfnlugs", "eflenags", "efinedlates", "elfnlogs", "elflogs", "eflcogs", "eblags", "eflales", "eflcamps", "eflcugs", "efklags", "eflsag", "efliagn", "elflpags", "elflpinks", "eblag", "eflcats", "efklamps", "efflamps", "eblcags", "efnlamps", "efflaps", "elflales", "eflugs", "efinedlenags", "eflcinks", "elflinks", "efklogs", "efflacks", "elflags", "efhlales", "eblinks", "efdlagged", "explacks", "eflenagn", "explamps", "efliags", "eflsugs", "efdlacks", "efliugs", "efhlats", "elflpales", "explcags", "elflugs", "elfnlamps", "eblcagged", "eblagged", "eflcaps", "eflsates", "efdlaps", "eflagged", "eblcag", "eflsagn", "eflamps", "efdlags", "explcaps", "eflpinks", "elflpats", "eflsags", "efinedlenugs", "eflagn", "eflats", "efnlags", "efliates", "eflenugs", "eflenates", "elflats", "eflacks", "eflag", "efdlinks", "eflaps", "efhlags", "efinedlagn", "efklugs", "efdlamps", "explaps", "explags", "eflcags", "eflpags", "eflsagged", "elflamps", "efnlogs", "efinedlenagn", "elfnlags", "eflogs", "efinedlags", "eflcagged", "efflags", "explcamps", "eflates", "eflsinks", "eblcinks", "efnlugs"], "fpus": ["gpcus", "FPus", "fncus", "fpaus", "ppouses", "piru", "fpuses", "fpsus", "piros", "bpu", "fnus", "bpcus", "FPu", "fpos", "xpUS", "fpscus", "fpsUS", "iopus", "gpos", "FPcus", "pirus", "cpUS", "vpuses", "xpcus", "gpu", "npus", "pirUS", "vpaus", "gpus", "tpis", "bpus", "hluses", "tpu", "fpu", "vpcus", "fnaus", "FPUS", "pircus", "hlcus", "xpuses", "vpUS", "cpu", "fpsaus", "cpuses", "iopaus", "piris", "npUS", "npuses", "cpcus", "cpis", "piruses", "fnu", "gpUS", "fpis", "cpus", "fpUS", "piraus", "FPuses", "vpis", "cpos", "vpus", "vpos", "fpcus", "bpUS", "jpu", "jpcus", "jpus", "ppocus", "hlu", "ppoUS", "gpis", "npu", "iopu", "vpu", "hlus", "gpuses", "tpus", "ppous", "tpUS", "jpuses", "tpos", "tpaus", "iopcus", "tpcus", "xpus", "npcus"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n\n                             int mmu_idx, target_ulong size)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    hwaddr iotlb, xlat, sz;\n\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n\n\n    assert_cpu_is_self(cpu);\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n\n\n    sz = size;\n\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n\n    assert(sz >= TARGET_PAGE_SIZE);\n\n\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n              \" prot=%x idx=%d\\n\",\n\n              vaddr, paddr, prot, mmu_idx);\n\n\n\n    address = vaddr;\n\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n\n        /* IO memory case */\n\n        address |= TLB_MMIO;\n\n        addend = 0;\n\n    } else {\n\n        /* TLB_MMIO for rom/romd handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 10351, "substitutes": {"cpu": ["p", "util", "cli", "instance", "proc", "CPU", "conn", "mem", "gpu", "upt", "alloc", "jp", "ck", "stat", "tp", "cow", "processor", "uart", "mac", "gnu", "rpm", "vm", "ka", "cu", "nic", "java", "process", "bench", "ilo", "cp", "uda", "server", "core", "pty", "phys", "pu", "sys", "ctx", "aco", "mx", "nu", "ork", "arch", "apache", "memory", "clock", "gc", "pc", "mu", "hw", "context", "socket", "linux", "cmd"], "vaddr": ["vmadd", "pAddress", "vcarr", "evptr", "vcpad", "padd", "vhost", "vradr", " vaddress", "evadr", "paddress", "madd", "vip", "vAddress", "pip", "uvaddr", "jarr", "maddress", "uvadd", "uvip", " vadded", "faddr", "pstore", "vphost", "vradded", "vcadd", "pref", "varr", "vptr", "vadded", "vadr", "vraddr", "vpaddr", "vchost", " vrun", "vparr", "vmaddr", "jaddr", "vaddress", "evaddr", "jhost", " vadd", "vpad", "vmAddress", "faddress", "vstore", "vrun", "vppad", "jpad", " vref", "vmip", "fref", "uvAddress", "prun", "vcstore", "vcaddr", " vadr", " vstore", "maddr", "vref", "fadd", "vcrun", "evadded", "vadd", "vrptr", " vptr"], "paddr": ["mptr", " pptr", "mconn", "ipaddr", "padd", "paddress", "madd", "ppconn", " padd", " paddress", "ipref", "gconn", "gaddr", " pconn", "pref", "gadd", "vptr", "pconn", "hadd", "gptr", "vaddress", "vconn", "haddr", "hptr", "pptr", "haddress", "ipadd", "ppaddr", "ipptr", " pref", "vref", "maddr", "ppadd", "vadd"], "attrs": ["attr", "addres", "addr", " attres", "attps", "attachrd", "attres", "Attps", "addrd", "addps", "addributes", "Attributes", "attachrs", "Attr", "attachributes", " attr", "Attrs", "attachres", "attrd", " attps", "addrs", " attributes", "attributes", " attrd"], "prot": ["pro", "platform", "chron", "password", "prototype", "flag", "vector", "tag", "type", "typ", " protocol", " proto", "stat", "format", "tz", "version", "period", "crypt", "height", "method", "Prot", "policy", " PROT", "tif", "push", "ext", "style", "tf", "header", "offset", "pat", "priority", "phy", "protection", "prop", "ssl", "pos", "top", "status", "ocol", "port", "ping", "mode", "col", "inet", "rot"], "mmu_idx": ["mmu_idef", "mmu_idf", "mmu_idex", "mmu2Idb", "mmu_pidv", "mmu_pidb", "mmu_idev", "_", "mmu_tryxs", "ptr", "mmu_pidx", "cont", "mmu_idv", "mmu_idey", "mmu_Idy", "mmu_idez", "ctl", "mmu_tryx", "mmu2Idx", "into", "mmu2Idy", "mmu_inx", "mmu_idxs", "mmu_Idxs", "mmu_idy", "mmu_Idf", "exec", "mmu2idx", "mmu_pidy", "mmu_Idv", "mmu_ideb", "mmu2Idv", "mmu_tryz", "mmu2idy", "mmu_idz", "mmu_Idb", "mmu_iny", "mmu_idb", "mmu_inv", "mmu_Idz", "mmu2idb", "mmu_tryy", "mmu2idv", "mmu_Idx"], "size": ["news", "send", "timeout", "sw", "mem", "city", "type", "loss", "sp", "number", "z", "data", "fee", "name", "network", "height", "padding", "capacity", "esi", "page", "small", "large", "share", "range", "space", "total", "count", "time", "zone", "area", "south", "gz", "scale", "Size", "bytes", "cache", "si", "s", "shape", "empty", "sn", "set", "style", "max", "offset", "too", "ize", "pos", "buffer", "num", "sum", "len", "pi", "message", "SIZE", "length", "storage"], "env": ["ent", "dev", "engine", "ote", "conn", "proc", "ev", "eng", "enter", "next", "eur", "pee", "v", "web", "esc", "pe", "eni", "environment", "ef", "end", "ei", "network", "esi", "era", "en", "window", "eg", "global", "org", "worker", "policy", "ve", "ew", "cv", "buf", "server", "obj", "vt", "er", "net", "core", "viron", "esp", "ner", "ec", "eu", "ah", "menu", "see", "ctx", "oe", "equ", "export", "ten", "manager", "here", "et", "console", "eh", "Environment", "stage", "db", "den", "po", "buffer", "vs", "context", "e", "ptr", " environment"], "section": ["ment", "session", "instance", "sections", "course", "comment", "feature", "sector", "region", "member", "selection", "tag", "portion", "job", "Section", "site", "sect", "ss", "settings", "pair", "connection", "environment", "version", "entry", "network", "test", "group", "page", "key", "channel", "array", "range", "server", "area", "zone", "journal", "prefix", "sec", "setting", "ner", "definition", "tab", "second", "set", "header", "container", "man", "module", "ctx", "part", "establishment", "block", "port", "row", "table", "division", "option", "side", "description", "mode", "context", "aux", "state", "sub", "profile", "se", "element", "mod"], "index": ["x", "instance", "ity", "value", "i", "link", "test", "success", "id", "number", "connection", "ind", "version", "location", "connect", "axis", "capacity", "interface", "page", "ion", "code", "date", "position", "lock", "ix", "Index", "route", "key", "order", "ice", "initial", "count", "iter", "time", "si", "info", "hash", "offset", "ize", "find", "open", "pos", "num", "loc", "row", "point", "IND", "context", "level", "length", "zero", "error"], "address": ["p", "distance", "ace", "password", "comment", "value", "region", "addr", "add", "end", "location", "network", "command", "interface", "page", "map", "code", "angle", "position", "route", "order", "device", "array", "ice", "ress", "area", "pointer", "a", "resource", "service", "prefix", "path", "shape", "attribute", "Address", "hash", "offset", "reference", "adr", "alias", "buffer", "ip", "port", "point", "table", "memory", "ase", "action", "message", "description", "context", "ptr", "alpha", "image", "length", "operation"], "code_address": ["code_addr", "create_address", "ode_location", "create_location", "code_memory", "ode_index", "ode_address", "code_point", "codelistmemory", "code_index", "codelistaddress", "codelistpoint", "code_location", "ode_addr", "create_point", "codelistlocation", "create_memory"], "addend": ["addEND", "ADDending", "Addr", "adended", "Addend", " addstart", "appender", "attachEND", "addr", "ADDender", "appending", "Addended", "attachend", "adstart", "addstart", " addended", " addr", "Addstart", "attachender", "appEND", "attachending", "AddEnd", "ADDend", "adr", "append", "addended", "adend", "ADDEND", "addending", "adEnd", "addEnd", "addender", " addEnd"], "te": ["ts", "tone", "be", "ue", "pee", "de", "TE", "pe", "ste", "tp", "team", "fo", "aste", "me", "ve", "ke", "ne", "ite", "ie", "td", "ete", "tre", "tr", "tle", "oe", "lex", "ce", "ele", "t", "je", "Te", "ge", "ette", "ta", "ti", "ye", "lete", "e", "ptr", "le", "se", "ter"], "iotlb": ["hotlbs", "motlb", "motl", "ytlbs", "hotlb", "iotl", "otb", "hotlab", "hotl", "otl", "potlab", "otlbs", "otlab", "otlb", "potlb", "iotb", "iotlab", "ytlab", "iotlbs", "ytlb", "potlbs", "potb", "ytb", "motlbs", "motlab"], "xlat": [" xrat", "ylat", "uxformat", "XLat", "ixLat", "ydat", "uxpat", "ixsat", "xxlat", "ixformat", "xptr", "ixlat", "txlat", " xdat", " xsat", "xaddr", "Xlat", "yLat", "xxsat", "xsat", "ixdat", " xformat", "xdat", "uxlat", "ypat", " xpat", "xxrat", "xrat", "uxrat", "xLat", "txaddr", "Xaddr", " xaddr", "ixpat", " xptr", "ixptr", "txLat", "xxptr", " xLat", "xpat", "ixrat", "xformat"], "sz": ["sszi", "sze", "sgz", "ssiz", "ssz", "szi", "sZ", " szi", "psZ", "lsze", "ssZ", "getsiz", "Sz", "Szi", "psz", " siz", "lsiz", "getsZ", "Siz", "sviz", "svgz", "Sze", "psze", "ssgz", "svze", "getszi", " sze", "psiz", "lsz", "ssze", "siz", "svz", "getsze", "lsgz", "getsz", "SZ", " sZ"], "vtlb_index": ["vtlb__index", "vtld__count", "vtld__id", "vtld__size", "vtlb2id", "vtlb_size", "vtld_id", "vtlb2count", "vtlb_count", "vtlb2index", "vtlb__size", "vtlb__id", "vtld_count", "vtlb2size", "vtlb_id", "vtlb__count", "vtld_index", "vtld_size", "vtld__index"]}}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}", "idx": 10355, "substitutes": {"cipher": ["coder", "unciper", "ctain", "chipher", "ctrypt", "ncain", "curipher", "ccain", "Cipher", "ciper", "Cron", "conoder", "cpher", "chorp", "Coder", "crypt", "curain", "curpher", "cciph", "ccipher", "ccpher", "Ciper", "chiph", "coniph", "nciph", "uncipher", "conipher", " cron", "Crypt", " crypt", " cain", " ciph", "ciph", " ciper", "ncpher", "ctipher", "Cain", " corp", "cain", "uncoder", "curiph", "ncipher", "cron", "corp", "uncrypt", " coder", "choder", "ctron", "conorp"], "key": ["p", "or", "init", "xy", "value", "type", " KEY", "id", "pair", "data", "air", "version", "name", "seed", "Key", "ek", "ver", "tip", "sky", "query", "code", "mac", "lock", "ey", "secret", "ex", "n", "ice", "ke", "ak", "size", "KEY", " Key", "prefix", "te", "index", "ch", "mk", "sign", "iv", "y", "ay", "hash", "node", "input", "token", "keys", "box", "power", "ce", "chain", "ip", "sk", "sum", "mask", "cert", "state", "k", "length", "ower"], "nkey": ["fnkey", "nfree", " nke", "Ndata", "natke", "nke", "nmdiff", "cnKey", " ndata", "nvfee", "nnfree", "ndata", "nvdiff", "Nkey", " nKey", "Nke", "nnKey", "npage", "fnpage", "nKey", "NKey", "gnkey", "ndiff", "Nfree", "Nk", " nk", "nvpage", "nkeys", "natKey", "Nkeys", " nkeys", "cnkeys", "fnKey", "natk", "nnkey", " npage", "cnkey", "nfee", "nmfee", "nk", "Npage", "gndiff", "natkey", "nmpage", "nndata", "nmkey", " nfree", "gnfee", "nvkey", "gnpage", "cndata"], "errp": ["Erpb", "ererP", " errP", "lerp", "ererpb", "errbp", "Erp", "lerpb", "errpa", " errpa", " errbp", " erP", "errP", "ererp", " errpb", "ererpa", "Erbp", "lerbp", " erp", " erpb", " erpa", "errpb"], "ctxt": ["curtxt", "enttx", "ctrench", "catxt", "sectxt", "ktext", "curxt", "uttxt", "curtx", "actxt", "ptxt", "critrench", "contrench", "cttxt", "contxt", "ctait", "secttxt", "sectext", "acttxt", "cxt", "CTief", "ectait", "crittx", "kttx", "ctext", "conttx", "uttx", "pttxt", "actfx", "catext", "ptfx", "ctresh", "sectief", "entext", "critext", "ecttxt", "ectext", "enttxt", "actrench", "cattxt", "ktxt", "critxt", "ectfx", "ectxt", "curext", "kttxt", "cttx", "ecttx", "ctx", "ptait", "pttx", "ptext", "nttxt", "utext", "actresh", "ctief", "actief", "ctfx", "conttxt", "CTct", "CText", "cext", "acttx", "CTtxt", "CTtx", "ctct", "ntct", "nttx", "contresh", "CTxt", "ectct", "utxt", "actext", "actait", "catresh", "ntxt", "context", "entxt"]}}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,\n\n                                    bool is_legacy)\n\n{\n\n    int ret;\n\n    VqInfoBlock info;\n\n    VqInfoBlockLegacy linfo;\n\n    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);\n\n\n\n    if (check_len) {\n\n        if (ccw.count != info_len) {\n\n            return -EINVAL;\n\n        }\n\n    } else if (ccw.count < info_len) {\n\n        /* Can't execute command. */\n\n        return -EINVAL;\n\n    }\n\n    if (!ccw.cda) {\n\n        return -EFAULT;\n\n    }\n\n    if (is_legacy) {\n\n        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        linfo.align = address_space_ldl_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(linfo.queue),\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n        linfo.index = address_space_lduw_be(&address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n", "idx": 10364, "substitutes": {"sch": ["cr", "gh", "ech", "ih", "sh", "sp", "ss", "rh", "usb", "sche", "tk", "Sch", "th", "wk", "chn", "sm", "cer", "kh", "ch", "mk", "sd", "chid", "sg", "gr", "hs", "kr", "ssl", "sk", "sc", "arch", "chip", "CH", "ssh", "hz", "isc", "ich"], "ccw": ["ccow", "accwd", "czwal", "ccws", " ccd", "ckow", "CCws", "ccy", " ccwt", "accwa", "cwa", "uccnw", " ccware", "ecd", "cy", "ccafw", "czwp", "ccnw", "icw", "cusware", " acW", " gccw", "czway", "cfwt", "ccaw", "ccfw", " acw", "cusw", "ckwt", " ccway", "ccwp", "ccd", " acwa", "cfwd", "czwd", "cusv", "uccwt", "ccwt", "ccaow", "scwa", "congw", "ckws", "ctxw", "cusway", "uccwd", "ccaws", "ecwt", "icwd", "ctxv", "pcw", "ckW", " gccW", " ccwal", "czy", "scw", "ccware", "accW", "ccv", "accws", "scword", "ccW", "icwt", "czow", " gccwa", "cfw", "cknw", "cword", "ccwa", "cwd", " ccy", "congwd", " ccwa", "accw", "cfnw", "pcway", "ecway", "congword", "ecw", "czfw", " ccW", "ccwd", "cwal", "ccwal", "CCW", "pcwp", "uccw", " gccwd", " ccwp", "ckfw", "czw", "scwd", "ccway", "CCwt", " ccv", "pcwd", "CCw", "icword", " ccwd", "cw", "accword", " acwd", "ccword", " ccword", "czwt", "ckwd", "ctxware", "accwt", "ctxway", "czws", "congwt", "czd", "ckw"], "check_len": ["infoablelif", "check_lif", "checkablelen", "infoableen", "checkitylif", "info_lif", "Check_Len", "check_ln", "Check_compl", "info_Len", "check_Len", "Check_len", "check_en", "check_compl", "checkityLen", "Check_ln", "infoablelen", "info_len", "checkitylen", "checkityen", "checkablelif", "info_en", "infoableLen", "checkableen", "checkableLen"], "is_legacy": ["is_Legacy", "is_LegACY", "is_regitimate", "is_privacy", "is_regacy", "is_magacy", "is_legical", "is_levitimate", "is_genantic", "is_genacy", "is_Legince", "is_regACY", "is_Legical", "is_privACY", "is_genACY", "is_Legantic", "is_regince", "is_legitimate", "is_Legitimate", "is_legince", "is_levince", "is_legantic", "is_magical", "is_privical", "is_magACY", "is_regantic", "is_legACY", "is_levacy"], "ret": ["r", "RET", "ft", "rev", " Ret", "cont", "xt", "re", "result", "usr", "Ret", " RET", "gt", "val", "rm", "out", "lt", "nt", "rets", "print", "mt", "try", "tr", "elt", "rt", "ref", "reset", "txt", "status", "res", "len", "resp", "alt", "Return", "rel"], "info": ["list", "py", "init", "where", "conf", "ote", "metadata", "no", "mem", "f", "type", "i", "iso", "test", "op", "id", "data", "stat", "by", "auth", "tip", "Info", "query", "fo", "good", "all", "notice", "help", "config", "time", "iter", "is", "hi", "history", "si", "index", "cache", "details", "def", "try", " inf", "unknown", " error", "local", "full", "ok", "note", "about", "fi", "it", "now", "ci", "kind", "check", "txt", "information", "num", "inf", "status", "ti", "row", "ist", "inner", "pi", "doc", "ki", "image", "INFO", "sort", "ready", "error"], "linfo": ["licgoo", " linph", "lnph", "lnso", " lingo", "lininfo", " linprop", "cinfo", "lnfo", "kinoha", "alinxf", "olinfo", " lininfo", "lninfo", "lifo", " linvey", "olinfi", "jinfo", "olinph", "olingoo", "linfe", " pinw", "olinprop", "jinmo", " linzz", "jinfi", "olinxf", "cinusr", "lnsty", "olinzz", "lnprop", "linxf", "jincho", "linusr", "kinso", "lnfi", "lincho", " pininfo", "linoha", " linfi", "liusr", "livey", "kinfi", "pinfi", "cinso", "lanfi", "lanfe", "jinprop", "cinfi", "lncho", "jinso", "cinvey", "lanaxy", " pinmo", "licfore", "kinfo", "pinfo", "lnmo", "pinmo", "linvey", "linph", "alinfi", "lingo", "lnco", "linco", "lango", "licxf", "lanso", "olinfe", "linmo", "lanmo", "linfore", "cincho", "alinfore", "lnoha", "olinmo", "cinsty", "linzz", "olinaxy", "linfi", "lanfo", "jinoha", "alinph", " pinfo", "kininfo", "lnzz", "olinfore", "jinsty", "olinvey", "lanprop", "olincho", "alinco", "pinfe", "lnvey", "olinusr", "jingo", "linw", "lingoo", "licfo", "linaxy", " linso", "lnw", "licho", "linsty", "kinmo", " linmo", "alinfo", "olinco", "olinso", " linw", "linprop", "alingoo", "kinaxy", "linso"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 10370, "substitutes": {"client": ["controller", "cli", "co", "web", "contact", "builder", "google", "channel", "close", "secure", "remote", "cache", "pattern", "force", "c", "manager", "current", "batch", "row", "template", "item", "cmd", "util", "collection", "ace", "public", "comment", "cell", "connect", "code", "all", "config", "obj", "Client", "core", "app", "match", "handle", "info", "attribute", "open", "protected", "p", "conn", "plugin", "confirmed", "entry", "command", "sim", "start", "window", "component", "patch", "out", "store", "complete", "server", "prefix", "project", "con", "pc", "self", "writer", "list", "friend", "quote", "connection", "call", "query", "cl", "application", "key", "debug", "event", "net", "form", "term", "local", "queue", "pat", "ce", "check", "grid", "lib", "response"], "err": ["r", "self", "cb", "die", "aaa", "cr", "dr", "cli", "Er", "conn", "ev", "rs", "attr", "rr", "der", "cfg", "norm", "fee", "str", "result", "fr", "usr", "good", "ex", "exc", "notice", "out", "n", " terr", "iter", "er", "g", "cer", "ch", "ah", "mk", "info", "eas", "arr", "desc", "elt", "gr", "mr", "fer", "kr", "oe", "br", "txt", "later", "res", "inner", "resp", "e", "eor", "msg", "error"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n", "idx": 10374, "substitutes": {"s": ["r", "ts", "p", "h", "sb", "ses", "rs", "f", "v", "sa", "sp", "es", "ss", "ps", "j", "gs", "sts", "space", "n", "fs", "sv", "sl", "is", "d", "st", "os", "q", "set", "js", "ds", "c", "sis", "S", "t", "sc", "se", "w", "ns"], "fd": ["rod", "ld", "bf", "bd", "df", "f", "ff", "du", "dd", "fc", "flo", "lf", "fed", "dl", "fb", " fid", "fa", "da", "tif", "fs", "td", "fn", "d", "fm", "dir", "FD", "fl", "sd", "fx", "dra", "fe", "fp", "fi", "ds", "fin", "ud", "db"], "virq": ["rivue", " virQ", " virue", "pirQ", "iovquire", "rivquire", " virqq", " virquire", "rivqq", "virtQ", "virQ", "viru", "piru", "rivq", "iovq", "iovue", "pirue", "virtue", "virquire", "virue", "iovqq", "virqq", " viru", "pirq", "virtq", "virtu"]}}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n", "idx": 10385, "substitutes": {"chan": ["cb", "opt", "conn", "cmd", "xy", "proc", "alloc", "cam", "rec", "ct", "an", "canon", "channel", "chn", "cp", "serv", "dir", "anon", "ch", "win", "act", "wh", "ach", "tx", "sys", "ctx", "Chan", "ann", "c", "res", "con", "arch", "can", "CH", "Ch", "wcs", "sch", "mon", "msg", "conv", "ich"], "cond": [" block", " conflict", " cursor", "condition", "Cond", " interrupt", "Condition", " transient", " obj", " timeout", " compress", " fut", " unconditional", " error", " Cond", " exc", " err", " instr", " code", " conditional", " conditions", "pos", " obs", " compressor", " bool", " proc", " trap"], "opaque": ["iposer", "ipula", "opartment", "ipartment", "ipque", "ipacity", "ioposer", " opacity", " Opascript", "ipent", " opque", "iopaque", "iopacity", "ipaque", " Opula", "opque", "bitque", "ipascript", "iopartment", "opascript", " Opaque", "iopent", "opula", "bitent", "bitoser", "bitaque", "iopque", "opent", " opartment", " opula", "oposer", "opacity", " Opque", " opascript"], "chr": ["chrar", "chre", "whlr", " chre", "echrs", "schr", "Chrar", " chmr", "CHrc", "echrb", "schl", "ichre", "Chrs", "schrar", "echre", "ichar", "echar", "chrs", " chrb", "Chl", "Chrb", "chrb", "chl", "chmr", "ichr", "whr", " chlr", " chrar", " chl", "ichrb", " chrs", " chrc", "CHlr", "schrb", "Char", "Chr", "echr", "CHr", "chrc", "chlr", "CHmr", "whrc", "whmr"], "s": ["changes", "sb", "ses", "ls", "aws", "sv", "bis", "js", "sys", "c", "t", "series", "se", "ms", "ins", "ns", "less", "search", "h", "ats", "sw", "ies", "settings", "ps", "http", "parts", "ess", "sq", "fs", "a", "sl", "serv", "set", "stats", "ds", "ssl", "services", "vs", "cs", "ims", "gets", "ports", "i", "its", "l", "store", "is", "b", "eps", "os", "y", "hs", "sis", "so", "conv", "self", "ts", "rs", "args", "ss", "syn", "es", "als", "gs", "j", "sts", "n", "details", "bs", "m", "S", "bits", "spec", "qs"], "status": ["active", "sync", "uses", "flag", "pres", "err", "success", "id", "Status", "ss", "stat", "sp", "name", "reason", "atus", "result", "str", "compl", "wait", "code", "progress", "summary", "in", "STAT", "US", "serv", "esp", "details", "st", "tr", "set", "js", "stats", "ssl", "c", "wa", "comments", "sc", "res", "current", "base", "resp", "valid", "gc", "cs", "state", "xml", "spec", "vis", "msg", "error"], "bufptr": ["cvcoord", "bufferproc", "boxctr", "buftrace", "bedpt", "bufctr", "ufcoord", "cbptr", "bufpointer", "cvcount", "vecptr", "bufPtr", "bufaddr", "ufPtr", "vecdepth", "bufprime", "cvctr", "boxprime", "cbctr", "bufferPtr", "ufprime", "buffpointer", "buffctr", "ufptr", "ufpointer", "boxptr", "propprime", "bufcount", "propptr", "ufcount", "proptrace", "bufferctr", "buffercount", "buffprime", "rabprime", "bufferprime", "buffptr", "bufferpointer", "cvaddr", "ufproc", "bedptr", "ufaddr", "proppt", "bufferptr", "veccoord", "vecaddr", "rabpt", "boxpointer", "bufproc", "cbpointer", "bufcoord", "bufpt", "cvproc", "bufdepth", "boxPtr", "bedprime", "cbprime", "ufctr", "bedtrace", "cvptr", "ufdepth", "rabtrace", "cvdepth", "rabptr"]}}
{"project": "qemu", "commit_id": "a01d8cadadf4c0dad8fc5157ee56aea8ec323982", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406, "substitutes": {"pic": ["p", "py", "i", "sp", "ic", "pb", "pict", "eric", "fc", "id", "ps", "Pic", "picture", "nic", "ics", "Picture", "pa", "script", " Pic", "asc", "sys", "fp", "fi", "IC", "mic", "c", "txt", "sc", "pi", "pc", "ig", "magic", "spec", "icc", "lib", "jp", "ac"], "s": ["sb", "ses", "events", "ls", "sh", "aws", "comm", "south", "sv", "as", "sam", "sys", "js", "c", "t", "se", "ms", "w", "ins", "ns", "h", "ats", "conf", "params", "settings", "ps", "an", "sq", "fs", "a", "sl", "sd", "q", "stats", "ds", "cs", "ims", "p", "i", "sa", "ar", "sp", "its", "l", "ops", "ex", "b", "is", "g", "os", "y", "hs", "so", "ips", "e", "us", "r", "ts", "rs", "v", "z", "ss", "es", "gs", "j", "sts", "n", "details", "bs", "pers", "m", "S", "im", "spec", "qs"], "d": ["r", "di", "p", "done", "dc", "ld", "send", "h", "x", "dr", "dx", "bd", "D", "i", "v", "dd", "der", "de", "id", "z", "dot", "gd", "add", "end", "ind", "l", "dict", "j", "new", "dt", "debug", "dos", "n", "o", "pd", "da", "md", "b", "g", "td", "er", "dh", "rest", "fd", "to", "y", "sd", "ds", "it", "m", "c", "t", "ad", "db", "e", "and", "w", "rd", "mod"], "PPC_io_memory": ["PPC_IO_media", "PPC_no2mem", "PPC_no_memory", "PPC_IO_storage", "PPC_io_message", "PPC_no_mem", "PPC_IO_memory", "PPC_io2media", "PPC_io_storage", "PPC_no_media", "PPC_io2mem", "PPC_no2memory", "PPC_io_mem", "PPC_no_message", "PPC_no2message", "PPC_io2memory", "PPC_no_storage", "PPC_io_media", "PPC_IO_mem", "PPC_no2media", "PPC_io2message"]}}
{"project": "FFmpeg", "commit_id": "6d24231e504f71a76a8fabe87c8d7cfa826da75a", "target": 0, "func": "static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n", "idx": 10410, "substitutes": {"avctx": ["averkt", "afconn", "aveca", "awconf", "wavctx", "wavtx", "AVkt", "avtx", "wavkw", "afctx", "avjp", " avkt", "averca", "avepkg", "averctx", "wavparams", "afca", "averpkg", "avcmd", "AVcmd", "avkw", "avercontext", "awctx", "avconf", "avecontext", "afkw", "averconf", "afparams", "avparams", " avcontext", "avca", "wavcontext", "averparams", "avertx", "averreq", "avekt", "avejp", " avpkg", "aveconn", "AVpkg", "awtx", "avereq", " avjp", "AVjp", "AVctx", "avkt", "avercmd", "afkt", " avtx", "avetx", "aftx", "avpkg", "afcontext", " avconf", "avreq", "avcontext", "avectx", "AVreq", "averconn", "avconn", "awcontext", "avecmd", "averkw"]}}
{"project": "FFmpeg", "commit_id": "14f3f3a1ad9aca7599bdaa399cdb8680c52dc696", "target": 1, "func": "static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb)\n\n{\n\n    v->res_rtm_flag = 1;\n\n    v->level = get_bits(gb, 3);\n\n    if(v->level >= 5)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Reserved LEVEL %i\\n\",v->level);\n\n    }\n\n    v->chromaformat = get_bits(gb, 2);\n\n    if (v->chromaformat != 1)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR,\n\n               \"Only 4:2:0 chroma format supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->postprocflag = get_bits(gb, 1); //common\n\n\n\n    v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1;\n\n    v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1;\n\n    v->broadcast = get_bits1(gb);\n\n    v->interlace = get_bits1(gb);\n\n    if(v->interlace){\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced mode not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    v->tfcntrflag = get_bits1(gb);\n\n    v->finterpflag = get_bits1(gb);\n\n    get_bits1(gb); // reserved\n\n    v->psf = get_bits1(gb);\n\n    if(v->psf) { //PsF, 6.1.13\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Progressive Segmented Frame mode: not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    if(get_bits1(gb)) { //Display Info - decoding is not affected by it\n\n        int w, h, ar = 0;\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display extended info:\\n\");\n\n        w = get_bits(gb, 14);\n\n        h = get_bits(gb, 14);\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display dimensions: %ix%i\\n\", w, h);\n\n        //TODO: store aspect ratio in AVCodecContext\n\n        if(get_bits1(gb))\n\n            ar = get_bits(gb, 4);\n\n        if(ar == 15) {\n\n            w = get_bits(gb, 8);\n\n            h = get_bits(gb, 8);\n\n        }\n\n\n\n        if(get_bits1(gb)){ //framerate stuff\n\n            if(get_bits1(gb)) {\n\n                get_bits(gb, 16);\n\n            } else {\n\n                get_bits(gb, 8);\n\n                get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        if(get_bits1(gb)){\n\n            v->color_prim = get_bits(gb, 8);\n\n            v->transfer_char = get_bits(gb, 8);\n\n            v->matrix_coef = get_bits(gb, 8);\n\n        }\n\n    }\n\n\n\n    v->hrd_param_flag = get_bits1(gb);\n\n    if(v->hrd_param_flag) {\n\n        int i;\n\n        v->hrd_num_leaky_buckets = get_bits(gb, 5);\n\n        get_bits(gb, 4); //bitrate exponent\n\n        get_bits(gb, 4); //buffer size exponent\n\n        for(i = 0; i < v->hrd_num_leaky_buckets; i++) {\n\n            get_bits(gb, 16); //hrd_rate[n]\n\n            get_bits(gb, 16); //hrd_buffer[n]\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 10414, "substitutes": {"v": ["p", "av", "dev", "x", "inv", "vim", "um", "value", "ev", "rev", "f", "qu", "vr", "z", "version", "l", "ver", "j", "query", "env", "en", "qv", "vm", "val", "va", "u", "n", "cv", "ve", "sv", "vt", "ov", "vv", "b", "g", "video", "er", "tv", "cache", "st", "var", "detail", "iv", "y", "q", "view", "max", "vi", "it", "V", "uv", "m", "wire", "t", "current", "status", "nv", "vs", "up", "pi", "vc", "vp", "lv", "k", "conv"], "gb": ["sb", "py", "cm", "cfg", "gd", "gt", "erb", "vm", "eb", "fb", "ib", "range", "buff", "hub", "sys", "db", "rb", "ruby", "GB", "tm", "cd", "raw", " rgb", "bt", "Gb", "gz", "mb", "sg", "tg", "wb", "bg", "storage", "um", "html", "xy", "pb", "gnu", "uf", "deg", "eg", "rect", "b", "bytes", "kb", "gm", "ctx", "verified", "gc", "pc", "gg", "lib", "cb", "bf", "goo", "gif", "gem", "mg", "nb", "args", "emb", "pg", "csv", "bc", "vg", "gs", "cz", "bb", "rg", "cv", "ch", "hog", "phy", "gam", "bits", "binary", "got", "bs", "img"], "w": ["r", "mm", "wd", "x", "wp", "sw", "z", "wi", "W", "l", "en", "window", "ex", "wx", "ew", "n", "a", "g", "wl", "d", "wh", "win", "iw", "s", "wt", "wid", "m", "wb", "wa", "weight", "t", "nw", "kw", "rw", "ww", "we", "man", "hw", "wal", "fw"], "h": ["p", " H", "hr", "dr", "html", "f", "ih", "hm", "sh", "z", "length", "rh", "height", "l", "en", "hd", "hz", "d", "u", "change", "n", "H", "o", "bh", "b", "g", "hi", "history", "oh", "ht", "he", "wh", "ch", "ah", "ph", "ha", "kh", "y", "hl", "hh", "hash", "q", "m", "c", "ho", "ish"]}}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 10416, "substitutes": {"address": ["search", "password", "ace", "directory", "region", "number", "add", "location", "network", "command", "interface", "page", "start", "date", "position", "order", "process", "record", "range", "ress", "size", "server", "domain", "pointer", "resource", "prefix", "index", "path", "attribute", "Address", "hash", "offset", "trace", "reference", "ip", "alias", "ad", "port", "dress", "point", "memory", "ase", "description", "message", "host", "length"], "pc": ["dc", "pic", "proc", "tc", "lp", "pp", "pid", "ic", "pb", "fc", "bp", "bc", " PC", "pt", "nc", "uc", "cu", "cc", "rc", "arc", "cp", "td", "pa", "ec", "pty", "asc", "PC", "ctx", "mc", "c", "cod", "sc", "oc", "xc", "cs", "gc", "vc", "isc"], "puc": ["cpuh", " pauc", "pauc", "cpUC", "pauh", "puh", "pUC", "iauc", "tauc", " pucc", "cpucc", "cpuc", "iUC", " puh", "tucc", "paucc", "pucc", "iucc", " pUC", "paUC", "tuc", "tUC", "iuc"], "prot": ["pro", "platform", "np", "proc", " shr", "seq", "mat", "eth", "tag", "type", "mult", "ret", "next", "typ", " protocol", " proto", " Proto", " plat", "stat", "fc", "method", "tp", "version", "pt", " fmt", " protocols", "lag", "format", "Prot", " PROT", "flags", "td", "net", "dh", "fl", "ext", "fd", "tr", "phys", "tf", "fp", " Prot", "pat", "prop", "ssl", "txt", "num", "top", "bits", " pref", "status", "ocol", "port", "pos", "pkg", "col", "ptr", "mobile", "rot", "msg", "cmd"], "p": ["pro", "pr", "pl", "np", "wp", "proc", "lp", "f", "i", "pp", "pre", "v", "sp", "pb", "op", "z", "tp", "pe", "dp", "bp", "pg", "pt", "ps", "j", "page", "rep", "comm", "progress", "patch", "policy", "out", "obj", "cp", "pd", "P", "post", "a", "g", "d", "app", "pa", "par", "cache", "ph", "parse", "pers", "y", "local", "fp", "pm", "pat", "m", "mp", "c", "t", "part", "port", "point", "resp", "ap", "pkg", "ping", "php", "vp", "w", "jp"], "host_start": [" host0end", "Host_length", " host0start", "Host_start", "host_art", "host_st", "host09start", "Host_begin", "host09next", "host0next", "host_size", "Host_end", " host0st", "host00end", " host_art", "host_begin", "host0start", "host_length", "host_key", "host09st", "host_next", "host00start", "Host_size", " host0next", " host_starting", " host_next", "host0end", "host00art", " host_st", "host_starting", "host0st", "host00starting", "host09end", "Host_key"], "host_end": ["host1ending", "host1END", "host_ends", "localhost_END", " host_max", "host_END", "target_stop", "localhost_ending", " host_END", "target_ends", "host1nd", "host_nd", "host1end", "host_ending", "host_stop", "localhost_nd", "host_ent", "localhost_end", "target_end", "target_start", "host_max", " host_ent"], "addr": ["wd", "x", "dr", "ls", "url", "end", "ix", "align", "index", "arr", "ref", "adr", "ad", "loc", "pkg", "ord", "ptr", "ms", "cmd", "ace", "on", "sw", "mem", "link", "ret", "ng", "ash", "oa", "order", "obj", "src", "mb", "handle", "arp", "hl", "rt", "lat", "gr", "res", "port", "host", "ag", "ack", "eth", "i", "coord", "points", "id", "pad", "l", "start", "oad", "at", "iter", "md", "mt", "dh", "Address", "elt", "ctx", "inter", "alias", "hw", "nz", "ac", "r", "att", "aj", "dev", "rs", "rev", "ast", "add", "mac", "aff", "adj", "offset", "gate", "ip", "pos", "point", "ap", "alt"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);\n\n}\n", "idx": 10429, "substitutes": {"dst": [" dport", "sest", "dsport", "dsdest", "ddest", "sst", " dest", "ldst", "rport", "dsest", "sdest", "lddest", "ldsc", "ssc", " dsc", "dsst", "dport", "rest", "rst", "ldest", "dsc", " ddest", "dest", "rdest"], "src": ["r", "dist", "sb", "np", "rs", "dq", "cur", "str", "trans", "rc", "sr", "in", "rl", "comp", "sl", "b", "inst", "st", "s", "ur", "impl", "gin", "iv", "hl", "sn", "input", "rt", "sys", "txt", "sc", "source", "loc", "inner", "bg", "dest", "ipl", "ptr", "ctr", "img", "ins"], "stride": ["trider", "trride", "strend", "slide", "drend", "strider", " strider", "stid", " strend", "struse", "slid", "Strride", "dride", "strage", "drride", "slope", "strride", "strope", "Struse", "druse", "divide", "strid", "STRride", " strride", "Stride", "stide", "Strend", "sride", "slider", " strope", " strage", " strid", "STRide", "sid", "slend", "divride", "tride", "stage", "slride", "side", "sage", "trope", "divid", "divend", "STRuse", "STRend"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int film_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 4)\n\n        return 0;\n\n\n\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 10449, "substitutes": {"p": ["r", "pod", "att", "pro", "art", "h", "np", "wp", "f", "pre", "pp", "v", "pb", "tp", "dp", "ps", "j", "progress", "process", "n", "cp", "P", "a", "post", "b", "g", "d", "pa", "pers", "q", "pat", "m", "c", "mp", "t", "ip", "press", "ad", "ap", "pkg", "up", "pc", "w", "jp"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,\n\n                       unsigned int size, int mem_index)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv taddr = tcg_temp_local_new();\n\n    TCGv tval = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    dc->postinc = 0;\n\n    cris_evaluate_flags(dc);\n\n\n\n    tcg_gen_mov_tl(taddr, addr);\n\n    tcg_gen_mov_tl(tval, val);\n\n\n\n    /* Store only if F flag isn't set */\n\n    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n    if (size == 1) {\n\n        tcg_gen_qemu_st8(tval, taddr, mem_index);\n\n    } else if (size == 2) {\n\n        tcg_gen_qemu_st16(tval, taddr, mem_index);\n\n    } else {\n\n        tcg_gen_qemu_st32(tval, taddr, mem_index);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */\n\n    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(tval);\n\n    tcg_temp_free(taddr);\n\n}\n", "idx": 10478, "substitutes": {"dc": ["di", "iac", "dr", "conn", "tc", "DC", "df", "cm", "dm", "cfg", "dp", "fc", "bc", "nc", "rec", "cd", "disc", "comm", "lc", "dt", "cc", "rc", "ctl", "cp", "da", "d", "ec", "tx", "ca", "ctx", "ds", "mc", "c", "ci", "sc", "oc", "xc", "cs", "pc", "doc", "gc", "ac"], "addr": ["r", "wd", "x", "ace", "dr", "conn", "mem", "eth", "attr", "rr", "alloc", "id", "add", "map", "ix", "oad", "oa", "at", "rc", "nl", "n", "src", "mt", "act", "tr", "var", "arp", "tx", "hl", "rt", "ref", "offset", "ctx", "adr", "ip", "pos", "alias", "ad", "loc", "pkg", "alt", "ptr", "host", "hw", "address"], "val": ["pol", "al", "p", "util", "dev", "pr", "vals", "Val", "value", "mem", "v", "ret", "vol", "test", "bal", "l", "bl", "lt", "label", "buf", "vt", "serv", "lit", "var", "tx", "rt", "ref", "eval", "VAL", "t", "loc", "alt", "vc", "el", "arg", "rel"], "size": ["equal", "send", "news", "sha", "ity", "sw", "mem", "type", "member", "sh", "sp", "number", "fee", "name", "ze", "capacity", "small", "notice", "space", "n", "count", "zone", "area", "sized", "scale", "Size", "si", "index", "see", "empty", "sn", "set", "style", "max", "now", "ize", "ci", "num", "len", "sum", "sy", "message", "iz", "SIZE", "length", "zero", "dimension", "scope"], "mem_index": ["mem2Index", "memoryposition", "mem2position", " mem_num", "mem_number", "mem2free", "memxnum", "memxind", "memzaddress", "mem_value", " mem_address", "memoryIndex", " mem_number", " mem_position", "mem_address", " mem_value", "mem2number", " mem_Index", "memznum", "memxindex", "memtfree", "mem_ind", "mem_free", "mem_num", "mem_instance", "memtposition", "memxnumber", "mem2ind", "memoryinstance", " mem_instance", "memzindex", " mem_free", " mem_ind", "mem2index", "mem_position", "mem_Index", "memoryindex", "memtIndex", "memzvalue", "memtindex", "mem2num"]}}
{"project": "qemu", "commit_id": "947858b0ba97f4ec097de667e45eff99212867c3", "target": 0, "func": "static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n", "idx": 10480, "substitutes": {"opaque": ["opity", "OPaques", "Oplation", "OPity", "cataque", "catque", "popque", "oplation", "oppaque", "iopity", "poplation", "OPiera", "iopaque", "operaques", "opque", "Opiera", "opiera", "iopaques", "oppque", "popaque", "OPaque", "cataques", "opaques", "Opaques", "Opity", "operaque", "operque", "iopque", "Opque", "popiera", "oppaques", "Opaque", "OPque", "OPlation"], "iocb": ["iocbc", "iocid", "dirocpb", "ioconb", "eiocbc", "iokbar", "iircbc", "piocbj", "ioricalb", "ioricalsb", "piocd", "piocbd", "ivocd", "irocbb", "iniocationbe", "iniocationb", "ioadv", "airocg", "airocd", "iiscB", "iocber", "piocyb", "pirocber", "ioca", "ioggsb", "pioadB", "airocb", "ioggb", "ioricalbc", "piocybar", "iocifb", "iniocbe", "iocg", "piocber", "iniocbc", "eiocpb", "iocybar", "iiscbb", "iiscbd", "ioadbd", "pirocb", "eioggpb", "dirocc", "eiocsb", "iocsb", "irocv", "airocv", "iocbd", "pioadb", "aiocb", "aiocv", "eioggbc", "iacona", "iocbf", "ioconc", "iallocpb", "irocber", "dioca", "diocc", "ioadg", "iocpb", "iallocbc", "iniocb", "pirocd", "piocb", "iocbe", "diocpb", "iallocsb", "iocyB", "irocc", "piocybj", "iorgber", "ivocg", "iocbar", "iocc", "piocB", "iircbe", "irocfb", "iocationbc", "iokB", "ioggbc", "irocpb", "iaconpb", "irocd", "ioconbf", "ioadbb", "iircb", "iocationbf", "iaconb", "eioggsb", "iociber", "piocyB", "ioadb", "ivocb", "dirocb", "iocB", "iallocb", "iocbj", "ioricalpb", "iiscb", "pirocfb", "eioggb", "iocybj", "iocib", "iniocationbc", "iocbb", "iniocationbf", "iocationb", "iocona", "iaconc", "ioadB", "irocB", "aiocg", "ioconbc", "iokbj", "ivocv", "piocfb", "ioconpb", "irocg", "aiocd", "iocyb", "iokb", "iorgfb", "iircbf", "iroca", "iorgd", "irocbar", "pioadbb", "iorgb", "irocbd", "iocationbe", "ioconbe", "eiocb", "iniocbf", "iocd", "ioadd", "irocb", "pioadbd", "ioggpb", "diroca", "irocbj", "piocbar", "piocbb", "iocfb", "diocb", "iocv"]}}
{"project": "qemu", "commit_id": "ad11ad77748bdd8016370db210751683dc038dd6", "target": 0, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n\n                            abi_long cmd, abi_long arg)\n\n{\n\n    void *argptr;\n\n    struct dm_ioctl *host_dm;\n\n    abi_long guest_data;\n\n    uint32_t guest_data_size;\n\n    int target_size;\n\n    const argtype *arg_type = ie->arg_type;\n\n    abi_long ret;\n\n    void *big_buf = NULL;\n\n    char *host_data;\n\n\n\n    arg_type++;\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        ret = -TARGET_EFAULT;\n\n        goto out;\n\n    }\n\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n\n    unlock_user(argptr, arg, 0);\n\n\n\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n\n    memcpy(big_buf, buf_temp, target_size);\n\n    buf_temp = big_buf;\n\n    host_dm = big_buf;\n\n\n\n    guest_data = arg + host_dm->data_start;\n\n    if ((guest_data - arg) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n\n    host_data = (char*)host_dm + host_dm->data_start;\n\n\n\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n\n    switch (ie->host_cmd) {\n\n    case DM_REMOVE_ALL:\n\n    case DM_LIST_DEVICES:\n\n    case DM_DEV_CREATE:\n\n    case DM_DEV_REMOVE:\n\n    case DM_DEV_SUSPEND:\n\n    case DM_DEV_STATUS:\n\n    case DM_DEV_WAIT:\n\n    case DM_TABLE_STATUS:\n\n    case DM_TABLE_CLEAR:\n\n    case DM_TABLE_DEPS:\n\n    case DM_LIST_VERSIONS:\n\n        /* no input data */\n\n        break;\n\n    case DM_DEV_RENAME:\n\n    case DM_DEV_SET_GEOMETRY:\n\n        /* data contains only strings */\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        break;\n\n    case DM_TARGET_MSG:\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n\n        break;\n\n    case DM_TABLE_LOAD:\n\n    {\n\n        void *gspec = argptr;\n\n        void *cur_data = host_data;\n\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n        int spec_size = thunk_type_size(arg_type, 0);\n\n        int i;\n\n\n\n        for (i = 0; i < host_dm->target_count; i++) {\n\n            struct dm_target_spec *spec = cur_data;\n\n            uint32_t next;\n\n            int slen;\n\n\n\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n\n            slen = strlen((char*)gspec + spec_size) + 1;\n\n            next = spec->next;\n\n            spec->next = sizeof(*spec) + slen;\n\n            strcpy((char*)&spec[1], gspec + spec_size);\n\n            gspec += next;\n\n            cur_data += spec->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        ret = -TARGET_EINVAL;\n\n        goto out;\n\n    }\n\n    unlock_user(argptr, guest_data, 0);\n\n\n\n    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (!is_error(ret)) {\n\n        guest_data = arg + host_dm->data_start;\n\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n\n        switch (ie->host_cmd) {\n\n        case DM_REMOVE_ALL:\n\n        case DM_DEV_CREATE:\n\n        case DM_DEV_REMOVE:\n\n        case DM_DEV_RENAME:\n\n        case DM_DEV_SUSPEND:\n\n        case DM_DEV_STATUS:\n\n        case DM_TABLE_LOAD:\n\n        case DM_TABLE_CLEAR:\n\n        case DM_TARGET_MSG:\n\n        case DM_DEV_SET_GEOMETRY:\n\n            /* no return data */\n\n            break;\n\n        case DM_LIST_DEVICES:\n\n        {\n\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n\n\n\n            while (1) {\n\n                uint32_t next = nl->next;\n\n                if (next) {\n\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n\n                }\n\n                if (remaining_data < nl->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + nl_size, nl->name);\n\n                cur_data += nl->next;\n\n                remaining_data -= nl->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                nl = (void*)nl + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_DEV_WAIT:\n\n        case DM_TABLE_STATUS:\n\n        {\n\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n            int spec_size = thunk_type_size(arg_type, 0);\n\n            int i;\n\n\n\n            for (i = 0; i < host_dm->target_count; i++) {\n\n                uint32_t next = spec->next;\n\n                int slen = strlen((char*)&spec[1]) + 1;\n\n                spec->next = (cur_data - argptr) + spec_size + slen;\n\n                if (guest_data_size < spec->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n\n                cur_data = argptr + spec->next;\n\n                spec = (void*)host_dm + host_dm->data_start + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_TABLE_DEPS:\n\n        {\n\n            void *hdata = (void*)host_dm + host_dm->data_start;\n\n            int count = *(uint32_t*)hdata;\n\n            uint64_t *hdev = hdata + 8;\n\n            uint64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10485, "substitutes": {"ie": ["ine", "icer", "die", "ace", "ies", "eur", "ive", "de", "dm", "tie", "ind", "ties", "ei", "esi", "ji", "ied", "wife", "eg", "iu", "eve", "iy", "ect", "me", "addy", "ctl", "ice", "estate", "ite", "el", "er", "eddy", "dem", "sie", "ipe", "ini", "driver", "oe", "it", "ce", "ele", "ia", "io", "je", "ij", "ee", "exe", "e", "ig", "le", "ide", "se", "ze", "IE"], "buf_temp": ["buf_tem", " buf_tmp", "buf32tem", "buf_0", " buf_ptr", "uf_temp", "buf_iter", "buf32emp", "batch_tem", "buf2tmp", " buf_buffer", "batch_emp", "batch_ptr", "buf2tem", "buf_tmp", "buffer_tmp", "buf32temp", "buf_emp", "batch_temp", "uf_tem", "batch32tem", "uf_0", "batch32emp", "buffer_tem", "batch32ptr", "buf_buffer", "buf32ptr", "buffer_iter", "buffer_temp", "uf_tmp", "buf2temp", "buf_ptr", "uf_iter", "batch32temp", "buf2iter"], "fd": [" offset", " func", "bf", "f", " df", " ev", "pid", "id", "fc", "ef", "Ret", " dst", "d", " sig", "fe", " dev", "af", "ref", " f", " resp", "t", "res", " res", " def", " af", " proc", " fin"], "cmd": ["wd", "init", "bind", "type", "addr", "op", "name", "command", "ct", "cd", "code", "buf", "cp", "nt", "md", "dir", "Cmd", "desc", "ctx", "kind", "target", "cut", "ptr", "host", "ctr", "gen", "msg"], "arg": ["ack", "p", "or", "flag", "deb", "mem", "tag", "attr", "ar", "err", "addr", "args", "op", "add", "pg", "emb", "ob", "call", "gt", "new", "val", "key", "admin", "in", "bar", "iter", "md", "g", "event", "par", "ext", "param", "var", "arp", "field", "arr", "bit", "ok", "ref", "reg", "argument", "Arg", "it", "inter", "prop", "target", "t", "ang", "ig", "doc", "ptr", "orig", "ag", "msg"], "argptr": ["arrptr", "arcert", "varPtr", "jobj", "igpointer", "opPtr", "argspointer", "argobj", "arrpr", "opptr", "argsPtr", "mempointer", "argpointers", "igptr", "argpt", "aggpointer", "varpointers", "argcert", "arptr", "argpointer", "arrobj", " argpr", "argsptr", " argPtr", "retcert", "arpointer", "artr", "igpt", "mempt", "igpointers", "mempointers", " argobj", "oppointer", " argpad", " argpointer", "argspad", "argPtr", "jpr", "aggpad", "varpointer", "aggPtr", "jpointer", "aggptr", " argpt", "argpad", "retptr", " argcert", "optr", "arPtr", "arrpointer", "memptr", " argtr", " argpointers", "retPtr", "arpointers", "varptr", "retpointer", "jptr", "argpr", "argtr"], "host_dm": ["work___drm", " host2dim", "host5dx", "host5dim", "host_dim", "host_nm", "other_nm", " host_DM", " host2dev", " host_cm", " host_mont", "host_dom", "host2dev", "host2dm", "host_drm", " host_dom", "hostMDM", " hosteddl", "host_dev", "work___dim", "host2dem", "hostLdm", "hostMdev", "hosteddm", "host_dt", "host___dem", "work_drm", " host_dem", "host2mont", "hostMdm", "work_dm", " host2DM", "server_dem", " hosteddm", "host5dm", "other_drm", "hostLdir", "host___dim", "hosteddl", "host_deb", "server_dim", "host_DM", " host2dem", "work_dx", "host2dx", " hosteddir", "host___dm", "host2DM", " host_dev", "host___drm", "other_dm", "server_dt", "hosteddir", "host___dev", "server_dm", "hosteddim", "hostLdim", "host2dim", " host_dl", "host_cm", "work___dx", " host_deb", "hostMdem", "other_dem", "host5drm", " host_dim", " host_dir", " host2mont", "work___dm", " host2dm", "host_dem", "host2drm", "host___dx", "host_dl", "host_dir", "host___DM", "host_mont", "host_dx", " hosteddim", "work_dim", "hostLdl"], "guest_data": ["guestJdata", "guost7image", "guEST2start", "guess_value", "guEST_value", "guest_name", "guess_size", "guost_Data", "guesteddata", "guesttdata", "guEST_no", "guest2Data", "guest2start", "guost7Data", "guest_DATA", "guEST2data", "guess_no", "guesttsize", "guest7Data", "guest2data", "guost7data", "guEST2DATA", "guest_start", "guesttvalue", "guest2image", "guEST_DATA", "guest2DATA", "guest7name", "guest_Data", "guess_data", "guest7data", "guest2size", "guost7name", "guesttno", "guEST2no", "guEST_data", "guestedvalue", "guest2name", "guestJDATA", "guost_name", "guest2no", "guest_value", "guestJstart", "guest2value", "guEST_start", "guost_data", "guest_no", "guest_image", "guest7image", "guestJno", "guestedDATA", "guest_size", "guost_image"], "guest_data_size": ["guest_data_Size", "guest_data_name", "guest_data_SIZE", "guest_data_length", "guest_block_length", "guest_block_size", "guest_data_sum", "guest_block_SIZE", "guest_block_Size"], "target_size": ["target7number", "Target_number", "targetvalnews", "target64string", "target32dim", "target_Size", "target32speed", "targetvaltype", "targetvalsize", "buffer_dim", "target64dim", "target64speed", "target_news", "arget_name", "target32string", "target_string", "arget_size", "target_number", "targetvaldim", "arg_size", "target7Size", "target7size", "arg32dim", "target_speed", "target32size", "buffer_news", "target_dim", "target64size", "arg32speed", "arg_dim", "Target_Size", "arg32string", "arg32size", "arget_Size", "arg_speed", "Target_size", "arg_string", "target_name", "buffer_size", "target_type", "buffer_type"], "arg_type": ["tag_name", "target_count", "arg_ype", "tag_type", "target_TYPE", "arg_label", "argmmname", "ig_var", "arg_length", "argtlength", "arg_name", "tag_length", "arg_case", "ig_type", "arg_TYPE", "arg_size", "argmmcase", "arg_t", "argttype", "argtname", "target_t", "arg_var", "argmmtype", "ig_group", "arg_Type", "argtype", "argmmlabel", "ig_Type", "target_label", "arg_group", "target_name", "tag_ype", "arg_count", "target_type", "target_case"], "ret": ["r", "ts", "att", "x", "dr", "flag", "RET", "red", "ft", "slot", "rev", "eth", "f", "err", "jump", " flags", "re", "__", "result", "j", "gt", "Ret", "val", "rm", "out", "nt", "g", "print", "mt", "def", "tr", "try", "ext", "desc", "elt", "rt", "ref", " ref", "sys", "reg", "target", "t", "status", "res", "ll", "resp", "alt", "gc", "Return", "nz"], "big_buf": ["bigJtemp", "Big_buffer", "big_Buff", "big2uf", "bigJbuf", " big_Buff", "fatPtmp", " big_tmp", "bigJBuff", "biglyBuff", "biglybuf", "big_tmp", "big___buf", "big2buff", "fat_uf", "big_buffer", "bigPuf", " big_data", "big_temp", " big_temp", "big___uf", "bigPdata", " big_uf", "fat_buf", "big_uf", " big_buffer", "big2buffer", "big_buff", "Big_buff", "big__buf", "bigPbuf", "big__data", "big___tmp", "biglytemp", "big_mem", "big_data", "Big_buf", "bigJbuffer", "fatPuf", "Big_uf", "big__buffer", "big__tmp", "big___mem", "bigPtmp", "biglybuffer", "fat_tmp", " big_buff", "fat_mem", "bigPbuffer", "fatPbuf", "big2buf", "bigPmem", "fatPmem"], "host_data": ["host_DATA", "Host_name", "Host_done", "host2data", "host2dir", "hub_memory", "Host_data", "host_memory", "hub_DATA", "host_dir", "hub_data", "host2done", "host_done", "Host_dir", "hub_name", "host_name", "host2name"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)\n\n{\n\n    InputStream        *ist = s->opaque;\n\n    DXVA2Context       *ctx = ist->hwaccel_ctx;\n\n    int                ret;\n\n\n\n    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_frame_copy_props(ctx->tmp_frame, frame);\n\n    if (ret < 0) {\n\n        av_frame_unref(ctx->tmp_frame);\n\n        return ret;\n\n    }\n\n\n\n    av_frame_unref(frame);\n\n    av_frame_move_ref(frame, ctx->tmp_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 10498, "substitutes": {"s": ["p", "h", "sb", "rs", "i", "v", "ls", "sp", "ss", "es", "its", "ps", "xs", "gs", "sts", "ess", "sq", "fs", "sv", "is", "g", "os", "sac", "sie", "set", "sg", "js", "sys", "hs", "ds", "c", "S", "cs", "e", "bs", "ns"], "frame": ["scene", "init", "seq", "feature", "cf", "fact", "f", "flow", "data", "fram", "sample", "fr", "code", "window", " Frame", "rame", "fb", "process", "piece", "feat", "Frame", "file", "video", "form", "def", "ext", "one", "none", "force", "ref", "fe", "sequence", "header", "fi", "face", "ce", "profile", "iframe", "draw", "chain", "hide", "framework", "ence", "block", "base", "point", "message", "context", "word", "doc", "image", "spec", "zero"], "ist": ["imet", "art", "osi", "ith", "wp", "alist", "ous", "ih", "ive", "ift", "xt", "ast", "ic", "ird", "its", "IS", "ind", "oci", "ust", "ert", "ik", "iss", "exist", "pect", "IST", "ess", "isi", "bh", "ost", "is", "sys", "aci", "iste", "it", "ism", "ists", "et", "isting", "ij", "est", "ush", "iop", "irst", "isc"], "ctx": ["cb", "np", "conn", "tc", "cf", "cm", "addr", "std", "ck", "cfg", "tm", "bp", "bc", "nc", "ct", "crit", "tk", "jac", "comm", "lc", "dl", "cu", "cc", "mom", "wx", "cv", "obj", "cp", "nt", "ctl", "history", "kl", "mk", "tx", "desc", "cmp", "sys", "iat", "ns", "wid", "ctrl", "mc", "req", "kt", "kw", "loc", "pkg", "vc", "gc", "context", "ctr", "msg", "scope", "jp", "cmd"], "ret": ["cat", "err", "gt", "Ret", "en", "rm", "vet", "print", "def", "arr", "ref", "sys", "reg", "t", "len", "ll", "ter", "cmd", "git", "cont", "xt", "code", "after", "expr", "desc", "rt", "ry", "rier", "it", "txt", "res", "ben", "pret", "fun", " Ret", "result", "prot", " RET", "deg", "reply", "rem", "out", "nt", "iter", "mt", "try", "tr", "elt", "inter", "nz", "arg", "RET", "ft", "re", "j", "usr", "val", "rets", "net", "back", " fut", "ext", "reset", "pat", "num", "ber", " res", "cert", "det", "resp", "alt"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,\n\n                    uint8_t *segment, uint8_t *ref, int layout)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (s->segmentation.update_map)\n\n        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);\n\n    else if (s->segmentation.enabled)\n\n        *segment = ref ? *ref : *segment;\n\n    mb->segment = *segment;\n\n\n\n    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;\n\n\n\n    if (s->keyframe) {\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,\n\n                                    vp8_pred16x16_prob_intra);\n\n\n\n        if (mb->mode == MODE_I4x4) {\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);\n\n        } else {\n\n            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;\n\n            if (s->mb_layout == 1)\n\n                AV_WN32A(mb->intra4x4_pred_mode_top, modes);\n\n            else\n\n                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);\n\n            AV_WN32A(s->intra4x4_pred_mode_left, modes);\n\n        }\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                vp8_pred8x8c_prob_intra);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {\n\n        // inter MB, 16.2\n\n        if (vp56_rac_get_prob_branchy(c, s->prob->last))\n\n            mb->ref_frame =\n\n                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */\n\n                                                      : VP56_FRAME_GOLDEN;\n\n        else\n\n            mb->ref_frame = VP56_FRAME_PREVIOUS;\n\n        s->ref_count[mb->ref_frame - 1]++;\n\n\n\n        // motion vectors, 16.3\n\n        decode_mvs(s, mb, mb_x, mb_y, layout);\n\n    } else {\n\n        // intra MB, 16.1\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);\n\n\n\n        if (mb->mode == MODE_I4x4)\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                s->prob->pred8x8c);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n        mb->partitioning     = VP8_SPLITMVMODE_NONE;\n\n        AV_ZERO32(&mb->bmv[0]);\n\n    }\n\n}\n", "idx": 10502, "substitutes": {"s": ["changes", "sb", "ses", "ls", "am", "aws", "comm", "ib", "sv", "sym", "as", "sam", "has", "rest", "js", "sys", "t", "series", "se", "w", "ms", "ins", "ns", "h", "ats", "conf", "sw", "tm", "settings", "ps", "http", "parts", "sq", "bound", "fs", "a", "sl", "app", "sd", "esm", "stats", "ds", "sc", "vs", "mys", "cs", "ims", "sub", "p", "mm", "i", "ar", "its", "l", "sim", "sports", "ops", "ex", "o", "b", "is", "g", "os", "hs", "e", "us", "r", "ts", "rs", "f", "v", "args", "mg", "ss", "gs", "j", "sts", "n", "details", "bs", "states", "m", "S", "mp", "bits", "spec", "bm", "qs"], "mb": ["sb", "orb", "sh", "mor", "BM", "vm", "eb", "ib", "amb", "sm", "xb", "sv", "byte", "ghost", "db", "rb", "ms", "mn", "cmd", "GB", "ab", "mem", "brain", "irm", "em", "ob", "jpg", "bl", "ml", "nm", "bound", "fm", "shape", "umb", "mc", "meg", "mop", "MB", "mm", "nob", "um", "bd", "job", "pb", "bp", "mar", "sim", "arb", " MB", "md", "b", "mt", "kb", "embed", "ym", "iam", "mob", "members", "memory", "bf", "v", "mg", "ebin", "norm", "emb", "bb", "sbm", "orm", "tab", "gb", "m", "mp", "mx", "im", "bs", "bm"], "mb_x": ["emb__ex", "emb__y", "emb__x", "emb_wx", "emb_ex", "emb_z", "mb__ex", "mb_tx", "MB_x", "MB_y", "mb_ex", "mb_wx", "mb__x", "MB_t", "emb_width", "mb__y", "mb_t", "mb_z", "mb_width", "mb__wx", "MB_tx", "emb_x", "emb_y", "emb__wx"], "mb_y": ["mb08z", "mb8y", "MB_z", "mb_yy", "mb08x", "MB_x", "mb8x", "mb08y", "MB_y", "mb08yy", "mb8yy", "MB_yy", "mb_z", "mb8z"], "segment": [" segement", "segn", "seagement", "asement", " sement", "segments", "lemission", "ement", "tega", "gement", "schega", "SEgement", "segan", "schegent", "gegments", "gega", "schegest", "gegment", "pement", "segement", "schement", " segm", "legment", "SEment", " segan", "vement", "tegent", "vegment", "schegement", "seagment", "legan", "segm", "semission", "SEgment", "segest", "egement", "sement", "seament", "tegment", " segments", "asegment", "vegn", "pegn", "pegm", "asegments", "vegm", "pega", "asegement", "egments", "vegan", "tegments", "pegment", "schegment", " segent", "segent", "lement", "seagest", " sega", "SEgest", "vemission", "schegments", " semission", "vegments", "pegments", "sega", "egment", "vega", " segn"], "ref": ["p", "bf", "physical", "snap", "conf", "seq", "mem", "rev", "tag", "Ref", "link", "f", "id", "pb", "re", "ef", "map", "page", "REF", "parent", "nav", "raw", "only", "range", "through", "remote", "diff", "b", "g", "index", "tab", "phys", "term", "full", "cmp", "af", "offset", "reg", "rt", "inter", "br", "req", "part", "pos", "buffer", "block", "row", "alt", "col", "reference", "rel"], "layout": ["lay", "slot", "flow", "frame", "id", "format", "settings", "tm", "params", "location", "height", "padding", "layer", "position", "scroll", "lc", "lag", "range", "label", "config", "margin", "loop", "join", "Layout", "scale", "mt", "def", "shape", "phys", "board", "display", " Layout", "none", "style", "offset", "draw", "mode", "template", "density", "level", "delay"], "c": ["r", "cpp", "p", "dc", "cb", "h", "co", "conf", "C", "cus", "cf", "tc", "f", "v", "cm", "cont", "fc", "bc", "l", "ct", "nc", "cd", "uc", "lc", "cu", "cc", "unc", "at", "rc", "u", "n", "cv", "cp", "a", "g", "b", "d", "cache", "ch", "ec", "com", "ca", "ctx", "ce", "mc", "m", "t", "chain", "sc", "con", "xc", "cs", "e", "context", "vc", "gc", "w", "cn", "ac"], "ref_frame": ["orig_state", "refpoframe", "origpoblock", "refporange", "origpostate", "refpoblock", "orig_frame", "origporange", "ref_range", "orig_range", "ref_block", "refpostate", "origpoframe", "ref_state", "orig_block"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    /* make sure instructions are on a halfword boundary */\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    /* Enforce properly-sized instructions in a delay slot */\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            /* GP */\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            /* MOVEP */\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n", "idx": 10504, "substitutes": {"env": ["dev", "sb", "conf", "proc", "conn", "ev", "err", "v", "esc", "pe", "environment", "ef", "ei", "en", "eg", "her", "ep", "org", "estate", "ew", "buf", "config", "vt", "enc", "er", "viron", "te", "ner", "ec", "eu", "ah", "param", "equ", "manager", "et", "eh", "ee", "context", "e", "ptr", "erd"], "ctx": ["x", "co", "np", "tc", "cm", "cfg", "ind", "nc", "xs", "cp", "history", "index", "sys", "iat", "loc", "kw", "xc", "pkg", "wcs", "jp", "cmd", "util", "conf", "mem", "tz", "abc", "cu", "org", "stack", "ctl", "obj", "config", "gz", "act", "shape", "tx", "mc", "req", "ctrl", "txt", "utils", "sc", "anc", "scope", "cn", "today", "init", "conn", "cf", "wp", "ck", "exec", "warn", "crit", "mom", "xp", "setup", "nt", "prefix", "that", "kb", "cmp", "gc", "hw", "conv", "func", "cb", "timeout", "document", "px", "bc", "ct", "cl", "jac", "cc", "wx", "cv", "work", "check", "kt", "resp", "context"], "is_branch": ["is_balarc", "is_blanch", "is_blag", "is_BRag", "is_balranch", "is_balag", "is_brag", "is_brarc", "is_balanch", "is_blarc", "is_brranch", "is_BRanch", "is_BRarc", "is_BRranch", "is_blranch"], "op": ["pol", "p", "or", "ot", "opt", "rop", "opl", "ype", "i", " ip", "hop", "oper", "pp", "typ", "ipp", "sp", "type", "ic", "tp", "cop", "sci", "pop", "rep", "OP", "Op", "ops", "gp", "xp", "o", "cp", "oop", "os", "arp", "bit", "cmp", "ok", "iat", " cop", "pat", "ip", "top", "pos", "operator", "oc", "mop", "osp", "ap", "up", "yp", "ope", "iop", "comp", "omp", "jp"]}}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)\n\n{\n\n    int i;\n\n    int vlc    = get_bits1(&q->gb);\n\n    int start  = cplband[p->js_subband_start];\n\n    int end    = cplband[p->subbands - 1];\n\n    int length = end - start + 1;\n\n\n\n    if (start > end)\n\n        return;\n\n\n\n    if (vlc)\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);\n\n}\n", "idx": 10513, "substitutes": {"q": ["r", "self", "h", "Q", "qq", "conf", "conn", "dq", "quote", "f", "v", "pp", "ck", "qu", "z", "iq", "j", "query", "question", "comm", "quit", "qt", "qa", "sq", "ve", "cp", "g", "ch", "eq", "gm", "info", "y", "tx", "quer", "ry", "ctx", "quest", "req", "c", "t", "qi", "requ", "aq", "pkg", "k", "w", "qs"], "p": ["att", "pro", "pl", "h", "np", "wp", "lp", "f", "pp", "v", "pre", "sp", "pb", "op", "tp", "pe", "dp", "bp", "pg", "pt", "ps", "j", "rep", "at", "cp", "P", "post", "b", "g", "d", "app", "pa", "er", "s", "os", "local", "pm", "fp", "c", "m", "part", "t", "press", "ip", "ap", "pkg", "pc", "vp", "w", "jp"], "decouple_tab": ["decoupleBcart", "decurry_bag", "decouple_bag", "decouple_ab", "decouple2tab", "decour_cart", "decouple_abs", "decurry_ab", "decouple2port", "decouple_table", "decouple2Tab", "decoupleBtable", "decouple_cart", "decurry_trans", "decoupleBtab", "decour_abs", "decouple_trans", "decouple2table", "decrue_tab", "decoupleBabs", "decouple_port", "decour_table", "decour_tab", "decrue_table", "decurry_tab", "decrue_Tab", "decrue_port", "decouple_Tab"], "i": ["ui", "di", "ami", "cli", "x", "init", "span", "v", "gi", "ic", "ai", "id", "iq", "ind", "l", "ii", "ei", "xi", "start", "I", "sim", "phi", "ji", "ix", "iu", "oi", "multi", "bi", "in", "me", "PI", "ni", "this", "is", "g", "print", "si", "li", "y", "ini", "gu", "it", "\u0438", "ci", "c", "m", "io", "t", "ip", "mi", "qi", "zi", "ij", "chain", "ti", "batch", "im", "cgi", "pi", "series", "client", "ki", "ims", "ms", "ski", "us"]}}
{"project": "FFmpeg", "commit_id": "d1f3e475f9807b445ba37ff2fd23f71c4645de79", "target": 1, "func": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n", "idx": 10520, "substitutes": {"pkt": ["packet", "cpct", "ppck", "perkt", "spact", "pact", "mact", "Pcmd", "cpacket", "pnt", "pst", "prkt", "prst", "prnt", "pcmd", "ppkt", "pct", " pck", "placket", " pnt", "ppct", "spkt", " preq", "preq", "pracket", " pct", "ppacket", "cpkt", "met", "Pst", "Pkt", "spet", " pst", "ppnt", "percmd", "peracket", "perreq", "mkt", "Pnt", "pck", "cpnt", "spkg", "plck", " pet", "pkg", " pkg", "Packet", "mkg", " pact", " packet", "plkt", "Preq", "pet", " pcmd"], "pkt_data": ["pnt_data", "pkt_map", "pkt2data", "pkt_def", "pck_data", "pck_Data", "pnt_def", "pck_no", "pkt2cache", "pck_cache", "pkt_no", "pkt_cache", "pck2cache", "pnt_dat", "pkt_Data", "pck2data", "pck2no", "pnt_map", "pkt2no", "pkt2Data", "pck2Data", "pkt_dat"], "pts": ["ptps", "ptts", "ntds", "ptds", " ptrts", "nts", " cmdps", "posxs", "ptruts", "plxs", " ptrs", "points", "ptTs", "apts", "ntts", "ptrds", "ptuts", " cmdTs", " ptps", " cmdts", " cmds", "pls", "pointds", "posts", " ptrps", "posls", "pointts", "aptxs", "ptls", "ptrs", "pointuts", "poss", "aptts", "ntuts", " ptts", "ptxs", "plls", " ptTs", "plts", "aptls", " ptrTs", "ptrts"], "ret": ["r", "pas", "flag", "RET", "final", "ft", "mem", "rev", "cont", "xt", "re", "result", "l", "j", "gt", "Ret", "deg", " RET", "usr", "val", "after", "out", "nt", "rets", "print", "mt", " alt", "tr", "elt", "rt", "ref", "set", "txt", "t", "et", "len", "res", "status", "det", "resp", "alt", "ter"], "data": ["options", "art", "p", "al", "extra", "done", "list", "DATA", "xy", "mem", "bin", "type", "json", "ATA", "read", "ata", "id", "format", "name", " DATA", "result", "Data", "str", "map", "window", "good", "new", "error", "raw", "content", "all", "out", "n", "and", "nt", "size", "da", "d", "bytes", "details", "cache", "dat", "def", "partial", "info", "empty", "bus", "m", "text", "t", "body", "buffer", "rew", "len", "row", "table", "results", "any", "valid", "message", "mu", "image", "aw", "doc", "rel"]}}
{"project": "FFmpeg", "commit_id": "54b2d317ed99622efa07b10aca217e1a083105d9", "target": 0, "func": "static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){\n\n    int i,j,k,m;\n\n    double l2tab[256];\n\n\n\n    for(i=1; i<256; i++)\n\n        l2tab[i]= log2(i/256.0);\n\n\n\n    for(i=0; i<256; i++){\n\n        double best_len[256];\n\n        double p= i/256.0;\n\n\n\n        for(j=0; j<256; j++)\n\n            best_len[j]= 1<<30;\n\n\n\n        for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){\n\n            double occ[256]={0};\n\n            double len=0;\n\n            occ[j]=1.0;\n\n            for(k=0; k<256; k++){\n\n                double newocc[256]={0};\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        len -=occ[m]*(     p *l2tab[    m]\n\n                                      + (1-p)*l2tab[256-m]);\n\n                    }\n\n                }\n\n                if(len < best_len[k]){\n\n                    best_len[k]= len;\n\n                    best_state[i][k]= j;\n\n                }\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        newocc[    one_state[    m]] += occ[m]*   p ;\n\n                        newocc[256-one_state[256-m]] += occ[m]*(1-p);\n\n                    }\n\n                }\n\n                memcpy(occ, newocc, sizeof(occ));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10539, "substitutes": {"best_state": ["best_point", "bestacnode", "orst_int", "bestacstates", "bestvaltag", "best_int", "selected_tag", "best_states", "bestvalstate", "bestvalindex", "bestacint", "orst_states", "bestvalpoint", "best_tag", "orst_node", "bestipstate", "selected_state", "bestipnode", "bestipint", "bestacstate", "orst_state", "selected_point", "selected_index", "bestipstates", "best_index", "best_node"], "one_state": ["one_size", "nodeplacestate", "node_group", "one_group", "one_states", "one___states", "ome_resource", "node_states", "one_resource", "ome_size", "oneplacegroup", "nodeplacestates", "ome_states", "one_status", "one___status", "oneplacestate", "node_state", "oneplacestates", "oneplacestatus", "one_job", "one_slice", "one___state", "ome_state", "nodeplacestatus", "one___group", "nodeplacegroup", "node_status"], "i": ["ami", "cli", "x", "json", "ind", "ix", "iu", "u", "bi", "print", "index", "li", "this", "io", "ti", "jp", "gi", "ic", "ei", "I", "phi", "ik", "ie", "info", "it", "qi", "mi", "ij", "ki", "me", "ims", "by", "ui", "p", "init", "um", "id", "l", "xi", "start", "oi", "at", "multi", "api", "is", "b", "g", "try", "y", "ini", "ia", "ci", "pi", "e", "di", "f", "v", "ri", "ai", "ii", "ji", "in", "n", "hi", "si", "ip", "zi", "im"], "j": ["r", "p", "aj", "pr", "no", "let", "be", "oj", "h", "jj", "next", "jc", "v", "json", "job", "jump", "jit", "z", "by", "sp", "ind", "l", "str", "bj", "fr", "ji", "ion", "jac", "lock", "bl", "at", "key", "u", "out", "bi", "n", "obj", "o", "ja", "b", "kj", "er", "kid", "g", "index", "jo", "try", "tr", "li", "y", "q", "note", "js", "adj", "J", "it", "br", "je", "jl", "ij", "dj", "ge", "uj", "block", "im", "bo", "bs", "jas", "jp"], "k": ["p", "km", "kn", "v", "ck", "z", "uk", "kick", "ek", "tk", "an", "ka", "ik", "key", "ijk", "wk", "n", "ke", "ak", "ark", "kj", "kid", "kh", "ko", "mk", "kl", "kk", "y", "ks", "q", "ok", "kan", "K", "kind", "kr", "ku", "c", "kt", "sk", "kw", "unk", "ki"], "m": ["dr", "km", "cm", "hm", "om", "am", "vm", "rm", "sm", "arm", "d", "met", "min", "mr", "pm", "c", "t", "len", "ms", "mn", "h", "month", "on", "mem", "em", "tm", "mo", "an", "all", "nm", "mut", "fm", "lem", "mk", "q", "mc", "mi", "me", "p", "mm", "span", "um", "M", "member", "perm", "l", "rem", "o", "md", "b", "g", "wm", "mt", "gm", "y", "ym", "mask", "mid", "mod", "r", "mat", "f", "v", "dm", "z", "mac", "n", "module", "num", "mx", "im", "bm"], "l2tab": ["l4tab", "l02Tab", " l4Tab", "l1Tab", "l1stab", "d4stab", "l36ctrl", "l36stab", "l3tab", "l4lab", "l1ab", " l4ctr", "d2tab", " l1Tab", "l2ab", "d2Tab", "l2ctrl", " l3ctl", " l1tab", "l10Tab", " l1lab", " l3Tab", "l4ctr", "l3ctl", " l2lab", " l3tab", "l02tab", "l4ab", " l4ab", "l10ab", "l2Tab", "l022tab", "l02ab", "d4Tab", "l022ab", "l1ctl", "l1tab", "l3Tab", " l3ab", "l2lab", " l4tab", "l4stab", "l4ctrl", "l36Tab", " l1ab", " l2Tab", "l1ctr", "l022ctl", "l10tab", "l36tab", "l1lab", "l2stab", "d2ctrl", "l10ctr", "l3ab", "l022Tab", "d4ctrl", " l2ctl", " l2ctr", "d2stab", "l2ctl", "l2ctr", "l02lab", " l2ab", "d4tab", "l1ctrl", "l4Tab"], "best_len": [" best2len", "better_state", "best_dist", "best_size", "best5len", "best_length", " best2state", "best__val", "best__size", "best2state", "best2val", "best_den", " best2Len", "better_size", " best_length", "better_den", "best2length", "best2len", "best5state", "better_compl", "better_val", "best__len", " best2length", "best2compl", "better_dist", " best_Len", "best5Len", "best__state", "best_compl", "best_val", "better_Len", "best2Len", "better_len", "best5length", "best_Len"], "occ": ["design", "co", "acc", "err", "mult", "obs", "nc", "circ", "exc", "buff", "arr", "ok", "roc", "loc", "ll", "ord", "mu", "ords", "eor", "coll", "Occ", "cont", "ob", "abc", "org", "cor", "config", "clus", "mc", "inf", "rd", "or", "cons", "opl", "seq", "cf", "give", "coord", "cur", "result", "cum", "inc", "sec", "fre", "fl", "ro", "times", "aug", "each", "oe", "cal", "con", "ctr", "rox", "cre", "ac", "pl", "proc", "rown", "fc", "rec", "ffe", "cc", "comb", "ec", "fe", "rn", "usc", "oc", "alph", "resp", "ocr"], "newocc": ["oldorg", "NEWOcc", "neworg", "oldocc", "newOcc", "oldcirc", "newinc", "newrec", " newinc", "newcur", "Newrec", "Newocc", "NewOcc", " newcur", "oldinc", "Newinc", "createOcc", "newcirc", " neworg", "oldOcc", "createrec", "newfe", "Newfe", " newcirc", "Neworg", "NEWrec", "oldrec", "createocc", "createfe", " newrec", " newOcc", " newfe", "NEWcur", "Newcur", "Newcirc", "NEWocc"]}}
{"project": "FFmpeg", "commit_id": "ff486c0f7f6b2ace3f0238660bc06cc35b389676", "target": 0, "func": "static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n", "idx": 10547, "substitutes": {"s": ["r", "ts", "less", "p", "self", "h", "sb", "ats", "conf", "sw", "ses", "rs", "sa", "v", "ains", "ls", "ss", "es", "its", "ps", "gs", "aws", "comm", "ops", "sts", "parts", "n", "sq", "fs", "sv", "a", "is", "g", "b", "details", "sam", "ins", "os", "ms", "js", "hs", "ds", "m", "c", "S", "t", "ares", "vs", "cs", "e", "ims", "bs", "w", "gets", "qs", "ns"], "x": ["p", "X", "h", "dx", "sw", "xy", "px", " cx", "i", "v", "xt", "xe", "xf", "l", "xs", "ox", "xi", "ix", "ex", "xd", "wx", "xp", "a", "ax", "el", "inx", "tx", "fx", "rx", "m", "yx", "mx", "xc", "xml", "w", "xx"], "y": ["p", "ny", "py", "fy", "h", "yi", "ery", "ies", "xy", "uy", "i", "v", "vy", "wy", "z", "oy", "height", "j", "sky", "ey", "ty", "key", "iy", "b", "my", "g", "yy", "ch", "axy", "Y", "iny", "ay", "yt", "ry", "ly", "cy", "t", "sy", "ye", "gy", "by"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int h264_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    int ret;\n\n    const uint8_t *new_extradata;\n\n    int new_extradata_size;\n\n\n\n    h->flags = avctx->flags;\n\n    h->setup_finished = 0;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\nout:\n\n    if (buf_size == 0) {\n\n        H264Picture *out;\n\n        int i, out_idx;\n\n\n\n        h->cur_pic_ptr = NULL;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f->key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            ret = output_frame(h, pict, out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n\n\n    new_extradata_size = 0;\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata_size > 0 && new_extradata) {\n\n        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,\n\n                                       &h->ps, &h->is_avc, &h->nal_length_size,\n\n                                       avctx->err_recognition, avctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size);\n\n    if (buf_index < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        buf_size = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            return 0;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        ff_h264_field_end(h, &h->slice_ctx[0], 0);\n\n\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||\n\n                                   h->next_output_pic->recovered)) {\n\n            if (!h->next_output_pic->recovered)\n\n                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;\n\n\n\n            ret = output_frame(h, pict, h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    }\n\n\n\n    assert(pict->buf[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 10554, "substitutes": {"avctx": ["ajcfg", "avetmp", " avhandle", "avecb", "savcp", "aversetup", "avecfg", "ajjac", "vrkw", "avjac", "averjac", "avecp", "vrsetup", "avcp", " avcfg", "vrcontext", " avcp", "avepkg", "averctx", "navcb", "avkw", "averhandle", "avercontext", "avecontext", " avcontext", "navctx", "savcontext", "ajctx", " avcb", "avsetup", "ajpkg", "savctx", "avcfg", "vrctx", "aveproc", "savproc", " avkw", "navcontext", "ajcontext", "avhandle", " avjac", " avproc", "avcb", "avpkg", " avtmp", "navtmp", "ajhandle", "avtmp", "avcontext", "avproc", " avsetup", "avectx", " avpkg", "averkw"], "data": ["p", "pic", "snap", "images", "DATA", "bin", "value", "next", "f", "read", "ata", "frame", "format", "name", "media", "pad", "str", "padding", "Data", "feed", "window", "picture", "content", "raw", "intel", "record", "feat", "obj", "size", "a", "d", "video", "png", "bytes", "form", "dat", "def", "act", "empty", "input", "offset", "ctx", "pat", "text", "t", "body", "buffer", "res", "batch", "action", "message", "doc", "image", "length", "img", "rel"], "got_frame": ["got___channel", "Got_point", "fetched___fr", "got_channel", "got___frame", "fetched_channel", "fetched_frame", "got_Frame", "fetched___channel", "fetched___frames", "got_event", "Got_frame", "got___fr", "got___frames", "got_fr", "got_frames", "Got_event", "fetched_fr", "Got_Frame", "fetched___frame", "got_point", "fetched_frames"], "avpkt": [" avopacket", "avppnt", "avpett", "avpackkt", "avpackett", " avptt", "avcpacket", "avcptt", "avcpnt", "avpadmsg", " avcpacket", " avopmsg", " avcpqt", "avpct", "avpacket", " avpet", "avopkt", "avPct", "avPqt", "avPett", "avPet", " avpct", " avPct", "avpackct", "avopmsg", "afpdt", "avopdt", "avpqt", "avopacket", " avpmit", "afopdt", "avopnt", "avcpet", " avpqt", " avPett", "avcompacket", " avPtt", "afopacket", "avpadmit", "avcompqt", "avcpett", "avdmsg", " avopkt", "afpacket", " avpacket", "avdmit", " avcpet", "avppacket", "afopnt", "avcpkt", "avdkt", "avcpqt", "avcpdt", "afpnt", "avpadkt", " avopmit", "avpadacket", " avPkt", "avpmit", " avpett", " avpmsg", "avPacket", "avppdt", "avpet", "avptt", "avpacktt", "avPkt", "afpkt", "avdacket", "avcompkt", "avpdt", " avcpkt", "avPtt", "avpmsg", "avopmit", "avpnt", "avppkt", "avcompet", "afopkt", "avcpct"], "buf": ["p", "cb", "seq", "np", "mem", "cap", "err", "v", "cam", "uf", "raw", "cv", "tmp", "buff", "b", "dat", "arr", "ref", "ctx", "vec", "br", "txt", "buffer", "msg", "doc", "ptr", "img", "cmd"], "h": ["self", "p", "HH", "hr", "mem", "gh", "his", "hp", "f", "v", "ih", "hm", "sh", "end", "rh", "l", "hook", "s", "j", "hd", "phi", "handle", "hz", "th", "http", "host", "help", "H", "o", "bh", "b", "g", "oh", "hi", "history", "ht", "he", "ch", "kh", "ah", "ph", "dh", "ha", "cache", "y", "hl", "tx", "hh", "hash", "q", "uh", "info", "ctx", "hs", "go", "it", "m", "c", "here", "this", "t", "eh", "hal", "k", "hw", "w"], "pict": ["camera", "p", "pas", "pic", "ot", "np", "cam", "Pic", "picture", "shit", "capt", "avi", "piece", "feat", "photo", "buff", "fn", "Picture", "ht", "png", "act", "pit", "info", "phys", "pdf", "ctx", "fi", "phy", "txt", "qi", " pic", "kt", "fig", " feat", "Pict", "lot", "img"], "ret": ["att", "r", "dr", "RET", "red", "ft", "fun", "rev", "err", " Ret", "cont", "plain", "re", "gov", "result", "gt", "Ret", "deg", "usr", "val", "reply", "rem", "at", "rm", "after", "nt", "over", "rets", "not", "net", "back", "print", "mt", "try", "tr", "def", "lit", "elt", "rt", "ref", "ry", "reset", "del", "reg", "it", "t", "et", "ber", "len", "res", "backed", "ll", "resp", "det", "alt", "gc", "ter", "nz", "response", "cmd"], "new_extradata": ["new_extreddata", "new_interrecdata", "new_extracATA", "new_extrata", "new_extrecaton", "new_extracaton", "new_extredata", "new_extracata", "new_exraddata", "new_interrecata", "new_interrecaton", "new_extrarATA", "new_exradATA", "new_extredaton", "new_extrdata", "new_extrecdata", "new_interradaton", "new_exracdata", "new_extrandaton", "new_exracata", "new_interradata", "new_extraton", "new_extradaton", "new_extrATA", "new_interrecATA", "new_extrandATA", "new_extracdata", "new_extrecata", "new_exradaton", "new_exredata", "new_extrecATA", "new_extraraton", "new_exreddata", "new_interradATA", "new_extradATA", "new_extrardata", "new_extrandata", "new_interraddata", "new_exredaton", "new_exredATA", "new_exracATA", "new_exradata", "new_extredATA", "new_exracaton", "new_extraddata", "new_extranddata", "new_extrarata"], "new_extradata_size": ["new_extradATA_max", "new_extradATA_count", "new_extradata2SIZE", "new_extradata_Size", "new_extradata_len", "new_extraddata_Size", "new_extradata_space", "new_extraddata_offset", "new_extraddata_SIZE", "new_extradatum_space", "new_extradATA_size", "new_extradATA_name", "new_extradata2name", "new_extradATA_Size", "new_extradatum_Size", "new_extradata_max", "new_extradata_count", "new_extraddata_size", "new_extradata_SIZE", "new_extradata2Size", "new_extradata_name", "new_extradatum_len", "new_extradATA_SIZE", "new_extradata2size", "new_extradatum_size", "new_extradata_offset"], "out": ["update", "no", "co", "aos", "err", "chan", "cam", "cfg", "end", "null", "cache", "to", "go", "c", "t", "w", "cmd", "ent", "conf", "output", "again", "new", "all", "after", "help", "obj", "ht", "one", "it", "txt", "status", "res", "p", "pic", "init", "off", "conn", "outs", "ou", "vol", "result", "at", "ex", "o", "tmp", "tif", "b", "g", "that", "video", "bool", "ctx", "can", "error", "conv", "ot", "opt", "timeout", "f", "from", "v", "j", "in", "n", "not", "file", "png", "ch", "Out", "check", "point", "OUT", "client", "image", "img"], "i": ["ami", "cli", "x", " ii", "ind", "ix", "iu", "u", "bi", "ni", "remote", "index", "to", "li", "go", "\u0438", "io", "t", "batch", "ti", "k", "gi", "ic", "them", "ei", "I", "phi", "my", "info", " bi", "q", "it", "mc", "qi", "mi", "ij", "status", "cgi", "ki", "ims", "me", "ui", "p", "init", "span", "uri", "id", "xi", "sim", "oi", "multi", "slice", "record", "is", "g", "try", "y", "ini", "gu", "ci", "chain", "pi", "e", "di", "f", "ri", "ai", "ii", "j", "ji", "iy", "n", "in", "hi", "si", "m", "zi", "ip", " j", "point", "im"], "out_idx": ["out_endy", "out_idex", "out_midz", "out_midix", "out_Idy", "out_sidx", "out_Idix", "out_sidxs", "out_dbix", "out_Idex", "out_inx", "out_dbx", "out_inex", "out_idv", "out_Idx", "out_midxs", "out_idz", "out_midx", "out_sidz", "out_idxs", "out_idy", "out_iny", "out_idc", "out_dbc", "out_Idz", "out_dbex", "out_endx", "out_Idc", "out_midy", "out_midv", "out_endz", "out_idix", "out_sidv", "out_inz", "out_endex"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)\n\n{\n\n    if (bin < 7) {\n\n        if ((b0 + 256) == b1)\n\n            a = 384;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else if (bin < 20) {\n\n        if ((b0 + 256) == b1)\n\n            a = 320;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else {\n\n        a = FFMAX(0, a - 128);\n\n    }\n\n\n\n    return a;\n\n}\n", "idx": 10556, "substitutes": {"a": ["aka", "acc", "err", "data", "am", "u", "ao", "da", "as", "d", "pa", "to", "c", "t", "w", "h", "aaaa", "ab", "abc", "an", "oa", "all", "act", "trace", "xa", "wa", "ta", "aq", "action", "ava", "au", "p", "aaa", "sta", "A", "sha", "off", "ga", "i", "sa", "ar", "ata", "l", "result", "era", "va", "at", "qa", "out", "o", "ea", "b", "g", "y", "ca", "ia", "apa", "e", "alpha", "aa", "ac", "aj", "ma", "ae", "from", "v", "z", "na", "j", "fa", "area", "m", "la", "ba", "ap"], "b0": ["bin0", "biskg", "obj0", "bb0", "bg0", "bops", "gb0", "v0", "embable", "b9", "embfunc", "name9", "b140", "vma", "y1", "bi000", "biable", "b3", "bma", "bis000", "y0", "bi0", "b195", "emb0", "wb9", "nameZero", "bkg", "wbZero", "bg140", "bgkg", "binma", "name0", "bb3", "bikg", "bg000", "bis0", "bZero", "bb140", "emb000", "gb195", "wb195", "val000", "b000", "bfunc", "bin1", "objfunc", "yops", "val0", "bin3", "objable", "bgable", "gbZero", "wb0", "bisable", "vops", "gb9", "valfunc", "bin000", "bb000", "obj000", "bin140", "yma", "name195", "bable", "bg3", "binops", "valable", "v1"], "b1": ["wb64", "bb0", "ba2", "v0", "a1", "b9", "gbOne", "bb2", "bbOne", "b3", " b64", "v3", "ba1", "wb1", "wb2", "b2", " b2", "bOne", "bb3", "b64", "bb11", " b3", "v2", "v9", "ba64", "a0", "gb64", "gb1", "gb11", "b11", " b11", " b9", "wb0", "gb2", "baOne", "gb3", "a2", "a3", "bb64", "v1", "bb1", "bb9"], "bin": ["rin", "or", "gain", "on", "spin", "fun", " Bin", "i", "un", "ebin", "nb", "pack", "tar", "version", "ln", "ion", " bins", "mix", "ix", "ran", "bi", "in", "n", "size", "b", "scan", "png", "comb", "win", "IN", "border", "gin", "bit", "big", "hash", "abin", "pin", "box", "byte", "part", "num", "bits", "binary", "len", "inner", "sun", "bn", "obin", "pc", "class", "lib", "mon", "by"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n                                      long width, long height,\n\n                                      long lumStride, long chromStride, long srcStride)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y+=2) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \"pcmpeqw                 %%mm7, %%mm7       \\n\\t\"\n\n            \"psrlw                      $8, %%mm7       \\n\\t\" // FF,00,FF,00...\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(4)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // U0V0 U0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // UVUV UVUV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(0)\n\n\n\n            MOVNTQ\"                  %%mm2, (%1, %%\"REG_a\", 2)  \\n\\t\"\n\n\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(12)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq                    %%mm2, %%mm4       \\n\\t\" // YUYV YUYV(12)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(8)\n\n            \"psrlw                      $8, %%mm2       \\n\\t\" // U0V0 U0V0(12)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm4       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm2, %%mm1       \\n\\t\" // UVUV UVUV(8)\n\n            \"packuswb                %%mm4, %%mm3       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm3, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // UVUV UVUV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // UVUV UVUV(8)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // V0V0 V0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // V0V0 V0V0(8)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // U0U0 U0U0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // U0U0 U0U0(8)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // VVVV VVVV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // UUUU UUUU(0)\n\n\n\n            MOVNTQ\"                  %%mm0, (%3, %%\"REG_a\")     \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, (%2, %%\"REG_a\")     \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm3       \\n\\t\" // YUYV YUYV(12)\n\n            \"pand                    %%mm7, %%mm0       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm1       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // YYYY YYYY(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm0,  (%1, %%\"REG_a\", 2) \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n#else\n\n        long i;\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            udst[i]     = src[4*i+1];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n            vdst[i]     = src[4*i+3];\n\n        }\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n        }\n\n#endif\n\n        udst += chromStride;\n\n        vdst += chromStride;\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(EMMS\"       \\n\\t\"\n\n                     SFENCE\"     \\n\\t\"\n\n                     :::\"memory\");\n\n#endif\n\n}\n", "idx": 10564, "substitutes": {"src": ["dist", "sb", "sw", "rs", "sur", "addr", "ser", "syn", "filename", "usr", "start", "sub", "rect", "stack", "rc", "sr", "origin", "in", "rl", "sl", "ost", "chrom", "inst", "scan", "st", "ur", "tr", "rol", "hl", "sn", "input", "rt", "sys", "lat", "strike", "rx", "usc", "sc", "source", "loc", "dest", "ipl", "RC", "rid", "lb", "lib", "img", "ins"], "ydst": ["dyst", "eddySt", "eyst", "ydSt", "yxst", "ydsta", "ldsta", "eybl", "ldst", "eystack", "dystr", "dyset", "bdsta", "ydstack", "ldST", "ytst", "yxbl", "ldSt", "ydstart", "ytstack", "ytsten", "eysten", "bdst", "ytbl", "ydST", "ydstr", "eddystart", "dySt", "bdset", "ldstart", "ldset", "yxstack", "yxsten", "ydbl", "dystart", "ydsten", "dysta", "eddystr", "bdST", "ydset", "eddyst", "ldstr", "dyST"], "udst": ["uprc", "odnd", "ldst", "ddost", "ubst", "upst", "vdsta", "odsc", "ubsta", "upnd", "udset", "ldrc", "ldsc", "udsta", "ddsta", "udrc", "ubost", "odrc", "ubset", "ldnd", "vdset", "ddset", "odst", "udsc", "vdost", "upsc", "udnd", "ddst", "udost"], "vdst": ["hdest", "hdsc", "udstop", "hdst", "xdst", "udST", "hdST", "hdstop", "xdST", "vdist", "ovstop", "vdest", "udist", "xdsc", "hdist", "vdST", "ovST", "udest", "vdsc", "ovst", "udsc", "vdstop", "ovest", "xdist"], "height": ["resolution", "inches", "h", "Height", "high", "bottom", "build", "ih", "gravity", "ows", "length", "rows", "radius", "padding", "capacity", "window", "depth", "ty", "th", "H", "count", "size", "graph", "history", "zh", "hub", "ht", "wh", "he", "shape", "stroke", "above", "max", "hs", "hei", "row", "density", "w"], "lumStride": ["lumRestro", "lumStrr", "lumsRestide", "lumSTr", "lumRestride", "lumStrride", "lumSTride", "lumStro", "lumsStro", "lumsRestr", "lumRestide", "lumFormr", "lumFormride", "lumenFormro", "lumenStro", "lumsStide", "lumstro", "lumstr", "lumFormro", "lumstide", "lumsStride", "lumsStr", "lumstride", "lumenStride", "lumRestr", "lumenStr", "lumenFormride", "lumStr", "lumStrro", "lumsRestro", "lumSTro", "lumStide", "lumenFormr", "lumsRestride"], "chromStride": ["chromStrrd", " chromStrip", "chromRestride", "chromRestrip", "chromStrd", " chromStrrd", "chromRestide", "chromStrip", "chromStrride", "chromStide", " chromStrride", "chromSTrip", "chromStrrip", " chromStrd", "chromRestrd", "chromSTride", " chromStide", "chromSTide", "chromSTrd", " chromStrrip"], "srcStride": ["rcStide", "srcSTride", "srcRestides", "rcStride", "srcStrides", "srcSTro", "srcStrro", "srcSTides", "srcStro", "chromStrause", "srcRestide", "srcEstause", "chromStrride", "srcRestride", "srcRestrid", "chromStide", "srcStide", "srcStrause", "srcStause", "chromStrrid", "rcStides", "chromStrid", "rcStrro", "srcEstide", "chromStause", "rcStrride", "srcRestause", "srcStrrid", "srcStrride", "srcRestro", "srcEstrid", "srcStides", "rcStrides", "srcEstride", "rcStro", "srcStrid", "srcSTide"], "y": ["p", "ny", "h", "x", "py", "yn", "yi", "ies", " x", "yr", "dy", "vy", "hy", "z", "asy", "j", "sky", "ys", "ey", "ty", "ady", "key", "hey", "iy", "out", "count", "b", "my", "yy", "index", "ch", " Y", "axy", " my", "Y", "ay", "ya", " cy", "yt", "ym", "ly", "m", "cy", "t", "yl", " j", "sy", "aily", "yp", "col", "w", "gy", "by", "ley"]}}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 10583, "substitutes": {"node": ["self", "ode", "instance", "np", "uri", "Node", "tree", "type", "link", "addr", "id", "number", "data", "handler", "connection", "oid", "NAME", "object", "primary", "title", "network", "code", "root", "parent", "component", "holder", "key", "device", "process", "arn", "error", "n", "label", "nt", "nm", "tmp", "server", "remote", "odes", "fn", "index", "path", "shape", "local", "desc", "hash", "none", "note", "ref", "kind", "standard", "target", "num", "station", "source", "normal", "description", "entity", "context", "production", "host", "image", "address", "msg", "peer"], "name": ["no", " Name", "comment", "value", "type", "id", "data", "NAME", "version", "title", "filename", "code", "named", "new", "parent", "key", "create", "n", "label", "nm", "size", "b", "prefix", "file", "names", "path", "info", "local", "none", "m", "ame", "Name", "nam", "part", "alias", "block", "base", "normal", "word", "w", "error", "ns"], "pbs": ["bns", "hbs", "hubs", "jubs", "pjs", "pbm", "bjs", "Pns", " pjs", "Pbs", " pns", "Pjs", " pbes", "hbm", " pbos", "pbes", "pubs", "pns", "jbm", " pubs", "Pbes", " pBS", "jbs", "bBS", "bbes", " pbm", "bbs", "bcs", "jbos", "Pcs", "PBS", "pbos", "pcs", "hbos", " pcs", "pBS"], "paio": ["ack", "co", "except", "acl", "acc", "asa", "esa", "aos", "cap", "anti", "alloc", "cont", "cur", "fc", "sic", "aic", "ct", "nc", "oci", "jac", "cu", "unc", "cc", "arc", "cv", "obj", "uca", "cas", "ec", "act", "ah", "cmp", "ca", "iat", "ctx", "aco", "ci", "auc", "sc", "anc", "con", "oc", "aux", "ucc", "comp", "annot", "ac"], "errp": ["diepa", "ererpoint", "ererpc", "rerpa", "errorpoint", "illerpg", "rrP", "ererf", "eorp", "eorpre", "erping", "illerpost", "errorpc", "errping", "diep", "rerp", "errpun", "rrp", "errorpre", "rrf", "errpg", "ererpost", "eorpc", "erpoint", "errpc", "dieping", "rerping", "illerpun", "rrpa", "errpa", " errpa", "erp", "eorpoint", "errpoint", "errorp", "ererpre", " erP", "rrpoint", " erping", "errP", "erP", "ererp", "errpost", " erpoint", "illerp", "rerf", "errpre", "ererpa", " erp", " erpg", " errping", "ererpun", " erpost", " erpun", "ererpg", "errf", "rrping", "ererping"], "bs": ["ts", "boxes", "caps", "sb", "vals", "aps", "rs", "aos", "outs", "bos", "uts", "ls", "BS", "pb", "bys", "its", "als", "es", "obs", "bc", "vers", "ps", "cks", "gs", "bed", "Bs", "bp", "bb", "eb", "ubs", "sts", "bl", "abilities", "fs", "bh", "b", "lbs", "blocks", "acts", "bles", "bytes", "s", "bas", "ks", "gb", "bis", "js", "bes", "stats", "ds", "ubis", "bits", "banks", "bing", "res", "bps", "base", "nos", "vs", "cs", "hz", "ns"], "bitmap": ["bytem", "bandmap", " bitMap", "bandnative", " bitMAP", "bitMAP", "bytepack", "bitnative", "BITMAP", "BITmap", "bitstream", "byteap", "itMap", "bytemap", "BITMap", "Bitstream", "BITnative", "itap", "itmap", "bitm", "itpack", "bandMap", " bitm", "itm", "bitpack", " bitpack", "bitmaps", " bitap", " bitnative", "bitap", "Bitmaps", "bitMap", "BitMap", "Bitap", "blockstream", "itmaps", " bitmaps", "blockmaps", " bitstream", "Bitmap", "bandMAP", "blockmap"], "aio_context": ["aio_request", "aiooscope", "aio_status", "aio2status", "aio_support", "aioodocument", "aive_context", "aIO_status", "aIO_resource", "aiop_ctx", "aiol_context", "aio___support", "aive_mask", "aio_cache", "aio2context", "aIO_ctx", "aiol_scope", "aio_choice", "aiol_choice", "aIO_Context", "aio2ctx", "aive_Context", "aio_resource", "aive_scope", "aio___mask", "aio2resource", "aio_ctx", "aive_document", "aiol_request", "aiop_context", "aiop_cache", "aio_document", "aio___context", "aive_support", "aiooctx", "aioocontext", "aio_scope", "aio___Context", "aio_Context", "aiop_scope", "aIO_context", "aive_ctx", "aio_mask"]}}
{"project": "qemu", "commit_id": "446f16a6906e9d05aa9ce0dde727d4f731a89298", "target": 1, "func": "void ppce500_init(MachineState *machine, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t loadaddr;\n\n    hwaddr kernel_base = -1LL;\n\n    int kernel_size = 0;\n\n    hwaddr dt_base = 0;\n\n    hwaddr initrd_base = 0;\n\n    int initrd_size = 0;\n\n    hwaddr cur_base = 0;\n\n    char *filename;\n\n    hwaddr bios_entry = 0;\n\n    target_long bios_size;\n\n    struct boot_info *boot_info;\n\n    int dt_size;\n\n    int i;\n\n    /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and\n\n     * 4 respectively */\n\n    unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i;\n\n        env->mpic_iack = params->ccsrbar_base +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    machine->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, params->ccsrbar_base,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_prop_set_uint32(dev, \"first_pin_irq\", pci_irq_nrs[0]);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", params->spin_base, NULL);\n\n\n\n    if (cur_base < (32 * 1024 * 1024)) {\n\n        /* u-boot occupies memory up to 32MB, so load blobs above */\n\n        cur_base = (32 * 1024 * 1024);\n\n    }\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        qemu_irq poweroff_irq;\n\n\n\n        dev = qdev_create(NULL, \"mpc8xxx_gpio\");\n\n        s = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]);\n\n        memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n\n\n        /* Power Off GPIO at Pin 0 */\n\n        poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0);\n\n        qdev_connect_gpio_out(dev, 0, poweroff_irq);\n\n    }\n\n\n\n    /* Platform Bus Device */\n\n    if (params->has_platform_bus) {\n\n        dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE);\n\n        dev->id = TYPE_PLATFORM_BUS_DEVICE;\n\n        qdev_prop_set_uint32(dev, \"num_irqs\", params->platform_bus_num_irqs);\n\n        qdev_prop_set_uint32(dev, \"mmio_size\", params->platform_bus_size);\n\n        qdev_init_nofail(dev);\n\n        s = SYS_BUS_DEVICE(dev);\n\n\n\n        for (i = 0; i < params->platform_bus_num_irqs; i++) {\n\n            int irqn = params->platform_bus_first_irq + i;\n\n            sysbus_connect_irq(s, i, mpic[irqn]);\n\n        }\n\n\n\n        memory_region_add_subregion(address_space_mem,\n\n                                    params->platform_bus_base,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (machine->kernel_filename) {\n\n        kernel_base = cur_base;\n\n        kernel_size = load_image_targphys(machine->kernel_filename,\n\n                                          cur_base,\n\n                                          ram_size - cur_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    machine->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base += kernel_size;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (machine->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    machine->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /*\n\n     * Smart firmware defaults ahead!\n\n     *\n\n     * We follow the following table to select which payload we execute.\n\n     *\n\n     *  -kernel | -bios | payload\n\n     * ---------+-------+---------\n\n     *     N    |   Y   | u-boot\n\n     *     N    |   N   | u-boot\n\n     *     Y    |   Y   | u-boot\n\n     *     Y    |   N   | kernel\n\n     *\n\n     * This ensures backwards compatibility with how we used to expose\n\n     * -kernel to users but allows them to run through u-boot as well.\n\n     */\n\n    if (bios_name == NULL) {\n\n        if (machine->kernel_filename) {\n\n            bios_name = machine->kernel_filename;\n\n        } else {\n\n            bios_name = \"u-boot.e500\";\n\n        }\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL,\n\n                         1, ELF_MACHINE, 0);\n\n    if (bios_size < 0) {\n\n        /*\n\n         * Hrm. No ELF image? Try a uImage, maybe someone is giving us an\n\n         * ePAPR compliant kernel\n\n         */\n\n        kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n\n                                  NULL, NULL);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Reserve space for dtb */\n\n    dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n\n\n    dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n\n                                       initrd_base, initrd_size,\n\n                                       kernel_base, kernel_size);\n\n    if (dt_size < 0) {\n\n        fprintf(stderr, \"couldn't load device tree\\n\");\n\n        exit(1);\n\n    }\n\n    assert(dt_size < DTB_MAX_SIZE);\n\n\n\n    boot_info = env->load_info;\n\n    boot_info->entry = bios_entry;\n\n    boot_info->dt_base = dt_base;\n\n    boot_info->dt_size = dt_size;\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 10594, "substitutes": {"machine": ["engine", "password", "instance", "metadata", "comment", "agent", "iso", "link", "mass", "frame", "handler", "model", "connection", "network", "command", "sim", "shell", "vm", "money", "component", "database", "device", "process", "direction", "owner", "me", "host", "server", "achine", "domain", "monitor", "zone", "net", "Machine", "node", "note", "module", "m", "power", "manager", "company", "chain", "alias", "this", "base", "mode", "template", "message", "series", "state", "image", "magic", "computer"], "params": ["mm", "images", "conf", "types", "json", "Parameters", " parameters", "settings", "ps", "Par", "AMS", "properties", "ams", "sym", "scan", "details", "par", "names", "param", "keys", "ctx", "ds", "m", "members", "pi", "spec", "eters"], "address_space_mem": ["address_space_reg", "address_sp2memory", "address_space_ref", "address_space2mem", "address_sp_mem", "address_sp2ref", "address_sp_memory", "address_space2memory", "address_sp2mem", "address_sp_ref", "address_sp_reg", "address_space_memory", "address_space2reg", "address_space2ref", "address_sp2reg"], "ram": ["mm", "gram", "rom", "conf", "ra", "mem", "bin", "em", "region", "alloc", "cam", "Mem", "am", "vm", "rem", "range", "serv", "mb", "sam", "dem", "ro", "reg", "RAM", "disk", "iam", "res", "memory", "mode"], "pci_bus": ["pico_queue", "pci8bus", "pci__bus", "pci_block", "pico_base", "pci__block", "pci8block", "pci8queue", "pico_block", "pci__queue", "pci8base", "pci_base", "pci__base", "pico_bus", "pci_queue"], "env": ["session", "ent", "erd", "instance", "conf", "conn", "proc", "ev", "mem", "em", "eng", "next", "err", "v", "agent", "esc", "cur", "environment", "ef", "end", "entry", "era", "en", "window", "vm", "ey", "org", "worker", "hw", "process", "ve", "buf", "obj", "ew", "ne", "server", "tmp", "enc", "er", "net", "ie", "viron", "el", "ea", "ner", "ec", "cache", "ext", "info", "node", "sys", "ctx", "equ", "ds", "event", "ele", "manager", "et", "port", "den", "nv", "vs", "context", "e", "me", "state", "w", "scope", "cmd"], "loadaddr": [" loadmem", "ockmem", "ockptr", "loadmem", "loadattr", " loadptr", "ockattr", "ockaddr", "packattr", " loadattr", "packmem", "packaddr", "packptr", "loadptr"], "filename": ["write", "bf", "File", "location", "command", "fr", "username", "family", "label", "config", "nm", "journal", "fs", "src", "prefix", "fn", "file", "fd", "files", "fp", "fi", "ame", "txt", "buffer", "asm", "socket", "tty", "cmd"], "bios_size": ["bios_info", "bios8info", "bio_count", "bio_size", "bios8size", "bios8count", "bios8name", "bio_info", "bio_name", "bios_count", "bios_name"], "boot_info": ["boot_information", "boot2information", "bootfielddata", "booteddata", "bootedsettings", "bootedinfo", "boot_INFO", "boot2info", "boot2INFO", "bootfieldsettings", "boot_state", "bootfieldinfo", "boot_settings", "start_state", "boot_data", "start_settings", "start_info", " boot_INFO", " boot_information", "bootfieldstate", "bootedstate", "start_data"], "dt_size": ["dt_time", "dk_range", "dk_scale", "dk_size", "dt_scale", "dk_time", "dt_range"], "i": ["ui", "di", "p", "r", "x", "h", "ims", "f", "v", "gi", "id", "ic", "ai", "z", " ii", "ind", "ei", "l", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "key", "multi", "bi", "n", "me", "in", "o", "b", "g", "hi", "si", "index", "li", "y", "ini", "q", "gu", "it", "m", "ci", "c", "counter", "t", "ip", "mi", "zi", " j", "qi", "status", "ti", "ij", "im", "pi", "k"], "pci_irq_nrs": ["pci_irq_pls", "pci_irq_prs", "pci_irq_pws", "pci_irq_numRS", "pci_irq_nws", "pci_irq_pRS", "pci_irq_numls", "pci_irq_nls", "pci_irq_numrs", "pci_irq_Nws", "pci_irq_Nrs", "pci_irq_NRS", "pci_irq_Nls", "pci_irq_numws", "pci_irq_nRS"], "irqs": [" irews", " irqq", "mirqs", "ierques", "ibrxes", "irqu", " irxes", "rirq", "iriches", "irews", "rirqs", "pirqi", "mirews", "ierews", " irq", "rirqu", "iorq", "pirqu", "ierqs", " irqu", "pirches", "iriqs", "ibrps", "irques", "ibrews", "ierps", "iorques", " irques", "iorqs", "mirques", "irches", " irches", "rirqq", " irps", "pirqs", "irqi", "iorqi", "mirqi", "irps", "ibrques", "iriq", "iriqu", "pirques", "ibrqs", "pirq", "pirews", "mirq", "pirxes", "irq", "irqq", "pirqq", "irxes"], "mpic": ["mmic", "mphic", "mphics", "mphIC", "cpIC", "mmics", "cpic", "mmIC", "cpik", "mpIC", "cpics", "mpik", "mphik", "mpics", "mmik"], "dev": ["DEV", "proc", "Dev", "ev", "conn", "mem", "v", "cam", "ver", "device", "ve", "md", "serv", "app", "def", "dem", "iv", "sys", "adv", "ds", "disk", "vo", "res", "vs", "doc", "w", "hw", "gen"], "firstenv": ["secondconn", "startenvironment", " firstconn", "secondenvironment", " firstenvironment", "startenc", "Firstenc", "startenv", "onlyenv", "onlyconn", "Firstenv", "firstenc", "latestenvironment", "onlyedge", "firstconn", "secondnode", "startconn", "firstenvironment", "startedge", "firstnode", "onlyenvironment", " firstenc", " firstedge", "Firstconn", " firstnode", "latestconn", "firstedge", "latestenv", "secondenv", "latestnode"], "ccsr_addr_space": ["ccsr_address_range", "ccsr_address_space", "ccsr_addr_range", "ccsr_addr2range", "ccsr_addr2space", "ccsr_addr2base", "ccsr_addr2sp", "ccsr_addr_sp", "ccsr_address_sp", "ccsr_address_base", "ccsr_addr_base"], "s": ["p", "h", "sb", "rs", "v", "ss", "ps", "gs", "n", "fs", "b", "g", "d", "os", "sys", "js", "ds", "m", "S", "c", "t", "spec", "e", "bs", "w", "socket", "ns"], "ccsr": ["cfcr", "csr", "cr", "cccr", "cctr", "ctsr", "ctr", "cftr", "ccr", "cttr", "ctcr", "cfsr", "cfr"], "cpu": ["pixel", "proc", "CPU", "conn", "mem", "gpu", "alloc", "ck", "cam", "cow", "crypt", "processor", "uart", "mac", "cum", "vm", "cn", "cu", "worker", "nic", "hw", "process", "device", "ilo", "cv", "cp", "us", "comp", "uda", "loader", "prof", "core", "net", "cache", "ec", "uu", "pu", "cmp", "ctx", "aco", "c", "sc", "mx", "ork", "clock", "gc", "pc", "mu", "php", "socket", "computer", "linux", "cmd"], "cs": ["ts", "caps", "proc", "tc", "rs", "ls", "csv", "ps", "cks", "acs", "ys", "ix", "cc", "cp", "cms", "CS", "cas", "fs", "ec", "ins", "os", "ks", "css", "sys", "js", "ctx", "ds", "c", "sc", "vs", "wcs", "bs", "ns"], "input": ["att", "active", "select", " inputs", "dq", "json", "head", "flow", "output", "data", "add", "import", "query", "shift", "raw", "process", "qt", "qa", "out", "in", "config", "initial", "event", "form", "history", "index", "get", "act", "local", "queue", "q", "Input", "it", "text", "buffer", "inner", "source", "table", "context", "state", "child", "image", "error", "cmd"]}}
{"project": "FFmpeg", "commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n", "idx": 10609, "substitutes": {"s": ["r", "ts", "p", "less", "erences", "self", "h", "sb", "ats", "ses", "rs", "v", "ains", "ls", "ss", "its", "es", "ps", "gs", "acs", "aws", "comm", "sts", "parts", "n", "sq", "a", "fs", "sv", "b", "is", "serv", "ins", "os", "js", "sys", "ctx", "hs", "ds", "stats", "c", "S", "t", "vs", "cs", "e", "ims", "bs", "w", "qs", "ns"], "rc_rice_param": ["rc_risk_param", "rc_riceetydim", "rc_rice_weight", "rc_rice__dim", "rc_risk_perm", "rc_rice67param", "rc_riceetydep", "rc_rice_dep", "rc_cost_option", "rc_rice_perm", "rc_riceprotype", "rc_rice__tag", "rc_risk_tag", "rc_cost_dep", "rc_rice_tag", "rc_cost_param", "rc_rice_remove", "rc_rice_field", "rc_riceeterparams", "rc_resource_param", "rc_riceeterparam", "rc_cost_remove", "rc_rice_type", "rc_race_params", "rc_rice_aram", "rc_rice67tag", "rc_riceeterremove", "rc_rice_num", "rc_rice67field", "rc_race_aram", "rc_riceetyparam", "rc_race_param", "rc_rice_params", "rc_riceetytag", "rc_rice_dim", "rc_cost_tag", "rc_resource_num", "rc_cost_dim", "rc_rice67perm", "rc_risk_field", "rc_rice_option", "rc_riceproaram", "rc_riceproparams", "rc_cost_params", "rc_riceproparam", "rc_race_type", "rc_resource_params", "rc_resource_weight", "rc_riceeteroption", "rc_rice__dep", "rc_rice__param"], "last_coeff_abs_level_remaining": ["last_coeff_abs_level_resained", "last_coeff_abs_level_Remain", "last_coeff_abs_level_relaining", "last_coeff_abs_level_Remaining", "last_coeff_abs_level_brain", "last_coeff_abs_level_relained", "last_coeff_abs_level_Remained", "last_coeff_abs_level_remains", "last_coeff_abs_level_relain", "last_coeff_abs_level_braining", "last_coeff_abs_level_resain", "last_coeff_abs_level_remained", "last_coeff_abs_level_resaining", "last_coeff_abs_level_Remains", "last_coeff_abs_level_resains", "last_coeff_abs_level_remain", "last_coeff_abs_level_brains", "last_coeff_abs_level_brained"], "i": ["ui", "di", "p", " pi", "cli", "x", "init", "uri", "v", "gi", "ic", "ai", " ii", "ind", "ei", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", "oi", "multi", "bi", "in", "me", "PI", "iter", "ie", "g", "hi", "si", "index", "uli", "li", "y", "ini", "q", "MI", "gu", "fi", "\u0438", "it", "ci", "m", "io", "c", "t", "zi", "mi", "ip", "qi", "ti", "point", "im", "asi", "pi", "ki", "ims", "ms"], "prefix": ["x", "rank", "err", "number", "ind", "radius", "circ", "ix", "domain", "print", "scale", "index", "pattern", "min", "len", "batch", "pkg", "magic", "ring", "major", "root", "foo", "path", "max", "sequence", "priority", "status", "word", "p", "span", "pace", "coord", "pre", "hop", "missing", "pad", "padding", "start", "position", "dirty", "label", "iter", "pointer", "none", "bridge", "wrapper", "weight", "chain", "alias", "division", "pi", "alpha", "length", "distance", "password", "timeout", "master", "next", "fix", "format", "version", "network", "ox", "key", "area", "post", "zone", "term", "local", "reset", "offset", "module", "base", "point", "address", "zero"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n", "idx": 10620, "substitutes": {"s": ["r", "ts", "p", "self", "h", "ats", "conf", "rs", "se", "f", "v", "ls", "sp", "ss", "es", "its", "ps", "gs", "j", "acs", "aws", "comm", "sts", "n", "sq", "fs", "a", "sv", "g", "b", "serv", "as", "sam", "os", "set", "sg", "js", "sys", "scl", "stats", "ds", "hs", "c", "S", "t", "spec", "cs", "ms", "w", "ns"], "last": ["active", "send", "list", "nd", "final", "next", "region", "never", "sort", "ast", "global", "all", "close", "prev", "reverse", "las", "cast", "since", "latest", "leaf", "st", "rest", "push", "empty", "full", "first", "local", "max", "best", "slave", "stable", "current", "est", "any", "valid", "gc", "ctr", "show", " Last", "Last"], "seg": ["segn", "seager", "parsege", "sederg", "sech", "sedig", "sew", "semsg", " sej", "sexig", "scheq", "seagn", "seleg", " segm", "segt", "scheeg", "pseerg", "vegn", " eleg", "sereg", "psegment", "psemsg", " sew", "sedge", "parsegn", "seage", "segc", "seagm", "adeag", "sogen", "sedleg", "schegt", " sev", "seam", "sema", " seeg", "selem", "sexgate", "SEgm", "soger", "schegs", "geq", "slereg", "sexg", "seach", "parsech", "sedgn", "sego", "pseig", "sedgment", "SEj", "slema", "seagt", "pseg", " elegs", "seG", "sedg", "selet", "schem", "seegn", "seaag", " sem", "slemsg", "seaG", "parsegment", "pseeg", "schemsg", "adegu", "schegen", "schech", "slev", " seG", "SEgn", "kead", "seag", "SEG", "soreg", "sedgs", "seaged", "SEeg", "seareg", "perleg", " segen", "schev", "psegm", "sexgn", "vej", " sege", "sexbg", "schej", "adeger", " segn", "sleg", "psej", " elegen", "seerg", "seaq", "sev", "SEg", "seq", "keged", "seegs", "perg", "sogm", " seq", "seew", "sem", "vege", "sedgate", "scheig", "sexged", "sexgo", "pselem", "parseg", "psegu", " seged", "pseleg", "seagment", "keG", "segm", "parsev", "psegt", "scheg", "seav", "schelem", "seged", "pseh", "seabg", "sej", "segen", "vegs", "seaig", "sogu", "keg", "pergment", "sedgc", "parseig", "sedmsg", "sedbg", "seger", "segs", "sead", "seh", "sealet", "parseger", "segment", "psema", "pseag", "sealeg", "parseleg", "soge", "veg", "psev", "seago", "sebg", "psegn", "sedgo", " segs", "gej", "soig", "soma", "gev", "sexgc", "schelet", "somsg", "seaeg", "perag", "pseq", "seig", "seagu", "SEgs", " elegn", "sedag", "sog", "pseG", "seah", "vegen", "segate", " segment", "psegs", "scheG", "seaw", "parselet", "seeg", "seagc", "seagen", "sealem", "geg", "parseged", "psege", "seags", "sexG", "schegm", "slem", "segu", "psem", " seger", "parseerg", "seagate", "adeg", "sexad", " sereg", "sedq", "psereg", "sege", "soag", " seh", "seaad"], "i": ["ui", "di", "p", "cli", "x", "v", "ret", "gi", "k", "ri", "id", "ai", "ic", "z", " ii", "ind", "ei", "ii", "l", "j", "xi", "sim", "I", "phi", "ix", "iu", "oi", "multi", "u", "slice", "bi", "n", " I", "me", "in", "ni", "o", "iter", "hi", "si", "index", "tim", "li", "y", "ini", "q", "it", "ci", "m", "t", "ip", "mi", "ij", " j", "zi", "qi", "ti", "im", "pi", "ki", "ims", "us"], "buf": ["cb", "h", "off", "seq", "mem", "cap", "err", "v", "Buffer", "ret", "pb", "cur", "data", "bc", "str", "result", "uf", "window", "new", "raw", "fb", "out", "cv", "nm", "tmp", "iter", "temp", "buff", "b", "bytes", "tr", "tab", "queue", "ref", "Buff", "ctx", " buffer", "br", "box", "wb", "text", "txt", "buffer", "batch", "rb", "rw", "msg", "w", "img", "cmd"]}}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640, "substitutes": {"a": ["al", "p", "aj", " l", "aaa", "sta", "A", "aka", "ma", "ab", "x", "ga", "ae", "i", "sa", "ar", "f", "v", " sa", " A", "l", "am", "na", "an", " pa", "oa", "va", "at", "val", "o", "da", " as", "area", "as", "d", "isa", " the", "ca", "ia", "m", "c", "la", " an", "t", "ta", " af", " la", "ba", "e", "alpha", " it", "aa", "ac"], "b": ["r", "p", "bf", "blue", "be", "ab", "i", "v", "nb", "z", "emb", "bc", "l", "j", "bb", "eb", "fb", "ib", "bi", "n", "g", "d", "B", "y", "bis", "bes", "br", "m", "c", "db", "rb", "ba", "bg", "e", "bs", "lib"]}}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n", "idx": 10648, "substitutes": {"expected": ["report", " unexpected", "found", "ordered", "pected", "read", "v", "test", "data", "announced", "pe", " expecting", " expects", "reported", "needed", "end", "command", "result", "actual", "hello", "example", "key", "fake", "old", "pect", " found", "sent", " required", " inspected", "config", "cv", "ex", "allowed", "event", "received", "pattern", "match", "required", "def", " e", "claimed", "force", "pecting", "style", "EXP", "ped", "ed", "et", "current", "matched", "est", " expect", "valid", "message", "seen", "e", " expectation", " desired"], "measured": ["mesasured", "mesasure", "measures", "memasure", "omeasures", "peasures", "peasured", "seasure", "memasures", "seasured", "mesasuring", "omeasuring", "measure", "mesasures", "seasuring", " measuring", "peasure", "omeasured", "peasuring", "memasured", "measuring", "memasuring", "seasures", " measures", "omeasure", " measure"], "cmd": ["send", "cb", "cli", "init", "conn", "bind", "cf", "mem", "dq", "fun", "std", "args", "exec", "test", "data", "cfg", "addr", "ind", "command", "str", "call", "ct", "cd", "pt", "code", "comm", "program", "raw", "qt", "out", "help", "buf", "cp", "obj", "tmp", "md", "g", "mt", "Cmd", "ch", "mk", "ext", "handle", "act", "def", "q", "force", "control", "ctx", "req", "c", "find", "text", "txt", "buffer", "batch", "resp", "pkg", "cut", "ctr", "col", "msg"]}}
{"project": "FFmpeg", "commit_id": "b4886795108e319a5b3a88370e90207d9c15a01e", "target": 1, "func": "static int decode_frame_byterun1(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height ; y++) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { //PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM\n\n        for(y = 0; y < avctx->height ; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(row, avctx->width, buf, buf_end);\n\n        }\n\n    } else { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n        for (y = 0; y < avctx->height ; y++) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);\n\n            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 10665, "substitutes": {"avctx": ["wavtx", "devcpu", "avecfg", "avdl", "avjac", "avecp", "navjac", "verctx", "AVcontext", " avcp", "avepkg", "averpkg", "avcmd", "afcfg", "avercontext", "vartx", "avecontext", "avejp", "ajcp", "varcpu", "ajctx", "devpkg", "afpkg", "avereq", "AVcmp", "wavcp", "afcontext", "avreq", "ajtx", "ajjp", "wavctx", "avercu", "abctx", "wavsys", "avtx", "avecmp", "wavcmp", "avcp", "wavcmd", "abcontext", "avcmp", "averctx", "afca", "afjp", "avcpu", "wavcontext", "avekt", "avsetup", "AVctx", " avtx", "avpkg", "ajdl", "avectx", "wavjp", "devctx", " avreq", "avecpu", "afcu", "wavctl", "ajca", "avecmd", "afctx", "avjp", "avercmp", "abjp", "varctx", "avectl", "abcp", "wavreq", "averjp", "verctl", "abtx", "navctx", " avpkg", "wavcu", "ajsys", "avejac", "wavca", "avcfg", "varpkg", "ajcontext", "avkt", " avjac", "aftx", "avctl", "afdl", "avcontext", " avctl", " avsys", " avcmp", "AVtx", "aveca", "avetmp", "avcu", "aversetup", " avkt", "avertmp", " avcfg", "verreq", "abkt", "wavcfg", "devtx", "afcmp", " avcontext", "avca", "wavpkg", "avsys", "avertx", "ajreq", "ajpkg", "navpkg", "vertx", "abpkg", "navcpu", " avjp", "avedl", "avetx", " avcmd", "abcfg", "avtmp", " avcpu", "wavsetup", " avsetup", "aftmp"], "data": ["r", "p", "done", "extra", "no", "DATA", "bin", "value", "next", "f", "read", "ata", "id", "frame", "bits", "end", "name", "entry", "pad", "padding", "str", "Data", "map", "query", "start", "window", "chain", "content", "raw", "debug", "device", "line", "rel", "initial", "size", "da", "b", "d", "values", "bytes", "cache", "dat", "def", "info", "empty", "offset", "header", "m", "text", "t", "body", "buffer", "part", "rew", "len", "block", "batch", "pieces", "table", "ad", "message", "mode", "mu", "image", "length", "zero", "error"], "data_size": ["buf_len", "data__len", "buf_length", "data_len", "data__length", "buf_size", "data_pos", "data__size", "buf_pos", "data__pos", "data_length"], "avpkt": ["avtpwk", "avpanet", "awpett", "avpett", "avpnet", "avwpkt", "avpaet", "avcpth", "iverpkg", "awcpth", "avdpkt", "avpadwd", "avdconn", "avpckt", "avjpkt", "wavdconn", "averpkt", "avpct", "avjpacket", "avpacket", "avtpct", "averpcmd", "avetpwk", "avpwp", "avopkt", "awpmsg", "avPth", "avPct", "iverlpnet", "avwett", "avdprt", "avPett", "avlpnet", "avlpkt", "awpct", "awpth", "averpycmd", "avwth", "avopmsg", "avtpkt", "wavdacket", "avopacket", "avpconn", "avwkt", "avjpct", "avdpacket", "avwpet", "avpcacket", "averpykt", "avpwd", "avpcet", "avtpconn", "avopconn", "avpakg", "avpction", "avpidacket", "avpkg", "avpth", "avcpwk", "avlpkg", "averpacket", "iverlpkt", "wavwpet", "avpywd", "avcpett", "avjpconn", "avpaacket", "awpacket", "averpidacket", "averpidkt", "avpadcmd", "avcpkt", "awopmsg", "avpadwp", "avdkt", "avpykt", "avepct", "wavpwd", "awpkt", "wavwpacket", "wavpet", "wavpkt", "awopction", "avpadkt", "avpwk", "awcpett", "wavpacket", "awcpkt", "avpadacket", "avwpdt", "iverlprt", "averpwd", "avjpwd", "avepwk", "avwpacket", "avpycmd", "avdpction", "avwct", "avdwd", "averpwp", "iverlpkg", "avepconn", "avPacket", "avepkt", "avpart", "awopacket", "avPction", "avpawd", "avpet", "avdpkg", "awpction", "avetpconn", "avlprt", "averpdt", "avPkt", "iverprt", "avpiddt", "avpacmd", "awopkt", "iverpnet", "wavdwd", "wavpconn", "wavwpkt", "avdacket", "avopction", "iverpkt", "averpiddt", "avdpmsg", "avpdt", "wavdkt", "averpywd", "avpmsg", "avetpkt", "avpidwp", "averpidwp", "awcpct", "avwpwp", "avjpwk", "avPmsg", "avcpconn", "avpcmd", "avprt", "avpakt", "avdpnet", "avpidkt", "avpaddt", "avetpct", "avcpct", "avopwd"], "s": ["r", "ts", "p", "less", "h", "sb", "ats", "conf", "sw", "ims", "ses", "rs", "i", "v", "ls", "args", "qs", "ss", "settings", "its", "es", "als", "ps", "gs", "aws", "comm", "ops", "sts", "ess", "sq", "sm", "sv", "a", "fs", "is", "b", "g", "actions", "details", "sam", "os", "ms", "scl", "js", "sys", "ctx", "stats", "hs", "ds", "ns", "S", "c", "t", "bits", "ares", "spec", "vs", "cs", "tes", "bs", "w", "sports", "ins"], "buf": ["r", "limit", "lim", "cb", "off", "mem", "cap", "err", "alloc", "cam", "bc", "uf", "map", "window", "raw", "bl", "rc", "cv", "bar", "pool", "tmp", "cp", "buff", "b", "bytes", "tr", "empty", "arr", "queue", "ref", "max", "ctx", "Buff", "vec", "br", "text", "pos", "buffer", "len", "block", "batch", "port", "pkg", "ptr", "Buffer", "msg", "conv", "cmd"], "buf_end": ["buf_ends", "buf_start", "buf2begin", "buff2start", "buf2ends", "buf2start", "buff_end", "buf_begin", "buff_ends", "buff2end", "buf2end", "buff_begin", "buff2ends", "buff2begin", "buff_start"], "y": ["p", "ny", "ot", "x", "py", "h", "fy", "ies", "xy", "uy", "sat", "yr", "i", "dy", "vy", "wy", "z", "asy", "yer", "oy", "ind", "kit", "height", " ty", "j", "sky", "sim", "ys", "ey", "ty", "ady", "key", "hey", "iy", " ly", "tiny", "b", "my", "yy", " i", "ch", "icy", "ach", "axy", "Y", "story", "iny", "ay", "ya", "sys", "ym", "yt", "ry", "ly", "yx", "cy", "t", "ip", "yl", "hot", "sy", "any", "ye", "iz", "col", "ate", "gy", "by"], "plane": [" planes", "flag", "mail", "flat", "cube", "du", "mate", "flow", "pose", "pe", "straight", "axis", "white", "ker", "depth", "slice", "line", "pipe", "ane", "ve", "zone", "place", "plate", "pa", "panel", "cone", "plot", "pse", "fl", "anes", " Plane", "rise", "pan", "late", "stroke", "heading", "face", "priority", "pen", "gate", "half", "slave", "port", "normal", "animate", "mode", "planes", "way", "bo", "clip", "profile", "lane"], "res": ["r", "pas", "resolution", "pr", "dr", "vals", "pres", "red", "mem", "proc", "rs", "rev", "json", "err", "ret", "der", "alloc", "rek", "ser", "plain", "re", "ps", "result", "fr", "rep", "rez", "val", "content", "rem", "progress", "rc", "rss", "out", "RES", "resh", "des", "ress", "fs", "resource", "serv", "expr", "details", "render", "rest", "def", "Res", "arr", "hash", "ref", "gr", "reset", "reg", "js", "ras", "fin", "req", "vec", " Res", "ber", "status", "resp", "results", "msg", "rel"], "row": ["r", "co", "pixel", "rs", "rown", "frame", "pair", "rows", "cell", "pad", "entry", "ver", "oom", "our", "rect", "th", "key", "roll", "record", "line", "bar", "iter", "ow", "tr", "ro", "tab", "node", "ry", "pos", "port", "block", "Row", "way", "col", "ptr", "rot", "item"]}}
{"project": "FFmpeg", "commit_id": "29d2dc59f973f9495c703b4cab17ded5c24ab3e8", "target": 1, "func": "int alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n\n    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11\n\n    const int mb_array_size= s->mb_stride*s->mb_height;\n\n    const int b8_array_size= s->b8_stride*s->mb_height*2;\n\n    const int b4_array_size= s->b4_stride*s->mb_height*4;\n\n    int i;\n\n\n\n    if(shared){\n\n        assert(pic->data[0]);\n\n        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);\n\n        pic->type= FF_BUFFER_TYPE_SHARED;\n\n    }else{\n\n        int r;\n\n\n\n        assert(!pic->data[0]);\n\n\n\n        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);\n\n\n\n        if(r<0 || !pic->age || !pic->type || !pic->data[0]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]);\n\n            return -1;\n\n        }\n\n\n\n        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (stride changed)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if(pic->linesize[1] != pic->linesize[2]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (uv stride mismatch)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        s->linesize  = pic->linesize[0];\n\n        s->uvlinesize= pic->linesize[1];\n\n    }\n\n\n\n    if(pic->qscale_table==NULL){\n\n        if (s->encoding) {\n\n            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))\n\n        }\n\n\n\n        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check\n\n        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))\n\n        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))\n\n        pic->mb_type= pic->mb_type_base + s->mb_stride+1;\n\n        if(s->out_format == FMT_H264){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 2;\n\n        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 3;\n\n        }\n\n        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)\n\n        }\n\n        pic->qstride= s->mb_stride;\n\n        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))\n\n    }\n\n\n\n    /* It might be nicer if the application would keep track of these\n\n     * but it would require an API change. */\n\n    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);\n\n    s->prev_pict_types[0]= s->pict_type;\n\n    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)\n\n        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.\n\n\n\n    return 0;\n\nfail: //for the CHECKED_ALLOCZ macro\n\n    return -1;\n\n}\n", "idx": 10670, "substitutes": {"s": ["news", "snap", "sb", "ses", "ls", "xs", "aws", "comm", "south", "sv", "as", "d", "sam", "sac", "js", "sys", "c", "this", "t", "https", "eds", "ms", "w", "se", "ins", "ns", "less", "h", "ats", "conf", "sw", "ies", "settings", "stat", "ps", "http", "parts", "sq", "a", "fs", "sl", "app", "sg", "stats", "ds", "sc", "vs", "mys", "cs", "ims", "ports", "p", "aunts", "pres", "sa", "sp", "its", "ties", "str", "sim", "sports", "space", "store", "is", "b", "g", "st", "eps", "os", "y", "ctx", "hs", "styles", "sis", "results", "spec", "sql", "conv", "ts", "rs", "v", "ss", "es", "csv", "uploads", "gs", "j", "sts", "n", "plays", "views", "si", "details", "m", "S", "mods", "bs", "qs"], "pic": ["iac", "snap", "py", "pid", "cam", "spr", "piece", "print", "pa", "par", "cache", "sam", "cro", "parse", "pin", "pkg", "magic", "jp", "pp", "ic", "op", "pict", "jpg", "ps", "rep", "like", "pick", "temp", "Picture", "kl", "script", "txt", "draw", "anc", "agic", "p", "pres", "wp", "photos", "perm", "vol", "sp", "sci", "eric", "pot", "str", "image", "sim", "capt", "photo", "pit", "pty", "phys", "style", "ctx", "mic", "prop", "pi", "gc", "pc", "doc", "lib", "ac", "pro", "pr", "pl", "proc", "feature", "px", "virt", "syn", "pg", "Pic", "mac", "shot", "jac", "picture", "peg", "feat", "phot", "png", "pse", "pan", "phy", "mp", "kt", "ping", "Pict", "spec", "img"], "shared": ["hidden", "private", "sh", "sp", "ared", "restricted", "needed", "global", "share", "parent", "raw", "dirty", "linked", "shadow", "only", "owner", "broken", "store", "bar", "safe", "bound", "Sh", "g", "mb", "bare", "sec", "required", "copy", "visible", "local", "basic", "ed", "exclusive", "stable", "stock", "checked", "sharing", "associated", "same", "used", "locked", "loaded", "ram", "acked"], "i": ["di", "p", "h", "ir", "x", "f", "v", "z", "l", "ii", "j", "I", "phi", "b", "g", "si", "y", "fi", "it", "ia", "ci", "m", "t", "ip", "ti", "im", "pi"], "r": ["p", "cr", "x", "dr", "hr", "h", "pr", "rs", "attr", "rr", "err", "v", "f", "ri", "z", "re", "l", "result", "R", "fr", "nr", "rate", "reb", "rc", "sr", "u", "range", "rg", "n", "rad", "er", "g", "d", "b", "rat", "arr", "rt", "q", "mr", "rar", "br", "m", "c", "t", "res", "rb", "rw", "w", "rd", "rel"]}}
{"project": "FFmpeg", "commit_id": "fa5dacce143f3fbe8eac14d5a99e926b2787e9e6", "target": 1, "func": "static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\n    if (get_bits(&ctx->gb, 5) != 0x1F) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\n        return -1;\n    ctx->prev_frame_type = ctx->frame_type;\n    ctx->frame_type      = get_bits(&ctx->gb, 3);\n    if (ctx->frame_type >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\n        return -1;\n    ctx->frame_num = get_bits(&ctx->gb, 8);\n    if (ctx->frame_type == FRAMETYPE_INTRA) {\n        ctx->gop_invalid = 1;\n        if (decode_gop_header(ctx, avctx))\n            return -1;\n        ctx->gop_invalid = 0;\n    if (ctx->frame_type != FRAMETYPE_NULL) {\n        ctx->frame_flags = get_bits(&ctx->gb, 8);\n        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\n        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n        /* skip unknown extension if any */\n        if (ctx->frame_flags & 0x20)\n            skip_hdr_extension(&ctx->gb); /* XXX: untested */\n        /* decode macroblock huffman codebook */\n        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\n            return -1;\n        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n    align_get_bits(&ctx->gb);\n    return 0;", "idx": 10671, "substitutes": {"ctx": ["dc", "iac", "wd", "co", "acl", "np", "tc", "cm", "cfg", "nc", "xs", "gt", "ka", "rc", "cp", "history", "index", "def", "sys", "ann", "batch", "kw", "loc", "xc", "pkg", "wcs", "jp", "ns", "cmd", "conf", "jj", "addr", "tm", "tz", "stat", "abc", "cd", "lc", "cu", "ctl", "obj", "expr", "kl", "act", "etc", "tx", "note", "rt", "ctrl", "req", "txt", "anc", "cookie", "aux", "btn", "conn", "cf", "wp", "ck", "exec", "warn", "crit", "tk", "qa", "xp", "nt", "tmp", "prefix", "that", "cmp", "ca", "ork", "gc", "pc", "ctr", "hw", "conv", "ac", "func", "cb", "timeout", "proc", "px", "height", "ct", "dl", "jac", "cc", "wx", "cv", "td", "inst", "work", "lex", "kind", "check", "kt", "resp", "context"], "avctx": ["avheight", "wavctx", "ivctx", "wavtx", "ajthread", "avethread", "avetmp", "wavctl", "ivcontext", "avtx", "avthread", "avjp", "afctx", "averheight", "evtx", "avertmp", "vrpkg", "avepkg", "AVcontext", "ivtx", "averctx", "averpkg", "avcmp", "vrtmp", "avecontext", "afjp", "avcpu", " avcontext", "wavcontext", "ajcpu", "vrheight", "avejp", "ajctx", " avthread", "evctx", "AVcmp", " avjp", "vrctx", "ajcontext", "AVctx", " avtx", "avpkg", "avctl", "avetx", "aftx", "afcontext", " avcpu", "avcontext", "avtmp", " avctl", "ivctl", "avectx", "evcmp", "aveheight", "evcontext", " avcmp", "avecpu", "AVtx"]}}
{"project": "FFmpeg", "commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "target": 1, "func": "static int mpegts_write_header(AVFormatContext *s)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    MpegTSWriteStream *ts_st;\n\n    MpegTSService *service;\n\n    AVStream *st, *pcr_st = NULL;\n\n    AVDictionaryEntry *title, *provider;\n\n    int i, j;\n\n    const char *service_name;\n\n    const char *provider_name;\n\n    int *pids;\n\n    int ret;\n\n\n\n    if (s->max_delay < 0) /* Not set by the caller */\n\n        s->max_delay = 0;\n\n\n\n    // round up to a whole number of TS packets\n\n    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;\n\n\n\n    ts->tsid = ts->transport_stream_id;\n\n    ts->onid = ts->original_network_id;\n\n    /* allocate a single DVB service */\n\n    title = av_dict_get(s->metadata, \"service_name\", NULL, 0);\n\n    if (!title)\n\n        title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;\n\n    provider      = av_dict_get(s->metadata, \"service_provider\", NULL, 0);\n\n    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;\n\n    service       = mpegts_add_service(ts, ts->service_id,\n\n                                       provider_name, service_name);\n\n\n\n    if (!service)\n\n        return AVERROR(ENOMEM);\n\n\n\n    service->pmt.write_packet = section_write_packet;\n\n    service->pmt.opaque       = s;\n\n    service->pmt.cc           = 15;\n\n\n\n    ts->pat.pid          = PAT_PID;\n\n    /* Initialize at 15 so that it wraps and is equal to 0 for the\n\n     * first packet we write. */\n\n    ts->pat.cc           = 15;\n\n    ts->pat.write_packet = section_write_packet;\n\n    ts->pat.opaque       = s;\n\n\n\n    ts->sdt.pid          = SDT_PID;\n\n    ts->sdt.cc           = 15;\n\n    ts->sdt.write_packet = section_write_packet;\n\n    ts->sdt.opaque       = s;\n\n\n\n    pids = av_malloc_array(s->nb_streams, sizeof(*pids));\n\n    if (!pids) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* assign pids to each stream */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n\n\n        ts_st = av_mallocz(sizeof(MpegTSWriteStream));\n\n        if (!ts_st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        st->priv_data = ts_st;\n\n\n\n        ts_st->user_tb = st->time_base;\n\n        avpriv_set_pts_info(st, 33, 1, 90000);\n\n\n\n        ts_st->payload = av_mallocz(ts->pes_payload_size);\n\n        if (!ts_st->payload) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        ts_st->service = service;\n\n        /* MPEG pid values < 16 are reserved. Applications which set st->id in\n\n         * this range are assigned a calculated pid. */\n\n        if (st->id < 16) {\n\n            ts_st->pid = ts->start_pid + i;\n\n        } else if (st->id < 0x1FFF) {\n\n            ts_st->pid = st->id;\n\n        } else {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Invalid stream id %d, must be less than 8191\\n\", st->id);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        if (ts_st->pid == service->pmt.pid) {\n\n            av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        for (j = 0; j < i; j++) {\n\n            if (pids[j] == ts_st->pid) {\n\n                av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        pids[i]                = ts_st->pid;\n\n        ts_st->payload_pts     = AV_NOPTS_VALUE;\n\n        ts_st->payload_dts     = AV_NOPTS_VALUE;\n\n        ts_st->first_pts_check = 1;\n\n        ts_st->cc              = 15;\n\n        /* update PCR pid by using the first video stream */\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            service->pcr_pid == 0x1fff) {\n\n            service->pcr_pid = ts_st->pid;\n\n            pcr_st           = st;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_AAC &&\n\n            st->codec->extradata_size > 0) {\n\n            AVStream *ast;\n\n            ts_st->amux = avformat_alloc_context();\n\n            if (!ts_st->amux) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ts_st->amux->oformat =\n\n                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? \"latm\" : \"adts\",\n\n                                NULL, NULL);\n\n            if (!ts_st->amux->oformat) {\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ret = avcodec_copy_context(ast->codec, st->codec);\n\n            if (ret != 0)\n\n                goto fail;\n\n            ast->time_base = st->time_base;\n\n            ret = avformat_write_header(ts_st->amux, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {\n\n            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;\n\n        }\n\n    }\n\n\n\n    av_freep(&pids);\n\n\n\n    /* if no video stream, use the first stream as PCR */\n\n    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {\n\n        pcr_st           = s->streams[0];\n\n        ts_st            = pcr_st->priv_data;\n\n        service->pcr_pid = ts_st->pid;\n\n    } else\n\n        ts_st = pcr_st->priv_data;\n\n\n\n    if (ts->mux_rate > 1) {\n\n        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n\n\n        if (ts->copyts < 1)\n\n            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);\n\n    } else {\n\n        /* Arbitrary values, PAT/PMT will also be written on video key frames */\n\n        ts->sdt_packet_period = 200;\n\n        ts->pat_packet_period = 40;\n\n        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (!pcr_st->codec->frame_size) {\n\n                av_log(s, AV_LOG_WARNING, \"frame size not set\\n\");\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * 512);\n\n            } else {\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);\n\n            }\n\n        } else {\n\n            // max delta PCR 0.1s\n\n            // TODO: should be avg_frame_rate\n\n            service->pcr_packet_period =\n\n                ts_st->user_tb.den / (10 * ts_st->user_tb.num);\n\n        }\n\n        if (!service->pcr_packet_period)\n\n            service->pcr_packet_period = 1;\n\n    }\n\n\n\n    ts->last_pat_ts = AV_NOPTS_VALUE;\n\n    ts->last_sdt_ts = AV_NOPTS_VALUE;\n\n    // The user specified a period, use only it\n\n    if (ts->pat_period < INT_MAX/2) {\n\n        ts->pat_packet_period = INT_MAX;\n\n    }\n\n    if (ts->sdt_period < INT_MAX/2) {\n\n        ts->sdt_packet_period = INT_MAX;\n\n    }\n\n\n\n    // output a PCR as soon as possible\n\n    service->pcr_packet_count = service->pcr_packet_period;\n\n    ts->pat_packet_count      = ts->pat_packet_period - 1;\n\n    ts->sdt_packet_count      = ts->sdt_packet_period - 1;\n\n\n\n    if (ts->mux_rate == 1)\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate VBR, \");\n\n    else\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate %d, \", ts->mux_rate);\n\n    av_log(s, AV_LOG_VERBOSE,\n\n           \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\",\n\n           service->pcr_packet_period,\n\n           ts->sdt_packet_period, ts->pat_packet_period);\n\n\n\n    if (ts->m2ts_mode == -1) {\n\n        if (av_match_ext(s->filename, \"m2ts\")) {\n\n            ts->m2ts_mode = 1;\n\n        } else {\n\n            ts->m2ts_mode = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&pids);\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st    = s->streams[i];\n\n        ts_st = st->priv_data;\n\n        if (ts_st) {\n\n            av_freep(&ts_st->payload);\n\n            if (ts_st->amux) {\n\n                avformat_free_context(ts_st->amux);\n\n                ts_st->amux = NULL;\n\n            }\n\n        }\n\n        av_freep(&st->priv_data);\n\n    }\n\n\n\n    for (i = 0; i < ts->nb_services; i++) {\n\n        service = ts->services[i];\n\n        av_freep(&service->provider_name);\n\n        av_freep(&service->name);\n\n        av_freep(&service);\n\n    }\n\n    av_freep(&ts->services);\n\n    return ret;\n\n}\n", "idx": 10672, "substitutes": {"s": ["p", "less", "changes", "h", "sb", "sets", "ats", "conf", "ses", "rs", "v", "ls", "args", "sp", "qs", "ss", "its", "ers", "als", "ps", "gs", "aws", "comm", "ops", "sts", "tests", "parts", "n", "sq", "tes", "south", "fs", "a", "sv", "b", "g", "is", "serv", "details", "bs", "ins", "os", "y", "js", "sys", "hs", "ds", "stats", "m", "c", "S", "arts", "t", "https", "ares", "spec", "services", "vs", "series", "cs", "ims", "ms", "socket", "sports", "ns"], "ts": ["options", "tl", "asts", "tc", "uts", "ls", "xs", "gt", "sv", "ics", "js", "sys", "t", "wcs", "ms", "ns", "ats", "types", "Ts", "test", "tm", "tz", "fts", "pt", "ps", "tt", "lt", "fs", "vt", "ets", "tx", "TS", "stats", "ds", "txt", "utils", "ta", "vs", "cs", "tes", "TPS", "ims", "ports", "outs", "points", "its", "ops", "tests", "tis", "nt", "that", "mt", "tr", "os", "times", "hs", "att", "opt", "ots", "aps", "rs", "tp", "als", "trans", "gs", "tags", "tn", "ty", "sts", "td", "wt", "arts", "bs"], "ts_st": ["ds_st", "ts_ste", "ds_ste", "ts_sta", "ds_std", "ds_sta", "ts_std"], "service": ["instance", "library", "comment", "type", "tree", "git", "test", "ser", "sp", "sort", "data", "function", "entry", "name", "command", "interface", "tt", "query", "Service", "ty", "component", "process", "sr", "ice", "store", "secure", "server", "sv", "serv", "resource", "sl", "file", "my", "sam", "info", "attribute", "section", "sn", "task", "ssl", "module", "so", "t", "status", "port", "spec", "table", "services", "vc", "way", "state", "statement", "image", "se", "storage", "item", "lib", "response"], "st": ["sw", "std", "sp", "ss", "ste", "str", "ST", "ct", "tt", "sts", "nt", "sv", "sl", "St", "mt", "rest", "spect", "sn", "so", "t", "stage", "est", "stable", "ist", "dest", "stream", "se"], "pcr_st": ["pcr_std", "pcm_const", "pcm_std", "pcr_const", "pcr2const", "pcr2std", "pcr2stream", "pcr2st", "pcr_stream", "pcm_stream", "pcm_st"], "title": ["att", "pole", "tel", "metadata", "comment", "html", "master", "type", "subject", "test", "nat", "id", "primary", "data", "format", "tele", "role", "version", "name", "filename", "meta", "chapter", "tt", "username", "hd", "phrase", "itled", "key", "summary", "TIT", "label", "lead", "total", "medium", "prefix", "Title", "details", "itle", "unknown", "term", "section", "note", "displayText", "tle", "header", "token", "hash", "basic", "ame", "t", "alias", "status", "normal", "itles", "description", "template", "alt", "important", "alpha", "profile", "jury", "town"], "provider": ["prader", "proviler", "provide", "rovide", "avison", "perader", "divIDER", "avendor", "provifier", "price", "roviler", "whereIDER", "veride", "servider", "rovider", "prendor", "provice", "proser", "provIDER", "provicator", "veroser", "pericator", "avider", "divide", "provison", "pricator", "servendor", "whereiler", "perider", "proader", "prifier", "divoser", "servison", "provader", "diviler", "rovIDER", "proider", "provendor", "pride", "whereider", "prison", "verifier", "whereide", "divifier", "provoser", "perice", "avice", "divider", "prider", "verider", "proicator", "proice"], "i": ["ui", "di", "p", "ami", "x", "jj", "v", "gi", "id", "ai", " ii", "ind", "ei", "ii", "xi", "ji", "I", "ix", "oi", "multi", "u", "bi", "in", "n", "o", "si", "index", "li", "ini", "\u0438", "ci", "m", "io", "t", "ip", "mi", "ij", "qi", "im", "pi", "us"], "j": ["p", "aj", "x", "jj", "jc", "f", "v", "jump", "z", "l", "ii", "ji", "n", "ni", "o", "ja", "g", "b", "li", "q", "js", "J", "it", "m", "pos", "ij", "k", "jp"], "service_name": ["section_id", "process_common", "service_id", "service_type", "resource_type", "resource_name", "serviceNamename", "process_comment", "resource_Name", "process_value", "serviceablename", "serviceablevalue", "sectionNameName", "resource_description", "section_value", "service_value", "service_Name", "sectionNamename", "sectionNamevalue", "serviceNamecomment", "serviceNamecommon", "service_description", "sectionNameid", "serviceNamevalue", "section_name", "serviceNameName", "serviceablecommon", "serviceablecomment", "process_name", "service_common", "service_comment", "serviceNameid", "section_Name"], "provider_name": ["provicer_default", "provider_comment", "provicerablename", "providerablenote", "provistryablecap", "provicer_name", "provide_id", "provicerablenumber", "provistryablename", "providerablecomment", "provide_name", "provistryablenote", "provicer_number", "provide_Name", "providerablecap", "provistry_cap", "provistryablecomment", "provicer_comment", "provistry_name", "provider_default", "provider_cap", "providerabledefault", "provider_id", "provider_Name", "provicerablecomment", "provistry_note", "provider_number", "providerablenumber", "provicerabledefault", "provistry_comment", "provider_note", "providerablename"], "pids": ["tid", "ppips", " pockets", "cpents", "mids", "pid", "cpads", "psids", "cpids", "mads", "ppires", "psoids", "pads", "psads", "piders", " piders", "pockets", "pires", "ppoids", " pid", "psires", "tids", "moids", "ppids", "poids", " pips", " poids", " pads", " pents", " pires", "psents", "cpoids", "ppid", "tips", "toids", "ppockets", "pents", "psockets", "pips", "cpiders", "miders"], "ret": ["r", "att", "opt", "RET", "mel", "ft", "mem", "err", "re", "result", "gt", "Ret", "val", "rem", "out", "nt", "rets", "back", "mt", "try", "lit", "get", "elt", "ry", "rt", "reset", "it", "t", "status", "res", "len", "true", "ll", "resp", "alt", "ter", "jp"]}}
{"project": "FFmpeg", "commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "target": 1, "func": "void dct32(INTFLOAT *out, const INTFLOAT *tab)\n\n{\n\n    INTFLOAT tmp0, tmp1;\n\n\n\n    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\n\n             val8 , val9 , val10, val11, val12, val13, val14, val15,\n\n             val16, val17, val18, val19, val20, val21, val22, val23,\n\n             val24, val25, val26, val27, val28, val29, val30, val31;\n\n\n\n    /* pass 1 */\n\n    BF0( 0, 31, COS0_0 , 1);\n\n    BF0(15, 16, COS0_15, 5);\n\n    /* pass 2 */\n\n    BF( 0, 15, COS1_0 , 1);\n\n    BF(16, 31,-COS1_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 7, 24, COS0_7 , 1);\n\n    BF0( 8, 23, COS0_8 , 1);\n\n    /* pass 2 */\n\n    BF( 7,  8, COS1_7 , 4);\n\n    BF(23, 24,-COS1_7 , 4);\n\n    /* pass 3 */\n\n    BF( 0,  7, COS2_0 , 1);\n\n    BF( 8, 15,-COS2_0 , 1);\n\n    BF(16, 23, COS2_0 , 1);\n\n    BF(24, 31,-COS2_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 3, 28, COS0_3 , 1);\n\n    BF0(12, 19, COS0_12, 2);\n\n    /* pass 2 */\n\n    BF( 3, 12, COS1_3 , 1);\n\n    BF(19, 28,-COS1_3 , 1);\n\n    /* pass 1 */\n\n    BF0( 4, 27, COS0_4 , 1);\n\n    BF0(11, 20, COS0_11, 2);\n\n    /* pass 2 */\n\n    BF( 4, 11, COS1_4 , 1);\n\n    BF(20, 27,-COS1_4 , 1);\n\n    /* pass 3 */\n\n    BF( 3,  4, COS2_3 , 3);\n\n    BF(11, 12,-COS2_3 , 3);\n\n    BF(19, 20, COS2_3 , 3);\n\n    BF(27, 28,-COS2_3 , 3);\n\n    /* pass 4 */\n\n    BF( 0,  3, COS3_0 , 1);\n\n    BF( 4,  7,-COS3_0 , 1);\n\n    BF( 8, 11, COS3_0 , 1);\n\n    BF(12, 15,-COS3_0 , 1);\n\n    BF(16, 19, COS3_0 , 1);\n\n    BF(20, 23,-COS3_0 , 1);\n\n    BF(24, 27, COS3_0 , 1);\n\n    BF(28, 31,-COS3_0 , 1);\n\n\n\n\n\n\n\n    /* pass 1 */\n\n    BF0( 1, 30, COS0_1 , 1);\n\n    BF0(14, 17, COS0_14, 3);\n\n    /* pass 2 */\n\n    BF( 1, 14, COS1_1 , 1);\n\n    BF(17, 30,-COS1_1 , 1);\n\n    /* pass 1 */\n\n    BF0( 6, 25, COS0_6 , 1);\n\n    BF0( 9, 22, COS0_9 , 1);\n\n    /* pass 2 */\n\n    BF( 6,  9, COS1_6 , 2);\n\n    BF(22, 25,-COS1_6 , 2);\n\n    /* pass 3 */\n\n    BF( 1,  6, COS2_1 , 1);\n\n    BF( 9, 14,-COS2_1 , 1);\n\n    BF(17, 22, COS2_1 , 1);\n\n    BF(25, 30,-COS2_1 , 1);\n\n\n\n    /* pass 1 */\n\n    BF0( 2, 29, COS0_2 , 1);\n\n    BF0(13, 18, COS0_13, 3);\n\n    /* pass 2 */\n\n    BF( 2, 13, COS1_2 , 1);\n\n    BF(18, 29,-COS1_2 , 1);\n\n    /* pass 1 */\n\n    BF0( 5, 26, COS0_5 , 1);\n\n    BF0(10, 21, COS0_10, 1);\n\n    /* pass 2 */\n\n    BF( 5, 10, COS1_5 , 2);\n\n    BF(21, 26,-COS1_5 , 2);\n\n    /* pass 3 */\n\n    BF( 2,  5, COS2_2 , 1);\n\n    BF(10, 13,-COS2_2 , 1);\n\n    BF(18, 21, COS2_2 , 1);\n\n    BF(26, 29,-COS2_2 , 1);\n\n    /* pass 4 */\n\n    BF( 1,  2, COS3_1 , 2);\n\n    BF( 5,  6,-COS3_1 , 2);\n\n    BF( 9, 10, COS3_1 , 2);\n\n    BF(13, 14,-COS3_1 , 2);\n\n    BF(17, 18, COS3_1 , 2);\n\n    BF(21, 22,-COS3_1 , 2);\n\n    BF(25, 26, COS3_1 , 2);\n\n    BF(29, 30,-COS3_1 , 2);\n\n\n\n    /* pass 5 */\n\n    BF1( 0,  1,  2,  3);\n\n    BF2( 4,  5,  6,  7);\n\n    BF1( 8,  9, 10, 11);\n\n    BF2(12, 13, 14, 15);\n\n    BF1(16, 17, 18, 19);\n\n    BF2(20, 21, 22, 23);\n\n    BF1(24, 25, 26, 27);\n\n    BF2(28, 29, 30, 31);\n\n\n\n    /* pass 6 */\n\n\n\n    ADD( 8, 12);\n\n    ADD(12, 10);\n\n    ADD(10, 14);\n\n    ADD(14,  9);\n\n    ADD( 9, 13);\n\n    ADD(13, 11);\n\n    ADD(11, 15);\n\n\n\n    out[ 0] = val0;\n\n    out[16] = val1;\n\n    out[ 8] = val2;\n\n    out[24] = val3;\n\n    out[ 4] = val4;\n\n    out[20] = val5;\n\n    out[12] = val6;\n\n    out[28] = val7;\n\n    out[ 2] = val8;\n\n    out[18] = val9;\n\n    out[10] = val10;\n\n    out[26] = val11;\n\n    out[ 6] = val12;\n\n    out[22] = val13;\n\n    out[14] = val14;\n\n    out[30] = val15;\n\n\n\n    ADD(24, 28);\n\n    ADD(28, 26);\n\n    ADD(26, 30);\n\n    ADD(30, 25);\n\n    ADD(25, 29);\n\n    ADD(29, 27);\n\n    ADD(27, 31);\n\n\n\n    out[ 1] = val16 + val24;\n\n    out[17] = val17 + val25;\n\n    out[ 9] = val18 + val26;\n\n    out[25] = val19 + val27;\n\n    out[ 5] = val20 + val28;\n\n    out[21] = val21 + val29;\n\n    out[13] = val22 + val30;\n\n    out[29] = val23 + val31;\n\n    out[ 3] = val24 + val20;\n\n    out[19] = val25 + val21;\n\n    out[11] = val26 + val22;\n\n    out[27] = val27 + val23;\n\n    out[ 7] = val28 + val18;\n\n    out[23] = val29 + val19;\n\n    out[15] = val30 + val17;\n\n    out[31] = val31;\n\n}\n", "idx": 10699, "substitutes": {"out": ["p", "list", "OU", "outs", "ou", "output", "str", "j", "new", "in", "o", "buf", "obj", "tmp", "serv", "ch", "os", "var", "Out", "io", "txt", "t", "pos", "batch", "table", "OUT", "w", "cmd"], "tab": ["ab", "seq", "acc", "cont", "pb", "cur", "ind", "cell", "circ", "terms", "nt", "obj", "tmp", "tr", "var", "term", "tx", "ref", "ctx", "ctrl", "txt", " tmp", "ij", "table", "ctr", "lib", "Tab"], "tmp0": ["mp0", "mp6", "td0", "mp1", "td1", " tmp5", "tmp6", "td5", "tmp5", " tmp6", "mp5", "td6"], "tmp1": [" tmp4", "tmp4", "txt1", "temp4", "txt4", "txt2", "txt5", " tmp5", "temp5", "temp2", "tmp5", "tmp2", " tmp2", "temp1"], "val0": ["py9", "valid9", "valid1", "py0", "py20", "valid0", "valid20", "py1"], "val1": ["value1", "test11", "test01", "val01", "value11", " val01", "value01", "test1"], "val2": [" valtwo", "VALTwo", "valtwo", "VAL02", "chotwo", "val02", "choTwo", "cho2", "valTwo", " valTwo", "cho02", "VAL2", "VALtwo", " val02"], "val3": ["item4", "item11", "eval03", "item3", "eval3", "eval4", " val03", "item03", "eval11", "val03"], "val4": [" val44", "valid6", "eval44", "eval3", "valid4", "eval4", "eval6", "valid3", "valid44", "val44"], "val5": ["eval25", "eval45", "val45", " val45", "al25", "al5", "eval15", "eval5", "al15", "al45"], "val6": ["cal06", "rel6", "rel06", "cal6", "rel26", "vol06", "rel16", "vol6", "vol26", "cal26", "cal16", "vol16", "val06"], "val7": ["value7", "value77", "eval77", "try07", "eval07", "eval7", "val07", "val77", "eval17", "value07", "try77", "try7", "try17", "value17"], "val8": ["cho8", "vol15", "dim9", "cho9", "dim18", "vol9", "cho15", "vol8", "dim15", "dim8", "vol18", "cho18"], "val9": ["Val9", "cal19", " val99", " val09", "val99", "cal99", "Val19", "cal9", "cal09", "val09", "Val09", "Val99"], "val10": ["it12", "it10", "it14", "vol11", "it11", "vol14", "vol12", "vol10"], "val11": ["valid14", "eval12", "valid11", "valid12", "valid17", "eval17", "eval11", "eval14"], "val12": ["id11", "id12", "vol15", "eval12", "id16", "vol11", "vol12", "eval11", "eval15", "eval16", "vol16", "id15"], "val13": ["dim13", "dim07", "dim16", "eval13", "def13", "eval07", "val07", "eval17", "dim17", "def16", "def17", "eval16", "def07"], "val14": ["li15", "vol15", "value15", "li14", "value16", "vol14", "li17", "value14", "vol17", "value17", "vol16", "li16"], "val15": ["vol30", "vol15", "valid15", "valid30", "eval12", "eval30", "valid17", "valid12", "eval17", "vol12", "eval15", "vol17"], "val16": ["test18", "test16", "vol15", "test15", "test17", "eval16", "eval17", "eval15", "vol17", "eval18", "vol18", "vol16"], "val17": ["valid07", "value16", "eval07", "valid17", "val07", "eval17", "value07", "valid27", "valid16", "eval27", "value27", "eval16", "value17"], "val18": ["item18", "valid23", "item23", "eval19", "item48", "item19", "val48", "valid48", "valid19", "eval48", "eval23", "eval18", "valid18"], "val19": ["eval19", "item23", "vol24", "item17", "item19", "vol19", "eval17", "eval23", "eval24", "vol23", "item24", "vol17"], "val20": ["eval19", "test60", "test10", "test20", "vol19", "vol20", "eval10", "val60", "test19", "vol60", "eval20", "eval60", "vol10"], "val21": ["dim21", "ul22", "rel28", "dim23", "rel23", "dim28", "rel21", "rel22", "ul23", "dim22", "ul21", "ul28"], "val22": ["all26", "cal21", "all28", "vol26", "all21", "cal26", "vol21", "cal28", "vol22", "vol28", "cal22", "all22"], "val23": ["eval26", "ver25", "eval25", "vol3", "eval3", "ver3", "ver26", "vol26", "ver23", "eval23", "vol23", "vol25"], "val24": ["al29", "item23", "al27", "al23", "item27", "item29", "item24", "al24"], "val25": ["test34", "test26", "item27", "val34", "item26", " val34", "item25", "test25", "item34", "test27"], "val26": ["ival25", "valid26", "ival30", "ival19", "ival26", "eval19", "valid30", "eval25", "eval26", "eval30", "valid25", "valid19"], "val27": ["eval26", "VAL29", "eval25", "VAL26", "VAL27", "eval29", "eval27", "VAL25"], "val28": ["eval38", "def38", "eval28", "def28", "def23", "val38", "eval23", " val38", "eval29", "def29"], "val29": ["ival28", "ival39", "eval28", "val39", " val39", "ival29", "eval29", "eval27", "eval39", "ival27"], "val30": ["VAL31", "ul30", "VAL29", "ul31", "val34", "ul29", "ul34", " val34", "VAL30", "VAL34"], "val31": ["al31", "bl31", "bl27", "bl34", "valid31", "al27", "val34", "al28", "valid34", "valid28", "bl28", "al34", "valid27"]}}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n\n{\n\n    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);\n\n    tcg_gen_st32_tl(cpu_T[0], cpu_env, \n\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n\n    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);\n\n    tcg_gen_st_tl(cpu_T[0], cpu_env, \n\n                  offsetof(CPUX86State,segs[seg_reg].base));\n\n}\n", "idx": 10721, "substitutes": {"seg_reg": ["seg2register", "seg__Reg", "seg_rec", "seg__rec", "seg_num", "seg__num", "segin_num", "segment_reg", "seg__reg", "sep_reg", "segment_Reg", "seg_Reg", "segin_reg", "seg_register", "segment_msg", "sep_Reg", "seg2reg", "sep_rec", "seg__register", "seg2num", "segin_register", "seg_msg"]}}
{"project": "FFmpeg", "commit_id": "5a446bc88e49cc6400d0c646ca1eb540a727c9de", "target": 1, "func": "static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n", "idx": 10723, "substitutes": {"src": ["sb", "np", "err", "sur", "ls", "url", "look", "ul", "unc", "rc", "arc", "secure", "load", "impl", "sys", "source", "rb", "loc", "pkg", "vp", "ptr", "rel", "ins", "sync", "via", "sw", "addr", "ser", "stat", "supp", "stack", "bh", "sl", "scan", "ur", "hl", "rt", "stats", "ssl", "req", "txt", "sc", "ij", "aux", "sub", "ack", "cur", "str", "result", "rob", "th", "sr", "slice", "iter", "sec", "st", "s", "tr", "sn", "input", "gc", "stream", "ctr", "comp", "RC", "lib", "conv", "r", "cb", "proc", "rs", "syn", "tp", "fc", "bc", "usr", "bb", "rl", "inst", "iv", "check", "usc", "dest", "vc", "spec", "img"], "stride": ["driveride", "STRice", "provide", "strend", "stockiden", "drend", "stringade", "arride", " strider", "frride", "dride", "provice", "arrride", "stringided", "stided", "stringid", "scopeided", "STRend", "fride", "stiding", "strine", "slide", "striding", "strride", "STRension", "scoperide", "arrided", " strade", "STRide", "strice", "STRiding", "slride", "scopeide", "slid", "drider", "strided", "STRided", "privide", "drride", "strade", "slice", "prividing", "strension", "scopeension", " strid", "slade", "frider", "STRider", "frend", " strided", "privride", "drivergrade", "STRgrade", "stine", "striden", "strider", "strgrade", "privine", "arrider", "strid", "STRride", "STRine", "stockgrade", " strride", "driverride", "stockride", "stide", "stringide", "driveriden", "slided", "STRiden", "stockide", "provride", "stension"], "i": ["ui", "di", "p", "x", "init", " multi", " x", " m", "v", "ic", "ai", " ii", "ind", "l", "ii", "xi", "j", "sim", "I", "phi", "ix", "iu", "at", "ex", "multi", "out", "bi", " I", "n", "me", "o", "is", "ie", "print", "si", "index", "li", " bi", "ini", "it", "ci", "m", "qi", "ip", "mi", " j", "status", "batch", "ti", "im", "pi", " n", "e", "us", "ish"], "a": ["p", "aj", "aaa", "ace", "A", "h", "ab", "ma", "ga", "ae", "sa", "ar", "ata", "ai", "l", "am", "na", "an", "oa", "va", "at", "ao", "o", " at", "ak", "da", "ea", "area", "as", "app", "pa", " ca", "ach", "aff", "ca", "ia", "xa", "la", "ta", "apa", "ba", "up", "ap", "au", "e", "alpha", "w", "aa", " ba", "ac"], "b": ["r", "p", "cb", "h", "sb", "bf", "be", "ab", "f", "v", "nb", "z", "ob", "bc", "l", "j", "bb", "eb", "ub", "fb", "bl", "u", "ib", "bi", "n", "bar", "g", "back", "B", "s", "y", "gb", "bu", "br", "wb", "ad", "db", "rb", "base", "ba", "bo", "e", "bs", "by"], "c": ["r", "p", "dc", "cb", "cr", "co", "h", "C", "tc", "cf", "cat", "f", "cm", "cont", "z", "fc", "bc", "l", "ct", "cd", "code", "uc", "lc", "cc", "rc", "u", "cp", "g", "ec", "ch", "ca", "ce", "ci", "m", "chain", "cod", "sc", "ad", "con", "cs", "cut", "e", "col", "w", "cn", "ac"], "d": ["r", "di", "p", "dc", "ld", "dev", "h", "nd", "dr", "be", "dx", "bd", "D", "f", "v", "df", "dd", "du", "de", "dom", "z", "l", "cd", "dt", "u", "dos", "n", "o", "da", "diff", "md", "g", "td", "dir", "s", "dat", "dh", "sd", "dra", "dn", "ds", "m", "t", "ed", "ad", "db", "e", "w"], "d1": ["d0", "dt2", "d14", "raj", "l0", " d9", "dn14", "D1", "D2", "d3", "dt1", "dh1", "dn3", "p1", " daj", "dt10", "d9", "dh3", "l2", "daj", " d3", "p2", "p3", "l3", "r10", "p9", "d10", " d10", " d0", "dtaj", "l14", "l001", "r1", "l9", "D14", "l1", "dn1", "dn2", "D3", "dh001", "dh0", " d001", "d001", "r2"], "d2": ["D21", "d0", "x3", "dt2", "dtwo", "D1", "Dtwo", "D2", "D0", "d3", "dt02", "da0", " dtwo", "D02", "da2", "l2", "ltwo", " d3", "xtwo", "d02", "da21", "l3", "x1", "x2", " d0", "da1", "l1", " d02", "D3", " d21", "d21"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727, "substitutes": {"d": ["di", "p", "idd", "dc", "ld", "dev", "done", "send", "dr", "dump", "dx", "nd", "red", "od", "bd", "D", "ard", "f", "df", "du", "dd", "de", "id", "dm", "z", "gd", "add", "ind", "ct", "cd", "j", "dl", "hd", "dt", "debug", "admin", "n", "o", "pd", "da", "md", "g", "did", "td", "details", "dh", "dat", "fd", "y", "sd", "amd", "q", "dn", "ds", "m", "draw", "ed", "ad", "db", "ord", "e", "and", "w", "rd", "mod"], "alloc": ["ack", "util", "usage", "dev", "inv", "init", "mem", "slot", "cmd", "fat", "vol", "access", "cu", "org", "raw", "all", "buf", "nt", "pool", "urg", "info", "empty", "cmp", "oca", "go", "gr", "iat", "reg", "ctx", "sys", "ref", "req", "pos", "rac", "loc", "res", "oc", "pkg", "aux", "gc", "hw", "zero", "ac"], "entry": ["r", "or", "ent", "x", "ient", "ace", "slot", "se", "enter", "insert", "attr", "ries", "cont", "id", "data", "connection", "cell", "seed", "needed", "name", "import", "query", "ident", "command", "window", "key", "record", "rance", "space", "nt", "count", "size", "event", "ie", "index", "try", "def", "field", "info", "attribute", "ry", "q", "offset", "inter", "it", "counter", "port", "row", "action", "Entry", "vid", "e", "RY", "ptr", "address", "zero", "error", "cmd"], "vector": ["shock", "controller", "ctors", "x", "ror", "feature", "value", "sector", "ar", "v", "ser", "vr", "number", "serial", "version", "command", "ver", "ion", "window", "device", "direction", "ve", "size", "iter", "sv", "conv", "relation", "transform", "index", "history", "tr", "var", "detail", "variable", "driver", "header", "sequence", "gradient", "vec", "V", "translation", "counter", "Vector", "buffer", "port", "row", "ensor", "action", "description", "clock", "product", "material", "expression", "address", "length", "response"], "control": ["controller", "high", "value", "cont", "success", "data", "Control", "version", "contact", "controlled", "command", "cell", "capacity", "lr", "shell", "scroll", "shift", "rc", "label", "config", "ctl", "card", "form", "trl", "index", "hold", "script", "handle", "rol", "bit", "driver", "sequence", "forward", "vec", "ctrl", "check", "critical", "filter", "sc", "status", "normal", "clock", "ctr", "cmd"], "addr": ["x", "inv", "dr", "np", "err", "ix", "align", "urg", "arr", "ref", "now", "adr", "t", "ad", "db", "loc", "pkg", "ord", "ptr", "k", "state", "w", "cmd", "sw", "attr", "ret", "order", "obj", "atom", "ress", "a", "gz", "act", "handle", "arp", "q", "rt", "hash", "req", "res", "asm", "aux", "host", "ag", "msg", "ack", "p", "init", "off", "eth", "i", "ar", "coord", "hop", "id", "l", "pad", "at", "nt", "g", "prefix", "Address", "aug", "elt", "alias", "arch", "arg", "r", "art", "aj", "v", "vr", "add", "debug", "admin", "aff", "adj", "offset", "uv", "gate", "ip", "pos", "point", "alt", "address"]}}
{"project": "qemu", "commit_id": "d279279e2b5cd40dbcc863fb66a695990f304077", "target": 1, "func": "static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        /* XXX: Some CPUs implement this in hardware.\n\n           Not supported yet. */\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 10730, "substitutes": {"ctx": ["func", "cb", "wd", "qq", "np", "conn", "tc", " cx", "xy", "cf", "cm", "std", "ck", "jp", "cfg", "tm", "bc", "nc", "ct", "height", "cl", "jac", "ka", "cu", "cc", "stack", "unc", "qt", "wx", "setup", "nt", "cp", "cv", "obj", "ctl", "cas", "prefix", "history", "work", "act", "handle", "kb", "info", "tx", "cmp", "ca", "js", "iat", "fx", "req", "c", "txt", "kt", "sc", "anc", "cpu", "kw", "resp", "Context", "xc", "pkg", "context", "wcs", "ctr", "gc", "hw", "ppo", "cn", "cmd"], "rt": ["r", "rin", "dist", "pr", "RT", "nd", "round", "unit", "rs", "rr", "ret", "ri", "vr", "wr", "wit", "rh", "rf", "pt", "ct", "rec", "fr", "tt", "gt", "hd", "root", "dt", "rect", "rc", "rm", "lt", "feat", "nt", "rl", "vt", "bt", "net", "mt", "try", "rat", "ut", "tx", "lat", "yt", "sys", "wt", "it", "fin", "rx", "rn", "adr", "txt", "res", "rb", "rw", "ti", "wind", "rot", "rid", "ptr"], "rd": ["r", "ld", "cr", "hr", "nd", "od", "red", "bd", "rs", "rr", "dd", "ri", "wr", "ird", "rend", "rh", "ct", "cd", "rss", "rc", "rm", "xd", "rg", "md", "td", "d", "hyd", "ro", "sd", "rn", "ped", "ud", "rb", "rw", "rust", "RD", "mid", "rid", "cmd"], "t0": ["t\t", " t8", "Tnet", "tc050", "detZero", " tnet", "T1", "tathis", "tcMac", " t1", "t780", "str0", "p2", "tcfunc", "t1", "tc256", "kt8", "set780", "dtZero", "vt050", " tZero", "tcZero", "pt0", "t256", "tc0", "detMac", "ct\t", "dt2", "taZero", "tfunc", "ct0", "ut0", " t528", "vt0", "dt7", "t7", "tbase", "ktbase", "pt528", " t255", "t050", "t255", " t7", "toZero", "dt0", "T7", "det0", "timeau", "tdnull", "t2", "setMac", "gMac", "tMac", "stZero", "pt255", "vtfunc", "tdthis", "tZero", "ct780", "ta256", "gInfo", "tcnull", "ptZero", "timeZero", " t3", "tInfo", " t050", "set0", " tbase", " t2", "tcInfo", "tanull", "tanet", "t528", "TZero", "dt1", "p7", "ta0", " tau", "gZero", "t3", "timeInfo", "kt\t", "to255", "tc8", "t8", "ut050", "td0", "tcbase", "T0", "st0", "tcthis", " tInfo", "str\t", "to528", "T2", "td256", "g0", "T3", "utfunc", "strMac", "tthis", "tc780", "p0", "tau", "tnull", "detInfo", "p3", "tnet", "str780", "kt0", "kt050", "time0", "to0", "kt780", "tcau"]}}
{"project": "qemu", "commit_id": "af01492755b82ccaf0d15014477b34ba3ea643fc", "target": 1, "func": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n", "idx": 10735, "substitutes": {"dev": [" Dev", "pro", "h", "conf", "DEV", "off", "Dev", "mem", "ev", " device", "conn", "proc", "v", "dd", "de", "data", "cam", "tech", "serial", "priv", "usb", "pad", "pt", "ver", "sky", "window", "new", "raw", "debug", "device", "out", "stick", "ve", "buf", "des", "obj", "nt", "devices", "md", "d", "hid", "def", "dem", "unknown", "info", "sd", "desc", "go", "sys", "adv", "ctx", "Device", "home", "dis", "ad", "det", "doc", "hw", "spec", "w", "cmd"], "errp": ["Erp", "errps", "errP", "erP", "ErP", "erps", "Erps", " errps", " errP", "erp"], "s": ["self", "ts", "sb", "ats", "ses", "sol", "rs", "su", "se", "sa", "i", "ls", "v", "sp", "ss", "syn", "es", "l", "ps", "gs", "aws", "sts", "n", "sq", "store", "sv", "sl", "is", "g", "b", "as", "si", "sam", "pers", "y", "set", "sys", "js", "stats", "hs", "ds", "S", "sis", "c", "t", "so", "spec", "services", "bs", "qs", "ns"]}}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "static int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n\n{\n\n    RangeCoder *c = &fs->c;\n\n    uint8_t state[CONTEXT_SIZE];\n\n    unsigned ps, i, context_count;\n\n    memset(state, 128, sizeof(state));\n\n\n\n    if (fs->ac > 1) {\n\n        for (i = 1; i < 256; i++) {\n\n            fs->c.one_state[i]        = f->state_transition[i];\n\n            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];\n\n        }\n\n    }\n\n\n\n    fs->slice_x      = get_symbol(c, state, 0) * f->width;\n\n    fs->slice_y      = get_symbol(c, state, 0) * f->height;\n\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;\n\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n\n\n    fs->slice_x     /= f->num_h_slices;\n\n    fs->slice_y     /= f->num_v_slices;\n\n    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;\n\n    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n\n    if ((unsigned)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < f->plane_count; i++) {\n\n        PlaneContext *const p = &fs->plane[i];\n\n        int idx               = get_symbol(c, state, 0);\n\n        if (idx > (unsigned)f->quant_table_count) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        p->quant_table_index = idx;\n\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n\n        context_count = f->context_count[idx];\n\n\n\n        if (p->context_count < context_count) {\n\n            av_freep(&p->state);\n\n            av_freep(&p->vlc_state);\n\n        }\n\n        p->context_count = context_count;\n\n    }\n\n\n\n    ps = get_symbol(c, state, 0);\n\n    if (ps == 1) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 1;\n\n    } else if (ps == 2) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 0;\n\n    } else if (ps == 3) {\n\n        f->cur->interlaced_frame = 0;\n\n    }\n\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n\n\n\n    if (av_image_check_sar(f->width, f->height,\n\n                           f->cur->sample_aspect_ratio) < 0) {\n\n        av_log(f->avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n\n               f->cur->sample_aspect_ratio.num,\n\n               f->cur->sample_aspect_ratio.den);\n\n        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10738, "substitutes": {"f": ["flag", "flow", "xf", "fr", "fed", "fo", "fb", "buff", "of", "_", "fff", "fx", "ref", "tf", "t", "fit", "fac", "w", "fw", "h", "conf", "cont", "fee", "ef", "lf", "all", "fal", "fm", "info", "inf", "al", "um", "cf", "rf", "l", "uf", "diff", "fab", "g", "fl", "fp", "fi", "F", "cal", "e", "func", "bf", "ft", "df", "v", "ff", "z", "fc", "call", "fa", "sf", "form", "fd", "full", "fe", "m", "fuel"], "fs": ["ls", "frames", "xf", "obs", "alf", "fr", "fb", "Fs", "flags", "ics", "sys", "tf", "js", "cells", "features", "faces", "ags", "wcs", "ms", "ns", "fw", "uses", "ats", "ows", "settings", "fee", "fts", "terms", "fm", "posts", "files", "stats", "ds", "fields", "weights", "utils", "services", "fits", "vs", "orts", "cs", "aux", "ims", "ports", "cf", "outs", "eks", "its", "FS", "uf", "ils", "bytes", "s", "irs", "reads", "videos", "os", "aints", "flows", "fp", "fi", "hs", "ips", "steps", "gc", "ts", "fps", "bf", "vals", "rs", "df", "iffs", "alls", "args", "ss", "fc", "bc", "gs", "sts", "sf", "rets", "actions", "views", "ums", "fd", "bits", "bs", "qs"], "c": ["r", "dc", "cb", "h", "co", "cr", "conf", "C", "cus", "cf", "tc", "cat", "ae", "v", "cm", "cont", "z", "cam", "fc", "bc", "l", "ct", "nc", "cd", "mac", "code", "uc", "cl", "lc", "cu", "cc", "unc", "rc", "u", "n", "cv", "o", "cp", "count", "comp", "config", "a", "g", "b", "cache", "ec", "ch", "s", "com", "ca", "ctx", "ce", "ci", "mc", "m", "t", "chain", "sc", "con", "xc", "cs", "e", "context", "gc", "pc", "icc", "cn", "ac"], "state": ["tag", "type", "data", "seed", "lock", "close", "range", "count", "er", "print", "history", "index", "cache", "_", "t", "ate", "h", "rule", "test", "output", "stat", "name", "code", "new", "root", "config", "resource", "handle", "info", "q", "sequence", "it", " states", "buffer", "status", "block", "port", "cs", "storage", "scope", "al", "init", "job", "commit", "id", "STATE", "l", "str", "result", "start", "component", " State", "slice", "out", "space", "store", "size", "pointer", "is", "st", "s", "stroke", "user", "node", "style", "length", "list", "request", "role", "version", "key", "n", "State", "area", "zone", "post", "local", "states", "m", "base", "spec"], "ps": [" pi", " cs", " pc", "aps", " ip", " pos", " seq", " ops", " flags", " sp", " parent", "ops", " points", " cp", " ss", " rows", "pa", "bytes", "s", " pp", "fp", "PS", " PS", "ips", " states", "cs", "ptr"], "i": ["ui", "di", "ami", "cli", "list", "ir", "init", "span", "uri", "gi", "ri", "id", "ai", "ic", "ind", "name", "ei", "ii", "mac", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "key", "ex", "multi", "bi", "me", "PI", "in", "o", "n", "iter", "remote", "g", "is", "er", "print", "si", "index", "try", "li", "info", "ini", "q", "gu", "it", "\u0438", "ci", "m", "chain", "ip", "mi", "ij", "zi", "qi", "batch", "ti", "point", "im", "pi", "ki", "ims", "us"], "context_count": ["context_name", "context_cache", "context1c", "context1cache", "context1name", " context_name", "context_c", " context_cache", " context_c", "context1count"], "p": ["r", "h", "lp", "v", "op", "pair", "l", "j", "at", "u", "n", "o", "cp", "P", "a", "g", "d", "pa", "m", "t", "pos", "port", "ap", "pc", "e"]}}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10741, "substitutes": {"cs": ["ts", "ims", "cus", "aps", "cf", "rs", "ls", "cm", "ces", "ss", "fc", "bc", "nc", "ps", "cks", "ct", "acs", "ys", "lc", "ix", "sts", "cc", "iss", "cp", "CS", "fs", "s", "ins", "ms", "ks", "css", "js", "ctx", "hs", "ds", "ce", "ci", "c", "sc", "Cs", "pc", "vc", "ctr", "wcs", "bs", "gc", "cn", "ns"], "bp": ["p", "cb", "bf", "sb", " BP", "np", "wp", "lp", "hp", "ipp", "pp", "nb", "sp", "pb", "tp", "dp", "bc", "bj", "bb", "ep", "eb", "gp", "fb", "ijk", "ib", "bi", "xp", "cp", "bh", "bt", "b", "ump", "pa", "bsp", "BP", "kb", "arp", "isp", "lip", "fp", "br", "bps", "db", "bn", "bg", "pc", "php", "vp", "bs", "jp"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n", "idx": 10744, "substitutes": {"rdma_ram_block": ["rdma_ramacBlock", "rdma_mem_bl", "rdma_ram_blocks", "rdma_mem_block", "rdma_rom_Block", "rdma_mem_lock", "rdma_rom_block", "rdma_ram__data", "rdma_ramacblocks", "rdma_ramacdata", "rdma_ram_lock", "rdma_ram_bl", "rdma_ramacblock", "rdma_ram_Block", "rdma_ram__blocks", "rdma_ram__Block", "rdma_ram_data", "rdma_rom_blocks", "rdma_ram__block", "rdma_rom_data"], "i": ["di", " pi", " l", "ami", " wi", " ti", "v", "gi", " key", "ri", "ai", " index", "l", " h", "ii", "xi", "j", "I", " vi", "phi", "iu", " mi", "oi", " mu", "multi", "bi", " I", "hi", "si", " k", " v", " im", "li", " bi", " e", " info", " err", "m", " hi", " di", "qi", "zi", "mi", "ij", " j", "t", " c", "ti", "pi", "k", " init"]}}
{"project": "FFmpeg", "commit_id": "a1e093a6fb324612266d40e3168a14f58adab265", "target": 0, "func": "static int decode_element(AVCodecContext *avctx, void *data, int ch_index,\n\n                          int channels)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;\n\n    uint32_t output_samples;\n\n    int i, ch;\n\n\n\n    skip_bits(&alac->gb, 4);  /* element instance tag */\n\n    skip_bits(&alac->gb, 12); /* unused header bits */\n\n\n\n    /* the number of output samples is stored in the frame */\n\n    has_size = get_bits1(&alac->gb);\n\n\n\n    alac->extra_bits = get_bits(&alac->gb, 2) << 3;\n\n    bps = alac->sample_size - alac->extra_bits + channels - 1;\n\n    if (bps > 32) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* whether the frame is compressed */\n\n    is_compressed = !get_bits1(&alac->gb);\n\n\n\n    if (has_size)\n\n        output_samples = get_bits_long(&alac->gb, 32);\n\n    else\n\n        output_samples = alac->max_samples_per_frame;\n\n    if (!output_samples || output_samples > alac->max_samples_per_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\",\n\n               output_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!alac->nb_samples) {\n\n        /* get output buffer */\n\n        alac->frame.nb_samples = output_samples;\n\n        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n    } else if (output_samples != alac->nb_samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\",\n\n               output_samples, alac->nb_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    alac->nb_samples = output_samples;\n\n    if (alac->direct_output) {\n\n        for (ch = 0; ch < channels; ch++)\n\n            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];\n\n    }\n\n\n\n    if (is_compressed) {\n\n        int16_t lpc_coefs[2][32];\n\n        int lpc_order[2];\n\n        int prediction_type[2];\n\n        int lpc_quant[2];\n\n        int rice_history_mult[2];\n\n\n\n        decorr_shift       = get_bits(&alac->gb, 8);\n\n        decorr_left_weight = get_bits(&alac->gb, 8);\n\n\n\n        for (ch = 0; ch < channels; ch++) {\n\n            prediction_type[ch]   = get_bits(&alac->gb, 4);\n\n            lpc_quant[ch]         = get_bits(&alac->gb, 4);\n\n            rice_history_mult[ch] = get_bits(&alac->gb, 3);\n\n            lpc_order[ch]         = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = lpc_order[ch] - 1; i >= 0; i--)\n\n                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);\n\n        }\n\n\n\n        if (alac->extra_bits) {\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                if(get_bits_left(&alac->gb) <= 0)\n\n                    return -1;\n\n                for (ch = 0; ch < channels; ch++)\n\n                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);\n\n            }\n\n        }\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],\n\n                            alac->nb_samples, bps,\n\n                            rice_history_mult[ch] * alac->rice_history_mult / 4);\n\n            if(ret<0)\n\n                return ret;\n\n\n\n            /* adaptive FIR filter */\n\n            if (prediction_type[ch] == 15) {\n\n                /* Prediction type 15 runs the adaptive FIR twice.\n\n                 * The first pass uses the special-case coef_num = 31, while\n\n                 * the second pass uses the coefs from the bitstream.\n\n                 *\n\n                 * However, this prediction type is not currently used by the\n\n                 * reference encoder.\n\n                 */\n\n                lpc_prediction(alac->predict_error_buffer[ch],\n\n                               alac->predict_error_buffer[ch],\n\n                               alac->nb_samples, bps, NULL, 31, 0);\n\n            } else if (prediction_type[ch] > 0) {\n\n                av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\",\n\n                       prediction_type[ch]);\n\n            }\n\n            lpc_prediction(alac->predict_error_buffer[ch],\n\n                           alac->output_samples_buffer[ch], alac->nb_samples,\n\n                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        for (i = 0; i < alac->nb_samples; i++) {\n\n            if(get_bits_left(&alac->gb) <= 0)\n\n                return -1;\n\n            for (ch = 0; ch < channels; ch++) {\n\n                alac->output_samples_buffer[ch][i] =\n\n                         get_sbits_long(&alac->gb, alac->sample_size);\n\n            }\n\n        }\n\n        alac->extra_bits   = 0;\n\n        decorr_shift       = 0;\n\n        decorr_left_weight = 0;\n\n    }\n\n\n\n    if (channels == 2 && decorr_left_weight) {\n\n        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,\n\n                           decorr_shift, decorr_left_weight);\n\n    }\n\n\n\n    if (alac->extra_bits) {\n\n        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,\n\n                          alac->extra_bits, channels, alac->nb_samples);\n\n    }\n\n\n\n    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {\n\n    switch(alac->sample_size) {\n\n    case 16: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10750, "substitutes": {"avctx": ["afconn", "avconfig", "ivctx", "ivcontext", "cvctx", "cvxc", "avjac", "avepkg", "avcc", "averpkg", "actjac", "avercontext", "vctx", "avecontext", "vctl", "actctx", "actcontext", "avejp", "ajctx", "afpkg", "auctx", "actconn", "averkt", "wavctx", "averkl", "avtx", "cvtx", "actcc", "afconfig", " avcc", "averctx", "ivjac", "wavcontext", "avekt", "actobj", "aukl", "afkt", " avtx", "avpkg", "ajconn", "ivctl", "avectx", "avconn", "aujp", "ajjac", "avjp", "afctx", "aveContext", "averxc", "avesys", "avkl", " avxc", "avobj", " avobj", "averjp", "cvcontext", "aveconn", "aveobj", "avxc", "averconfig", "avejac", "wavContext", "avkt", " avjac", "avctl", "vjac", "avcontext", " avctl", "aveconfig", "averconn", "vcontext", " avconn", "ausys", " avContext", " avcontext", "wavpkg", "avsys", "avertx", "aversys", "avContext", "avekl", "ajcc", " avpkg"], "data": ["p", "DATA", "value", "bin", "ata", "output", "Data", "window", "raw", "channel", "out", "buf", "o", "a", "d", "bytes", "dat", "def", "input", "text", "buffer", "batch", "block", "message", "stream", "image", "w", "response"], "ch_index": ["channel_ind", "ch_slice", "channel_slice", "ch_ind", "ch2ind", "channel_index", "ch_num", "ch2index", "channel_num", "ch2num", "ch2slice"], "channels": ["ichunks", "champs", " chopes", "tchannels", "Chunks", "ichanches", "chapters", "ichamps", "echunks", "achannels", "chanches", "achunks", " champs", "ichannels", "achapters", "chopes", "copes", "echannels", " chanches", "chunks", "tchapters", "capters", " chains", "echopes", "cannels", " chunks", "tchars", "tchunks", "chars", "cains", "Champs", "cunks", "Channels", "chains", "echains", "cars", "Chanches", "achars"], "alac": ["talact", "malAc", "aliace", "aldac", "allacet", "alacl", "isalic", "alic", "alerac", "halAC", "staliac", "balAc", "ulsac", "salach", "amacc", "palace", "attact", "allacc", " alAC", "aliAC", "stalact", "palac", "flacc", "stalach", "palacc", "dalac", "talsac", "aliacc", "balic", "balam", "stalacc", "aliacs", "maliac", "salacc", "salAC", " alact", "aliach", "allam", " alacc", "attiac", "malsac", "ialac", "talAc", "aracet", "aliacer", "calAc", "palacl", "halAc", "malAC", "aract", "attacl", "aliact", "stalsac", "alsac", "ulact", "halact", "ialacc", "attacc", "balsac", "elacc", "calacc", "alacet", "calic", "aljac", "alAc", "alace", "allAc", "saliac", "allac", "alAC", "alacer", "ulica", "isalacc", "aliac", "malac", "malic", "realacet", "salacl", "valact", "alerAC", "salam", "malacc", "halac", "balax", "aliacl", "salic", "dalacs", "alax", "ialic", "balAC", "allact", "balact", "calAC", "stalac", "alach", "malact", "calac", "alact", "aliax", " alacl", "talac", "amace", "attac", "talacc", "ialax", "balacl", "alam", " alic", "calacl", "salact", "flacs", "calacer", "allic", "caliac", "talAC", "caljac", "daljac", "alica", "allAC", "stalic", "allacer", "stalam", "aliiac", "allax", "allacl", "flac", "balacc", "elic", "valac", "aldact", "realac", "salac", "balac", "amacl", "isalacl", "stalica", " alax", "realact", "isalac", "arac", " aliac", "flacl", "aric", "aldsac", "valacc", "aliic", "realic", "dalacl", "malacl", " aljac", "eliac", "amac", "ulac", "aldica", "elac", "alacs", "alacc", "dalacc", " alam", "daliac", "aliam", "attic"], "has_size": ["groups_size", "has__Size", "has_length", "groups_Size", "has_error", "has_small", " has_small", "Has_size", "Has_length", "has__small", " has_Size", "groups_error", "has_Size", "has__sized", "groups_sized", "has_sized", "has__size", " has_sized", "Has_Size"], "bps": ["clips", "fps", "caps", "ats", "aps", "pps", "places", "points", "pins", "ls", "phones", "allows", "bys", "its", "cats", "tp", "bp", "jobs", "ps", "xs", "amps", "gs", "issues", "rate", "ops", "fixes", "parts", "nets", "fs", "lbs", "plugins", "posts", "bytes", "los", "eps", "flows", "bis", "grades", "rots", "tops", "hops", "bits", "ips", "tips", "weights", "beta", "steps", "planes", "TPS", "bs", "hz", "rates"], "is_compressed": ["is_cression", "isPompression", "is_buffress", "is_ompressed", "is_buffression", "is_exposed", "is_composed", "is_expressed", "is_buffressed", "isPompressor", "is_Compressor", "is_cressed", "is_Composed", "is_cressor", "is_omposed", "isPomposed", "is_compression", "is_cress", "is_ompression", "isPompressed", "isPcompression", "is_compress", "isPcomposed", "is_compressor", "is_buffressor", "is_Compressed", "is_expressor", "is_expression", "isPcompressed", "is_Compression", "is_ompressor", "is_Compress", "isPcompressor"], "decorr_shift": ["decorr___pad", "decorr_offset", "decor_offset", "decorr___shift", "decorr___share", "decorr_pad", "decor_pad", "decorr_share", "decor_share", "decor_shift", "decorr___offset"], "decorr_left_weight": ["decorr_shift_weight", "decorr_leftnesswidth", "decorr_shift_width", "decorr_shift_weights", "decorr_left_width", "decorr_leftnessshift", "decorr_leftnessweight", "decorr_left_weights", "decorr_shift_shift", "decorr_leftnessweights", "decorr_left_shift"], "ret": ["RET", "mel", "ft", "mem", "f", "repl", "re", "str", "result", "uf", "gt", "Ret", "new", "dt", "val", "reply", "rem", "summary", "out", "nt", "rets", "tmp", "not", "mt", "def", "tr", "ext", "elt", "rt", "ref", "reset", "tf", "it", "txt", "rew", "res", "len", "ll", "resp", "alt", "aux", "img", "jp"], "output_samples": ["output_saveples", "output_nonents", "output_examps", "output\u05bcsinlements", "output\u05bcsounds", "output\u05bcsinamps", "output_wsamples", "output_esutes", "output_sims", "output_pamps", "output_wsims", "output_sizes", "output_symamps", "output_symchanges", "output_sases", "output_insones", "output_csases", "output_eamples", "output_examples", "outputptsaveples", "output_bales", "output_itsonents", "output_sones", "output_svizes", "output_symutes", "output_sounds", "output_insamps", "output_csappings", "output_wsales", "output_insizes", "output_nactly", "output_namples", "output_nucks", "output_sples", "output_sesamps", "output_sonents", "output_sinamps", "output_sinks", "output_sutes", "output_samps", "output_sesinks", "outputptsaveamples", "output_bamps", "outputptsaveakes", "output_Samples", "output_csinks", "output_exlements", "output_symucks", "output_tactly", "output_iples", "output_symamples", "output_iamps", "output_sesamples", "output_csones", "output_genonents", "output_namps", "output\u05bcsamps", "output_symales", "output_sinamples", "output_eounds", "output_csizes", "output_Sales", "outputptsamps", "output_itsodes", "output_pounds", "output_slements", "output_sales", "output_symims", "outputptsaveamps", "output_Sounds", "output_csonents", "output_csamps", "output_nappings", "output_genases", "output_svamples", "outputptsamples", "output_saveamps", "output_eamps", "output_eonents", "output_iakes", "output_sakes", "output_tizes", "output_nutes", "output_sappings", "output_esamples", "output_iamples", "output_sactly", "output\u05bcsamples", "output_saveakes", "output_Slements", "output_bamples", "output\u05bcslements", "outputptsples", "output_csodes", "output_genodes", "output_ninks", "output_sinounds", "output_ponents", "output\u05bcsinamples", "output_tamples", "output_esucks", "output_tamps", "output_csamples", "output_esamps", "output_exounds", "output_sesappings", "output_sodes", "outputptsakes", "output_insamples", "output_genamples", "output_nizes", "output_svactly", "output_itsamples", "output_nounds", "output_wschanges", "output\u05bcsinounds", "output_saveamples", "output_tones", "output_sinlements", "output_nples", "output_svamps", "output_pamples", "output_Samps", "output_sucks", "output_itsases", "output_nakes", "output_schanges"], "i": ["p", "x", "v", "ai", "ind", "l", "ii", "j", "I", "phi", "ix", "bi", "b", "si", "index", "li", "y", "set", "q", "it", "ci", "c", "m", "ip", "mi", "ti", "pi"], "ch": ["att", "cb", "x", "h", "hr", "atch", "ech", "gh", "uch", "k", "cm", "chan", "sh", "ind", "cell", "cl", "child", "bot", "th", "chat", "channel", "tch", "cht", "cor", "chn", "cp", "count", "bh", "ac", "zh", "ht", "ph", "mk", "kh", "ach", "wh", "y", "chid", "ay", "q", "och", "kr", "br", "c", "sk", "batch", "anch", "chip", "CH", "cho", "cs", "pc", "col", "sch", "cut", "Ch", "ble", "ich"]}}
{"project": "FFmpeg", "commit_id": "57cc1ad35fd488c7a879661498f6f3508038d5a9", "target": 0, "func": "static av_always_inline float quantize_and_encode_band_cost_template(\n\n                                struct AACEncContext *s,\n\n                                PutBitContext *pb, const float *in,\n\n                                const float *scaled, int size, int scale_idx,\n\n                                int cb, const float lambda, const float uplim,\n\n                                int *bits, int BT_ZERO, int BT_UNSIGNED,\n\n                                int BT_PAIR, int BT_ESC)\n\n{\n\n    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float CLIPPED_ESCAPE = 165140.0f*IQ;\n\n    int i, j, k;\n\n    float cost = 0;\n\n    const int dim = BT_PAIR ? 2 : 4;\n\n    int resbits = 0;\n\n    const float  Q34 = sqrtf(Q * sqrtf(Q));\n\n    const int range  = aac_cb_range[cb];\n\n    const int maxval = aac_cb_maxval[cb];\n\n    int off;\n\n\n\n    if (BT_ZERO) {\n\n        for (i = 0; i < size; i++)\n\n            cost += in[i]*in[i];\n\n        if (bits)\n\n            *bits = 0;\n\n        return cost * lambda;\n\n    }\n\n    if (!scaled) {\n\n        abs_pow34_v(s->scoefs, in, size);\n\n        scaled = s->scoefs;\n\n    }\n\n    quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval);\n\n    if (BT_UNSIGNED) {\n\n        off = 0;\n\n    } else {\n\n        off = maxval;\n\n    }\n\n    for (i = 0; i < size; i += dim) {\n\n        const float *vec;\n\n        int *quants = s->qcoefs + i;\n\n        int curidx = 0;\n\n        int curbits;\n\n        float rd = 0.0f;\n\n        for (j = 0; j < dim; j++) {\n\n            curidx *= range;\n\n            curidx += quants[j] + off;\n\n        }\n\n        curbits =  ff_aac_spectral_bits[cb-1][curidx];\n\n        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];\n\n        if (BT_UNSIGNED) {\n\n            for (k = 0; k < dim; k++) {\n\n                float t = fabsf(in[i+k]);\n\n                float di;\n\n                if (BT_ESC && vec[k] == 64.0f) { //FIXME: slow\n\n                    if (t >= CLIPPED_ESCAPE) {\n\n                        di = t - CLIPPED_ESCAPE;\n\n                        curbits += 21;\n\n                    } else {\n\n                        int c = av_clip(quant(t, Q), 0, 8191);\n\n                        di = t - c*cbrtf(c)*IQ;\n\n                        curbits += av_log2(c)*2 - 4 + 1;\n\n                    }\n\n                } else {\n\n                    di = t - vec[k]*IQ;\n\n                }\n\n                if (vec[k] != 0.0f)\n\n                    curbits++;\n\n                rd += di*di;\n\n            }\n\n        } else {\n\n            for (k = 0; k < dim; k++) {\n\n                float di = in[i+k] - vec[k]*IQ;\n\n                rd += di*di;\n\n            }\n\n        }\n\n        cost    += rd * lambda + curbits;\n\n        resbits += curbits;\n\n        if (cost >= uplim)\n\n            return uplim;\n\n        if (pb) {\n\n            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);\n\n            if (BT_UNSIGNED)\n\n                for (j = 0; j < dim; j++)\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)\n\n                        put_bits(pb, 1, in[i+j] < 0.0f);\n\n            if (BT_ESC) {\n\n                for (j = 0; j < 2; j++) {\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {\n\n                        int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191);\n\n                        int len = av_log2(coef);\n\n\n\n                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);\n\n                        put_bits(pb, len, coef & ((1 << len) - 1));\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (bits)\n\n        *bits = resbits;\n\n    return cost;\n\n}\n", "idx": 10765, "substitutes": {"s": ["ts", "p", "less", "fps", "h", "sb", "ats", "sw", "ses", "rs", "sa", "v", "ls", "ss", "es", "its", "ps", "gs", "aws", "an", "ops", "sts", "http", "n", "sq", "a", "sv", "fs", "g", "is", "as", "sam", "ins", "sg", "scl", "js", "sys", "hs", "ds", "ssl", "stats", "S", "c", "t", "spec", "pkg", "cs", "e", "bs", "w", "sort", "qs", "ns"], "pb": ["p", "bf", "sb", "np", "wp", "tc", "lp", "nb", "tp", "bp", "tk", "uf", "cv", "cp", "xb", "bh", "pa", "BP", "kB", "fp", "mp", "bps", "rb", "pkg", "pc", "vp", "lb", "bm", "conv"], "in": ["p", "rin", "inv", "init", "mem", "bin", "v", "id", "ic", "data", "add", "ind", "inn", "l", "sample", "isin", "en", "val", "raw", "ani", "inc", "out", "range", "is", "ac", "din", "scan", "vin", "IN", "min", "gin", "In", "bit", "input", "local", "it", "m", "c", "nin", "inf", "sum", "len", "inner", "con", "ins"], "scaled": ["pscaled", " unscale", "ascalled", "scaped", " scale", "Scaped", "pscaling", "pscattered", "scalled", "escalled", "Scaling", "scached", "Scaled", "Scale", "ascached", "SCalled", "SCaling", "pscaped", " unscaled", " unscattered", "SCaled", "SCale", " unscached", "Scattered", "scale", " unscaped", " unscaling", "ascaled", "ascale", " scalled", " scached", "Scalled", " unscalled", "escaling", "escale", "scattered", "scaling", "escaled"], "size": ["send", "span", "sw", "mem", "sp", "fee", "name", "height", " sizes", "capacity", "small", "ose", "shift", "large", "slice", "range", "space", "n", "out", "count", "time", "area", "zone", "scale", "Size", "si", "win", "dim", "shape", "empty", "sn", "max", "ize", "m", "c", "num", "sc", "len", "im", "mode", "SIZE", "length", "zero", "dimension", "scope"], "scale_idx": ["scaleEidpx", "scaleEidentpx", "scale_midxe", "scale_sidxc", "scale_idX", "scale_idxs", "scaleEidx", "scaleEidentindex", "scale_idindex", "scale_sidindex", "scale_idexs", "scale_identindex", "scaleEidentx", "scale_midX", "scale_identpx", "scale_idpx", "scale_idxc", "scale_iny", "scale_idepx", "scale_sidx", "scale_identx", "scale_midx", "scale_uidx", "scale_idexc", "scale_ideindex", "scaleEidentxc", "scale_idey", "scaleEidindex", "scale_uidX", "scale_idxe", "scale_idy", "scale_inxs", "scaleEidxc", "scale_sidpx", "scale_uidxe", "scale_inx", "scale_idex", "scale_inxc", "scale_identxc"], "cb": ["fine", "func", "dc", "bf", "sb", "cli", "cf", "tc", "coord", "nb", "ck", "cfg", "fc", "iq", "cell", "bc", "nc", "cd", "bb", "lc", "cu", "cc", "cv", "cp", "b", "CU", "dim", "crop", "kb", "cmp", "gb", "ctx", "fi", "ctrl", "c", "abb", "wb", "ci", "cod", "sc", "db", "CB", "rb", "beta", "callback", "gc", "vc", "ctr", "lb", "cale", "cn", "cmd"], "lambda": ["eta", "lux", "func", "step", "bf", "dist", "cf", "fun", "vol", "z", "xf", "function", "appa", "phi", "igma", "pha", "elta", "shift", "sq", "lam", "da", "sf", "lu", "grad", "dB", "scale", "shr", "kl", "partial", "etc", "Delta", "wt", "beta", "kw", "mu", "alpha", "lb", "length", "factor", "delay"], "uplim": ["uppim", "fuplib", "uppib", "fuplist", "fuppist", "uplib", "fuppims", "uiplim", "uppims", "uppist", "fuplims", "uiplims", "ublib", "ublims", "uiplib", "ublim", "uplist", "ublist", "uplims", "fuppib", "uiplist", "fuppim", "fuplim"], "bits": ["ones", "units", "bf", "vals", "points", "frames", "its", "bands", "obs", "rows", "jobs", "ps", "heads", "xs", "ops", "parts", "nets", "checks", "flags", "fs", "b", "blocks", "bytes", "offs", "ions", "bool", "bit", "bis", "offset", "ints", "keys", "limits", "weights", "pos", "bps", "items", "pieces", "features", "words", "planes", "ims", "bs", "hz"], "BT_ZERO": ["BT_NONE", "BT_SCETA", "BT__SOW", "BT__SERO", "BT__SONE", "BT_NZero", "BT_ZETA", "BT_SCONE", "BT_USE", "BT_USOW", "BT__ZOW", "BT_HOW", "BT_ZIETA", "BT_ZZero", "BT_HE", "BT_SCZero", "BT__ZERO", "BT_HERO", "BT_ZIZero", "BT_ZOW", "BT_ZIERO", "BT__SE", "BT_SONE", "BT_ZONE", "BT_HONE", "BT_USONE", "BT_SOW", "BT__ZONE", "BT_SCERO", "BT_SE", "BT_NERO", "BT_ZE", "BT_ZIONE", "BT__ZE", "BT_SERO", "BT_NETA", "BT_USERO"], "BT_UNSIGNED": ["BT_UNSIGNed", "BT_UNSIGNENT", "BT_UNIGNED", "BT_UnIGNED", "BT_ULSIGNID", "BT_UNIGNed", "BT_UNSIGNABLE", "BT_UnSIGNENT", "BT_UnSIGNED", "BT_UNAGING", "BT_UNPORTED", "BT_UnIGNABLE", "BT_UnSIGNABLE", "BT_UnSIGNAL", "BT_UNSPECed", "BT_UNAGed", "BT_UNSPECENT", "BT_UNSIGNIFIED", "BT_ULSIGNING", "BT_UNCAPed", "BT_UNSAed", "BT_UNIGNENT", "BT_UNPORTed", "BT_UNSIGNAL", "BT_UNSSENT", "BT_UNCAPED", "BT_UNSSed", "BT_ULCAPed", "BT_UNIGNID", "BT_UNPORTABLE", "BT_UNIGNING", "BT_UNCAPID", "BT_ULCAPED", "BT_UNSSIFIED", "BT_UNSIGNING", "BT_UNSIGNID", "BT_UNSPECIFIED", "BT_ULCAPID", "BT_UnIGNAL", "BT_UNIGNIFIED", "BT_UnIGNENT", "BT_UnSIGNIFIED", "BT_ULSIGNED", "BT_UNSAABLE", "BT_UNPORTAL", "BT_UNSAED", "BT_UnIGNed", "BT_ULCAPING", "BT_UNSPECED", "BT_UNSSED", "BT_UnIGNIFIED", "BT_UNIGNAL", "BT_ULSIGNed", "BT_UNAGED", "BT_UNAGID", "BT_UnSIGNed", "BT_UNIGNABLE", "BT_UNCAPING", "BT_UNSAAL"], "BT_PAIR": ["BT_SAIR", "BT_AIRED", "BT_CLAINTER", "BT_PAORD", "BT_NEILL", "BT_PAILL", "BT_CLAIL", "BT_AIM", "BT_AIR", "BT_PAIRED", "BT_PAINTER", "BT_NEIR", "BT_SAIL", "BT_SAORD", "BT_HAILL", "BT_PORD", "BT_AILL", "BT_CLAIR", "BT_PAIM", "BT_NEIM", "BT_PINTER", "BT_CLAORD", "BT_PIR", "BT_NEIRED", "BT_HAIM", "BT_PAIL", "BT_SAINTER", "BT_HAIR", "BT_PIL", "BT_HAIRED"], "BT_ESC": ["BT_BSC", "BT_PSC", "BT_ESE", "BT_BSCD", "BT_RESCAP", "BT_BSCAP", "BT_ESCD", "BT_PSCD", "BT_BSE", "BT_RESE", "BT_ESCAP", "BT_PSE", "BT_RESCD", "BT_RESC", "BT_PSCAP"], "i": ["r", "p", "ui", "ami", "cli", "x", "f", "v", "gi", "ri", "id", "ai", "ic", "ind", "l", "ii", "ei", "xi", "sim", "I", "ji", "ix", "iu", "oi", "multi", "bi", "n", "me", "iter", "b", "ie", "g", "print", "si", "index", "hi", "is", "try", "li", "info", "y", "ini", "q", "it", "ci", "m", "t", "zi", "mi", "ij", "ip", "chain", "status", "ti", "point", "qi", "im", "batch", "pi", "e", "ki"], "j": ["att", "p", "aj", " dj", "oj", "jj", "next", "jc", "v", "json", "job", "jump", "jit", "z", "ng", "ind", "l", "pt", "bj", "ji", "other", "jac", "key", "ijk", "bi", "n", "o", "obj", "ja", "b", "kj", "g", "ie", "index", "jo", "try", "tr", "y", "q", "js", "adj", "it", "J", "m", "c", "br", "je", "jl", "ij", "dj", "uj", "jas", "jp"], "k": ["r", "p", "x", "v", "z", "ka", "ik", "key", "u", "n", "o", "ak", "g", "b", "mk", "y", "q", "ok", "max", "K", "it", "m", "sk", "ij", "ki", "w", "ac"], "off": ["ack", " offset", "dev", "opt", "ot", "on", "mem", "OFF", "ff", "from", "f", "attr", "offer", "wo", "loss", "op", "end", "alf", "pad", "height", "command", "start", "window", "shift", "raw", "after", "out", "o", "obj", "total", "over", "ov", "load", "offs", "Off", "of", "def", "ext", "ok", "ref", "down", "offset", "eff", "Offset", " OFF", "check", "t", "pos", "loc", "point", "kw", "opp", "before", " Off", "bo", "aux", "low", "error", "cmd"], "vec": ["init", "vals", "seq", "xy", "vector", "err", "norm", "ver", "val", "cv", "ve", "buf", "rad", "act", "var", "iv", "cmp", "ref", "eff", "sc", "len", "res", "loc", "nv", "vc", "fac", "conv"], "quants": ["inquants", "quANT", "QUants", " quant", "inquats", "aquats", "QUats", "quant", "inquANT", "QUANT", " quANT", "aquANT", " quats", "aquants", "inquant", "QUant", "quats", "aquant"], "curbits": ["turbedits", "cribITS", "culpitations", "cobbit", " culpists", "cibITS", "curbats", "curbITS", "curbedITS", "cobbitations", "crobitations", "turbals", "cribats", "turbedals", "culpit", "crobit", "curbitations", "turbITS", "cribits", " curbit", "cribals", " curbitations", "curbedats", "turbedITS", "curbedals", "curbists", "curbedits", "turbits", " culpitations", "cobbists", "crobists", "culpits", " curbists", "culpists", "curbals", "turbedats", "cibals", " culpit", "cobbits", "curbit", "cibats", " culpits", "turbats", "crobits", "cibits"]}}
{"project": "FFmpeg", "commit_id": "ba571f6b4d15a998d6fde387509cd84177fccd96", "target": 0, "func": "static void event_loop(VideoState *cur_stream)\n\n{\n\n    SDL_Event event;\n\n    double incr, pos, frac;\n\n\n\n    for(;;) {\n\n        double x;\n\n        SDL_WaitEvent(&event);\n\n        switch(event.type) {\n\n        case SDL_KEYDOWN:\n\n            if (exit_on_keydown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n            switch(event.key.keysym.sym) {\n\n            case SDLK_ESCAPE:\n\n            case SDLK_q:\n\n                do_exit(cur_stream);\n\n                break;\n\n            case SDLK_f:\n\n                toggle_full_screen(cur_stream);\n\n                break;\n\n            case SDLK_p:\n\n            case SDLK_SPACE:\n\n                if (cur_stream)\n\n                    toggle_pause(cur_stream);\n\n                break;\n\n            case SDLK_s: //S: Step to next frame\n\n                if (cur_stream)\n\n                    step_to_next_frame(cur_stream);\n\n                break;\n\n            case SDLK_a:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);\n\n                break;\n\n            case SDLK_v:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);\n\n                break;\n\n            case SDLK_t:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);\n\n                break;\n\n            case SDLK_w:\n\n                if (cur_stream)\n\n                    toggle_audio_display(cur_stream);\n\n                break;\n\n            case SDLK_LEFT:\n\n                incr = -10.0;\n\n                goto do_seek;\n\n            case SDLK_RIGHT:\n\n                incr = 10.0;\n\n                goto do_seek;\n\n            case SDLK_UP:\n\n                incr = 60.0;\n\n                goto do_seek;\n\n            case SDLK_DOWN:\n\n                incr = -60.0;\n\n            do_seek:\n\n                if (cur_stream) {\n\n                    if (seek_by_bytes) {\n\n                        if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){\n\n                            pos= cur_stream->video_current_pos;\n\n                        }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){\n\n                            pos= cur_stream->audio_pkt.pos;\n\n                        }else\n\n                            pos = avio_tell(cur_stream->ic->pb);\n\n                        if (cur_stream->ic->bit_rate)\n\n                            incr *= cur_stream->ic->bit_rate / 8.0;\n\n                        else\n\n                            incr *= 180000.0;\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, pos, incr, 1);\n\n                    } else {\n\n                        pos = get_master_clock(cur_stream);\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            break;\n\n        case SDL_MOUSEBUTTONDOWN:\n\n            if (exit_on_mousedown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n        case SDL_MOUSEMOTION:\n\n            if(event.type ==SDL_MOUSEBUTTONDOWN){\n\n                x= event.button.x;\n\n            }else{\n\n                if(event.motion.state != SDL_PRESSED)\n\n                    break;\n\n                x= event.motion.x;\n\n            }\n\n            if (cur_stream) {\n\n                if(seek_by_bytes || cur_stream->ic->duration<=0){\n\n                    uint64_t size=  avio_size(cur_stream->ic->pb);\n\n                    stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);\n\n                }else{\n\n                    int64_t ts;\n\n                    int ns, hh, mm, ss;\n\n                    int tns, thh, tmm, tss;\n\n                    tns = cur_stream->ic->duration/1000000LL;\n\n                    thh = tns/3600;\n\n                    tmm = (tns%3600)/60;\n\n                    tss = (tns%60);\n\n                    frac = x/cur_stream->width;\n\n                    ns = frac*tns;\n\n                    hh = ns/3600;\n\n                    mm = (ns%3600)/60;\n\n                    ss = (ns%60);\n\n                    fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \\n\", frac*100,\n\n                            hh, mm, ss, thh, tmm, tss);\n\n                    ts = frac*cur_stream->ic->duration;\n\n                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)\n\n                        ts += cur_stream->ic->start_time;\n\n                    stream_seek(cur_stream, ts, 0, 0);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_VIDEORESIZE:\n\n            if (cur_stream) {\n\n                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,\n\n                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);\n\n                screen_width = cur_stream->width = event.resize.w;\n\n                screen_height= cur_stream->height= event.resize.h;\n\n            }\n\n            break;\n\n        case SDL_QUIT:\n\n        case FF_QUIT_EVENT:\n\n            do_exit(cur_stream);\n\n            break;\n\n        case FF_ALLOC_EVENT:\n\n            video_open(event.user.data1);\n\n            alloc_picture(event.user.data1);\n\n            break;\n\n        case FF_REFRESH_EVENT:\n\n            video_refresh(event.user.data1);\n\n            cur_stream->refresh=0;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 10767, "substitutes": {"cur_stream": ["curlywindow", "curptstage", " Curdstream", "cont_stream", "etc_console", "origmmsource", "cur\u064elevel", "curplethread", "srclystage", "curmmruntime", "cont_console", "curdsystem", "cont_Stream", "cur\u05bctime", "form_thread", "curtsource", "curmystream", "cur_list", "curpleconsole", " Cur_stream", " Curdthread", "rev_stream", "origmmuser", "tmpplewindow", "cur_runtime", "cur\u064estream", "cur_state", "newpleclean", "cur_window", "curlysocket", "curptconsole", "curptiterator", "cur_store", " cur_post", "var_stream", "curplerow", "pre_console", "cur_port", "curmypeer", "current_stream", " cur_window", "cont__console", "curlystream", "curitytime", "orig_runtime", "curplesystem", "curitylevel", "ctr_system", "curpleparent", "etc_log", "cur_clean", " cur_loop", "curplesource", "curtruntime", "new_stream", "curmytransform", "curpleport", "new_session", "cur2stage", "curitystream", "pre_stream", "form_stream", "curmmuser", "curpysource", "cur_parent", "cur_node", "cur_wrapper", "currentlymystream", "cur2state", "form_remote", "curopstage", "cur_form", "curopstream", "varplerow", "cur\u05bcstream", "curitylog", "curdbthread", "dev_wrapper", "cur__stream", "cur_console", " Curdsocket", "ctr_console", "curmyStream", "cur_time", "curmmsource", "cur_iterator", "cur_server", "curpythread", "cur_socket", "tmp_status", "curmyconsole", " Cur_thread", "curpleuser", "curntstatus", "src_stage", "curdbsource", "curdbstream", "src_window", "current_store", "cur_source", "dev_transform", "tmpplestatus", " Curdsystem", "currently_system", "cur2store", "curLthread", "rev_console", "var_source", "cur_monitor", " Cur_socket", "cur_user", "curitylist", "curopconsole", "origmmstream", " cur_stage", "curLwindow", "curmlsession", "currently_network", "cur_row", "pre_port", "dev_stream", "curlymonitor", "dev_window", "var_row", "curntserver", "curpysocket", "cur_Stream", "curdthread", "curtsystem", " cur_node", "curpystream", "curplewindow", " cur_form", " cur_time", "curptnode", "cur\u05bcloop", "cur_system", " cur_monitor", "curlyruntime", "tmppleparent", "curdbrow", "cur_level", "srclystream", "curpleruntime", "curLsystem", "curplesession", " cur_system", "cur\u064elist", "curityconsole", "curmypost", "rev_peer", "curLsource", "curtStream", "src_runtime", "tmp_parent", "curdsocket", "curopnode", "cur_status", " cur_source", "curtstream", " cur_transform", "ctr_stream", "curLremote", "curmlconsole", "curdstream", "current_state", "currentlymysystem", "curptstream", "new_console", "cont__Stream", " cur_list", "form_source", "srclywindow", "curtuser", " cur_server", "curmysystem", "currentlymyStream", "cont__stream", "cur_transform", "cur_loop", "currently_stream", "varplesource", "curityloop", "curitythread", "cur_peer", "srclyruntime", "curmmstream", "curlystage", "currentlymynetwork", "curmlclean", "curLstream", "tmp_window", "cur__post", "newplestream", "varplethread", "new_clean", " cur_status", "cur_log", "etc_port", "ctr_port", "cur2stream", "curLmonitor", "pre_draw", "cur_stage", " Cur_system", "orig_stream", "curplestream", "cur_session", "curtnetwork", "origmmruntime", "curntstream", "rev_iterator", "cur__Stream", "cur_draw", "curityport", "currently_Stream", "curpyrow", "cont_post", "newpleconsole", "newplesession", "orig_source", "curmyiterator", "cont__post", " cur_thread", "src_stream", "curpysystem", "orig_user", "cur_post", "cur\u05bcthread", "curmlstream", "var_thread", "curmynetwork", "curpleclean", "cur__console", " cur_console", "etc_stream", "curplestatus", " cur_level", "curptpeer", "tmp_stream", "curntstage", "curlysystem", "curlythread", "cur_network", "cur_remote", "tmpplestream", "cur_thread", "varplestream", "current_stage"], "event": ["self", "ack", "ent", "via", "except", "flag", "mem", "ev", "se", "eng", "request", "commit", "pair", "pack", "handler", "frame", "ind", "function", "object", "command", "vent", "window", "other", "shift", "all", "ex", "exc", "process", "channel", "change", "config", "complete", "index", "ec", "ext", "info", "term", "attribute", "empty", "input", "age", "Event", "q", "task", "argument", "escape", "ce", "cal", "press", "ee", "block", "message", "context", "e", "state", "word", "image", "address", "eor", "msg", "arg", "error", "cmd"], "incr": ["INCrd", " inccr", "explorr", "incsr", "circar", " incrate", "Incer", " incar", "expar", "circrar", "explar", "INCer", " incrc", "collr", "declr", "ecar", "incorr", "incer", "declsr", "Incr", "incar", "incrd", "incrate", "incrar", " incrar", "respra", "resprc", "declrc", "circorr", "respr", "Incrd", " incer", "explrar", "circr", "exprc", "INCrate", "seqcr", "expr", "incrc", "ecrc", "seqra", "INCr", "ecr", " incsr", "collrc", " incorr", "explr", "ecsr", "declar", " incrd", "Incrate", "collra", "expra", "seqr", " incra", "incra", "respar", "seqrc", "inccr", "collcr"], "pos": ["pro", "p", "limit", "pr", "no", "conf", "off", "seq", "xy", "slot", "px", "pre", "pid", "op", "pose", "name", "pt", "ps", "axis", "cond", "trans", "Pos", "start", "position", "val", "buf", "tmp", "seek", "zone", "index", "os", "ref", "lat", "offset", "part", "num", "POS", "len", "port", "loc", "po", "point", "resp", "spec", "con", "pi", "pc", "doc", "col", "rot", "rel"], "frac": ["fps", "cb", "round", "acc", "fun", "err", "format", "cell", "call", "fr", "raw", "rc", "area", "load", "scale", "repeat", "crop", " fraction", "fx", "max", "percent", "callback", "xff", "timer", "clip", "fac", "rel"], "x": ["X", "dx", " cx", "px", "xy", "f", "i", "v", "xt", "z", "xe", "xf", "ct", "xs", "xi", "ex", "d", "y", "tx", "fx", "rx", "m", "t", "xc", "e", "xml", "w"]}}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int sox_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    int ret, size;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n\n\n    size = SOX_SAMPLES*s->streams[0]->codec->block_align;\n\n    ret = av_get_packet(s->pb, pkt, size);\n\n    if (ret < 0)\n\n        return AVERROR(EIO);\n\n\n    pkt->stream_index = 0;\n\n    pkt->size = ret;\n\n\n\n    return 0;\n\n}", "idx": 10772, "substitutes": {"s": ["r", "ts", "p", "h", "conf", "ats", "ses", "events", "v", "ls", "ss", "its", "ps", "gs", "aws", "comm", "sts", "ex", "parts", "n", "sq", "fs", "a", "g", "b", "is", "ins", "ms", "bis", "js", "sys", "stats", "ds", "hs", "c", "S", "t", "vs", "cs", "ims", "bs", "w", "qs", "conv", "ns"], "pkt": ["packet", "spnt", "opacket", "compkg", "Pct", "pnt", "ppkg", "ppkt", "ppqt", "spqt", "Pkg", "pct", " pck", " pnt", "spkt", "compkt", " pconn", "compct", "pconn", "wnt", "hacket", " pct", "wkt", "wconn", "hkt", "wacket", "het", "Pkt", "ppnt", "opck", "pqt", " pqt", "Pnt", "hck", "pck", "Pconn", "compnt", "spkg", "opkt", " pet", "pkg", " pkg", "Packet", " packet", "pet", "opet"], "ret": ["RET", "ft", "fun", "mem", "rev", "v", " Ret", "cont", "xt", "std", "sp", "re", "result", "j", "gt", "Ret", "deg", "uf", "val", "reply", "rem", "out", "nt", "buf", "rets", "ne", "count", "back", "mt", "sec", "bytes", " alt", "def", "tr", "ext", "dim", "desc", "elt", "rt", "ref", "reset", "inter", "txt", "t", "et", "num", "ber", "len", "res", "sum", "resp", "alt", "ord", "ctr", "ptr", "ter", "nz", "arg", "cmd"], "size": ["limit", "send", "news", "sha", "span", "mem", "value", "type", "read", "loss", "number", "z", "format", "speed", "fee", "end", "data", "l", "height", "capacity", "name", "small", "scroll", "summary", "sent", "space", "n", "sq", "nl", "total", "count", "area", "zone", "g", "scale", "Size", "bytes", "si", "dim", "min", "shape", "see", "empty", "sd", "sn", "max", "offset", "ize", "body", "num", "pos", "buffer", "len", "sum", "memory", "SIZE", "se", "length", "storage"]}}
{"project": "FFmpeg", "commit_id": "d094052c8e8a036666ac02bfc52bf221ad39e4c8", "target": 1, "func": "static av_cold int svq1_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVQ1Context * const s = avctx->priv_data;\n\n\n\n    dsputil_init(&s->dsp, avctx);\n\n    avctx->coded_frame= (AVFrame*)&s->picture;\n\n\n\n    s->frame_width = avctx->width;\n\n    s->frame_height = avctx->height;\n\n\n\n    s->y_block_width = (s->frame_width + 15) / 16;\n\n    s->y_block_height = (s->frame_height + 15) / 16;\n\n\n\n    s->c_block_width = (s->frame_width / 4 + 15) / 16;\n\n    s->c_block_height = (s->frame_height / 4 + 15) / 16;\n\n\n\n    s->avctx= avctx;\n\n    s->m.avctx= avctx;\n\n\n    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));\n\n    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));\n\n    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));\n\n    h263_encode_init(&s->m); //mv_penalty\n\n\n\n    return 0;\n\n}", "idx": 10773, "substitutes": {"avctx": ["ajcam", "wavtx", "navhw", "cvctx", "avecfg", "avjac", "AVcontext", "avcmd", "afcfg", "svkt", "avercontext", "Avtx", "avecontext", "ajkl", "ajctx", "ovjp", "navcontext", "afcontext", "AVctl", "ajtx", "svcmp", "wavctx", " avcam", "abctx", "avtx", "cvtx", "apctx", "wavcmd", "abcontext", "averctx", "avcmp", "wavcf", "avercpu", "apcontext", "avcpu", "wavcontext", " avca", "ovcontext", "avecam", "afjac", "AVctx", "afkt", " avcf", " avtx", "avercam", "ajcmd", "ajconn", "avectx", "avconn", "ovhw", "aptx", "wavctl", "afctx", "avjp", "avhw", "avkl", " avkl", "abjp", "Avctx", "svctx", "cvcontext", "ajcpu", "navctx", "svcontext", "avcfg", "ajcontext", "avkt", " avjac", "Avcontext", "aftx", "avctl", "avcontext", "apca", " avctl", "navjp", "averconn", " avcmp", "AVtx", "Avconn", "aveca", "afcam", " avconn", " avkt", "avcf", " avcfg", "ajcf", "avcam", "afcmp", " avcontext", "cvjac", "avca", "avertx", "ovctx", "abhw", "avetx", " avcmd", " avcpu", "avekl"], "s": ["changes", "sb", "ses", "ls", "aws", "comm", "south", "sv", "as", "d", "sam", "sac", "js", "sys", "c", "t", "https", "ags", "ms", "ords", "w", "ids", "rates", "ins", "ns", "less", "h", "ats", "conf", "sw", "ies", "params", "ows", "ers", "settings", "ps", "acs", "ads", "parts", "ess", "sq", "fs", "sl", "sd", "set", "stats", "ds", "comments", "sc", "locks", "vs", "cs", "ims", "gets", "ports", "p", "aunts", "i", "sa", "ar", "its", "l", "sports", "ops", "tests", "is", "g", "eps", "os", "hs", "styles", "ares", "self", "ts", "rs", "v", "args", "ss", "es", "als", "uploads", "gs", "sts", "n", "actions", "views", "details", "states", "m", "S", "bits", "mods", "bs", "qs", "ants"]}}
{"project": "qemu", "commit_id": "d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801, "substitutes": {"ad": ["att", "pod", "ack", "al", "art", "ld", "dev", "wd", "ace", "od", "ab", "conn", "ard", "dd", "addr", "add", "ind", "end", "pad", "Ad", "ade", "cd", "an", "ads", "ada", "aud", "admin", "rad", "a", "post", "md", "ax", "quad", "d", "arp", "ay", "adj", "adv", "inter", "adr", "ann", "adi", "ud", "play", "aq", "AD", "ord", "and", "ag", "mod", "ac"], "sglist": [" sgnist", "sgellist", "sblist", "sblists", "sgliste", " sgnists", "sgnists", "sgnist", "sgelists", " sgniste", "sgnlist", "sgeliste", "sbllist", "sglists", " sgliste", " sglists", " sgnlist", "sbliste", "sgllist", "sgniste", " sgllist", "sgelist"], "offset": ["skip", "off", "slot", "from", "amount", "addr", "sp", "location", "entry", "pad", "padding", "start", "upper", "position", "shift", "slice", "range", "origin", "o", "size", "count", "seek", "pointer", "bound", "index", "offs", "to", "set", "reset", "Offset", "pos", "top", "buffer", "len", "mask", "base", "point", "row", "loc", "ta", "ptr", " offsets", "address", "length", "error"], "cmd": ["news", "send", "cli", "conf", "conn", "cf", "cat", "cont", "op", "cur", "cfg", "auth", "command", "ct", "cd", "call", "good", "comm", "cc", "cor", "help", "config", "nt", "cp", "ctl", "md", "Cmd", "mk", "def", "cmp", "ctx", "ctrl", "c", "req", "check", "cod", "pkg", "ctr", "col", "msg"], "prdt": ["prmt", "partry", "pardt", "prtc", "Prcat", "sprtt", "pritc", "prdat", "Prmt", "sprcat", "Prdm", "sprdt", "sprmt", "prtf", "prtt", " prtt", "Prtt", " prcat", "PrDT", "prcat", "partf", "prtry", "pritry", " prtry", "prDT", " prdm", "pritf", "sprdm", "prdm", " prtc", "partc", "sprdat", " prmt", " prdat", "sprDT", " prDT", "Prdt", "pridt", "Prdat", " prtf"], "i": ["r", "di", "p", "ui", "ami", "cli", "x", "ims", "yi", "f", "v", "gi", "ri", "id", "ai", " ii", "ind", "l", "ei", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "multi", "u", "bi", "n", "me", "o", "in", "iter", "a", "ie", "hi", "si", "index", "li", "info", "y", "ini", "fi", "it", "m", "ci", "c", "t", "ip", "mi", "zi", "qi", "port", "ti", "im", "pi", "e", "ki", "k", "ms", "item"], "tbl_entry_size": ["tbl_entry_length", "tbl_Entry_size", "tbl_entry_Size", "tbl_Entry_length", "tbl_Entry_index", "tbl_Entry_len", "tbl_entry_len", "tbl_entry_index", "tbl_Entry_Size"], "bus": ["bid", "pod", "dev", "proc", "bind", "cat", "boot", "interface", "proxy", "lock", "cc", "device", "bug", "host", "config", "buf", "loop", "b", "serv", "handle", "os", "board", "mount", "driver", "bridge", "kind", "box", "gate", "Bus", "chain", "pos", "alias", "port", "book", "base", "BUS", "way", "vc", "state", "us", "bs"], "qbus": ["qBUS", "dqbal", "dqBUS", "iqbus", "iqBus", "iqBUS", "qBus", " qbal", "qbal", " qBus", " qBUS", "dqBus", "dqbus", "iqbal"], "tbl": ["itbl", "lbl", "Tbt", "Tpl", "tBL", "itrie", "ktpl", "lpl", " trie", "lrie", "Tbl", "tbt", "ktbl", " tpl", "trie", " tbt", "itBL", "itpl", "lBL", "ktbt", " tBL", "tpl"]}}
{"project": "FFmpeg", "commit_id": "9b6aafba6c06ef62783dd5e9c5ed668f3a095128", "target": 1, "func": "static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n\n                                                uint8_t *dest_y,\n\n                                                uint8_t *dest_cb,\n\n                                                uint8_t *dest_cr,\n\n                                                int field_based,\n\n                                                int bottom_field,\n\n                                                int field_select,\n\n                                                uint8_t **ref_picture,\n\n                                                h264_chroma_mc_func *pix_op,\n\n                                                int motion_x, int motion_y,\n\n                                                int h, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,\n\n        uvsx, uvsy;\n\n    const int lowres     = s->avctx->lowres;\n\n    const int op_index   = FFMIN(lowres, 2);\n\n    const int block_s    = 8>>lowres;\n\n    const int s_mask     = (2 << lowres) - 1;\n\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n\n    if (s->quarter_sample) {\n\n        motion_x /= 2;\n\n        motion_y /= 2;\n\n    }\n\n\n\n    if (field_based) {\n\n        motion_y += (bottom_field - field_select) * (1 << lowres - 1);\n\n    }\n\n\n\n    sx = motion_x & s_mask;\n\n    sy = motion_y & s_mask;\n\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n\n        uvsrc_x = src_x >> 1;\n\n        uvsrc_y = src_y >> 1;\n\n    } else if (s->out_format == FMT_H261) {\n\n        // even chroma mv's are full pel in H261\n\n        mx      = motion_x / 4;\n\n        my      = motion_y / 4;\n\n        uvsx    = (2 * mx) & s_mask;\n\n        uvsy    = (2 * my) & s_mask;\n\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n\n    } else {\n\n        mx      = motion_x / 2;\n\n        my      = motion_y / 2;\n\n        uvsx    = mx & s_mask;\n\n        uvsy    = my & s_mask;\n\n        uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n\n        uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if ((unsigned) src_x >  h_edge_pos - (!!sx) - 2 * block_s ||\n\n        (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) {\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n\n                                s->linesize, 17, 17 + field_based,\n\n                                src_x, src_y << field_based, h_edge_pos,\n\n                                v_edge_pos);\n\n        ptr_y = s->edge_emu_buffer;\n\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n\n            s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            ptr_cb = uvbuf;\n\n            ptr_cr = uvbuf + 16;\n\n        }\n\n    }\n\n\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data\n\n    if (bottom_field) {\n\n        dest_y  += s->linesize;\n\n        dest_cb += s->uvlinesize;\n\n        dest_cr += s->uvlinesize;\n\n    }\n\n\n\n    if (field_select) {\n\n        ptr_y   += s->linesize;\n\n        ptr_cb  += s->uvlinesize;\n\n        ptr_cr  += s->uvlinesize;\n\n    }\n\n\n\n    sx = (sx << 2) >> lowres;\n\n    sy = (sy << 2) >> lowres;\n\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n        uvsx = (uvsx << 2) >> lowres;\n\n        uvsy = (uvsy << 2) >> lowres;\n\n        pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n        pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n    }\n\n    // FIXME h261 lowres loop filter\n\n}\n", "idx": 10836, "substitutes": {"s": ["ts", "p", "less", "changes", "fps", "sb", "conf", "aunts", "sw", "ats", "ses", "rs", "se", "i", "v", "ls", "qs", "ss", "es", "its", "stat", "csv", "ps", "gs", "aws", "an", "comm", "sts", "ex", "space", "n", "sq", "sv", "a", "g", "b", "as", "details", "ins", "os", "times", "set", "scl", "js", "sys", "ctx", "stats", "ds", "hs", "m", "c", "S", "webkit", "t", "sc", "spec", "cs", "e", "ims", "ms", "w", "sports", "ns"], "dest_y": ["dest__gy", " dest_x", "destamex", "dest_cy", "destamey", " dest_gy", "dest__cy", "destamecy", "dest__x", "dest_x", "destamegy", "dest__y", "dest_gy", " dest_cy"], "dest_cb": ["src_ctrl", "dest_rb", "src_rb", "dest_ctrl", "dest_cm", "src_cb", "src_cm"], "dest_cr": ["dest__ctr", "dest2cd", "dest__cr", "src_cd", "src_cr", "dest_cd", "dest2cr", "dest2cb", "src_ctr", "src_cb", "dest_ctr", "dest2ctr", "dest__cd", "dest__cb"], "field_based": ["Field_based", "field2bal", "FIELD_hidden", "fieldvalbased", "fielderselect", "fieldityselect", "field_Based", "Field_base", "field2based", " field_Based", "field_base", "Field_Based", "field___base", " field_faced", "fieldityfaced", "fieldlybased", "field2base", "fieldlybase", "fieldvalbacked", "field_required", "fieldlyBased", "FIELD_required", "field___handled", "fieldvalhidden", "fieldlybal", "Field_bal", "fieldvalbase", "FIELD_Based", "field___Based", "field_backed", "FIELD_base", "field_hidden", "FIELD_backed", "FIELD_handled", "field_faced", "field_led", "fielderbased", "fieldvalrequired", "field___based", "field_handled", "fielditybased", "FIELD_based", "fielderBased", "fielderfaced", "fieldityBased", "fieldvalled", "field2Based", "FIELD_led", "field_bal"], "bottom_field": ["bottom_length", "body_fields", "bottom_f", "body_length", "bottom_fields", "body_field", "base_f", "bodylylength", "base_field", "bodylygravity", "bottom_gravity", "bottomlygravity", "bottom___key", "bodylyfields", "bottom___f", "bottom___field", "bottomlyfield", "bottomlyfields", "bodylyfield", "base_key", "bottom_key", "bottomlylength", "body_gravity"], "field_select": [" field_lect", "fieldNameedit", "fieldNameselected", "field_selection", " field_sel", "field_edit", "field08lect", " field_edit", "field_lect", "field08select", "field08selection", " field_selected", "field_selected", "fieldNameselect", " field_selection", "field08selected", "fieldNamesel", "field_sel"], "ref_picture": ["refjimage", "ref2image", "ref2picture", " ref_pic", "ref__picture", " ref_memory", "refjpic", " ref__image", "ref__pic", "refjmemory", "ref__memory", "ref__image", " ref_image", "ref_image", "ref_pic", "ref2pic", "ref_memory", " ref__pic", "refjpicture", "ref2memory", " ref__memory", " ref__picture"], "pix_op": ["pixels2info", "pixels2pos", "pixels2op", "pixels_info", "pixels2oper", "pix_info", "pixchoper", "pix2oper", "pixels_pos", "pix2pos", "pix2info", "pix2op", "pixels_oper", "pixchinfo", "pixchop", "pix_oper", "pixchpos", "pixels_op", "pix_pos"], "motion_x": ["move_ex", "fire08px", "motion_yx", " motion_ox", " motion__ix", "motion00rx", " motion__xi", "memoryuremix", "motion08x", "motion_ax", "fire08x", "move_on", "motion______x", "motion_xi", "fire_xd", "motion__xi", "memory_mix", "motion_on", "memoryurex", "fire_px", "motionuremix", "motion______ax", "fire08xd", "move_y", "motion_ox", "memoryureax", "motionurex", "motion_____mix", "motion_ix", "motion_____x", "motion_xd", "motion_mix", "fire_x", "motion_ex", "motion__ix", "move_x", "motion00ix", "motion08px", "motion_____ax", " motion__y", "motion_rx", "motion00ox", " motion_ix", "motion______mix", "memory_x", "motion__y", " motion_xi", "motion_____yx", "motion__x", "memory_yx", " motion_rx", "motion00x", "motionureyx", "motion08xd", " motion__x", "memoryureyx", "motionureax", "motion_px", "motion______yx", "memory_ax"], "motion_y": ["motion_ch", "motion_ym", "mission67ry", "motion___yy", "motion_yy", "motion_yl", "motion_____ry", "mission_ey", " motion_b", "mission67iy", "mission_____Y", "motion_____Y", "mission67y", "motion08x", "error08x", "motion___yt", "error_yl", "error08ym", "motion_ey", "error_x", "movie_y", "motion_d", "motion___iy", "mission_ch", "motion67d", "error_y", "error08yl", "error08y", "mission_d", "mission_y", "mission_ry", "motion_____y", "mission_b", " motion_ym", "movie_yy", "mission_iy", "motion_yt", "mission67d", "mission_____ry", "motion08yl", " motion_yy", "motion08ym", "motion_Y", "mission_____ch", "motion67ry", "motion_iy", "motion08y", "motion_ry", "motion67iy", "mission_____y", "movie_iy", "motion___y", "movie_yt", "error_ym", "mission_Y", "motion67y", "motion_b", "motion_____ch"], "h": ["p", "x", "f", "i", "v", "ih", "z", "l", "height", "n", "H", "b", "d", "ch", "ha", "y", "hh", "q", "hs", "it", "m", "c", "t", "e", "k", "hw", "w"], "mb_y": ["embixys", "db_cy", "mb08z", "mb_b", "mb08b", "db08z", "embixy", "embixsy", "mbixy", "mb_cy", "mb_sy", "mboxsy", "mb08y", "mbgys", "mb_ny", "mbixys", "mboxb", "db_b", "mbgny", "mbgsy", "mboxys", "db08b", "emb_sy", "mb_ys", "mb08cy", "mbixsy", "db_z", "db08cy", "mboxcy", "mboxz", "embixny", "emb_ys", "mb_z", "mbgy", "mboxy", "mboxny", "emb_ny", "db08y", "db_y", "emb_y", "mbixny"], "ptr_y": ["ptr_cy", "ptr___gy", "tmp_cy", "ptr_gy", "ptr___yi", "tmp_gy", "ptr______cy", "ptr______y", "tmp_yi", "ptr___cy", "ptr_yi", "ptr______gy", "ptr______yi", "ptr___y", "tmp_y"], "ptr_cb": ["ptr___cb", "ptrtcb", "ptrtwb", "ref_cb", "ptr___rb", "ptr___ca", "ref_wb", "ptr_rb", "ptr_wb", "ptrtca", "ref_rb", "ptrtrb", "ptr___wb", "ptr_ca", "ref_ca"], "ptr_cr": ["ptr55dr", "ptrTdr", "ptrTcr", "ptr55ctr", "ref_crop", "ptr55cr", "ptr_crop", "ref_ctr", "ptrTcrop", "ref_dr", "ptr_dr", "ref_cr", "ptr_ctr", "ptr55crop", "ptrTctr"], "mx": ["mm", "ma", "xy", "zx", "px", "xx", "xe", "mph", "xs", "xi", "mo", "ey", "ml", "ex", "xp", "wx", "mk", "fx", "mr", "ux", "lex", "rx", "yx", "mi", "xc", "ms", "nz", "mn"], "my": ["ny", "mm", "py", "fy", "ky", "ma", "ery", "xy", "gy", "xx", "sky", "ty", "sym", "md", "yy", "mk", "mn", "ry", "ym", "phy", "mic", "yx", "cy", "mi", "mid", "ms", "mis"], "src_x": ["rc_y", "source_x", "src__x", "src_ex", "src__wx", "rc_ex", "source_wx", "source_ex", "src__ex", "rc_z", "source_y", "src_z", "src__y", "src_wx", "rc_X", "src_X", "rc_x"], "src_y": [" src_yy", "src_yy", "src_py", "src_ny", "dest_Y", "src_h", " src_ny", "src_Y", " src_py", "dest_h", "dest_x"], "uvsrc_x": ["uvsource_xy", "uvsource_y", "uvsource_x", "uvsrc_ex", "uvst_x", "uvst_ex", "uvst_rx", "uvsrc_rx", "uvsrc_xy"], "uvsrc_y": ["uvsecure_ys", "uvsecure_x", "uvsecure_b", "uvsecure_y", "uvsrc_ys", "uvsrc_b"], "uvlinesize": ["uxtimesize", "uvlinesource", "uvlineize", "uvlimitsizer", "uulinsize", "uvlinsource", "uvlimitsiz", "uvpagesiz", "uvlinesiz", "uvpagesen", "uvlinesization", "uvtimesization", "uxlinesiz", "uvtimesize", "uulinsource", "uxtimesization", "uvlineization", "uxtimesiz", "uxtimesizer", "uulinesize", "uvlinsen", "uvpagesize", "uvlineizer", "uvlinsize", "uvinesiz", "uulinesen", "uulinesource", "uulinsen", "uvlineiz", "uvlimitsize", "uvinesize", "uvlimitsization", "uvlinsiz", "uvinesource", "uvinesen", "uvlinesizer", "uxlinesization", "uvpagesource", "uxlinesize", "uvtimesizer", "uvlinesen", "uulinsiz", "uxlinesizer", "uulinesiz", "uvtimesiz"], "linesize": ["netsization", "lineszie", "losized", "inesizer", "inesize", "losiz", "linsiz", "boardsize", " linesiz", "boardssize", "dosize", "boardsization", "storesization", " lineszie", "netsized", "linesizer", "daysized", "inesIZE", "linesIZE", "linsize", "inesiz", "dosized", "dayssize", "linesization", "daysize", "storesize", "daysization", "linsIZE", "storesizer", "linszie", "dosization", "losize", "linessize", "netsize", "inessize", "losization", "dossize", "inesized", "linesized", "storessize", "inesization", "ineszie", "linesiz", "boardsizer", " linesIZE", "netsiz"], "sx": ["rsy", "lswx", "ssz", " sxi", "lsxc", "ssxx", "swx", "lsrx", "insz", "insxi", "sxx", "lsfx", "ssfx", "ssxc", "insy", "lsxx", "tsx", "ssrx", "sfx", "lsx", "sswx", "sxi", " sz", "ssx", "rsz", "sxc", "lsz", "srx", "rsx", "tsxc", "sz", "tsxx", "insx", "tsz", "rsxi"], "sy": ["ny", "SY", "py", "fy", "ky", "ery", "uy", "sty", "sa", "dy", "ss", "syn", "sky", "ys", "ty", "ey", "tsy", "sq", "ony", "sm", "south", "sv", "she", "sym", "si", "yy", "icy", "pse", "y", "ay", "ry", "sys", "ly", "sid", "phy", "cy", "mi", "san", "gy", "Sy"], "uvsx": ["uidsx", " uvsock", "uhsx", "ufsock", "uversx", "uvsim", " uvsw", "uhsock", "uversock", "umsix", " uvsix", " uvsim", "uvsX", "uidsX", " uversw", "umsx", " ucsx", "ucsim", "ufsx", " ucsix", "ufsize", "uversize", "uvsock", " uvsize", " uversx", " uversock", "umsim", " uversize", "uidsix", "uhsw", "ucsx", "uhsize", "uvsize", " ucsim", "uvsw", " ucsX", "umsX", "ufsw", "ucsix", "ucsX", "uvsix", " uvsX", "uversw", "uidsim"], "uvsy": ["ucsym", "UVsm", "uvsm", "uvser", "uvsym", "uumsy", "uumcy", "UVcy", "uvcy", "ucsm", "uefy", "uumser", "ucfy", "uesy", "uusym", "uuser", "uusm", "UVser", "uumsm", "UVsy", "uucy", "uvfy", "uesm", "ucsy", "uufy", "uesym", "uusy"]}}
{"project": "FFmpeg", "commit_id": "1178868683d25c0f358b0364eb55f69b563b24f3", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf      = avpkt->data;\n\n    unsigned int   buf_size = avpkt->size;\n\n    const uint8_t *buf_end  = buf + buf_size;\n\n\n\n    const AVPixFmtDescriptor *desc;\n\n    EXRContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr;\n\n\n\n    int i, x, y, stride, magic_number, version, flags, ret;\n\n    int w = 0;\n\n    int h = 0;\n\n    unsigned int xmin   = ~0;\n\n    unsigned int xmax   = ~0;\n\n    unsigned int ymin   = ~0;\n\n    unsigned int ymax   = ~0;\n\n    unsigned int xdelta = ~0;\n\n\n\n    int out_line_size;\n\n    int bxmin, axmax;\n\n    int scan_lines_per_block;\n\n    unsigned long scan_line_size;\n\n    unsigned long uncompressed_size;\n\n\n\n    unsigned int current_channel_offset = 0;\n\n\n\n    s->channel_offsets[0] = -1;\n\n    s->channel_offsets[1] = -1;\n\n    s->channel_offsets[2] = -1;\n\n    s->channel_offsets[3] = -1;\n\n    s->bits_per_color_id = -1;\n\n    s->compr = -1;\n\n\n\n    if (buf_size < 10) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_number = bytestream_get_le32(&buf);\n\n    if (magic_number != 20000630) { // As per documentation of OpenEXR it's supposed to be int 20000630 little-endian\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    version = bytestream_get_byte(&buf);\n\n    if (version != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version %d\\n\", version);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    flags = bytestream_get_le24(&buf);\n\n    if (flags & 0x2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    // Parse the header\n\n    while (buf < buf_end && buf[0]) {\n\n        unsigned int variable_buffer_data_size;\n\n        // Process the channel list\n\n        if (check_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) >= 0) {\n\n            const uint8_t *channel_list_end;\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            channel_list_end = buf + variable_buffer_data_size;\n\n            while (channel_list_end - buf >= 19) {\n\n                int current_bits_per_color_id = -1;\n\n                int channel_index = -1;\n\n\n\n                if (!strcmp(buf, \"R\"))\n\n                    channel_index = 0;\n\n                else if (!strcmp(buf, \"G\"))\n\n                    channel_index = 1;\n\n                else if (!strcmp(buf, \"B\"))\n\n                    channel_index = 2;\n\n                else if (!strcmp(buf, \"A\"))\n\n                    channel_index = 3;\n\n                else\n\n                    av_log(avctx, AV_LOG_WARNING, \"Unsupported channel %.256s\\n\", buf);\n\n\n\n                while (bytestream_get_byte(&buf) && buf < channel_list_end)\n\n                    continue; /* skip */\n\n\n\n                if (channel_list_end - * &buf < 4) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                current_bits_per_color_id = bytestream_get_le32(&buf);\n\n                if (current_bits_per_color_id > 2) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (channel_index >= 0) {\n\n                    if (s->bits_per_color_id != -1 && s->bits_per_color_id != current_bits_per_color_id) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    s->bits_per_color_id  = current_bits_per_color_id;\n\n                    s->channel_offsets[channel_index] = current_channel_offset;\n\n                }\n\n\n\n                current_channel_offset += 1 << current_bits_per_color_id;\n\n                buf += 12;\n\n            }\n\n\n\n            /* Check if all channels are set with an offset or if the channels\n\n             * are causing an overflow  */\n\n\n\n            if (FFMIN3(s->channel_offsets[0],\n\n                       s->channel_offsets[1],\n\n                       s->channel_offsets[2]) < 0) {\n\n                if (s->channel_offsets[0] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing red channel\\n\");\n\n                if (s->channel_offsets[1] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing green channel\\n\");\n\n                if (s->channel_offsets[2] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing blue channel\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            buf = channel_list_end;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            xmin = AV_RL32(buf);\n\n            ymin = AV_RL32(buf + 4);\n\n            xmax = AV_RL32(buf + 8);\n\n            ymax = AV_RL32(buf + 12);\n\n            xdelta = (xmax-xmin) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            w = AV_RL32(buf + 8) + 1;\n\n            h = AV_RL32(buf + 12) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (*buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"pixelAspectRatio\", \"float\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255);\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (s->compr == -1)\n\n                s->compr = *buf;\n\n            else\n\n                av_log(avctx, AV_LOG_WARNING, \"Found more than one compression attribute\\n\");\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        }\n\n\n\n        // Check if there is enough bytes for a header\n\n        if (buf_end - buf <= 9) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        // Process unknown variables\n\n        for (i = 0; i < 2; i++) {\n\n            // Skip variable name/type\n\n            while (++buf < buf_end)\n\n                if (buf[0] == 0x0)\n\n                    break;\n\n        }\n\n        buf++;\n\n        // Skip variable length\n\n        if (buf_end - buf >= 5) {\n\n            variable_buffer_data_size = get_header_variable_length(&buf, buf_end);\n\n            if (!variable_buffer_data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            buf += variable_buffer_data_size;\n\n        }\n\n    }\n\n\n\n    if (s->compr == -1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing compression attribute\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (buf >= buf_end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    buf++;\n\n\n\n    switch (s->bits_per_color_id) {\n\n    case 2: // 32-bit\n\n    case 1: // 16-bit\n\n        if (s->channel_offsets[3] >= 0)\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB48;\n\n        break;\n\n    // 8-bit\n\n    case 0:\n\n        av_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);\n\n        return AVERROR_PATCHWELCOME;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (s->compr) {\n\n    case EXR_RAW:\n\n    case EXR_RLE:\n\n    case EXR_ZIP1:\n\n        scan_lines_per_block = 1;\n\n        break;\n\n    case EXR_ZIP16:\n\n        scan_lines_per_block = 16;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Compression type %d is not supported\\n\", s->compr);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        ff_thread_release_buffer(avctx, &s->picture);\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // Verify the xmin, xmax, ymin, ymax and xdelta before setting the actual image size\n\n    if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (w != avctx->width || h != avctx->height) {\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    }\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    bxmin = xmin * 2 * desc->nb_components;\n\n    axmax = (avctx->width - (xmax + 1)) * 2 * desc->nb_components;\n\n    out_line_size = avctx->width * 2 * desc->nb_components;\n\n    scan_line_size = xdelta * current_channel_offset;\n\n    uncompressed_size = scan_line_size * scan_lines_per_block;\n\n\n\n    if (s->compr != EXR_RAW) {\n\n        av_fast_padded_malloc(&s->uncompressed_data, &s->uncompressed_size, uncompressed_size);\n\n        av_fast_padded_malloc(&s->tmp, &s->tmp_size, uncompressed_size);\n\n        if (!s->uncompressed_data || !s->tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if ((ret = ff_thread_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    // Zero out the start if ymin is not 0\n\n    for (y = 0; y < ymin; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    // Process the actual scan line blocks\n\n    for (y = ymin; y <= ymax; y += scan_lines_per_block) {\n\n        uint16_t *ptr_x = (uint16_t *)ptr;\n\n        if (buf_end - buf > 8) {\n\n            /* Read the lineoffset from the line offset table and add 8 bytes\n\n               to skip the coordinates and data size fields */\n\n            const uint64_t line_offset = bytestream_get_le64(&buf) + 8;\n\n            int32_t data_size;\n\n\n\n            // Check if the buffer has the required bytes needed from the offset\n\n            if ((line_offset > buf_size) ||\n\n                (s->compr == EXR_RAW && line_offset > avpkt->size - xdelta * current_channel_offset) ||\n\n                (s->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32(avpkt->data + line_offset - 4)))) {\n\n                // Line offset is probably wrong and not inside the buffer\n\n                av_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    ptr_x = (uint16_t *)ptr;\n\n                    memset(ptr_x, 0, out_line_size);\n\n                }\n\n            } else {\n\n                const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0;\n\n\n\n                if (scan_lines_per_block > 1)\n\n                    uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1);\n\n                if ((s->compr == EXR_ZIP1 || s->compr == EXR_ZIP16) && data_size < uncompressed_size) {\n\n                    unsigned long dest_len = uncompressed_size;\n\n\n\n                    if (uncompress(s->tmp, &dest_len, avpkt->data + line_offset, data_size) != Z_OK ||\n\n                        dest_len != uncompressed_size) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during zlib decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                } else if (s->compr == EXR_RLE && data_size < uncompressed_size) {\n\n                    if (rle_uncompress(avpkt->data + line_offset, data_size, s->tmp, uncompressed_size)) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during rle decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                }\n\n\n\n                if (s->compr != EXR_RAW && data_size < uncompressed_size) {\n\n                    predictor(s->tmp, uncompressed_size);\n\n                    reorder_pixels(s->tmp, s->uncompressed_data, uncompressed_size);\n\n\n\n                    red_channel_buffer   = s->uncompressed_data + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = s->uncompressed_data + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[3];\n\n                } else {\n\n                    red_channel_buffer   = avpkt->data + line_offset + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = avpkt->data + line_offset + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[3];\n\n                }\n\n\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    const uint8_t *r, *g, *b, *a;\n\n\n\n                    r = red_channel_buffer;\n\n                    g = green_channel_buffer;\n\n                    b = blue_channel_buffer;\n\n                    if (alpha_channel_buffer)\n\n                        a = alpha_channel_buffer;\n\n\n\n                    ptr_x = (uint16_t *)ptr;\n\n\n\n                    // Zero out the start if xmin is not 0\n\n                    memset(ptr_x, 0, bxmin);\n\n                    ptr_x += xmin * desc->nb_components;\n\n                    if (s->bits_per_color_id == 2) {\n\n                        // 32-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n\n                        }\n\n                    } else {\n\n                        // 16-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n\n                        }\n\n                    }\n\n\n\n                    // Zero out the end if xmax+1 is not w\n\n                    memset(ptr_x, 0, axmax);\n\n\n\n                    red_channel_buffer   += scan_line_size;\n\n                    green_channel_buffer += scan_line_size;\n\n                    blue_channel_buffer  += scan_line_size;\n\n                    if (alpha_channel_buffer)\n\n                        alpha_channel_buffer += scan_line_size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    // Zero out the end if ymax+1 is not h\n\n    for (y = ymax + 1; y < avctx->height; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 10842, "substitutes": {"avctx": ["ajjp", "vrctl", "avconfig", "avetmp", "vercontext", "avcu", "avercu", "afgc", "awcu", "averctl", "ajgc", "aversetup", "avtx", "avergc", "awsetup", "afctx", "avjac", "averjac", "avjp", "verctx", "avcp", "afrx", "afsetup", "afconfig", "avercmp", "AVcontext", " avcp", "vrcontext", "awrx", "avcmp", "averctx", "ajctl", "averrx", "vrcp", "awctx", "avecontext", "averjp", "verctl", "afcmp", "afjp", " avcontext", "avertx", "averconfig", "ajctx", "avgc", "AVtmp", "avejac", "avsetup", "vrctx", "awcmp", "awconfig", "AVctx", "afctl", "avrx", "avesetup", " avtx", "avetx", "avctl", "ajsetup", "aftx", " avtmp", "avtmp", "avcontext", "awjac", " avctl", "avectx", "avecu", "ajconfig", "AVtx", "ajtx", "vercp"], "data": ["DATA", "value", "bin", "next", "json", "read", "ata", "frame", "reader", "name", "pad", "padding", "Data", "map", "window", "family", "raw", "record", "out", "size", "area", "pointer", "join", "d", "video", "file", "bytes", "form", "dat", "def", "to", "package", "empty", "input", "offset", "text", "t", "buffer", "current", "block", "batch", "audio", "table", "action", "message", "stream", "image", "length"], "got_frame": ["got___channel", "got___state", "received_offset", "gotgrframe", "got_state", "got_channel", "got___frame", "got___offset", "got_offset", "received_frame", "gotgroffset", "received_state", "gotgrchannel", "gotgrstate", "received_channel"], "avpkt": ["avjpst", "avcpmt", "avwpct", "avepkt", "avppmt", "afpacket", "AVpst", "avpux", "avppacket", "avpbkt", "avewpkt", "afpux", "avcpkt", "avwpcs", "avcpst", "AVpmt", "avdpkg", "avpbcs", "AVcpmt", "avPcs", "avcpacket", "avepct", "avpbnt", "avPkt", "avewpcs", "avwpkt", "avppst", "afpkt", "avdpux", "avcpkg", "avjpmt", "AVcpacket", "avdpkt", "AVpkt", "avdpacket", "avewpct", "avjpkt", "afcpkg", "avcpux", "afpkg", "avepnt", "avpct", "avjpacket", "avpacket", "avwpkg", "avwpacket", "avewpnt", "afcpux", "avwpnt", "avpcs", "avpbct", "avPnt", "avpnt", "AVcpst", "avepcs", "avpkg", "avpmt", "avppkt", "avwpux", "AVpacket", "afcpacket", "AVcpkt", "afcpkt", "avpst", "avPct"], "buf": ["limit", "cb", "h", "off", "seq", "proc", "mem", "next", "cap", "err", "v", "Buffer", "alloc", "cur", "cam", "pack", "emb", "bp", "bc", "pad", "uf", "map", "window", "comm", "bl", "bag", "cv", "img", "count", "bar", "pool", "buff", "bytes", "queue", "ref", "max", "ctx", "vec", "br", "box", "txt", "t", "pos", "buffer", "len", "batch", "block", "loc", "rb", "pkg", "xff", "doc", "ctr", "length", "msg", "cmd"], "buf_end": ["buf_ends", "buf_start", "buffer_start", "buffer_end", "buffer_offset", "buf_offset", "buffer_ends"], "desc": ["dc", "dist", "dev", "Desc", "attr", "esc", "cam", "rec", "crit", "rc", "des", "comp", "enc", "dir", "ec", "def", "tx", "cmp", "asc", "sc", "res", "description", "doc", "col", "sub", "conv", "cmd"], "s": ["ts", "changes", "h", "sb", "ats", "sw", "rs", "se", "sa", "v", "ls", "sp", "ss", "its", "settings", "es", "ps", "j", "gs", "comm", "ops", "sts", "summary", "space", "n", "sq", "fs", "sv", "service", "as", "d", "is", "details", "st", "ins", "ms", "os", "tx", "set", "sys", "js", "stats", "ds", "styles", "S", "c", "t", "utils", "status", "source", "spec", "results", "services", "vs", "cs", "bs", "w", "storage", "qs", "ns"], "picture": ["camera", "pic", "password", "feature", "document", "pid", "frame", "pict", "format", "stat", "media", "command", "query", "family", "share", "program", "policy", "piece", "photo", "file", "video", "Picture", "pa", "path", "info", "fp", "fi", "pen", "profile", "buffer", "status", "point", "description", "message", "context", "friendly", "image", "screen", "img", "icon"], "p": ["pic", "np", "lp", "f", "pp", "v", "sp", "pb", "op", "ps", "j", "cp", "P", "pa", "par", "m", "c", "mp", "t", "ip", "per", "ap", "pkg", "pc", "jp"], "ptr": ["pr", "pointers", "dr", "np", "rev", "attr", "err", "addr", "alloc", "cont", "sp", "cur", "pad", "rect", "rc", "seek", "pointer", "conv", "tr", "arr", "ref", "ctx", "br", "buffer", "sc", "pc", "ctr", "rel"], "i": ["f", "v", "id", "l", "ii", "j", "xi", "I", "ix", "bi", "o", "si", "index", "it", "ci", "m", "c", "ip", "ij", "base", "pi", "e", "k"], "x": ["X", "dx", "xy", "px", "axis", "xs", "ox", "xi", "ix", "key", "ex", "xp", "time", "index", "path", "tx", "lat", "rx", "m", "pos", "xc", "col", "w"], "y": ["h", "yn", "xy", "type", "dy", "height", "ys", "ey", "ty", "key", "iy", "n", "my", "yy", "ch", "axy", "Y", "yt", "ym", "m", "t", "yl", "sy", "ye"], "stride": ["slides", "slue", "tride", "spride", "strue", "true", "sprides", "strope", "strides", "slide", "trope", "trides", "sprope", "slope", "sprue"], "magic_number": ["mag_sequence", "magic_block", "magicicalnumber", "magicetyblock", "magic\u05bcnotation", " magic_code", "magic_operator", "magicicaloperator", "magic_sequence", "mag_notation", " magic_notation", " magic_name", "magicetysequence", " magic_operator", "magic_no", "magic7no", "magicicalumber", "magic_umber", "magic_code", " magic_umber", "magic7operator", "magic_notation", "magicetynumber", "magic\u05bcno", "magic_byte", "magicetynotation", "mag_block", "mag_number", "magic_name", "magicicalno", " magic_no", " magic_byte", "magic7number", "magic7umber", "magic\u05bcnumber", "magic\u05bcbyte"], "version": ["usage", "VER", "Version", "feature", "value", "vector", "sector", "type", "iso", "vision", "v", "tag", "major", "python", "number", "format", "connection", "serial", "vers", "name", "ver", "code", "release", "vert", "position", "family", "depth", "program", "order", "direction", "size", "server", "latest", "fish", "index", "scale", "ison", "VERSION", "package", "section", "browser", "hash", "sequence", "driver", "supported", "about", "power", "wire", "part", "status", "quality", "option", "description", "mode", "product", "magic", "class", "length", "versions", "conv"], "flags": ["options", "bugs", "reports", "codes", "flag", "types", "notes", "doms", "events", "levels", "phones", "pins", "args", "frames", "settings", "ps", "heads", "tags", "terms", "properties", "errors", "abilities", "FLAG", "fs", "actions", "Flags", "posts", "details", "finals", "missions", "ints", "stats", "grades", "styles", "states", "limits", "fields", "weights", "bits", "comments", "features", "mask", "faces", "locks", "members", "ags", "wcs", "magic", "versions", "rates"], "ret": ["RET", "mem", "rev", "result", "Ret", "deg", "val", "out", "rel", "details", "match", "ext", "ref", "reset", "txt", "num", "buffer", "len", "res", "status", "resp", "alt", "jp"], "out_line_size": ["out_line_length", "out_line_number", "out_pixel_size", "out_pixel_Size", "out_line_Size", "out_pixel_number", "out_pixel_length"], "bxmin": ["bdxstart", "bwreq", "cbxreq", "bxstart", "bexmod", "bexreq", "bwstart", "cbwmod", "cbxmod", "cbwmin", "bdxmod", "bdxmin", "bdxreq", "bwmin", "bwmod", "bxreq", "cbxmin", "bexstart", "cbwstart", "cbwreq", "bexmin", "cbxstart", "bxmod"], "axmax": ["dxmin", "dxgt", "axMax", "xMax", "xgt", "axgt", "oxmax", "axmin", "xmax", "xmin", "dxMax", "oxMax", "oxgt", "dxmax", "oxmin"], "scan_lines_per_block": ["scan_lines_PER_pixel", "scan_lines_per_line", "scan_lines_per_pixel", "scan_lines_PER_type", "scan_lines_per_type", "scan_lines_PER_block", "scan_lines_PER_line"], "scan_line_size": ["scan_line_number", "scan_block_SIZE", "scan_line_length", "scan_block_size", "scan_block_length", "scan_line_SIZE", "scan_block_number"], "uncompressed_size": ["uncompression_data", "uncompressededsize", "uncompressed_data", "uncompression_SIZE", "uncompressededdata", "uncompressededmessage", "uncompression_size", "uncompression_message", "uncompressededSIZE", "uncompressed_SIZE", "uncompressed_message"]}}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n", "idx": 10847, "substitutes": {"s": ["ts", "less", "ports", "sync", "changes", "sb", "ats", "ses", "ies", "rs", "events", "se", "ls", "ss", "its", "ers", "es", "als", "ps", "gs", "acs", "aws", "comm", "ops", "ads", "sts", "tests", "parts", "space", "sq", "store", "sv", "fs", "sl", "is", "as", "b", "details", "bs", "reads", "ins", "sac", "os", "pers", "y", "eps", "bis", "set", "js", "stats", "ds", "hs", "S", "spec", "locks", "vs", "cs", "ims", "ms", "gets", "qs", "ns"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 10849, "substitutes": {"src": ["sb", "rs", "sur", "sel", "ser", "usr", "our", "supp", "rc", "sr", "in", "sq", "rl", "secure", "sl", "load", "inst", "scan", "sec", "st", "s", "ur", "ch", "impl", "iv", "files", "input", "gb", "sn", "sys", "check", "usc", "sc", "source", "dest", "ipl", "stream", "sub", "screen", "img"], "dst": ["dbl", "daST", "darc", "bdnd", " dST", "ddest", " drc", "disdest", "dast", "Dbl", "Dst", "dnd", "DST", " dnd", "dabl", "disnd", "bdst", "bddest", "Drc", "dST", "disst", " dbl", " ddest", "drc", "bdST", "disST"], "src_size": ["src_Size", "sb_shape", "src_offset", "sb_dimension", "src_dimension", "src_ize", "sb_size", "src__ize", " src_ize", "src__Size", " src_Size", "sb_offset", "src__size", "src_shape"], "i": ["ui", "di", "p", "cli", "x", "uri", "json", "gi", "ri", "ic", "ai", "id", " ii", "ind", "name", "ei", "l", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "ik", "ex", "multi", "bi", "n", "a", "is", "print", "si", "index", "li", " bi", "y", "ini", "info", "\u0438", "it", "ci", "m", "qi", "ip", "mi", "zi", " j", "ij", "status", "ti", "batch", "im", "asi", "pi", "series", "used", "e", "ki", "me", "jp", "us"], "b": ["p", "cb", "h", "bf", "sb", "be", "bin", "f", "v", "nb", "ob", "bc", "l", "j", "bb", "fb", "u", "bi", "n", "a", "bound", "d", "B", "back", "gb", "bis", "br", "m", "wb", "c", "body", "t", "db", "rb", "base", "ba", "bg", "e", "bo", "bs", "w", "by"], "g": ["p", "green", "gh", "ga", "f", "gi", "mg", "gd", "pg", "G", "l", "gre", "group", "gs", "gt", "j", "eg", "gp", "u", "rg", "d", "gm", "gray", "gb", "go", "gr", "gu", "fg", "reg", "tg", "ger", "m", "c", "gam", "ge", "bg", "gc", "ig", "e", "gg", "gen"], "r": ["p", "cr", "pr", "dr", "rs", "attr", "f", "ar", "err", "ri", "vr", "re", "l", "R", "usr", "fr", "rate", "rect", "rc", "rm", "sr", "range", "u", "rg", "n", "out", "rl", "d", "ur", "rat", "ro", "term", "rt", "gr", "mr", "rar", "reg", "br", "m", "c", "t", "res", "rb", "e", "w", "rd", "rel"], "rgb": ["ggt", "srgd", "mrii", "recgg", "ggd", "mrgd", " drgb", " Rbb", "regb", " Rhtml", "rcg", "mrgb", " rgd", " rGB", "srgt", " rgc", "rgg", "recGB", "regg", "rgt", "recimg", "srgc", "rii", "urgb", "mrval", "srii", "rg", "rcgg", "reimg", "rimg", "urGB", "ggc", " rval", "rcgb", "urimg", "rgc", "reg", " rg", " Rgb", " rbb", "srval", "urgg", "srgb", "rbb", "rgd", " rimg", "rGB", "recgb", " rii", "rhtml", " rhtml", " drhtml", " drbb", "rval", "ggb", " rgg", "rcimg", " rgt"]}}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n", "idx": 10857, "substitutes": {"netdev": [" netver", " netdriver", "netDev", "navdevice", "Netdriver", "NETdriver", "natdevice", "netDEV", "navDEV", "etdevice", "natdev", "networkDev", "NETDEV", " netdevice", "webdriver", "webdev", " netDev", "etcam", "NETdev", "NetDev", "etdev", "networkdriver", "webdevice", "NETdevice", "networkdev", "Netdev", "webDEV", "natver", "netcam", " netcam", "etver", "natcam", "netver", "navdriver", "netdevice", "navdev", "netdriver"], "name": ["p", "news", "common", "no", "mem", "comment", "type", "cap", "id", "NAME", "title", "ident", "str", "named", "family", "key", "admin", "n", "in", "nm", "prefix", "net", "file", "names", "path", "one", "info", "term", "user", "local", "quick", "package", "ame", "Name", "nam", "part", "ip", "base", "normal", "pkg", "word", "me", "error", "cmd"], "peer": ["pod", "p", "pro", "instance", "public", "proc", "enter", "private", "member", "pe", "shared", "ker", "parent", "worker", "component", "channel", "owner", "established", "pool", "server", "remote", "er", "cer", "soc", " Peer", "package", "local", "node", "ctx", "ssl", "target", "chain", "buffer", "per", "inner", "pkg", "context", "pc", "ptr", "socket", "scope"], "errp": [" erps", " errpp", "rrP", "errps", "err", "errr", " errP", " errr", "traceP", "rrr", "erpp", "tracepp", "Erp", "rrps", "tracer", "rrp", "rrpg", "errpg", " erpress", " errpg", "errpe", " errps", "errpa", "erp", " errpa", "rrpress", "Erpe", "errorp", "errorr", "errorpa", "errP", "erP", "erpa", "tracep", "rrpe", " errpe", "errorP", "Err", "errpp", "errpress", " erp", " erpg", " errpress", "ErP"], "queues": ["queasks", "boumers", "qUES", "quesines", "queines", "ques", " queued", "quvers", "Queuers", "quesubes", "Queums", "queubes", "QueUES", "quasks", " queries", " Queuers", "quubes", "flues", "quue", "quuers", "quesumers", "quries", "boues", "quesvers", "Queues", "queUES", "quumers", "quesUES", "Queures", "boue", "quesasks", "quesries", "quesuers", "queums", " queines", " queubes", "queued", "Queue", "bovers", "que", "queue", " queue", "quesums", "quued", "quesued", " queures", "quesue", "queries", "quines", " queumers", "qums", "flries", "quevers", " Queures", "flasks", " queuers", " Queue", "fluers", "queures", "quues", "queuers", "quesues", "queumers", " Queues"], "vhost_user_opts": ["vhost_user_pcs", "vhost_user_opcs", "vhost_user_OPps", "vhost_user_opms", "vhost_user_opTS", "vhost_user_OPs", "vhost_user_props", "vhost_user_ps", "vhost_user_prs", "vhost_user_OPcs", "vhost_user_topt", "vhost_user_topms", "vhost_user_optters", "vhost_user_opt", "vhost_user_pops", "vhost_user_popTS", "vhost_user_tops", "vhost_user_optt", "vhost_user_procs", "vhost_user_sett", "vhost_user_opps", "vhost_user_pros", "vhost_user_setms", "vhost_user_OPters", "vhost_user_popps", "vhost_user_prots", "vhost_user_OPTS", "vhost_user_prors", "vhost_user_sets", "vhost_user_proTS", "vhost_user_ops", "vhost_user_setps", "vhost_user_optps", "vhost_user_optts", "vhost_user_oprs", "vhost_user_opters", "vhost_user_OPt", "vhost_user_topts", "vhost_user_popts", "vhost_user_setts", "vhost_user_OPrs", "vhost_user_proters", "vhost_user_OPms", "vhost_user_OPts", "vhost_user_pts"], "chr": ["chrg", "ichp", "shc", " chmr", "Chrs", "chrs", " chrb", "Chrb", "chsr", "chrb", " chrg", "chmr", " chsr", "ichr", "ichrs", "ichrg", "ichc", "thr", "ichmr", "thrd", "ichrb", " chc", " chrs", "Chp", "shr", " chp", "cherb", "chc", "chers", " chrd", "Chr", "shrg", "shmr", "thrs", "chrd", "chp", "Chsr", "cherd", "cher", "thrb", "ichsr"]}}
{"project": "FFmpeg", "commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "target": 1, "func": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10868, "substitutes": {"gb": ["GB", "cb", "bf", "sb", "gh", "gif", "git", "nb", "ng", "cfg", "gd", "pg", "vg", "gs", "gt", "eg", "bb", "arb", "eb", "vm", "google", "fb", "rg", "buff", "bt", "g", "Gb", "mb", "gm", "kb", "fg", "gu", "ctx", "tg", "vd", "db", "yg", "rb", "bg", "gc", "gg"], "value": ["self", "report", "p", "x", "feature", "unit", "vector", "type", "v", "commit", "number", "data", "format", "version", "function", "widget", "result", "code", "VALUE", "position", "content", "process", "Value", "buf", "total", "property", "b", "values", "index", "field", "package", "bit", "input", "attribute", "variable", "trace", "sequence", "VAL", "byte", "weight", "wire", "buffer", "block", "memory", "action", "description", "message", "valid", "state", "image", "w"], "series": ["options", "codes", "images", "windows", "ses", "pins", "species", "frames", " Series", "ties", "IES", "axis", "terms", "slice", "parts", "config", "seconds", "blocks", "si", "bytes", "values", "times", "sys", "sequence", "ints", "stats", "Series", "states", "sis", "chain", "nos", "spec", "chains", "steps", "prime", "sers", "strings", "groups", "ms", "eries"], "i": ["ui", "di", "p", "x", "h", "spin", "uri", "f", "v", "gi", "id", "ai", "ic", "z", "ind", "l", "ii", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "multi", "bi", "n", "me", "o", "b", "is", "hi", "si", "index", "info", "li", "y", "bit", "ini", "it", "\u0438", "ci", "m", "io", "t", "ip", "mi", "ij", "zi", "status", "batch", "ti", "point", "im", "pi", "e", "ims", "ms", "by", "us"], "val": ["p", "al", "dev", "x", "pr", "vals", "pl", "Val", "bin", "v", "ret", "vol", "test", "bal", "z", "data", "als", "pt", "l", "ul", "bl", " bit", "obj", "vt", "b", " vec", " v", "mint", "lit", "var", "rol", "bit", "tx", "eval", "elt", "ref", "arr", "reg", "ctx", "it", "V", "vec", "cal", "VAL", "text", "t", "num", "res", " valid", "base", "valid", "bs", " Val", "rel"], "bits": ["ts", "units", "changes", "codes", "vals", "ats", "ots", "dates", "outs", "points", "pins", "frames", "its", "als", "length", "jobs", "obs", "rows", "ps", "heads", "xs", "gs", "tags", "ops", "terms", "parts", "nets", "checks", "flags", "blocks", "bles", "bytes", "values", "s", "ions", "os", "bit", "bis", "js", "ints", "stats", "keys", "ns", "rots", "limits", "states", "weights", "ips", "pos", "status", "bps", "items", "nos", "vs", "orts", "ims", "bs", "words", "gets", "ids", "ins"]}}
{"project": "FFmpeg", "commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "target": 1, "func": "static void check_add_res(HEVCDSPContext h, int bit_depth)\n\n{\n\n    int i;\n\n    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);\n\n    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);\n\n\n\n    for (i = 2; i <= 5; i++) {\n\n        int block_size = 1 << i;\n\n        int size = block_size * block_size;\n\n        ptrdiff_t stride = block_size << (bit_depth > 8);\n\n        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);\n\n\n\n        randomize_buffers(res0, size);\n\n        randomize_buffers2(dst0, size);\n\n        memcpy(res1, res0, sizeof(*res0) * size);\n\n        memcpy(dst1, dst0, size);\n\n\n\n        if (check_func(h.add_residual[i - 2], \"add_res_%dx%d_%d\", block_size, block_size, bit_depth)) {\n\n            call_ref(dst0, res0, stride);\n\n            call_new(dst1, res1, stride);\n\n            if (memcmp(dst0, dst1, size))\n\n                fail();\n\n            bench_new(dst1, res1, stride);\n\n        }\n\n    }\n\n}\n", "idx": 10869, "substitutes": {"h": ["p", "hp", "f", "ih", "v", "k", "sh", "hm", "rh", "l", "help", "n", "H", "bh", "b", "oh", "ht", "he", "ch", "ph", "handle", "ah", "dh", "kh", "hl", "hh", "q", "uh", "ctx", "m", "c", "here", "t", "host", "hw"], "bit_depth": [" bit2Depth", " bit_store", "bit_deep", "bit_device", "bit32value", "batch_device", "bit2Depth", " bit2deep", "bit32device", "bitlydeep", "bit_Depth", "batch_value", "bit_value", "bitlydepth", "bitlymode", "bit32complex", " bit_mode", "bit_store", " bit_Depth", "bit2deep", "bit32depth", "bit_mode", "bitlystore", "bit_complex", " bit2depth", "batch_depth", " bit_deep", "bit2depth", "batch_complex"], "i": ["ui", "di", "p", "x", "init", "uri", "f", "v", "k", "ic", "ai", "id", "ri", " ii", "iq", "ind", "ei", "ii", "l", "j", "xi", "sim", "I", "phi", "ix", "iu", "oi", "multi", "bi", " I", "n", "in", "a", "is", "b", "d", "print", "si", "index", "li", " bi", "y", "ini", "fi", "it", "ci", "m", "qi", "ip", "mi", "t", " j", "zi", "ti", "im", "pi", "me", "by"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n", "idx": 10875, "substitutes": {"data": ["done", "step", "p", "DATA", "mem", "unit", "next", "json", "accept", "ata", "format", "reader", "result", "Data", "map", "window", "error", "raw", "device", "initial", "da", "join", "d", "form", "dat", "def", "to", "info", "empty", "input", "bus", "t", "rew", "res", "batch", "table", "context", "mu", "spec", "rel"], "unused": ["unuse", " unchecked", "unalinitialized", "UNinitialized", "unaluse", " uninitialized", "UNchecked", " unuse", "UNuse", "unalused", "UNused", "uninitialized", "unalchecked", "unchecked"], "tmp": ["p", "snap", "np", "mem", "xy", "attr", "err", "perm", "nb", "sp", "tm", "tt", "old", "cv", "buf", "nt", "temp", "obj", "src", "vt", "emp", "buff", "mut", "mb", "sam", "mk", "etc", "mint", "var", "arr", "rt", "Temp", "ctx", "uv", "m", "mp", "txt", "t", "MP", "rb", "rw", "nv", "pkg", "aux", "vp", "ptr", "imm", "img"], "errp": ["ererr", "rrpy", "errpo", "lrp", "rrpo", "err", "errr", "ererP", " errr", " errP", "ferpc", "errpt", "attrpo", " errpre", "rrp", "errpy", "ferp", "errpc", " errpt", "rrpa", "erpre", "errpa", "erp", "lrpy", " errpy", "ererpre", "ferpa", "rrpt", "errP", "erP", "attrp", "ererp", "attrpa", "rrpc", "ferpo", "attrpc", "errpre", "lrpt"], "v": ["p", "av", "h", "x", "ev", "i", "f", "vy", "vr", "l", "ver", "j", "vert", "vm", "u", "cv", "sv", "vt", "vv", "g", "b", "tv", "iv", "y", "q", "vi", "it", "V", "uv", "m", "c", "t", "nv", "vs", "vc", "vp", "w", "vis", "conv"]}}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n", "idx": 10877, "substitutes": {"env": ["extra", "ev", "err", "ender", "end", "nc", "en", "worker", "qt", "exc", "buf", "vv", "er", "menu", "def", "manager", "outer", "pkg", "timer", "door", "vp", "cmd", "ent", "conf", "enter", "esc", "shell", "ew", "ve", "obj", "config", "vt", "enc", "app", "expr", "ah", "desc", "equ", "req", "et", "block", "vs", "ack", "conn", "exec", "cur", "environment", "entry", "era", "tk", "window", "server", "viron", "ctx", "ten", "here", "nv", "e", "erd", "engine", "dev", "die", "proc", "eng", "v", "policy", "cv", "chart", "ec", "EN", "uv", "console", "eh", "Environment", "po", "context", "En", "response"], "new_cr4": ["new__rc_", "new_crfour", "new_tr4", "new_ctr2", "new_r4", "new_cd04", "new_Cr04", "new__crfour", "new__rc4", "new_rfour", "new_r2", "new_cd44", "new_cr3", "new_cm2", "new_rc44", "new_rcfour", "new_rc04", "new_cm04", "new__rc2", "new_pr8", "new__cr2", "new__cr4", "new_cr2", "new_pr2", "new__cr_", "new_rc3", "new_rc2", "new_ctr4", "new_sr8", "new_Cr3", "new_Cr2", "new_pr04", "new_cr04", "new_cr_", "new_Cr44", "new_r_", "new_cdfour", "new_tr2", "new_sr2", "new_Cr4", "new_cmfour", "new_sr4", "new_cr8", "new_cm8", "new_ctrfour", "new_tr04", "new_cm4", "new_sr04", "new_rc_", "new__rcfour", "new_pr4", "new_cm_", "new_ctr3", "new_Crfour", "new_cr44", "new_rc4", "new_cd4"]}}
{"project": "qemu", "commit_id": "ffad4116b96e29e0fbe892806f97c0a6c903d30d", "target": 0, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 10899, "substitutes": {"arg": ["ack", "ma", "mem", "agent", "tag", "job", "ar", "args", "op", "emb", "pg", "cell", "call", "cand", "admin", "config", "ark", "md", "ax", "g", "event", "ac", "parse", "param", "arp", "ay", "ref", "og", "mer", "reg", "argument", "Arg", "cal", "mark", "ad", "ang", "loc", "ig", "doc", "ag", "cmd"], "snapshot": ["apvol", "Snapshot", "sysaction", "snapvol", "sysshot", "apshot", "Snapvol", "apshots", "Snapaction", "sysshots", "sysvol", "Snapshots", "snapshots", "apaction", "snapaction"], "opaque": ["OPatile", "opatile", "operient", "oppient", "opient", "ipque", "ipacity", "operacity", "pient", "oppaque", "oatile", "OPacity", "ipaque", "oppacity", "operaques", "opque", "ipatile", "oacity", "oque", "oaque", "OPaque", "opaques", "operaque", "oppaques", "paques", "opacity", "OPque", "paque", "pacity"], "buf": ["np", "bin", "err", "data", "cfg", "rc", "cp", "buff", "history", "def", "var", "arr", "ref", "Buff", "text", "batch", "rb", "pkg", "Buffer", "cmd", "attr", "map", "code", "obj", "src", "bt", "act", "path", "desc", "bus", "txt", "buffer", "block", "orig", "msg", "p", "init", "seq", "cap", "cur", "uf", "window", "array", "tmp", "iter", "b", "bytes", "tr", "ctx", "br", "prop", "rw", "doc", "ctr", "conv", "r", "cb", "proc", "read", "args", "alloc", "pg", "bc", "filename", "cv", "pool", "dir", "queue", "box", "base", "ba", "img"], "file": ["limit", "File", "unit", "f", "link", "fat", "vol", "number", "stat", "connection", "name", "filename", "page", "code", "family", "position", "device", "channel", "array", "line", "resource", "dir", "path", "board", "files", "queue", "bus", "header", "disk", "io", "body", "ile", "chain", "buffer", "volume", "block", "db", "base", "table", "port", "le"], "devname": ["busbase", " devnames", "privpath", "Devname", "deviceName", "volname", "evname", "privname", "propstr", "deviceword", "divaddr", "volgroup", "diskaddr", "busword", "diskName", "privgroup", "privName", "volName", "devicedef", "volbase", "evgroup", "evName", "deviceaddr", "devgroup", "devName", "divtype", "devnames", "proptype", "propName", "devword", "evstr", "volword", "diskname", "propname", "volpath", "busName", "DevName", "divname", "devbase", "devstr", "divdef", "divName", "Devnames", "devtype", "diskdef", "devicebase", "devicenames", "divstr", "evpath", "devpath", "busname", "evtype", "devaddr", "devdef", " devName", "devicename"], "serial": ["util", "controller", "proc", "comment", "Serial", "iso", "sector", "vol", "ser", "number", "speed", "version", "ident", "ion", "security", "device", "label", "unknown", "bus", "driver", "phone", "num", "port", "loc", "description", "mode", "error"], "mediastr": ["mediastructure", "mediastrip", "mediaserructure", "mediestructure", "medastr", "medustrip", "medastar", "mediestrip", "mediustructure", "medastructure", "mediestar", "medustr", "mediaserrip", "mediustar", "mediustr", "medastrip", "mediestr", "medustructure", "mediaserar", "mediustrip", "medustar", "mediastar", "mediaserr"], "type": ["language", "list", "instance", "where", "types", "ype", "rule", "test", "typ", "id", "op", "role", "format", "pe", "title", "command", "interface", "ver", "family", "position", "ty", "parent", "all", "policy", "like", "create", "rel", "change", "time", "event", "relation", " TYPE", " family", "TYPE", "copy", "Type", "category", "view", "style", "kind", "t", "top", "ping", "message", "state", "class"], "media": ["camera", "util", "language", "pic", "library", "metadata", "communication", "version", "reader", "command", "meta", "interface", "picture", "medi", "content", "movie", "device", "policy", "medium", "gallery", "area", "history", "relation", "category", "browser", "Media", "bridge", "style", "module", "io", "volume", "memory", "option", "message", "mode", "production", "material", "magic", "image", "storage"], "bus_id": ["block_kid", " bus2id", "buszid", "block_ident", " bus_pid", "buszkid", "bus2pid", "buszident", "buszId", "bus_kid", " bus_ids", "bus_ident", "bus_ids", "box_ID", "block_id", " bus2pid", "bus_ID", "box_id", "box_name", "bus2ids", "bus_Id", "box_it", "busgID", " bus_ref", "bus_pid", " bus2ID", "bus_ref", " bus2ids", "busgid", " bus_ID", "block_Id", "bus2ID", "bus_it", "busgname", "bus2id", "busgit", "bus_name", " bus_ident"], "unit_id": [" unit_ID", "unit_ID", "unit_ids", "bus_ID", "unit2id", "unit2type", "unit_type", " unit_type", " unit_ident", "unit2ID", " unit_ids", "unit2status", "bus_name", "unit_status", " unit_status", "unit_name", "unit_ident"], "cyls": ["styols", " cyrs", "cyjs", "lyjs", "styjs", "cyrs", "tyls", "tyl", "tyles", " cyl", "syles", "syl", "tyrs", "syjs", "syols", "cyols", "cyl", "syrs", " cyles", "syls", "styles", "styls", "cyles", "lyols", "lyles", "lyls"], "heads": ["bots", "sets", "aunts", "outs", "workers", "head", "pages", "rows", "uploads", "cks", "uns", "headed", "ads", "loads", "sticks", "links", "maps", "docs", "hours", "blocks", "views", "offs", "reads", "tails", "headers", "helps", "HEAD", "relations", " Heads", "masters", "limits", "tops", "ashes", "hops", "locks", "mins", "roots", "aches"], "secs": ["sects", "divs", "seccs", "sqns", "divss", " seccs", "secS", "divns", "sqss", "Seccs", "Secs", "Secls", "secss", "sectS", "secns", " secns", "SecS", "divls", " secss", " secS", "sectcs", "sqls", "secls", " secls", "sqs", "sectls"], "translation": ["options", "language", "usage", "util", "lation", "lations", "comment", "communication", "settings", "rating", "version", "location", "lang", "trans", "padding", "command", "ion", "using", "family", "versions", "direction", "generation", "creation", "history", "transform", "relation", "Translation", "tr", "binding", "late", "heading", "utils", "alias", "source", "normal", "description", "message", "selection", "operation", "conv"], "bdrv": ["bderV", "bldvs", "bsrm", "bderm", "bsrV", "bdrV", " bdervs", "bsrv", "bderv", " bdrvs", " bderm", "bdrm", " bderv", "bldv", "bsrvs", " bdrV", " bdrm", "bldV", " bderV", "bdrvs", "bldm", "bdervs"], "drv": ["derp", " drp", "derm", "srm", "dervs", " drm", "drvs", "derv", "drp", "srp", "srv", " drvs", "srvs", "drm"], "machine": ["mobi", "engine", "instance", "link", "handler", "model", "connection", "network", "command", "meta", "interface", "vm", "parent", "device", "policy", "owner", "host", "achine", "domain", " machines", "Machine", "variable", "module", "mc", "m", "manager", "target", "volume", "chain", "disk", "mob", "memory", "mode", "template", "mobile", "magic", "state", "image", "storage"], "max_devs": ["max_pts", "max_Devts", "max_devds", "max_evS", "max_ptds", "max_vols", "max_devS", "max_devions", "max_Devds", "max_ptts", "max_volions", "max_defs", "max_devts", "max_defions", "max_volms", "max_DevS", "max_evs", "max_defS", "max_devms", "max_Devms", "max_evions", "max_volS", "max_Devs", "max_evds", "max_evms", "max_evts"], "index": ["x", "instance", "comment", "i", "link", "id", "connection", "ind", "version", "connect", "location", "speed", "axis", "interface", "access", "page", "code", "position", "lock", "Index", "key", "order", "count", "size", "loop", "info", "offset", "pos", "num", "status", "stable", "loc", "action", "context", "level", "address", "error"], "cache": ["cycle", "ache", "limit", "sync", "dc", "session", "co", "cover", "timeout", "comment", "acc", "master", "ached", "capacity", "map", "code", "lock", "cu", "cc", "debug", "rc", "config", "count", "scan", "scale", "Cache", "cmp", "hash", "force", "max", "toc", "module", "c", "check", "volume", "comments", "con", "oc", "option", "gc", "aches", "ac"], "bdrv_flags": ["bdrve_stats", "bdrv__flags", "bdrv_stats", "bdrv_flag", "bdrv__flag", "bdrve_flag", "bdrve_flags", "bdrve_limits", "bdrv__limits", "bdrv_limits", "bdrv__stats"], "onerror": ["rerROR", "asterrr", "ierrr", "ierror", "onerrored", "asterrored", "onerrr", "rerrr", "rerror", "ierrored", "onerROR", "asterROR", "asterror", "ierROR", "rerrored"], "drives_table_idx": ["drives_table_Idnum", "drives_table_idxs", "drives_table_idindex", "drives_table_Idx", "drives_table_Idindex", "drives_table_indx", "drives_table_indindex", "drives_table_Idxs", "drives_table_indnum", "drives_table_indxs", "drives_table_idnum"], "str": ["r", "p", "bool", "list", "dr", "proc", "rs", "attr", "err", "ar", "cont", "vol", "exec", "sp", "data", "format", "cfg", "name", "priv", "ps", "trans", "fr", "usr", "def", "STR", "raw", "key", "out", "obj", "String", "enc", "er", "inst", "expr", "par", "st", "Str", "tr", "parse", "var", "try", "ext", "arr", "desc", "cmp", "br", "text", "txt", "chain", "buffer", "status", "res", "nick", "doc", "ctr", "ptr", "spec", "orig", "msg", "conv"], "params": ["options", "p", "units", "changes", "list", "vals", "conf", "types", "proc", "attr", "json", "pins", "args", "data", "settings", "cfg", "name", "ps", "tags", "ops", "AMS", "ams", "config", "flags", "errors", "tmp", "actions", "values", "par", "s", "names", "param", "headers", "files", "cmp", "keys", "pos", "comments", "strings", "spec", "conv"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n", "idx": 10914, "substitutes": {"fd": ["bf", "df", "f", " df", "ff", "dd", "pid", "du", "id", "fc", "fee", "lf", "ln", "fed", "fr", "dl", "hd", "fb", " fid", "dos", "fa", "da", "fs", "td", "dir", "d", "file", " fut", "FD", "sd", "fe", "ffff", "fp", "fi", "ds", "fin", "disk", " f", "pos", "ud", "port", "socket", " fin", "stream", "rd"], "err": ["r", "aer", "or", "aaa", "die", "cr", "Er", "ev", "rs", "attr", "coord", "rr", "ar", "der", "norm", "fee", "ef", "ox", "cand", "usr", "fr", "ez", "Error", "ex", "exc", "rc", "buf", "obj", " terr", "er", "ner", "eas", "elt", "mr", "kr", "rn", "ocr", "resp", "e", "erd", "eor", "msg", "error"], "opaque": ["popaques", "oplasus", "opliera", "ipacity", "oiera", "ipaques", "opsasus", "ipaque", "opasus", "opque", "ipvious", "opsaque", "popvious", "opvious", "oque", "opiera", "oaque", "opsque", "popaque", "opaques", "oplaques", "oplque", "oplacity", "oasus", "opsiera", "oplaque", "oplvious", "opacity", "popacity"], "s": ["ts", "less", "h", "sb", "sw", "rs", "se", "v", "ls", "ss", "settings", "als", "es", "z", "l", "ps", "gs", "j", "an", "comm", "sts", "iss", "mos", "ess", "sq", "n", " ss", "store", "sv", "a", "sl", "is", "b", "g", "details", "sam", "y", "set", "bis", "sys", "js", "stats", "ds", "ssl", "hs", "m", "S", "sis", "spec", "cs", "bs", "qs", "ns"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *pict, int *got_packet)\n\n{\n\n    LJpegEncContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    const int width  = avctx->width;\n\n    const int height = avctx->height;\n\n    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];\n\n    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];\n\n    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;\n\n    int ret, header_bits;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        max_pkt_size += width * height * 3 * 3;\n\n    else {\n\n        max_pkt_size += mb_width * mb_height * 3 * 4\n\n                        * s->hsample[0] * s->vsample[0];\n\n    }\n\n    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", max_pkt_size);\n\n        return ret;\n\n    }\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n\n\n    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,\n\n                                   s->matrix);\n\n\n\n    header_bits = put_bits_count(&pb);\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        ret = ljpeg_encode_bgr(avctx, &pb, pict);\n\n    else\n\n        ret = ljpeg_encode_yuv(avctx, &pb, pict);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(&pb, header_bits);\n\n\n\n    flush_put_bits(&pb);\n\n    pkt->size   = put_bits_ptr(&pb) - pb.buf;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10950, "substitutes": {"avctx": ["avconfig", "wavtx", "wavconfig", "devjac", "avecfg", "avjac", "AVcontext", "avcc", "averpkg", "avcmd", "avercc", "avercontext", "savconn", "avct", "avecontext", "ajcmp", "aveaddr", "ajctx", "savctx", "afpkg", "wavcc", " avct", "navcontext", "afcontext", " avtmp", "ajtx", "wavctx", "afcmd", "avercu", " avcam", "avercfg", "avtx", "apctx", "ravctx", "avecmp", "wavcmp", " avcc", "averctx", "avcmp", "apcontext", "wavcontext", "devclient", "AVpkg", "avecam", "avcheck", "savct", "afjac", "aveclient", "AVctx", " avtx", "avpkg", "ravcc", "avaddr", "avectx", "devctx", "avconn", "navcu", "vactx", "jamtx", "ajjac", "avercheck", "averjac", "afctx", "avercmp", "ajclient", "avecheck", "ravcam", "navctx", "averconfig", "averaddr", "jamcontext", "vacfg", "avejac", "avcfg", "apconn", "avercmd", "avclient", "aftx", "navtmp", "avcontext", "avecc", "aveconfig", "AVtx", "avcu", " avconn", "avertmp", " avcu", "devcmp", "avcam", "jamctx", "jamcu", "vacheck", " avcontext", "wavpkg", "avertx", "savcontext", "ajpkg", "ravcontext", "avetx", " avcmd", "apct", "avtmp", "avecu", "vaaddr", " avpkg"], "pkt": ["packet", "wkl", "cpct", "spact", "lpacket", "pact", "aptx", "spacket", "apkt", "wppt", "ptx", "Pet", "wpkt", "wett", "cpacket", " pett", "Pct", "pnt", " pdu", "pdu", "pekt", "lpet", "ppt", "wpett", "pct", "wpacket", "Pact", " pnt", " pkl", "pett", "wpdu", "spkt", "wpt", "wnt", "petx", " pct", "cpkt", "wkt", "apacket", " ptx", "wacket", "Pkt", "wdu", "spet", "peacket", "wpnt", "Pnt", "lpnt", "cpet", " ppt", "lpkt", " pet", "pent", "Packet", " pact", " packet", "pet", "wpkl", "apnt", "pkl"], "pict": ["camera", "p", "pas", "pic", "conf", "pres", " tum", " picture", "fat", "gif", "cont", "sci", "pain", "stat", "cam", "eric", " img", "pt", "Pic", "picture", "capt", "rect", "pub", "pai", "feat", "Picture", "png", "ht", "act", "def", "isch", "phys", "mot", "fx", "ctx", "fi", "phy", "txt", " pic", "fig", "kt", "hot", " feat", "Pict", "img", " crap"], "got_packet": ["got_packacket", "got_packset", "got_buck_", "got_pack_", "got_packets", "got_packsacket", "got_buckacket", "got_bucket", "got_packsets", "got_bucketime", "got_preset", "got_presetime", "got_pres_", "got_buckets", "got_presets", "got_packetime", "got_pick_", "got_presacket", "got_packsetime"], "s": ["r", "ts", "p", "less", "changes", "h", "sb", "ats", "aunts", "sw", "conf", "ses", "rs", "v", "ls", "sh", "sp", "ss", "its", "es", "stat", "l", "ps", "gs", "j", "aws", "sports", "an", "comm", "sts", "ex", "ess", "sq", "sv", "fs", "sl", "g", "a", "d", "serv", "details", "bs", "has", "ins", "os", "sam", "y", "sd", "bis", "scl", "js", "sys", "ctx", "stats", "ds", "hs", "styles", "m", "S", "c", "t", "sc", "ares", "cs", "ims", "spec", "qs", "ants", "ns"], "pb": ["sb", "py", "np", "pac", " proto", "pack", "cam", "erb", "eb", " np", "tap", "pub", " PB", "buf", "cp", "buff", "pa", "sys", "orp", "batch", "kw", "db", "rb", "pkg", "vp", "jp", "ab", "pt", "ps", "apy", "bot", " buf", "bh", "tg", "wb", "bolt", "peer", "p", "pic", "wp", "lp", "sp", "bp", "bj", "tk", "uf", "rob", "pak", "patch", "tmp", "b", " mp", "BP", "ctx", "prop", "stab", "pc", "lb", "pod", "func", "pas", "cb", "pl", "proc", "px", "tp", "emb", "pg", "dp", "cv", "PB", "pool", "td", "tab", "gb", "mp", "resp", "ping", "bs"], "ret": ["flag", "gt", "Ret", "rm", "ern", "vet", "print", "def", "arr", "ref", "tf", "reg", "t", "len", "ll", "class", "ter", "cmd", "mel", "mem", "value", "cont", "desc", "rt", "hash", "ry", "it", "status", "res", "Return", "pret", "fun", " Ret", "result", "deg", " RET", "rem", "out", "nt", "mt", "try", "tr", "elt", "prop", "gc", "arg", "r", "att", "pas", "RET", "ft", "rev", "success", "jump", "plain", "re", "usr", "val", "rets", "back", "ext", "lit", "reset", "fin", "ber", "cert", "det", "resp", "alt"], "header_bits": ["header_properties", "header_flags", " header_its", " header_bugs", " header_bytes", " header_bit", "header_bit", "header_bugs", " header_properties", "header_details", " header_details", "header_bytes", "header_its", " header_flags"]}}
{"project": "FFmpeg", "commit_id": "27bcf55f459e038e81f09c17e72e6d44898b9015", "target": 1, "func": "int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterLink *outlink = buffer_filter->outputs[0];\n\n    int ret;\n\n\n\n    if (c->picref) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n\n        AVFilterContext *scale = buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n        char scale_param[1024];\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO,\n\n               \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,\n\n               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);\n\n\n\n        if (!scale || strcmp(scale->filter->name, \"scale\")) {\n\n            AVFilter *f = avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n\n                return ret;\n\n\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n\n            scale->filter->init(scale, scale_param, NULL);\n\n        }\n\n\n\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n\n\n\n        link = scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    c->picref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n\n                                          picref->video->w, picref->video->h);\n\n    av_image_copy(c->picref->data, c->picref->linesize,\n\n                  picref->data, picref->linesize,\n\n                  picref->format, picref->video->w, picref->video->h);\n\n    avfilter_copy_buffer_ref_props(c->picref, picref);\n\n\n\n    return 0;\n\n}\n", "idx": 10962, "substitutes": {"buffer_filter": ["buffer_stream", "package_container", "bufferityfilter", "bufferptresult", "bufferptlist", "button_filter", "bufferptcontainer", "buffer___filter", "buffer_load", "buffergactivate", " buffer__stream", " buffer__format", "scalegerror", "bufferityformat", "buffer__find", "buffer64find", "scale_error", "buffergfil", " buffer2filter", "bufferlycontext", "buttonptformat", "bufferlyload", "packageopstream", "batch_filter", " buffer_find", "buffer___context", "bridgeityformat", "bridge_test", "buffergfilter", "bufferletresult", "button_driver", "bufferopblock", "bufferopstream", "bufferlettrigger", "buffer___info", "buffer2find", "bridgeitytest", "buffer__filter", "scale_fil", " buffer__filter", "buffer2filter", "batch___load", "buffer_fil", "buffer___load", "buffer__stream", "bufferopfilter", "bridgeitylock", "buffer2Filter", "package_block", "buffer64filter", "batch___filter", "package_filter", " buffer2fil", "buffergerror", "bufferptformat", "bufferletfilter", "buffer_info", "bufferlyinfo", "buffer_lock", " buffer_stream", "buffer_result", "packageopblock", "button_list", "scalegfil", "buffer_context", "buffer64Filter", "bufferlyfilter", "bufferptdriver", "bufferitylock", "buffer_list", " buffer_Filter", " buffer_fil", " buffer_result", "bridge_lock", " buffer_format", "bufferopcontainer", "bufferptfilter", "buffer_container", "scale_activate", " buffer2Filter", "buffer_Filter", "buffer_find", "buttonptlist", "buffer_driver", "buffer_format", "batch___info", "bufferletformat", "bufferptstream", "batch_info", "bridge_format", "bufferptblock", " buffer2find", "buffer2fil", "buffer_trigger", "buttonptfilter", "buffer_block", "scalegactivate", "packageopfilter", "button_format", "scale_filter", "buffer_activate", " buffer_trigger", "packageopcontainer", "package_stream", "buffer_error", "scalegfilter", "bridge_filter", "buffer__format", "batch_load", "batch___context", "batch_context", "bufferitytest", "bufferpttrigger", "bridgeityfilter", "buffer_test", "buttonptdriver", " buffer__find", "buffer64fil"], "picref": ["nicdiff", "pinrf", "camref", " picob", "panarg", "picro", "pngref", "pngreference", "pindiff", "piconly", "nicre", "acob", "picreference", "nicarg", "camonly", "pcob", "pireference", "icreq", "pegfirst", "panref", "icRef", "picrel", " picreference", "icref", "pinarg", "pegonly", "nicro", " picrange", "acrel", "panreference", " picdiff", "picRef", "picdiff", "pinmb", " picconf", "icreference", "pinreference", "pegref", "pinconf", "pirange", "icrf", "pinreq", "pngonly", "pcreference", "picre", " picRef", "pngfirst", " picmb", "pegreference", "picconf", "acref", "pinref", "picarg", "picmb", "pinob", "panrf", "camreference", "pinre", " picre", "nicreference", " picrel", "piref", "nicob", "picrange", "nicRef", "acreference", "pinrange", "picrf", "icconf", "pcref", "icarg", "nicreq", "pcro", "picob", "picfirst", "camfirst", "pinRef", " picro", "nicref", "picreq", "pinrel", "pimb"], "c": ["dc", "co", "tc", "cat", "cm", "cam", "nc", "comm", "rc", "u", "arc", "cp", "count", "d", "cache", "this", "t", "current", "w", "coll", "h", "conf", "cont", "ic", "abc", "lc", "cu", "circle", "config", "etc", "mc", "ctrl", "draw", "comments", "sc", "anc", "cs", "cn", "p", "cf", "i", "cur", "l", "g", "cmp", "ca", "ctx", "ci", "chain", "con", "can", "gc", "pc", "comp", "conv", "ac", "cb", "C", "v", "fc", "bc", "rec", "ct", "call", "uc", "cc", "n", "cv", "ec", "com", "container", "ce", "m", "context", "vc"], "outlink": ["inLink", "outLink", "outline", "inlink", "OUTlink", " outline", "OUTLink", "OUTline", " outLink"], "ret": ["flag", "cat", "err", "url", "gt", "Ret", "progress", "rm", "nl", "print", "def", "arr", "ref", "reg", "t", "ll", "valid", "del", "mel", "mem", "irm", "cont", "__", "rt", "ry", "it", "txt", "status", "res", "Return", "pass", " Ret", "result", " RET", "deg", "rem", "out", "nt", "complete", "iter", "mt", "try", "tr", "elt", "gc", "att", "pas", "RET", "mail", "ft", "rev", "success", "jump", "re", "format", "usr", "val", "not", "rets", "net", "back", "Alt", " alt", "full", "reset", "last", "det", "resp", "alt"], "scale": ["grade", "acc", "center", "iso", "site", "data", "cam", "radius", "sample", "Scale", "channel", "create", "total", "remote", "transform", "cache", "parse", "fx", "sys", "ize", "filter", "valid", "series", "se", "sort", "allow", "sync", "coll", "ale", "ser", "rate", "raw", "all", "config", "scan", "match", "info", "set", "draw", "sc", "status", "screen", "scope", "scene", "init", "sup", "l", "sale", "sim", "slice", "store", "size", "server", "cast", "g", "video", "alias", "mask", "can", "gc", "alpha", "use", "conv", "error", "feature", "save", "fc", "sche", "call", "query", "share", "forge", "ice", "service", "si", "super", "rage", "average", "base", "xml", "score", "image", "spec", "cale"], "link": ["ink", "Link", "type", "l", "lock", "error", "linked", "slice", "line", "label", "load", "relation", "scan", "transform", "match", "path", "info", "node", "set", "tile", "status", "base", "loc", "action", "le", "rel"], "scale_param": ["scaleerparam", "cale2var", "scale_comment", "cale2comment", "scalepyparam", "cale2name", "cale2cal", " scale_index", "scalepycal", "cale_comment", "scale2params", "scale_attribute", "scale2name", "scaleerstring", "scale_params", "scale2index", "scale_name", "scale_min", "cale_string", "scaleerparams", "scale2param", "cale2param", "cale2params", "scalepyvar", "scale_index", "scale_cal", " scale2index", " scale_min", "cale_params", "scalepyname", "cale_var", "cale_attribute", "scaleerattribute", " scale_params", " scale2param", "scale2var", "scale2min", "scale_string", "cale_name", "cale_cal", "scale2cal", "scale_var", " scale2min", "scale2comment", "cale_param", " scale2params"], "f": ["p", "h", "bf", "cf", "ft", "i", "v", "fc", "xf", "l", "fr", "fo", "fa", "sf", "fs", "b", "g", "file", "fn", "fl", "fg", "tf", "fp", "fi", "F", "m", "t", "filter", "e", "fac", "w", "conv", "fw"]}}
{"project": "FFmpeg", "commit_id": "9568b2e425f127031ddc91dd78cb9b9f2cae206d", "target": 1, "func": "int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n                                         H264ParamSets *ps, int bit_length)\n{\n    AVBufferRef *pps_buf;\n    const SPS *sps;\n    unsigned int pps_id = get_ue_golomb(gb);\n    PPS *pps;\n    int qp_bd_offset;\n    int bits_left;\n    int ret;\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    pps_buf = av_buffer_allocz(sizeof(*pps));\n    if (!pps_buf)\n        return AVERROR(ENOMEM);\n    pps = (PPS*)pps_buf->data;\n    pps->data_size = gb->buffer_end - gb->buffer;\n    if (pps->data_size > sizeof(pps->data)) {\n        av_log(avctx, AV_LOG_WARNING, \"Truncating likely oversized PPS \"\n               \"(%\"SIZE_SPECIFIER\" > %\"SIZE_SPECIFIER\")\\n\",\n               pps->data_size, sizeof(pps->data));\n        pps->data_size = sizeof(pps->data);\n    memcpy(pps->data, gb->buffer, pps->data_size);\n    pps->sps_id = get_ue_golomb_31(gb);\n    if ((unsigned)pps->sps_id >= MAX_SPS_COUNT ||\n        !ps->sps_list[pps->sps_id]) {\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id);\n    sps = (const SPS*)ps->sps_list[pps->sps_id]->data;\n    if (sps->bit_depth_luma > 14) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Invalid luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n    } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unimplemented luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n        ret = AVERROR_PATCHWELCOME;\n    pps->cabac             = get_bits1(gb);\n    pps->pic_order_present = get_bits1(gb);\n    pps->slice_group_count = get_ue_golomb(gb) + 1;\n    if (pps->slice_group_count > 1) {\n        pps->mb_slice_group_map_type = get_ue_golomb(gb);\n        av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch (pps->mb_slice_group_map_type) {\n        case 0:\n#if 0\n    |       for (i = 0; i <= num_slice_groups_minus1; i++)  |   |      |\n    |           run_length[i]                               |1  |ue(v) |\n#endif\n            break;\n        case 2:\n#if 0\n    |       for (i = 0; i < num_slice_groups_minus1; i++) { |   |      |\n    |           top_left_mb[i]                              |1  |ue(v) |\n    |           bottom_right_mb[i]                          |1  |ue(v) |\n    |       }                                               |   |      |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n    |       slice_group_change_direction_flag               |1  |u(1)  |\n    |       slice_group_change_rate_minus1                  |1  |ue(v) |\n#endif\n            break;\n        case 6:\n#if 0\n    |       slice_group_id_cnt_minus1                       |1  |ue(v) |\n    |       for (i = 0; i <= slice_group_id_cnt_minus1; i++)|   |      |\n    |           slice_group_id[i]                           |1  |u(v)  |\n#endif\n            break;\n    pps->ref_count[0] = get_ue_golomb(gb) + 1;\n    pps->ref_count[1] = get_ue_golomb(gb) + 1;\n    if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) {\n        av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n    qp_bd_offset = 6 * (sps->bit_depth_luma - 8);\n    pps->weighted_pred                        = get_bits1(gb);\n    pps->weighted_bipred_idc                  = get_bits(gb, 2);\n    pps->init_qp                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->init_qs                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->chroma_qp_index_offset[0]            = get_se_golomb(gb);\n    pps->deblocking_filter_parameters_present = get_bits1(gb);\n    pps->constrained_intra_pred               = get_bits1(gb);\n    pps->redundant_pic_cnt_present            = get_bits1(gb);\n    pps->transform_8x8_mode = 0;\n    memcpy(pps->scaling_matrix4, sps->scaling_matrix4,\n           sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, sps->scaling_matrix8,\n           sizeof(pps->scaling_matrix8));\n    bits_left = bit_length - get_bits_count(gb);\n    if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) {\n        pps->transform_8x8_mode = get_bits1(gb);\n        decode_scaling_matrices(gb, sps, pps, 0,\n                                pps->scaling_matrix4, pps->scaling_matrix8);\n        // second_chroma_qp_index_offset\n        pps->chroma_qp_index_offset[1] = get_se_golomb(gb);\n        if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) {\n    } else {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n    init_dequant_tables(pps, sps);\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n    return 0;\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;", "idx": 10971, "substitutes": {"gb": ["GB", "cb", "bf", "sb", "py", "np", "gh", "rs", "attr", "gif", "cm", "nb", "pb", "cfg", "tm", "gd", "pg", "bc", "vg", "gs", "gt", "uf", "eg", "bb", "vm", "eb", "gp", "fb", "rg", "cv", "buf", "cp", "img", "tmp", "obj", "buff", "bt", "g", "Gb", "gz", "b", "mb", "hub", "bs", "storage", "kb", "gm", "sg", "bridge", "pm", "hog", "ctx", "sys", "tg", "wb", "io", "buffer", "db", "rb", "bn", "bg", "gc", "pc", "gg", "hz", "bm", "gy"], "avctx": ["aveca", "avcpp", "avergc", "averctl", "aversetup", " avconn", "avercpp", "avercp", "averca", "avcp", "avertc", "mediacp", " avcp", "avectl", "averctx", "avetc", "navcpp", "avcmd", "navtc", "avercontext", "avecontext", "mediacontext", " avcontext", "avca", "mediagc", "navctx", "averreq", "avecpp", " avgc", "aveconn", "avgc", "avsetup", "navsc", "savctx", "avereq", "avesc", "mediactx", "savreq", "avercmd", "avegc", "avesetup", "avsc", "navcmd", "avctl", "aversc", "avreq", "avcontext", " avsetup", " avctl", "avectx", "savca", "averconn", " avreq", "savgc", "avconn", "navreq", "avtc", "avecmd"], "ps": ["ports", "ts", "caps", "fps", "ats", "aps", "pres", "dates", "ies", "places", "pp", "alls", "params", "its", "als", "pt", "amps", "gs", "ops", "Ps", "sts", "parts", "checks", "ples", "abilities", "ets", "pes", "plays", "posts", "eps", "pse", "pers", "ups", "times", "ins", "ks", "css", "js", "PS", "ds", "ands", "mp", "ists", "ips", "mys", "cs", "ims", "ms", "ppa"], "bit_length": [" bit64len", "bit64len", " bit_padding", "bit_padding", "bit64length", "bit64size", " bit_size", " bit64size", " bit64length", " bit_len", "bit42length", " bit64padding", "bit42size", "bit64padding", "bit_len", "bit_size", "bit42padding", "bit42len"], "pps_buf": ["pps2buffer", "pps___buff", "pps_alloc", "pps2vec", "pp_alloc", "pps_uf", "pps2buff", "ps_uf", "pp_obj", "pps2alloc", "pps___obj", "pp_uf", "pps2uf", "ps_buf", "pps_cb", "pp_buff", "pps___buf", "pps_fg", "pps_vec", "pps2buf", "pp_buf", "pps_obj", "pp_vec", "pps___fg", "pp_buffer", "pp_fg", "pps_buff", "ps_cb", "pps_buffer"], "sps": [" sPS", "nsPS", "desps", "spers", "sfs", "wsPS", "spe", "ospe", "nsples", "nsls", "isPS", "sspped", "ospers", "sls", "osPS", "sPS", "Spar", "dsps", "usales", "wspped", " sts", " seps", "spar", "spped", "Sls", "sples", "dsPS", "osps", "msplays", "wspar", "desips", "isps", "iseps", "dspers", "lsPS", " sfs", "isplays", "wsps", "dspe", "Spped", " splays", " sales", "ssPS", "Sples", "asps", "usips", "SPS", "msps", "mseps", "sspar", "sips", "asls", "sales", "asPS", "lsfs", " spers", "isips", "ssps", "usPS", "lsps", "desplays", "seps", "lsts", "Sps", "desPS", "splays", "sts", " sips", "nsps", "usps", "msPS", " spe", "asples"], "pps": ["changes", "opa", "ls", "ppers", "ears", "mph", "mos", "fixes", "apps", "isp", "fx", "ppe", "tops", "hops", "opp", "pkg", "ppo", "drops", "forces", "caps", "pp", "phones", "dd", "params", "dds", "ppy", "pt", "pport", "parts", "checks", "acts", "posts", "ks", "oops", "stats", "vs", "ews", "clips", "ppa", "ports", "pres", "points", "PP", "ops", "xp", "phis", "ppings", "eps", "facts", "times", "PS", "ips", "bps", "php", "OPS", "alks", "fps", "pl", "aps", "rs", "px", "alls", "stuff", "pots", "forms", "papers", "rpm", "AMS", "makes", "details", "ups", "kk", "mp", "balls", "words"], "qp_bd_offset": ["qp_bdptno", "qp_bin_off", "qp_bd_shift", "qp_bdptshift", "qp_bdxoff", "qp_bdptoffset", "qp_bd_off", "qp_bdptoff", "qp_bdxno", "qp_bd_no", "qp_bdxoffset", "qp_bin_shift", "qp_bdxshift", "qp_bin_offset", "qp_bin_no"], "bits_left": ["bits_needed", " bits_len", "bits_right", " bits_needed", "bits_len", " bits_right"], "ret": ["pert", "flag", "RET", "ft", "mem", "plain", "format", "result", "Ret", "val", "rem", "nt", "total", "print", "def", "rt", "set", "prop", "et", "ll", "resp", "ruby", "alt", "Return"]}}
{"project": "qemu", "commit_id": "a52b2cbf218d52f9e357961acb271a98a2bdff71", "target": 1, "func": "static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)\n\n{\n\n    trace_qxl_spice_monitors_config(qxl->id);\n\n    if (replay) {\n\n        /*\n\n         * don't use QXL_COOKIE_TYPE_IO:\n\n         *  - we are not running yet (post_load), we will assert\n\n         *    in send_events\n\n         *  - this is not a guest io, but a reply, so async_io isn't set.\n\n         */\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->guest_monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(\n\n                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,\n\n                    0));\n\n    } else {\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n        if (qxl->max_outputs) {\n\n            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,\n\n                                                qxl->max_outputs);\n\n        }\n\n#endif\n\n        qxl->guest_monitors_config = qxl->ram->monitors_config;\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->ram->monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n\n                                          QXL_IO_MONITORS_CONFIG_ASYNC));\n\n    }\n\n}\n", "idx": 10974, "substitutes": {"qxl": ["quxl", "qfxL", "quxlp", "qaxdl", "quxlin", "cachexxl", "queuexlen", "quxd", "qxila", "qtxL", "qxls", "quxli", "qxyli", "qrexlam", "queryxls", "qmxl", "qexls", "queryxsl", "qrosslp", "qxfll", "qnzli", "iqxla", "queinxl", "quxfl", "qxpls", "quxfli", " qxyl", "qtxl", "qxisl", "qxlin", "qrossd", "qxpla", "qxeslen", "queryxlen", "aqxdl", "qxlor", " qxls", "qinxlp", "qxpli", "qrxll", "qxyln", "cachexxls", "quuxlp", "cachexls", "qxils", " qxL", "qxL", "quexls", "qtryll", "updatexile", "quuxlor", "qxfli", "qxli", "qixli", "qrxL", "queinxly", "qtxli", "quexl", "quxll", "cachexll", "qnzL", "iqxli", "iqxl", "qrexdl", "qpxL", "qxla", "quxsl", "qtxln", "aqxydl", "iqxpli", "qexL", "qmxls", "qxyls", "queuexl", "qxil", "qnzle", "iqxpla", "quexlp", "qinxl", "qtxdl", "qxyle", "iqxls", "queryuxlen", "queryxl", "qexdl", "qrxlin", "qtrylan", "qxilen", "qtryli", "quxfll", "qxfl", "qxd", "aqxlam", " qexL", "qrxle", "quxlan", "queuexilen", "qxlen", "qnzl", "aqxli", "queryuxsl", "cachexxle", "qxln", "updatexL", "qrossl", " qxli", "qrxls", "qxlam", "qxxll", "quxdl", "queinxlp", "qfxly", "queuexla", "qxlp", "qexlin", " qexli", "quexly", "qxsl", "qxesla", "qxydl", "quxflan", "updatexiL", "qxals", "qpxl", " qxylen", "qxylor", "qtxls", "aqxyln", "qxle", " qtxls", "qmxlen", "queryuxl", "qfxlp", "aqxylam", "qxile", "updatexil", " qxle", "qfxl", "quexL", "qxflan", "qxal", "qexle", "qxyl", "qxyd", "qexl", "qxylam", "qtxle", "iqxpl", "qxlan", "quxlor", "iqxpls", "aqxyl", "qmxsl", "qxpl", " qexle", "queuexil", "qxxle", "qaxlin", "qxylp", "qaxl", "quexdl", "qrosslor", "qxdl", "quxls", "qxyL", "qtxla", "qxll", "qexli", "cachexle", "qaxls", "qxylen", "aqxln", "queryuxls", " qtxL", "qrxdl", "qtxlam", "qpxls", "qinxly", "qrxl", " qtxl", "queinxL", "queuexila", " qxlen", "cachexl", "quxlen", "qinxL", "qtryl", "qxiL", "qxala", "qtxll", "qxxls", "qixl", "qtxlen", "updatexle", "quexlin", "aqxyli", "qxxl", "quuxl", " qexl", "qxili", "qixln", "aqxl", "updatexl", " qxyli", "cachexxll", "quuxd", "qxesl", "qxly", "qrexl", "qxyly", "qxali", "qxyla"], "replay": ["Replay", "recplayer", "preplay", "replaying", "creplays", "replays", "preplaying", "Replaying", "creplaying", " replaying", "rerplaying", "rerPlay", "recplaying", "rerplays", "crePlay", "replayer", "prePlay", "Replayer", "recPlay", " replays", " rePlay", "creplay", "rePlay", "rerplay", "RePlay", "recplay", "preplayer"]}}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n", "idx": 10982, "substitutes": {"n": ["ren", "p", "ot", "h", "no", "nd", "nn", "yn", "on", "np", "conn", "conf", "i", "v", "nb", "ng", "norm", "N", "network", "name", "l", "na", "ln", "en", "j", "wn", "an", "nr", "tn", "comm", "pn", "nl", "unn", "and", "nt", "gn", "ne", "nm", "obj", "g", "fn", "net", "d", "form", "anon", "cache", "names", "local", "sn", "node", "note", "adj", "dn", "rn", "c", "m", "num", "cdn", "nu", "nw", "hn", "nv", "nor", "el", "mn", "cn", "ns"], "status": ["active", "p", "x", "no", "sw", "tag", "type", "i", "enabled", "f", "test", "Status", "stat", "version", "atus", "name", "result", "str", "network", "code", "at", "out", "size", "prefix", "net", "scale", "st", "s", "info", "y", "node", "weight", "check", "t", "sc", "current", "res", "resp", "ping", "cs", "state", "xml", "w", "spec", "msg", "error"], "vdev": ["evdevice", "vcdes", "vrval", "mdev", "vrdevice", "svdev", "evtech", "mDEV", "evreg", "vDEV", "vcdevice", "vdes", " vDEV", "mdef", "vev", " vreg", "vraddr", "vcdev", " vev", "wval", "vdevice", " vaddr", "vctech", " vdef", "evdes", "vaddr", "waddr", "vcev", "svDEV", "vdef", "wdev", "svdevice", "vtech", "wdevice", "vcreg", "evev", "mdevice", " vval", "evdev", " vdes", " vtech", "vrdev", "vreg", " vdevice", "vval", "svdef"], "nc": ["NC", "dc", "sync", "cb", "nn", "yn", "np", "conn", "tc", "cus", "cmd", "nb", "ng", "ic", "nec", "bc", "ct", "neck", "disc", "nr", "cu", "nic", "cc", "pn", "nl", "cv", "nt", "gn", "ne", "ni", "enc", "fn", "phys", "sn", "ctx", "dn", "rn", "c", "mc", "nih", "anc", "hn", "nw", "nv", "xc", "cs", "pc", "gc", "nor", "mn", "cn", "ns"], "r": ["p", "x", "h", "dr", "hr", "cr", "pr", "red", "rs", "attr", "i", "err", "rr", "f", "ar", "repl", "vr", "re", "rf", "result", "l", "R", "lr", "nr", "rate", "rc", "sr", "u", "out", "rg", "rad", "er", "g", "d", "ur", "_", "rat", "ro", "arr", "q", "rt", "mr", "rar", " err", "kr", "br", "m", "c", "t", "res", "rb", "w", "rd"]}}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n", "idx": 10984, "substitutes": {"obj": ["ot", "opt", "instance", "Obj", "np", "conn", "xy", "obo", "attr", "onet", "typ", "alloc", "ob", "obs", "object", "bj", "j", "org", "ex", "o", "nt", "tmp", "bh", "ht", "act", "os", "y", "go", "js", "ref", "ctx", "kind", "it", "txt", "po", "resp", "bo", "hw", "cmd"], "core": ["cycle", "ore", "common", "cr", "co", "init", "conn", "wp", "feature", "primary", "cop", "ob", "ome", "ox", "ain", "rc", "process", "Core", "cp", "ve", "cast", "cer", "ec", "copy", "ro", "one", "node", "force", "go", "oe", "ce", "cy", "ge", "port", "po", "gc", "pc", "cpu", "ready", "ac"], "name": ["common", "no", "ma", "mem", "type", "cap", "k", "id", "data", "NAME", "title", "str", "named", "new", "root", "sen", "key", "ex", "out", "space", "n", "label", "o", "nm", "size", "prefix", "names", "def", "path", "one", "var", "lat", "ref", "ame", "Name", "nam", "t", "c", "len", "base", "up", "word", "class", "me", "w", "cn", "ns"], "oc": ["dc", "ot", "co", "voc", "erc", "oco", "alloc", "ic", "oid", "ob", "bc", "nc", "ct", "oci", "uc", "ico", "unc", "nic", "cc", "rc", "o", "ec", "osc", "roc", "og", "ocate", "toc", "aco", "oss", "c", "orp", "anc", "ocr", "OC", "gc", "ucc", "pc", "yo", "cs", "isc", "ac"]}}
{"project": "FFmpeg", "commit_id": "892fc83e88a20f9543c6c5be3626712be7a2e6f2", "target": 0, "func": "static void init_block_mapping(Vp3DecodeContext *s) \n\n{\n\n    int i, j;\n\n    signed int hilbert_walk_y[16];\n\n    signed int hilbert_walk_c[16];\n\n    signed int hilbert_walk_mb[4];\n\n\n\n    int current_fragment = 0;\n\n    int current_width = 0;\n\n    int current_height = 0;\n\n    int right_edge = 0;\n\n    int bottom_edge = 0;\n\n    int superblock_row_inc = 0;\n\n    int *hilbert = NULL;\n\n    int mapping_index = 0;\n\n\n\n    int current_macroblock;\n\n    int c_fragment;\n\n\n\n    signed char travel_width[16] = {\n\n         1,  1,  0, -1, \n\n         0,  0,  1,  0,\n\n         1,  0,  1,  0,\n\n         0, -1,  0,  1\n\n    };\n\n\n\n    signed char travel_height[16] = {\n\n         0,  0,  1,  0,\n\n         1,  1,  0, -1,\n\n         0,  1,  0, -1,\n\n        -1,  0, -1,  0\n\n    };\n\n\n\n    signed char travel_width_mb[4] = {\n\n         1,  0,  1,  0\n\n    };\n\n\n\n    signed char travel_height_mb[4] = {\n\n         0,  1,  0, -1\n\n    };\n\n\n\n    debug_vp3(\"  vp3: initialize block mapping tables\\n\");\n\n\n\n    /* figure out hilbert pattern per these frame dimensions */\n\n    hilbert_walk_y[0]  = 1;\n\n    hilbert_walk_y[1]  = 1;\n\n    hilbert_walk_y[2]  = s->fragment_width;\n\n    hilbert_walk_y[3]  = -1;\n\n    hilbert_walk_y[4]  = s->fragment_width;\n\n    hilbert_walk_y[5]  = s->fragment_width;\n\n    hilbert_walk_y[6]  = 1;\n\n    hilbert_walk_y[7]  = -s->fragment_width;\n\n    hilbert_walk_y[8]  = 1;\n\n    hilbert_walk_y[9]  = s->fragment_width;\n\n    hilbert_walk_y[10]  = 1;\n\n    hilbert_walk_y[11] = -s->fragment_width;\n\n    hilbert_walk_y[12] = -s->fragment_width;\n\n    hilbert_walk_y[13] = -1;\n\n    hilbert_walk_y[14] = -s->fragment_width;\n\n    hilbert_walk_y[15] = 1;\n\n\n\n    hilbert_walk_c[0]  = 1;\n\n    hilbert_walk_c[1]  = 1;\n\n    hilbert_walk_c[2]  = s->fragment_width / 2;\n\n    hilbert_walk_c[3]  = -1;\n\n    hilbert_walk_c[4]  = s->fragment_width / 2;\n\n    hilbert_walk_c[5]  = s->fragment_width / 2;\n\n    hilbert_walk_c[6]  = 1;\n\n    hilbert_walk_c[7]  = -s->fragment_width / 2;\n\n    hilbert_walk_c[8]  = 1;\n\n    hilbert_walk_c[9]  = s->fragment_width / 2;\n\n    hilbert_walk_c[10]  = 1;\n\n    hilbert_walk_c[11] = -s->fragment_width / 2;\n\n    hilbert_walk_c[12] = -s->fragment_width / 2;\n\n    hilbert_walk_c[13] = -1;\n\n    hilbert_walk_c[14] = -s->fragment_width / 2;\n\n    hilbert_walk_c[15] = 1;\n\n\n\n    hilbert_walk_mb[0] = 1;\n\n    hilbert_walk_mb[1] = s->macroblock_width;\n\n    hilbert_walk_mb[2] = 1;\n\n    hilbert_walk_mb[3] = -s->macroblock_width;\n\n\n\n    /* iterate through each superblock (all planes) and map the fragments */\n\n    for (i = 0; i < s->superblock_count; i++) {\n\n        debug_init(\"    superblock %d (u starts @ %d, v starts @ %d)\\n\",\n\n            i, s->u_superblock_start, s->v_superblock_start);\n\n\n\n        /* time to re-assign the limits? */\n\n        if (i == 0) {\n\n\n\n            /* start of Y superblocks */\n\n            right_edge = s->fragment_width;\n\n            bottom_edge = s->fragment_height;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * s->fragment_width;\n\n            hilbert = hilbert_walk_y;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = -1;\n\n\n\n        } else if (i == s->u_superblock_start) {\n\n\n\n            /* start of U superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->u_fragment_start - 1;\n\n\n\n        } else if (i == s->v_superblock_start) {\n\n\n\n            /* start of V superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->v_fragment_start - 1;\n\n\n\n        }\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 4;\n\n\n\n            /* fragment is now at the start of a new superblock row */\n\n            current_fragment += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through all 16 fragments in a superblock */\n\n        for (j = 0; j < 16; j++) {\n\n            current_fragment += hilbert[j];\n\n            current_height += travel_height[j];\n\n\n\n            /* check if the fragment is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_fragments[mapping_index] = current_fragment;\n\n                debug_init(\"    mapping fragment %d to superblock %d, position %d\\n\", \n\n                    s->superblock_fragments[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_fragments[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no fragment\\n\", \n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the superblock <-> macroblock mapping; iterate through\n\n     * all of the Y plane superblocks to build this mapping */\n\n    right_edge = s->macroblock_width;\n\n    bottom_edge = s->macroblock_height;\n\n    current_width = 0;\n\n    current_height = 0;\n\n    superblock_row_inc = s->macroblock_width;\n\n    hilbert = hilbert_walk_mb;\n\n    mapping_index = 0;\n\n    current_macroblock = -1;\n\n    for (i = 0; i < s->u_superblock_start; i++) {\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 2;\n\n\n\n            /* macroblock is now at the start of a new superblock row */\n\n            current_macroblock += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through each potential macroblock in the superblock */\n\n        for (j = 0; j < 4; j++) {\n\n            current_macroblock += hilbert_walk_mb[j];\n\n            current_height += travel_height_mb[j];\n\n\n\n            /* check if the macroblock is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_macroblocks[mapping_index] = current_macroblock;\n\n                debug_init(\"    mapping macroblock %d to superblock %d, position %d\\n\",\n\n                    s->superblock_macroblocks[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_macroblocks[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no macroblock\\n\",\n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width_mb[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the macroblock <-> fragment mapping */\n\n    current_fragment = 0;\n\n    current_macroblock = 0;\n\n    mapping_index = 0;\n\n    for (i = 0; i < s->fragment_height; i += 2) {\n\n\n\n        for (j = 0; j < s->fragment_width; j += 2) {\n\n\n\n            debug_init(\"    macroblock %d contains fragments: \", current_macroblock);\n\n            s->all_fragments[current_fragment].macroblock = current_macroblock;\n\n            s->macroblock_fragments[mapping_index++] = current_fragment;\n\n            debug_init(\"%d \", current_fragment);\n\n\n\n            if (j + 1 < s->fragment_width) {\n\n                s->all_fragments[current_fragment + 1].macroblock = current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = current_fragment + 1;\n\n                debug_init(\"%d \", current_fragment + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if (i + 1 < s->fragment_height) {\n\n                s->all_fragments[current_fragment + s->fragment_width].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {\n\n                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width + 1;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            /* C planes */\n\n            c_fragment = s->u_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            c_fragment = s->v_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            debug_init(\"\\n\");\n\n\n\n            if (j + 2 <= s->fragment_width)\n\n                current_fragment += 2;\n\n            else \n\n                current_fragment++;\n\n            current_macroblock++;\n\n        }\n\n\n\n        current_fragment += s->fragment_width;\n\n    }\n\n}\n", "idx": 10992, "substitutes": {"s": ["ts", "p", "less", "h", "sb", "conf", "ats", "sw", "ses", "rs", "se", "v", "ls", "ss", "es", "settings", "its", "ps", "gs", "aws", "comm", "ops", "sts", "ex", "space", "n", "sq", "south", "fs", "sv", "sym", "is", "os", "ms", "bis", "sg", "js", "scl", "sys", "hs", "ds", "S", "c", "source", "spec", "cs", "e", "state", "bs", "qs", "conv", "ns"], "i": ["r", "p", "x", "h", "f", "v", "ri", "ic", "ai", " ii", "l", "ii", "I", "iu", "bi", "n", "b", "is", "si", "li", "y", "ci", "m", "c", "mi", "ij", "pi"], "j": ["r", "p", "aj", "jj", "jc", "v", "f", "jump", "z", "l", "ii", "ji", "bi", "n", "ja", "b", "kj", "g", "q", "js", "J", "m", "je", "jl", "ij", "k", "jp"], "hilbert_walk_y": ["hilbert_walk10y", "hilbert_player10ey", "hilbert_walk10Y", "hilbert_walk__ey", "hilbert_step_Y", "hilbert_walkery", "hilbert_walk_Y", "hilbert_walk10ey", "hilbert_node_y", "hilbert_read_base", "hilbert_look\u0430x", "hilbert_look_yu", "hilbert_walk_py", "hilbert_walkerhot", "hilbert_loop_y", "hilbert_player_Y", "hilbert_walkerye", "hilbert_read_x", "hilbert_nodeableY", "hilbert_loopYyer", "hilbert_walkpty", "hilbert_walk10base", "hilbert_nodeabley", "hilbert_walk_iy", "hilbert_walkabley", "hilbert_walk_store", "hilbert_play_by", "hilbert_walkerx", "hilbert_loop_Y", "hilbert_look_store", "hilbert_read_Y", "hilbert_player_yo", "hilbert_nodeableyer", "hilbert_watch_y", "hilbert_player10y", "hilbert_watch_x", "hilbert_walk_e", "hilbert_walk_yo", "hilbert_walkYY", "hilbert_walk_ye", "hilbert_walk_ey", "hilbert_player10yo", "hilbert_walk_hot", "hilbert_walker_x", "hilbert_node_Y", "hilbert_walkableyer", "hilbert_walkererhot", "hilbert_move_y", "hilbert_step_ey", "hilbert_walkererx", "hilbert_walkptyu", "hilbert_play_Y", "hilbert_watch___x", "hilbert_watch___cy", "hilbert_walk0yer", "hilbert_walk__e", "hilbert_walk_yer", "hilbert_walk_by", "hilbert_walk___y", "hilbert_walkableoy", "hilbert_walkptstore", "hilbert_walk17y", "hilbert_watch___y", "hilbert_nodeablex", "hilbert_look\u0430yu", "hilbert_walk10yo", "hilbert_play_y", "hilbert_look\u0430y", "hilbert_walkYpy", "hilbert_loopYpy", "hilbert_walk\u0430y", "hilbert_step_x", "hilbert_walkererye", "hilbert_walk__yy", "hilbert_walk___cy", "hilbert_loop_py", "hilbert_walk_cy", "hilbert_walk_yu", "hilbert_walk__oy", "hilbert_loopYy", "hilbert_walkableY", "hilbert_look_y", "hilbert_walkerery", "hilbert_walker_hot", "hilbert_look\u0430store", "hilbert_look_x", "hilbert_walkYy", "hilbert_walk_base", "hilbert_walker_ye", "hilbert_walkablex", "hilbert_walker_y", "hilbert_walk10x", "hilbert_move_ey", "hilbert_walk0y", "hilbert_node_x", "hilbert_walk17x", "hilbert_walk17yx", "hilbert_walkptx", "hilbert_player_y", "hilbert_walk\u0430yu", "hilbert_walk_yx", "hilbert_walk_yy", "hilbert_walk__x", "hilbert_player_ey", "hilbert_walk__y", "hilbert_walk\u0430store", "hilbert_walk_x", "hilbert_walk17cy", "hilbert_walk_yd", "hilbert_walk_oy", "hilbert_loop_yer", "hilbert_walk0Y", "hilbert_move_oy", "hilbert_step_e", "hilbert_walk__Y", "hilbert_play_ys", "hilbert_player10Y", "hilbert_walkYyer", "hilbert_walk0py", "hilbert_read_y", "hilbert_node_yer", "hilbert_watch___yx", "hilbert_walk_ys", "hilbert_move_yy", "hilbert_watch_cy", "hilbert_walk___yx", "hilbert_step_y", "hilbert_loopYY", "hilbert_walk\u0430x", "hilbert_watch_yx", "hilbert_walk___x"], "hilbert_walk_c": ["hilbert_walk_cm", "hilbert_step_cm", "hilbert_step_c", "hilbert_step_m", "hilbert_walk_cs", "hilbert_step_cs", "hilbert_walk_m"], "hilbert_walk_mb": ["hilbert_walk2mm", "hilbert_walk2emb", "hilbert_walk2b", "hilbert_walk2mb", "hilbert_move_mb", "hilbert_walk_b", "hilbert_walk_mm", "hilbert_move_b", "hilbert_walk_emb", "hilbert_move_emb", "hilbert_move_mm"], "hilbert": ["hailbe", "Hailbit", "Hilbe", "hoolbe", "hillber", "Hailbert", "hailber", "Hilber", "Hilbit", "hillbe", "hilber", "hilbit", "hoolber", "hillbit", "hillbert", "hoolbit", "hoolbert", "Hailbe", "Hilbert", "hilbe", "hailbert", "Hailber", "hailbit"], "current_macroblock": ["current_macromfield", "current_macroidrow", "current_acrofield", "current_macromblock", "current_macroidblock", "current_macromrow", "current_macrosrow", "current_macroidfield", "current_macrorow", "current_acroidrow", "current_macrofield", "current_macrosfield", "current_acroidfield", "current_macrosblock", "current_acroblock", "current_acrorow", "current_acroidblock"], "c_fragment": ["c_frangmented", "c_frangment", "c_fraggmented", "c_pragment", "c_fragggment", "c_prigmented", "c_prigment", "c_frangments", "c_fragments", "c_fragmented", "c_pragmented", "c_fraggments", "c_friggment", "c_praggment", "c_franggment", "c_fraggment", "c_frigment", "c_priggment", "c_prigments", "c_frigmented", "c_pragments", "c_frigments"], "travel_width": ["travel_length", " travel_length", " travel_score", "travel_score", "travel67memory", "travelalscore", "travel67length", "travel67score", "travel_memory", "travelalwidth", "travelalmemory", " travel_memory", "travelallength", "travel67width"], "travel_height": ["travel_length", " travel_length", "travel_cy", "travel_memory", " travel_cy", " travel_memory"], "travel_width_mb": ["travel_width_mm", "travel_width_MB", "travel_width_mg", "travel_radius_mg", "travel_radius_MB", "travel_radius_mm", "travel_radius_mb"], "travel_height_mb": ["travel_height42mb", "travel_height42low", "travel_height_mm", "travel_length_low", "travel_height42mm", "travel_length_mb", "travel_height42cr", "travel_height_cr", "travel_length_mm", "travel_height_low", "travel_length_cr"], "mapping_index": ["mapping__index", "mapping_num", "mapping__row", "mapped_row", "mapped_index", "mapping_cycle", "mapped_num", "mapping__num", "mapping__cycle", "mapped_cycle", "mapping_row"], "current_fragment": ["current_praggment", "current_pranggment", "current_prangments", "current_franchgment", "current_frangment", "current_frangments", "current_frigments", "current_friggment", "current_franchmented", "current_frigmented", "current_pragment", "current_frigment", "current_fragmented", "current_fraggment", "current_prangmented", "current_franchment", "current_franggment", "current_fragments", "current_prangment", "current_franchments", "current_pragmented", "current_frangmented", "current_pragments"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; m68k_cpu_defs[i].name; i++) {\n\n        (*cpu_fprintf)(f, \"%s\\n\", m68k_cpu_defs[i].name);\n\n    }\n\n}\n", "idx": 10999, "substitutes": {"f": ["r", "p", "h", "cf", "v", "ff", "fc", "l", "rf", "j", "fr", "uf", "fo", "fb", "o", "fa", "sf", "a", "fs", "b", "g", "file", "d", "fn", "form", "s", "fl", "fd", "fx", "q", "fe", "fp", "tf", "fi", "F", "m", "c", "t", "e", "w", "fw"], "cpu_fprintf": ["cpu_dmt", "cpu_fmt", "cpu_dprintf", "cpu_vprint", "cpu_vformat", "cpu_mformat", "cpu_fformat", "cpu_dprint", "cpu_vprintf", "cpu_mprint", "cpu_dformat", "cpu_fprint", "cpu_mprintf", "cpu_mmt", "cpu_vmt"], "i": ["ui", "di", "p", " pi", "collection", "cli", "x", "init", " multi", "ma", "uri", " ti", " m", "v", "gi", "json", "ri", "ic", "ai", "id", "z", " ii", "ind", "ei", "ii", "j", "xi", "sim", "I", "phi", " Li", "ix", "iu", "oi", "multi", "bi", " I", "ni", "remote", "my", "si", "index", "s", "li", " bi", "y", "ini", " li", "info", "\u0438", "it", "m", "ci", "c", " di", "qi", "zi", "mi", "ip", " j", "ti", "im", "asi", "pi", "e", "ki", "ims", " si"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11016, "substitutes": {"s": ["r", "ts", "p", "self", "session", "sync", "h", "sb", "conf", "ses", "rs", "v", "ls", "sp", "ss", "es", "stat", "ps", "gs", "comm", "ops", "sts", "http", "n", "sq", "o", "obj", "sm", "south", "fs", "sv", "is", "b", "sam", "os", "set", "sys", "js", "hs", "ds", "ssl", "stats", "S", "c", "so", "t", "spec", "cs", "bs", "qs", "ns"], "dev": ["p", "develop", "wd", "DEV", "Dev", "conn", "ev", "mem", "proc", "v", "der", "dd", "de", "data", "cam", "end", "pad", "ver", "cand", "debug", "device", "out", "stick", "ve", "nt", "des", "md", "serv", "d", "app", "def", "dem", "var", "go", "Device", "phy", "vo", "ad", "det", "doc", "hw", "w", "cmd"], "state": ["r", "powered", "al", "p", "or", "no", "ace", "next", "tag", "type", "test", "ss", "STATE", "pe", "output", "function", "name", "role", "l", "start", " stated", "new", "future", "th", "close", "policy", "range", "store", "count", "ne", "size", "State", "event", "post", "is", "zone", "print", "mt", "st", "te", "are", "see", "note", "hash", "style", "trace", "states", "check", "ed", "operator", "status", "source", "ate", "se", "show", "scope"]}}
{"project": "FFmpeg", "commit_id": "af8aa846fa5b9f2c7dcde451c872426528b8b561", "target": 0, "func": "static void frame_start(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n\n\n    MPV_frame_start(s, s->avctx);\n\n    ff_er_frame_start(s);\n\n\n\n    assert(s->linesize && s->uvlinesize);\n\n\n\n    for(i=0; i<16; i++){\n\n        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n    for(i=0; i<4; i++){\n\n        h->block_offset[16+i]=\n\n        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+16+i]=\n\n        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n\n\n    /* can't be in alloc_tables because linesize isn't known there.\n\n     * FIXME: redo bipred weight to not require extra buffer? */\n\n    if(!s->obmc_scratchpad)\n\n        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);\n\n\n\n//    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;\n\n}\n", "idx": 11026, "substitutes": {"h": ["p", "HH", "hr", "sw", "hp", "ih", "v", "k", "hm", "sh", "rh", "hd", "her", "hz", "http", "th", "ho", "H", "o", "bh", "b", "el", "oh", "history", "ht", "he", "dh", "ah", "kh", "ph", "ch", "ow", "enh", "hl", "hh", "hash", "hs", "m", "c", "eh", "current", "cache", "host", "hw", "w"], "s": ["changes", "sb", "ses", "ls", "sh", "aws", "comm", "des", "sv", "as", "has", "js", "sys", "bes", "c", "t", "ags", "ssh", "wcs", "se", "ms", "w", "ins", "ns", "less", "session", "ats", "sw", "ps", "parts", "ess", "sq", "fs", "a", "sl", "stats", "ds", "ssl", "sc", "vs", "cs", "ims", "tes", "p", "aunts", "sp", "its", "sports", "th", "o", "is", "g", "b", "st", "eps", "os", "times", "hs", "styles", "spec", "conv", "r", "ts", "rs", "f", "v", "ss", "es", "als", "j", "gs", "sts", "n", "css", "m", "S", "bs", "qs"], "i": ["ami", "cli", "x", " ti", " m", "err", " ii", "ind", "ix", "iu", "bi", " I", "print", "eu", "to", "li", "\u0438", "this", "io", "t", "ti", " n", "jp", " pi", "iii", "gi", "ic", "ei", "I", "phi", "ik", "ie", "info", " bi", "set", "q", "it", "qi", "mi", "ij", "status", "asi", "ki", "ims", "me", "ori", "ui", "p", "init", "um", "uri", "id", "eric", "xi", "sim", "oi", "ex", "at", "multi", "is", "y", "ini", "gu", "ia", "ci", "pi", "us", "di", " multi", " x", "v", "ri", "ai", "ii", "j", "ji", " mi", "in", "hi", "si", " v", " li", "vi", " ni", "m", " p", "zi", "ip", " j", "im", " si", "il"]}}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}", "idx": 11046, "substitutes": {"dev": ["di", "p", "av", "develop", "h", "od", "DEV", "off", "Dev", "mem", "ev", " device", "eth", "conn", "v", "de", "sh", "data", "serial", "cam", "end", "priv", "ind", "pad", "pt", "ver", "sky", "env", "nav", "th", "hw", "device", "ve", "nt", "des", "obj", "devices", "md", "g", "serv", "d", "app", "hid", "def", "dem", "ach", "tr", "var", "board", "sd", "go", "gu", "adv", "ad", "db", "port", "pi", "cho", "w"], "bmdma_bar": ["bmdmaptcar", "bmdMa_bar", "bmdda2car", "bmdma2car", "bmdma2buf", "bmdda_var", "bmdMa_batch", "bmdma_batch", "bmdmaptbuf", "bmdma2bar", "bmdma_car", "bmdma2var", "bmdma_var", "bmdMa_car", "bmdda2bar", "bmdma_buf", "bmdda_bar", "bmdda_buf", "bmdda_car", "bmdmaptbar", "bmdmaptvar", "bmdda2buf", "bmdda2var"], "ide_bar": ["ide_cart", "ine__consumer", "ide_good", "ideixbar", "ine_car", "ide__bar", "ine_group", "ide__car", "ide_group", "idemybart", "idi_car", "ide___batch", "ide_button", "ide_bill", "ide___bar", "ide2button", "ide_batch", "idi_bar", "ine_bar", "ide__bill", "ideixor", "ide2or", "ine__bar", "ipe_button", "idi_bill", "ide__consumer", "ide__batch", "ide_or", "ide___bill", "ine_bart", "ipeixgood", "ipeixbar", "ipeixbutton", "ide_car", "ipeixor", "ideixgood", "ide_default", "ide__bart", "idemycart", "ide_consumer", "ide___car", "idemybar", "ine_cart", "ipe_bar", "ipe_or", "ide_bart", "ide__cart", "ine__cart", "idi_batch", "ine_default", "ide2good", "ideixbutton", "idemyconsumer", "ipe_good", "ine_consumer", "ide2bar", "ine__bart"]}}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}", "idx": 11070, "substitutes": {"handle": ["h", "sha", "bind", "ih", "pid", "sh", "id", "oid", "handler", "pad", "result", "angle", "eno", "lock", "close", "help", "obj", "size", "use", "pointer", "file", "index", "hold", "Handle", "get", "path", "ha", "hash", "ref", "note", "ca", "ctx", "wrapper", "hand", "draw", "status", "handled", "gc", "ptr", "le", "hw", "cmd"], "errp": ["errorpo", "ptrp", "ptrpa", "errpo", "errps", "arrpa", "erpad", "arrpo", " errn", " errpad", "ptrpy", "errpad", "errpy", "ern", " errps", "errorpy", " erpad", "errpa", "erp", " errpa", " ern", "errorps", "errorp", "errn", " errpy", "arrp", "errorpa", "erpa", "arrps", " erp", " errpo", " erpa"], "gfh": ["gsfp", "gtfh", "gfxH", "gevph", " gfhd", "gfH", "gvH", "getfoh", "getfh", "gfhd", "gfyha", " gfha", "gsfih", "gtfih", "gtfoh", "gfxhr", "gcfh", " gsfha", "gfih", "gcfph", " gsfh", "gcfH", "gbfp", "gfhr", "gtfp", "gefih", "gdfhd", "gevhr", "gbfoh", "getfp", "gsfha", "gbfih", "gdfha", "gfxph", "gbfh", "gfoh", "gvhr", "gefhr", "gfha", " gsfhd", "gvh", "gcfhr", "gfxh", "gfyh", "gvph", "gsfoh", "gfph", "gefh", "gdfh", "gefph", "gfp", "gsfhd", "gefoh", "gsfh", "getfih", "gefH", "gevh", "gfyhd", "gefp", "gevH"], "fh": ["cfch", "Fht", "fith", "lfh", "ffbh", "fiph", "lfph", "Fh", "Fsh", "lfsh", "ffh", "cfhandle", "ffc", "fth", "Fbh", "fih", "fc", "Fhandle", "foh", "hhandle", "hph", "lfth", " fsh", " fch", "fsh", "ffsh", "ffhandle", "Fc", "cfph", "fbh", "fish", "fch", "Foh", "ffht", "hch", "cfh", "hh", "ffoh", "fph", "hsh", " fhandle", " fbh", " fht", "fht", "fhandle", "hth", " fc", " fph", " foh"], "ret": ["att", "done", "flag", "RET", "fun", "err", " Ret", "cont", "re", "result", "gt", "Ret", "deg", "val", "ert", "rem", "rm", "lt", "nt", "rets", "not", "back", "print", "mt", " alt", "def", "tr", "elt", "rt", "reset", "del", "inter", "fin", "t", "status", "res", "len", "ll", "det", "resp", "alt", "ter", "nz"]}}
{"project": "FFmpeg", "commit_id": "c9aab8a123c0bcf6adeab390db1ec783326456ca", "target": 0, "func": "static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture * const ref1 = &h->ref_list[1][0];\n\n    int j, old_ref, rfield;\n\n    int start= mbafi ? 16                      : 0;\n\n    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];\n\n    int interl= mbafi || s->picture_structure != PICT_FRAME;\n\n\n\n    /* bogus; fills in for missing frames */\n\n    memset(map[list], 0, sizeof(map[list]));\n\n\n\n    for(rfield=0; rfield<2; rfield++){\n\n        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){\n\n            int poc = ref1->ref_poc[colfield][list][old_ref];\n\n\n\n            if     (!interl)\n\n                poc |= 3;\n\n            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed\n\n                poc= (poc&~3) + rfield + 1;\n\n\n\n            for(j=start; j<end; j++){\n\n                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {\n\n                    int cur_ref= mbafi ? (j-16)^field : j;\n\n                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;\n\n                    if(rfield == field || !interl)\n\n                        map[list][old_ref] = cur_ref;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11080, "substitutes": {"h": ["p", "x", "his", "hp", "f", "i", "v", "k", "ih", "sh", "hm", "rh", "l", "hd", "her", "comm", "http", "hz", "help", "H", "bh", "b", "g", "oh", "history", "ht", "he", "kh", "ah", "handle", "y", "hl", "hh", "q", "hash", "each", "hs", "it", "m", "c", "t", "eh", "e", "host", "hw", "w"], "map": ["conf", "mem", "master", "cap", "link", "save", "sp", "pack", "clear", "Map", "add", "pad", "dict", "result", "en", "code", "window", "share", "collect", "tap", "rm", "process", "config", "make", "maps", "cp", "cast", "load", "file", "app", "scale", "form", "cache", "scan", "print", "MAP", "mk", "match", "copy", "shape", "pan", "view", "set", "max", "bridge", "hash", "cmp", "m", "mp", "ip", "filter", "ape", "mask", "block", "table", "ap", "use", "bm"], "list": ["p", "html", "flat", "tree", "link", "v", "pre", "json", "listed", "test", "id", "pair", "cont", "lists", "name", "l", "ul", "dict", "str", "LIST", "code", "dl", "result", "new", "parent", "stack", "all", "array", "range", "out", "label", "lt", "nt", "null", "count", "not", "List", "type", "form", "index", "st", "details", "def", "path", "li", "detail", "set", "ref", "note", "m", "chain", "filter", "len", "batch", "base", "table", "ist", "status", "source", "point", "single", "block", "word", "level", "spec", "i"], "field": ["p", "present", "FIELD", "bf", "x", "flag", "comment", "value", "tag", "f", "ield", "type", "rule", "ff", "v", "attr", "id", "number", "fix", "format", "fc", "xf", "function", "name", "pad", "end", "start", "depth", "good", "shift", "key", "label", "count", "size", "file", "index", "term", "Field", "fe", "offset", "fields", "t", "len", "row", "table", "word", "col", "length", "zero", "error"], "colfield": ["propdisplay", "refhandler", "attrcomponent", "Colfield", "COLvariable", "refvariable", "COLpixel", "Colvalue", "COLhandler", "propfield", "colcomponent", "COLdisplay", "Colkey", "rolfield", " colFIELD", "colradio", " colkey", "refdisplay", "attrradio", " colvalue", "colFIELD", "colvalue", "colvariable", "prophandler", "colkey", "coldisplay", "attrfield", "attrpixel", "charkey", "colhandler", "rolcomponent", "rolradio", "rolpixel", "COLcomponent", "charvalue", "reffield", "COLradio", "charFIELD", "propvariable", "COLfield", "charfield", "colpixel", "ColFIELD"], "mbafi": ["nobafa", "mmiana", "MBafi", "mbiana", "bbafa", "ambiera", "mbafa", "mtiana", "mbatha", "mpiera", "mbifa", "mmelia", "mpiana", "kbifi", "MBiana", "gbifi", "mmifi", "bbifi", "nobafi", "ambafa", "mbiera", "ambafi", "ambelia", "mmias", "mtifi", "gbafa", "mtatha", "bbfi", "gbafi", "mmafi", "MBfi", "mmiera", "mtias", "mmfi", "mbelia", "mpias", "mtafi", "nobifa", "kbafi", "bbafi", "gbatha", "mpafa", "kbifa", "mpafi", "kbatha", "kbafa", "nobifi", "mbfi", "bbifa", "mpelia", "bbiana", "mpifi", "mbias", "mmafa", "mbifi", "mtafa", "MBifi"], "s": ["ts", "p", "session", "sb", "ats", "sections", "sw", "rs", "i", "v", "ls", "sh", "sp", "ss", "settings", "spe", "ps", "gs", "sts", "n", "fs", "sv", "sl", "is", "g", "a", "serv", "os", "sn", "css", "set", "js", "sys", "hs", "stats", "ds", "styles", "m", "c", "S", "t", "cs", "wcs", "ims", "ms", "w", "ns"], "ref1": ["ref0", " ref2", "refs", "Refs", "map1", " refs", "mapOne", "references", "rel2", " ref0", "Ref2", "reference2", "referenceOne", "relOne", "reference1", "Ref1", "map0", "reference0", "rel1", "refOne", "map2", "Ref0", " refOne", "ref2", "rel0"], "j": ["r", "p", "aj", "x", "oj", "jj", "i", "job", "v", "jc", "json", "f", "jump", "jit", "z", "ng", "ind", "l", "pt", "bj", "fr", "ji", "start", "jac", "ix", "key", "ijk", "n", "o", "obj", "ja", "b", "g", "d", "kj", "er", "index", "kid", "jo", "tr", "y", "q", "note", "js", "adj", "J", "br", "it", "req", "m", "t", "pos", "jl", "ij", "dj", "je", "uj", "bo", "k", "jp"], "old_ref": ["cur_ref", "old__int", "older_pos", " old_loc", "oldenseq", " old_int", "oldxint", "older_Ref", "old_rel", "oldencol", "older_cond", "older_ref", "old_range", "old_seq", " old_num", "older_loc", "old_col", " old_Ref", "oldxref", "cur_col", "oldenref", " old_rel", "old_err", "cur_pos", "cur_seq", "old_loc", "old__num", "old_int", "curencol", "old__ref", "old_cond", "curenref", "oldxrel", "older_err", "curenseq", "old__rel", "old_reference", "old_pos", "oldenpos", "curenpos", "old_Ref", " old_err", "older_range", " old_reference", "old_num", "oldxnum"], "rfield": ["rarfunction", "rarkey", "rarField", "rlabel", "rforce", "artag", "Rvalue", "Rlabel", "rbfunction", "srsim", " rlen", "rarforce", "rarversion", "rbyte", "srforce", "rarvalue", "rbfield", "rvalue", "rversion", " rfunction", " rbyte", "srrule", "srField", "Rsim", " rkey", "rtvalue", "Rversion", "RField", "rsim", " rlabel", " rField", "arfield", "srfunction", "Rdistance", "rtag", "rkey", "rarbyte", "Rrule", "Rforce", "Rtag", "Rlen", "rartag", "rarchild", "srlen", "rchild", "rarrule", "srfield", "rtField", " rvalue", "Rfield", "arkey", "rrule", " rdistance", "rtfield", "rbField", "rField", "rarfield", "rtlabel", "rbsim", " rchild", "Rbyte", "Rfunction", "rdistance", "srdistance", " rtag", "archild", "srversion", "rfunction", "rlen"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 11084, "substitutes": {"pnum": ["panue", "snenum", "gnam", "pnenum", "pannum", "pinnum", "gnums", "wnump", "snum", "panenum", "penump", "gnom", "panumb", "bnum", "panums", "bnumb", "cnue", "PNum", "penam", "penumber", "penUM", "penenum", "cnom", "penumb", "cnum", "bnUM", "PNhum", "gnumb", "pinums", "bnam", "pinumb", "gnumer", "gnUM", "penum", "penums", "pnom", "pnumber", "panumber", "panum", "pnue", "PNumb", "pnumer", "pnums", "gnum", "PNnum", "gnue", "panom", "snumb", "wnums", "pnUM", "snumber", "pnnum", "pnump", "pinump", "penom", "penumer", "panumer", "pnumb", "panhum", "pnhum", "pnam", "wnum", "pinhum", "cnums", "wnumb", "pinum"], "pden": [" pdes", "jdn", "ndn", "qdon", " pdon", "jarden", "pdes", "npDen", "pdn", "mdon", "parDen", "plen", "ndon", "pardn", "Pdon", " parden", "pdal", "jlen", " pdn", " plen", " pDen", "mden", "Pdal", "Pdes", "npdes", "pDen", "mdn", "Pdn", "npden", "qden", " pdal", "Pden", "qdal", "mlen", "PDen", "Parden", "pararden", "pdon", "nden", "qDen", "parden", "jden", "marden"], "s": ["ts", "p", "h", "sb", "sw", "sa", "v", "sp", "ss", "ps", "gs", "sv", "fs", "sl", "g", "d", "sam", "ds", "m", "c", "t", "sc", "spec", "cs", "e", "se", "w"], "st": ["ts", "art", "step", "ld", "sta", "nd", "sw", "sty", "se", "std", "sp", "ast", "ss", "pb", "ste", "stru", "ct", "ST", "pt", "fr", "tt", "ust", "l", "cl", "usr", "stop", "sts", "th", "str", "nt", "obj", "sv", "src", "St", "sl", "ost", "inst", "td", "mt", "rest", "ut", "spect", "rt", "ctx", "standard", "so", "t", "et", "stage", "sc", "status", "est", "stable", "ist", "irst", "storage"], "pc": ["p", "dc", "pic", "pas", "pr", "amp", "pac", "proc", "tc", "wp", "lp", "pp", "ic", "pb", "pe", "fc", "tp", "bc", "nc", "pt", "ct", "ps", "tk", "amps", "rh", "psc", "lc", "cu", "pn", "cc", "pd", "cp", "pa", "cmp", "PC", "pm", "ctx", "pat", "mic", "mc", "c", "mp", "sc", "anc", "pi", "cs", "vc", "vp", "icc", "jp"], "pkt": ["packet", "pingwk", "pcgi", "prekg", " pwk", " pdu", "pdu", "pwk", "pingkt", "pscgi", "produ", "pskt", "prokg", "predu", "pingdu", "pingcgi", " pcgi", "proacket", "prekt", "prokt", "pswk", "pkg", " pkg", " packet", "psdu", "preacket"], "frame_size": ["frameedloss", "frame_loss", "frame67location", "frame_source", "frameablesource", "framevalstorage", "frameablename", "framelexlocation", "framelystorage", "frame_num", "frame_location", "frameLnum", "faceablename", "frame_space", "dataedloss", "frame_cache", "frame_name", " frame_duration", "movielexstyle", " frame_storage", "frameedsize", "frameablesize", "faceablesource", "movie_num", "frameLsize", "face_name", "frame_style", "frame_storage", "framelyduration", "movie_location", "frame64space", "face_size", "faceablespace", "dataedsize", "framelexsize", "movielexnum", "framevalsize", "frameedfee", "movielexsize", "frame64source", "frameedcache", "frame64name", "data_size", "frameLlocation", "movie_size", "data_fee", "faceablesize", "frame_duration", "frame67num", "dataedcache", "framevalduration", "frame67style", "face_source", "framelexnum", "data_cache", "face_space", "movielexlocation", "framelysize", "frameablespace", "dataedfee", "movie_style", "frame_fee", "frame67size", "data_loss", "frameLstyle", "frame64size", "framelexstyle"]}}
{"project": "qemu", "commit_id": "ecbddbb106114f90008024b4e6c3ba1c38d7ca0e", "target": 1, "func": "static int os_host_main_loop_wait(int64_t timeout)\n{\n    GMainContext *context = g_main_context_default();\n    GPollFD poll_fds[1024 * 2]; /* this is probably overkill */\n    int select_ret = 0;\n    int g_poll_ret, ret, i, n_poll_fds;\n    PollingEntry *pe;\n    WaitObjects *w = &wait_objects;\n    gint poll_timeout;\n    int64_t poll_timeout_ns;\n    static struct timeval tv0;\n    fd_set rfds, wfds, xfds;\n    int nfds;\n    /* XXX: need to suppress polling by better using win32 events */\n    ret = 0;\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n        ret |= pe->func(pe->opaque);\n    }\n    if (ret != 0) {\n        return ret;\n    }\n    FD_ZERO(&rfds);\n    FD_ZERO(&wfds);\n    FD_ZERO(&xfds);\n    nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds);\n    if (nfds >= 0) {\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n        if (select_ret != 0) {\n            timeout = 0;\n        }\n        if (select_ret > 0) {\n            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);\n        }\n    }\n    g_main_context_prepare(context, &max_priority);\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n    for (i = 0; i < w->num; i++) {\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n    }\n    if (poll_timeout < 0) {\n        poll_timeout_ns = -1;\n    } else {\n        poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS;\n    }\n    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);\n    qemu_mutex_unlock_iothread();\n    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);\n    qemu_mutex_lock_iothread();\n    if (g_poll_ret > 0) {\n        for (i = 0; i < w->num; i++) {\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n        }\n        for (i = 0; i < w->num; i++) {\n            if (w->revents[i] && w->func[i]) {\n                w->func[i](w->opaque[i]);\n            }\n        }\n    }\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n        g_main_context_dispatch(context);\n    }\n    return select_ret || g_poll_ret;\n}", "idx": 11113, "substitutes": {"timeout": ["r", "options", "ts", "watch", "resolution", "response", "opt", "tc", "slot", "uration", "v", "params", "period", "wait", "tt", "window", "dt", "error", "policy", "out", "size", "time", "server", "event", "service", "seconds", "tv", "script", "Timeout", "poll", "io", "t", "buffer", "status", "option", "timer", "state", "duration", "frequency"], "context": ["language", "instance", "center", "condition", "document", "subject", "request", "private", "connection", "environment", "network", "location", "contact", "command", "window", "parent", "awareness", "setup", "config", "event", "resource", "history", "index", "cache", "address", "package", "ctx", "wrapper", "ce", "c", "translation", "information", "background", "buffer", "sc", "current", "memory", "Context", "message", "host", "reference", "foundation"], "poll_fds": ["poll_fifcs", "poll_fns", "poll1xfaults", "poll____faders", "poll1fds", "poll_faults", "poll_ncs", "poll_fld", "poll_fcs", "poll_fifrs", "poll_fullaults", "poll1xfixtures", "poll_fdcs", "poll_cars", "poll_frs", "poll2ccs", "poll2crs", "poll_ffars", "poll_fmaders", "poll_rfds", "poll_fmaults", "poll_fullixtures", "poll_rfrs", "poll_fdbs", "poll2fcs", "poll1fbs", "poll2frs", "poll____fortcs", "poll_fmds", "poll_rfuds", "poll_fortcs", "poll2cars", "poll_nods", "poll_cds", "poll_fixtures", "poll_ccs", "poll_ffrs", "poll2fods", "poll_fortaders", "poll_fifld", "poll2fds", "poll_nds", "poll_nns", "poll____fortaders", "poll2fars", "poll1xfbs", "poll_fifds", "poll_faders", "poll1faults", "poll_crs", "poll_ffds", "poll____fcs", "poll____faults", "poll1fixtures", "poll_ffcs", "poll_caults", "poll_fortds", "poll1xfds", "poll_fdods", "poll_fullbs", "poll_fos", "poll_fdaults", "poll_xfbs", "poll_fullds", "poll_xfaults", "poll____fortds", "poll_fbs", "poll_fdixtures", "poll_caders", "poll_fifuds", "poll2fns", "poll_fdns", "poll_xfixtures", "poll2cds", "poll____fortaults", "poll_xfds", "poll_fars", "poll____fds", "poll_rfos", "poll_fortaults", "poll_fods", "poll_fifos", "poll_fmcs", "poll_fuds", "poll_cld", "poll_fdds"], "g_poll_ret": ["g_poll2Ret", "g_oll_val", "g_poll_Ret", "g_poll_val", "g_poll2return", "g_oll_Ret", "g_oll_return", "g_pollsret", "g_poll_return", "g_poll2val", "g_pollsreturn", "g_pollsval", "g_pollsRet", "g_poll2ret", "g_oll_ret"], "ret": ["r", "pret", "opt", "flag", "RET", "select", "ft", "mem", "err", " Ret", "repl", "success", "re", "result", "j", "gt", "Ret", "deg", "tn", "new", "val", "dt", "rem", "rm", "out", "lt", "nt", "over", "rets", "not", "vet", "back", "mt", "def", "tr", "fd", "lit", "try", "ext", "elt", "rt", "ref", "reset", "reg", "fi", "inter", "last", "txt", "t", "len", "res", "status", "got", "alt", "gc", "ter"], "i": ["ui", "di", "p", "ami", "cli", "x", "ir", "init", "gi", "id", "ai", "ic", "ind", "ei", "ii", "l", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "oi", "multi", "bi", "n", "me", "o", "hi", "si", "index", "li", "info", "y", "ini", "gu", "fi", "inter", "it", "\u0438", "ci", "m", "io", "chain", "ip", "mi", "ij", "zi", "qi", "batch", "ti", "point", "im", "pi", "e", "ki", "ims", "us"], "n_poll_fds": ["n_poll_funds", "n_poll_cns", "n_poll_fdcs", "n_poll_vns", "n_poll_fdns", "n_poll_fdrs", "n_poll_flers", "n_poll_fccs", "n_poll_cds", "n_poll_fists", "n_poll_vds", "n_poll_crs", "n_poll_cuds", "n_poll_ftys", "n_poll_fros", "n_poll_funcs", "n_poll_ccs", "n_poll2fbs", "n_poll_fenys", "n_poll_fcds", "n_poll_cbs", "n_poll_vcs", "n_poll_fmlers", "n_poll_fenlers", "n_poll_cgs", "n_poll_fns", "n_poll_dbs", "n_poll_fys", "n_poll_ftlers", "n_poll_drs", "n_poll_fbs", "n_poll_funros", "n_poll_fcuds", "n_poll_frs", "n_poll_fmists", "n_poll_fmys", "n_poll2fds", "n_poll_fenists", "n_poll_dds", "n_poll2fgs", "n_poll_vrs", "n_poll_fends", "n_poll_fgs", "n_poll_ftists", "n_poll_cros", "n_poll_fcrs", "n_poll_ftds", "n_poll_dgs", "n_poll2frs", "n_poll_funrs", "n_poll_fdds", "n_poll_fmds", "n_poll_fuds", "n_poll_fcs"], "pe": ["p", "peak", "pl", "ale", "py", "ue", "pee", "ae", "pp", "pb", "xe", "tp", "ste", "ze", "spe", "este", "ps", "aste", "Pe", "ep", "peg", "ice", "ve", "ke", "cp", "pd", "pei", "pes", "pa", "te", "he", "parse", "pse", "pex", "ple", "see", "que", "fe", "ppe", "oe", "lex", "ce", "ele", "PE", "ped", "je", "ape", "per", "ase", "ope", "e", "le", "se", "pet", "nce", "peer", "pri"], "w": ["p", "writer", "wall", "wp", "sw", "v", "wr", "wi", "W", "wait", "wat", "window", "wx", "ew", "saw", "wl", "tw", "g", "work", "wh", "iw", "y", "wine", "q", "wt", "wb", "wa", "nw", "kw", "rw", "we", "wcs", "word", "aw", "hw", "wal", "fw"], "poll_timeout": ["search_policy", "poll67delay", "poll2sleep", "poll_sleep", "poll2timeout", "poll_policy", "poll_delay", "poll_timer", "search_timeout", "query_delay", "poll32timeout", "poll32period", "query67sleep", "poll_time", "poll2delay", "query67timeout", "search_size", "query_timeout", "query67time", "poll_Timeout", " poll_period", "poll2time", "query_time", "poll67sleep", "query67delay", "poll_period", " poll_timer", "poll_size", "poll67timeout", "poll32timer", " poll_delay", "search_Timeout", "poll67time", "poll32delay", "query_sleep"], "poll_timeout_ns": ["poll_timeout_ds", "poll_out_ns", "poll_out_mins", "poll_out_NS", "poll_timeout_ms", "poll_delay_ds", "poll_timeout_ins", "poll_out_ms", "poll_delay_ms", "poll_delay_ns", "poll_timeout_NS", "poll_delay_ins", "poll_timeout_mins"], "tv0": ["tvval", " tvval", "tfno", "tfval", "tv1", "sec6", "ttno", "TVds", "ttds", "secds", "tv2", "tt1", "tf0", "tt2", "ttval", "tv6", "TV2", "tf1", "tvno", "tvds", " tv1", "sec0", " tvno", "TV6", "tt0", "tt6", "sec2", "TV0"], "rfds": ["fgds", "rnds", "rfcs", "rfers", "rafjs", "fgs", "rfxs", "xfcs", "rafcs", "rfargs", "rfls", "rafargs", "fgargs", "xfns", "rnjs", "rfrs", "fwrs", "rafds", "sfdes", "sfcs", "rafers", "rfients", "rafls", "rafs", "fws", "fgcs", "sfns", "fwcs", "rfdes", "rfns", "rafxs", "fwers", "fwds", "rnvals", "xfrs", "fgls", "fwls", "rafns", "fwxs", "xfxs", "sfds", "rafvals", "fwients", "xfdes", "fwargs", "rfs", "fwjs", "rafdes", "rfvals", "fgients", "rfjs", "rncs", "xfs", "fgers", "rafrs", "rafients", "fwvals"], "wfds": ["wcfrs", "rwfDS", " Wufds", "rwxfrs", " Wufdays", "wdfdays", " Wfds", "wfsrs", "wcfd", "ewfrs", "wwds", "rwfcs", "ewxfDS", "ewfuds", " Wfdays", "rwvd", "rwfrs", "wfcs", "wsfd", "wsfrs", "wdfuds", "wsfcs", "wwks", "wrfds", "ewfdays", "wrfd", "wfdays", "wvDS", "rwfds", "wxfd", "wwws", "wdfDS", "wsfds", "wrfDS", "wwDS", "rwxfcs", "wfsDS", "rwfd", "wfws", "wxfws", "rwxfd", "wxfdays", "wxfcs", "ewxfdays", " Wufks", "wvords", " Wfrs", "wfuds", "wxfks", "wxfDS", " Wufrs", "wxfds", "rwfords", "rwvDS", "wrfdays", "ewxfrs", "ewxfws", "wxfuds", "ewxfds", "wufks", "wfks", "wrfuds", "rwxfds", " Wfks", "wcfcs", "ewfws", "rwvds", "wrfords", "wfDS", "wufdays", "wcfds", "wfrs", "wdfds", "wufrs", "wfsws", "wwrs", "wwdays", "wfsds", "wxfords", "wfords", "wufds", "wvds", "rwvords", "wvd", "ewfDS", "wfd", "wxfrs", "ewxfuds", "ewfds"], "xfds": ["xfeds", "cfrs", "xfcs", "fifdds", "fxants", "fxeds", "fxns", "xfns", "xfants", "fxps", "fwrs", "rfeds", "ffieldDS", "sfcs", "ffieldants", "ffieldds", "fxdds", "rfdds", "sfargs", "xfps", "sfps", "rfps", "fwps", "fifds", "fxDS", "cfands", "fwcs", "fifns", "fwdds", "fwDS", "xfands", "fwds", "fifeds", "xfrs", "cfDS", "fifda", "fwants", "cfns", "sfds", "fxrs", "fifps", "fwargs", "fwda", "xfdds", "cfda", "fxds", "xfargs", "fifcs", "fifargs", "xfDS", "fwns", "ffielddds", "xfda", "fifands", "fwands", "cfds"], "nfds": ["nxfods", "nfwds", "nffds", "nrfds", "ncfds", "ncfrs", "nfwats", "nffays", "ndods", "nfdids", " nfns", "nbfcs", "nrfdds", "ndns", " nfcs", "nfods", "nbfdds", " ncfays", "ncfcs", " nxfods", " nxfrs", "nrfrs", "nfwids", "nbfats", "nxfns", "ncfd", " nfats", " nfays", "nfwrs", "nfd", "ndds", " nfdds", "nxfrs", "nfdds", "nfoays", " ncfcs", " nfids", "nfcs", "nfwdds", "nxfd", "nfays", "nfrs", "ncfods", "nfdns", "nxfids", " nfrs", " nxfcs", "ndrs", " nxfns", "nxfcs", "nfdods", "nfdrs", "nfids", "nxfds", "nrfd", "ncfays", "ncfdds", " nxfdds", "nfwcs", " nxfds", " nfods", " nfd", " nxfd", "nfns", "nffods", "nffcs", "nfoods", "nfats", "nfdcs", "nxfdds", "nfocs", " ncfds", " ncfods", "nbfds", " nxfids"]}}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n", "idx": 11117, "substitutes": {"bs": ["ts", "irms", "bf", "sb", "blog", "bd", "rs", "aos", "uts", "bos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "cks", "gs", "ubs", "sbm", "sts", "fs", "lbs", "bles", "bsp", "bytes", "ms", "bas", "ks", "bis", "js", "bes", "hs", "ds", "ubis", "bits", "bing", "bps", "aus", "bn", "vs", "cs", "hz", "bm", "qs", "ns"], "snapshot_id": ["snapcut_id", "snapreenshot_ident", "snapreenshot_id", "snapshotWd", "snapshot_ID", "snapshotuuident", "snapshot_string", "snapshotOd", "snapreenshot_name", "snapshotOstring", "snapcut_string", "snapshot_d", "snapshotuuid", "snapshot_Id", "snapshotuuId", "snapshotuuname", "snapshotOcode", "snapshotWstring", "snapshotWid", "snapreenshot_ID", "snapshotWcode", "snapcut_code", "snapshot_ident", "snapshotOid", "snapreenshot_Id", "snapshot_name", "snapcut_d", "snapshot_code"], "drv": [" drvr", "srch", "vrv", "hrf", "vrva", "drch", " drvd", "vrw", "rdf", "srv", "vrf", "drr", "ldh", " drch", "Drf", "srvd", " drw", "hrvr", "drw", "drvd", "rdvd", "drva", "DRvs", "ldvs", "ldvr", " drf", "vrh", "rdr", "Drvr", "vrvr", "parf", "DRh", "parv", "parvd", "DRv", "rdch", "drvr", "parr", "Drva", " drvs", "hrv", "srm", "rdv", "rdm", " drm", "DRvr", "Drv", "Drh", " drr", "drvs", "drh", "Drw", "hrva", "drf", " drh", "ldv", "drm"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint32_t val;\n\n\n\n    val = bswap32(cpu_inl(addr & IOPORTS_MASK));\n\n    return val;\n\n}\n", "idx": 11126, "substitutes": {"opaque": ["ospcode", "ospus", "iopus", "ospac", "ospaque", " opac", "opus", "iopaque", "opac", " opus", "iopcode", " opcode", "opcode", "iopac"], "addr": ["r", "p", "x", "ace", "dr", "mem", "slot", "rs", "attr", "coord", "err", "hop", "alloc", " address", "url", "add", "pad", "ident", "ix", "align", "at", "n", "prefix", "work", "mt", "dh", "act", "to", "arp", "rol", "arr", "tx", "Address", "ref", "offset", "adr", "pos", "alias", "ad", "loc", "ord", "ptr", "host", "address", "zero", "cmd"], "val": ["pol", "al", " Val", "p", "util", "x", "pl", "vals", "Val", "value", "slot", "mem", "v", "ret", "sel", "bal", "z", "data", "als", " bl", "ul", " el", "pt", "l", " eval", "aval", "all", "bl", "out", " VAL", "buf", " ret", "vt", "sl", "serv", "ival", " al", " vec", " v", "fl", "lit", " value", "elt", "eval", "fi", "it", "vec", "abl", "VAL", "t", "resp", "valid", "pal", " arg", "il"]}}
{"project": "qemu", "commit_id": "5dafc53f1fb091d242f2179ffcb43bb28af36d1e", "target": 0, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n", "idx": 11127, "substitutes": {"f": ["r", "p", "h", "x", "bf", "flag", "conf", "proc", "cf", "ft", "df", "v", "i", "ff", "ret", "exec", "z", "fc", "fee", "ef", "alf", "l", "rf", "ct", "fr", "j", "uf", "fo", "good", "lf", "fb", "all", "fal", "sf", "iter", "fs", "fab", "b", "g", "file", "d", "form", "fm", "ac", "s", "el", "of", "fd", "fl", "info", "ext", "y", "etc", "full", "af", "fe", "q", "fp", "tf", "fi", "F", "it", "m", "c", "t", "inf", "e", "fac", "w", "fw"], "len": ["limit", "tl", "err", "ls", "compl", " el", "en", "nl", "count", "ann", "t", "ll", "valid", "pkg", " msg", "el", "del", " ell", "rel", "coll", " lib", "ret", "cont", " dist", "lf", "all", "lt", "mil", "hl", "lan", "wid", "msg", "gl", "lim", "seq", "fun", "html", "lp", " repl", "Len", "sp", "l", " rot", " fmt", "deg", "label", "nt", "bytes", "fl", " ans", "elt", "cmp", "vec", "lon", "comp", "length", "rot", "conv", "ld", "list", "mat", "repl", "syn", "add", "ln", "dl", "val", "n", " al", " vec", " ll", "lit", "full", "fin", "cod", "pos", " fn", "resp", "alt", "lib"]}}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n", "idx": 11128, "substitutes": {"hub": ["util", "h", "conn", " hubs", "web", "build", "job", "hop", "hy", "pb", "band", "connection", "hook", "proxy", "feed", "sub", "hd", "ub", "ubs", "http", "pub", "bro", "org", "bug", "ib", "hole", "pool", "server", "bh", "rub", "loop", "b", "hi", "hover", "hold", "bs", "handle", "board", "igh", "gb", "bridge", "bus", "driver", "home", "ube", "uber", "box", "hog", "project", "wrapper", "wire", "hyper", "bang", "row", "client", "Hub", "host", "hw", "plug", "grid", "lib"], "port": ["ports", "p", "pod", "pr", "plugin", "fat", "test", "vr", "connection", "version", "pt", "ver", "group", "interface", "proxy", "page", "http", "Port", "channel", "device", "range", "host", "ve", "cp", "pool", "server", "service", "serv", "eport", "net", "player", "bridge", "ort", "phy", "target", "point", "ping", "PORT", "message", "client", "pc", "porter", "state", "socket"], "peer": ["pro", "p", "pod", "instance", "metadata", "consumer", "next", "type", "member", "offer", "actor", "sp", "handler", "primary", "connection", "pe", "tp", "reader", "vr", "ver", "group", "ker", "parent", "worker", "component", "holder", "channel", "device", "owner", "rel", "host", "ne", "pool", "server", "remote", "older", "er", "player", "soc", "that", "cer", "user", "local", "package", "node", "wrapper", "bean", "ger", "target", "part", "manager", "outer", "point", "ping", "message", "entity", "context", "client", "pc", "state", "caster", "ter", "socket", "scope"]}}
{"project": "FFmpeg", "commit_id": "c4e554701ec27b31b1b6396130b8bb2aaa0d4ad0", "target": 0, "func": "DVDemuxContext* dv_init_demux(AVFormatContext *s)\n\n{\n\n    DVDemuxContext *c;\n\n\n\n    c = av_mallocz(sizeof(DVDemuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->vst = av_new_stream(s, 0);\n\n    c->ast[0] = av_new_stream(s, 0);\n\n    if (!c->vst || !c->ast[0])\n\n        goto fail;\n\n    av_set_pts_info(c->vst, 64, 1, 30000);\n\n    av_set_pts_info(c->ast[0], 64, 1, 30000);\n\n\n\n    c->fctx = s;\n\n    c->ast[1] = NULL;\n\n    c->ach = 0;\n\n    c->frames = 0;\n\n    c->abytes = 0;\n\n    c->audio_pkt[0].size = 0;\n\n    c->audio_pkt[1].size = 0;\n\n    \n\n    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;\n\n    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;\n\n    c->vst->codec.bit_rate = 25000000;\n\n    \n\n    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;\n\n    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;\n\n   \n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; \n\n    \n\n    return c;\n\n    \n\nfail:\n\n    if (c->vst)\n\n        av_free(c->vst);\n\n    if (c->ast[0])\n\n        av_free(c->ast[0]);\n\n    av_free(c);\n\n    return NULL;\n\n}\n", "idx": 11140, "substitutes": {"s": ["r", "ts", "less", "p", "options", "h", "sb", "ats", "ses", "rs", "f", "v", "ls", "i", "ar", "ss", "its", "es", "settings", "ps", "l", "gs", "sts", "space", "sq", "fs", "a", "sv", "is", "b", "d", "g", "as", "bs", "ins", "os", "sys", "js", "ctx", "stats", "ds", "m", "S", "t", "sc", "cs", "ims", "spec", "w", "conv", "ns"], "c": ["dc", "co", "tc", "err", "cm", "nc", "comm", "unc", "rc", "u", "arc", "cp", "d", "cache", "t", "current", "xc", "k", "coll", "cr", "h", "conf", "cont", "ic", "abc", "cd", "lc", "cu", "config", "a", "enc", "etc", "mc", "comments", "sc", "anc", "cs", "cn", "p", "cf", "cur", "l", "g", "b", "cmp", "ca", "ctx", "ci", "cal", "chain", "con", "can", "gc", "pc", "comp", "ac", "self", "cb", "C", "f", "v", "fc", "bc", "ct", "call", "cl", "uc", "cc", "n", "cv", "ec", "ch", "com", "ce", "m", "check", "vc"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int bytes, BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {0};\n\n    int ret = 0;\n\n    bool need_flush = false;\n\n    int head = 0;\n\n    int tail = 0;\n\n\n\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n\n                        bs->bl.request_alignment);\n\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                    MAX_WRITE_ZEROES_BOUNCE_BUFFER);\n\n\n\n    assert(alignment % bs->bl.request_alignment == 0);\n\n    head = offset % alignment;\n\n    tail = (offset + bytes) % alignment;\n\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n\n\n\n    while (bytes > 0 && !ret) {\n\n        int num = bytes;\n\n\n\n        /* Align request.  Block drivers can expect the \"bulk\" of the request\n\n         * to be aligned, and that unaligned requests do not cross cluster\n\n         * boundaries.\n\n         */\n\n        if (head) {\n\n            /* Make a small request up to the first aligned sector. For\n\n             * convenience, limit this request to max_transfer even if\n\n             * we don't need to fall back to writes.  */\n\n            num = MIN(MIN(bytes, max_transfer), alignment - head);\n\n            head = (head + num) % alignment;\n\n            assert(num < max_write_zeroes);\n\n        } else if (tail && num > alignment) {\n\n            /* Shorten the request to the last aligned sector.  */\n\n            num -= tail;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_write_zeroes) {\n\n            num = max_write_zeroes;\n\n        }\n\n\n\n        ret = -ENOTSUP;\n\n        /* First try the efficient write zeroes operation */\n\n        if (drv->bdrv_co_pwrite_zeroes) {\n\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                /* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end */\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            /* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             */\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        bytes -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n", "idx": 11141, "substitutes": {"bs": ["ts", "boxes", "fps", "sb", "vals", "ims", "ats", "blog", "bd", "aos", "outs", "bos", "uts", "ls", "BS", "pb", "its", "als", "bp", "bc", "obs", "ps", "cks", "gs", "aws", "bb", "ops", "ads", "ubs", "sts", "bl", "bi", "ils", "abilities", "bh", "fs", "bt", "b", "lbs", "actions", "is", "bles", "bis", "css", "js", "sys", "bes", "hs", "ds", "stats", "rots", "ubis", "aks", "ashes", "bits", "banks", "bing", "bps", "aus", "bn", "vs", "cs", "lb", "hz", "bm", "qs", "ns"], "offset": ["ot", "bf", "off", "slot", "addr", "alloc", "onet", "id", "oid", "onto", "end", "location", "pad", "padding", "start", "window", "position", "shift", "root", "order", "slice", "out", "origin", "o", "size", "seek", "pointer", "bound", "prefix", "transform", "index", "offs", "attribute", "set", "ref", "reset", "Offset", "pos", "num", "alias", "buffer", "et", "block", "base", "batch", "point", "loc", "unk", "address", "length", "zero", "error"], "bytes": ["ones", "options", "units", "lines", "pointers", "outs", "frames", "its", "pages", "izes", "es", "rows", "length", "heads", "gs", "loads", "terms", "parts", "nets", "SIZE", "total", "errors", "ally", "size", "count", "buf", "blocks", "seconds", "values", "offs", "reads", "s", "mb", "ions", "os", "ms", "Bytes", "files", "elt", "byte", "bits", "ips", "pos", "abytes", "len", "bps", "faces", "items", "memory", "pieces", "nos", "runs", "tes", "words", "gets", "ns"], "flags": ["ts", "options", "bugs", "fps", "codes", "vals", "sets", "flag", "types", "aps", "atts", "rs", "uts", "args", "settings", "xf", "fts", "ps", "heads", "gnu", " fleets", "tags", "ops", "lag", " Flags", "terms", " flock", "parts", "properties", "FLAG", "fs", "actions", "Flags", "posts", "details", "files", " styles", "ds", "limits", "fields", "tops", "utils", "bits", "weights", "comments", "mods", "faces", "mask", "locks", "ags", "fits", "orts", "wcs", "rates"], "drv": ["drim", "derver", "rvr", "derf", "vrv", "drj", "derv", "drve", "derj", "rdf", "srv", "rdj", "derve", "srj", "dervs", " drw", "drw", "vrg", "rm", "drivs", "rg", "srf", "srver", "vrvr", "derw", "driv", "rdvr", "srw", "srvr", "drvr", "drver", "derg", "drive", "derm", "rdv", "srm", "rv", " drm", "dervr", "drvs", "drf", "drg", " drver", "srvs", "vrm", "srve", "drm"], "qiov": ["Qiop", "iqiop", "Qiov", "Qiev", "Qiv", "iqiev", "dqiop", "dqiev", "qiv", "iqiv", "qiop", "iqiov", "qiev", "dqiv", "dqiov"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n", "idx": 11142, "substitutes": {"f": ["r", "p", "h", "x", "bf", "cf", "ft", "ff", "v", "z", "fc", "xf", "l", "lf", "rf", "j", "fr", "uf", "fo", "fb", "o", "fa", "sf", "a", "fs", "enc", "b", "g", "d", "file", "form", "fm", "ac", "fn", "fd", "y", "full", "fx", "af", "tf", "fp", "fi", "F", "m", "c", "t", "e", "fac", "w", "fw"], "q": ["r", "p", "Q", "qq", "ue", "conf", "dq", "v", "ck", "qu", "z", "iq", "pt", "query", "cl", "comm", "quit", "all", "qt", "u", "qa", "sq", "ve", "g", "d", "ch", "eq", "y", "que", "quick", "queue", "gr", "quest", "req", "c", "qi", "requ", "t", "aq", "pkg", "w", "msg"], "i": ["ui", "di", "p", " pi", "ami", "cli", "x", "init", " multi", " ti", " m", "v", "gi", "ri", "ic", "ai", "id", "wi", " ii", "ind", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", " mi", "ex", "multi", "u", "bi", " I", "me", "in", "is", "my", "hi", "si", "index", "li", " bi", "y", "ini", " li", "sequence", "gu", " err", "fi", "it", " ni", "ci", "m", "io", " di", "qi", "zi", "mi", "ij", "ti", "im", "asi", "pi", "mu", "ki", "ims"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)\n\n{\n\n    uint32_t entry;\n\n    EHCIQueue *q;\n\n    int reload;\n\n\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    q = ehci_find_queue_by_qh(ehci, entry);\n\n    if (NULL == q) {\n\n        q = ehci_alloc_queue(ehci, async);\n\n    }\n\n    q->qhaddr = entry;\n\n    q->seen++;\n\n\n\n    if (q->seen > 1) {\n\n        /* we are going in circles -- stop processing */\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        q = NULL;\n\n        goto out;\n\n    }\n\n\n\n    get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);\n\n\n\n    if (q->async == EHCI_ASYNC_INFLIGHT) {\n\n        /* I/O still in progress -- skip queue */\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n        goto out;\n\n    }\n\n    if (q->async == EHCI_ASYNC_FINISHED) {\n\n        /* I/O finished -- continue processing queue */\n\n        trace_usb_ehci_queue_action(q, \"resume\");\n\n        ehci_set_state(ehci, async, EST_EXECUTING);\n\n        goto out;\n\n    }\n\n\n\n    if (async && (q->qh.epchar & QH_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n", "idx": 11143, "substitutes": {"ehci": ["ehcgi", "cmdcci", "ethercci", "etherci", "drmcli", "ehcos", "eshci", "erci", "phyci", "ehcu", "ahcu", "ethercgi", "ekoci", "ehli", " ehcos", "ehchain", "ehcli", "cmdcu", " ehchain", "ethercin", "ekchain", "ehcci", " ehcci", "ethni", "ohcli", "ehoci", "ethcit", "phyco", "drmcgi", "drmci", "ahcli", "ahcci", "orthco", "khchain", "etherdi", "ahci", "khoci", "ethcin", "phycci", "ohcci", "ohco", "ahco", "ethercu", "ethercit", "ehcin", "etheroci", "eshni", "engci", "ethcos", "ehco", "eshcos", "ahli", "ehdi", "eshcci", "engcci", "engcgi", "ekci", "eshdi", "ekcit", "eshco", "drmcci", "khci", "ethcgi", "engcli", "eshcu", "khcci", "cmdci", "ohci", "cmdoci", "ercos", "ahoci", "ohli", "ehcit", "ercci", "ekcin", "orthcci", "etherli", "ethci", "phydi", "ehni", "ohdi", "erni", "eshcli", "phycli", "etherco", "ethcli", "orthci", "ekcci", "ethcci", "ahcos", " ehoci", " ehcu", "orthcli", "ahdi", "ekcgi"], "async": [" asday", "lasync", "facync", "asNC", " asNC", "Asynchronous", " assync", "masynchronous", " asynchronous", "acsync", "asday", "aserssync", " asline", " Assync", "anynchronous", "assync", "rasync", "asersday", "alnic", "asyline", "alync", "masync", "lassync", "Assync", " Asynchronous", "asynchronous", "acunc", "massync", " asunc", "asersync", "facyn", "ASync", "asunc", "ASynchronous", "maschron", "asyn", "alsync", "alyn", "rasunc", "ASNC", "asysync", "Async", "acyn", "asersynchronous", "Asday", "ASline", "ASsync", "lasyn", "rassync", "facnic", " AsSync", "acync", "ASyn", "facsync", "anyn", "Aschron", "Asyn", "asyyn", " asSync", " Async", "AsSync", "anync", "ansync", "acNC", "rasyn", " aschron", " asyn", "asline", "asSync", "asyync", "lasynchronous", "aschron", " asnic", "asnic"], "entry": ["search", "or", "ent", "ient", "directory", "slot", "enter", "insert", "dq", "link", "member", "ries", "addr", "id", "cell", "look", "str", "needed", "import", "query", "angle", "rent", "nr", "key", "rc", "record", "qa", "nt", "tmp", "pointer", "join", "print", "index", "kh", "try", "match", "path", "ary", "ry", "queue", "offset", "ly", "inter", "it", "adr", "hash", "escape", "alias", "existent", "row", "Entry", "way", "RY", "ptr", "address"], "q": ["inv", "qq", "qv", "lock", "comm", "qt", "u", "quant", "d", "cache", "eq", "que", "quest", "c", "t", "requ", "pkg", "le", "k", "w", "item", "h", "conf", "comment", "iq", "pt", "sq", "ve", "my", "think", "info", "quick", "ry", "quer", "req", "qi", "aq", "msg", "p", "ue", "ql", "dq", "i", "ck", "qu", "l", "window", "quit", "qa", "o", "store", "g", "gm", "y", "e", "fresh", "r", "Q", "quote", "f", "v", "z", "pg", "ox", "j", "query", "question", "cv", "ch", "get", "local", "queue", "view", "m", "check", "ping", "client", "qs"], "reload": [" Reloader", "reeloader", " replay", "reeplay", "reeload", " Reloads", "replay", " Replay", "reeloads", "reloads", " Reload", "reloader", " reloads", " reloader"], "seen": ["done", "found", "common", "seeing", "far", "ordered", "known", "kept", "written", "awaited", "ered", "there", "numbered", "linked", "sent", "saw", "since", "views", "recorded", "received", "served", "hid", "documented", "see", "visible", "connected", "represented", "marked", "zi", "standing", "sofar", "verified", "registered", "shown", "killed", "used", " unseen"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n", "idx": 11167, "substitutes": {"s": ["ts", "less", "p", "sync", "changes", "lines", "h", "sb", "ats", "sw", "ses", "sol", "rs", "ies", "se", "ls", "ears", "params", "ss", "its", "als", "ers", "es", "z", "ps", "xs", "gs", "aws", "an", "comm", "ops", "ads", "sts", "parts", "tes", "sm", "store", "sv", "fs", "sl", "is", "as", "b", "details", "ins", "sac", "ms", "os", "y", "js", "sys", "stats", "ds", "hs", "S", "t", "utils", "comments", "mods", "spec", "locks", "services", "results", "vs", "cs", "ims", "bs", "qs", "rates", "ns"], "tm": ["ts", "tic", "mm", " TM", "tem", " time", "TM", "mem", "tc", "em", " ti", "attr", "hm", " te", "htm", "tz", "tp", "tk", "tt", "map", "sim", "tn", "cu", "dt", "rm", "qt", "tis", "wx", "sm", "time", "tmp", "nm", "temp", "md", "td", " ts", "mt", "tv", "tim", " tc", " im", "tu", "te", "gm", " tim", "mint", " td", "tr", "tx", " tem", " mt", "mr", " timer", "m", "mc", "mp", "txt", "t", " tmp", " mc", "mi", " mem", "ti", "timer", "ims", "ms", "him"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void tosa_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    PXA2xxState *mpu;\n\n    TC6393xbState *tmio;\n\n    DeviceState *scp0, *scp1;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa255\";\n\n\n\n    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);\n\n\n\n    memory_region_init_ram(rom, NULL, \"tosa.rom\", TOSA_ROM, &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n    tmio = tc6393xb_init(address_space_mem, 0x10000000,\n\n            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));\n\n\n\n    scp0 = sysbus_create_simple(\"scoop\", 0x08800000, NULL);\n\n    scp1 = sysbus_create_simple(\"scoop\", 0x14800040, NULL);\n\n\n\n    tosa_gpio_setup(mpu, scp0, scp1, tmio);\n\n\n\n    tosa_microdrive_attach(mpu);\n\n\n\n    tosa_tg_init(mpu);\n\n\n\n    tosa_binfo.kernel_filename = kernel_filename;\n\n    tosa_binfo.kernel_cmdline = kernel_cmdline;\n\n    tosa_binfo.initrd_filename = initrd_filename;\n\n    tosa_binfo.board_id = 0x208;\n\n    arm_load_kernel(mpu->cpu, &tosa_binfo);\n\n    sl_bootparam_write(SL_PXA_PARAM_BASE);\n\n}\n", "idx": 11193, "substitutes": {"machine": ["controller", "engine", "instance", "green", "iso", "link", "handler", "model", "connection", "keeper", "cell", "hard", "command", "mac", "sim", "shell", "vm", "hello", "money", "device", "process", "space", "host", "monitor", "achine", "zone", "server", "domain", "history", "dem", "smart", "Machine", "node", "module", "m", "power", "manager", "gate", "chain", "check", "mc", "cpu", "mode", "template", "message", "state", "me", "image"], "cpu_model": ["cpuwarerelation", "cpu_label", "pu_type", "cpuityimage", "cpu_image", "pixel_label", "pu_label", "cpu_link", "cpu_brand", "cpuitybrand", "cpu_mode", "cpuitymode", "cpuwaremodel", "pu_relation", "pu_brand", "pu_image", "cpuitymodel", "pixel_link", "cpu_type", "cpuwaremode", "pu_model", "pixel_class", "pixel_model", "cpu_relation", "cpu_class", "cpuwaretype", "pu_mode"], "kernel_filename": ["ernel_filename", " kernel_via", "kernel___uri", "kernel_via", "ernel_uri", " kernel_fn", "kernelphpfilename", "ernel_command", "kernel32username", "kernel___filename", "kernel_nom", "kernelphpcommand", "kernel32via", "kernel32fn", "kernel___command", " kernel_username", "kernel___fn", "ernel_location", "ernel_username", "kernelphpfile", "kernelphpuri", "kernelitynom", "ernel_nom", "kernel___file", "kernel___via", "kernel_file", "kernelityFilename", "kernel_Filename", "kernel___username", "kernel_fn", "kernel32filename", "kernelityfile", "kernel_uri", "ernel_Filename", "kernel_username", "kernel_command", "kernelityfilename", "ernel_file", "kernel_location"], "kernel_cmdline": ["kernel_catline", "kernel_controlline", "kernel_controllines", "kernel_cmdLine", "kernel_catcall", "kernel_catLine", "kernel_paylines", "kernel_cmdlines", "kernel_commandword", "kernel_cssword", "kernel_cmdle", "kernel_cssLine", "kernel_cmdword", "kernel_extine", "kernel_cmdcall", "kernel_payle", "kernel_commandline", "kernel_extline", "kernel_commandLine", "kernel_cssline", "kernel_mdcall", "kernel_extle", "kernel_cmdine", "kernel_mdLine", "kernel_commandle", "kernel_mdline", "kernel_commandlines", "kernel_extlines", "kernel_controline", "kernel_payline", "kernel_mdword", "kernel_commandcall", "kernel_commandine"], "initrd_filename": ["initrdptfile", "initrd_file", "initrs_file", "initrdptdatabase", "initrd_where", "initrs_filename", "initrd___source", "initrd_database", "initrd_username", "initrs_Filename", "initara_function", "initrb_file", "initrd__filename", "initrd___function", "initrb_database", "initrd__where", "initrd___database", "initrd___file", "initrd___module", "initrr_where", "initrdptstring", "initrd_module", "initrd_string", "initrdaphfunction", "initrd__username", "initara_source", "initrs_creation", "initrb_string", "initara_filename", "initrd_Filename", "initrdptfilename", "initrdaphmodule", "initrr_filename", "initrr_files", "initrd__files", "initara_module", "initrdaphfilename", "initrd___filename", "initrr_username", "initrd_function", "initrdaphsource", "initrb_filename", "initrd_source", "initrd___string", "initrd_creation", "initrd_files"], "address_space_mem": ["address_space_Mem", "address_area_ram", "address_space_ram", "address_space_ref", "address_space5rom", "address_space5ram", "address_space_buf", "address_space5mem", "address_space_memory", "address_area_mem", "address_area_memory", "address_space_rom"], "rom": ["prem", "mm", "cr", "ra", "mem", "irm", "rs", "region", "roma", "cm", "gem", "sem", "ri", "rim", "mor", "tm", "rep", "usr", "gra", "ran", "rob", "rem", "rm", "sr", "rg", "ru", "arm", "rum", "ros", "serv", "chrom", "rain", "sam", "rib", "dem", "ro", "com", "mr", "reg", "rar", "ROM", "prom", "res", "im", "ram", "cpu", "bm", "drm"], "mpu": ["pptu", "mpcu", "pmtu", "ppi", "ampu", "scpu", "mta", "pmu", "mmus", "pmuu", "ppU", "cpi", "umpu", "mpiu", "mptu", "mppu", "scui", "MPo", "mto", "ppuu", "mtU", "mpui", "umu", "mmu", "mtpu", "cpiu", "mpo", "mtu", "sciu", "mmiu", "umus", "mpU", "poptu", "pppu", "mpuu", "mmU", "umiu", "popuu", "popcu", "pmcu", "cpU", "MPi", "cpa", "ampa", "ampus", "ppcu", "MPu", "cppu", "MPU", "scu", "cpus", "ppu", "mpus", "mpi", "mtus", "mmpu", "cpui", "mtiu", "popu", "MPus", "scus", "mtui", "mpa", "ampui", "MPpu", "cpu", "mmo"], "tmio": ["pmiol", "tmii", "tcao", "tciol", "tmao", "mmao", "vtIO", "mtio", "tnii", "tmo", "tomient", "pmotor", "pmii", "tnio", "tniol", "tnao", "pmio", "vtiol", "tcii", "vtio", "tmIO", "pmIO", "vtotor", "pmao", "mtIO", "mmient", "mtotor", "tmotor", "tomao", "tmiol", "tomio", "mmio", "tcio", "tnient", "mtiol", "tomo", "tno", "tmient", "mmo"], "scp0": [" scop080", "scpafrom", "scjp080", "scpa2", "scyp2", "scop0", "scp8", "scp2", "scjp1", "scap0", "scu00", "scjp8", "scvp1", " scop1", "scsp0", "scvp00", "scpi080", "scvpzero", " scp00", " scop0", "scuzero", " scp8", "scspfrom", "scpi8", " scvpzero", "scapzero", "scp00", "scu0", "scanp2", "scpi0", "scanyp0", "scanpfrom", "scsp2", "scpzero", " scvp0", "scop080", "scyp0", "scvp0", " scpzero", "scp080", "scap1", "scanyp2", "scap00", "scop1", "scanp0", "scpa0", "scypfrom", " scop8", "scpi1", " scvp1", " scp080", "scop8", "scanypfrom", "scpfrom", "scu1", "scjp0", " scvp00"], "scp1": ["scpa9", "scop0", "scap2", " scsp0", "scp2", "scp11", "scmOne", "escap4", "scpc0", "scsp0", " scop1", " scop0", "scop11", "scsp4", "escpOne", "escp1", " scp11", "scap4", "scpe11", "scpe0", "scp4", "escp2", "scm2", "scpe1", "scp9", "scpc9", " scp9", "scsp2", "escapOne", "escp4", "scspOne", " scop9", "scap1", "scop1", "scpc1", "scm4", "scpa0", "scpa1", "scsp1", "scapOne", "escap2", "scm1", " scsp11", "scop9", " scsp1", "scsp11", "escap1", "scpOne"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n", "idx": 11202, "substitutes": {"ibs": ["obsc", "ijh", "ibsol", " ibh", "ibjs", "ribd", "ibfs", "ippjs", "iams", "iamjs", "ibh", "obfs", "obs", " ibfs", "IBsol", "IBs", "ibsc", "IBjs", "ribfs", "ribs", "ijfs", "ipps", "ijs", "ribsc", " ibsc", "ippsol", " ibd", "ijjs", "IBfs", " ibjs", "IBh", "obd", "iamsol", "ibd"], "cmd": ["news", "send", "cli", "cb", "nd", "conf", "off", "seq", "job", "cont", "args", "exec", "op", "cfg", "iq", "auth", "command", "ct", "cd", "crit", "call", "good", "comm", "once", "raw", "forge", "patch", "config", "ctl", "cp", "md", "grad", "form", "mt", "Cmd", "ext", "act", "def", "desc", "cmp", "force", "ctx", "control", "ctrl", "req", "rn", "check", "prop", "cod", "batch", "pkg", "ctr", "bind", "msg", "pay"], "cmd_len": ["cmd__ref", "cmd_ref", " cmd_ref", " cmd_ls", "cmd__len", " cmd_lon", "cmd_ls", "cmd__lon", "cmd__ls", "cmd_lon"], "rsp": ["Rsw", "Rsp", "rdsw", "wsp", "Rpc", "rps", "wp", "Rresp", " rp", "rdsp", "rsw", " rsw", "rresp", "wps", "Rps", "Rp", " rpc", "rp", "wsw", "rdpc", " rps", " rresp", "rpc", "rdresp"], "rsp_len": ["rpt_size", "rpt_gen", "rpt_len", "rsp2gen", "rsp2size", "rsp2len", "rsp_size", "rsp2ls", "rsp_ls", "rsp_gen", "rpt_ls"], "max_rsp_len": ["max_rresp_Len", "max_rresp_length", "max_rsp_Len", "max_rsp_gen", "max_rsp_length", "max_rresp_len", "max_rresp_gen", "max_rsp2len", "max_rsp2Len", "max_rsp2gen", "max_rsp2length"], "sens": ["psens", "isans", "isends", "isens", "SENS", "seans", "cents", "teng", "gENS", "ceng", "seENS", "Sends", "pans", "sends", "gents", "Sans", "tans", "gens", "gans", " sent", "isent", "seng", "tent", "cens", "Seng", "Sents", "soss", " soss", "sent", " sents", "seensor", "tends", "seens", "sensor", " sENS", "tents", " sensor", "sans", "sents", "psents", "pensor", "tens", "pens", "psent", " seng", "pENS", "Sensor", "Sens", "sENS", "psensor", "iseng", "cent", "Sent", "tENS", " sans", "isoss", "Soss"]}}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n", "idx": 11235, "substitutes": {"base": ["cycle", "p", "h", "x", "se", "f", "i", "v", "id", "re", "kit", "name", "l", "key", "out", "space", "n", "null", "range", "store", "size", "server", "domain", "area", "bound", "b", "prefix", "a", "mb", "index", "pa", "handle", "bas", "ASE", "y", "bit", "set", "ref", "sys", "offset", "Base", "m", "c", "ip", "buffer", "pos", " bases", "res", "ase", "memory", "based", "pi", "bind", "address"], "irq": [" irqq", " irch", "mirqs", "irqu", "arq", "mirch", "irquant", "IRqi", " irqi", "pirqi", "arqi", "ibrqq", "irtch", "arqu", "ircqi", "irtq", "pirch", "ircq", "pirqu", "irch", " irqu", "irtqq", "ironch", "ironqi", "ibrq", "mirqq", "iriquant", "irtqs", "ircQ", "IRq", "ibrquant", "IRqu", "ircqu", "irqi", "IRQ", "arQ", "irQ", "irqs", "ironq", "ibrqi", "ironqu", "nirquant", "iriq", "nirqq", " irqs", "iriqq", "pirq", "nirq", "mirq", "iriqi", "irqq", "nirqi"], "fclk": ["flasskg", "fClkr", "fplke", " fflk", " fclp", "fblke", "fklp", "fClke", "fmlkr", "fmlke", " fclck", "flassk", "fflke", "fclkg", "fflck", "fllp", "fllke", " fflke", "fmlck", "fsclp", "fplk", "fclp", "fklk", " fllck", "fclck", " fllp", "fsclk", " fclke", "fflkr", " fflkr", "fflp", "fsclck", "fblk", "fblp", " fclj", "fflk", "fllck", " fllk", "fblkg", "fplp", "fmlk", "fclkr", " fplp", " fclkg", " fflck", "fblj", "fplj", "fklck", "fclke", "fclj", "fklke", "fClck", " fplk", " fplj", "flasske", " fplkg", "fClk", "fllk", "fplkg", "fflj", " fllke", "fsclke", " fplke", " fclkr"], "iclk": ["ircrlq", "iclch", "icdlq", "icrlk", "irclq", "irclk", "iclcke", "iclke", "icrlq", "irclch", "icrlch", "icrlke", "icdlke", "ircrlke", "iclq", "icdlch", "ircrlch", "icdlk", "iclcch", "ircrlk", "irclke", "iclck", "iclcq"], "txdma": ["txvdma", "txsdmas", "rtnmas", "txsdia", "rtnma", "rtdmas", "txsdMA", "txnia", "txdMA", "txvdmas", "txvdia", "rtnMA", "txnma", "rtdma", "rtdia", "txsdma", "txnMA", "txdia", "rtdMA", "txnmas", "rtnia", "txdmas", "txvdMA"], "rxdma": ["rdxda", "txdda", "tdxda", "rldmas", "rldda", "rdxmas", "rldma", "rxdmas", "rxdMA", "rldMA", "tdxMA", "txdMA", "rvdmas", "tdxma", "tdxmas", "rdxMA", "rxdda", "rvdMA", "rvdda", "rvdma", "rdxma", "txdmas"], "label": ["lab", "layout", "comment", "slot", "unit", "brand", "tag", "link", "type", "id", "role", "serial", "cell", "name", "l", "group", "els", "Label", "val", "key", "abel", "LAB", "local", "desc", "style", "control", "alias", "block", "loc", "ell", "description", "bel", "annot", "pal", "el", "msg"], "chr": ["CHdr", "echrs", "Chrs", "CHrs", "chrs", "echar", "echrd", "chdr", "Chrd", " chrs", " chrd", "CHar", "Char", "Chr", "echr", "chrd", "CHr", "Chdr", " chdr"], "s": ["r", "ts", "p", "ports", "changes", "h", "sb", "ats", "rs", "f", "v", "ls", "save", "i", "ss", "its", "settings", "es", "ers", "izes", "l", "ps", " is", "gs", "j", "acs", "sports", "comm", "sts", "tests", "space", "store", " os", "a", "fs", "sl", "g", "as", "b", "d", "is", "details", "bs", "pers", "ms", "os", "set", "js", "stats", "ds", "ns", "states", "m", "S", "c", "ists", "t", "status", "source", "spec", " sets", "services", "vs", "cs", "se", "w", "gets", "qs", "ins"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)\n\n{\n\n    VHDDynDiskHeader *dyndisk_header =\n\n        (VHDDynDiskHeader *) buf;\n\n    size_t block_size, num_bat_entries;\n\n    int i;\n\n    int ret = -EIO;\n\n\n\n    // Write the footer (twice: at the beginning and at the end)\n\n    block_size = 0x200000;\n\n    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);\n\n\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    // Write the initial BAT\n\n    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    memset(buf, 0xFF, 512);\n\n    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n\n        if (write(fd, buf, 512) != 512) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    // Prepare the Dynamic Disk Header\n\n    memset(buf, 0, 1024);\n\n\n\n    memcpy(dyndisk_header->magic, \"cxsparse\", 8);\n\n\n\n    /*\n\n     * Note: The spec is actually wrong here for data_offset, it says\n\n     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.\n\n     */\n\n    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);\n\n    dyndisk_header->table_offset = be64_to_cpu(3 * 512);\n\n    dyndisk_header->version = be32_to_cpu(0x00010000);\n\n    dyndisk_header->block_size = be32_to_cpu(block_size);\n\n    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);\n\n\n\n    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));\n\n\n\n    // Write the header\n\n    if (lseek(fd, 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (write(fd, buf, 1024) != 1024) {\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 11268, "substitutes": {"fd": ["func", "ld", "dev", "bf", "cb", "df", "ff", "fat", "f", "dd", "pid", "vol", "actor", "handler", "std", "gd", "fc", "lf", "cond", "fed", "uf", "fr", "window", "hd", "eg", "dl", "dt", "fb", " fid", "ctl", "fa", "feat", "fs", "buff", "td", "dir", "d", "file", "form", "fn", "gz", "FD", "handle", "fl", "sd", "elt", "fp", "ctx", "fi", "ds", "fin", "io", "ud", "buffer", "db", "stream", "ptr", "fax"], "buf": ["aka", "bin", "pack", "data", "cam", "fb", "buff", "cache", "var", "arr", "ref", "Buff", "db", "rb", "batch", "pkg", "ptr", "w", "Buffer", "fw", "cmd", "attr", "cont", "ob", "good", "raw", "bl", "obj", "bar", "bt", "act", "foo", "desc", "it", "wb", "txt", "buffer", "block", "bg", "orig", "msg", "cap", "pb", "cur", "uf", "window", "out", "bag", "tmp", "iter", "b", "bytes", "tr", "kb", "ctx", "vec", "bu", "br", "rw", "doc", "cb", "bf", "proc", "BU", "ff", "v", "alloc", "bc", "uffer", "cv", "tab", "queue", "box", "img"], "total_sectors": ["total_veves", "total_spellers", "total_serves", "total_selements", "total_vecs", "total_secs", "total_speors", "total_serctors", "total_velements", "total_psellers", "total_serors", "total_pseors", "total_vectors", "total_psectors", "total_psecs", "total_seors", "total_vellers", "total_sellers", "total_serlements", "total_specs", "total_seves", "total_spectors", "total_veors"], "dyndisk_header": ["dyndiff_manager", "dyndiff_magic", "dyndiskityhandler", "dyndiff_handler", "dyndisk_wrapper", "dyndiskdbmodule", "dyndiff_header", "dyndiff_Header", "dyndiff_data", "dyndiff_writer", "dyndisk_data", "dyndisk_manager", "dyndiff_list", "dyndiskdbheader", "dyndiskitymanager", "dyndisk_list", "dyndisk__head", "dyndiff_info", "dyndiff_module", "dyndisk_buffer", "dyndisk_writer", "dyndisk_head", "dyndisk_module", "dyndisk__list", "dyndiff_profile", "dyndisk_profile", "dyndisk_Header", "dyndiskdbaverage", "dyndisk_info", "dyndisk_handler", "dyndiff_buffer", "dyndisk_average", "dyndiskmopmagic", "dyndiskmopheader", "dyndiskityheader", "dyndiskityhead", "dyndiff_wrapper", "dyndisk_headers", "dyndisk_magic", "dyndiskdbhead", "dyndiff_head", "dyndisk__buffer", "dyndiskmopmanager", "dyndiff_headers", "dyndiskmophead", "dyndisk__header", "dyndiff_average"], "block_size": ["disk_description", "Block_SIZE", "block_Size", " block_name", "line_height", " block_start", "disk_count", "line_cache", "blockPstart", "block_start", "blockPSize", "disk_SIZE", "line_size", "block_count", "line_Size", "block_source", "blocklysource", "disk_size", "blocklySize", "block_height", "Block_source", "block_description", " block_SIZE", "block_name", "blockPsize", "Block_Size", "blocklySIZE", "Block_window", "block_cache", "blocklysize", "block_SIZE", "Block_size", " block_Size", "block_window"], "num_bat_entries": ["num_bat_ntrys", "num_bat_entrys", "num_bat_ntries", "num_bat_matires", "num_bat_entsrys", "num_bat_matries", "num_bat_enties", "num_bat_sentires", "num_bat_entues", "num_bat_Entires", "num_bat_ntry", "num_bat_addrys", "num_bat_serys", "num_bat_series", "num_bat_seresses", "num_bat_entryries", "num_bat_addriers", "num_bat_addries", "num_bat_entryrys", "num_bat_entryarts", "num_bat_entsresses", "num_bat_sentries", "num_bat_Entriers", "num_bat_entry", "num_bat_Enties", "num_bat_sentrys", "num_bat_entryies", "num_bat_Entresses", "num_bat_entarts", "num_bat_entsries", "num_bat_entresses", "num_bat_seories", "num_bat_Entarts", "num_bat_Entry", "num_bat_ntriers", "num_bat_Entrys", "num_bat_entsories", "num_bat_sentues", "num_bat_addresses", "num_bat_Entries", "num_bat_entories", "num_bat_matues", "num_bat_entires", "num_bat_entriers", "num_bat_matrys", "num_bat_Entories", "num_bat_Entues"], "i": ["ui", "di", "p", "h", "x", "f", "v", "gi", "ai", "ind", "l", "ii", "j", "xi", "sim", "I", "phi", "ix", "iu", "ex", "multi", "u", "bi", "n", "me", "in", "b", "g", "print", "si", "index", "try", "li", "info", "y", "ini", "q", "it", "ci", "m", "c", "t", "ip", "mi", "zi", "chain", "qi", "ti", "im", "pi", "ki", "k", "by"]}}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 11303, "substitutes": {"bs": ["ts", "sb", "rs", "aos", "ls", "BS", "pb", "ss", "its", "bp", "bc", "obs", "ps", "gs", "ubs", "bl", "fs", "bh", "b", "lbs", "os", "ms", "bis", "js", "bes", "hs", "ds", "bits", "aus", "vs", "cs", "us", "ns"], "psn_tab": ["psn_map", "psn___map", "psn_Tab", "psns_Tab", "psn____tab", "psn____reg", "psn_cell", "psn___Tab", "psns_tab", "psn____map", "psn_buf", "psn___buf", "psns_reg", "psns_cell", "psn___reg", "psns_buf", "psns_map", "psn___cell", "psn___tab", "psn_reg", "psn____Tab"], "s": ["ts", "p", "less", "h", "sb", "rs", "v", "ls", "sp", "ss", "its", "ps", "gs", "sts", " ss", "sv", "fs", "b", "is", "ins", "os", "sn", "js", "sys", "hs", "ds", "stats", "S", "c", "t", "vs", "cs", "ns"], "sn_info": ["sn_INFO", "nn_type", "connect_success", "snobjcount", "syn_type", " sn_INFO", "sn__comment", "nn__type", "syn_fo", "sn__type", "snap_information", "honjinfo", "sn__INFO", "sn_comment", "sn7type", "syn_info", "hon_information", "sn8INFO", "sn_name", "snmdinf", "sn__fo", " sn_state", "cn_details", "honjlink", "snistinformation", "sn7info", " sn_success", "hon_info", "hon_link", "nn_list", "snjinfo", "sn_information", "nn_INFO", "nn__list", "honjinformation", "pn_fo", " sn_comment", "sn_success", "snap_info", "sn__list", "sn7INFO", "sn8details", "sn_link", "sn_check", "sn_type", "sn8info", "cn_inf", " sn_inf", "snjinformation", "honjname", "snistinfo", "hon_name", "sn__info", "snobjinfo", "sn_list", " sn_fo", "nn__info", "connect_info", "sn_state", "sn_details", "connect_information", "sn_fo", "snobjfo", "snobjlist", "syn_INFO", "cn_info", "pn_INFO", "pn_check", "snjname", "sn8type", "pn_info", "sn_inf", "sn_count", "snmdinfo", "snjlink", "syn_count", "nn__INFO", "snistname", "connect_inf", "nn_info", "snmddetails", "syn_details", "syn_list", "sn7list"], "sn_tab": ["snap_tab", "nlaxyctrl", "snxtab", "snap_db", "snap_track", "sn__Tab", "Sn_tab", "snjabs", "snaxytab", "sn_ctrl", "snaxyctrl", "snaxylab", "sn_tmp", "snap_Tab", "sn_buf", "sn_bag", "sn8tab", "snjinfo", "snxlab", "nn_lab", "sn__buf", "Sn_bag", "snaxyTab", "snxinfo", "sn__track", "sn8Tab", "snjlab", "nlaxytab", "snjtab", "sn__db", "nn_tab", "nl_tab", "sn__tab", "sn_db", "snxabs", "sn_abs", "sn8lab", "Sn_tmp", "sn_track", "sn_lab", "nlaxylab", "nl_ctrl", "sn__tmp", "nn_abs", "nl_lab", "sn8ctrl", "nn_info", "Sn_buf", "sn_Tab", "nlaxyTab", "sn__bag", "nl_Tab"], "i": ["ami", "cli", "x", " ti", "json", " ii", "ind", "ix", "iu", "bi", "remote", "index", "li", "\u0438", "c", "t", "batch", "ti", "series", "k", "h", "gi", "ic", "iq", "ei", "I", "phi", "ie", "info", " bi", "it", "qi", "mi", "ij", "status", "ki", "ims", "me", "ui", "p", "init", "l", "xi", "sim", "ex", "multi", "slice", "is", "y", "ini", "ci", "pi", "e", "di", "f", "v", "ri", "ai", "ii", "j", "ji", " mi", "n", "in", "hi", "si", " ni", "m", "ip", "zi", " j", "point", "im", " si"], "snap_count": ["capt_total", "nav64count", "snap32list", "snapptnum", "snap_current", "snap64data", "snap_cache", "span_current", "capt_count", "snap_entry", "snap_status", "sn_sum", "snap64entry", "sn_cache", "snitycount", "nav_num", "span_counter", "nav_cmd", "spanjcounter", "snap32check", "ap_info", " snap_len", "snapXct", "spanjcount", "snapitycheck", "snapitycount", "snap___count", "snapptdata", "snapjcounter", "nav64cmd", "snapCountlen", "snap64total", "snap_cycle", "snap_cell", "snapitystatus", "snap1count", "snap1status", "snapjcurrent", "snap1check", " snap_cycle", "snap32cycle", "snapCountct", "snap_list", "spanjentry", "sn_Count", " snap_list", "nav64num", "nav64data", "snap_Count", "span_entry", "snitystatus", "snap64len", "ap_nb", " snap_ct", "capt64total", "snap_sum", " snap_flag", "snitycache", "snapXcount", "capt64num", "capt64len", "snap_data", "capt_num", "snap_total", "snap_info", "snap_ct", "snap32counter", "snap_check", "sn_status", "sn_check", "snap32entry", "capt64count", "snapptcmd", "span_count", "snapitycache", "snap___num", "snapCountcount", " snap_Count", "snap64cmd", "snap1cache", "snap_num", "snapXCount", "sn_list", "snap64num", "snapjcount", "ap_sum", "snap___cmd", "snap64current", "snap32Count", "snapptcount", "nav_count", "snap_len", "nav_data", "snitycheck", "snap_flag", "snap64count", "snap64counter", "snap32current", "snap32cache", "snap_cmd", "sn_count", "snapjentry", "snap32count", "spanjcurrent", "capt_len", "snap_nb", "ap_count", "snap32status", "snapXlen", "snap___data", "snapCountCount", " snap_cell", "snap_counter"], "snaps": ["nnops", "cnap", " snapses", " snacs", " snats", "reshamps", "snap", "naps", "nacs", "nats", "swapped", "swacs", "snapats", "snapamps", " snps", "Snamps", "reshaps", "slaps", "swamps", "swops", "swaps", "snapims", "snps", "synops", "synats", "Sneps", "swapses", "reshacs", "cnaps", "Snaps", "sneps", "napses", "swats", "slops", "slapes", "slats", "snapaps", "nap", "nops", "synapes", "Snapses", " snops", "cnapped", " sneps", "Snats", "nnaps", "synaps", "snops", " snamps", "cnats", "snapped", "namps", " snims", "reshats", "swims", "snamps", "swap", "Snap", " snap", "snims", "snacs", "synapses", "nnats", "slps", "napped", "swps", "snats", "syneps", "snapses", "nnapes", "slacs", "snapes"], "snap_name": ["snap_resource", "snapJbase", " snap2name", "snJbase", "snap_text", "snapjtime", "snappttext", "snap_info", "snappttype", "sn_base", " snap_info", "snJtext", "sn_time", " snap2info", "sn_word", "snapJtype", "sn_type", "sn_name", "snap_base", " snap2label", " snap_resource", "snapJname", "sn_text", "snap2info", "snap_label", "snap2resource", "snap2time", "snap_type", "snap2word", "snJname", " snap_label", "snapjinfo", "snapameresource", "snapjname", "snapamename", " snap2resource", "snapJtext", "snapjword", "snapptname", "snap_time", "snapptbase", "snap2name", "snap_word", "snap2label", "snapameinfo", "snapamelabel", "snJtype"]}}
{"project": "qemu", "commit_id": "62c58ee0b24eafb44c06402fe059fbd7972eb409", "target": 0, "func": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,\n\n                                 MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                                 hwaddr *phys_ptr, int *prot, uint32_t *fsr)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    bool is_user = regime_is_user(env, mmu_idx);\n\n    int n;\n\n    int matchregion = -1;\n\n    bool hit = false;\n\n\n\n    *phys_ptr = address;\n\n    *prot = 0;\n\n\n\n    /* Unlike the ARM ARM pseudocode, we don't need to check whether this\n\n     * was an exception vector read from the vector table (which is always\n\n     * done using the default system address map), because those accesses\n\n     * are done in arm_v7m_load_vector(), which always does a direct\n\n     * read using address_space_ldl(), rather than going via this function.\n\n     */\n\n    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */\n\n        hit = true;\n\n    } else if (m_is_ppb_region(env, address)) {\n\n        hit = true;\n\n    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {\n\n        hit = true;\n\n    } else {\n\n        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {\n\n            /* region search */\n\n            /* Note that the base address is bits [31:5] from the register\n\n             * with bits [4:0] all zeroes, but the limit address is bits\n\n             * [31:5] from the register with bits [4:0] all ones.\n\n             */\n\n            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;\n\n            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;\n\n\n\n            if (!(env->pmsav8.rlar[n] & 0x1)) {\n\n                /* Region disabled */\n\n                continue;\n\n            }\n\n\n\n            if (address < base || address > limit) {\n\n                continue;\n\n            }\n\n\n\n            if (hit) {\n\n                /* Multiple regions match -- always a failure (unlike\n\n                 * PMSAv7 where highest-numbered-region wins)\n\n                 */\n\n                *fsr = 0x00d; /* permission fault */\n\n                return true;\n\n            }\n\n\n\n            matchregion = n;\n\n            hit = true;\n\n\n\n            if (base & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region base\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, base, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n            if ((limit + 1) & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region limit\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, limit, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!hit) {\n\n        /* background fault */\n\n        *fsr = 0;\n\n        return true;\n\n    }\n\n\n\n    if (matchregion == -1) {\n\n        /* hit using the background region */\n\n        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);\n\n    } else {\n\n        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);\n\n        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);\n\n\n\n        if (m_is_system_region(env, address)) {\n\n            /* System space is always execute never */\n\n            xn = 1;\n\n        }\n\n\n\n        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);\n\n        if (*prot && !xn) {\n\n            *prot |= PAGE_EXEC;\n\n        }\n\n        /* We don't need to look the attribute up in the MAIR0/MAIR1\n\n         * registers because that only tells us about cacheability.\n\n         */\n\n    }\n\n\n\n    *fsr = 0x00d; /* Permission fault */\n\n    return !(*prot & (1 << access_type));\n\n}\n", "idx": 11316, "substitutes": {"env": ["ami", "runner", "np", "ev", "center", "end", "en", "vm", "worker", "exc", "cp", "er", "te", "eu", "t", "pkg", "vp", "ptr", "state", "cmd", "conf", "sw", "docker", "enter", "shell", "org", "estate", "config", "obj", "vt", "serv", "kh", "ah", "eas", "set", "esm", "kernel", "et", "vs", "msg", "wall", "init", "conn", "eni", "environment", "era", "window", "server", "email", "viron", "st", "ctx", "home", "here", "nv", "e", "erd", "hw", "dev", "proc", "eng", "v", "network", "cv", "event", "net", "esp", "ner", "queue", "uv", "disk", "Environment", "context", "eco"], "address": ["r", "x", "ace", " Address", "uri", "condition", "region", "private", "type", "request", "addr", "i", "number", "location", "network", "name", "command", "interface", "date", "position", "route", "order", "process", "device", "range", "execute", "pointer", "domain", "a", "resource", "prefix", "index", "path", "shape", "attribute", "Address", "offset", "trace", "reference", "adr", "target", "ip", "buffer", "alias", "port", "base", "point", "memory", "ase", "description", "message", "action", "ptr", "host", "image", "operation", "error"], "access_type": ["access_address", "accessTypeaddress", "Access_address", "Access_info", "access2type", "access_info", "access2info", "access2Type", "accessTypeinfo", "accessTypeType", "accessTypetype", "Access_Type", "access_Type", "Access_type", "access2address"], "mmu_idx": ["mmu_dg", "mmu2idci", "mmu_lastv", "mmu_inci", "mmu_idexc", "mmu_lastp", "mmu_midv", "mmu_idy", "mmu2midci", "mmu_idv", "mmu_idci", "mmu2idx", "mmu_indexp", "mmu_idey", "mmu_idex", "mmu_indexxc", "mmu_Idy", "mmu_Idv", "mmu_inp", "mmu_idz", "mmu_idez", "mmu_Idg", "mmu2midv", "mmu_idg", "mmu2idv", "mmu_dy", "mmu_iny", "mmu_idp", "mmu_Idz", "mmu_midci", "mmu2idp", "mmu_inv", "mmu2midx", "mmu_dv", "mmu_Idp", "mmu_midx", "mmu_ideg", "mmu_midp", "mmu_idep", "mmu_indexg", "mmu_inx", "mmu_dx", "mmu_inz", "mmu2midp", "mmu_lastci", "mmu_indexx", "mmu_lastx", "mmu_Idx", "mmu_idxc"], "phys_ptr": ["phys_handle", "phys_ref", "physical_desc", "phys__addr", "phys__pointers", "phys__handle", "physical_ptr", "physical_ref", "phys_addr", "phy_handle", "physical_addr", "phys_desc", "phy_addr", "phys_pointers", "physlyaddr", "physlyhandle", "phys__ptr", "physlyptr", "phy_pointers", "physlypointers", "phy_ptr"], "prot": ["pro", "platform", "chron", "password", "slot", "eth", "type", "mult", "addr", "typ", "tz", "stat", "format", "version", "method", "dt", "channel", "Prot", "tif", "net", "virtual", "pattern", "ext", "fd", "tf", "lan", "iat", "pat", "priority", "phy", "status", "ocol", "port", "ping", "mode", "pc", "col", "ptr", "rot"], "fsr": ["wsrb", "msrs", "wssr", "tssr", "resrs", "fsrb", "resR", "ssR", "FSr", "fsrs", "msr", "ssrb", "FSR", "msR", "fsR", "FSrs", "ressr", "tsR", "FSsr", "FSvr", "tsr", "ssr", "FSrb", "resr", "mssr", "tsvr", "fssr", "fsvr", "wsr", "resvr", "sssr", "wsR"], "cpu": ["p", "runner", "np", "proc", "conn", "CPU", "mem", "gpu", "linux", "onet", "addr", "jp", "alloc", "cam", "tp", "processor", "nc", "vm", "ka", "cu", "nic", "process", "device", "cv", "cp", "prof", "core", "net", "phys", "machine", "node", "pu", "sys", "ctx", "bean", "c", "ip", "mx", "nu", "arch", "clock", "gc", "pc", "mu", "hw", "ram", "socket", "cn"], "n": ["ren", "x", "no", "np", "number", "N", "nc", "en", "wn", "ni", "count", "remote", "fn", "d", "index", "names", "min", "c", "t", "len", "k", "w", "mn", "ns", "h", "on", "un", "ng", "name", "an", "non", "new", " i", "note", "dn", "it", "cn", "p", "span", "conn", "i", "l", "out", "nt", "o", "ne", "g", " N", "b", "y", "sn", "node", "nor", "r", "ot", "nn", "next", "v", "nb", "z", "network", "na", "j", "ln", "nr", "in", "gn", "nan", "m", "num", "pos", "nu", "nw", "base"]}}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 11328, "substitutes": {"s": ["r", "ts", "p", "h", "sb", "ses", "rs", "f", "i", "sp", "ss", "es", "ps", "j", "sts", "iss", "n", "sq", "o", "fs", "sv", "is", "b", "d", "os", "sys", "ds", "m", "S", "c", "t", "e", "bs", "ns"], "pdu": [" plu", "psu", "plu", " puu", " pde", "wpuu", "pcu", "iptu", "dpsu", "ipdu", "puu", "ptu", "pdef", "pingbur", " pu", " psu", "pau", "wpdu", "pinguu", "dpdu", "ipsu", "dptu", "palu", "wpbur", "dpde", "pingdu", "pde", "pbur", "pu", "pclu", "ipde", "padef", "pcdef", " ptu", "padu", "pingsu", " pbur", "pcdu", "wpsu", " pdef"], "fidp": ["lfidp", "fadg", "foidj", "fbidpad", "fridpd", "fIdpy", "fmidP", "fadp", "fmidg", "lfidnp", "lfaidp", "fIdg", "fhotpa", "flidphp", "faidpd", "fidP", "fridnp", "fidnp", "fmidpy", "flidpad", "fmidp", "faidnp", "fidpd", "fardphp", "fidpad", "fidpy", "cidpy", "fadP", "fhotphp", "fardpad", "fIdp", "fbidpa", "fardpa", "foidpd", "lfidpd", "fbidphp", "flhotpad", "fidj", "faidj", "flhotp", "flidp", "flhotpa", "fardp", "cIdP", "lfidj", "cIdpy", "cidg", "flidpa", "cIdp", "flhotphp", "cidP", "fadpy", "faidp", "lfaidj", "fhotpad", "fridj", "foidnp", "lfaidnp", "fidphp", "fridp", "cidp", "fhotp", "fidpa", "fbidp", "fidg", "cIdg", "lfaidpd", "fIdP", "foidp"], "off": [" offset", "dev", "bf", "on", "fun", "OFF", "ff", "from", "attr", "offer", "addr", "op", "end", "pad", "start", "shift", "new", "raw", "ex", "after", "out", "over", "o", "buf", "offs", "Off", "ext", "of", "empty", "set", "ref", "ok", "reset", "offset", "now", "Offset", " OFF", "t", "pos", "et", "block", " Off", "aux", "cmd"], "max_count": ["maxCsize", " max_ount", "maxingonly", " max_Count", "maxfulcount", " max_sum", "maxitysize", "maxfulsum", "maxptmax", "max_sum", "maxingcount", "maxitycounter", "max_counter", "max_max", "maxfulCount", "maxityount", "maxitycount", " max_max", "maxptCount", "maxptcount", "maxptcounter", "maxCount", " max_only", "max_Count", " max_size", "max_ount", "maxCcount", "max_size", "maxfulonly", "maxitymax", "maxingsum", "maxityCount", "max_only", "maxingCount", " max_counter"], "err": ["extra", "dr", "type", "cfg", "ind", "fr", "erer", " Err", "probably", "buf", "errors", "count", "er", "arr", "go", "sys", "mr", "rar", "fer", "kr", "js", "len", "outer", "beta", "later", "timer", "ptr", "state", "eor", "aer", "cmd", "cr", "conf", "addr", "fee", "ei", "lr", "code", "org", "Error", "order", "rss", "notice", "margin", "cer", "core", "gz", "ah", "eas", "trace", "req", "txt", "status", "res", "msg", "peer", "or", "aaa", "hr", "Er", "yr", "coord", "dy", "warn", "str", "result", "ered", "ier", "size", "iter", "server", "diff", "try", "late", "none", "elt", "cmp", "oe", "br", "here", "e", "ctr", "length", "error", "r", "die", "rr", "alloc", "plain", "norm", "usr", "ner", "css", "offset", "resp", "score", "hz"], "read_count": ["read67num", "readablelen", "readptlen", " read_c", "readityoffset", "read_len", "read_rate", "user_count", "reading_data", "readptoffset", "readablelog", "user67num", "error_log", "read_cmd", "read64Count", "readptnum", "reading_code", "read64count", "read_Count", "readlenCount", "read_length", "read00count", "Read_Count", "readptcode", "read00Count", "read00rate", "read67count", "read00data", "errorablethis", "read_num", "read_counter", "readitycounter", "user_len", "readitycount", "readingptcode", "reading_rate", "reading00rate", "readablethis", "errorablecounter", "read_cont", "read67len", "read_offset", "Read_count", "readable_cont", "readingptcmd", "reading_count", "reading00Count", "errorablecount", "readablenot", "readabletime", "error_counter", "readlencount", "readablenum", "readptcount", "readitythis", "readable_length", "readable_count", "user67len", "read64data", "read64rate", "read67not", "read_log", "reading_cmd", "reading_Count", "read_this", " read_time", "read_time", "readlencmd", "read_data", "readCounttime", "readCountcount", " read_Count", "readitycmd", "Read_cmd", "readablecount", "readitylog", "error_count", "reading00data", "user_num", "error_this", "readCountc", "readablecounter", "errorablelog", "readptnot", "readptcmd", "readingptcount", "readablelength", "read_not", " read_length", "user67not", "read_code", "readitycode", "user_not", "reading_offset", "user67count", "readableCount", "reading00count", "read_c", "readingptoffset"], "xattr_len": ["xattr2elt", "xattribute2len", "xattr_elt", "xatt_vec", "xattribute_elt", "xatt_val", "xatt_length", "xattribute2val", "xattr_Len", "xatt_size", "xattribute2Len", "xattribute2elt", "xattr2val", "xattr_vec", "xatt_Len", "xatt_len", "xattr_length", "xattr2Len", "xattr2len", "xattribute_val", "xattribute_Len", "xattr_val", "xattr2vec", "xattr_size", "xattribute_len"], "v": ["r", "p", "av", "h", "x", "f", "i", "vr", "l", "ver", "j", "vm", "volt", "va", "u", "n", "o", "sv", "vt", "ov", "b", "g", "d", "tv", "mint", "y", "q", "V", "m", "c", "uv", "t", "nv", "vs", "e", "vp", "w", "conv"], "elem": ["velement", "elev", "noteem", "pele", "inelem", "velem", "velems", "nelem", "beelement", "belem", "inelev", "peem", "velev", "semm", " element", "emm", "elems", " elev", "belement", " emm", "nelement", "neem", "eem", "notelem", "noteelement", "eelement", "seem", "inelems", "ele", "pemm", " eem", "sele", "neelement", "selem", "notelement", "pelem", "inelement", "beem", " elems", "element", " ele"]}}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "substitutes": {"bs": ["ts", "boxes", "bf", "sb", "blog", "rs", "aos", "outs", "bos", "uts", "ls", "BS", "ss", "its", "bp", "bc", "obs", "cks", "gs", "bb", "ubs", "sts", "iss", "bl", "bi", "fs", "bh", "b", "lbs", "bas", "bis", "js", "bes", "hs", "ds", "ubis", "bing", "bits", "bps", "aus", "vs", "cs", "bm", "qs", "ns"], "sector_num": ["sector_orig", " sector_orig", "sector_mon", "sectoritynum", "sectorityorig", " sector_index", "sectoritynb", " sector_number", "sector_index", "sectoritymon", "sectorityindex", "sector_nb", " sector_nb", "sector_number", "sectoritynumber", " sector_mon"], "buf": ["cb", "aka", "seq", "proc", "mem", "bin", "cat", "cap", "ff", "err", "pack", "data", "pb", "result", "uf", "map", "window", "new", "raw", "bag", "cv", "buff", "enc", "b", "bytes", "tab", "queue", "ref", "Buff", "box", "vec", "br", "wb", "text", "prop", "buffer", "batch", "block", "rb", "rw", "msg", "doc", "Buffer", "img", "cmd"], "nb_sectors": ["nb_serors", "nb_vectors", "nb_ensegments", "nb_serers", "nb_ensectors", "nb_bectors", "nb_peors", "nb_enseors", "nb_pelements", "nb_begments", "nb_serctors", "nb_seors", "nb_enserers", "nb_segments", "nb_velements", "nb_sergments", "nb_veors", "nb_selements", "nb_berers", "nb_pegments", "nb_vegments", "nb_beors", "nb_verers", "nb_pectors", "nb_serlements"], "ret": ["r", "ts", "flag", "RET", "ft", "rs", "rev", "f", "cont", "xt", "re", "l", "result", "gt", "Ret", "ert", "val", "rem", "ern", "out", "nt", "rets", "print", "mt", " alt", " fut", "ext", "tr", "rt", "ref", "set", "inter", "txt", "t", "len", "res", "status", "ll", "det", "resp", "alt", "gc", "ter"], "s": ["ts", "less", "h", "ats", "conf", "ses", "rs", "ls", "sp", "ss", "its", "als", "ps", "gs", "j", "sts", "iss", "ess", "sq", " ss", "a", "fs", "sl", "is", "serv", "g", "sam", "ins", "ms", "os", "bis", "js", "sys", "stats", "ds", "S", "sis", "spec", "cs", "ims", "w", "qs", "ns"]}}
{"project": "qemu", "commit_id": "968fc24d843c9e9b24231ca1960b47ef2fc724ea", "target": 1, "func": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n\n                         uint8_t *dst, int dlen)\n\n{\n\n    uint32_t zrun_len = 0, nzrun_len = 0;\n\n    int d = 0, i = 0;\n\n    long res, xor;\n\n    uint8_t *nzrun_start = NULL;\n\n\n\n    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %\n\n               sizeof(long)));\n\n\n\n    while (i < slen) {\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] == new_buf[i]) {\n\n            zrun_len++;\n\n            i++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed */\n\n        if (!res) {\n\n            while (i < slen &&\n\n                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {\n\n                i += sizeof(long);\n\n                zrun_len += sizeof(long);\n\n            }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n", "idx": 11359, "substitutes": {"old_buf": [" old_uf", "old_batch", " old_buffer", "new_rb", "olditybuffer", "new_buffer", "old__vec", " old_arr", "new_buff", "_", "old_buff", "new_batch", "new_queue", "oldJbin", "oldJbuf", "bl", "new_msg", "old_bin", "new_vec", "old_rb", "oldJqueue", "old__queue", "old__buf", "old_arr", " old_buff", "old_msg", "old_vec", "old_pool", "oldJbuffer", " old_pool", "bool", "oldityrb", "old_buffer", "func", "oldJbatch", "olditybuf", "old_uf", "new_bin", "old_queue", "old__buffer", "olditybuff"], "new_buf": ["new___buff", " new_doc", "new___buffer", "newgrbuffer", "new_buffer", "old_cv", "newptdoc", " new_buff", "new_buff", "newgrbuf", " new_queue", "old_buff", "newptbuffer", "newgrqueue", "newgrbuff", "newptqueue", "new_queue", "old_data", "old_bin", "new_cache", "new___vec", "newptcache", "new_vec", "new_doc", "new___buf", "new___Buff", " new_buffer", "newptbuff", "new_Buff", "re_buff", "re_buf", "new_uf", "old_vec", "new___bin", "newptbuf", "new___data", "re_cache", "old_buffer", "old_Buff", "new_cv", "new_data", "old_uf", "new_bin", "re_queue"], "slen": ["Slen", "loen", "sslEN", "shenum", "shoen", "slang", "kllen", "islen", "selatten", "slatten", "islatten", "SlEN", "klatten", "Slent", "mlun", "mlen", "sslatten", "len", "islenum", " slEN", "sslan", "splend", "SLen", "mlent", "slenum", "SLEN", "shend", "ssloen", "slens", "SLength", "sleng", "Sllen", "scheatten", "islens", "slend", "slent", "Slatten", "Slenum", "splEN", "sslens", "SLeng", "Slang", "SLoen", "isloen", "islem", "klEN", "shen", "sploen", "shent", "splan", "isleng", "SLens", "mlatten", "sslen", "scheen", "scheens", "scheoen", "shem", "slEN", "SLatten", "klen", "shatten", "latten", "ssllen", "selen", "Slem", "shan", "splens", "splen", "sloen", "islang", "leng", "selens", "sslend", "slun", "spleng", "Slend", "shang", "splem", " slength", "sllen", "seloen", "sslem", "slength", "slem", "ssleng", "slan", "splatten", " slens", "splength", "Slun", "shun"], "dst": ["sdsts", "sdst", "newbr", "ddest", "sddest", " dest", "Dest", "Dbr", "newST", "sdbr", "Dst", "dnd", "DST", " dnd", "newsts", "sdest", "sdnd", "Dnd", "dsts", "newst", "Dsts", "dST", "sdST", "dbr", " ddest", "dest", "Ddest"], "dlen": ["endLen", "hlen", "Dcmp", "dsl", "nsl", "dLen", "xcmp", "Dfl", "rlength", "endlen", "xlength", "hsl", " dlength", "Dlen", "hlength", " dfl", "dfl", "endfl", "dlength", "rLen", "hLen", "DLen", "Dlength", "nlen", "dcmp", "xlen", "rcmp", "nlength", "xLen", "nLen", " dLen", " dsl", "rlen"], "res": ["dr", "err", "clean", "ver", "resources", "rez", "progress", "resh", "remote", "d", "rest", "has", "def", "Res", "arr", "ref", "js", "sys", "reg", "ms", "rel", "ins", "ns", "red", "successful", "ret", "ps", "new", "ress", "resource", " compress", "expr", "nil", "max", "gr", "req", "yes", "status", "prime", "vs", "cs", "p", "resolution", "cons", "init", "pres", "final", "windows", "sol", "confirmed", "pre", "vol", "id", "result", "rem", "out", "RES", "os", "times", " Res", "chain", " residual", "mask", "reed", "us", "fresh", "r", "vals", "rs", "rev", "success", "ri", "re", "cond", "j", "val", " RES", "details", "reset", "m", "bits", "base", "resp", "results"], "xor": ["wxor", "xxorm", "ixmor", "xorer", " Xor", "wxore", "ixor", " xorm", "xori", " xOR", "ixOR", "xxor", "xore", "zOR", " xors", " Xors", "zore", "wxorer", "xxori", "xxOR", "zmor", " xmor", "rxOR", "ixore", " xorer", "xmor", " xore", "axorm", " Xorer", "axori", "rxore", "xOR", " Xore", "xorm", " xori", "axor", "zor", "axOR", "wxOR", "rxor", "xors", "rxors", "wxors"], "nzrun_start": ["nzrunptbegin", "nzrun_begin", "nzrun_size", "nzrun_end", "nzrunptend", "nzRun_start", "nzRun_size", "nzRun_begin", "nzRun_end", "nzrunptlen", "nzRun_len", "nzrunptstart", "nzrunptsize"], "i": ["ui", "di", "p", "ami", "cli", "x", "iii", "init", "h", "ma", "ims", "uri", "gi", "ri", "ic", "ai", "id", "ind", "l", "ei", "ii", "j", "xi", "ji", "I", "phi", "ix", "iu", "oi", "multi", "bi", "n", "in", "o", "iter", "is", "b", "d", "hi", "si", "index", "ie", "s", "li", "info", "y", "ini", "iat", "fi", "it", "\u0438", "ci", "m", "c", "io", "t", "ip", "mi", "ij", "qi", "zi", "iri", "ti", "ia", "im", "pi", "ki", "me", "ori", "item"], "zrun_len": ["zrunnerxlen", "zrun0start", "zrun_buf", "zran_compl", "zrunner_len", "zrunner_loc", "zrun_Len", "zran_num", "zrun_val", "zran_limit", "zrun__ln", "zrunnerxloc", "zran_len", "zrunxloc", "zrunxlen", "zrunnerxdl", "zrun_set", "zrunxdl", "zrun0len", "zrun67Len", "zrun67len", "zrun__len", "zrunnerxstart", "zrun0loc", "zran_ln", "zrunptln", "zran_Len", "zrun_ln", "zrunner_dl", "zrunptnum", "zrun__limit", "zrunxstart", "zrun__compl", "zrun_la", "zrun67elt", "zrun_num", "zrun67la", "zrunner_start", "zrun_loc", "zrunptlen", "zrun0dl", "zrun_elt", "zrun_dl", "zrun_start", "zrun_compl", "zrunptLen", "zrun_limit"], "nzrun_len": ["nzrun2gen", "nzrun2num", "nzru_Len", "nzrun_num", "nzname_num", "nzru_lim", "nzru_mem", "nzname_gen", "nzrun_lim", "nzrun_gen", "nzname_len", "nzrun2buf", "nzrun_buf", "nzrun_mem", "nzrun_Len", "nzrun2len", "nzru_len", "nzname_buf"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static av_cold void init_atrac3_transforms(ATRAC3Context *q) {\n\n    float enc_window[256];\n\n    int i;\n\n\n\n    /* Generate the mdct window, for details see\n\n     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */\n\n    for (i=0 ; i<256; i++)\n\n        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;\n\n\n\n    if (!mdct_window[0])\n\n        for (i=0 ; i<256; i++) {\n\n            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);\n\n            mdct_window[511-i] = mdct_window[i];\n\n        }\n\n\n\n    /* Initialize the MDCT transform. */\n\n    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);\n\n}\n", "idx": 11361, "substitutes": {"q": ["p", "x", "Q", "h", "qq", "dq", "f", "v", "ck", "qu", "z", "iq", "query", "cc", "qt", "rc", "qa", "u", "sq", "cv", "o", "g", "eq", "tx", "qi", "t", "w", "qs"], "enc_window": ["enc7stack", "valid_window", "encallwindow", "encallheight", "ec_table", "enc_windows", "enc_buffer", "ec_stack", "ec_profile", "ec_vector", "enc___storage", "enc_stack", "enc_device", "enc_win", " enc_win", "enc_vector", "enc___width", "ec_window", "ENC_stack", "valid_height", "ec_width", "enc___height", "enc8height", "ENC_window", "ec_windows", "enc_table", "enc2window", "enc_profile", "enc12windows", "enc___device", "enc12window", "enc7window", "enc___buffer", " enc_windows", "validallwindow", "ec_buffer", "enc8window", "ENC_device", "enc7table", "enc_width", "encalldevice", "enc___window", "enc8device", "enc2stack", "encallstorage", "enc_tree", " enc_data", "enc7vector", "enc2buffer", "enc_storage", " enc_tree", "enc8storage", "valid_device", "validallstorage", "enc_height", "validallheight", "enc_data", "enc12data", "validalldevice", "enc12tree", "enc___windows", "ENC_buffer", "enc___stack", "enc2device", "valid_storage"], "i": ["ami", "cli", "x", "dr", " ti", "err", " ii", "ind", "ix", "iu", "u", "bi", " I", "print", "index", "to", "li", "\u0438", "io", "t", "ti", "source", "jp", "h", "gi", "ic", "ei", "I", "phi", "ik", "like", "one", "info", " bi", "it", "qi", "mi", "ij", "status", "ki", "me", "ims", "ui", "p", "uri", "id", "l", "xi", " ki", "sim", "oi", "at", "ex", "multi", "o", "g", "is", "s", "try", "y", "ini", "fi", "ci", "chain", "pi", "e", "us", "di", "f", "v", "ri", "ai", "es", "ii", "j", "ji", "key", "in", "hi", "si", " li", "m", "zi", "ip", " j", "point", "im", "client"]}}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "substitutes": {"dcl": ["dnfl", "dnCL", " dCL", " dfl", " dsc", "dsc", "deCL", "dfl", "dCL", "decl", "dnsc", "dncl", "desc", "defl"], "ds": ["ts", "ld", "dev", "sta", "ats", "dx", "ims", "edes", "cmd", "rs", "dq", "ods", "ls", "dd", "der", "args", "ss", "its", "ows", "dp", "dds", "ps", "xs", "gs", "ys", "hd", "dl", "ops", "Ds", "dt", "ads", "DS", "sts", "qt", "dos", "des", "pd", "da", "rets", "md", "d", "uds", "ysis", "irs", "eps", "os", "def", "dat", "sd", "desc", "ks", "iris", "js", "sys", "hs", "vd", "ists", "dies", "db", "vs", "asi", "eds", "cs", "tes", "bs", "qs", "ants", "ns"], "s": ["changes", "sb", "ses", "ls", "comm", "south", "sv", "as", "d", "sam", "js", "sys", "c", "t", "eds", "se", "ms", "w", "ins", "ns", "less", "h", "ats", "conf", "sw", "ies", "ps", "terms", "parts", "sq", "obj", "a", "fs", "sl", "ysis", "q", "set", "stats", "services", "vs", "cs", "ims", "gets", "ports", "p", "i", "sa", "its", "l", "ops", "store", "g", "is", "b", "eps", "os", "hs", "styles", "so", "ts", "rs", "v", "ss", "z", "als", "gs", "j", "sts", "n", "plays", "details", "bs", "m", "S", "spec", "qs"], "kind": [" kinds", "func", "font", "instance", "metadata", "cmd", "brand", "type", "from", "rank", "k", "tag", " Kind", "id", "stuff", "data", "method", "ind", "name", "reason", "needed", "str", "kick", "interface", "family", "school", "key", "like", "pick", "ke", "kg", "choice", "need", "dir", "kid", "dk", "index", "work", "def", "mk", "what", "smart", "shape", "info", "desc", "style", "kernel", "part", "kt", "sk", "kw", "division", "nick", "mode", "context", "pkg", "magic", "sch", "cost", "spec", "Kind"], "stride": ["trider", "bride", "strine", "slide", "charide", "strider", " strider", "striride", "brue", "charride", "striides", "brine", "strride", "strope", "charides", "trine", "divide", "striide", "sline", " strride", "strape", "strides", "slider", " strope", "striope", "divride", "divape", "slue", "tride", " strape", " strides", "strue", "true", "charope", "slride", "slape", "divider", "brider"], "req": ["r", "require", "dist", " q", "fy", "qq", "seq", "Requ", "mem", "dq", "request", "err", "rr", " requ", "jp", "iq", "ind", "needed", "ps", "crit", "cond", "j", "usr", "fr", "good", "rez", "qt", " fr", "wx", "sq", "esp", "expr", "required", "eq", "urg", "tab", "desc", "q", "rt", "gr", "ref", "ctx", "quest", " resp", "requ", "res", "quire", "resp", "pkg", "aux", "ctr", "msg", " gr", "cmd"], "sx": ["svfx", "rsy", " sxd", "ssz", "Spx", "six", "svxd", "insrx", "despx", "atsx", "insz", "rsrx", " sfx", "desfx", "sxd", "insy", "desx", "desix", "ssrx", "spx", "sfx", "svpx", "lfx", "lix", "atsix", "ssx", "lx", "rsz", "Sx", "ssy", "svix", "atspx", "srx", "rsx", "Sfx", "sz", " six", " spx", "svx", "lpx", "atsxd", "Six", "insx"], "sy": ["ny", "SY", "py", "fy", "nn", "sb", "ery", "uy", "sty", "sat", "sa", "dy", "wy", "ss", "asy", "syn", "sche", "na", "ln", "sky", "ys", "shell", "pha", "ty", "ey", "ady", "tsy", "ony", "sm", "sf", "south", "she", "sym", "si", "yy", "icy", "pse", "y", "ry", "sys", "ly", "fi", "psy", "sid", "cy", "mx", "san", "cs", "se", "Sy"]}}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}", "idx": 11381, "substitutes": {"d": ["r", "di", "p", "done", "dev", "h", "x", "dr", "dx", "D", "f", "i", "v", "dd", "de", "dm", "data", "z", "l", "j", "dt", "n", "o", "da", "md", "g", "b", "dat", "y", "sd", "dn", "ds", "m", "c", "t", "e", "w", "del"], "jtx": ["jtext", " jtr", "jty", "ujx", "qx", " jtext", "dta", "Jtxt", "jti", " jta", " jtrans", " jfx", "jta", "jjty", "dtr", "ujty", "Jx", "jjtx", "Jtrans", "jjti", "gtx", "gtrans", "ujtx", "jx", " jty", "gfx", " jti", "jjtr", "Jfx", "Jtx", "gtext", "dtx", " jx", "jfx", "dti", " jtxt", "Jtext", "jtxt", "ujtrans", "qtx", "Jty", "qtxt", "jjta", "jtrans", "jjtrans", "qty", "jtr", "jjx"], "s": ["ts", "less", "p", "h", "sb", "ats", "sw", "ses", "sol", "rs", "se", "ls", "ss", "es", "als", "ps", "gs", "comm", "sts", "iss", "ex", "ess", "sq", " ss", "store", "fs", "sv", "sl", "is", "b", "has", "sam", "ins", "ms", "set", "bis", "js", "sys", "stats", "hs", "ds", "states", "S", "sis", "c", "source", "spec", "vs", "cs", "sand", "bs", "qs", "ns"]}}
{"project": "FFmpeg", "commit_id": "3df2be9fa7365646f22a93cfde1e4097467f498e", "target": 1, "func": "static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n\n                                    AVPacket *pkt, uint64_t display_duration)\n\n{\n\n    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',')\n\n        layer = ++ptr;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',') {\n\n        int64_t end_pts = pkt->pts + display_duration;\n\n        int sc = matroska->time_scale * pkt->pts / 10000000;\n\n        int ec = matroska->time_scale * end_pts  / 10000000;\n\n        int sh, sm, ss, eh, em, es, len;\n\n        sh = sc/360000;  sc -= 360000*sh;\n\n        sm = sc/  6000;  sc -=   6000*sm;\n\n        ss = sc/   100;  sc -=    100*ss;\n\n        eh = ec/360000;  ec -= 360000*eh;\n\n        em = ec/  6000;  ec -=   6000*em;\n\n        es = ec/   100;  ec -=    100*es;\n\n        *ptr++ = '\\0';\n\n        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;\n\n        if (!(line = av_malloc(len)))\n\n            return;\n\n        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\",\n\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n\n        av_free(pkt->data);\n\n        pkt->data = line;\n\n        pkt->size = strlen(line);\n\n    }\n\n}\n", "idx": 11383, "substitutes": {"matroska": ["matrisaka", "matroky", "matrisky", "matrasko", "matrosky", " matrasa", "matroko", "macrosaka", "matrosa", "matrasky", " matrosha", " matrosko", "macroka", "matrisa", "matrisko", "macrosko", "matraska", "matrisha", "matrotska", "matrotsaka", " matraska", "matrasa", "matrasha", "macroko", "matroha", "matrosha", " matrasko", "macrosha", "matrotsko", "matriska", " matrasha", "matrosko", "matroa", "matroka", " matrosa", "macrosky", "macroha", "matrotsha", "matroaka", "macroska", "matrosaka", "macroky", "macroaka"], "pkt": ["packet", "opacket", "Pwk", "pact", "tkt", "pakt", "prekg", "tkg", "Pet", "cpacket", " pwk", "Pct", "pnt", "pwk", "tnt", "pack", "ppkt", "Pck", "pant", "pct", " pck", "ppet", " pnt", " pconn", "pconn", "tacket", "twk", " pct", "ppacket", "cpkt", "prent", "Pkt", "Pix", "ppnt", "tet", " pix", "Pnt", "pix", "cpnt", "opnt", "pck", "Pconn", "cpet", "paacket", "opkt", " pet", "prekt", "pkg", " pkg", "Packet", "paix", " packet", "opconn", "pet", "cpwk", "preacket"], "display_duration": ["display2Duration", "play_duration", "displayutionlength", "displayutionDuration", "display_position", "displayutionstatus", " display_Duration", "displayutionruntime", " display2Duration", " display2length", " display_length", " display2status", "displayutionposition", "display2status", "display_runtime", "display_status", "display_Duration", "display_length", "display2duration", " display2duration", "play_position", "play_runtime", " display_status", "displayutionduration", "display2length"], "line": ["Line", "ine", "lines", "list", "lay", "cmd", "cat", "comment", "link", "dd", "frame", "data", "pe", "cell", "l", "str", "ln", "fr", "query", "code", "cl", "lock", "call", "nl", "label", "liner", "out", "n", "iter", "eline", "mt", "path", "detail", "user", "lo", "header", "text", "buffer", "lin", "block", "base", "train", "row", "LINE", "word", "ide", "le", "se", "el"], "layer": ["ld", "lay", "ayer", "lp", "tag", "type", "id", "pair", "name", "l", "padding", "ln", "lr", "depth", "lc", "dt", "Layer", "device", "channel", "label", "size", "wl", "file", "kl", "field", "lvl", "section", "hl", "header", "offset", "lan", "tile", "pen", "part", "kt", "buffer", "block", "source", "loc", "batch", "lv", "ayers", "vel", "pc", "level", "length"], "ptr": ["pert", "dr", "err", "ind", "tip", "fr", "DEP", "depth", "ix", "nl", "buf", "forth", "print", "arr", "ref", "adr", "loc", "row", "rel", "cmd", "jp", "pointers", "attr", "addr", "cont", "pt", "rep", "lr", "obj", "begin", "src", "expr", "kl", "hl", "desc", "trace", "buffer", "port", "assert", "prime", "rd", "peer", "p", "hr", "off", "lp", "eth", "dq", "coord", "sp", "cur", "pair", "pend", "pad", "warn", "str", "deg", "rect", " pointer", "th", "iter", "pointer", "sec", "try", "tr", "push", "elt", "fp", "inter", "br", "pen", "pc", "ctr", "length", "ts", "pod", "ld", "pr", "pl", "proc", "next", "der", "vr", "tp", "debug", "dig", "dep", "inters", "Ptr", "inst", "pers", "iv", "dra", "offset", "pos", "point", "address"], "end": ["hend", "send", "ent", "ending", "dev", "nd", "END", "eng", "ff", "head", "add", "ender", "pend", "pad", "rend", "entry", "en", "start", "stop", "window", "ep", "all", "edge", "iter", "bound", "begin", "ended", "End", "rest", "win", "ext", "endif", "empty", "set", "max", "last", "fin", "append", "ad", "est", "ell", "dest", "mid", "e"], "sh": ["h", "x", "sha", "sw", "se", "ih", "ls", "osh", "sp", "z", "cl", "shift", "th", "cc", "sr", "sq", "resh", "size", "SH", "sv", "Sh", "sl", "zh", "shr", "si", "kh", "esh", "s", "ch", "ph", "sd", "hl", "igh", "sn", "hs", "sc", "sk", "sy", "ksh", "ssh", "cs", "hel", "sch", "hw", "bs", "ish"], "sm": ["sb", "ims", "sw", "mem", "sa", "sem", "sp", "dm", "mg", "mph", "tm", "sim", "sbm", "rm", "sr", "arm", "sv", "sym", "md", "sl", "si", "mt", "sam", "ch", "s", "gm", "hem", "sd", "sn", "esm", "ym", "m", "ism", "mp", "mc", "mi", "sk", "sc", "SM", "sy", "cs", "sch", "ms", "mn"], "ss": ["sw", "rs", "sa", "ls", "sem", "sp", "sim", "ys", "SS", "iss", "cc", "rss", "sr", "ess", "sq", "ress", "sv", "sl", "si", "s", "bs", "pse", "ms", "sd", "sn", "css", "ness", "js", "sys", "ds", "oss", "ism", "sc", "est", "sy", "vs", "ssh", "cs", "sch", "se", "mes", "ass", "ns"], "eh": ["h", "hr", "erm", "ech", "ev", "eth", "eng", "hp", "mem", "ih", "der", "exec", "ears", "eric", "ef", "uth", "ei", "ek", "en", "eg", "her", "ep", "eb", "ern", "me", "resh", "Oh", "arm", "ea", "er", "oh", "expr", "he", "ec", "lem", "kh", "ah", "ph", "ach", "ch", "hem", "hl", "igh", "eman", "oe", "sch", "e", "oen", "eor", "drm"], "em": ["tem", "emin", "erm", "um", "eme", "mem", "eng", "ev", "sem", "om", "emi", "en", "ema", "eg", "ex", "iem", "ess", "arm", "ems", "emp", "er", "EM", "ec", "lem", "ch", "pse", "mn", "hem", "esm", "pm", "ym", "ism", "mp", "et", "mi", "ell", "im", "e", "me", "imm", "el", "mes"], "es": ["ens", "emin", "ats", "ies", "ses", "xes", "ls", "eks", "ese", "ces", "ers", "als", "ps", "en", "els", "eg", "ees", "ex", "rees", "ess", "des", "ems", "ES", "nes", "ets", "er", "enes", "is", "esp", "ec", "s", "eu", "eps", "Es", "css", "esm", "js", "bes", "ele", "ed", "et", "ests", "exe", "eds", "cs", "e", "ales", "tes", "se", "mes", "ns"], "len": ["ld", "pl", "yn", "mem", "lp", "err", "ls", "Len", "sp", "syn", "length", "fc", "l", "lf", "str", "ln", "en", "cl", "dl", "lc", "val", "ml", "nl", "n", "nt", "size", "ne", "sl", "wl", "mil", "kl", "fl", "fd", "li", "elt", "offset", "lan", "vec", "fin", "pos", "ell", "loc", "ll", "L", "vel", "le", "el"]}}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n", "idx": 11400, "substitutes": {"type": ["p", "types", "ype", "value", "tag", "link", "rule", "test", "typ", "id", "number", "role", "format", "pe", "tp", "version", "name", "title", "command", "game", "ver", "year", "position", "family", "ty", "error", "ico", "key", "total", "size", "time", "event", "file", "index", "TYPE", "shape", "Type", "y", "info", "style", "otype", "sequence", "kind", "t", "buffer", "status", "source", "spec", "ping", "message", "state", "class", "address", "length", "sort", "scope"], "reader_id": ["writer_id", "reader2id", "writer_seq", "reader___id", "reader___info", "reader_Id", "reader_ids", "reader____id", "writer_ids", "reader_side", "reader___pid", "reader2ids", "reader____seq", "reader2Id", " reader_Id", "reader___ids", "reader_pid", "reader_seq", " reader_ids", "reader_info", "writer_side", " reader_info", "reader____side", "reader____ids", " reader_pid"], "msg": ["p", "send", "seq", "mem", "v", "mg", "args", "id", "frame", "data", "str", "gs", "Msg", "raw", "out", "buf", "event", "md", "g", "b", "gz", "bytes", "get", "gm", "q", "og", "m", "text", "body", "t", "txt", "batch", "message", "pkg", "doc", "ms", "mess", "cmd"], "mhHeader": [" mwTree", "mhmHeader", " mvNumber", "mihLine", "mahColumn", "mohTree", "mhdComment", "mhmLine", "mwOwner", " mhLine", " mhField", "mihHeader", "mwHead", "mihBody", "mhLine", "smihBody", " mvHead", " mhtHeader", " mhNumber", "mzHeader", " mhHead", "smhBody", " mwType", "mhTree", "mhNumber", "mahHeader", "mzField", "mhrHead", "mohContent", "mhBody", " mvComment", "mHNumber", "mhdheader", "mhOwner", "mhComment", "mhtheader", "mhtHeader", " mhtheader", "mhdTree", "mhrType", "mzHead", "mhContent", "smihLine", " mhType", "mwType", "smhHeader", "mohOwner", " mvHeader", "mvHead", "mvNumber", "mohType", "mhheader", "mhpHeader", " mwHead", " mhColumn", "mhpColumn", " mhTree", " mhOwner", "mhdHeader", "mhColumn", "mhType", "smihHeader", " mhtField", "mohHead", "mhField", " mwOwner", "mhtField", "mwTree", "mhpLine", "mhrHeader", " mhheader", " mwHeader", "mvHeader", "mzheader", "mwHeader", " mhContent", "smhLine", "mHHeader", "mahLine", "mhrContent", "mHComment", "mahHead", "mhtHead", "mhdField", "mHHead", "mhmBody", "mhHead", " mwContent", "mwContent", "mvComment", "mhpHead", " mhComment", " mhtHead", "mhdNumber", "mhdHead", "mohHeader", "mhdOwner"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){\n\n    int i, j;\n\n    int dc = (((dctcoef*)block)[0] + 32) >> 6;\n\n    pixel *dst = (pixel*)_dst;\n\n    stride >>= sizeof(pixel)-1;\n\n    for( j = 0; j < 4; j++ )\n\n    {\n\n        for( i = 0; i < 4; i++ )\n\n            dst[i] = av_clip_pixel( dst[i] + dc );\n\n        dst += stride;\n\n    }\n\n}\n", "idx": 11423, "substitutes": {"_dst": ["_dct", "_dST", "_ddest", " _ddest", "___idsrc", "_fct", " _Dest", "___dbr", " _DST", "_Dsrc", "_idct", "_idst", "_dsrc", "_idbr", "___dsrc", "_DST", "_daST", "_Dst", " _Ddest", "___dst", "_dest", "_dadest", "_Dest", "_dbr", "___idct", "_idsrc", "_Dbr", "_daest", " _Dst", "___idbr", "_fsrc", " _dST", "_Dct", "_dast", "_Ddest", "_fst", " _dest", "___idst", "_fbr", "___dct"], "block": ["sync", "Block", "pixel", "proc", "bin", "type", "link", "pack", "frame", "object", "group", "map", "cl", "lock", "bl", "channel", "device", "BL", "line", "label", "config", "blocks", "load", "field", "hash", "ref", "box", "byte", "part", "chain", "check", "buffer", "filter", "mask", "row", "word", "image", "lib"], "stride": ["STRime", "strend", "stides", "Strice", "Strategy", "stategy", "relategy", " strend", "specide", "strope", "strride", "strade", "stope", "relide", "strategy", "STRride", "strime", " strride", "relope", "relice", "strides", "Stride", "stide", " strope", " strade", " strime", "strice", "STRide", "specade", "stime", " strides", "stade", "specend", "stice", "STRope", "specides", "Strope", "stend"], "i": ["ui", "di", "p", "ami", "x", "h", "uri", "f", "v", "gi", "ri", "ic", "ai", "id", "iq", "ind", "l", "ii", "xi", "ji", "I", "sim", "ix", "iu", "ik", "at", "ex", "u", "iy", "multi", "bi", "in", "PI", "o", "iter", "is", "b", "ie", "my", "si", "index", "g", "li", "y", "ini", "q", "\u0438", "it", "ia", "ci", "m", "c", "io", "qi", "ip", "mi", "ij", "zi", "chain", "ti", "point", "im", "pi", "ki", "me", "ish"], "j": ["r", "p", "aj", "x", "pr", "init", "oj", "jj", "f", "v", "jc", "json", "job", "jump", "jit", "z", "ind", "jack", "l", "ii", "bj", "fr", "ji", "sim", "at", "bi", "n", "o", "obj", "ne", "ja", "b", "g", "kj", "s", "jo", "try", "q", "js", "it", "J", "m", "c", "br", "t", "jl", "Ja", "ij", "dj", "ge", "uj", "im", "bo", "k", "bs", "jp"], "dst": ["dbl", "sdst", " dST", "ddest", "drast", "ldst", " dpr", "idst", "dosts", "idout", "dpr", "dict", " dict", "Dict", " dout", "Dout", "Dbr", "Dbl", "Dst", "sdbr", "draST", "dobr", "dout", "lddest", "sdost", "idbr", "dessts", "dsts", "ldsts", " dbr", "draost", "desst", "Dsts", "ldpr", " dost", "dST", "sdST", "dbr", "despr", " ddest", "desdest", " dbl", "dost", " dsts", "dobl", "drabr", "idict"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt,\n\n                             const AVFrame *pict, int *got_packet)\n\n{\n\n    const AVFrame *const p = pict;\n\n    const int near         = avctx->prediction_method;\n\n    PutBitContext pb, pb2;\n\n    GetBitContext gb;\n\n    uint8_t *buf2 = NULL;\n\n    uint8_t *zero = NULL;\n\n    uint8_t *cur  = NULL;\n\n    uint8_t *last = NULL;\n\n    JLSState *state;\n\n    int i, size, ret;\n\n    int comps;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n        avctx->pix_fmt == AV_PIX_FMT_GRAY16)\n\n        comps = 1;\n\n    else\n\n        comps = 3;\n\n\n\n    if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 +\n\n                               AV_INPUT_BUFFER_MIN_SIZE)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    buf2 = av_malloc(pkt->size);\n\n    if (!buf2)\n\n        goto memfail;\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n    init_put_bits(&pb2, buf2, pkt->size);\n\n\n\n    /* write our own JPEG header, can't use mjpeg_picture_header */\n\n    put_marker(&pb, SOI);\n\n    put_marker(&pb, SOF48);\n\n    put_bits(&pb, 16, 8 + comps * 3); // header size depends on components\n\n    put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8);  // bpp\n\n    put_bits(&pb, 16, avctx->height);\n\n    put_bits(&pb, 16, avctx->width);\n\n    put_bits(&pb, 8, comps);          // components\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);     // component ID\n\n        put_bits(&pb, 8, 0x11);  // subsampling: none\n\n        put_bits(&pb, 8, 0);     // Tiq, used by JPEG-LS ext\n\n    }\n\n\n\n    put_marker(&pb, SOS);\n\n    put_bits(&pb, 16, 6 + comps * 2);\n\n    put_bits(&pb, 8, comps);\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);   // component ID\n\n        put_bits(&pb, 8, 0);   // mapping index: none\n\n    }\n\n    put_bits(&pb, 8, near);\n\n    put_bits(&pb, 8, (comps > 1) ? 1 : 0);  // interleaving: 0 - plane, 1 - line\n\n    put_bits(&pb, 8, 0);  // point transform: none\n\n\n\n    state = av_mallocz(sizeof(JLSState));\n\n    if (!state)\n\n        goto memfail;\n\n\n\n    /* initialize JPEG-LS state from JPEG parameters */\n\n    state->near = near;\n\n    state->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;\n\n    ff_jpegls_reset_coding_parameters(state, 0);\n\n    ff_jpegls_init_state(state);\n\n\n\n    ls_store_lse(state, &pb);\n\n\n\n    zero = last = av_mallocz(p->linesize[0]);\n\n    if (!zero)\n\n        goto memfail;\n\n\n\n    cur  = p->data[0];\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 8);\n\n            t    = last[0];\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 16);\n\n            t    = *((uint16_t *)last);\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 0; j < 3; j++) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 2; j >= 0; j--) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    }\n\n\n\n    av_freep(&zero);\n\n    av_freep(&state);\n\n\n\n    /* the specification says that after doing 0xff escaping unused bits in\n\n     * the last byte must be set to 0, so just append 7 \"optional\" zero-bits\n\n     * to avoid special-casing. */\n\n    put_bits(&pb2, 7, 0);\n\n    size = put_bits_count(&pb2);\n\n    flush_put_bits(&pb2);\n\n    /* do escape coding */\n\n    init_get_bits(&gb, buf2, size);\n\n    size -= 7;\n\n    while (get_bits_count(&gb) < size) {\n\n        int v;\n\n        v = get_bits(&gb, 8);\n\n        put_bits(&pb, 8, v);\n\n        if (v == 0xFF) {\n\n            v = get_bits(&gb, 7);\n\n            put_bits(&pb, 8, v);\n\n        }\n\n    }\n\n    avpriv_align_put_bits(&pb);\n\n    av_freep(&buf2);\n\n\n\n    /* End of image */\n\n    put_marker(&pb, EOI);\n\n    flush_put_bits(&pb);\n\n\n\n    emms_c();\n\n\n\n    pkt->size   = put_bits_count(&pb) >> 3;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n\n\nmemfail:\n\n    av_packet_unref(pkt);\n\n    av_freep(&buf2);\n\n    av_freep(&state);\n\n    av_freep(&zero);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 11427, "substitutes": {"avctx": ["afconn", "ajcfg", "wavtx", "avecb", "averctl", "avecfg", "avvoc", "avjac", "AVcontext", "avcmd", "afcfg", "avercontext", "avecontext", "Avcmp", "auctl", "ajctx", "AVconf", "auctx", "avcv", "afcontext", "AVctl", "ajtx", "averkw", "wavctx", "wavconf", "afcmd", "avtx", "wavcmd", "avcmp", "averctx", "avkw", "AVcv", "autx", "avercv", "afjac", "avervoc", " avkw", "AVctx", " avtx", "avectx", "devctx", "avconn", "averjac", "afctx", "avhw", "aujac", " avcv", "Avctx", "avconf", "averhw", "aucmd", "auconn", "avcfg", "avercmd", "Avcontext", "aftx", "avcb", "avctl", "avcontext", " avctl", "averconn", " avcmp", "AVtx", "Avconn", " avvoc", "avekw", " avconn", " avcfg", "AVcmd", "devtx", "averconf", "afcmp", "afhw", " avcontext", "avertx", "ajcb", " avcb", "devcfg", "devcontext", "auvoc", " avhw", "avetx", " avcmd", "avecmd"], "pkt": ["packet", "wpkg", "mconn", "cix", "apkt", "ckt", "wpkt", "Pct", "pnt", "mvc", "cacket", "Pck", "dkt", "pct", "dacket", "wpvc", "wpacket", " pck", "Pkg", " pnt", "dck", "mix", "cct", " pconn", " pvc", "pconn", " pct", "pvc", "apix", "apacket", "Pkt", "Pix", " pix", "mkt", "macket", "Pnt", "dnt", "pix", "mct", "pck", "Pconn", "apct", "Packet", "pkg", " pkg", "mkg", " packet", "apnt"], "pict": ["pas", "pic", "fps", "pl", "pres", "fen", "gif", "pain", "stat", "cam", "pt", "Pic", "picture", "capt", "avi", "pai", "feat", "phot", "Picture", "png", "act", "pit", "phys", "iat", "ctx", "fi", "fp", "phy", "prop", "kt", "pkg", "vp", "Pict", "lot", "img", "jp"], "got_packet": ["got_paykt", "got_packets", "got_payet", "got_payets", "got_pet", "got_ppkt", "got_pets", "got_pett", "got_pkt", "got_packkt", "got_payett", "got_packett", "got_ppets", "got_ppett", "got_ppet"], "p": ["pro", "pic", "pr", "pl", "lp", "f", "pp", "pid", "pt", "pn", "cp", "pd", "P", "pa", "par", "fp", "m", "c", "pen", "t", "ap", "pkg", "pc", "vp", "jp"], "pb": ["pro", "pod", "pas", "pic", "cb", "bf", "sb", "py", "pl", "ab", "amp", "np", "wp", "proc", "public", "lp", "px", "pp", "typ", "nb", "plain", "tp", "dp", "pg", "bp", "emb", "pt", "bj", "tk", "uf", "bb", "vm", "root", "ub", "gp", "fb", "eb", "bot", "cv", "buf", "PB", "cp", "xb", "peer", "tmp", "td", "b", "pa", "mb", "tab", "sys", "ctx", "tg", "wb", "mp", "orp", "bolt", "kt", "db", "rb", "resp", "ping", "pkg", "verb", "pc", "vp", "lb", "bs", "msg", "jp", "cmd"], "pb2": ["pbb", "pkg3", "cv1", "pkg1", "jpb", "cv3", "p1", "jp1", "pblet", "pkg2", "p2", "p3", "pb1", "buf1", "jplet", "jp2", "bufb", "pb3", "plet", "cv2", "buflet"], "gb": [" GB", "GB", "cb", "bf", " eg", "sb", "gh", " gu", "gd", " db", "gs", "gt", "uf", " rgb", "cv", " storage", "g", "Gb", "gm", "kb", " gif", " bu", "sg", " rg", " gui", "tg", "db", "bg", "gc"], "buf2": [" buf0", "buffer2", " buf3", "buffer3", " buf1", "buf0", " buf02", "uf02", "buff02", "uf0", "buf02", "buffer02", "buff1", "buffer1", "buf3", "buff2", "pb1", "buf1", "uf2", "uf1", "uf3", "buff3", "pb0"], "zero": ["equal", "zer", "ma", "final", "comment", "major", "ket", "fee", "na", "good", "window", "root", "dirty", "null", "initial", "total", "prefix", "scale", "index", "one", "empty", "none", "sc", "mask", "ta", "me"], "cur": ["cr", "dr", "final", "rev", "err", "cont", "ser", "ct", "rc", "prev", "cor", "cv", "buf", "tmp", "serv", "cache", "desc", "quick", "cmp", "num", "sc", "res", "con", "row", "mid", "ctr", "ptr", "msg", "pri"], "last": ["dist", "list", "final", "next", "master", "end", "str", "stop", "start", "old", "close", "prev", "range", "total", "latest", "st", "rest", "cache", "full", "first", "tail", "max", "reg", "num", "est", "stable", "base", "low", "Last"], "state": ["list", "next", "tag", "type", "err", "test", "STATE", "stat", "name", "result", "code", "progress", "config", "State", "event", "st", "ch", "te", "act", "info", "tx", "style", "states", "status", "port", "msg", "error"], "i": ["ui", "di", "ami", "iii", "x", "gi", "ic", "ai", "id", " ii", "iq", "ind", "ei", "ii", "xi", "sim", "I", "phi", "ix", "iu", "multi", "bi", "n", " I", "me", "o", "in", "iter", "is", "ie", "hi", "si", "index", "li", " bi", "y", "ini", "gu", "it", "ci", "m", "io", "c", "t", "ip", "mi", "ij", "zi", "qi", "ti", "im", "pi", "e", "ki", "ims", "ms"], "size": ["ui", "send", "mem", "head", "sp", "data", "format", "speed", "fee", "name", "height", "capacity", "start", "small", "window", "depth", "sent", "space", "SIZE", "n", "count", "si", "Size", "scale", "index", "bytes", "dim", "shape", "sn", "big", "set", "offset", "ize", "c", "weight", "body", "pos", "buffer", "len", "sum", "iz", "address", "length", "storage", "dimension"], "ret": ["flag", "RET", "red", "mem", "fun", "value", "rev", "final", "err", "repl", "cont", "success", " Ret", "re", "result", "gt", "Ret", "val", "rem", "out", "nt", "buf", "rets", "tmp", "iter", "back", "mt", "try", "tr", "def", "arr", "elt", "rt", "ref", "reset", "reg", "tf", "it", "fin", "txt", "t", "len", "res", "ll", "resp", "alt", "gc"], "comps": ["quredits", "comonents", "COMales", "proples", "temres", "repps", "props", "COMcs", "coms", "COMrs", "speonents", "complets", "compports", "temps", "conps", "COMs", "collples", "commcs", "commredits", "comredits", "compredits", "reports", "Coms", "commups", "qups", "comppps", "comrs", "commplets", "speps", "commres", "collps", "compups", "comorts", "commops", "compres", "compcs", "compps", "comcs", "quplets", " comales", "collPS", "commorts", "conports", "compops", "temups", " comcs", "COMples", "conpps", " comrs", "ComPS", "Comports", "concs", " coms", "comPS", " comPS", "COMpps", "collpps", "proPS", "commrs", "temorts", "reps", "comales", "COMports", "commales", "commports", "compplets", "spepps", "comples", "comports", "COMps", "comops", "COMPS", " compps", "commpps", " comports", "speports", "comres", " comonents", "quops", "propps", "reonents", "comups", "Comps", "commps"]}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "void ff_vc1_decode_blocks(VC1Context *v)\n\n{\n\n\n\n    v->s.esc3_level_length = 0;\n\n    if (v->x8_type) {\n\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);\n\n\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n    } else {\n\n        v->cur_blk_idx     =  0;\n\n        v->left_blk_idx    = -1;\n\n        v->topleft_blk_idx =  1;\n\n        v->top_blk_idx     =  2;\n\n        switch (v->s.pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            if (v->profile == PROFILE_ADVANCED)\n\n                vc1_decode_i_blocks_adv(v);\n\n            else\n\n                vc1_decode_i_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            if (v->p_frame_skipped)\n\n                vc1_decode_skip_blocks(v);\n\n            else\n\n                vc1_decode_p_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            if (v->bi_type) {\n\n                if (v->profile == PROFILE_ADVANCED)\n\n                    vc1_decode_i_blocks_adv(v);\n\n                else\n\n                    vc1_decode_i_blocks(v);\n\n            } else\n\n                vc1_decode_b_blocks(v);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 11428, "substitutes": {"v": ["x", "inv", "ev", "vector", "cam", "ver", "en", "qv", "vm", "u", "sv", "vv", "d", "cache", "c", "wire", "t", "vp", "w", "av", "h", "on", "value", "env", "ve", "vt", "q", "button", "it", "vs", "p", "vim", "um", "html", "i", "vol", "qu", "l", "command", "window", "va", "ov", "g", "b", "video", "tv", "s", "y", "V", "nv", "lv", "conv", "r", "att", "dev", "rev", "f", "vr", "version", "j", "vert", "val", "n", "cv", "form", "ch", "get", "iv", "view", "vi", "uv", "m", "vc"]}}
{"project": "FFmpeg", "commit_id": "8ce803db51a28eb662b6271b2b223e0312bdb3d2", "target": 1, "func": "paint_mouse_pointer(XImage *image, struct x11_grab *s)\n\n{\n\n    int x_off = s->x_off;\n\n    int y_off = s->y_off;\n\n    int width = s->width;\n\n    int height = s->height;\n\n    Display *dpy = s->dpy;\n\n    XFixesCursorImage *xcim;\n\n    int x, y;\n\n    int line, column;\n\n    int to_line, to_column;\n\n    int image_addr, xcim_addr;\n\n\n\n    xcim = XFixesGetCursorImage(dpy);\n\n\n\n    x = xcim->x - xcim->xhot;\n\n    y = xcim->y - xcim->yhot;\n\n\n\n    to_line = FFMIN((y + xcim->height), (height + y_off));\n\n    to_column = FFMIN((x + xcim->width), (width + x_off));\n\n\n\n    for (line = FFMAX(y, y_off); line < to_line; line++) {\n\n        for (column = FFMAX(x, x_off); column < to_column; column++) {\n\n            xcim_addr = (line - y) * xcim->width + column - x;\n\n\n\n            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel\n\n                image_addr = ((line - y_off) * width + column - x_off) * 4;\n\n\n\n                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);\n\n                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);\n\n                image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);\n\n            }\n\n        }\n\n    }\n\n\n\n    XFree(xcim);\n\n    xcim = NULL;\n\n}\n", "idx": 11433, "substitutes": {"dpy": ["dmy", "bpy", "sdgb", " dmp", "npor", "dpi", "cpi", "dspty", "dsgb", "wmp", "bpm", "dpor", "cpic", "dspy", "dmp", " dpty", "nmp", "sdpy", "sdpic", "wgb", "bpic", " dgb", "cpy", "dpm", "dsmy", " dmy", "wpor", "sdpty", "cpm", "dgb", "dpty", "wpy", "dpic", "sdmy", "npy", "sdpi", "bpi", "sdpm", " dpor", "ngb"], "xcim": ["occimm", "abcim", "cuimm", "confimi", "ctximm", "bcimus", "octim", "xaimus", "etcrim", "zxiro", "ctximus", "occime", "xdimi", "mcm", "bcim", "xdimus", "lcimm", "conimus", "lcima", "mcimal", "cnimm", "mcif", "xaam", "cpimp", "confim", "xdimal", "vcim", "confimal", "xcif", "occimus", "zxime", "conif", "vcit", "cpime", "xcima", "rcim", "ccimus", "zxim", "vcif", "xcam", "abcrim", "pcim", "octsim", "xfam", "cmpim", "conimm", "xciro", "cpim", "xbimus", "confit", "xcimal", "confimm", "cnif", "xfimus", "lciro", "xcit", "xcime", "pscimus", "xcimi", "confif", "cuam", "cmpime", "xaimg", "cnim", "funcif", "zxil", "xfim", "vcimm", "ctxim", "xdm", "wxsim", "webkitrim", "occim", "occimal", "xcrim", "rcimi", "abcimus", "etcimus", "pcime", "zxam", "octima", "ccim", "xdim", "vcrim", "pscimm", "xaimm", "xcm", "xdimm", "bcm", "xfiro", "etcim", "mcim", "webkitimus", "wxima", "funcit", "xdime", "lcim", "wxim", "xfil", "zximus", "cuaram", "mcimus", "funcimm", "xfimi", "zximm", "xarim", "ctxrim", "bcimal", "mcimm", "pscrim", "ctximi", "cnimus", "conim", "rcimm", "octimm", "lcsim", "webkitimg", "xcaram", "xcimg", "cuim", "ccif", "conrim", "cmpil", "cmpimp", "lcam", "funcimus", "xcimm", "pscim", "pcimp", "cpil", "ctximal", "vcimi", "vcimal", "ccimm", "xcimp", "xcimus", "xbim", "xcsim", "xaim", "xaimal", "rcimal", "abcimg", "xbimm", "pcil", "xfimm", "lcil", "xcil", "xaaram", "vcimus", "etcimm", "xaif", "funcimal", "xfaram", "xbif", "funcim", "webkitim", "wximm", "confimus"], "x": ["ine", "p", "X", "h", "on", "dx", "nex", "xy", "px", "i", "v", "xt", "z", "length", "xf", "l", "height", "xs", "ox", "ln", "xi", "angle", "en", "j", "ix", "ex", "at", "n", "ice", "o", "wx", "xp", "g", "el", "index", "tx", "fx", "ry", "lat", "ly", "m", "c", "rx", "yx", "ile", "xa", "t", "lin", "row", "im", "lon", "xc", "e", "xml", "le", "image", "col", "w", "xx"], "y": ["p", "ny", "py", "h", "on", "ery", "ies", "xy", "uy", "i", "v", "vy", "wy", "z", "asy", "yer", "cell", "height", "l", "j", "year", "page", "sky", "ys", "ey", "ty", "key", "iy", "n", "o", "b", "my", "yy", "ch", "axy", "Y", "ay", "ya", "ry", "yt", "ym", "ly", "m", "c", "yx", "cy", "t", "yl", "hot", "sy", "row", "ye", "col", "yo", "w", "gy", "by"], "line": ["Line", "ine", "on", "pixel", "lay", "link", "frame", "pe", "cell", "entry", "l", "ln", "page", "image", "code", "lock", "position", "record", "range", "pipe", "n", "label", "iter", "eline", "loop", "ie", "file", "index", "try", "path", "li", "stroke", "section", "node", "lo", "style", "tile", "chain", "lin", "block", "port", "row", "point", "LINE", "entity", "ide", "col", "le", "level", "se", "word"], "column": ["collection", "directory", "condition", "slot", "number", "output", "format", "connection", "function", "cell", "csv", "height", "widget", "command", "axis", "page", "year", "position", "day", "component", "key", "channel", "piece", "label", "margin", "umn", "pointer", "zone", "property", "rain", "index", "letter", "pattern", "field", "character", "paragraph", "crop", "attribute", "section", "category", "custom", "display", "variable", "header", "cloud", "forward", "Column", "c", "cy", "chain", "block", "point", "row", "table", "client", "col", "word", "dimension"], "to_line": ["toplacelink", "max_lin", "to_link", "to__Line", "toplacenode", " to_node", "toplacerow", "to__node", "to__lines", "too_Line", "to_row", "to67file", "toplaceline", "too__line", "to__link", "to__row", "to67lines", "to67lin", "to__lin", " to_link", "max_lines", "too_lin", "too__Line", " to_row", "max_line", "to_lin", "to__line", "max_file", "too__lines", "to_lines", "too_line", "too__lin", "to67line", "to_node", "to_Line", "to_file", "too_lines"], "to_column": ["TO_row", "to__square", "to_row", "TO_column", "to_Column", "TO_attribute", "to_cell", "to_property", "to__column", " to_character", "to__property", " to_square", "toplacesquare", "TO_Column", " to_cell", "to__cell", "toplacecell", "to_square", " to_Column", " to_property", "toplaceproperty", "to_character", "toplacecolumn", "to_attribute"], "image_addr": ["picture_dir", "sequence_offset", "sequence_row", "image_ser", "image_adr", "image_ord", "image___addr", " image_err", "image_offset", "sequence_addr", "image_ip", " image_offset", "sequence_adr", "picture_obj", "image_ptr", " image_adr", "image__addr", "image_obj", "image_dir", " image_ptr", "image__offset", "image_row", " image_ord", "image___dir", "picture_addr", "image_err", " image_ip", "image__ptr", "image___obj", "picture_ser", "image__adr"], "xcim_addr": ["xcem_loc", "xcim_off", "xcim_src", "xcim_loc", "xcim__addr", "xcim__attr", "xcig_ext", "xcig_off", "xcim__address", "xcimus_ad", "xcim_attr", "xcimus_src", "xcim5addr", "xcem_data", "xcim_ad", "xcrim_mt", "xcim_ptr", "xcim5data", "xcimus_addr", "xcim_mt", "xcig_addr", "xcem_ptr", "xcim__err", "xcim_ord", "xcimus_attr", "xcrim_ord", "xcimus_add", "xcim5loc", "xcim_address", "xcig_ptr", "xcem_addr", "xcim_err", "xcim_arr", "xcim_data", "xcrim_err", "xcrim_address", "xcimus_arr", "xcrim_addr", "xcim_add", "xcim5ptr", "xcrim_attr", "xcim_ext"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr,\n\n                                    unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint32_t gic_freq, val;\n\n\n\n    if (size != 4) {\n\n        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);\n\n        return 0;\n\n    }\n\n\n\n    switch (addr & 0xffff) {\n\n    case PLAT_FPGA_BUILD:\n\n    case PLAT_CORE_CL:\n\n    case PLAT_WRAPPER_CL:\n\n        return 0;\n\n    case PLAT_DDR3_STATUS:\n\n        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;\n\n    case PLAT_MMCM_DIV:\n\n        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;\n\n        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;\n\n        return val;\n\n    case PLAT_BUILD_CFG:\n\n        val = PLAT_BUILD_CFG_PCIE0_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE1_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE2_EN;\n\n        return val;\n\n    case PLAT_DDR_CFG:\n\n        val = s->mach->ram_size / G_BYTE;\n\n        assert(!(val & ~PLAT_DDR_CFG_SIZE));\n\n        val |= PLAT_DDR_CFG_MHZ;\n\n        return val;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,\n\n                      addr & 0xffff);\n\n        return 0;\n\n    }\n\n}\n", "idx": 11439, "substitutes": {"opaque": ["obque", "OPatile", "opatile", "OPca", "opca", "obaque", "obhole", " ophole", "OPosit", " opaques", " opque", "oppca", "oaques", "oppaque", "oppatile", "oatile", "opque", "obaques", "oposit", "oque", "ophole", "oaque", "OPaque", "opaques", "oosit", "oca", "ohole", "opposit"], "addr": ["r", "ack", "dr", "np", "mem", "rs", "attr", "coord", "hop", "v", "alloc", "id", " address", "add", "ash", "pad", "map", "ix", "align", "rc", "src", "a", "prefix", "work", "act", "arp", "arr", "tx", "Address", "rt", "ref", "aff", "offset", "ctx", "hash", "inter", "wid", "rn", "adr", "gate", "ip", "pos", "alias", "ad", "res", "loc", "arch", "alt", "ord", "ptr", "host", "hw", "address", "cmd"], "size": ["send", "x", "mem", "type", "sh", "sp", "number", "data", "z", "fee", "name", "ze", "l", "padding", "capacity", "start", "small", "shift", "notice", "space", "n", "count", "sized", "g", "scale", "Size", "dim", "false", "shape", "empty", "sd", "sn", "grow", "offset", "max", "ize", "c", "body", "num", "len", "sum", "message", "e", "SIZE", "address", "length"], "s": ["r", "ts", "p", "h", "sb", "ses", "ies", "rs", "i", "v", "ls", "sp", "ss", "es", "ps", "gs", "sts", "sq", "o", "sv", "fs", "a", "g", "is", "b", "ins", "os", "sac", "q", "js", "hs", "ds", "ssl", "stats", "m", "S", "c", "t", "e", "bs", "ns"], "gic_freq": ["gic_req", "gic_frqs", "gic_Freq", "gic_frez", "gic67freq", "gic_fastz", "gic2freq", "gic_fech", "gic67fastz", "gic67fastreq", "gic_freQ", "gic2frqs", "gic67freqs", "gic_Frez", "gic_Freqs", "gic2frch", "gic_frch", "gic_feqs", "gic_frereq", "gic_Frech", "gic_fastqs", "gic67fastq", "gic_fastq", "gic_Freek", "gic2freqs", "gic_rez", "gic_freqs", "gic_fastreq", "gic_freek", "gic2frq", "gic67frez", "gic_FreQ", "gic_feq", "gic_reek", "gic_frq", "gic_frech", "gic_Frereq", "gic2frech", "gic67fastqs", "gic67frereq", "gic_reQ"], "val": ["x", "err", "compl", "ul", "ver", "buf", "def", "var", "arr", "ref", "echo", "len", "loc", "valid", "el", "item", "rel", "util", "value", "ret", "test", "bal", "pt", "new", "aval", "bl", "all", "ve", "obj", "vt", "sl", "serv", "ival", "expr", "kl", "rol", "tx", "it", "VAL", "res", "fail", "cho", "msg", "al", "pret", "slot", "vol", "sel", "l", "str", "crit", "Value", "bool", "elt", "eval", "ctx", "vec", "prop", "cal", "alpha", "lev", "lib", "pol", "func", "dev", "pr", "pl", "vals", "opt", "Val", "v", "als", "cond", "key", "grad", "local", "pos", "num", "ee", "point", "resp", "alt", "pal", "il"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int avfilter_register(AVFilter *filter)\n\n{\n\n    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)\n\n        return -1;\n\n\n\n    registered_avfilters[next_registered_avfilter_idx++] = filter;\n\n    return 0;\n\n}\n", "idx": 11444, "substitutes": {"filter": ["report", "search", "list", "fire", "feature", "cf", "fil", "f", "v", "rule", "test", "entry", "call", "query", "page", "Filter", "map", "only", "channel", "event", "resource", "file", "form", "transform", "match", "term", "attribute", "package", "ref", "find", "check", "block", "batch", "table", "before", "profile", "spec", "sort", "apply"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n", "idx": 11449, "substitutes": {"errp": [" erP", " errpid", "errP", "erpid", "erP", "errpid", " erp", " errP", " erpid", "erp"]}}
{"project": "qemu", "commit_id": "eefff991d059d299b917627d2a95bce34d2f97f3", "target": 1, "func": "int load_snapshot(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11455, "substitutes": {"name": ["no", "snap", "type", "data", "NAME", "named", "create", "range", "null", "names", "def", "ref", "t", "current", "w", "ns", "cmd", "on", "sw", "mem", "tree", "title", "new", "order", "nm", "a", "resource", "path", "one", "info", "package", "word", "cn", "p", "common", "id", "sp", "missing", "str", "out", "label", "size", "b", "prefix", "Name", "alias", "error", "dev", "ma", "v", "format", "version", "filename", "old", "key", "run", "admin", "n", "in", "file", "get", "local", "m", "ame", "part", "base", "normal"], "errp": ["diepa", "errpat", "errorwp", "errcp", "ierpa", "acerpart", "rrper", "eorp", "ermpatch", "errpart", "diep", "acerp", "errpe", "errorap", "riskp", "errorps", "errpoint", "errorp", "arrpat", "herpe", "acerpress", "errper", "ierpoint", "rrping", "aercp", "ermpoint", "diepoint", "riskpat", "errping", "scorepp", "aerpart", "arrpress", "eorpat", "eorper", "arrpart", "scoreP", "arrwp", "ermpa", "crwp", "scorep", " errpat", "herd", "diepatch", "rrpart", "rrd", "errpatch", "rrpat", "errwp", "crap", "eorping", "acerping", "errpa", "errP", "scorepat", "arrap", "riskpp", "rrpe", "errorpart", "aerps", "crp", "errd", "errpp", "arrping", "rrcp", "errpress", "errap", "errorcp", "ierp", " errpp", "rrpp", "errps", " errP", "derp", "herpp", "rrps", "rrp", "ierpatch", "aerp", "derpe", "rrpress", "arrp", "derpp", "ermp", "errorpat", "crpat", "arrper", "derd", "riskP", "herp"], "bs": ["ts", "boxes", "sb", "blog", "aps", "rs", "aos", "bos", "ls", "BS", "pb", "its", "als", "bp", "bc", "obs", "ps", "vers", "boot", "gs", "bb", "ubs", "bl", "bi", "las", "bh", "fs", "bt", "b", "lbs", "s", "os", "bas", "bis", "gb", "js", "sys", "bes", "ubis", "oss", "ists", "bits", "bps", "bn", "bg", "vs", "cs", "lb", "hz", "bm", "ns"], "bs_vm_state": ["bs_virtual_state", "bs_VM_info", "bs_vmgrstatus", "bs_vd_resource", "bs_nvpttype", "bs_vm2port", "bs_virtual_status", "bs_vmgrstate", "bs_vmptstart", "bs_vm_info", "bs_vm2State", "bs_vmpttype", "bs_nvptstart", "bs_nvptstate", "bs_virtual_start", "bs_nv_states", "bs_nv_state", "bs_vm_type", "bs_nvgrtype", "bs_vm_tag", "bs_vm_resource", "bs_vmgrtype", "bs_VM_port", "bs_vmptstates", "bs_vd_info", "bs_vm2info", "bs_VM_state", "bs_nv_type", "bs_vm_port", "bs_vm_status", "bs_vmptstate", "bs_vm2state", "bs_vd_state", "bs_virtual_State", "bs_nvgrstate", "bs_vm_states", "bs_nv_status", "bs_nvgrstatus", "bs_vm_start", "bs_vm2resource", "bs_vm_State", "bs_VM_State", "bs_nvptstates", "bs_virtual_tag", "bs_nv_start"], "sn": [" cs", "snap", "sb", "nd", "nn", " Sn", "sw", "nex", "sol", "su", " syn", "np", " SN", "sa", "Sn", "kn", "sh", "sp", "syn", "stat", "spe", " sr", "na", " sc", "ln", "tn", "nr", "SN", "sr", "ern", "spr", "nl", "n", "sq", " ss", "sm", "gn", "nt", "sv", " sv", "sl", "nm", "fn", "si", "st", "sam", "fl", "sd", "rn", "sc", " sw", "sk", " scr", "cn", "ns"], "f": ["r", "p", "bf", "h", "x", "cf", "ff", "elf", "v", "fc", "xf", "ef", "rf", "lf", "l", "fr", "uf", "fo", "fb", "u", "fa", "sf", "fs", "fab", "b", "fn", "file", "fm", "d", "s", "fd", "fx", "af", "fe", "tf", "fp", "fi", "F", "m", "c", "t", "buffer", "e", "w", "fw"], "ret": ["no", "err", "number", "end", "gt", "Ret", "ert", "rm", "remote", "vet", "fn", "print", "def", "ref", "reg", "t", "len", "ll", "description", "ter", "del", "cmd", "value", "addr", "code", "new", "after", "nm", "expr", "script", "desc", "rt", "ry", "it", "txt", "status", "res", "ben", "slot", " Ret", "id", "str", "result", " RET", "rect", "reply", "rem", "summary", "out", "nt", "ne", "server", "mt", "try", "tr", "elt", "inter", "nz", "att", "cb", "RT", "RET", "ft", "rev", "success", "nb", "plain", "re", "format", "usr", "val", "run", "not", "rets", "net", "back", "get", "ext", "reset", "last", "fin", "num", "ber", "cert", "det", "resp", "alt"], "aio_context": ["aogo_window", "aio_window", "aian_information", "aio_support", "aive_context", "aio_information", "aogo_context", "aio_translation", "aogo_text", "aio_pointer", "aIO_ctx", "aogo_support", "aIO_support", "aian_context", "aian_Context", "aio_text", "aive_Context", "aian_pointer", "aio_ctx", "aIO_translation", "aive_support", "aio_Context", "aIO_context", "aive_ctx"], "mis": ["pas", "mm", "ma", "MS", "mas", "cm", "mor", "oses", "isin", "sim", "mit", "mo", "ias", "mos", "Mis", "tis", "las", "cms", "mal", "mes", "mus", "mt", "mn", "sys", "pm", "mr", "miss", "mic", "mc", "dis", "sis", "m", "mi", "mx", "dj", "uj", "emis", "mu", "ms", "jp"]}}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,\n\n                                             ptrdiff_t buf_stride,\n\n                                             ptrdiff_t src_stride,\n\n                                             int block_w, int block_h,\n\n                                             int src_x, int src_y, int w, int h)\n\n{\n\n    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\n\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\n\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);\n\n}\n", "idx": 11468, "substitutes": {"buf": ["cb", "wd", "aka", "seq", "mem", "ff", "cap", "v", "Buffer", "pack", "bc", "uf", "map", "broad", "window", "bl", "rc", "cv", "buff", "b", "tr", "var", "tx", "queue", "ref", "ctx", "Buff", "br", "vec", "buffer", "block", "batch", "db", "dest", "ptr", "img"], "src": ["r", "sb", "rs", "sur", "sel", "ser", "sup", "cur", "syn", "sing", "uns", "usr", "raw", "supp", "rc", "sr", "sq", "rl", "sl", "inst", "sec", "st", "s", "ur", "urg", "iv", "sn", "input", "sys", "sc", "source", "dest", "stream", "ptr", "sub", "ctr", "img", "ins"], "buf_stride": ["buf_brride", "buf_descope", "buf_drope", "buf_trride", "buf_bride", "buf_descide", "buf_brider", "buf_trade", "buf_tride", "buf_drides", "buf_strade", "buf_Stride", "buf_descider", "buf_descride", "buf_strride", "buf_trides", "buf_Strides", "buf_Strride", "buf_drade", "buf_drride", "buf_Strade", "buf_strider", "buf_brope", "buf_dride", "buf_strope", "buf_strides", "buf_drider"], "src_stride": ["src_divage", "src_ride", "src_decides", "src_sride", "src_divride", "src_Strides", "src_sage", "src_strage", "src_decage", "src_strider", "src_side", "src_Strider", "src_Stride", "src_divension", "src_strride", "src_decide", "src_strension", "src_rider", "src_rride", "src_strides", "src_sension", "src_divide", "src_Strride", "src_rides", "src_decider", "src_decride", "src_decension"], "block_w": ["Block_b", "blocklyW", "Block_W", "block_nw", "block1wx", "Block_w", "blockxW", " block_wx", " block_W", "blockxw", "blockxwx", "blocklyb", "blockxnw", "Block_width", "block_width", "blocklyw", "blocklywidth", "block_W", "block1nw", "block_wx", "block1w", " block_nw", "block1W", "block_b"], "block_h": [" block_hh", "blockablehl", " block_hl", "block0h", "block0hl", "blockabley", "block7h", "blockableh", " block_y", "block_hl", "block0y", "block_y", "block7hz", "block_hz", " block_hz", "block7hh", "block_hh"], "src_x": ["rc_y", "src64x", "src64h", "rc_ix", " src_ix", "src_ix", "src_h", "src64ix", "rc_h", "src64y", "rc_x"], "src_y": ["src_ya", "rc_y", "src_ny", "rc_ny", "rc_ya", "src_Y", "rc_z", "rc_Y", "src_z", "rc_x"], "w": ["r", "p", "wd", "x", "wp", "v", "wo", "wr", "z", "W", "l", "wn", "window", "wx", "ew", " W", "wl", "b", "win", "wh", "iw", "ow", "wt", "wid", "m", "wb", "wa", "nw", "kw", "rw", "aw", "hw", "fw"], "h": ["p", "x", "hr", "high", "v", "ih", "head", "hm", "sh", "z", "rh", "height", "l", "j", "hd", "H", "bh", "g", "b", "oh", "hi", "ht", "he", "kh", "ph", "ah", "ha", "y", "hl", "hh", "hash", "q", "uh", "m", "c", "hal", "ho", "ish"]}}
{"project": "FFmpeg", "commit_id": "a1a32fdb0ee63783d06c63b7d90bb382eea356ce", "target": 1, "func": "static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m)\n\n{\n\n    char *tx3g_ptr = avctx->extradata;\n\n    int i, box_size, font_length;\n\n    int8_t v_align, h_align;\n\n    int style_fontID;\n\n    StyleBox s_default;\n\n\n\n    m->count_f = 0;\n\n    m->ftab_entries = 0;\n\n    box_size = BOX_SIZE_INITIAL; /* Size till ftab_entries */\n\n    if (avctx->extradata_size < box_size)\n\n        return -1;\n\n\n\n    // Display Flags\n\n    tx3g_ptr += 4;\n\n    // Alignment\n\n    h_align = *tx3g_ptr++;\n\n    v_align = *tx3g_ptr++;\n\n    if (h_align == 0) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_LEFT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_LEFT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_LEFT;\n\n    }\n\n    if (h_align == 1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_CENTER;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_CENTER;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_CENTER;\n\n    }\n\n    if (h_align == -1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_RIGHT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_RIGHT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_RIGHT;\n\n    }\n\n    // Background Color\n\n    m->d.back_color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // BoxRecord\n\n    tx3g_ptr += 8;\n\n    // StyleRecord\n\n    tx3g_ptr += 4;\n\n    // fontID\n\n    style_fontID = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n    // face-style-flags\n\n    s_default.style_flag = *tx3g_ptr++;\n\n    m->d.bold = s_default.style_flag & STYLE_FLAG_BOLD;\n\n    m->d.italic = s_default.style_flag & STYLE_FLAG_ITALIC;\n\n    m->d.underline = s_default.style_flag & STYLE_FLAG_UNDERLINE;\n\n    // fontsize\n\n    m->d.fontsize = *tx3g_ptr++;\n\n    // Primary color\n\n    m->d.color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // FontRecord\n\n    // FontRecord Size\n\n    tx3g_ptr += 4;\n\n    // ftab\n\n    tx3g_ptr += 4;\n\n\n\n    m->ftab_entries = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n\n\n        box_size += 3;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp = av_malloc(sizeof(*m->ftab_temp));\n\n        if (!m->ftab_temp) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        m->ftab_temp->fontID = AV_RB16(tx3g_ptr);\n\n        tx3g_ptr += 2;\n\n        font_length = *tx3g_ptr++;\n\n\n\n        box_size = box_size + font_length;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp->font = av_malloc(font_length + 1);\n\n        if (!m->ftab_temp->font) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(m->ftab_temp->font, tx3g_ptr, font_length);\n\n        m->ftab_temp->font[font_length] = '\\0';\n\n        av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp);\n\n        if (!m->ftab) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        tx3g_ptr = tx3g_ptr + font_length;\n\n    }\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n        if (style_fontID == m->ftab[i]->fontID)\n\n            m->d.font = m->ftab[i]->font;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11488, "substitutes": {"avctx": ["svcmp", "avconfig", "svtx", "vercontext", "avtx", " avconfig", "afctx", "avecmp", "ovtx", "verctx", "avcp", "ovcmp", " avcp", "avcmp", "verconfig", "Avctx", "svctx", "avecontext", "afcmp", " avcontext", "ovcontext", "ovctx", "svcontext", "Avcp", "Avcontext", " avtx", "avetx", "aftx", "Avconfig", "afcontext", "avcontext", "avectx", " avcmp", "vercp"], "m": ["p", "mm", "h", "mail", "um", "km", "em", "mat", "M", "v", "cm", "perm", "hm", "om", "dm", "tm", "them", "media", "am", "mac", "j", "mod", "an", "vm", "rem", "rm", "n", "me", "sm", "nm", "item", "mean", "md", "g", "b", "d", "met", "mt", "fm", "wm", "s", "mk", "dim", "gm", "mn", "min", "esm", "pm", "mr", "module", "c", "mc", "t", "mi", "mask", "im", "message", "mode", "man", "ms", "bm", "msg"], "tx3g_ptr": ["tx3j__rep", "tx3d_len", "tx3g7pointer", "tx3g4ser", "tx3g___ptr", "tx3g___iter", "tx3d_peer", "tx3g__rep", "tx3g7ped", "tx3g_ser", "tx3gMemlen", "tx3g_dep", "tx3g_ctr", "tx3j_rep", "tx3g__tr", "tx3g64ptr", "tx3g__tp", "tx3gMemPtr", "tx3g_tp", "tx3goxpert", "tx3g_len", "tx3sg_addr", "tx3goxinst", "tx3j_tr", "tx3g___ped", "tx3d_ptr", "tx3group_pointer", "tx3d_ser", "tx3d_pad", "tx3d_pert", "tx3g64pert", "tx3gc_pers", "tx3g_desc", "tx3d_inst", "tx3d_ped", "tx3d_tr", "tx3g64addr", "tx3g4pointer", "tx3group7pointer", "tx3group_ped", "tx3sg_pointer", "tx3g_Ptr", "tx3group7ped", "tx3g_addr", "tx3gc_ptr", "tx3g64inst", "tx3j__tp", "tx3d_addr", "tx3g_ped", "tx3g_pad", "tx3g7ptr", "tx3goxptr", "tx3gMempointer", "tx3sg_ptr", "tx3g_pert", "tx3d_pointer", "tx3g___pers", "tx3group_ptr", "tx3group7iter", "tx3gc_pointer", "tx3g4ptr", "tx3j_tp", "tx3g__ptr", "tx3d_ctr", "tx3j__ptr", "tx3g___pointer", "tx3d_desc", "tx3sg_dep", "tx3g_tr", "tx3goxaddr", "tx3g__addr", "tx3g___pert", "tx3g_pointer", "tx3group7ptr", "tx3g4Ptr", "tx3g7iter", "tx3g__peer", "tx3g__pointer", "tx3g__ctr", "tx3g_iter", "tx3d_Ptr", "tx3gMemptr", "tx3j__tr", "tx3g_pers", "tx3g_inst", "tx3g__pad", "tx3gc_pert", "tx3g_rep", "tx3g_peer", "tx3g__Ptr", "tx3group_iter", "tx3j_ptr"], "i": ["r", "di", "p", " ti", "f", "v", "ei", " fi", "j", "I", "o", "b", "er", "si", " v", " bi", "it", " ni", "c", " f", " di", "t", "ip", " j", " c", "ti", "ta", "e"], "box_size": ["box_shape", " box1length", " box2length", " box1scale", "box1SIZE", " box_scale", "box1scale", "box2length", "box_length", "box1size", " box2scale", "box2SIZE", "box2size", " box2SIZE", "box_scale", "box_SIZE", " box1SIZE", " box_shape", " box_length", " box1size", " box2shape", "box1length", "box2scale", "box2shape", " box_SIZE", " box2size"], "font_length": ["fontletsize", "font_size", " font_len", "font_depth", "font_len", " font_depth", "fontletlen", "fontletdepth", " font_size", "fontletlength"], "v_align": ["V_angle", "h_fill", "nv_match", "iv_move", "v_rank", "qv_repeat", "vc_adjust", "v___alter", "h_nav", "v_repeat", "vPrang", "vmmnav", "V_length", "v0alter", "v__align", "cv_label", "v0adj", "v_block", "h_ign", "version_align", "v_adj", "vcPignore", "v_ignore", "v_play", "v8length", "h_offset", "vcPalign", "v__offset", "v_label", "v_angle", "v0align", "v_fill", "v_cmp", "vv_align", "vPfill", "v_move", "version_block", "cv_rang", "version_cmp", "cv_loc", "qv_align", "v8align", "v_rang", "vc_ignore", "vv___play", "vPnav", "var_rank", "vc_skip", "nv_skip", "v_alter", "vmyrank", "vmyskip", "vmmfill", "v8al", "vPcmp", "v_ign", "vPlabel", "v_direction", "v_aff", "v_aligned", "h_aligned", "vmmaligned", "vc_align", "vmmalign", "v_loc", "V_al", "v___adj", "vPalign", "vcPskip", "vmyfill", "v_nav", "qv_nav", "vPblock", "iv_ign", "h_angle", "iv_aff", "v0play", "vPloc", "v_length", "v_offset", "v_adjust", "cv_align", "vmydirection", "v___align", "vPignore", "v_al", "version_adjust", "vmyadjust", "v__angle", "vPaligned", "vv___alter", "var_align", "vv___align", "vcPadjust", "vv_play", "vv___adj", "var_fill", "vmyignore", "V_align", "v_match", "v___play", "v_layout", "var_direction", "v__ign", "vPadjust", "vmyalign", "vv_alter", "v_skip", "qv_offset", "nv_align", "v8angle", "vPskip", "iv_align", "nv_layout", "vv_adj"], "h_align": ["H_align", "h_adj", "h__ign", "hhPaug", "h9align", " h_aligned", "hh_align", "h9aligned", "h_ign", "hPaligned", "v_angle", "hPaug", "hh_aff", "h_num", "h_sign", "h__angle", "h_direction", "h_format", " h_adj", "hhPaligned", "hmmalign", "v_direction", "h_aligned", "H_num", " h_sign", "h9format", "h_aff", "hh_aligned", "h_angle", "h9num", "H_format", "h__align", "h_layout", "hhPalign", "H_aligned", "hh_aug", " h_ign", " h_angle", "hPaff", "hmmangle", "v_layout", "hmmdirection", "hmmlayout", "h__aligned", "h_aug", "hPalign", "hhPaff"], "style_fontID": ["style_FontType", "style_FontName", "style_fontName", "style_sheetIDs", "style_familyID", "style_FontID", "style_textID", "style_fontid", "style_fontIDs", "style_familyIDs", "style_faceName", "style_faceType", "style_familyName", "style_textName", "style_FontIDs", "style_sheetID", "style_faceID", "style_textIDs", "style_faceIDs", "style_sheetid", "style_sheetName", "style_Fontid", "style_familyType", "style_textid", "style_fontType"], "s_default": ["s___default", "s_def", "s_FAULT", "solydef", " sptcurrent", "s_Default", "sptcurrent", "ts_force", " sptFAULT", "s_new", "s____Default", "solyforce", " sptDefault", "ds_best", "s___force", "s____new", " s_new", " s_FAULT", "s_primary", "sptDefault", "ts_def", "s_best", "sptdefault", "s_current", "s_force", "ds_default", " s_current", "s___def", "ds_primary", "sptFAULT", "solydefault", " sptdefault", "ts_default", "s___primary", "s____default", " s_Default", "s___best"]}}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 11501, "substitutes": {"chr": [" chor", "echrs", "echrb", "Chrs", "Chor", "chrs", "echar", " chrb", "echsr", "Chrb", "chsr", "chrb", "chor", "chdr", "chedr", " chrs", "inchrs", "chers", "inchr", "Char", "Chr", "echr", "Chdr", "Chsr", "cher", "inchsr", "inchrb", "cheor", " chdr"], "mouse": ["write", " mice", "where", "ma", " cursor", "master", "paste", "de", "mate", "mass", "mor", "Mouse", "mmm", "sample", "query", "shell", "mo", "ole", "hello", "fake", "key", " me", "click", "server", "pointer", "domain", "remote", "my", "oused", "hover", "menu", "print", "le", "yahoo", "address", "che", "user", "ouse", "none", "local", "go", "MI", "voice", "focus", "m", " microphone", "mallow", "ime", "hand", "console", "mi", "mx", "press", "mc", "memory", "ping", "cookie", "me", "ms", " clay", " gorilla"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n", "idx": 11516, "substitutes": {"ret": ["oret", "ts", "pret", "flag", "RET", "red", "ft", "git", "cont", " Ret", "re", "pet", "compl", "result", "gt", "Ret", " RET", "deg", "val", "rem", "rm", "out", "lt", "nt", "rets", "iter", "vet", "back", "print", "mt", "leg", " alt", "def", "tr", "lit", "bool", "ext", "try", "get", "arr", "elt", "rt", "ref", "set", "reset", "reg", "it", "txt", "t", "et", "len", "res", "cert", "got", "det", "alt", "Return", "ter", " jet"]}}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "substitutes": {"tmpenv": ["mpdev", "dirtyenvironment", "imgenv", "tmptmp", "mkvar", "permenvironment", " tmpvar", "temptmp", "txttmp", "dirtyconn", "dirtyenv", "mptmp", "tempconn", "tmpconn", "cmpvar", "mpenv", "mkenvironment", "tmpv", "mpenvironment", "mintenv", " tmpenvironment", "permenv", "mpbuf", "imgenvironment", "txtbuf", "mintvar", " tmpbuf", "txtenv", "cmpenv", "cmpconn", "tmpdev", "permbuf", "imgvar", "imgen", "tempenv", " tmpdev", "mpv", "tempv", "tempbuf", "tempvar", "mkenv", "mken", "tmpen", "permdev", "mintenvironment", "cmpenvironment", "dirtyvar", "tempen", "tmpenvironment", "tempenvironment", "txtv", "tmpvar", "tmpbuf"], "envvar": [" envname", "entityvar", "envver", "enerlist", "enervar", "enval", " envlist", "tenval", "environmentfunc", "namevariable", "envVar", "namevar", "enerprop", "tenvariable", " envval", "entityvariable", "environmentlist", " envVar", " envpack", "enname", "envval", "tenvar", "envprev", "entitypack", "envname", " envvariable", " envfunc", "environmentver", "enerfunc", " envver", "enVar", "vname", "envpack", "vver", "enerver", "envvariable", "namepack", "entityval", "envariable", "enerprev", "environmentprev", "environmentvar", "environmentprop", "vvar", "enver", "envprop", " envprev", "envlist", "tenVar", " envprop", "envar", "envfunc", "nameval"], "envsave": ["enpsare", " envsare", "encsaved", " encsaved", "envsaver", "enfsare", "encsaves", "enpssave", "enlinesav", "envalsaves", "enlinesaved", "enfsave", " encssave", "encsave", "envalsave", " envalsaves", " envalsave", " envalsaver", " encsave", "envsare", "enlinessave", "envalsav", "enfssave", " encsare", "enpsaves", "encsaver", " envalssave", "encsav", " encsaver", "envsav", " envsaved", " encsav", "envalsaver", " envsaver", " envsaves", "envsaved", "enlinesave", "envsaves", "enfsaver", "enpsaver", "envalsaved", "encsare", "envalssave", "envssave", "encssave", " envssave", " envsav", "enpsave"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    unsigned char tag[5];\n\n    unsigned int flags = 0;\n\n    const int stream_index = pkt->stream_index;\n\n    int size               = pkt->size;\n\n    AVIContext *avi     = s->priv_data;\n\n    AVIOContext *pb     = s->pb;\n\n    AVIStream *avist    = s->streams[stream_index]->priv_data;\n\n    AVCodecParameters *par = s->streams[stream_index]->codecpar;\n\n\n\n    while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE &&\n\n           pkt->dts > avist->packet_count) {\n\n        AVPacket empty_packet;\n\n\n\n        av_init_packet(&empty_packet);\n\n        empty_packet.size         = 0;\n\n        empty_packet.data         = NULL;\n\n        empty_packet.stream_index = stream_index;\n\n        avi_write_packet(s, &empty_packet);\n\n    }\n\n    avist->packet_count++;\n\n\n\n    // Make sure to put an OpenDML chunk when the file size exceeds the limits\n\n    if (pb->seekable &&\n\n        (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) {\n\n        avi_write_ix(s);\n\n        ff_end_tag(pb, avi->movi_list);\n\n\n\n        if (avi->riff_id == 1)\n\n            avi_write_idx1(s);\n\n\n\n        ff_end_tag(pb, avi->riff_start);\n\n        avi->movi_list = avi_start_new_riff(s, pb, \"AVIX\", \"movi\");\n\n    }\n\n\n\n    avi_stream2fourcc(tag, stream_index, par->codec_type);\n\n    if (pkt->flags & AV_PKT_FLAG_KEY)\n\n        flags = 0x10;\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avist->audio_strm_length += size;\n\n\n\n    if (s->pb->seekable) {\n\n        int err;\n\n        AVIIndex *idx = &avist->indexes;\n\n        int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE;\n\n        int id = idx->entry % AVI_INDEX_CLUSTER_SIZE;\n\n        if (idx->ents_allocated <= idx->entry) {\n\n            if ((err = av_reallocp(&idx->cluster,\n\n                                   (cl + 1) * sizeof(*idx->cluster))) < 0) {\n\n                idx->ents_allocated = 0;\n\n                idx->entry          = 0;\n\n                return err;\n\n            }\n\n            idx->cluster[cl] =\n\n                av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry));\n\n            if (!idx->cluster[cl])\n\n                return -1;\n\n            idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE;\n\n        }\n\n\n\n        idx->cluster[cl][id].flags = flags;\n\n        idx->cluster[cl][id].pos   = avio_tell(pb) - avi->movi_list;\n\n        idx->cluster[cl][id].len   = size;\n\n        idx->entry++;\n\n    }\n\n\n\n    avio_write(pb, tag, 4);\n\n    avio_wl32(pb, size);\n\n    avio_write(pb, pkt->data, size);\n\n    if (size & 1)\n\n        avio_w8(pb, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 11527, "substitutes": {"s": ["self", "ts", "p", "ports", "changes", "fps", "h", "sb", "ats", "conf", "aps", "ses", "rs", "sa", "i", "ls", "v", "args", "sp", "ss", "es", "its", "settings", "tp", "bp", "ps", "gs", "j", "aws", "sports", "comm", "ops", "sts", "ex", "n", "sq", "fs", "sv", "actions", "b", "g", "is", "app", "a", "ins", "os", "times", "sg", "js", "sys", "ctx", "stats", "ds", "S", "c", "sis", "t", "sc", "pkg", "cs", "vp", "ims", "bs", "w", "qs", "ns"], "pkt": ["packet", "spnt", "spacket", "tkt", "apkt", "ppkat", "ckt", "wpkt", "Pct", "wpct", "pnt", "apkat", " pdu", "Pdu", "pdu", "tnt", "Ppt", "cacket", "ppkt", "spdu", "ppt", "dkt", "pct", "ddu", "wpacket", " pnt", "ppct", "spkt", "tacket", "cdu", "pkat", " pct", "dpt", "ppacket", "apacket", "Pkt", "wpnt", "Pnt", "dnt", " ppt", "tdu", "apct", " pkat", "Packet", " packet", "cnt"], "tag": ["dr", "flag", "seq", "sw", "cat", "type", "attr", "head", " TAG", "id", "data", "tar", "pack", "stat", "pair", "name", "pad", "start", "tags", "ix", "key", "rc", " Tag", "channel", "peg", "buf", "event", "prefix", "field", "var", "TAG", "node", "Tag", "offset", "txt", "pos", "ad", "row", "message", "mode", "stream", "length", "ag", "msg", "ac"], "avi": ["ui", "oti", "av", "ami", "news", "aaa", "mobi", "alist", "aaaa", "py", "opa", "ave", "jam", "sav", "sa", "pheus", "roo", "ata", "wav", "VI", "ai", "cam", "abba", " av", "eni", "wi", "media", "oga", "riot", "ano", "aver", "audi", "opus", "jac", "gra", "wiki", "nav", "oi", "kat", "pai", "feat", "avan", "ja", "video", "iv", "eas", "pan", "bis", "vi", "ia", "adi", "txt", "arf", "mi", "ogg", "aria", "apache", "pi", "au", "dit", "vp", "ifa", "gg", "afi", "ag"], "pb": ["pro", "p", "cb", "pl", "py", "sb", "snap", "prototype", "np", "wp", "tc", "conn", "lp", "proc", "pp", "typ", "nb", "sp", "pause", "tp", "dp", "pg", "bp", "pt", "ps", "prot", "uf", "tk", "bj", "apy", "new", "eb", "gp", "ub", "pub", "patch", "cv", "buf", "PB", "cp", "pool", "sv", "buff", "conv", "soc", "b", "td", "pa", "mb", "tab", "phys", "pan", "sys", "fp", "ctx", "tg", "wb", "mp", "txt", "stab", "buffer", "db", "rb", "resp", "pkg", "pi", "pc", "vp", "bs", "jp"], "avist": ["AViste", "avisted", "savists", " avistant", "awIST", "aveist", "avalister", "savert", "savistant", "ravister", "aveistent", "ravistic", "ajIST", "ajists", "avert", " aviste", "savister", "varist", "varistent", "avists", "averist", "averists", "averdist", "aviste", "avister", "ravist", "avalistic", "avdist", "varert", "ajist", "avalist", "avistic", "AVIST", " avistic", "raviste", " avister", "savisted", "avistent", "avIST", "aveisted", "awist", "savistent", " avists", "avaliste", "savist", "ajister", "ajistant", "avistant", " avdist", "averIST", "AVist", "varisted", " avIST", "awists", "aveert", "ajdist", "AVists", "awiste"], "par": ["pol", "pro", "p", "pas", "pic", "dr", "proc", "kar", "ar", "pp", "pre", "params", "cam", "tar", "war", "rec", "ps", "rep", "ran", "Par", "kat", "rel", "cp", "pa", "ph", "parse", "def", "param", "var", "arp", "tx", "cmp", "pard", "rar", "prop", "req", "mp", "part", "per", "prep", "decl", "pi", "pkg", "pc", "comp", "arg", "jp", "pri"], "empty_packet": ["empty_packpet", "empty_palpet", "empty_PackET", "empty_mixET", "empty_pet", "empty_payel", "empty_buckET", "empty_Packacket", "empty_packline", "empty_prese", "empty_packageet", "empty_octacket", "empty_mixets", "empty_codacket", "empty_pacET", "empty_packe", "empty_codant", "empty_octpet", "empty_maskpoint", "empty_octet", "empty_packets", "empty_pickacket", "empty_Packetting", "empty_bucket", "empty_palacket", "empty_packette", "empty_packeter", "empty_palet", "empty_codet", "empty_masket", "empty_packel", "empty_packacket", "empty_packageetting", "empty_pacet", "empty_pacette", "empty_packageline", "empty_packant", "empty_buckacket", "empty_pET", "empty_packageET", "empty_maskette", "empty_packpoint", "empty_payet", "empty_preset", "empty_pel", "empty_packetting", "empty_buckpet", "empty_packageets", "empty_octeter", "empty_mixet", "empty_presant", "empty_pickline", "empty_code", "empty_presacket", "empty_bucketting", "empty_pickette", "empty_paye", "empty_mixline", "empty_pacpoint", "empty_maskET", "empty_packET", "empty_pickel", "empty_payant", "empty_payacket", "empty_paleter", "empty_pickpoint", "empty_payET", "empty_packageacket", "empty_pickET", "empty_bucketer", "empty_pickets", "empty_Packet", "empty_picket"], "packet_count": ["packacket_id", "packet_Count", "packet__total", "packet_counter", "packet__count", "packacket_counter", "packacket_length", "packacket_Count", "packacket_count", "packet__Count", "packacket_total", "packet__counter", "packet_length", "packet_id", "packet_total"], "err": ["r", "flag", "coord", "rr", "type", "str", "usr", "code", " next", "Error", " ptr", " fid", "line", "count", "er", "act", "ach", " ok", " error", "oe", " resp", "pos", " score", " res", "resp", "e", "ptr", "error"], "idx": [" idn", "indn", "indxes", "iddx", "idex", " idxes", "cont", " idex", " idxd", "new", "idxd", "identx", "identxd", "obj", "index", "identex", "_", " idch", " riddx", "cmp", "indx", " iddx", "idxes", "fp", "indch", "inddx", "idn", "c", "identn", " ridch", "idch", "indxd", " ridex", " ridx", "identxes"], "entry": ["or", "ent", "instance", "directory", "enter", "next", "member", "link", "id", "primary", "connection", "ident", "result", "meta", "query", "nr", "new", "key", "ex", "count", "ie", "index", "try", "quick", "ry", "view", "inter", "counter", "exclusive", "existent", "row", "Entry", "mid", "element", "low", "error"]}}
{"project": "FFmpeg", "commit_id": "0d021cc8b30a6f81c27fbeca7f99f1ee7a20acf8", "target": 0, "func": "static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)\n\n{\n\n    if (err != CUDA_SUCCESS) {\n\n        av_log(avctx, AV_LOG_FATAL, \">> %s - failed with error code 0x%x\\n\", func, err);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 11529, "substitutes": {"avctx": ["wavctx", " avkt", "AVcontext", "wavkt", "avecontext", " avContext", " avcontext", "avca", "wavgc", "wavcontext", "avekt", " avgc", " avca", "AVContext", "AVca", "avgc", "wavca", "avContext", "AVctx", "avkt", "avegc", "avcontext", "avectx", "wavContext"], "err": ["r", "cb", "cr", "die", "off", "Er", "proc", "ev", "rs", "attr", "coord", "rr", "ERROR", "rank", "addr", "cur", "norm", "fee", "result", "usr", "lr", "code", "nr", "Error", "unc", "ex", "exc", "rc", "n", "cv", "buf", "diff", "er", "cer", "ner", "ec", "ah", "arr", "desc", "cmp", "sys", "ctx", "kr", "req", "c", "status", "res", "rb", "inner", "resp", "e", "msg", "error", "cmd"], "func": ["util", "cb", "proc", "fun", "cf", "attr", "f", "args", "exec", "fc", "function", "mac", "lambda", "unc", "cc", "obj", "cast", "fn", "act", "impl", "var", "package", "tx", "sys", "task", "ctx", "kw", "callback", "con", "pkg", "aux", "grid", "doc", "comp", "fac", "spec", "conv", "cmd"]}}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    const AVCodec *dec;\n\n    char val_str[128];\n\n    const char *s;\n\n    AVRational sar, dar;\n\n    AVBPrint pbuf;\n\n\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n\n\n    print_int(\"index\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        const char *profile = NULL;\n\n        dec = dec_ctx->codec;\n\n        if (dec) {\n\n            print_str(\"codec_name\", dec->name);\n\n            if (!do_bitexact) {\n\n                if (dec->long_name) print_str    (\"codec_long_name\", dec->long_name);\n\n                else                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        } else {\n\n            print_str_opt(\"codec_name\", \"unknown\");\n\n            if (!do_bitexact) {\n\n                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        }\n\n\n\n        if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile)))\n\n            print_str(\"profile\", profile);\n\n        else\n\n            print_str_opt(\"profile\", \"unknown\");\n\n\n\n        s = av_get_media_type_string(dec_ctx->codec_type);\n\n        if (s) print_str    (\"codec_type\", s);\n\n        else   print_str_opt(\"codec_type\", \"unknown\");\n\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        print_str(\"codec_tag_string\",    val_str);\n\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            print_int(\"width\",        dec_ctx->width);\n\n            print_int(\"height\",       dec_ctx->height);\n\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n\n            sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n\n            if (sar.den) {\n\n                print_q(\"sample_aspect_ratio\", sar, ':');\n\n                av_reduce(&dar.num, &dar.den,\n\n                          dec_ctx->width  * sar.num,\n\n                          dec_ctx->height * sar.den,\n\n                          1024*1024);\n\n                print_q(\"display_aspect_ratio\", dar, ':');\n\n            } else {\n\n                print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n\n                print_str_opt(\"display_aspect_ratio\", \"N/A\");\n\n            }\n\n            s = av_get_pix_fmt_name(dec_ctx->pix_fmt);\n\n            if (s) print_str    (\"pix_fmt\", s);\n\n            else   print_str_opt(\"pix_fmt\", \"unknown\");\n\n            print_int(\"level\",   dec_ctx->level);\n\n            if (dec_ctx->timecode_frame_start >= 0) {\n\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n\n                av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n\n                print_str(\"timecode\", tcbuf);\n\n            } else {\n\n                print_str_opt(\"timecode\", \"N/A\");\n\n            }\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            s = av_get_sample_fmt_name(dec_ctx->sample_fmt);\n\n            if (s) print_str    (\"sample_fmt\", s);\n\n            else   print_str_opt(\"sample_fmt\", \"unknown\");\n\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n\n            print_int(\"channels\",        dec_ctx->channels);\n\n\n\n            if (dec_ctx->channel_layout) {\n\n                av_bprint_clear(&pbuf);\n\n                av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout);\n\n                print_str    (\"channel_layout\", pbuf.str);\n\n            } else {\n\n                print_str_opt(\"channel_layout\", \"unknown\");\n\n            }\n\n\n\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            if (dec_ctx->width)\n\n                print_int(\"width\",       dec_ctx->width);\n\n            else\n\n                print_str_opt(\"width\",   \"N/A\");\n\n            if (dec_ctx->height)\n\n                print_int(\"height\",      dec_ctx->height);\n\n            else\n\n                print_str_opt(\"height\",  \"N/A\");\n\n            break;\n\n        }\n\n    } else {\n\n        print_str_opt(\"codec_type\", \"unknown\");\n\n    }\n\n    if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n\n        const AVOption *opt = NULL;\n\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n\n            uint8_t *str;\n\n            if (opt->flags) continue;\n\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n\n                print_str(opt->name, str);\n\n                av_free(str);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n\n    else                                          print_str_opt(\"id\", \"N/A\");\n\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n\n    print_q(\"time_base\",      stream->time_base,      '/');\n\n    print_ts  (\"start_pts\",   stream->start_time);\n\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n\n    print_ts  (\"duration_ts\", stream->duration);\n\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n\n    if (dec_ctx->bit_rate > 0) print_val    (\"bit_rate\", dec_ctx->bit_rate, unit_bit_per_second_str);\n\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n\n    if (do_show_data)\n\n        writer_print_data(w, \"extradata\", dec_ctx->extradata,\n\n                                          dec_ctx->extradata_size);\n\n\n\n    /* Print disposition information */\n\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n\n    } while (0)\n\n\n\n    if (do_show_stream_disposition) {\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n\n    PRINT_DISPOSITION(DUB,              \"dub\");\n\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n\n    writer_print_section_footer(w);\n\n    }\n\n\n\n    show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n\n    fflush(stdout);\n\n}\n", "idx": 11535, "substitutes": {"w": ["r", "self", "p", "writer", "write", "h", "x", "wp", "sw", "f", "v", "wr", "z", "W", "l", "window", "n", "ew", "wx", "g", "b", "d", "wh", "iw", "wt", "m", "c", "wa", "wb", "t", "nw", "kw", "rw", "we", "word", "man", "hw", "wal"], "fmt_ctx": ["fmtPrec", "flt_context", "ffm_cp", "fmtPobj", "flt_rec", "flt_obj", "fmt_obj", "fmtPcontext", "fmt_rec", "flt_ctx", "fmt_tx", "fmtPctx", "fmt_cp", "ffm_tx", "fmt_context", "ffm_ctx", "ffm_context"], "stream_idx": ["stream_idxf", "stream_idn", "stream_indx", "stream_inn", "stream_indy", "stream_indg", "stream_ridx", "stream_idg", "stream_iny", "stream_idy", "stream_ridy", "stream_ing", "stream_inx", "stream_indxf", "stream_indxc", "stream_indn", "stream_ridxc", "stream_idxc", "stream_ridxf"], "in_program": ["inplaceembed", "in_resource", "inmaybeProgram", " in_video", "inmaybescript", " in_Program", "in_script", "inplaceProgram", "in_embed", "inplaceprogram", "in_video", " in_resource", "inplaceresource", "inplacevideo", "inplacescript", " in_embed", " in_script", "in_Program", "inmaybevideo", "inmaybeprogram"], "stream": ["ack", "dev", "instance", "sw", "cf", "iterator", "Stream", "accept", "read", "download", "clean", "data", "reader", "sche", "hook", "feed", "window", "raw", "channel", "store", "time", "seek", "sl", "serv", "form", "video", "transform", "sam", "uu", "sign", "path", "ec", "REAM", "spect", "ream", "each", "view", "wrapper", "open", "draw", "console", "chain", "sc", "decl", "row", "ocr", "valid", "message", "context", "host", "length"], "dec_ctx": ["dec___act", "dec_req", "dec2cmp", "dec_tx", "dec2conn", "decl_context", "decptkw", "Dec_kw", "decptcontext", " dec2obj", "ec_tx", "dec5cmp", "Dec_context", "ec_ctx", "dec5tx", "dec_pkg", "dec2pop", "dec2obj", "dec_loc", " dec2ctx", "dec_conn", "dec_act", "ec_obj", "dec5pop", "dec2tx", "dec5list", "dec5obj", "decolyctx", "dec2ctx", "decptctx", "decpttx", "dec5ctx", "dec___ctx", "ec_req", "ec_context", "Dec_act", " dec_obj", "ec_cmp", "Dec_tx", " dec2cmp", "dec2context", "dec_handle", "decl_obj", "decolyconn", "dec_obj", "ec_handle", "decl_ctx", " dec_cmp", "dec5kw", "decolytx", "Dec_ctx", "decl_tx", "Dec_handle", "ec_conn", "Dec_pkg", "decolycmp", "dec___pkg", "dec_pop", "ec_kw", " dec2pop", "Dec_list", "ec_loc", " dec_pop", "dec_context", "dec___tx", "decpthandle", "dec_kw", "decptobj", "dec_list", "dec_cmp"], "val_str": ["valPbuf", "val_res", "val2def", "val_Str", "val_buf", "val2buf", " val2arr", "val_int", " val_arr", " val2Str", " val2int", "vals_st", "val9string", "val2int", " val_string", "val2res", "vals_arr", " val_br", "val9buf", "val2txt", "vals2str", " val_int", "vals_def", "vals2buf", " val2string", "val_st", "val2br", "valpystr", "vals_res", " val2txt", " val2br", "val9str", " val2str", "vals_str", "valpytxt", "val9def", "valPstring", "val_string", "val2st", "vals2st", "val2string", "valpyStr", "vals_string", " val_txt", "val_arr", "vals2def", "val2str", "valPdef", "valpyarr", "valPstr", " val_Str", "val_def", "val_txt", "vals2string", "vals2res", "vals2arr", "val2arr", "val2Str", "vals_buf", "val_br"], "s": ["r", "ts", "p", "h", "ats", "rs", "sa", "v", "i", "ls", "sp", "ss", "its", "spe", "l", "ps", "gs", "sts", "u", "space", "n", "sq", "sv", "a", "sl", "g", "b", "fs", "si", "sam", "os", "q", "set", "js", "stats", "ds", "ns", "hs", "m", "S", "c", "so", "t", "https", "sc", "spec", "series", "cs", "ims", "bs", "gets", "ins"], "sar": ["tra", "Sra", "svra", "sra"], "dar": ["camera", "pro", "platform", "pas", "dr", "ar", "der", "PAR", "primary", "mar", "mac", "family", "ara", "da", "par", "def", "car", "dim", "raf", "AR", "pard", "lan", "rar", "rac", "ta", "star", "series", "ram"], "pbuf": ["rbuff", "spuf", "opbuf", "pbuffer", "tbuff", "tbuffer", "pbuff", "spbuffer", "tbuf", "rbuf", "rbuffer", "opbuff", " pbuffer", " puf", "opbuffer", "spbuff", "ruf", "spbuf", "tuf", "puf", "opuf", " pbuff"], "profile": ["pro", "platform", "usage", "p", "pl", "pr", "proc", "feature", "slot", "gpu", "tag", "type", "frame", "role", "name", "filename", "sample", "group", "username", "family", "depth", "Profile", "picture", "program", "component", "key", "parent", "summary", "policy", "PRO", "pool", "prof", "property", "soc", "relation", "history", "kh", "ph", "pse", "path", "character", "user", "display", "performance", "local", "style", "face", "phy", "prop", "pen", "alias", "buffer", "port", "source", "prime", "option", "description", "context", "vp", "cpu", "screen"]}}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}", "idx": 11543, "substitutes": {"gb": [" GB", "GB", "sync", "cb", "bf", "sb", "py", "gh", "html", "goo", "gif", "mg", "nb", "pb", "cfg", "gd", "pg", "bc", "vg", "gov", "sys", "gs", "gt", "sky", "eg", "bb", "google", "arb", "bitcoin", "gp", "ib", "rg", "server", "bt", "g", "Gb", "mb", "hub", "kb", "gm", "sg", "bridge", "gu", "ctx", "hog", "ry", "tg", "ssl", "phy", "gue", "ym", "db", "rb", "bg", "gc", "pc", "msg", "hw", "gg", "bm", "img"], "block": ["list", "Block", "mem", "bin", "unit", "lp", "type", "un", "pack", "pb", "data", "bc", "axis", "group", "map", "cl", "lock", "new", "bl", "ml", "BL", "out", "obj", "b", "blocks", "cache", "ch", "field", "local", "zero", "set", "ref", "q", "box", "byte", "chain", "buffer", "base", "row", "bm"], "scan": ["seq", "feature", "bin", "tc", "op", "fee", "call", "mac", "access", "map", "rc", "cas", "form", "scale", "cache", "act", "ach", "sys", " dc", "mic", "ann", "sc", "sum", "ad", "doc", "pc", "aa"], "quant": ["util", "ent", "final", "comment", "acc", "dq", "mult", "cur", "wait", "query", "good", "depth", "inc", "sq", "quad", "form", "Quant", "dat", "quick", "desc", "q", " dc", "qi", "draw", "frac", "doc", "comp", "fac", "spec"], "coeff": [" coff", "Coefficient", "Coeff", "coef", "COeff", " coeffic", " Coff", "coeeff", "COff", "coff", " Coeff", "foefficient", " coef", "foeffic", "coeef", "coxeff", "COefficient", "Coeffic", "coxeffic", "COef", " Coef", "foeff", "coefficient", " coefficient", "Coef", "yeseff", "coxefficient", "coeffic", "coverage", "yeseffic", "coeverage", "yesef", " Coefficient", "conefficient", "conef", "converage", "coneff", "foef", "COverage", "Coff", "conff", "coxef", "COeffic", "yesff"], "i": ["p", "x", "f", "v", "ic", "ai", "ind", "l", "ii", "j", "I", "ix", "bi", "b", "g", "si", "index", "y", "ci", "m", "c", "t", "mi", "ij", "pi", "k"], "n": ["p", "no", "nn", "nat", "nb", "N", "nc", "l", "na", "nr", "pn", "nl", "ni", "nt", "ne", "nm", "count", "nan", "fn", "sn", "m", "c", "num", "len", "k", "mn", "cn", "ns"], "ac": ["func", "dc", "iac", "ace", "acl", "pac", "acc", "attr", "cap", "erc", "ic", "cam", "Ac", "fc", "bc", "abc", "mac", "acs", "uc", "jac", "cu", "cc", "unc", "AC", "ex", "cas", "fa", " cac", "app", "cache", "ec", "act", "ach", "sac", "ca", " acc", "aco", "it", "mic", "mc", "c", "gam", "ip", "auc", "anc", "rac", "oc", " lac", "ric", "aca", "vc", "pc", "alpha", "doc", "fac", "aa"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 11546, "substitutes": {"t0": [" t6", "tc01", "v0", "timeKey", " t2", "tc1", "T6", "tcKey", "T1", "p1", "th9", " tzero", "dt7", "t7", "time1", "time01", "p0", "lt7", "ltzero", "th6", " t7", "p2", "v2", "tKey", "T01", "T9", "dt0", "lt0", "t2", "t9", "t6", "dtzero", "th0", "T0", "t01", "time0", "TKey", " t9", "tzero", "tc0", "v1", "th1"], "t1": [" t3", "tone", "tOne", "p10", "v0", "T3", "t10", " t2", "tc1", "tt9", "v3", " t10", "T1", "p1", "t3", "tt1", "Tone", "p0", "pt2", "ttone", "vOne", "p2", "v2", "T9", "v9", " tone", "tt3", "TOne", "t2", "t9", "pt3", "T0", "pt0", "T10", "tcOne", "tt0", "tc2", " t9", "tc0", "v1", "T2", "pt1"], "rd": ["r", "ld", "rod", "rer", "cr", "dr", "nd", "hr", "dx", "ra", "red", "rs", "rr", "dd", "ri", "ird", "gd", "re", "rend", "ind", "rh", "rf", "fr", "new", "rob", "rm", "rc", "xd", "rg", "ru", "rl", "src", "md", "td", "d", "fd", "tr", "rax", "rt", "dra", "reg", "ds", "rn", "rx", "rb", "rw", "rust", "RD", "rid", "ptr"], "tmp": ["r", "pro", "mm", "snap", "tem", "py", "nd", "np", "proc", "tc", "attr", "rr", "pp", "ret", "dd", "test", "nb", "sp", "pb", "tm", "tar", "tz", "tp", "perm", "data", "err", "rf", "pt", "tk", "tt", "tn", "new", "rm", "rc", "cv", "nt", "obj", "temp", "null", "src", "vt", "emp", "td", "buff", "bt", "gz", "mb", "tv", "cache", "sam", "st", "mk", "tr", "etc", "copy", "false", "cmp", "rt", "tf", "ctx", "mp", "txt", "t", "buffer", "db", "rb", "rw", "table", "v", "resp", "pkg", "ptr", "jp"]}}
{"project": "FFmpeg", "commit_id": "6722e564a82bac471d92b02550b5017c09b539ba", "target": 0, "func": "static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n\n{\n\n    if (buf_size < 13)\n\n        return AVERROR_INVALIDDATA;\n\n    if (memcmp(buf, \"FLV\", 3))\n\n        return AVERROR_INVALIDDATA;\n\n    buf      += 13;\n\n    buf_size -= 13;\n\n    while (buf_size >= 11 + 4) {\n\n        int type = buf[0];\n\n        int size = AV_RB24(&buf[1]) + 11 + 4;\n\n        if (size > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n        if (type == 8 || type == 9) {\n\n            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n\n                return AVERROR_INVALIDDATA;\n\n            os->extra_packet_sizes[os->nb_extra_packets] = size;\n\n            os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n\n            if (!os->extra_packets[os->nb_extra_packets])\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n\n            os->nb_extra_packets++;\n\n        } else if (type == 0x12) {\n\n            if (os->metadata)\n\n                return AVERROR_INVALIDDATA;\n\n            os->metadata_size = size - 11 - 4;\n\n            os->metadata      = av_malloc(os->metadata_size);\n\n            if (!os->metadata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->metadata, buf + 11, os->metadata_size);\n\n        }\n\n        buf      += size;\n\n        buf_size -= size;\n\n    }\n\n    if (!os->metadata)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n", "idx": 11553, "substitutes": {"os": ["options", "OS", "aos", "bos", "ls", "loss", "om", "obs", "mos", "otes", "des", "cms", "ros", "los", "ok", "sys", "js", "ons", "io", "wcs", "ms", "mes", "ns", "oos", "ows", "oses", "boot", "ps", "acs", "ose", "rss", "dos", "fs", "eas", "ks", "oops", "stats", "ds", "oss", "rots", "et", "res", "cs", "ims", "oS", "ports", "ack", "windows", "soft", "ops", "at", "o", "is", "ions", "mot", "ips", "oids", "Os", "ones", "osi", "ot", "oid", "ss", "ast", "ox", "ost", "plays", "ans", "css", "reset", "ands", "pos", "bits", "bs", "ants"], "buf": ["limit", "aka", "cat", "err", "pack", "data", "end", "rc", "cp", "count", "buff", "cache", "var", "arr", "que", "ref", "Buff", "now", "len", "batch", "rb", "pkg", "ptr", "Buffer", "cmd", "h", "mem", "addr", "ob", "env", "code", "raw", "bar", "bt", "foo", "desc", "max", "req", "txt", "buffer", "block", "port", "msg", "p", "off", "seq", "cap", "coord", "pb", "cur", "bp", "uf", "start", "window", "tmp", "iter", "cast", "b", "bytes", "tr", "br", "vec", "prop", "doc", "ctr", "length", "func", "cb", "quote", "next", "v", "read", "alloc", "bc", "page", "bb", "cv", "queue", "box", "uv", "img"], "buf_size": ["buf_set", " buf_member", "buf5ize", "tab5SIZE", "buf_range", "tab_size", "buf_max", "buf_source", "tab_ize", "tab_SIZE", " buf_Size", "tab5sent", "uf_ize", "buf5sent", "buf_length", "uf_length", "uf_size", " buf_len", "buf5SIZE", " buf_max", "bufptmax", "buf_ize", "buf_len", "buf_num", "buf_SIZE", "tab5size", "uf_name", "bufptSize", "buf_sent", "buf5size", "buf_member", "uf_range", "buf_Size", "tab5ize", "bufptsize", "uf_Size", "buf_name", "uf_SIZE", "bufptsource", " buf_source", "tab_sent", "uf_set", " buf_num"], "nb_extra_packets": ["nb_extra_presETS", "nb_extra_packseters", "nb_extra_packessions", "nb_extra_packses", "nb_extra_bucketers", "nb_extra_packeters", "nb_extra_presets", "nb_extra_mixets", "nb_extra_peessions", "nb_extra_packet", "nb_extra_pETS", "nb_extra_itemstons", "nb_extra_preses", "nb_extra_packsages", "nb_extra_packstons", "nb_extra_packsces", "nb_extra_mixers", "nb_extra_pets", "nb_extra_presents", "nb_extra_packents", "nb_extra_peet", "nb_extra_packces", "nb_extra_packETS", "nb_extra_exages", "nb_extra_preset", "nb_extra_popces", "nb_extra_exets", "nb_extra_buckessions", "nb_extra_packsets", "nb_extra_packtons", "nb_extra_pents", "nb_extra_popages", "nb_extra_popet", "nb_extra_packset", "nb_extra_itemsets", "nb_extra_offstons", "nb_extra_exces", "nb_extra_packers", "nb_extra_packsessions", "nb_extra_popets", "nb_extra_itemset", "nb_extra_buckETS", "nb_extra_packsETS", "nb_extra_buckets", "nb_extra_packsers", "nb_extra_offsents", "nb_extra_mixet", "nb_extra_packes", "nb_extra_itemsETS", "nb_extra_offsets", "nb_extra_peETS", "nb_extra_offsETS", "nb_extra_preseters", "nb_extra_mixes", "nb_extra_offset", "nb_extra_bucket", "nb_extra_peets", "nb_extra_packages", "nb_extra_presers", "nb_extra_pet", "nb_extra_exet"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n    __get_user(regs->CP0_EPC, &sc->sc_pc);\n\n\n\n    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);\n\n    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);\n\n\n\n    for (i = 1; i < 32; ++i) {\n\n        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);\n\n    }\n\n\n\n    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);\n\n    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);\n\n    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);\n\n    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);\n\n    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);\n\n    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);\n\n    {\n\n        uint32_t dsp;\n\n        __get_user(dsp, &sc->sc_dsp);\n\n        cpu_wrdsp(dsp, 0x3ff, regs);\n\n    }\n\n\n\n    for (i = 0; i < 32; ++i) {\n\n        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 11566, "substitutes": {"i": ["ami", "cli", "x", "fire", "json", " ii", "ind", "ix", "iu", "u", "bi", "remote", "history", "index", "li", "go", "\u0438", "io", "this", "t", "batch", "ti", "gi", "ic", "iq", "ei", "I", "phi", "my", "ie", "info", "q", "it", "qi", "mi", "port", "ims", "me", "ui", "p", "init", "uri", "id", "xi", "sim", "oi", "ex", "multi", "o", "complete", "g", "y", "ini", "gu", "ci", "chain", "any", "pi", "php", "e", "us", "di", "list", "f", "v", "ri", "ai", "ii", "mac", "j", "ji", "in", "si", "m", "zi", "ip", " j", "point", "im"], "dsp": ["lSP", "rdsw", " dsi", "dnbsp", "dbsp", "rdspe", "dnSP", "nsp", "rdsi", "dspe", "rdsp", "lsp", " dSP", "dsw", "llp", "nspe", "rdlp", "dnlp", "nSP", " dspe", "rdSP", " dlp", "dSP", "lbsp", " dbsp", " dsw", "dlp", "dsi", "nsw", "dnsp", "dnsi"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_block_to_card(SDHCIState *s)\n\n{\n\n    int index = 0;\n\n\n\n    if (s->prnsts & SDHC_SPACE_AVAILABLE) {\n\n        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n            s->norintsts |= SDHC_NIS_WBUFRDY;\n\n        }\n\n        sdhci_update_irq(s);\n\n        return;\n\n    }\n\n\n\n    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n        if (s->blkcnt == 0) {\n\n            return;\n\n        } else {\n\n            s->blkcnt--;\n\n        }\n\n    }\n\n\n\n    for (index = 0; index < (s->blksize & 0x0fff); index++) {\n\n        sd_write_data(s->card, s->fifo_buffer[index]);\n\n    }\n\n\n\n    /* Next data can be written through BUFFER DATORT register */\n\n    s->prnsts |= SDHC_SPACE_AVAILABLE;\n\n\n\n    /* Finish transfer if that was the last block of data */\n\n    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n            ((s->trnmod & SDHC_TRNS_MULTI) &&\n\n            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n        s->norintsts |= SDHC_NIS_WBUFRDY;\n\n    }\n\n\n\n    /* Generate Block Gap Event if requested and if not the last block */\n\n    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&\n\n            s->blkcnt > 0) {\n\n        s->prnsts &= ~SDHC_DOING_WRITE;\n\n        if (s->norintstsen & SDHC_EISEN_BLKGAP) {\n\n            s->norintsts |= SDHC_EIS_BLKGAP;\n\n        }\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n}\n", "idx": 11592, "substitutes": {"s": ["changes", "sb", "ses", "events", "err", "ls", "ears", "xs", "aws", "comm", "south", "sv", "as", "er", "bis", "js", "sys", "t", "source", "se", "ms", "w", "ns", "less", "search", "sync", "h", "ats", "conf", "sw", "ies", "params", "ers", "stat", "ps", "acs", "an", "terms", "parts", "sq", "obj", "fs", "serv", "set", "esm", "stats", "ds", "comments", "services", "vs", "cs", "ims", "gets", "ports", "p", "span", "i", "its", "sports", "ex", "tests", "store", "is", "b", "eps", "os", "y", "hs", "us", "r", "ts", "rs", "v", "args", "es", "ss", "als", "z", "uploads", "gs", "sts", "n", "in", "service", "details", "states", "m", "S", "bits", "mods", "bs", "qs"], "blkcnt": ["blkmnc", "blkcacheaught", "blkcuraught", "blkgncounters", "blkcgt", "blkfcnt", "blknount", "blkCtx", "blkfcst", "blkgcounters", "blkscst", "blkgcaught", "blkmnt", "blksctx", "blkscnc", "blkncaught", "blkCount", "blkncent", "blckCnc", "blkdcnc", "blckcgt", "blksCount", "blckCgt", "blkgncent", "blckcnc", "blkdcount", "blkcachent", "blkncnt", "blksCst", "blkcountnt", "blkgncnt", "blkdcgt", "blkntx", "blkmgt", "blkcountount", "blkcaught", "blkscount", "blkcountst", "blkgncaught", "blkCnt", "blkcurent", "blkcacheent", "blksCtx", "blckCount", "blkmount", "blkcount", "blkcountnc", "blkcacheounters", "blkcurounters", "blkCgt", "blckcnt", "blckcount", "blkcent", "blkgcnt", "blkfcnc", "blksCnt", "blkCnc", "blkcurnt", "blkcst", "blknnc", "blkCst", "blkscnt", "blksCnc", "blckCnt", "blkdcnt", "blkcounters", "blkcnc", "blkctx", "blknnt", "blkgcent", "blkncounters", "blkfcount"], "index": ["update", "x", "instance", "where", "select", "condition", "i", "column", "head", "number", "primary", "length", "connection", "ind", "location", "connect", "axis", "capacity", "date", "position", "lock", "Index", "ix", "mix", "thread", "key", "ex", "label", "ice", "foot", "size", "count", "seek", "time", "loop", "handle", "empty", "set", "max", "offset", "EX", "face", "eight", "find", "open", "check", "num", "pos", "alias", "buffer", "loc", "row", "point", "prime", "IND", "context", "level", "address", "zero", "error"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n", "idx": 11608, "substitutes": {"s": ["r", "ts", "p", "less", "sync", "changes", "ports", "h", "sb", "ats", "sw", "ses", "rs", "su", "i", "v", "ls", "sa", "sh", "sp", "ss", "es", "its", "l", "ps", " is", "gs", "j", "comm", "sts", "n", "sq", "sm", "sv", "fs", "sl", "g", "is", "b", "a", "d", "sam", "ms", "y", "sd", "q", "set", "js", "stats", "ds", "hs", "m", "S", "c", "so", "t", "vs", "cs", "sub", "bs", "qs", "ns"], "cli": ["ui", "p", "cb", "qq", "seq", "tc", "uri", "i", "cm", "ls", "cfg", "eric", "iq", "command", "ii", "prot", "tk", "cl", "shell", "lc", "cu", "ico", "qt", "multi", "bi", "ni", "ctl", "cp", "lu", "prefix", "hi", "gz", "path", "li", "fp", "phy", "ci", "c", "ctrl", "txt", "ip", "mi", "cgi", "nu", "chip", "pi", "exe", "client", "cci", "cmd"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n", "idx": 11624, "substitutes": {"as": ["asis", "ts", "pas", "nas", "ats", "rs", "aos", "sa", "mas", "ar", "ast", "ais", "auth", "As", "ps", "am", "acs", "aws", "ias", "AS", "las", "ak", "a", "asar", "is", "pa", "s", "has", "ins", "os", "sac", "ms", "sys", "js", "ds", "oss", "ras", "sis", "ars", "asia", "ares", "aus", "ase", "asha", "asm", "us", "bs", "ass", "ask", "ns"], "d": ["di", "p", "ld", "dc", "nd", "od", "dr", "dx", "bd", "D", "i", "du", "dd", "de", "dot", "gd", "l", "ade", "disc", "dl", "dos", "n", "pd", "da", "des", "o", "md", "g", "did", "b", "mad", "dh", "dat", "fd", "sd", "amd", "dra", "dn", "ds", "dis", "c", "m", "dj", "ad", "db", "e", "ded", "w", "del"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n", "idx": 11631, "substitutes": {"s": ["sb", "sets", "ls", "ains", "rows", "ails", "d", "js", "c", "ists", "t", "ests", "eds", "ords", "w", "rates", "ns", "ins", "h", "ats", "ies", "ries", "ers", "ps", "parts", "sq", "fs", "a", "acts", "ches", "umps", "ds", " parts", " sets", " outputs", "ports", "p", "erences", "itions", "outs", "i", "its", " ads", "ents", "ments", "o", "g", "ions", "resses", "os", " returns", "ocks", "e", "r", "ts", " results", "rs", "v", "iffs", "alls", "ss", "als", "izes", " values", "j", "gs", "sts", "n", "ums", "aces", "ves", "m", "S", "ands", "ations", "ants", "aches"]}}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix_ide_initfn(PCIIDEState *d)\n\n{\n\n    uint8_t *pci_conf = d->dev.config;\n\n\n\n    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode\n\n    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);\n\n\n\n    qemu_register_reset(piix3_reset, d);\n\n\n\n    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);\n\n\n\n    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);\n\n\n\n    pci_piix_init_ports(d);\n\n\n\n    return 0;\n\n}\n", "idx": 11635, "substitutes": {"d": ["r", "di", "p", "done", "dc", "ld", "dev", "h", "dr", "nd", "dx", "bd", "D", "v", "dd", "de", "dm", "dom", "ind", "l", "dict", "j", "dl", "dt", "dos", "n", "o", "des", "da", "pd", "md", "g", "b", "did", "dh", "dat", "s", "fd", "sd", "q", "dn", "ds", "m", "c", "t", "ad", "db", "e", "ord", "w", "del"], "pci_conf": ["pci_fab", "pki_map", "pci__conn", "pci_cfg", "pci__config", "pki_conf", "pct_con", "pcm_config", "pct_fab", "pcm_conf", "pki_con", "pct_conf", "pci__cfg", "pcm_cfg", "pki_config", "pci_config", "pct_config", "pci__conf", "pcm_conn", "pci_conn", "pci_con", "pci_map"]}}
{"project": "qemu", "commit_id": "da3e8a23492dbc13c4b70d90b6ae42970624e63a", "target": 0, "func": "static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    DeviceState *qdev = DEVICE(vpci_dev);\n\n    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);\n\n    virtio_net_set_netclient_name(&dev->vdev, qdev->id,\n\n                                  object_get_typename(OBJECT(qdev)));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 11641, "substitutes": {"vpci_dev": ["vpci1device", "vpii_dec", "vpci_info", "vpci___info", "vpc_dev", "vpci___device", "vpci_ver", "vpii___conn", "vpcci_Dev", "vpc_info", "vpii___dev", "vpii_cur", "vpc_device", "vpci_conn", "vpci1info", "vpcci_dev", "vpci1dev", "vpcci_server", "vpii_dev", "vpci_des", "vpci_Dev", "vpci_device", "vpii_cmd", "vpci___dev", "vpii___cur", "vpci___des", "vpcci_val", "vpci___conn", "vpcci_ver", "vpii___des", "vpii_des", "vpii_conn", "vpci___cur", "vpci_cur", "vpci_cmd", "vpci___pub", "vpci___cmd", "vpii_pub", "vpci___Dev", "vpci_dec", "vpc_Dev", "vpci___dec", "vpcci_device", "vpci_pub", "vpci_server", "vpci1Dev", "vpci_val"], "errp": ["rrP", "errps", "riskwp", "Erpb", "riskps", "err", "errr", " errP", " errr", "rrr", "erping", "errping", "Erp", "rrp", " errwp", "errwp", " errps", "riskp", "erp", "riskpb", "Erwp", "errP", "erP", "Erps", " errpb", " errping", "rrping", "errpb"], "qdev": ["qgo", "dqdiv", "qudev", "iqdiv", "qqdiv", "dqdevice", "qmd", "qdata", "iqgo", "qvgo", "qqdata", "qudevice", "querymd", " qdevice", "qvdiv", "iqgu", "querydata", "querydev", "qumd", "qvgu", "qqgo", "eqdev", "eqdiv", "qdevice", "querydevice", "dqdev", "qqgu", "qgu", "qqdevice", "qqdev", "qvdev", "eqdevice", "qudata", "qdiv", " qdiv", "qqmd", "iqdev"], "dev": ["att", "develop", "die", "wd", "conf", "DEV", "Dev", "mem", "ev", "eng", "conn", "attr", "v", "dd", "test", "de", "data", "cam", "priv", "ver", "env", "window", "val", "raw", "hw", "debug", "device", "ve", "des", "buf", "serv", "d", "def", "dem", "var", "local", "go", "gu", "adv", "det", "doc", "cho", "w", "del", "cmd"], "vdev": ["vgo", "qgo", "mdev", "svdev", "qvalid", " vDev", "qde", "mvar", "svDev", " vcast", "vcast", "svvar", "cdevice", "pdef", "evvar", "vtdevice", "vtvalid", "evdef", " vvar", "evgo", "wDev", "mdef", "vev", "cdev", " vde", "mDev", "qev", "vde", " vvalid", "wev", " vev", "vdevice", "vtde", "qdevice", " vdef", "qapp", "vDev", "qcast", "qdef", "pdev", "vtdev", "pdevice", "vvalid", "vdef", " vgo", "qDev", "pgo", "wdev", "wdevice", "wcast", "vvar", "qvar", "mdevice", "cvar", "svdevice", "cDev", "vapp", " vapp", "evdev", "wapp", "mgo", " vdevice"]}}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n", "idx": 11642, "substitutes": {"dev": ["att", "pro", "p", "DEV", "Dev", "mem", "ev", "conn", "proc", "v", "de", "data", "serial", "cam", "priv", "usb", "pad", "ver", "device", "md", "serv", "grad", "d", "def", "dem", "ach", "iv", "sd", "adv", "Device", "phy", "disk", "ad", "nv", "hw", "w", "cmd"], "errp": ["errorpg", "dieP", "ererr", "rrpy", "errps", "erpy", "err", "errr", " errP", " errr", "iterp", "rrping", "rrr", "scorepg", "diep", "errping", "errpad", "rrps", "rrp", "errpg", "errpy", " errpg", "dier", "errpe", "rrpad", "erp", "erpe", "ererpy", "errorp", "errP", "errorpb", "scorepb", "erP", "ererp", "ererps", " errpe", "scoreP", " errpb", "errorP", "iterping", "ererpad", "iterps", "erps", "iterpad", "diepe", "ererping", "scorep", "errpb"], "nvram": ["navmm", "svroy", "nvma", "NVram", "nvnam", "cvrom", "nvsam", "vcscan", "npgram", "svdim", "svram", "nwmem", "nngram", "navrum", "nvrum", "nvmem", "svmem", "cvdim", "nvlim", "nvgram", "nwram", "navmem", "nvmm", "nvdim", "naviam", "uvrum", "nvrem", "vcgram", "NVrom", "vccam", "nnram", "navrom", "npram", " svcam", "cvlamm", "svmm", "svgram", "navarma", "svcam", "navyan", "nwgram", " svrum", "cviam", "uvmm", "NVgram", "vcarma", "nvroy", "svrum", "nvcam", "cvma", "nvarma", "svnam", "cvarma", "cvrum", "nvrix", "nvscan", "navma", "nnrum", "cvlim", "vcgam", " svram", "navrix", "nwsam", "svrom", "nvgam", "vcrem", "nviam", "vcsam", "uvsam", "navgram", "vcrix", "svrix", "vcdim", "uvgram", "navram", "vcram", "uvlim", "NViam", "nprom", "svsam", "svgam", "cvmm", "NVcam", "NVlamm", "npcam", "svrem", "nwiam", " svgram", "uvram", "cvrem", "uviam", "cvsam", "nvrom", "nnrom", "cvcam", "vcrom", "nvyan", "uvscan", "uvrom", "cvscan", "cvgram", "vcmm", "sviam", "cvnam", "nvlamm", "cvram", "vcma", "npyan", "navcam", "uvnam", "NVscan", "cvyan", "navlim", "npiam", "NVgam", "nwrom", "cvroy", "vclamm", "uvroy", "vciam", "uvcam", "navsam"], "ret": ["r", "pret", "flag", "RET", "red", "ft", "fun", "f", "err", " Ret", "success", "xt", "re", "gt", "Ret", "deg", "val", "ert", "reply", "rem", "after", "out", "nt", "rets", "back", "print", "mt", " alt", "try", "tr", "ext", "elt", "rt", "ref", "reset", "reg", "t", "len", "res", "cert", "det", "alt", "Return", "ter", "cmd"]}}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 11646, "substitutes": {"p": ["att", "r", "x", "h", "np", "wp", "proc", "lp", "f", "i", "pp", "v", "pre", "request", "op", "pb", "sp", "z", "tp", "bp", "l", "ps", "command", "pt", "j", "rep", "comm", "at", "progress", "process", "n", "o", "cp", "temp", "P", "post", "a", "b", "d", "app", "pa", "cache", "pers", "y", "local", "q", "pm", "fp", "pat", "c", "m", "power", "press", "t", "part", "req", "port", "ping", "ap", "pkg", "pi", "pc", "php", "vp", "w", "jp"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstU, dstV, src1, width);\n\n}\n", "idx": 11662, "substitutes": {"dstU": [" dndP", "sndU", "dndV", "dndU", "dstsA", "dstUp", "sndUV", "dSTG", "dSTUV", "dstUV", "destA", "dndG", " dndA", " dstUp", "sstUV", "sstG", "sndG", "sstU", " dstA", "dptV", "dndUV", "destU", " dndUp", "dSTU", "sstV", "dndP", "dstsP", "dstP", "sndV", "destP", "dptG", "dptU", "dstsUp", "dstG", "dstsU", "dptUV", " dndU", "dndUp", "destUp", " dstP", "dstA", "dSTV", "dndA"], "dstV": [" destVO", "DstN", "DestV", "dstUV", "dsrcN", "DstV", "dstN", "dntL", "dsrcV", "ddestUV", "DstL", "ddestV", "destU", " destU", " destV", "ddestL", "ddestN", "dsrcL", "dsetL", "dntU", "dntV", " dstL", "DstUV", "dntVO", "destL", "DestN", "dstL", "dstVO", "DestUV", "destV", " destL", "destUV", "DestL", "dsetVO", "destN", "destVO", "dsetU", " dstVO", "dsrcUV", "dsetV"], "src1": ["source1", "srcOne", "sourceOne", "rc1", " srcOne", "src01", "rc01", "src0", " src01", "rcOne", " src0", "source01", "rc0", "source0", "rc2", "source2"], "src2": ["rc1", "source3", "src3", " src3", "source1", "srcB", "sourceB", "rc2", "rcB", "source2", " srcB", "rc3"], "unused": ["unuse", " unavailable", " unUsed", "unavailable", "Unavailable", " unuse", "UnUsed", "unaluse", "Unuse", "unalused", "unalavailable", "unalUsed", "unUsed", "Unused"]}}
{"project": "FFmpeg", "commit_id": "30e256430eb88c6d4c382581b89bca171d79fbc0", "target": 0, "func": "int ff_thread_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->thread_opaque) {\n\n        av_log(avctx, AV_LOG_ERROR, \"avcodec_thread_init is ignored after avcodec_open\\n\");\n\n        return -1;\n\n    }\n\n\n\n#if HAVE_W32THREADS\n\n    w32thread_init();\n\n#endif\n\n\n\n    if (avctx->codec) {\n\n        validate_thread_parameters(avctx);\n\n\n\n        if (avctx->active_thread_type&FF_THREAD_SLICE)\n\n            return thread_init(avctx);\n\n        else if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            return frame_thread_init(avctx);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11665, "substitutes": {"avctx": ["afconn", "wavtx", "averctl", "cvctx", "iqcrit", "avecall", "avjac", "avcrit", "avepkg", "averctr", "averpkg", "wavkt", "avcmd", "svpool", "avercontext", "avct", "avecontext", "avejp", "iqct", "avepool", "avcall", "faxcaps", "averct", "cvkt", "afcontext", "AVctl", "avpool", "averkw", "wavctx", "svtx", "averkl", "avtx", "cvtx", "avcaps", "wavcmd", "iqsys", "averctx", "avkw", "wavcontext", "AVkl", "wavkl", " avkw", "AVctx", " avtx", "avpkg", "avectx", "afcaps", "avconn", "wavctl", "afsys", "averjac", "avjp", "afctx", "avesys", "avkl", "svctx", "averjp", "cvcontext", "avectr", "afctr", "avejac", "avctr", "svcontext", "avkt", " avjac", "afcall", "avercmd", "aftx", "avctl", "avcontext", "iqctx", "averconn", "avecrit", "avekw", " avconn", " avkt", "AVcmd", "faxctx", " avcontext", "avsys", "avertx", "aversys", "avect", "faxtx", " avjp", "avercrit", "afpool", "avecaps", "avetx", "faxcall", " avpkg"]}}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "substitutes": {"mr": ["r", "MT", "mm", "pr", "hr", "dr", "km", "rs", "irm", "rr", "hm", "vr", "Mr", "tm", "wr", "rpm", "nr", "ml", "rm", "sr", "lt", "rg", "nm", "older", "RM", "md", "shr", "mt", "mk", "tr", "gm", "rar", "pm", "kr", "adr", "m", "br", "rn", "mx", "ocr", "MR", "asm", "ctr", "ims", "ms", "bm", "mn", "drm"], "is_write": ["flagpubpost", "ispubwriting", "is_writing", "Is_written", "Is_write", "is_send", "flagpubwrit", "Is_only", "ispubwrite", "is_only", "Is_send", "flag_write", "is_read", "flag_writing", "is_control", "ispubpost", "Is_control", "ispubwrit", "flag_writ", "flagpubwrite", "is_post", "is_writ", "is_written", "Is_read", "flagpubwriting", "flag_post"]}}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!blk->serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(blk->conf.bs);\n\n        if (*dinfo->serial) {\n\n            blk->serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 11685, "substitutes": {"dev": ["pro", "av", "conf", "DEV", "Dev", "mem", "ev", "conn", "link", "v", "de", "sh", "vr", "data", "cam", "tech", "priv", "pad", "ver", "env", "val", "device", "out", "ve", "buf", "nt", "des", "obj", "d", "def", "dem", "info", "iv", "sd", "js", "gu", "adv", "dis", "disk", "ad", "res", "block", "db", "hw", "w", "cmd"], "blk": ["bleck", "blkw", "plK", "bkw", "slkt", "blkid", "blekid", "slck", "blek", "belak", "Blak", " blak", "slkg", " blck", "chkw", "plak", "blck", "plck", "bln", "BLak", "Blg", "Blk", "blj", " blkw", "BLkw", "BLk", "Blke", "belkw", "bkt", "Blj", "Bln", "bk", "blkt", " blkid", "bleak", " blkt", " blark", "bleke", "blark", "plark", "blK", "blockark", "slg", "slk", "plg", "sln", "slc", "bleK", "blg", "blb", "Blc", "chb", "llk", "chk", "llck", "plk", "blej", "llke", "llak", "belk", "chck", "blockck", "pln", " blke", "BLck", "BLK", "BLke", "blockk", "Blck", "BLark", "Blkid", "blockak", "blc", " blb", "bck", "plc", "bkg", "bb", "blkg", " blkg", "belck", "blke", "blak", " blj"], "s": ["changes", "sb", "ses", "ls", "aws", "comm", "des", "south", "sv", "as", "d", "bis", "js", "c", "https", "t", "source", "se", "ms", "w", "ins", "ns", "less", "sync", "h", "ats", "conf", "params", "qs", "settings", "ps", "http", "fs", "a", "sl", "serv", "sd", "set", "stats", "ds", "utils", "services", "vs", "cs", "ims", "gets", "ports", "p", "i", "sp", "its", "tests", "is", "b", "g", "os", "y", "hs", "us", "simple", "self", "ts", "r", "rs", "v", "args", "ss", "es", "als", "gs", "j", "sts", "n", "actions", "views", "details", "bs", "m", "S", "bits", "spec", "sports"], "cylinders": ["solidcles", "bilinders", "chelinders", "cylicans", "chelicans", "chelriers", "ylinders", "clikes", "shellicans", "ylicans", "clinders", "solidinders", "bilcles", "clcles", "cylikes", "shellriers", "bilsers", "cylsers", "solidikes", "clsers", "shellinders", "ylriers", "cylriers", "cylcles", "solidsers", "bilikes"], "heads": ["aunts", "storms", "nuts", "head", " hangs", "rows", "uploads", "headed", "ads", "stocks", "quarters", "loads", "cles", "links", " bends", "anches", "views", "blocks", "uds", "mers", "offs", "reads", "tails", "headers", "helps", "HEAD", "guards", " Heads", "masters", "inks", "hops", "tips", "ths", "locks", "cycles", "olds", "bs", "hz", "thens"], "secs": ["sects", "rupts", "Secs", "Secis", "Secls", "secondsls", "secondss", "secns", "reqts", "reqs", "secondsns", "secis", " secns", "ruptls", "reqns", " sects", "secondsts", "ruptis", " secps", "reqls", "ruptps", "secls", "secps", " secls", "Secps", " secis"], "virtio_blk_id": ["virtio_blkPid", "virtio_block_name", "virtio_blk_name", "virtio_blkPi", "virtio_block__name", "virtio_blk__no", "virtio_blck_i", "virtio_blkPnum", "virtio_blck_num", "virtio_block__no", "virtio_blk_num", "virtio_blk__name", "virtio_block_id", "virtio_block_no", "virtio_blck_id", "virtio_block__ref", "virtio_blk__id", "virtio_block__id", "virtio_blk_no", "virtio_blk_i", "virtio_blk_ref", "virtio_blk__ref", "virtio_blkPno", "virtio_blck_no", "virtio_block_ref"], "dinfo": ["edinfo", " dpi", " dinformation", "ddetails", "bdentry", "bdinformation", "dpi", "bddetails", "finfo", "dsinformation", "bdpi", "dsinfo", "eddetails", "ffo", "bdinfo", "sdinformation", "dbinformation", " dfo", "sdfo", "dsinf", "rinfo", "dfo", "bdfo", "rfo", "dbinfo", "finformation", "dsfo", "dinformation", "sdinfo", "rinf", "dentry", "finf", "rpi", "dinf", "dbdetails", "bdinf", " dinf", "edinformation", "dbentry", "edentry", "sdinf"]}}
{"project": "FFmpeg", "commit_id": "e048a9cab10f1d41dca7b1ad9c8ecaceb3424d86", "target": 1, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCMDecode *s = avctx->priv_data;\n    int sample_size, c, n, i;\n    short *samples;\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n    uint8_t *dstu8;\n    int16_t *dst_int16_t;\n    int32_t *dst_int32_t;\n    int64_t *dst_int64_t;\n    uint16_t *dst_uint16_t;\n    uint32_t *dst_uint32_t;\n    samples = data;\n    src = buf;\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n        return -1;\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n        return -1;\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n        /* 2 samples are interleaved per block in PCM_DVD */\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n        /* we process 40-bit blocks per channel for LXF */\n        sample_size = 5;\n    n = avctx->channels * sample_size;\n    if(n && buf_size % n){\n        if (buf_size < n) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n            return -1;\n        }else\n            buf_size -= buf_size % n;\n    buf_size= FFMIN(buf_size, *data_size/2);\n    *data_size=0;\n    n = buf_size/sample_size;\n    switch(avctx->codec->id) {\n    case CODEC_ID_PCM_U32LE:\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_U32BE:\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_S24LE:\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_S24BE:\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_U24LE:\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_U24BE:\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_S24DAUD:\n        for(;n>0;n--) {\n          uint32_t v = bytestream_get_be24(&src);\n          v >>= 4; // sync flags are here\n          *samples++ = av_reverse[(v >> 8) & 0xff] +\n                       (av_reverse[v & 0xff] << 8);\n        break;\n    case CODEC_ID_PCM_S16LE_PLANAR:\n        n /= avctx->channels;\n        for(c=0;c<avctx->channels;c++)\n            src2[c] = &src[c*n*2];\n        for(;n>0;n--)\n            for(c=0;c<avctx->channels;c++)\n                *samples++ = bytestream_get_le16(&src2[c]);\n        src = src2[avctx->channels-1];\n        break;\n    case CODEC_ID_PCM_U16LE:\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_U16BE:\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_S8:\n        dstu8= (uint8_t*)samples;\n        for(;n>0;n--) {\n            *dstu8++ = *src++ + 128;\n        samples= (short*)dstu8;\n        break;\n#if HAVE_BIGENDIAN\n    case CODEC_ID_PCM_F64LE:\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_F32LE:\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16LE:\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64BE:\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n    case CODEC_ID_PCM_S16BE:\n#else\n    case CODEC_ID_PCM_F64BE:\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16BE:\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64LE:\n    case CODEC_ID_PCM_F32LE:\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_S16LE:\n#endif /* HAVE_BIGENDIAN */\n    case CODEC_ID_PCM_U8:\n        memcpy(samples, src, n*sample_size);\n        src += n*sample_size;\n        samples = (short*)((uint8_t*)data + n*sample_size);\n        break;\n    case CODEC_ID_PCM_ZORK:\n        for(;n>0;n--) {\n            int x= *src++;\n            if(x&128) x-= 128;\n            else      x = -x;\n            *samples++ = x << 8;\n        break;\n    case CODEC_ID_PCM_ALAW:\n    case CODEC_ID_PCM_MULAW:\n        for(;n>0;n--) {\n            *samples++ = s->table[*src++];\n        break;\n    case CODEC_ID_PCM_DVD:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        switch (avctx->bits_per_coded_sample) {\n        case 20:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n                src = src8;\n            break;\n        case 24:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;", "idx": 11712, "substitutes": {"avctx": ["ajcfg", "avconfig", "wavtx", "wavconfig", "navconfig", "avecfg", "avjac", " avkj", "AVcontext", "vrcontext", "ajpid", "avepkg", "avcmd", "afcfg", "avecontext", "afaddr", "avejp", "aveaddr", "ajctx", "navcontext", "vrkl", "vrkj", "ajcu", "abpid", "AVctl", "afkw", "averkw", "ajtx", "wavctx", "navcfg", "vrctl", "vrtx", "abctx", "wavsys", "avercfg", "avtx", "avecmp", "afconfig", "wavcmd", "vrconfig", "abcontext", "avcmp", "averctx", "avkw", "avepid", "awctx", "AVcfg", "avekj", "wavcontext", "awresp", "vrctx", " avkw", "AVctx", "avresp", " avtx", "avpkg", "avaddr", "ajconn", "navkl", " avresp", "avectx", "averresp", "avconn", "avkj", "wavctl", "ajca", "averjac", "afctx", "avjp", "abcu", "avesys", "avercmp", "avkl", "abconf", "avobj", "avectl", " avobj", "avconf", "navctx", "aveobj", "abctl", "averconfig", "ajsys", "averaddr", "awtx", "avcfg", "ajcontext", "abconn", " avjac", "aftx", "avctl", "navkw", "aveconf", " avconf", "avcontext", "aveconfig", "navjp", "AVtx", "aveca", "avekw", "avcu", " avconn", "wavkw", " avcfg", "vrpkg", "vrcfg", "ajctl", " avcu", "wavcfg", "avpid", "afcmp", " avcontext", "avca", "avsys", "wavpkg", "avertx", "ajpkg", "abca", " avjp", "avetx", " avcmd", "awjac", "avekl", "abobj", "avecmd"], "data": ["r", "p", "DATA", "bin", "value", "next", "f", "type", "read", "ata", "id", "frame", "output", "name", "rec", "pad", "Data", "sample", "map", "feed", "window", "raw", "out", "in", "size", "a", "area", "d", "video", "bytes", "dat", "to", "empty", "package", "input", "m", "text", "t", "bits", "buffer", "txt", "batch", "block", "audio", "message", "stream", "mu", "w", "image", "length", "ns"], "data_size": ["data_length", "data_timeout", "data_type", "dat_size", " data_Size", "dat5timeout", "dat_type", "data_offset", " data_offset", "dat_Size", "data_string", "data_Size", "dat5type", "data5type", "dat_timeout", "data5size", "data5Size", "dat5Size", " data_timeout", " data_string", "data_SIZE", "data5timeout", " data_SIZE", "dat5size", " data_length"], "avpkt": ["avppvt", "avepkt", "avnpnt", "avwpct", "avPacket", "avppnt", " avpacket", "wavpmsg", " avcpkg", "wavopkt", "avwpmsg", " avpct", "avcpkt", "avcpst", "avopmsg", "avcpacket", "aveppst", "avPkt", "avppst", "avepst", "avwpkt", "avcpkg", "avopacket", "avcpnt", "avopkg", "wavpkt", "avnpvt", "wavopmsg", "wavpkg", "wavpacket", " avpkg", "avcpvt", " avcpkt", "aveppnt", " avcpacket", "avpmsg", "avepvt", "avnpkt", "avepnt", "avnpst", "avpct", "avpvt", "avpacket", "avwpkg", "avwpacket", "aveppvt", "avPmsg", "avPkg", "avpkg", "avpnt", "avopkt", " avcpct", "aveppkt", "wavopkg", "avppkt", "wavopacket", "avcpct", "avpst", "avPct"], "buf": ["r", "p", "cb", "seq", "np", "mem", "proc", "bin", "cap", "v", "uf", "map", "raw", "cv", "img", "tmp", "buff", "b", "bytes", "cache", "queue", "ref", "ctx", "vec", "box", "wb", "br", "txt", "buffer", "db", "rb", "pkg", "orig", "Buffer", "msg", "conv", "cmd"], "s": ["r", "p", "h", "sb", "rs", "v", "ss", "ps", "gs", "j", "sq", "a", "g", "b", "d", "sys", "js", "stats", "ds", "m", "S", "e", "spec", "w", "ns"], "sample_size": ["change_status", "change_size", " sample_Size", "sample_body", "sample_filter", "changeletmember", "sampleletsize", "ample_length", "sampleletfilter", " sample_location", "sampleptlocation", "sample_length", "ample_count", "sampleletstring", "changeletsize", "sample_space", "sampleptSIZE", " sample_start", "sample_SIZE", "sample_start", "sample_member", "sample_status", "sampleptloss", "ample_scope", "ample_Size", " sample_type", "sample67status", "sample67location", "sampleletmember", "sample_loss", "sampleletstatus", "ample_string", " sample_SIZE", "sample_count", "sample_scope", "sample67SIZE", "change_member", "sampleptsize", "change_filter", "samplelysize", " sample_body", "samplelymember", "changeletfilter", "sample67body", "sample_Size", "sample67filter", "changeletstatus", "ample_size", "sample_string", "sample67size", "samplelystatus", "sample_type", "sampleletscope", " sample_loss", "sampleletspace", "samplelyfilter", "ample_space", "sample67member", "sample_location", "sampleptbody"], "c": ["p", "dc", "cb", "x", "co", "C", "f", "v", "cm", "bc", "nc", "lc", "cc", "cp", "count", "b", "g", "d", "ch", "ca", "ci", "m", "t", "cs", "e", "k", "cn"], "n": ["r", "p", "h", "no", "x", "nn", "nas", "np", "f", "v", "un", "nb", "ng", "number", "z", "norm", "N", "network", "name", "l", "nc", "na", "j", "en", "ln", "an", "nr", "new", "u", "nl", "ni", "o", "nt", "nm", "ne", "nan", "size", "g", "net", "d", "fn", "b", " N", "false", "Ni", "sn", "dn", "nor", "m", "rn", "t", "num", "len", "nw", "normal", "nv", "k", "w", "mn", "cn", "ns"], "i": ["di", "p", "x", "ir", "v", "ic", "id", "l", "ii", "j", "I", "ix", "iu", "bi", "o", "b", "d", "si", "li", "y", "it", "ci", "m", "ip", "mi", "im", "pi"], "samples": ["camples", "cources", "cents", "sannels", "seents", "specizes", "Samps", "samps", "Sources", "Sents", "psamps", "psamples", "seources", "psizes", "Sizes", "specamps", "seannels", "sources", "seamples", "specamples", "Sannels", "sizes", "Samples", "cannels", "sents", "psources", "specources"], "src": ["r", "sb", "seq", "proc", "bin", "rs", "attr", "addr", "ser", "url", "bc", "str", "trans", "filename", "sub", "rc", "sr", "rel", "tmp", "sl", "b", "inst", "st", "iv", "input", "req", "txt", "sc", "source", "loc", "dest", "ptr", "comp", "img", "conv", "ins"], "src8": ["inst8", "source64", "rc64", "inst2", "src6", "inst6", "inst64", "rc6", "source6", "src64", "rc2", "source2", "source8", "rc8"], "src2": ["rc1", "src1", "source1", "rc0", "source0", "rc2", "src0", "source2", " src0", " src1"], "MAX_CHANNELS": ["MAX_CHANSEL", "MAX_CHOUNEL", "MAX_CHANNES", "MAX_CHANGATIONS", "MAX_CHANSELS", "MAX_PLANSERS", "MAX_CHOUNATIONS", "MAX_CHANNERS", "MAX_CHOUNES", "MAX_CHACEL", "MAX_CHANICS", "MAX_ChANNEL", "MAX_CHANNATIONS", "MAX_PLANNERS", "MAX_CHOUNELS", "MAX_CHANNICS", "MAX_PLANNICS", "MAX_PLANSICS", "MAX_PLANSELS", "MAX_CHANEL", "MAX_CHACELS", "MAX_CHANGELS", "MAX_CHANGEL", "MAX_ChANGATIONS", "MAX_CHANGERS", "MAX_PLANSEL", "MAX_ChANGES", "MAX_CHACES", "MAX_ChANGEL", "MAX_ChANNES", "MAX_CHANNEL", "MAX_ChANGELS", "MAX_CHANSICS", "MAX_CHANGES", "MAX_ChANNELS", "MAX_CHANGICS", "MAX_CHACATIONS", "MAX_CHANERS", "MAX_PLANNELS", "MAX_CHANSERS", "MAX_PLANNEL", "MAX_CHANELS", "MAX_ChANNATIONS"], "dstu8": ["dSTU6", "dstU2", "dst_2", "dSTu8", "dSTU2", "dst_6", "dSTu6", "dstu2", "dst_8", "dSTU8", "dstU6", "dstu6", "dstU8", "dSTu2"], "dst_int16_t": ["dst_int32_T", "dst_int32_type", "dst_int16_n", "dst_int16_type", "dst_int16_T", "dst_int32_n"], "dst_int32_t": ["dst_int32_T", "dst_int32_type", "dst_int64_type", "dst_int64_n", "dst_int64_T", "dst_int32_n"], "dst_int64_t": ["dst_int32_T", "dst_int32_type", "dst_int64_type", "dst_int64_T", "dst_int64_p", "dst_int32_p"], "dst_uint16_t": ["dst_uint8_t", "dst_uint8_T", "dst_uint16_T", "dst_uint8_n", "dst_uint16_n"], "dst_uint32_t": ["dst_uint64_T", "dst_uint32_T", "dst_uint64_t", "dst_uint32_n", "dst_uint64_p", "dst_uint64_n", "dst_uint32_p"]}}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n", "idx": 11714, "substitutes": {"env": ["engine", "dev", "conf", "conn", "mem", "ev", "enter", "v", "esc", "environment", "ef", "network", "en", "window", "shell", "org", "worker", "policy", "estate", "ew", "buf", "config", "cv", "ve", "ov", "er", "viron", "te", "ec", "ah", "param", "EN", "ctx", "oe", "ten", "manager", "kernel", "et", "eh", "vs", "context", "e", "En"], "ri": ["di", "rin", "ami", "RI", "ir", "ra", "uri", "i", "gi", "ria", "rip", "ai", "wi", "uti", "ii", "xi", "udi", "phi", "gra", "stri", "iu", "rob", "ru", "ni", "iro", "si", "umi", "ira", "rise", "ini", "ry", "rt", "vi", "ci", "ita", "mi", "iri", "ti", "ric", "pi", "rid", "ki", "ati", "rd", "rio", "ris", "pri"], "value": ["update", "ue", "unit", "region", "type", "v", "rule", "test", "data", "function", "name", "code", "VALUE", "new", "val", "key", "range", "Value", "total", "size", "property", "values", "scale", "index", "field", "info", "attribute", "local", "node", "max", "buffer", "current", "block", "word", "state", "image", "address", "w"]}}
{"project": "qemu", "commit_id": "036078475427f2562c8e505f6bb44dbf5d8cbd95", "target": 1, "func": "static int usb_host_open(USBHostDevice *dev, int bus_num,\n\n                         int addr, const char *port,\n\n                         const char *prod_name, int speed)\n\n{\n\n    int fd = -1, ret;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (dev->fd != -1) {\n\n        goto fail;\n\n    }\n\n\n\n    fd = usb_host_open_device(bus_num, addr);\n\n    if (fd < 0) {\n\n        goto fail;\n\n    }\n\n    DPRINTF(\"husb: opened %s\\n\", buf);\n\n\n\n    dev->bus_num = bus_num;\n\n    dev->addr = addr;\n\n    strcpy(dev->port, port);\n\n    dev->fd = fd;\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"husb: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++) {\n\n            printf(\"%02x \", dev->descr[x]);\n\n        }\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n\n\n    /* start unconfigured -- we'll wait for the guest to set a configuration */\n\n    if (!usb_host_claim_interfaces(dev, 0)) {\n\n        goto fail;\n\n    }\n\n\n\n    usb_ep_init(&dev->dev);\n\n    usb_linux_update_endp_table(dev);\n\n\n\n    if (speed == -1) {\n\n        struct usbdevfs_connectinfo ci;\n\n\n\n        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n        if (ret < 0) {\n\n            perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n            goto fail;\n\n        }\n\n\n\n        if (ci.slow) {\n\n            speed = USB_SPEED_LOW;\n\n        } else {\n\n            speed = USB_SPEED_HIGH;\n\n        }\n\n    }\n\n    dev->dev.speed = speed;\n\n    dev->dev.speedmask = (1 << speed);\n\n    if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) {\n\n        dev->dev.speedmask |= USB_SPEED_MASK_FULL;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n\n\n    if (!prod_name || prod_name[0] == '\\0') {\n\n        snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    } else {\n\n        pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                prod_name);\n\n    }\n\n\n\n    ret = usb_device_attach(&dev->dev);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* USB devio uses 'write' flag to check for async completions */\n\n    qemu_set_fd_handler(dev->fd, NULL, async_complete, dev);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (dev->fd != -1) {\n\n        close(dev->fd);\n\n        dev->fd = -1;\n\n    }\n\n    return -1;\n\n}\n", "idx": 11742, "substitutes": {"dev": ["wd", "DEV", "ev", "tag", "de", "cam", "end", "ver", "pub", "buf", "des", "remote", "er", "player", "d", "cache", "def", "var", "go", "sys", "task", "ad", "db", "den", "valid", "pkg", "ptr", "se", "w", "cmd", "util", "av", "develop", "h", "conf", "Dev", "mem", "comment", "build", "attr", "link", "dd", "test", "stat", "priv", "connect", "env", "rent", "raw", "all", "ve", "obj", "temp", "serv", "app", "scan", "handle", "ach", "package", "sd", "desc", "ay", "req", "draw", "buffer", "fail", "aux", "cho", "send", "conn", "exec", "serial", "pad", "command", "start", "window", "th", "patch", "api", "nt", "store", "cast", "server", "md", "ow", "unknown", "user", "gu", "ctx", "home", "prop", "any", "pi", "doc", "hw", "mod", "error", "att", "pro", "self", "write", "writer", "watch", "od", "proc", "v", "add", "usb", "query", "hd", "val", "debug", "device", "devices", "event", "prof", "form", "driver", "disk", "normal", "det", "client", "spec"], "bus_num": ["buslmon", "bus_n", "bus_um", "chainingn", "bus_NUM", "chaininggen", "buslnum", "busznom", "boot_nom", "boot_name", "boot_mon", "buszhom", "chain_n", "boot_num", "bus_nom", "chainingno", "buslnumber", "bus_Num", "busingno", "boot_Num", "businggen", "boot_NUM", "bus_mon", "bus_number", "boot_n", "busznumber", "buslNUM", "busingnum", "chain_num", "boot_hom", "bus_hom", "chainingnum", "chain_gen", "boot_number", "busitynom", "busitynumber", "bus_gen", "busitynum", "boot_um", "bus_name", "busityhom", "busznum", "busingn", "bus_no", "chain_no"], "addr": ["r", "att", "p", "ack", "wd", "ace", "conn", "eth", "attr", "alloc", "dd", "id", "url", "nat", "add", "name", "pad", "trans", "mac", "map", "ix", "align", "pub", "at", "order", "host", "buf", "store", "obj", "src", "prefix", "net", "ac", "mt", "act", "handle", "arp", "Address", "rt", "ref", "offset", "adr", "rn", "gate", "ip", "alias", "pos", "ad", "res", "loc", "et", "az", "pkg", "alt", "ord", "ptr", "bind", "address", "ag", "rel", "cmd"], "port": ["ports", "pod", "p", "value", "type", "pid", "pose", "version", "name", "pad", "pt", "prot", "interface", "gp", "key", "Port", "direction", "pport", "pipe", "buf", "cp", " sport", "size", "server", "service", "prefix", "file", "bus", "ort", "control", "priority", "pos", "ip", "buffer", "len", "num", "PORT", "pc", "ptr", "host", "address", "length", "rot"], "prod_name": ["prod2desc", "proc_num", "proc2name", "prods_file", "prod__names", "prod_file", "prod_type", "prod2num", "prod_desc", "proc2desc", "prod_num", "proc_spec", "prods2type", "prods2name", "prods_name", "prod2file", "prodnamenames", "prod_spec", "proc_desc", "prod2names", "prodnametype", "proc2num", "prod2name", "prod_names", "prod__name", "proc_name", "prods_type", "prod2spec", "prods2file", "prod2type", "prodnamefile", "prods_names", "proc_names", "prod__spec", "proc_type", "proc2names", "prods2names", "prod__type", "prodnamename"], "speed": ["powered", "limit", "flag", "type", "loss", "species", "wait", "capacity", "interface", "peed", "flags", "fast", "secure", "count", "scale", "transform", "sys", "t", "len", "state", "sort", "sync", "gain", "Speed", "sw", "pe", "fee", "rate", "ctl", "seek", "efficiency", "sd", "performance", "ssl", "power", "priority", "buffer", "sk", "sc", "status", "cost", "cpu", "skip", "sp", "command", "sim", "scroll", "size", "time", "server", "sec", "slow", "sign", "EED", "sn", "style", "weight", "wind", "mode", "stream", "length", "engine", "timeout", "ss", "height", "cc", "policy", "sex", "service", "fd", "sie", "driver", "kind", "score", "spec", "zero", "delay"], "ret": ["att", "r", "func", "flag", "RET", "ft", "fun", "mem", "rev", "sat", "err", " Ret", "std", "success", "re", "result", "j", "gt", "Ret", "deg", "val", "reply", "nl", "sent", "out", "nt", "tmp", "rets", "iter", "back", "mt", "try", "tr", "elt", "rt", "lat", "reset", "fi", "fin", "t", "len", "res", "cert", "det", "alt", "ptr", "rel", "cmd"], "x": ["X", "dx", "nex", " cx", "xy", " xx", "i", "xes", "px", " y", "xt", "number", "z", " t", "cross", "axis", "xs", "ox", "xi", "mix", "ix", "ey", "key", "ex", "wx", "xp", "time", "ax", " dx", "inx", " k", "index", " i", " v", "xxxx", "times", "y", "tx", "fx", "\u00e7", "max", "xxx", "ctx", "ux", "lex", "rx", "xa", "yx", " _", "t", " X", "mx", " c", "batch", " ax", "ick", "any", "xc", "xx", "xxxxxxxx"], "ci": ["di", " pi", "cli", "co", "ace", " cc", "Si", " ti", " ic", "i", "cm", "ic", "ai", "sci", " ii", " cis", "ii", " vi", "lc", "cu", "ico", " mi", "ni", "ice", " pri", " cd", "si", "CI", "li", "ini", "ca", "gu", "ctx", "fi", "vi", "ia", " ice", "II", " di", "ctrl", "mi", "cgi", "ee", "ti", "pi", "cs", "vc", "cci", "ki", "ati", " si", "icc"]}}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 11748, "substitutes": {"dev": ["att", "pro", "p", "h", "DEV", "Dev", "conn", "ev", "mem", "proc", " device", "v", "dd", "de", "test", "vol", "dm", "data", "cam", "serial", "tm", "priv", "pad", "pt", "ver", "window", "device", "api", "ve", "nt", "des", "obj", "devices", "remote", "server", "md", "serv", "app", "scan", "hid", "ch", "def", "dem", "sd", "go", "bus", "sys", "ctx", "driver", "Device", "phy", "home", "adv", "disk", "DE", "ad", "normal", "pi", "hw", "spec", "w", "cmd"], "pci": ["Pca", "pni", "pcgi", "apki", "patvi", "cpci", " pct", "epki", "pcca", "pmi", "Pci", "pix", "pingcci", "patcgi", "ppci", "ipni", "vpni", "ipii", "psi", "pcpi", "ppi", " pki", "ppca", "Pki", "apmi", "opii", "postci", " pmi", "pct", "patci", "vpsi", "Pcu", "pingsi", " pvi", "epcu", "ppcu", " poci", "patix", "ipoci", "ppki", "pingci", "postix", " pcci", "epcus", "pcu", " pcu", "pii", "pppi", "pki", " ppi", "ipcci", "pca", "vpci", "postcgi", "ppcus", "ipci", " pii", "ipsi", "poci", "cpmi", "apci", "epci", "pcus", " pcus", "cpki", "pvi", "cpct", "pingni", "pccu", " pca", "pcci", "opcci", "opoci", "postvi", " pix", " pcgi", "vpcci", "apct", "opci"], "d": ["r", "di", "p", "done", "dc", "h", "dr", "bd", "D", "dq", "i", "f", "v", "dd", "de", "dm", "gd", "ind", "l", "dict", "dt", "device", "n", "o", "pd", "des", "da", "md", "did", "b", "g", "dh", "dat", "fd", "sd", "dn", "ds", "m", "c", "dis", "t", "ad", "db", "dest", "e", "w", "del"], "s": ["r", "ts", "p", "session", "h", "sb", "ats", "sw", "ses", "sol", "rs", "se", "cmd", "i", "v", "sa", "ls", "f", "sp", "ss", "its", "es", "l", "ps", "gs", "j", "ys", "comm", "sts", "n", "sq", "store", "des", "server", "sv", "south", "a", "is", "g", "b", "st", "sam", "ins", "os", "y", "sd", "set", "js", "stats", "ds", "hs", "m", "S", "c", "so", "t", "source", "spec", "services", "vs", "cs", "ims", "bs", "qs", "ns"], "pci_conf": ["ppi_con", "pki_ref", "pci__config", "pki_conf", "ppi_Conf", "pci__Conf", "pci__con", "pki_con", "pki_config", "ppi_config", "pci_config", "pci_Conf", "ppi_conf", "pci_ref", "pci__ref", "pci__conf", "pci_con", "pki_Conf"], "err": ["r", "cb", "aaa", "die", "cr", "dr", "conf", "Er", "ev", "rs", "rev", "rr", "der", "cfg", "norm", "fee", "str", "result", "usr", "lr", "erb", "Error", "order", "exc", "rc", "ex", "out", "notice", "buf", "errors", "iter", "er", "cer", "gz", "ec", "ch", "try", "ah", "arr", "desc", "gr", "mr", "trace", "kr", "br", "rn", "txt", "res", "inner", "ocr", "resp", "e", "erd", "hz", "eor", "msg", "error", "drm"]}}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void copy_frame(Jpeg2000EncoderContext *s)\n\n{\n\n    int tileno, compno, i, y, x;\n\n    uint8_t *line;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){\n\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (s->planar){\n\n            for (compno = 0; compno < s->ncomponents; compno++){\n\n                Jpeg2000Component *comp = tile->comp + compno;\n\n                int *dst = comp->data;\n\n                line = s->picture.data[compno]\n\n                       + comp->coord[1][0] * s->picture.linesize[compno]\n\n                       + comp->coord[0][0];\n\n                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){\n\n                    uint8_t *ptr = line;\n\n                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)\n\n                        *dst++ = *ptr++ - (1 << 7);\n\n                    line += s->picture.linesize[compno];\n\n                }\n\n            }\n\n        } else{\n\n            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]\n\n                   + tile->comp[0].coord[0][0] * s->ncomponents;\n\n\n\n            i = 0;\n\n            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){\n\n                uint8_t *ptr = line;\n\n                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){\n\n                    for (compno = 0; compno < s->ncomponents; compno++){\n\n                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);\n\n                    }\n\n                }\n\n                line += s->picture.linesize[0];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11749, "substitutes": {"s": ["orders", "sb", "sets", "ses", "ls", "prints", "aws", "comm", "sv", "as", "bis", "js", "sys", "c", "this", "t", "source", "series", "ms", "ins", "ns", "reports", "less", "ats", "sw", "qs", "ows", "settings", "ps", "ads", "http", "parts", "sq", "fs", "a", "sg", "stats", "ds", "services", "vs", "cs", "ims", "gets", "ports", "p", "ours", "its", "ops", "b", "is", "g", "os", "times", "hs", "styles", "steps", "e", "r", "ts", "rs", "ss", "es", "als", "gs", "sts", "n", "plays", "details", "pers", "m", "S", "bits", "results", "sports", "ants"], "tileno": ["utilestate", "ilno", "tooleno", "tilzo", "utilno", "dalono", "bilano", "tilno", "bilno", "ilano", "tilena", "taleno", "utilzo", "talena", "tltery", "tiltery", "tilento", "atalena", "elinzo", "ileno", "utilono", "bilzo", "tlena", "ilename", "ylleno", "ilento", "bilena", " tilestate", "toolno", "daleno", " tilzo", "elineno", "elinena", " tilono", "tilogo", "atalogo", "tilensis", "ilensis", "bileno", "tilano", "bilename", "dalzo", " tilename", "taltery", "tleno", "toolento", "yllno", "yllename", "ataleno", "utilento", "yllano", "dalestate", "tlogo", "tilono", "talogo", "tilename", "utileno", "ataltery", " tilena", "elinename", "utilensis", "tilestate", "toolensis"], "compno": ["commsym", "cmpyes", "compna", "commmeta", "componentmo", "componentNO", "ompda", "cmpnos", "comppo", "comdo", "compNO", "ompNO", "cmpda", "commna", "cmpmo", "comyes", "commda", "commeno", "buffnone", "componentdo", "omppos", "cmpko", "cmpdo", "configNO", " compko", "procno", "ompmeta", "commpos", "componentsym", "ompko", "procnumber", "compnone", "cmpNO", "compdo", "commpo", "comppos", "commo", "ompnos", " compeno", "comnone", "comeno", "ompyes", "configno", "ompeno", "commmo", "buffyes", "compo", "componentpo", "cmpeno", "compnumber", " compnos", "ompmo", "critko", "commnone", "commNO", "cmpnone", "comnumber", "compyes", "propna", "ompnone", "cmppos", "compmeta", "compnos", "compda", "cmpna", "procpo", "comnos", "comno", "configeno", " compmo", "buffko", "procNO", "propNO", "comNO", "ompdo", "compko", "propno", "omppo", "cmpmeta", "componentnos", "critnone", "critno", " compyes", "propsym", "compeno", "crityes", "commno", "buffno", "componentna", "compmo", "ompno", "componentno", "componenteno", "cmppo", " compnone", "compsym", "comko", "configko", "cmpno", "componentnumber", "ompna"], "i": ["ui", "di", "p", "cli", "v", "ic", "id", "ai", "z", "l", "ii", "xi", "j", "I", "phi", "ix", "iu", "ico", "n", "o", "is", "si", "index", "li", "ini", "it", "II", "ci", "c", "m", "io", "t", "zi", "mi", "ij", "ip", "ti", "im", "pi", "e", "ori"], "y": ["ny", "py", "fy", "yn", "yi", "ies", "xy", "uy", "yr", "html", "dy", "wy", "yer", "oy", "kit", "j", "sky", "year", "ey", "ty", "very", "ady", "parent", "hey", "iy", "out", "o", "b", "my", "g", "yy", "ch", "try", "axy", "Y", "ay", "yt", "ya", "ry", "ym", "ly", "sys", "lat", "m", "yes", "cy", "yout", "hot", "sy", "lon", "any", "ye", "gy", "by", "ley"], "x": ["att", "p", "step", "X", "dr", "on", "dx", "xy", "px", "xes", "f", "v", "mat", "xt", "z", "xe", "xf", "xs", "ox", "xi", "j", "ix", "content", "ex", "at", "xp", "wx", "ax", "el", "ext", "path", "xxxx", "tx", "fx", "q", "lat", "xxx", "ux", "rx", "m", "xa", "text", "ip", "mx", "lon", "any", "xc", "e", "xml", "php", "w", "xx"], "line": ["Line", "ine", "limit", "lines", "list", "co", "lay", "comment", "online", "next", "link", "frame", "url", "pe", "cell", "l", "call", "ln", "page", "code", "lock", "nl", "pipe", "liner", "range", "out", "label", "iter", "zone", "eline", "email", "file", "print", "try", "path", "user", "stroke", "node", "queue", "lo", "trace", "byte", "text", "chain", "pos", "ip", "lin", "len", "block", "port", "row", "point", "LINE", "base", "ide", "word", "le"], "tile": ["tc", "unit", "sector", "mate", "tele", "league", "tip", "skill", "ite", "player", "print", "scale", "te", "transform", "cache", "browser", "tf", "sid", "TI", "t", "ti", "template", "util", "via", "tier", "lay", "pixel", "til", "tree", "link", "test", "tain", "cell", "title", "map", "ve", "vt", "ie", "nil", "note", "tle", "trace", "tg", "target", "ile", "buffer", "port", "table", "surface", "tty", "peer", "sel", "frame", "tool", "sim", "component", "th", "slice", "store", "tif", "iter", "tu", "mt", "node", "face", "ten", "Tile", "chip", "mobile", "profile", "ts", "feature", "mat", "quote", "texture", "tar", "query", "shot", "ty", "feat", "file", "details", "tab", "detail", "term", "bit", "yt", "token", "sett", "queue", "phy", "module", "kt", "console", "entity", "grid", "il"], "comp": ["att", "pro", "Comp", "func", "coll", "co", "pixel", "proc", "cmd", "cat", "acc", "conn", "comment", "coord", "cont", "perm", "op", "deep", "fc", "cell", "rec", "compl", "priv", "crit", "cond", "rep", "mod", "mac", "cum", "comm", "lc", "agg", "cc", "component", "supp", "rc", "rel", "config", "dep", "cp", "prof", "buff", "app", "comb", "sec", "par", "ch", "cache", "etc", "tab", "com", "var", "bit", "desc", "cmp", "ctx", "prop", "c", "mp", "req", "prep", "con", "loc", "spec", "resp", "cong", "pkg", "col", "omp", "lib", "fac", "conv", "ac"], "dst": ["dbl", " dport", "csp", " dST", "ddest", "dedbl", " dest", "Dest", "dsp", "dedST", "cport", " dsp", "Dbl", "Dst", "cdest", "DST", "cst", "dport", "dST", "Dport", " dbl", " ddest", "dedst", "dedest", "dest", "Dsp", "Ddest"], "ptr": ["pert", "pr", "pointers", "dr", "eth", "coord", "link", "err", "addr", "sp", "pair", "tp", "butt", "pend", "pad", "pt", "tip", "fr", "rep", "lr", "deg", "phrase", "nl", "pipe", "dep", "inters", "iter", "pointer", "Ptr", "grad", "quad", "dh", "eps", "tr", "fd", "arr", "hl", "dra", "ref", "trace", "offset", "inter", "adr", "ped", "pen", "br", "req", "vec", "pos", "buffer", "len", "port", "prime", "pi", "cut", "ctr", "peer", "cmd"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n", "idx": 11781, "substitutes": {"ctx": ["cb", "wd", "conn", "cf", " cx", "px", "fc", "bc", "ct", "xs", "cc", "unc", "obj", "cas", "tx", "fx", "cmp", "ref", "ca", "kind", "mc", "req", "anc", "Context", "pkg", "xc", "context", "hw", "cmd"], "fs": ["ts", "less", "fps", "rs", "df", "f", "ls", "ss", "fc", "FS", "obs", "ps", "xs", "gs", "ys", "aws", "Fs", "sf", "s", "irs", "fd", "os", "ms", "sys", "hs", "ds", "ns", "bits", "vs", "cs", "ims", "bs", "qs", "fw"]}}
{"project": "FFmpeg", "commit_id": "4b5a12a2cb0252c4a08b6d099eaf69523e8c62e5", "target": 0, "func": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)\n\n{\n\n    AResampleContext *aresample = inlink->dst->priv;\n\n    const int n_in  = insamplesref->audio->nb_samples;\n\n    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);\n\n    AVFilterLink *const outlink = inlink->dst->outputs[0];\n\n    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);\n\n    int ret;\n\n\n\n    if(!outsamplesref)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);\n\n    outsamplesref->format                = outlink->format;\n\n    outsamplesref->audio->channel_layout = outlink->channel_layout;\n\n    outsamplesref->audio->sample_rate    = outlink->sample_rate;\n\n\n\n    if(insamplesref->pts != AV_NOPTS_VALUE) {\n\n        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);\n\n        int64_t outpts= swr_next_pts(aresample->swr, inpts);\n\n        aresample->next_pts =\n\n        outsamplesref->pts  = (outpts + inlink->sample_rate/2) / inlink->sample_rate;\n\n    } else {\n\n        outsamplesref->pts  = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,\n\n                                 (void *)insamplesref->extended_data, n_in);\n\n    if (n_out <= 0) {\n\n        avfilter_unref_buffer(outsamplesref);\n\n        avfilter_unref_buffer(insamplesref);\n\n        return 0;\n\n    }\n\n\n\n    outsamplesref->audio->nb_samples  = n_out;\n\n\n\n    ret = ff_filter_samples(outlink, outsamplesref);\n\n    aresample->req_fullfilled= 1;\n\n    avfilter_unref_buffer(insamplesref);\n\n    return ret;\n\n}\n", "idx": 11793, "substitutes": {"inlink": ["outLink", "inputlay", "newlock", "inrange", "uncommand", "cinlayer", " inlay", "isinline", "outcommand", "inflow", "instream", "unline", "cinlink", "cinstream", "outflow", "outline", "oinLink", "inputflow", " instream", "isinlayer", "inputtool", " instyle", " outline", "inlinked", " inband", "isinlinked", "inntool", "oinlink", "innrange", "inputrange", "instyle", " outLink", "incommand", "inLink", "oinlayer", "newlink", "outstyle", "unlay", " inLink", "inlay", "innlock", "newtool", "outstream", " inflow", "outlayer", "unLink", "unlink", "unband", "newrange", "cinlinked", "innlink", " outstyle", "outlinked", "isinlink", " inlayer", "oinline", " incommand", "inputline", "inputlock", "inlayer", "inputstream", "inputLink", "inlock", "cinline", "intool", " inlinked", "inband", "inputband", "inputlink"], "insamplesref": ["insilesref", "inampsref", "insamplepb", "insplesp", "inampsdef", "insonentsref", "insreportsreference", "inamplesp", "stsizesdef", "insacesdef", "insentsdef", "stsamplesobj", "insampstab", "insampsre", "insentsRef", "insampsrel", "insancesref", "outsamplesre", "insplesdef", "outsamplestab", "insamplespb", "insentsp", "insampsRef", "stsampsref", "insancesobj", "outsampsrel", "stsamplesef", "outsampsRef", "insamplesrb", "insreportsref", "insplesreference", "insizesRef", "insacesrb", "stsampsobj", "insentsref", "insamplereference", "insonentsreference", "stsampsreference", "insampsef", "insplesrel", "insamplestab", "insampleref", "insizesre", "insplesRef", "outsampstab", "insamplesrel", "insamplesef", "insilesreference", "outsamplesdef", "insacesRef", "insoundsdef", "stsizesef", "insilesre", "insacesref", "insonentsdef", "stsizesreference", "outsampsref", "insonentsef", "stsamplesref", "insoundsRef", "insplesref", "insancesreference", "insreportspb", "inamplesdef", "insizesdef", "stsamplesdef", "insampsreference", "insizesrel", "outsampsdef", "inampsRef", "insizesef", "insplesobj", "insamplesreference", "insoundsrb", "insizestab", "outsamplesrel", "insampsdef", "insampledef", "insplestab", "outsamplesRef", "insampsobj", "inamplesref", "insampsref", "outsamplespb", "inampsp", "outsamplesreference", "outsampspb", "insreportsdef", "inamplesRef", "stsamplesrel", "stsizesref", "insampsp", "insamplesre", "insizesreference", "insizesref", "insamplesRef", "insancesrel", "insoundsref", "insilesrel", "outsamplesrb", "insamplesdef", "outsampsre", "outsampsreference", "stsamplesreference", "insamplesp", "insamplesobj", "stsampsrel", "insampspb"], "aresample": ["rsam", "iansam", "iansamp", "rumsample", "arssample", "aream", "kesam", "aresam", "astsamp", "arsam", "airsam", "stsamp", "arerspm", "rsample", "rumsamp", "arspect", "astspm", "kesamp", "arespler", "iresam", "airsamp", "stspm", "astspect", "areample", "ianspler", "iresample", "stsam", "iansample", "airsample", "rssample", "arespect", "rsamp", "rumspm", "airspler", "kesample", "rumspace", "stspace", "astssample", "irespect", "kespler", "airssample", "arerspace", "arersamp", "arspm", "stssample", "arsamp", "irespm", "aresamp", "arespm", "stsample", "arersample", "astsam", "kessample", "astsample", "aressample", "arsample", "arespace", "areamp"], "outlink": ["othread", "outerlinked", "instream", " outthread", "onlinked", "newpack", "offlink", "offlock", "nport", "outlock", "outpack", "checklink", "outstream", "todisk", "newline", "outlinked", "offline", "outerdisk", "outport", "indisk", "offpack", "Outlinked", "outloader", "OUTline", "offlayer", "outcomp", "outline", "offcomp", "onlet", "outerlink", "offport", " outlayer", "outlet", " outlinked", "OUTcomp", "incomp", "Outline", "outlayer", "inlock", "Outlink", "OUTlet", "nlayer", "OUTlink", "outerlayer", "olinked", "inhandle", "offdisk", "olink", "newlink", "servloader", "toloader", " outdisk", "outthread", "OUTstream", "outerport", "Outlet", "onlink", "newlock", " outloader", "outdisk", "checkhandle", "servdisk", "online", "nlink", "tolink", "checkdisk", "outerthread", "inpack", "olayer", "outerhandle", "outhandle", "servlink", "OUTlinked", "ndisk", "offstream"], "outsamplesref": ["outsampsro", "outsumpsref", "nsamplesRef", "nsampsro", "outsappingsfer", "outsamplesresp", "outsessionsobj", "outsampself", "inasamplestab", "inasolutionsinfo", "outspacesre", "outsumpsnote", "outsamplesnote", "unsamplesfer", "bspacesref", "outsplesobj", "alsamplesRef", "outsizesre", "nsampsreference", "offsamplesre", "outsamplesmb", "offspacesre", "outsamplesre", "outspacesRef", "outsizesref", "outsamplestab", "insampsRef", "unsappingsresp", "outsampsrel", "outsampleslf", "offsamplesRef", "outsampsRef", "outsocksmb", "alsampsref", "outsizesRef", "outsimsrel", "bsamplesref", "outsumpsRef", "outsplesmb", "bspacesrel", "outspacesrel", "offsampleslf", "outsizeslf", "alsamplesrel", "alsampself", "outsocksro", "insamplesREF", "outsappingsref", "outspaceslf", "offspacesreference", "outsolutionstab", "inasolutionsref", "outsimsref", "outsidesref", "outsonentsref", "outsappingsresp", "unsappingsfer", "outsportsref", "outsinksRef", "offsamplesref", "outsolutionsobj", "outsampslf", "outsampsmb", "outsidesinfo", "inasamplesobj", "outsappingsrel", "outsamplesobj", "outsportsre", "outsizesold", "outsportsrel", "outsportslf", "outsamplesfer", "outsresultsreference", "outsinksref", "outsampsref", "offspacesref", "offspacesrel", "offspacesRef", "bsampleslf", "outsessionsinfo", " outsamplesold", "outsamplesinfo", "outsessionsref", "outsplesref", "outspacesold", " outsizesobj", "unsamplesrel", "alsampsRef", "unsappingsrel", "outsinksreference", "outsplesRef", " outsamplesreference", "outsampsnote", "outsonentsrel", "unsamplesresp", "outsessionstab", "bsamplesRef", "outsocksreference", "outsidesobj", "offspaceslf", "inasamplesref", "outspacesref", "nsampsnote", "outsolutionsref", "alsampsrel", "outsamplesrel", "nsamplesnote", "outsizesresp", "nsamplesro", " outsizesref", "outsimslf", "outspaceself", "nsamplesmb", "offsamplesreference", "outsamplesro", "outsimsRef", "outsampsREF", "unsamplesref", "outsamplesRef", "outsamplesold", "insampsobj", " outsizesold", "unsappingsref", "insampsref", "outsresultsobj", "outsinksrel", " outsamplesobj", "outsizesrel", "insampsREF", "outsamplesreference", "alsamplesref", "nsampsref", "outsizesfer", "outsportsRef", "nsampsmb", "outsizesreference", "inasolutionstab", "bspacesRef", "outsplesro", "nsamplesref", "outsonentsresp", "outsonentsfer", "outsampleself", "outsumpsreference", "insamplesRef", "outsresultsref", "offsamplesrel", "outsizesobj", "outspacesobj", "outsimsREF", "nsampsRef", "outsampsre", "outsresultsold", "outsampsreference", "outsimsobj", "alsampleself", "outsolutionsinfo", "insamplesobj", "bsamplesrel", "inasamplesinfo", "inasolutionsobj", "outsampsobj", "outspacesreference", "nsamplesreference", "bspaceslf", "outsocksref", "outsamplesREF", " outsizesreference", "outsidestab", "outsplesREF", "outsplesreference"], "ret": ["att", "RET", "mel", " Ret", "read", "re", "str", "result", "gt", "Ret", " RET", "val", "rem", "after", "nt", "rets", "print", "mt", "def", "get", "tr", "try", "arr", "elt", "ry", "rt", "ref", "reset", "it", "t", "len", "res", "true", "ll", "resp", "alt", "Return", "jp"]}}
{"project": "FFmpeg", "commit_id": "138568e9da0e3abfc818329ab12ea3fb667639fb", "target": 0, "func": "static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    unsigned int i, entries;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    entries = get_be32(pb);\n\n    if(entries >= UINT_MAX / sizeof(MOV_stts_t))\n\n        return -1;\n\n\n\n    sc->ctts_count = entries;\n\n    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));\n\n    if (!sc->ctts_data)\n\n        return -1;\n\n    dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    for(i=0; i<entries; i++) {\n\n        int count    =get_be32(pb);\n\n        int duration =get_be32(pb);\n\n\n\n        if (duration < 0) {\n\n            av_log(c->fc, AV_LOG_ERROR, \"negative ctts, ignoring\\n\");\n\n            sc->ctts_count = 0;\n\n            url_fskip(pb, 8 * (entries - i - 1));\n\n            break;\n\n        }\n\n        sc->ctts_data[i].count   = count;\n\n        sc->ctts_data[i].duration= duration;\n\n\n\n        sc->time_rate= ff_gcd(sc->time_rate, duration);\n\n    }\n\n    return 0;\n\n}\n", "idx": 11795, "substitutes": {"c": ["p", "dc", "cb", "coll", "cr", "co", "conf", "C", "tc", "cf", "f", "v", "cm", "cont", "cur", "cam", "fc", "abc", "bc", "nc", "ct", "l", "call", "cl", "lc", "cu", "cc", "rc", "n", "cp", "enc", "b", "g", "ec", "cache", "etc", "com", "ca", "ctx", "ce", "ci", "m", "mc", "t", "chain", "anc", "con", "cs", "pc", "e", "cn", "ac"], "pb": ["pro", "p", "cb", "pl", "sb", "amp", "wp", "tc", "proc", "lp", "px", "pp", "typ", "sp", "pack", "tp", "dp", "pg", "bp", "bc", "emb", "pt", "bj", "ob", "uf", "erb", "sub", "bb", "eb", "ub", "fb", "buf", "cp", "PB", "buff", "b", "td", "pa", "mb", "gb", "sys", "fp", "ctx", "pm", "tf", "wb", "mp", "stab", "rb", "resp", "ping", "pkg", "asm", "pc", "vp", "lb", "jp"], "atom": [" carb", "tem", " Atom", "um", " term", "type", "ata", "om", "entry", "name", " element", "at", " symb", "tmp", " atoms", "item", "chem", "orm", "app", "term", "tg", "m", " tmp", " form", "fam", " om", " app", "msg"], "st": ["sta", "sw", "ft", "sa", "sh", "cont", "sp", "ss", "ste", "ct", "pt", "ST", "stra", "tt", "str", "ust", "start", "sim", "sts", "th", "at", " ss", "sv", "src", "St", "sl", "ost", "inst", "mt", "sec", "s", "rest", "ch", "tr", "ut", "sn", "set", "so", "t", "et", "stage", "est", "ist", "se"], "sc": ["ui", "sync", "dc", "cr", "proc", "tc", " subsc", "esc", "sh", "ck", "sp", "exec", "ss", "cam", "sup", "bc", "nc", "sche", "disc", "cl", "uc", "psc", "lc", "ka", "cu", "capt", "cc", "rc", "arc", "tch", "cv", "ctl", "sv", "sl", "cer", "enc", "soc", "sec", "scale", "ec", "ch", "osc", "asc", "desc", "scl", "sys", "ctx", "mc", "ci", "sch", "usc", "Sc", "anc", "sum", "loc", "spec", "decl", "cs", "pc", "gc", "comp", "SC", "scope", "isc"], "i": ["ui", "di", "p", "cli", "x", "v", "k", "gi", "ri", "id", "ai", "ic", " ii", "iq", "ind", "ei", "ii", "l", "j", "xi", "sim", "I", "ji", "phi", "ix", "iu", "iy", "multi", "u", "bi", "n", "me", "in", "o", "qi", "g", "is", "hi", "d", "si", "index", "li", "y", "ini", "fi", "it", "\u0438", "ci", "m", "t", "ip", "mi", "zi", "chain", "ij", "batch", "ti", "cgi", "im", "iri", "asi", "pi", "e", "ki", "ims"], "entries": ["ientances", "Entries", "entrier", "enties", "ntriers", "ntries", "ientries", "pentlements", "Entrys", "penties", "nties", "entsrys", "ENTries", " entires", " Entriers", "enires", "ntrys", "entires", "entrys", "entsriers", " entarts", " Entries", " entures", "entriers", "ENTrier", "centriers", " enties", " entrys", " Entures", "pentrys", "entsencies", "ientrier", "Entresses", "ENTrys", "entsances", "pentriers", "Entires", "entsies", "Entriers", "ENTances", "Entrier", "enrys", "entances", "entsries", "Entencies", "ENTies", "centrier", "entsrier", "Enties", "centrys", "enresses", "pentries", "ntlements", "entures", " Entarts", "ientrys", "entencies", "entsresses", "enries", "pentencies", "entlements", "entslements", "ENTires", "centries", "entsarts", "entresses", " entriers", "entarts", "entsures", "entsires"]}}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n", "idx": 11806, "substitutes": {"obj": ["self", "ot", "co", "Obj", "off", "xy", "attr", "onet", "oid", "ob", "ind", "object", "pt", "bj", "str", "j", "window", "rect", "out", "nt", "o", "tmp", "bh", "inst", "act", "ref", "og", "js", "ctx", "so", "t", "ij", "pkg", "bo", "hw", "img"], "name": ["dev", "no", "ma", "ra", "mem", "type", "f", "cap", "id", "data", "NAME", "str", "am", "key", "order", "n", "me", "nm", "names", "def", "path", "var", "info", "lat", "m", "ame", "Name", "nam", "c", "t", "alias", "fam", "base", "word", "man", "spec", "w", "cmd"], "o_out": ["ozin", "o_in", "ozOut", " o_Out", "o__out", "o2outs", "o__in", " o_in", " o2outs", "o_Out", "ozout", "o_outs", " o2in", " o_outs", "o2in", " o2out", "o2out", "o__outs"]}}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        if (bdrv_truncate(base, length) < 0) {\n\n            error_setg(errp, \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, errp,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(errp)) {\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 11810, "substitutes": {"bs": ["ts", "fps", "bf", "sb", "blog", "rs", "bos", "ls", "BS", "pb", "its", "obs", "bc", "bp", "ps", "boot", "gs", "sub", "ubs", "bi", "fs", "bh", "b", "lbs", "is", "bytes", "pse", "ms", "bas", "bis", "js", "sys", "ctx", "basic", "ds", "stats", "bits", "bps", "ase", "vs", "cs", "lb", "hz", "bm", "ns"], "base": ["bid", "extra", "no", "sb", "was", "handler", "fr", "change", "bi", "null", "cp", "as", "history", "pa", "cache", "to", "force", "sys", "this", "db", "source", "based", "state", "se", "h", "bal", "kit", "name", "ps", "root", "bot", "http", "bar", "bound", "mb", "handle", "set", "basic", "it", "buffer", "top", "res", "p", "pre", "id", "bp", "start", "parent", "out", "space", "store", "server", "b", "real", "prefix", "bas", "chain", "stable", "ase", "bo", "v", "old", "key", "origin", "las", "area", "back", "file", "super", "pse", "binding", "bit", "local", "full", "Base", "box", "ip"], "speed": ["limit", "send", "engine", "disable", "Speed", "sw", "duration", "height", "command", "wait", "interface", "start", "scroll", "position", " speeds", "thread", "slice", "peed", "sex", "time", "size", "seek", "count", "scale", "sleep", "EED", "offset", "driver", "priority", "drive", "weight", "buffer", "status", "port", "score", " size", "spec", "delay", "frequency"], "on_error": [" on_command", " on_result", " on_query", "onJresult", "on_query", " on_err", "on___command", "on_ERROR", " on_close", "onWresult", "on___close", " on_ERROR", "on___error", "onJerror", "on_err", "on_command", "onJERROR", "on___query", "onWERROR", "on_close", "on_result", "on___err", "onWerror"], "cb": ["func", "dc", "bf", "cf", "tc", "fun", "ck", "pb", "cfg", "handler", "fc", "ob", "bp", "bc", "nc", "cd", "bb", "cc", "cor", "cv", "buf", "cp", "b", "fn", "cmp", "gb", "fp", "ctx", "ctrl", "c", "db", "CB", "callback", "rb", "cs", "lb", "cn"], "opaque": ["okaques", "opfac", "obaque", "Opacity", "pque", "hopacity", " opacity", " opaques", "hopaque", "hopque", " opulence", "pfac", "Opaque", "opque", "obacity", "obaques", "obulence", "Opfac", "okaque", "hopfac", "opaques", "okacity", "Opque", "opulence", "okulence", "opacity", "paque", "pacity"], "errp": ["diepa", "dieP", "derping", "usrpa", "errcp", "rrP", "errps", "errorping", "erpb", "errr", " errP", " errr", "rrr", "erping", "errorpc", " errpc", "diep", "errping", "derpc", "rerp", "derp", "derps", "usrping", "rrp", "usrp", "warncache", "rerps", "errcache", "dangerpc", "rerpb", "errpe", "errpc", "errpb", "rrpa", "warncp", " errps", "errpa", " errpa", "erp", "errorps", "errorp", "rerjp", "errorr", "errorcache", "errorpa", "errP", "errorpb", "erpa", " errpe", "rrpe", "dangercache", "errorP", "errjp", "warnpc", "errorjp", "warnp", "dangerp", "erps", "dangercp", "erjp", "diepe", " errping", "rrping", "errorcp"], "length": ["p", "limit", "present", "distance", "Length", "h", "be", "ength", "build", "idth", "type", "f", "json", "read", "head", "number", "ob", "end", "l", "height", "capacity", "padding", "angle", "code", "position", "depth", "phi", "ENGTH", "component", "zip", "total", "size", "count", "time", "loop", "join", "history", "transform", "index", "ah", "match", "path", "maximum", "shape", "term", "performance", "full", "max", "driver", "sequence", "offset", "weight", "volume", "buffer", "len", "port", "enth", "wind", "message", "SIZE", "level", "address", "zero", "duration", "frequency"], "base_length": [" base2width", "base_width", "base_len", "baselencode", "baseJstrength", "base2length", " base_strength", " base2code", "baselenphi", " base_match", "baselenlength", "base_duration", "base67code", "base_strength", "baseJmatch", " base_width", "base67width", " baseJlength", "base2len", "base67phi", "base2width", "base67length", "baseJduration", " baseJmatch", " base2phi", " base_phi", " baseJduration", "base8strength", "server_length", "base2Length", "base2phi", "base_match", "base_Length", " baseJstrength", " base2length", "baselenwidth", " base_len", "base_code", " base_duration", "base_phi", " base_code", "base2code", " base2len", "server_len", " base2Length", "base8length", "base8match", " base_Length", "base8duration", "baseJlength", "server_Length"], "orig_base_flags": ["orig_cache_properties", "orig_base_links", "orig_ase_styles", "orig_base_flag", "orig_baseLocalstyles", "orig_base_properties", "orig_base_styles", "orig_cache_fs", "orig_cache_flags", "orig_ase_flag", "orig_file_links", "orig_ase_flags", "orig_baseLocalflags", "orig_baseLocalflag", "orig_base_fs", "orig_file_fs", "orig_cache_flag", "orig_file_flag", "orig_file_flags"]}}
{"project": "FFmpeg", "commit_id": "4f90688b6e1d79d85ac2e065a2cf1e7e9bd665a7", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n                                  MatroskaTrack *track)\n{\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n    uint8_t* data = *buf;\n    int isize = *buf_size;\n    uint8_t* pkt_data = NULL;\n    int pkt_size = isize;\n    int result = 0;\n    int olen;\n    switch (encodings[0].compression.algo) {\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n        return encodings[0].compression.settings.size;\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n        do {\n            olen = pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n        if (result)\n            goto failed;\n        pkt_size -= olen;\n        break;\n#if CONFIG_ZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n        z_stream zstream = {0};\n        if (inflateInit(&zstream) != Z_OK)\n        zstream.next_in = data;\n        zstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            zstream.avail_out = pkt_size - zstream.total_out;\n            zstream.next_out = pkt_data + zstream.total_out;\n            result = inflate(&zstream, Z_NO_FLUSH);\n        } while (result==Z_OK && pkt_size<10000000);\n        pkt_size = zstream.total_out;\n        inflateEnd(&zstream);\n        if (result != Z_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n#if CONFIG_BZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n        bz_stream bzstream = {0};\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n        bzstream.next_in = data;\n        bzstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n            result = BZ2_bzDecompress(&bzstream);\n        } while (result==BZ_OK && pkt_size<10000000);\n        pkt_size = bzstream.total_out_lo32;\n        BZ2_bzDecompressEnd(&bzstream);\n        if (result != BZ_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n    default:\n    }\n    *buf = pkt_data;\n    *buf_size = pkt_size;\n    return 0;\n failed:\n    av_free(pkt_data);\n}", "idx": 11813, "substitutes": {"buf": ["p", "cb", "h", "seq", "mem", "cap", "v", "read", "Buffer", "bc", "pad", "uf", "window", "bl", "rc", "cv", "tmp", "cast", "buff", "enc", "b", "bytes", "dat", "var", "arr", "que", "queue", "box", "wb", "pos", "buffer", "block", "rb", "batch", "pkg", "doc", "bs", "w", "cmd"], "buf_size": ["buff_sh", "buff_size", "buf_length", "buf2scale", "buf_sh", "buf_SIZE", "buf_scale", "buf_Size", "buff_Size", "buf__length", "buf2size", "buf__SIZE", "buf2length", "buf__size", "buff_SIZE", "buf2SIZE", "buff_scale", "buf__scale", "buff_length"], "track": ["r", "ack", "report", "search", "session", "sync", "sound", "metadata", "fire", "tracking", "pack", "rack", "kick", "run", "record", "roll", "Track", "store", "reflect", "seek", "met", "transform", "index", "match", "tr", "tab", "handle", "queue", "set", "trace", "t", "claim", "tracks", "batch", "train", "race", "stream", "bind", "cmd"], "encodings": ["encointers", "encODifiers", "enccodifications", "encording", "decodrings", "eccodifiers", "enccodings", "encorders", "enceners", "enccodrings", "decoding", "encodrings", "encointings", "encenifications", "encODifications", "encODing", "decODers", "encodifiers", "encointifiers", "eccodifications", "ecodings", "decoders", "ecodifications", "decodings", "encoders", "enccoding", "eccoding", "ecodations", "encODrings", "encodifications", "encODings", "encODations", "encODers", "encordings", "eccoders", "enccoders", "encenings", "eccodings", "encoding", "enccodations", "enccodifiers", "encening", "encordations", "encodations", "decODing", "ecodifiers", "ecoding", "decODrings", "eccodations", "decODings", "ecoders", "encointing"], "data": ["r", "p", "no", "DATA", "mem", "xy", "bin", "value", "next", "read", "ATA", "ata", "end", "name", " DATA", "result", "Data", "str", "map", " Data", "start", "window", "good", "raw", "array", "n", "size", "iter", "d", "bytes", "dat", "info", "input", "offset", "open", "t", "pos", "buffer", "len", "res", "batch", "table", "valid", "aw", "w", "mu", "image", "results", "length", "error"], "pkt_data": ["packet_data", "pnt_data", "pct_buffer", "pet_data", "pkt_info", "pnt_cache", "packet_cache", "ptt_data", "pet_str", "pelt_name", "pkt_batch", "pkt_mem", "pet_len", "ptt_size", "packet_size", "pktLmap", "pnt_name", "pkt_size", "pktlystr", "ptt_map", "packet_name", "pkt_name", "pktlydata", "pktLmem", "pkt_str", "pelt_info", "pkt64len", "pct_size", "pct_len", "packet_read", "pkt64size", "pktLdata", "pelt_size", "packet_str", "pct_data", "pkt_map", "pelt_data", "pkt64buffer", "pkt64data", "pkt_buffer", "ptt_mem", "pkt_cache", "pkt_read", "pkt_len", "pktlyread", "pktLsize", "pet_batch"], "olen": ["done", "nom", "haven", "angled", "mel", "oled", "mem", "filled", "eth", "lost", "didn", "failed", "sol", "known", "ret", " leftover", "rown", "led", "written", "wn", "ln", "cn", "ran", "occupied", "lol", "origin", "won", "oin", "broken", "total", "temp", "opted", "hung", "alg", "het", "hat", "kl", "held", "ldon", "zon", "claimed", "aled", "lan", "ken", "equipped", "wid", "olid", "rn", "ele", "linger", "sofar", "len", "hal", "killed", "aken", "wan", "alt", "ilee", "regon", "mn", "agger"]}}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n", "idx": 11833, "substitutes": {"cs": ["ts", "ats", "cus", "rs", "ls", "ck", "ces", "ss", "ps", "cks", "uns", "acs", "ys", "sts", "cc", "rc", "cp", "CS", "fs", "ics", "ec", "ins", "ks", "css", "js", "ds", "ras", "ce", "c", "ars", "sc", "vs", "wcs", "bs", "qs", "ns"], "addr": ["r", "x", "rs", "eth", "attr", "rr", "v", "hop", "alloc", "err", "id", " address", "url", "name", "pad", "str", "uid", "rc", "obj", "src", "a", "prefix", "dh", "act", "handle", "arp", "Address", "rt", "ref", "hash", "offset", "ctx", "adr", "rn", "ip", "ad", "res", "pkg", "ord", "ptr", "host", "hw", "address", "cmd"], "is_write": ["is_writing", "Is_write", "is__read", "is_wait", "Is_only", "is__writing", "is_only", "is_read", " is_read", "is__writ", "Is_wait", " is_writ", "is__write", "is_writ", "Is_read", " is_writing"], "is_exec": ["is2open", " is_open", "is2run", "is_run", "is2read", "is_open", "is_read", " is_read", "is2exec", " is_run"], "unused": ["unuse", " unavailable", "unausage", "unavailable", "Unavailable", " unuse", "unause", "Unuse", " unusage", "unusage", "unaused", "Unusage", "unaavailable", "Unused"], "size": ["send", "mem", "cap", "alloc", "izes", "name", "l", "en", "uid", "n", "count", "use", "g", "Size", "bytes", "empty", "sn", "max", "offset", "ize", "weight", "len", "sum", "block", "SIZE", "length"], "cpu": ["nn", "rom", "np", "proc", "CPU", "conn", "mem", "gpu", "alloc", "ck", "jp", "stat", "processor", "nc", "ox", "ka", "cu", "nic", "hw", "ex", "process", "qa", "setup", "cp", "uda", "prof", "core", "phys", "pu", "ca", "ctx", "aco", "phy", "bean", "nu", "anc", "chip", "aq", "clock", "pc", "gc", "aux", "cn", "ac"], "env": ["extra", "inv", "ev", " ens", "err", "end", "nc", "en", "worker", "buf", "er", "te", "cause", "manager", "db", "den", "gear", "vp", "ptr", "cmd", "esc", "ef", "priv", "ei", "map", "shell", "stack", "estate", "ew", "obj", "vt", "ah", "eas", "desc", "esm", "dn", "export", "bean", "txt", "sc", "vs", "msg", "scope", "conn", "environment", "entry", "era", "window", "store", "server", "viron", "dh", "node", "ctx", "oe", "ten", "here", "nv", "e", "doc", "bind", "erd", "ts", "ens", "engine", "dev", "cb", "proc", "next", "v", "neck", "forge", "cv", "ec", "ext", "uv", "console", "eh", "Environment", "ee", "dest", "context"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static int virtio_serial_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&\n\n        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */\n\n        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */\n\n        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;\n\n\n\n    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);\n\n    if (!vdev) {\n\n        return -1;\n\n    }\n\n    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED\n\n                                        ? proxy->serial.max_virtserial_ports + 1\n\n                                        : proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    proxy->class_code, 0x00);\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}\n", "idx": 11834, "substitutes": {"pci_dev": ["pci_buf", "pci_Dev", "pciCdevice", "pciCDev", "pcu_dev", "ppi_buf", "pci_ev", "pcu_serial", "ppi_dev", "pcu2dev", "pcu2serial", "pci2serial", "ppi_ev", "ppi_req", "pci2def", "pci_device", "pci_ve", "pci_def", "pciCdev", "pcu_conn", "pcu_ve", "pci_conn", "pciCserial", "pci2Dev", "pcu_def", "pcu2device", "pcu_device", "pci2device", "pci2ve", "pcu_Dev", "pci_req", "pci2dev", "pci_serial", "pcu2Dev"], "proxy": ["roxy", "controller", "handler", "lock", "worker", "null", "cas", "remote", "relation", "index", "cache", "cone", "browser", "force", "echo", "pin", "manager", "slave", "source", "series", "socket", "select", "link", "Proxy", "map", "http", "info", "trace", "priority", "target", "mi", "port", "prime", "native", "linux", "XY", "report", "xy", "pre", "primary", "result", "gp", "parent", "reply", "dirty", "holder", "reverse", "pipe", "server", "pointer", "false", "embed", "copy", "user", "none", "project", "wrapper", "oe", "alias", "tor", "callback", "use", "profile", "show", "clone", "self", "pro", " proxies", "friend", "password", "master", "request", "connection", "version", "reason", "query", "ion", "page", "shadow", "device", "PRO", "pool", "super", "pse", "see", "view", "driver", "phy", "module", "console", "po", "ping", "client", "address"], "vdev": ["nvdes", "evdevice", "cvev", "ndev", "mdev", " vdat", "vnormal", " vnormal", " vconn", "fdevice", "ndata", "uvdev", " vdef", "uvdes", "vdes", "uvdef", "vcdef", "uvconn", "evprof", "vprof", "vcconn", "vev", "cvdev", " vpriv", "vpriv", "fev", "nvev", "vcdev", " vev", "ndevice", "vdevice", "mprof", "nvdev", "nvpriv", "nvnormal", "evdes", " vw", " vprof", "vdiv", "pdev", "nvdiv", "vconn", "uvw", "vdat", "vw", "cvdat", "vdef", " vval", "mdevice", "pnormal", "vcw", "nev", "ndat", "uvpriv", "evdev", "fdev", " vdes", "mdes", "pev", "uvval", "fdata", " vdata", "pdiv", " vdiv", " vdevice", "vdata", "nvval", "vval"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n", "idx": 11840, "substitutes": {"id": ["dev", "aid", "tag", "pid", "oid", "end", "name", "ident", "root", "uid", "Id", " fid", " rid", " pid", "kid", "ID", " tid", "path", "hash", "ref", "sid", "kind", "ad", "vid", "mid", "rid", "ids"], "backend": ["gateender", "backad", "bookends", "bookad", "jackended", "bookender", "bookline", "Backends", "bookended", "backended", "Backend", "gateend", "gateends", "Backline", "backender", "Backended", "backline", "jackend", "backends", "gateline", "Backender", "jackender", "jackad", "Backad", "bookend"], "ret": ["RET", "red", "mem", "std", "sel", "re", "Ret", "val", "rect", "rem", "rm", "nt", "des", "rets", "mt", "def", "lit", "tr", "rt", "ref", "reg", "txt", "et", "res", "det", "resp", "pet"], "errp": [" erps", "errpo", "errps", " errm", "krm", "errr", "lerp", " errr", " erpo", "errbp", "krr", "lerpo", " errps", "errorm", " errbp", "krp", "errorp", "errorr", " erbp", "lerps", "errm", "lerbp", " erp", " errpo"], "serial": ["util", "dev", "spot", "selected", "select", "final", "Serial", "iso", "json", "private", "sel", "ser", "primary", "random", "usb", "ident", "boot", "erial", "human", "special", "sharp", "root", "raw", "device", "quant", "initial", "des", "remote", "serv", "handle", "unknown", "machine", "mot", "custom", "local", "specific", "bus", "sys", "phone", "normal", "series", "mobile", "host", "cho", "pal", "tty", "tel", "error"], "fd": ["ld", "cb", "bf", "nd", " d", "off", "cf", "bd", "df", "ff", " df", "f", "dd", "gd", "fc", "ind", "fee", "fr", "fed", "ln", "cond", "hd", "dl", "dt", "fb", " fid", "pd", "da", "fa", "fs", "td", "dir", "d", "fn", "fm", "file", "form", " fut", "FD", "fl", "dat", " td", " ff", "sd", "ini", "elt", "af", "fe", "fp", "fi", "ds", "fin", "ped", "disk", " f", "ud", " fin", "ptr"]}}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 11843, "substitutes": {"pci_bus": ["pci__boot", "pci_box", "pcimyloop", "pci__bus", "ppi_bus", "pciitycomponent", "pcietybus", "pca_Bus", "pcp_box", "pca_component", "pci_lock", "pcimylock", "pca_host", "pciitydriver", "ppi_interface", "pciitybyte", "pcietylock", "pci_driver", "pdi_bus", "pdi_byte", "pcpetyloop", "pciityboot", "pci_interface", "pci_loop", "pcpetybox", "pdi_boot", "pca_box", "pci_bridge", "pci_BUS", "pca_boot", "pciityBUS", "pciityinterface", "pciityBus", "pci_boot", "pci_component", "ppi_driver", "pcpetylock", "pciitybus", "pci__box", "pdi_BUS", "pcp_loop", "pci__bridge", "pciityhost", "pci_byte", "pca_bridge", "pcpetybus", "pci_host", "pcimybus", "pca_bus", "ppi_boot", "pcp_bus", "pcietyloop", "pci_Bus", "pcietybox", "pcp_lock", "pcimybox"]}}
{"project": "qemu", "commit_id": "75554a3ca10a7ad295d2a3d2e14ee6ba90f94c8b", "target": 0, "func": "struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n", "idx": 11844, "substitutes": {"ta": ["ts", "eta", "ma", "Ta", "ra", "sa", "ata", "tie", "tm", "tar", "tp", "meta", "na", "TA", "pha", "ka", "oa", "tta", "tap", "ota", "fa", "da", "a", "pa", "tu", "mt", "te", "si", "tr", "bas", "tx", "ca", "wa", "t", "la", "mi", "tor", "ti", "base", "ba", "beta", "po", "pi", "mu"], "irq": ["irqu", "ironquire", "pirql", " irquest", " irql", "mrq", "irquire", "ironqs", "pirqu", "pirquest", " irqu", "ironquest", "mrqs", "pirqs", " irquire", "irqs", "mrqu", "ironq", " irqs", "pirquire", "pirq", "irql", "irquest", "mrql"], "fclk": ["foclk", "fcld", "fslq", "fplke", "fpld", "fllq", "lfllik", "lflltk", "lfllk", "fllik", "lfcltk", "flk", "flik", "focld", "foclke", "lfclq", "flltk", "fplk", "fsltk", " fpld", "fmilke", "flq", " fclke", "fmild", "fcltk", "lfclk", " fcld", "fclq", "fslik", "lfllq", "fclke", " fplk", "fmilk", "fltk", "fllk", "fclik", "fslk", " fplke", "lfclik"], "iclk": ["icdlj", "IClke", "icllke", "icdlq", "IClq", "icrlk", "icclq", "icflck", "icflk", "iccllke", "ICrlke", "iclke", "icclke", "ICrlck", "icrlq", "icflq", "IClck", "icclck", "ICrlk", "iclj", "icflke", "icrlke", "icrlj", "icdlke", "iclq", "icclj", "iccllq", "icllj", "iccllk", "icllq", "icdlk", "ICrlq", "iccllj", "iclck", "icllk", "IClk", "icclk", "icrlck"], "txdma": ["txsdmas", "txdms", "txDmas", " txsdma", "xlmm", "txDms", "txDna", "xdms", "xlms", "txdmm", " txdna", "xlma", "xdma", "txsdmm", "txDmm", "xdmas", "txlmm", " txdmas", "txlmas", "txDma", "xdmm", "txdna", "txlms", " txdmm", "txnma", "txsdma", "txlma", "txnmm", "txnna", "txsdna", " txsdmas", "txnmas", "xlmas", " txsdmm", "txsdms", " txsdna", "txdmas"], "rxdma": [" rdxmm", " rdxda", "rdxda", " rxdda", "rddota", "rxdota", "rcdmm", "rdxmas", "rrdmm", "rdxm", "rcdmas", "rddma", "rxdm", "rcdda", "rxdmas", "rvdm", " rxdmas", "rxdmm", "rrdmas", "rddmas", " rxdota", " rxdmm", "rcdma", "rvdmas", " rxdm", "rddm", " rdxma", "rxdda", "rrdda", " rdxota", " rdxm", "rdxmm", "rvdma", "rvdota", "rdxma", "rdxota", "rrdma", " rdxmas"], "chr": ["shre", "clsr", "chrg", "chre", "clre", " chre", "Chrs", "chrs", "chsr", " chrg", " chsr", "clr", "cherr", " chrs", "cherar", "shr", "cherrg", "Chrg", "cherrs", "Char", "Chr", "clrs", "shrs", "shsr"], "s": ["r", "ts", "p", "ports", "changes", "h", "sb", "ats", "ies", "rs", "se", "su", "sa", "i", "v", "f", "ls", "ss", "its", "als", "es", " gets", "l", "ps", " is", "gs", " reports", "sts", "n", "sq", "sm", "o", "des", "sv", "fs", "sl", "is", "b", "a", "g", "details", "ins", "ms", "os", "js", "stats", "hs", "ds", "states", "m", "S", "c", "t", "bits", " sets", "services", "vs", "single", "cs", "e", "bs", "w", "gets", "qs", "rates", "ns"]}}
{"project": "qemu", "commit_id": "6e6e55f5c2e5b520d6506c2716287ba3b5d1bbc8", "target": 0, "func": "static void QEMU_NORETURN help(void)\n\n{\n\n    const char *help_msg =\n\n           QEMU_IMG_VERSION\n\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n\n           \"QEMU disk image utility\\n\"\n\n           \"\\n\"\n\n           \"    '-h', '--help'       display this help and exit\\n\"\n\n           \"    '-V', '--version'    output version information and exit\\n\"\n\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\n           \"                         specify tracing options\\n\"\n\n           \"\\n\"\n\n           \"Command syntax:\\n\"\n\n#define DEF(option, callback, arg_string)        \\\n\n           \"  \" arg_string \"\\n\"\n\n#include \"qemu-img-cmds.h\"\n\n#undef DEF\n\n#undef GEN_DOCS\n\n           \"\\n\"\n\n           \"Command parameters:\\n\"\n\n           \"  'filename' is a disk image filename\\n\"\n\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n\n           \"    manual page for a description of the object properties. The most common\\n\"\n\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n\n           \"    encryption keys.\\n\"\n\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n\n           \"    options are the same as for the 'cache' option\\n\"\n\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n\n           \"    supported. 'b' is ignored.\\n\"\n\n           \"  'output_filename' is the destination disk image filename\\n\"\n\n           \"  'output_fmt' is the destination format\\n\"\n\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n\n           \"    used format\\n\"\n\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\n           \"    '[ID_OR_NAME]'\\n\"\n\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n\n           \"    instead\\n\"\n\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n\n           \"  '-p' show progress of command (only certain commands)\\n\"\n\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n\n           \"       fully allocated\\n\"\n\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n", "idx": 11852, "substitutes": {"QEMU_NORETURN": ["QEMU_NORETOOL", "QEMU_NORetURN", "QEMU_Ret_", "QEMU_NOREPURN", "QEMU_NOREP_", "QEMU_NORANTOOL", "QEMU_NOReturn", "QEMU_RetURN", "QEMU_RETURN", "QEMU_NOREPOOL", "QEMU_Return", "QEMU_NORET_", "QEMU_RETurn", "QEMU_NORet_", "QEMU_NORANT_", "QEMU_RETOOL", "QEMU_NORETurn", "QEMU_NORANTURN", "QEMU_RET_", "QEMU_NORetOOL", "QEMU_NOREPurn", "QEMU_NORANTurn", "QEMU_RetOOL"], "help_msg": ["help_char", "help_bg", "help___bg", "help___Msg", " help_char", " help_Msg", "help___msg", " help_bg", "help_Msg"]}}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void coroutine_fn bdrv_create_co_entry(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    CreateCo *cco = opaque;\n\n    assert(cco->drv);\n\n\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(&cco->err, local_err);\n\n    }\n\n    cco->ret = ret;\n\n}\n", "idx": 11853, "substitutes": {"opaque": ["OPatile", "opatile", "Oplation", "OPinion", "Opacity", " copacity", "hopulent", "porinion", "hopinion", " copacement", "hopaque", "oplation", "hopatile", "metacement", "OPulent", "metlation", "OPaque", "opacity", "metaque", "poratile", " coplation", "porulent", "metacity", "opulent", "poraque", "opacement", "Opaque", "opinion", "Opacement", " copaque"], "local_err": ["local_txt", "local_loc", "localederr", " locally_err", "otherityplain", "local___plain", " local_er", "otherityarr", "local___er", "localityplain", "other_arr", "local___err", " locally_error", "localedtxt", "other_plain", "local___arr", " locally_attr", "localeder", "local_usr", "local_error", "state_err", " locally_er", " local_lr", "local___error", "local___usr", "state___loc", " local_txt", "local_lr", "local___lr", "local_er", "local_arr", "state_usr", "localedlr", "state___usr", "local___loc", "local_attr", "localityerr", "state___err", "local_plain", "local___txt", "state_loc", "local___attr", "otherityerr", "other_err", "localityarr"], "ret": ["att", "r", "pas", "pret", "flag", "RET", "mem", "ft", "fun", "rev", "cat", "err", "cont", "xt", "url", "re", "pt", "uf", "gt", "Ret", " RET", "deg", "val", "rect", "reply", "rem", "rm", "out", "lt", "nl", "nt", "rets", "vt", "mt", "rest", "get", "tr", "def", "lit", "ext", "elt", "rt", "ref", "reset", "inter", "pat", "t", "len", "res", "ll", "resp", "alt", "gc", "Return", "ptr", "nz", "arg", "rel", "ben"], "cco": ["ckoo", "co", "eca", "becoin", "CCoin", "becpo", "incos", "coo", " aco", " ccano", " acO", "inco", "incopy", " icos", "ecov", "fcoin", "cov", "ccoo", "becos", " icco", "fco", "ecoo", "cu", " icO", "czos", "scos", "czano", "ccu", "ckov", "ccopy", "beco", "ccov", "ckco", "ckO", "coin", " ccos", "ckoin", " ccco", "cca", " acco", "CCo", "cko", "czco", "czO", "incoin", "ccano", "ccO", "ccos", "scpo", "czopy", "czoin", "sco", "ccoin", "ccco", " cca", "CCoo", "ecu", "cza", "CCopy", "ccpo", "cO", " ccO", "cku", "scoin", "CCos", " ccoo", "ecco", "CCO", "czo", "fcos", " ico", "fcpo", "eco", "ecano", " ccoin"]}}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    target_ulong old, val, mask;\n\n    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;\n\n    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {\n\n        mask |= 1 << CP0EnHi_EHINV;\n\n    }\n\n\n\n    /* 1k pages not implemented */\n\n#if defined(TARGET_MIPS64)\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        int entryhi_r = extract64(arg1, 62, 2);\n\n        int config0_at = extract32(env->CP0_Config0, 13, 2);\n\n        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;\n\n        if ((entryhi_r == 2) ||\n\n            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {\n\n            /* skip EntryHi.R field if new value is reserved */\n\n            mask &= ~(0x3ull << 62);\n\n        }\n\n    }\n\n    mask &= env->SEGMask;\n\n#endif\n\n    old = env->CP0_EntryHi;\n\n    val = (arg1 & mask) | (old & ~mask);\n\n    env->CP0_EntryHi = val;\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_entryhi(env, env->current_tc);\n\n    }\n\n    /* If the ASID changes, flush qemu's TLB.  */\n\n    if ((old & env->CP0_EntryHi_ASID_mask) !=\n\n        (val & env->CP0_EntryHi_ASID_mask)) {\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n}\n", "idx": 11854, "substitutes": {"env": ["sb", "ev", "err", "end", "en", "vm", "worker", "buf", "vv", "er", "te", "manager", "outer", "db", "gear", "timer", "door", "vp", "ter", "cmd", "ent", "conf", "enter", "esc", "addr", "test", "ef", "code", "her", "org", "ve", "ew", "obj", "config", "vt", "enc", "serv", "ah", "eas", "desc", "equ", "req", "txt", "et", "vs", "msg", "init", "conn", "pb", "environment", "entry", "era", "tk", "window", "server", "ctx", "oe", "here", "nv", "e", "doc", "erd", "hw", "engine", "dev", "cb", "eng", "v", "pg", "query", "vert", "forge", "cv", "event", "chart", "ner", "ec", "queue", "uv", "gate", "console", "eh", "context"], "arg1": ["argument2", " arg4", "Arg4", "argument5", "Arg1", "arg4", "Arg5", " arg2", "args4", "arg2", "arg3", "args2", "arg5", "doc1", "Arg3", " arg5", "args3", "args1", "doc2", "argument3", " arg3", "argument1", "doc4", "Arg2", "doc3"], "old": ["al", "equal", "or", "ld", "found", "x", " update", "high", "off", "mem", "from", "v", "ret", "test", "Old", "oid", "add", "ind", "lower", "hard", "lock", "other", "new", " handle", "holder", "expected", " updated", "obj", " os", " unused", "older", "tmp", "diff", " ind", "back", " saved", "hold", "index", "OLD", "handle", "var", " previous", " error", "empty", " low", " last", "local", "bor", " local", " ref", "ref", " orig", "last", "hash", "set", " form", "current", "loc", "inner", "same", "full", "valid", "alt", "orig", "ord", "le", "low", "arg", " new"], "val": ["pol", "p", "al", "func", "dev", "x", "pl", "vals", "final", "Val", "value", "mem", "err", "v", "ret", "vol", "sel", "test", "bal", "data", "entry", "result", "new", "aval", "key", "buf", "obj", "vt", "ival", "index", "act", "var", "rol", "iv", "tx", "arr", "elt", "eval", "ref", "mount", "bit", "max", "it", "cal", "VAL", "res", "loc", "valid", "alt", "orig", "pal", "el", "item"], "mask": ["limit", "flag", "ma", "mail", "qual", "master", "tag", "fix", "mas", "perm", "mass", "pack", "clear", "result", "mac", "mod", "map", "broad", "lock", "window", "shift", "key", "lag", "zip", "patch", "flags", "mission", "mean", "mut", "mt", "mb", "scale", "hold", "transform", "match", "Mask", "mk", "sign", "shape", "black", "bit", "cmp", "set", "mount", "hash", "ban", "miss", "m", "weight", "gate", "buffer", "mark", "sk", "sum", "batch", "block", "mx", "filter", "message", "magic", "zero", "mn", "ask", "cmd"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n", "idx": 11861, "substitutes": {"dshmem": ["dshtab", "dshmemory", "dshms", "dchmem", "dskmem", " dshmemory", "dshram", "dchms", "dhMem", "dskMem", "dSHms", "deshms", " dshtab", "dhmem", "dskmemory", " dshms", " dchms", " dshram", "dhtab", "dchram", "dshMem", "deshram", "deshmem", " dshMem", "dSHram", " dchmem", " dchram", "dsktab", "dhmemory", "dSHmem"]}}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n", "idx": 11865, "substitutes": {"ptr": ["r", "p", "dev", "pr", "dr", "proc", "mem", "eth", "addr", "alloc", "sp", "id", "ind", "pad", "pt", "ps", "str", "deg", "rob", "th", "rc", "buf", "obj", "pointer", "src", "Ptr", "expr", "index", "kl", "handle", "tr", "iv", "arr", "desc", "rt", "ref", "ctx", "inter", "t", "pos", "buffer", "port", "loc", "resp", "pc", "ctr", "hw", "address", "tty", "jp"], "ram_addr": ["ram__add", "ram_cmd", "gram_address", "ram_info", "ram_env", " ram_cmd", " ram__obj", "ram__addr", "ram____env", "ram__obj", "gram_env", "ram_obj", "ram__cmd", " ram_obj", "ram____address", "ram____addr", "ram_add", " ram__addr", " ram__cmd", "ram__address", "sam_info", "ram_ptr", "sam_address", "ram__info", " ram__add", "sam_addr", "gram_addr", "ram_address", "sam_ptr", "ram__ptr", " ram_add"]}}
{"project": "FFmpeg", "commit_id": "03acb035d1292685cc24a2be0f62dd8332711734", "target": 1, "func": "static int decode_format80(VqaContext *s, int src_size,\n\n    unsigned char *dest, int dest_size, int check_size) {\n\n\n\n    int dest_index = 0;\n\n    int count, opcode, start;\n\n    int src_pos;\n\n    unsigned char color;\n\n    int i;\n\n\n\n    start = bytestream2_tell(&s->gb);\n\n    while (bytestream2_tell(&s->gb) - start < src_size) {\n\n        opcode = bytestream2_get_byte(&s->gb);\n\n        av_dlog(s->avctx, \"opcode %02X: \", opcode);\n\n\n\n        /* 0x80 means that frame is finished */\n\n        if (opcode == 0x80)\n\n            break;\n\n\n\n        if (dest_index >= dest_size) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (opcode == 0xFF) {\n\n\n\n            count   = bytestream2_get_le16(&s->gb);\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode == 0xFE) {\n\n\n\n            count = bytestream2_get_le16(&s->gb);\n\n            color = bytestream2_get_byte(&s->gb);\n\n            av_dlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color);\n\n            CHECK_COUNT();\n\n            memset(&dest[dest_index], color, count);\n\n            dest_index += count;\n\n\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n\n\n            count = (opcode & 0x3F) + 3;\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode > 0x80) {\n\n\n\n            count = opcode & 0x3F;\n\n            av_dlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n\n            CHECK_COUNT();\n\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n\n            dest_index += count;\n\n\n\n        } else {\n\n\n\n            count = ((opcode & 0x70) >> 4) + 3;\n\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n\n            av_dlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(dest_index - src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n\n            dest_index += count;\n\n        }\n\n    }\n\n\n\n    /* validate that the entire destination buffer was filled; this is\n\n     * important for decoding frame maps since each vector needs to have a\n\n     * codebook entry; it is not important for compressed codebooks because\n\n     * not every entry needs to be filled */\n\n    if (check_size)\n\n        if (dest_index < dest_size)\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n\n\n    return 0; // let's display what we decoded anyway\n\n}\n", "idx": 11877, "substitutes": {"s": ["r", "ts", "less", "erences", "changes", "h", "sb", "ats", "conf", "ses", "ies", "rs", "v", "ains", "ls", "f", "params", "ss", "es", "als", "its", "ps", "gs", "j", "aws", "sports", "an", "comm", "sts", "parts", "n", "sq", "ess", "store", "a", "fs", "sv", "is", "serv", "as", "details", "bs", "ins", "os", "bis", "sg", "js", "sys", "hs", "ds", "stats", "m", "c", "S", "t", "bits", "vs", "cs", "e", "ims", "ms", "qs", "ants", "ns"], "src_size": ["rc_size", "src_end", "src_offset", "rc_end", "rc_SIZE", "src_name", "rc_offset", "src_SIZE", "src_length", "rc_length", "rc_name"], "dest": ["dc", "dist", "dev", "mem", "cat", "master", "v", "cont", "Dest", "test", "sort", "end", "priv", "csv", "trans", "result", "usr", "global", "good", "out", "origin", "null", "buf", "config", "temp", "tmp", "iter", "src", "comb", "st", "rest", "tr", "copy", "desc", "set", "target", "txt", "gate", "buffer", "status", "foreign", "port", "source", "loc", "decl", "table", "est", "sum", "way", "orig", "ptr", "del"], "dest_size": ["destrictname", "dest2name", "destrictsize", "dest_index", "dest_name", " dest_num", "destrictindex", "dest2num", "dest_SIZE", " dest_index", "Dest_Size", " dest_name", "Dest_SIZE", "dest_Size", "dest_set", "Dest_set", "dest2size", "Dest_size", "dest2index", "destrictnum", "dest_num", "Dest_index"], "check_size": ["checkmodsize", "checkbufpadding", "check_padding", "addr_offset", "checkktpadding", "checkktsize", "addrktpadding", "check_offset", "addrktoffset", "addrktnum", "checkmodpadding", "checkbufoffset", "addr_num", "checkktoffset", "addr_padding", "checkktnum", "checkmodoffset", "addrktsize", "check_num", "addr_size", "checkbufsize", "checkmodnum", "checkbufnum"], "count": ["limit", "found", "flag", "type", "number", "depth", "total", "history", "index", "cache", "empty", "force", "mount", "now", "find", "c", "filter", "sum", "len", "current", "cmd", "allow", "collection", "conf", "comment", "cont", "test", "cd", "code", "all", "balance", "core", "hold", "match", "info", "hash", "set", "max", "counter", "draw", "cost", "common", "amount", "command", "only", "process", "nt", "size", "cast", "ount", "each", "weight", "col", "ctr", "length", "frequency", "cycle", "list", "C", "v", "nb", "z", "add", "height", "ct", "call", "cond", "val", "Count", "cc", "n", "make", "offset", "check", "num", "important", "score"], "opcode": [" opno", "hopcase", "opercache", "opercommand", "OPce", "opso", " opso", "deepno", " opse", " opdate", "operCode", "itso", "operno", "iopclass", "hopce", "OPcase", "opercode", "ropclass", " opcod", " opcache", "opcod", " opct", "OPcommand", "deepcode", "hopCode", "itCode", "ropCode", "oppcode", "opcache", "hopcode", " opclass", "hopcommand", " opce", "hopcod", "operclass", "OPcod", "hopno", "OPct", "deepcod", "opct", "Opno", "opCode", "opcase", "iopdate", "Opnum", " opCode", "OPcode", "hopso", "OPnum", "OPno", "OpCode", "operse", "operce", "itcod", "oppno", "ropdate", "opce", "operct", "itcode", "ropcode", "hopclass", "deepcase", " opcommand", "opnum", "iopCode", "Opcode", "hopcache", "OPCode", "oppnum", "iopcode", "opdate", "opclass", "opcommand", "hopse", "oppCode", "opse", "opno"], "start": ["art", "skip", "limit", "p", "init", "next", "from", "head", "id", "sp", "end", "trans", "import", "stop", "Start", "shift", " Start", "origin", "in", "starting", "time", "size", "begin", "seek", "index", "st", "get", "first", "set", "offset", "reset", "it", "check", "part", "pos", "top", "len", "base", "wind", "before", "ish"], "src_pos": ["src67position", "dest_index", "src_offset", " src_position", "source_cos", "srcmmindex", "dest_pat", " src_offset", "srcmmpos", "src64cos", "srczpo", "dest_len", "src_os", "dest_pos", "src_pc", "src_cos", "src_po", " src_pt", "src1os", "src10rot", "src_rot", "src_pt", " src_rot", "src67pt", "source_pos", "src10pos", " src_pc", "src_pat", "src_parent", "srczparent", "src_position", " src_po", "src1pos", " src_os", " src_loc", "src67pos", "source_po", "src64pos", "src___pos", "src_loc", "src67os", "source_loc", " src_parent", " src_cos", "src_len", "src___pc", "src1cos", "srcmmpat", "src_index", "src___rot", "srcmmlen", "src10pc", "src64os", "srczpos"], "color": ["r", "or", "coll", "font", "blue", "pixel", "red", "comment", "cat", "feature", "value", "type", "err", "colored", "pair", "olor", "country", "role", "name", "white", "COLOR", "code", "other", "parent", "key", "rc", "cor", "light", "black", "border", "term", "category", "hash", "style", "token", "theme", "c", " colour", "background", "source", "colour", "normal", "Color", "col", "state", "alpha"], "i": ["cli", "x", " ii", "ind", "ix", "iu", "u", "bi", "index", "_", "var", "li", "uint", "\u0438", "c", "t", "batch", "ti", "cmd", "gi", "cont", "ic", "ei", "I", "phi", "q", "it", "qi", "mi", "ij", "buffer", "ki", "ims", "me", "ui", "p", "init", "uri", "id", "xi", "sim", "multi", "o", "iter", "g", "is", "copy", "y", "ini", "cmp", "fi", "ci", "chain", "pi", "di", "func", "C", "v", "ai", "ii", "j", "ji", "key", "n", "in", "hi", "si", "m", "ip", "zi", " j", "im", "ish", "ski"]}}
{"project": "FFmpeg", "commit_id": "d3b25383daffac154846daeb4e4fb46569e728db", "target": 1, "func": "static int zero12v_decode_frame(AVCodecContext *avctx, void *data,\n\n                                int *got_frame, AVPacket *avpkt)\n\n{\n\n    int line = 0, ret;\n\n    const int width = avctx->width;\n\n    AVFrame *pic = data;\n\n    uint16_t *y, *u, *v;\n\n    const uint8_t *line_end, *src = avpkt->data;\n\n    int stride = avctx->width * 8 / 3;\n\n\n\n    if (width == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Width 1 not supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')\n\n        && avpkt->size % avctx->height == 0\n\n        && avpkt->size / avctx->height * 3 >= width * 8)\n\n        stride = avpkt->size / avctx->height;\n\n\n\n    if (avpkt->size < avctx->height * stride) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small: %d instead of %d\\n\",\n\n               avpkt->size, avctx->height * stride);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    pic->key_frame = 1;\n\n\n\n    y = (uint16_t *)pic->data[0];\n\n    u = (uint16_t *)pic->data[1];\n\n    v = (uint16_t *)pic->data[2];\n\n    line_end = avpkt->data + stride;\n\n\n\n    while (line++ < avctx->height) {\n\n        while (1) {\n\n            uint32_t t = AV_RL32(src);\n\n            src += 4;\n\n            *u++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *v++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *u++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 2) {\n\n                if (!(width & 1)) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *v++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *u++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *v++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 2) {\n\n                if (width & 1) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 11885, "substitutes": {"avctx": ["ajcfg", "afconn", "avdyl", "avedyl", "avecfg", "avjac", "aflvl", "avcc", "avepkg", "avcmd", "avercc", "afcfg", "avercontext", "avecontext", "ajkl", "ajctx", "avereq", "abcmp", "navcontext", "navcmd", "afcontext", "avreq", "navtx", "navdyl", "ajtx", "afcmd", "abctx", "averkl", "avercfg", "avtx", "afdyl", "abcontext", "avcmp", "averctx", "awctx", "averlvl", " avtx", "avpkg", "ajtmp", "ajcmd", "ajconn", "avectx", "avconn", "avlvl", "awcontext", "afcu", "navcu", "ajjac", "afcc", "averjac", "afctx", "avecmd", "avkl", "avectl", "avelvl", "navctx", "abtx", "averreq", "avejac", "awtx", "avcfg", "ajcontext", " avjac", "avercmd", "aftx", "avctl", "avcontext", " avctl", "avecc", "awcmd", " avcmp", "avetmp", "avcu", " avconn", "avertmp", " avcfg", " avcu", "ajctl", "afcmp", " avcontext", "avertx", "ajreq", "ajpkg", "avetx", " avcmd", "avtmp", "avekl", " avpkg"], "data": ["options", "extra", "bin", "number", "depth", "buf", "d", "history", "index", "cache", "def", "to", "empty", "first", "byte", "text", "t", "current", "mu", "w", "rel", "ns", "done", "value", "ic", "params", "name", "code", "new", "raw", "stack", "obj", "a", "blocks", "info", "hash", "it", "buffer", "block", "pieces", "table", "action", "p", "init", "i", "ata", "id", "frame", "pad", "str", "padding", "window", "at", "record", "size", "video", "values", "bytes", "times", "input", "mode", "length", "error", "r", "step", "ot", "list", "DATA", "next", "read", "args", "plain", "format", "height", "Data", "feed", "date", "val", "device", "origin", "area", "file", "dat", "ext", "offset", "m", "bits", "num", "items", "base", "message", "image", "response"], "got_frame": ["received_error", "received_frames", "got2state", "got_state", "received_frame", "got2frame", "got2error", "got2frames", "received_state", "got_frames", "got_error"], "avpkt": ["aftpatx", "avpadkg", "avppnt", "aftptx", "avpett", "avewpkt", "avspwk", "avnpacket", "airwpkt", "avcpacket", "avepkg", "avpKT", "airpcht", "avwpkt", "avpaet", "avcpnt", " avPnt", "avjpkt", "avenpKT", "avptx", "avnpett", "avsptx", "avpct", "avpacket", "avspkt", " avpht", "avnpdat", "avenpett", "airwpett", "avepett", "avPct", "avpcht", "airwpacket", "afpcht", "avpawk", "avlpkt", " avpct", "avprekt", "avlpacket", " avPct", "aftpwk", "avpadat", "avewpkg", "aftpkt", "avpartwt", "wavpct", "avewpacket", "avipacket", "avjpct", "avpdat", "avjpnt", "avwpet", "avcpet", "avnpet", "airpett", "aftpakt", "avipkt", "avwpkg", "avpaynt", "avcpKT", "avcpdat", "avpkg", "avwpcht", "avpwt", "avcpwk", "avepet", "avpaycht", "wavpadkg", "avcpett", "avpant", "avpartcht", "avPht", "avenpkt", "wavpadct", "avpaacket", "afpacket", "avcpwt", "avewpet", "avcpkt", "afpdat", "avspnt", "afpnt", "avcpkg", "avnpkg", "wavpkt", "avpadkt", "avpwk", "aftpant", "wavpacket", "avlpett", "avpadacket", "airwpcht", "avpaykt", "avwpacket", "avpaywt", "afpwt", "avipkg", "afcpet", " avPkt", "avpatett", "avpatkt", "aftpnt", "avprect", "afcpwt", "avppht", "aftpawk", "avpartkt", "avpatKT", "avepkt", "avpartnt", " avpnt", "airpacket", "avpet", "avPkt", "avnpKT", "avpht", "avepacket", "afpkt", "avwpett", "avpreacket", "avpatacket", "avepKT", "avcpcht", "avipet", "avlpcht", "wavpkg", " avPht", "avpatx", "afcpcht", "avppct", "afcpdat", "avnpkt", "afpet", "afcpnt", "wavpadacket", "airpkt", "avprekg", "avPnt", "avjpht", "avpnt", "avpakt", "avpadct", "avppkt", "avenpacket", "afcpkt", "afcpacket", "wavpadkt", "avcpct", "avcptx"], "ret": ["pret", "flag", "RET", "ft", "mem", "err", "cont", "success", "jp", "re", "format", "result", "fr", "gt", "Ret", "val", "rem", "progress", "rm", "out", "nt", "rets", "not", "back", "print", "mt", "def", "tr", "try", "lit", "elt", "rt", "ref", "ry", "reset", "it", "fin", "txt", "len", "res", "status", "ll", "resp", "det", "alt", "rel"], "pic": ["pol", "p", "iac", "pert", "ot", "py", "pl", "pres", "wp", "lp", "px", "perm", "typ", "vol", "ic", "sp", "eric", "pict", "cam", "fc", "syn", "kit", "stat", "pot", "pt", "Pic", "ps", "fr", "tt", "shot", "xi", "jac", "picture", "capt", "chat", "peg", "pick", "piece", "ican", "feat", "photo", "pa", "mt", "png", "Picture", "parse", "script", "pit", "pse", "phys", "pan", "tx", "fp", "ctx", "pin", "pat", "mic", "pen", "txt", "ip", "kt", "anc", "plain", "ping", "pi", "gc", "pc", "ig", "magic", "Pict", "img", "jp", "ac"], "y": ["r", "p", "ny", "x", "h", "py", "yi", "xy", "yr", "i", "k", "vy", "dy", "z", "yer", "oy", "l", "height", "j", "sky", "ys", "ey", "key", "iy", "n", "o", "b", "my", "g", "yy", "s", "ch", "axy", "Y", "iny", "yt", "ay", "sys", "ym", "ly", "offset", "m", "c", "cy", "t", "top", "yl", "sy", "ye", "e", "yo", "w", "rot", "gy", "by"], "u": ["ui", "util", "p", "uni", "x", "h", "ue", "um", "su", "i", "f", "ou", "un", "k", "ul", "l", "uf", "U", "uc", "iu", "cu", "uid", "n", "o", "lu", "tu", "ur", "uu", "eu", "ut", "fu", "pu", "uv", "c", "t", "nu", "au", "mu", "us", "w"], "v": ["p", "av", "x", "h", "f", "i", "vol", "vr", "version", "l", "ver", "j", "qv", "va", "n", "ve", "cv", "o", "sv", "vt", "a", "b", "vv", "g", "var", "iv", "q", "vi", "V", "uv", "c", "m", "t", "nv", "vc", "vp", "e", "k", "w", "conv"], "line_end": ["line_ender", "line2END", " line_start", "line2end", "linePender", " line_ender", " line_bound", "line2id", "linePbound", "line_ends", "line_id", " line2end", "line_start", " line_id", "line2start", "line2ends", " line2start", "line_ended", "line_END", " line_ends", " line2ends", " line_ended", " line_END", "linePend", "linePstart", " line2END", "line_bound"], "src": ["r", "sync", "x", "sb", "rs", "attr", "i", "err", "addr", "ser", "ic", "url", "syn", "tp", "fc", "bc", "l", "filename", "str", "start", "sub", "nr", "ix", "th", "rc", "sr", "slice", "in", "sq", "rl", "time", "comp", "iter", "sl", "sec", "scan", "st", "s", "ur", "hl", "sn", "input", "rt", "lat", "sys", "c", "txt", "text", "pos", "sc", "lin", "source", "loc", "inner", "row", "dest", "ptr", "ctr", "img"], "line": ["Line", "ine", " slide", " l", "ode", "lines", "no", " lines", "pixel", "i", "link", " stroke", "id", "frame", "pair", "pe", "cell", "l", " row", "ln", "page", "code", "depth", "position", " frame", "slice", "nl", "pipe", "liner", " lin", "iter", "eline", "ie", "file", "path", "li", "node", "lo", "offset", "pos", "lin", "block", "port", "row", "source", "LINE", "ide", "e", "le", "level", "se", "length", "edge"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n", "idx": 11911, "substitutes": {"field": ["ment", "FIELD", "list", "flag", "master", "tag", "f", "link", "rule", "test", "pair", "pack", "butt", "cell", "pad", "league", "group", "map", "window", "array", "line", "bar", "load", "file", "form", "match", "term", "Field", "queue", "node", "fields", "manager", "buffer", "row", "table", "message", "grid", "word", "address"], "bit": ["p", "x", "flag", "slot", "bin", "unit", "tag", "i", "git", "gem", "test", "id", "op", "band", "bc", "hit", "lock", "bot", "key", "bug", "piece", "config", "Bit", "bt", "b", "ch", "board", "uint", "task", "it", "byte", "check", "t", "ip", "bits", "status", "block", "port", "row", "point", "word", "BIT", "rot", "ac"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 11919, "substitutes": {"str": ["r", "p", "coll", "pr", "list", "dr", "seq", "ar", "pre", "cont", "vol", "sp", "cur", "format", "end", "name", "trans", "fr", "rep", "STR", "stri", "raw", "out", "n", "buf", "obj", "iter", "enc", "prefix", "inst", "print", "shr", "form", "st", "s", "Str", "tr", "expr", "ext", "arr", "gr", "br", "txt", "chain", "t", "buffer", "text", "len", "res", "inner", "ocr", "doc", "ctr", "ptr", "spec", "orig", "del", "msg"], "endptr": ["stopptr", "nextpointer", "nextpointers", "ENDpointer", "enderPtr", "stoprep", "nextptr", "entpointer", "enderptr", "startbytes", "startptr", "enderbytes", "endobj", "endctr", "entctr", "startpointers", "endpt", "startpointer", "enderobj", "enderpt", "stoppt", "enderpointer", "endedpointer", "endpointers", "enderinst", "ENDpt", "lastpt", "startobj", "enderrep", " endPtr", "endersp", " endobj", "ENDctr", "endsp", " endpointers", "startinst", "endedptr", "endrep", "endedsp", "lastpointer", " endpt", "endpointer", "ENDptr", "enderpointers", "endedpointers", " endpointer", "endedPtr", "endedpt", "endedctr", "stopsp", "endedrep", "nextbytes", "entptr", "endinst", " endinst", "endPtr", "lastptr", "startPtr", "endbytes", "entpt"], "err": ["r", " typ", "or", "coll", "cr", "die", "dr", "pr", "conf", "hr", "Er", " gr", "attr", "rr", "repl", "der", " dist", "z", "norm", "warn", "ox", "fr", " arr", "usr", "lr", "erer", "Error", " Err", "progress", "spr", "exc", " fr", "notice", "rel", "rm", " terr", "iter", "diff", " cr", "er", "cer", "gz", "shr", " er", "act", "urg", "rol", " error", "arr", "gr", "sys", "mr", "kr", "rar", "ger", "req", "here", " ec", " score", "res", "inner", "ell", "resp", "e", "erd", "eor", "error"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n", "idx": 11933, "substitutes": {"klass": ["ikkls", "iklass", "Kcl", "cctor", "ikcl", "klas", "ccclass", "iklasses", "ikls", "ikkclass", " klas", "ikktor", "kls", " kclass", "Kls", "cclass", "ccls", "ikklas", "kcl", "ikklass", "klasses", " klasses", " ktor", "oklas", "kclass", "oklass", "Klass", "ktor", "okclass", "Klasses", "okls", " kcl", " kls"], "data": ["r", "di", "dev", " d", "DATA", "bin", "json", "ata", "name", "rec", " DATA", "result", "Data", " Data", " sd", "key", "raw", "rc", "out", "o", "d", "dat", "def", "module", "m", "res", "mu"], "dc": ["di", "p", "iac", "cr", "tc", "DC", "ga", "i", "cm", "dd", "ck", "ic", "dm", "dp", "fc", "bc", "nc", "cd", "disc", "lc", "dt", "cc", "rc", "cp", " DC", "da", "a", "d", "dk", "dh", "ec", "desc", "ca", "mc", "c", "m", "db", "ta", "kw", "gc", "pc", "cs", "cca", "doc", "nz", "cmd"], "k": ["ack", "p", "km", "kar", "i", "kn", "rek", "ck", "z", "kit", "uk", "kick", "ek", "ikk", "tk", "j", "ka", "ik", "key", "kat", "ijk", "wk", "n", "o", "ak", "b", "kj", "d", "kid", "dk", "g", "kh", "ko", "mk", "work", "kl", "kk", "ks", "ok", "q", "kan", "K", "ku", "kr", "it", "mc", "c", "m", "kind", "t", "kt", "sk", "kw", "ki", "spec"]}}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n", "idx": 11936, "substitutes": {"wsource": ["rwinterface", "hwsequence", "waseries", " wser", "expsite", "waservice", "awource", "wtcause", "walsource", "wcause", "yinput", "yser", "wtstore", "wtsource", " wsite", "winput", "expinput", "walinterface", "walcause", "wordsession", "wtscope", "wscope", "wastore", "ysource", "awsource", "hwsource", "winterface", "rwsource", "wtsession", "wasource", "expsource", "wtseries", " wservice", "wstore", "ysite", "walsequence", "wseries", "wasite", "hwsession", " wstore", " wscope", "hwmessage", "wser", "wmessage", " winput", "awservice", "wsession", "wservice", "expser", "wtinterface", "wordmessage", "wsequence", "waource", "rwcause", " wource", "wource", "wordsequence", "awsite", "wtmessage", "rwsequence", "wascope", "wordsource", "wtsequence", "wsite", " wseries"]}}
{"project": "qemu", "commit_id": "e40c3d2e7f4b58669a1b4e5dfb684e57c0bf62ce", "target": 0, "func": "static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,\n\n                              uint32_t irq, bool use_highmem)\n\n{\n\n    Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf;\n\n    int i, bus_no;\n\n    hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base;\n\n    hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size;\n\n    hwaddr base_pio = memmap[VIRT_PCIE_PIO].base;\n\n    hwaddr size_pio = memmap[VIRT_PCIE_PIO].size;\n\n    hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base;\n\n    hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size;\n\n    int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;\n\n\n\n    Aml *dev = aml_device(\"%s\", \"PCI0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A08\")));\n\n    aml_append(dev, aml_name_decl(\"_CID\", aml_string(\"PNP0A03\")));\n\n    aml_append(dev, aml_name_decl(\"_SEG\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_BBN\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"PCI0\")));\n\n    aml_append(dev, aml_name_decl(\"_STR\", aml_unicode(\"PCIe 0 Device\")));\n\n    aml_append(dev, aml_name_decl(\"_CCA\", aml_int(1)));\n\n\n\n    /* Declare the PCI Routing Table. */\n\n    Aml *rt_pkg = aml_package(nr_pcie_buses * PCI_NUM_PINS);\n\n    for (bus_no = 0; bus_no < nr_pcie_buses; bus_no++) {\n\n        for (i = 0; i < PCI_NUM_PINS; i++) {\n\n            int gsi = (i + bus_no) % PCI_NUM_PINS;\n\n            Aml *pkg = aml_package(4);\n\n            aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF));\n\n            aml_append(pkg, aml_int(i));\n\n            aml_append(pkg, aml_name(\"GSI%d\", gsi));\n\n            aml_append(pkg, aml_int(0));\n\n            aml_append(rt_pkg, pkg);\n\n        }\n\n    }\n\n    aml_append(dev, aml_name_decl(\"_PRT\", rt_pkg));\n\n\n\n    /* Create GSI link device */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irqs =  irq + i;\n\n        Aml *dev_gsi = aml_device(\"GSI%d\", i);\n\n        aml_append(dev_gsi, aml_name_decl(\"_HID\", aml_string(\"PNP0C0F\")));\n\n        aml_append(dev_gsi, aml_name_decl(\"_UID\", aml_int(0)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_PRS\", crs));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_CRS\", crs));\n\n        method = aml_method(\"_SRS\", 1, AML_NOTSERIALIZED);\n\n        aml_append(dev_gsi, method);\n\n        aml_append(dev, dev_gsi);\n\n    }\n\n\n\n    method = aml_method(\"_CBA\", 0, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_return(aml_int(base_ecam)));\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_CRS\", 0, AML_NOTSERIALIZED);\n\n    Aml *rbuf = aml_resource_template();\n\n    aml_append(rbuf,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0000, nr_pcie_buses - 1, 0x0000,\n\n                            nr_pcie_buses));\n\n    aml_append(rbuf,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio,\n\n                         base_mmio + size_mmio - 1, 0x0000, size_mmio));\n\n    aml_append(rbuf,\n\n        aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                     AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio,\n\n                     size_pio));\n\n\n\n    if (use_highmem) {\n\n        hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base;\n\n        hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size;\n\n\n\n        aml_append(rbuf,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000,\n\n                             base_mmio_high, base_mmio_high, 0x0000,\n\n                             size_mmio_high));\n\n    }\n\n\n\n    aml_append(method, aml_name_decl(\"RBUF\", rbuf));\n\n    aml_append(method, aml_return(rbuf));\n\n    aml_append(dev, method);\n\n\n\n    /* Declare an _OSC (OS Control Handoff) method */\n\n    aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n    method = aml_method(\"_OSC\", 4, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_create_dword_field(aml_arg(3), aml_int(0), \"CDW1\"));\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.5.1. _OSC Interface for PCI Host Bridge Devices\n\n     * The _OSC interface for a PCI/PCI-X/PCI Express hierarchy is\n\n     * identified by the Universal Unique IDentifier (UUID)\n\n     * 33DB4D5B-1FF7-401C-9657-7441C03DD766\n\n     */\n\n    UUID = aml_touuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW2\"), aml_name(\"SUPP\")));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW3\"), aml_name(\"CTRL\")));\n\n    aml_append(ifctx, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\n\n                                aml_name(\"CTRL\")));\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    aml_append(ifctx, aml_store(aml_name(\"CTRL\"), aml_name(\"CDW3\")));\n\n    aml_append(ifctx, aml_return(aml_arg(3)));\n\n    aml_append(method, ifctx);\n\n\n\n    elsectx = aml_else();\n\n    aml_append(elsectx, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\n\n                                  aml_name(\"CDW1\")));\n\n    aml_append(elsectx, aml_return(aml_arg(3)));\n\n    aml_append(method, elsectx);\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_DSM\", 4, AML_NOTSERIALIZED);\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.6.1. _DSM for PCI Express Slot Information\n\n     * The UUID in _DSM in this context is\n\n     * {E5C937D0-3553-4D7A-9117-EA4D19C3434D}\n\n     */\n\n    UUID = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\n\n    uint8_t byte_list[1] = {1};\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(ifctx1, aml_return(buf));\n\n    aml_append(ifctx, ifctx1);\n\n    aml_append(method, ifctx);\n\n\n\n    byte_list[0] = 0;\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(method, aml_return(buf));\n\n    aml_append(dev, method);\n\n\n\n    Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\n\n    aml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, dev_rp0);\n\n    aml_append(scope, dev);\n\n}\n", "idx": 11957, "substitutes": {"scope": ["proc", "acc", "alloc", "test", "sp", "flow", "serial", "env", "cl", "window", "ops", "root", "event", "app", "scan", "tr", "var", "sys", "ctx", "module", "req", "sc", "res", "block", "row", "mode", "ram", "spec"], "memmap": ["cachemap", "memhash", "memoryapper", "hwapper", "Memmap", "ramhash", "memorytab", "mapdict", "mempack", "mmmap", "memorymap", "hwdown", "memorypack", "memdict", "cachemask", "memcache", "mapap", "rammap", "memlist", "memoryhash", "timmap", "maphash", "memoryap", "timtab", "MemMap", "cachelist", "memorycap", "mmcap", "hwcap", "mmap", "memorydown", "memmask", " memMap", "timpack", "memMap", " mempack", "mapapper", "Mempack", "histap", "mmmask", "hwtab", "cacheap", "memorydict", "timap", "memorylist", "histcache", "histcap", "memapper", "ramMap", "hwlist", "hwap", "memorycache", "memcap", "histmap", "hwpack", "memap", "memdown", "mmcache", "hwmap", "mmlist", "ramdict", "mapdown", "rampack", "memtab", "ramap", "mapmap", "memorymask"], "irq": ["ibrz", "ibrqu", "rerquant", "ibrq", "rerz", "irqu", "yrq", "ibrquant", "yrqu", "yrquant", "rerqu", "irquant", "yrz", "rerq", "irz"], "use_highmem": ["use_highMem", "use_fastmem", "use2highms", "use2lowMem", "use_lowmem", "use_hmem", "use2lowmemory", "use2highMem", "use_hmemory", "use_fastmemory", "use_lowmemory", "use_fastms", "use_hms", "use_fastMem", "use_highmemory", "use_highms", "use2highmem", "use_hMem", "use_lowMem", "use2lowmem", "use2lowms", "use2highmemory", "use_lowms"], "method": ["util", "func", "Method", "instance", "fun", "acc", "attr", "member", "exec", "hod", "call", "access", "record", "event", "inst", "METHOD", "tr", "path", "cmp", "mount", "module", "prop", "ann", "action", "mode", "spec", "mod", "cmd"], "crs": ["Cds", "acrs", "cRS", "CRS", "cds", "Cri", "cri", "ccRS", "Crs", "ccri", "acds", "acRS", "ccds", "acri", "ccrs"], "ifctx": ["Iftx", "Ifaddr", "condaddr", "ifaddr", "IFctx", "Ifcontext", "IFtx", "ifcontext", "iftx", "condcontext", "condtx", "condctx", "Ifctx", "IFaddr", "IFcontext"], "UUID": ["CID", "SUUL", "SUUID", "NUID", "CUID", "Uuid", "CUL", "SUID", "SUuid", "Nuid", "UUL", "NUL", "NID", "Cuid", "UID"], "ifctx1": ["ifcontext2", "ifreq0", "ifreq1", "ifreq3", "Ifctx0", "ifctx3", "ifcc1", "ifcc3", "Ifcontext1", "Ifcontext2", "ifctx2", "ifcc2", "Ifctx1", "Ifctx2", "Ifcontext3", "ifcc0", "ifcontext3", "ifcontext1", "ifcontext0", "ifreq2", "ifctx0", "Ifcontext0", "Ifctx3"], "elsectx": ["elseqx", "elseqX", "evseqi", "elifx", "elsectionh", "elsectX", "elifh", "elsectionX", "elifX", "elsectioni", "evsectX", "evseqx", "elifi", "elsectionx", "elseqh", "evsecti", "evsectx", "evseqh", "evsecth", "evseqX", "elsecti", "elseqi", "elsecth"], "buf": ["cb", "seq", "proc", "mem", "cf", "cap", "err", "ff", "alloc", "bc", "uf", "family", "cv", "tmp", "cast", "buff", "act", "queue", "ref", "ctx", "box", "buffer", "batch", "kw", "block", "doc", "msg", "cmd"], "i": ["ui", "di", "p", " pi", "x", " ti", "v", "gi", "id", "ai", "ic", " ii", "ei", "l", "ii", "j", "xi", "sim", "I", "ix", " mi", "oi", "multi", "u", "bi", "n", " I", "o", "a", "b", "si", "li", " bi", "y", " e", " li", "ini", "it", " ni", "ci", "m", "c", " di", "qi", "ip", "mi", "zi", " j", "ti", "pi", "e", "ki", "k"], "bus_no": ["bus_NO", "bridge_NO", "busptrow", "bus7No", "bus_yes", "Bus_row", "bus_row", "bus7no", "bridge_eno", "bus_go", "Bus_No", " bus_ne", "busptNo", "bus_eno", " bus_No", " bus_row", "bridge_no", "bus7row", "Bus_no", "bridge_go", "bus7nos", "bus_nos", "busptno", "bus_ne", " bus_yes", "Bus_nos", "busptyes", " bus_nos", "bus_No"], "dev": ["pro", "av", "develop", "DEV", "off", "conn", "Dev", "ev", "mem", "gpu", "v", "dd", "vol", "cam", "tech", "serial", "end", "priv", "pad", "pt", "ver", "env", "hd", "val", "nav", "raw", "debug", "device", "roll", "ve", "dep", "des", "temp", "nt", "md", "serv", "slow", "hid", "def", "dem", "tr", "var", "sd", "desc", "pu", "development", "go", "gu", "adv", "home", "local", "disk", "draw", "prom", "stable", "den", "det", "normal", "cho", "w", "cmd"], "rt_pkg": ["rx_pkg", "rx_kg", "rx_pack", "rx_buf", "rt_buf", "rt_pack", "rt_kg"]}}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11958, "substitutes": {"bs": ["ts", "irms", "sb", "vals", "blog", "ses", "rs", "aos", "outs", "bos", "ls", "BS", "pb", "ss", "its", "als", "es", "bp", "bc", "obs", "ps", "gs", "acs", "aws", "bb", "ubs", "sts", "fs", "bh", "b", "lbs", "ins", "os", "ms", "bis", "js", "bes", "hs", "ds", "ubis", "bits", "bps", "aus", "bn", "vs", "cs", "ims", "hz", "qs", "ns"], "p_name": ["pbostonname", " p_Name", " p_id", "pad_error", "prentext", "p_label", "prenName", " p_lan", "p_names", "puppettext", "pc_Name", "p_text", "puppetlabel", "pkgcap", "p_error", "pb_code", "p_Name", "pugerror", "prenlabel", "pugname", "padugn", " p_default", "pcuppetlabel", "p_code", "p_id", "pocklan", "pc_text", "pugn", "pkglan", "padugname", "pb_name", "pcuppetname", "p_old", "puppetName", " p_nm", "pkgnames", "p_val", "pcuppettext", "pocknm", "p_parent", "postoncode", "pkgparent", "pugcode", "pc_label", "p_nm", "pcuppetName", "pkgnm", "pad_name", "pad_n", "pbostoncap", "p_n", "pad_path", "pb_parent", "pbostonparent", "padugpath", "p_cap", " p_old", "postonparent", "postonname", "p_path", "p_lan", "pocknames", "puppetname", "pugpath", "p_default", "pkgname", "pugparent", " p_val", "pugcap", " p_names", "postoncap", "pc_name", "prenname", "pkgcode", "padugerror", "pockname", "pb_cap", "pbostoncode"], "desc": ["pro", "dc", "dist", "dev", "Desc", "seq", "red", "comment", "bd", "ript", "pres", "described", "esc", "cont", "de", "name", "rec", "dict", "str", "cd", "disc", "sub", "good", "phrase", "rc", "dep", "buf", "des", "nt", "obj", "comp", "md", "dir", "d", "sec", "st", "ext", "def", "info", "asc", "cmp", "ds", "req", "txt", "sc", "DES", "resp", "description", "dest", "doc", "ptr", "sort", "msg", "cmd"], "s": ["ts", "p", "sb", "ats", "ses", "rs", "se", "v", "ls", "sp", "ss", "ps", "xs", "gs", "j", "aws", "sts", "ess", "sq", "sv", "fs", "b", "ms", "js", "sys", "hs", "ds", "S", "sis", "c", "t", "vs", "cs", "ns"], "end_name": ["end_ame", "ENDjame", "END_name", "end64mem", "end64name", "endjname", "start_num", " end_val", "end_Name", " end_Name", "endjName", " end_path", "start_key", "start__key", "endjame", "end_error", " end_on", "end__error", "ENDjName", "start_error", "END_Name", "end64val", " end_mem", "end_num", "start__error", "end_val", "end_on", "end_key", "end__num", "END_ame", "start__num", "end_mem", "end_path", "start_name", "end__key", "end__name", "end64Name", "start__name", "ENDjname"]}}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static MemoryRegionSection address_space_do_translate(AddressSpace *as,\n\n                                                      hwaddr addr,\n\n                                                      hwaddr *xlat,\n\n                                                      hwaddr *plen,\n\n                                                      bool is_write,\n\n                                                      bool is_mmio)\n\n{\n\n    IOMMUTLBEntry iotlb;\n\n    MemoryRegionSection *section;\n\n    MemoryRegion *mr;\n\n\n\n    for (;;) {\n\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n\n        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);\n\n        mr = section->mr;\n\n\n\n        if (!mr->iommu_ops) {\n\n            break;\n\n        }\n\n\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n\n                | (addr & iotlb.addr_mask));\n\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n\n            goto translate_fail;\n\n        }\n\n\n\n        as = iotlb.target_as;\n\n    }\n\n\n\n    *xlat = addr;\n\n\n\n    return *section;\n\n\n\ntranslate_fail:\n\n    return (MemoryRegionSection) { .mr = &io_mem_unassigned };\n\n}\n", "idx": 11969, "substitutes": {"as": ["ts", "mm", "ra", "asa", "rs", "aos", "ar", "sa", "ast", "ss", "As", "am", "acs", "ias", "AS", "admin", "las", "ak", "a", "area", "ac", "pa", "aser", "os", "ach", "arp", "eas", "ms", "sys", "ds", "ras", "with", "ame", "ars", "ase", "asi", "asm", "cs", "us", "bs", "ag", "aster", "ns"], "addr": ["wd", "x", "dr", "err", "url", "data", "align", "rc", "nl", "da", "arr", "ref", "adr", "t", "ad", "len", "loc", "ord", "ptr", "rid", "cmd", "ace", "attr", "dd", "ash", "name", "lr", "oa", "obj", "ress", "a", "src", "act", "arp", "tx", "hl", "rt", "lat", "hash", "wid", "res", "ag", "ack", "off", "coord", "ar", "i", "id", "pad", "str", "start", "oad", "at", "mt", "tr", "ha", "Address", "elt", "ctx", "alias", "arch", "alpha", "hw", "ac", "r", "art", "ld", "rs", "rr", "add", "las", "work", "offset", "rn", "ip", "pos", "alt", "address"], "xlat": ["wsat", "XLat", "exaddr", "exLat", " xsat", "xaddr", "Xsat", "Xlat", "exlat", "xsat", "wlat", "waddr", "exsat", "wLat", "xLat", "Xaddr", " xaddr", " xLat"], "plen": ["iplEN", " plEN", "selength", "selen", "pllen", "PLength", "selEN", "plEN", "kllen", "ptun", "penlen", "klEN", "PLen", "slen", " plener", "ptatten", "klength", "slun", "PLlen", " pllen", "platten", " plength", "pten", " plun", "plength", "sllen", "klun", " platten", "klatten", "penen", "slener", "penength", "ipllen", "iplener", "plun", "klen", "penEN", "PLEN", "iplength", "iplun", "iplen", "ptEN", "sellen", "plener"], "is_write": ["is_Write", "Is_write", "is1fine", "type_fine", "isletread", "type_write", "is1read", "isletwrite", "Is_Write", "isletfine", "is_update", "type1log", "is_read", "type1fine", "type_read", " is_read", " is_Write", "Is_update", "type_log", "is_fine", "type1write", "type1read", "isletlog", "is1log", "is1write", " is_writ", "is_writ", "is_log"], "is_mmio": ["is2mmios", "is_mio", "is_tmIO", "is_miol", "is_MMios", "is2mmIO", "is_mmios", "is_mmiol", "is2mxio", "is_MMiol", "is_mxIO", "is_mxios", "is_mxio", "is_MMio", "is_mmIO", "is_mios", "is2mxios", "is_tmios", "is_mIO", "is2mmio", "is2mxIO", "is_tmio"], "iotlb": ["itb", "iottb", "netlbs", "iobl", "iottlb", "iourlbs", "iotlu", "potl", "ioplb", "ylb", "skyb", "iotlp", "iotbl", "iopbl", "ietlab", "ylab", "yLB", "iourlr", "otbl", "ietlbs", "iotl", "ioplr", "otelu", "otb", "itlab", "iolbs", "ietlb", "skylbs", "ietb", "nitlr", "skylab", "nitlb", "otl", "nitlbs", "ietlu", "iotlr", "ylu", "nitlp", "potlab", "otelab", "iottlr", "otlbs", "potbl", "iottl", "otlab", "iotLB", "otlb", "potlb", "ietLB", "iottlp", "iotb", "iolb", "iolr", "otelb", "iottbl", "potlr", "iotlab", "iottlab", "netlb", "ioplbs", "nitlab", "skyl", "itlbs", "potlp", "skylb", "iotlbs", "nitbl", "potlbs", "oteLB", "iottlbs", "iourlp", "netlp", "itlb", "netlr", "iourlb"], "section": ["ment", "r", "session", "sb", "instance", "sections", "table", "master", "sector", "region", "member", "tag", "job", "Section", "sect", "ss", "pair", "connection", "format", "entry", "result", "j", "group", "layer", "lc", "our", "rup", "component", "channel", "journal", "area", "sec", "ner", "sam", "tr", "ry", "set", "header", "module", "manager", "part", "block", "port", "db", "row", "spec", "option", "description", "mode", "asm", "context", "state", "sub", "se", "mod", "room"], "mr": ["r", "rer", "pr", "hr", "dr", "tur", "rs", "rr", "ar", "cm", "hm", "mor", "vr", "Mr", "wr", "usr", "lr", "rpm", "nr", "our", "dt", "ml", "rm", "sr", "rg", "nm", "older", "rl", "md", "er", "wm", "mt", "mb", "shr", "mir", "tr", "mk", "arry", "rt", "gr", "rar", "pm", "kr", "ds", "adr", "rn", "m", "mc", "mp", "br", "mx", "rb", "ocr", "MR", "asm", "mid", "wcs", "ctr", "ms", "bm", "mn", "drm"], "d": ["r", "di", "p", "done", "dc", "h", "dr", "dx", "bd", "D", "dq", "f", "dd", "de", "dm", "gd", "dp", "j", "dl", "dt", "debug", "pd", "da", "g", "b", "dir", "did", "s", "dh", "dat", "fd", "dra", "dn", "ds", "t", "dj", "db"]}}
{"project": "qemu", "commit_id": "30de46db50d2f9f74c5f7ab1cc463b8dec026407", "target": 0, "func": "static void read_guest_mem(void)\n\n{\n\n    uint32_t *guest_mem;\n\n    gint64 end_time;\n\n    int i, j;\n\n    size_t size;\n\n\n\n    g_mutex_lock(data_mutex);\n\n\n\n    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n    while (!fds_num) {\n\n        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {\n\n            /* timeout has passed */\n\n            g_assert(fds_num);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check for sanity */\n\n    g_assert_cmpint(fds_num, >, 0);\n\n    g_assert_cmpint(fds_num, ==, memory.nregions);\n\n\n\n    /* iterate all regions */\n\n    for (i = 0; i < fds_num; i++) {\n\n\n\n        /* We'll check only the region statring at 0x0*/\n\n        if (memory.regions[i].guest_phys_addr != 0x0) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);\n\n\n\n        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;\n\n\n\n        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,\n\n                         MAP_SHARED, fds[i], 0);\n\n\n\n        g_assert(guest_mem != MAP_FAILED);\n\n        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));\n\n\n\n        for (j = 0; j < 256; j++) {\n\n            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);\n\n            uint32_t b = guest_mem[j];\n\n\n\n            g_assert_cmpint(a, ==, b);\n\n        }\n\n\n\n        munmap(guest_mem, memory.regions[i].memory_size);\n\n    }\n\n\n\n    g_assert_cmpint(1, ==, 1);\n\n    g_mutex_unlock(data_mutex);\n\n}\n", "idx": 11975, "substitutes": {"guest_mem": ["guest2mat", "guestJmemory", "guome___mem", "guest_mt", "guest_num", "guest_addr", "guest___rm", "guester___mem", "guest_mat", "guested2mem", "guested_mem", "guestJmem", "guest___Mem", "guest___num", "guest_buf", "guested2num", "guome_rm", "guestJman", "guess_link", "guest2num", "guEST_mem", "guest___reg", "guests_addr", "guestThemt", "guested_ram", "guEST_buf", "guest___mt", "guest_err", "guest_ram", "guested2Mem", "guome_mat", "guester_dim", "guest_link", "guest2rm", "guest_rm", "guest___mem", "guester_err", "guest2mem", "guest_memory", "guest_Mem", "guester___mt", "guest___err", "guome_mem", "guome_reg", "guested2memory", "guestThemem", "guome___reg", "guester___err", "guested_memory", "guestThedim", "guester___dim", "guEST_man", "guome___mat", "guested_num", "guested_Mem", "guest___mat", "guests_reg", "guests_mem", "guEST_memory", "guess_mem", "guest2reg", "guest_reg", "guester_mt", "guester_mem", "guome___rm", "guest2memory", "guest___dim", "guest2Mem", "guestJbuf", "guest___memory", "guess_memory", "guestTheerr", "guest_man", "guest_dim", "guested_reg"], "end_time": ["endjTime", "endptclock", "endjtime", "end_sec", "ending_runtime", "endpttx", "endingclock", "endxtime", "end_tim", "endjtimes", " end_date", "endingtime", "end8tx", "endingingruntime", " end_sec", "endxsec", "end8runtime", "endptruntime", " end_tim", "endpttime", "endjtim", "endxTime", "ending_tx", "endingingtime", "ending_time", "end_times", "endingtx", "end_Time", " end_Time", "endingruntime", "end_clock", "end8time", "end_tx", "end8clock", "end_runtime", "ending_clock", " end_times", "endingingclock", "endxdate", "endingingtx", "end_date"], "i": ["ami", "x", "json", " ii", "ind", "ix", "iu", "bi", "remote", "print", "history", "index", "to", "li", "\u0438", "io", "batch", "ti", "series", "h", "gi", "ic", "name", "ei", "I", "phi", "ik", "ie", "info", "set", "q", "it", "mi", "ij", "status", "ki", "me", "ims", "ui", "init", "uri", "id", "xi", "sim", "ex", "multi", "o", "is", "y", "ini", "ia", "ci", "chain", "pi", "e", "us", "self", "di", "list", "v", "ri", "ai", "ii", "ji", "n", "in", "hi", "si", "m", "zi", "ip", "iri", "point", "im"], "j": ["att", "p", "aj", "x", "oj", "on", "ev", "jj", "jc", "v", "f", "job", "json", "jump", "jit", "z", "ng", "by", "ind", "jack", "l", "bj", "fr", "ji", "ju", "ix", "key", "n", "obj", "o", "ja", "b", "kj", "yy", "index", "kh", "jo", "ch", "y", "q", "js", "adj", "J", "br", "m", "c", "it", "jl", "ij", "dj", "uj", "bo", "k", "jas", "jp"], "size": ["mem", "huge", "type", "sp", "number", "data", "z", "format", "name", "height", "capacity", "code", "small", "new", "large", "space", "n", "total", "count", "south", "area", "zone", "use", "g", "si", "Size", "scale", "s", "cache", "dim", "shape", "empty", "set", "grow", "max", "now", "ia", "ize", "c", "m", "body", "buffer", "sum", "base", "message", "gc", "SIZE", "address", "length", "storage"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n\n                               uint32_t *byte_len)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n", "idx": 11978, "substitutes": {"rdma": ["rodma", "rdMA", "erdmm", "rdmeta", "rhmar", "irdms", "redmeta", "rrm", "redme", "erdMA", "rdmad", "irdma", "rodpo", "rhda", "redmad", "rdme", "redma", "irdmb", "rdmb", "rdman", "drman", "erdmar", "ldla", "redms", "drmad", "drmar", "drpo", "ldman", "erdla", "rrma", "drme", "rdmar", "rodmar", "redm", "rhm", "rdda", "redmb", "ldMA", "rhman", "irdmad", "rdmm", "ldmm", "rhma", "ldma", "rodmm", "redmm", "drmb", "rodda", "rdms", "rodmeta", "drMA", "redMA", "redmar", "drms", "redla", "drda", "rdla", "erdma", "drma", "ldme", "rdpo", "rrmar", "rhpo", "redman", "erdmeta", "rrman", "rdm"], "wr_id_out": ["wr_id_Out", "wr_info_in", "wr_info_Out", "wr_id_str", "wr_id_output", "wr_id_in", "wr_info_output", "wr_info_out"], "byte_len": ["byte_size", "Byte_Len", "Byte_size", "Byte_length", "Byte_len", "byte_Len", "byte_length"], "ret": ["x", "no", "flag", "err", "failed", "gt", "Ret", "total", "def", "arr", "ref", "tf", "reg", "t", "backed", "len", "ll", "ter", "red", "sat", "git", "cont", "code", "after", "rt", "set", "txt", "status", "res", "fail", "Return", "pret", "final", "fun", "imp", " Ret", " RET", "deg", "reply", "rem", "out", "nt", "iter", "tif", "mt", "try", "tr", "elt", "inter", "RET", "ft", "re", "j", "usr", "tn", "val", "rets", "td", "net", "back", "bad", " fut", "ext", "lit", "reset", "num", "cert", "resp", "alt", "lib", "zero"], "wc": ["kwc", " wce", "wordcc", "rwcm", "kwcm", "rwce", "rwvc", "wcs", "wece", "privc", "wrcs", "evct", "rww", "wcan", "wct", "wav", "wce", "wecs", "wacm", "wvc", "wdg", "wev", "rwg", " wcs", "wec", "wcu", " wcan", "wdcs", "wordv", "wtcan", "wcc", "rwv", "wtco", "wac", " wcc", "ww", "rwc", "wtcs", "privcu", "kwcs", "privcs", "wact", "wtcu", "wdc", "wy", "privco", "wordcs", " wv", "wco", " wco", "wrc", "wtc", "wordc", "wdy", "wrco", "wv", "wcm", "wg", "rwci", "rwy", "evc", "rwct", "wrcan", "wci", "rwcs", "wdw", "wry", " ww", "kwci", "wacs", "wacc", "evcs", "wrg", "evvc", "waci", "wavc", " wcu"], "wr_id": ["wr_link", "rw_id", " wr_type", "wa_bit", "rwOid", "wroghash", "wr_Id", " wr_k", " wr_info", "wm_info", "wrOsource", " wrnamecode", "wrOid", "wa_i", "pr_info", " wr_name", "wr_info", " wrnameid", "write_id", "wa_id", "wr_k", "wrOflag", "write_name", "wr___link", "wrOtype", "wr_flag", "rwOip", "pr_id", "wr_ip", "wroginfo", "rw_flag", "wrogid", "pr_ID", "wr_url", "wr_name", "wrnamek", "wr_orig", "wrThek", "wrnamecode", "wrOsid", "wr_ID", "wm_in", "pr_addr", "wr_kid", " wrnameide", "wt_url", "wr_bit", "wr___flag", "wrnameide", "wrTheide", "rw_ip", "wa_Id", "pr_pid", "wr_pid", "wr_ids", "wt_kid", "wr_code", "wr___in", "wr_ide", "wr___id", "rwOflag", "wr___number", "wr_in", "wr_hash", "write_type", "wrogsid", "wt_id", "pr_ids", "rw_link", "write_info", "wr_number", "wm_number", "write_sid", "wrThecode", "wr_addr", "write_source", " wr_code", " wrnamek", "wr_sid", "wr___ip", "wm_id", "wrOip", "wrTheid", "wr___info", " wr_ide", "rwOlink", "write_hash", "wt_Id", "wrnameid", "wr_source", "wr_i", "wrOlink", "wr_type", "pr_orig"], "block": ["mm", "sync", "Block", "off", "mem", "unit", "type", "link", "number", "data", "name", "entry", "group", "map", "start", "window", "lock", "key", "record", "line", "piece", "pool", "event", "join", "blocks", "work", "OCK", "tx", "bit", "local", "ref", "bus", "task", "box", "open", "byte", "part", "chain", "buffer", "batch", "row", "point", "word", "item", "error"], "nb_sent": ["nbbytesreceived", "nb_received", "nbbytessent", "nb_send", "num_Sent", "nb_Sent", "nbbytessend", "num_send", "num_sent", "nbbytesSent", "num_received"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    uint32_t minor_ver;\n\n    int comp_brand_size;\n\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n\n    char* comp_brands_str;\n\n    uint8_t type[5] = {0};\n\n\n\n    avio_read(pb, type, 4);\n\n    if (strcmp(type, \"qt  \"))\n\n        c->isom = 1;\n\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n\n    minor_ver = avio_rb32(pb); /* minor version */\n\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%\"PRIu32\"\", minor_ver);\n\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n\n\n    comp_brand_size = atom.size - 8;\n\n    if (comp_brand_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n\n    if (!comp_brands_str)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, comp_brands_str, comp_brand_size);\n\n    comp_brands_str[comp_brand_size] = 0;\n\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n\n    av_freep(&comp_brands_str);\n\n\n\n    return 0;\n\n}\n", "idx": 11979, "substitutes": {"c": ["p", "dc", "cb", "coll", "co", "cr", "h", "conf", "C", "tc", "cf", "f", "v", "cm", "k", "cam", "fc", "abc", "bc", "nc", "ct", "l", "cl", "lc", "cu", "cc", "rc", "n", "cv", "cp", "a", "enc", "b", "g", "cache", "ec", "etc", "ctx", "ce", "ci", "m", "mc", "t", "anc", "con", "can", "xc", "cs", "pc", "e", "gc", "vc", "ac"], "pb": ["p", "cb", "sb", "ab", "np", "wp", "tc", "proc", "lp", "px", "pp", "typ", "sp", "tp", "fc", "pg", "bp", "bc", "ob", "pt", "bj", "uf", "tk", "erb", "apy", "bb", "ub", "fb", "pel", "buf", "cp", "PB", "pool", "xb", "b", "pa", "mb", "tab", "phys", "pan", "fp", "ctx", "tf", "pm", "phy", "wb", "mp", "rb", "ap", "pkg", "asm", "ping", "pc", "vp", "bs", "jp"], "atom": ["ator", "p", "al", "or", "x", "tem", "mol", "month", "um", "orb", "atomic", "from", "ata", "typ", "om", "mate", "data", "op", "tar", "tm", " orb", "org", "raw", " com", "at", "component", "o", "item", "sym", "b", "orm", "app", "com", "term", "y", "node", " exc", "ym", " err", "m", "prop", " form", "base", " component", "state", "omp", "element", "msg"], "minor_ver": ["minore_ever", "minor_vert", "minor2ver", "miner_ver", "miner_Ver", "minornetcur", "miner_vers", "minore_ver", "minornetver", "minornetdec", "minor_ever", "minor2dec", "minor__Ver", "minOR_dec", "minor_Ver", "minor_dec", "minOR2dec", "minor2cur", "minOR_ver", "minOR2ver", "miner_ser", "minor_v", "minore_vert", "minor__ser", "minor__vers", "minor_vers", "minOR2cur", "minor_cur", "minor_ser", "minore_v", "minornetVer", "minOR_cur", "minOR_Ver", "minor__ver", "minOR2Ver", "minor2Ver"], "comp_brand_size": ["comp_font_count", "comp_cost_count", "comp_family_Size", "comp_family_len", "comp_cost_size", "comp_font_size", "comp_brand_SIZE", "comp_label_index", "comp_font_SIZE", "comp_brand_name", "comp_label_size", "comp_branditySIZE", "comp_branditysize", "comp_brand_len", "comp_font_name", "comp_costitysize", "comp_cost_SIZE", "comp_family_index", "comp_costitycount", "comp_label_count", "comp_costitySIZE", "comp_family_size", "comp_branditycity", "comp_brand_count", "comp_branditycount", "comp_brand_index", "comp_cost_city", "comp_brand_Size", "comp_brand_city", "comp_label_Size", "comp_costitycity"], "minor_ver_str": ["minor_Ver_STR", "minor_version_dr", "minor_Ver_br", "minor_ver_name", "minor_Ver_arr", "minor_ser_arr", "minor_ver2fr", "minor_ver2Str", "minor_ver2STR", "minor_ver_STR", "minor_ver_Str", "minor_version_Str", "minor_ver_arr", "minor_ver_fr", "minor_ver2br", "minor_ser_Str", "minor_Ver_str", "minor_Ver_Str", "minor_ver_dr", "minor_ver2name", "minor_ver2str", "minor_version_str", "minor_ser_fr", "minor_ver2arr", "minor_version_br", "minor_ser_str", "minor_ver_br", "minor_Ver_name"], "comp_brands_str": ["comp_brands_br", "comp_brards_br", "comp_brands2data", "comp_brages_br", "comp_brands_dr", "comp_brances_list", "comp_brels_Str", "comp_brels2ptr", "comp_brads_string", "comp_brands2str", "comp_brands2arr", "comp_brels_br", "comp_brards_arr", "comp_brances_arr", "comp_brags_str", "comp_brands_string", "comp_brands_fr", "comp_brages_Str", "comp_brands2Str", "comp_brands2ptr", "comp_brels_str", "comp_brands2list", "comp_brels_arr", "comp_brags_dr", "comp_brads_arr", "comp_brances_str", "comp_brands_list", "comp_brages_data", "comp_brands_data", "comp_brels2string", "comp_brards_string", "comp_brels2Str", "comp_brands_Str", "comp_brages_str", "comp_brels_ptr", "comp_brels2str", "comp_brags_string", "comp_brances_data", "comp_brags_arr", "comp_brands2string", "comp_brands_arr", "comp_brads_fr", "comp_brads_str", "comp_brands_ptr", "comp_brels_string", "comp_brards_str"], "type": ["p", "where", "types", "ype", "ror", "value", "unit", "tag", "rule", "typ", "test", "id", "pack", "data", "format", "pe", "tp", " Type", "name", " ty", "ver", "ty", "ico", "key", "all", "null", "size", "time", "file", "index", " TYPE", "TYPE", "field", "what", "shape", "Type", "info", "y", "desc", "style", "header", "kind", "check", "t", "buffer", "status", "block", "ping", "message", "class", "state", "sort", "error"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980, "substitutes": {"bus": [" Bus", "controller", "dev", "uses", " buses", "proc", " device", "ck", "usb", "boot", "lock", "device", "config", "buf", " BUS", "handle", " board", "board", "mount", "driver", "box", "Bus", "chain", "book", "block", "BUS", "used", "us"], "devfn": ["evnm", " devlen", " devfunction", "devfunction", "evfn", "evlen", "devicefunction", "devicefn", "devnm", " devnm", "devlen", " devicefunction", " devicenm", " devicefn", "devicelen", "devicenm"], "offset": ["util", "off", "slot", "type", "offer", "addr", "id", "oid", "location", "seed", "padding", "start", "window", "position", "shift", "out", "origin", "initial", "o", "size", "prefix", "index", "info", "attribute", "set", "ref", "trace", "Offset", "alias", "pos", "block", "loc", "point", "before", " offsets", "address", "length", "zero", "error"], "value": ["ue", "comment", "vector", "unit", "type", "v", "number", "data", "output", "version", "function", "name", "command", "result", "code", "VALUE", "val", "key", "range", "Value", "size", "property", "values", "index", "term", "attribute", "sequence", "power", "text", "volume", "buffer", "current", "description", "message", "word", "address"]}}
{"project": "FFmpeg", "commit_id": "073811cdd29e365498b3455ee4e0eda4b957a957", "target": 0, "func": "static int decode_stream_header(NUTContext *nut){\n\n    AVFormatContext *s= nut->avf;\n\n    ByteIOContext *bc = &s->pb;\n\n    StreamContext *stc;\n\n    int class, stream_id;\n\n    uint64_t tmp, end;\n\n    AVStream *st;\n\n\n\n    end= get_packetheader(nut, bc, 1);\n\n    end += url_ftell(bc);\n\n\n\n    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);\n\n    stc= &nut->stream[stream_id];\n\n\n\n    st = s->streams[stream_id];\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    class = get_v(bc);\n\n    tmp = get_fourcc(bc);\n\n    st->codec->codec_tag= tmp;\n\n    switch(class)\n\n    {\n\n        case 0:\n\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n            st->codec->codec_id = codec_get_id(codec_bmp_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 1:\n\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            st->codec->codec_id = codec_get_id(codec_wav_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 2:\n\n//            st->codec->codec_type = CODEC_TYPE_TEXT;\n\n//            break;\n\n        case 3:\n\n            st->codec->codec_type = CODEC_TYPE_DATA;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown stream class (%d)\\n\", class);\n\n            return -1;\n\n    }\n\n    GET_V(stc->time_base_id    , tmp < nut->time_base_count);\n\n    GET_V(stc->msb_pts_shift   , tmp < 16);\n\n    stc->max_pts_distance= get_v(bc);\n\n    GET_V(stc->decode_delay    , tmp < 1000); //sanity limit, raise this if moors law is true\n\n    st->codec->has_b_frames= stc->decode_delay;\n\n    get_v(bc); //stream flags\n\n\n\n    GET_V(st->codec->extradata_size, tmp < (1<<30));\n\n    if(st->codec->extradata_size){\n\n        st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        get_buffer(bc, st->codec->extradata, st->codec->extradata_size);\n\n    }\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_VIDEO){\n\n        GET_V(st->codec->width , tmp > 0)\n\n        GET_V(st->codec->height, tmp > 0)\n\n        st->codec->sample_aspect_ratio.num= get_v(bc);\n\n        st->codec->sample_aspect_ratio.den= get_v(bc);\n\n        if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){\n\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio\\n\");\n\n            return -1;\n\n        }\n\n        get_v(bc); /* csp type */\n\n    }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){\n\n        GET_V(st->codec->sample_rate , tmp > 0)\n\n        tmp= get_v(bc); // samplerate_den\n\n        if(tmp > st->codec->sample_rate){\n\n            av_log(s, AV_LOG_ERROR, \"bleh, libnut muxed this ;)\\n\");\n\n            st->codec->sample_rate= tmp;\n\n        }\n\n        GET_V(st->codec->channels, tmp > 0)\n\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n\n        av_log(s, AV_LOG_ERROR, \"Stream header %d checksum mismatch\\n\", stream_id);\n\n        return -1;\n\n    }\n\n    stc->time_base= &nut->time_base[stc->time_base_id];\n\n    av_set_pts_info(s->streams[stream_id], 63, stc->time_base->num, stc->time_base->den);\n\n    return 0;\n\n}\n", "idx": 11983, "substitutes": {"nut": ["art", "ot", "snap", "nova", "nas", "np", "wp", "cmd", "sat", "aos", "nuts", "uts", "cont", "nat", "Nut", "ng", "orr", "torn", "ours", "nc", "pot", "ano", "ox", "na", "six", "sequ", "nir", "nr", "tn", "org", "our", "sts", "n", "piece", "nt", "config", "nm", "ne", "orn", "gob", "fn", "net", "sam", "etc", "ut", "nil", "node", "ctx", "hog", "hawk", "rn", "this", "nih", "cot", "stab", "roy", "nu", "nw", "hn", "got", "nv", "nov", "pieces", "ocr", "utt", "san", "nor", "rot", "mn", "cn", "ns"], "s": ["ts", "p", "h", "sb", "ats", "conf", "sw", "tools", "ses", "sat", "rs", "sa", "v", "ls", "i", "sp", "ss", "obs", "ps", "gs", "aws", "sts", "out", "n", "sq", "sm", "south", "fs", "sv", "sl", "src", "a", "g", "b", "is", "os", "sac", "sn", "set", "sg", "sys", "js", "stats", "ds", "c", "S", "t", "sc", "status", "cs", "bs", "w", "qs", "ns"], "bc": ["dc", "cb", "bf", "snap", "chron", "sb", "proc", "tc", "cf", "voc", "jc", "ck", "ic", "pb", "ng", "fc", "bp", "nc", "cl", "uc", "bb", "lc", "cn", "comm", "cc", "rc", "arc", "gro", "buf", "bt", "soc", "ec", "BC", "etc", "gb", "sys", "ctx", "mc", "c", "sc", "db", "rb", "ba", "oc", "bg", "xc", "gc", "pc", "bo", "vc", "cs", "bs"], "stc": [" stac", "stac", "ustl", " str", "ste", "ustfac", "stl", "ntc", "nte", "stcc", "stco", "ustt", "istt", "irstac", "thm", "strlc", "Stf", "utt", "thw", "strw", "esth", "stt", "ustcu", "istf", "stcu", "stdfac", "stdm", "latc", "thfac", "estl", "strfac", "lath", "sth", "strac", "stdc", "irstlc", "istm", "strc", "str", "stw", "ustc", "strcc", "Stc", "latl", "stlc", "estfac", "utcu", "stdco", " stdc", "usth", "strm", "irstcc", "irstc", "ntt", "ntco", " stt", "stfac", " ste", "stdw", "utm", " stco", " stlc", "stm", "istdc", "estc", "istr", "ustm", " stf", " stcc", "stf", "stde", "Str", "latfac", "istc", "stdt", "Stdc", "thc", "istcu", "utc"], "class": ["func", "instance", "lass", "tag", "type", "cap", "test", "id", "pe", "fc", "version", "name", "title", "ident", "capacity", "interface", "method", "cl", "code", " CLASS", "lc", "aud", "Class", "cc", "label", "count", "size", "cast", " Class", "event", "package", "cmp", "style", "kind", "module", "prop", "c", "part", "t", "sc", "status", "con", "spec", "CLASS", "ord", "state", "level", "classes", "mod", "lib"], "stream_id": ["stream____start", "stream____pid", "streamNameinfo", "Stream_id", "channel_index", "mount_oid", "mount_hash", "stream_source", "streameroid", "mountIDsource", "stream_pid", "mountIDid", "streamIDhash", "Stream_ids", "streamerhash", "channel_info", "channel_id", "stream_no", "stream_oid", "channel_no", "stream_ids", "mountIDoid", "stream____no", "streamNameid", "Stream_info", "stream_start", "stream_index", "streamNameno", "mount_id", "streamersource", "streamerid", "mountIDhash", "streamNameindex", "stream_info", "streamIDoid", "channel_pid", "streamIDsource", "channel_start", "mount_source", "stream_hash", "stream____id", "streamIDid"], "tmp": ["snap", "qq", "np", "metadata", "tc", "tag", "sample", " np", "zip", " tv", "buf", "cp", "total", "buff", "cache", "sam", "crop", "tf", "t", "rb", "up", "pkg", "jp", "amp", "attr", "cont", "test", "addr", "params", "tm", "meta", "tt", "obj", "temp", "src", "emp", "mb", "tim", "mk", "etc", "desc", "ffff", "rt", "max", "txt", "top", "orig", "appy", "p", "final", "perm", "sp", "pb", "trap", "nt", "size", "prefix", " mp", "tv", "cmp", "elt", "node", "ctx", "prop", "cb", "timeout", "proc", "nb", "tar", "tp", "tn", "cv", "td", "net", "png", "ext", "offset", "uv", "mp", "pos", "resp", "img"], "end": ["limit", "send", "ent", "ending", "nd", "END", "np", "ff", "v", "head", "id", "add", "pend", "start", "stop", "obj", "size", "begin", "bound", "post", "ended", "End", "rest", "ext", "ut", "set", "max", "offset", "last", "fin", "append", "pos", "len", "ad", "dest", "alt", "e", "ord", "and", "length"], "st": ["art", "step", "ot", "sta", "nd", "sw", "ft", "sat", "std", "cont", "sp", "ast", "ss", "stat", "ste", "stan", "sh", "add", "pt", "ST", "ct", "str", "tt", "stop", "ust", "start", "irst", "usr", "sts", "th", "stack", "tra", "out", "must", "nt", "obj", "store", "sv", "src", "St", "ost", "sl", "inst", "td", "mt", "net", "rest", "ut", "sn", "rt", "set", "wt", "so", "t", "et", "sc", "stable", "est", "ist", "mont", "se", "storage"]}}
{"project": "FFmpeg", "commit_id": "5127f465bd3e2cf9cbf66dea3cf7b481b522d266", "target": 1, "func": "static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *s;\n\n    unsigned char *d;\n\n    unsigned char *d_end;\n\n    unsigned char queue[QUEUE_SIZE];\n\n    unsigned int qpos;\n\n    unsigned int dataleft;\n\n    unsigned int chainofs;\n\n    unsigned int chainlen;\n\n    unsigned int speclen;\n\n    unsigned char tag;\n\n    unsigned int i, j;\n\n\n\n    s = src;\n\n    d = dest;\n\n    d_end = d + dest_len;\n\n    dataleft = AV_RL32(s);\n\n    s += 4;\n\n    memset(queue, 0x20, QUEUE_SIZE);\n\n    if (AV_RL32(s) == 0x56781234) {\n\n        s += 4;\n\n        qpos = 0x111;\n\n        speclen = 0xF + 3;\n\n    } else {\n\n        qpos = 0xFEE;\n\n        speclen = 100;  /* no speclen */\n\n    }\n\n\n\n    while (dataleft > 0) {\n\n        tag = *s++;\n\n        if ((tag == 0xFF) && (dataleft > 8)) {\n\n            if (d + 8 > d_end)\n\n                return;\n\n            for (i = 0; i < 8; i++) {\n\n                queue[qpos++] = *d++ = *s++;\n\n                qpos &= QUEUE_MASK;\n\n            }\n\n            dataleft -= 8;\n\n        } else {\n\n            for (i = 0; i < 8; i++) {\n\n                if (dataleft == 0)\n\n                    break;\n\n                if (tag & 0x01) {\n\n                    if (d + 1 > d_end)\n\n                        return;\n\n                    queue[qpos++] = *d++ = *s++;\n\n                    qpos &= QUEUE_MASK;\n\n                    dataleft--;\n\n                } else {\n\n                    chainofs = *s++;\n\n                    chainofs |= ((*s & 0xF0) << 4);\n\n                    chainlen = (*s++ & 0x0F) + 3;\n\n                    if (chainlen == speclen)\n\n                        chainlen = *s++ + 0xF + 3;\n\n                    if (d + chainlen > d_end)\n\n                        return;\n\n                    for (j = 0; j < chainlen; j++) {\n\n                        *d = queue[chainofs++ & QUEUE_MASK];\n\n                        queue[qpos++] = *d++;\n\n                        qpos &= QUEUE_MASK;\n\n                    }\n\n                    dataleft -= chainlen;\n\n                }\n\n                tag >>= 1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11985, "substitutes": {"src": ["r", "x", "sb", "bin", "rs", "sur", "addr", "cur", "trans", "usr", "rc", "sr", "out", "in", "rl", "tmp", "b", "st", "ur", "rest", "copy", "iv", "sys", "c", "txt", "sc", "source", "loc", "rb", "star", "sub", "bs", "img", "rel", "ins"], "dest": ["r", "done", "p", "dc", "dist", "red", "cat", "master", "v", "Dest", "test", "id", "end", "trans", "result", "good", "out", "origin", "temp", "tmp", "st", "rest", "partial", "to", "desc", "home", "target", "gate", "slave", "source", "loc", "decl", "table", "way", "w", "del"], "dest_len": ["orig_len", "del___len", "dest__len", "del_length", "dest___length", "dest___l", "dest_pos", "orig_length", "del_lon", "dest__pos", "dest__l", "dest___len", "dest__loc", "del___l", "del_l", "dest_l", "del_len", "dest_loc", "orig_pos", "del___lon", "dest_length", "del___length", "orig_loc", "dest__length", "dest__lon", "dest_lon", "dest___lon"], "s": ["x", "sb", "ls", "xs", "des", "sv", "as", "index", "has", "js", "sys", "c", "t", "source", "series", "ms", "w", "ns", "ins", "less", "h", "ats", "ps", "sq", "a", "fs", "q", "stats", "ds", "comments", "sc", "status", "cs", "tes", "ims", "p", "span", "ar", "sp", "its", "str", "start", "ops", "b", "g", "is", "st", "os", "hs", "spec", "e", "us", "r", "ts", "self", "units", "rs", "f", "args", "ss", "es", "z", "gs", "sts", "n", "m", "S", "bits", "single", "bs", "qs"], "d": ["r", "di", "p", "done", "dc", "ld", "dist", "dev", "dr", "dx", "red", "bd", "D", "dq", "f", "v", "du", "de", "dd", "id", "dm", "dom", "z", "gd", "dp", "end", "l", "dict", "result", "new", "dt", "dig", "debug", "dos", "out", "n", "des", "da", "pd", "o", "diff", "b", "did", "dir", "g", "td", "dh", "dim", "fd", "dat", "def", "sd", "dra", "q", "dn", "ds", "m", "c", "t", "ad", "db", "e", "w", "del"], "d_end": ["D_pos", " d_len", "d__start", "dxbegin", "D_len", "dxstart", "d_pos", "d_start", "d_en", "D_start", "d_len", "d__ender", " d_begin", "dec_ender", "d_ender", " d_END", "dxEND", "dec_end", "dh_END", " d_en", "dxlen", "dxend", "dh_close", "d__end", "d_begin", "d_END", "dec_start", "dec_en", "d_close", "dh_ender", " d_range", " d_start", "D_end", "d__len", "dxen", "d__en", "dxrange", "dh_end", "d_range", "d__pos"], "queue": ["limit", "sync", "require", "list", "Q", "library", "ue", "ques", "flag", "dq", "master", "job", "next", "data", "jobs", "entry", "result", "layer", "qv", "worker", "stack", "all", "database", "channel", "array", "process", "archive", "line", "available", "config", "buf", "store", "complete", "pool", "server", "journal", "prefix", "menu", "history", "cache", "required", "Queue", "que", "q", "force", "sequence", "priority", "manager", "console", "buffer", "tube", "status", "base", "block", "quality", "batch", "message", "context", "client", "msg"], "qpos": ["qPOS", "iqPOS", "qupos", "xpo", "qPos", "quPOS", " qPos", "qtpos", " qblock", "dqpo", "qualPOS", "qloc", "qualpo", "dqPos", "qpo", "qualpos", "tPos", "qposition", "qupo", "querypoint", "queryloc", "eqpos", "qpoint", "qualpoint", "qprop", "xpos", "qtpo", "iqpo", " qPOS", "iqposition", "qcache", "querypo", "eqprop", "queryposition", "tpo", "queryblock", "tposition", " qloc", " qpo", "iqpoint", "qublock", "qualposition", "eqpo", "qtpoint", " qcache", "qtposition", "querypos", "ixpos", "dqpos", " qposition", "queryPOS", "tpos", "qblock", "ixposition", "dqprop", "xpoint", "ixpo", " qprop", "eqPos", "quloc", "iqcache", "qucache", "xposition", "dqpoint", "dqposition", "ixPos", "quposition", "iqpos"], "dataleft": ["dataleykt", "dataseff", "datasept", "dataalept", "dataleld", "datalesxt", "datalff", " dat8", "catalsefter", "dataaseff", "dataleyfts", "datalseaft", "dataleaft", " dataleykt", "dataaleft", " dataleyft", "datealft", "dataseffer", "datalseffer", "datanefter", " dataseffer", "dataleff", "datalft", "cataleaft", "catalsexp", " dataleyxt", "datealaft", "datealffer", "datealkt", "dt_", " datasefter", "cataleft", "datasexp", "catalseft", "datapleff", "date_", "dataleffer", "datalespt", "dataaseft", "datalesff", " dataseff", "dataseaft", "datalesfter", "dataneaft", " dataseaft", "datapleft", "dataleyld", "dataleyaft", "datasefter", "catalefter", "datalept", "dataaleaft", "dataseft", "dataleyff", "datalext", "dataleyxt", "datalexp", " datalexp", "catalexp", " dataleyff", "Dataleyff", "Dataleyxt", "dataleskt", "dataaseaft", " dataleaft", "dataasept", "dataplefts", "datalsext", "datalesft", "dataneft", " datasexp", "Dataleld", "datalpt", " datalext", "datalefts", "Dataleyld", " dataleff", "datealxp", "Dataleft", " datalefter", "Datalext", " dataleypt", "datalesxp", "datALEft", "datalsexp", "dataleypt", "datalseft", "datalekt", " datalefts", "datalaft", " dat_", " dataseft", "dataplept", "datanexp", "dataleyfter", "datalefter", "dataleyft", "dataaleff", "datALExt", "Dataleff", "datalsept", "Dataleyft", " dataleffer", " dataleyfts", "dt8", "dat_", "dat8", "datasext", " datalekt", "datALEld", "datalseff", " datalept", " dataleyaft", "dataseld", "datALEff", "datalsefter", "catalseaft", " datasext", "datealxt", "datalesaft", "datalsefts", "date8"], "chainofs": ["chainofsw", "chainlengthsi", "baseOFs", "chaineffg", "blockOFsid", "chainOfs", "chainOFsw", "baseofis", "chainOFsi", "chainofsid", "blockOFs", "ChainOfss", "chainoffe", "chainfontS", "chainoffg", "Chainofss", "chainOFss", "ChainOfs", "blockOFS", "chainofi", "blockofe", "chainfonti", "chainofsb", "chainOFs", "blockOFe", "chainOFsb", "chainOfi", "chainOfsid", "chainlengths", "chainlengthis", "chainofS", "blockOFg", "chaineffs", "chainOFi", "chaineffe", "Chainofsid", "chaineffsid", "Chainofs", "ChainOfsw", "chainOfss", "chainofg", "blockOFi", "blockofi", "chainlengthsid", "blockofg", "chainfontsb", "chainoffs", "baseOFsi", "chainofsi", "Chainofsw", "chainOFsid", "chainofis", "blockOFsb", "chainfontsw", "chainfontsid", "blockofs", "blockofsid", "chainfonts", "chainOFg", "baseOFsid", "chainofss", "chainoffsid", "baseofs", "chainfontss", "ChainOfsid", "blockofsb", "blockofS", "baseofsi", "baseOFis", "chainOFe", "chainofe", "chainoffsi", "chainOFS", "chainOfS", "chainoffis", "baseofsid", "chainOfsb", "chainOFis", "chainOfsw"], "chainlen": ["stacklon", "chainln", "chainlan", "repeatlan", "blocklength", "rangeerr", "rowen", "blocklen", "grouperr", "cachelen", "grouplen", "repeatlen", "chaincoll", "rangelength", "rowlen", " chainLen", "chainll", "rowcoll", "Chainlen", " chainlan", "cachell", "chainlon", " chaincoll", "grouplan", "Chainref", "stackln", " chainln", " chainerr", "repeatlon", " chainll", "chainLen", "checken", "checkLen", "chainen", " chainlength", "chainerr", "stacklan", "repeatln", "Chainln", "Chainen", "rowll", "rangelen", "Chainlength", "ChainLen", "stacklen", " chainen", "checklen", "checkln", "cachecoll", " chainref", "cachelon", "cachelan", "grouplength", "cacheen", "rangelan", "blockref", "chainref", "cacheln", "chainlength", "blockLen"], "speclen": ["speclew", "speccend", "specken", "speflon", "Speclon", "Speccength", "specledength", "specledew", "speccew", "pepllen", "speCLen", "speflength", "Speclen", "specluseng", "peccength", "speplenum", "specelen", "speccog", "speckenum", "speclusength", "Speclew", "speclon", "speCLength", "speclend", "Speclog", "speccon", "Speclength", "peccen", "speclusend", "pecceng", "specceng", "Speclens", "specklen", "specledens", "speCLenum", "speplength", "speclength", "pecllen", "speckog", "specleng", "speclog", "speflen", "Speccew", "Speccen", "Speccens", "Speccon", "speflog", "speccength", "speckon", "peccend", "peclength", "speccens", "speflew", "peplen", "speCLlen", "peplength", "pecleng", "speclusen", "peclenum", "spepllen", "peplenum", "peclend", "Speccog", "speccen", "specelend", "specleden", "peclen", "speflens", "speceleng", "speclenum", "specllen", "specelength", "speclens", "speplen", "speckength"], "tag": ["flag", "tc", "comment", "cat", "type", "attr", "link", "brand", "test", "id", "pack", "stat", "format", "tar", "version", "name", "tt", "tags", "date", "key", "bug", "feat", "te", "match", "field", "var", "TAG", "bit", "hash", "token", "Tag", "style", "reg", "task", "kind", "tg", "go", "tail", "t", "set", "mode", "word", "color", "magic", "ag", "mod", "cmd"], "i": ["r", "di", "p", "ui", "cli", "h", "init", "v", "gi", "ic", "ai", "id", "ind", "l", "ei", "ii", "str", "xi", "sim", "I", "phi", "ix", "iu", "oi", "multi", "out", "bi", "n", "me", "iter", "b", "ie", "g", "hi", "si", "index", "li", "info", "y", "ini", "it", "\u0438", "m", "ci", "c", "io", "t", "zi", "mi", "ij", "ip", "qi", "ti", "status", "im", "pi", "e", "ki", "k", "us"], "j": ["att", "p", "art", "aj", "x", "pr", "no", "oj", "jj", "json", "v", "job", "f", "jump", "jit", "z", "ind", "l", "pt", "bj", "fr", "ji", "sim", "at", "bi", "n", "o", "obj", "ja", "b", "kj", "ie", "index", "ch", "jo", "try", "li", "y", "q", "js", "it", "J", "m", "c", "br", "t", "pos", "jl", "ij", "dj", "uj", "k", "jas", "jp"]}}
{"project": "qemu", "commit_id": "3daa41078aedf227ec98b0d1c9d56b77b6d20153", "target": 1, "func": "void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}", "idx": 11988, "substitutes": {"req": ["r", "ack", "require", "cb", "inv", "qq", "seq", "dq", "coord", "request", "rr", "err", "addr", "subject", "exec", "job", "ind", "compl", "rec", "needed", "ps", "call", "crit", "fr", "query", "usr", "deg", "good", "comm", "org", "rem", "pub", "qt", "progress", "rel", "wx", "sq", "obj", "tek", "md", "need", "prefix", "forced", "rest", "required", "ext", "urg", "tx", "desc", "cmp", "q", "gr", "js", "task", "reg", "quest", "ctx", "txt", "requ", "res", "decl", "resp", "pkg", "wcs", "aux", "ctr", "comp", "low", "jp", "cmd"]}}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 11998, "substitutes": {"s": ["r", "ts", "p", "sb", "ses", "rs", "i", "v", "ls", "ss", "es", "z", "ps", "gs", "aws", "comm", "sts", "n", "sq", "fs", "a", "is", "as", "g", "d", "b", "ms", "os", "sd", "sn", "sg", "js", "stats", "ds", "m", "c", "S", "t", "cs", "bs", "qs", "ns"], "pc": ["ts", "p", "pic", "amp", "proc", "tc", "rs", "px", "pp", "pb", "fc", "bc", " PC", "pt", "nc", " rc", " RPC", "cc", "rc", "arc", "enc", "td", "pa", "sec", "ec", "asc", "PC", " dc", "mc", "c", "sc", " proc", "cs", "gc", "vc", "ptr", "ms", "ac"], "tmp": ["appy", "p", "util", " result", "cb", "snap", " tcp", "np", "v", "ret", "perm", "test", "nb", "sp", " temp", "pb", " t", " sp", "uf", "tt", "map", "lambda", "tn", " out", " np", " ptr", "zip", " cached", "cv", "obj", "cp", "temp", " unused", "buf", "vt", "buff", "emp", " ts", " mp", "mb", "mk", "mint", "etc", " td", " pp", "cmp", "Temp", " mt", " MP", "rt", "tf", "ctx", " p", "m", "mp", " resp", "t", "txt", "MP", "buffer", "resp", " proc", "prime", "pkg", "ptr", "comp", "img", "jp"]}}
{"project": "qemu", "commit_id": "8dfd5f96515ca20c4eb109cb0ee28e2bb32fc505", "target": 0, "func": "static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n\n                                            uint16_t code, const char *reason)\n\n{\n\n    struct iovec iov;\n\n    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n\n    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =\n\n        cpu_to_be16(code);\n\n    ioc->rawoutput.offset += 2;\n\n    if (reason) {\n\n        buffer_append(&ioc->rawoutput, reason, strlen(reason));\n\n    }\n\n    iov.iov_base = ioc->rawoutput.buffer;\n\n    iov.iov_len = ioc->rawoutput.offset;\n\n    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,\n\n                               &iov, 1, iov.iov_len);\n\n    buffer_reset(&ioc->rawoutput);\n\n    qio_channel_websock_write_wire(ioc, NULL);\n\n    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);\n\n}\n", "idx": 12023, "substitutes": {"ioc": ["xiocation", "hiocation", "uioci", "piocate", "liocy", "sioc", "iuog", "lioc", "diroc", "dioco", "iiroc", "ioco", "piroc", "iog", "Ioci", "Ioc", "cioc", "giog", "ciOC", " iocr", "iiocy", "ioca", "iocal", "piog", "miosc", "hioc", "iOC", "pioco", "ioad", " ioci", "inioc", "miog", "clioc", "iroc", "miocon", "liocate", "liocation", "iuoc", " iog", "piOC", "dioci", "xiocate", "cliOC", "xiog", "lioci", "Iroc", "liov", "mioad", "uiok", " iocate", "liog", "iocy", "pioad", "biocate", "pioc", "inioci", "ciocal", " iocation", "iocr", "liroc", "iocon", "liocal", "piocation", "diOC", "mioca", "mioc", "IOC", "pioci", "siosc", "iniOC", "ioint", "inioad", "iuoca", "giroc", "giocon", "gioc", "iuocr", "hiocate", "Iocy", "uiict", "cioci", " ioad", " iocon", "siocon", "biog", " iocal", "dioc", "lioint", "ciict", " iroc", "cioint", "iict", "piocon", "clioci", "iioc", "clioad", "hioci", "iocation", "iok", "iosc", "diocy", " iocy", " iOC", "ciok", "iiOC", " ioint", "miocr", "Iict", "sioad", "uioc", "iocate", "liOC", " ioco", " ioca", "biov", "piosc", "ioci", "xioc", "bioc", "Iok"], "code": ["scene", "ode", " cause", " change", " program", " create", "value", " message", "type", " sequence", " event", " scheme", "coe", "frame", " chunk", "data", " decode", " chip", " status", " challenge", "command", "call", " count", "error", " frame", "close", " coded", "create", "change", " body", "size", "time", "count", " state", " error", "second", "age", " text", "Code", "ce", "buffer", " mode", "status", " command", " cmd", " component", "mode", "message", " content", "length", " control"], "reason": ["report", "require", "because", "comment", "why", "condition", "lost", "value", "unit", "request", " why", "rule", "severe", "when", "connection", "re", "name", " whence", "command", "warn", "crit", "group", "cond", "original", "other", "component", "warning", "close", "asons", "change", "external", "broken", "ASON", "details", "unknown", "detail", " reasons", "desc", "none", "Reason", "note", "force", "zero", "negative", "cause", "chain", "critical", "intention", "roy", "status", "res", "block", "race", "description", "message", "before", "context", "template", "use", "ason", "msg", "error"], "iov": ["ovo", "av", "nom", "iol", "inv", "rov", "iii", "np", "imp", "von", "iour", "vector", "voc", "ech", "i", "ovi", "v", "ih", "iev", "vision", "vr", "iq", "ei", "gov", "iph", "iu", "ever", "kov", "liv", "rolet", "soc", "ibr", "iro", "kj", "chrom", "tv", "iw", "ichael", "iva", "rir", "iv", "mpeg", "verbs", "voice", "lov", "ux", "vec", "uv", " vib", "io", "vo", "isco", "meg", "ij", "ivic", "uj", "nov", "IV", "resp", "river", "idav", "iop", "vp", "lv", "Iv", "minecraft", "drm"]}}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)\n\n{\n\n    fadt->model = 1;\n\n    fadt->reserved1 = 0;\n\n    fadt->sci_int = cpu_to_le16(pm->sci_int);\n\n    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);\n\n    fadt->acpi_enable = pm->acpi_enable_cmd;\n\n    fadt->acpi_disable = pm->acpi_disable_cmd;\n\n    /* EVT, CNT, TMR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n", "idx": 12026, "substitutes": {"fadt": ["facht", "fraddt", "ffpadter", "freatdt", "efadtt", "ladt", "fwdx", "tfpadth", "fadst", "fachnot", "faudset", "fladter", "fadkt", "fpadt", "leadt", "foradwt", "fadout", "fpadta", "fwdto", "xeadt", "fadg", "faultvt", "fadta", "favekt", "fadeti", "fadets", "ifadtor", "ffpadtor", "ffadnot", "ifadt", "xeadg", "feadkt", "fadx", "faytar", "confpadnt", "fopadout", "yrakdt", "tfadset", "farttree", "confadtr", "confplaytr", "ufpadtree", "fachset", "yaddt", "flavelet", "fildto", "fadwt", "fopadh", "foadt", "frakto", "freatt", "ufpadto", "fachtr", "fpadth", "frakt", "confplayto", "fpadtar", "foradx", "fradt", "formradt", "foadout", "ufadt", "faudtr", "confadt", "fplaytd", "fAdT", "confadta", "fachto", "failh", "yadt", "efadset", "fayit", "fayt", "failt", "fadT", "xadt", "fradedt", "fadvt", "fplayt", "fadh", "faultto", "fadth", "fladlet", "fpadet", "fAdto", "fplaywt", "feadto", "fangnot", "foreadwt", "fadeot", "strrodt", "fangter", "efpadset", "tfpadts", "fpadset", "fadtor", "fwdtor", "feadwt", "ufadto", "fladkt", "faudkt", "ufpadh", "fwdt", "frodg", "formadtr", "fachts", "leadit", "ufadtree", "flpadet", "tfpadset", "fAdkt", "ffpadnot", "facedt", "fiberdt", "dfpadit", "feddt", "fadti", "fradett", "faudte", "ffadt", "flavets", "fibertt", "feadT", "fpadout", "farktar", "fadnt", "strrodx", "fadtr", "fwdts", "flpadt", "faidto", "fADit", "confplaytd", "stradx", "ladT", "ffadter", "dfadrt", "fadtar", "fedddet", "fadsnt", "feadtd", "fladte", "favets", "fADlet", "farkt", "fpadh", "feadot", "faidtt", "tfadts", "faidt", "fadelet", "fartt", "fopadt", "efpadit", "faddlet", "fpadto", "fauddet", "fpadtor", "frakdt", "ufpadt", "fleadg", "fAdt", "formadkt", "fpadrt", "fadtd", "formradtr", "fpadkt", "frakvt", "foadtr", "fAdtr", "faytd", "fleadt", "fpadts", "stradt", "fwdh", "flaveot", "yrakt", "foradt", "dfadtar", "fpadnt", "efadt", "dfadit", "fadts", "xadT", "fplayto", "leadlet", "confadnt", "favet", "fayrt", "faudt", "ifpaddet", "confpadto", "fadtt", "feddtor", "faultt", "ifpadtor", "frodtd", "fradkt", "fradti", "fayT", "faytt", "fpaddet", "fplaytr", "strrodtor", "feadg", "fadot", "fildtd", " fAdT", "tfadt", "fadit", "faudwt", "efadit", "fachth", "faultdt", "fradtr", "fankh", "foreadt", "fildt", " fAdt", "fradet", "xeadtd", "favelet", "leadT", "fachtor", "feadnt", "fopadtr", "ifaddet", "stradtor", "fpadtr", "freatti", "ffadtor", "fplayte", "confadtd", "favex", "fpadte", "xadg", "fachter", "fartto", "fladg", "fADT", "fpadtt", "frodts", "frodtor", "failtr", "xeadT", "fadtree", "stradts", "fpadwt", "dfpadrt", "ufadh", "feadx", "faudth", "fankt", "yadto", "fayset", "facet", "fladet", "fpadter", "fadet", "fiberti", "confplayt", "fplayet", "confadto", "fAdtt", "feadit", "flavet", "faidT", "feadta", "foradkt", "confpadta", "faddit", "flpadwt", "dfpadt", "feadt", "fladot", "tfpadt", "fangt", "feadset", "tfadth", " fAdto", "fodkt", "frodx", "fpadx", "ifpadte", "fadlet", "yrakvt", "foreadx", "fanktr", "fibert", "faudet", "fleadter", "fleadkt", "fadedt", "faudtor", "ffpadt", "fadter", "farkrt", "fankout", "feadter", "fadsta", "fpadit", "faveot", "fpadtree", "fadset", "faudts", "faceto", "feadts", "ifpadt", "formadt", "ifadte", "frodT", "fadett", " fAdtt", " fadto", "strrodts", "fadsto", "feddte", "farth", "fladts", "dfpadtar", "dfadt", "fradeti", "yrakto", "fadnot", "fradtt", "ladlet", "fadrt", "confpadt", "favewt", "efpadtt", "fADt", "yadvt", " fadtt", "faddt", "fodg", "foreadkt", "xadtd", "farkit", "fodt", "fladwt", "fpadnot", "frodt", "foadh", "flpadte", "efpadt", "feadlet", "fwdtree", "failout", "fildtr", "fodter", "feadtt", "freattt", "fachtd", "faddT", "fayg", "fadto", "fadte", "fladt", "formradkt", "facevt", " fadT", "ladit", "fangtor", "faddet"], "pm": ["p", "prem", "mm", "dev", "py", "conf", "wp", "um", "px", "master", "member", "pp", "gem", "perm", "hm", "pid", "cm", "dm", "pb", "pre", "lamm", "pg", "pt", "mmm", "ps", "am", "rpm", "mo", "vm", "PM", "rem", "rm", "process", "pai", "ams", "sm", "pd", "nm", "activity", "post", "service", "my", "pa", "sam", "gm", "param", "gom", "ym", "m", "mp", "iam", "prom", "mi", "po", "pi", "pkg", "asm", "pc", "ram", "ms", "bm", "mod"]}}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)\n\n{\n\n    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);\n\n\n\n    if (val & ACPI_BITMASK_SLEEP_ENABLE) {\n\n        /* change suspend type */\n\n        uint16_t sus_typ = (val >> 10) & 7;\n\n        switch(sus_typ) {\n\n        case 0: /* soft power off */\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        case 1:\n\n            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.\n\n               Pretend that resume was caused by power button */\n\n            ar->pm1.evt.sts |=\n\n                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);\n\n            qemu_system_reset_request();\n\n            qemu_irq_raise(ar->pm1.cnt.cmos_s3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 12036, "substitutes": {"ar": ["r", "art", "or", "cr", "ir", "ra", "ard", "rs", "ear", "rr", "actor", "air", "tar", "war", "mar", "am", "ler", "arb", "arc", "aro", "ara", "arm", "ak", "bar", "a", "er", "par", "are", "ah", "car", "arry", "ro", "arp", "ur", "ary", "arr", "AR", "mr", "rar", "adr", "ars", "et", "har", "anc", "ocr", "dar", "ag", "aer", "arg"], "val": ["pol", "al", "p", "x", "vals", "conf", "Val", "value", "sol", "unit", "xy", "v", "sel", "vol", "test", "bal", "data", "stat", "l", "crit", " aval", "key", "aval", "fb", "buf", "count", "vt", "b", "serv", "values", "index", " v", "kl", "var", "rol", " value", "bit", "elt", "eval", "ref", "tx", "max", "reg", "it", "cal", "VAL", "num", "status", "res", "len", "valid", "el"]}}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 12038, "substitutes": {"t": ["r", "ts", "p", "ent", "x", "h", "tc", "f", "i", "v", "ret", "test", "T", "tm", "z", "l", "pt", "tt", "dt", "u", "n", "nt", "tin", "o", "a", "vt", "b", "g", "d", "td", "mt", "tu", "te", "that", "tick", "mint", "tr", "y", "wt", "tg", "it", "m", "c", "txt", "kt", "ta", "e", "k", "w"], "data": ["no", "dr", "json", "da", "d", "relation", "index", "cache", "def", "empty", "ad", "db", "valid", "delete", "state", "rel", "done", "params", "name", " DATA", "group", "new", "config", "obj", "join", "info", "bus", "ta", "block", "table", "action", "p", "defined", "final", "ata", "exec", "clear", "entry", "str", " Data", "window", "record", "o", "complete", "size", "chain", "error", "r", "att", "writer", "dev", "list", "DATA", "request", "format", "connection", "version", "add", "rec", "call", "Data", "date", "share", "key", "debug", "owner", "n", "details", "dat", "module", "m", "normal", "client", "zero"], "nearest_delta_us": ["nearest_dota_u", "nearest_dota_mus", "nearest_delta_u", "nearest_delta_um", "nearest_dota_ms", "nearest_dota_us", "nearest_dota_eu", "nearest_delta_ms", "nearest_delta_eu", "nearest_dota_um", "nearest_delta_mus"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n", "idx": 12075, "substitutes": {"v": ["r", "p", "av", "vim", "h", "x", "ev", "i", "f", "vy", "vr", "j", "qv", "vm", "u", "n", "cv", "o", "sv", "vt", "ov", "vv", "b", "d", "tv", "var", "y", "q", "vi", "V", "m", "c", "uv", "vd", "vo", "nov", "nv", "verb", "vc", "e", "vp", "conv"], "errp": ["rP", "errP", "erP", "err", "rr", "rp", "errr", " errr", " errP", "erp"], "qov": ["wovi", "qovi", "quova", "wav", "qvo", " qovi", "wov", "qova", "qOV", "dqov", " qOV", "quOV", "quov", "quvo", "dqova", " qav", " qova", "dqOV", "qav", " qvo", "quovi", "wova", "quav", "dqvo"], "obj": ["ts", "func", "Object", "objects", "instance", "Obj", "xy", "attr", "addr", "vol", "ob", "object", "str", "bj", "pt", "j", "tk", "fr", "mo", "rect", "o", "nt", "tmp", "fn", "inst", "expr", "act", "os", "arr", "elt", "ok", "ref", "js", "ctx", "txt", "resp", "any", "utt", "alt", "bo", "ptr", "ready", "rel", "ns"]}}
{"project": "qemu", "commit_id": "c951d9a6751576a076ac80a5e5145ceb8d794d38", "target": 1, "func": "static void file_completion(const char *input)\n\n{\n\n    DIR *ffs;\n\n    struct dirent *d;\n\n    char path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n", "idx": 12079, "substitutes": {"input": ["x", "sample", "human", "ix", "shift", "u", "history", "index", "pattern", "empty", "first", "focus", "c", "text", "current", "source", "up", "w", "cmd", "h", "select", "value", "output", " in", "raw", "config", "join", "field", "q", "it", "buffer", "init", " inputs", "uri", "i", "exec", "id", "cur", "missing", "pad", "command", "str", "padding", "import", "start", "inc", "prefix", "unknown", "active", "f", "request", "read", "edit", "PUT", "query", "key", " Input", "in", "initial", "P", "form", "get", "local", "view", "Input", "m", "ip", "base", "context", "image"], "ffs": ["ufjs", " ffws", "ffields", "FFjs", "affgins", "FFns", "FFds", "ufs", "ffds", "ffts", "FFfs", "effs", "ffws", "xffS", "FFws", "aftjs", "FFS", "lfds", "ffgins", "ffS", "affns", "ffieldgins", "afts", "affs", "ufts", "lfs", "ffieldjs", "aftns", "lffs", "uffs", "affS", "effS", "xffws", "FFgins", "effds", "ffieldS", "ffns", "effts", "effjs", "ffjs", "effns", "ffieldns", "fffs", "xffs", "FFs", "ufds", "lfts", "FFts", "aftS", " ffS"], "d": ["r", "di", "defined", "dc", "ld", "dist", "h", "done", "dr", "nd", "dx", "bd", "D", "f", "i", "v", "du", "dd", "de", "dm", "z", "data", "gd", "dot", "l", "dict", "j", "dl", "dt", "n", "pd", "da", "md", "b", "dir", "g", "td", "s", "dat", "dh", "fd", "dim", "sd", "dn", "ds", "m", "c", "t", "ad", "db", "e", "w"], "path": ["directory", "type", "ath", "data", "cp", "print", "history", "index", "pattern", "cache", "empty", "ref", "mount", "c", "text", "current", "pkg", "template", "ring", "cmd", "session", "link", "test", "output", "stat", "name", "pt", "code", "root", "raw", "all", "parts", "line", "config", "temp", "core", "package", "desc", "set", "Path", "open", "port", "host", "conn", "sp", "entry", "str", "parent", "th", "out", "time", "pointer", "prefix", "prop", "chain", "doc", "length", "error", "list", "format", "call", "route", "key", "policy", "dir", "form", "local", "full", "m", "PATH", "part", "message", "context"], "file": ["r", "cli", "list", "h", "File", "document", "f", "type", "tree", "id", "data", "format", "model", "output", "stat", "name", "filename", "result", "page", "lock", "parent", "channel", "out", "line", "null", "time", "size", "server", "domain", "dir", "s", "handle", "fd", "field", "to", "user", "bit", "files", "local", "full", "fp", "header", "fi", "disk", "byte", "io", "ile", "part", "buffer", "txt", "db", "base", "port", "table", "source", "entity", "image", "length", "il", "error"], "file_prefix": ["fileerprefix", "file_password", "file__root", "module_prefix", "file_padding", "file2fix", "file_ix", "folder_ix", "folder_pre", "file2prefix", "file_root", "module_base", "FILE_fix", "file_pre", "module_label", "file_context", " file_root", "fileerpassword", "file_network", "file__label", " file_fix", "foldererprefix", "file_base", "foldererpre", "file__base", "FILE_pre", "file__fix", " file_ix", " file_network", "FILE_prefix", "page_prefix", "page_padding", "file__ix", "file2pre", "file_label", "file_path", "fileerpre", "file2root", " file_primary", "file__prefix", "file_fix", "file_primary", "folder_prefix", "page_path", "foldererix", " file_pre", "module_ix", "file__pre", "fileerix", "foldererpassword", "page_context", "folder_password"], "input_path_len": ["input_path__length", "input_Path_size", "input_path2Len", "input_Path_l", "input_Path_el", "input_Path_len", "input_Path_label", "input_path__len", "input_pathtyval", "input_path_loc", "input_Path_num", "input_Path_val", "input_path_el", "input_path2length", "input_path__en", "input_path_val", "input_Path_pos", "input_col_len", "input_path_lon", "input_path__Len", "input_pathtyLen", "input_path2len", "input_path___loc", "input_path_length", "input_path___Len", "input_pathtylabel", "input_path_num", "input_path_Len", "input_path_l", "input_path_coll", "input_path___num", "input_Path_Len", "input_path__lon", "input_col_coll", "input_path___len", "input_Path_length", "input_pathtylen", "input_path_en", "input_path_label", "input_col_pos", "input_col_en", "input_Path_lon", "input_path__coll", "input_path_size", "input_Path_loc", "input_path_pos", "input_path__pos", "input_path2l"], "p": ["r", "pro", "pr", "h", "x", "np", "wp", "lp", "f", "i", "pp", "pre", "v", "sp", "pb", "pe", "tp", "pg", "bp", "pad", "ps", "pt", "padding", "j", "l", "u", "after", "n", "cp", "P", "post", "a", "g", "prefix", "b", "pa", "par", "ph", "y", "q", "fp", "c", "m", "t", "pos", "ip", "press", "ping", "pi", "ap", "pkg", "pc", "php", "k", "jp"], "sb": [" sys", "ld", "cb", "bf", "sw", "bd", "sa", "std", "sh", "nb", "sp", "pb", " sa", "stat", "dm", "ob", "bp", " db", " sp", " sc", "dl", "bb", "hd", "eb", " sd", "ib", "sq", "sm", " ss", "sf", "sv", "b", "dB", "mb", "si", "st", "dh", "s", "sam", "bs", "kb", "sd", "gb", "sg", "ds", "ssl", "sc", "db", "rb", "zb", " b", " SB", "SB", "sth"]}}
{"project": "qemu", "commit_id": "6350b0904615cc0531cc3059ea34db5c009c88aa", "target": 1, "func": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n", "idx": 12083, "substitutes": {"obj": ["p", "h", "inv", "ot", "od", "Obj", "ev", "xy", "attr", "onet", "typ", "cont", "oid", "vr", "ob", "obs", "object", "j", "org", "ex", "out", "o", "nt", "tmp", "bh", "serv", "inst", "act", "os", "unknown", "phys", "ref", "js", "go", "ctx", "it", "bo", "hw"], "v": ["r", "p", "av", "ev", "f", "vy", "vis", "vr", "l", "ver", "j", "vm", "cv", "o", "sv", "vt", "b", "g", "vv", "d", "tv", "q", "vi", "V", "m", "uv", "c", "t", "nv", "vu", "vs", "vc", "vp", "w", "conv"], "opaque": [" oposer", " opacity", "opane", " opque", "popque", "opque", "opsaque", "poser", "pane", "opsane", "opain", " opane", "popaque", " opain", "oplque", "popain", "opsoser", "oplacity", "oposer", "oplain", "oplaque", "opacity", "paque", "popacity"], "name": ["p", " Name", "comment", "attr", "type", "cap", "tag", "id", "data", "NAME", "title", "str", "named", "family", "key", " prefix", "n", "label", "nm", "size", "property", "prefix", "names", "path", "var", "param", "term", "local", "ame", "Name", "nam", "text", "part", "alias", "m", " names", "word", "error"], "errp": ["ierp", "ererpc", "rezpoint", "errcp", "errorpoint", "errorping", "rrm", "rrbp", " errm", "nrbp", "ererP", "warnpad", "rezp", "errping", "errbp", "errpad", "rrp", "rezping", "ierm", "warnbp", "ierbp", "errpc", "warncp", "errpa", "erp", "errorm", " errbp", "errpoint", "errorp", "nrp", "rezm", "rrpoint", "errP", "erP", "nrcp", "iercp", "ererp", "warnpa", "erpa", "ierpad", "errm", "erpc", "warnpc", "ererpa", "warnp", "nrpad", "rrping", "warnP"], "dev": ["att", "pro", " Dev", "av", "wd", "die", "od", "conf", "DEV", "conn", "proc", "ev", "Dev", "eng", " device", "dd", "addr", "cam", "tech", "oy", "serial", "priv", "pt", "ver", "env", "nav", "debug", "device", "dep", "nt", "ve", "des", "vt", "md", "serv", "d", "app", "def", "dem", "van", "var", "go", "gu", "adv", "Device", "ad", "den", "det", "hw", "w"], "prop": ["att", "pro", "p", "pr", "pl", "opt", "rop", "conf", "proc", "acc", "ev", "attr", "cap", "err", "perm", "op", "pb", "pack", "cfg", "pri", "by", "priv", "pt", "ps", "str", "j", "Prop", "rep", "prot", " Prop", "val", "supp", "key", "rel", "feat", "cp", "comp", "prof", "property", "sec", "ph", "def", "lit", "plot", "info", "term", "tx", "ctx", "pred", "mp", "pos", "per", " props", "decl", "pkg", "col", "fac", "spec", "jp", "cmd"], "ptr": ["p", "pert", "pr", "pointers", "dr", "proc", "eth", "attr", "err", "addr", "sp", "vr", "tp", "pt", "rep", "val", "rob", "buf", "inters", "seek", "pointer", "vt", "Ptr", "expr", "index", "tr", "arr", "set", "ref", "offset", "ctx", "inter", "priority", "br", "adr", "pos", "buffer", "loc", "dest", "ctr", "address", "jp"], "local_err": ["local_gz", "loc_err", " local_buf", "localmyconn", " local_exc", " local_er", "localmyrb", "local_rs", "local2rr", "local2exc", "localmyerr", "local_conn", "locmyrb", "localErr", "local_buf", "local2msg", "localjerr", "localmyer", "loc_er", "localErrs", "local_r", "locmyconn", "localErbuf", "local_exc", " local_r", "local_rr", "localjexc", "localErerr", "local_er", " local_msg", "local_rb", "locmyer", "locmyerr", "loc_conn", "local_msg", "localjmsg", "local2err", " local_gz", "localjrr", "loc_rb", " local_rr", " local_rs"], "value": ["update", "unit", "type", "json", "data", " seek", "depth", "hello", "range", " tv", "total", "sv", "index", "currently", "now", "byte", "text", "current", " payload", "description", "valid", "vp", "state", " quantity", "test", "output", "raw", " val", " bar", "field", "attribute", "set", "max", "priority", "VAL", "buffer", "status", "port", "we", "always", " result", "ue", " priority", "id", " address", "serial", "entry", "result", "start", "VALUE", "position", "Value", "label", " VAL", "size", "values", "tv", " load", "unknown", "checked", "length", " total", " Value", "save", "version", " values", " rest", "val", "content", "key", "property", " voltage", " compute", "see", "address"]}}
{"project": "qemu", "commit_id": "d7cd369402191814a1bb339a730f3af411e9682f", "target": 1, "func": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 12086, "substitutes": {"opaque": ["OPaques", "coaques", "pque", " opvious", "opossibly", "oplation", "coque", "OPque", "opque", "opvious", " Opaque", "Opossibly", " opinion", " Opossibly", "OPaque", "opaques", "colation", "coaque", "Opvious", " Opinion", " Opvious", "paques", "Opinion", " opossibly", "Opaque", "opinion", "paque", "OPlation", "plation"], "co": [" mo", " Co", " ro", "ra", "uto", "op", "osa", "nc", "flo", "fo", "mo", "cu", "ico", "o", "CO", "ko", "cro", "oo", "ro", " ho", "ca", "go", "lo", "aco", "oe", "c", "cal", " con", "mi", "con", "po", "oc", "Co", "bo", "pc", "col", "ho"]}}
{"project": "FFmpeg", "commit_id": "6a99310fce49f51773ab7d8ffa4f4748bbf58db9", "target": 1, "func": "static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)\n\n{\n\n    int i = 0;\n\n    unsigned int ave_mean;\n\n    s->transient[ch] = get_bits1(&s->gb);\n\n    if (s->transient[ch]) {\n\n        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));\n\n        if (s->transient_pos[ch])\n\n            s->transient[ch] = 0;\n\n        s->channel[ch].transient_counter =\n\n            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);\n\n    } else if (s->channel[ch].transient_counter)\n\n        s->transient[ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 12095, "substitutes": {"s": ["orders", "changes", "sb", "sets", "ses", "events", "ls", "ains", "aws", "comm", "sv", "as", "sam", "bis", "js", "sys", "c", "t", "series", "se", "ms", "rates", "ins", "ns", "less", "h", "ats", "conf", "sw", "ies", "qs", "ers", "settings", "stat", "ps", "http", "parts", "ess", "sq", "obj", "fs", "a", "serv", "set", "sg", "stats", "ds", "ssl", "comments", "status", "services", "vs", "cs", "ims", "gets", "ports", "its", "ties", "ops", "ex", "store", "is", "eps", "os", "y", "hs", "styles", "results", "ts", "rs", "ss", "es", "als", "z", "gs", "sts", "views", "details", "states", "m", "S", "bits", "bs", "sports", "ants"], "ch": ["p", "cb", "h", "chron", "hr", "cha", "ech", "gh", "ih", "v", "chan", "sh", "cur", "z", "chi", "cell", " chip", "ver", "sky", "cl", "th", "chat", "channel", "tch", "change", "cht", "cor", "chn", "cp", "cer", "chrom", "chart", "zh", "history", "ht", "chin", "ches", "che", "kh", "ach", "ah", "y", "pan", "hl", "q", "gr", "ched", "och", "br", "c", "sch", "chain", "cod", "batch", "chip", "CH", "Ch", "client", "col", "k", "cho", "cs", "ich"], "tile_size": ["tree_number", "tile67dimension", "tileNamesmall", "tile10width", "tree67size", "tile_length", "tile67size", "tile_len", "tile10number", "tile_width", "tree67width", "tileNamesize", "tree67dimension", " tile_length", "tile_number", " tile_len", "tile10size", "tree_width", "tree67number", "tree_dimension", "tileNameSize", "tile10dimension", "tile_small", "tile_dimension", "tile67number", " tile_Size", "tree_size", "tile67width", "tile_Size", " tile_small"], "ave_mean": ["ena00metadata", "ave_normal", "ave00metadata", "ave2max", "avematsav", "vae_normal", "ave67sav", "ena_metadata", "avematmean", "erve_mean", "av_sum", "ave_max", "ave00min", "ena00min", "ave2average", "ave__max", "ave67normal", "ave2made", "ena00mean", "ena_mean", "ena_group", "ave_group", "ave00group", "ave_sem", "ave_sav", "ena_min", "vae_summary", "ave_made", "ome_average", "aveLEgroup", "ome_mean", "vae_mean", "ome2average", "ave_summary", "ave_sum", "erve_mode", "ave42made", "ave00mean", "ave_average", "ave_____sem", "ave_metadata", "av2max", "av2mean", "erve_sem", "av_mean", "av_max", "ena00group", "ave2normal", "ave_____sum", "aveLEmetadata", "ave2sum", "avematsummary", "ave67mean", "ome_an", "ave_min", "ome_normal", "ome2normal", "av2made", "erve_sum", "ave2mean", "ave42max", "av_made", "ave42mean", "av2sum", "vae_sav", "ave__made", "ome2mean", "ave_an", "ave_mode", "avematnormal", "ave42sum", "ave_____mean", "ave_____mode", "ave2an", "aveLEmean", "ome2an", "ave67summary", "ave__sum", "aveLEmin", "ave__mean"], "i": ["ui", "di", "p", " pi", "cli", "h", " multi", " ti", " m", "v", "gi", "ic", "ai", "z", "id", " ii", " index", "ei", "ii", "j", " iter", "xi", "I", "phi", "ix", "iu", "multi", "u", "bi", " I", "in", "o", "iter", "is", "hi", "si", " k", "index", "li", " bi", "y", "ini", " li", "info", "go", "gu", "it", " ni", "ci", "m", " di", "t", "qi", "mi", " j", "status", "ti", "im", "pi", "e", "ki", "us", " si"], "rem": ["pol", "fine", "extra", "rom", "pres", "mem", "em", "cm", "hist", "rip", "re", "rec", "comm", "Rem", "rm", "REM", "temp", "remote", "chrom", "br", "io", "prom", "mi", "num", "res", "im", "resp"], "rem_bits": ["rem2bs", " rem__", " rem_bit", "rem__bits", " rem_ins", "rem2ins", " rem_0", "rem__bit", "rem__ins", "rem2bit", "rem_bs", "rem_bit", "rem__bs", "rem_0", "rem__", "rem2bits", "rem_ins", " rem_bs"], "residue": ["resinUE", "residuer", "resolidue", "Resinue", "resviduer", "residues", "rsidUE", "reshiduer", "rsidentuer", "resinuer", "rsidentues", "reshidues", "residentues", "rsidue", "Resinues", "resolidUE", "resolidues", "resinue", "ResidUE", "Resinuer", "ResinUE", "residentue", "rsidues", "Residues", "resinues", "rsidentue", "residentuer", "resvidUE", "resvidue", "rsidentUE", "Residuer", "residentUE", "resvidues", "resoliduer", "Residue", "reshidue", "reshidUE", "residUE", "rsiduer"], "quo": ["sqota", "quot", "queos", "quos", "sqo", "quesot", "squos", "requao", "squoo", "squo", "aquot", " qupo", " quao", "requot", "aquota", "qpo", "quesos", "tyota", "qupo", "requo", "squoin", "aquos", "requoo", "queota", " quot", "qos", "tyo", "queo", " quota", "queoo", "sqos", " quoo", "aqupo", "typo", "aquo", "queso", "queot", "quepo", "quao", "tyoo", "qo", "sqot", "quesota", "quoo", "quoin", "aquoin", "aquoo", "qoo", "queao", "quota", "qoin"]}}
{"project": "FFmpeg", "commit_id": "405af431040a57c630716b3940d7240021e8b80c", "target": 0, "func": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    CinAudioContext *cin = avctx->priv_data;\n\n    const uint8_t *src = buf;\n\n    int16_t *samples = data;\n\n    int delta;\n\n\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n\n\n    delta = cin->delta;\n\n    if (cin->initial_decode_frame) {\n\n        cin->initial_decode_frame = 0;\n\n        delta = (int16_t)AV_RL16(src); src += 2;\n\n        *samples++ = delta;\n\n        buf_size -= 2;\n\n    }\n\n    while (buf_size > 0) {\n\n        delta += cinaudio_delta16_table[*src++];\n\n        delta = av_clip_int16(delta);\n\n        *samples++ = delta;\n\n        --buf_size;\n\n    }\n\n    cin->delta = delta;\n\n\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n\n\n    return src - buf;\n\n}\n", "idx": 12099, "substitutes": {"avctx": ["vrtx", "aptx", "avtx", " avconn", "apctx", "afctx", "vrcmp", "vrcontext", "avcmp", "Avctx", "Avtx", "apcontext", "afcmp", " avcontext", "vrctx", "apconn", "Avcontext", " avtx", "aftx", "afcontext", "avcontext", " avcmp", "avconn", "Avconn"], "data": ["r", "p", "done", "dev", "DATA", "bin", "value", "read", "addr", "ata", "frame", "output", "name", "media", "pad", " DATA", "padding", "Data", "str", "start", "feed", "window", "raw", "content", "n", "size", "a", "area", "d", "video", "bytes", "cache", "dat", "s", "to", "empty", "input", "offset", "text", "t", "pos", "buffer", "bits", "len", "batch", "block", "audio", "table", "items", "message", "stream", "mu", "image", "results", "length", "zero", "error", "ns"], "data_size": ["buf_Size", "data_sent", "data_type", "buf_range", " data_sent", "buf_type", " data_Size", " data_range", "data_range", "dataCTsent", "data_Size", "dataCTsize", "dataCTSize", "dataCTlength", "data_SIZE", " data_SIZE", "data_length", " data_length"], "avpkt": ["avpatth", "avppth", "avcpwp", "afpacket", " avpacket", "avPacket", "avppnt", "wavpnt", "avppacket", "avcpkt", "avcpst", "afPkt", "avparwp", "avcpacket", "avpka", "avPkt", "avppst", "avwpkt", "wavpdu", "afpkt", " avpth", "avcpth", "avparct", " avpka", "avpatacket", "avcpnt", "wavpkt", "wavpst", "avwpst", "wavppdu", "avppka", "avppdu", " avcpkt", " avcpacket", "afpct", "avcpdu", " avcpth", "avpdu", "avPwp", "avwpdu", "wavppnt", "avpct", "afPacket", "avpacket", "avcpka", "avpatka", "avwpnt", "afPct", "avpwp", "avpnt", "avpth", "wavppst", "avparkt", "avppkt", "avparacket", "afpwp", "avpatkt", "afPwp", "wavppkt", "avcpct", "avpst", "avPct", " avcpka"], "buf": ["p", "cb", "mem", "bin", "cap", "ff", "alloc", "pb", "output", "cur", "bc", "uf", "map", "rc", "cv", "config", "tmp", "img", "buff", "bh", "b", "bytes", "cache", "dat", "late", "queue", "ref", "ctx", "Buff", "box", "vec", "wb", "br", "txt", "uv", "pos", "buffer", "len", "block", "rb", "loc", "batch", "pkg", "dest", "context", "orig", "ptr", "xff", "msg", "cmd"], "src": ["bin", "url", "ind", "obs", "rc", "ref", "sys", "sid", "len", "source", "loc", "ptr", "rel", "ins", "sync", "attr", "addr", "ser", "stat", "raw", "obj", "seek", "sl", "scan", "shape", "txt", "buffer", "sc", "inner", "sub", "sta", "cur", "start", "rob", "sr", "slice", "size", "tmp", "iter", "bytes", "st", "s", "sn", "input", "ctx", "stream", "ctr", "comp", "length", "self", "func", "cb", "proc", "rs", "syn", "rec", "filename", "trans", "usr", "nr", "in", "rl", "ost", "inst", "iv", "offset", "uv", "pos", "num", "dest", "ipl", "xff", "img"], "samples": ["dems", "sounds", "sdents", " sples", "damps", "Samps", "Sems", "samps", "Sounds", "Sources", "tamples", "Sents", "sples", "tources", " sents", "namples", "Sples", "sources", "filesents", "tents", "filesples", "filesamps", "Samples", "dents", "dounds", "sdamps", "namps", "nounds", "sdems", "sents", "sems", "sdamples", "dources", "nents", "filesamples", "damples", "tamps", " samps"], "delta": ["sdant", "delt", "Dant", "edummy", "selta", "lota", "edota", "lelt", "ristant", "mota", "mporal", "lant", "sdynamic", "felt", "adant", "mynamic", " distant", "sdummy", "metime", "edelt", "edelta", "drelta", "sdota", "lummy", "fata", "DDelta", "drota", "mummy", "sdiff", "dporal", "adelt", "driff", "diota", "sporal", "felta", "Delt", "melt", "dummy", "distant", "Dota", "dota", "relta", "idynamic", "idelta", "sota", "dant", "diff", "melta", "dynamic", "lelta", "dielta", "relt", "sdelt", " dynamic", " dota", "dDelta", " detime", "sdelta", "sistant", "selt", " delt", "idelt", "fota", " dDelta", " dummy", "adota", "drynamic", "dielt", "sant", "rota", "diporal", "adDelta", "Delta", " diff", "adelta", "idota", "retime", "mata", "detime"], "buf_size": ["buf_shift", "bufixSIZE", "buff_size", " buf_shift", " buf_len", "bufixsize", "buff_Size", "buf_to", "queue_sized", " buf2SIZE", "window_scale", "buf_offset", "window_size", " buf2shift", "buf_ize", "buf_index", "queue_SIZE", "buf_len", "queue_offset", "window_ize", " buf_to", " buf2size", "buf_sized", "buf_SIZE", "buf_scale", "buff_min", "buf2size", "window_index", "buf_min", "buf2shift", "queue_scale", "buf2to", " buf2to", "buf2SIZE", "bufixoffset", "bufixempty", " buf_SIZE", "buf_Size", "queue_size", "buf_empty", "queue_empty", "buff_scale"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j, k;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[0];\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + 2]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[0][0];\n\n    my += r->dmv[0][1];\n\n    for(j = 0; j < 2; j++){\n\n        for(i = 0; i < 2; i++){\n\n            for(k = 0; k < 2; k++){\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 12106, "substitutes": {"r": ["p", "h", "dr", "hr", "ra", "rs", "rr", "v", "ar", "f", "err", "vr", "re", "rf", "l", "result", "R", "nr", "sr", "rc", "n", "o", "er", "g", "d", "b", "resource", "ur", "tr", "rt", "q", "gr", "mr", "rar", "kr", "br", "m", "c", "this", "t", "res", "rb", "rw", "e", "w", "rd"], "block_type": ["block2type", "block_id", "byte_size", "block8size", "block2id", "byte_type", "block_size", "block_name", "block2size", "byte_name", "block2name", "byte_id", "block8id", "block8type", "block8name"], "dir": ["DIR", "di", "ir", " d", "directory", "coord", "dy", "direct", " direction", "ind", "cond", "angle", "deg", "depth", "lock", "rect", "direction", "dep", "rad", "bound", "d", "dim", "path", "desc", "Dir", "box", "orient", "db"], "s": ["sb", "ses", "ls", "sh", "xs", "sm", "south", "sv", "as", "er", "d", "sys", "js", "c", "t", "https", "source", "series", "se", "ms", "w", "ins", "ns", "less", "session", "h", "conf", "ats", "sw", "settings", "ps", "an", "http", "sq", "obj", "fs", "a", "sl", "sd", "stats", "ds", "ssl", "sc", "status", "vs", "cs", "ims", "p", "ar", "sp", "its", "l", "ops", "ex", "sr", "space", "is", "b", "g", "st", "os", "times", "y", "hs", "ts", "self", "rs", "f", "v", "ss", "es", "als", "gs", "sts", "n", "m", "S", "single", "spec", "sports"], "A": ["Av", "ALL", "BA", "O", "Both", "An", "AV", "AH", "M", "AP", "T", "N", "Others", "As", "G", "R", "AM", "I", "U", "All", "Answer", "AL", "API", "Alpha", "AC", "AS", "SA", "Args", "Java", "P", "a", "And", "Array", "AN", "Area", "AA", "App", "CA", "NA", "UA", "If", "Bar", "LA", "AR", "AT", "K", "F", "V", "At", "S", "AF", "AB", "EA", "ACC", " a", "Abs", "ACE", "Al", "ACT", "L", "Ar", "HA", "JA", "AU", "GA", "Ass"], "B": ["RB", "BI", "GB", "BA", "Block", "Chain", "Q", "Body", "IB", "BR", "Builder", "D", "Both", "Box", "M", "Big", "BS", "Other", "T", "BM", "Bern", "N", "BER", "Z", "R", "Bs", "I", "VB", "BL", "OB", "PB", "P", "BE", "DB", "b", "LIB", "BC", "Be", "Bar", "Y", "Bytes", "TB", "BB", "F", "J", "V", "BF", "S", "LB", "AB", "BY", "WB", "CB", "L", "NB", "Blue", "FB", "Buffer", "BG"], "C": ["X", "CON", "Q", "Chain", "DC", "D", "CT", "M", "EC", "T", "N", "G", "Z", "R", "I", "CG", "JC", "CE", "Count", "Con", "Config", "CL", "CW", "CR", "Cl", "CC", "AC", "H", "CS", "P", "CN", "CP", "Car", "CA", "Cache", "BC", "Cat", "Y", "K", "Code", "F", "V", "c", "S", "CNN", "E", "CD", "Cs", "CB", "CM", "Co", "L", "Ch", "SC", "CU"], "i": ["p", "x", "ir", "h", "f", "v", "ic", "ai", "l", "ii", "I", "iu", "ik", "iy", "bi", "o", "a", "si", "li", "it", "ia", "ci", "m", "mi", "ij", "e"], "j": ["p", "aj", "jj", "jc", "v", "jump", "z", "l", "ii", "ji", "n", "o", "ja", "g", "b", "kj", "y", "q", "J", "m", "c", "ij", "dj", "uj", "jp"], "k": ["p", "km", "v", "ck", "z", "ek", "tk", "ka", "ik", "key", "u", "n", "o", "ke", "kg", "ak", "kj", "kh", "ko", "mk", "kk", "q", "K", "kr", "m", "sk", "kw"], "mx": ["mm", "ma", "dx", "km", "xy", "zx", "px", "MX", " xx", "xx", "xs", "xi", "ml", "ex", "xp", "kg", "mal", "nm", "mk", "yx", "mi", "sk", "ll", "xc", "yp", "mu", "ms", "nz", "mn"], "my": ["mm", "ny", "py", "ky", "ma", "gy", "vm", "ml", "me", "nm", "md", "mt", "mb", "yy", "mk", "gm", "mis", "pm", "mr", "mc", "mp", "mi", "mid", "yo", "ms", "bm", "mn"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n", "idx": 12111, "substitutes": {"aioinit": [" aioerr", "aIOInit", "aIOinit", "aioserr", "aiosInit", " aIOerr", " aioInit", "aiosinit", " aIOinit", " aIOInit", "aioerr", "aIOerr", "aioInit"], "ret": ["att", "ld", "pas", "RET", "ft", "cat", "eth", "err", " Ret", "cont", "nat", "re", "result", "gt", "Ret", " RET", "deg", "usr", "val", "dt", "reply", "rem", "rm", "out", "lt", "nl", "nt", " terr", "rets", "iter", "not", "vet", "net", "back", "print", "mt", "Alt", "leg", " alt", " fut", "def", "tr", "ext", "get", "try", "arr", "desc", "elt", "rt", "full", "reset", "reg", "it", "txt", "t", "et", "backed", "len", "res", "cert", "det", "ll", "alt", "ter", "del", "cmd"]}}
{"project": "qemu", "commit_id": "2c80e42395bfe0bf291c082f9399431e1ff9d758", "target": 0, "func": "dprint(int level, const char *fmt, ...)\n\n{\n\n    va_list args;\n\n\n\n    if (level <= debug) {\n\n        va_start(args, fmt);\n\n        vfprintf(stderr, fmt, args);\n\n        va_end(args);\n\n    }\n\n}\n", "idx": 12130, "substitutes": {"level": ["coll", "ale", "co", "where", "high", "levels", "tag", "type", "v", "Level", "role", "format", "pe", "VEL", "l", "code", "family", "key", "debug", " lvl", "enc", "le", "print", "scale", "goal", "lvl", "display", "local", "set", "style", "priority", "stage", "console", "loc", "action", "mode", "message", "fail", "cost", "vel", "color", "state", "col", "rel"], "args": ["options", "ts", "func", "lines", "caps", "vals", "types", " arguments", "atts", "aps", "cmd", "rs", "ables", "points", "ls", "params", "uments", "qs", "__", "ants", "rows", "igs", "str", "xs", "gs", "aws", "ads", "terms", "tests", "parts", "Args", "flags", "actions", "ics", "values", "s", "names", "ins", "arr", "files", "keys", "ds", "limits", "fields", "ars", "bits", "items", "ags", "vs", "ims", "results", "w", "ids", "arg", "ns"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n", "idx": 12133, "substitutes": {"hotplug_dev": ["hotplug_def", "hotplug_ev", "hotpl_dev", "hotplugPdef", "hotplug2def", "hotplugPev", "hotpl_def", "hotplug2dev", "hotpl_buf", "hotplugPbuf", "hotplug2ev", "hotplugPdev", "hotpl_ev", "hotplug_buf", "hotplug2buf"], "dev": ["pro", "av", "develop", "conf", "DEV", "conn", "Dev", "ev", "mem", "eng", "err", "v", "de", "der", "dd", "data", "cam", "tech", "priv", "ver", "env", "val", "pub", "debug", "device", "out", "ve", "buf", "des", "obj", "d", "ch", "def", "dem", "info", "development", "driver", "adv", "home", "Device", "gu", "dis", "doc", "state", "hw", "spec", "w", "cmd"], "errp": ["rP", " errps", "errps", "rps", "errP", "erP", "err", "rr", "rp", "errr", " errr", "erps", " errP", "erp"], "pci_dev": ["pci_Dev", "pcipdev", "pudietydevice", "pci_develop", "pci___def", "pcu_dev", "pcci_def", "pudi_device", "pci_adv", "pci_ev", "pcci_develop", "pcipadv", "pudietycache", "pki_adv", "pcci_dev", "pudi_dev", "pki_ev", "pci_dec", "pci___ev", "pki_dec", "pcci_ev", "pci_device", "pcipdec", "pci_def", "pcietycache", "pcietydevice", "pci___dev", "pci_cache", "pcietydev", "pcu_ev", "pki_dev", "pcu_device", "pudietydev", "pcipev", "pci___develop", "pcu_Dev", "pudi_cache"], "pbdev": ["pbpriv", "lpbus", "PBdev", "pkggo", "bpdesc", "rbdevice", "pbrent", "pkgdef", "bpdes", "tfdevice", "lbcache", "pcbuf", "xbsys", "bpdev", "tpdevice", "pxdevice", "PBvar", "pbval", "PBdevice", "pbcache", "erbdev", "tpdev", "pbbuf", "cbdef", "pbdes", "pcdevice", "sbdevice", "pcbuild", "erbdes", "cbver", "xbdef", "lpev", "bufdevice", "cbdev", "pcdef", "jpdevice", "jpev", "jpdev", "pkgval", "pkgdet", "pcdevelop", "tpver", "pxval", "sbdiv", "bufdev", "xbdesc", "pbbus", "PBpriv", "pgbuf", "bufDev", "pgdev", "erbev", "fbdev", "tpvar", "lpdevice", "sbdev", "pkgbuf", "pcDEV", "pkgdev", "xbdev", "pxdev", "pkgbuild", "bufev", "xbbuild", "bpdiv", "rbev", "tfdef", "bpcache", "pgval", "ebdevice", "pbsys", "lbdevice", "pkgdevice", "PBcache", "pbdevice", "pcdev", "PBver", "pbbuild", "cbev", "ppdes", "rbdev", "pgrent", "PBdiv", "PBdes", "bpsys", "xbdes", "lbdev", "pcval", "pbdef", "rbdes", "pgdevice", "fbdevice", "ebev", "ebbus", "cbrent", "pcdet", "pxdet", "pkgDEV", "ppsys", "pbdet", "cbdevelop", "cbdevice", "ebdev", "ppdesc", "pcver", "pbDEV", "pgver", "tfdevelop", "fbvar", "bpdevice", "ppdev", "pcrent", "xbgo", "pbver", "pbdiv", "pbdesc", "fbver", "pbev", "rbDev", "lpdev", "cbDev", "jpbus", "pgDEV", "pbDev", "erbdevice", "sbev", "pcgo", "tfdev", "pbgo", "lbpriv", "pbdevelop", "bppriv", "pbvar", "bpev", "PBev"], "s": ["r", "ts", "p", "h", "sb", "rs", "i", "v", "ls", "f", "ss", "ps", "gs", "j", "sts", "n", "sq", "south", "fs", "sv", "g", "b", "is", "sam", "set", "js", "hs", "ds", "ssl", "m", "S", "sis", "c", "t", "bs", "w", "socket", "ns"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12134, "substitutes": {"opaque": [" opatibility", "opsais", "iperatibility", "opatile", "opient", "opais", "iperaque", " opient", "iopaque", "iopacity", "Opatile", " opatile", "iperient", "opsaque", "opsulse", "opacity", "opatibility", "oplais", "oplulse", "iperatile", "opulse", "Opient", "iopais", "oplacity", "Opatibility", "opsacity", "oplaque", "Opaque", "iopulse"], "addr": ["r", "ack", "x", "dr", "sha", "mem", "rs", "tag", "coord", "hop", "err", "id", " address", "data", "add", "name", "pad", "str", "map", "usr", "ix", "align", "shift", "at", "order", "obj", "src", "a", "net", "work", "index", "mt", "dh", "act", "handle", "urg", "tx", "arr", "Address", "hash", "ref", "cmp", "offset", "ctx", "hl", "now", "pat", "adr", "rn", "reg", "gate", "pos", "ad", "res", "len", "loc", "row", "pkg", "ord", "ptr", "state", "hw", "address", "msg", "cmd"], "size": ["password", "mem", "type", "cap", "id", "data", "z", "name", "start", "code", "shift", "align", "n", "count", "Size", "desc", "offset", "ize", "c", "len", "sum", "message", "mode", "SIZE", "address", "length", "msg"], "s": ["r", "ts", "p", "h", "sb", "conf", "ses", "rs", "f", "v", "ss", "es", "l", "ps", "xs", "gs", "j", "ops", "n", "sq", "o", "fs", "a", "g", "b", "d", "pers", "os", "js", "hs", "m", "S", "c", "t", "ms", "w", "ns"]}}
{"project": "qemu", "commit_id": "c471ad0e9bd46ca5f5c9c796e727230e043a091d", "target": 0, "func": "static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n", "idx": 12142, "substitutes": {"dev": [" Dev", "att", "pro", "develop", "DEV", "conn", "Dev", "ev", " device", "mem", "v", "dd", "test", "exec", "de", "data", "cam", "tech", "serial", "usb", "pad", "ver", "debug", "device", "ve", "nt", "des", "devices", "d", "app", "scan", "ac", "def", "dem", "unknown", "info", "sd", "local", "development", "go", "driver", "adv", "gu", "Device", "phy", "disk", "ad", "host", "hw", "w", "cmd"], "start_addr": ["start___address", "start_hop", "start_phys", " start_ptr", "startLpos", "start_address", "start_adr", "start_pos", "start__pos", "start_tick", "starting_address", "start_mt", "startLphys", "start___adr", "starting_adr", "start__addr", "starting_hop", "starting_ptr", "starting_addr", "start___tick", " start_phys", "start__phys", "start_ptr", "startLaddr", " start_mt", " start_pos", "start___addr", " start_adr", "starting_tick"], "size": ["send", "resolution", "mem", "unit", "sp", "z", "format", "fee", "name", "network", "height", "capacity", "small", "share", "range", "space", "count", "si", "Size", "scale", "s", "dim", "shape", "empty", "max", "ize", "c", "body", "sum", "len", "message", "mode", "pi", "iz", "SIZE", "length", "storage"], "i": ["r", "di", "p", "ui", "ami", "x", "h", "ir", "yi", "v", "gi", "ri", "id", "ai", "ic", "z", "iq", "ind", "l", "ii", "xi", "sim", "I", "ji", "phi", "ix", "iu", "u", "multi", "bi", "n", "in", "o", "g", "ie", "hi", "si", "index", "li", "y", "ini", "q", "fi", "it", "ci", "m", "c", "t", "ip", "zi", "mi", "ij", "qi", "ti", "im", "pi", "e", "me"], "j": ["r", "p", "aj", "x", "pr", "h", "jj", "next", "err", "v", "job", "json", "jc", "jump", "ret", "z", "ind", "l", "ct", "fr", "ji", "jac", "out", "bi", "n", "obj", "o", "ja", "b", "g", "kj", "d", "index", "try", "y", "q", "note", "js", "adj", "it", "J", "m", "br", "c", "t", "jl", "je", "ij", "dj", "res", "uj", "row", "Ja", "state", "k", "jp"], "part_name": ["part9names", " part_data", "partxnam", "part_data", " part_id", " part_no", "part9name", "part_info", "partxnames", " part_names", " part_info", "part9data", "part_no", "part9nam", "partxdata", " part_nam", "part_names", "part_id", " part_dict", "part_dict", "part_nam", "partxname"], "vq": ["vcomm", "vequ", "voq", " vqt", " vcharge", "vmquant", " vkg", "vqt", " vquant", "vqu", "varquant", "vvqs", "vvquant", " vqu", "nvq", "vvcomm", " vclient", "vmrequ", "veqs", "varcal", "invclient", "vcquant", "vcdq", "verrequ", "voqs", "avqt", "vrqs", " vquest", " vqs", "vrq", "fqu", "vquery", "veq", "nvpl", "vqs", "fqs", "varquest", "avqs", "vclient", "vvq", "vmq", "nvqs", "nvkg", "vccal", "voqu", "vkg", "vqa", "invue", "avqa", "vvcal", "vmqt", "varq", "vue", "vdq", "vardq", "varkg", "vcqt", "avq", "verdq", " vpl", " vquery", "vvquery", "vvdq", " vdq", " vrequ", "vcrequ", "vcquest", "tvcharge", "varclient", "varqt", "vcharge", "fdq", "tvqu", "vcq", "verq", "vvcharge", "tvq", "invq", "invquest", "varue", "verquest", " vqa", "vrquery", "avkg", "vcal", "varcomm", "vedq", " vue", "vquant", "vpl", "vquest", "avpl", "vrcharge", " vcomm", "fq", "vocharge", "vrequ", "varqa", "tvqs"]}}
{"project": "qemu", "commit_id": "3435f39513a104294b5e3bbf3612047028d25cfc", "target": 0, "func": "void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t offset;\n\n    int flags;\n\n    void *area, *vaddr;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 12145, "substitutes": {"addr": ["art", "dr", "off", "eth", "attr", "coord", "i", "err", "alloc", "id", " address", "add", "name", "location", "pad", "map", "start", "align", "oad", "order", "nl", "owner", "obj", "size", "pointer", "a", "prefix", "act", "var", "arity", "Address", "hash", "ref", "max", "adr", "pos", "ip", "alias", "len", "loc", "arch", "base", "point", "action", "row", "ptr", "host", "address", "error"], "length": ["limit", "Length", "vector", "type", "number", "data", "end", "capacity", "family", "lock", "total", "count", "index", "len", "row", "ptr", "level", "square", "h", "ength", "build", "ob", "angle", "line", "join", "oh", "required", "path", "shape", "section", "max", "sequence", "port", "SIZE", "host", "idth", "amount", "location", "l", "padding", "position", "ENGTH", "size", "time", "maximum", "mask", "lon", "enth", "lib", "frequency", "present", "enabled", "format", "height", "available", "loop", "form", "full", "last", "volume", "message", "address", "duration"], "block": ["p", "sync", "list", "Block", "instance", "snap", "no", "mem", "type", "link", "pack", "frame", "model", "number", "network", "object", "group", "map", "lock", "bl", "device", "record", "BL", "range", "line", "space", "label", "obj", "buf", "size", "store", "b", "blocks", "prefix", "work", "def", "info", "attribute", "tx", "bit", "q", "ref", "set", "hash", "header", "box", "byte", "part", "chain", "ip", "buffer", "mark", "check", "profile", "base", "row", "mask", "point", "bo", "ram", "k", "image", "address", "word", "zero"], "offset": ["ace", "flag", "off", "slot", "next", "coord", "amount", "iso", "type", "alloc", "sp", "id", "end", "location", "entry", "pad", "height", "ano", "padding", "start", "angle", "position", "shift", "align", "key", "order", "owner", "origin", "total", "count", "size", "o", "pointer", "seek", "prefix", "index", "aff", "set", "Offset", "inter", "frequency", "pos", "buffer", "alias", "len", "et", "port", "loc", "base", "point", "mask", "lon", "row", "ptr", "address", "error"], "flags": ["options", "packages", "flag", "acl", "tools", "frames", "ants", "alf", "amps", " Flags", "errors", "finals", "grades", "features", "faces", "ags", "state", "ms", "ats", "types", "levels", "params", "settings", "lights", "terms", "parts", "properties", "generation", "fs", "acts", "posts", "missions", "stats", "fields", "weights", "utils", "comments", "status", "locks", "ports", "lines", "marks", "atts", "points", "ops", "ments", "lag", "rights", "links", "FLAG", "Flags", "values", "offs", "s", "styles", "limits", "weight", "mask", "ts", "units", "func", "fps", "aps", "args", "heads", "cond", "tags", "ensions", "actions", "details", "fd", "alities", "goal", "states", "bits", "items", "quality", "words", "lands"], "area": ["usage", "rea", "instance", "ma", "off", "metadata", "ra", "acl", "region", "iso", "ata", "alloc", " address", "format", "function", "location", "pad", "meta", "era", "access", "map", "page", "angle", "window", "rep", "ka", "va", "balance", "order", "array", "qa", "range", "space", "total", "bar", "buf", "zone", "a", "Area", "prefix", "are", "definition", "foo", "ha", " areas", "section", "rage", "average", "volume", "alias", "buffer", "mask", "ta", "division", "memory", "action", "description", "mode", "au", "alpha", "address", "storage", "aa"], "vaddr": ["avadd", "vroffset", "vararea", "voffset", "uvaddr", "avhost", "hdr", "Vaddress", "vptr", "uvaddress", " vint", "varg", "varaddr", "haddr", "hptr", "vstore", "hadr", "svadd", "wint", "vtint", "svcoord", "svalloc", "laddr", "avarg", "qvaddress", "svadr", "varadd", "vmadd", " vmod", "vmhost", " vdr", "vmod", "vraddr", "Vaddr", "rdr", "vaddress", "larea", "vthost", "haddress", "vmmod", "wptr", " vdb", " vrt", " vstore", "avaddr", "wadr", "vrdr", "vmrt", "qvcoord", "hint", "vadd", "svaddr", "vmaddress", "varadr", "vtarg", "vrstore", "qvoffset", "ladr", "valloc", " valloc", "svarea", "avrt", "vtaddr", "vadr", "vdr", "vrt", " varg", "svaddress", " voffset", "avmod", " vadr", "vint", " vptr", "avalloc", "avint", "Vhost", "svhost", "avdb", "ladd", "svoffset", "vhost", " vaddress", "vmdb", "raddr", "waddress", "vmaddr", "varea", " vhost", " vadd", "Vadd", "vcoord", "waddr", "uvcoord", "uvoffset", "rstore", "roffset", "qvaddr", "wdr", "vdb"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n", "idx": 12182, "substitutes": {"obj": ["self", "objects", "od", "instance", "Obj", "oj", "xy", "obo", "attr", "onet", "typ", "cur", "data", "ob", "ind", "obs", "object", "pot", "j", "sky", "tk", "parent", "o", "nt", "tmp", "nm", "bh", "src", "inst", "expr", "ht", "act", "elt", "ref", "js", "og", "ctx", "sys", "ctrl", "req", "this", "txt", "rb", "po", "any", "cmd"]}}
{"project": "FFmpeg", "commit_id": "1846a3eac854799fbffc9669dcf4de558b917957", "target": 0, "func": "static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx,\n\n                                      AVCodecContext *avctx,\n\n                                      int fallback_allowed)\n\n{\n\n    AVVAAPIDeviceContext *hwctx = ctx->device->hwctx;\n\n    AVVAAPIHWConfig *hwconfig = NULL;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    VAStatus vas;\n\n    int err, i, j;\n\n    int loglevel = fallback_allowed ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    const AVCodecDescriptor *codec_desc;\n\n    const AVPixFmtDescriptor *pix_desc;\n\n    enum AVPixelFormat pix_fmt;\n\n    VAProfile profile, *profile_list = NULL;\n\n    int profile_count, exact_match, alt_profile;\n\n\n\n    codec_desc = avcodec_descriptor_get(avctx->codec_id);\n\n    if (!codec_desc) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    profile_count = vaMaxNumProfiles(hwctx->display);\n\n    profile_list = av_malloc(profile_count * sizeof(VAProfile));\n\n    if (!profile_list) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaQueryConfigProfiles(hwctx->display,\n\n                                profile_list, &profile_count);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, loglevel, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    profile = VAProfileNone;\n\n    exact_match = 0;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vaapi_profile_map); i++) {\n\n        int profile_match = 0;\n\n        if (avctx->codec_id != vaapi_profile_map[i].codec_id)\n\n            continue;\n\n        if (avctx->profile == vaapi_profile_map[i].codec_profile)\n\n            profile_match = 1;\n\n        profile = vaapi_profile_map[i].va_profile;\n\n        for (j = 0; j < profile_count; j++) {\n\n            if (profile == profile_list[j]) {\n\n                exact_match = profile_match;\n\n                break;\n\n            }\n\n        }\n\n        if (j < profile_count) {\n\n            if (exact_match)\n\n                break;\n\n            alt_profile = vaapi_profile_map[i].codec_profile;\n\n        }\n\n    }\n\n    av_freep(&profile_list);\n\n\n\n    if (profile == VAProfileNone) {\n\n        av_log(ctx, loglevel, \"No VAAPI support for codec %s.\\n\",\n\n               codec_desc->name);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    if (!exact_match) {\n\n        if (fallback_allowed || !hwaccel_lax_profile_check) {\n\n            av_log(ctx, loglevel, \"No VAAPI support for codec %s \"\n\n                   \"profile %d.\\n\", codec_desc->name, avctx->profile);\n\n            if (!fallback_allowed) {\n\n                av_log(ctx, AV_LOG_WARNING, \"If you want attempt decoding \"\n\n                       \"anyway with a possibly-incompatible profile, add \"\n\n                       \"the option -hwaccel_lax_profile_check.\\n\");\n\n            }\n\n            err = AVERROR(EINVAL);\n\n            goto fail;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"No VAAPI support for codec %s \"\n\n                   \"profile %d: trying instead with profile %d.\\n\",\n\n                   codec_desc->name, avctx->profile, alt_profile);\n\n            av_log(ctx, AV_LOG_WARNING, \"This may fail or give \"\n\n                   \"incorrect results, depending on your hardware.\\n\");\n\n        }\n\n    }\n\n\n\n    ctx->va_profile = profile;\n\n    ctx->va_entrypoint = VAEntrypointVLD;\n\n\n\n    vas = vaCreateConfig(hwctx->display, ctx->va_profile,\n\n                         ctx->va_entrypoint, 0, 0, &ctx->va_config);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to create decode pipeline \"\n\n               \"configuration: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    hwconfig = av_hwdevice_hwconfig_alloc(ctx->device_ref);\n\n    if (!hwconfig) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    hwconfig->config_id = ctx->va_config;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->device_ref,\n\n                                                      hwconfig);\n\n    if (!constraints)\n\n        goto fail;\n\n\n\n    // Decide on the decoder target format.\n\n    // If the user specified something with -hwaccel_output_format then\n\n    // try to use that to minimise conversions later.\n\n    ctx->decode_format = AV_PIX_FMT_NONE;\n\n    if (ctx->output_format != AV_PIX_FMT_NONE &&\n\n        ctx->output_format != AV_PIX_FMT_VAAPI) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            if (constraints->valid_sw_formats[i] == ctx->decode_format) {\n\n                ctx->decode_format = ctx->output_format;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (output \"\n\n                       \"format).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise, we would like to try to choose something which matches the\n\n    // decoder output, but there isn't enough information available here to\n\n    // do so.  Assume for now that we are always dealing with YUV 4:2:0, so\n\n    // pick a format which does that.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            pix_fmt  = constraints->valid_sw_formats[i];\n\n            pix_desc = av_pix_fmt_desc_get(pix_fmt);\n\n            if (pix_desc->nb_components == 3 &&\n\n                pix_desc->log2_chroma_w == 1 &&\n\n                pix_desc->log2_chroma_h == 1) {\n\n                ctx->decode_format = pix_fmt;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (format \"\n\n                       \"matched).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise pick the first in the list and hope for the best.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        ctx->decode_format = constraints->valid_sw_formats[0];\n\n        av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (first in list).\\n\",\n\n               av_get_pix_fmt_name(ctx->decode_format));\n\n        if (i > 1) {\n\n            // There was a choice, and we picked randomly.  Warn the user\n\n            // that they might want to choose intelligently instead.\n\n            av_log(ctx, AV_LOG_WARNING, \"Using randomly chosen decode \"\n\n                   \"format %s.\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n        }\n\n    }\n\n\n\n    // Ensure the picture size is supported by the hardware.\n\n    ctx->decode_width  = avctx->coded_width;\n\n    ctx->decode_height = avctx->coded_height;\n\n    if (ctx->decode_width  < constraints->min_width  ||\n\n        ctx->decode_height < constraints->min_height ||\n\n        ctx->decode_width  > constraints->max_width  ||\n\n        ctx->decode_height >constraints->max_height) {\n\n        av_log(ctx, AV_LOG_ERROR, \"VAAPI hardware does not support image \"\n\n               \"size %dx%d (constraints: width %d-%d height %d-%d).\\n\",\n\n               ctx->decode_width, ctx->decode_height,\n\n               constraints->min_width,  constraints->max_width,\n\n               constraints->min_height, constraints->max_height);\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n\n\n    // Decide how many reference frames we need.  This might be doable more\n\n    // nicely based on the codec and input stream?\n\n    ctx->decode_surfaces = DEFAULT_SURFACES;\n\n    // For frame-threaded decoding, one additional surfaces is needed for\n\n    // each thread.\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n        ctx->decode_surfaces += avctx->thread_count;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n    vaDestroyConfig(hwctx->display, ctx->va_config);\n\n    av_freep(&profile_list);\n\n    return err;\n\n}\n", "idx": 12190, "substitutes": {"ctx": ["dc", "cb", "np", "conn", "tc", " cx", "cf", "voc", "cm", "ck", "cfg", "cam", "bc", "nc", "ct", "crit", "jac", "comm", "cu", "cc", "rc", "config", "cv", "cp", "obj", "setup", "cas", "conv", "act", "tx", "cmp", "mc", "req", "txt", "kt", "kw", "con", "Context", "xc", "pkg", "context", "pc", "vp", "wcs", "hw", "jp", "cmd"], "avctx": ["vrctl", "avconfig", "svtx", "hwconn", "vrtx", "camctx", "hwcomp", "evcomp", "avtx", "ravtx", " avconfig", "ravctx", "evtx", "vrcontext", "vrconn", "awctx", "ravcomp", "svctx", "hwtx", " avcontext", "camcontext", "awtx", "avcomp", "svcontext", "evctx", "camtx", "vrctx", "ravcontext", "awconfig", " avtx", "avctl", "svconn", "hwcontext", "camconfig", "avcontext", "evcontext", " avctl", "avconn", "awcontext", "hwctl"], "fallback_allowed": ["fallback2only", "fallback2enabled", "fallBack_only", "fallback2allowed", "fallback_forced", "fallback2forced", "fallback_defined", "fallBack_forced", "fallBack_defined", "fallBack_enabled", "fallback_enabled", "fallback_only", "fallBack_allowed"], "hwctx": ["fwcontext", "hwconn", "avconfig", "fwtx", "nwctx", "htconn", "fwctx", "himcp", "fwconfig", "iwcontext", "owconfig", "hwcp", "owconn", "htcfg", "iwconn", "iwpkg", "owctx", "hwpkg", "nwpkg", "hawcp", "iwctx", "hwtx", "htconfig", "iwcfg", "himctx", "iwconfig", "hawpkg", "fwcp", "iwtx", "avcfg", "owcfg", "fwcfg", "iwcp", "hawctx", "hwcfg", "himcontext", "hwcontext", "hawtx", "htctx", "avcontext", "himtx", "nwcp", "nwtx"], "hwconfig": ["htcfg", "iwcfg", "htconf", "iwconf", "fwConfig", "iwconfig", "fwconfig", "fwconf", "hwcfg", "htConfig", "hwConfig", "iwConfig", "fwcfg", "hwconf", "htconfig"], "constraints": ["contracts", "constaints", "contraints", "Constrains", "Constsaints", "constrains", "constracts", "contraint", "constsains", "constraint", "constsaints", "constsacts", "Constraint", "Constsaint", "Constraints", "constains", "constsaint", "constaint", "contrains", "Constracts", "Constsacts", "constacts", "Constsains"], "vas": ["camera", "nas", "cus", " cursor", "ega", " coord", " vers", "cam", " fs", "cfg", "vers", "ver", " tv", "buf", " os", " vac", "as", "menu", "scale", "cache", "eu", " canvas", "wcs", "caps", " stats", " ov", "ows", "jpg", "usa", "cu", "stack", "fs", "ja", "eas", "tx", " dc", "sc", "status", "res", "vs", "cs", "vis", "nexus", "pres", "cf", "result", " va", "VS", "va", "qa", "ea", "bridge", "ras", " ec", "can", "VA", "vid", "gc", "us", "jas", "conv", "rus", "ts", "rea", " cs", "pas", "vals", "save", "es", "na", "sts", "las", "area", " cac", "png", "css", "auc", " vis", "base", "bs"], "err": ["r", "or", "cli", "cr", "pr", "aaa", "dr", "conf", "die", "Er", "attr", "rank", "rr", "der", "test", "cfg", "fee", "str", "erer", "fr", "lr", "usr", "nr", "Error", "order", "resh", "buf", "obj", "count", "iter", "er", "gz", "ner", "render", "try", "ach", "y", "arr", "elt", "css", "fg", "fer", "mr", "gr", "oe", "kr", "br", "rn", "req", "inner", "resp", "error"], "i": ["ui", "di", "p", "ami", "x", "ir", "h", "init", "instance", "um", "v", "gi", "id", "ai", "ic", "iq", "ind", "l", "ii", "xi", "ji", "I", "sim", "phi", "ix", "iu", "ex", "multi", "bi", "in", "me", "remote", "my", "ie", "hi", "si", "index", "eu", "try", "li", "info", "y", "ini", "it", "ia", "ci", "c", "m", "chain", "ip", "mi", "ij", "zi", "ti", "im", "pi", "e", "ki", "ims"], "j": ["x", "ev", "json", "jc", "fr", "kj", "index", "def", "_", "FIG", "js", "c", "t", "jl", "dj", "uj", "k", "jp", "jj", "ng", "IA", "ja", "q", "IC", "it", "ij", "fail", "p", "job", "jit", "l", "bj", "o", "b", "g", "try", "tr", "y", "IF", "J", "br", "V", "e", "us", "att", "func", "aj", "pr", "oj", "C", "v", "jump", "z", "ji", "key", "n", "jo", "m"], "codec_desc": ["coddec_cmp", "coddec_desc", "codec_spec", "codecopdef", "codecopdes", "codec509des", "codec509cmp", "codecopdesc", "codec509set", "codoc_supp", "codoc_des", "coddec_set", "codec_set", "codoc_spec", "codec509desc", "codoc_description", "codec_description", "codecopdescription", "codec_def", "codec_des", "codoc_desc", "codec_supp", "coddec_des", "codec_cmp", "codoc_def"], "pix_desc": ["pix_vec", "pix__buf", "pix__desc", "pix_buf", "pfx_vec", "pfx_desc", "pfx_des", "pix__vec", "pix__des", "pix_des", "pfx_buf"], "pix_fmt": ["pix2flt", "pix2Flt", "pix2ftm", "pix_ttm", "pix_fdr", "pix_ftm", "pix_sflt", "pix_sfdr", "pix_Fdr", "pix_tmt", "pix_tlt", "pix2Ftm", "pix_Ftm", "pix2Fdr", "pix_sfmt", "pix2Fmt", "pix_Flt", "pix_Fmt", "pix_tdr", "pix_sftm", "pix_flt", "pix2fmt", "pix2fdr"], "profile": ["pro", "usage", "pr", "h", "instance", "prototype", "proc", "feature", "slot", "gpu", "type", "tree", "primary", "role", "settings", "pe", "include", "frame", "processor", "result", "image", "sample", "username", "depth", "family", "picture", "Profile", "component", "person", "key", "device", "policy", "summary", "line", "PRO", "properties", "prof", "property", "file", "history", "relation", "menu", "cache", "ph", "pse", "package", "user", "full", "node", "style", "header", "module", "priority", "prop", "pen", "phone", "volume", "alias", "filter", "buffer", "status", "port", "base", "po", "table", "cpu", "option", "description", "pi", "me", "spec", "plane", "fac"], "profile_list": ["Profile2lists", " profile_no", "profile_group", "profile_set", "Profile_lists", "prof_LIST", "profile_no", "profile2List", " profile_dict", "Profile_List", " profile_lists", "profile12no", " profile_listed", "prof_list", "profile_listed", "profile_lists", "profile2lists", "profile_dict", "profile_LIST", "profile12count", "profile8group", "profile_List", "Profile2List", "profile8list", "profile12list", " profile_LIST", "Profile2list", "profile2list", " profile_group", "prof_set", "profile8count", "profile12listed", "Profile_list"], "profile_count": ["projectCountcount", "project_length", "profileCountcheck", "sample_Count", "profile12log", "profile00list", "profile_match", "profile2length", "user_label", "profile2count", "user_count", "profile12length", " profile_length", "profile2max", " profile2base", " profile2max", "profileCountcount", "profile_length", "profile00label", "profile00count", "user_list", "profile32max", "profileCountbase", "profile2log", "profile32base", " profile2count", "project_check", "profile32count", " profile_base", "profile_max", "sample_index", "profile_check", "project_max", "user_found", " profile2length", "profile12count", "sample_count", "profile32list", " profile2list", "projectCountcheck", "profile2base", " profile2log", "profile_index", "projectCountmax", "profileCountlist", "profile_Count", "profile_base", " profile_log", "projectCountlength", "profileCountmax", "profile_label", "profile12list", "profile12max", " profile_max", "profile2list", "sample_match", "profile_found", "profile_log", "project_count", "profile00found", "profile12check", "profileCountlength"], "exact_match": ["exactly_Match", "exact_Match", "exical_match", "exactisticmatch", "exactly_count", "exactisticmessage", "exact0error", "exical0met", "exact0met", "exical_met", "exactly_message", "exical_count", "exact_met", "exact0match", "exical_error", "exactly_match", "exact_message", "exactisticMatch", "exical0count", "exact_error", "exact0count", "exical0error", "exical0match", "exact_count", "exactisticcount"], "alt_profile": ["altacksample", "alt_sample", "alt_project", "alt__sample", "altackprof", "alt_prof", "alt__prof", " alt_project", "alt__project", " alt_prof", "altackproject", " alt_sample", "alt__profile", "altackprofile"]}}
{"project": "FFmpeg", "commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "target": 0, "func": "static int parse(AVCodecParserContext *ctx,\n\n                 AVCodecContext *avctx,\n\n                 const uint8_t **out_data, int *out_size,\n\n                 const uint8_t *data, int size)\n\n{\n\n    VP9ParseContext *s = ctx->priv_data;\n\n    int marker;\n\n\n\n    if (size <= 0) {\n\n        *out_size = 0;\n\n        *out_data = data;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (s->n_frames > 0) {\n\n        *out_data = data;\n\n        *out_size = s->size[--s->n_frames];\n\n        parse_frame(ctx, *out_data, *out_size);\n\n\n\n        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;\n\n    }\n\n\n\n    marker = data[size - 1];\n\n    if ((marker & 0xe0) == 0xc0) {\n\n        int nbytes = 1 + ((marker >> 3) & 0x3);\n\n        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;\n\n\n\n        if (size >= idx_sz && data[size - idx_sz] == marker) {\n\n            const uint8_t *idx = data + size + 1 - idx_sz;\n\n            int first = 1;\n\n\n\n            switch (nbytes) {\n\n#define case_n(a, rd) \\\n\n            case a: \\\n\n                while (n_frames--) { \\\n\n                    int sz = rd; \\\n\n                    idx += a; \\\n\n                    if (sz > size) { \\\n\n                        s->n_frames = 0; \\\n\n                        av_log(avctx, AV_LOG_ERROR, \\\n\n                               \"Superframe packet size too big: %d > %d\\n\", \\\n\n                               sz, size); \\\n\n                        return AVERROR_INVALIDDATA; \\\n\n                    } \\\n\n                    if (first) { \\\n\n                        first = 0; \\\n\n                        *out_data = data; \\\n\n                        *out_size = sz; \\\n\n                        s->n_frames = n_frames; \\\n\n                    } else { \\\n\n                        s->size[n_frames] = sz; \\\n\n                    } \\\n\n                    data += sz; \\\n\n                    size -= sz; \\\n\n                } \\\n\n                parse_frame(ctx, *out_data, *out_size); \\\n\n                return *out_size\n\n\n\n                case_n(1, *idx);\n\n                case_n(2, AV_RL16(idx));\n\n                case_n(3, AV_RL24(idx));\n\n                case_n(4, AV_RL32(idx));\n\n            }\n\n        }\n\n    }\n\n\n\n    *out_data = data;\n\n    *out_size = size;\n\n    parse_frame(ctx, data, size);\n\n\n\n    return size;\n\n}\n", "idx": 12192, "substitutes": {"ctx": ["p", "cb", "x", "wd", "np", "conn", "tc", " cx", "cf", "cm", "ck", "tz", "bc", "ct", "jac", "cn", "cu", "cc", "unc", "cv", "obj", "cp", "config", "cas", "ctl", "conv", "ac", "gz", "kh", "kl", "act", "kb", "kk", "tx", "cmp", "ca", "sys", "req", "c", "kt", "sc", "kw", "aus", "resp", "xc", "pkg", "context", "pc", "ctr", "k", "hw", "gc", "jp", "cmd"], "avctx": ["avclient", "ajclient", "Avcontext", "avjs", "ajctx", " avclient", "Avjs", " avjs", "Avclient", "avcontext", "Avctx", "ajcontext", " avcontext", "ajjs"], "out_data": ["outmemdata", "net_data", "outmemDATA", " out_dat", "out__data", "in_data", "outmopsize", "out_source", "out__size", "out_body", "out_details", "full_div", " out_body", "net_size", "in_size", "fullmopdata", "out__Data", "net_source", "outmopdiv", "out__dat", "out_DATA", "in_bytes", " out_details", "full_size", "fullmopdiv", " out_Data", "outmopdata", "out_Data", "out_div", "out_bytes", " out_bytes", "full_data", "fullmopsize", "outmemsource", "net_DATA", "outmemsize", "out_dat"], "out_size": ["window_message", "out_score", "Out_width", "out_height", "out_length", "in_name", "out_ize", "out_width", "out_SIZE", " out_len", "window_size", "outptsize", "out_speed", "Out_shape", "in_size", "outptscore", "out_message", "in_length", "Out_ize", "n_height", " out_speed", "window_ize", "out_shape", "n_SIZE", "n_size", " out_length", "outptize", " out_SIZE", "out_len", " out_name", "Out_size", "window_score", "outptmessage", "out_name"], "data": ["extra", "snap", "no", "x", "type", "number", "maybe", "buf", "d", "index", "cache", "def", "to", "empty", "ref", "this", "text", "t", "byte", "len", "mu", "rel", "done", "value", "name", "root", "raw", "all", "a", "info", "package", "tx", "buffer", "block", "inner", "table", "p", "i", "ata", "missing", "padding", "str", "window", "only", "at", "record", "pointer", "video", "values", "bytes", "none", "any", "mode", "stream", "length", "list", "DATA", "next", "read", "format", "Data", "form", "file", "dat", "partial", "offset", "rew", "message", "image", "zero"], "size": ["vector", "type", "number", "capacity", "shift", "range", "total", "count", "south", "scale", "index", "cache", "to", "empty", "now", "ize", "mark", "sum", "len", "se", "value", "speed", "fee", "name", "code", "small", "new", "rate", "notice", " Size", "shape", "negative", "set", "max", "power", "yes", "body", "buffer", "status", "SIZE", "storage", "scope", "send", "final", "member", "sp", "padding", "l", "window", "position", "space", "time", "g", "is", "false", "sn", "style", "mode", "e", "length", "equal", "write", "timeout", "from", "v", "z", "format", "network", "height", "content", "n", "zone", "Size", "offset", "last", "num", "normal", "message", "address", "zero"], "s": ["self", "ts", "p", "changes", "h", "sb", "sets", "ats", "sw", "ses", "rs", "v", "ls", "ss", "its", "es", "als", "ps", "xs", "gs", "aws", "comm", "sts", "tests", "parts", "ess", "sq", "checks", "fs", "sv", "sl", "is", "actions", "g", "details", "os", "set", "sys", "js", "hs", "ds", "ssl", "stats", "m", "S", "c", "states", "t", "comments", "cs", "ims", "bs", "w", "qs", "ns"], "marker": ["markter", "arker", "signater", "maskter", "misser", "signner", "locner", "Markener", "arkter", "markaster", "arkt", " markt", "markin", "signER", " markner", "markt", "masker", "Markder", "markater", "Markt", "arkER", "Markiner", "arkar", "maskar", "locaster", "missater", "maskener", "markder", "signiner", "signarer", " markER", " markiner", " markter", "misster", " markaster", "arkder", "markar", "markER", "markiner", "mixarer", "mixER", "arkener", "Markin", "maskater", "markarer", "maskin", " markder", "Markar", " markarer", " markin", "maskiner", "signaster", "locater", "signer", "Markter", " markater", "MarkER", "missener", "maskER", "Markater", "markner", "mixer", "locer", "mixiner", "Marker", "markener"], "idx": [" idct", " idn", "catxes", "indb", "Idv", "IDdx", "idb", "indxes", "indy", "IDx", "inz", " idb", "Idex", "midz", "idex", "iddx", " idxes", "IDy", " idex", "Idix", " idxs", "Iddx", "catxs", "iden", "midix", "idct", "inn", "indxs", "midx", " idz", " idy", "Idz", "idix", " idix", "catx", "IDix", " idv", "inx", "idect", "midex", "IDv", "Idx", "idxs", "indx", "idxes", " iddx", "IDz", "catb", "idez", "idn", "idy", "Idxs", "inct", "idz", "indz", "idv", "Idy"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n", "idx": 12200, "substitutes": {"dev": ["pro", "p", "wd", "DEV", "Dev", "conn", "ev", "mem", "proc", "v", "dd", "de", "cam", "priv", "pad", "ver", "window", "raw", "debug", "device", "ve", "obj", "des", "cast", "devices", "md", "serv", "app", "def", "dem", "ow", "var", "info", "iv", "sd", "go", "gu", "adv", "ds", "Device", "dis", "ad", "doc", "hw", "w"], "d": ["r", "di", "done", "p", "ld", "dc", "dr", "od", "dx", "nd", "bd", "D", "f", "v", "du", "dd", "de", "args", "dm", "dom", "gd", "dp", "ind", "l", "dict", "str", "j", "dt", "dos", "n", "o", "da", "md", "did", "b", "dh", "dat", "dim", "fd", "drivers", "y", "sd", "dra", "dn", "ds", "dis", "c", "dj", "ad", "db", "ord", "e", "ded", "w", "mod"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 12205, "substitutes": {"d": ["r", "di", "p", "dc", "ld", "dev", "dr", "dump", "dx", "bd", "D", "dq", "df", "du", "dd", "de", "dm", "data", "gd", "dp", "ind", "l", "dl", "dt", "debug", "dos", "pd", "da", "md", "b", "did", "dh", "dat", "fd", "info", "sd", "dra", "dn", "ds", "it", "m", "c", "t", "ad", "db", "ord", "rd"], "val": ["pol", "al", "p", "util", "x", "pr", "vals", "pl", "Val", "value", "v", "ret", "vol", "bal", "sil", "data", "test", " data", "sel", "fee", "ul", "pt", "crit", "cond", " eval", "aval", "all", " VAL", "buf", "vt", "sl", "b", "ival", "serv", " al", " v", " value", "tx", "elt", "eval", "ref", "set", "max", "bit", "vec", "prop", "cal", "VAL", "t", "loc", "valid", "cho", "pal", "el", "il", "rel", "ac"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 12215, "substitutes": {"f": ["r", "self", "p", "h", "bf", "um", "cf", "ft", "df", "i", "ff", "ret", "z", "fc", "l", "rf", "lf", "fr", "uf", "fo", "new", "fb", "fs", "b", "file", "form", "d", "ac", "fm", "fd", "of", "full", "fx", "af", "q", "fe", "fp", "tf", "fi", "F", "m", "c", "t", "e", "fac", "w", "fw"], "v": ["p", "av", "x", "h", "inv", "um", "ev", "value", "i", " iv", "vol", "version", "l", "ver", "j", "qv", "vm", "val", "va", "u", "NV", "n", "ve", "cv", "o", "size", "sv", "vt", "b", "vv", "d", "values", "tv", " i", "get", "iv", "q", "vi", "V", "uv", "c", "m", "wire", "vd", "nv", "vs", "vc", " n", "lv", "k", "vp", "w", "conv"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n\n{\n\n    int i, len, sz;\n\n    GetBitContext gb;\n\n    int code_table[64];\n\n\n\n    /* get the rle codes (at most 64 bytes) */\n\n    init_get_bits(&gb, src, 64 * 8);\n\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n\n        code_table[i] = get_sbits(&gb, 4);\n\n        sz += FFABS(code_table[i]);\n\n    }\n\n    src += (get_bits_count(&gb) + 7) / 8;\n\n\n\n    /* do the rle unpacking */\n\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n\n        len = code_table[i];\n\n        if (len < 0) {\n\n            len = -len;\n\n            memset(dst, *src++, FFMIN(len, dst_size));\n\n        } else {\n\n            memcpy(dst, src, FFMIN(len, dst_size));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n        dst_size -= len;\n\n    }\n\n    return src;\n\n}\n", "idx": 12216, "substitutes": {"src": ["sb", "bin", "sur", "ls", "url", "ind", "fr", "rc", "buf", "sys", "now", "source", "loc", "ptr", "ins", "sync", "insert", "addr", "cont", "ser", "code", "stack", "sq", "obj", "scan", "hl", "rt", "ctrl", "req", "txt", "buffer", "sc", "bg", "sub", "init", "sel", "cur", "str", "start", "th", "sr", "slice", "out", "tmp", "iter", "sec", "bytes", "st", "s", "copy", "sn", "input", "fp", "stream", "RC", "ctr", "comp", "conv", "r", "dist", "cb", "rs", "read", "syn", "fc", "rec", "bc", "usr", "in", "rl", "inst", "iv", "offset", "uv", "usc", "dest", "img"], "dst": ["sdsts", "sdpt", "sdst", "Dost", "dsdest", "deost", " dest", "sdht", "ddest", "Dest", " dend", "Dpt", "dssts", "Dst", "dsest", "dend", "dsput", "sdest", "dht", "dpt", "Ddest", "dsst", " dht", "deest", "dput", "dsts", "Dend", "deend", "Dsts", " dpt", " dost", " ddest", "dost", "dest", "sdput", " dput", " dsts", "dsht"], "dst_size": ["dst__capacity", "dost__SIZE", "dst_num", "dbr_Size", "dost_capacity", "ddest_scope", "dst_shape", "dint_sum", "dbr_time", "dst_group", "dpt_size", "ddest_max", "dbr_size", "dost__capacity", "dost_SIZE", "dtd_block", "dpt_SIZE", "dst_style", "dst_block", "dst__size", "dst_time", "dint_SIZE", "dst_max", "dbr_num", "dst_scope", "dst_SIZE", "dost__size", "dst_sum", "dst_capacity", "dtd_group", "dpt_offset", "dint_size", "dpt_style", "dtd_size", "dost_size", "dst_offset", "dst__SIZE", "ddest_size", "dint_shape", "dst_Size"], "i": ["ami", "cli", "x", " ti", " ii", "ind", "ix", "iu", "bi", "PI", "remote", "index", "li", "\u0438", "this", "io", "t", "batch", "ti", "series", "sync", "gi", "ic", "ei", "I", "phi", "info", " bi", "q", "it", "qi", "mi", "ij", "status", "cgi", "asi", "ki", "ims", "me", "ui", "p", "span", "yi", "uri", "l", "xi", "sim", "oi", "multi", "o", "is", "y", "ini", "fi", "ci", "chain", "pi", "e", "r", "di", "list", "v", "ri", "ai", "ii", "j", "ji", "iy", "n", "si", "m", "zi", "ip", " j", "point", "im", "client", "ski"], "len": ["limit", "tl", "ls", "loss", "compl", "ul", "en", "nl", "total", "li", "loc", "ll", "L", "el", "del", "rel", "von", "mem", "lf", "lang", "lc", "all", "lt", "sl", "gz", "kl", "hl", "tail", "lis", "lan", "msg", "low", "gl", "lim", "html", "lp", "Len", "l", "deg", "size", "iter", "fl", "elt", "cmp", "vec", "lon", "length", "rot", "lib", "ld", "pl", "list", "rev", "repl", "z", "syn", "ln", "ler", "dl", "val", "n", "lit", "full", "fin", "pos", "alt", "spec", "il"], "sz": [" sZ", "asz", "tsz", "esld", "sze", "tszi", "sszi", "szi", "ssiz", "tsiz", "ssz", "rszip", " szi", "esz", "sZ", "tesz", "esze", "asze", "ssZ", "rszi", "asld", " siz", " sld", "tesiz", "asnz", "esnz", "gesz", "snz", " szip", "rszh", "sld", "geszi", " sze", " szh", "rsz", "siz", "tsZ", "gesiz", "teszip", "szh", "szip", "geszh", "teszi", " snz", "rsiz"], "gb": [" GB", "GB", "cb", "bf", "sb", "gif", "git", "nb", "ubi", "cfg", "gd", "pg", "vg", "cd", "gs", "gt", "uf", "eg", "bb", "vm", " rgb", "rg", "cv", "rl", "tmp", "buff", "bt", "g", "Gb", "b", "mb", "hub", "bs", "kb", "gm", "gin", "fg", "bridge", "fi", "tg", "bits", "cgi", "db", "rb", "yg", "bg", "ruby", "gc", "gg", "bm", "lib", "by"], "code_table": [" code_collection", "code_tmp", "code2TABLE", "code_Table", "code__buffer", " code_TABLE", "code2buffer", " code_buffer", "codeptTABLE", "codeptpool", "code__map", "code_cache", "codematpool", " code_cache", "code2entry", "change_tmp", " code_entry", "code_map", "change_TABLE", "code_collection", "code2map", "code__entry", "change_table", "code2Table", "change_angle", "code2table", "codeptcollection", "codematcollection", "code_entry", "code_pool", "code2cache", "codematTABLE", "code_buffer", "code_TABLE", "codepttable", " code_pool", " code_Table", "code__table", "code_angle", " code_map", "codemattable"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 12243, "substitutes": {"candidate": [" candeter", "candeter", "Candidates", "Candate", " Candate", "centidates", "formeter", "centate", " Candidate", "resulteter", "candiate", "resulticate", "resultiate", " Candidates", "Candiate", "formiate", "Candidate", "formidate", " candiate", "centidate", " Candiate", "resultidate", "candicate", "formicate", "centiate", " candicate", "candidates", "candate"], "bs": ["ts", "sb", "uts", "bos", "BS", "pb", "es", "its", "bp", "bc", "obs", "ps", "gs", "Bs", "bb", "ubs", "sts", "bl", "ib", "bi", "bh", "fs", "bt", "b", "lbs", "is", "ics", "bsp", "os", "ms", "bas", "bis", "js", "sys", "ists", "bits", "bg", "vs", "cs", "us", "bm", "ns"], "it": ["att", "al", "p", "ot", "h", "ir", "ITS", "init", "i", "exec", "ic", "its", "ind", "wait", "l", "ul", "j", "mit", "hit", "quit", "bl", "at", "ex", "ib", "out", "in", "n", "iti", "iter", "bt", "g", "pit", "lit", "ut", "sit", "ait", "q", "lat", "It", "ists", "t", "ip", "est", "ist", "im", "itted", "iz", "IT", "item", "il"], "perm": ["pol", "p", " permission", "prem", "mm", "pl", "pr", " permits", "proc", "imp", "acc", "em", "attr", " cond", "pp", " perf", "priv", "por", "mod", "rep", "rpm", "cum", "comm", "unc", "xp", "cp", "tmp", "mission", "mut", "emp", "prof", " permitted", " imp", "mb", "lem", "pty", "dem", "pers", "marg", " sec", "m", "req", "mp", "prop", "prom", "mi", "per", "cert", "prime", "pc", "ptr", "fac", "ms", "msg", "jp", "pri"]}}
{"project": "qemu", "commit_id": "f4bf56fb78ed0e9f60fa1ed656c14ff4c494da5a", "target": 1, "func": "static int vhost_user_set_mem_table(struct vhost_dev *dev,\n\n                                    struct vhost_memory *mem)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    int i, fd;\n\n    size_t fd_num = 0;\n\n    bool reply_supported = virtio_has_feature(dev->protocol_features,\n\n                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);\n\n\n\n    VhostUserMsg msg = {\n\n        .hdr.request = VHOST_USER_SET_MEM_TABLE,\n\n        .hdr.flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (reply_supported) {\n\n        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;\n\n    }\n\n\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        ram_addr_t offset;\n\n        MemoryRegion *mr;\n\n\n\n        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);\n\n        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,\n\n                                     &offset);\n\n        fd = memory_region_get_fd(mr);\n\n        if (fd > 0) {\n\n            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;\n\n            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;\n\n            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;\n\n            msg.payload.memory.regions[fd_num].mmap_offset = offset;\n\n            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);\n\n            fds[fd_num++] = fd;\n\n        }\n\n    }\n\n\n\n    msg.payload.memory.nregions = fd_num;\n\n\n\n    if (!fd_num) {\n\n        error_report(\"Failed initializing vhost-user memory map, \"\n\n                     \"consider using -object memory-backend-file share=on\");\n\n        return -1;\n\n    }\n\n\n\n    msg.hdr.size = sizeof(msg.payload.memory.nregions);\n\n    msg.hdr.size += sizeof(msg.payload.memory.padding);\n\n    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);\n\n\n\n    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (reply_supported) {\n\n        return process_message_reply(dev, &msg);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12245, "substitutes": {"dev": ["att", "pro", "av", "develop", "conf", "DEV", "conn", "ev", "proc", "Dev", "eng", "build", "v", "de", "addr", "test", "data", "cam", "serial", "priv", "pad", "boot", "ver", "env", "debug", "device", "nt", "des", "devices", "md", "d", "app", "scan", "def", "handle", "os", "var", "info", "van", "sd", "development", "go", "adv", "prop", "disk", "ad", "db", "det", "doc", "ram", "host", "hw", "w", "cmd"], "mem": ["lim", "mm", "usage", "nom", "tem", "em", "master", "addr", "alloc", "hist", "tm", "stat", "emb", "Mem", "am", "access", "map", "program", "rem", "rm", "store", "temp", "Memory", "buff", "md", "serv", "my", "met", "core", "mb", "mt", "cache", " Mem", "phys", "tx", "ref", "sys", "m", "mi", "buffer", "res", "sum", "loc", "memory", "gc", "mu", "ram", "doc", "hw", "ms", "storage", "msg"], "fds": [" fDs", "alfd", "fdos", "frdos", "efrs", "frs", "hds", "alfDs", "effs", "fuds", " fdos", "efds", "alfdos", "efuds", "hrs", " fuds", " frs", "ffs", "frds", "huds", "fDs", "hfs", " ffs", "alfds", "frd", "frDs"], "i": ["ui", "di", "p", "x", "init", " ti", "f", "v", "gi", "id", "ic", "ai", " ii", "ind", "ei", "ii", "j", "xi", "sim", "I", "l", "phi", "ix", "iu", "oi", "multi", "bi", "n", "in", "o", "g", "ie", "si", "index", "li", "y", "ini", "it", "ia", "ci", "m", "io", "c", "t", "ip", "mi", "zi", " j", "chain", "ij", "ti", "im", "pi", "e", "k"], "fd": ["func", "bf", "nd", "ft", "cf", "fun", "df", "f", "ff", "fat", "dd", "gd", "fc", "lf", "fr", "dl", "hd", "dt", "fb", " fid", "FF", "fa", "tif", "fs", "td", "fn", "d", "dir", "file", "fm", "index", "FD", "fl", "sd", "ini", "elt", "fe", "ffff", "fp", "fi", "ds", "fin", "draw", "db", "ptr"], "reg": ["r", "pr", "dr", "rom", "conn", "rs", "tag", "region", "rr", "repl", "ret", "addr", "err", "rule", "re", "rec", "disc", "mod", "eg", "gra", "org", "rem", "debug", "rm", "rg", "config", "gro", "g", "form", "app", "mb", "sam", "Reg", "act", "mn", "ro", "arr", "ref", "gr", "go", "rar", "br", "req", "roy", "res", "loc", "arch", "REG", "resp", "gc", "ram", "msg", "arg", "rel", "cmd"], "offset": ["mm", "extra", "off", "slot", "attr", "f", "err", "coord", "addr", "alloc", "data", "location", "seed", "padding", "meta", "map", "start", "window", "position", "shift", "key", "order", "owner", "origin", "o", "size", "tmp", "pointer", "area", "mt", "index", "offs", "mb", "field", "ms", "ref", "fp", "reset", "Offset", "pos", "len", "loc", "row", "mid", "ptr", "address", "length", "error"], "mr": ["r", "igr", "pr", "cr", "hr", "dr", "rs", "irm", "rr", "ar", "cm", "mor", "vr", "Mr", "lr", "nr", "ml", "rm", "sr", "rg", "rl", "RM", "er", "mt", "shr", "ur", "mk", "tr", "rt", "gr", "rar", "mer", "kr", "adr", "rn", "mc", "m", "br", "mx", "ocr", "MR", "bm", "mn", "drm"]}}
{"project": "FFmpeg", "commit_id": "fa74cdc60d19798c951dcc242ca7273e6483f2b3", "target": 1, "func": "int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size,\n                     int64_t pts, int64_t dts, int64_t pos)\n{\n    int index, i;\n    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];\n    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {\n        s->next_frame_offset =\n        s->cur_offset        = pos;\n        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;\n    }\n    if (buf_size == 0) {\n        /* padding is always necessary even if EOF, so we add it here */\n        memset(dummy_buf, 0, sizeof(dummy_buf));\n        buf = dummy_buf;\n    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */\n        /* add a new packet descriptor */\n        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);\n        s->cur_frame_start_index = i;\n        s->cur_frame_offset[i]   = s->cur_offset;\n        s->cur_frame_end[i]      = s->cur_offset + buf_size;\n        s->cur_frame_pts[i]      = pts;\n        s->cur_frame_dts[i]      = dts;\n        s->cur_frame_pos[i]      = pos;\n    }\n    if (s->fetch_timestamp) {\n        s->fetch_timestamp = 0;\n        s->last_pts        = s->pts;\n        s->last_dts        = s->dts;\n        s->last_pos        = s->pos;\n        ff_fetch_timestamp(s, 0, 0, 0);\n    }\n    /* WARNING: the returned index can be negative */\n    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,\n                                    poutbuf_size, buf, buf_size);\n    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes\n    /* update the file pointer */\n    if (*poutbuf_size) {\n        /* fill the data for the current frame */\n        s->frame_offset = s->next_frame_offset;\n        /* offset of the next frame */\n        s->next_frame_offset = s->cur_offset + index;\n        s->fetch_timestamp   = 1;\n    }\n    if (index < 0)\n        index = 0;\n    s->cur_offset += index;\n    return index;\n}", "idx": 12255, "substitutes": {"s": ["changes", "sb", "ses", "ls", "end", "xs", "aws", "comm", "sv", "er", "as", "rest", "sam", "_", "bis", "js", "sys", "c", "https", "source", "ags", "state", "ms", "se", "w", "ins", "ns", "less", "search", "sync", "h", "ats", "conf", "sw", "settings", "ers", "ps", "acs", "new", "http", "raw", "terms", "parts", "sq", "obj", "fs", "a", "serv", "set", "into", "stats", "ds", "ssl", "comments", "sc", "services", "vs", "cs", "ims", "ports", "p", "aunts", "ar", "its", "ties", "sports", "ops", "ex", "tests", "store", "is", "g", "b", "eps", "os", "y", "hs", "spec", "sql", "r", "ts", "func", "rs", "save", "v", "ss", "es", "als", "re", "z", "call", "gs", "j", "sts", "n", "details", "states", "m", "S", "bits", "bs", "qs"], "avctx": ["avertmp", " avcc", "avcc", "AVcontext", "averctx", "averpkg", "avercc", "avercontext", " avcon", " avcontext", "AVcc", "AVpkg", "AVtmp", "avercon", "AVctx", "avpkg", "avcon", " avtmp", "avtmp", "avcontext", " avpkg", "AVcon"], "poutbuf": ["pinbuffer", "potvec", "spotuf", "poutvec", "pendbuf", "spoutbuf", "spoutvec", "pendvec", " pOutbuf", "spotbuf", "pOutqueue", "penduf", "potbuf", " pOutqueue", " pOutuf", "pinqueue", "spoutbuffer", "spotvec", "pinuf", "pOutbuffer", " poutqueue", "pinbuf", "potbuffer", "poutbuffer", " pOutbuffer", "pinvec", "pendbuffer", " poutbuffer", "potqueue", "poutqueue", " poutuf", "pOutbuf", "spotbuffer", "pOutuf", "poutuf", "spoutuf", "potuf"], "poutbuf_size": ["poutqueue2size", "poutbuf0size", "poutqueue_size", "poutqueue_SIZE", "poutbuffer_Size", "poutbuf_length", "poutqueue2Size", "poutbuffer_size", "poutqueue2dim", "poutbuf2size", "poutbuf_dim", "poutqueue_len", "poutbuf2Size", "poutbuf_len", "poutbuf0Size", "poutqueue_dim", "poutbuf2dim", "poutbuf_SIZE", "poutbuffer_SIZE", "poutqueue_Size", "poutbuf0dim", "poutbuf_Size", "poutbuffer_length"], "buf": ["p", "cb", "bf", "h", "mem", "bin", "cap", "ff", "grab", "pb", "data", "bc", "str", "uf", "map", "raw", "fb", "out", "bag", "cv", "bar", "cp", "pool", "tmp", "buff", "cast", "b", "bytes", "cache", "foo", "queue", "ref", "Buff", "vec", "br", "wb", "box", "buffer", "block", "batch", "rb", "port", "db", "doc", "ptr", "Buffer", "conv", "cmd"], "buf_size": [" buffer_sync", " bufferseqsync", "bufINGsize", "buffer_Size", "buffer_SIZE", "buf_length", "uf_length", "buffer_count", "uf_size", " buf_time", "buf2sync", "buf_sw", "bufINGchain", " buffer_SIZE", "buf_count", "buf_SIZE", "buf_chain", "buf2size", " bufferseqsize", "buf2SIZE", "bufINGsw", "uf_sw", "bufseqsize", " buf_count", "buf_Size", " buf_SIZE", "buffer_size", "bufseqsync", " bufferseqSIZE", "bufseqSIZE", "uf_Size", "uf_chain", "uf_SIZE", "buf_sync", " buffer_size", "bufINGSize", "buf_time"], "pts": ["ointjs", "cmdids", "pkgss", "ptts", "ptds", "pps", "PTets", "points", "PTts", "pkgts", "oints", "ptjs", "ointets", "apts", "PTjs", "ppts", "PTs", "ointts", "cmdjs", "ptss", "pointids", "ptids", "pkgs", "ppss", "ptets", "pointts", "aptss", "ptrs", "cmdets", "aptts", "aptds", "cmdts", "pkgds", "ptrns", "ppds", "cmds", "cmdns", "ptrts", "pointns", "ptrids", "ptns"], "dts": ["pjs", "pps", "edms", "pms", "edts", "gdjs", "gdcs", "mdts", "mps", "dps", " dTS", "dcs", "mdcs", "gdps", "edcs", "djs", "dTS", " dcs", "dms", "mdps", "pTS", "mts", " dps", " dms", "gdts", "mdTS", "pcs", "mjs", "mcs", "edps"], "pos": ["pro", "p", "limit", "no", "neg", "off", "pres", "proc", "tag", "pid", "op", "pb", "pose", "add", "end", "pt", "lang", "ps", "prot", "cond", "Pos", "start", "position", "mos", "origin", "o", "size", "tmp", "mon", "pointer", "win", "def", "os", "to", "set", "ref", "lat", "offset", "oss", "gen", "body", "top", "POS", "len", "res", "port", "loc", "po", "base", "point", "nos", "resp", "pi", "pc", "doc", "spec", "length", "rot", "bits"], "index": ["active", "x", "no", "timeout", "value", "f", "success", "id", "frame", "number", "length", "ind", "connect", "result", "j", "ion", "code", "position", "Index", "val", "key", "out", "n", "size", "count", "seek", "pointer", "d", "si", "of", "negative", "set", "offset", "find", "c", "num", "len", "status", "loc", "point", "row", "IND", "e", "state", "address", "zero", "error"], "i": ["ui", "di", "p", "cli", "x", "init", "uri", "f", "v", "gi", "ri", "id", "ai", "ic", "ind", "ei", "ii", "j", "xi", "I", "phi", "ix", "iu", "oi", "multi", "bi", "n", "iter", "a", "is", "g", "hi", "si", "li", "info", "y", "ini", "fi", "vi", "it", "ci", "m", "io", "qi", "mi", "ij", "ip", "zi", "chain", "ti", "im", "pi", "e", "ori"], "dummy_buf": ["duffy_pg", "dummyedcur", "dummyedpg", "duffy_buff", "dummy_cmd", "dancy_uf", "dummy___uf", "duffy_pb", "dummy_cur", "dummy___buff", "duffy_uf", "duffy_cur", "dummy_pb", "dummy_buff", "dancy_buf", "duffy_buf", "dummy_pg", "dummy_buffer", "dummy___cmd", "dummyedbuf", "dummy_uf", "dummyeduf", "duffy_cmd", "dancy_buff", "dancy_buffer", "dummy___buf"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 12257, "substitutes": {"client": ["util", "controller", "session", "cli", "co", "public", "conn", "private", "ic", "handler", "connection", "contact", "cell", "connect", "network", "call", "cl", "window", "google", "http", "component", "close", "api", "config", "server", "Client", "remote", "bound", "core", "net", "cache", "local", "node", "force", "ce", "open", "c", "manager", "cod", "current", "con", "context", "grid"], "sector_num": ["sector_hom", "sector_Num", "ceiver_num", "sectoracnum", "sector_mon", "ceiverlysym", "ector_Num", "ector_mon", "ceiver_index", "sectoracNum", "sectorlynum", "sectorlyindex", "sector_index", "sectorlysym", "ceiverlyindex", "sectoracsym", "ector_hom", "ceiverlynum", "sector_sym", "ceiverlyNum", "sectorlyNum", "ceiver_Num", "sectoracindex", "ector_num", "ceiver_sym"], "nb_sectors": ["nb_secs", "nb_vevers", "nb_vectors", "nb_pevers", "nb_psevers", "nb_pecs", "nb_severs", "nb_peors", "nb_specs", "nb_psectors", "nb_vecs", "nb_pelements", "nb_seors", "nb_pseors", "nb_spegments", "nb_segments", "nb_velements", "nb_spectors", "nb_speors", "nb_veors", "nb_selements", "nb_pegments", "nb_vegments", "nb_pectors", "nb_pselements"], "qiov": ["qiva", "quiov", "koj", "kiov", "chconv", "quiop", "chiev", "choj", "qiop", "qiv", "chiov", "kiv", "chiva", " qiv", " qiop", "chiv", "qiev", "qoj", "quconv", "quiva", "chiop", " qoj", " qiva", " qconv", " qiev", "kiev", "qconv"], "offset": ["off", "timeout", "slot", "from", "addr", "offer", "id", "oid", "end", "location", "seed", "pad", "padding", "start", "shift", "origin", "o", "size", "seek", "pointer", "index", "encrypted", "set", "style", "ref", "reset", "Offset", "pos", "num", "et", "len", "ta", "base", "point", " off", " offsets", "address", "error"], "request": ["QUEST", "update", "condition", "rank", "type", "transfer", "worker", "create", "change", "over", "print", "index", "parse", "task", "quest", "reference", "requ", "child", "cmd", "search", "public", "select", "rule", "new", "root", "order", " query", " requesting", " requested", "begin", "core", "match", "package", "attribute", "q", "req", " argument", "report", "common", "pair", "frame", "command", "import", "process", "record", " attempt", "setup", "execute", "complete", "push", "copy", "input", "project", "claim", "art", "document", "from", "add", "call", "question", "query", "work", "suggest", "param", "reset", "forward", "Request", " req", "point", " command", "message", "xml", "address", "response"], "reply": ["r", "report", "write", "send", "respond", " Reply", "ror", "comment", "next", "tree", "rr", "repl", "err", "transfer", "link", "bill", "vote", "output", "related", "command", "result", "dict", "proxy", "bb", "route", "error", "nl", "out", "notice", "tmp", "post", "service", "b", "back", "relation", "match", "apply", "bool", "try", "info", "force", "sett", "echo", "translation", "replace", "part", "body", "status", "callback", "table", "resp", "message", "ply", "Reply", "onse", "answer", "state", "ish", "response"], "ret": ["r", "report", "ts", "limit", "att", "flag", "RET", "mem", "ft", "fun", "f", "read", "args", "data", "re", "result", "prot", "j", "gt", "Ret", "deg", "val", "rem", "out", "lt", "nt", "obj", "rets", "tmp", "back", "print", "mt", "def", "ext", "info", "arr", "desc", "elt", "rt", "ref", "sys", "set", "tf", "reset", "inter", "pat", "ry", "gb", "t", "et", "backed", "status", "res", "len", "db", "ll", "det", "resp", "alt", "ply", "ord", "rot", "ter", "nz", "arg"]}}
