{"project": "FFmpeg", "commit_id": "32bf6550cb9cc9f487a6722fe2bfc272a93c1065", "target": 0, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "idx": 3, "substitutes": {"s": ["b", "c", "d", "w", "p", "ts", "sd", "ps", "gs", "v", "e", "ss", "g", "sv", "conv", "fs", "ds", "a", "ats", "t", "ns", "sw", "h", "f", "aws", "sa", "m"], "pb": ["proc", "bp", "tp", "pro", "fb", "pool", "np", "orp", "emb", "uf", "new", "rb", "td", "pt", "dp", "pause", "p", "py", "mp", "cp", "buf", "pc", "fp", "sys", "peer", "jp", "conf", "pp", "ctx", "conv", "apy", "lp", "tk", "cb", "pm", "PB", "resp", "px", "pl", "sb", "txt", "phys", "vp", "bj", "pg", "span", "tm", "tf", "obj", "pkg", "tmp", "gp", "wp", "bot", "vm", "typ", "buff", "xp", "tab", "erb", "db", "pa"], "codec": ["Coddec", "critisc", "modEC", "codeect", " codoc", " codac", "predeman", "codpeg", "odcam", "callenc", " codeca", "codeeco", "odEC", "octel", "odiac", "codoe", "typdec", "odica", "podEC", "codeec", "codeeg", " codiac", "codel", "checkec", " codeco", "copeca", "typpeg", "calliac", "octec", "Codeco", "podcam", "celloe", "codecam", "modent", "copsc", "predec", "codenc", "octoc", "codeeca", "codener", " codeman", "Coderer", "celleman", "codica", "modec", "checkapter", "podec", "codiac", "typec", "callect", "cellec", "podeca", "criteman", "coderer", "oderer", " codica", "modeca", "modsc", "cedec", "cedeca", "predera", " coderer", " codapter", "coec", "typeg", "odec", "Codoc", "codapter", " codent", "podener", "cedeco", "codeiac", "codefc", "codfc", " coddec", "coerer", "Codel", "codeisc", "octeco", " codener", "podisc", "podest", "codeman", "codera", "ceiac", "modoc", " codEC", "codedec", "codeest", "codeener", "odeco", "coisc", "ceec", "codcam", "codoc", "copec", "codsc", "codEC", "cmddec", "odest", "codeoc", "coeco", "typEC", "ceenc", "cmdec", "cellapter", "codender", "odac", " codsc", "codeerer", "critec", " codpeg", "critera", "codeco", "codeender", "coddec", "copent", "cmdelta", "odeca", "codelta", "odisc", "codeac", " codoe", "moddec", " codelta", "Codec", " codfc", "odoe", "codisc", "typerer", "podac", "ceect", " codisc", "codac", "podica", "model", " codera", "modpeg", "Codelta", "Codac", "codest", "cedac", "codeoe", "modeco", "checkeman", "checkoe", "codeEC", " codender", "odfc", "odender", "codect", "callec", "codeca", "codent", "codeg", "cmderer", "codeenc", "predisc", " codeg", "odener"], "size": ["n", "count", "empty", "what", "length", "bytes", "sample", "see", "m", "sn", "dimension", "capacity", "max", "sum", "scroll", "type", "south", "send", "offset", "body", "ize", "number", "e", "message", "len", "name", "num", "area", "space", "news", "shift", "scope", "set", "settings", "position", "to", "total", "fee", "SIZE", "scale", "sized", "shape", "storage", "range", "small", "buffer", "Size", "notice", "data"], "big_endian": ["big_endsian", "big_startIAN", "big_rendian", "big_endIAN", "big_endeian", "big_ander", "big_endical", "big_ENDior", "big_andIAN", "big_rendIAN", "big_endsior", "big_endsical", "big_andian", "big_startian", "big_endeIAN", "big_endingian", "big_endingican", "big_endingIAN", "big_endeical", "big_ender", "big_starter", "big_rendior", "big_rendican", "big_ENDians", "big_andior", "big_endior", "big_ENDian", "big_endsians", "big_startians", "big_endsIAN", "big_endeians", "big_andians", "big_ENDIAN", "big_ENDical", "big_endians", "big_endser", "big_endican", "big_endsican", "big_endingior"], "id": ["null", "time", "hash", "rid", "rank", "head", "bid", "is", "it", "h", "like", "with", "kid", "init", "wire", "md", "uid", "status", "hd", "ID", "x", "len", "num", "mid", "index", "debug", "no", "ids", "data", "ide", "Id", "tag", "ad", "ident", "vid", "style", "start", "try", "p", "oid", "ip", " tid", "format", "info", "name", "key", "code", "set", "addr", "iden", "tar", "root", "hid", "k", "aid", "orig", "d", "type", "parent", "offset", "in", "hide", "url", "link", "end", "sid", "t", "ref", "f", " fid", "pid"], "bitrate": ["bugRate", " bitRate", "fitride", "fitrate", "butride", "butzip", "Bitrates", "bugrate", "Bitrate", " bitcurrency", "BitRate", "butrates", "bugcurrency", "bitrates", "bitRate", "bitride", "bitsrates", "bitsRate", " bitride", "bitscurrency", " bitzip", "bugrates", " bitrates", "bitzip", "fitrates", "bitcurrency", "butrate", "fitzip", "bitsrate"]}}
{"project": "qemu", "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189", "target": 1, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}", "idx": 12, "substitutes": {"xendev": ["xaenderiv", "xtentef", "exenterv", "wendedef", "xtentee", "xendediv", "xendedem", "xendedoe", " xenddev", "xentdev", "xendedev", "xandec", "xaenderec", "xenderer", "xendsew", "xendata", "xendedec", "xestiv", "xandeg", "xestoe", "xendee", "xtentev", "xnderer", "xadec", "xtentdev", "xendeg", "xENDev", "xenderiv", "wendec", "xendedeg", " xendeew", "xaenderoe", "xendsef", " xendov", "wendev", "xendov", "xendsev", "xaendoe", "xendoc", "wendef", "yenddev", "wendedev", "xenderev", "xendew", "xenderoe", " xendeoc", " xndev", "xENDec", " xendoc", "xendeata", "xndov", "xentem", "yendedev", "yendedec", "xendsee", "wendedee", "xendedee", "xendederer", "xendedep", "xadev", " xndov", "xendeoc", "xtendef", " xendata", "xendiv", " xendeata", "wendee", "xhenddev", "xentee", "xaendev", "xendsoc", "exenderv", "yendec", "xandep", "xadep", "xentev", "xentew", "xenderv", "xendedef", "xenderec", "xENDdev", "xaendiv", "xnddev", "xendeem", "xenterv", " xnddev", "xendem", "xendederv", "yendeddev", "xestec", "exendev", "wendedec", "xandev", "xtendev", " xendew", "xENDee", "exenddev", "xendsdev", "xhendev", "xtendee", "xenddev", "xentef", "xtenddev", "xndew", "xendeew", "exendem", "exentev", "xenderew", "xendef", "xENDef", "yenderer", "exentdev", "exentem", "xENDov", "xaenderev", "xndec", "xentoc", "xaendec", "xhenderer", "xndev", "xENDew", "yendev", "xendoe", "wendedep", "xadeg", "yendederer", "xenderdev", "wendedeg", " xndew", "xestev", "wendep", "xendeddev", "xenderov", "xendeerv", "xendep", "xendsec", "xendsata", "xendec", " xendeev", "wendeg", "xendeev", "xentata", "xhendec"], "i": ["oi", "cli", "slice", " multi", "iri", "mi", " si", " mi", "ind", " I", "ai", "is", "v", "ij", "ei", " n", "ic", "go", "it", "si", " my", "y", "h", "id", "ti", "io", "phi", "iu", "bi", "hi", "init", " v", "ui", "batch", " m", "c", "di", " k", "x", "fi", "ini", "list", "zi", "ims", "xi", "conv", " ti", "ami", " ii", "index", "multi", "sim", "ri", "j", "I", " li", "asi", "im", "p", " bi", "ip", "info", "my", "ix", "ci", " ni", "gi", "m", "li", " j", "ii", "remote", "ji", "\u0438", "pi", "in", " pi", "me", "qi", "f", "err", "o", "series"], "xen_9pdev": ["xen_15pdev", "xen_10pds", "xen_9erdes", "xen_9fev", "xen_ninepserv", "xen_9paddevice", "xen_999pidgu", "xen_970bpdev", "xen_9ppDev", "xen_9wpdata", "xen_09pdem", "xen_9pden", "xen_9pdcast", "xen_9ptDEV", "xen_9lpdd", "xen_9pgdef", "xen_9tpdevice", "xen_9piddev", "xen_14parcast", "xen_6pcdiv", "xen_9dDEV", "xen_09tpdevice", "xen_9bpgo", "xen_9tpver", "xen_9edes", "xen_09pgu", "xen_6pcserv", "xen_9pcdes", "xen_9ppdevice", "xen_2009tpev", "xen_9pcDEV", "xen_9pprof", "xen_9tpcast", "xen_9nDEV", "xen_5tpdev", "xen_9pcver", "xen_9piddd", "xen_9lpdev", "xen_9ddb", "xen_9pgconn", "xen_9tatt", "xen_970bpgo", "xen_9pdver", "xen_9opserv", "xen_9xpdev", "xen_9tpgu", "xen_09tpDEV", "xen_999pDev", "xen_9opdev", "xen_30pdev", "xen_14pDEV", "xen_1pdb", "xen_ninedev", "xen_9posttech", "xen_ninetpgu", "xen_5pver", "xen_9pds", "xen_9phpcast", "xen_9ppgu", "xen_10fdes", "xen_9pdiv", "xen_9pctech", "xen_9erdev", "xen_9parDEV", "xen_9prDev", "xen_9wpden", "xen_9ptdem", "xen_30bpDEV", "xen_9dev", "xen_9pgdd", "xen_5pstat", "xen_9xpgu", "xen_9pgDev", "xen_9pidgu", "xen_nineddev", "xen_9pDEV", "xen_ninepdevice", "xen_9lpdevice", "xen_970bpcom", "xen_2009pdev", "xen_9parcast", "xen_9pconn", "xen_9ptech", "xen_9tblock", "xen_9npdev", "xen_9fgu", "xen_9lpDEV", "xen_nineddevice", "xen_1dDev", "xen_9pev", "xen_970bpDev", "xen_9eDEV", "xen_9wpdem", "xen_ninetpdev", "xen_9ppver", "xen_ninepds", "xen_5pdev", "xen_9pidev", "xen_9lpgu", "xen_9ndev", "xen_15pdevice", "xen_ninetblock", "xen_09pDEV", "xen_6pev", "xen_9pddev", "xen_9pdata", "xen_9pccast", "xen_9ppfam", "xen_999pidev", "xen_2009pev", "xen_9lpev", "xen_9ppdev", "xen_30bpmem", "xen_6pdef", "xen_6pDEV", "xen_9pdem", "xen_999prDev", "xen_9dDev", "xen_9pver", "xen_9pdstat", "xen_9pcdata", "xen_14parDEV", "xen_9bpcom", "xen_6pcDEV", "xen_9pgo", "xen_9partdev", "xen_1dconn", "xen_93pgdd", "xen_9pdes", "xen_9tdevice", "xen_9pcconn", "xen_9fdes", "xen_6pcdes", "xen_9pcom", "xen_ninetdev", "xen_ninetdef", "xen_9ppprof", "xen_9pidfam", "xen_9prden", "xen_9pcev", "xen_10pdev", "xen_6pdev", "xen_9ppval", "xen_9tpatt", "xen_9pgdev", "xen_9ppblock", "xen_9pddes", "xen_9lpds", "xen_999pden", "xen_ninepblock", "xen_14pdata", "xen_09tpdev", "xen_09tpgu", "xen_9npDEV", "xen_10pdes", "xen_9paddev", "xen_1pDev", "xen_999pdd", "xen_9dconn", "xen_9pidevice", "xen_93pgdef", "xen_10ddev", "xen_93pdev", "xen_09wpdev", "xen_9partDEV", "xen_ninetpds", "xen_10pserv", "xen_10dDEV", "xen_9npdevice", "xen_9erdiv", "xen_999prden", "xen_ninepgo", "xen_93pgdev", "xen_15ppval", "xen_9ppcom", "xen_9pdevice", "xen_9eds", "xen_9pgu", "xen_9tdd", "xen_9ppdef", "xen_17pdev", "xen_9fds", "xen_9tev", "xen_15ppdevice", "xen_9ptdef", "xen_9tpds", "xen_9padev", "xen_9pDev", "xen_9ndef", "xen_9patt", "xen_9pstat", "xen_9opDEV", "xen_9pccom", "xen_09pdef", "xen_999pgu", "xen_9tpDEV", "xen_14pardev", "xen_6pcdev", "xen_9wpDEV", "xen_9pmem", "xen_6pcev", "xen_9tserv", "xen_10dserv", "xen_ninepprof", "xen_15pval", "xen_93pgev", "xen_5tpstat", "xen_5tpver", "xen_10fds", "xen_9pfam", "xen_9pigu", "xen_2009tpatt", "xen_970pdev", "xen_ninetprof", "xen_970pDev", "xen_9postcom", "xen_15ppfam", "xen_9lpserv", "xen_9lpgo", "xen_9fdev", "xen_9piblock", "xen_9dserv", "xen_9lpval", "xen_970pcom", "xen_9ndem", "xen_9Pdef", "xen_9pcdevice", "xen_9tpstat", "xen_ninetver", "xen_9pcdb", "xen_17ptech", "xen_30bpdev", "xen_9tpdev", "xen_ninepdev", "xen_14pcast", "xen_9edev", "xen_30pDEV", "xen_9ddev", "xen_14pardata", "xen_9fdd", "xen_9lpmem", "xen_6pdiv", "xen_2009patt", "xen_14pdev", "xen_9pgev", "xen_9pdd", "xen_9wpcast", "xen_ninetdevice", "xen_9postdev", "xen_9pblock", "xen_9pcprof", "xen_9pardev", "xen_9bpmem", "xen_30pmem", "xen_17pccom", "xen_9phpver", "xen_09pdev", "xen_6pdes", "xen_10fDEV", "xen_2009tpdev", "xen_5pcast", "xen_9pval", "xen_9pdef", "xen_9wpdev", "xen_17pctech", "xen_9pdds", "xen_9Pev", "xen_6pserv", "xen_9pardata", "xen_9tgu", "xen_9piddevice", "xen_ninepdef", "xen_999prdev", "xen_9tver", "xen_6pcdef", "xen_9pgdb", "xen_9pcdiv", "xen_9pcDev", "xen_9padserv", "xen_ninetgu", "xen_ninepgu", "xen_1ddb", "xen_5tpcast", "xen_9pdDEV", "xen_9erDEV", "xen_17pcdev", "xen_970pgo", "xen_9pcast", "xen_9npgu", "xen_9ddevice", "xen_15pfam", "xen_9prdev", "xen_9pcdef", "xen_9tdev", "xen_9tpev", "xen_09pdevice", "xen_9pdb", "xen_10pev", "xen_9ppgo", "xen_9wpDev", "xen_9pcserv", "xen_9tprof", "xen_93pev", "xen_09wpdef", "xen_9wpdef", "xen_9tdef", "xen_9pidval", "xen_9ptdev", "xen_ninepev", "xen_9lpfam", "xen_9Pdev", "xen_10fdev", "xen_999piddd", "xen_9bpdev", "xen_ninetpgo", "xen_ninedserv", "xen_9phpdev", "xen_1pconn", "xen_ninepver", "xen_15ppdev", "xen_9Pserv", "xen_9fDEV", "xen_93pdef", "xen_9lpdef", "xen_9bpDev", "xen_999piddev", "xen_9fmem", "xen_9pserv", "xen_17pcom", "xen_9bpDEV", "xen_999pev", "xen_10pDEV", "xen_9partdes", "xen_93pdd", "xen_9xpgo", "xen_999pdev", "xen_9partdiv", "xen_9opev", "xen_10dev", "xen_1pdev", "xen_09wpdem", "xen_1ddev", "xen_09wpDEV", "xen_9xpds", "xen_9pcgu", "xen_9pcdev", "xen_9phpstat", "xen_9tpgo"], "s": ["n", "stats", "b", "c", "d", "m", "w", "r", "p", "ps", "gs", "v", "e", "ss", "g", "os", "fs", "ds", "t", "rs", "sb", "S", "h", "o", "j"], "fsdev": ["fsDev", "fsdevice", " fsDEV", "csdevice", "FSDEV", "fsDEV", " fsdevice", "FSdev", "csdev", "FSdevice", " fsDev", "FSDev", "csDEV", "csDev"], "str": ["cr", "fr", "tr", "b", "wr", "w", "r", "pr", "Str", "p", "buf", "vol", "out", "v", "st", "x", "arr", "g", "name", "sc", "STR", "br", "ring", "it", "sts", "er", "msg", "res", "t", "rs", "txt", "shr", "sw", "ptr", "dr", "sl", "f", "cs", "sp", "err", "chain", "buffer", "ctr", "print", "j", "data"], "ring_order": [" ring_record", "ring_err", " ring_type", "ring_record", " ring_err", "ring_type"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    /* subframe header */\n\n    count += 8;\n\n\n\n    /* subframe */\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        /* warm-up samples */\n\n        count += pred_order * sub->obits;\n\n\n\n        /* LPC coefficients */\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        /* rice-encoded block */\n\n        count += 2;\n\n\n\n        /* partition order */\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        /* residual */\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n", "idx": 35, "substitutes": {"s": ["n", "sg", "stats", "spec", "bs", "sec", "ses", "comm", "es", "b", "c", "ls", "ts", "its", "ps", "gs", "v", "is", "sys", "sh", "x", "e", "less", "ss", "g", "ims", "ms", "se", "sv", "os", "bis", "fs", "ds", "a", "set", "vs", "sts", "ats", "t", "ns", "rs", "http", "sb", "S", "ins", "h", "sw", "sq", "f", "cs", "hs", "js", "sim"], "sub": ["sam", "other", "test", "supp", "pro", "repl", "tag", "sing", "lib", "j", "bs", "sec", "rc", "seq", "var", "ext", "slice", "embed", "exec", "prep", "summary", "utils", "b", "cond", "pb", "com", "th", "mod", "syn", "control", "watch", "sel", "sum", "aux", "stat", "web", "sup", "super", "reg", "nil", "sc", "rob", "pred", "Sub", "so", "sur", "pl", "sb", "ver", "subject", "dev", "ub", "pre", "sl", "sq", "pkg", "pop", "desc", "add", "ch", "sim", "sci", "con", "job"], "pred_order": ["pred_index", "preduloindex", "pred_orders", "pred_unit", "seqpostend", "pred_Order", "pred_end", "pred_offer", "predpostord", "permationkey", "predpostOrder", " pred_num", "predationnum", "seq_end", "pred_key", "pred_num", "preduloorder", "seqpostOrder", " pred_err", "permationorder", "perm_order", "pred_ord", "predationkey", "predulokey", "perm_index", "predationindex", "perm_offer", "permationoffer", "permationindex", "predationunit", "perm_key", "seqpostorder", "predulooffer", "seqpostord", "predpostorder", "predationoffer", " pred_unit", "seq_ord", "seq_order", " pred_orders", "pred_err", "predationorders", "predationorder", "seq_Order", "predpostend"], "p": ["k", "n", "pro", "bp", "tp", "app", "pat", "np", "ep", "point", "b", "c", "post", "P", "d", "m", "pt", "pers", "r", "pr", "per", "at", "cp", "ps", "pad", "pc", "l", "ip", "v", "x", "ap", "pi", " P", "ping", "xp", "jp", "g", "port", "pp", "lp", "pe", "t", "pl", "perm", "vp", "pg", "h", "pre", "pkg", "wp", "sp", "o", "j", "pos", "pa"], "porder": [" pfield", " prank", " pnumber", "permrender", "crank", "pinversion", "pfield", "pme", "pnorder", "pinfo", "pporder", "pprender", "pinorder", "ppder", "pnposition", "pforce", " pinfo", "pppriority", " pversion", "pprank", " pme", "pposition", "pcinfo", "painfo", "piversion", "pcorder", " pforce", "ppdir", "ppriority", "pder", " pposition", "prender", "corder", "pnkey", "pcfield", "pdir", " ppriority", " pder", "pinforce", "pame", "porders", " pkey", "pporders", " pgrade", " porders", "pnder", " pdir", "pafield", "pcme", "pversion", "pnumber", "pinumber", "prank", "corders", "ppgrade", "pgrade", "ppkey", "paorder", "piforce", " prender", "permgrade", "permpriority", "piorder", "ppposition", "pkey", "pinnumber", "permorder", "cdir"], "psize": ["ppsizer", "upssize", "persizer", "ppsization", "upsize", "ssizable", "fpsizer", "persiz", "apsize", "upsizer", "msize", "alsization", "ipssize", "msized", "fpsiz", "ssize", "psiz", "psized", "psizable", "psization", "ppsiz", "ppsizable", "sssize", "msizer", "apsization", "ipsize", "alsizer", "persize", "persization", "ipsization", "psizer", "ssization", "fpsize", "ppssize", "msization", "fpsization", "alsized", "pssize", "apssize", "upsization", "ppsize", "rsize", "apsizer", "alsize", "rsization", "ipsizable", "rsized", "rsizer"], "i": ["phi", "ish", "k", "iu", "I", "bi", "iter", "li", "point", "c", "di", "ir", "ia", "ii", "at", "mi", "start", "ind", "ip", "ai", "is", "v", "ij", "l", "x", "u", "pi", "e", "fi", "in", "info", "ini", "jp", "ic", "xi", "it", "end", "si", "ix", "iat", "ci", "index", "y", "h", "sp", "id", "ti", "m", "j", "pid", "pa"], "part_end": ["part7end", "part2end", "partMemend", "part_pend", " part_ends", "part7stop", " part_begin", "part_ends", "partJEND", "partJpend", "part_start", "part_ender", " part_End", "partMemedge", "part_END", "part64end", " part_END", "partJstop", "part_edge", "part_begin", " part_edge", "partMemEnd", "part2ends", "part2begin", " part_pend", " part_ender", "part_stop", "partJend", "part7END", "part64ender", " part_stop", "part2start", " part_start", "part7pend", "part_End"]}}
{"project": "qemu", "commit_id": "24408a7d2b459bed3697367b81ada76518ca96ef", "target": 0, "func": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 43, "substitutes": {"args": ["ads", "ars", "xs", "images", "limits", "qs", "ants", "users", "comm", "results", "ags", "values", "atts", "arms", "arg", "ts", "points", "changes", "aux", "gs", "artifacts", "terms", "units", "parts", "arr", "apps", "keys", "grades", "orders", "objects", "doc", "yrs", "flags", "params", "words", "bits", "yes", "amps", "vals", "locks", "ids", "GS", "err", "cmd", "aws", "js", "names", "roots", "ams", "Args", "ians", "actions"], "cpu_model": ["cpupronetwork", "cpubookcontrol", "cpubookmode", "cpu_models", "cpubookmodels", "cpu_control", "mem_mode", "mem_control", "cpupromodel", "mem_models", "pu_model", "membookcontrol", "membookmodel", "cpuprofine", "pu_fine", "cpu_fine", "cpupromode", "membookmode", "pu_mode", "mem_model", "cpubookmodel", "cpu_network", "pu_network", "membookmodels", "cpu_mode"], "kernel_filename": ["kernel_folder", "kernel_subject", "cpu_module", "system_filename", "system_file", "kernel___folder", "kernel_file", "kernel_files", "cpu_filename", "kernelitysubject", "kernel___file", "kernel_module", "system_folder", "kernelityfile", "cpu_location", "kernel_location", "kernel___filename", "system_subject", "cpu_files", "kernelityfilename", "kernelityfolder", "kernel___subject"], "kernel_cmdline": ["kernel_commandname", "kernel_bindline", "kernel_commpoint", "kernel_bindLine", "kernel_cmdlines", "kernel_cmdLine", "kernel_bindlines", "kernel_commandline", "kernel_commandLine", "kernel_cmdpoint", "kernel_cpLine", "kernel_commline", "kernel_bindpoint", "kernel_cpline", "kernel_commandpoint", "kernel_commlines", "kernel_bindname", "kernel_cmdname", "kernel_commandlines", "kernel_cpname"], "initrd_filename": ["initrb_filename", "initrd___file", "initrb_file", "initrb_location", "initrd_location", "initrd_prefix", "initrd__filename", "initrd_file", "initrb_label", "initrd__label", "initrd_directory", "initrb_directory", "initrd___prefix", "initrb_prefix", "initrd_label", "initrd___label", "initrd__file", "initrd__prefix", "initrd___filename"], "boot_device": ["boot64device", "start_option", "boot_register", "boot_order", "boot64option", "start_device", "boot_option", "boot64register", "boot64order", "start_register", "start_order"], "cpu": ["core", "proc", "cow", "pool", "c", "CPU", "cu", "prof", "util", "cache", "gc", "cp", "pc", "mem", "chip", "linux", "ctx", "conn", "process", "pu", "phys", "clock", "gpu", "hw", "processor", "net", "vm", "boot"], "env": ["em", "proc", "el", "ext", "ew", "ef", "eu", "cur", "worker", "environment", "ec", "her", "te", "ei", "sh", "e", "eng", "here", "me", "ctx", "en", "end", "pe", "er", "dev", "pid", "vm", "eas", "ev"], "phb": ["Phb", "phbp", "PHbs", "Php", "PHbp", "phbs", "php", " phbs", "Phbp", "Phbs", " php", "PHb", " phbp", "PHp"], "i": ["I", "n", "bi", "li", "et", "b", "ia", "im", "r", "p", " bi", "l", "ip", "v", "e", "x", "pi", "it", "a", "si", "ci", "y", "h", "z", "f", "m", "j", "io"], "sysmem": [" sysMem", "sysmemory", " sysreg", "ysmem", "Sysreg", "sysMem", "Sysmem", "sysmeta", "systemmem", "ysreg", " sysmemory", "systemmeta", " sysmeta", "ysMem", "sysreg", "Sysmemory", "ysmemory", "ysmeta", "systemMem", "systemmemory"], "ram": ["sam", "ra", "gra", "iam", "RAM", "lim", "rum", "memory", "am", "mem", "mm", "row", "reg", "cam", "ma", "gram", "process", "fam", "res", "dev", "mb", "tem", "vm", "range", "Ram", "rem", "ro", "rom"], "rma_alloc_size": ["rma_ptr_len", "rma_mem_size", "rma_alloc_sum", "rma_alloc_storage", "rma_alloc_ize", "rma_buf_sum", "rma_alloc_name", "rma_buf_space", "rma_alloc_space", "rma_mem_ize", "rma_max_string", "rma_alloc_address", "rma_allocxspace", "rma_alloc_count", "rma_max_SIZE", "rma_alloc_Size", "rma_mem_storage", "rma_allocxlen", "rma_mem_address", "rma_allocxsize", "rma_ptr_data", "rma_alloc_len", "rma_ptr_size", "rma_buf_len", "rma_ptr_Size", "rma_alloc_SIZE", "rma_mem_name", "rma_alloc_string", "rma_buf_size", "rma_max_size", "rma_buf_count", "rma_alloc_data"], "load_limit": ["load2lim", "lengthablelim", "lengthablepolicy", "length_lim", "length_limit", "loadablelimits", "loadablelimit", "load2limit", "length_limits", "load_policy", "load_limits", "Load_limit", "loadablepolicy", "Load_lim", "load_lim", "loadablelim", "Load_size", "load_size", "lengthablelimit", "load2size", "lengthablelimits", "length_policy"], "rtas_limit": ["rtAs_link", "rtAs_limit", "rtlas_limit", "rtlas_adjust", "rtAs_size", "rtlas_Limit", "rtas_adjust", "rtas67limit", "rtas_link", "rtas_size", "rtas_lim", "rtas67size", "rtas_level", "rtAs_lim", "rtas67set", "rtas_set", "rtAs_set", "rtas67level", "rtas_Limit", "rtAs_level", "rtlas_size"], "fw_size": ["hw_size", "hw_Size", "fw_Size", "hw_SIZE", "fw_SIZE"], "filename": ["ame", "ename", "jpg", "metadata", "uri", "family", "username", "kan", "fp", "prefix", "socket", "original", "format", "seek", "fs", "location", "kj", "params", "fn", "framework", "files", "Filename", "writer", "fil", "processor", "json", "nm"], "spapr": ["servicerape", "sparmrb", "spagrer", "processapperr", "processapperrb", "sprapd", "spashi", "spapperrb", " spopcr", "spajar", " spaprb", " spoprb", "spcapr", "spapperren", "ppaptr", "spaprar", "ispaprb", "ppmapre", "spapsr", "spashr", "spaprer", "repmapu", "ppappru", "spajr", "processapr", "spapprc", "spaperrb", "spaptrc", "spaspr", "repaprr", "spapsrer", "spcaprb", "sparmr", "spajrer", "spmapre", "repmapr", "repaperen", "scopeapterr", "servicerapd", " spaprer", "sprape", "spagr", "spaperr", "spaperrr", "espapcr", "spapp", "repapscr", "spopr", "spapercr", "repapsr", "isparmrar", "spagcr", "spappre", "repaprb", "spaperen", "sparmi", "spaperb", "repapers", "repapr", "ppmapr", "ispapr", "servicerapr", "espcapcr", "spaptcr", "espcapr", "repapren", "spappp", "spapterr", "spmapcr", "spapeerr", "spopre", "repapcr", "spapperstr", "ppaperr", "ppmapp", "spapti", "scopeaptr", "sparmren", "spapren", "spiprer", "spapar", "spmaprer", "ppapr", "ppaptar", "processapperren", "scopeaptner", "spcapcr", "spapee", "spaprr", "sparmrar", "scopeapr", "repmaprb", "spapperrs", "spaprb", "spapcr", "spashd", "spapsrr", "spaptrt", "espaprb", "sprapr", "ppapre", "processaprar", "spapdr", "repapsrr", "spaptr", "spmape", "processapperrar", "spmapr", "spopp", "serviceraprar", "espaprer", "spopcr", " spapcr", "spappner", "spape", "spaspren", "espapar", "sphapcr", "spapestr", "sphapner", "spashrar", "spapu", "ppapp", "spapner", "spajrt", "spapru", "spaptar", "espaprt", "spaprc", "espcaprer", "spappar", "spappr", "spapprer", "spapscr", "spaperbr", "ppaptdr", "processaprb", "scopeapner", "spcapru", "spaptrer", "spapers", "scopeaprc", "scopeaperr", " spopr", "spaptdr", "repapu", "spaped", "spaptner", "ppape", "spapi", "spapstr", "serviceaprar", "isparmi", "spapecr", "spoprb", "ispapi", "espajr", "spapeu", "spapsrb", "serviceape", "spaprt", "ppapru", "sphaprc", "spaptrar", "spaspstr", "ppapprer", "spaperrar", "spapedr", "spipru", "ppapprs", "spashe", "spapear", "scopeaptrc", "spagrb", "espapr", "sphaprr", "repaper", "spapperrar", "spaper", "serviceapd", "spaprs", "sphapr", "spasprs", "ppappr", "spaperren", "repapestr", "sphaperr", "espajar", "processapren", "espajrer", "spaperar", "spipr", "repapsbr", "isparmr", "spmapp", "spappdr", " spoprer", "espajrt", "ppaprs", "ispaprar", "spope", "spapd", "spapsbr", "spmaprb", "ppmape", "spapprt", "spappe", "ppapdr", "spmapu", "isparmrb", "spiprs", "spcaprs", "sphapbr", "spappru", "espcaprb", "spashrb", "spaptrb", "spaptu", "repaprs", "spcaprer", "ppapar", "repapstr", "spapperr", "repmapcr", "ppaprer", "spapre", "serviceapr", "repapbr", "spapbr", "ppapterr", "spapprs", "spoprer", "spraprar"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60, "substitutes": {"avctx": ["svcontext", "Avctx", "wavjac", " avpkg", "avepkg", "svjac", "avertmp", "avcu", "abctx", "AVconn", "averconn", "wavctx", "avecontext", " avjac", " avconn", "AVbuf", "Avtx", "avcfg", "avctl", "avcontext", "AVtx", " avgc", "vercu", "averobj", "avercontext", "avecfg", "abbuf", " avobj", "wavtx", "avercu", "avbuf", "vertx", " avcp", " avcu", "wavpkg", "verctx", " avcontext", "abcontext", "averca", "avetmp", "averctl", "averctx", "avpkg", " avcfg", "avecmp", "avercmp", "avecp", "avertx", "avca", " avtmp", "averjac", "avconn", "avtmp", "aveconn", "evcontext", "AVctx", "svctx", "wavcontext", "avectx", " avctl", "wavcp", " avtx", "avgc", " avca", "avcmp", "avectl", "AVcontext", "avtx", "ajgc", "avergc", "Avconn", "ajca", "avercfg", "AVobj", "verconn", "Avcontext", " avcmp", "abobj", "aveobj", "avobj", "ajcontext", "avcp", "evctx", "evtx", "ajctx", "avjac", "avebuf", "evjac", "svtx", "avetx"], "buf": ["fb", "bp", "read", "seq", "bin", "bytes", "uf", "bg", "b", "rb", "pb", "block", "w", "p", "max", "img", "window", "out", "bc", "bf", "queue", "ctx", "br", "code", "cb", "msg", "ref", "text", "cv", "Buffer", "mb", "tmp", "raw", "cmd", "err", "buffer", "buff", "data", "db"], "buf_size": ["queue_len", "queue_size", "queue_SIZE", "buf_Size", "buf2len", "buf_SIZE", "buf2Size", "buf2SIZE", "buf_len", "queue_Size", "buf2size"], "s1": ["js1", "s01", "sOne", "ts1", "ls2", "sone", "ls1", "hs1", "ssOne", "s2", " s01", "lsOne", "tsone", " sOne", "ss01", "ss1", "ssone", "sts2", "tsOne", "hsOne", "jsone", "js2", "sts01", "hs2", "stsOne", " sone", "ss2", "sts1", "lsone", " s2", "jsOne", "hsone", "ts2"], "s": ["n", "esm", "an", "is", "sync", "ops", "parts", "sis", "fs", "ds", "bits", "sb", "scl", "y", "h", "sq", "hs", "sports", "bs", "ses", "c", "status", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "details", "qs", "p", "ps", "comments", "l", "sys", "less", "ss", "tests", "ms", "bis", "set", "params", "times", "sm", "args", "us", "m", "sam", "spec", "stats", "sym", "comm", "es", "b", "ls", "w", "als", "ts", "its", "changes", "gs", "e", "csv", "conf", "g", "se", "tes", "acs", "settings", "rs", "ns", "t", "ins", "S", "obj", "sw", "f", "cs", "js", "aws"], "height": ["count", "high", "hash", "holes", "length", "above", "display", "angle", "tight", "rank", "Height", "he", "cache", "huge", "history", "radius", "docker", "alpha", "bits", "h", "y", "scale", "padding", "range", "quality", " Height", "th", "memory", "xy", "wh", "density", "through", "window", "row", "hei", " heights", "host", "table", "shape", "crop", "buffer", "dim", "hang", "confidence", "style", "grow", "capacity", "lat", "ip", "kw", "rows", "root", "gravity", "depth", "level", "show", "visible", "ht", "resolution", "embed", "results", "volume", "gh", "html", "sky", "title", "hold", "ows", "bottom", "total", "zh", "size", "ty"], "i": ["iu", "I", "n", "q", "b", "ia", "ii", "mi", "p", "l", "ij", "x", "pi", "info", "g", "it", "si", "ix", "ci", "index", "y", "h", "f", "id", "m"], "v": ["k", "n", "q", "b", "c", "w", "p", "av", "vt", "V", "iv", "l", "u", "va", "e", "g", "sv", "value", "lv", "vp", "uv", "h", "z", "f", "qv", "vc", "m"], "j": ["k", "uj", "n", "jc", "q", "jump", "b", "c", "p", "ji", "l", "ij", "jj", "jp", "g", "kj", "aj", "y", "z", "f", "json", "jl", "js", "J", "m", "pos"], "aspect": ["xpect", "iaspi", "accesspect", "iaspecting", " Aspi", "assception", "raspi", "ascel", "ario", "raspecting", "raspect", "aspi", "raspects", "asspection", "aspects", "xspect", "anpi", "nasspect", " Aspect", "ASpect", "iaspect", "aupect", "nascel", "anpect", "ancel", "apect", "asform", "aform", " Aspects", "assform", "aception", "AScel", "accesspects", "asio", "aupection", "arpects", "ASpi", "asception", "ASspect", "accessio", "xpects", "auform", "iaspects", "naspect", "anspect", "aspecting", "auception", "asspect", "xio", "arspect", "naspi", "accessspect", " Aspecting", "aspection", "apection", "arpect"]}}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70, "substitutes": {"drc": [" dirc", " dsoc", "kirc", "didsrc", "Disco", "pdarc", "Drc", "drom", "DRC", " duc", "Dric", "hdRC", " drom", " dsrc", "didrom", "duc", "disco", "pduc", "drs", " dRC", "prs", "dric", "Dirc", "pdrh", "dsoc", "pdsoc", "ddarc", "pdric", "darc", "krc", "pdrom", "krs", "hdrc", "Dsrc", "pdRC", "didsoc", "pdrc", " dric", "Drh", "prc", "dduc", "didrc", "psrc", "dsrc", " drs", " drh", "ddRC", "drh", "ksrc", "dirc", "didric", " darc", "pdirc", "ddrc", "hdisco", "hdsrc", "dRC", "pirc", "didisco", "didRC"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 83, "substitutes": {"r": ["re", "tr", "rd", "error", "kr", "rg", "rh", "pr", "i", "v", "hr", "br", "or", "ry", "run", "sr", "er", "h", "request", "nr", "cr", "repl", "q", "vr", "c", "rec", "rw", "req", "x", "gr", "rel", "j", "ro", "mr", "attr", "this", "rc", "fr", "rb", "p", "ret", "l", "rate", "rt", "reg", "rn", "ar", "rr", "all", "usr", "m", "result", "rem", "lr", "rar", "ren", "item", "b", "d", "w", "rect", "rer", "rl", "remote", "rf", "ur", "e", "u", "g", "adr", "res", "rs", "t", "ref", "obj", "R", "err", "o"], "s": ["spec", "stats", "bs", "qs", "q", "es", "b", "c", "sn", "w", "p", "ps", "i", "gs", "v", "is", "sys", "ss", "os", "fs", "ds", "a", "sts", "res", "rs", "ns", "sb", "S", "h", "y", "sl", "sq", "cs", "sp", "js"], "n": ["nw", "note", "nl", "dn", "np", " N", "nt", "na", "new", "c", "b", "nu", "nor", "d", "ot", " ng", "w", "sn", "m", "p", "ll", "i", "ul", "l", "out", "v", "number", "x", "nan", "cn", "g", "len", "nc", "num", "mn", "ne", "en", "or", "non", "un", "nb", "t", "ns", "fn", "N", "size", "no", "h", "y", "z", "ln", "nn", "none", "nm", "names", "o", "j"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void lm32_evr_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    hwaddr ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    hwaddr timer0_base = 0x80002000;\n\n    hwaddr uart0_base  = 0x80006000;\n\n    hwaddr timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"lm32_evr.sdram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 84, "substitutes": {"machine": ["computer", "hello", "dem", "Machine", "engine", "achine", "cell", "m", "frame", "model", "channel", "iso", "shell", "connection", "money", "template", "message", "command", "me", "network", "zone", "handler", "history", "server", "host", "manager", "process", "state", "node", "device", "monitor", "module", "agent", "session", "vm", "hard", "mac", "sim", "config", "mode", "series", "instance"], "cpu_model": ["pu_module", "nic67model", "cu_label", "processormymodel", "cpubookname", "nic67location", "pu_model", "pu_link", "nic_location", "cpu_mode", "cu_type", "cpu67base", "cpu_relation", "cpu_name", "cpu_device", "cu_model", "pu_vector", "cpubookmodel", " cpu_string", "processor_model", " cpu_mode", "cpu2label", "cpu_type", "cpumyname", "cpu_link", "cpu67link", "cpu_location", "cpubookvector", "processormyname", "cpumyrelation", "processormyrelation", "cpumymodel", "nic_base", "nic67link", "nic_model", "cpubookdevice", "processor_name", "cpu67model", "pu_device", "nic_link", "cpu2model", "pu_name", "cpu_vector", "nic67base", "cpu_module", "cpu_string", "cpu67location", "cpu2type", " cpu_link", "cu_link", "cpu2link", "cpu_base", "processor_relation", "cpu_label"], "kernel_filename": ["kernel_names", "kernelamefilename", "system_filename", "kernelamefile", "system_names", "system_file", "kernel_file", "kernelamemode", "kernel_mode", "processor_name", "kernel_name", "processor_directory", "processor_file", "processor_filename", "kernelamenames", "kernel_directory", "system_mode"], "cpu": ["computer", "core", "proc", "cli", "aco", "np", "ilo", "normal", "ka", "comm", "nu", "CPU", "bench", "cu", "prof", "frame", "comp", "util", "cache", "gc", "uu", "cp", "arch", "pc", "mem", "program", "onet", "pai", "chip", "cn", "linux", "current", "runner", "ctx", "cam", "task", "conn", "process", "bean", "node", "home", "pu", "phys", "hog", "clock", "module", "obj", "gpu", "hw", "pkg", "loader", "mu", "processor", "net", "vm", "mac", "cum", "boot", "nic", "mx", "base", "instance"], "env": ["ext", "init", "Environment", "np", "event", "org", "eu", "nv", "map", "equ", "environment", "ec", "buf", "ve", "era", "shell", "window", "mem", "v", "next", "context", "e", "eng", "info", "obs", "conf", "estate", "network", "ctx", "mn", "en", "conn", "win", "server", "visor", "vs", "manager", "viron", "er", "gear", "state", "node", "ner", "disk", "uv", "dev", "session", "ent", "policy", "sw", "net", "priv", "vm", "global", "config", "eas", "ev"], "dinfo": [" dinformation", "rinf", "Dinformation", "Dinf", "uinf", "rfo", "ddinfo", "uinformation", "rinformation", "Dinfo", "Dfo", "rinfo", "dInfo", "didinfo", "uinfo", "dbinf", "dno", "dbinformation", "dinf", " dinf", "drinfo", " dInfo", "dbfo", " dno", "didno", " dago", " dfo", "rInfo", "ddube", "dfo", "didago", "drinformation", "didube", "dago", "dbinfo", " dube", "dinformation", "drinf", "ddago", "ddno", "drfo", "uInfo", "dube"], "address_space_mem": ["address_space2memory", "address_area_ram", "address_space2ram", "address_space2mem", "address_area_mem", "address_space_memory", "address_space_ram", "address_area_memory"], "phys_ram": ["phys2ram", "phys______memory", "physssam", " phys_sam", "phys______room", "sys_ram", "phys_disk", "phys______ram", "physsmem", "phys2room", " phys_iam", "phy_memory", "phys_sam", "physsram", "phy_ram", "physsdisk", "phy_room", "phys2mem", "phys_iam", "sys_disk", "sys_sam", " phys_mem", "phys_mem", "phys______mem", "phys2memory", "phys_room", "phy_mem", "sys_mem", "phys_memory"], "irq": ["irve", "ibriq", "IRiq", "IRQ", "irQ", "IRve", "ibrve", "ireq", "ibrq", "ireve", "ireiq", "ireQ", "IRq", "ibrQ", "iriq"], "reset_info": ["resetableinit", "reset_Info", " reset_lock", "etableentry", "etableinfo", " reset_init", "resetPrInfo", "et_Info", "reset_lock", "et_info", "resetableentry", " resetgrdata", "resetnessdetails", "reseterdata", "resetgrinfo", "et_init", "resetgrlock", "reseterinit", "etableInfo", "resetPrinit", "resetnessinfo", "resetableInfo", "reset_data", "et_entry", "resetableinfo", "reset_details", "etableinit", "resetPrentry", "reseterinfo", "resetPrinfo", " reset_data", "resetgrdata", "resetnessInfo", " resetgrinfo", " resetgrdetails", " resetgrlock", "reset_entry", "resetgrdetails", "reset_init", " reset_details", " reset_Info"], "i": ["phi", "iu", "I", "b", "di", "ia", "ii", "p", " bi", "ip", "ei", "v", "e", "pi", "fi", " pi", "xi", "o", "a", "si", "t", "z", "imm", "f", "id", "m", "j", "io"]}}
{"project": "qemu", "commit_id": "cf57298af5336df2aece47ef16c290a3a81457dd", "target": 0, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 108, "substitutes": {"argv": ["targetm", "docc", " argp", "argsver", "argumentp", "arguments", "argsV", "firec", "argsk", "arpvs", "argver", "arpk", "arpc", "argk", "argV", "argvin", " argm", "argss", "matchc", "argsv", "agc", "argumentc", "argsm", "argl", "firev", "matchvs", "pars", "targetc", "docV", "firever", "argsvs", "argc", "argsvin", "argsl", " argvs", "Argp", "parc", "parvs", " argc", "argsp", "firevin", "targetv", "arpv", " argk", "argp", "agvin", "argvs", " argV", "docv", "args", "Argv", "agv", "argsc", "docvs", "argumentl", "Argc", " argvin", "argumentv", "Argm", "matchv", "agver", "targetvin", "matchm", " argl", "parv", "argm", "argumentvs"], "p": ["n", "count", "tp", "pat", "np", "q", "b", "pb", "P", "m", "pt", "d", "at", "r", "pr", "cp", "ps", "pc", "fp", "l", "v", "ap", "u", "ping", "pattern", "jp", "g", "pp", "lp", "it", "a", "op", "t", "pl", "vp", "y", "h", "pkg", "f", "sp", "o", "j", "pos", "pa"], "nr_iov": ["NR_yon", "nr__iov", "etr_iov", "n__iv", "nr___iov", "n__iour", "nr_veh", "etr_ios", "nr_ovi", "nr___iour", "NR_ovi", "nr__veh", "etrmyibr", "n_iov", "nrmyij", "n_veh", "nr___iv", "nr_volt", "nr__iour", "nrmyios", "nrpyiv", "n__iov", "nr__iv", "nr_iour", "nrmyibr", "our_iv", "nrmyiov", "NR_iov", "nr_voice", "nr___veh", "our_iov", "etrmyij", "n_iv", "nrpyyon", "nr_yon", "n_iour", "nr_ij", "nr_ios", "our_volt", "etr_ibr", "nr_ibr", "nr_iv", "nrpyiov", "etr_ij", "nrpyovi", "etrmyios", "our_voice", "n__veh", "NR_iv", "etrmyiov"], "i": ["phi", "iu", "I", "n", "oi", "bi", "cli", "hi", "this", "iter", "li", "q", "ui", "b", "di", "status", "ii", "im", "mi", "ki", "ite", "ji", "\u0438", "ind", "ip", "ei", "v", "l", "ij", "ai", "x", "pi", "is", "in", "ini", "info", "zi", "g", "ic", "me", "qi", "xi", "ims", "ami", "it", "si", "ix", "ci", "t", "tim", "index", "multi", "y", "progress", "f", "id", "ti", "sim", "gi", "ri", "m", "j", "chain", "ex"], "c": ["k", "n", "count", "mc", "cmp", "ct", "b", "lc", "gc", "cc", "cp", "ec", "l", "cf", "v", "x", "e", "bc", "co", "dc", "xc", "g", "fc", "col", "o", "ac", "coll", "a", "cb", "C", "ce", "t", "cont", "abc", "unc", "h", "tc", "cl", "f", "cs", "vc", "ch", "m", "con"], "ctx": ["Context", "nt", "cmp", "today", "kt", "cp", "std", "cf", "crit", "nc", "history", "conn", "scope", "resp", "val", "txt", "module", "hw", "pkg", "cmd", "xp", "lc", "cu", "req", "window", "prefix", "dc", "jac", "gt", "xc", "mom", "cb", "expr", "loc", "iat", "px", "fn", "index", "ctl", "config", "wx", "bp", "np", "cookie", "utils", "ca", "cc", "ck", "sys", "co", "cm", "kw", "that", "addr", "msg", "tm", "cv", "tmp", "tx", "ctr", "cas", "ctrl", "k", "proc", "exec", "cfg", "ct", "func", "gc", "check", "timeout", "wrapper", "parent", "context", "tz", "conf", "fc", "handler", "settings", "t", "abc", "unc", "act", "obj", "tc", "acl", "client"], "acb": ["sacbr", "sacgb", "acB", "ACB", "accB", "accgb", " acsb", "acbd", "accbr", " acbd", "icbd", "icsb", " acB", " acgb", "acgb", "acsb", "sacb", "icb", "ACsb", "acbr", "sacB", " acbr", "icB", "accb", "ACbd", "ACb"], "optind": ["mmcond", "optimini", "altIND", "optcond", "optimind", "optini", "timeoutinn", "opIND", "altinder", "fitindex", "Optcount", "timeoutind", "stopine", "optimcond", "timeoutcond", "opinder", "optimloc", "OptIND", "optinf", "optimval", "opInd", "OptInd", "optnd", "optedIND", "optindex", "optedinf", "optiminf", "optedcond", "optwind", "optmind", "optionind", "timeoutindex", "optionmind", "Optindex", " optInd", "optloc", "Optinn", "optionindex", "optedind", "optionIND", "opcount", " optIND", "opnd", "stopinf", " optindex", "optionsmind", "mmind", "timeoutmind", "Optval", "opcond", "opindex", "optioninn", "fitind", "Optbind", "optionbind", "optval", "optinder", "optcount", "optedwind", "optbind", "ossind", "optiminn", "opind", "mmini", "optedloc", "optimmind", "ossval", " optwind", "optedindex", " optcount", "optimindex", "optinn", "altind", "optionsind", "fitIND", "optInd", "ossinn", "optionsindex", "mmmind", "optine", "Optind", "optimnd", " optcond", "optimine", "Optwind", "optimInd", "optedine", " optnd", "fitinder", "ossindex", "optIND", "optedInd", "optedbind", "stoploc", "stopind", "altindex", "timeoutini", "optionsinn"], "len": ["n", "count", "iter", "length", "cmp", "lit", "cp", "ll", "loop", "tl", "en", "coll", "val", "il", "ml", "pos", "lan", "lf", "repl", "bl", "str", "del", "lc", "alt", "lic", "L", "ler", " bl", "gt", "ele", "num", "ld", "fn", "pl", "mat", "pre", "els", "ln", "line", "led", "lib", "bin", "dl", "kl", "ell", "gl", "l", "body", "format", "elt", "lt", "all", "Len", "fl", "full", "msg", "sl", "lis", "compl", "lon", "el", "nl", "ellen", "li", "ls", "gen", "la", "mem", "offset", "fun", "fin", "url", "link", "lp", "doc", "le", "lif", "size", "err", "lig", "vec"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121, "substitutes": {"dest": ["dep", "iter", "target", "tr", "dist", "output", "seed", "rest", "mount", "cp", "est", "v", "port", "draw", "coord", "origin", "store", "trans", "it", "success", "delete", "transfer", "ptr", "address", "global", "pos", "gate", "transform", "comb", "status", "alt", "sum", "buf", "decl", "route", "st", "nom", "dc", "gest", "list", "host", "master", "loc", "dat", "last", "rel", "cont", "table", "desc", "add", "chain", "dim", "save", "Dest", "start", "match", "out", "good", "reverse", "search", "task", "copy", "addr", "msg", "usr", "tmp", "sp", "ctr", "result", "sort", "spec", "pipe", "axis", "orig", "reason", "temp", "comment", "src", "d", "opt", "check", "parent", "mem", "way", "shift", "source", "server", "dev", "wait"], "linesize": ["csizes", "valsize", "csize", "linesizer", " linesIZE", "valsizes", "linesIZE", "csizable", " linesizes", "inesizable", "csizer", "linesizable", " linesiz", "lsiz", "lsizes", "inesize", "lsize", "inesizes", "lsizable", "inesizer", "valsiz", "linesiz", "lsizer", "valsIZE", "lsIZE", "linesizes"], "block": ["param", "bl", "bin", "record", "unit", "point", "cell", "entry", "map", "check", "type", "ip", "word", "row", "field", "bf", "pixel", "list", "Block", "box", "group", "BL", "source", "link", "copy", "trans", "set", "stop", "load", "lock", "node", "join", "cl", "pack", "chain", "buffer", "event", "scan", "line"], "i": ["phi", "iu", "I", "n", "bi", "init", " v", "li", "iter", "q", " err", "ui", "point", " j", "batch", " m", "asi", "c", "di", "ii", "im", "mi", "ki", " bi", "ind", " I", "ip", "ai", "v", "ei", "is", "x", "pi", "ini", " pi", "zi", "ic", "me", "qi", "xi", "ims", " iter", " ti", " ii", "it", "si", "ix", "ci", "print", "index", "multi", "y", "ti", "sim", " x", "m", "j"], "cm": ["fm", "cut", "cr", "form", "mc", "cmp", "wm", "hm", "mask", "comm", "ct", "c", "ca", "lc", "com", "sem", "km", "gc", "mp", "cc", "cp", "fine", "csv", "pc", "mode", "mm", "asm", "ck", "dc", "gr", "co", "cn", "bm", "rm", "fc", "conf", "copy", "CM", "pm", "ym", "ci", "cont", "cv", "tc", "cl", "module", "mb", "ace", "mt", "rom", "cs", "um", "cmd", "vm", "cd", "ch", "gm", "ctr", "nm", "m", "cy", "mr"]}}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n        const char *desc_file_path)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 122, "substitutes": {"desc": ["bl", "rc", "pat", "seq", "comment", "dist", "lc", "pb", "path", "cur", "rec", "buf", "description", "ec", "pc", "out", "dc", "esc", "sc", "ctx", "doc", "resp", "cont", "txt", "ref", "phrase", "ptr", "asc", "des", "cmd", "err", "cd", "id", "label", "sub", "Desc"], "bs": ["bt", "BS", "bp", "bi", "bl", "bas", "qs", "lbs", "ses", "b", "bps", "pb", "ls", "bh", "ts", "its", "ps", "bn", "gs", "sys", "bc", "bf", "bm", "ks", "obs", "bos", "aos", "ms", "bis", "fs", "ds", "acs", "vs", "cb", "rs", "ns", "bits", "bank", "sb", "bd", "cs", "js", "ubs"], "desc_file_path": ["desc_file_name", "desc_File_name", "desc_file_Path", "desc_File_ref", "desc_File_Path", "desc_File_path", "desc_file_ref"], "ret": ["n", "gov", "rets", "iter", "hash", "nt", "re", "tr", "prot", "ber", "lit", "stay", "r", "ll", "rm", "deg", "ne", "ry", "run", "it", "value", "dt", "resp", "Ret", "val", "txt", "bool", "net", "cmd", "del", "jump", "att", "status", "after", "alt", "x", "def", "rev", "gt", "jp", "ft", "ter", "len", "backed", "last", "cont", "mt", "j", "get", "cat", "try", "inter", "arg", " Ret", "out", "format", "arm", "rt", "elt", "lt", "code", "RET", "rot", "state", "usr", "result", "rem", "flag", "det", "final", "fun", "arr", "reset", "res", "t", "cert", "obj", "err", "red", "print", "got", "back"], "access": ["test", "attr", "read", "ext", "view", "str", "seq", "use", "Access", "length", "mask", "ca", "att", "path", "array", "status", "ast", "ha", "max", "upload", "arch", "req", "est", "exclusive", "row", "accept", "ax", "assert", "esc", "name", "sc", "seek", "area", "url", "ac", "accessible", "key", "code", "ma", "pass", "acc", "sect", "ref", "index", "act", "alias", "asc", "usage", "cast", "ace", "sha", "aw", "id", "acl", "action", "config", "scan", "priv", "mode", "owner", "ex"], "type": ["Type", "tag", "otype", "test", "core", "null", "view", "time", "length", "cmp", "style", "error", "path", "ime", "status", "block", "description", " Type", "te", "sys", "title", "kind", "ping", "info", "file", "name", "port", "link", "key", "all", "code", "dt", "pe", "to", "types", "t", "class", "table", "ref", "ver", "index", "size", "color", "alias", "TYPE", "role", "cast", "shape", "address", "ty", "version", "action", "typ", "buffer", "range", "ype", "sort"], "fname": [" fpath", "fnames", " fnames", "Fnames", "fullname", "cfName", "fullnames", "fullpath", "fulltype", "ftype", " ftype", "lfName", "lftype", "Fname", "Fpath", "fpath", "fullName", "lfname", "FName", "fName", "Ftype", "cfname", "cfnames", "lfpath", "cfpath", " fName"], "p": ["s", "n", "tp", "pat", "rep", "q", "b", "c", "pb", "path", "P", "d", "pt", "pers", "r", "pr", "cp", "ps", "pc", "fp", "l", "v", "e", "ap", "ping", "jp", "g", "par", "pp", "lp", "t", "h", "y", "ptr", "f", "sp", "m", "j", "pa"], "flat_offset": ["flush_address", "flat_address", " flat_pos", "flatstartorigin", "flat_offs", "flat_op", "flatrowoffset", "utf_offset", "flatzoffset", "full_Offset", "flatstartpos", "flat__pos", "full_count", "flatMemdata", "flatzcount", "flatstartOffset", "flatrowlimit", "flat__origin", "flatMemOffset", "flat_shift", "flat_limit", "flatzshift", "flat___offset", "flush_data", "flat_origin", "flush_offset", "full_shift", "flat_data", " flat_offs", "flatrowset", "flatstartoffset", "full_offset", "flatrowop", "utf_op", "utf_limit", "flatMemaddress", "flatMemoffset", "utf_set", " flat_Offset", "flat___Offset", "flat_set", "flatzOffset", "flat___offs", "flat_Offset", "flush_Offset", " flat_origin", "flat_pos", "flat_count", "flat__Offset", "flat__offset"], "extent_path": ["extention_Path", "extent___path", "extention_group", "extend_path", "extents_path", "extend_name", "extent___name", "extent_group", "extent___file", "extend_Path", "extention_file", "extent_pointer", "extent_Path", "extend_pointer", "extention_path", "extents_file", "extent_name", "extent___pointer", "extend_file", "extents_name", "extents_Path"], "extent_file": ["extent2path", "extents_files", "extentipfile", "extentsfield", "extent_fp", "extentsfiles", "extents_path", "extentiparray", "extent_File", "extentsarray", "extent_field", "extent_array", "extent2files", "extent_base", "extentipfiles", "extentipfield", "extent2fp", "extent_files", "extant_File", "extend_files", "extent2file", "extend_array", "extant_base", "extentsfile", "extant_file", "extend_field", "extents_file", "extend_file", "extents_fp"], "local_err": ["localErstate", "locallyerr", "totallyerror", "localErcfg", "local___er", " local_msg", "masterlyattr", "master_conf", "local_er", "locallystate", "master_err", "local_state", "totallycfg", "locallysys", "local1sys", "total_state", "local___err", "local___rr", " local_error", "local1conf", "total_error", "masterlyconf", "master_attr", "locallyerror", "locallycfg", " local_res", " local_er", "total_err", "local1attr", "local_res", "local_rr", "local_error", "local1err", "local_cfg", "local_attr", "local___res", "master_sys", "localErerr", " local_rr", "totallystate", "local___attr", "locallyconf", "local_conf", "local___sys", "local___conf", "local_sys", "local_msg", "totallyerr", "masterlyerr", "locallyattr", "localErerror", "masterlysys", "total_cfg"], "extent": ["indant", "ordension", "indension", "xtent", "ordent", "xtend", "indent", "exent", "Extency", "extend", "extented", "xtented", "existant", "txtend", "exented", "Extant", "txtency", "extension", "extency", "txtant", "existency", "Extend", "exant", "exency", "existent", "Extent", "content", "contant", "ordency", "xtant", "contension", "contency", "extant", "ordant", "indency", "existented", "txtent", "xtency"]}}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy(AC3EncodeContext *s)\n\n{\n\n    int nb_coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            /* calculate calculate sum of squared coeffs for one band in one block */\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            /* compare sums to determine if rematrixing will be used for this band */\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            /* determine if new rematrixing flags will be sent */\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n", "idx": 149, "substitutes": {"s": ["n", "sg", "stats", "spec", "bs", "qs", "self", "ses", "services", "comm", "es", "b", "c", "ls", "syn", "p", "ts", "ps", "comments", "gs", "sys", "stat", "x", "e", "sync", "ops", "less", "parts", "ss", "g", "conf", "space", "source", "sv", "conv", "os", "fs", "ds", "eps", "a", "settings", "set", "sts", "ats", "times", "t", "ns", "rs", "bits", "http", "sb", "S", "scl", "sw", "span", "sq", "cs", "details", "js", "aws", "m", "j", "series", "ex"], "nb_coefs": ["nb_coefficienterences", "nb_conefls", "nb_conffs", "nb_conefficientsts", "nb_coecs", "nb_coeffe", "nb_conffe", "nb_conefficientsS", "nb_coufes", "nb_coffers", "nb_coafs", "nb_coecls", "nb_coafls", "nb_coefp", "nb_coefficientsts", "nb_conefers", "nb_conffers", "nb_coffe", "nb_coefficiente", "nb_coafers", "nb_coafts", "nb_couferences", "nb_coeffp", "nb_conefficientss", "nb_coufls", "nb_coeferences", "nb_coufS", "nb_coeffers", "nb_coefts", "nb_coeffs", "nb_confferences", "nb_coafes", "nb_coefls", "nb_coefficientsls", "nb_coefS", "nb_coefficientsers", "nb_coffls", "nb_conefes", "nb_conefS", "nb_coecp", "nb_codefts", "nb_coefficientss", "nb_coefficients", "nb_coafS", "nb_conefficientsers", "nb_codefs", "nb_coeffls", "nb_coefe", "nb_coefers", "nb_coefes", "nb_coffS", "nb_coufs", "nb_coefficienters", "nb_conefe", "nb_conefficientses", "nb_coefferences", "nb_coefficientserences", "nb_coneferences", "nb_coeffS", "nb_codefers", "nb_coefficientses", "nb_coefficientsS", "nb_coecerences", "nb_coffs", "nb_conefficientsls", "nb_coefficientsp", "nb_conefts", "nb_cofferences", "nb_conefs"], "blk": [" blunk", "lbunk", "silek", "silk", "BLn", "lbkk", " blkg", "bgck", "blekid", "blogunk", "glck", "glak", "blkid", "bgkid", "berk", "BLk", "glkid", "bleak", "lbck", "frtk", "blck", "lbkid", "blark", "glkk", "flck", "brck", " blek", "brkid", "blogck", " blkh", "brk", "bleek", "bleck", "berak", "bertk", "blkk", "lbk", "frk", "blek", " blark", "blkh", " blck", "frck", " blak", "brkk", "silak", "bln", "flkk", "lbark", "glkh", "bgk", "lbak", "blogk", "bgkg", " blkk", "blkg", "blekk", "blen", "BLkid", " blkid", "flkh", "glk", "frak", "brn", "silkk", "blogark", "berck", "bltk", "blak", "brak", "flk", "blunk", " bltk", "BLck", "brkg"], "bnd": ["bend", "bld", "bdd", "blnd", "bbind", "bbdir", "bbd", "bgn", "ynd", " bond", "abbd", "lbd", "bbng", "brbd", "brind", "abond", "hnd", " bust", "bneck", "ubnd", "bck", " bdd", "blend", "bhnd", "abst", "abck", "ubdir", "brust", "blond", "abdj", "bbst", "bbond", "lld", "blck", "hbd", "bhnt", " bst", "bond", " bend", "brnd", "lnt", "abnt", "ybd", "hst", "tnd", "bbund", "yust", "hld", " bneck", "lend", " bgn", " bind", " bund", "ubdd", "bbdd", "brnt", "bldj", "abld", "bbnt", "bng", "bhneck", "lnd", "lst", "bdj", " bck", "bbgn", " bnt", " bbd", "abend", " bld", "tng", "brld", "brgn", "abnd", "bust", "abneck", "brst", "bind", "bhld", "brend", " bdj", "bund", "bbld", "tond", "bbbd", "bbnd", "bnt", "ubund", "bst", "tnt", "bdir", "abng", "blnt", "ynt", " bdir"], "i": ["phi", "k", "iu", "I", "n", "oi", "bi", "cli", "hi", "this", "li", "ui", "b", "di", "status", "start", "ii", "uri", "mi", "ki", "p", "ji", "\u0438", "ind", "ip", "ei", "v", "is", "ij", "ai", "u", "x", "pi", "ori", "io", "in", "ini", "info", "zi", "ic", "me", "qi", "xi", "ami", "it", "si", "ix", "ci", "print", "index", "multi", "y", "id", "ti", "gi", "ri", "m", "j", "series", "PI"], "block": ["record", "one", "blocking", "loop", "plugin", "sync", "zone", "scope", "part", "object", "cl", "clip", "bl", "pool", "unit", "jump", "bus", "map", "window", "row", "x", "prefix", "def", "command", "list", "file", "bit", "group", "BL", "book", "clus", "no", "pack", "pop", "chain", "buffer", "line", "box", "bin", "blocks", "point", "new", "p", "wall", "condition", "ip", "ck", "out", "number", "field", "set", "manager", "bank", "join", "sp", "unknown", "base", "instance", "k", "filter", "mask", "b", "volume", "byte", "local", "type", "check", "bc", "Block", "network", "link", "flow", "layout", "load", "lock", "zero", "obj", "snap", "skip", "bo"], "block0": ["bl0", " blockk", "bl2", "group2", "groupk", "group1", "box0", "box1", "bl1", "Block0", "Blockk", "Block2", "Block1", " block1", "block1", "blockk", "block2", "group0", " block2"], "sum": ["sam", "count", "stack", "use", "hash", "Sum", "put", "cmp", "up", "summary", "see", "post", "comment", "average", " Sum", "tu", "status", "cache", "max", "ut", "match", "mem", "ge", "cal", "sky", "sun", "stat", " SUM", "info", "score", "num", "sat", "all", "doc", "ma", "set", "si", "gram", "total", "process", "msg", "share", "zero", "size", "dict", "cast", "us", "scale", "mu", "su", "ass", "um", "mean", "add", "sim", "cum", "vol", "result", "save", "fac", "sort"]}}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164, "substitutes": {"x0": ["x180", "t1", "X2", "tx00", "X0", "t3", "xn", "ox25", "ix25", "x25", "Xn", "x2", "rx1", "t2", " x2", "ox0", "tx0", "ix1", " xn", "xt0", " x25", "x3", " x180", "t0", "ox1", "x4", "rx3", "tn", "xt4", " x00", "t00", "X1", "tx1", "tx3", " x4", "tx2", "ox180", "ix0", " x3", "rx0", "ox4", "xt1", "x00", "rx2", "ix180"], "x1": ["tone", "t1", "vOne", "t3", "v01", "x2", " xone", "t2", " x2", "xone", "tx0", "t01", "x3", "t0", " x01", "xx3", "xx0", " xOne", "tOne", "v0", "v1", "tx1", "xxone", "x01", "xOne", "tx2", "txOne", " x3", "xx1"]}}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n", "idx": 176, "substitutes": {"env": ["proc", "gov", "En", "ef", "nv", "entry", "Ev", "environment", "buf", "NV", "req", "ve", "window", "v", "vv", "next", "esc", "menu", "ctx", "en", "conn", "doc", "code", "end", "viron", "ov", "server", " ens", "gear", "txt", "vp", "cv", "dev", "uv", "obj", "priv", "desc", "qv", "event", "ah", "ev", " environment"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178, "substitutes": {"env": ["proc", "stack", "w", "map", "environment", "buf", "window", "v", "vv", "web", "bar", "e", "context", "info", "name", "en", "code", "end", "vs", "txt", "disk", "cv", "dev", "uv", "buffer", "config", "vec", "ev"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n", "idx": 179, "substitutes": {"s": ["service", "n", "spec", "stats", "iss", "bs", "qs", "events", "ses", "services", "comm", "utils", "es", "b", "ags", "ares", "ls", "states", "w", "ains", "ts", "uns", "ps", "comments", "changes", "south", "gs", "is", "sys", "st", "tests", "less", "parts", "ss", "ers", "se", "ms", "ims", "sis", "source", "os", "sv", "ies", "fs", "ds", "sts", "ats", "params", "rs", "ns", "as", "sb", "S", "y", "sw", "h", "sq", "cs", "hs", "details", "js", "aws", "j", "bes"], "link_down": ["linkydown", "linkedopen", "linkedmin", "linkentarget", "close_down", "link_open", "link_setup", "linkeddown", "linkedown", "link_off", "link42down", " link_open", "link_desc", "linkymin", "linklytarget", "linkenfull", "linkydowns", "match_down", "link_full", "ink_setup", "link_free", "closeydowns", "match_full", "linklydown", "linkendown", "linkenfree", "ink_off", "link_target", "link_min", "link_now", "matchenfull", " link_up", "linkityfree", "match_free", " link_min", "close_desc", "matchenfree", " link_own", "link_downs", "close_downs", "matchentarget", "closeydown", "linkitydown", " link_now", "link64downs", "link_up", "ink_downs", "link42min", "linkitytarget", "link42downs", "ink_down", "closeydesc", "linkityfull", "linkydesc", "link64min", "linklyfree", "linklyfull", "matchendown", "link64desc", "link42desc", "link_own", "match_target", "closeymin", "link64down", "close_min"]}}
{"project": "FFmpeg", "commit_id": "3547f8e8f8418af0c578eba0de62ecba08e460c2", "target": 0, "func": "static int rv34_decode_mv(RV34DecContext *r, int block_type)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int i, j, k, l;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int next_bt;\n\n\n\n    memset(r->dmv, 0, sizeof(r->dmv));\n\n    for(i = 0; i < num_mvs[block_type]; i++){\n\n        r->dmv[i][0] = svq3_get_se_golomb(gb);\n\n        r->dmv[i][1] = svq3_get_se_golomb(gb);\n\n    }\n\n    switch(block_type){\n\n    case RV34_MB_TYPE_INTRA:\n\n    case RV34_MB_TYPE_INTRA16x16:\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        return 0;\n\n    case RV34_MB_SKIP:\n\n        if(s->pict_type == AV_PICTURE_TYPE_P){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n            break;\n\n        }\n\n    case RV34_MB_B_DIRECT:\n\n        //surprisingly, it uses motion scheme from next reference frame\n\n        /* wait for the current mb row to be finished */\n\n        if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n\n            ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0);\n\n\n\n        next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride];\n\n        if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        }else\n\n            for(j = 0; j < 2; j++)\n\n                for(i = 0; i < 2; i++)\n\n                    for(k = 0; k < 2; k++)\n\n                        for(l = 0; l < 2; l++)\n\n                            s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);\n\n        if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) //we can use whole macroblock MC\n\n            rv34_mc_2mv(r, block_type);\n\n        else\n\n            rv34_mc_2mv_skip(r);\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        break;\n\n    case RV34_MB_P_16x16:\n\n    case RV34_MB_P_MIX16x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n        break;\n\n    case RV34_MB_B_FORWARD:\n\n    case RV34_MB_B_BACKWARD:\n\n        r->dmv[1][0] = r->dmv[0][0];\n\n        r->dmv[1][1] = r->dmv[0][1];\n\n        if(r->rv30)\n\n            rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        else\n\n            rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);\n\n        break;\n\n    case RV34_MB_P_16x8:\n\n    case RV34_MB_P_8x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n\n        if(block_type == RV34_MB_P_16x8){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n\n            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n\n        }\n\n        if(block_type == RV34_MB_P_8x16){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n\n            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n\n        }\n\n        break;\n\n    case RV34_MB_B_BIDIR:\n\n        rv34_pred_mv_b  (r, block_type, 0);\n\n        rv34_pred_mv_b  (r, block_type, 1);\n\n        rv34_mc_2mv     (r, block_type);\n\n        break;\n\n    case RV34_MB_P_8x8:\n\n        for(i=0;i< 4;i++){\n\n            rv34_pred_mv(r, block_type, i, i);\n\n            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);\n\n        }\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 185, "substitutes": {"r": ["n", "cr", "attr", "this", "rar", "rc", "fr", "q", "self", "re", "rd", "vr", "b", "c", "rb", "response", "kr", "ir", "d", "w", "rg", "rec", "rect", "p", "rw", "v", "hr", "e", "u", "gr", "rm", "g", "rt", "ocr", "rn", "ar", "rr", "o", "or", "adr", "ry", "br", "sr", "er", "res", "rs", "t", "rel", "usr", "obj", "h", "R", "nr", "err", "m", "result", "ro", "mr"], "block_type": ["block___type", "Block_status", "Block_name", "blockitytype", "blocketyname", "blocketyType", "block___length", "blocketystatus", "blocktypet", "block_t", "Block_t", "byte_role", "block_status", "block2type", "block2Type", "block___role", "block2status", "block_key", " block_kind", "blockitykey", " block_Type", "block___key", "Block_Type", "block_Type", "byte_length", "Block_TYPE", "Block_type", "blocketytype", "blockitylength", "blockityrole", "block_TYPE", "blocktypetype", "block_length", "block_kind", " block_name", "blocktypeTYPE", "block_name", "block2name", "blocktypeType", "block_role", "byte_key", "byte_type"], "s": ["n", "ants", "eds", "south", "is", "v", "ops", "parts", "fs", "ds", "eps", "sr", "gets", "bits", "sb", "h", "y", "sq", "hs", "sports", "bs", "ses", "c", "ims", "conv", "os", "sv", "a", "vs", "sts", "ats", "as", "session", "details", "qs", "events", "utils", "states", "p", "ps", "sys", "less", "ss", "ms", "ar", "bis", "params", "times", "args", "sl", "sp", "aunts", "m", "sam", "spec", "stats", "xs", "comm", "es", "b", "ls", "w", "als", "ts", "its", "changes", "gs", "e", "g", "conf", "settings", "rs", "t", "ns", "ins", "S", "sw", "f", "cs", "js", "aws", "o"], "gb": ["bt", "vg", "fb", "kb", "bs", "yg", "eb", "gd", "Gb", "uf", "bg", "cfg", "b", "rb", "gow", "gh", "rg", "fg", "rect", "gc", "py", "gs", "pi", "cm", "bm", "bf", "gt", "g", "gif", "deg", "meg", "sv", "gu", "cb", "si", "nb", "now", "hub", "sb", "bb", "tm", "goo", "hog", "GB", "cv", "bd", "gam", "mb", "sl", "eg", "gg", "gm", "tg", "range", "gy", "ch", "db"], "i": ["phi", "iu", "I", "bi", "hi", "iter", "li", "ui", "batch", "b", "c", "asi", "di", "ii", "m", "mi", "im", "ki", "uri", "p", "iso", "ji", "ip", "ind", "is", "v", "ai", "ij", "x", "u", "pi", "in", "ini", "info", "zi", "list", "ic", "qi", "xi", "key", "ami", " ii", "it", "si", "ix", "ci", "index", "multi", "h", "y", "span", "z", "f", "id", "ski", "ti", "sim", "gi", "ri", "o"], "j": ["uj", "n", "bi", "jc", "q", "b", "jump", "m", "p", "dj", "ji", "ja", "v", "ij", "jj", "jp", "g", "key", "kj", "aj", "z", "jl", "ch", "J", "o"], "k": ["n", "K", "q", "ka", "kk", "sk", "km", "w", "ki", "p", "ck", "v", "mk", "u", "ke", "ks", "g", "ik", "o", "key", "ko", "kj", "kh", "z", "ch", "m", "kg"], "l": ["n", "el", "nl", "li", "length", "lc", "ls", "p", "ll", "v", "L", "e", "g", "len", "o", "lp", "loc", "le", "lv", "pl", "lock", "il", "h", "sl", "ln", "lo", "m"], "next_bt": ["next_cb", " next_BT", "next___gt", "next____bt", " next___bt", "next_bc", " next_bc", " next___bc", "next_gt", " next_gb", "next_BT", "next___gb", "next____BT", "next___bc", "next____bc", " next___cb", "next____cb", " next_cb", " next___BT", "next_gb", "next___cb", " next_gt", "next___BT", "next___bt"]}}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}", "idx": 200, "substitutes": {"bs": ["db", "BS", "bp", "stats", "iss", "lbs", "bas", "bytes", "b", "blog", "bps", "pb", "ls", "bus", "bh", "bolt", "ts", "its", "ps", "fps", "gs", "sys", "bc", "socket", "prefix", "obs", "bos", "box", "ctx", "os", "bis", "fs", "ds", "vs", "gb", "lb", "rs", "ns", "bits", "sb", "bb", "hz", "obj", "cs", "hs", "js", "ubs", "boot"], "target": ["bt", "db", "view", "this", "secondary", "b", "jump", "task", "src", "path", "dest", "launch", "trigger", "map", "bolt", "local", "ts", "arg", "type", "p", "match", "stable", "parent", "window", "v", "next", "template", "kit", "gt", "super", "port", "source", "link", "origin", "handle", "it", "host", "scope", "stop", "master", "to", "total", "manager", "t", "rel", "table", "device", "home", "primary", "root", "join", "obj", "dev", "compatible", "Target", "arget", "address", "sp", "range", "buffer", "result", "top"], "replaces": ["vrechanges", "progex", "greps", "comforms", "complaces", "Replaced", "replace", "compps", "REplaces", "reforms", "creplace", "prechanges", "creps", "creplaces", "reps", "breplaced", "remplace", "prochanges", "remplaces", "proplaces", "regex", "Reps", "complaced", "crechanges", "rechanges", "preforms", "vreps", "creforms", "REpps", "breps", "breforms", "Rebs", "Replaces", "pregex", "REforms", "Replace", "vreplaces", "greplays", "preplays", "cregex", "preps", "breplaces", "repps", "replays", "creplaced", "preplaces", "greplaces", "rebs", "rembs", "REps", "proforms", "REplaced", "replaced", "preplaced", "crebs", "vreplays", "prepps", "grechanges", "remplaced", "remps"], "speed": ["sql", "count", "stats", "peed", "length", "engine", "status", "sn", "slow", "capacity", "seed", "height", "frequency", "fps", "timeout", "delay", "offset", "rate", "sex", "sync", "command", "port", "seek", "force", "flags", "fast", "sleep", "priority", "rates", "size", " speeds", "sw", "scale", "weight", "address", "skip", "buffer", "scroll", "Speed"], "granularity": ["angulus", "gunity", " granly", "cosulus", "gunular", "ranulus", "ranular", "gunulation", "cosularity", "ranity", "severularity", "severity", "granity", "genularity", "circulus", "ranularity", "cosular", "granality", "angule", " granule", "cumity", "hangulation", " granular", "ranulation", "cumular", "genulus", "hangularity", "genly", "genulation", "granule", "circularity", "granulus", "angity", "hangular", "angularity", "granly", "cosulation", "gunule", "severular", " granulus", " granality", "gunularity", "cumularity", "sanulus", "sanality", "granulation", "sanularity", "gunality", "circulation", "granular", "genity", "sanity", "cumulus", "gunulus", "genular", "circular", " granity", "severly", "hangity"], "buf_size": ["buf_sum", "buf_space", "uf_sum", "poolitylimit", "buffer_space", "bufitylimit", "bg_size", "buf_Size", "bg3len", "buffer_SIZE", "buf3len", "uf_SIZE", "buf2limit", "bufitycount", "buf_lock", "buf2count", "buflenlock", "buf_count", "buf2capacity", "bufitysize", "pool_limit", "buf3capacity", "buf2len", "pool_lock", "buf2lock", "bg3capacity", "pool_count", "bg3size", "buflenlimit", "buffer_Size", "poolitylock", "buf_limit", "uf_len", "buf_len", "poolitycount", "buf3size", "buf2size", "pool_size", "bufitylock", "uf_size", "buf_capacity", "buffer_size", "buflencount", "bg_len", "bg_capacity", "poolitysize", "buf_SIZE", "buflensize"], "on_source_error": ["on_sourceaccessror", "on_sourceceptiondanger", "on_sourcefulerr", "on_sourcelogdanger", "on_sourcefuldanger", "on_target__err", "on_source__error", "on_target__danger", "on_target_err", "on_target_tag", "on_source__danger", "on_sourcelogror", "on_source_tag", "on_source_err", "on_sourcelogtag", "on_target_danger", "on_target_ror", "on_source_node", "on_sourceceptionror", "on_source_change", "on_source__ror", "on_sourcefulerror", "on_target__error", "on_sourcelogerror", "on_sourceaccessnode", "on_target_change", "on_sourcefulror", "on_target__ror", "on_source__err", "on_source_danger", "on_sourceceptiontag", "on_target_node", "on_source__change", "on_sourceceptionerror", "on_sourceaccesserror", "on_source_ror"], "on_target_error": ["on_target_fail", "on_source_result", "on_targetlyror", "on_source_fail", "on_targetlyerr", "on_targetlyerror", "on_target_result", "on_target_option", "on_target2ror", "on_target2error", "on_source_err", "on_target2fail", "on_target_ror", "on_target_catch", "on_source_ror", "on_source_catch", "on_target_err", "on_source_option", "on_targetlycatch"], "unmap": ["Unmaps", "UNpack", "unpack", "unmaps", " unpack", "Unpack", "unmask", " unmask", "Unmap", " unmaps", "UNmaps", "UNmask", "UNmap", "Unmask"], "cb": ["CB", "proc", "bp", "rc", "eb", "cmp", "cfg", "b", "rb", "c", "obb", "pb", "func", "src", "cp", "buf", "cc", "fp", "cf", "ck", "callback", "bc", "dc", "fun", "bf", "fc", "obs", "ctx", "gb", "nb", "lb", "fn", "call", "cv", "cs", "cmd", "cd", "ctrl", "db"], "opaque": ["opsacity", "ipatile", " oplay", "opatile", "pplex", "oplacement", "opacity", "play", "opacement", "opsaque", "paque", "oplaque", "ipacement", "oplacity", " opplex", "ipacity", "opsatile", "pacity", "opsacement", " opacity", "opplex", "oplatile", "iplay", "oplay", "ipaque", "ipplex"], "errp": ["arrp", "erpa", " errm", " errps", "errpp", "sprpa", "errorr", " errpr", "rrm", "derp", "errpa", "herP", "erps", "krp", " errr", "arrpa", "errorpc", "rrpp", "rerp", "arrpr", "erpp", "errpc", "herp", "erp", "errps", "errorps", "rerpad", "herpp", " errsp", "erm", "krpa", "erP", "sprp", "rrP", "errr", "rerpc", "rrp", "sprpr", "rrsp", "errorp", "sprP", "rerpid", "errorpid", "errpad", "errm", "krP", "errP", "derpid", "rersp", "krm", "errorpad", " errpa", "errsp", "derpad", "rerm", "err", "arrP", "errpr", "errorP", " errP", "errpid", "derpc", "herm"], "driver": ["Driver", "service", "core", "builder", "browser", "utils", "dist", "native", "finder", "bus", "ctor", "type", "wrapper", "description", "river", "window", "tool", "drivers", "definition", "handler", "box", "force", "handle", "host", "manager", "der", "docker", "proxy", "hub", "device", "drive", "ver", "setup", "dev", "dr", "writer", "desc", "js", "version", "owner", "db"], "is_none_mode": ["is_noneammode", "is_noneamenabled", "is_None_enabled", "is_nonebermode", "is_none_mate", "is_nonebermessage", "is_noneamMode", "is_none_Mode", "is_no_Mode", "is_no_mode", "is_none_message", "is_None_mode", "is_noneberMode", "is_None_Mode", "is_none_enabled", "is_no_mate", "is_None_message"], "base": ["back", "ase", "bound", "shadow", "null", "support", "bp", "bas", "enabled", "b", "start", "cache", "p", "bal", "local", "stable", "parent", "bid", "ip", "is", "bar", "bare", "sys", "based", "prefix", "kit", "super", "bit", "source", "force", "scope", "origin", "store", "history", "server", "background", "it", "Base", "master", "state", "root", "scale", "id", "buffer", "boot", "db", "top"], "s": ["sports", "n", "ports", "single", "stats", "qs", "ses", "comm", "es", "b", "c", "uploads", "ls", "d", "pers", "w", "als", "p", "ts", "its", "ps", "i", "l", "gs", "is", "v", "sys", "e", "sync", "less", "ss", "search", "ims", "ms", "sv", "os", "bis", "fs", "ds", "store", "set", "settings", "vs", "sts", "ats", "gets", "rs", "ns", "t", "S", "y", "h", "locks", "sl", "sq", "f", "cs", "hs", "details", "js", "aws", "m", "j", "actions", "ex"]}}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "substitutes": {"qi": ["quer", "qu", "dq", "iu", "imei", "oi", "ogi", "qua", "qs", "cgi", "q", "yi", "ia", "ii", "cu", "ki", "uti", "eni", "agi", "i", "eur", "ei", "IQ", "pi", "fi", "qq", "aki", "ugi", "ini", "zi", "mic", "ik", "cci", "omi", "iq", "qa", "ci", "qt", "chi", "Ni", "iqu", "sq", "qv", "ti", "ku", "aq"]}}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);", "idx": 244, "substitutes": {"ctx": ["Context", "rc", "mc", "cmp", "ct", "c", "ca", "cu", "kt", "cp", "cc", "pc", "mem", "context", "bc", "cm", "jac", "kw", "xc", "jp", "fc", "sc", "conn", "cb", " cx", "ci", "abc", "txt", "unc", "cv", "tc", "setup", "obj", "pkg", "tmp", "cmd", "tx", "care", "cas", "ctrl"], "gb": ["bt", "vg", "ib", "fb", "kb", "yg", "eb", "Gb", "bytes", "gd", "uf", "bg", "cfg", "rb", "gh", "rg", "gc", "py", "rl", "bn", "wb", "again", "img", "asm", "gs", "csv", "bf", "gt", "gif", "g", "deg", "bsp", "cb", "nb", "px", "hub", "sb", "bb", "pg", "GB", "mb", "eg", "storage", "gg", "tg", "gm", "buffer", "db"], "vlc": ["wlcs", "cilc", "tlt", "rll", "rlv", "wlc", "wlv", "tlc", "lvt", "vll", "rlc", "tlcs", "wlci", "rlcs", "tlci", "vlcs", "cilcs", "vlt", "cilv", "cill", "vlv", "lvci", "wll", "wlt", "vlci", "lvcs", "lvc"], "symbols": ["Symbol", "symmbels", "symbles", "symmsials", "Sympol", "sympials", "syphels", "sychels", "syembles", "sembs", "symsels", "syphles", "syembols", "Sympels", "symples", "sembels", "sychol", "sympols", "Sympols", "symbors", "symmbials", "sembles", "semss", "Symbors", "symmsels", "sychors", "semsols", "symmsles", "symbels", "sympol", "sympors", "syphols", "syembials", "sychols", "Symbels", "sympels", "symsles", "symmbles", "sembols", "syphol", "symbials", "symbs", "semsles", "symmbols", "symss", "Sympors", "semsels", "symsols", "symmsols", "syphs", "syphors", "syembels", "symbol", "Symbols", "symps", "symsials"], "bits": ["ports", "dates", "stats", "bs", "blocks", "nets", "bytes", "utils", "rots", "items", "bps", "values", "issues", "ints", "fixes", "bles", "states", "jobs", "cuts", "lists", "its", "tops", "ps", "tags", "cells", "ops", "fits", "parts", "obs", "keys", "bit", "lines", "checks", "bis", "versions", "flags", "settings", "ats", "gets", "words", "bars", "cats", "ins", "weights", "files", "plugins", "locks", "pins", "details", "ubs", "errors", "pieces"], "codes": ["sections", "ones", "xs", "bs", "images", "blocks", "scripts", "bytes", "items", "bps", "values", "ints", "fixes", "states", "modules", "lists", "cache", "cells", "tags", "comments", "terms", "classes", "lines", "keys", "headers", "checks", "versions", "flags", "code", "cod", "types", "cats", "maps", "odes", "ids", "cs", "inters", "names", "errors"], "num_lens": ["num_Languages", "num_lates", "num_rans", "num_lans", "num_leis", "num_lsens", "num_lents", "num_Lms", "num_leens", "num_lems", "num_lsiens", "num_lms", "num_lsuns", "num_Liens", "num_leuns", "num_Lans", "num_lsates", "num_Lates", "num_rents", "num_rens", "num_leates", "num_ranguages", "num_lsis", "num_luns", "num_Luns", "num_Lis", "num_lis", "num_Lens", "num_Lents", "num_liens", "num_lsents", "num_lsms", "num_leiens", "num_leents", "num_languages"], "num_codes": ["num_ones", " num_objects", "num_checks", " num_cats", "num_bits", "num_cats", "NUM_odes", " num_planes", " num_bits", " num_checks", " num_errors", "num___odes", "num___codes", " num_ones", "num___obs", "num_obs", "num___checks", "num___cats", "num_errors", "num_planes", "num___planes", "num_code", "NUM_codes", "NUM_obs", "num_objects", "num___code", "num_odes", "NUM_cats", " num_code"], "num_codes_sum": ["num_lines_map", "num_codes2count", "num_codes___count", "num_values_sum", "num_codes_num", "num_codes2sum", "num_codes2num", "num_lines_count", "num_lines_total", "num_images_sum", "num_codes__sum", "num_codes_se", "num_images_Sum", "num_lines_sum", "num_codes_total", "num_codes2max", "num_codes_msg", "num_lines2up", "num_images_num", "num_lines_up", "num_codes_Sum", "num_codes2total", "num_codes___map", "num_codes_map", "num_lines_max", "num_values_count", "num_codes_count", "num_codes___sum", "num_lines2total", "num_codes__total", "num_codes2map", "num_lines2sum", "num_codes__max", "num_codes_max", "num_codes_size", "num_values_msg", "num_values_size", "num_codes__up", "num_images_se", "num_codes_up", "num_lines2max", "num_images_count", "num_codes2up"], "prefix": ["n", "bp", "localhost", "init", "length", "fix", "point", "batch", "mask", "post", "fixes", "status", "path", "cache", "height", "p", "max", "pointer", "timeout", "pad", "ind", "offset", "missing", "next", "pi", "power", "quote", "len", "term", "reset", "origin", "key", "code", "position", "master", "ix", "radius", "counter", "base", "priority", "alpha", "ref", "zero", "index", "alias", "root", "size", "lock", "pre", "pkg", "scale", "padding", "none", "version", "chain", "label", "password", "print", "sequence"], "i": ["phi", "ish", "iy", "iu", "n", "I", "s", "bi", "hi", "this", "li", "q", "ui", "b", "c", "di", "start", "ii", "im", "at", "p", "ji", "l", "ip", "ind", "ai", "is", "v", "ij", "offset", "x", "e", "pi", "in", "ini", "info", "zi", "jp", "ims", "xi", "ami", "it", "si", "ix", "iq", "ci", "index", "ie", "multi", "y", "id", "ti", "gi", "m", "io"], "j": ["k", "uj", "other", "n", "jc", "fr", "q", "adj", "b", "jump", "c", "att", "at", "oj", "pt", "pr", "p", "dj", "ji", "on", "l", "ja", "ge", "v", "ij", "x", "e", "jj", "jac", "jp", "g", "o", "br", "key", "it", "jit", "kj", "ix", "aj", "index", "bj", "obj", "y", "z", "json", "jl", "js", "J", "m", "job"], "count": ["n", "core", "hash", "length", "nt", "cache", "mount", "ind", "loop", "next", "common", "queue", "score", "ount", "handle", "success", "process", "id", "close", "range", "test", "child", "batch", "c", "status", "max", "sum", "req", "missing", "list", "len", "num", "found", "cont", "table", "index", "amount", "Count", "z", "add", "chain", "read", "new", "find", "start", "try", "create", "out", "number", "race", "info", "current", "name", "key", "code", "set", "state", "depth", "ctr", "level", "scroll", "result", "base", "summary", "temp", "comment", "write", "frequency", "type", "conf", "total", "counter", "now", "ref", "size", "call", "cast", "weight", "err", "cycle", "sequence"]}}
{"project": "FFmpeg", "commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "target": 1, "func": "static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,\n\n                                  CodedBitstreamUnit *unit)\n\n{\n\n    BitstreamContext bc;\n\n    int err;\n\n\n\n    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n\n    if (err < 0)\n\n        return err;\n\n\n\n    switch (unit->type) {\n\n    case HEVC_NAL_VPS:\n\n        {\n\n            H265RawVPS *vps;\n\n\n\n            vps = av_mallocz(sizeof(*vps));\n\n            if (!vps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_vps(ctx, &bc, vps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_vps(ctx, vps);\n\n            if (err < 0) {\n\n                av_free(vps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = vps;\n\n        }\n\n        break;\n\n    case HEVC_NAL_SPS:\n\n        {\n\n            H265RawSPS *sps;\n\n\n\n            sps = av_mallocz(sizeof(*sps));\n\n            if (!sps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_sps(ctx, &bc, sps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_sps(ctx, sps);\n\n            if (err < 0) {\n\n                av_free(sps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = sps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_PPS:\n\n        {\n\n            H265RawPPS *pps;\n\n\n\n            pps = av_mallocz(sizeof(*pps));\n\n            if (!pps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_pps(ctx, &bc, pps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_pps(ctx, pps);\n\n            if (err < 0) {\n\n                av_free(pps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = pps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_TRAIL_N:\n\n    case HEVC_NAL_TRAIL_R:\n\n    case HEVC_NAL_TSA_N:\n\n    case HEVC_NAL_TSA_R:\n\n    case HEVC_NAL_STSA_N:\n\n    case HEVC_NAL_STSA_R:\n\n    case HEVC_NAL_RADL_N:\n\n    case HEVC_NAL_RADL_R:\n\n    case HEVC_NAL_RASL_N:\n\n    case HEVC_NAL_RASL_R:\n\n    case HEVC_NAL_BLA_W_LP:\n\n    case HEVC_NAL_BLA_W_RADL:\n\n    case HEVC_NAL_BLA_N_LP:\n\n    case HEVC_NAL_IDR_W_RADL:\n\n    case HEVC_NAL_IDR_N_LP:\n\n    case HEVC_NAL_CRA_NUT:\n\n        {\n\n            H265RawSlice *slice;\n\n            int pos, len;\n\n\n\n            slice = av_mallocz(sizeof(*slice));\n\n            if (!slice)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n\n            if (err < 0) {\n\n                av_free(slice);\n\n                return err;\n\n            }\n\n\n\n            pos = bitstream_tell(&bc);\n\n            len = unit->data_size;\n\n            if (!unit->data[len - 1]) {\n\n                int z;\n\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n\n                       \"from slice data.\\n\", z);\n\n                len -= z;\n\n            }\n\n\n\n            slice->data_size = len - pos / 8;\n\n            slice->data = av_malloc(slice->data_size);\n\n            if (!slice->data) {\n\n                av_free(slice);\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(slice->data,\n\n                   unit->data + pos / 8, slice->data_size);\n\n            slice->data_bit_start = pos % 8;\n\n\n\n            unit->content = slice;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_AUD:\n\n        {\n\n            H265RawAUD *aud;\n\n\n\n            aud = av_mallocz(sizeof(*aud));\n\n            if (!aud)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n\n            if (err < 0) {\n\n                av_free(aud);\n\n                return err;\n\n            }\n\n\n\n            unit->content = aud;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 245, "substitutes": {"ctx": ["wx", "rc", "np", "nt", "mc", "cmp", "ka", "comm", "grad", "cfg", "ct", "func", "cond", "cu", "kt", "gru", "kl", "gc", "cp", "cc", "req", "xy", "pc", "ck", "sys", "context", "jac", "kw", "xc", "jp", "fc", "conf", "nc", "sc", "conv", "history", "conn", "voc", "cb", "cci", "wcs", "iat", "unc", "act", "cv", "tc", "setup", "etc", "hw", "pkg", "cl", "ctl", "cmd", "tx", "vc", "config", "cas"], "unit": ["tag", "other", "test", "note", "volt", "init", "nit", "reason", "bin", "man", "relation", "item", "nu", "volume", "byte", "plain", "tu", "block", "gem", "kt", "uu", "type", "sum", "uint", "vol", "word", "out", "condition", "connection", "attribute", "number", "prefix", "category", "units", "command", "format", "bit", "document", "num", "force", "task", "un", "doc", "it", "position", "Unit", "mun", "piece", "lock", "device", "element", "module", "tc", "package", "no", "du", "option", "application", "mu", "su", "net", "um", "cmd", "version", "domain", "term", "unt"], "bc": ["wic", "bt", "bp", "ba", "bridge", "bi", "bs", "rc", " BC", "mc", "exec", "comm", "bg", "b", "c", "ca", "BBC", "lc", "ct", "bitcoin", " db", "gc", "bn", "cc", "ec", "ll", "lic", "pc", "dc", "bf", " buf", "CBC", " bo", "fc", "ic", "aos", "sc", "nc", "bec", "voc", "cb", " dc", " cx", " ba", "BC", "clus", "sb", "bb", "abl", "uc", " ac", "bd", "tc", "circ", "cs", "vc", " ic", "bo"], "err": [" arr", "iter", "yr", "erd", "any", "error", "kr", "rank", "r", "pr", "late", "die", "br", "or", "ry", "aaa", "resp", "er", "fee", "val", "order", "shr", "y", "actor", "cmd", "errors", "priv", "nr", "test", "cr", "str", "empty", "init", "ait", "gz", "vr", "drm", "buf", "req", "warn", "rev", " terr", "ach", " er", " Err", "der", "expr", "rel", "extra", "cer", "typ", "term", "virt", "eas", "mr", "attr", "rc", "fr", "rb", "plain", "try", "ell", "l", "Error", "sys", "trace", "here", "norm", "elt", "exc", "rn", "rr", "later", "code", " ec", "msg", "usr", "dr", "Er", "level", "notice", "result", "css", "lr", "rar", "diff", "erer", " br", "ier", "cfg", "rez", " error", "oe", "arr", "conf", "fer", "eor", "res", "rs", "ner", "hz", "dev", " cr", "js", "ev"], "vps": ["vinports", "avports", "vcps", " vts", "wPs", "vinists", " vjs", "wps", " vports", " veps", "vplets", "vtists", "vcips", "vjs", "vpoints", "verps", "verplays", " vPs", "nvports", "vcpoints", " vmes", "avts", "vgs", "vcpps", "vtpy", "vceps", " vplets", " vpass", " vplays", "vports", " vpoints", "avp", "verpps", "vcases", "vcplays", "vips", "verars", "vinases", "vp", "vicjs", "vinpy", "avps", "vtplets", "vpps", "vinplets", "vmes", "vicplays", "victs", "vmps", "weps", "vcplets", "vars", "vinps", " vases", "wplays", "vases", "vPs", "veps", " vp", "vicps", " vips", "vtps", "vcp", "vcpass", "avpoints", "vcmes", "vmpy", " vgs", "avips", "nvpass", "vcports", "vcars", "vcts", "nvts", "vists", "vings", "vcPs", " vpps", "vpy", "vpass", "verts", "vmists", " vars", "vcgs", "avmes", "vplays", "nvps", "verplets", "vmplets", "vts", "verjs"], "sps": ["paps", "vesops", " sts", "pmp", " spped", "ospps", "spps", "sips", "ismp", "vesps", "ppt", "iesPS", "svPS", " smp", " saps", " seps", "hops", "spr", "sveps", "seps", "svpr", "ppl", "gPS", "jsss", " sPS", " spl", "rsips", "ppps", "osPS", "Sps", "saps", "esps", "gpr", "SPS", "haspps", "sts", " spt", "gps", "smp", "ispps", "Spps", "vesips", "iesps", "jspl", "iesplets", "rsps", "sops", "sms", "svps", "vests", " sops", "spl", "spt", "esms", "espr", "Splets", " sss", "jsaps", "sss", "hasips", "sPS", "hts", "hasps", " spr", "osps", "haspped", "isms", "pss", "hps", " sips", "rspped", "rspps", " sms", "hips", "spped", "splets", "jsps", " splets", "oseps", "ispt", "isps", "ispr", "geps", "Seps", "Spr", " spps", "iespps", "espt"], "pps": ["stats", "xs", "helps", "php", "kk", "sticks", "ppo", "hands", "bps", "dds", "ppa", "ls", "opers", "clips", "trak", "fps", "ps", "tops", "ups", "fx", "upp", "houses", "pres", "oops", "ops", "phones", "ks", "cpp", "hops", "apps", "ppers", "acts", "pp", "ips", "aps", "eps", "params", "rpm", "pots", "px", "places", "psc", "ods", "phys", "amps", "mph", "phis", "caps", "makes", "pes", "ears", "ppings"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n", "idx": 246, "substitutes": {"opaque": ["iopument", "popaque", "opque", "popque", "iopacity", "opacity", "opument", "ipula", "ipque", "popacity", " opque", "opula", "ipacity", "obument", "obaque", " opacity", " opula", "iopula", "popument", "ipaque", "obacity", "popula", "iopaque", "obula"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248, "substitutes": {"priv": ["proc", "pro", "attr", "access", "rc", "api", "Pri", "por", "path", "pr", "pad", "auth", "iv", "mem", "disabled", "pub", "pi", "Priv", "info", "conn", "riv", "adv", "serv", "private", "phys", "debug", "ptr", "pkg", "env", "alloc", "pri", "DEV", "ev", "prop"], "id": ["tag", "aid", "str", "init", "wid", "var", "ident", "ide", "rid", "vid", "hash", "uid", "did", "status", "start", "path", "type", "ID", "oid", "bid", "ip", " tid", "kind", "info", " rid", "name", "num", "mid", " mid", "key", "end", "addr", "sid", " pid", "iden", "ref", "h", "ids", " fid", "kid", "pid", "Id"], "bulk_packet": ["bulk_packedet", "bulk_buckets", "bulk_buckatcher", "bulk_paramet", "bulk_payets", "bulk_packedacket", "bulk_packedatcher", "bulk_bucket", "bulk_bucker", "bulk_messer", "bulk_picket", "bulk_packets", "bulk_packET", "bulk_payette", "bulk_payon", "bulk_bucketting", "bulk_packeder", "bulk_headette", "bulk_picketer", "bulk_parametting", "bulk_payacket", "bulk_paramacket", "bulk_signets", "bulk_buckpoint", "bulk_headET", "bulk_payetting", "bulk_messacket", "bulk_packer", "bulk_packon", "bulk_ippet", "bulk_header", "bulk_ippetting", "bulk_packseter", "bulk_decacket", "bulk_octet", "bulk_payet", "bulk_packset", "bulk_packetting", "bulk_ippET", "bulk_decet", "bulk_payer", "bulk_pickacket", "bulk_messpoint", "bulk_signeter", "bulk_packser", "bulk_bucketer", "bulk_signon", "bulk_octacket", "bulk_parameter", "bulk_payET", "bulk_octatcher", "bulk_deceter", "bulk_buckette", "bulk_packpoint", "bulk_decetting", "bulk_octpoint", "bulk_signacket", "bulk_buckon", "bulk_signET", "bulk_buckacket", "bulk_octer", "bulk_packatcher", "bulk_packette", "bulk_packacket", "bulk_messet", "bulk_payeter", "bulk_pickET", "bulk_packeter", "bulk_headet", "bulk_packsacket", "bulk_ipper", "bulk_buckET", "bulk_signet"], "data": ["ad", "DATA", "ata", "db", "read", "this", "str", "empty", "input", "bin", "length", "bytes", "batch", "any", "di", "error", "d", "block", "w", "rec", "cache", "p", "reader", "ret", "buf", "pad", "type", "mem", "window", "out", "Data", "def", "result", "len", "name", "fin", "all", "value", "sequence", "params", "dat", "resp", "full", "load", "val", "bits", "zero", "text", "device", "size", "done", "obj", "extra", "raw", "mu", "f", "sent", "rew", "none", "action", "buffer", "tx", "off", "pos", "box"], "data_len": ["data_en", "data_ln", "data00rel", "ata2length", "file_lan", " data_en", "data00fun", "buffer_rel", "buffer00fun", "data0len", "data00Len", "buffer00Len", "ata_len", "data_length", "ata_en", "ata_length", "data_lan", "ata_ln", "data00len", "data0Len", "file_ln", "data2en", "data_rel", "ata2en", "file_length", " data_Len", "ata2len", "data_Len", "buffer00rel", "buffer_fun", "buffer_Len", "ata2Len", "data0length", "data2len", "data0en", "buffer_len", "data2length", "data2Len", "data_fun", "file_len", " data_length", "ata_Len", "buffer00len"], "dev": ["db", "ad", "test", "proc", "pro", "stick", "prom", "app", "var", "school", "nt", "api", "tr", "d", "w", "Device", "p", "av", "sd", "pad", "iv", "ve", "mem", "window", "v", "sys", "pub", "pi", "def", "info", "conf", "ctx", "cam", "conn", "link", "go", "riv", "adv", "Dev", "tech", "serv", "device", "wd", "home", "ver", "debug", "obj", "ptr", "pack", "hw", "des", "raw", " Dev", "hid", "cmd", "DEV", "scan", "env", "ev", "prop"], "aurb": ["aucby", "urchm", "aurbd", "aub", "augl", " aurbot", "augdb", "averrb", "urchbot", "augbar", "aernb", "augb", "aurm", "arialnb", "arialby", "arryb", "urchnb", "aurbi", "thurm", "aucbi", "thurl", "vaeb", "augnb", "aurdb", "aurB", "nargb", "aimB", "thurgb", "urchl", "aharnb", "aerba", "aurbr", "aharbi", "aucnb", "auggb", "aerbase", "aucgb", "augbd", "afferrb", "urchbr", "ahardb", "urchbo", "urib", "arrysb", "urb", "aurbot", "thurbar", "affernb", "urchbase", "narl", "urchdb", "auf", "aurab", "urchB", "augbind", "aurbind", "augbi", "afferb", "auraa", "thurB", "auraf", "urchbi", "averb", "arryib", " aurbind", "urchbind", "thurfb", "arrybase", "aura", "aucbo", "aurbo", "aucf", "vaeba", "narbar", "thurbo", "urchb", "aurbb", "aua", "aerbb", "aurba", "aharb", "aurib", "aimba", "augbot", "thurb", "arialb", "urchba", "thurf", "aul", "arryba", "aimb", "aursb", "aurgb", "aurbase", "arialf", "thurbd", "aurfb", "urchfb", "aurl", "aucfb", "arrybb", "urchby", "narb", "aucrb", "aerbr", "urchbb", "vaesb", "ursb", "urchf", "aurf", "afferbr", "aurnb", "vaeib", "averba", "thurrb", "urba", "aurbar", "averbi", "thura", " aurdb", "urchrb", "urchgb", "aerb", "aerrb", "urchbd", "aimrb", "thurba", "aucb", "aucba", "aurby", "augm", "aural", "aurrb"]}}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262, "substitutes": {"avctx": ["afctx", "devctx", "avcontext", "vcmp", "avecp", "AVtx", "AVcontext", "avtx", "vrctx", "AVconf", "aftx", "avconn", "avecfg", "afcontext", " avxy", "aveconn", "apctx", "vrcp", "apcontext", "avconf", "verconn", " avcmp", "vercontext", " avcp", "vcfg", "vctx", "AVctx", "vercfg", "apconn", "AVconn", "verctx", " avcontext", "devconf", "avectx", "avecontext", "avcp", "devconn", "vrxy", "vcontext", "vrcontext", "apconf", "devcontext", " avconn", "avxy", " avcfg", " avtx", "avcfg", "avecmp", "afconn", "avcmp", "avexy"], "s": ["n", "services", "is", "v", "sync", "parts", "ies", "store", "fs", "ds", "eps", "gets", "sb", "y", "h", "sq", "hs", "sports", "single", "bs", "ses", "c", "status", "st", "ims", "sv", "os", "a", "vs", "sts", "ats", "z", "details", "j", "save", "has", "ports", "qs", "utils", "states", "p", "ps", "comments", "l", "sys", "less", "ss", "ms", "set", "params", "so", "args", "sl", "sa", "m", "spec", "stats", "self", "comm", "es", "b", "ls", "als", "local", "ts", "its", "changes", "gs", "stat", "g", "conf", "se", "sc", "source", "rs", "ns", "t", "ins", "S", "sw", "ess", "cs", "js", "aws"], "i": ["n", "oi", "cli", " multi", "uri", "mi", "rest", " si", " mi", " I", "ai", "v", "ei", "ij", "ic", "it", "si", "y", "id", "ti", "io", "phi", "iu", "bi", " v", "q", "ui", " m", "c", "di", "status", "adi", " info", "x", "ori", "fi", "ini", "zi", "xi", " ti", "ami", " ii", "multi", "chain", "sim", "ri", "j", "I", " li", "point", "asi", "ki", "try", "p", " bi", "l", "ip", "info", "ix", "ci", " ki", " ni", "span", "gi", "m", "k", "spec", "li", " j", "b", "ii", "remote", "ji", "\u0438", "u", "pi", " pi", "g", "me", "qi", "res", "t", "print"]}}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n", "idx": 265, "substitutes": {"avctx": ["vcontext", "avcontext", "AVtx", " avtx", "AVcontext", "avtx", " avcontext", "avcc", " avcc", "AVcc", "vtx", "vctx", "AVctx", "vcc"], "s": ["sam", "sg", "stats", "spec", "ports", "bs", "qs", "ses", "comm", "services", "es", "c", "ssl", "ls", "status", "d", "w", "als", "p", "ts", "its", "ps", "changes", "gs", "v", "is", "sys", "ops", "less", "parts", "ss", "ims", "source", "sv", "os", "ips", "bis", "ds", "eps", "set", "vs", "settings", "sts", "ats", "params", "er", "a", "t", "rs", "ns", "serv", "args", "sb", "S", "session", "sw", "h", "sq", "cs", "sp", "hs", "details", "js", "aws"], "length": ["count", "ENGTH", "form", "q", "duration", "angle", "be", "c", "hl", "th", "capacity", " Length", "height", "p", "type", " lengths", "l", "v", "L", "number", "x", "pi", "message", "Length", "len", "history", "lp", "end", "position", "available", "enth", "full", "total", "load", "t", "component", "text", "bb", "size", "h", "f", "shape", "padding", "buffer", "term", "ength", "data", "sequence"], "n": ["nl", "np", " N", "nt", "an", "nu", "c", "na", "d", "ot", "ni", "sn", "w", "p", "ul", "l", "v", "x", "nan", "cn", "len", "num", "mn", "ne", "network", "en", "o", "all", "ng", "it", "Len", "nb", "t", "ns", "N", "size", "no", "y", "net", "nn", "nm", "m", "j"], "i": ["oi", "cli", "uri", "mi", "ni", "ind", "ai", "is", "ei", "ij", "ic", "it", "si", "ie", "y", "id", "ti", "PI", "phi", "ish", "io", "iu", "bi", "hi", "init", "ui", "batch", "di", "ir", "status", "at", "ini", "list", "zi", "ims", "xi", "ami", "iq", "index", "multi", "chain", "sim", "ri", "j", "I", "this", "point", "im", "ki", "l", "ip", "ix", "ci", "gi", "ex", "li", "ii", "ji", "\u0438", "u", "e", "pi", "in", "me", "qi", "gu", "esi", "progress", "print"], "r": ["cr", "lr", "ra", "rar", "rc", "re", "art", "tr", "rd", "rb", "c", "d", "rg", "ru", "rect", "rl", "rx", "l", "rf", "hr", "rate", "ur", "e", "gr", "u", "rm", "rt", "rn", "ar", "rr", "br", "a", "sr", "er", "res", "rs", "dr", "R", "nr", "red", "ri", "ro", "mr"], "g": ["q", "gd", "bg", "c", "gh", "G", "ger", "gen", "rg", "fg", "gc", "p", "ug", "l", "ge", "ga", "gs", "u", "gr", "gt", "reg", "green", "group", "ig", " G", "gu", "mg", "go", "msg", "gb", "pg", "gam", "gravity", "gy", "eg", "gp", "gg", "gm", "tg", "gi"], "b": ["ib", "ba", "fb", "bi", "ab", "bs", "eb", "bin", "blue", "bg", "rb", "be", "c", "by", "d", "p", "l", "bar", "v", "bc", "u", "ob", "bf", "bit", "br", "bis", "a", "cb", "gb", "nb", "beta", "base", "sb", "bb", "obj", "z", "f", "bo", "j", "db", "B"]}}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n", "idx": 272, "substitutes": {"opaque": ["cataques", "opque", "open", " Opque", "iopane", "iopaques", "ospen", "opsolete", "ospaque", "ipaques", "catane", "hopque", " Opsolete", "hopaques", "ipque", "hopaque", "hopsolete", "iopen", "opane", "ospane", " Opaques", "caten", "ospaques", "ipaque", "cataque", "opaques", "ipsolete", "iopaque", " Opaque"], "addr": ["ad", "ack", "attr", "ag", "wid", "work", "rc", "hash", "ident", "art", "from", "src", "r", "map", "alt", "inter", "pad", "align", " address", "ip", "asm", "offset", "prefix", "rt", "coord", "ord", "handle", "adr", "arp", "host", "ix", "aj", "rs", " af", "ref", "act", "ange", "alias", "obj", "ptr", "dr", "ace", "hw", "address", "add", "tx", "id", "alloc"], "value": ["vector", "time", "seq", "length", "unit", "values", "byte", "block", "w", "VALUE", "map", "memory", "type", " address", "mem", "v", "attribute", "field", "number", "message", "image", "name", "store", "set", "total", "msg", " data", "val", "state", "content", "ue", " val", "weight", "address", "padding", "buffer", " Value", "data", "Value", "sequence"], "size": ["s", "count", "empty", "length", "bytes", "style", "start", " Size", "sn", "sum", "type", "mem", "window", "offset", "number", "ize", "message", "len", "name", "space", "set", "si", "total", "fee", "sid", "amount", "SIZE", "scale", "sha", "z", "storage", "shape", "address", "Size", "data", "sy"], "attrs": ["attrr", "attrrs", "attrls", "attr", "attributes", " attr", "attrributes", "ttributes", "ttrs", " attributes", "ttr", " attls", "ttls", "attls"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280, "substitutes": {}}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289, "substitutes": {"dev": ["de", "ad", "spec", "dem", "nt", "vr", "start", "d", "w", "usb", "sd", "buf", "pad", "ve", "mem", "vol", "v", "sys", "dis", "dd", "def", "info", "cam", "conn", "link", "ach", "gu", "adv", "res", "Dev", "val", "serv", "device", "ver", "obj", "hw", "des", "priv", "cmd", "DEV", "scan", "env", "data", "ev"], "conf": ["param", "cmp", "cache", "cp", "cons", "cf", "asm", "change", "bm", "crit", "conn", "fs", " Conf", "fam", "module", "cmd", "prop", "init", "app", "comb", "c", "map", "auth", "decl", "ion", "def", "command", "conv", "irm", "cb", "acc", "inf", "config", "vol", "con", "aff", "lib", "Conf", "cell", "com", "cc", "arch", "aux", "cal", "inv", "cm", "co", "info", "ctx", "nb", "phys", "sp", "ch", "compl", "spec", "proc", "cap", "comm", "cfg", "comment", "cond", "confirmed", "sky", "parse", "disc", "cn", "res", "ns", "apache", "ref", "hz", "obj", "f", "cs", "fac"], "serial": ["sql", "soft", "spec", "cho", "vector", "token", "zip", "micro", "encrypted", "initial", "ident", "final", "normal", "custom", "temp", "Serial", "path", "phone", "sem", "usb", "bus", "tty", "mobile", "iso", "sector", "quant", "random", "selected", "description", "select", "psy", "optional", "sys", "template", "sex", "sync", "chip", "technical", "power", "virtual", "chron", "special", "sat", "mot", "ionic", "res", "pocket", "serv", "material", "device", "primary", "phys", "ver", "color", "successful", " Serial", "specific", "raw", "erial", "json", "id", "version", "ser", "human", "vol", "boot", "series", "slot"], "s": ["n", "services", "r", "i", "south", "is", "v", "sync", "store", "fs", "ds", "gets", "http", "sb", "h", "y", "sq", "hs", "sports", "bs", "app", "ses", "c", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "https", "des", "details", "j", "ports", "qs", "utils", "p", "ps", "less", "ss", "tests", "ms", "set", "params", "args", "sl", "sp", "service", "spec", "stats", "comm", "es", "b", "ls", "w", "ts", "its", "changes", "gs", "e", "csv", "g", "se", "source", "settings", "rs", "ns", "t", "serv", "ins", "S", "cs", "js", "aws", "simple"], "cylinders": [" sidewcles", "oblograms", "oblcles", "cylograms", " sidewinders", "cylainers", "oblsers", " sidewsers", "rocketours", "rocketiners", "cylours", "cellours", "rocketainers", "celliners", "cellinders", "cellainers", "cylcles", "dylainers", "dylinders", "dyliners", "ylinders", "oblinders", "ylograms", "cyliners", "ylsers", " sidewograms", "dylours", "rocketinders", "cylsers", "ylcles"], "heads": ["cles", "ads", "helps", "cycles", "reads", "bs", "tips", "blocks", "anches", "masters", "offs", "uploads", "links", "head", "quarters", "olds", "views", "storms", "nuts", " Heads", " bends", "hops", "headers", "inks", " hangs", "forces", "stocks", "ths", "thens", "hz", "loads", "locks", "headed", "tails", "HEAD", "uds", "aunts", "mers"], "secs": [" secats", " secd", "townls", "threadn", "secats", "Secats", "townd", " secps", "ecs", "ecls", "towns", "secd", " secls", "ecps", "secn", "threads", "Secls", "Secps", "threadls", " secn", "Secs", "townn", "secps", "ecats", "secls", "threadd"], "virtio_blk_id": ["virtio_blk_index", "virtio_blck_ref", "virtio_blk_i", "virtio_blks_index", "virtio_blck_no", "virtio_blk_ref", "virtio_blk_no", "virtio_blk_info", "virtio_blks_id", "virtio_blck_id", "virtio_blks_ref", "virtio_blks_info", "virtio_blck_i"], "dinfo": [" dinformation", "edinfo", "xinfo", "dishow", "arddetails", "Dinformation", "DInfo", "Dinf", "mdshow", " ddetails", "Dinfo", "dInfo", "diinfo", "ardInfo", "ardinfo", "dshow", "ddetails", "edinf", "xInfo", "Ddetails", "dinf", " dinf", "didetails", " dInfo", "eddetails", "xinformation", "xinf", "mdinf", "diinf", "mdinfo", " dshow", "dinformation", "edInfo", "mddetails"]}}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n", "idx": 304, "substitutes": {"buf": ["bp", "read", "bl", "bs", "cap", "bin", "q", "uf", "b", "c", "rb", "pb", "cur", "block", "w", "Buff", "r", "bh", "p", "wb", "mem", "window", "out", "v", "cf", "bc", "ob", "bf", "queue", "box", "ctx", "cb", "msg", "txt", "text", "cv", "h", "Buffer", "obj", "pkg", "tmp", "raw", "cmd", "err", "buffer", "buff", "data", "vec", "alloc"], "magic": ["tag", "bug", "spec", "flag", "hash", "md", "length", "pic", "cookie", "style", "metadata", "volume", "xxx", "mag", "iso", "type", "offset", "header", "prefix", "icy", "pi", "chip", "power", "format", "kind", "info", "mic", "ic", "handler", "mid", "Magic", "serial", "code", "flags", "meta", "h", "policy", "eric", "agic", "sha", "phy", "padding", "cmd", "id", "version", "kid", "icon", "vol", "data"], "s": ["str", "bs", "self", "q", "b", "c", "r", "p", "ts", "ps", "gs", "v", "sys", "e", "ss", "g", "sv", "fs", "ds", "a", "t", "rs", "ns", "as", "sb", "S", "ins", "h", "f", "cs", "sp", "js", "m"], "len": ["lf", "n", "el", "ext", "lib", "nl", "str", "wid", "li", "seq", "iter", "length", "bytes", "nt", "ls", "hl", "pos", "gen", "dl", "lim", "kl", "syn", "alt", "ll", "l", "mem", "v", "L", "fun", "mil", "g", "elt", "nc", "num", "fin", "mn", "en", "mid", "lp", "limit", "Len", "coll", "fl", "doc", "ld", "loc", "msg", "le", "t", "val", "pl", "vec", "size", "enc", "sl", "ln", "lang", "fil", "padding", "err", "vol", "data", "lan"], "buflen": ["buplun", "buplar", " buplar", "buglun", "buglen", "BUglan", " buplen", " buflength", "BUglength", "buselar", "buglan", "buplength", "bullar", "buplen", "buclength", "BUflen", "bullen", " buplength", "BUflan", "BUglun", "BUflun", "buglength", "buselength", "buflun", "BUflength", "buselen", "bullength", "buplan", "buclan", "buclun", " buplun", "buflar", "buclen", "buflan", "buflength", "buselun", " buflun", " buflar", "bullun", "BUglen"], "ext_backing_fmt": ["ext_backing_fats", "ext_backing_lats", "ext_backing_vlt", "ext_backing_ftm", "ext_backing_vmt", "ext_backing_ftx", "ext_backing_lmt", "ext_backing_fmmt", "ext_backing_fformat", "ext_backing_vtx", "ext_backing_mlt", "ext_backing_mnt", "ext_backing_fnt", "ext_backing_vtm", "ext_backing_flt", "ext_backing_mmt", "ext_backing_mformat", "ext_backing_mats", "ext_backing_lnt", "ext_backing_fmats", "ext_backing_lformat", "ext_backing_ltx", "ext_backing_fmnt", "ext_backing_mtx", "ext_backing_ltm", "ext_backing_llt", "ext_backing_fmformat", "ext_backing_mtm"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n", "idx": 305, "substitutes": {"c": ["cr", "rc", "mc", "ct", "lc", "com", "cur", "cu", "gc", "p", "anc", "cache", "cc", "ec", "pc", "l", "cf", "v", "e", "dc", "bc", "cm", "co", "cn", "fc", "conf", "g", "nc", "ctx", "ac", "coll", "cb", "C", "ce", "t", "ci", "cont", "abc", "enc", "etc", "tc", "f", "cs", "cd", "m", "con"], "pb": ["ib", "bp", "tp", "fb", "ab", "bs", "np", "uf", "b", "rb", "td", "pt", "dp", "p", "mp", "pan", "cp", "wb", "buf", "pc", "fp", "ap", "bc", "jp", "pp", "ctx", "lp", "cb", "pm", "PB", "nb", "lb", "pl", "sb", "bb", "vp", "pg", "cv", "tc", "ub", "pkg", "wp", "sp", "erb", "db", "pa"], "atom": ["sam", "attr", "ext", "str", "app", "form", "orb", "normal", "event", "emb", "xml", "item", "b", "ct", "kat", "att", "byte", "entry", "oat", "at", "m", "arb", "p", "prop", " orb", "asm", "het", "x", "ap", "ob", "format", "om", " om", "chem", "num", "coord", "o", "or", " form", "addr", "msg", "canon", "tar", "component", "node", "abc", "mat", "atomic", "orm", "tm", "obj", "element", "phys", "tem", "ace", "raw", "f", "tmp", "cmd", "nm", "ch", "buffer", "typ", "term", "tab", "data", "ata"], "st": ["s", "bt", "ist", "inst", "stack", "str", "ust", "fr", "nt", "tt", "step", "et", "art", "ct", "td", "nd", "start", "th", "ast", "sn", "pt", "at", "rest", "p", "ut", "ts", "est", "stable", "std", "sh", "stat", "stage", "St", "ss", "must", "rt", "stan", "se", "sc", "ste", "ost", "sta", "end", "set", "stop", "sts", "so", "t", "sb", "usr", "sty", "etc", "mt", "irst", "sw", "sl", "ST", "sp", "tra"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321, "substitutes": {"listener": ["nullender", "openable", "listeners", "LISTener", "listenable", "Listenable", "Listender", "nullener", "LISTenable", "opender", "leners", "nulleners", "Listener", "lender", " listeners", " listenable", "Listerer", "lener", "opener", "LISTender", "lenable", "openers", "LISTerer", "listerer", "listender", " listerer", " listender"], "d": ["de", "ad", "dq", "n", "dn", "pd", "b", "c", "di", "did", "dl", "w", "r", "p", "sd", "i", "e", "dc", "dd", "D", "g", "ord", "o", "ds", "dt", "ld", "dat", "t", "da", "dm", "fd", "bd", "dict", "dr", "du", "dra", "f", "m", "j", "dx", "db"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "substitutes": {"bpp": [" bip", "pip", "rpl", "ppps", "bpl", " bpl", "rpps", "bff", " bff", "rPP", "psp", "cip", "dpps", "cpps", "bpps", "sbff", "cpp", "dPP", "rpp", "bsp", "cPP", " bsp", "bip", "ppl", "sbpp", " bpps", "sbpl", "pff", "ppp", "sbsp", "dpl", "dpp", "bPP", "cpl"], "buf": ["proc", "fb", "cat", "cap", "iter", "seq", "np", "bin", "aka", "ait", "pool", "que", "emb", "batch", "uf", "grad", "b", "rb", "func", "kat", "pb", "cur", "block", "w", "Buff", "r", "map", "cache", "req", "feat", "img", "window", "aux", "v", "bar", "bc", "empty", "def", "queue", "list", "deg", "result", "cam", "conv", "br", "doc", "cb", "msg", "fam", "agg", "bag", "ref", "mat", "act", "pg", "cv", "pack", "pkg", "raw", "phy", "cmd", "desc", "err", "nm", "buffer", "buff", "data", "vec", "db", "prop"]}}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338, "substitutes": {"netdev": ["Netprivate", "netconn", " networkdev", "NETdef", "webdef", " netDev", " netconn", "webdev", "netDev", "NETDev", "netprivate", "NetDev", " netdevice", "NETconn", "webDev", "NETdevice", "webconn", "netdef", "netdevice", " netprivate", " networkDev", " networkprivate", "Netdev", " netdef", "NETdev", "webdevice"], "name": ["n", "ame", "ename", "nam", "cap", "ident", "new", "path", "channel", "family", "p", "local", "type", "ip", "prefix", "who", "info", "file", " Name", "key", "host", "part", "table", "order", "Name", "filename", "alias", "NAME", "no", "package", "size", "address", "named", "id", "version", "names", "chain", "data", "base"], "peer": ["proc", "tp", "via", "pipe", "eth", "pool", "verified", "target", "self", "ker", "ssl", "worker", "channel", "remote", "p", "local", "player", "type", "stable", "parent", "pc", "connection", "socket", "ping", "ter", "connected", "handler", "pod", "server", "host", "pe", "er", "slave", "node", "peak", "soc", "package", "pkg", "actor", "holder", "sp", "chain", "buffer", "ser", "owner", "client", "instance"], "errp": [" errm", "timerps", "derpat", " errps", "derpb", "timerp", "rerps", " errpid", "dangerp", "errping", "errpa", "derp", "rrm", "errpb", "ererp", "derm", "rerp", "errpat", "timerpart", "dercp", "errorpat", "ererpart", "errps", "erp", "ierpat", "errorps", "erpat", "iercp", "erP", " errpat", "dangerpat", "errorpart", "ererps", "rrp", "errorpa", "errorp", "rerpid", "errorpid", "timerpat", "ierpb", "errcp", "erercp", "errm", "ererpat", " errping", "errP", "derping", "rrping", "ierp", " errpa", "dangerP", "errpart", "rerpa", " errP", "errpid", "ererpb"], "tap": ["tp", "tt", "tr", "kat", "td", "tw", "cp", "apt", "port", "raf", "conn", "arp", "tk", "ape", "tif", "hap", "wan", "package", "amp", "tab", "wt", "atom", "test", "transform", "app", "pool", "rep", "batch", "comb", "att", "pb", "th", "dp", "map", "pai", "pin", "ach", "ta", "TP", "dat", "pl", "table", "tf", "vp", "pack", "wp", "tg", "cat", "plant", "tu", "channel", "p", "lat", "pan", "wat", "ap", "trace", "ping", "format", "attach", "submit", "pp", "tun", "op", "tar", "tm", "tmp", "sp", "trip", "bat", "Tap", "pa", "capt", "each", "atten", "cap", "ten", "ts", "trap", "parse", "t", "tim", "tc", "snap", "buff"], "fd": ["lf", "fm", "fb", "pipe", "ff", "fr", "gd", "rd", "ud", " fin", "func", "td", "d", "dl", "tty", "fa", "hd", "sd", "buf", "fe", "fp", "cf", "socket", "dc", "fi", "dd", "bf", "FD", "fc", "file", "port", "fin", "raf", "handler", "df", "handle", "fs", "ds", "dt", "fl", "cb", "ld", "dat", "draft", "dir", "fee", "tif", "fn", "da", "flo", "disk", "bd", "ptr", "du", "fed", "dra", "f", "ctl", " fid", "result", "pid", "db", "io"], "queues": ["quesUES", "plues", "tenue", "QueUES", "tenums", "peots", "quesots", "quesues", "quesue", "quesums", "quesants", "tenued", "quues", "quue", "quesued", "plued", "plue", "queants", "queots", "queue", "tenants", "peued", "tenots", "Queue", "quUES", "peues", "queUES", "queued", "peants", "tenues", "queums", "plums", "Queues"], "script": ["method", "execute", "sql", "capt", "test", "shadow", "attr", "pipe", "lib", "spec", "rc", "magic", "scripts", "exec", "style", "comment", "control", "png", "type", "description", "timeout", "shell", "fun", "template", "sync", "parse", "command", "Script", "driver", "handler", "source", "sc", "push", "server", "run", "profile", "cmd", "action", "cript", "parser", "ssh"], "downscript": ["downScript", " downfunction", "DOWNscript", "offScript", "Downstyle", " downstyle", "ownScript", "owntemplate", "offbutton", "downtemplate", "ownscript", "evenbutton", "DOWNfunction", "Downfunction", "ownbutton", "downfunction", "DownScript", "Downscript", "DOWNScript", "downbutton", "eventemplate", "DOWNstyle", "offscript", " downScript", "evenScript", "offtemplate", "downstyle", "evenscript"], "err": ["inner", "test", "cr", "attr", "lr", "str", "init", "empty", "rc", "iter", "fr", "gz", "erd", "cfg", "error", "kr", "plain", "try", "r", "anne", "ered", "buf", "aer", "rx", "req", "warn", "Error", "sys", "e", "rm", "rev", "arr", "conf", "elt", "exc", "norm", "rn", "rr", "eor", "ev", "aaa", "cb", "timer", "der", "er", "msg", "resp", "res", "rs", "fee", "order", "obj", "progress", "ptr", "dr", "later", "ln", "Er", "cmd", "ch", "errors", "notice", "result", "eas", "urg", "mr"], "vhostfdname": ["vhostFDspec", "vhoststreamnam", "vhostfcname", "vhoststreamName", "vhostfdnum", "vHostFDnam", "vHostFDnames", "vhostflName", "vHostfdn", "vhostflspec", "vhoststreamname", "vhostfxnam", "vhostFDnam", "vHostfdname", "vhostFDnames", "vhostfnName", "vhostfxName", "vHostfdnames", "vhostfdName", "vHostfdspec", "vhostFDnum", "vHostFDid", "vhostfnnum", "vhostdirName", "vhostFDid", "vHostFDName", "vhostflname", "vhostdirn", "vhostdirname", "vHostfdnam", "vhostflnum", "vhoststreamid", "vhostfdnam", "vhostfnspec", "vhostFDn", "vhostfdn", "vhostfcn", "vhostfcName", "vHostFDspec", "vHostfdName", "vhostfxid", "vhostFDname", "vhostfdid", "vhostfdnames", "vhostdirnames", "vHostFDnum", "vhostfnname", "vHostFDname", "vhostfdspec", "vhostFDName", "vHostfdnum", "vHostfdid", "vHostFDn", "vhostfcnames", "vhostfxname"], "ifname": ["Ifnames", "ifaddress", "Ifaddress", "fnames", "fname", "fullname", "ifnames", "fullnames", "fulladdress", "Ifname", "faddress"], "fds": [" fuds", "ccs", "fuds", "wds", "cds", "wuds", "fdds", "cdds", "wcs", "cuds", "fcs", " fcs", " fdds", "wdds"], "vhost_fds": ["vhost_lds", "vhost_lrs", "vhost_luds", "vhost_frs", "vhost_fdds", "vhost_ifdds", "vhost_cuds", "vhost_ldds", "vhost_cdds", "vhost_crs", "vhost_ifuds", "vhost_cds", "vhost_ifds", "vhost_ifrs", "vhost_fuds"], "nfds": ["exec", "func", "c", "block", "_", "def", "call", "ctl", "cmd", "config"], "i": ["phi", "k", "I", "n", "cli", "iter", "c", "di", "ii", "r", "p", "ind", "ip", "ai", "v", "ij", "pi", "fi", "it", "si", "ci", "index", "f", "id", "ti", "m", "j"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369, "substitutes": {"job_id": ["jobIdid", "jobIdids", "job_Id", "jobNameid", "job__ids", "job_source", "jobNameids", "jobIdsource", "job__Id", " job_oid", "job_version", " job_version", "jobIdversion", "job__id", " job_source", "jobNameversion", "job__oid", " job_ids", "job_ids", "jobNamesource", " job_Id", "job_oid"], "bs": ["bt", "BS", "bp", "bi", "bas", "lbs", "es", "b", "bps", "ls", "pb", "bles", "bus", "bh", "ts", "its", "ps", "gs", "bc", "bm", "obs", "bos", "bis", "fs", "ds", "vs", "las", "gb", "lb", "rs", "sb", "bb", "cs", "js", "ubs", "ubis"], "base": ["db", "ase", "bound", "shadow", "bp", "bas", "absolute", "lower", "fr", "b", "from", "start", "ias", "bal", "local", "p", "bo", "check", "on", "real", "stable", "parent", "bid", "bar", "bare", "relative", "based", "prefix", "bind", "reverse", "socket", "st", "client", "common", "super", "file", "se", "port", "source", "area", "origin", "fs", "bu", "server", "bottom", "Base", "birth", "state", "sb", "root", "extra", "us", "mb", "scale", "f", "id", "buffer", "basic", "boot", "back", "pa"], "backing_file_str": ["backing_files_spec", "backing_file_name", "backing_files_name", "backing_file2str", "backing_File_str", "backing_files_str", "backing_file_br", "backing_file_spec", "backing_file2name", "backing_File_string", "backing_File_dr", "backing_file_dr", "backing_file2string", "backing_file_arr", "backing_files_string", "backing_file2spec", "backing_file_string", "backing_File_br"], "speed": ["spec", "stats", " Speed", "enable", "peed", "length", "status", "start", "rank", "slow", "capacity", "height", "frequency", "fps", "sum", "delay", "offset", "spe", "sex", "command", "power", "score", "driver", "seek", "port", "fast", "pload", "state", "priority", "size", " speeds", "sw", "interface", "scale", "mph", "weight", "EED", "buffer", "Speed"], "on_error": ["ona_bug", "ona___complete", "onistcomplete", "on_complete", "onphperror", "onphpERROR", "on____block", "onphpror", "ona_error", "on_scale", "on____scale", " on_scale", "on___bug", "ona___error", "ona___bug", "on____error", "on_block", "onistbug", " on_ERROR", "ona_complete", "on_ERROR", "onisterror", " on_ror", "on___complete", "on_bug", "on_ror", "on___error", " on_block", "on___ror", "on___ERROR"], "cb": ["CB", "fb", "cgi", "rc", "cfg", "obb", "rb", "b", "func", "pb", "c", "cell", "xb", "cc", "cp", "fp", "cf", "ck", "callback", "bc", "fun", "bf", "fc", "nc", "rob", "ctx", "gb", "cod", "lb", "fn", "sb", "cand", "bb", "cv", "tc", "cs", "cmd", "cd", "ctr", "ctrl", "erb", "job", "db"], "opaque": ["hoprox", " opca", "popaque", "Opacity", "popaques", "Opaques", "oppca", "opacity", "paque", "bitaque", "pca", "hopaque", "Opience", "bitulence", "popacity", "oppaques", "opience", "bitacity", "prox", "oprox", "pacity", " opacity", "bitrox", "hopulence", "opulence", "hopacity", "pulence", "Opaque", " opience", " opaques", "opaques", "opca", "popience", "oppaque", "paques", "oppacity"], "errp": [" errpad", "derpa", " errps", " erp", "Erpo", "derp", "errpa", "Erpa", "eorpa", " erpad", "errpo", " Errpad", "derpo", "errps", " Errpos", "eorpo", "Erp", " Errps", " erps", "eorp", "eorsp", " erpos", "errpad", "errpos", "errsp", " errpos", "Ersp", "dersp", " Errp"], "s": ["n", "an", "services", "r", "i", "views", "is", "v", "south", "sync", "common", "ies", "store", "fs", "ds", "eps", "http", "sb", "y", "h", "sq", "hs", "sports", "single", "ses", "c", "status", "st", "sol", "ims", "sv", "os", "a", "sts", "ats", "https", "des", "details", "j", "save", "ports", "qs", "events", "ssl", "states", "p", "sd", "ps", "l", "less", "ss", "ms", "set", "so", "sm", "args", "sl", "su", "sp", "m", "sam", "spec", "stats", "comm", "results", "es", "b", "ls", "d", "pers", "w", "als", "ts", "its", "changes", "gs", "e", "g", "se", "source", "settings", "rs", "ns", "t", "ins", "S", "f", "cs", "js", "aws", "o"]}}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372, "substitutes": {"avctx": ["devcmd", "AVcu", "avjp", "actjac", "avereq", "avfunc", "afcontext", " avpkg", "avkw", "avepkg", "vercontext", "avertmp", "avcu", " avtxt", "avcb", "abcp", "abctx", "averconn", "averkw", "avtc", "wavctx", "avecontext", "awtx", " avconn", "wavconn", "avcfg", "savjp", "aveproc", "wavcmd", "avctl", "wavca", "afctx", "avcontext", "avecmd", "AVtx", "ajcfg", " avgc", "avefunc", "devkw", "wavcfg", "abtx", "avercontext", "capctx", "avertxt", "savproc", " avsys", "wavtx", "avproc", "avercp", "vertx", "avecu", "wavmem", "wavpkg", "actctx", "verctx", "awcpu", "avermem", " avcontext", "abcontext", "averca", "wavctl", "avetmp", "awctx", " avcpu", "averctl", "averctx", "avpkg", "captx", "awcontext", "avercmp", "afconn", "wavtxt", "avetxt", "devctx", "avecp", "avertx", "avehw", "actjp", "avca", " avtmp", "averjac", "avconn", "avtmp", "evtxt", "wavcu", "capcu", "ajtx", "AVproc", "abconn", "navtxt", "evcontext", "avreq", "avtxt", "avhw", "AVctx", "wavfunc", "wavcontext", "avectx", "avecb", "AVfunc", "actgc", " avctl", "savctx", "wavcp", "absys", "averpkg", " avtx", "avgc", "capcfg", "avcmd", " avca", "savcu", "avcmp", "evconn", "abcpu", "ajcu", "abtc", "AVcontext", "avtx", "abcb", "acthw", " avtc", "averjp", "savtx", "ajgc", "avsys", "afpkg", "avekw", "navctx", "averreq", "avercmd", "verconn", "acttx", " avcmp", "evhw", " avreq", "avmem", "avertc", "aversys", "savjac", "devtx", "avcpu", "ajcontext", "avcp", "evctx", "ajctx", "evtx", "navconn", "navcontext", "avjac", "avercb", "avemem", "abcmp", "actcontext", "avetx"], "picture": ["note", "friendly", "support", "pict", "person", "query", "man", "pic", "iture", "summary", "style", "comment", "Picture", "frame", "pen", "pair", "family", "png", "description", "feat", "img", " Picture", "stat", "relative", " profile", "pi", "def", "image", "pty", "power", "info", "video", "file", "performance", "audio", "ctx", "important", "history", "please", "show", "position", " perspective", "contact", "share", "profile", "foreign", "piece", "place", "join", "private", "vp", "media", "feature", "command", "policy", "public", "pdf", "remember", "camera", "details", "import", "figure", "professional", "password", "print", "secure", "photo", "Profile"], "got_picture_ptr": ["got_pictureptptr", "got_picture_pos", "got_picture_ctr", "got_picture_pointer", "got_picture___pointer", "got_picture___ptr", "got_picture_Ptr", "got_picture___ref", "got_profile_ptr", "got_profile_pointers", "got_photo_pointer", "got_profile_pointer", "got_profile_ctr", "got_picture_addr", "got_picture_pointers", "got_pictureptpointer", "got_photo_ptr", "got_pictureptaddr", "got_profile_pos", "got_profile_round", "got_profile_addr", "got_photo_Ptr", "got_picture___pointers", "got_picture_obj", "got_picture_pad", "got_pictureptround", "got_picture_round", "got_profile_ref", "got_picture_ref", "got_picture_inst", "got_photo_pad"], "avpkt": ["avpkin", "averpds", "obpcmd", "avpamit", "avpacktx", "avhkt", "averpacket", "avpayacket", "avejpacket", "avcpkg", "avbpvc", "averptx", "avpads", "avepkg", "avjpkt", "avdtx", "avdds", "avmvt", "ahpackut", "avepkt", "averpkt", "averpfx", "rawpacket", "avpput", "avnpacket", "obpakt", "avpakin", "aveptt", "avpfx", "avpds", "averhkt", "avwmit", "obpmit", "avppket", "averhmk", "avpackut", "avwft", "avpadft", "avwcmd", "averpakt", "avpacket", "rawpkt", "obpamit", "avejpkl", "avpadmit", "avmacket", "avepkl", "avnpkin", "avecptt", "rawnpacket", "avpaacket", "avtpkg", "avpadkt", "avtpkt", "avpaykl", "avcpkt", "ahpkt", "averpatx", "avpemk", "avpaft", "avpaykt", "avppkg", "avpkg", "avbpkg", "avbptt", "avejpkt", "ahpket", "avpnt", "avpatx", "avpket", "avpvt", "rawnpkt", "avpackds", "avpekt", "avbpkt", "obpacmd", "rawpnt", "avepvc", "avjpvt", "avmkl", "averpaacket", "avpamk", "avpcmd", "ahpackkg", "avpmk", "avdacket", "avnpnt", "averhacket", "avejpvt", "obpkt", "avhacket", "avpefx", "avwkt", "averpmk", "avcptt", "rawnpnt", "rawnpkin", "avcpvc", "obpaft", "avptx", "avpakt", "avptt", "ahpackkt", "averhfx", "avjpacket", "avpackket", "avepacket", "avdnt", "avpkl", "avpeacket", "avpackkg", "avpackkt", "avwut", "ahpackket", "avtpvc", "avdkt", "avtptt", "avpayvt", "avecpvc", "avdkin", "avpadcmd", "avecpkg", "avpackacket", "avppkt", "ahput", "avhmk", "avpafx", "avhfx", "avpacmd", "avpmit", "avnpkt", "avwket", "avpft", "ahpkg", "avpant", "avput", "rawpkin", "averpads", "obpft", "avjpkl", "avecpkt", "avmkt", "avpvc", "avepvt", "avwkg"], "ret": ["flag", "get", "del", "rets", "det", "final", "nt", "re", "sort", "summary", "tr", "ert", "att", "status", "lit", "r", "gc", "alt", "arg", "pret", "ll", "pas", "mem", "out", "ort", "fun", "def", "rev", "gt", "ft", "ter", "rt", "elt", "len", "fin", "reset", "al", "success", "resp", "Ret", "RET", "res", "t", "report", "print", "val", "cert", "ref", "cont", "usr", "mt", " RET", "result", "back", "rem"], "frame_number": ["framepocounter", "frame__counter", "frame_count", "frameponumber", "framepoid", "image_count", "frame_counter", "framepocount", "frame__id", "frame_id", "frame__number", "image_number", "image_id", "image_counter", "frame__count"]}}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373, "substitutes": {"sbd": [" svd", "dsbd", "dsbc", "jsdd", "sbm", "rsbd", " spd", "ysbb", " sbb", "scd", "jsbd", "svd", "csbd", "rsdb", "gbc", "rsbm", "gBD", "rsbb", "sdb", "gdb", "rsdd", "jscd", " sbc", " sdd", "spd", "cspd", "dsdb", "ysbd", " sdb", " sBD", "rsBD", "sbb", "sBD", "rscd", "jsdb", "csvd", " sbm", "ysbm", "gbd", "dsBD", "csdb", " scd", "ysBD", "sdd", "sbc"], "dev": ["de", "ad", "db", "proc", "pro", "dep", "dem", "var", "nt", "tr", " device", " dw", "d", "th", "w", "av", "sd", "pad", "ve", "mem", "window", "v", "sh", "disc", "dis", "dd", "def", "DE", "eng", "cam", "conn", "gu", "go", "adv", "Dev", "rad", "device", "ver", "sw", "h", "hw", "des", " Dev", "priv", "ch", "DEV", "env", "ev"], "s": ["sam", "n", "spec", "stats", "sing", "bs", "qs", "ants", "services", "comm", "es", "b", "c", "ls", "d", "w", "r", "p", "ts", "sd", "ps", "its", "i", "comments", "changes", "l", "is", "gs", "v", "sys", "parts", "ss", "g", "ims", "sv", "ds", "a", "set", "settings", "params", "ats", "sts", "rs", "ns", "sm", "as", "args", "sb", "S", "bits", "sw", "h", "sq", "cs", "sp", "hs", "details", "js", "aws", "m", "j"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n", "idx": 391, "substitutes": {"s": ["sam", "sports", "spec", "single", "qs", "self", "comm", "es", "b", "c", "ls", "ssl", "p", "ts", "ps", "i", "is", "gs", "sh", "sys", "v", "less", "ss", "conf", "se", "sis", "sv", "source", "os", "ds", "a", "set", "master", "so", "rs", "ns", "sb", "S", "obj", "sl", "sq", "raw", "sp", "aws", "js", "sa", "sub", "m", "sac", "has"], "slave": [" slaves", "pipe", "bridge", "slice", "asha", "peg", " servant", "ssl", "th", "dest", "mi", "capacity", "worker", "pause", "caster", "stable", "ve", "seat", "sh", "attribute", "sync", "command", "peer", "submit", "se", "sudo", "handler", "cam", " Slave", "link", "ds", "server", "code", "master", "ave", "so", "node", "proxy", "device", "sb", "esi", "vp", "sl", "des", "student", "writer", "address", "phy", "raw", "buffer", "sa", "ser", "ssh", "save", "instance"]}}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n", "idx": 399, "substitutes": {"a": ["s", "au", "eas", "ba", "access", "el", "ab", "app", "aka", "an", "A", "es", "oa", "ca", "att", "ia", "at", "w", "r", "p", "am", "la", "apt", "ant", "era", "l", "aux", "out", "v", "ga", "ai", "e", "ap", "ar", "area", "af", "ac", "al", "sta", "ma", "aaa", "ach", "ae", "acs", "er", "aj", "t", "as", "alpha", "act", "ed", "ace", "ea", "pkg", "aa", "sa", "aq", "back", "ata"], "b": ["s", "back", "other", "ib", "ba", "fb", "bi", "bp", "ab", "bl", "bs", "app", "lib", "eb", "bin", "bg", "c", "rb", "be", "pb", "new", "by", "d", "r", "i", "l", "out", "v", "body", "bc", "x", "u", "ob", "e", "g", "br", "bis", "cb", "to", "gb", "nb", "beta", "base", "sb", "bb", "y", "mb", "z", "f", "o", "j", "erb", "db", "B"], "status": ["spec", "flag", "str", "reason", "fr", "warning", "tr", "uses", "error", "active", "gc", "p", "check", "type", "atus", "valid", "stat", "st", "prefix", "sex", "sync", "info", "name", "sc", "code", "flags", "msg", " Status", "res", "state", "Status", "progress", "sw", "scale", "tree", "negative", "err", "desc", "details", "result", "compl"]}}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402, "substitutes": {"lexer": [" lexter", "lexger", "flexener", "lexiter", " lexiter", "logner", "polliner", "taxe", "logter", "taxber", "Lexiner", "taxer", "flexiner", " lexger", "lexe", "lexiner", "speer", "ixer", "poller", "Lexger", "spener", "Lexener", "flexer", "ixener", "ixner", "wordber", "Lexter", "lexter", "flexter", "lexener", "lexner", " lexber", " lexner", "logiter", "worde", "taxiter", " lexe", "spee", "loger", "flexiter", "Lexer", "lexber", " lexener", "pollner", "flexner", "worditer", "ixe", "pollter", "worder", "pollener", "pollger", "speener"], "func": ["lambda", "impl", " function", " fn", "exec", " fmt", "new", " fun", "update", "req", "apply", "xy", "cf", "aux", "callback", "fun", "kw", "fc", "handler", "ctx", "conv", "coord", "code", "cb", "expr", "msg", "res", "fn", "val", "as", "unc", "obj", "mb", "f", "cmd", "event", "m", "function", "result", "job", "fac"]}}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404, "substitutes": {"bs": ["bt", "BS", "bp", "ba", "bi", "lbs", "bas", "ses", "b", "bps", "ls", "pb", "bh", "ts", "its", "ps", "gs", "bc", "bm", "bf", "ss", "cks", "obs", "aos", "bos", "bis", "fs", "ds", "gb", "lb", "ns", "bits", "sb", "bb", "bd", "aks", "cs", "ubs", "aus"], "fd": ["fm", "ff", "pd", "rd", "td", "cond", "nd", "d", "dl", "hd", "sector", "sd", "fps", "fe", "fp", "fi", "dd", "bf", "FD", "fc", "fin", "df", "fs", "ds", "dt", "dat", "dir", "fee", "fn", "disk", "ed", "du", "fed", "pid", "f", "fat", " fid", "id", "pos", "db"], "sector_num": ["sector_Num", "sector_nom", " sector_index", "piece_orig", " sector_Num", "piece_prim", "piece_nom", "sector_prim", "piece_num", "sector_orig", "sector_index", "sectorPindex", "sector_no", "sectorPNum", "sectorPnum", " sector_no"], "qiov": ["sqiour", "requiev", " quj", "requiov", "quiop", "qurov", "quiour", "qukov", "requrov", "qiev", "qiop", "quiev", " qiev", "quiv", "sqiv", "quj", "qios", "qquj", "quios", "quiov", "quigroup", "qqiov", "Qiov", "qiour", " qigroup", "qiv", "Qigroup", " qrov", "qrov", "sqiov", " qkov", " qios", "qqios", "Qiop", "qigroup", "quuj", " qiop", "requiv", " qiour", "sqiop", "qkov", "qqiev", " qiv", "Qkov"], "nb_sectors": ["nb_veors", "nb_speriers", "nb_bevers", "nb_severs", "nb_veriers", "nb_peivers", "nb_bectors", "nb_psellers", "nb__vectors", "nb_eivers", "nb_periers", "nb_pectors", "nb_selements", "nb_seors", "nb__veriers", "nb_spectors", "nb_vevers", "nb_peors", "nb_sellers", "nb_seivers", "nb_bellers", "nb_pellers", "nb_sections", "nb_pelements", "nb_vections", "nb_seriers", "nb__seriers", "nb_bections", "nb_egments", "nb_spellers", "nb_pegments", "nb_ectors", "nb__sellers", "nb__veors", "nb__vellers", "nb_vellers", "nb_psections", "nb_speors", "nb_vectors", "nb__seors", "nb_elements", "nb__sectors", "nb_segments", "nb_psevers", "nb_psectors"], "cb": ["bt", "CB", "fb", "cli", "kb", "cgi", "eb", "cfg", "obb", "b", "rb", "c", "pb", "func", "cell", "cp", "cc", "fp", "cf", "ck", "abb", "callback", "bc", "dc", "bf", "fc", "conf", "nc", "ctx", "conn", "dt", "gb", "nb", "lb", "sb", "cv", "ub", "cmd", "cd", "ctrl", "erb", "db"], "opaque": ["oppen", " opartment", "upputo", "opque", "open", "suppaque", "uppaques", "ocacity", " open", "opacity", "oppaque", "paque", "opputo", "suppartment", "oppula", "oppaques", "opula", " opque", "uppacity", "ocaque", "oppque", "oppartment", "pacity", "suppacity", "suppen", " opacity", "oputo", "puto", "uppaque", "opaques", "ocula", "ocque", "opartment", " opula", "paques", "oppacity"], "type": ["Type", "tag", "test", " ty", "tp", "time", "what", "length", "unit", "style", "error", "status", "by", "family", "timeout", "oid", "pc", "kind", "info", "name", "port", "handler", "TY", "key", "value", "dt", "pe", "to", "types", "t", "state", "ver", "size", "tc", "TYPE", "role", "weight", "f", "ico", "id", "ty", "typ", "ype"], "acb": ["acbb", "accpb", "aclbe", "icanbt", "pac2", "acub", "acn", "pacy", "facgb", "sacrb", "acpb", "facb", "ascl", "icanl", "pacwb", "cabb", "acp", "acerb", "aclub", " acB", "iacsb", "sacb", "ACbe", "ancbar", "iacb", "iacB", "Acdb", "iacpb", "aca", "ancc", "acxb", "aclp", "ancsb", "sacbuilder", "cabe", " acn", "Acfb", "can", "aucbe", "acy", " cac2", "ancv", "iacn", "macbb", "accbb", "acla", "aucl", " cacbt", " acl", "ancrb", "ach", "iacl", "facba", "acc", "acsb", "cab", "ac2", "acerbe", " cacl", "abh", "accsb", " acbb", "ascb", "sacc", "abfb", "ACb", "iacbt", "sacbe", " cacxb", "iacbe", "facl", " acp", "acba", "acB", "ACn", "acca", "icanbc", " acsb", " cacub", "facn", "accbt", "sacsb", "aclb", "sacbar", "icanb", "acbuilder", "acdb", "sacn", "abb", "accxb", "ACl", "macbe", " cacbc", "Acb", " cacy", "icsb", "sacba", "acv", "ascbe", "racbe", "acgb", "aclxb", "sacv", "acerbuilder", "acfb", "acrb", "acbc", "aucpb", "macb", "accub", " acv", " cacsb", "acwb", "acbt", "icB", "accb", "icbe", "Acgb", " acbe", "accn", "racbuilder", "ancb", "racba", "accbe", " aca", " cacb", "accba", "sacbb", " cacwb", "iach", "acerba", "sacy", "accl", " acba", "abgb", " cacrb", "ascn", "sac2", "abdb", "acbar", "facfb", "acbe", "icb", " ach", "pacb", "aclsb", "abbt", "abbe", "aucb", "racb", "abn", " acc", "sacwb", "acl", " cacbar", "accp", "accbc", "facdb"]}}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    const char *nested_url;\n\n    int ret;\n\n    CryptoContext *c = h->priv_data;\n\n\n\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n\n\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n    if (flags & AVIO_FLAG_WRITE) {\n\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n\n        ret = AVERROR(ENOSYS);\n\n        goto err;\n\n    }\n\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n\n        goto err;\n\n    }\n\n    c->aes = av_mallocz(av_aes_size);\n\n    if (!c->aes) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto err;\n\n    }\n\n\n\n    av_aes_init(c->aes, c->key, 128, 1);\n\n\n\n    h->is_streamed = 1;\n\n\n\n    return 0;\n\nerr:\n\n    av_free(c->key);\n\n    av_free(c->iv);\n\n    return ret;\n\n}\n", "idx": 436, "substitutes": {"h": ["ph", "ht", "hi", "hash", "dh", "q", "eh", "help", "self", "hm", "comm", "b", "ih", "hl", "th", "hh", "hp", "he", "bh", "p", "hd", "r", "rh", "ha", "cache", "her", "l", "v", "hr", "sh", "H", "context", "here", "hal", "g", "ctx", "handle", "history", "enh", "it", "host", "kh", "oh", "http", "zh", "hz", "y", "hw", "hs", "ch", "m", "ah"], "uri": ["phi", "iu", "hi", "this", "query", "q", "ui", "href", "nu", "uid", "iri", "path", "universal", "html", "ir", " URI", "remote", "uu", "username", "i", "fp", "connection", "ur", "web", "u", "prefix", "pi", "har", "picture", "ugi", "queue", "archive", "nil", "file", "qi", "source", "url", "origin", "location", "uni", "http", "resource", "subject", "filename", "uv", "du", "address", "request", "URI", "id", "domain", "ri", "directory", "base", "io"], "flags": ["lf", "posts", "flag", "planes", "options", "utils", "ags", "atts", "links", "states", "facts", "ts", "fps", "ps", "tags", "comments", "cons", "heads", "gs", "ops", "fields", "levels", "acts", "workers", "features", "settings", "fl", "wcs", "ats", "params", "bits", "args", "weights", "vals", "files", "lag", "locks", "pins", "cs", "pages", "details", "Flags", "names", "properties", "actions"], "nested_url": ["nappedtstr", "nestedlyurl", "nestedturl", "nest_url", "nesting_domain", "nesting_str", "nesting_Url", "nested_l", "nesting_uri", "nested_Url", "napped_url", "nested_domain", "nested_loc", "nappedtloc", "napped_str", "nestedlystr", "nested_str", "nest_l", "napped_path", "napped_loc", "nappedtpath", "nappedturl", "nest_link", "nestedtstr", "nested_link", "nesting_l", "nestedlyl", "nestedtpath", "nest_uri", "nested_uri", "nested_path", "nestedlydomain", "nestedtloc", "nesting_url"], "ret": ["rets", "nt", "re", "tr", "ber", "r", "ll", "pas", "rm", "deg", "alg", "dt", "it", "resp", "Ret", "val", "txt", "il", "cmd", "off", "prop", "str", "del", "att", "status", "alt", "pret", "def", "rev", "gt", "ft", "ter", "jp", "len", "rel", "mt", "desc", "j", "ext", "get", "Return", "try", "arg", " Ret", "l", "out", "rt", "elt", "lt", "reg", "addr", "RET", "result", "compl", "rem", "nl", "det", "gc", "mem", "fun", "arr", "reset", "pass", "res", "t", "ref", " RET", "f", "err", "print", "back"], "c": ["n", "cr", "lib", "rc", "mc", "can", "comm", "ct", "ca", "com", "lc", "b", "cur", "d", "cu", "w", "cache", "p", "gc", "anc", "cp", "cc", "ec", "l", "cf", "v", "bc", "dc", "co", "cm", "xc", "conf", "fc", "g", "nc", "ctx", "col", "cam", "conv", "ac", "coll", "a", "cb", "C", "ce", "ci", "t", "cont", "abc", "ctrl", "enc", "etc", "cv", "cl", "tc", "f", "cs", "ch", "chain", "config", "con"]}}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439, "substitutes": {"avctx": ["afctx", "wavsys", "avcontext", "ivercu", "avconn", "Avctx", "afpkg", "avsys", "afcontext", "Avconn", "navdesc", "iverproc", "navctx", "avproc", "ivercontext", "avepkg", "Avcontext", "iverdesc", "avcu", "avdesc", " avcu", "iverctx", "wavpkg", "wavcontext", "avesys", "avpc", " avcontext", "avectx", "wavctx", "avecontext", "Avpc", "afsys", " avproc", "navproc", " avconn", "navconn", "navcontext", "avpkg", "afcu", " avpc", "afdesc", "navpc", "navcu"], "count": ["n", "only", "length", "nt", "cmp", "batch", "consider", "b", "c", "ct", "th", "try", "cache", "max", "gc", "sum", "cc", "type", "OUNT", "ind", "number", "message", "info", "list", "current", "ount", "len", "num", "all", "code", "total", "C", "nb", "counter", "t", "now", "found", "cont", "size", "index", "call", "amount", "Count", "z", "skip", "add", "id", "buffer", "base"], "i": ["phi", "iu", "I", "n", "bi", "hi", "cli", "li", "ui", " j", "batch", " m", "c", "di", "yi", "ii", "uri", "mi", "ki", "remote", "uu", " mi", "ji", "\u0438", "ip", "window", "ai", "v", "ei", "is", "x", "u", "pi", "e", "fi", "in", "ri", "info", "zi", "g", "me", "qi", "xi", "ims", "history", "key", " ii", "it", "go", "si", "gu", "ix", "ci", "t", "print", "index", "multi", "y", "us", "span", "id", "ski", "chain", "sim", "gi", "ti", "m", "j", "series"], "p": ["w", "proc", "pro", "tp", "bp", "app", "pool", "np", "rep", "php", "q", "pd", "up", "post", "b", "pb", "P", "status", "at", "pt", "per", "pers", "hp", "dp", "d", "local", "comp", "cp", "ps", "admin", "cache", "pc", "fp", "ip", "l", "ap", "parse", "pi", "ping", "power", "info", "jp", "g", "xp", "par", "port", "pp", "br", "lp", "pe", "er", "pm", "part", "op", "resp", "pl", "process", "vp", "pg", "h", "patch", "progress", "pre", "pkg", "policy", "public", "f", "wp", "complete", "j", "pa"]}}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "substitutes": {"filename": ["n", "tp", "null", "ame", "ename", "FN", "jpg", "aka", "fle", "src", "path", "uri", "kl", "family", "username", "wav", "fp", "lua", "prefix", "title", "csv", "journal", "original", "file", "name", "nil", "println", "nature", "kj", "flake", "fn", "txt", "subject", "unc", "None", "Filename", "files", "FIL", "f", "fil", "stem", "ames", "nm", "figure", "til", "directory"], "fd": ["fb", "ff", "fr", "pd", "gd", "gz", "ud", "td", "cond", "nd", "d", "dl", "hd", "FH", "sd", "stream", "dig", "fx", "ind", "fp", "cf", "fi", "dd", "xd", "bf", "ini", "fc", "FD", "elt", " ff", "fin", "dial", "df", "conn", "fs", "ds", "dt", "fl", "cb", "ld", "dat", "dir", "fee", "fn", "da", "wd", "disk", "bd", "ed", "ptr", "fed", "ln", "f", "wind", " fid", "od", "cd", "pid", "db"], "ret": ["lt", "nl", "ext", "rets", "det", "nz", "iter", "nt", "et", "re", "tr", "not", "att", "status", "rect", "after", "inter", "alt", "arg", "ll", " Ret", "mem", "tail", "out", "fun", "quad", "leg", "fi", "rm", "def", "ft", "gt", "rev", "rt", "tn", "deg", "elt", "fin", "reset", "ne", "url", "br", "success", "resp", "Ret", "RET", "ter", "res", "t", "val", "cont", "txt", "cert", "usr", "mail", "mt", "nat", "des", "len", "err", "cmd", "reply", "result", "back", "rem"], "fdparam": ["cfparam", "bfParam", "ndaram", "dParam", "FDaram", "fdParam", "bfparam", "fdparams", "FDparams", "fdaram", "cfParam", "dparams", "dparam", "ndparam", "FDparam", "bfaram", "cfaram", "bfparams", "ndParam", "FDprom", "FDParam", "cfprom", "fdprom", "ndprom", "daram"], "st": ["inst", "ist", "sth", "stru", "str", "ust", "fr", " est", "et", "tt", "ct", " ss", "nd", "start", "sn", "ast", "th", "r", "rest", "p", "ut", " stat", " ST", "est", "stable", "l", "std", "sh", "stat", "stage", "St", "rt", "se", "sc", "ste", "ost", "sta", "end", "set", "sts", "so", "t", "state", "sm", "cont", "sty", "mt", "sw", "cl", "sl", "z", "ST", "sp"]}}
{"project": "qemu", "commit_id": "7d55273fcdc307399fc0e327a0c14c140cd439cf", "target": 0, "func": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    // Override warm reset address with cold start address\n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        /* XXX: put correct offset */\n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    // XXX Should be pci_bus3\n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    /* FIXME: wire up interrupts.  */\n\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 461, "substitutes": {"RAM_size": ["ram_size", "RAM_SIZE", "RAM_space", "RAM_align", "ramLLSIZE", "ram_SIZE", "ram_space", "ramLLalign", "ramLLspace", "ram_align", "ramLLsize"], "boot_devices": ["serialablegpu", "serialabledevices", "bootedgpu", "serial_gpu", "bootabledevices", "bootedpages", "bootablepages", "bootedblocks", "boot_pages", "bootablegpu", "bootableblocks", "booteddevices", "serial_blocks", "serial_pages", "serialablepages", "serialableblocks", "boot_blocks", "boot_gpu", "serial_devices"], "kernel_filename": ["kernel_path", "kernel_fn", "system_filename", "kernel_cmd", "system_file", "kernel_file", "cpu_filename", "cpu_fn", "system_cmd", "kernel_processor", "cpu_file", "cpu_path", "system_processor"], "kernel_cmdline": ["kernel_commandl", "kernel_extl", "kernel_cmdlines", "kernel_cmdl", "kernel_commandline", "kernel_calll", "kernel_extlines", "kernel_callline", "kernel_commandlines", "kernel_extline", "kernel_calllines"], "initrd_filename": ["initrs_files", "initrs_file", "initrd_file", "initrs_fn", "initrd_fn", "initrs_filename", "initrd_files"], "cpu_model": ["default_models", "pu_Model", "cpu_Model", "default_model", "gpu_mode", "gpu_model", "cpu_settings", "cpuitysettings", "gpu_link", "pu_model", "core_model", "pu_link", "cpuitymodels", "core_settings", "cpu_link", "default_Model", "cpuitymode", "default_machine", "pu_models", "cpu_machine", "cpuitymodel", "core_mode", "gpu_models", "cpu_models", "cpu_mode", "core_models"], "hwdef": ["fwDef", "hwdefault", "fwdata", "hddefault", "cowdef", "hwdata", "hwdict", "hwf", "hzDef", "hddef", "fwf", "iwdefine", "fwobj", "cowDef", "hhdict", "fwdef", "hhDef", "hwdefined", "hhdef", "hwdefinition", "wxdefinition", "hardDef", "htobj", "fwDEF", "hdobj", "hardf", "hdDEF", "iwdef", "cowdata", "hddefinition", "harddata", "hwobj", "hzdefine", "hubDef", "iwdefined", "iwDef", "hdDef", "fwdefined", "hwDEF", "iwdict", "hubdef", "htdef", "harddef", "iwdefault", "wxdef", "cowf", "hhdefine", "hwDef", "hzdict", "iwdefinition", "wxDef", "hubdefined", "htDef", "hwdefine", "wxdefault", "htDEF", "hzdef"], "env": ["inst", "esm", "dn", "org", "erd", "eu", "ve", "era", "shell", "te", "ei", "v", "eng", "en", "conn", "iev", "pe", "er", "door", "sb", "ed", "ent", "h", "hw", "console", "actor", "net", "erb", "Environment", "eh", "ef", "vr", "ger", "worker", "ped", "environment", "buf", "window", "esc", "sv", "vs", "cb", "operator", "vp", "uv", "desc", "eas", "em", "ext", "forge", "ew", "et", "engine", "nv", "export", "entry", "equ", "eni", "ec", "ja", "inv", "info", "here", "ctx", "code", "manager", "ae", "msg", "den", "gear", "state", "usr", "cv", "eg", "ea", "proc", "el", "eb", "cfg", "hl", "nav", "vt", "img", "mem", "context", "e", "oe", "conf", "network", "end", "server", "ev", "serv", "ner", "obj", "dev", "vm", "ee", "event", "eve", "ah", "db"], "filename": ["ename", "nam", "src", "uri", "tty", "kl", "family", "username", "fp", "prefix", "file", "driver", "rn", "fs", "location", "fn", "disk", "Filename", "files", "fil", "processor", "stem", "cmd", "nm", "buffer", "til"], "nvram": ["NVgram", "vgram", "tvmem", "NVrum", "tvrum", "tvram", "NVmem", "tvgram", "vmem", "vrum", "nvrum", "nvgram", "nvmem", "vram", "NVram"], "ret": ["flag", "nt", "status", "lit", "ll", "mem", "sys", "fi", "def", "format", "ter", "rt", "reg", "reset", "ry", "irm", "set", "Ret", "RET", "res", "val", "ref", "net", "cmd", "rem"], "linux_boot": ["linux__boot", "Linux_Boot", "Linux_boot", "linux_out", "linux_bus", "linux_Boot", "linux__Boot", "Linux_bus", "linux_soft", "Linux_soft", "linux__start", "linux_start", "linux__out", "Linux_out", "Linux_start"], "i": ["iy", "I", "bi", "li", "b", "di", "ia", "ii", "mi", "p", "l", "ip", "v", "pi", "fi", "info", "o", "it", "si", "ci", "t", "y", "f", "ti", "m", "j", "io"], "ram_offset": ["ram_size", "RAM_pos", "RAM_offset", "RAM_addr", "ram_pos", "ram_addr"], "prom_offset": ["prom__addr", "prom_pos", "rem_offset", "rem_address", "rem_pos", "rem_addr", "prom__offset", "prom_addr", "prom__address", "prom__pos", "prom_address"], "initrd_size": ["initrtsize", "initrdlyarea", "initr_sum", "initrdtsize", "initr_area", "initrdlylen", "initrtarea", "initrd_sum", "initrd_len", "initrdtsum", "initrtsum", "initrdtarea", "initrdlysum", "initrdtlen", "initrtlen", "initrd_area", "initr_size", "initr_len", "initrdlysize"], "kernel_size": ["kernel_index", "program_size", "kernel_length", "kernel_name", "program_name", "program_index", "program_length"], "pci_bus": ["pci2driver", "pci___us", "pci___boot", "pci___driver", "pci2boot", "pdi_us", "pci_boot", "pci2bus", "pdi_driver", "pci_driver", "pdi_bus", "pci___bus", "pci_us", "pdi_boot", "pci2us"], "pci_bus2": ["pci_BUS0", "pci_boot2", "pci__bus2", "pci_bus0", "pci_boot3", "pci__dev1", "pci_dev3", "pci__dev2", "pci_dev1", "pci_BUS3", "pci_BUS1", "pci_bus1", "pci_boot1", "pci__bus1", "pci_boot0", "pci_BUS2", "pci_dev2", "pci__bus3", "pci_dev0", "pci__dev0", "pci__dev3", "pci__bus0"], "pci_bus3": ["pci_block7", "pci_bus7", "pci_device3", "pci_block5", "pci_dev5", "pci_bus5", "pci_device7", "pci_dev3", "pci_device5", "pci_device2", "pci_dev2", "pci_block3", "pci_dev7", "pci_block2"], "bh": ["phi", "bt", "ht", "fb", "bp", "eth", "bridge", "bl", "lr", "bs", "eb", "dh", "eh", " inh", "vr", "b", "ih", "pb", "hl", "ssl", "hn", "ash", "hh", "ha", "hp", "rh", "bn", "bash", "pas", "uh", "hr", "bang", "sh", "abb", "bf", "orth", "hal", "bone", "beck", "ctx", "bec", "bis", "br", "hirt", "hab", "igh", "kh", "lb", "fn", "oh", "hub", "sb", "bb", "zh", "bj", "hz", "bd", "h", "ldon", "hun", "hw", "bol", "pkg", "phy", "bo", "ah"], "irq": ["IRck", "pirq", "IRqs", "prq", "IRq", "pirqs", "prck", "pirv", "prqs", "irck", "irv", "prv", "pirck", "irqs", "IRv"], "drive_index": ["drive_num", "drive_id", "drive_addr", "drive__id", "drive__addr", "driver_id", "driver_addr", "drive__index", "drive__num", "driver_num", "driver_index"], "hd": ["dq", "ht", "vd", "kb", "dn", "pd", "dh", "md", "him", "hl", "hn", "dl", "rh", "hp", "HD", "ha", "he", "ck", "sh", "dd", "dt", "ld", "hz", "bd", "haw", "dr", "hw", "hs", "hid"], "MAX_IDE_BUS": ["MAX_ID_BUS", "MAX_ID_TX", "MAX_IDE_BS", "MAX_IDEOPBUS", "MAX_IDEOPBS", "MAX_IDEOPTX", "MAX_ID_US", "MAX_IDEOPUS", "MAX_IDE_TX", "MAX_ID_BS", "MAX_IDE_US"], "MAX_IDE_DEVS": ["MAX_IDE2DEYS", "MAX_IDE_DIPS", "MAX_IDE_DAYS", "MAX_IDE_DEBS", "MAX_IDE_DABS", "MAX_IDE2DAPS", "MAX_IDE_DEPS", "MAX_IDE2DABS", "MAX_IDE_DPS", "MAX_IDE2DEBS", "MAX_IDE_DBS", "MAX_IDE2DEPS", "MAX_IDE2DAYS", "MAX_IDE_DIYS", "MAX_IDE2DAVS", "MAX_IDE_DAVS", "MAX_IDE_DEYS", "MAX_IDE_DAPS", "MAX_IDE2DEVS", "MAX_IDE_DYS", "MAX_IDE_DIVS", "MAX_IDE_DVS", "MAX_IDE_DIBS"], "fd": ["fb", "ff", "fr", "md", "dh", "pd", "ef", "dl", "sd", "fp", "fi", "dd", "def", "FD", "fc", "fin", "df", "fs", "ds", "dt", "fl", "dir", "wd", "bd", "dr", "f", "fat", "cd", "db"], "MAX_FD": [" MAX_DIR", "MAX_DF", " MAX_DF", "MAX_DIR", "MAX_FILE", " MAX_FILE"], "fw_cfg": ["FW_cfg", "FW_conf", "fw2cfg", "fw2config", "fw2conf", "fw_conf", "FW_fg", "fw2fg", "fw_fg", "fw_config", "FW_config"], "reset_info": ["starter_INFO", "reset___info", "resetableid", "resetationno", "eterfo", "reset_information", "reset___Info", "resetableINFO", "resetationinfo", "mem_info", "reset_flag", " reset_data", " reset_information", "reset___attr", "reset_id", "et_fo", "reseterno", "resetedfo", "resetedno", "et_no", "resetedinfo", "reset2Info", "resetingstate", "reset_INFO", "reset___state", "resetationhistory", "reset___flag", "reseterhistory", "resetingflag", "resetableinfo", "reseterinformation", "resetationdata", "reset2info", " reset_Info", "eterhistory", "reset_Info", "starter_info", "reset_history", "reset_fo", "reset___information", "init_id", "resetabledata", "mem_flag", "mem_state", "reset2ini", "init_INFO", "init_data", "eterno", "reset_state", "reset_data", " reset_attr", "resetationInfo", "reset_details", "mem_information", "reset2data", "reseterinfo", "resetinginformation", " reset_ini", "starter_details", "resetinginfo", "resetationini", "meminginformation", "memingflag", "resetedhistory", "et_history", "reset_attr", "reset_no", "et_info", "init_info", "starter_information", "reset_ini", "reseterInfo", "eterinfo", "reseterfo", "reseterattr", "meminginfo", "resetationfo", "memingstate"]}}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474, "substitutes": {"env": ["dn", "org", "erd", "cur", "ve", "era", "shell", "v", "eng", "die", "queue", "en", "conn", "store", "ds", "ov", "er", "door", "txt", "enc", "hw", "init", "Environment", "En", "eh", "ef", "worker", "environment", "buf", "window", "ter", "esc", "EN", "sv", "viron", "vs", "expr", "uv", "config", "em", "forge", "ew", "et", "engine", "response", "nv", "entry", "equ", "ec", "vv", "ctx", "code", "addr", "manager", "cv", "el", "que", "eb", "ten", "exec", "cfg", "hl", "enter", "block", "e", "context", "ob", "oe", "conf", "doc", "server", "end", "ev", "ner", "obj", "dev", "err", "ee", "event", "ah", "db"], "def": ["de", "Def", "pro", "spec", "init", "form", "det", "dem", "ef", "lit", "block", "buf", "req", "prop", "decl", "out", "definition", "define", "info", "crit", "conf", "fc", "df", "doc", "fam", "res", "ref", "act", "dev", "DEF", "cmd", "desc", "defined", "vec"], "i": ["phi", "s", "em", "I", "n", "bi", "cli", " li", "li", " multi", " v", " wi", "iter", "ui", " j", " m", "di", "im", " p", "mi", "ii", "ki", "p", " mi", " bi", "ind", " I", "ip", "ai", "v", "l", "x", "e", "pi", "ini", " pi", "zi", "ic", "ims", "me", "xi", " iter", "o", " ti", "key", "ami", " ii", "it", "si", "gu", "ix", "ci", " my", " e", "index", "multi", "y", "us", "id", "chain", "sim", "gi", "ti", "m", "j", "ex"]}}
{"project": "FFmpeg", "commit_id": "ccc27e2139336b66cdec3bb73a2cc7e60ef7e599", "target": 1, "func": "static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    BFIContext *bfi = avctx->priv_data;\n\n    uint8_t *dst = bfi->dst;\n\n    uint8_t *src, *dst_offset, colour1, colour2;\n\n    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n\n    uint32_t *pal;\n\n    int i, j, height = avctx->height;\n\n\n\n    if (bfi->frame.data[0])\n\n        avctx->release_buffer(avctx, &bfi->frame);\n\n\n\n    bfi->frame.reference = 1;\n\n\n\n    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Set frame parameters and palette, if necessary */\n\n    if (!avctx->frame_number) {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        bfi->frame.key_frame = 1;\n\n        /* Setting the palette */\n\n        if (avctx->extradata_size > 768) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Palette is too large.\\n\");\n\n            return -1;\n\n        }\n\n        pal = (uint32_t *)bfi->frame.data[1];\n\n        for (i = 0; i < avctx->extradata_size / 3; i++) {\n\n            int shift = 16;\n\n            *pal = 0;\n\n            for (j = 0; j < 3; j++, shift -= 8)\n\n                *pal +=\n\n                    ((avctx->extradata[i * 3 + j] << 2) |\n\n                    (avctx->extradata[i * 3 + j] >> 4)) << shift;\n\n            pal++;\n\n        }\n\n        bfi->frame.palette_has_changed = 1;\n\n    } else {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        bfi->frame.key_frame = 0;\n\n    }\n\n\n\n    buf += 4; // Unpacked size, not required.\n\n\n\n    while (dst != frame_end) {\n\n        static const uint8_t lentab[4] = { 0, 2, 0, 1 };\n\n        unsigned int byte   = *buf++, av_uninit(offset);\n\n        unsigned int code   = byte >> 6;\n\n        unsigned int length = byte & ~0xC0;\n\n\n\n        if (buf >= buf_end) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n", "idx": 490, "substitutes": {"avctx": ["wavnp", "averconfig", "avjp", "wavjac", "ravcontext", "avcu", "avcc", "abgc", "abctx", "AVconn", "averconn", "avesys", "avervoc", "wavctx", "avecontext", " avjac", " avconf", " avconn", " avcmd", "afcmp", "ajcmd", "ajcp", "ajsys", "avctl", "afctx", "avcontext", "avecmd", "ravconfig", "wavcmp", " avgc", "avercv", "abtx", "avercontext", "ajjac", "averconf", "wavtx", "avercp", "avercu", "ravctx", "avecu", " avcu", "avenp", "avejac", "ravvoc", " avcontext", "abcontext", "ajcc", "wavctl", "ajcmp", "averctl", "averctx", "avercmp", "avecmp", "abctl", "avecp", "avertx", "avnp", "averjac", "avconfig", "avconn", "avegc", "wavconf", "afgc", "avernp", "avecv", "ajtx", "abconn", "aveconn", "abcu", "avreq", "wavcc", "AVctx", "ajvoc", "ajconfig", "wavcontext", "avectx", " avctl", " avtx", "avgc", "avcmd", "AVcmd", "avcmp", "ajreq", "avectl", "avvoc", "ajcu", "AVcontext", "avtx", "averjp", "ravcmp", "avsys", "avergc", "avejp", "averreq", "avercmd", " avjp", "avconf", " avcmp", "aversys", "ravreq", "avcv", "ajcontext", "avcp", "ravjac", "avercc", "ajctx", "avjac", "afcv", "abcmp"], "data": ["DATA", "error", "output", "cache", "stream", "next", "multiple", "apps", "video", "value", "flags", "done", "padding", "id", "mode", "actions", "pos", "str", "empty", "batch", "at", "max", "pad", "window", "Data", "def", "list", "len", "file", "mid", "dat", "last", "feed", "fn", "rel", "table", "no", "extra", "date", "chain", "buffer", "pieces", "ata", "attr", "read", "input", "rc", "bin", "start", "frame", "p", "button", "name", "area", "text", "mu", "first", "filter", "bytes", "results", "d", "block", "w", "align", "offset", "important", "end", "res", "load", "ns", "content", "da", "device", "size", "raw"], "data_size": ["buf_offset", "data_length", "data_SIZE", "buf_size", "buf_SIZE", "buf_length", "data_offset"], "avpkt": ["campaacket", "avpadvt", "avpadt", "avwqt", "uvpptt", "wavcpdat", "avepkg", "uvpkt", "avPkg", "avepkt", "avewpkg", "wavpvt", "avcompcmd", "campconn", "avnpdat", "avwpkt", "campvt", "uvpvt", "avPkt", "avwpvt", "avpdat", "avpaction", "avcompvt", "avopkt", "wavpdat", "avcpnt", "uvppvt", "avwpconn", "avnpvt", "wavpkt", "avpacket", "uvppcmd", "avwct", "avpodvt", "avpawp", "avwpct", "avepction", "wavcpnt", "avpaacket", "wavcpkt", "avpadkt", "avcpkt", "uvppkt", "avpqt", "avpkg", "avPct", "avpartkt", "avpaconn", "avpct", "avpoddat", "avpnt", "avpadtt", "avcomptt", "avopvt", "campaconn", "avpptt", "avpvt", "avpdt", "avppvt", "avpartction", "avepqt", "avewpction", "avwpdt", "avewpqt", "avcpdat", "avpcmd", "avepwp", "avopacket", "campkt", "avewpkt", "avnpnt", "avwpction", "avpconn", "campavt", "avopconn", "avwkt", "avpartwp", "avpction", "avwpacket", "uvpcmd", "avpodkt", "avpakt", "avptt", "campakt", "avPqt", "avpwp", "avcpvt", "uvptt", "avpavt", "avwpqt", "wavpnt", "avepdt", "avepct", "avewpct", "avpadcmd", "avppkt", "avnpkt", "avpodnt", "avewpdt", "avppcmd", "avcompkt", "campacket", "wavcpvt", "avwpkg", "avpartdt", "avwkg", "avwpwp", "avewpwp"], "buf": ["cap", "rc", "iter", "seq", "ff", "batch", "uf", "bg", "b", "rb", "pos", "block", "bn", "img", "mem", "window", "offset", "next", "bc", "queue", "len", "shift", "ctx", "br", "cb", "addr", "dat", "msg", "ref", "cv", "Buffer", "ptr", "tmp", "raw", "cmd", "err", "buffer", "buff", "vec", "box"], "buf_end": ["buffer_stop", "buffer_ends", "buffer_end", "buffer_start", "buf_stop", "buf_ends", "buf_start"], "bfi": ["hubili", " bfo", "nbdi", "mdi", "sbfi", " bdi", "brxf", "bbilia", "mfi", "mbfi", "erbcgi", "erbfi", "brili", "sbqi", "hubcgi", "ffi", "bmi", "bbfi", " bbi", "fci", "bpi", "erbilia", "ffd", "ubini", "boundini", "bfif", "mbilia", "bqi", "boundili", "erbqi", "bbli", "bvi", "bbfif", " bcgi", " bqi", "dbili", " blu", "wbpi", " bili", "ablu", "dbisi", "bbdi", "nbfo", "gci", "filia", "bfo", "bbpi", " bini", "bcgi", "lfo", "gfo", "bbili", "boundfi", "abfo", "bini", "brfi", "erbili", "dbini", "bbvi", "lfi", " bilia", "wbfi", "fqi", "sbfo", " bisi", "bilia", "sbfd", "lci", "bbbi", "ffo", "brdi", "erbfif", "bci", "ubqi", "abmi", "bbxf", "bbfo", "bisi", "abbi", "abci", " bpi", "bfd", "nbfi", "bbqi", " bmi", "ubfi", " bci", "boundisi", "mbci", "hubfi", "dbfi", "bxf", "gfi", " bfif", "bli", "bdi", "mini", "lpi", "hubdi", "erbdi", "hubqi", "bbini", "gpi", "nbini", " bli", " bfd", " bvi", "wbili", "abli", "abvi", "bbi", "mbili", "bbmi", "bbci", "blu", "mfo", "fili", "ubfo", "bili", "lvi", "hubxf", "wbilia", "llu", "abfi"], "dst": ["bend", "isdsc", " dset", "bbl", "draest", " dST", "Dnt", " dsrc", "dST", "dsc", "drasc", "bsrc", "Dest", " dnt", "Ddest", "vbl", "ddest", "dest", "vst", "Dsc", "DST", "Dset", "ddsrc", "Dst", "gST", "dend", "Dsrc", "Dend", "isdest", "drast", "isdst", "drabl", "vend", "gst", "dsrc", "ddnt", "dbl", "bst", "Dbl", "gset", "vsrc", "dset", "ddst", "gdest", " ddest", "isdbl", "dnt", " dest"], "src": ["str", "rc", "seq", "bin", "bg", "dest", "sn", "rg", "comp", "seed", "rl", "iv", "img", "sys", "seek", "source", "origin", "trans", "addr", "cb", "loc", "rel", "usr", "ptr", "tmp", "sq", "scale", "lang", "sub"], "dst_offset": ["dsrc_alt", "dsrc_slot", "dst_pos", "dst_slot", "dst_alt", "dsrc_offset", "dsrc_pos"], "colour1": ["color2", "color1", "colorOne", " colourOne", "greyOne", "grey2", "colourOne", "grey1"], "colour2": ["type2", " colour62", " colour02", "type02", "colour02", " colours62", "colour62", " colours2", " colours02", "type62"], "frame_end": ["data_end", "data_start", "frame2start", "frame2end", "frame_length", "data_length", "frame2length", "window_start", "frame_max", "window_end", "frame_END", "data_END", "window_max", "frame_start", "frame2END"], "pal": ["sam", "ph", "pro", "attr", "Pal", "stack", "pool", "pat", "what", "isal", "bin", "flat", "pillar", "sal", "batch", "mask", "style", "mon", "att", "pos", "face", "prof", "pen", "cache", "p", "png", "local", "quant", "sum", "wh", "ul", "pill", "mem", "cal", "out", "pard", "qq", "pixel", "phil", "pp", "shift", "mel", "al", "all", "qt", "val", "alpha", "pl", "font", "mat", "base", "phal", "color", "shr", "stal", "pac", "pack", "pid", "ass", "padding", "buff", "pattern", "fac"], "i": ["iu", "I", "bi", "hi", "init", "li", "ui", "b", "eu", "di", "ia", "ii", "im", "mi", "by", "ki", "at", "p", "\u0438", "ind", "ip", "ai", "v", "is", "ij", "x", "e", "pi", "ei", "in", "ini", "info", "zi", "g", "ic", "me", "qi", "xi", "ami", " ii", "it", "si", "ix", "er", "ci", "index", "ie", "multi", "y", "us", "f", "ti", "gi", "ri", "m", "ex"], "j": ["k", "uj", "other", "n", "note", "bi", "str", "bs", "jc", "q", "b", "jump", "c", "ii", "oj", "je", "p", "bo", "dj", "ji", "l", "ja", "ge", "out", "v", "ij", "jj", "ion", "jp", "g", "mn", "ju", "br", "key", "it", "jit", "kj", "kh", "aj", "index", "bj", "ie", "obj", "y", "and", "z", "json", "bot", "jl", "js", "J", "jo", "o", "jas"], "height": ["k", "resolution", "count", "read", "input", "high", "hash", "hang", "volume", "th", "Height", "w", "html", "capacity", "p", "png", "memory", "wh", "density", "window", "row", "offset", "cy", "hei", "shift", "headers", "history", "scope", "bottom", "host", "kh", "t", "alpha", "room", "table", "zh", "size", "h", "y", "gravity", "depth", "f", "padding", "ty", "ch", "tx", "buffer", "dim"]}}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491, "substitutes": {"opts": ["iopops", "opcs", "optcs", "operths", "iops", " opss", "expermos", "OPops", "optmos", "opmos", "optpx", "opths", "itts", "opers", "OPts", "oppx", "iopTS", "OPs", "experops", "operss", "opss", "iopts", "itcs", "experpx", "itmos", "opops", "ops", "itpx", "expers", "optts", "OPss", "opTS", " ops", "experTS", "expercs", "operts", " opths", "experts", "OPTS", "OPths"], "oc": ["rc", "toc", "org", "mc", "orp", "roc", "c", "cur", "ot", "oca", "og", "ctor", "anc", "cc", "cp", "ec", "OC", "oid", "oco", "bc", "co", "ob", "oe", "ocr", "ic", "nc", "os", "ost", "ac", "osc", "mot", "voc", "coll", "it", "loc", "op", "canon", "ocate", "arc", "erc", "unc", "obj", "soc", "oci", "cs", "ox", "ico", "od", "ok", "o", "ku", "alloc"], "dc": ["cca", "design", "cr", "cat", "rc", "mc", "cmp", "cfg", "c", "di", "lc", "d", "dp", "gc", "cc", "cp", "ec", "dj", "pc", "cf", "bc", "disc", "co", "dd", "cm", "kw", "fc", "nc", "mn", "cam", "ctx", "df", "ac", "adr", "doc", "dt", "dat", "da", "dm", "disk", "bd", "tc", "dr", "DC", "ctl", "cs", "cmd", "desc", "vc", "cd", "iac", "ctr", "ctrl", "db"], "driver": ["Driver", "bridge", "iter", "target", "cmp", "graph", "error", "control", "stream", "ind", "definition", "plugin", "direction", "port", "draw", "handle", "driving", "writer", "loader", "json", "cmd", "tab", "test", "foo", "_", "route", "drivers", "kind", "def", "dd", "force", "hop", "host", "der", "operator", "debug", "session", "roy", "desc", "ctor", "sql", " drivers", "step", " Driver", "engine", "reader", "username", "oid", "field", "DR", "search", "key", "addr", "manager", "dir", "proxy", "drive", "alias", "NAME", "dr", "interface", "roller", "browser", "finder", "remote", "type", "description", "wrapper", "river", "connection", "handler", "source", "url", "adr", "device", "filename", "call", "direct", "label", "db"], "path": ["method", "Path", "test", "hook", "spec", "str", "input", "form", "query", "length", "point", "th", "pt", "p", "mount", "local", "pointer", "prop", "route", "prefix", "context", "template", "kind", "port", "url", "link", "key", "it", "host", "full", "loc", "dir", "arc", "where", "device", "index", "ath", "alias", "root", "partial", "patch", "pkg", "raw", "depth", "desc", "chain", "pattern", "PATH", "data", "box", "io"], "id": ["tag", "init", "time", "ident", "rid", "uid", "status", "ID", "i", "oid", "ip", "is", "ind", "kind", "rev", "port", "os", "serial", "addr", "ref", "alias", "root", "ids", "kid", "pid", "Id"], "dev": ["de", "test", "spec", "nt", "di", "w", "buf", "iv", "aux", "sys", "def", "info", "cam", "os", "conn", "ds", "doc", "res", "Dev", "val", "device", "wd", "obj", "des", "tx", "DEV", "ev"], "bus": ["back", "bug", "test", "db", "stick", "bridge", "ack", "lib", "bs", "cat", "nt", "hand", "browser", "b", "di", "block", "util", "used", "cache", "bolt", "mount", "board", "local", "buf", "bal", "loop", "bid", "bar", "body", "sys", "Bus", "socket", "bc", "way", "kit", "callback", "boss", "port", "binding", "handler", "os", "handle", "ac", "serial", "host", "cb", "BUS", "pass", "state", "proxy", "lock", "base", "hub", "http", "home", "bool", "us", "chain", "boot", "box"], "err": ["proc", "attr", "cr", "init", "iter", "cfg", "error", "cur", "r", "buf", "sys", "arr", "conf", "exc", "rr", "cb", "der", "er", "msg", "usr", "txt", "obj", "cmd", "errors", "ev", "mr"], "typename": ["sylename", "tylenename", "sylenename", "tyrenamed", "typnamer", "sylenamed", "typname", "tyrename", "tylenamer", "sypenamed", "tyrenename", "tylenAME", "typenamer", "typerame", "tyrenAME", "sylenAME", "typeramed", "typenAME", "tyrenamer", "sypenename", "typerAME", "tylenamed", "sypenamer", "tylename", "sypenAME", "typnename", "sylenamer", "sypename", "typnAME", "typerename", "typenename", "typenamed"]}}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n", "idx": 501, "substitutes": {"func": ["proc", "lambda", "orig", "b", "cell", "lc", "con", "util", "comp", "cc", "apply", "fx", "cf", "aux", "good", "fun", "def", "kw", "grid", "fc", "closure", "df", "coord", "doc", "cb", "fee", "fn", "unc", "act", "cast", "pkg", "f", "cs", "cmd", "function", "job", "fac"], "arg": ["ad", "param", "ack", "gov", " argument", "ag", "org", " targ", "item", "new", "og", "oc", "ret", " larg", "mem", "window", "mm", "argument", "inc", "ax", "arr", "g", " Arg", "reg", "par", "num", "ctx", "ar", "ig", "doc", "ng", "arp", "win", "msg", "val", "args", "ref", "Arg", "mb", "event", "vol", "urg"]}}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n", "idx": 510, "substitutes": {}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539, "substitutes": {"cpu": ["core", "null", "tp", "cli", "ka", "cmp", "CPU", "cache", "uu", "cp", "bo", "cf", "nc", "conn", "go", "process", "setup", "hw", "pkg", "console", "processor", "net", "cmd", "boot", "localhost", "gnu", "pool", "ilo", "c", "lc", "cu", "prof", "util", "comp", "pc", "linux", "jp", "cam", "ctl", "cum", "nz", "np", "cell", "frame", "p", "ruby", "thread", "ck", "sys", "nan", "co", "current", "ctx", "copy", "rpm", "node", "pu", "phys", "cv", "mu", "ch", "mac", "alloc", "proc", "que", "aco", "remote", "gc", "mem", "stat", "context", "ob", "cn", "pty", "java", "device", "hz", "act", "clock", "obj", "gpu", "vm", "none", "o", "nic"], "cc": ["cca", "proc", "rc", "mc", "cmp", "ct", "cell", "c", "lc", "func", "cu", "comp", "gc", "anc", "cp", "ec", "pc", "cf", "ck", "bc", "co", "CC", "xc", "cz", "fc", "nc", "ctx", "bec", "pp", "cci", "cb", "acc", "ci", "uc", "unc", "cv", "cl", "tc", "cast", "cs", "ctl", "cmd", "vc", "icc", "cy"], "ret": ["soft", "count", "flag", "nl", "nz", "nt", "Return", "re", "tr", "status", "try", "r", "alt", "match", " Ret", "out", "std", "git", "fi", "ft", "gt", "elt", "rt", "len", "reg", "num", "reset", "ne", "conv", "conn", "resp", "Ret", "RET", "res", "t", "val", "print", "ref", "no", " RET", "f", "sp", "result", "got", "rem"], "sc": ["sch", " sd", "rc", "mc", "isc", "cmp", "c", " ss", "lc", "ssl", "syn", "oc", "gc", "mp", "sd", "ec", "SC", "pc", "sys", "bc", "sync", "ss", "fc", "esc", "ctx", "sv", "scope", "ac", "osc", "rs", "arc", "sb", "scl", "uc", "cv", "cl", "tc", "sw", "asc", "Sc", "sq", "cs", "sp", "ch"], "last_tb": ["last_tsb", "last_trbr", "last_tfb", "last_ttba", "last_tbl", "last_wtbi", "last_Tb", "last_tsl", "last_wtl", "last_ttj", "last_Tbe", "last_ttb", "last_ttfb", "last_trrb", "last_otba", "last_tj", "last_tba", "last_tracefb", "last_Trb", "last_tracej", "last_tbe", "last_tl", "last_traceb", "last_otj", "last_tsbr", "last_tsbi", "last_tbr", "last_traceba", "last_tsbe", "last_Tbi", "last_otfb", "last_Tbr", "last_tsbl", "last_otb", "last_Tbl", "last_tbi", "last_trb", "last_wtb", "last_Tl", "last_wtbr"], "tb": ["ptbl", " tmb", "testbc", "tbl", "tempmb", "ltb", "xbl", "ltbl", "xb", "tempbre", "testbre", "tv", "testmb", "ptv", "ltv", "ptb", "testb", "tmb", " tbc", "tempb", "tbc", "xv", "xbt", "ltbt", "tempbc", " tbre", "tbre", "ptbt", "tbt"]}}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n", "idx": 547, "substitutes": {"dest": ["bound", "iter", "target", "them", "tr", "display", "dist", "rest", "wb", "est", "v", "member", "port", "store", "origin", "trans", "success", "to", "foreign", "order", "ptr", "global", "priv", "prop", "phi", "test", "transform", "prototype", "comb", "rw", "sum", "req", "decl", "st", "nom", "message", "gest", "master", "loc", "pl", "rel", "cont", "shape", "desc", "created", "chain", "complete", "consider", "see", "Dest", "export", "out", "good", "document", "copy", "usr", "tmp", "result", "sort", "spec", "orig", "results", "temp", "comment", "w", "opt", "remote", "local", "wrapper", "way", "peer", "source", "translation", "end", "total", "now", "dev", "env"], "src": ["inst", "via", "sing", "cmp", "from", "dist", "cur", "sn", "rest", "ind", "sync", "origin", "sr", "http", "sb", "etc", "setup", "sq", "inner", "init", "comp", "sel", "req", "st", "obl", "super", "nil", "loc", "rel", "pack", "desc", "sub", "other", "supp", "lib", "input", "rc", "bin", "start", "syn", "iv", "sys", "sup", "stri", "secure", "rt", "ctx", "ost", "usr", "sl", "tmp", "unknown", "pri", "stab", "ser", "ctr", "sort", "ack", "sec", "stock", "usc", "ipp", "ripp", "sh", "inc", "in", "sc", "source", "SOURCE", "btn", "rs", "now", "sur", "filename", "sw"], "pmcw": ["pmacw", "pxcwx", "pmacsw", "pxcinwa", "PMdcwa", "pmccW", "pmscwx", "pmscwd", "pxcwa", "mpcW", "pmcwx", "pxcw", "PMcnw", "pmacnw", "pmpcws", "pmdcnw", "pmmcw", "mpcws", "pmarcW", "pmccnw", "PMdcnw", "pmdcsw", "pmarcnw", "pmcinw", "pxcinw", "pmmcsw", "pmcwa", "PMdcsw", "pmdcw", "mpccnw", "pmrcw", "pxcwd", "pmcinwd", "pxcinwx", "pmcwd", "pmscwa", "pmmcwa", "pxcinwd", "pmacwa", "PMcwa", "PMcsw", "pmcW", "pmcws", "pmccw", "PMdcw", "pmpcnw", "mpccws", "pmrcwx", "PMcw", "pmscw", "mpcnw", "pmpcw", "pmcnw", "pmarcws", "pmrcwa", "mpcw", "mpccw", "pmpcW", "pmarcw", "pmccws", "pmcsw", "pmrcwd", "pmmcnw", "pmdcwa", "pmcinwa", "pmcinwx", "mpccW"], "i": ["oi", "cli", "spin", " multi", "eu", "iri", "uri", "mi", " si", " mi", "ind", "ai", "ei", "is", "ic", "port", "it", "si", "to", "y", "json", "id", "ti", "io", "phi", "PI", "iu", "bi", "init", "q", "ui", "batch", " m", "di", "x", "fi", "ini", "list", "zi", "ims", "xi", " ti", "ami", " ii", "multi", "chain", "sim", "ri", "I", " li", "point", "im", "ki", "try", " bi", "ip", "name", " iter", "ix", "ci", "span", " ni", "us", "mac", "gi", "m", "ex", "li", "php", "page", "ii", "remote", "ji", "\u0438", "parent", "u", "pi", "in", " pi", "qi", "sequence", "t", "f", "um", "print", "client"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566, "substitutes": {"ist": ["inst", "istant", " est", "erd", "isd", "dist", "ief", "ister", "ast", "wn", "rest", "artist", "spect", "est", "ind", "pas", "asm", "is", "ict", "ic", "pect", "il", "ick", "hw", "irc", "xp", "hist", "ait", "eh", "art", "ert", "att", "ir", "ird", "drm", "tip", "st", "ous", "ire", "ik", "irm", "IST", "sts", "ld", "expr", "iat", "ect", "ilst", "ift", "irst", "htt", "wp", "edit", "xt", "typ", "ith", "isting", "iste", "ism", "elist", "isi", "et", "dit", "alist", "ists", "ont", "iz", "usr", "irs", "ht", "each", "ista", "ush", "ust", "hl", "pir", "pt", "exist", "its", "ort", "assert", "lect", "lp", "istar", "act", "ess", "wikipedia", "iop"], "pkt": ["dacket", "tpkg", " pnt", "phpkt", "paykt", "apelt", "opkg", "paft", " packet", " pct", "ppcht", "dkt", "det", "expkt", "pet", "expkg", "tpacket", "apkg", "prokt", "payet", "Pct", " pft", "pelt", "packet", "pcht", "pant", "ppck", " pck", "payelt", "apct", "pct", "pck", "pakt", "paelt", "opkt", "pcmd", "expacket", "Packet", "expct", "dck", "ppacket", "opacket", "phpkg", "ppet", "opcmd", "promsg", "proacket", "phpacket", " pkg", "opcht", " pmsg", "tpmsg", " pelt", "ppkt", "ppelt", "opelt", "pnt", "prokg", "apkt", "apnt", "payacket", "Pkg", "Pkt", "pkg", "pft", "opet", "phpcmd", "pmsg", " pcht", "tpkt", " pet", " pcmd", "apft", "apacket"], "i": ["I", "n", " j", " m", "b", "di", "ir", "ii", "mi", "r", "p", "ret", "l", "mem", "ip", "v", "x", "fi", "info", "g", "it", "si", "iat", "t", "id", "m", "j"], "got_output": ["goturecurrent", "gotureOutput", "got_client", "gotableclient", "get_log", "gotablelog", "got_offset", "got_wrong", "got___success", "got___offset", "gotptresult", "gotabledot", "fitted_output", "got___wrong", "get_dot", "gotableresult", "gotten_wrong", "got_log", "get_output", "gotten_success", "got_exit", "fitted_client", "got___output", "fitted_result", "gotableoutput", "get_current", "got_Output", "got_current", "gotableexit", "get_Output", "gotten_output", "gotptoutput", "gotureoutput", "got_success", "gotptclient", "gotten_offset", "got_dot", "got_result", "gotptexit", "fitted_exit"], "avpkt": ["campayet", "avpadvt", "averpacmd", "avepreacket", "avlpgt", "averpcmd", "avcpkg", "avpartka", "avpodact", "avpskat", "avfkat", "avcpelt", "avvpkg", "avwpelt", "avpmt", "avpostkt", "avepkg", "avvpkt", "avtkg", "avjpkt", "avpostaddr", "avevwk", "avprkt", "avcpet", "avpreka", "afwpacket", "avcpacket", "afpelt", "avPett", "avepkt", "ajpkg", "avprekt", "avpydr", "wavipmk", "averpkt", "avtpelt", "avpscht", "avspkt", "aveppkt", "avpadr", "avtpdu", "avpskt", "avnpcht", "avfkt", "avjpaddr", "wavpvt", "avpadvc", "avppwk", "avevact", "avwpkt", "avepact", "avPkt", "avpskg", "averfkg", "avppmk", " avPpty", " avpnt", "avepwk", "avvact", "avopkt", "avdpkt", "avdconn", "ajpqt", "avtaddr", "wavipkt", "campet", "avenpkt", "avvpwk", "afwpkt", "avphpkt", "avdwk", "avcpdu", "avpycmd", "averpdr", "avpreacket", "avnpwk", "avepreka", " avppty", "wavpkt", "averpakg", "avpwk", "averpakt", "avipvt", "avpgt", "avpacket", "avprnt", "avppty", "avpayet", "avspket", "avpka", "avlpconn", "avbpvt", "avevcht", "avvpmt", "aveppconn", "avpakg", "avpett", " avPett", "ajpostkg", "avpact", "avpayvec", "avjpkg", "avlpmt", "avepka", "avpykg", "averpaet", "averpkat", "wavipvt", "avopcmd", "avppacket", "avpadkt", "avtpkt", "avcpkt", "afpkt", "avpvec", "averpet", "avpodcht", "avPnt", "aveppwk", "avpadet", "averpcht", "averfkt", "avpaykt", "afpacket", "avpkg", "avpqt", "avpostqt", "ajpostaddr", "avpet", "avepgt", "avppgt", "avpartkt", "avpreket", "avvkt", " avPnt", "avpnt", "avpcvc", "avlpkg", "avphpet", "avpckt", "ajpostqt", "avpket", "avepmt", "avpodwk", "avpvt", "avbpacket", "avipmk", "avppvt", "aveppgt", "avbpkt", "avprpty", "avwpcht", "avnpmt", "avopdr", "avtkt", "avbpmk", "ajpaddr", "campaykg", "afwpdu", "avpcmd", "avepreket", "avpelt", "campkt", "avpaddr", "avpdr", "avwpdu", "avnpkg", "avpmk", "avpcvt", "averpvt", "avpavc", "avepket", "campvec", "avpostkg", "avppconn", "avcpvec", "avpykt", "avtpacket", " avPkt", "avpconn", "averpavc", "averpkg", "avfkg", "avpcht", "avdpnt", "avwpacket", "avPpty", "avepcht", "ajpostkt", "wavpmk", "avenpwk", "avpodkt", "avpakt", "avevkt", "avenpmt", "averfkat", "avspacket", "avepacket", "avjpqt", "avpcet", "avpavt", "avdkt", "afwpelt", "avnpact", "avpartket", "avipkt", "avdgt", "averpvc", "avvwk", "avpaykg", "aveprekt", "avlpwk", "avwpkat", "avlpkt", " avpett", "avspka", "avtqt", "avppkt", "afpdu", "avpaet", "avopkg", "avpacmd", "avnpkt", "wavpacket", "averpavt", "campkg", "avpartacket", "avpkat", "avpdu", "avdpett", "avvcht", "wavipacket", "averfcht", "avipacket", "avenpkg", "avepconn", "avfcht", "ajpkt", "avwpkg", "avphpvec", "avpvc", "campayvec", "avprett", "avdppty", "averpadr", "campaykt", "avphpkg"]}}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, CPUState *cpu)\n\n{\n\n    CPUX86State *env = cpu->env_ptr;\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n    target_ulong pc_start = s->base.pc_next;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n    if (sigsetjmp(s->jmpbuf, 0) != 0) {\n\n        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        return s->pc;\n\n    }\n\n\n\n next_byte:\n\n    b = x86_ldub_code(env, s);\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = x86_ldub_code(env, s);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n            }\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n            }\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = x86_ldub_code(env, s);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = x86_ldub_code(env, s);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = x86_ldub_code(env, s) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n                }\n\n            }\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n        }\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n        }\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = x86_ldub_code(env, s) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = x86_ldub_code(env, s);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = x86_ldub_code(env, s);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        }\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n        }\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n                }\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                }\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        }\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = x86_lduw_code(env, s);\n\n            level = x86_ldub_code(env, s);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n        }\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n        }\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    }\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n        }\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = x86_ldq_code(env, s);\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = x86_ldq_code(env, s);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = x86_ldub_code(env, s);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = x86_ldsw_code(env, s);\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = x86_ldsw_code(env, s);\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n        }\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n        /* load shift */\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            }\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            }\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n            }\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n            }\n\n        }\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = x86_ldub_code(env, s);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            }\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n            }\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n            }\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                }\n\n                break;\n\n            }\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_rdtscp(cpu_env);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x11a:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n                }\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n                    }\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n                }\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                }\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n            }\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            }\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n                }\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n                }\n\n                break;\n\n            }\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            }\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n", "idx": 569, "substitutes": {"s": ["n", "sg", "an", "services", "eds", "i", "is", "v", "ies", "fs", "ds", "eps", "er", "gets", "sb", "y", "h", "sq", "hs", "actions", "ears", "bs", "ses", "c", "ares", "ains", "uns", "ims", "sv", "os", "a", "vs", "sts", "ats", "z", "ans", "details", "properties", "j", "ports", "qs", "scripts", "uploads", "ssl", "states", "p", "sd", "ps", "strings", "comments", "sys", "terms", "ss", "tests", "ms", "ar", "params", "rates", "args", "sl", "mods", "sp", "bes", "spec", "stats", "ads", "sym", "comm", "results", "es", "ls", "sets", "pers", "als", "ts", "its", "tags", "changes", "gs", "sh", "e", "g", "ers", "se", "conf", "tes", "settings", "rs", "ns", "ins", "S", "sw", "cs", "aws", "js"], "cpu": ["proc", "core", "tp", "spec", "pro", "cap", "np", "c", "CPU", "cu", "gc", "p", "cache", "cp", "ps", "mem", "sys", "x", "linux", "jp", "sc", "ctx", "os", "conn", "ds", "process", "pu", "phys", "clock", "gpu", "hw", "mu", "cs", "alloc", "vm"], "env": ["proc", "et", "ef", "ten", "eu", "w", "cp", "environment", "ec", "buf", "window", "v", "e", "context", "eng", "ss", "conf", "here", "esc", "ctx", "sv", "en", "conn", "ds", "server", "vs", "pe", "er", "docker", "usr", "home", "vp", "disk", "obj", "dev", "setup", "hw", "net", "cmd", "vm", "ev"], "b": ["ib", "n", "ba", "bp", "bi", "fb", "ab", "bs", "reb", "eb", "bin", "rb", "byte", "c", "be", "d", "w", "r", "p", "wb", "i", "l", "v", "bind", "e", "bc", "x", "u", "bf", "g", "bit", "o", "br", "a", "cb", "nb", "sb", "bb", "y", "h", "mb", "m", "db", "B"], "prefixes": [" prefixis", "prefixers", "prefixentials", "fixlees", "parentsentials", "frams", "prefixES", "prefixels", "fixesales", "prefixs", "termsES", "fixis", "prefixales", " prefixlees", "fixels", "fixes", "ixers", "fixesES", "ixes", " prefixels", "stripes", "fixesions", "termsions", "termsedes", "ixs", " prefixales", "stripedes", " prefixets", "fixentials", "fixales", "stripES", "ixences", "prefixets", "fixesels", "prefixions", "parentses", " prefixs", "ixales", "fixers", "sticklees", "ixets", "stickes", "fixesedes", "prefixlees", "fixese", "prefixis", "stripions", " prefixences", "stickences", "fixesers", "prefixedes", "parentsES", "frames", "framers", "termses", "ixe", "prefixe", "fixES", "fixe", "parentsales", "fixences", "prefixences", "framets", "fixesentials", " prefixers", "stickales", "fixesis", "fixeses", " prefixe"], "shift": ["aff", "use", "ff", "mask", "start", "opt", "align", "sh", "sup", "conf", "xff", "Shift", "push", "set", "cb", "hift", "load", "sb", "wrap", "scale", "aw", "ffff", "sp", "rew", "ctr", "off"], "ot": ["Os", "oo", "et", "re", "ct", "O", "oc", "ut", "ress", "uts", " os", "ort", "ow", "os", "ost", "OT", "br", "ool", "rot", "ots", "ref", "ol", "ent", "OL", "o", "oll", "ro", "io"], "aflag": ["abld", "aftlit", "afread", "aftread", "afld", "alflag", "alfld", "alflit", "abread", "aftlag", "alfread", "aftld", "ablag", "aflit", "ablit"], "dflag": ["dfree", "rflag", " dfield", "dfield", "pflags", "pflag", " dfree", " dflags", "pfield", "rfield", "rflags", "pfree", "dflags", "rfree"], "modrm": ["Modr", "modr", "MODrem", "modmem", " modrem", "Modrm", "MODrm", "MODr", "MODmem", "Modrem", " modr", " modmem", "Modmem", "modrem"], "reg": ["rar", "rc", "rep", "re", "rec", "ru", "r", "ret", "mem", "REG", "Reg", "g", "rt", "win", "mg", "res", "ref", "rom", "ram", "eg", "red", "ro", "rem"], "rm": ["attr", "rar", "rid", "RM", "re", "rb", "r", "rim", "mem", "rf", "arm", "rt", "rn", "raf", "rr", "rpm", "res", "rel", "ref", "perm", "rom", "ram", "rem", "m", "ro", "mr"], "mod": ["pro", "del", "md", "man", "mem", "mm", "fun", "mo", "MOD", "set", "addr", "cod", "ref", "perm", "module", "pop", "mods", "add", "od", "sub", "m", "mode", "pos", "rem"], "op": ["pro", "attr", "rep", "cmp", "up", "opt", "oc", "p", "mp", "ip", "ap", "ops", "oper", "bit", "hop", "loc", "rot", "ref", "obj", "pop", "ok", "o", "off", "pos", "OP"], "opreg": [" opregister", "aprec", "omregister", "apreg", "oprec", "omreg", " oprec", "opregister", "omrec", "apregister"], "val": ["var", "VAL", "bin", "pr", "ret", "alt", "bal", "buf", "mem", "v", "def", "num", "ctx", "pol", "value", "rel", "ref", "eval", "vals", "dev", "tx", "vol", "data", "pos", "rem"], "next_eip": ["next_seip", "next_eips", "next_edip", "next_edi", "next_eeip", "next_sei", "next_eeips", "next_edips", "next_eei", "next_seips", "next_ei"], "tval": ["Tvalue", "pbl", "Tbl", " tVal", "tvalue", "pVal", " tbl", " tvalue", "pval", "TVal", "pvalue", "tbl", "tVal", "Tval"], "rex_w": ["rex_b", "pex_W", "wr_weight", "rex_x", "rex___weight", "rex___x", "rex___w", "rex_W", "wr_r", "pex_x", "rex_weight", "wr_x", "wr_w", "pex_w", "pex_b", "rex___r"], "rex_r": ["x_f", "x_r", "rex_b", "rex7r", "rex_f", "rex7w", "rez_o", "rex7f", "rez_r", "rez_b", "x_w", "rex7l", "x_l", "rex_o", "rex_l"], "pc": ["pn", "proc", "bp", "tp", "po", "rc", "mc", "cmp", "pic", "point", "page", "c", "pb", "pt", "pr", "gc", "p", "mp", "pan", "cc", "cp", "ec", "bc", "PC", "dc", "pi", "co", "fc", "port", "sc", "pp", "ctx", "pm", "arc", "ptr", "cs", "pid", "pa"], "base": ["db", "back", "ase", "bound", "bp", "bas", "bs", "mark", "status", "block", "cache", "out", "sys", "prefix", "file", "name", "balance", "server", "Base", "profile", "ref", "extra", "mb", "cs", "buffer", "top"]}}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572, "substitutes": {"bs": ["BS", "bp", "bi", "bl", "lbs", "bas", "bg", "b", "bps", "bh", "ts", "bn", "ps", "its", "gs", "is", "bc", "bm", "bf", "ks", "ss", "cks", "bos", "aos", "bis", "fs", "ds", "rs", "ns", "bits", "sb", "bb", "bd", "cs", "ubs"], "filename": ["via", "localhost", "ame", "ename", "binary", "FN", "sbm", "jpg", "aka", "fle", "src", "path", "uri", "family", "username", "fp", "lua", "asm", "prefix", "title", "file", "name", "nil", "rn", "source", "url", "println", "origin", "fs", "location", "kj", "fn", "txt", "subject", "Filename", "files", "f", "fil", "json", "LCS", "ames", "nm", "til", "directory"], "flags": ["flag", "FLAG", " fmt", "options", "mask", "ags", "status", "links", "ts", "tags", " flag", "xf", "fields", "linux", "features", "fs", "Flag", "settings", "faces", "fee", "bits", "fd", "args", "files", "locks", "Flags", " options", "properties"], "iscsilun": ["iscslut", "ircslut", "iscsinun", "ircslong", "iscslUN", "iscsiln", "iscselut", "ircslUN", "ecsinun", "ircsilut", "iscsinut", "iscsilut", "iscsilong", "iscsilUN", "iscselun", "iscselUN", "iscsolut", "ecsilun", "ircslun", "ecsiln", "ircsilong", "iscsisong", "ircsilun", "iscsisun", "iscsisut", "ircsilUN", "iscseln", "ecsilUN", "iscsolong", "iscsolun", "iscsolUN", "iscslun", "iscsinn", "iscsisUN", "iscsln", "ecsilut", "iscslong", "ecsinUN", "ecsinn", "ecsinut", "iscsinUN"], "iscsi": ["iscdi", "iwci", "escsi", "icci", "discci", "iscsc", "impsi", "escsim", "ircki", "discii", "scity", "sicdi", "iscsie", "discdi", "impsan", "iscity", "ischSI", "uscdi", "iscSI", "sicscale", "ischso", "miscno", "ischity", "discsie", "iwsie", "uscso", "icsi", "nicii", "ischsim", "ischki", "iscsan", "ircSI", "uscsi", "sicsi", "nicsc", "iscsim", "iscsd", "iscso", "ischsi", "uscsan", "discsc", "uscki", "iconsi", "uscno", "impscale", "iscci", "miscsi", "iconsim", "iscii", "ircsie", "iscki", "scsi", "discity", "uscsim", "uscsd", "uscsa", "ischsa", "iwsi", "discSI", "scsim", "discsi", "uscSI", "scsd", "miscso", "icondi", "scii", "ischsd", "ircsim", "discsan", "ischno", "scsc", "iscscale", "iscno", "iscsa", "discsim", "ircsi", "escsie", "iwsc", "iconsan", "sicsan", "discscale", "miscSI", "discsa", "scsa", "ircsd", "nicsa", "discsd", "icsie", "icsc", "impdi", "nicsi", "ircsa"], "iscsi_url": ["iscci_username", "iscsiptbuf", "iscsim_Url", "iscsi_date", "iscstapyret", "iscsta_handler", "iscsipturl", "iscsi_len", "iscsipturi", "iscasus_url", "iscsimyurl", "iscsi_handler", "iscsi1loader", "iscsiptstr", "iscsi_username", "iscsi_buf", "iscsi_dl", "iscsipystr", "iscci_rel", "iscsi1url", "iscsi_uri", "iscci_str", "iscstapyhandler", "iscdi_http", "iscsi_res", "iscsi_result", "iscsimyrel", "iscstapyurl", "iscsta_ret", "iscci_res", "iscsi_file", "iscsi_loader", "iscsim_str", "iscdi_str", "iscsi1Url", "iscsi_Url", "iscsimylink", "iscsiacstr", "iscsta_result", "iscsim_loader", "iscsi_rel", "iscsi__file", "iscci_len", "iscsiacurl", "iscsi__url", "iscsiacjson", "iscsi_http", "iscci_dl", "iscci_link", "iscstapyresult", "iscsipyresult", "iscsiacUrl", "iscsi_link", "iscsi_str", "iscasus_str", "iscdi_uri", "iscsi_ret", "iscasus_uri", "iscsipyurl", "iscsipyhandler", "iscsi__link", "iscsipyusername", "iscsim_json", "iscsipyret", "iscsi_json", "iscdi_url", "iscsi__str", "iscsta_url", "iscci_url", "iscsimyres", "iscdi_date", "iscdi_link", "iscsipydl", "iscsim_url", "iscasus_buf", "iscdi_file"], "task": ["proc", "exec", "func", "new", " tasks", " transaction", "thread", "TAG", " tid", "command", " Task", "bit", "link", "Task", "background", "master", "t", "table", "text", " unknown", "unknown", "tx", "action", "function", "job", "instance"], "initiator_name": ["initiater_Name", "initiator___string", "initiatorNametype", "initiator____NAME", "initiatorNameName", "initiator____version", "initiator_version", "initiater_no", "initiator___key", "initiate_NAME", "initiate_key", "initiate_string", "initiate_version", "initiator_key", "initiator____name", "initiator_type", "initiator_string", "initiatorNamename", "initiate_name", "initiator___name", "initiater_name", "initiater_type", "initiator_Name", "initiatorNameno", "initiator_NAME", "initiator_no"], "ret": ["eth", "ext", "get", "str", "rets", "det", "final", "hash", "nz", "nt", "et", "re", "tr", "vet", "ert", "att", "status", "pt", "try", "opt", "gc", "alt", "arg", "ts", "ll", " Ret", "pas", "mem", "out", "fun", "rm", "def", "rev", "ft", "gt", "ter", "rt", "elt", "len", "deg", "arr", "reset", "mel", "dt", "expr", "resp", "Ret", "RET", "backed", "res", "t", "val", "print", "rel", "mt", " RET", "mb", "tmp", "tree", "cmd", "xt", "desc", "reply", "result", "back", "rem"]}}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "substitutes": {"pkt": [" pnt", "pth", "paykt", "pett", "rkt", " packet", " pth", "paywk", "prokt", "tpacket", "rnt", "pet", "apett", "produ", "Pth", "packet", "vpth", "apcmd", "tpnt", "rpt", "vpkt", "pcmd", "ppt", "Pnt", "Pett", "Packet", "prowk", "proacket", "vpet", "Pet", "tppt", "racket", "pnt", "apkt", "pdu", "apnt", " pett", "payacket", "Pkt", "Pcmd", "vpacket", " pdu", " pwk", " ppt", "paydu", "tpkt", " pet", " pcmd", "pwk"], "pkt_data": ["pnt_str", "pnt_bin", "pet_data", "pkt_buf", "pnt_data", "pkt_length", "pet_len", "pnt_buf", "pkt_bin", "pet_length", "pkt_str", "pet_str"], "pkt_len": ["pwd_data", "pet_data", "pkt1data", "pwd_length", "pct_len", "pkt1str", "pkt_length", "pet_len", "pct_length", "pkt_Len", "pkt2data", "pet_length", "pet_l", "pkt2Len", "pkt_str", "pkt_l", "pkt2length", "pwd_len", "pct_data", "pwd_str", "pkt1len", "pct_Len", "pkt1length", "pkt2len"], "vhdr": ["uvhpar", "vhusr", "nvhdr", "varchdr", "vshdr", "vhasdr", "vhelparr", "vihrr", "vhsrr", "vereharg", "vchdr", "vhdcmd", "vchaddr", "vhard", "hthrr", "vhsusr", "vHint", "vhheader", "vhsman", "hhheader", "uvhddr", "vHbr", "vthr", "vwrr", "vthder", " vihdel", "vhelpusr", "vehgt", "vhelpdr", "vharg", "vhhgt", "vdhheader", "vchld", " vhrid", " vohheader", "vihman", "verhgt", "nvhard", "cHint", "uvhsg", "vphld", "vhint", "vchDR", "vhstr", "vhdgr", "chdr", "vohr", "nvhald", "hhdr", "vihrid", "vHgt", "vshpar", "vhdder", "vhrid", "vHarg", "vhdrr", "verehgt", "vhald", "vphdr", "vbhdr", " vhvr", "vhord", "vhashdr", "vhddr", "vhalp", "Vihrd", "verhbr", " vhaddr", " vthvr", "chDR", "vhddel", "cHdr", "Vihdr", "vihg", "uvhdr", " vohpar", "hhder", "vhelprid", "vphlp", " vthaddr", "uvhdgt", "vhadr", "vihdel", "vhr", "vshstr", "vharr", "vherder", "vchstr", "vhostbr", "vhostarg", "varcharr", "vhaddr", "vphrd", "vhrd", "vthld", "vwder", "vshint", "vhdheader", "vhashgt", " vohr", "vshdel", "uvhg", "nvhadr", "hthdr", "vthaddr", "uvhdel", "vthrr", "vdhrid", "uvhgr", "vihgt", "vhhgr", " vihDR", "hthder", " vohDR", "uvhdcmd", "Vhrd", "vhcmd", "verhdr", "vhtrd", "vohDR", "vhhcmd", "vhgr", "vHstr", " vhld", "vohdr", "vchvr", "vchint", "nvhld", "Vhder", "vthdr", "vhrusr", "verehbr", "vhpar", "vbhld", "vbhaddr", "vohrid", "uvhddel", "vrhgt", "vohheader", "vhsgt", "uvhgt", " vhgt", "nvhlp", "uvhsman", "vherrd", "vshDR", " vohdr", "verehdr", "nvhrd", " vhheader", "vhelpdel", "uvhman", "vrhdel", "vihDR", "vrhdr", "vhasman", "vhsDR", "vhld", "vhasg", "veharg", "vhrdr", "vohpar", "vihdr", "vherdr", "vohder", "vHDR", "vhsdr", "uvhdgr", " vhr", "vhashgr", "vhtrid", "vbhvr", "vhrpar", "Vhdr", "vhtdr", " vhDR", "vthheader", "vwdr", "vhelppar", "uvhrid", "vohusr", " vihdr", "vhDR", "vhdgt", "vhvr", "vhashcmd", " vihgt", "uvhdrid", "vhsg", "vHdr", "vhostdr", "vrhDR", " vhder", "uvhcmd", "chstr", "Vihder", "vhelpder", " vohder", "vthvr", "vwheader", "vhasrr", " vohusr", "vherrid", "vhsdel", "chint", " vthld", " vhdel", "vhg", " vharr", "cHstr", "vhostgt", "vihder", "vhspar", "varchder", "vhhdr", "vhodr", "vholp", "hthheader", "vihrd", "vhtder", "vhder", "vhold", "vhgt", "verharg", " vhpar", "varchusr", "nvhalp", " vhusr", "vehdr", "Vihrid", "vhdel", "vhdrid", "vthrid", "hhrr", "uvhsdr", "vhrDR", "uvhsrr", "uvhrr", "vshrid", "vhlp", "vdhr", "vhbr", " vohrid", "vdhdr", "cHDR", " voharr", "vhrr", " vthdr", "vehbr", "vhdpar", "Vhrid", "vhman", "voharr", "uvhdpar"], "isip4": ["isip44", "ismp256", "istip4", "istip6", "isip256", "istp0", "istp04", " isip8", "isIP6", "isp04", "iscp4", "isist0", "iscp44", "istp6", "isist04", "isip04", "isIP4", "isep256", " isIP4", "ismp44", "isep04", "isep4", " isip256", " isIP44", "isist4", " isIP8", "isp8", "istp4", "isist6", "isp44", "isp0", "iscp6", "ismp4", "istip04", "isIP8", "isip0", "istip0", "iscp8", "isip8", "isp6", "isep44", "isp4", "isep6", " isip44", "ismp6", " isIP6", "isIP44", "isep0"], "isip6": ["ismhip62", "ismip36", "issipnet", "iship8", "isipnet", "isIP6", "iship62", "isipp8", "issIP4", "issIP8", "isop3", "isIPnet", "isip2", "ismhip36", "isipp36", "ismhip6", "isidnet", "issIP6", "isIP4", "isop6", "isp3", "ismhip8", "ismip62", "isep4", "issip4", "issip8", "isipp6", "isep36", "isip3", "isid6", "isid8", "isep8", "iship36", "isIP8", "Isip2", "isop2", "Isip4", "iship6", "isip36", "ismip8", "isop4", "isipp62", "Isip6", "isip62", "issip6", "isip8", "isp6", "isp2", "isep62", "isid4", "issIPnet", "isep6", "isp4", "ismip6", "Isip3", "isepnet"], "istcp": ["ditcp", "pectcp", "histpc", "ismcp", "ismcop", "iftcop", "pectcop", "ortcp", "ditwp", "ditdp", "ditpd", "ISTcp", "iftcmp", "istcop", "histcop", "istpd", "histp", "histpd", "histcp", "ISTmp", "histwp", "istpc", "istmp", "istwp", "iftcp", "ismmp", "histdp", "ISTcop", "istp", "ortdp", "ortwp", "ISTpc", "ismcmp", "pectpc", "ISTcmp", "ortpd", "ISTp", "iftmp", "pectp", "istdp", "istcmp"], "isudp": ["isrodps", "isudps", "isuidu", "ismwebpc", "iswebpa", "isuvpa", "isrodu", "istsudcp", "isbugpt", "isuidpd", "isadpc", "ismudp", "ismwebp", "isudpc", "isbugcp", "ismudpc", "istsugcp", "istsugps", "ismwebpa", "isadcp", "iudcp", "isadpa", "isuidps", "iudp", "istsugp", "isbugpd", "isudpd", "isuidp", "isbugp", "isuvpc", "isugps", "isrodp", "iswebp", "isudpa", "isugcp", "ismudpa", "istsudu", "iuidp", "isrodcp", "ismudcp", "isugp", "iswebpc", "isudcp", "isadp", "isudpt", "istsudp", "istsugu", "iudpt", "isuidpt", "isuvcp", "ismwebcp", "iuidpd", "iuidpt", "iudpd", "isuidcp", "isldpd", "isldpt", "isuvp", "isldp", "istsudps", "isugu", "isudu", "iswebcp", "isldcp", "iuidcp"], "data": ["DATA", "n", " Data", "input", "str", "bin", "length", "bytes", "batch", "di", "d", "block", "output", "map", "p", "pad", "ip", "window", "valid", " DATA", "Data", "message", "in", "image", "result", "def", "name", "area", "al", "value", "a", "dat", "to", "t", "val", "rel", "table", "text", "size", "done", "no", "extra", "raw", "mu", "aw", "rew", "padding", "id", "buffer", "m", "pos", "db", "ata"], "len": ["lf", "n", "lon", "el", "str", "wid", "length", " length", "cmp", "nt", "ls", "pos", "lit", "gen", "lim", "kl", " clen", "p", "ll", "lic", "l", "mem", "offset", "v", "L", "valid", " l", "elt", "fin", "num", "en", "lp", "limit", "Len", "end", "trans", "resp", "le", "total", "loc", "t", "val", "vec", " el", "size", "enc", "il", "h", "z", "ln", "lang", "sp", "err", "vol", "lan", "compl"]}}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574, "substitutes": {"errp": ["errP", "rps", "erP", "errr", "rrP", "rrp", "rr", "rrr", "err", "errps", "erp", "rrps", "rP", "erps", "rp"], "list": ["ist", "collection", "null", "str", "nt", "flat", "record", "LIST", "batch", "new", "temp", "lc", "ls", "block", "map", "p", "local", "listed", "i", "ul", "parent", "l", "out", "v", "st", "info", "lt", "all", "data", "limit", "set", "lp", "it", "part", "t", "pl", "lock", "table", "cont", "found", "dict", "List", "print", "result", "instance"]}}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n\n                         unsigned int c, const unsigned int *div_blocks,\n\n                         unsigned int *js_blocks)\n\n{\n\n    ALSSpecificConfig *sconf = &ctx->sconf;\n\n    unsigned int offset = 0;\n\n    unsigned int b;\n\n    ALSBlockData bd[2] = { { 0 } };\n\n\n\n    bd[0].ra_block         = ra_frame;\n\n    bd[0].const_block      = ctx->const_block;\n\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[0].opt_order        = ctx->opt_order;\n\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n\n    bd[0].use_ltp          = ctx->use_ltp;\n\n    bd[0].ltp_lag          = ctx->ltp_lag;\n\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[0].quant_cof        = ctx->quant_cof[0];\n\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[0].js_blocks        = *js_blocks;\n\n\n\n    bd[1].ra_block         = ra_frame;\n\n    bd[1].const_block      = ctx->const_block;\n\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[1].opt_order        = ctx->opt_order;\n\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n\n    bd[1].use_ltp          = ctx->use_ltp;\n\n    bd[1].ltp_lag          = ctx->ltp_lag;\n\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[1].quant_cof        = ctx->quant_cof[0];\n\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[1].js_blocks        = *(js_blocks + 1);\n\n\n\n    // decode all blocks\n\n    for (b = 0; b < ctx->num_blocks; b++) {\n\n        unsigned int s;\n\n\n\n        bd[0].block_length = div_blocks[b];\n\n        bd[1].block_length = div_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n", "idx": 585, "substitutes": {"ctx": ["via", "Context", "ka", "cmp", "them", "today", "kt", "pause", "bh", "cp", "std", "cf", "animate", "crit", "history", "conn", "resp", " cx", "txt", "etc", "setup", "hw", "pkg", "cmd", "xp", "kb", "anc", "req", "xy", "prefix", "jac", "xc", "jp", "nil", "mom", "conv", "cb", "wcs", "loc", "iat", "px", "fn", "ctl", "asia", "config", "wx", "mc", "utils", "ppo", "ca", "dl", "kl", "cc", "aux", "ck", "cm", "kw", "that", "addr", "msg", "policy", "tx", "care", "proc", "xs", "pat", "work", "grad", "cfg", "ct", "func", "ia", "rect", "gc", "timeout", "bc", "context", "conf", "ann", "handler", "something", "abc", "apache", "act", "obj", "tc", "course"], "ra_frame": ["ra___series", "ra_shot", "dra_lock", "ra___frame", "RA_frames", "ravelopshot", "RA_frame", "raptlock", "RA_block", "ror_frame", "ra_series", "ra_block", "ra___channel", "ror_scene", "ra___scene", "ror_channel", "ror_series", "dra_shot", "ra_channel", "raptframe", "ra_frames", "dra_frame", "ra_lock", "raptshot", "raveloplock", "ra_scene", "ravelopframe"], "c": ["n", "count", "cut", "rc", "ct", "lc", "d", "r", "cache", "p", "ec", "l", "bc", "dc", "e", "fc", "ac", "a", "cb", "C", "t", "ci", "unc", "f", "cs", "config", "m"], "div_blocks": ["div___blocks", "div___frames", "div___block", "ra_block", "div_frames", "div_images", "ra_frames", "div___images", "div_block", "ra_blocks", "ra_images"], "js_blocks": ["js67rows", "js__blocks", "js____guards", "bs_guards", "qs_values", "jsTheblocks", "qs_blocks", "css_times", "obs_rows", "css___times", "js_locks", "css_blocks", "bs_nos", "js___events", "css___blocks", "obs_maps", "js_guards", "js____block", "js___locks", "jsTheblock", "css___locks", "js_maps", "js____nos", "bs_block", "obs_blocks", "js_values", "js_pages", "jsThepages", "js_nos", "js_events", "js____blocks", "qs_Blocks", "css_events", "bs_jobs", "bs_blocks", "js_rows", "obs_boxes", "js_block", "js__times", "js67blocks", "js67boxes", "jsThejobs", "js__locks", "css_locks", "js__events", "css___events", "js___blocks", "bs_pages", "js67maps", "js_times", "qs_locks", "js___times", "js_jobs", "js_Blocks", "js_boxes"], "sconf": ["scfg", "Sconfig", "sscfg", "SConf", " sConf", "ssconf", "dscon", "Sconf", " scfg", "ssconfig", " sconfig", "tscfg", "Scon", "tsconfig", "sscon", "dsconf", "dsconfig", "tsConf", "sconfig", "tsconf", "Scfg", "scon", "sConf", "dscfg"], "b": ["k", "ib", "bp", "ba", "bi", "ab", "eb", "bg", "rb", "d", "bh", "p", "buf", "i", "l", "v", "bar", "bc", "e", "x", "bf", "g", "br", "a", "cb", "nb", "t", "base", "sb", "bb", "y", "mb", "buffer", "m", "db", "B"], "bd": ["BD", "td", "bh", "bn", "shell", "dis", "bf", "dash", "br", "ds", "dt", "sb", "bb", "cmd", "tab", "off", "bt", "db", "bi", "bl", "kb", "bs", "md", "gd", "di", "att", "th", "bet", "hd", "dj", "pad", "dc", "dd", "def", "ben", "ld", "dat", "aj", "fn", "wd", "no", "des", "desc", "ba", "bg", "dl", "try", "py", "sd", "ck", "fl", "bot", "bro", "de", "det", "pd", "dh", "be", "cond", "nd", "d", "bind", "sh", "bc", "bos", "but", "btn", "bel", "da", "dev", "od", "cd", "js", "bo", "back"]}}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599, "substitutes": {"argc": ["argsz", "axC", "catc", "argC", "axw", "catl", "axl", " argz", " arglc", "argsv", "argumentlc", "argumentc", "axc", "argl", "flagC", "flagc", "flaglc", "argumentz", "argw", "catw", "argsl", "arglc", "flagl", "catC", "argsc", "argumentl", " argC", "argumentv", "argumentC", " argl", "argz", " argw"], "argv": [" argp", "logvs", "logc", "argumentp", "agm", " arg2", "argsV", "arpc", "argV", " argm", "argvin", "arg2", "argsv", "agc", "argumentc", "argsm", "arkvin", "regp", "arkv", "regc", "argsvs", "argsvin", "regv", " argvs", "logv", "agV", "argsp", "args2", "arpv", "arp2", "argp", "argvs", " argV", " argvin", "agv", "argsc", "regvs", "argumentv", "argumentV", "arkc", "arpp", "argm"], "t1": ["T3", "t3", " t0", "v2", "int1", "T1", "int001", "T0", "T2", "t001", " t3", "t0", " t001", "v0", "v1", "int3", "int2", "v3", "T001"], "t2": ["T3", "t3", " t0", "time2", "time3", "t02", "T1", "T0", "T2", " t3", "time0", "t0", "time1", " t02", "time02", "T02"], "c": ["k", "n", "cut", "cat", "rc", "mc", "cmp", "ct", "b", "lc", "cur", "d", "gc", "p", "cache", "cc", "cp", "ec", "i", "l", "pc", "v", "bc", "dc", "co", "g", "fc", "sc", "col", "ac", "code", "cb", "C", "ce", "cod", "t", "cont", "abc", "unc", "color", "h", "tc", "z", "f", "cs", "vc", "ch", "cd", "con"], "cnt": ["lcnt", "CNT", "dcount", "acnt", "dcct", "lcount", "ecnt", " cct", "ecct", "cNT", "Ccount", "cct", "cant", "lcct", "acNT", "ecount", "acant", "account", "dcnt", "eccount", " cpt", "Cpt", "acct", "ccount", "Cct", " ccount", "cpt", "Cnt", "Cant", "dcpt", " cNT", "Count", "lcant", " cant", "dcant", "acount", "dcNT"], "buf": ["bt", "proc", "str", "cat", "cap", "rc", "var", "pool", "ff", "bin", "nt", "aka", "seq", "iter", "batch", "uf", "b", "rb", "func", "pb", "cur", "block", "Buff", "cache", "wb", "cp", "img", "mem", "window", "out", "bc", "ob", "queue", "result", "bed", "ctx", "br", "BU", "cb", "bag", "fd", "txt", "ref", "cv", "Buffer", "tmp", "pkg", "cmd", "err", "desc", "buffer", "buff", "data", "vec", "box"], "offset": ["bound", "slice", "time", "offer", "length", "offs", "error", "attribute", "handle", "origin", "store", "location", "part", "order", "h", "address", "padding", "id", "range", "off", "iterator", "pos", "top", "inner", "at", "util", "pad", "window", "prefix", "online", "before", "len", "loc", "meta", "index", "extra", "buffer", "needed", "et", "point", "style", "entry", "start", "p", "iso", "oid", "trace", "format", "info", "seek", "area", "key", "set", "addr", "position", "op", "rot", "alias", "tmp", "office", "Offset", "base", "slot", "flag", "first", "encrypted", "path", "local", "pointer", "timeout", "eta", "shift", "reset", "end", "total", "t", "zero", "ref", "size", "f", "skip", "owner"], "count": ["n", "iter", "time", "length", "nt", "cache", "v", "parts", "ount", "limit", "coll", "process", "part", "more", "cmd", "pattern", "child", "q", "batch", "max", "sum", "message", "list", "len", "num", "group", "force", "found", "cont", "index", "amount", "Count", "z", "add", "buffer", "other", "collection", "read", "cat", "latest", "find", "currency", "start", "try", "p", "match", "number", "info", "current", "name", "all", "code", "nb", "depth", "scroll", "result", "base", "first", "flag", "page", "ct", "comment", "not", "cond", "check", "type", "total", "counter", "now", "size", "call", "skip", "cycle", "print"], "optind": ["optinn", "argmind", " optreq", "OptInd", "optionbind", "optedIND", "optindex", "argbind", "potIND", "optedwind", "varsp", "alternstart", "varind", "alternIND", "optsp", "argind", "opsp", "optbind", "optwind", "optiminn", "opind", "varInd", " optstart", "arginn", "optInd", "optmind", "optionind", "optstart", "alternind", "optionmind", "optimind", "optimmind", "opmind", " optInd", "alternreq", "opIND", "Optind", "optedmind", "optionindex", "optionInd", "opinn", "optedind", "optimIND", "optimstart", " optwind", " optIND", "varindex", "optIND", "optreq", "optionsp", "optimindex", "opindex", "potmind", "OptIND", "potind", "potwind", "optimreq", "opInd", " optmind", "argindex", "optimbind"]}}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 657, "substitutes": {"avctx": ["wavcmd", "afctx", "devctx", "wavca", "avcontext", "wavjp", "avtx", "svcontext", "avjp", "afjp", "avca", "aftx", "navjp", "exctx", "avconn", "averjp", "wavjac", "afcontext", "svjp", "ravtx", "navctx", "wavtx", "avercmd", " avjp", "ravctx", "navtx", "devjp", "svctx", "devtx", "ravca", "averconn", " avcontext", "wavctx", "ravjac", " avjac", "excmd", "exconn", "devcontext", "averctx", "navcontext", "avjac", " avtx", "wavconn", "avcmd", "svtx", "exjp", " avca"], "frame": ["stack", "view", "slice", "fr", "point", "style", "ime", "face", "block", "one", "Frame", "word", "window", "row", "header", "trace", "shot", "format", "rame", "picture", "pixel", "list", "file", "video", "info", "zone", "reset", "force", "show", "flow", "code", "sequence", "process", "profile", "state", "framework", "component", "base", "module", "feature", "frames", "iframe", "f", "office", "scene", "range", "close", "version", "buffer", "function", "data", "line"], "image": ["inner", "age", "view", "images", " Image", "time", "entity", "self", "event", "xml", "item", "page", "im", "model", "ime", "integer", "remote", "p", "memory", "update", "i", "img", "word", "v", "attribute", "format", "picture", "pixel", "message", "info", "file", "video", "document", "audio", "Image", "source", "archive", "url", "ami", "code", "ma", "value", "operator", "t", "http", "print", "object", "order", "size", "ie", "module", "media", "imgur", "associated", "scene", "um", "version", "import", "figure", "buffer", "article", "m", "data", "photo", "instance", "io"], "compno": ["comeno", "condno", "buffno", "ompnumber", "compyes", "comdo", "ompno", "procnone", "comno", "cmpna", "condpo", " compNo", "comko", "condyes", "critNO", " compnumber", "compna", "compko", " compko", "compnumber", "cmpnet", "omppo", "proceno", "condnumber", "compname", "procNO", " compyes", "compnum", "componentno", "cpno", "procnumber", " compname", " compeno", "compdo", "cmpNO", "procdo", "compNo", "comnum", "ompname", "compnone", "ompmo", "componentna", "cpn", "Compno", "crityes", "critnone", "compmo", "compnos", "cmpeno", "commo", "cmpnumber", "comppo", "critno", "ompn", "biteno", "cpnet", "buffname", "ompyes", "ompNO", "CompNo", "critpo", "cmpname", "cmpn", "ompnone", "procpo", "critko", "expnum", "cmpno", "condNO", " compn", "cmpmo", "expno", " comppo", "comyes", "ompNo", "buffn", "cpnumber", "componentNO", " compnos", " compnone", "cmpyes", "ompna", "compn", "bitno", "ompeno", "componentyes", "CompNO", "ompnos", "comna", "criteno", "cmppo", "expNO", "cpeno", "comnone", "procno", " compNO", "comn", "compo", "cmpdo", "comNO", "buffNO", "comnumber", " compna", "compNO", "componentnone", "Compnos", "comnet", "cmpnone", "compnet", "componentnumber", "compeno", "exppo", "bitnumber", "condnum", "bitn", "comname"], "x": ["n", "time", "xes", "xml", "any", "r", "xxxx", "i", "v", "en", "history", "h", "ox", "xe", "xp", "q", "c", "at", "_", "on", "xy", "ax", "xf", "xc", "xi", "xa", "px", "index", "xx", "lex", "z", "yx", "xt", "add", "dx", "wx", "ext", "only", "step", "im", "height", "p", "lat", "fx", "l", "cross", "key", "full", "ix", "ce", "text", "inx", "dr", "tx", "m", "mx", "ex", "lon", "el", "xs", "php", "ct", "path", "X", "w", "check", "rx", "e", "xd", "content", "act", "ux", "xxx"], "y": ["asy", "n", "ley", "wy", "yr", "any", "by", "ady", "ey", "i", "hy", "v", "yd", "ies", "ry", "yy", "ny", "h", "uy", "top", "c", "yt", "xy", "row", "icy", "ys", "col", "ay", "ym", "Y", "index", "oy", "xx", "z", "yet", "gy", "vy", "j", "yer", "ya", "yo", "height", "p", "py", "out", "fy", "sys", "very", "my", "key", "yl", "axy", "ch", "ye", "m", "k", "iy", "entity", "ly", "b", "year", "w", "hey", "yn", "sky", "hot", "t", "aily", "ty", "o", "cy", "sy"], "image_line": ["image______liner", " image_link", "image______line", "img_lin", "image_ine", "current______liner", "image___node", "image______link", "image2line", "image______lines", "document_loop", "current______lines", "image_lines", "image_link", "image2eline", "imageldlin", "img_line", "image_____eline", " image_inline", "imageldrecord", "sequence_LINE", "imagelexline", "sequence_lin", "current_lines", "current______link", "image_loop", "imagelexliner", "image_liner", "image_row", "sequence___stroke", "picture2line", "sequence_row", "image_____lin", "sequence_line", " image_node", "inner_lin", "image___line", "sequence___line", "sequence___node", "current_liner", "inner_ine", "imageldine", "picture2eline", "document_link", "picture_line", "image_stroke", "imagelexlink", "image_record", "sequence_node", "document_line", "image___stroke", "picture_lin", "image_lin", "inner_line", "picture2lin", "current______line", "img_liner", "image2lin", "imagelexloop", "image_____line", "image_node", "current_line", "picture_eline", "current_link", "image_inline", "document_liner", "image_LINE", "image_eline", "sequence_stroke", "img_node", "imageldline", "inner_record"], "frame_index": ["frame__offset", " frame_ind", " frame_Index", "frame_i", "frame2index", "image_size", "image_Index", "line_index", "frame__index", " frame_size", "line_Index", "frame__Index", "image_index", "frame_offset", "frame_point", "line_i", "frame___Index", "frame___i", "frame__size", "frame2size", "frame_size", "frame__ind", "frame_Index", "frame2Index", " frame_sequence", "frame_ind", "frame2ind", "line_point", "frame_sequence", "frame___point", "frame___index", "image_offset"], "frame_ptr": [" frame_addr", "frame_rep", " frame_pointers", "framePopointer", "framePoptr", " frame_rep", "frame_addr", " frame_pointer", "framePorow", "framePoaddr", "frame_pointers", "frame_pointer", " frame_row", "frame_row"]}}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666, "substitutes": {"stream": ["present", "hook", "iter", "time", "normal", "length", "tr", "mount", "loop", "sync", "port", "draw", "history", "store", "trans", "console", "wind", "range", "import", "iterator", "test", "transform", "down", "empty", "pool", "sample", "post", "ream", "through", "window", "row", "REAM", "message", "list", "host", "table", "track", "lo", "version", "chain", "line", "read", "ready", "step", "point", "response", "ssl", "start", "forward", "channel", "reader", "valid", "stage", "roll", "seek", "pod", "poll", "follow", "scroll", "instance", "spec", "stack", "pipe", "each", "view", "form", "filter", "sign", "path", "flash", "clean", "remote", "local", "wrapper", "connection", "send", "Stream", "socket", "peer", "image", "driver", "hold", "network", "source", "link", "flow", "server", "sequence", "load", "sw", "client"], "feed": ["hook", "ff", "length", "graph", "control", "pause", "loop", "cf", "next", "port", "account", "draw", "history", "push", "limit", "delete", "and", "package", "json", "range", "import", "tab", "iterator", "io", "test", "transform", "post", "family", "row", "fi", "def", "raft", "host", "hub", "mail", "table", "index", "pop", "allow", "drop", "connect", "fail", "add", "github", "buffer", "config", "save", "supp", "read", "build", "find", "style", "grow", "entry", "channel", "rss", "valid", "good", "journal", "format", "low", "search", "submit", "df", "set", "full", "report", "join", "follow", "service", "zip", "form", "filter", "insert", "cond", "flash", "check", "send", "accept", "context", "socket", "parse", "driver", "hold", "source", "url", "link", "flow", "layout", "load", "zero", "look", "Feed", "raw", "f", "wait", "label", "event", "update"], "i": ["n", "oi", "cli", "slice", "record", "iri", "ati", "uri", "mi", "ind", "ai", "is", "v", "ij", "ei", "ic", "history", "it", "si", "to", "ie", "y", "h", "associated", "json", "id", "ti", "PI", "phi", "io", "ish", "iu", "bi", "hi", "init", "q", "ui", "batch", "c", "di", "status", "x", "fi", "ini", "list", "zi", "ims", "xi", "ami", "index", "multi", "chain", "sim", "ri", "j", "data", "I", "collection", "point", "entry", "im", "ki", "try", "p", "l", "ip", "info", "name", "set", "ix", "ci", "us", "gi", "m", "k", "li", "ii", "remote", "ji", "\u0438", "parent", "u", "e", "pi", "g", "me", "qi", "t", "f", "ski", "o", "client"], "fd": ["dates", "bound", "form", "diff", "fr", " f", "length", "find", "new", "cond", "d", "fe", "ists", "ms", " mismatch", "fs", "features", "set", "ci", "iff", "size", "ptr", "ffff", "err", " fid", "sofar"], "s": ["sam", "service", "sports", "n", "spec", "stats", "bs", "self", "ses", "es", "b", "c", "ssl", "ls", "start", "p", "its", "sd", "ps", "ts", "south", "gs", "v", "socket", "g", "se", "sc", "space", "source", "sv", "os", "fs", "ds", "set", "sts", "ats", "rs", "ns", "sb", "S", "sw", "y", "ess", "sq", "z", "f", "sl", "js", "series", "css"], "sf": ["lf", "alf", "ils", "esm", "xs", "ef", "uf", "ssl", "sk", "src", "sn", "fo", "orf", "sd", "fx", "cf", "rf", "fy", "sh", "fi", "bf", "xf", "ft", "isf", "se", "sc", "rn", "sv", "fs", "si", "sr", "fts", "so", "tif", "sm", "sb", "tf", "sw", "she", "fw", "iffs", "sl", "sq", "utf", "f", "sp", "hs", "SF", "sy"], "ss": ["iss", "bs", "ses", "es", "hess", "ssl", "sn", "ts", "sd", "ress", "rss", "\u00df", "ps", "cf", "gs", "sys", "socket", "sol", "se", "sc", "ms", "ys", "sv", "sis", "oss", "fs", "ds", "si", "sr", "sy", "rs", "ns", "SS", "sb", "sw", "ess", "sq", "sl", "ass", "cs", "sp", "pse", "hs", "js", "aws", "css"], "ccf": [" ccb", "cr", " cced", "ecb", "cked", " cct", " ccv", "cff", "cct", "ccb", " ccc", "cf", "cced", "ecv", "cft", "ecf", " ccr", "ccc", "cb", "cfed", "ecr", "cv", "ckt", "ccv", "cfc", "ckf", "ccr", "ckc"], "ccs": ["ucfs", "ccos", "rcf", "rcc", "cct", " ccfs", "ocs", "ucos", "ccfs", "cfos", "ccuts", "cks", "cffs", "rct", "ocf", "ucs", "rcs", " ccuts", "ccc", " ccos", "cfuts", "ckt", "occ", "cfs", "ckf", "ucuts", "ckc"]}}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669, "substitutes": {"env": ["param", "nw", "attr", "esm", "ext", "rc", "np", "forge", "ew", "et", "eh", "dh", "erd", "org", "enc", "rb", "site", "nv", "worker", "enter", "ut", "environment", "ec", "vt", "req", "era", "shell", "window", "v", "e", "context", "eng", "end", "esc", "ctx", "en", "conn", "code", "server", "vs", "manager", "addr", "er", "cb", "tk", "msg", "qt", "ect", "sb", "ner", "tm", "vp", "usr", "cv", "dev", "obj", "hw", "uv", "rod", "pkg", "disk", "net", "cmd", "vm", "config", "erb", "ah", "ev"], "intno": ["shortno", "pointna", "intnos", "innernos", "intername", "indnum", "innerNO", "internumber", " intorno", "INTorno", "intNo", "INTno", "interNo", " inteno", "inteno", " intnos", "portNo", "interNO", "intname", "portno", "innerNo", " intNo", "altno", "altNO", "intn", "innerno", "pointNo", " intname", "pointnos", "indNo", "tnos", " intnum", "intmo", "tnum", "internos", "indno", " intNO", " intnumber", "pointorno", "intnum", "INTeno", "intern", "intNO", "intnumber", "tNo", "INTNo", "shortnos", "interno", "intna", "interna", "altnos", "pointnum", "inno", "intermo", " intmo", "inNo", "shortNo", "pointnumber", "altname", "inmo", "indname", "intorno", "pointeno", "shortn", "portnos", "internum", "portn", " intna", "pointno", "tno", "inNO"], "is_int": [" is_internal", "isa_integer", "isGint", "isa_int", "is_intel", " is_intel", "is_inter", "isa_str", "is_ind", " is_id", "isGind", "is_str", "is_bool", "isGinternal", "is_internal", "is_integer", "isa_inter", " is_str", "isGstr", "is_id", " is_bool", " is_ind"], "error_code": [" error_codes", "error_type", " error_type", "error_codes"], "next_eip": ["next_eriph", "next_aeip", "next_seip", "next_ep", "next_peipp", "next_peIP", "next_eIP", "next_aeipp", "next_seipp", "next_seIP", "next_seiph", "next_eeiph", "next_eeip", "next_eep", "next_erIP", "next_aep", "next_peip", "next_eeIP", "next_aeIP", "next_eeipp", "next_eiph", "next_erip", "next_eipp", "next_eripp", "next_pep"], "is_hw": ["is2pkg", " is_fw", "is_float", " is_ht", "is2hh", "is_fw", " is_pkg", "is2hw", " is_hh", "is2ht", "is_hh", "is_ht", "is_pkg", " is_float"], "dt": ["bt", "dq", "tp", "dh", "et", "tt", "dar", "ct", "td", "d", "dl", "kt", "dp", "dc", "dd", "tz", "rt", "elt", "tn", "ctx", "lp", "ds", "tk", "dat", "tif", "iat", "t", "qt", "ect", "DT", "dm", "txt", "tm", "mt", "tc", "ctl", "typ", "db"], "ptr": ["inst", "bp", "tp", "eth", "lr", "attr", "dep", "iter", "np", "ep", "fr", "tr", "cur", "pt", "pr", "r", " pr", "p", " pointer", "ts", "pointer", "req", "pad", "Ptr", "rect", "inter", "ind", "fp", "prime", "next", "ij", "jp", "arr", "deg", "shift", "ctx", "coord", "handle", "br", "adr", "addr", "expr", "loc", "t", "etr", " prot", "pointers", "rel", "ref", "usr", "cont", "obj", "mt", " addr", "dr", "address", "sp", "inters", "cmd", "xt", "ctl", "ctr", "pos"], "type": ["Type", "tag", "test", "count", "tp", "day", "time", "what", "length", "cmp", "relation", "unit", "style", "error", "status", "rule", "p", "family", "kind", "ping", "info", "format", "name", "ror", "code", "set", "pe", "op", "types", "t", "ice", "class", "state", "ver", "size", "TYPE", "role", "like", "ico", "id", "ty", "range", "typ", "o", "ype"], "dpl": ["rfl", "rpl", "cdpel", "cdfl", "npl", "cdpl", "nlp", "pmultipl", " dpel", "dcopl", " dPL", "rmultipl", "popl", "dPL", "dsmultipl", "dsopl", " dlp", "dcpl", " dmultipl", "dcplug", "cfl", "dfl", "nmultipl", "dplug", "ppl", "pplug", "dsplug", "rlp", "nfl", "dlp", "cpel", "cPL", " dfl", "dopl", "cdPL", "dmultipl", "dspl", "dcmultipl", "dpel"], "selector": ["SELECTOR", "selectors", "selection", "lectOR", " Selector", " selecter", "selecter", "lecter", " selection", "elector", "election", "SELECTer", "selective", " selectors", "Selective", "selectOR", "electors", "SELECTive", "Selector", "SelectOR", "lective", "SELECTor", "electer", "Selecter", "lector", " Selecter", " Selectors", " Selection"], "cpl": ["dpal", "pPL", "dPL", " cpal", " cpp", "cpp", "dcpl", "upt", "ppr", "dcpr", "cfl", "pfl", "dfl", "ufl", "dcPL", " cpt", "upl", "ppl", " cpr", "dpt", "cpr", "cpt", " cfl", "cPL", "cpal", "ppp", "dpp", "upal", "dcfl", "dcpp"], "ist": ["iste", "ism", "dist", "at", "ast", "ind", "oid", "tip", "ip", "fp", "isp", "st", "is", "asm", "list", "ists", "reset", "os", "store", "push", "set", "IST", "osp", "sw", "wp", "sp", "xp", "lift"], "has_error_code": ["has_success_code", "has_error_codes", "has_success_error", "has_error___number", "has_success_codes", "has_success_number", "has_error_Code", "has_error___code", "has_error_number", "has_error___error", "has_error___codes", "has_success_Code", "has_error_error"], "new_stack": ["from_scope", "newlchain", "from_stack", "newlstack", "new_sp", "newlscope", "from_sp", "new_chain", "newlsp", "from_chain", "new_scope"], "e1": ["te2", "xe4", " e4", "er1", "e5", "xe6", "ee1", "er2", "xe1", "ee3", "e4", "te3", "ee2", "er5", "ee4", "xe2", "te4", "E1", " e7", "e7", " e6", "ee6", " e5", "E2", "ee5", "E3", "er7", "ee7", "te1", "e6", "E4"], "e2": ["ae6", "te2", "te6", "E02", "er1", "e5", "ee1", "er2", "ee3", "e4", "te3", "E5", "ee2", "ei5", "etwo", "ectwo", "ee4", " etwo", "ei2", "ertwo", "er3", "ec2", "ei1", "ec7", " e7", "e7", "ec02", "E1", "ee6", "ei3", " e5", "E2", "ee02", "er4", "ae2", "ae3", "ae1", "ee5", "E3", "er7", " e02", "ee7", "te1", "er02", "e6", "E4", "e02"], "e3": ["t1", " e4", "t3", "ce8", " e43", "e5", "ee1", "E7", "ee3", "e4", "e30", " e30", "ee2", "E5", "t4", "e8", "ee4", "t43", " e8", "ce3", "ce2", " e7", "e7", "E30", "ce5", " e5", "t30", "ee5", "t7", "ee8", "E3", "ee43", "e43", "t5"], "ss": ["s", "iss", "bs", "ssl", "status", "ts", "ps", "rss", "sh", "st", "sys", "ping", "sc", "oss", "os", "ds", "si", "osp", "rs", "SS", "esi", "sb", "sw", "sq", "sp", "ssh", "css"], "old_eip": ["old_eop", "old_aeep", "old___eip", "old_eliu", "old_eri", "old_egim", "old_aeip", "old_aeap", "old_elim", "old_Ei", "old_seop", "old_eim", "old___eim", "old_seap", "old___aeap", "old_eep", "old___erep", "old___eiu", "old_teep", "old_erim", "old___aeep", "old_Eop", "old_erop", "old___eep", "old_sei", "old___erim", "old_erep", "old_seep", "old___eriu", "old_eap", "old_egep", "old_egip", "old___eap", "old___erip", "old___aeip", "old_egiu", "old_erip", "old_teap", "old_Eip", "old_ei", "old_Eep", "old_teip", "old_elep", "old_elip", "old_eiu", "old_eriu", "old_seip"], "esp": ["bp", "tp", "ext", "ep", "et", "es", "ps", "fp", "ip", "ei", "isp", "ap", "jp", "reset", "lp", "eps", "si", "expr", "resp", "osp", "er", "rel", "esi", "vp", "yp", "tmp", "sp", "err", "xp"], "offset": ["attr", "slice", "point", "error", "start", "ot", "alt", "pointer", "scroll", "timeout", "oid", "ip", "fp", "next", "seek", "shift", "origin", "position", "addr", "loc", "op", "lock", "ref", "index", "size", "extra", "address", "Offset", "sp", "skip", "off", "pos", "slot"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n", "idx": 674, "substitutes": {"src": ["inst", "supp", "stack", "tp", "ipl", "ack", "input", "bs", "rc", "sec", "stock", "iter", "slice", "usc", "ipp", "bg", "ripp", "cur", "start", "th", "dest", "sn", "seed", "comp", "rl", "iv", "img", "ind", "sh", "st", "ur", "sup", "inc", "sync", "in", "rt", "sc", "source", "set", "addr", "sr", "ix", "rs", "sur", "sb", "ins", "txt", "filename", "usr", "sw", "ptr", "sl", "sq", "pri", "gin", "ser", "ctr", "sub", "scan"], "dst": [" dentry", "dnd", "ddST", "pst", " dST", "dST", "dhbr", " dx", "dentry", "ddend", "idbl", "ddsts", " dw", "dest", "pw", "idst", "dslt", "dbr", "dend", "ddbr", "dw", "dsts", "dx", "dests", "dhentry", "fdentry", "debr", "idw", "dhST", " dbl", " dut", "fnd", "fst", "dsend", "dond", "dhst", "pbl", "dlt", "fut", " dot", "dot", " dsts", "deST", "dbl", "fot", "px", "doot", " dend", "ddot", " dbr", "fdst", "fdST", "ddst", "ddlt", "fdbr", "dut", "dost", " dnd", "dout", "idx", "dsot", "dsst", " dlt"], "num_pixels": ["num_ppels", "num_pels", "num_ppours", "num_xpues", "num_xpels", "num_mixels", "num_npours", "num_xpixels", "num_meters", "num_peimens", "num_Peters", "num_Pixels", "num_Pix", "num_pues", "num_mimens", "num_npels", "num_npixels", "num_peters", "num_npues", "num_pours", "num_pix", "num_peixels", "num_Pimens", "num_mix", "num_pimens", "num_ppues", "num_peeters", "num_peix", "num_ppixels", "num_xpours"], "palette": ["plette", "pettes", " palte", "Palette", " palellow", "palue", " pallette", "calet", "pette", "calue", "palettes", " palue", "calma", "pma", " palet", "alettes", "pallette", "Palte", "palellow", "calette", "alet", "palet", " palma", "alue", " palettes", "palma", "calettes", "Palellow", "Palue", "alte", "alette", "callette", "alellow", "palte"], "i": ["oi", "cli", " multi", " err", " p", "mi", "uri", " mi", "ind", " I", "ai", "ei", "is", "ij", "ic", "it", "go", "si", "json", "id", "ti", "io", "iu", "bi", "hi", "init", " wi", "ui", " m", "di", "status", "ini", " di", "zi", "list", "ims", "xi", " ti", "ami", " ii", "index", "multi", "chain", "sim", "ri", "I", "this", "point", "asi", "uli", "im", "ki", " index", " bi", "ip", "info", "ix", "ci", " ni", "gi", "m", "ex", "li", " j", "ii", "ji", "pi", "in", " pi", "g", "me", "qi", "gu", "print", "series"]}}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    /* check for any coded coefficients in this codeblock */\n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    /* TODO: context pointer? */\n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}\n", "idx": 677, "substitutes": {"s": ["n", "spec", "stats", "bs", "ses", "ls", "sets", "d", "p", "ts", "its", "i", "is", "gs", "sh", "sys", "v", "e", "st", "ss", "se", "sc", "sv", "os", "ds", "a", "vs", "set", "sts", "settings", "t", "rs", "ns", "sm", "args", "S", "sf", "h", "sw", "sl", "f", "cs", "sp", "hs", "js", "sa", "j"], "b": ["em", "bt", "db", "ib", "ad", "fb", "bp", "bi", "lib", "ab", "bl", "bs", "n", "ba", "bound", "eb", "amb", "emb", "display", "bg", "be", "rb", "pb", "d", "r", "bh", "p", "wb", "i", "l", "v", "bar", "bc", "u", "ob", "bm", "g", "br", "bis", "ac", "it", "a", "cb", "o", "nb", "lb", "t", "sb", "bb", "obj", "ub", "bd", "mb", "ed", "h", "f", "ch", "buffer", "buff", "bo", "j", "erb", "base", "B"], "gb": ["bt", "vg", "sg", "fb", "kb", "yg", "bs", "eb", "gd", "bg", "cfg", "rb", "gh", "pb", "rg", "gc", "py", "wb", "xy", "gs", "bc", "csv", "cm", "bf", "bm", "gt", "g", "cb", "gio", "nb", "lb", "sb", "bb", "GB", "cv", "ub", "mb", "gpu", "eg", "gg", "tg", "ubs", "ch", "gy", "gm", "erb", "db"], "c": ["cr", "rc", "mc", "cmp", "ct", "lc", "con", "ca", "cu", "r", "p", "cc", "cp", "ec", "l", "pc", "cf", "bc", "dc", "csv", "cm", "co", "cn", "xc", "g", "fc", "sc", "ctx", "ac", "a", "cb", "C", "ce", "ci", "t", "cont", "abc", "cv", "tc", "f", "cs", "vc", "ch", "ctrl"], "top": ["tp", "localhost", "first", "min", "lower", "toc", "above", "target", "start", "at", "ot", "pt", "height", "lat", "p", "local", "tops", "parent", "tip", "hot", "offset", "title", "best", "my", "num", "hop", "origin", "to", "op", "Top", "t", "table", "root", "TOP", "tmp", "sp", "bot", "ty", "upper", "below", "j", "pos", "client", "slot", "north"], "bottom": ["above", "org", "bill", "tight", "yt", "mobile", "height", "board", "loop", "south", "offset", "bott", "body", "row", "off", "window", " Bottom", "my", "zone", "box", "origin", "total", "last", "radius", "base", "odd", "zero", "where", "root", "Bottom", "gravity", "mb", "bot", "level", "upper", "below", "bo", "boot", "boost", "back", "blue"], "blockcnt_one": ["blockcnt_zero", "blockcnt_many", "blockcnt_One", "blockcount_zero", "blockcnt_1", "blockcount_one", "blockcount_One", "blockcount_two", "blockcnt_two", "blockcount_1", "blockcount_many"], "is_arith": ["is_erich", "is_uract", "is_carth", "isplacedarich", "is_karitch", "is_irith", "is_darith", "is_darithmetic", "is_dritch", "isplacedarith", "is_caract", "is_rth", "isplacearich", "is_alth", "isplacedarth", "is_arhs", "is_rith", "is_aract", "is_karhs", "is_aritch", "is_eroch", "is_aroch", "is_irITH", "is_drITH", "is_drhs", "is_karITH", "is_karith", "is_arcact", "is_arcith", "is_arcth", "is_alithmetic", "isplacearith", "is_drith", "isplacearithmetic", "is_arcoch", "is_irhs", "is_urich", "isplacedarithmetic", "is_urith", "is_carith", "is_urth", "is_iract", "is_arich", "is_rithmetic", "is_alich", "is_darich", "is_arITH", "is_erith", "is_arth", "is_iroch", "is_darth", "is_arithmetic", "is_alith", "is_rich", "is_eract", "is_carich", "is_erth", "isplacearth", "is_irth", "is_iritch"], "x": ["k", "n", "wx", "el", "xs", "xes", "xml", "xxx", "d", "X", "w", "p", "lat", "rx", "i", "xy", "fx", "l", "row", "v", "u", "e", "ax", "xd", "xp", "xf", "xc", "g", "cross", "mx", "xi", "xa", "key", "ry", "ix", "op", "ice", "t", "px", "index", "inx", "xx", "ux", "lex", "ick", "z", "yx", "h", "f", "ox", "tx", "xt", "ch", "ty", "m", "j", "cy", "dx", "ex"], "y": ["iy", "asy", "yer", "wy", "yr", "et", "ya", "ly", "year", "ble", "ot", "yt", "pt", "ady", "ey", "py", "dy", "xy", "i", "yn", "v", "fy", "hot", "sky", "icy", "kit", "my", "ys", "ies", "ery", "ay", "ry", "yy", "ny", "ym", "t", "Y", "yl", "oy", "uy", "h", "axy", "gy", "yx", "z", "ty", "ch", "ye", "vy", "j", "cy", "sy"], "zero_block": ["zero_run", "zeroablebox", "zero67lock", "Zero_run", "zero67run", "positive_lock", "positive_box", "zero67cap", "zeroablebit", "zero67line", "zero_cap", "Zero_lock", "zero67block", " zero_sync", "zero67chain", "zero_box", "zero_sync", " zero_group", "positive_bit", "zero_chain", "zeroableblock", "zero_line", "Zero_line", "zeroablelock", "zero67group", "positive_block", "zero_lock", "zero_bit", " zero_chain", "zero_group", "Zero_block", " zero_bit", " zero_cap"], "qoffset": ["qustart", "quslot", "qqset", "qualpoint", "dqarea", "qualoffset", "dqaddr", "qset", "qqoffset", "qutrace", "quset", " qtrace", "qtrace", "qqurl", " qerror", "dqstart", "queryoff", "ckarea", "ckoffset", "Qstart", "qqpad", "qoff", "qurl", "qpad", "qerror", "ckaddr", "querystart", "qslot", " qoff", " qset", "qqoff", " qpoint", "ckstart", "qualset", "qualslot", "qarea", "qualtrace", " qurl", "queryset", "Qaddr", "qqerror", "dqoffset", "queryoffset", "qaddr", "ueurl", "qualstart", "qpoint", "uepad", "qstart", " qstart", "qqstart", "Qoffset", " qpad", "ueerror", "ueoffset", "quoffset", " qslot", "Qarea", "qupoint"], "qfactor": ["dqfactor", "dqterm", "sqoffset", "aqactor", "aqterm", "qrate", "qqfloor", "qfloor", "eqrate", "sqterm", "queryfactor", " qterm", "eqactor", "zactor", "queryprocessor", "aqfactor", "qqrate", "dqactor", "eqterm", " qactor", "queryactor", "eqfloor", " qrate", "sqclass", "aqoffset", "qprocessor", " qoperator", "eqoperator", "qqoperator", "zterm", "qterm", "dqoffset", "queryoffset", "eqfactor", "qclass", "qactor", "zclass", "qqfactor", " qclass", "eqoffset", "zfactor", "sqactor", "sqprocessor", "eqprocessor", "sqfactor", " qfloor", "qoperator"], "buf": ["fb", "read", "pool", "iter", "cap", "np", "ff", "emb", "batch", "uf", "rb", "pb", "cur", "block", "Buff", "cache", "bn", "wb", "img", "mem", "window", "bar", "off", "out", "keep", "def", "queue", "result", "port", "cam", " vec", "conv", "xff", "br", "ctx", "limit", "BU", "end", "cb", "msg", "now", "ref", "home", "cv", "Buffer", "cast", "mb", "pkg", "tmp", "raw", "pack", "broad", "cmd", "err", "um", "buffer", "ctr", "buff", "tab", "data", "vec", "box"]}}
{"project": "FFmpeg", "commit_id": "d58a6d8537a6f34941973c5c3be93d484a4d62ed", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    FFV1Context *f = avctx->priv_data;\n\n    CABACContext * const c= &f->c;\n\n    AVFrame *pict = data;\n\n    const int width= f->width;\n\n    const int height= f->height;\n\n    AVFrame * const p= &f->picture;\n\n    int used_count= 0;\n\n\n\n    if(avctx->strict_std_compliance >= 0){\n\n        av_log(avctx, AV_LOG_ERROR, \"this codec is under development, files encoded with it wont be decodeable with future versions!!!\\n\"\n\n               \"use vstrict=-1 to use it anyway\\n\");\n\n        return -1;\n\n    }\n\n        \n\n    ff_init_cabac_encoder(c, buf, buf_size);\n\n    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);\n\n    c->lps_state[2] = 1;\n\n    c->lps_state[3] = 0;\n\n    \n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    \n\n    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){\n\n        put_cabac_bypass(c, 1);\n\n        p->key_frame= 1;\n\n        write_header(f);\n\n        clear_state(f);\n\n    }else{\n\n        put_cabac_bypass(c, 0);\n\n        p->key_frame= 0;\n\n    }\n\n\n\n    if(!f->ac){\n\n        used_count += put_cabac_terminate(c, 1);\n\n//printf(\"pos=%d\\n\", used_count);\n\n        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);\n\n    }\n\n    \n\n    if(f->colorspace==0){\n\n        const int chroma_width = -((-width )>>f->chroma_h_shift);\n\n        const int chroma_height= -((-height)>>f->chroma_v_shift);\n\n\n\n        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);\n\n\n\n        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);\n\n        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);\n\n    }else{\n\n        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);\n\n    }\n\n    emms_c();\n\n    \n\n    f->picture_number++;\n\n\n\n    if(f->ac){\n\n        return put_cabac_terminate(c, 1);\n\n    }else{\n\n        flush_put_bits(&f->pb); //nicer padding FIXME\n\n        return used_count + (put_bits_count(&f->pb)+7)/8;\n\n    }\n\n}\n", "idx": 683, "substitutes": {"avctx": ["cvjac", " savcontext", "wavsys", "avcontext", "avecmd", "savcfg", " avbc", "AVtx", "AVcontext", "avercv", "avertx", "avtx", "averjac", "avercontext", "avsys", " avpkg", "avxc", " avsys", " avxc", "cvcmd", "wavtx", "avercfg", " savjac", "cvconf", "AVcv", "avconf", "aveconf", "ovctx", "AVctx", " avcv", "avejac", " savctx", "abctx", "cvctx", "wavcontext", "avcv", "avesys", " avcontext", "abxc", "abcontext", "averxc", "avectx", "ovconf", "wavctx", "avecontext", " avjac", "ovjac", "savctx", "averbc", "averctx", "savpkg", "avpkg", "avjac", " avtx", "abjac", "averpkg", " avcfg", " savbc", "avcmd", "ovcmd", "avcfg", "savcontext", "avbc", "avetx"], "buf": ["db", "fb", "bp", "bs", "cap", "bin", "bytes", "batch", "uf", "b", "rb", "cur", "pos", "block", "w", "bh", "cache", "wb", "pad", "img", "mem", "window", "bar", "bc", "bf", "queue", "len", "ctx", "xff", "br", "BU", "limit", "cb", "ref", "txt", "text", "cv", "Buffer", "mb", "tmp", "raw", "cmd", "err", "buffer", "buff", "vec", "box"], "buf_size": ["buflenlength", " buf2size", "uf_size", "bufablelength", " buf2state", "bufablesize", "buf2max", "uf_number", "bufablenumber", " buf_SIZE", "bufbufmax", "bufbufsize", "bufbufSIZE", "buf_state", " buf2SIZE", "buflenaddress", "buflensize", "buf_number", "buf_SIZE", "uf_SIZE", "buf2SIZE", "bufableSIZE", "buf_max", "bufbufstate", " buf_max", "buf2size", " buf_state", "buf2state", "buf_length", "uf_length", "buflenSIZE", "buf_address", "uf_address", " buf2max"], "data": ["DATA", "first", "str", "empty", "form", "what", "init", "bin", "flat", "bytes", "batch", "new", "values", "array", "d", "block", "w", "frame", "r", "cache", "png", "board", "points", "pad", "xy", "window", " DATA", "Data", "next", "format", "picture", "image", "def", "info", "button", "video", "message", "list", "box", "area", "value", "a", "code", "params", "dat", "actions", "rel", "da", "table", "text", "intel", "ref", "device", "state", "obj", "media", "snap", "extra", "raw", "mu", "json", "rew", "buffer", "sequence", "ata"], "f": ["fu", "ff", "fg", "r", "i", "cf", "v", "bf", "fs", "foreign", "h", "y", "F", "lf", "fm", "q", "ef", "uf", "fort", "far", "util", "fa", "fe", "fi", "fab", "xf", "ft", "def", "file", "inf", "tf", "z", "j", "fax", "of", "fb", "fr", "fen", "ec", "fx", "l", "out", "info", "ctx", "df", "fl", "full", "fw", "mac", "m", "form", "b", "d", "w", "fo", "feat", "fp", "rf", "e", "u", "fc", "conf", "g", "flow", "t", "fd", "sf", "um", "o", "fac"], "c": ["n", "lib", "rc", "mc", "cmp", "b", "ct", "lc", "ca", "com", "cu", "r", "gc", "cache", "cp", "cc", "ec", "i", "l", "pc", "cf", "v", "bc", "dc", "u", "co", "e", "cm", "xc", "fc", "g", "conf", "ic", "nc", "ctx", "cam", "conv", "ac", "coll", "a", "C", "ce", "t", "ci", "cont", "abc", "uc", "unc", "cv", "h", "tc", "etc", "cus", "cs", "ch", "chain", "icc", "m", "con", "fac"], "pict": ["capt", "ht", "np", "pic", "ct", "P", "cu", "pt", "kt", "pen", "pr", "fen", "util", "feat", "img", "pas", "stat", "pres", "pai", "fi", "picture", "Pict", "fc", "conf", "ctx", "cam", "conv", "fl", "fn", "pl", "txt", "act", "vp", "h", "fig", "phy", "Pic", "ch", "fac"], "p": ["ph", "n", "pro", "tp", "proc", "bp", "app", "rep", "np", "pic", "b", "post", "att", "pb", "P", "at", "pt", "per", "dp", "pr", "mp", "local", "cp", "ps", "py", "i", "parent", "pc", "fp", "ip", "l", "v", "u", "ap", "pi", "ping", "picture", "jp", "par", "pp", "o", "lp", "it", "a", "resp", "op", "part", "t", "perm", "vp", "h", "progress", "policy", "pkg", "public", "pre", "wp", "sp", "m", "pa"], "picture_number": ["picture_type", "photo_no", "picture_no", "photo_type", "photo_number", "photo_num", "picture_num"]}}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686, "substitutes": {"ret": ["vector", "repl", "flag", "ext", "rets", "det", "rep", "iter", "final", "nt", "q", "secondary", "re", "tr", "prot", "lit", "r", "opt", " fut", "alt", "inter", "arg", "vt", "match", "ll", "elt", "prime", "out", "v", "fun", "quad", "rm", "rev", "gt", "ft", "ter", "rt", "lt", "port", "g", "reg", "reset", "reflect", "deg", "bit", "ry", "expr", "ld", "Ret", "RET", "rot", "res", "t", "val", "print", "jp", "ref", "obj", "mt", " RET", "tmp", "cmd", "red", "desc", "result", "rem"]}}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707, "substitutes": {"opaque": ["popaque", "OPque", "opque", "compaque", "popque", "popaques", "OPaques", "oroch", "compaques", "opoch", "OPacity", "opacity", "popacity", "compoch", " opque", "opaco", "popaco", " opacity", "oraques", "compaco", "oraco", " opaques", "popoch", "opaques", "oraque", "OPaque"], "ret": ["count", "flag", "ext", "rets", "iter", "det", "hash", "nt", "re", "tr", "status", "lit", "after", "alt", "ts", "arg", " Ret", "mem", "tail", "out", "fun", "def", "rev", "ft", "gt", "ter", "rt", "lt", "elt", "fin", "reset", "success", "set", "resp", "Ret", "RET", "rot", "res", "t", "val", "cont", "ref", "tf", "ent", "mt", "tree", "cmd", "err", "red", "desc", "result", "rem"], "offset": ["offer", "length", "et", "error", "start", "block", "at", "util", "alt", "p", "iso", " offsets", "pointer", "align", "oid", "fp", "l", "row", "out", "next", "onet", "ob", "ft", "seek", "shift", "reset", "origin", "end", "set", "addr", "location", "op", "rot", "ref", "order", "size", "index", "mt", "z", "f", "address", "Offset", "sp", "buffer", "o", "off", "data", "pos", "slot"], "len": ["lf", "n", "lon", "el", "nl", "lib", "seq", "length", "bytes", "nt", "mult", "ls", "pos", "lit", "lim", "syn", "alt", "ll", "l", "fun", "rev", "elt", "lt", "fin", "en", "all", "trans", "Len", "fl", "resp", "lis", "res", "t", "vec", "val", "ref", "size", "il", "h", "ail", "ln", "sp", "err", "term", "lan"], "acb": ["acbb", "aconnb", "aclbe", "aconx", "aclf", "aclbp", "acd", "acona", "accnb", "racnb", "acong", "acabd", " acwb", "accch", "acp", "acx", "pacwb", "ocb", "ocr", "pacbd", "jacbb", "iacobj", "accg", "accd", "aclc", "iacsb", "sacb", "pacr", "pacc", "actb", "iacb", "iacbb", "iacbi", "racmb", "aconbi", "aca", "aclp", "aconrb", " cacnb", "pacobj", "iacnb", "aconf", "jacbe", "pacgb", "jacb", " acnb", "ancnb", "aclch", "Acv", "acmb", "accob", "acbp", "accbb", "acla", "aclw", "acr", " acl", "aclwb", "sacby", "jacby", "iacp", "acbol", "acab", "acc", "acw", "acsb", "accsb", "pacnb", " acbb", "Acr", "aconby", "accab", "iacbe", " acp", "acf", "acba", "acca", "aclbol", "iacbd", "iacbar", " acsb", "aclob", "aclb", "iacab", "acby", "acbd", "sacbar", " acbd", "ancgb", "aclbi", "aconbp", "aconbar", "sacnb", "accx", "Acb", "accv", "iacgb", "sacba", "acv", "iacob", "acgb", "ancwb", " acr", " cacba", "actbar", "acrb", "acanb", "aclnb", "aclba", "acob", "actbd", "acwb", "acg", "accb", "pacg", "aconbol", "pacbp", "actnb", "iacf", " acbe", "acabar", " acch", "acnb", "racbp", "aclrb", "accbp", "ancb", " acw", " aca", "ocd", "accmb", "iacx", " acobj", " cacb", "accba", "sacbb", "ocv", "acbi", "jacnb", "jacr", "acch", "aconbe", "accc", "Acd", "accl", " acba", " cacbb", "pacp", "accr", "acobj", "aclmb", "aconb", " acbol", "aclab", "iacwb", "aclbb", "acbar", "aconw", "acbe", "pacbb", "aclr", "jacbar", "pacb", "aclsb", "aconl", "aconp", "racb", " acc", " acrb", "acl", "accp", "accf"], "s": ["sam", "stats", "es", "b", "c", "ls", "states", "w", "r", "ains", "p", "ts", "its", "ps", "i", "gs", "is", "sys", "less", "ss", "g", "ms", "space", "sv", "os", "fs", "ashes", "ds", "acs", "sts", "ats", "rs", "ns", "t", "bits", "sb", "S", "ins", "h", "us", "locks", "sl", "sq", "cs", "js", "ubs"], "bs": ["bt", "BS", "ba", "bp", "bi", "bl", "lbs", "bas", "blocks", "bytes", "b", "bps", "ls", "bh", "ts", "its", "ps", "aus", "gs", "sys", "bc", "bm", "ks", "obs", "bos", "aos", "outs", "os", "bis", "fs", "ds", "br", "acs", "cb", "vs", "ats", "vers", "rs", "lb", "irms", "bits", "ns", "sb", "bb", "bd", "locks", "cs", "hs", "js", "ubs", "aws", "css", "bes"]}}
{"project": "qemu", "commit_id": "b6c147622d31272f9728da9ec16d146bf8c45a74", "target": 1, "func": "int qcow2_update_header(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowHeader *header;\n\n    char *buf;\n\n    size_t buflen = s->cluster_size;\n\n    int ret;\n\n    uint64_t total_size;\n\n    uint32_t refcount_table_clusters;\n\n    size_t header_length;\n\n    Qcow2UnknownHeaderExtension *uext;\n\n\n\n    buf = qemu_blockalign(bs, buflen);\n\n\n\n    /* Header structure */\n\n    header = (QCowHeader*) buf;\n\n\n\n    if (buflen < sizeof(*header)) {\n\n        ret = -ENOSPC;\n\n        goto fail;\n\n    }\n\n\n\n    header_length = sizeof(*header) + s->unknown_header_fields_size;\n\n    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);\n\n\n\n    *header = (QCowHeader) {\n\n        /* Version 2 fields */\n\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n\n        .version                = cpu_to_be32(s->qcow_version),\n\n        .backing_file_offset    = 0,\n\n        .backing_file_size      = 0,\n\n        .cluster_bits           = cpu_to_be32(s->cluster_bits),\n\n        .size                   = cpu_to_be64(total_size),\n\n        .crypt_method           = cpu_to_be32(s->crypt_method_header),\n\n        .l1_size                = cpu_to_be32(s->l1_size),\n\n        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),\n\n        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),\n\n        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),\n\n        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),\n\n        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),\n\n\n\n        /* Version 3 fields */\n\n        .incompatible_features  = cpu_to_be64(s->incompatible_features),\n\n        .compatible_features    = cpu_to_be64(s->compatible_features),\n\n        .autoclear_features     = cpu_to_be64(s->autoclear_features),\n\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n\n        .header_length          = cpu_to_be32(header_length),\n\n    };\n\n\n\n    /* For older versions, write a shorter header */\n\n    switch (s->qcow_version) {\n\n    case 2:\n\n        ret = offsetof(QCowHeader, incompatible_features);\n\n        break;\n\n    case 3:\n\n        ret = sizeof(*header);\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n    memset(buf, 0, buflen);\n\n\n\n    /* Preserve any unknown field in the header */\n\n    if (s->unknown_header_fields_size) {\n\n        if (buflen < s->unknown_header_fields_size) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n\n        buf += s->unknown_header_fields_size;\n\n        buflen -= s->unknown_header_fields_size;\n\n    }\n\n\n\n    /* Backing file format header extension */\n\n    if (*bs->backing_format) {\n\n        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n", "idx": 710, "substitutes": {"bs": ["BS", "bp", "bl", "lbs", "ses", "b", "bps", "ls", "bles", "als", "bh", "its", "ts", "fps", "ps", "gs", "bc", "bm", "ss", "obs", "bos", "aos", "bes", "outs", "os", "bis", "fs", "ds", "vs", "ats", "rs", "ns", "bits", "sb", "hz", "cs", "hs", "js", "ubs", "ubis", "aus"], "s": ["sn", "is", "parts", "fs", "ds", "bits", "http", "sb", "h", "y", "sq", "hs", "steps", "impl", "ses", "_", "def", "big", "ims", "sv", "os", "ashes", "vs", "sts", "ats", "as", "cont", "details", "j", "of", "qs", "states", "p", "ps", "into", "sys", "less", "ss", "ms", "bis", "params", "times", "args", "sl", "sam", "spec", "stats", "xs", "ust", "comm", "results", "es", "b", "func", "ls", "als", "its", "ts", "changes", "gs", "g", "settings", "rs", "ns", "t", "ins", "S", "obj", "cs", "js", "aws", "series"], "header": ["tag", "token", "var", "hash", "pillar", "layer", "relation", "tr", "section", "metadata", "comment", "status", "frame", "block", "channel", "cache", "map", "memory", "head", "bo", "Header", "wrapper", "parent", "window", "row", "field", "title", "format", "member", "list", "queue", "heading", "document", "shift", "headers", "port", "handler", "history", "name", "key", "master", "column", "er", "profile", "tar", "table", "index", "module", "h", "dr", "policy", "tree", "holder", "cmd", "HEAD", "padding", "version", "buffer", "event", "term", "data"], "buf": ["read", "bl", "cap", "rc", "pool", "bin", "bytes", "uffer", "foo", "uf", "b", "rb", "pb", "block", "Buff", "bh", "map", "cache", "img", "mem", "window", "cf", "late", "bc", "ob", "queue", "box", "conv", "br", "copy", "cb", "t", "ref", "cv", "h", "Buffer", "pack", "tmp", "raw", "cmd", "buffer", "buff", "data", "vec", "alloc", "utter"], "ret": ["flag", "rets", "nt", "Return", "re", "tr", "status", "lit", "r", "alt", " Ret", "out", "rm", "def", "rev", "ft", "gt", "rt", "deg", "elt", "reg", "len", "reset", "resp", "Ret", "RET", "res", "t", "val", "ref", "mt", "err", "red", "result", "rem"], "total_size": ["general67size", "total12address", "total_address", "total__ize", "totalTimeaddress", "total67position", "general_size", "total_des", "totaledsize", "total_bytes", " total_bytes", "total_position", "Total_state", "general_position", "total_Size", "Total_size", " total_ize", "total12size", "totaledposition", "totalTimestate", "total__bytes", "Total_address", "general_SIZE", "total67size", "general67position", " total_Size", "total__size", "totaleddes", "general_des", "total12Size", "total67SIZE", "total_state", "total_SIZE", "general67des", "totalTimesize", "totalTimeSize", "totaledSIZE", "Total_Size", "total12state", "general67SIZE", "total_ize", "total67des", "total__Size"], "refcount_table_clusters": ["refcount_table_colodes", "refcount_table_clodes", "refcount_table_colusters", "refcount_table_cluster", "refcount_table_glients", "refcount_table_coluster", "refcount_table_gluster", "refcount_table_glusters", "refcount_table_clients", "refcount_table_lusters", "refcount_table_plusters", "refcount_table_Clients", "refcount_table_Clusters", "refcount_table_pluster", "refcount_table_colients", "refcount_table_colroups", "refcount_table_lodes", "refcount_table_clroups", "refcount_table_plroups", "refcount_table_glroups", "refcount_table_Cluster", "refcount_table_glodes", "refcount_table_lroups", "refcount_table_plients"], "header_length": ["Header_length", "Header_len", "header_len", "Header_width", "header_size", "Header_size", " header_len", " header_size", "header_width"], "uext": ["ubeXT", "UEXT", "UExt", "ubev", "ubext", "UEv", "gext", "geXT", "gev", "UEext", "ueext", "geext", "ubeext", "uev", "ueXT"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 729, "substitutes": {"host_port": ["host_PORT", "host_ip", " host_PORT", " host_host", " host_ports", "host_ports", "host_host", " host_ip"], "errp": [" errm", " errps", "errping", "derp", "erps", " errr", "derm", "errpe", "errps", "erp", " errpe", "erping", "erm", "erP", "errr", "rrP", "rrp", "derpe", "errm", "derr", " errping", "errP", "rrping", "erpe", "err", "rrps", " errP"], "s": ["n", "spec", "stats", " ts", "es", "b", "c", " ss", "ls", " parts", " inputs", "d", "ares", "w", "r", "p", "ts", " sets", "ps", " samples", "fps", "i", "its", "l", " fs", "south", "gs", "v", "is", " S", "socket", " gets", "e", " rs", "less", "ss", "tes", "space", "sv", "os", "ips", "fs", "ds", "a", "set", "sts", "ats", "rs", "ns", "t", "sb", "S", "h", "span", " a", "sl", "sq", "f", "su", "sp", "z", "js", "m", " es"]}}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740, "substitutes": {"dev": ["de", "ad", "db", "test", "proc", "pro", "stick", "spec", "prom", "app", "det", "var", "school", "md", "nt", "normal", "tr", "di", "any", " device", "devices", "w", "usb", "Device", "local", "av", "sd", "req", "pad", "ve", "mem", "window", "v", "valid", "sys", "pi", "def", "die", "info", "driver", "cam", "handle", "conn", "serial", "doc", "server", "develop", "go", "adv", "Dev", "development", "tech", "serv", "device", "ver", "home", "debug", "obj", "hw", "des", "phy", "cmd", "priv", "hid", "project", "range", " Dev", "DEV", "scan", "env", "ev"], "fdt": ["dbts", "fifl", "fredy", "hdt", "hdy", "pedts", "dirtd", "ffout", "fctd", "FDtt", "ardout", "diry", "hdT", "dlt", "fedk", "FDt", "dedts", "fedts", "fdp", "fredwt", "fdl", "fcm", "flT", "rodt", "condT", "fredts", "fftt", "flts", "dedwt", "fct", "fifwt", "fdk", "dbk", "fcT", "fredt", "FDl", "udT", "fft", "ardp", "fdy", "flt", "inedlist", "dlwt", "dirwt", "inedl", "dbt", "FDout", "dirts", "FDwt", "fdout", "dirm", "fiftd", "udout", "fedT", "fcout", "dlout", "fift", "fdT", "dirt", "fdm", "fcwt", "inedt", "dedt", "fdlist", "fifm", "pedwt", "ardtt", "rodk", "fdtt", "dlT", "hdk", "fcy", "condt", "condts", "fiflist", "fdtd", "flwt", "FDp", "udwt", "fdts", "fedt", "pedT", "ffp", "fedy", "inedwt", "dbT", "pedt", "ardt", "condk", "fcts", "FDlist", "dedT", "udt", "fdwt", "rodT", "rody"], "offset": ["vector", "count", "slice", "initial", "offer", "length", "offs", "from", "error", "shared", "append", "packed", "origin", "store", "location", "tile", "ptr", "associated", "address", "padding", "id", "range", "tab", "off", "pos", "transform", "empty", "prototype", "batch", "pad", "exclusive", "row", "online", "len", "num", "ta", "index", "extra", "ength", "initialized", "attr", "point", "style", "outer", "entry", "start", "oid", "optional", "seek", "set", "position", "alias", "Offset", "scroll", "base", "slot", "locked", "encrypted", "final", "frequency", "pointer", " offsets", "align", "mounted", "shift", "layout", "total", "zero", "atomic", "size", "o", "owner"], "sphb": ["spersefb", "sphfb", "smphi", "ssmphb", "southperseg", "southphg", "ssphi", "sphbr", "shpp", "ssmphp", "spha", "southpersebr", "ssphb", "southperseb", "sPHg", "southphbr", "sphp", "ssmpha", "southphfb", "smphb", "smphp", "sphg", "sPHb", "smpha", "ssmphi", "spersebr", "southpersefb", "ssphp", "sphi", "sPHbr", "shpi", "southphb", "shpb", "sperseg", "shpa", "sPHfb", "sspha", "sperseb"], "rp": ["Rp", "prp", "prpc", " rr", "rr", "Rr", "rpc", "prr", " rpc", "Rpc"], "pci_status": ["pci2stat", "pdi_status", "pdi2status", "pdi2progress", "pci2progress", "pci2status", "pdi2stat", "pci2name", "pdi_progress", "pci_name", "pdi2name", "pdi_name", "pci_stat", "pdi_stat", "pci_progress"], "err": ["proc", "attr", "init", "iter", "rc", "error", "cur", "pr", "req", "Error", "rev", "arr", "conf", "exc", "rr", "br", "cb", "resp", "msg", "er", "res", "rel", "txt", "ch", "typ", "notice", "ev"], "buf": ["proc", "pipe", "str", "cap", "pool", "seq", "ff", "uf", "b", "temp", "tty", "cache", "p", "mem", "bc", "queue", "br", "cb", "msg", "cv", "Buffer", "ptr", "tmp", "cmd", "ch", "buffer", "buff", "vec"], "max_msi": ["max_msI", "max_apsis", "max_msis", "max_ksI", "max_tsi", "max_apsi", "max_ksis", "max_tsI", "max_tsis", "max_ksi", "max_apsI"], "max_msix": ["max_psci", "max_tsie", "max_tsi", "max_tsci", "max_fsix", "max_msci", "max_msie", "max_psi", "max_fsi", "max_fsci", "max_tsix", "max_psie", "max_psix", "max_fsie"]}}
{"project": "FFmpeg", "commit_id": "a8d702859b8bd17978fb5d8cb1d6acc363031e80", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748, "substitutes": {"m": ["em", "fm", "n", "esm", "md", "mc", "wm", "man", "hm", "iam", "b", "c", "metadata", "im", "d", "mi", "mod", "cache", "p", "mp", "am", "on", "i", "l", "pc", "mem", "mm", "v", "e", "cm", "bm", "message", "om", "mo", "g", "ms", "all", "pm", "t", "sm", "dm", "mat", "perm", "M", "tm", "module", "mt", "h", "media", "y", "f", "um", "vm", "gm", "nm", "sim", "mac", "mx"], "gb": ["vg", "sg", "bridge", "kb", "gov", "eb", "Gb", "wm", "uf", "bg", "gow", "cfg", "rb", "rg", " db", "gc", "img", "bf", "bm", "gt", "deg", "gu", "cb", "nb", "hub", "sb", "GB", "gam", "mb", "ram", "eg", "gp", "gg", "gm", "tg", " GB", "db"], "mh": ["permkh", "mpl", "imv", "tmhas", "adeh", "imh", "amoh", "mhr", "hmhash", "mrh", "cmhr", " msh", "cmho", "mtrh", "mhash", " mv", "manho", "permh", "kmv", "esmhash", "tmrh", "mthi", "imhr", "dmth", "imhi", "dmh", "vmhz", "bmrh", "tmoh", "amht", "nmh", "remhash", "mths", "hmv", "tmh", "vmh", " mhr", "remho", "vmhash", "remoh", "kmhr", "dmv", "mwh", "muthash", "dmhash", "dmhz", "manhash", "mhi", "moh", "imhz", "imoh", "mtoh", "imht", "permoh", "mv", "math", "adehas", "mkh", "manwh", "rmh", "hmkh", "matho", "hmoh", "munrh", "hmsh", "bmv", "manoh", "mehash", "munoh", " mwh", " mesh", " mih", " mht", " mhas", "mtesh", "vmhs", "meoh", "dmsh", "bmhas", " mhash", "mutoh", "mht", "amh", "fmzh", "Mh", "smesh", "msh", "meh", "mathash", "rmhash", "amho", "esmh", "manesh", " mkh", "mesh", " mth", "nmoh", "vmhi", "mth", "matv", "rmwh", "mhas", "muth", "imhs", "manh", " mhs", "mekh", "Mpl", "esmth", "nmhash", "adeho", "remh", "mathz", "smih", "remzh", "amhr", "esmv", "matesh", "mthz", "mhz", "permho", "Mhash", "mthas", "fmoh", "vmv", "hmhz", "smoh", " moh", "amrh", "remkh", "kmhs", "cmrh", "hmh", "kmh", "bmho", "munh", "fmhash", "adev", " mho", " mzh", "bmh", "mhs", "cmh", "rmoh", "Moh", "mzh", "bmhr", "mutpl", " mhz", "mtih", "smh", "fmh", "munhas", "nmpl", "mih", "mho"], "substr": ["sublen", " subchar", "Subchar", " sublen", "subj", "ublen", "Sublen", "ubchar", "ubstr", "Substr", "ubj", "Subj", " subj", "subchar"], "ret": ["failed", "rets", "det", "nt", "re", "tr", "not", "ber", "status", "gc", "alt", "ll", " Ret", "mem", "out", "rev", "gt", "ter", "rt", "len", "reset", "mel", "value", "resp", "Ret", "RET", "res", "t", "val", "print", "rel", "cont", "ref", "txt", "mt", " RET", "f", "err", "result", "back", "rem"]}}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767, "substitutes": {"s": ["n", "spec", "bs", "qs", "ses", "es", "b", "c", "ls", "sn", "w", "p", "ts", "ps", "i", "gs", "v", "is", "sys", "less", "parts", "ss", "sc", "sv", "os", "fs", "ds", "set", "sts", "ats", "rs", "ns", "t", "as", "ins", "S", "sl", "f", "cs", "hs", "js", "aws", "sac"], "bin": ["sam", "inner", "n", "bi", "lib", "bl", "spin", "binary", "str", "vin", "comb", "b", "mon", "src", "by", "cache", "anc", "png", "bn", "sum", " Bin", "von", "mem", "img", "buff", "ang", "stat", "bc", "disc", "bm", "in", "sten", "conf", "reg", "stan", "ann", "ebin", "num", "conv", "bis", "win", "rin", " ans", "dat", "inn", "nb", "bank", "ins", "abin", "size", "enc", "txt", "soc", "obin", "pac", "ram", " bins", "lang", "net", "tin", "gin", "butt", "scan", "con", "data", "box"], "st": ["ist", "inst", "utt", "bl", "str", "ust", "fr", "nt", " est", "tt", "et", "put", "art", "step", "ct", "td", "src", "nd", "start", "d", "th", "sn", "ot", "ast", "rest", "ut", "ts", "stone", "est", "stream", "stable", "std", "sh", "stat", "stage", "stri", "St", "ft", "rt", "stan", "se", "sc", "ste", "ctx", "ost", "sv", "sta", "dt", "set", "stop", "sts", "so", "t", "usr", "sty", "obj", "mt", "irst", "sw", "cl", "sl", "tmp", "ST", "sp", "net", "add"]}}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n", "idx": 781, "substitutes": {"bs": ["BS", "bp", "bi", "iss", "bl", "bas", "lbs", "bing", "ses", "bytes", "b", "bps", "abilities", "blog", "pb", "ls", "boxes", "bles", "bh", "ts", "its", "bn", "fps", "ps", "aus", "uts", "gs", "bc", "bm", "bf", "cks", "ss", "obs", "lines", "bos", "aos", "outs", "ms", "bec", "os", "bis", "fs", "ds", "vs", "sts", "rs", "ns", "bits", "irms", "sb", "bb", "hz", "cs", "js", "ubs", "ubis", "bes"], "sector_num": [" sector_snap", "sector2number", "sector2num", "tar_num", "sector_hom", " sector_number", "tar_Num", "riverityNum", "sector2Num", "sector_nom", "sector_mun", "ector_Num", " sector_Num", "sector_number", "riveritynum", "sector_nb", "sectoritymun", "sector2nb", " sector_prim", "river_Num", "ector_un", "sector_sym", "sector_Num", "riverityhom", "tar_nom", "sector_prim", "sector_un", "riveritymun", "ector_num", "sector_nam", "sectoritynum", "ector_nam", " sector_nb", "sector_snap", "sectorityhom", "tar_sym", "river_mun", "river_num", "river_hom", "sectorityNum"], "nb_sectors": ["nb_negments", "nb_electors", "nb_elears", "nb2segments", "nb\u05bcperseurers", "nb_specs", "nb2vectors", "nb_esctors", "nb_veces", "nb_spears", "nb_persectors", "nb_veors", "nb\u05bcseurers", "nb_specctors", "nb_esces", "nb\u05bcseces", "nb_selements", "nb\u05bcperseces", "nb_persecs", "nb_seurers", "nb\u05bcsectors", "nb_elecs", "nb2vegments", "nb_pselements", "nb_speors", "nb_vectors", "nb\u05bcpersectors", "nb2veors", "nb_specitors", "nb_perseces", "nb_esurers", "nb_secs", "nb_escs", "nb_sears", "nb_bectors", "nb_seors", "nb2vecs", "nb_spegments", "nb_beors", "nb_becs", "nb_segments", "nb_begments", "nb\u05bcsecs", "nb\u05bcpersecs", "nb_vecs", "nb2sectors", "nb_speccs", "nb_seitors", "nb_psegments", "nb_veurers", "nb_spectors", "nb_specors", "nb_perseurers", "nb_nectors", "nb_pseors", "nb_vears", "nb2seors", "nb_velements", "nb2secs", "nb_veitors", "nb_neors", "nb_seces", "nb_speitors", "nb_psectors", "nb_vegments", "nb_nelements", "nb_eleors"], "qiov": ["Qiev", "Qiv", "fiev", "quiop", "qiev", " qovi", "qiop", "quiev", "fiov", " qiev", "quiv", "fiour", "quiov", "Qiov", "qiour", "qiv", "qovi", "kovi", "kiev", "kiov", "Qiop", " qiop", "kiour", " qiour", " qiv", "fovi"], "acb": ["acbb", "icbb", "ocbb", "astB", "accB", "racbb", "accnb", " caca", "acp", "ocb", "astb", " acB", " acfb", " cacv", "astp", "ocnb", "ainbb", "aca", "astbt", "accwb", "accfb", "ocwb", " acnb", "accob", "racrb", "accbb", "ainb", "acsb", "AcB", "accsb", "icbc", "aicba", "aica", " acbb", "ACb", " acp", "racfb", "acba", "acB", " acsb", "accbt", "icba", " acob", "ainba", "Acb", "accrb", "acv", "acfb", "ocbc", " cacba", "Acsb", "acrb", "acbc", "acob", " acv", "acwb", "acbt", "accb", "ACwb", "aicv", "ACB", "acnb", " aca", "ainob", " cacb", "ocba", " acba", "ainsb", "aicb", "Acnb", "icb", " acbt", "ACnb", "ACsb", "ainbc", "ocsb", " acrb", "racb", "accp"], "ret": ["rets", "iter", "nt", "re", "tr", "ber", "lit", "r", "rest", "rm", "deg", "success", "dt", "value", "ry", "resp", "Ret", "val", "txt", "net", "cmd", "prop", "att", "status", " fut", "alt", "max", "after", "pret", "def", "rev", "gt", "ft", "ter", "len", "rel", "cont", "tf", "mt", "desc", "dim", "virt", "tag", "ext", "nz", "try", "arg", " Ret", "out", "rt", "elt", "reg", "RET", "report", "usr", "ctr", "result", "reply", "rem", "flag", "det", "oret", "ort", "fun", "arr", "fin", "reset", "res", "cert", "ref", "red", "print"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "substitutes": {"dx": ["tex", "dq", "wx", "xs", "eddy", "dh", "DX", "dist", "start", "d", "dl", "nox", "w", "lat", "dj", "pad", "xy", "delay", "fx", "XX", "rx", "ax", "xd", "dd", "xc", "mx", "xi", "dial", "ix", "px", "wd", "xx", "ux", "lex", "dr", "yx", "ox", "dim", "tx", "xe", "ty", "xp", "ex"], "dy": ["iy", "dq", "lon", "eddy", "wy", "dh", "idy", "ly", "addy", "d", "isy", "dl", "ady", "ey", "py", "dj", "xy", "hy", "cy", "fy", "iny", "dis", "dd", "my", "ay", "bis", "ds", "ry", "dt", "yy", "ny", "Y", "uy", "axy", "zy", "phy", "ury", "ty", "gy", "dim", "lly", "sy"], "x": ["wx", "xs", "xml", "ct", "c", "path", "d", "X", "w", "p", "lat", "rx", "xy", "fx", "i", "l", "v", "ax", "xd", "xf", "xc", "mx", "xi", "xa", "ry", "ix", "px", "ed", "h", "xx", "lex", "z", "yx", "ox", "tx", "xt", "xe", "xp", "ex"], "y": ["iy", "n", "wy", "ya", "ly", "b", "by", "m", "ot", "yt", "yan", "ey", "py", "p", "ye", "xy", "i", "hy", "v", "yd", "fy", "iny", "sky", "icy", "sys", "my", "col", "ay", "ery", "ies", "ry", "yy", "ny", "er", "ym", "Y", "yl", "top", "oy", "h", "uy", "aily", "axy", "ty", "ch", "gy", "vy", "o", "cy", "sy"], "state": ["test", "spec", "count", "length", "unit", "style", "b", "new", "error", "future", "status", "states", "start", "d", "w", "active", "p", "local", "update", "type", "out", "STATE", "valid", "stat", "next", "in", "info", "power", "g", "current", "name", "port", "zone", "fire", "scope", "key", "data", "value", "set", "success", "State", "code", "to", "t", "val", "ate", "powered", "lock", "size", "resource", "color", "h", "stroke", "component", "policy", "ty", "ch", "id", "none", "close", "m", "result"], "bmap": ["bbcap", "wmap", "bbset", "wMAP", " bcap", " bset", " bMap", "bset", "bMAP", "rbmap", "rbcap", "lbMAP", "bcap", "lbMap", " bMAP", "bMap", "lbmap", "wMap", "rbset", "bbmap"], "prev_state": [" prev_status", "prev_info", "final_action", "final___info", "viousJsequence", "prev_out", "final_status", "prev_State", "final___action", "prev___action", "prevJsequence", "prev_action", "final___state", "viousJout", "final_state", " prev_State", "vious_state", "prev___info", "prevJstate", "prev_status", "final___status", "prev___job", "vious_sequence", "prev_job", "final_info", "prevJstatus", "prev_sequence", "viousJstatus", "prev___status", " prev_job", "prevJout", "prev___state", "vious_status", "viousJstate", "vious_out"]}}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n", "idx": 797, "substitutes": {"obj": ["inst", "attr", "bs", "nt", "org", "any", "att", "src", "ot", "bh", "oc", "xy", "oid", "onet", "ob", "obo", "obs", "elt", "ctx", "os", "o", "go", "object", "vo", "cont", "txt", "ref", "act", "bj", "hw", "tmp", "Obj", "json", "od", "js", "id", "typ", "bo", "j", "ev", "ex"], "dev": ["de", "db", "cho", "pro", "init", "var", "dem", "rem", "nt", "normal", "build", "tr", "nv", "devices", "d", "th", "w", "prof", "fo", "van", "av", "buf", "pad", "stable", "ve", "mem", "off", "out", "v", "pub", "gr", "def", "die", "ow", "cam", "conn", "serial", "all", "gu", "go", "develop", "ov", "loc", "adv", "res", "Dev", "tech", "serv", "device", "ver", "oy", "enc", "wd", "sw", "cast", "hw", "pack", "des", "cmd", "priv", "od", "DEV", "scan", "env", "boot", "ev"], "prop": ["plot", "bug", "ph", "proc", "pro", "attr", "property", "po", "supp", "spec", "rep", "cfg", "com", "pb", "lit", "pt", "per", "comp", "pr", "opt", "prof", "p", "mp", "bo", "ps", "cp", "buf", "feat", "decl", "def", "xp", "jp", "conf", "term", "par", "pp", "col", "ctx", "coord", "br", "key", "pred", "ko", "coll", "loc", "op", "acc", "rop", "pl", "val", "rel", "ptr", "pkg", " props", "sp", "pri", "Prop", "cmd", "priv", "con", "pos", "ev"]}}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837, "substitutes": {"req": ["dq", "dep", "org", "dist", "cur", " requ", "pr", "ind", "egg", "qq", "crit", "deg", "conn", "grab", "alg", "resp", "quest", "txt", "ptr", "pkg", "sq", "request", "cmd", "test", "str", "init", "rep", "q", "md", "gz", "worker", "comp", "rec", "sel", "buf", "decl", "pub", "gr", "sol", "jp", "expr", "wcs", "qt", "perm", "requ", "desc", "config", "term", "j", "urg", "wx", "pro", "attr", "ext", "seq", "fr", "sem", "esp", "p", "Requ", "tek", "out", "aux", "good", "reg", "exc", "ctx", "rr", "task", "exe", "Q", "msg", "usr", "pri", "tx", "ctr", "proc", "eq", "query", " resp", "exec", "comm", "cfg", "cond", "rx", "mem", "res", "ref", "dev", "progress", "err", "job"], "r": ["re", "tr", "rd", "kr", "rg", "rh", "pr", "ru", "i", "v", "hr", "rm", "br", "or", "ry", "sr", "resp", "er", "h", "y", "request", "range", "nr", "cr", "var", "q", "vr", "c", "rec", "rw", "x", "gr", "rel", "requ", "j", "ro", "mr", "attr", "rc", "fr", "rb", "response", "p", "reader", "ret", "l", "out", "rate", "rt", "reg", "rn", "ar", "rr", "all", "usr", "dr", "m", "result", "rem", "lr", "rar", "ren", "item", "b", "d", "w", "rer", "rx", "rf", "e", "g", "adr", "res", "rs", "t", "ref", "obj", "f", "R", "err", "red", "o"], "s": ["sam", "service", "stats", "bs", "qs", "app", "q", "ses", "self", "comm", "es", "b", "c", "ls", "p", "ts", "its", "ps", "i", "south", "gs", "v", "is", "sys", "socket", "ops", "less", "ss", "conf", "g", "ims", "sc", "ms", "sv", "os", "ies", "fs", "ds", "settings", "vs", "sts", "params", "t", "rs", "ns", "http", "serv", "sb", "S", "https", "y", "h", "sw", "sl", "sq", "cs", "sp", "hs", "js", "client"], "n": ["nw", " N", " na", "gn", "nt", "an", "np", "na", "b", "c", "nu", "d", "sn", "w", "ni", "p", "i", "yn", "l", "v", "u", "nan", "cn", "g", "len", "norm", "nc", " len", "num", "ne", "o", "non", "un", "a", "nb", "t", "ns", "fn", "N", "size", "h", "z", "f", "nn", "nm", "m", "j"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848, "substitutes": {"plow": ["puigh", "plew", " pligh", "palew", "plOW", "prov", "penog", "pligh", "explowe", " plowe", "palown", "phow", "palowed", "phowed", "pigh", " ploor", "plov", "prow", "puow", "peligh", "pelow", "phog", "penov", "phew", "palov", "puown", "ploor", "pelowed", "pelew", "power", "palow", "penow", "expligh", "plown", "prowed", "puowed", "penowed", "prog", "powe", " plower", "pelog", "plowed", " plOW", "phOW", "phov", "phoor", "plog", "explower", "palog", "plowe", "palOW", " plov", "explow", "pelown", "paloor", "paligh", "plower"], "phigh": ["shIGH", " phiz", " phIGH", "mphiz", "plushi", "khord", "phiresh", "pligh", "mphith", "phow", "procigh", "phith", " phight", "thig", "phiigh", "chigh", " phow", "procong", "shith", "chig", " phong", "shigh", "thow", "thiz", "pliz", "shig", "khig", "phIGH", " phig", "phiIGH", "procight", "mphIGH", "phight", "plong", "mphresh", "thigh", "phiz", " phushi", "mphigh", "chow", "phiow", "phig", "mphig", "phong", "mphord", "procushi", " phresh", "chiz", "phresh", "phushi", "shiz", "plight", "khresh", "khigh", "phord", " phord", "plig", "show", "mphow", " phith"], "b": ["s", "db", "bt", "ib", "n", "fb", "ba", "bi", "bp", " that", "j", "bs", " y", "eb", " f", " base", " m", " body", " i", "rb", "pb", "be", "bg", "d", " p", "r", "bh", " h", " db", "p", "i", "l", "v", "bc", "u", "e", "ob", " bound", "bf", " ab", "g", " storage", "br", "a", "cb", " binary", "gb", " d", "nb", " buffer", " null", "t", "beta", "bb", "h", "y", " bab", " a", "z", "f", " msg", " t", "m", " to", "base", "B"], "sa": ["sam", "wa", "au", "s", " sd", "sie", "SI", "ama", "na", "asi", "ca", "ssl", "ia", "sama", "mi", "ha", "SA", " si", "sd", "la", "mas", "ja", "Sa", "sea", "ga", "ai", "lab", "pi", "se", "sc", "sta", "ma", "a", "si", "gu", "ae", "sr", "go", "so", " Sa", "sy", "as", "da", "sl", "sha", "su", "sp", "pse", "asa", "aa", "eas", "za", "pa"], "sb": ["sam", "s", "bt", "ib", "sth", "bp", "sg", "bi", "fb", "lr", "kb", "bs", "sbm", "eb", "bg", "rb", "pb", "sk", "ssl", "sn", "bh", "gc", "sd", "sh", "bc", "bf", "se", "sc", "rob", "sv", "bis", "si", "cb", "sr", "osp", "gb", "nb", "lb", "sm", "sf", "bb", "zb", "bj", "mb", "sl", "tmp", "sp", "SB", "pa"]}}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855, "substitutes": {"linker": ["linkers", "drawler", "lockier", " linkier", "inker", "inkier", "loadner", "linkger", "lockers", "drawer", " linkger", "inkner", "lockger", "drawner", "inkers", "inkler", "loadger", "linkner", "loadler", "linkler", "drawger", "locker", "linkier", "loader", "inkger", " linkers"], "file": ["db", " File", "ile", "read", "page", "angle", "byte", "path", "block", "channel", "family", "local", "type", "fp", "offset", "out", "field", "fi", "message", "format", "image", "queue", "port", "name", "source", "handle", "link", "key", "iles", "full", "le", "dir", "user", "table", "ref", "resource", "disk", "filename", "module", "files", "File", "f", "range", "id", "action", "buffer", "domain", "chain", "data", "line", "io"], "alloc_align": ["alloctalign", "auto67angle", "cmp_aligned", "alloc67coord", "alloc_num", "auto_coord", "alloc67aligned", "alloc_aligned", "oc_num", "auto67coord", "auto_angle", "alloc8ign", "alloctadjust", "auto67align", "auto_aligned", "alloc_adjust", "alloc67align", "alloc8aff", "auto_align", " alloc_aff", "oc_align", "alloc2aligned", "alloc_coord", "alloc_ign", " alloc_angle", "alloctaligned", " alloc_ign", "alloc_aff", "alloc8angle", "oc_angle", "alloc_angle", "alloc2coord", "alloc2angle", "cmp_adjust", "cmp_num", "oc_range", "alloctnum", "alloc2align", "auto67aligned", "alloc8align", "alloc_range", "alloc67angle", "cmp_align"], "alloc_fseg": ["alloc_tseyg", "alloc_fsei", "alloc_fsegs", "alloc_tbei", "alloc_fpseg", "alloc_fpeg", "alloc_fSEi", "alloc_tseg", "alloc_fpseyg", "alloc_tsep", "alloc_fbep", "alloc_fasei", "alloc_fasebg", "alloc_fbei", "alloc_fpeyg", "alloc_fbeg", "alloc_fbeeg", "alloc_fpegs", "alloc_fSEp", "alloc_fseeg", "alloc_fsep", "alloc_tsebg", "alloc_tpseg", "alloc_faseg", "alloc_fpseeg", "alloc_tsegs", "alloc_tpsegs", "alloc_tsei", "alloc_fbegs", "alloc_fseyg", "alloc_tbep", "alloc_fpsegs", "alloc_fSEg", "alloc_fbebg", "alloc_fbeyg", "alloc_tbeg", "alloc_fSEbg", "alloc_tpseeg", "alloc_fasep", "alloc_fpeeg", "alloc_tseeg", "alloc_tpseyg", "alloc_tbebg", "alloc_fsebg"], "entry": ["nt", "record", "xml", "error", "r", "our", "rance", "attribute", "deep", "__", "member", "or", "ry", "value", "delete", "component", "Entry", "ent", "ptr", "import", "inner", "escape", "q", "RY", "ient", "pair", "req", "row", "command", "def", "card", "existent", "index", "add", "desc", "data", "line", "ment", "ries", "needed", "rent", "see", "section", "cell", "response", "try", "inter", "match", "aux", "out", "field", "ary", "info", "search", "key", "set", "office", "result", "base", "instance", "form", "query", "self", "item", "comment", "insert", "enter", "check", " Entry", "connection", "e", "parse", "way", "image", "se", "server", "cue", "element", "obj", "event", "print", "client"]}}
{"project": "qemu", "commit_id": "95eaa78537c734fa3cb3373d47ba8c0099a36ff0", "target": 1, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 860, "substitutes": {"bs": ["bt", "BS", "bp", "stats", "bi", "bl", "lbs", "qs", "eb", "bg", "b", "bps", "blog", "pb", "ls", "boxes", "bles", "bh", "ts", "its", "ps", "bn", "aus", "gs", "bc", "bm", "ss", "cks", "obs", "bos", "aos", "ims", "bec", "bis", "fs", "ds", "bsp", "vs", "sts", "ats", "ns", "bits", "irms", "sb", "bb", "ins", "hz", "bd", "vals", "cs", "js", "ubs", "ubis", "banks", "bes"], "errp": ["errP", "Erp", "erP", " errps", "Erps", "errps", "erp", "ErP", " errP", "erps"], "iscsilun": ["iscvaleoun", "iscsentut", "iscvaleund", "isclitun", "iamseveremun", "uscvaleunt", "iscmilut", "iscsiduna", "uscinelgun", "iscsslund", "ischidentund", "iscgilune", "iscesiun", "iscinelune", "iamsevereund", "ricsilun", "isecsiung", "iscmilunk", "illacsilut", "ionicsilun", "iscsinunk", "iscsilut", "iscryptun", "nicvaleut", "iscsentuna", "iscvaleunc", "ischematicunt", "ionicsilmun", "isecvaleunc", "uscsinune", "issmilune", "riconsequune", "ischsilunk", "iscsolgun", "uscvalefun", "iscsuccessfulun", "iscidentunk", "iscidentung", "isssilgun", "isecsilunt", "iscidentmun", "issgilgun", "designsilmun", "micsidu", "iscsidu", "uscvaleund", "iscesiunt", "nicsilmun", "isssiduna", "isecsiun", "iscmilunt", "isecsentuna", "uscvaleuna", "iscsingun", "iscsiloun", "ischematicmun", "iscvaleu", "issgilune", "iscsevereune", "isctilun", "designmilund", "iscsentgun", "iscidentun", "iscmilun", "iscseveregun", "micsiduna", "iscsilune", "ionicticuna", "ischematicune", "iscsilfun", "isecsilund", "issmilund", "iscidentund", "ionicsiluna", "iamsilun", "nicsilgun", "micsilun", "iscsiden", "iscstatgun", "iscticung", "iamsilgun", "iscrippund", "ionicticun", "iscsiuna", "isanchlorun", "iscidentuna", "iscsslun", "isctilmun", "iscvaleunn", "iscvalegun", "uscsilun", "iscvaleunk", "inctilgun", "iscticuna", "iscspellunc", "iscrypten", "illacsuccessfulun", "iscsidgun", "iscwashmun", "iscesiuna", "iscstatuna", "iscsuune", "iscsevereund", "nicsiluna", "isssilunk", "iscspellfun", "iscsslune", "iscspellund", "designsilun", "iscsuccessfulune", "illacsuccessfulune", "issmilunk", "iscsilgun", "isecsiunt", "iscchloren", "iscinelban", "illacsilun", "inctilun", "iscvaleunt", "iscchlorund", "nicsinuna", "iscsilen", "uscsiluna", "iscsilcon", "uscvaleune", "illacsilune", "iscineluna", "iscsimgun", "inctilunn", "iscvaleun", "uscinelun", "isssiluna", "uscsinoun", "iscinelgun", "uscinelune", "uscinelban", "iscsuunk", "ischidentuna", "issineluna", "iscchlorune", "iscvaleune", "iscgilunc", "riconsequun", "isansilung", "iscryptuna", "isfsoluna", "isctiluna", "nicsinune", "uscsinun", "iscmilmun", "iscidentunt", "iscsidung", "iscslunt", "iscurityund", "iscsimun", "iscvalemun", "iscsentun", "iscticunn", "designsilund", "ionicticgun", "iscsinmun", "iscvaleut", "iscvalefun", "iscpalund", "uscvaleun", "iscstatun", "isssilunc", "isfsilun", "isciphanyuna", "uscsingun", "issgilunc", "iscsuund", "designsilcon", "isecsilune", "iscsqlund", "uscsilban", "iscpalunk", "issmilun", "iscsimmun", "iscryptung", "iscgilund", "nicvaleuna", "isciphanyun", "isecvaleunt", "micsidune", "iscsluna", "designmilun", "iamseveregun", "isecsentund", "nicvaleun", "isconsequmun", "iscchlorun", "iscslgun", "iscticmun", "iscidentu", "iscsqluna", "isssilund", "iscsilunc", "iscsentund", "iscspellun", "iscesigun", "iscinelmun", "iscsinun", "isanchloren", "nicsilut", "iscsinban", "micsilu", "iscsidunt", "iscidentgun", "ischsilun", "micsilune", "ricsilune", "nicsinmun", "nicsilune", "isfsolunt", "iscgiluna", "isctilune", "isfsolun", "iscstatut", "isclitmun", "iscurityun", "iscryptune", "isecsilung", "iscsisunk", "iscchlormun", "uscsilune", "iscgilgun", "isctilgun", "iscsslgun", "iscsisund", "iscinelun", "isctilunt", "iamsilund", "iscsinut", "illacsuccessfulut", "iscrippuna", "iscryptund", "iscticgun", "iscpalune", "ionicticmun", "iscsentunk", "isecsentun", "iscsqlunk", "isanchloruna", "iscvaleuna", "iscsolunt", "nicsilun", "isfsilgun", "iscsidune", "designmilmun", "uscsiloun", "iscpalun", "iscwashune", "uscsilgun", "iscsilmun", "iscgilunk", "iscmilund", "isctilunc", "iscsiun", "iscspellune", "iscuritymun", "iscinelund", "ischidentunk", "iscsilunk", "incsiluna", "ischematicun", "isclituna", "riconsequmun", "incsilunn", "iscsiluna", "iscsimuna", "nicsinun", "isansiluna", "iscsinuna", "iscgilun", "iscticunt", "isecsiuna", "uscsinunk", "iscsuccessfulut", "illacsilunt", "uscinelund", "isfsiluna", "isciphanyune", "isansilen", "iscwashuna", "iscsiung", "isclitund", "iscsinoun", "isconsequunt", "illacsuccessfulunt", "isciphanyund", "iscsoluna", "iscsuun", "iscsinunt", "iscsisun", "isssidu", "iscsilu", "iscmilcon", "iscsinund", "nicvalegun", "iamsevereun", "iscslun", "uscsilund", "iscrippun", "ricsilmun", "isssidun", "uscineluna", "iscsevereban", "isssilmun", "iscsilund", "isssilu", "iscmilune", "isecvaleune", "incsilun", "iscsilban", "iscsuuna", "uscsilunk", "iamsilmun", "iscinelcon", "iscsinune", "iscchloroun", "issinelmun", "iscchlorung", "isecsentunk", "ricsilunt", "iscchloruna", "iscsilunt", "iscsuccessfulunt", "iscsilung", "uscsilunt", "isconsequune", "issinelun", "ischidentun", "ischsilund", "iscseverefun", "isctilunn", "iscchlorcon", "issgilun", "inctiluna", "isansilun", "uscsinuna", "iscinelu", "isecsilun", "isfsolgun", "isfsilunt", "iscsevereun", "isecvaleun", "isecsiluna", "iscsidun", "iscsilunn", "iscticun", "designmilcon", "iscseveremun", "iscsevereuna", "iscuritygun", "uscsilfun", "iscsiunt", "iscwashun", "iscspellgun", "iscspellunt", "iscsugun", "micsiluna", "uscsinund", "iscsisuna", "micsidun", "issinelund", "isssilune", "isconsequun", "incsilgun", "iscrippunk", "ionicsilgun", "iscsolun", "isssilun", "ischsiluna", "iscryptgun", "isanchlorung", "iscsidund", "riconsequunt", "isecsilunc", "isssidgun", "isecsilunk", "iscsqlun"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 883, "substitutes": {"opaque": ["oposit", "iopaques", "Opacity", "iopacity", "Opaques", "opface", "operface", "opacity", "oposter", " opface", "iopca", " oposter", " Opaques", " oposit", "Oposter", " Opacity", "Opaque", " Opca", "operoster", "Oposit", "operosit", "Opface", "operaque", "opaques", "opca", "Opca", "iopaque", " Opaque"], "buf": ["fb", "cat", "cap", "aka", "q", "batch", "uf", "b", "rb", "pb", "cur", "block", "Buff", " buff", "map", "p", "wb", "img", "mem", "window", "v", "accept", "bc", "queue", "br", "doc", "cb", " buffer", "bag", "ref", "bb", "text", "cv", "Buffer", "pack", "raw", "cmd", "buffer", "buff", "data", "vec"], "size": ["n", "count", "empty", "time", " resize", "length", " notice", " news", " Size", "sn", " count", "sum", "type", "mem", " error", "send", "ize", "e", " pos", "g", "len", "name", "space", " code", "news", " sizes", "code", "set", " name", "since", "fee", "now", "SIZE", "z", "shape", "buffer", " event", "Size"], "s": ["sam", "n", "spec", "stats", "ses", "b", "c", "ls", "ssl", "w", "r", "p", "ts", "ps", "i", "gs", "is", "v", "sys", "less", "ss", "se", "sv", "store", "fs", "ds", "sts", "t", "ns", "sm", "rs", "state", "sb", "S", "session", "ess", "sq", "hs", "sp", "js", "sa", "j"], "ret": ["flag", "ext", "str", "cat", "nz", "nt", "Return", "re", "tr", "att", "try", "r", "alt", "inter", "pret", "arg", "out", "v", "x", "rm", "def", "gt", "ft", "arr", "rt", "deg", "elt", "num", "reset", "ry", "resp", "Ret", "RET", "res", "t", "val", "cont", "mt", "mb", "err", "red", "cmd", "xt", "ctr", "reply", "back", "rem"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886, "substitutes": {"dev": ["de", "ad", "test", "proc", "pro", "stick", "spec", "app", "form", "dem", "det", "md", "nt", "build", "exec", "any", "att", "d", "th", "w", "block", "pt", "av", "pad", "ve", "mem", "window", "v", "sky", "def", "dd", "conf", "ow", "cam", "draw", "serial", "doc", "go", "develop", "gu", "end", "adv", "Dev", "val", "tech", "serv", "device", "ver", "wd", "disk", "debug", "patch", "cast", "hw", "des", "raw", "env", "cmd", "ch", "DEV", "scan", "priv", "boot", "ev"], "errp": [" errq", "aerpost", "errpre", "rrps", " errps", "aerps", "rrpost", "errorq", "lerpost", "rrpa", "errpa", "erps", "errorper", "errorpc", "aerpa", "errorpre", "errpc", "errorpost", "aerp", "errps", "erp", "errorps", "lerp", "erP", "lerP", "rrP", "erpre", "errpost", "rrp", " errpc", "errorp", "rrpc", "rrq", "errq", " errpre", " errper", "errP", " errpa", "errorP", "errper", "lerper", " errpost", " errP"], "dinfo": ["didINFO", "dINFO", "dstate", "DInfo", "Dinf", "fdINFO", " ddetails", "Dinfo", "dInfo", "DINFO", "didinfo", "ddetails", "dxInfo", "Dstate", "dxdev", "ddev", "Ddetails", "dinf", " dinf", " dInfo", "ordinfo", "Ddev", "orddetails", "fdInfo", "didInfo", "dxinf", "ordinf", "fdstate", "dxinfo", "didstate", "ordInfo", " ddev", "fdinfo"], "local_err": ["locallyerr", "local____err", "local____arr", "localablebar", "localableeas", "local_er", "local___eas", "locallyarr", "serial_err", "local_bar", "seriallyarr", "local___err", "thisableeas", "local_usr", "local___rr", " local_error", "seriallyconn", "serial_conn", "serial_arr", "local____conn", "local_eas", "thisablebar", "this_er", "locallyconn", "seriallyerr", "local___error", " local_eas", "local_rr", "local_arr", "local_error", "local___usr", "thisableer", " local_rr", "thisableerr", "localableerr", "this_bar", "local_conn", "this_err", "this_eas", " local_usr", "localableer"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899, "substitutes": {"bs": ["BS", "bp", "bl", "lbs", "b", "blog", "ls", "als", "bh", "ts", "its", "ps", "gs", "bc", "bm", "ss", "obs", "cks", "bos", "ms", "os", "bis", "fs", "ds", "vs", "rs", "ns", "bits", "sb", "cs", "hs", "js", "ubs", "aus"], "sn_info": ["sn_description", "tn_info", " sn_Info", "snWInfo", "sn_list", "Sn_INFO", "snWnote", "sn2info", "snmydetails", "tn_description", "snptINFO", "sn2Info", "zn___details", " sn_note", "skymydetails", "sn_Info", "Sn_inf", "sn__Info", "rn_information", "rn_info", "sn_note", "sn2note", "sn___info", " sn__note", "sn_details", "sn__inf", "pn_info", " sn__Info", "snptinfo", "Sn_recent", "pn_INFO", " sn__inf", "snWinfo", "zn_info", "sn_error", "sn__note", "sky_info", "sn___list", "sky_details", "zn___info", " sn_error", "rn_about", "sn_about", "sn_recent", " sn__info", "Sn_info", "snPinfo", " sn_INFO", "skymyInfo", "snmyINFO", "tn_inf", " sn_inf", "Sn_Info", "snpterror", "snptInfo", "snPlist", "zn___list", "sn_INFO", "pn_Info", "sn_kind", "snWinf", "sn_inf", "Sn_kind", "snmyrecent", "snmyinfo", "sn2inf", "skymyinfo", "sky_Info", "zn_list", "snPdetails", "zn_details", "pn_description", "snmyInfo", "sn_information", "sn__info", "sn___details"], "s": ["services", "sn", "south", "is", "v", "ops", "parts", "ies", "ds", "eps", "gets", "bits", "http", "sb", "y", "h", "sq", "hs", "ses", "c", " ss", "ains", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "https", "details", "sim", "has", "ports", "qs", "events", "ssl", "states", "p", "ps", "l", "sys", "less", "ss", "tests", "ms", "bis", "so", "sm", "sl", "sa", "m", "ex", "sam", "service", "spec", "stats", "xs", "comm", "results", "es", "b", "ls", "w", "als", "ysis", "ts", "its", "changes", "gs", "conf", "g", "settings", "rs", "ns", "t", "serv", "ins", "S", "sw", "cs", "js", "aws"], "ret": ["flag", "ext", "del", "rets", "det", "nz", "nt", "tt", "Return", "re", "gz", "tr", "ert", "prot", "att", "status", "at", "try", "gc", "alt", "after", "ll", " Ret", "out", "x", "fi", "def", "rm", "ft", "gt", "ter", "rt", "lt", "len", "deg", "fin", "elt", "reset", "arr", "fl", "cb", "resp", "Ret", "RET", "res", "t", "val", "print", "cont", "cert", "usr", "txt", "il", "mt", " RET", "ptr", "net", "cmd", "err", "j", "result", "back", "rem"], "fd": ["lf", "fm", "fb", "ff", "deb", "gz", "gd", "fr", "uf", "rd", "ud", "func", "td", "nd", "d", "dl", "tty", "fa", "hd", "buf", "fe", "fp", "cf", "fun", "dc", "fi", "dd", "bf", "ft", "fc", "FD", "file", "elt", "fin", "raf", "ctx", "df", "handle", "fs", "ds", "dt", "fl", "cb", "ld", "resp", "dir", "fn", "bd", "obj", "ptr", "du", "fed", "ln", "f", "err", "cd", "pid", "db", "io"], "new_vid": ["new_uid", "newtvid", "pb_vi", "new___uid", "pb_pid", "New_vid", "new___vi", "pb___uid", "new_vi", "pb_uid", "newtvi", "New_pid", "pb___vi", "new_pid", "newtpid", "new___vid", "New_vision", "new___pid", "New_vi", "new___vision", "pb___pid", "new_vision", "newtuid", "pb___vid", "pb_vid"], "inode": ["enow", "intoder", " inoe", "rinode", "innole", "intote", "ninode", "rinoder", "inoder", "rinade", "insodo", "innerode", "innodo", "inneroe", "inote", " inonymous", " inom", " inola", "iname", "loginoe", "ninnode", "inodo", "insode", "sinod", "loginola", "binom", " inole", "binode", "INnode", "binod", "nod", "enod", "anote", "cinox", "inname", "INode", "inom", "innonymous", "innoder", "insod", " inoration", "innote", "ginode", "innow", "kinole", "inneronse", "innoration", "ninod", "insox", " inade", "loginode", "ninox", "iade", "kinoration", "innox", "ininode", "inoe", "ino", "intow", " inoice", " inoder", "ninoder", " iname", "annode", "iniod", "INod", "anox", "inonymous", " ino", " inonse", "nino", "sinode", "cinod", "cinoder", "iniame", "iode", "ginox", "inow", "ioder", "ninodo", "anod", "inod", "sinox", "into", "iniodo", "inoice", "inole", "bino", "ninom", "innerola", "node", "intod", "innnode", "kinod", "ano", "inoration", "inonse", "INoder", "inade", "enode", "anode", "inola", "inionymous", "kinode", "inioice", "enoder", "sinoder", "iniode", "noder", "nox", "inock", "innod", "ginod", "inox", "loginonse", " inod", "ginnode", " inock", "rinock", "intode", "inno", "innode", "INox", "iock", "cinode", "innoice"], "datalen": [" dalength", "damelize", "datalig", " dalize", "dblob", "diallen", "datsEN", "daiallen", "datalim", "dalerener", "damelength", "datalener", "dalength", "dallEN", "dalerlen", "Dalob", "datalens", "daatallen", "dulens", "datsen", " datalEN", "daatalen", "datsig", "daatalig", " dallength", "dialen", " dalens", "damelens", "datalob", "dulen", "Datalim", "dalob", "dalerig", "daialig", "dblength", "dotalEN", "daialener", "datalength", "datsength", "Dalength", "dblim", "damelen", "dalens", "dblen", " datalength", "dotalener", "dotallen", "dallength", "dulength", "dalim", "dulize", " dallig", "dotalen", "dreatim", "dreatength", " dallEN", "dallig", "dotalig", "Dalim", "Dalen", "dreaten", "Datalength", " dalen", " datalig", " datalens", "datalize", "datalEN", "dalen", "datallen", "dialener", " dallen", "dalize", "daatalener", "dotalength", "dallen", "dialig", "daleren", " datalize", "dreatob", "daialen", "Datalen", "Datalob"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 906, "substitutes": {"vd": ["dq", " od", " sd", "pd", "dll", "md", "gd", "erd", "vid", "dh", "rid", "vi", "vr", "rd", "ud", "dds", "him", "td", "nv", "idd", "d", "dl", "hd", "managed", "sd", "vt", "ve", "oud", "dk", "vol", "ced", "v", "vv", "xd", "dd", "pty", "df", "ord", "VD", "dt", "ond", "vs", "ld", " cd", "gb", "lv", "cod", "qt", "fd", "dm", "wd", "vp", "disk", "bd", "ard", "dr", "du", "vision", "pdf", "dri", "vm", "vc", "od", "cd", "rod", "db"], "saddr": ["sadr", "saddress", "gsaddress", " sarr", "lsarr", "nsadd", "gsaddr", "gsadr", "lsaddress", "lsadd", "nsarr", " sadd", "nsadr", "sadd", "gsadd", "lsadr", " saddress", "sarr", "nsaddress", "lsaddr"], "nsaddr": ["sadr", "saddress", "msaddress", "nscoord", "xscoord", "msaddr", "xsaddr", "msadr", "sptr", "msptr", "wscoord", "xsaddress", "wsptr", "nsarr", "bsaddr", "nsadr", "wsaddress", "wsadr", "nsptr", "bscoord", "xsarr", "bsarr", "nsaddress", "wsarr", "bsaddress"], "wsaddr": ["atsadd", "atsaddr", "WSptr", "lsptr", "nsadd", "gsaddr", "gsadr", "WSadr", "wsadd", "lsadd", "gsha", "wsptr", "nsadr", "nsptr", "wsadr", "gsadd", "lsadr", "atsha", "WSaddr", "atsadr", "nsha", "wsha", "lsaddr", "WSadd"], "nwsaddr": ["nhsaddress", " nmshop", "nnsaddr", "nhshop", "nmscap", "nWsaddr", " nWsadr", " nWsaddress", "nnscoord", "nmsaddr", "nnshop", " nmsaddress", "nWscoord", " nwscap", "nhsaddr", " nwshop", "nawsadr", "nnscap", "nnsadr", " nmscap", "nnsaddress", " nwsaddress", " nmsaddr", "nawsaddr", " nWscoord", "nwscap", "nwsaddress", "nmshop", "nwscoord", " nWsaddr", "nwsadr", " nwsadr", "nawsaddress", "nwshop", "nWsadr", "nhscap", "nmsaddress", "nWsaddress", " nwscoord", "nawscoord"], "errp": ["errpp", "eorpid", "erd", "errpa", "lrp", "rrproc", " errr", "ererp", "rrpid", " errd", "rrr", "cerpp", "erp", "errop", "errproc", "errr", "eorp", "rrp", "erop", "eorproc", "cerp", "errcp", "erercp", "rrop", "ererproc", "eorcp", "cerpa", "lrpp", " errpp", " errpa", "rrcp", "errd", "err", "lrpa", "ererpid", "rrd", "errpid", " errop"], "i": ["oi", "cli", "slice", "record", " err", "eu", "uri", "mi", "ind", " I", "ai", "v", "ei", "is", "ic", "it", "go", "si", "ie", "y", "ti", "io", "phi", "iu", "bi", "hi", "init", "ui", "c", "di", "series", "fi", "ini", "zi", "xi", "ami", "index", "multi", "chain", "sim", "I", "ogi", "this", "asi", "uli", "im", "ki", "p", "l", "ip", "info", "key", "ix", "ci", "us", "gi", "m", "s", "li", " j", "b", "ii", "ji", "\u0438", "e", "u", "pi", "in", "g", "me", "qi", "gu", "t", "print", "client"]}}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 913, "substitutes": {"cpus": ["cpcu", "puus", "cpots", "cpuli", "puuli", "puos", "cpuses", " cpuses", "cpos", " cpuli", " cpots", " tcpus", "cmpuses", "pucs", "puuls", "cmpu", "compcu", "pus", " cpos", "pucu", "puses", "compu", "puu", " tcpuli", "cmpus", " cpuls", " cpcs", "pots", " tcpos", "cpuls", "compuses", "puuses", "pcs", "cmpcu", "puots", " tcpuls", "compus", "cpcs"], "max_cpus": ["max_ps", "max_capus", "max4processus", "max_cpos", "max_caps", "max4cpes", "max4cps", "max4cpus", "max_puses", "max_compu", "max_comppu", "max_compus", "max_ipors", "max_cppu", "max_processes", "max_ipuses", "max4processs", "max_cpuonents", "max_comps", "max4processes", "max_compors", "max_cpors", "max_cpes", "max_cpuses", "max_ipus", "max_pors", "max_pu", "max_cpuu", "max_processos", "max_cpu", "max_gponents", "max_capu", "max_ips", "max_ponents", "max_compes", "max4processos", "max_cpuus", "max_gpus", "max4cpos", "max_pus", "max_gps", "max_cappu", "max_gppu", "max_processs", "max_gpu", "max_cps", "max_cponents", "max_compos", "max_compuses", "max_processus"], "cpu": ["computer", "core", "tp", "what", "cmp", " mem", " cu", "CPU", " pc", "bench", "cache", "uu", "cp", "common", "port", "process", "component", "pkg", "processor", "boot", "pool", "worker", "cu", "prof", "util", "comp", "pc", "pai", "linux", "jp", "pixel", "runner", "num", " CU", "bean", "currently", "cum", " process", "nu", " processor", " chip", "ruby", "thread", " ip", "ip", "percent", "goal", "current", "\u00e7", " performance", "node", " proc", "pu", "phys", "us", "mx", "alloc", "instance", "proc", "coin", "oton", " core", " runtime", "ct", "CP", "remote", " cp", "gc", "check", "mem", "u", "socket", " quota", "hog", "clock", "gpu", " nic", "nic", "pid"], "s": ["sql", "n", "sg", "spec", "str", "qs", "q", "an", "b", "ls", "w", "p", "ts", "ps", "l", "south", "is", "gs", "v", "csv", "ss", "g", "se", "ms", "space", "sv", "os", "fs", "ds", "eps", "set", "sts", "ats", "rs", "ns", "t", "sb", "S", "txt", "h", "sl", "sq", "z", "sp", "js", "m", "j"]}}
{"project": "qemu", "commit_id": "8ad9fa5d8be7fd04e723020088eca664971eb363", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921, "substitutes": {"command": ["execute", "query", "target", "help", "exec", "from", "path", "start", "m", "channel", "type", "description", "condition", "program", "connection", "attribute", "template", "context", "prefix", "message", "direction", "power", "file", "menu", "name", "code", "value", "location", "Command", "text", "address", "request", "cmd", "action", "buffer", "domain", "password", "pattern", "mode", "directory", "sequence"], "bandwidth_limit": ["bandwidth_line", "bandwidth_limits", "bandwidth_block", "bandwidth_lim", "bandwidth_policy", "bandWidth_lim", "bandWidth_policy", "bandWidth_line", "bandWidth_limits", "bandWidth_limit"], "async": ["nasynchronous", "nasallel", "masync", "ASynchron", "asynchron", " asynchronous", "asyn", "assync", "asarynchron", "nasynchron", "ASYsync", "ASYynchron", "asarync", "masynchron", "masallel", " asallel", "ASyn", "masynchronous", " asynchron", "ASYync", "ASync", "asynchronous", "ASsync", "nasync", "asallel", "ASYyn", "asaryn", "asarsync"], "s": ["n", "sing", "services", "r", "rest", "is", "v", "ops", "ies", "fs", "ds", "gets", "sb", "h", "y", "locks", "sq", "hs", "actions", "sports", "bs", "ses", "c", "status", "st", "sol", "ties", "lines", "ims", "sv", "os", "vs", "sts", "ats", "as", "session", "z", "details", "ports", "qs", "utils", "states", "p", "ps", "l", "sys", "less", "ss", "tests", "ms", "set", "params", "state", "args", "sl", "sp", "sa", "m", "ex", "sam", "spec", "stats", "self", "es", "b", "ls", "d", "pers", "w", "als", "ts", "its", "changes", "gs", "sh", "stat", "e", "g", "conf", "se", "ers", "sc", "acs", "settings", "rs", "ns", "ins", "S", "cs", "storage", "js", "aws"], "f": ["lf", "fm", "alf", "fb", "form", "ff", "fr", "ef", "uf", "b", "c", "far", "d", "m", "w", "fo", "r", "p", "fa", "fe", "i", "l", "fp", "cf", "rf", "v", "fi", "bf", "xf", "ft", "fc", "g", "file", "af", "fs", "t", "fn", "fd", "sf", "tf", "fed", "z", "F", "o", "fac"]}}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924, "substitutes": {}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937, "substitutes": {"env": ["test", "proc", "cur", "dest", "Ev", "map", "buf", "ec", "te", "v", "sh", "e", "eng", "def", "kw", "conf", "ctx", "en", "scope", "conn", "end", "viron", "obj", "ptr", "err", "con", "ev"], "spapr": ["papr", " spapcr", "spiprus", "spajrus", "spaper", "spapR", " spipR", "sparpr", "papir", " spiprus", "spapsren", "spaptR", "sparprus", "spipr", "papsir", "spapsir", "sparpcr", "papsR", "spipR", "spaptir", "papsren", "spipcr", "spapsr", " spapR", "spapren", " spaprus", "sparpR", "papren", "spapir", "spapeR", "spajr", "spapeir", " spipr", " spipcr", "papsr", "spapsR", "spaprus", "spajcr", "spaptren", "spapcr", "spajR", "papR", "spaperen", "spaptr"], "opcode": ["npcode", "mopcode", "opcc", "pcodes", "oprec", "moprec", "mopcc", "pcc", "npcc", "npcodes", "nprec", "prec", "mopcodes", "pcode", "opcodes"], "args": ["stats", "xs", "bs", "limits", "qs", "app", "users", "blocks", "ags", "values", "atts", "ams", "seconds", "arms", "modules", "arg", "ts", "points", "changes", "aux", "gs", "ras", "members", "terms", "fields", "arr", "parts", "keys", "grades", "apps", "ms", "ims", "workers", "objects", "conf", "fs", "bugs", "flags", "params", "ns", "bits", "words", "related", "vals", "days", "cmd", "range", "js", "aws", "roots", "names", "Args", "actions"], "dev": ["de", "test", "proc", "app", "dep", "var", "dem", "det", "nt", "browser", "rent", "ther", "d", "w", "usb", "van", "Device", "local", "av", "ve", "mem", "v", "eng", "def", "dd", "DE", "driver", "cam", "conn", "ds", "ev", "develop", "gu", "go", "der", "er", "den", "adv", "Dev", "development", "tech", "device", "ver", "home", "debug", "obj", "ptr", "hw", "des", "priv", "cmd", "DEV", "db"], "rtce": ["tcer", "rcer", "rentce", "aptced", "ptcer", "mtcle", "ptce", "aptce", "rte", "rtte", "tce", "rtced", "mtced", "rtces", "rce", "rces", "ptte", "rentces", "rotcer", "mtces", "rtcer", "rentcle", "mtce", "rentced", "tcle", "ptcy", "rotce", "aptcer", "ptced", "rtcy", "aptcy", "rotced", "tte", "rtcle", "tced", "ptces", "rotcy", "tces"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n", "idx": 941, "substitutes": {"obj": ["ist", "inst", "attr", "impl", "nt", "org", "cmp", "vr", "att", "ot", "og", "bh", "opt", "p", "xy", "oid", "onet", "ob", "ctx", "os", "conn", "expr", "t", "object", "serv", "cont", "ref", "txt", "act", "hw", "tmp", "Obj", "cmd", "js", "typ", "o", "j", "instance", "ex"], "v": ["n", "vim", "view", "q", "vi", "vr", "vu", "b", "c", "nv", "w", "r", "p", "vt", "V", "i", "tv", "ve", "l", "g", "sv", "conv", "o", "vis", "vs", "t", "vp", "cv", "h", "uv", "f", "vm", "vc", "qv", "m", "j", "ev"], "opaque": ["appaz", "opencode", "epaz", "opz", "appz", "epaque", "appaque", "openaque", "appcode", "opcode", "openaz", "epz", "opaz", "openz", "epcode"], "name": ["n", "attr", "ame", "str", "init", "nam", "cap", " names", "na", "c", "comment", "error", "path", "ni", "type", "word", "mem", "prefix", "def", "info", "black", " Name", "key", "part", "t", "ns", "text", "Name", "NAME", "no", "cmd", "id", "nm", "names", "term", "data", "san"], "errp": ["erpa", "rrps", "usrp", "rrpa", "errpa", "errorper", "cerbp", "errps", "erp", "erbp", "errorps", " Errps", "erP", "rrp", " Errper", "errorpa", "cerp", "errorp", " Errpa", "usrP", "errP", "usrbp", "cerP", "cerpa", "rrper", "usrpa", "errper", " Errp", "errbp"], "s": ["sam", "n", "sg", "ses", "b", "c", "ls", "ssl", "sn", "p", "ts", "sd", "ps", "gs", "is", "sys", "ss", "sis", "sv", "os", "o", "source", "fs", "ds", "ats", "rs", "ns", "t", "serv", "sm", "sb", "S", "session", "h", "sq", "cs", "sp", "js", "m"]}}
{"project": "FFmpeg", "commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "target": 1, "func": "ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n\n                    int *seq, int flags, int64_t timestamp)\n\n{\n\n    RMDemuxContext *rm = s->priv_data;\n\n    int ret;\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        rm->current_stream= st->id;\n\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n\n        if(ret)\n\n            return ret < 0 ? ret : -1; //got partial frame or error\n\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n\n            (ast->deint_id == DEINT_ID_INT4) ||\n\n            (ast->deint_id == DEINT_ID_SIPR)) {\n\n            int x;\n\n            int sps = ast->sub_packet_size;\n\n            int cfs = ast->coded_framesize;\n\n            int h = ast->sub_packet_h;\n\n            int y = ast->sub_packet_cnt;\n\n            int w = ast->audio_framesize;\n\n\n\n            if (flags & 2)\n\n                y = ast->sub_packet_cnt = 0;\n\n            if (!y)\n\n                ast->audiotimestamp = timestamp;\n\n\n\n            switch (ast->deint_id) {\n\n                case DEINT_ID_INT4:\n\n                    for (x = 0; x < h/2; x++)\n\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n\n                    break;\n\n                case DEINT_ID_GENR:\n\n                    for (x = 0; x < w/sps; x++)\n\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n\n                    break;\n\n                case DEINT_ID_SIPR:\n\n                    avio_read(pb, ast->pkt.data + y * w, w);\n\n                    break;\n\n            }\n\n\n\n            if (++(ast->sub_packet_cnt) < h)\n\n                return -1;\n\n            if (ast->deint_id == DEINT_ID_SIPR)\n\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n\n\n             ast->sub_packet_cnt = 0;\n\n             rm->audio_stream_num = st->index;\n\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n\n            int x;\n\n            rm->audio_stream_num = st->index;\n\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n\n            if (ast->sub_packet_cnt) {\n\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n\n                ast->audiotimestamp = timestamp;\n\n            } else\n\n                return -1;\n\n        } else {\n\n            av_get_packet(pb, pkt, len);\n\n            rm_ac3_swap_bytes(st, pkt);\n\n        }\n\n    } else\n\n        av_get_packet(pb, pkt, len);\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n#if 0\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n\n\n            seq |= (timestamp&~0x3FFF);\n\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n\n        }\n\n    }\n\n#endif\n\n\n\n    pkt->pts = timestamp;\n\n    if (flags & 2)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n\n}\n", "idx": 944, "substitutes": {"rm": ["fm", "RM", "wm", "md", "re", "rb", "pb", "ha", "r", "drm", "gc", "mp", "rw", "am", "mem", "asm", "mk", "bm", "arm", "rt", "reg", "rn", "raf", "ctx", "rr", "irm", "sr", "rpm", "pm", "res", "rs", "sm", "dm", "sb", "ref", "mr", "mt", "rom", "mb", "ram", "tmp", "lamm", "vm", "gm", "nm", "m", "mx", "rem"], "ret": ["flag", "lib", "rets", "det", "nz", "nt", "Return", "re", "tr", "status", "lit", "try", "r", "rect", "alt", "pret", " Ret", "out", "v", "ort", "fun", "rev", "gt", "ft", "ter", "rt", "deg", "tn", "len", "reg", "reset", "elt", "lt", "nil", "dt", "cb", "full", "jp", "Ret", "RET", "res", "t", "val", "print", "ref", "mt", " RET", "err", "cmd", "red", "j", "result", "rem"], "x": ["xxxxxxxx", "n", "wx", "el", "xs", "php", "xes", "step", " xx", "xml", "xxx", "any", "d", "X", "im", "at", "w", "r", "p", "check", "on", "rx", "i", "xy", "fx", "l", "dx", "xxxx", "v", "e", "ax", "xd", "xp", "xf", "xc", "g", "cross", "xi", "xa", "ix", "t", "px", "index", "inx", "h", "xx", "ux", "lex", "y", "z", "yx", "f", "ox", "tx", "xt", "xe", "add", "m", "j", "mx", "ex"], "ast": ["ist", "bound", "nt", "an", "tt", "dist", "any", "ief", "rest", "asting", "est", "apt", "asted", "esta", "std", "asm", "mast", "store", "part", "quest", "and", "ed", "cmd", "ared", "asts", "test", "ab", "str", "md", "art", "some", "acy", "pb", "at", "AST", "ream", "hd", "am", "old", "cest", "st", "def", "list", "stan", "hop", "ord", "amd", "ma", "a", "ld", "as", "ard", "mt", "irst", "ram", "ace", "ata", "ad", "et", "aft", "admin", "must", "elt", "best", "ost", "all", "sta", "addr", "tx", "sam", "ase", "ack", "each", "ag", "aster", "na", "nd", "ts", "stone", "mem", "wal", "sh", "sc", "ann", "ac", "past", "blast", "act", "sw", "cast", "ess", "aw", "raw", "um", "err", "acl"], "sub_packet_cnt": ["sub_packet_cst", "sub_packet_countst", "sub_packet_pcount", "sub_packet_nnd", "sub_packet_nnt", "sub_packet_hcount", "sub_packet_pnt", "sub_packet_count", "sub_packet_hnt", "sub_packet_pount", "sub_packet_nount", "sub_packet_ncount", "sub_packet_ccount", "sub_packet_curst", "sub_packet_countount", "sub_packet_curnt", "sub_packet_hnd", "sub_packet_nst", "sub_packet_countnt", "sub_packet_hount", "sub_packet_curount", "sub_packet_cnd", "sub_packet_countcount", "sub_packet_curcount", "sub_packet_pnd"]}}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946, "substitutes": {"parent": ["parents", "child", "form", "pool", "initial", "man", "self", "unit", "point", "up", "page", "per", "remote", "p", "local", "ip", "peer", "g", "port", "ma", "host", "server", "master", "mother", "object", "component", "paren", "Parent", "root", "associated", "tmp", "net", "owner", "base"], "part": ["other", "str", "work", "half", "art", " parts", "path", "start", "star", "block", "comp", "pair", "p", "local", "pad", "word", "prefix", "parts", "name", "PART", "trans", "value", "host", "joined", "piece", "component", "object", "join", "root", "partial", "Part", "base", " PART"], "prop": ["plot", "ph", "proc", "pro", "attr", "property", "po", "supp", "dep", "rep", "cfg", "func", "prot", "att", "pb", "lit", "pt", "comp", "pr", "opt", "p", "mp", "cp", "ps", "buf", "req", "feat", "stat", "def", "info", "jp", "conf", "term", "par", "pp", "col", "coord", "pred", "expr", "resp", "msg", "op", "acc", "pl", "rel", "perm", "phys", "sty", "obj", "pkg", "tmp", " props", "cmd", "Prop", "desc", "typ", "priv", "properties", "pos", "fac"]}}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n", "idx": 961, "substitutes": {"s": ["n", "q", "ses", "self", "es", "b", "c", "ls", "d", "w", "r", "p", "ts", "ps", "is", "v", "st", "ss", "g", "se", "space", "sc", "sv", "fs", "ds", "sts", "so", "rs", "t", "ns", "state", "sb", "S", "h", "y", "session", "z", "sp", "js", "sa"], "req": ["dq", "uj", "wx", "pro", "attr", "seq", "q", "comm", "quick", "r", "rec", "p", "rw", "ind", "decl", "require", "qq", "info", "jp", "crit", "ire", "reg", "conf", "ctx", "rr", "resp", "msg", "res", "quest", "qt", "Resp", "rel", "usr", "pkg", "sq", "request", "requ", "cmd", "desc", "js", "err", "tx", "j", "urg", "compl"], "iu": ["imei", "au", "ib", "uj", "fu", "ipl", "itus", "uci", "ui", "ipp", "asu", "nu", "eu", "lu", "uin", "ief", "ici", "tu", "ia", "cu", "ii", "gru", "ru", "uu", "wei", "its", "eni", "agi", "iov", "i", "ei", "ij", "u", "ugi", "iw", "ic", "qi", "xi", "wi", "udi", "si", "rin", "iq", "tif", "aci", "qt", "isu", "ifa", "ue", "pu", "ie", "inqu", "gpu", "ua", "mu", "iao", "ieu", "ou", "ti", "ri", "gui", "hu"], "rsp": [" rdb", "rpl", "rpb", "rerresp", "rcsp", "rssp", " rpc", " rpp", "mrply", "rrply", "rpc", "rersync", "rrdb", " rpar", "rrsync", "mrsp", "srdb", "rpp", "srsw", "rrsp", "prSP", "resp", "rrtr", "rersp", "rresp", "srosp", " rosp", "rply", " rcap", "rsjp", "RSP", "mrSP", "srply", " rme", "Rsp", "rsss", "rrpp", "srSP", "prply", "srsp", "prresp", "wrresp", " rsw", "rrosp", " rSP", "rrpt", "mrosp", "wrjs", "rcSP", " rsync", "rrpar", "rdb", "rerosp", "rstr", "prpb", "rrsw", "prsp", "Rpb", " rpl", "rso", "prpt", "rjp", "crso", "rpt", "rcpb", "rss", "rcso", "prpar", "prme", "sresp", " rply", "rspl", " rjs", "rjs", "rrpl", "rsw", "rtr", "crsp", "prpc", "rosp", " resp", "rSP", "rcply", " rpt", "rcap", "rrme", "rcss", "rpar", " rresp", "Rply", "rrjs", "rrcap", "crjp", "wrsp", "rrresp", "rrpc", "rme", "wrcap", "rspp", " rtr", "rsso", "crss", "rsync", "rcjp"]}}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "substitutes": {"timer": ["tp", "this", "Timer", "time", "iter", "builder", "ester", "duration", "cell", "bench", "ger", "worker", "trigger", "finder", "tick", "controller", "icker", "player", "memory", "timeout", "her", "wrapper", "definition", "header", "older", "trace", "message", "peer", "ter", "runner", "handler", "activity", "later", "server", "dt", "manager", "er", "iler", "msg", "counter", "t", "imer", "taker", "tim", "txt", "tm", "monitor", "transfer", "clock", "tc", "span", "ptr", "cer", "walker", "meter", "actor", "writer", "processor", "loader", "err", "vm", "sim", "event", "dim", "term", "buffer", "instance", "mr"], "count": ["n", "empty", "latest", "time", "hash", "only", "length", "record", "nt", "batch", "ct", "c", "cache", "max", "frequency", "gc", "sum", "check", "number", "stat", "message", "info", "list", "conf", "len", "ount", "current", "num", "reset", "force", "all", "code", "set", "total", "report", "nb", "counter", "found", "now", "size", "index", "call", "amount", "Count", "z", "ctr", "data", "base"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971, "substitutes": {"job_id": ["job2id", "job2ids", "job_Id", "job_ID", "job_bid", " job_bid", "job_uid", "job2Id", " job_ID", "job2bid", " job_uid", " job_ids", "job_ids", " job_Id"], "bs": ["bt", "BS", "bp", "stats", "bi", "ab", "bas", "lbs", "bin", "b", "bps", "blog", "ls", "pb", "bh", "local", "its", "ts", "ps", "gs", "sys", "bc", "ob", "bed", "obs", "bos", "box", "os", "bis", "fs", "vs", "lb", "rs", "ns", "bits", "as", "sb", "bb", "obj", "tmp", "cs", "js", "ubs", "sub", "ubis"], "base": ["db", "BS", "ase", "bp", "bound", "bi", "null", "bas", "boot", "b", "clone", "bal", "local", "parent", "basic", "ip", "bar", "bare", "sys", "based", "template", "socket", "kit", "list", "super", "file", "bit", "space", "area", "origin", "fs", "server", "bottom", "it", "las", "Base", "to", "http", "as", "root", "tmp", "bot", "id", "buffer", "upper", "bo", "bat", "back"], "top": ["single", "null", "first", "this", "target", "above", " TOP", "pb", "status", "at", "p", "local", "head", "tops", "bo", "ps", "type", "parent", "sys", "template", "title", "client", "jp", "super", "file", "name", "best", "origin", "copy", "server", "bottom", "las", "master", "to", "op", "meta", "Top", "t", "part", "table", "root", "soc", "TOP", "tmp", "pop", "bot", "there", "tor", "typ", "upper", "clip", "boot", "job"], "speed": ["spec", "read", "peed", "length", "tt", "new", "status", "start", "height", "fps", "type", "timeout", "stream", "row", "screen", "ize", "sync", "score", "ss", "driver", "seek", "sc", "name", "limit", "fast", "state", "priority", "zero", "size", " speeds", "sw", "SIZE", "interface", "scale", "weight", "ctl", "skip", "EED", "buffer", "scroll", "Speed"], "on_error": ["onewchange", "onjsuccess", "on___success", " onjsuccess", "on_success", "on_change", "on___err", "onjerr", "onjerror", "on_err", "onewerr", " onjchange", " onjerror", "onjchange", " on_change", "onewerror", " on_success", "onewsuccess", "on___error", "on___change", " onjerr", " on_err"], "backing_file_str": ["backing_file_name", "backing_node_name", "backing_node_url", "backing_file_url", "backing_node_str", "backing_node_string", "backing_file_string"], "filter_node_name": ["filter_nodefiletype", "filter_node_list", "filter_file_list", "filter_node_str", "filter_node_type", "filter_nodefilestr", "filter_nodefilename", "filter_file_str", "filter_file_type", "filter_file_name", "filter_nodefilelist"], "errp": ["derpa", " errphp", " errps", " erp", "usrp", "nerpa", "erphp", "derP", "rrpa", "errping", "ererP", "errpa", "derp", "erps", "ererpa", "ererp", "nerp", "usrps", "orderps", "orderpa", "usrping", "errps", "erp", "errorps", "orderphp", " erphp", "nerps", "erP", "rrP", " erps", "ererps", "rrp", "errorpa", "errorp", " erP", "nerphp", " errping", "errP", "derping", "errphp", " errpa", "errorP", "usrpa", "rrps", "errorping", " errP", "orderp"], "s": ["sports", "n", "stats", "single", "qs", "ses", "comm", "b", "c", "ls", "ssl", "r", "p", "ts", "its", "ps", "fps", "i", "gs", "less", "ss", "g", "grades", "ims", "sv", "os", "conv", "fs", "ds", "ats", "rs", "ns", "t", "state", "rates", "sb", "S", "h", "sq", "cs", "hs", "js", "m", "j"], "reopen_queue": ["reclose_q", "reopen_q", "reense_component", "reopenedqueue", "reapplyetbutton", "reopenableque", "reopenerqueue", "reclose_entry", "reopen___buffer", "reopen_list", "reopenablequeue", "reopenlybutton", "reclose_que", "reopenedfile", "reopenINGqueue", "reopenerque", "reopen_ue", "reopen_target", "reopenINGentry", "reclose_buffer", "reapply_button", "reopenlyqueue", "reopenINGque", "reclose_file", "reopenedcollection", "reopen___list", "reopen_thread", "reopen_button", "reopenetque", "reopenableue", "reopenetbutton", "reopen_buffer", "reclose_collection", "reapply_que", "recreate_thread", "reopen___queue", "reopen_collection", "reapplyetentry", "recreate_que", "reense_queue", "reopenINGserver", "reopen___q", "reopen_que", "reapply_queue", "reclose_server", "reopenetentry", "reense_target", "reclose_list", "reclose_ue", "reopen_file", "reopenedlist", "reopenlyque", "reclose_queue", "reapplyetque", "reopenerbuffer", "reopen_entry", "reapply_entry", "reopenetqueue", "recreate_queue", "reopenablebuffer", "reapplyetqueue", "reopen_server", "reopenerue", "reopenlyentry", "reopen_component"], "orig_overlay_flags": ["orig_overline_posts", "orig_overlay_states", "orig_overplay_ags", "orig_overlay___flags", "orig_overplay_args", "orig_overplay_flags", "orig_overline_flags", "orig_override_vals", "orig_override_flags", "orig_overlay_flag", "orig_overlaysfiles", "orig_overlay_fs", "orig_overplay_flag", "orig_overlay_vals", "orig_overline_links", "orig_overline_states", "orig_overlaysstates", "orig_overlay___vals", "orig_override_fs", "orig_overlaysflags", "orig_overlay_posts", "orig_overlay_bits", "orig_override_bits", "orig_overlay___bits", "orig_overline_files", "orig_overlay_args", "orig_overlay_ags", "orig_overlay_files", "orig_overlay_links", "orig_overlay___fs"], "orig_base_flags": ["orig_base9ants", "orig_base_files", "orig_Base2flag", "orig_base9packages", "orig_base2flags", "orig_base32tags", "orig_local_ants", "orig_base00ants", "orig_base2fs", "orig_local00packages", "orig_base_fs", "orig_Base_ags", "orig_base32flag", "orig_baselyflags", "orig_Base_ants", "orig_local00ants", "orig_base2flag", "orig_base32flags", "orig_Base2flags", "orig_Base2fs", "orig_local_flags", "orig_base_tags", "orig_base9flags", "orig_base00flags", "orig_Base_files", "orig_base_flag", "orig_base_ags", "orig_local00flags", "orig_local_packages", "orig_Base2files", "orig_Base_flags", "orig_base2files", "orig_Base_fs", "orig_base00packages", "orig_baselyags", "orig_base_ants", "orig_base_packages", "orig_baselyants", "orig_Base_flag"], "iter": ["inner", "stack", "bi", "cli", "init", "initial", "rest", "head", "stable", "loop", "ip", "valid", "sys", "based", "accept", "rev", "here", "super", "server", "si", "res", "rel", "extra", "loader", "pri", "id", "chain", "upper", "iterator"], "overlay_bs": ["overline_lbs", "overaque_sb", "overaque_bas", "override_bytes", "overhang_bs", "overlayablebytes", "overlayablebos", "overlap_bs", "overlap_bas", "overlay_sb", "overlay_bps", "overlay_bos", "overlayMbs", "overlay___BS", "override_bos", "overlay_bas", "overlayablebs", "overlay32bu", "overlay32bs", "overlayMsb", "overlayMBS", "overlay_bu", "overlay32fs", "overhang_fs", "overhang_bps", "overlay_lbs", "overlay3bs", "override_bs", "overlayMbas", "overaque_BS", "overlay___bs", "overlay_js", "overline_bs", "overlay_ns", "overhang_bu", "overlap_js", "overlay3ns", "overaque_bs", "overlay32bps", "overlay___lbs", "overlay_bytes", "overlay___b", "overlay3bytes", "overlay_BS", "overline_BS", "overlayablens", "overlay_fs", "overlay3bos", "overlay_b", "overline_b", "override_ns", "overlap_lbs"], "commit_top_bs": ["commit_top_obs", "commit_job_BS", "commit_job_pb", "commit_top_pb", "commit_job_obs", "commit_top_BS", "commit_job_bs"], "local_err": ["locallyerr", "local_ner", "locmyerr", "localmyerr", "local___founder", "locallyner", " local_arr", "localmyfunc", "local_buf", "locallyarr", "local2err", "local2msg", " local___error", "local_founder", "localmyrr", "local___err", "loc_rr", " local_founder", "local_usr", " local_error", "internal_buf", "internal_usr", "locallyerror", "locmyfunc", "local2func", "local___error", "local_func", "loc_err", "loc_msg", "local_rr", "local_arr", "local_error", "locmyrr", "internal_err", " local___founder", "local2rr", "localmymsg", " local_ner", "loc_func", " local___err", "local_msg", "locmymsg", "locallyfounder"], "ret": ["count", "flag", " alt", " resp", "Return", "re", " mem", "status", "alt", "ts", "mem", "sys", "rev", "rt", "len", "num", "resp", "Ret", "RET", "res", "rs", "val", "t", " RET", "result"]}}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n", "idx": 982, "substitutes": {"bs": ["BS", "bp", "ba", "bi", "iss", "bl", "ab", "qs", "sbm", "lbs", "blocks", "ses", "b", "pb", "ls", "bles", "bh", "its", "ts", "bn", "is", "gs", "bc", "ks", " BS", "ss", "obs", "bos", "aos", "bis", "fs", "ds", "vs", "sts", "ns", "as", "sb", "bb", "bd", "ubs", "bes"]}}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}", "idx": 1035, "substitutes": {"link": ["age", "lib", "query", "filter", "links", "frame", "map", "match", "l", "plug", "light", "tool", "image", "file", "group", "Link", "handle", "load", "lock", "ref", "index", "disk", "linked", "address", "label", "ink", "line"], "samplesref": ["soundsRef", " sampsre", "sampsRef", "sampsreference", "soundsre", "sampsref", " sampsreference", "soundsref", " samplesreference", "samplesRef", "sampsre", " samplesRef", " sampsref", " sampsRef", "samplesre", " samplesre", "soundsreference", "samplesreference"]}}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038, "substitutes": {"options": ["ports", "stats", "errors", "config", "Options", "events", "allows", "offs", "plates", "results", "items", "lets", "values", "issues", "atts", "abilities", "pps", "styles", "links", "uploads", "includes", "opt", "als", "ts", "points", "tops", "ps", "changes", "oops", "phones", "terms", "ops", "parts", "classes", "keys", "apps", "ims", "orders", "checks", "os", "aps", "fs", "versions", "flags", "settings", "finals", "params", "faces", "op", "meta", "times", "types", "args", "zero", "weights", "vals", "option", "pins", "caps", "ices", "tools", "details", "rules", "roots", "names", "IONS", "ptions", "actions", "steps"], "errp": ["arrp", "derpa", "ererping", "derpb", "lrpb", "errf", "errfp", "scorepa", "rrpa", "derp", "latepat", "errping", "errpa", "scorepkg", "errpkg", "errpb", "latepkg", "ererpa", "ererp", "lrp", "arrpa", "rrm", "riskm", "fercp", "errpat", "ererwp", "ferpa", "latepa", "lrwp", "errps", "ererpkg", "errorps", "ererpt", "latep", "riskcp", "ererm", "rrfp", "riskp", "arrf", "ererps", "rrp", "scorep", "errorp", "ferp", "rrpt", "errpt", "errcp", "erercp", "ererfp", "errm", "ererpat", "arrcp", "rrping", "derwp", "errorpt", "rrcp", "rrf", "ferf", "scorepat", "riskfp", "lrpa", "rrps", "errorping", "errwp", "ererpb"], "ov": ["uj", "oi", "oo", "gov", "VOL", "erv", "aven", "vr", "nv", "ovi", "fo", "og", "orf", "van", "kov", "oc", "av", "iov", "iv", "tv", "oid", "vol", "osh", "OV", "sov", "ova", "nov", "ocr", "ow", "o", "lov", "iev", "oh", " tv", "vo", "hov", "rov", "vp", "oval", "uv", "mt", "ovan", "va", "off", "ove"], "obj": ["inst", "n", "attr", "str", "orig", "impl", "adj", "nt", "org", " ob", "cmp", "rb", "att", "Object", "ot", "oj", "opt", "pr", "alt", "bo", "ind", "vol", "out", "ck", "onet", "ob", "obo", "arr", "obs", "opp", "elt", "Ob", "ctx", "oss", "os", "expr", "op", "object", "cont", "ref", "txt", "bj", "tmp", "Obj", "err", "json", "od", "js", "buff", "o", "j", "data", "po", "instance"], "qdict": ["qualdef", "qtdict", "qstr", "qqcompl", "dqdir", "qualjson", "qqdef", "qjson", "qtd", "qdir", "qutd", "qtdom", "sqcompl", "qtdir", "iqdict", "qualtd", "dqdom", "iqcompl", "qqdb", "sqdb", "sqtd", "qualdict", "qudir", " qcompl", "qqstr", "qudef", "qqds", "qdom", "dqdict", "qcompl", "qds", "sqjson", "qubody", "qujson", "qdef", "iqdef", "qqdict", "qbody", "sqds", " qdb", "iqstr", "qtbody", "sqdef", "qdb", "sqdict", "qudict", "dqbody", "qudom", " qds", "sqstr"], "local_err": [" locally_err", " local_elt", "locallyerr", "local_cb", "error_err", "local____err", "local_r", "local____rb", "locallyelt", "error_fer", "localpyr", "locitylog", "localxconf", "localJconf", " locallyedcb", "local____rs", "locallyloc", "local____cb", "local_rs", "locxcb", "locxconf", "local_er", "locxrs", "localJcb", " locally_arr", "locallypeer", " locallyederr", "local__er", "localpyerr", "localJrs", "loc_cb", "local_fee", "localisederr", " local_r", " local_conn", "localityerr", "local____conf", "valid___error", "localitypeer", "local___err", "local___cb", "locallyrr", "valid___err", "local___rr", " local_rb", "locallyfee", "localxrs", "loc_peer", "error_rr", "error_gr", "locallyerror", "locxerr", "localpyelt", "localisedgr", "localJerr", "loc_conf", "localedcb", " locally_cb", "local_fer", "local__err", "local_peer", "loc_fee", "localxerr", " locally_elt", "localederr", "locallyconn", " local_er", "localitylog", " locallyedelt", "local___error", "localisedrr", "loc_err", "localpyconn", "loc_rs", "local_obj", "local___elt", "local__obj", "local____obj", "local_rr", "valid___rr", "local_arr", "local_log", "local_error", "localedarr", "locallyr", "locallylog", " locallyedarr", "valid___loc", "localityfee", "locityerr", "valid_rr", "local_elt", "loc_log", "valid_error", "localedelt", "localxcb", "local_conf", "local_rb", "local_loc", "local___arr", "local_gr", "local_conn", "local____er", "localisedfer", "locityfee", " local_obj", "local___loc", "local__rb", "locitypeer", "valid_loc", "valid_err"]}}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040, "substitutes": {}}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n", "idx": 1046, "substitutes": {"opaque": ["oposit", "ropaque", " opade", "opatile", "opsolete", "OPaques", "OPade", "opade", " opatile", "ropsolete", " Oposit", "opascript", " opascript", "ropatile", "ropade", " Opaques", " oposit", " opsolete", " opaques", "OPascript", "opaques", "OPatile", " Opascript", "OPsolete", "OPosit", "OPaque", " Opaque"], "s": ["spec", "ports", "stats", "bs", "ses", "comm", "es", "b", "ls", "ssl", "als", "p", "ts", "ps", "i", "changes", "gs", "is", "sys", "st", "less", "ss", "g", "se", "sis", "sv", "store", "fs", "ds", "eps", "set", "a", "sts", "ats", "so", "t", "rs", "state", "ns", "sb", "S", "h", "ess", "sl", "sq", "cs", "hs", "des", "sp", "f", "sa", "m", "series"], "data": ["DATA", "n", " extra", "metadata", "kat", "td", "output", "r", "cache", "al", "ds", "to", "done", "json", "wa", "str", " datas", " info", "Data", "def", " di", "list", "a", " name", " dc", "dat", "ta", " d", "table", "no", "vals", "extra", "des", "ATA", "buffer", "ata", "ad", " input", " df", "new", "response", " ed", "p", "out", "good", "info", "name", " output", "mu", "defined", "result", " td", "de", " delta", " sd", "values", "nd", "d", "w", "mem", " dat", "res", "t", "ns", "da", " advertising", "size", " dataset", "dev", "aw", "o", "db"], "ret": ["db", "n", "flag", "ext", "cat", "rets", "det", "nz", "del", "sec", "nt", "re", "tr", "status", "at", "pt", "gc", "alt", "inter", "ll", " Ret", "out", "git", "def", "rev", "ft", "gt", "ter", "rt", "elt", "lt", "tn", "deg", "reset", "len", "code", "jp", "Ret", "RET", "resp", "res", "t", "val", "print", "cont", "cert", "mt", " RET", "dr", "net", "ctr", "j", "result", "back", "reply"]}}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056, "substitutes": {"s": ["sports", "n", "stats", "bs", "qs", "q", "ses", "an", "comm", "es", "ls", "d", "r", "p", "ts", "its", "ps", "is", "gs", "sh", "sys", "st", "sync", "less", "ties", "ss", "se", "source", "sv", "os", "store", "fs", "ds", "set", "vs", "sts", "ats", "er", "rs", "ns", "t", "sm", "sb", "S", "h", "sw", "sl", "sq", "z", "cs", "hs", "sp", "js", "save"], "buf": ["uffy", "str", "orig", "cap", "var", "que", "iter", "seq", "aka", "bytes", "batch", "uf", "b", "rb", "pb", "block", "Buff", "map", "pad", "mem", "window", "v", "bar", "bc", "arr", "queue", "ctx", "br", "data", "doc", "cb", "msg", " buffer", "text", "ref", "vp", "cv", "Buffer", "cast", "pack", "tmp", "raw", "cmd", "buffer", "buff", "result", "vec", "box"], "len": ["lf", "n", "count", "lon", "el", "lib", "nl", "seq", "length", " length", "nt", "bytes", "elf", "c", "lc", "ls", "pos", "hl", "gen", " clen", "ll", "l", "mem", "v", "L", " n", " bl", "low", "Length", " l", "elt", "fin", "en", "all", "un", "Len", "limit", "full", "t", "val", "vec", "ref", " el", "size", "qual", "il", "h", "ln", "f", "lis", "lan", "compl"]}}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n", "idx": 1059, "substitutes": {"bc": ["bp", "gov", "mc", "isc", "usc", "comm", "ct", "c", "ca", "lc", "pb", "bitcoin", "oc", "gc", "cc", "ec", "pc", "dc", "cm", "cn", "xc", "fc", "nc", "sc", "bec", "cb", "BC", "cont", "arc", "bb", "tc", "circ", "soc", "cl", "vc", "icc", "bo"]}}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060, "substitutes": {"s": ["n", "sand", "services", "r", "i", "is", "v", "parts", "ies", "fs", "ds", "eps", "gets", "bits", "sb", "y", "locks", "sq", "hs", "reads", "ses", "c", "ties", "lines", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "ids", "des", "details", "ports", "qs", "events", "erences", "uploads", "states", "p", "sd", "ps", "comments", "out", "sys", "terms", "less", "ss", "grades", "tests", "ms", "bis", "set", "params", "times", "args", "mods", "bes", "stats", "ads", "comm", "results", "es", "b", "ls", "sets", "d", "pers", "als", "ts", "its", "changes", "gs", "e", "ks", "ers", "conf", "se", "g", "tes", "settings", "t", "rs", "ns", "ins", "S", "sw", "cs", "js", "aws"], "blk": ["Blj", "Blck", "silke", "blke", "blj", "BLak", "siltk", "blker", "BLk", "slg", "blg", " blkid", "lockak", "Blkt", "clck", "blb", "plb", " blkt", "silk", "bleke", "brb", "lockg", "plj", "Blg", "bleak", "bleker", "lockk", "brok", "blek", " blck", "blck", " blak", "slck", "blekt", "Blak", "clj", "brock", "silck", "brog", "plkt", "brck", " blker", " blg", "Blk", "plk", "brokt", "bletk", "clak", "BLkt", "slk", "bltk", "blak", " blke", "plker", "brkid", "plck", "brak", "slak", "broak", "blkid", "clk", " bltk", "BLck", "brk", "brob", "plak", "bleg", "blkt", "lockkt", "Blkid", " blj", "bleck"], "kind": ["method", "k", "spec", "needed", "magic", "what", "work", "school", "K", "md", "half", "cmp", "conduct", "Kind", "style", "sk", "rank", "th", "start", "kt", "family", "kernel", "type", "ind", "sky", "mk", "context", "ke", "info", "kw", "ks", "direction", "name", "kick", "brand", "key", "ko", "dir", "tech", "state", "pick", "module", "look", "make", "shape", "wind", "rend", "cmd", "id", "need", "kid", "mode"], "version": ["tag", "vector", "spec", "release", "length", "browser", "major", "platform", "controller", "iso", "description", "iv", "program", "v", "Version", "virtual", "command", "VERSION", "brand", "versions", "server", "ver", "size", "software", "root", "vision", "actor", "mode"], "serial": ["initialized", "vector", "release", "encrypted", "final", "ident", "normal", "custom", "volume", "social", "phone", "native", "util", "integer", "mobile", "controller", "iso", "random", "local", "morph", "description", "quant", "iv", "number", "template", "sex", "virtual", "chip", "special", "history", "mot", "material", "device", "ver", "primary", "dev", "specific", "raw", "erial", "address", "id", "small", "ser", "human", "kid", "series"], "model": ["tag", "vector", "spec", "form", "length", "event", "volume", "machine", "mod", "map", "controller", "product", "iso", "morph", "type", "description", "variable", "shell", "models", "template", "command", "virtual", "image", "power", "file", "name", "brand", "link", "Model", "location", "state", "device", "ver", "size", "software", "module", "dev", "feature", "address", "id", "label", "human", "m", "mode", "data"], "wwn": ["wbnd", "wnd", "Wwn", "wnt", "Wnt", "ewmn", "whwn", "wbkn", "wbgn", "Wmn", "www", " wmn", "wmn", "Wgn", " wgn", "whww", "ewgn", "Www", " wkn", "whnt", "Wnd", "ewnd", " www", "wgn", "Wkn", "ewwn", "whgn", " wnt", "wkn", "wbwn", " wnd"], "cylinders": ["celeds", "silresses", "shelllins", "silriers", "cellections", "cylinder", "fileds", "cyllins", "cylresses", "cllins", "silinders", "ylriers", "harmeds", "clinder", " cylinder", "cylbers", "harminders", "harmiants", "cellriers", "shellinders", "cellresses", "clinders", "filinders", "ylresses", "cellinders", "harmlections", "celinders", "cyleds", "shellinder", "ylinders", "fillections", "cyliants", "filiants", "celiants", "cylriers", "cyllections", "ylbers", "cellbers", "silbers", " cyllins"], "heads": ["cles", "cycles", "helps", "reads", "limits", "blocks", "masters", "holders", "planes", "offs", "ocks", "uses", "atts", "links", "arms", "utes", "head", "tops", "fps", "quarters", "leases", "adders", "forms", "olds", "uts", "views", "guards", "storms", " Heads", "hours", "hops", "outs", "headers", "workers", "history", "docs", "ths", "thens", "rows", "h", "loads", "maps", "locks", "pins", "headed", "tails", "HEAD", "mods", "aunts", "uds", "roots", "mers"], "secs": [" sects", "secds", "Secids", "seqts", "reqts", "ecids", "reqrs", "ecs", "ecls", "ecrs", "reqds", "sects", "reqs", "seqds", "seqids", "Secls", "secids", "secrs", "seqls", "seqs", " secds", "Secs", "Secrs", " secrs", "secls", "seqrs"], "chs_trans": ["chss_Trans", "chs_tr", "chs_translation", "chs_transform", "chs_Trans", "chs_rans", "chss_rans", "chms_tr", "chs2tr", "chs_rel", "chss_trans", "chms_translation", "chs2translation", "chls_trans", "chms_Trans", "chls_Trans", "chs2Trans", "chs2trans", "chss_rel", "chms_trans", "chs2transform", "chls_transform"], "nb_sectors": ["nb_peapters", "nb_pections", "nb_veors", "nb_secs", "nb_vebs", "nb_vecs", "nb___sebs", "nb_severs", "nb_peivers", "nb_bectors", "nb___wectors", "nb___wevers", "nb_weors", "nb_pectors", "nb___seors", "nb_specs", "nb_seors", "nb_wevers", "nb_spectors", "nb_vevers", "nb_peors", "nb_Secs", "nb_seivers", "nb___webs", "nb___sectors", "nb_Seapters", "nb_spections", "nb_sections", "nb_suctors", "nb_sebs", "nb_webs", "nb_spegments", "nb_veivers", "nb_wectors", "nb_pegments", "nb_beivers", "nb_subs", "nb_speapters", "nb_beors", "nb_speors", "nb_suvers", "nb_vectors", "nb_pecs", "nb_Sections", "nb_segments", "nb___weors", "nb___severs", "nb_vegments", "nb_suors", "nb_Sectors", "nb_begments", "nb_seapters"]}}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 1089, "substitutes": {"dev": ["de", "ad", "db", "test", "spec", "app", "var", "dem", "nt", "event", "api", " device", "devices", "d", "block", "w", "pt", "bus", "nav", "Device", "p", "av", "buf", "pad", "ve", "mem", "window", "out", "v", "connection", "def", "client", "info", "g", "conf", "port", "ctx", "handle", "link", "conn", "go", "develop", "server", "adv", "Dev", "device", "obj", "h", "hw", "des", "cmd", "priv", "hid", "DEV", "env", "data", "ev"], "iova": ["giona", "sioa", " iovan", "vona", "piiva", "diovan", "bioa", "vova", "diiva", "iona", " ioa", " ioco", " iov", "iov", "piovan", "siova", "diova", "biona", "iovan", "piov", "ioa", "voa", "iove", "pioa", "siov", "giove", "iiva", "giova", "biova", "vove", "gioa", "ioco", "sioco", "diov", "pioco", " iiva", "biove", "piova"], "len": ["lf", "n", "spec", "lon", "el", "nl", "lib", "wid", "seq", "bin", "length", "bytes", "nt", "cmp", "ls", "hl", "pos", "lit", "gen", "lim", "ll", "l", "L", "fun", "elt", "fin", "num", "en", "un", "Len", "coll", "loc", "iden", "fn", "vec", "size", "enc", "il", "h", "ln", "ml", "lis", "lan", "compl"], "imsg": ["membersgd", " simg", "msgs", "minsg", "omsgu", "tmgm", "epsG", "epsg", "minsgu", "omsgs", "appsg", "omsgm", "emsge", " simgs", "imsG", "imsgm", "membersgs", "omsge", "imsgd", "emsgm", "appsgs", "emsm", "imG", "img", "imsge", "appsgent", "tmgent", "appsgm", "membersm", "omsG", "omsg", "imgent", "imsgs", "emsg", " simge", "msG", "imge", "imsgu", "emsgs", "epsgu", "minsG", " simG", "msg", "tmg", "imsgent", "msge", "imsm", "omsgd", "imgm", "emsgd", "minsgm", "epsgm", "tmgs", "membersg", "omsm", "imgs"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    uint32_t val;\n\n    val = gic_dist_readb(opaque, offset);\n\n    val |= gic_dist_readb(opaque, offset + 1) << 8;\n\n    return val;\n\n}\n", "idx": 1107, "substitutes": {"opaque": ["opsue", "ipface", "opque", "obque", "paco", "opsque", "opface", " opc", "opacity", "paque", "opsaque", "ipaco", "ipque", "pc", "obue", " opface", " opque", "opaco", " Opaco", "opue", "pque", "opc", "oprox", "obaque", "pacity", " oprox", "pface", "obrox", " opacity", " Opacity", " Opc", " opue", "ipaque", "opsrox", " opaco", " Opaque"], "offset": ["bound", "slice", "encrypted", "offer", "target", "length", "secondary", "point", "from", "style", "error", "start", "at", "output", "seed", "p", "frequency", "sector", "pointer", "type", "scroll", "timeout", "pad", "parent", "oid", "row", "optional", "attribute", "prefix", "command", "seek", "shift", "origin", "location", "position", "set", "addr", "ta", "kh", "op", "index", "size", "alias", "address", "Offset", "padding", "buffer", "oint", "o", "off", "pos", "slot"], "val": ["el", "bl", "ival", "VAL", " v", "pl", " al", "rol", " arg", "lit", "pt", " eval", "als", "pr", "bal", "ret", "p", "sel", "state", "vt", "local", "ul", "ind", "l", "cal", "valid", "v", "out", "x", " bl", "pal", "elt", "ctx", " ret", " vec", "al", "pol", "value", "it", "aval", " aval", "loc", "t", "rel", "serv", "Val", " value", "eval", " el", "AL", " update", "vals", "il", "oval", "sl", "z", "tx", "vol", "data", "vec", "slot"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 1108, "substitutes": {"str": ["s", "inst", "attr", "input", "orig", "seq", "fr", "q", "tr", "b", "c", "cur", "start", "r", "pr", "Str", "p", "buf", "i", "vol", "out", "st", "prefix", "gr", "stri", "arr", "list", "len", "name", "STR", "source", "gap", "br", "end", "full", "msg", "res", "t", "text", "txt", "shr", "ptr", "pre", "f", "sp", "buffer", "ctr", "print", "data", "pos"], "endptr": [" endpointer", "endobj", "ENDptr", "enderpt", "endedaddr", " endPtr", "ENDobj", "endedreq", "endedobj", "endreq", " endaddr", "ENDPtr", "endproc", "enderreq", "ENDaddr", " endproc", "enderPtr", "startptr", "endPtr", "enderptr", "endaddr", "ENDpt", " endobj", "startpointer", "startproc", "ENDreq", " endpt", "endpointer", "endedpointer", " endreq", "endedproc", "endedptr", "endpt"], "err": [" result", "cr", "attr", "lr", "iter", "diff", " resp", "fr", " ex", "tr", " res", "error", "kr", "ger", "rank", " dr", " rc", "r", "pr", " error", " wr", "Error", " ptr", "sys", " gr", "gr", "die", " typ", "oe", "arr", "conf", "exc", "rr", "br", " terr", " r", " er", " Err", "er", "der", "resp", "res", " dist", "msg", "usr", "ner", " fr", "order", "mr", "ptr", "dr", " cr", "cer", "Er", "ox", "errors", "result", "ev", "nr"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "PXA2xxState *pxa255_init(unsigned int sdram_size)\n\n{\n\n    PXA2xxState *s;\n\n    int iomemtype, i;\n\n    DriveInfo *dinfo;\n\n\n\n    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n\n\n\n    s->env = cpu_init(\"pxa255\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n\n                    qemu_ram_alloc(NULL, \"pxa255.sdram\",\n\n                                   sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n\n                    qemu_ram_alloc(NULL, \"pxa255.internal\",\n\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n\n                              s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n\n        if (serial_hds[i]) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 1);\n\n#else\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 0);\n\n#endif\n\n        } else {\n\n            break;\n\n        }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base,\n\n                                   s->pic[pxa255_ssp[i].irqn]);\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                             s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n\n                    pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 1119, "substitutes": {"sdram_size": ["sdram_SIZE", "sdmem_SIZE", "sdstrom_height", "sdram_time", "sdram_format", "sdstrom_size", "sdmem_length", "sdmem_name", "sdram_name", "sdgram_format", "sdgram_style", "sdram_height", "sdmem_size", "sdgram_size", "sdstrom_time", "sdram_length", "sdram_style"], "s": ["n", "services", "ags", "r", "is", "v", "parts", "ies", "store", "fs", "eps", "http", "bits", "sb", "h", "y", "sq", "hs", "sports", "bs", "q", "ses", "c", "status", "st", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "session", "z", "des", "details", "j", "sql", "ports", "qs", "his", "scripts", "utils", "p", "ps", "l", "less", "ss", "tests", "ar", "set", "so", "args", "us", "sl", "sp", "sa", "m", "ex", "sam", "spec", "stats", "self", "comm", "es", "b", "ls", "pers", "w", "als", "ts", "its", "tags", "changes", "gs", "sh", "e", "csv", "in", "conf", "g", "se", "source", "rs", "t", "ns", "ins", "S", "f", "cs", "js", "aws", "simple", "o"], "iomemtype": [" qymunit", " quotemstyle", " qEMunit", " qEMtype", " qemstype", " qemunit", " qemsname", " quotEMname", " quotEMstyle", " qEMname", " quotEMtype", " qemname", " quotemname", " qemsstyle", " qemstyle", " quotemunit", " qymstyle", " quotemtype", " qymname", " qemsunit", " qEMstyle", " qemtype", " qymtype", " quotEMunit"], "i": ["phi", "iu", "I", "oi", "n", "bi", "li", "ui", "b", "c", "di", "ii", "mi", "p", "ind", "ip", "l", "ai", "v", "is", "ij", "e", "x", "pi", "in", "info", "ini", "zi", "g", "ic", "ims", "me", "xi", "o", "ami", "it", "si", "ix", "ci", "index", "multi", "y", "h", "f", "id", "ti", "sim", "gi", "m", "j"], "dinfo": [" dinformation", "ddhelp", "ddstat", "ndinfo", "Dinformation", "DInfo", "Dinf", "ardhelp", " dby", "ddinfo", "ardinf", "fdinformation", "Dfo", "Dinfo", "ardinfo", "ddinf", "Dby", "dInfo", "rdinf", "rdtry", "dtry", "Dtry", "dby", " dstat", "dinf", " dinf", " dInfo", " dfo", "fdInfo", "ardstat", "dfo", "ndinf", " dhelp", "rdfo", "rdinfo", "dstat", "ndinformation", "dinformation", " dtry", "dhelp", "ndby", "fdinfo"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 1121, "substitutes": {"busnr": ["bugor", "bridgenr", "bootor", "blockNR", "blockmor", "bootnor", " busnor", "bridgemor", "bugnr", " busNR", " busor", "bridgeNR", "bootmor", "bridgenor", "blocknor", "busNR", "bugnor", "bootnr", "bugNR", "blocknr", "busnor", "busmor", "bootNR", "busor"], "addr": ["ad", "ack", "attr", "eth", "ext", "ag", "pat", "work", "hash", "att", "at", "kt", "r", "map", "alt", "inter", "pad", " address", "ip", "offset", "Address", "bind", "x", "prefix", "title", "inv", "gt", "arr", "rt", "len", "name", "url", "adr", "arp", "set", "host", "loc", "ix", "dir", "res", "ns", "rel", "ref", "act", "alias", "obj", "ptr", "address", "cmd", "add", "id", "err", "tx", "gate", "has"], "bus": ["bug", "bridge", "nt", "cache", "mount", "loop", "boss", "conn", "store", "br", "bits", "http", "bool", "boot", "uss", "pos", "db", "bs", "pool", "hand", "bill", "di", " BUS", "util", "bal", "sum", "buf", "plug", "file", "os", "book", "bu", "host", "loc", "chain", "vol", "data", "box", "stick", "lib", "cat", "bur", "build", "bar", "good", "Bus", "full", "state", "proxy", "phys", "disk", "us", "ch", "ack", "stack", "mask", "b", "usb", "used", "local", "board", "cpu", "bc", "socket", "way", "obs", "driver", "ac", "BUS", "total", "lock", "cast", "bo", "back"], "port": ["db", "service", "ports", "tp", "null", "bridge", "pool", "ported", "unit", "point", "page", "pit", "pos", "pt", "per", "used", "pr", " sport", "p", "local", "pose", "cp", "type", "pad", "buf", "ve", "parent", "pc", "ip", "window", "seat", "eport", "ort", "next", "socket", "trace", "pi", "v", "ping", "info", "queue", "peer", "file", "pp", "cam", "pod", "handle", "key", "doc", "server", "it", "host", "report", "pport", "profile", "t", "http", "serv", "mit", "device", "table", "mt", "Port", "ptr", "interface", "fat", "gp", "PORT", "project", "pid", "client"], "dev": ["de", "ad", "db", "test", "pro", "app", "det", "var", "dem", "md", "dist", "di", "att", "comment", "nd", "d", "ot", "pt", "prof", "nav", "av", "sd", "buf", "req", "ve", "mem", "aux", "out", "v", "vol", "dis", "def", "info", "driver", "cam", "handle", "conn", "doc", "ds", "gu", "develop", "der", "loc", "den", "adv", "Dev", "val", "serv", "device", "ver", "home", "debug", "obj", "sw", "hw", "des", "vision", "cmd", "desc", "add", "err", "DEV", "priv", "off", "ev", "prop"], "nused": ["numused", "nbused", "numavailable", "nbfree", "numuse", "nofree", "nbavailable", "noavailable", "nouse", "numfree", "noused", "nbuse", "nuse", "navailable"], "nfree": ["numused", "nsfree", "nsused", " ntotal", " navailable", "numtotal", "ntotal", "nsavailable", "nstotal", "numfree", "numavailable", "navailable"]}}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n", "idx": 1122, "substitutes": {"v": ["k", "vim", "vd", "q", "vi", "vr", "b", "c", "nv", "verb", "d", "w", "r", "p", "av", "vt", "V", "tv", "l", "u", "inv", "g", "sv", "conv", "vis", "vs", "ov", "ver", "vp", "cv", "h", "uv", "f", "vm", "vc", "qv", "m", "j", "ev"], "name": ["s", "n", "attr", "ame", "str", "init", "nam", "var", "cap", "normal", "b", "error", "path", "w", "p", "lat", "type", "l", "word", "mem", "prefix", "x", "title", "def", "info", "num", "key", "ma", "a", "t", "val", "Name", "size", "NAME", "no", "pkg", "named", "id", "names", "label", "j", "data"], "obj": ["inst", "proc", "attr", "str", "seq", "np", "adj", "func", "src", "pos", "fx", "sys", "ob", "def", "obs", "ctx", "objects", "handle", "tk", "cb", "addr", "expr", "resp", "fn", "object", "txt", "ref", "bj", "act", "tmp", "pkg", "Obj", "cmd", "js", " Obj", "off", "po"], "errp": ["errP", "Erp", "wrpb", "errr", "rr", "rpb", "wrr", "wrp", "wrP", "ErP", "rP", "Erpb", "Err", "errpb", "rp"], "qov": ["qob", "gov", "quova", "qova", "qOV", " qove", "qukov", "qove", " qob", " qOV", " qova", " queryov", "quOV", "quove", "quov", " qkov", "gova", "gkov", " queryob", "quovo", " queryOV", "quob", "qovo", "qkov", " qovo", " queryovo", "gove"]}}
{"project": "qemu", "commit_id": "0e01b76e7cc43068f6b8cc05297f61539ccd5279", "target": 1, "func": "static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CqP:z\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'z':\n\n            ctx->zflag = 1;\n\n            break;\n\n        default:\n\n\n            return qemuio_command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return qemuio_command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    if (ctx->zflag && optind != argc - 2) {\n\n        printf(\"-z supports only a single length parameter\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag && ctx->Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag) {\n\n        int64_t count = cvtnum(argv[optind]);\n\n        if (count < 0) {\n\n            print_cvtnum_err(count, argv[optind]);\n\n\n            return 0;\n\n        }\n\n\n\n        ctx->qiov.size = count;\n\n        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,\n\n                             aio_write_done, ctx);\n\n    } else {\n\n        nr_iov = argc - optind;\n\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n\n                                pattern);\n\n        if (ctx->buf == NULL) {\n\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n            return 0;\n\n        }\n\n\n\n        gettimeofday(&ctx->t1, NULL);\n\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                         BLOCK_ACCT_WRITE);\n\n\n\n        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,\n\n                       ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    }\n\n    return 0;\n\n}", "idx": 1130, "substitutes": {"blk": ["Blck", "BLak", "blker", "BLk", "lak", "blg", "Blker", "blw", "Blkt", "slb", "lk", "lbk", "blb", " blkt", "bleak", "Blg", "lbck", "lbw", "BLb", "blek", "brkt", " blck", "brker", " blw", "blck", "slkt", "lck", " blak", "blew", "blekt", "Blak", " blker", "brck", " blg", "Blk", "BLkt", "slk", "Blb", "blak", "slak", "lbak", "BLck", "brk", "blkt", "bleg", "lkt", "bleck"], "argc": [" argp", "argsz", "opv", "argsxc", "argumentn", "argslc", "callxc", "argxc", " arglc", " argz", "argumentxc", "argsv", " argn", "argumentc", "argl", "argn", "argsn", " argxc", "argumentz", "calllc", "opc", "opp", "argsl", "opl", "argsp", "argp", "callv", "argsc", "argumentl", "argumentv", "callc", " argl", "argz", "arglc"], "argv": ["targetm", " argp", "argssv", "argumentk", "argumentp", "extc", "agm", "argsV", "argumentve", "argsk", "argumentm", "argk", "argV", " argm", "argvin", "extsv", "argsv", "agc", "argumentc", "argsm", "argve", "extvin", "argumentsv", "argsve", "targetc", "argsvin", "targetv", "argsp", " argk", "argp", "agvin", " argV", " argvin", "argumentvin", "argsc", "targetve", "agv", "argumentv", "argumentV", "extv", "argm"], "nr_iov": ["nr__iov", "nb__iov", "nr_voc", " NR_iov", "nr__iop", "nr_voice", " NR__voice", "nb__iop", "nr_iop", "nr__voc", "nr_ovi", "nb__iv", "nr__iv", "nr_iv", " NR__iov", " NR_iv", "nr__voice", " NR_voc", " NR__voc", "nb_iop", "nb_ovi", "nb_iov", " NR__iv", "nr__ovi", "nb_iv", " NR_voice", "nb__ovi"], "c": ["k", "n", "count", "form", "rc", "mc", "cmp", "ct", "b", "lc", "com", "d", "r", "cache", "p", "cc", "cp", "ec", "i", "pc", "cf", "v", "x", "e", "bc", "co", "cm", "u", "dc", "g", "fc", "o", "ac", "a", "C", "ce", "t", "abc", "unc", "call", "h", "tc", "f", "cs", "vc", "ch", "m", "con"], "ctx": ["uj", "inst", "Context", "nt", "cmp", "kt", "pause", "cp", "unk", "ind", "std", "cf", "crit", "history", "conn", "handle", "tk", "resp", "val", "txt", "hw", "pkg", "hs", "cmd", "xp", "inner", "init", "pool", "lc", "cu", "_", "util", "req", "warn", "prefix", "dc", "jac", "def", "command", "gt", "jp", "mom", "conv", "cb", "kj", "loc", "iat", "px", "index", "ctl", "config", "wx", "np", "kk", "help", "utils", "kl", "p", "cc", "aux", "ck", "mk", "sys", "cm", "co", "kw", "info", "that", "addr", "tm", "bj", "yes", "cv", "fw", "tx", "ctrl", "alloc", "proc", "ork", "work", "exec", "cfg", "ct", "func", "ia", "pt", "gc", "local", "check", "timeout", "parent", "context", "tz", "conf", "fc", "handler", "btn", "canon", "abc", "unc", "act", "obj", "tc", "call"], "optind": ["altIND", "optcond", "optatt", "jsonstick", "optimind", "Optcond", "opIND", "timeoutind", "optimcond", "tryind", "OptIND", "opInd", " optmind", "OptInd", "optindex", "fitine", "fitatt", "fitPtr", "letptr", "optmind", "optionind", "optionptr", "optptr", " optInd", "optimsing", "optstick", "Optinn", "optioncond", "optionindex", "optedind", "optionIND", "fitsing", "timeoutPtr", " optIND", " optindex", "timeoutmind", "opindex", "optioninn", "fitind", "fitmind", "optedptr", "trysing", "optediter", "optiminn", "opind", "optsing", " optinn", "timeoutine", "optimmind", "jsoncond", "optionInd", "tryine", "optedindex", "tryatt", "altinn", "optimindex", "jsonmind", "optinn", "letind", "altind", "optimstick", "jsonind", "letiter", "optInd", "optiter", "optioniter", "optine", "Optind", "optedPtr", "optedmind", " optcond", "optimine", "optPtr", "optedine", "letindex", "optIND", "optimatt", " optstick"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n    int64_t cluster_index, uint16_t **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                 (void**) refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1136, "substitutes": {"bs": ["bt", "BS", "bp", "bl", "lbs", "ses", "b", "blog", "bps", "ls", "boxes", "bles", "bh", "ts", "its", "aus", "uts", "gs", "sys", "bc", "jac", "ks", "ss", "cks", "obs", "bos", "aos", "outs", "ms", "os", "bis", "fs", "ds", "acs", "ashes", "vs", "sts", "rs", "ns", "bits", "sb", "hz", "locks", "cs", "hs", "js", "ubs", "ubis", "bes"], "cluster_index": ["cluster_length", "cluster_Index", "cluster_loc", "clstrap67Index", "cluster1index", "cluster1block", "cluster0block", "clusterPostlength", "clusters_index", "cluster67index", "clusters_length", "clstrap_index", "cluster7host", "cluster_block", "clstrap67loc", "clstrap_Index", "cluster7index", "clusterPostindex", "clusters_key", "cluster0key", "clusters_Index", "cluster_host", "cluster67loc", "cluster1id", "clusters_block", "cluster_key", "cluster67Index", "cluster7id", "cluster0index", "cluster_id", "cluster1key", "clusterPostid", "clusterPostIndex", "clusters_id", "cluster0id", "cluster7Index", "clstrap_loc", "clusters_host", "clstrap67index"], "refcount_block": ["refcount___type", "refCount_chain", "refcount_part", "refCount_block", "refcountybin", "refcount___lock", "refcountmyfilter", "refcoreedbin", "refcountyfilter", "refcountmyblock", "refcountedbin", "refcount_error", "refcountedfilter", "refcountedblocking", "refcache_block", "refcount2block", "refcount2chain", "refCount_map", "refcount___block", "refCount_lock", "refount_part", "refcountingblock", "refcountingpart", "refcount_chain", "refcount2Block", "refcount___chain", "refcore_filter", "refcountmybin", "refcountyblocking", "refCount_data", "refcount_filter", "refcountedblock", "refcore_bin", "refcoreedfilter", "refount_lock", "refcache_Block", "refcountinglock", "refcount_blocking", "refcountingerror", "refcount___Block", "refcount___data", "refcore_block", "refcoreedblocking", "refcoreedblock", "refcountmyblocking", "refcount_Block", "refount_block", "refcount_data", "refcache_type", "refcountyblock", "refcount_lock", "refount_error", "refcount_type", "refcount2type", "refcount_map", "refcore_blocking", "refcount_bin", "refcache_chain", "refCount_Block"], "s": ["sam", "spec", "stats", "qs", "self", "ses", "comm", "b", "c", "ags", "ls", "sn", "als", "p", "ts", "its", "ps", "changes", "l", "gs", "is", "v", "sys", "less", "parts", "ss", "conf", "ims", "ms", "tes", "sv", "os", "bis", "fs", "ds", "ashes", "vs", "sts", "ats", "rs", "ns", "sm", "as", "http", "sb", "S", "ins", "bits", "args", "sw", "h", "sl", "sq", "cs", "sp", "hs", "details", "js", "aws", "bes"], "refcount_table_index": ["refcount_Table_Index", "refcount_block_index", "refcount_table__index", "refcount_table__size", "refcount_table_ind", "refcount_table_size", "refcount_table__key", "refcount_block_key", "refcount_table_Index", "refcount_Table_index", "refcount_block_size", "refcount_block_ind", "refcount_block_type", "refcount_table__Index", "refcount_table_key", "refcount_block_number", "refcount_table_type", "refcount_table_number", "refcount_Table_ind", "refcount_block_Index"], "ret": ["flag", "ext", "del", "rets", "det", "final", "hash", "nt", "Return", "re", "tr", "jump", "att", "ber", "status", "try", "r", "gc", "alt", "inter", "arg", "ll", " Ret", "mem", "out", "body", "next", "fun", "rm", "def", "rev", "gt", "ft", "ter", "rt", "len", "elt", "lt", "reg", "reset", "deg", "value", "ry", "run", "resp", "Ret", "RET", "last", "res", "t", "val", "print", "cert", "ref", "usr", "tf", "il", "mt", " RET", "f", "net", "err", "cmd", "result", "back", "rem"]}}
{"project": "FFmpeg", "commit_id": "95801b6a0727d6f7e6f1204ce812b1e81613307d", "target": 1, "func": "static int alac_decode_frame(AVCodecContext *avctx,\n\n                             void *outbuffer, int *outputsize,\n\n                             const uint8_t *inbuffer, int input_buffer_size)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n\n\n    int channels;\n\n    unsigned int outputsamples;\n\n    int hassize;\n\n    int readsamplesize;\n\n    int wasted_bytes;\n\n    int isnotcompressed;\n\n    uint8_t interlacing_shift;\n\n    uint8_t interlacing_leftweight;\n\n\n\n    /* short-circuit null buffers */\n\n    if (!inbuffer || !input_buffer_size)\n\n        return input_buffer_size;\n\n\n\n    /* initialize from the extradata */\n\n    if (!alac->context_initialized) {\n\n        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: expected %d extradata bytes\\n\",\n\n                ALAC_EXTRADATA_SIZE);\n\n            return input_buffer_size;\n\n        }\n\n        if (alac_set_info(alac)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: set_info failed\\n\");\n\n            return input_buffer_size;\n\n        }\n\n        alac->context_initialized = 1;\n\n    }\n\n\n\n    init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);\n\n\n\n    channels = get_bits(&alac->gb, 3) + 1;\n\n    if (channels > MAX_CHANNELS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"channels > %d not supported\\n\",\n\n               MAX_CHANNELS);\n\n        return input_buffer_size;\n\n    }\n\n\n\n    /* 2^result = something to do with output waiting.\n\n     * perhaps matters if we read > 1 frame in a pass?\n\n     */\n\n    skip_bits(&alac->gb, 4);\n\n\n\n    skip_bits(&alac->gb, 12); /* unknown, skip 12 bits */\n\n\n\n    /* the output sample size is stored soon */\n\n    hassize = get_bits1(&alac->gb);\n\n\n\n    wasted_bytes = get_bits(&alac->gb, 2); /* unknown ? */\n\n\n\n    /* whether the frame is compressed */\n\n    isnotcompressed = get_bits1(&alac->gb);\n\n\n\n    if (hassize) {\n\n        /* now read the number of samples as a 32bit integer */\n\n        outputsamples = get_bits_long(&alac->gb, 32);\n\n        if(outputsamples > alac->setinfo_max_samples_per_frame){\n\n            av_log(avctx, AV_LOG_ERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfo_max_samples_per_frame);\n\n            return -1;\n\n        }\n\n    } else\n\n        outputsamples = alac->setinfo_max_samples_per_frame;\n\n\n\n    if(outputsamples > *outputsize / alac->bytespersample){\n\n        av_log(avctx, AV_LOG_ERROR, \"sample buffer too small\\n\");\n\n        return -1;\n\n    }\n\n\n\n    *outputsize = outputsamples * alac->bytespersample;\n\n    readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1;\n\n\n\n    if (!isnotcompressed) {\n\n        /* so it is compressed */\n\n        int16_t predictor_coef_table[channels][32];\n\n        int predictor_coef_num[channels];\n\n        int prediction_type[channels];\n\n        int prediction_quantitization[channels];\n\n        int ricemodifier[channels];\n\n        int i, chan;\n\n\n\n        interlacing_shift = get_bits(&alac->gb, 8);\n\n        interlacing_leftweight = get_bits(&alac->gb, 8);\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            prediction_type[chan] = get_bits(&alac->gb, 4);\n\n            prediction_quantitization[chan] = get_bits(&alac->gb, 4);\n\n\n\n            ricemodifier[chan] = get_bits(&alac->gb, 3);\n\n            predictor_coef_num[chan] = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = 0; i < predictor_coef_num[chan]; i++)\n\n                predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16);\n\n        }\n\n\n\n        if (wasted_bytes)\n\n            av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented, unhandling of wasted_bytes\\n\");\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            bastardized_rice_decompress(alac,\n\n                                        alac->predicterror_buffer[chan],\n\n                                        outputsamples,\n\n                                        readsamplesize,\n\n                                        alac->setinfo_rice_initialhistory,\n\n                                        alac->setinfo_rice_kmodifier,\n\n                                        ricemodifier[chan] * alac->setinfo_rice_historymult / 4,\n\n                                        (1 << alac->setinfo_rice_kmodifier) - 1);\n\n\n\n            if (prediction_type[chan] == 0) {\n\n                /* adaptive fir */\n\n                predictor_decompress_fir_adapt(alac->predicterror_buffer[chan],\n\n                                               alac->outputsamples_buffer[chan],\n\n                                               outputsamples,\n\n                                               readsamplesize,\n\n                                               predictor_coef_table[chan],\n\n                                               predictor_coef_num[chan],\n\n                                               prediction_quantitization[chan]);\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR, \"FIXME: unhandled prediction type: %i\\n\", prediction_type[chan]);\n\n                /* I think the only other prediction type (or perhaps this is\n\n                 * just a boolean?) runs adaptive fir twice.. like:\n\n                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)\n\n                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)\n\n                 * little strange..\n\n                 */\n\n            }\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        int i, chan;\n\n        for (i = 0; i < outputsamples; i++)\n\n            for (chan = 0; chan < channels; chan++) {\n\n                int32_t audiobits;\n\n\n\n                audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size);\n\n                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);\n\n\n\n                alac->outputsamples_buffer[chan][i] = audiobits;\n\n            }\n\n        /* wasted_bytes = 0; */\n\n        interlacing_shift = 0;\n\n        interlacing_leftweight = 0;\n\n    }\n\n    if (get_bits(&alac->gb, 3) != 7)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\");\n\n\n\n    switch(alac->setinfo_sample_size) {\n\n    case 16:\n\n        if (channels == 2) {\n\n            reconstruct_stereo_16(alac->outputsamples_buffer,\n\n                                  (int16_t*)outbuffer,\n\n                                  alac->numchannels,\n\n                                  outputsamples,\n\n                                  interlacing_shift,\n\n                                  interlacing_leftweight);\n\n        } else {\n\n            int i;\n\n            for (i = 0; i < outputsamples; i++) {\n\n                int16_t sample = alac->outputsamples_buffer[0][i];\n\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n\n            }\n\n        }\n\n        break;\n\n    case 20:\n\n    case 24:\n\n        // It is not clear if there exist any encoder that creates 24 bit ALAC\n\n        // files. iTunes convert 24 bit raw files to 16 bit before encoding.\n\n    case 32:\n\n        av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8 - get_bits_count(&alac->gb));\n\n\n\n    return input_buffer_size;\n\n}\n", "idx": 1137, "substitutes": {"avctx": ["wavcmd", "afctx", "wavca", "avctl", "avcontext", "abkb", "avectl", "abcpp", " avgc", "avtx", "avca", "avegc", "abtx", "afobj", "afmsg", "afpkg", "avergc", " avpkg", "avcpp", " avsetup", "afcpp", "avecpp", "avepkg", "vercp", "aveca", "avercmd", "avkb", "aversetup", "vercontext", "avercpu", " avcp", "avecpu", "abobj", " avkb", "avmsg", "abpkg", "abgc", "abcp", "abctx", "wavpkg", "aveobj", "verctx", "avobj", " avcontext", "avcpu", "avsetup", "abcontext", "avectx", "avecontext", "avcp", "wavctx", "averca", " avjac", " avcpu", "avesetup", " avctl", "afcmd", "wavgc", "averctl", "averctx", "avekb", "avpkg", "avjac", "avgc", " avtx", "abjac", "averpkg", "avcmd", "avermsg", "verjac", "wavmsg", "avetx"], "outbuffer": ["outputbuffer", "instream", "inbuff", "outputbuff", "outstream", "outbuff", "outputBuffer", "inBuffer", "outBuffer", " outBuffer", "outputstream", " outstream", " outbuff"], "outputsize": ["inputlength", "hiddenlength", "outputcount", "outputSize", "Outputcount", "inputcount", "hiddensize", "hiddencount", "outputlength", "hiddenSize", "inputSize", "inputsize", "Outputlength", "Outputsize", "OutputSize"], "inbuffer": [" inbuff", "inbuff", "cinbuffer", "inbuf", " inBuffer", "inBuffer", "outbuff", "cinbase", "outbound", "cinbuf", " inbase", "binbuff", " inbound", "binBuffer", "INBuffer", "cinbuff", " inbuf", "outBuffer", "binbuffer", "InBuffer", "binbuf", "inbase", "inbound", "INbuff", "Inbuf", "Inbase", "Inbuff", "INbound", "INbuffer", "Inbuffer"], "input_buffer_size": ["input_bufferzheight", "input_buffer_SIZE", "input_buffer_count", "input_buffer_ize", "input_Buffer_count", "input_buffer_len", "input_bufferzSize", "input_buffer2size", "input_Buffer_SIZE", "input_bufferzSIZE", "input_Buffer_Size", "input_queue_Size", "input_cache_length", "input_buffer_Size", "input_Buffer_length", "input_queue_len", "input_bufferzsize", "input_Buffer_size", "input_buffer_length", "input_queue_SIZE", "input_queue_size", "input_cache_string", "input_buffer_height", "input_buffer2len", "input_Buffer_height", "input_queue_ize", "input_cache_Size", "input_buffer2SIZE", "input_queue_length", "input_buffer2length", "input_buffer_string", "input_cache_size"], "alac": [" aljac", "alic", "delacl", "ralacc", "delacer", "allac", "allic", "aleriac", "alerac", "ralsac", "aliAC", "alax", "balace", "calAC", "altacc", "aleraic", "aracl", "stalic", "realax", "realace", "balact", "balaic", "balacl", "ilsac", "aliaco", "alacl", " alacc", "balaca", "altacer", "calacl", " alace", "calac", "alsac", "malac", "alAc", "calace", "arac", "var", "daliac", "realac", "talac", "allAc", "c", "altac", "_", "aliiac", "allacc", "aleracer", "talAC", "delac", "balam", "aracer", "alAC", "realam", "baliac", "ilac", "alacc", "salace", "stalac", "balac", "allacer", "cont", "aliax", "salaca", "calca", "malmac", "ilacc", "valacc", "aleraco", "aldacc", "malace", "data", "aliac", "talacl", "halac", "haliac", "balacc", "balacer", "alaca", "stalacer", "alimac", "new", "alact", "channel", "stalAc", " aliac", "aldac", "dalacc", "alljac", "into", "ralact", "balAC", "aliacl", "info", "salmac", "valjac", "salsac", "aldAC", "ilact", "malacl", "halacer", "alace", "valac", "salacl", "halic", "aleracl", "alica", "altiac", "aleract", "alacer", "allace", " alacer", "salact", "aliam", "alca", "alam", "halAc", "halact", "salaco", "exec", "halacl", "salAC", "salac", "salacc", "almac", "altaco", "salacer", "halaca", "context", " alAC", "balca", "aleracc", "alaco", " alact", "halacc", "ralac", "call", "dalac", "aldact", "dalaic", "balax", "valace", "alaic", "aljac", "aliace"], "channels": ["achones", "chonents", "contorts", "chedamps", "chorts", "Channels", "hayers", "horts", "achorts", "honents", "chategories", "Chayers", "chanes", "achanes", "chayers", "contones", "chords", "achanguages", "chedanes", " chanes", "Chonents", "chones", "hannels", "chedategories", " champs", "achannels", "contannels", "Chords", " chategories", "chedannels", "champs", "contonents", "hones", "contords", "contanguages", "achamps", "changuages", "hanguages", "hords", "achategories", "contayers"], "outputsamples": ["outputssonents", "outputssamples", "outputnsorts", "inputssongs", "outputsents", "outputnsents", "OutputSides", "outputbisamples", "outputssfaces", "outputspamples", "putsonents", "outputspents", "inputsamples", "putssfaces", "outputSls", "outputseonents", "outputcamps", "OutputSamps", "outputgspaces", "outputSamps", "inputssamp", "outputssamp", "outputstatorts", "putssamples", "Outputsides", "Outputsls", "OutputSets", "OutputSls", "outputconsamples", "putssonents", "outputstatamples", "outputssorts", "inputsongs", "outputseents", "outputsfaces", "outputsongs", "inputsamps", "Outputsents", "Outputsets", "outputbisets", "outputspaces", "outputconsets", "putsamples", "Outputnsamples", "outputsefaces", "Outputsamps", "outputnsamples", "outputstatamps", "outputsonents", "outputsides", "outputsets", "outputcamp", "OutputSamples", "outputsetsamp", "outputssongs", "Outputsamples", "outputconsls", "inputssamples", "outputsorts", "outputsamp", "outputSpaces", "outputsetsamps", "outputgsamps", "outputresamps", "outputgsides", "outputsetsamples", "outputseamples", "Outputspaces", "outputstatents", "outputSamples", "putssents", "outputcongs", "outputsponents", "outputSets", "putsfaces", "Outputnsorts", "outputresides", "outputsls", "outputssents", "Outputsorts", "outputspfaces", "Outputnsamps", "outputcamples", "outputconsamps", "outputrespaces", "outputgsamples", "outputbisamps", "putsents", "inputsamp", "inputssamps", "outputsetsongs", "outputbisls", "Outputnsents", "outputnsamps", "outputSides", "outputsamps", "outputssamps", "OutputSpaces", "outputresamples"], "hassize": ["hassiz", "chassiz", "hossize", "hallspace", "hassIZE", "shassIZE", "hassesizable", " hassizable", "hasscale", "shassespace", "hasesized", "chassescale", "harspace", "shassesIZE", "halscale", "hallsize", "hassespace", "harscale", "harsize", "chasscale", " hasspace", "hosspace", "hassizable", "hasesize", "shassesiz", "hallsized", " hassized", "shassesize", "chassesized", "chassesize", " hassesized", "chassized", "hassized", "hassesIZE", "chassize", "shasspace", "harsiz", "hasesizable", " hassesizable", "hassesized", "hassesiz", "halsized", " hassesize", "chassesiz", "shassiz", "halsiz", "harsIZE", " hassespace", "hossiz", "hasespace", "hassesize", "hallsizable", "hassescale", "harsized", "shassize", "hasspace", "halsize", "hossIZE"], "readsamplesize": ["readsitesized", "readsitesz", "readsavesizes", "readspacesized", "checkspacesz", "checksamplesized", "readsavesized", "readspacesz", "checksamplesizes", "checkspacesizes", "readsitesizes", "readsamplesized", "checkspacesize", "checkspacesized", "readsitesize", "readsamplesz", "checksamplesize", "readsavesize", "readsavesz", "readspacesize", "readsamplesizes", "checksamplesz", "readspacesizes"], "wasted_bytes": ["wasted_files", "wanted_bits", "wushed_values", "wanted_Bytes", "wasted_rows", "wanted_bytes", "wasted_values", "wasted_byte", "wasted_Bytes", "wushed_files", "wushed_byte", "wushed_bytes", "wanted_rows", "wasted_bits"], "isnotcompressed": ["isnotcondress", "isnotsuppression", "isnotcomlied", "isnotcompression", "isnotcondressed", "isnotCompression", "isnotsupplied", "isnotsuppress", "isnoncomlied", "isnotCompress", "isnoncompress", "isnotcondression", "isnoncondressor", "isnotcompress", "isnoncondress", "isnoncompressed", "isnotCompressor", "isnotcomress", "isnoncompacted", "isnotcomressed", "isnotdeflied", "isnoncomacted", "isnoncondressed", "isnotdefressed", "isnotdefress", "isnoncondression", "isnotcomacted", "isnotcomplied", "isnotsuppressor", "isnotsuppacted", "isnotcompacted", "isnoncompressor", "isnoncompression", "isnotcondressor", "isnoncomplied", "isnotdefacted", "isnotsuppressed", "isnotCompressed", "isnoncomressed", "isnoncomress", "isnotcompressor"], "interlacing_shift": ["interlacing2shift", "interlacing_weight", "interlating_scale", "interlacing_scale", "interlacing2weight", "interlacing2offset", "interlating_shift", "interlating_offset", "interlating_weight", "interlacing2scale", "interlacing_offset"], "interlacing_leftweight": ["interlacing_leftscale", "interlacing_leftmask", "interlacing_lowscale", "interlacing_rightweight", "interlacing_innermask", "interlacing_rightscale", "interlacing_rightmask", "interlacing_lowmask", "interlacing_innerweights", "interlacing_lowweight", "interlacing_innerscale", "interlacing_innerweight", "interlacing_lowweights", "interlacing_rightweights", "interlacing_leftweights"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n", "idx": 1145, "substitutes": {"argc": [" argp", "optcs", "valp", "argslc", "argnc", "targetac", " argnc", " argcat", "targetlc", "lenc", "optz", " arglc", "targetn", "argcs", " argz", " argac", "targetnc", " argn", "argl", "argn", " argcs", "targetc", "valnc", "argsl", "targetl", "lenz", "optc", "argp", "argsc", "lencs", "argcat", "argac", "argsac", "valc", "optcat", "targetp", "lencat", " argl", "valn", "argz", "arglc"], "argv": [" argp", "Argf", "metvP", "callV", "opv", "argsV", "configc", "opvs", "configvin", "metv", "configv", "argvP", "argsf", "metc", "argV", "argvin", " argm", "argsv", "argumentc", "flagvs", "Argvs", "firevs", "firev", "flagc", " argvP", "locvs", "argsvs", "opc", "locv", "callvin", "argumentf", " argvs", "Argp", " argf", "firevin", "locc", "opm", "argp", "argvs", "argsvP", "configp", " argV", "metvs", "callv", "Argv", " argvin", "argsc", "argf", "flagv", "Argc", "argm", "argumentv", "callc", "opf", "Argm", "Argvin", "callvs", "callf", "argumentvs"], "opts": ["opcs", "optcs", "optioncs", " optnt", "optpt", "opnt", "optionters", " optoptions", "operins", "optionts", " opnt", "optters", "optts", "opins", "operters", "optins", "oppt", "optnt", " optpt", " oppt", "opoptions", "opercs", "opters", "operts", " opoptions", "optoptions", "optionins", " optts"], "c": ["k", "n", "cut", "count", "cat", "rc", " C", "mc", "cmp", "ct", "b", "lc", "com", "cur", "d", "cu", "w", "comp", "r", "oc", "cache", "p", "gc", "opt", "cc", "i", "pc", "l", "cf", "out", "v", "bc", "dc", "e", "co", "cn", "x", "g", "fc", "ic", "name", "nc", "ctx", "o", "ac", "it", "a", "cb", "C", "cod", "ce", "t", "ci", "cont", "arc", "abc", "unc", "etc", "tc", "h", "f", "cs", "vc", "ch", "cd", "chain", "config", "m", "con"], "cp": ["ph", "proc", "bp", "tp", "zip", "cat", "cap", "np", "cmp", "cfg", "ct", "lc", "pb", "CP", "cu", "comp", "opt", "oc", "p", "mp", "pr", "cc", "gc", "pc", "fp", "ip", "cf", "csv", "dc", "hp", "jp", "quote", "cop", "ctx", "lp", "copy", "cb", "cv", "tc", "pkg", "cs", "wp", "cmd", "gp", "ch", "cd", "ctrl"], "optind": [" optPtr", "optimini", "optcond", "optcall", "expmind", "optednt", "timeoutstick", "ptmind", "fitkind", "optatt", "opmd", "optimind", "optini", "opIND", "optionwind", "timeoutbind", "plotind", "timeoutind", "optimIND", "ortind", "optimcond", "optimnt", "objind", " optbind", "opteddep", "tryind", "tipInd", "optionmd", "opInd", " optmind", "optionPtr", "optindex", "expind", "optdir", "tipindex", "ptInd", "optedcond", "optwind", "ortcall", "tipind", "ortstick", "optmind", "optionind", "optionmind", " optkind", "statdep", "statinder", "opmind", " optInd", "trybind", "optstick", " optinder", "optionindex", "tipwind", "optedind", "optionIND", "optedatt", " optIND", "opwind", " optindex", "statinn", "optreq", "letnt", "optedreq", " optdir", "opindex", "ptind", "optimbind", "fitind", "fitmind", "optionbind", "optinder", "objmind", "letdir", "ortbind", "objIND", "trymind", " optcall", "optiminder", " optnt", "optbind", "optiminn", "opind", "optedinn", "servdep", " optinn", "servind", "optimmind", "optdep", "optnt", "optionInd", "plotInd", "opcall", "optimmd", "timeoutcall", "tryreq", "optimcall", " optatt", "servinn", "optinn", "optmd", "letmind", "ptcall", "letind", "opPtr", "expnt", "optkind", "plotini", "fitIND", "expbind", "optInd", "optionreq", "optedinder", "objInd", "optimkind", "opteddir", "opini", "optedmind", " optcond", "optimInd", "optPtr", "optimdir", "optIND", "optimatt", "optedbind", "plotmd", "servinder", " optstick", "statind"], "sp": ["sam", "inst", "proc", "bp", "tp", "cap", "pat", "np", "ep", "spl", "sk", "pt", "syn", "esp", "p", "mp", "sd", "ps", "ind", "ip", "pc", "isp", "sh", "spe", "ap", "pres", "sync", "xp", "jp", "se", "par", "space", "pp", "sc", "sv", "sil", "scope", "lp", "pol", "bsp", "SP", "si", "ng", "push", " esp", "osp", "loc", "pl", "sm", "serv", "rel", "index", "Sp", "yp", "sw", "asp", "snap", "soc", "sl", "span", "ptr", "pre", "policy", "amp", "pse", "ch", "dim", "vol", "j", "pos", "ssh", "top"]}}
{"project": "qemu", "commit_id": "6240d6467077a12c24878bab645d8e2983e4975a", "target": 0, "func": "static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,\n\n                                    uint32_t val)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr;\n\n    int reload = 0;\n\n\n\n    DPRINTF(\"write \" TARGET_FMT_plx \" %08x\\n\", addr, val);\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case TIMER_LIMIT:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter MSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else {\n\n            // set limit, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = val & TIMER_MAX_COUNT32;\n\n            if (!s->limit)\n\n                s->limit = TIMER_MAX_COUNT32;\n\n            ptimer_set_limit(s->timer, s->limit >> 9, 1);\n\n        }\n\n        break;\n\n    case TIMER_COUNTER:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter LSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else\n\n            DPRINTF(\"not user timer\\n\");\n\n        break;\n\n    case TIMER_COUNTER_NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n", "idx": 1167, "substitutes": {"opaque": ["OPque", "opque", "opse", "opatile", "OPse", "OPaques", "iopaco", "OPaco", " opatile", "iopque", "oaques", "oaque", "oque", "OPus", "ous", "opaco", "oatile", "iopus", " opse", "opus", "ose", " opaques", "opaques", "OPatile", "oaco", "iopaque", "OPaque"], "addr": ["ad", "ack", "attr", "eth", "var", "rc", "hash", "oad", "tr", "rol", "src", "kt", "r", "map", "max", "inter", "pad", "align", "mem", "ip", "offset", "x", "arr", "rt", "elt", "seek", "ctx", "ay", "coord", "ord", "adr", "trans", "ix", "loc", "res", "rs", "now", "ref", "alias", "mt", "ptr", "dr", "hw", "address", "cmd", "add", "err", "tx", "pos", "alloc"], "val": ["test", "count", "VAL", "ival", "var", "seq", "bin", "cmp", "grad", "rol", "alt", "arg", "bal", "local", "buf", "vt", "sel", "ret", "req", "mem", "cal", "v", "valid", "x", "elt", "len", "bit", "num", "ctx", "al", "pol", "value", "it", "key", "fee", "res", "rel", "serv", "Val", " value", "ref", "eval", "index", "hz", "vals", "dev", "act", "z", "pri", "err", "tx", "cmd", "vol", "data", "Value"], "s": ["n", "services", "is", "v", "parts", "ies", "fs", "ds", "bits", "sb", "y", "h", "sq", "hs", "sports", "bs", "ses", "ties", "ims", "sv", "os", "vs", "sts", "ats", "as", "z", "details", "j", "has", "qs", "ssl", "p", "ps", "l", "sys", "less", "ss", "ms", "ar", "bis", "set", "params", "sm", "args", "sl", "sp", "aunts", "m", "sam", "service", "stats", "xs", "sie", "comm", "es", "b", "ls", "pers", "als", "ts", "its", "changes", "gs", "ers", "g", "conf", "tes", "se", "settings", "rs", "t", "ns", "serv", "ins", "S", "sw", "ess", "cs", "js", "aws", "series"], "saddr": ["saddress", "paddress", "svaddr", "pattr", "Sdr", "sqptr", "Sattr", "Saddr", " sdr", "paddr", "ssrc", "sqconn", "tdr", "sptr", "sattr", "psrc", " sconn", " sref", "sconn", " saddress", " sptr", "svconn", "sref", "taddress", "Saddress", "svptr", "sdr", "Ssrc", "svref", "sqref", "sqaddr", "taddr"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n", "idx": 1194, "substitutes": {"env": ["proc", "stack", "w", "environment", "buf", "window", "v", "bar", "web", "context", "e", "def", "info", "name", "en", "end", "code", "cb", "vs", "gear", "txt", "disk", "cv", "dev", "uv", "h", "buffer", "ev"]}}
{"project": "qemu", "commit_id": "b591dc59bc98ee558db4ca512aa117748ebfdeef", "target": 0, "func": "static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n", "idx": 1215, "substitutes": {"s": ["spec", "sg", "stats", "n", "bs", "qs", "ses", "comm", "es", "b", "c", "ls", "p", "its", "ps", "i", "l", "gs", "is", "v", "sys", "st", "ops", "less", "ss", "conf", "g", "ims", "ms", "se", "source", "sv", "os", "fs", "ds", "a", "vs", "set", "sts", "ats", "so", "times", "t", "ns", "rs", "state", "sb", "S", "ins", "h", "sw", "sq", "z", "cs", "hs", "aws", "js", "m", "ex"], "temp": ["test", " Temp", "time", "Temperature", "tr", "cell", "c", "wr", "cu", "pt", "mod", "max", "cum", "type", "vt", "nom", "emp", "current", "deg", "perature", "unt", "coord", "ac", "set", "dat", "t", "tim", "tar", "perm", "size", "unc", "tc", "ptr", "pre", "tem", "tmp", "id", "typ", "level", "m", "fac", "Temp"], "ts": ["ports", "tp", "stats", "TS", "bs", "tt", "ics", "nt", "tr", "Ts", "td", "ls", "pt", "als", "opt", "ret", "alt", "its", "ps", "vt", "tv", "mint", "te", "uts", "gs", "out", "ops", "gt", "ss", "tz", "tl", "tn", "tes", "ms", "ols", "outs", "ims", "os", "acs", "fs", "vs", "sts", "ats", "ta", "fts", "ots", "times", "t", "tar", "rs", "ns", "tis", "ins", "mt", "tc", "amps", "ptr", "cs", "hs", " t", "tx", "js", "wt"]}}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n", "idx": 1227, "substitutes": {"device": ["test", "spec", "query", "display", "volume", "error", "path", "devices", "block", "model", "remote", "Device", "family", "product", "mobile", "controller", "pad", "description", "connection", "number", "android", "template", "command", "image", "DE", "driver", "document", "pod", "network", "link", "serial", "location", "position", "pe", "component", "drive", "resource", "disk", "module", "dev", "feature", "package", "interface", "address", "phy", "hid", "buffer", "mode", "directory"], "has_base": [" has_back", " has_bas", "has_based", " has_based", "has_bas", "has_back"], "base": ["ase", "bound", "bp", "bi", "support", "bas", "use", "absolute", "only", "unit", "batch", "b", "used", "remote", "family", "local", "p", "bal", "type", "real", "stable", "shell", "create", "bid", "bare", "bar", "relative", "based", "prefix", "template", "reverse", "kit", "image", "common", "file", "bit", "name", "source", "area", "force", "handle", "br", "server", "bottom", "background", "Base", "full", "last", "profile", "phrase", "alias", "root", "extra", "address", "id", "chain", "buffer", "basic", "back", "pa"], "errp": [" errpad", "lerpa", "scorepc", " errps", " erp", "errpp", "eorpart", "errpa", "eorps", "errorpc", "eorpad", "scorepp", "lerpad", "errorpar", "rerP", "errpc", "rerp", "errpat", " erpad", " erpp", "errps", "errorps", "lerp", "rerpad", "lerP", "scoreps", "eorp", " erps", " errpat", "rrp", " errpc", " erpat", "errorp", "scorep", "errpar", "errpad", "scorepar", "rrpad", "errP", "rrpart", " errpa", " errpp", " errpar", "scorepat", "errpart", " erpart", "rerpa", "rrps", " errP"], "bs": ["s", "BS", "bp", "stats", "bi", "iss", "bl", "bas", "lbs", "qs", "eb", "b", "bps", "pb", "ls", "bus", "bh", "bal", "ts", "its", "bo", "ps", "bn", "gs", "is", "sys", "bc", "socket", "bm", "bed", "cks", "obs", "bos", "bes", "outs", "aos", "ms", "ctx", "bis", "fs", "ds", "bu", "vs", "cb", "sts", "gb", "rs", "ns", "bits", "sb", "bb", "hz", "obj", "cs", "js", "ubs", "ubis", "aus"], "base_bs": ["b_bs", "base_cs", " base_bits", "base_base", "base_abs", "base_ls", " base_base", "relative_bs", "base_ts", "relative_BS", " base_abs", "base_BS", "base_bis", " base_bb", "relative_js", "relative_bis", "b_ls", "b_cs", "base_js", " base_ns", "b_bits", "base_bits", "base_ns", "base_bb", " base_ts"], "local_err": ["local____err", "specific____err", " local_cfg", "local_r", " local_sys", "specific____error", "local____notice", "local__r", "local_order", "specific_err", " local_attr", "local_er", "local_diff", "local42attr", " local_r", "specific____order", "specific_error", "localingdiff", " local_error", "local42cfg", "local__err", "localingerr", " local_er", "specific____notice", " local_diff", "specific_notice", "local_rr", "local_error", "local_cfg", "specific_order", "local_attr", "local____order", " local_rr", "local42er", "local42err", "local_sys", "local_notice", "localingsys", "local____error", "local__rr", "localinger", "local__error"]}}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF &&\n\n        msi_init(dev, 0, 1, true, false) >= 0) {\n\n        /* TODO check for errors */\n\n        s->msi_in_use = true;\n\n    }\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 1277, "substitutes": {"dev": ["nt", " device", "devices", "av", "ve", "v", "draw", "conn", "ds", "go", "er", "tech", "home", "h", "hw", "cmd", "DEV", "scan", "test", "app", "var", "md", "att", "req", "pad", "window", "dd", "def", "cam", "os", "ver", "vp", "debug", "ram", "des", "desc", "ad", "pro", "stick", "Device", "p", "sd", "out", "ctx", "serial", "develop", "Dev", "disk", "phy", "hid", "de", "spec", "proc", "dem", "det", "w", "pt", "mem", "g", "conf", "driver", "gu", "ev", "adv", "serv", "device", "sw", "raw", "o", "db"], "errp": ["errP", "erP", "errr", "rr", "err", "erp", "rP", " errP", "rp", " errr"], "d": ["de", "ad", "n", "dn", "dh", "b", "c", "di", "w", "r", "p", "sd", "v", "e", "D", "g", "ds", "dt", "t", "dm", "h", "dr", "f", "m", "j", "data", "db"], "s": ["an", "services", "i", "is", "v", "shared", "sync", "ies", "store", "fs", "ds", "er", "gets", "bits", "sb", "y", "h", "sq", "hs", "sports", "bs", "ses", "ares", "ties", "ims", "sv", "os", "vs", "sts", "ats", "as", "session", "des", "details", "j", "ports", "qs", "utils", "ssl", "p", "sd", "ps", "l", "sys", "ss", "ms", "bis", "set", "params", "args", "sp", "mods", "sa", "m", "bes", "k", "ex", "sam", "spec", "stats", "ads", "self", "comm", "es", "b", "ls", "w", "als", "ts", "its", "changes", "gs", "g", "se", "tes", "settings", "rs", "ns", "t", "serv", "ins", "S", "obj", "sw", "f", "cs", "js", "aws"]}}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n", "idx": 1290, "substitutes": {"s": ["sports", "qs", "ses", "es", "c", "ares", "ls", "r", "ains", "p", "ts", "ps", "gs", "is", "sys", "sol", "less", "ss", "ers", "parts", "ims", "ms", "sis", "sv", "ies", "fs", "ds", "a", "set", "sts", "ats", "rs", "ns", "t", "as", "rates", "sb", "S", "ins", "h", "sl", "sq", "hs", "js", "aws"]}}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "func": "FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n", "idx": 1307, "substitutes": {"nbits": ["numbits", " nparts", "nnbits", "inbits", "numbool", "nnbool", "inparts", "nbbytes", "numbytes", "nbparts", "nnbytes", "inints", "inbytes", " nints", "numints", "nnints", "nbints", "nints", "nparts", "nbytes", " nbool", "nbool", "nbbits", " nbytes"], "inverse": [" inversion", "edInverse", "inversible", " inhibit", "dinvert", "dinhibit", " inversible", "edInvert", "Inversion", "dinverse", "Inverse", "Inverted", "inhibit", "Inhibit", "invert", "dinversible", "inverted", " inverted", "inversion", "edInversion", " invert", "Invert", "Inversible", "edInverted"], "s": ["n", "stats", "bs", "q", "self", "comm", "es", "b", "c", "ls", "d", "w", "ast", "r", "als", "p", "ts", "its", "ps", "i", "l", "gs", "v", "is", "sys", "x", "less", "ss", "g", "sc", "sv", "os", " is", "fs", "ds", "a", "sts", "ats", "t", "ns", "rs", "as", "serv", "sb", "S", "h", "sq", "f", "cs", "hs", "js", "m", "j", "has"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1308, "substitutes": {"var": ["spec", " cur", "ars", "iter", "self", " tmp", " variable", "array", "star", "map", " bar", "type", "iv", "variable", "bar", "v", " Var", "par", "name", "ar", " vec", "prev", "ac", "addr", "widget", "car", "val", "serv", "node", "ver", "bb", " val", "obj", "tab", "ptr", "vc", "Var", "fac"]}}
{"project": "FFmpeg", "commit_id": "89325417e7b33f4b08171d9d609c48662d96b2d3", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for SIZ\\n\");\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {\n        avpriv_request_sample(s->avctx, \"Large Dimensions\");\n        return AVERROR_PATCHWELCOME;\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              ncomponents);\n        return AVERROR_PATCHWELCOME;\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents);\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n    if (i == possible_fmts_nb) {\n        if (ncomponents == 4 &&\n            s->cdy[0] == 1 && s->cdx[0] == 1 &&\n            s->cdy[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;", "idx": 1318, "substitutes": {"s": ["n", "sg", "ants", "services", "ags", "ords", "is", "ops", "parts", "ies", "fs", "ds", "eps", "er", "gets", "bits", "sb", "locks", "sq", "hs", "sports", "bs", "ses", "c", "status", "styles", "_", "uint", "def", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "ids", "des", "details", "ports", "qs", "jpg", "erences", "new", "uploads", "states", "png", "ps", "comments", "l", "sys", "terms", "less", "ss", "tests", "ms", "my", "bis", "set", "params", "state", "rates", "args", "us", "mods", "sam", "stats", "ads", "comm", "results", "es", "ls", "sets", "pers", "als", "ts", "its", "changes", "gs", "g", "ers", "conf", "tes", "acs", "rs", "ns", "t", "serv", "ins", "S", "cs", "err", "js", "aws"], "i": ["phi", "I", "bi", " v", " j", " m", "c", "ii", "ati", "mi", "im", "p", " mi", " bi", "ip", "ai", "v", "pi", " pi", "xi", " ti", "it", " ii", "si", "ci", "ti", "m", "j"], "ncomponents": ["ncpixels", "ncplements", "ncomports", "dndiffients", " ncompensions", " ncomports", "nCompients", "nCompaints", "ncompensions", "Ncompensions", "ncompresses", "ndeeports", " nCompaints", "ncomplements", "ncompones", "ncomonent", "ncompients", "numcpients", "nompixels", "nCompensions", "dncompients", "ncommlements", "dncomponents", "ncponents", "ncpients", "nComponents", " nompients", "ncommients", "nComports", "ncomients", " ncompients", "ncpensions", "Ncomonents", "dncompresses", " nComponents", "nomponent", "dndiffonents", "dndifflements", "ncomponent", "ncompaints", "ncompixels", "ncports", "ncomensions", "numcpensions", "nCompixels", "ndeepones", " nomports", " ncompaints", "nCompones", "numcompensions", "Ncompones", "ncomorts", "numcomponent", "nomponents", "ndiffients", " nomponents", " ncomplements", "nompensions", "ndiffonents", "nomports", "nComplements", "nexplements", "dncomplements", "nomplements", " nompixels", " nComplements", "Ncomports", "ncomonents", " nCompensions", "Ncomensions", "nompresses", "numcponents", "Ncomones", "ncommonents", "numcponent", "Ncomponents", "Ncomorts", "nompients", "nexpensions", "numcomponents", "ndifflements", "ncpaints", "nexpaints", "ndiffresses", "nexponents", "ncommresses", " ncompixels", "numcompients", "dndiffresses", "ncomones", "ndeepensions", "ndeeponents", "ncponent"], "possible_fmts": ["possible__fmters", "possible__fmcs", "possible_nmats", "possible_fmters", "possible_fmcs", "possible__nmcs", "possible_nmts", "possible_mters", "possible_cmcs", "possible__nmts", "possible__fmats", "possible_mats", "possible_cmters", "possible__nmats", "possible__nmters", "possible_cmts", "possible_mcs", "possible_nmcs", "possible_fmats", "possible_nmters", "possible_cmats", "possible__fmts", "possible_mts"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "substitutes": {"job": ["dq", "gov", "work", "org", "build", "batch", "jump", "b", "cell", "block", "jobs", "jam", "map", "Job", "band", "row", "web", "jj", "journal", "ob", "command", "image", "queue", "obs", "jp", "low", "group", "jar", "task", "process", "lock", "node", "hub", "cmd", "j", "db"], "speed": ["sports", "spec", "time", "peed", "length", "shock", "ly", "status", "rank", "start", "sk", "slow", "capacity", "frequency", "sum", "fps", "delay", "density", "send", "percent", "spe", "rate", "sex", "distance", "command", "power", "score", "ss", "gain", "performance", "wage", "port", "seek", "kick", "force", "limit", "fast", "when", "priority", "powered", "size", " speeds", "sw", "gravity", "scale", "mph", "weight", "shape", "EED", "efficiency", "species", "Speed"], "errp": ["ererping", " erp", "ererpar", "errping", " errbp", "ererP", "ererp", " erbp", "iterp", "ererbp", "errpar", " erP", "iterP", " errping", "errP", " erpar", " errpar", "iterping", " errP", "errbp"], "s": ["bs", "q", "b", "c", "ls", "r", "p", "ts", "ps", "is", "gs", "v", "sys", "ss", "g", "sc", "ms", "sv", "fs", "ds", "a", "rs", "ns", "sm", "t", "sb", "S", "h", "sl", "sq", "f", "cs", "sp", "hs", "js", "m", "j"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_int(int *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n\n        else\n\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n\n        return;\n\n    }\n\n\n\n    extend97_int(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n}\n", "idx": 1338, "substitutes": {"p": ["pn", "ist", "n", "bp", "tp", "app", "np", "php", "pd", "q", "up", "post", "new", "c", "pb", "P", "d", "pt", "dp", "hp", "pr", "at", "cache", "mp", "cp", "ps", "pad", "pc", "ip", "fp", "out", "l", "ap", "x", "pi", "jp", "g", "par", "pp", "ar", "lp", "it", "a", "params", "pm", "pe", "op", "t", "perm", "vp", "pg", "progress", "pre", "pkg", "f", "wp", "sp", "xp", "j", "result", "pa"], "i0": ["xi0", "ci0", "iuStart", "ti000", "pi90", "i25", "iu1", "e1", "i2", "pi2", "di00", "pi25", "iator", "iStart", "ii000", "ci00", "li0", "ti00", "ui00", "bi00", "oi0", "bi0", "ii1", "zi1", "zi0", " i00", "xi00", " i50", "i50", "si00", "oiStart", "piator", "di000", "iiZero", "si50", "ci2", " i000", "ci50", "pi0", "ui000", "si0", "e90", "oi25", "ip00", "ui0", "ii0", "e0", "i90", "ini0", "ti1", "oi1", "e2", "li1", "ii00", "piStart", "iZero", "ip0", "pi00", "iarg", "ti0", "di0", "ini00", "i000", "iu0", "li000", " iZero", "pi1", "ip000", "ini000", "li00", "i00", "bi1", "xi000", "pi000", " iator", "ziator", "iu25", "xi1", "ci1", "si1", "biarg", "xiarg", "iiarg", "ci90", "xiZero"], "i1": ["xi0", "is0", "ic0", "is001", "int1", "ri0", "ic100", "i91", "ai91", " i91", "ai001", "ui1", "i2", "pi2", " i001", "ri100", " i4", "di1", "is1", "li0", "li001", "hi1", "hi91", "ai1", "oi127", "ione", "mi001", "oi11", "inted", "uiOne", "lied", "iob", "ic2", "diOne", "pi0", "icob", " iob", "xi91", "li127", "ui0", "liOne", "ic001", "ri001", "li4", " i2", "pi001", "li1", "oi1", "int127", "isone", "oied", "li91", "ic1", "li11", "ui4", "i127", "di0", "di91", "ied", "i4", "mione", "ri1", "xi001", "pione", "iOne", "i001", "pi1", "int11", "piob", "mi1", "xi1", "mi0", "li100", "hi001", "ui91", "i11", "i100"], "i": ["oi", "cli", "iri", "uri", "mi", "ni", " si", " mi", "ind", " I", "ai", "ei", "is", "v", "ij", "ic", "it", "go", "si", "to", "er", "ie", "il", "y", "id", "ti", "io", "phi", "iu", "bi", "hi", "init", "ql", "q", "ui", "c", "di", "status", "x", "fi", "ini", "zi", "ik", "xi", " ti", " ii", " vi", "multi", "ri", "j", "I", "ogi", " li", "point", "asi", "im", "ki", " bi", "iii", "ip", "key", "ix", "ci", " ni", "us", "ico", "gi", "m", "s", "iy", "li", " j", "ia", "ii", "ji", "\u0438", "u", "pi", "in", " pi", "g", "me", "qi", "gu", "t", "f", "ski", "o"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n", "idx": 1341, "substitutes": {"dst": ["dbsrc", "ddlist", "pict", "pst", " dlist", "pST", " dST", " dsrc", "dlist", "dST", "ddend", "dbst", "stict", "dend", "ddsrc", "stST", " dict", "stst", "stout", "dsrc", "dblist", " dend", "pout", "dict", "ddst", "dout", " dout", "dbend"], "src": ["s", "inst", "supp", "null", "ipl", "input", "str", "rc", "sec", "usc", "rb", "cur", "hl", "dest", "r", "rect", "rl", "bh", "req", "iv", "img", "aux", "st", "ur", "sys", "in", "secure", "sc", "source", "copy", "sr", "times", "rs", "sur", "cont", "sb", "ins", "usr", "ptr", "sl", "sq", "tmp", "ch", "ctr", "config", "RC"], "i": ["oi", "cli", " multi", "mi", "ind", " I", "ai", "v", "is", "ei", "ij", "ic", "it", "si", "y", "h", "json", "id", "ti", "io", "phi", "iu", "bi", "init", "ui", "batch", " m", "di", "status", "x", "ini", "jp", "zi", "ims", "xi", " ti", "ami", " ii", "ma", "index", "multi", "chain", "sim", "ri", "j", "I", "his", "uli", "im", "ki", "p", "gl", " bi", "l", "ip", "ms", "my", "ix", "ci", "span", "gi", "m", "ex", "s", "li", "b", "ia", "ii", "ji", "\u0438", "e", "pi", " pi", "me", "qi", "t", "o"]}}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n", "idx": 1351, "substitutes": {"errp": ["diep", " errps", "errpp", "errorpb", "diepb", "excpb", "errpa", "errpb", "rrpp", "rrpb", "excpa", "errps", "errorps", "diesp", " errsp", "rrp", "errorp", "errorpp", " errpb", " errpa", " errpp", "errsp", "diepa", "excp", "rrps", "excsp"], "fid": ["dq", "fovid", "orfid", "fdID", "tfidem", "FId", "fenid", "lfId", "lfID", "foid", "orfpid", "foId", " fpid", "fenq", "fcmd", " fvid", " fbegin", "did", "fduid", "fidem", "faccmd", "Fidem", "confcmd", "tfpid", "hpid", "fq", "fbid", "fdid", "fuid", "fpid", " fId", "fdq", "lfcmd", "fvid", " fbid", "fbegin", "fenID", "Fid", "Fpid", "facid", "confdid", "facdid", " foid", "tfid", "lfdid", "tfoid", " fidem", "Fbegin", "duid", "facID", "FID", "lfid", "fId", "orfbegin", "Foid", "hId", "lfbid", "dID", "orfId", "fID", "confid", "hid", "lfvid", "hID", "fenuid", " fID", "confID", "fobid"]}}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n", "idx": 1360, "substitutes": {"dev": ["de", "ad", "test", "spec", "pro", "proc", "dem", "nt", "md", "tr", "att", "d", "th", "w", "p", "vt", "pad", "ve", "mem", "def", "dd", "cam", "doc", "go", "develop", "res", "Dev", "serv", "device", "ver", "wd", "hw", "des", "env", "cmd", "ch", "DEV", "priv", "off", "data", "ev"], "errp": ["errpre", "errpp", "nerpre", "derP", "errping", "derp", " Errpp", "ererp", "errorpc", " ErrP", "nerp", "errpc", "errorpre", "ererpre", " Errping", "errorp", "nerpp", "errorpp", "ererpc", " errping", "errP", "derping", "derpp", "ererpp", " errpp", "nerpc", " Errp", " errP"], "vdev": ["vev", " vev", " vdat", "mev", "vdata", "Vdat", " vdata", "vtdev", "vardev", "vtdevice", "varev", "vtev", "Vdev", "mdata", "vtdata", "vardat", "mdev", "Vdata", "vdevice", "vdat", "vardata", " vdevice", "mdevice", "Vev"], "v": ["n", "var", "q", "b", "c", "d", "w", "r", "p", "av", "vt", "V", "i", "tv", "l", "u", "x", "e", "g", "sv", "vs", "t", "ver", "vp", "uv", "h", "y", "cv", "z", "f", "vm", "vc", "m", "j", "ev"], "s": ["sam", "n", "bs", "q", "b", "c", "ls", "w", "p", "ts", "ps", "i", "gs", "is", "ss", "sv", "fs", "vs", "sts", "ats", "t", "ns", "rs", "state", "sb", "S", "h", "us", "sl", "f", "cs", "sp", "m"]}}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n", "idx": 1373, "substitutes": {"s": ["n", "qs", "ses", "comm", "b", "c", "ls", "d", "r", "p", "ts", "ps", "i", "gs", "v", "e", "less", "in", "ss", "sv", "os", "fs", "ds", "a", "sts", "ats", "t", "ns", "rs", "as", "ins", "S", "sb", "sq", "z", "f", "cs", "hs", "js", "aws", "m"], "pkt": ["mqt", "ppqt", " packet", "pet", "packet", "met", "ipkt", "mkt", "ppacket", "ppet", "ipqt", "ppkt", " pqt", "pqt", "ipacket", "macket", " pet", "ipet"], "ipmovie": ["hipjob", "ipfilm", "IPMovie", " ipMovie", "ippMovie", "ipjob", "ippmovie", "ippvideo", "hipmovie", "IPfilm", "irage", "ipMovie", "IPmovie", "ipprage", "ifilm", "hiprage", "IPvideo", "imovie", " ipvideo", "ipvideo", " ipfilm", "ippjob", "iprage", "ippfilm", "ijob", "hipfilm"], "pb": ["ib", "bp", "tp", "fb", "ab", "pool", "np", "eb", "orp", "batch", "uf", "rb", "bps", "bh", "xb", "p", "mp", "pan", "cp", "buf", "wb", "pc", "fp", "ob", "jp", "pp", "ctx", "apy", "lp", "tk", "cb", "pm", "PB", "gb", "nb", "lb", "pl", "sb", "vp", "bj", "ub", "pkg", "wp", "typ", "pa"], "ret": ["rets", "hash", "nt", "re", "tr", "prot", "rest", "pas", "deg", "dt", "resp", "Ret", "val", "cmd", "off", "prop", "alf", "str", "del", " alt", "rep", "ert", "att", "status", "at", " fut", "alt", "pret", "def", "rev", "ft", "gt", "ter", "jp", "tn", "num", "ben", "aj", "cont", "mt", "desc", "xt", "eth", "ext", "cat", "nz", "Return", "try", "arg", " Ret", "aux", "out", "rt", "elt", "RET", "usr", "dr", "result", "reply", "rem", "flag", "det", "pat", "reason", "summary", "vet", " res", "mem", "fun", "arr", "reset", "res", "t", "cert", "ref", " RET", "red", "print", "back"]}}
{"project": "FFmpeg", "commit_id": "46e3883519b7592e946258c68d072abd89e583c8", "target": 1, "func": "static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)\n\n{\n\n    int samples    = s->packet.frame_duration;\n\n    int redundancy = 0;\n\n    int redundancy_size, redundancy_pos;\n\n    int ret, i, consumed;\n\n    int delayed_samples = s->delayed_samples;\n\n\n\n    ret = opus_rc_init(&s->rc, data, size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* decode the silk frame */\n\n    if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        if (!swr_is_initialized(s->swr)) {\n\n            ret = opus_init_resample(s);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n\n\n        samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output,\n\n                                            FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),\n\n                                            s->packet.stereo + 1,\n\n                                            silk_frame_duration_ms[s->packet.config]);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error decoding a SILK frame.\\n\");\n\n            return samples;\n\n        }\n\n        samples = swr_convert(s->swr,\n\n                              (uint8_t**)s->out, s->packet.frame_duration,\n\n                              (const uint8_t**)s->silk_output, samples);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error resampling SILK data.\\n\");\n\n            return samples;\n\n        }\n\n\n        s->delayed_samples += s->packet.frame_duration - samples;\n\n    } else\n\n        ff_silk_flush(s->silk);\n\n\n\n    // decode redundancy information\n\n    consumed = opus_rc_tell(&s->rc);\n\n    if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8)\n\n        redundancy = opus_rc_p2model(&s->rc, 12);\n\n    else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8)\n\n        redundancy = 1;\n\n\n\n    if (redundancy) {\n\n        redundancy_pos = opus_rc_p2model(&s->rc, 1);\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID)\n\n            redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2;\n\n        else\n\n            redundancy_size = size - (consumed + 7) / 8;\n\n        size -= redundancy_size;\n\n        if (size < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid redundancy frame size.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (redundancy_pos) {\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_celt_flush(s->celt);\n\n        }\n\n    }\n\n\n\n    /* decode the CELT frame */\n\n    if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        float *out_tmp[2] = { s->out[0], s->out[1] };\n\n        float **dst = (s->packet.mode == OPUS_MODE_CELT) ?\n\n                      out_tmp : s->celt_output;\n\n        int celt_output_samples = samples;\n\n        int delay_samples = av_audio_fifo_size(s->celt_delay);\n\n\n\n        if (delay_samples) {\n\n            if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n                av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples);\n\n\n\n                for (i = 0; i < s->output_channels; i++) {\n\n                    s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0,\n\n                                                delay_samples);\n\n                    out_tmp[i] += delay_samples;\n\n                }\n\n                celt_output_samples -= delay_samples;\n\n            } else {\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Spurious CELT delay samples present.\\n\");\n\n                av_audio_fifo_drain(s->celt_delay, delay_samples);\n\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_BUG;\n\n            }\n\n        }\n\n\n\n        opus_raw_init(&s->rc, data + size, size);\n\n\n\n        ret = ff_celt_decode_frame(s->celt, &s->rc, dst,\n\n                                   s->packet.stereo + 1,\n\n                                   s->packet.frame_duration,\n\n                                   (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0,\n\n                                   celt_band_end[s->packet.bandwidth]);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n            int celt_delay = s->packet.frame_duration - celt_output_samples;\n\n            void *delaybuf[2] = { s->celt_output[0] + celt_output_samples,\n\n                                  s->celt_output[1] + celt_output_samples };\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                s->fdsp->vector_fmac_scalar(out_tmp[i],\n\n                                            s->celt_output[i], 1.0,\n\n                                            celt_output_samples);\n\n            }\n\n\n\n            ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n    } else\n\n        ff_celt_flush(s->celt);\n\n\n\n    if (s->redundancy_idx) {\n\n        for (i = 0; i < s->output_channels; i++)\n\n            opus_fade(s->out[i], s->out[i],\n\n                      s->redundancy_output[i] + 120 + s->redundancy_idx,\n\n                      ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx);\n\n        s->redundancy_idx = 0;\n\n    }\n\n    if (redundancy) {\n\n        if (!redundancy_pos) {\n\n            ff_celt_flush(s->celt);\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                opus_fade(s->out[i] + samples - 120 + delayed_samples,\n\n                          s->out[i] + samples - 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          ff_celt_window2, 120 - delayed_samples);\n\n                if (delayed_samples)\n\n                    s->redundancy_idx = 120 - delayed_samples;\n\n            }\n\n        } else {\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));\n\n                opus_fade(s->out[i] + 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          s->out[i] + 120 + delayed_samples,\n\n                          ff_celt_window2, 120);\n\n            }\n\n        }\n\n    }\n\n\n\n    return samples;\n\n}", "idx": 1377, "substitutes": {"s": ["n", "ants", "ags", "is", "v", "ops", "parts", "fs", "ds", "gets", "sb", "h", "sq", "hs", "sports", "bs", "ses", "ions", "c", "ares", "ains", "ties", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "details", "qs", "events", "p", "ps", "comments", "l", "sys", "less", "ss", "ms", "bis", "times", "args", "us", "m", "bes", "spec", "stats", "ads", "xs", "self", "comm", "es", "b", "ls", "als", "ts", "its", "changes", "gs", "g", "conf", "tes", "ows", "settings", "t", "rs", "ns", "serv", "ins", "S", "sw", "cs", "js", "aws"], "data": ["DATA", "input", "empty", "str", "bin", "sample", "bytes", "batch", "new", "d", "r", "p", "buf", "pad", "type", "window", " DATA", "Data", "message", "in", "image", "def", "format", "value", "dat", "base", "text", "ref", "extra", "raw", "rew", "padding", "none", "buffer", "o", "box", "ata"], "size": ["n", "count", "empty", "time", "length", "sample", "bytes", "m", "capacity", "max", "sum", "type", "l", "mem", "offset", "send", "body", "ize", "number", "e", "message", "format", "g", "len", "name", "space", "area", "num", "shift", "too", "to", "fee", "SIZE", "scale", "z", "shape", "padding", "small", "dim", "Size"], "redundancy_size": ["redundantly_size", "redundancy_len", "redundantly_pos", "redundantly_len"], "redundancy_pos": ["redundancies_loc", "redundancy_loc", "redundancies_pos", "redundancies_position", "redundancy_type", "redundancy_position", "redundancies_type"], "ret": ["count", "rets", "iter", "hash", "nt", "re", "tr", "prot", "rest", "ll", "rm", "deg", "limit", "value", "ry", "it", "resp", "Ret", "val", "txt", "net", "cmd", "str", "status", "alt", "pret", "def", "rev", "ft", "gt", "ter", "len", "cb", "last", "mt", "j", "get", "nz", "utils", "response", "try", "arg", " Ret", "out", "sys", "format", "rt", "elt", "reg", "RET", "report", "usr", "result", "rem", "flag", "nl", "summary", "gc", "ts", "mem", "arr", "reset", "url", "res", "t", "ref", "obj", "mb", "f", "print", "back"], "i": ["iu", "I", "n", "init", "b", "ir", "ii", "im", "mi", "r", "p", "ind", "ip", "v", "ij", "pi", "g", "it", "si", "ix", "iat", "t", "index", "f", "id", "m", "j"], "consumed": [" conserved", "Consceived", "reserved", "conserved", "resumption", "resceived", " consented", "Conserved", "coserved", "resented", "consuming", "offsumption", "cosuming", "cosumed", "consumption", "preserved", "offsceived", " consuming", "csumed", "consceived", "offsume", "consented", "csented", "presumed", "Consumed", "offsumed", "presumption", "cosumption", "presume", "Consumption", "resume", "resumed", " consumption", "resuming", "csumption", "Consume", "consume", "cserved"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381, "substitutes": {"queue": ["qu", "dq", "collection", "config", "que", "pool", "q", "batch", "quit", "ques", "topic", "channel", "block", "cache", "buf", "loop", "journal", "message", "client", "consumer", "archive", "grid", "quote", "list", "menu", "line", "file", "space", "store", "server", "cue", "Q", "process", "Queue", "priority", "ue", "module", "command", "processor", "buffer", "required", "complete", "job", "sequence"], "next": ["n", "null", "first", "nl", "gov", "sec", "latest", "seq", "fr", "nt", "self", "normal", "new", "future", "response", "entry", "start", "forward", "gen", "nd", "used", "head", " NEXT", "out", "valid", "missing", "button", "jp", "current", "nil", "info", "network", "ne", "prev", "link", "key", "ng", "success", "code", "set", "going", "data", "to", "fn", "base", "node", "txt", "primary", "index", "public", "tmp", "Next", "net", "EXT", "front", "nn", "j", "result", "job", "sequence", "reply"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)\n\n{\n\n    int   band, result=0, numSubbands, lastTonal, numBands;\n\n\n\n    if (codingMode == JOINT_STEREO && channelNum == 1) {\n\n        if (get_bits(gb,2) != 3) {\n\n            av_log(NULL,AV_LOG_ERROR,\"JS mono Sound Unit id != 3.\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (get_bits(gb,6) != 0x28) {\n\n            av_log(NULL,AV_LOG_ERROR,\"Sound Unit id != 0x28.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* number of coded QMF bands */\n\n    pSnd->bandsCoded = get_bits(gb,2);\n\n\n\n    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);\n\n    if (result) return result;\n\n\n\n    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);\n\n    if (pSnd->numComponents == -1) return -1;\n\n\n\n    numSubbands = decodeSpectrum (gb, pSnd->spectrum);\n\n\n\n    /* Merge the decoded spectrum and tonal components. */\n\n    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);\n\n\n\n\n\n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n\n    numBands = (subbandTab[numSubbands] - 1) >> 8;\n\n    if (lastTonal >= 0)\n\n        numBands = FFMAX((lastTonal + 256) >> 8, numBands);\n\n\n\n\n\n    /* Reconstruct time domain samples. */\n\n    for (band=0; band<4; band++) {\n\n        /* Perform the IMDCT step without overlapping. */\n\n        if (band <= numBands) {\n\n            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);\n\n        } else\n\n            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));\n\n\n\n        /* gain compensation and overlapping */\n\n        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),\n\n                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),\n\n                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));\n\n    }\n\n\n\n    /* Swap the gain control buffers for the next frame. */\n\n    pSnd->gcBlkSwitch ^= 1;\n\n\n\n    return 0;\n\n}\n", "idx": 1404, "substitutes": {"q": ["qu", "k", "dq", "eq", "qs", "query", "c", "m", "w", "p", "ck", "v", "u", "qq", "g", "qi", "o", "Q", "iq", "ix", "t", "qt", "h", "pkg", "sq", "ch", "Query", "aq"], "gb": ["bt", "vg", "sg", "fb", "vd", "kb", "binary", "gnu", "cgi", "eb", "gd", "Gb", "bytes", "hm", "bg", "cfg", "rb", "gh", "pb", "rg", "html", "rect", "gc", "py", "bn", "img", "asm", "gs", "cm", "bm", "bf", "gt", "gif", "fc", "g", "cz", "cb", "nb", "hub", "sb", "bb", "goo", "hz", "GB", "bd", "cv", "mb", "eg", "raw", "phy", "um", "gg", "tg", "gm", "cd", "db", "io"], "pSnd": ["pSND", "pEsnt", "pCsond", "pkgInsnt", "pcNnd", "pSwin", "pSetgn", "pSysvd", "pIndi", "pNvd", "pkgInsnd", "pWinond", " pSsrc", "PInvd", "pSessionnt", "pCssend", "lpSond", "pSnt", "pCSnt", "pSessiongn", "pSendsend", "pkgSst", "pSnw", "pCind", "pWinnd", "pInsst", "pInsfd", "pmSchend", "PRsnd", "jSnd", "pSendnow", "pcNnt", "pPsnt", "pInsond", "pScond", "pDessrc", "pSsrc", "pCnd", "pcNgn", "pSst", "pInnt", " pSND", "pInND", "pSendND", " pSetnd", "pmSst", "pSourceold", "pLnt", "pkgSnt", "pcSgn", "pCND", "expSendnd", "lpScond", "pSdi", "pSchefd", "pkgSond", "pInsnow", "PSst", "pSetind", "pSendond", "pRsND", "pkgInsond", "pWinst", "pSessionND", "jRsND", "pSignnw", "pDesst", " pSetND", "pSendst", "pLst", "pSysnt", "PRsst", "pUnd", "pSetld", " pSold", "pSnow", "lpSendnd", "pRssrc", "pRswin", " pSetnt", "pAsssend", "expSnd", "pInond", "pSetnt", "pSendcond", "pmSchedd", "pNnt", "pUst", "pcSnt", "pSsend", "jRsind", "jSnt", "lpSendnow", "pCsend", "pmSnd", "pcSnd", "pSetsend", "pUond", "lpSnow", "expSND", "pSld", "pInnd", "lpSendond", "pSetsd", "pAsscond", "lpSsend", "pSfd", "pRsnt", "jRsnt", "PSetgn", "pCSwin", "PSnt", "pSessiondi", "pCnt", "PInND", "pmSchest", "PSnd", "pSignnow", "pSchend", "pRsst", "pSgn", "pSetst", "lpSendcond", "pcSvd", "pSetND", "expSst", "expSendsd", "lpSnd", "pSourcest", "pSignst", "pSysgn", "pEsnd", "pSchedd", "pmSdd", "pAssnd", "pWinsend", "pSunow", "expSendst", "pNgn", "pSourceND", "pSessionnd", " pSond", "pSysnd", "pCsst", "pCSnd", "PSetnd", "pSourcend", " pSnw", "pNSvd", "pNSst", "pSessionvd", "pEsND", "PSgn", "PRswin", "jRsnd", "pSchest", "pSetold", "pSunw", "lpSst", "pCsnd", "pSsd", " pSsend", "PSwin", "pcNvd", "pmSfd", "PSetst", " pSld", "pCSst", "pDesnd", "pSust", "pSvd", "expSendND", "PInnd", "pInvd", "pUsend", "pAssst", "jSND", " pSst", "pNSND", "pEssend", "pInssend", "pSetnd", "PSND", "jSind", "pmSchefd", "pLnd", "pkgInsst", "pSund", "pRsind", "pSind", "pNnd", "pSendsd", " pSetsend", "pNSnd", "pkgSnd", " pSdi", "pPsst", "pSond", " pSnt", "pDesND", "PInst", "lpSendst", "pInsdd", "pInst", "pInsnd", "pInsnt", " pSnow", "pSignnd", "pRsnd", "pPssend", "pSendnd", "expSsd", "lpSendsend", "PSetnt", "PRsnt", "pSdd", "PSvd", "pLgn", "pPsnd", "pSold"], "pOut": ["cpOutput", "pOutput", "mIn", " pIn", "cpout", "mout", "PIn", " pOutput", "POut", "pIn", " pout", "cpOut", "pout", "Pout", "mOut", "cpIn", "POutput"], "channelNum": ["chanNUM", " channelnum", "channelNUM", " channelMon", "ChannelMon", " channelNo", "chanMon", "chNumber", " channelNUM", "ChannelNum", "chanNum", "channelnum", "channelNumber", "Channelnum", "channum", "chNo", "chanNo", "chNum", "chanNumber", "ChannelNumber", "channelNo", "channelMon", "chNUM", " channelNumber"], "codingMode": ["codeMODE", "codingMODE", "CodingMODE", "Codemode", "codeMode", "cachingmode", "cachingMODE", "codeMethod", "CordingMethod", "CodingMode", "CodeMethod", "CordingMODE", "Codingmode", "codingMethod", "cordingmode", "cordingMODE", "cordingMethod", "codemode", "CordingMode", "Cordingmode", "codedMODE", "CodeMode", "codingmode", "codedmode", "codedMode", "codedMethod", "cordingMode", "cachingMode", "CodeMODE", "cachingMethod", "CodingMethod"], "band": ["bug", "day", "bridge", "bound", "slice", "bright", "display", "kt", "product", "unk", "ind", "bid", "plugin", "atch", " channel", " column", "part", "component", "lag", "db", "batch", "art", "ud", "bolt", "row", "power", "pixel", "bit", "ord", "mid", "bands", "card", "index", "ard", "version", "chain", "ide", "und", "plot", "tag", "bin", "step", "cell", "channel", "number", "field", "stage", " coefficient", "dB", "brand", "key", "column", "rad", "node", "disk", " Band", "brain", "slot", "Band", "flag", " step", "work", "jack", "dom", "filter", "b", "byte", "nd", "flash", "d", "block", " bit", "frequency", "board", " bin", "word", "connection", "bind", "ann", "ask", "ond", "cloud", "bd", "weight", "broad", "cd", "rod", "job", "back"], "numSubbands": ["numberSubframes", "numBplanes", "numSubands", " numUBplanes", "numSubplanes", "numUBimages", "nSubplanes", "numberSubimages", "numSuperands", "nSubands", "numSimages", "numBframes", "numSubframes", "numSplanes", "numUBplanes", "numSuperplanes", " numSubplanes", "nSuperplanes", "numsubbands", "nSubimages", "numSbands", "numsubframes", "nSuperands", "numSuperbands", "nSuperbands", "numSands", "numSuperimages", "numberBimages", "numBimages", "nSubbands", "numberBframes", " numUBands", "numSubimages", "nSuperimages", "numUBbands", "numberSubbands", " numSubands", "numsubimages", "numSuperframes", " numUBimages", "numBbands", "numUBands", "numberBbands", " numSubimages", " numUBbands"], "lastTonal": [" lasttonic", "lastETzon", "lastTimeandem", "lastVToned", "lastNonal", "leftETonal", "leftToned", "lastRoned", "lasttonal", "lastNona", " lasttandem", "lastRional", "lastTona", "leftTional", "lastTimeoned", "lastRally", "lastTandem", "lasttonic", "lastRonic", " lastTonic", "lastLional", "lastEToned", "lastRona", "leftETional", "lastTially", "lasttional", " lasttional", " lastToned", "lastRzon", "leftTonal", "lastTones", "lastRones", "lastETonal", "lastLonal", "lastLoned", " lastTally", "leftETzon", "leftEToned", "lasttoned", " lastRonal", "lastNally", " lastRonic", "lasttones", " lastRally", " lastTandem", "lastRonal", "lastETional", " lasttonal", "lastTionic", "lastVTandem", "lastTonic", "lastNional", "lastVTonal", " lastTional", "lastTimeonal", "lastTimeones", "lastTally", " lasttones", "lastLzon", " lastTones", "lastTional", "lastNonic", "lastNones", "lastTiona", "lastVTones", "lasttandem", "lastToned", " lastTona", " lasttoned", "lastTzon", "leftTzon", " lastRona"], "numBands": ["numMards", " numBodes", "numMonents", "numBonents", "numTatches", "numChodes", "numbands", "numNards", "numBeands", " numMards", " numMands", " numbbands", "numbasks", " numbounds", "numBeounds", "numBebands", "numBbands", "numMasks", "numMounds", " numbands", "numChasks", "numBRatches", "NUMBbands", " numBatches", "numBannels", "numMannels", "numChones", "numMands", "numMones", "numTasks", " numMannels", " numBounds", "numBRones", "numChounds", "numChands", "NUMBeounds", "numMbands", "NUMBeonents", "NUMBounds", " numBasks", "numBones", "numBatches", "numBounds", "numBRasks", "numTands", "numTodes", "NUMBeands", "numBodes", "numBeonents", "numChannels", " numbasks", " numBbands", "numChards", "numBasks", " numBannels", "numbounds", "NUMBands", "NUMBebands", "NUMBonents", " numBards", "numBRands", " numMasks", "numChbands", "numbbands", " numMones", " numModes", "numNands", "numTones", "numModes", "numBards", " numBones", "numNasks", "numNannels"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n", "idx": 1420, "substitutes": {"md": ["ad", "dn", "dem", "det", "pd", "dh", "mc", "metadata", "td", "nd", " mm", "met", "hd", "mm", "mk", " dd", "dd", "MD", "mn", "df", "ds", "ld", "sm", "dm", "bd", "mt", "cmd", "od"], "val": ["VAL", "ival", " v", " arg", "lit", " eval", "slot", "pt", "pr", " index", "mod", "arg", "p", "bal", "sel", "vt", "v", "fi", "reg", "num", "col", "ctx", "al", "key", "value", "pol", "si", "loc", " aval", "state", "Val", " value", "ref", "index", "eval", "serv", "vals", "ee", "vol", "pos", " Val"], "env": ["em", "db", "proc", "po", "open", "gov", "ew", "eh", "ten", "ef", "org", "eu", "cur", "nv", "entry", "ped", "environment", "vt", "ec", "buf", "ve", "window", "cal", "v", "bar", "e", "context", "eng", "conf", "ctx", "proven", "en", "conn", "data", "cb", "manager", "msg", "bean", " ens", "state", "txt", "enc", "uv", "cv", "obj", "ptr", "dev", "tmp", "sp", "cmd", "qv", "event", " en", "ah", "ev"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)\n\n{\n\n    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);\n\n    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);\n\n}\n", "idx": 1426, "substitutes": {"dst": ["dtrest", "dhct", "dust", "dstr", "mdstr", "idsrc", " dost", "idust", "pst", "adost", " dsrc", "dtust", "dht", "adht", "ldost", "post", "not", "ddest", " dht", "pht", "dest", "mddest", "idst", " drest", "dddest", "dtst", "dsts", "ldst", "adest", "idot", "mdst", "drest", "dhst", "adst", " dsts", "nst", "dtsrc", "dsrc", "dot", "idrest", " dot", "dhsts", " dstr", "dhost", "ldct", "ddstr", "ldsts", " dct", "ddst", "dost", "pest", " ddest", "nsts", " dust", "dct", " dest", "idsts"], "block": ["proc", "view", "open", "bl", "hash", "blocks", "bin", "filter", "event", "batch", "b", "array", "frame", "model", "bus", "map", "type", "check", "word", "window", "row", "vol", "ip", "bc", "sync", "inv", "bm", "def", "info", "list", "Block", "file", "panel", "group", "BL", "link", "profile", "part", "load", "lock", "zero", "join", "disk", "pack", "range", "chain", "buffer", "config", "label", "bo", "data", "box", "isk"], "stride": [" stripe", "stripe", "dride", "stine", "stize", "strize", "shrice", "strice", "arrhide", "strhide", "stider", "wrider", "STRider", "drride", "trider", "striipe", "errider", "strope", "trize", "strride", "drider", "shrride", "wrice", " strride", " strider", "strime", "STRize", "trice", "striride", "stage", "wrride", "stide", "STRride", "arrider", "shrider", "tride", "shride", "strine", "STRide", "STRine", "STRhide", "strider", "arrride", " strhide", "strage", "striide", " strice", "stime", "STRime", "STRope", " strime", "stipe", "trride", "wride", "STRage", "drice", " strope", " strine", "errride", " strage", "STRipe", "striope", "STRice", "erripe", "arride", "erride", " strize"]}}
{"project": "qemu", "commit_id": "b86160555f8d1fe11d6bcec393e08e645d7e1e8d", "target": 1, "func": "static void integratorcp_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"integrator.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    /* And again at address 0x80000000 */\n\n    memory_region_init_alias(ram_alias, NULL, \"ram.alias\", ram, 0, ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);\n\n\n\n    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}", "idx": 1434, "substitutes": {"args": ["ads", "ars", "images", "limits", "bs", "ants", "users", "md", "comm", "results", "ags", "flows", "values", "atts", "eds", "arg", "ts", "GV", "points", "changes", "aux", "gs", "ras", "terms", "units", "parts", "arr", "apps", "ims", "orders", "objects", "aps", "doc", "yrs", "flags", "settings", "params", "full", "words", "bits", "ins", "yes", "amps", "vals", "locks", "GS", "cmd", "err", "aws", "js", "names", "ams", "Args", "ians", "actions"], "cpu_model": ["pu_module", "memorylemode", "apache00package", "memorylemodel", "pu_model", "cpuLEmode", "apache00model", "cpuLEmodule", "cpu_package", "cpu00package", "cpu00mode", "apache00param", "pu_vector", "cpuitymodel", "pu_string", "cpu_Model", "cpu_library", "cpuitypackage", "cpu00param", " cpu_Model", " cpu_mode", "apache_model", "apache_mode", "memory_mode", "cpu_type", "memory_machine", "memory_type", "cpu00model", "cpulemachine", "apache00mode", "cpuletype", "cpuLEmodel", "pu_library", "cpu_param", "cpuitymode", "pu_mode", "cpu_method", "apache_package", "memory_model", "cpulemodel", "cpu_vector", "cpu_module", "cpuityparam", "cpu_string", "pu_method", "apache_param", "memorylemachine", "cpuLEvector", "memoryletype", "cpulemode", "cpu_machine", "cpu_mode"], "kernel_filename": ["knowledgeityfile", "kernelablefamily", "kernelacsetup", "knowledge_file", "knowledgeityfilename", "kernel_source", "kernel_family", "kernel_file", "kernelablefilename", "knowledge_model", "kernelacfile", "knowledge_filename", "kernel_setup", "ernel_filename", "kernelitysetup", "kernelacmodel", "knowledgeitymodel", "kernelityfile", "kernelablefile", "kernelacfilename", "kernelitymodel", "kernelablesource", "ernel_source", "knowledgeitysetup", "kernel_model", "kernelityfilename", "ernel_file", "knowledge_setup", "ernel_family"], "kernel_cmdline": ["kernel_cplines", "kernel_bindline", "kernel_bindLine", "kernel_cmdlines", "kernel_cmdLine", "kernel_bindlines", "kernel_commandline", "kernel_commandLine", "kernel_cmdpoint", "kernel_cpLine", "kernel_bindpoint", "kernel_cpline", "kernel_catline", "kernel_commandpoint", "kernel_catlines", "kernel_commandlines", "kernel_catpoint"], "initrd_filename": ["initrb_filename", "initrdistfile", "initrh__directory", "initrb_file", "initrd__directory", "initrdetyfiles", "initrdistfilename", "initrdetydirectory", "initrh_json", "initrb_fn", "initrd__filename", "initrd_file", "initrdetyjson", "initrdistdirectory", "initrdetyfilename", "initrdistfn", "initrd_directory", "initrh__files", "initrh__json", "initrb_directory", "initrd__json", "initrh_filename", "initrd_fn", "initrh_directory", "initrd_files", "initrd_json", "initrh_files", "initrh__filename", "initrd__files"], "cpu": ["computer", "core", "proc", "null", "tp", "cow", "aco", "c", "crypt", "CPU", "cu", "prof", "util", "gc", "cache", "uu", "memory", "cp", "density", "pc", "mem", "aux", "sys", "socket", "pai", "chip", "cn", "linux", "pixel", "ctx", "cam", "os", "uart", "process", "node", "apache", "device", "pu", "phys", "nice", "clock", "gpu", "hw", " CPU", "mu", "processor", "mac", "cum", "bo", "boot", "nic"], "address_space_mem": ["address_space2memory", "address_system_gem", "address_space_mc", "address_space2ram", "address_part_ram", "address_space2mem", "address_system_mem", "address_system_mb", "address_space___reg", "address_part2ram", "address_space_gem", "address_part2mem", "address_part_mem", "address_system_memory", "address_system_reg", "address_space_memory", "address_space_mb", "address_space_ram", "address_space__memory", "address_part_mc", "address_space__mb", "address_space2mb", "address_part2mc", "address_space_reg", "address_space2mc", "address_part_memory", "address_space___gem", "address_part2memory", "address_space___mem", "address_space__mem"], "ram": ["sam", "core", "lam", "ra", "gra", "bin", "mc", "iam", "RAM", "na", "ran", "rank", "gem", "path", "gc", "rum", "memory", "am", "sum", "mem", "program", "row", "sky", "mm", "ras", "rm", "reg", "region", "cam", "ma", "gram", "process", "rain", "tar", "room", "resource", "disk", "mb", "tem", "raw", "hw", "dim", "vm", "ank", "mac", "sim", "Ram", "scan", "ro", "rom"], "ram_alias": ["mem_ias", "rammmshadow", "ram_shadow", "mem_alias", "rammmrole", "mem_ali", "ram_ali", "ram_ghost", "ram_role", "ram_prefix", "rammmalias", "mem_role", "ram_ias", "mem_ghost", "rammmias", "mem_prefix", "mem_shadow"], "pic": ["wic", "pict", "ics", "mc", "peg", "script", " pc", "cu", "oc", "gc", "py", "p", "pc", "sys", "pi", "fi", "picture", "Pict", "fc", "mic", "ic", "cam", "pin", "ac", "ig", "sci", "si", "px", "pl", "arc", "eric", "agic", "pins", "fig", " nic", "sp", "Pic", "iac", "icon", "icc", "nic"], "dev": ["de", "ad", "db", "stick", "pro", "var", "dem", "nt", "d", "w", "van", "Device", "hd", "av", "sd", "pad", "iv", "ve", "mem", "window", "row", "v", "def", "dd", "ow", "cam", "conn", "serial", "ds", "gu", "push", "go", "der", "adv", "Dev", "vo", "serv", "device", "ver", "pu", "disk", "wd", "home", "ptr", "hw", "gpu", "des", "vision", "unknown", "priv", "DEV", "env", "data", "ev", "rem"], "i": ["s", "iu", "I", "n", "bi", "cli", " v", "li", "ui", " j", " m", "c", "di", "ii", "im", "mi", " k", "p", " bi", "\u0438", "ind", " I", "ip", "ai", "v", "ei", "is", "ij", "x", "e", "pi", "in", "ini", " pi", "zi", " di", " l", "ims", "ic", "xi", "ms", "wi", " ti", "ami", " ii", "it", "si", "gu", "a", "ix", "t", "ci", " e", "l", "index", "multi", "y", "us", "z", "ti", "sim", "gi", " x", "m", "j", "ex"]}}
{"project": "qemu", "commit_id": "30c367ed446b6ea53245589a5cf373578ac075d7", "target": 1, "func": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n", "idx": 1435, "substitutes": {"obj": ["attr", "nt", "org", "cmp", "vr", "any", "bh", "p", "av", "bo", "xy", "iv", "oid", "onet", "sys", "inv", "ob", "obs", "ctx", "os", "conn", "it", "t", "object", "vo", "cont", "ref", "act", "vp", "hw", "tmp", "unknown", "Obj", "priv", "cmd", "js", "o", "j", "ex"], "v": ["n", "vim", "q", "vi", "vr", "vu", "b", "c", "m", "d", "w", "r", "p", "vt", "V", "tv", "l", "x", "g", "sv", "conv", "vs", "vp", "cv", "uv", "h", "f", "vm", "vc", "vy", "o", "j", "ev"], "opaque": ["popoxy", "popaque", "buffacity", "popaques", "oplface", "opface", "opacity", "paque", "oaques", "oplaques", "oplaque", "oaque", "popacity", "ooxy", "oplacity", "buffface", "pacity", "pface", "oploxy", "oacity", "opoxy", "buffaque", "opaques"], "name": ["tag", "n", "pro", "attr", "property", "ame", "str", "nam", "cap", "reason", "normal", " names", "san", "comment", "error", "path", "family", "local", "am", "type", "description", "word", "mem", "category", "prefix", "title", "format", "in", "info", " Name", "group", "key", "value", "part", "Name", "qual", "alias", "NAME", "no", "size", "named", "nm", "names", "label", "none", "version", "m", "domain", "data"], "errp": ["attrpt", "ermp", "diep", "derpa", " errm", "errpre", " errps", "derpb", "dieP", "errorr", "diepb", "derP", "derp", "errpa", "errpb", " errr", "ererp", " errpt", "errorpre", "ermphp", "errps", "erp", "errorps", "ermps", "ererphp", "errorphp", "ererpre", "errorm", "attrps", "erm", "errr", "ererps", "attrp", "errorp", "ermpre", "errpt", "errm", "errP", "errphp", " errpb", " errpa", "errorpt", "errorP", "err", "diepa", "attrP", " errP"], "dev": ["de", "proc", "pro", "attr", "dep", "dem", "det", "nt", "md", "nv", "d", "w", "fo", "Device", "av", "sd", "buf", "vt", "ve", "mem", "dis", "def", "eng", "conf", "cam", "os", "conn", "go", "gu", "addr", "Dev", "tech", "device", "ver", "wd", "home", "hw", "des", "unknown", "priv", "desc", "od", "DEV", "env", "ev"], "prop": ["ph", "proc", "pro", "attr", "property", "spec", "po", "prov", "dep", " Prop", "cfg", "pb", "pos", "lit", "m", "pt", "prof", "comp", "pr", "opt", "p", "claim", "cp", "ps", "buf", "def", "kind", "info", "conf", "term", "ctx", "col", "key", "pred", "op", "pkg", "tmp", " props", "pri", "Prop", "cmd", "desc", "priv", "properties", "pid", "ev"], "peers_ptr": ["pelers_p", "peer_ptr", "peers_p", "peersPptr", "peersPpt", "peersPtmp", "pelers_tr", "pelers_arr", "peers_obj", "peers_pt", "peer_obj", "peersPobj", "peer_pt", "peers_tr", "peer_tmp", "peers_tmp", "pelers_ptr", "peers_arr"], "ptr": ["proc", "attr", "eth", "tp", "pend", "rep", "dh", "tr", "vr", "func", "cur", "src", "th", "dest", "pt", "pers", "pr", "ret", "inter", "ts", "pointer", "p", "Ptr", "pad", "iv", "prime", "__", "rev", "kw", "arr", "jp", "port", "ctx", "br", "adr", "addr", "expr", "pointers", "ref", "dr", "hw", "tmp", "sp", "pri", "err", "pert", "inters", "xt", "ctr", "pos"], "local_err": ["local_r", "initial___arr", "local___Er", "local___er", "local2buf", " local_priv", "local_er", "local___msg", "local_buf", "local2r", "local__mr", "local2err", " local_r", "local2priv", "local___err", "localErEr", "local_mr", "initial_err", " local_error", " local_buf", "local2error", "localErarr", "local__err", " local_er", "local___r", " local_mr", "local_priv", "local_rr", "local_arr", "local_error", "localErmsg", "initial___err", "localErerr", " local_rr", "localErpriv", "local_Er", "initial___Er", "local2er", "localErer", "initial_msg", "local___arr", "local___buf", "initial_Er", "local_msg", "local__rr", "initial_arr", "initial___msg", "localErerror", "local__error"], "id": ["tag", " org", "orig", "wid", "Id", "ident", "time", "rid", "vid", "gd", "uid", "did", "ime", "ider", "p", "type", "pad", "ID", "oid", "ip", "bid", "is", " tid", " lid", "peer", "len", " rid", "port", "num", "url", "mid", " mid", "key", "it", "addr", "sid", " pid", " offset", "iden", "fd", "ref", " done", "index", "no", "h", "ick", "ids", " fid", "od", "kid", "hid", "tx", "pid", "ide"], "hubport": ["hubserver", "hostPort", "hubconnection", "homeserver", "busconnection", "hostPORT", "broadport", " hubPORT", "hostport", "ubclient", "homePort", "hubpool", "hubstate", "hostpage", "ubPORT", "broadclient", "hostserver", " hubPort", "homePORT", "hubPort", "hubclient", "homeclient", "ubport", "homepool", "ubpage", "buspage", "ubpool", "homestate", "ubconnection", "busserver", " hubstate", "ubPort", " hubserver", "ubserver", "hostconnection", "hubpage", "ubstate", "broadpool", "busport", "broadserver", "hubPORT", "homeport"]}}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 1439, "substitutes": {"avctx": ["avcomp", "aveproc", "avctl", "averproc", "avectl", "avcontext", "avecc", " avcli", "avconn", "invctx", "avercontext", "invcmd", "averkt", "ravconn", "avercomp", "avereq", "avcpp", " avkt", "avproc", "avecpp", "averreq", "aveconn", "ravproc", "avercmd", "avreq", "ravctx", "ravcpp", "ravcli", "invcontext", " avreq", "avecli", "avcc", "avcli", "avercli", "averconn", " avcontext", "avectx", "avecontext", "avecomp", " avctl", "avercc", "averctl", "averctx", " avcomp", "avekt", "avkt", "ravcc", "invcli", " avcmd", "avcmd", "avercpp"], "s": ["sam", "spec", "stats", "bs", "qs", "comm", "services", "results", "es", "erences", "b", "ls", "pers", "w", "als", "ts", "sd", "ps", "its", "comments", "changes", "l", "gs", "is", "sys", "sync", "ops", "less", "parts", "ss", "g", "ims", "ms", "tes", "sv", "os", "fs", "ds", "eps", "vs", "sts", "ats", "params", "rs", "ns", "bits", "as", "sb", "S", "scl", "ins", "h", "us", "session", "sw", "ess", "sq", "sl", "ass", "cs", "hs", "z", "details", "aws", "js", "has"]}}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n", "idx": 1457, "substitutes": {"chr": ["ichr", " Chor", " chrl", "chrb", "childrl", "Chrb", "echrs", "echr", " chrb", "chor", "ichrt", "cherd", "chR", "echrb", "childR", " Char", "cher", " chrs", "cheor", "chrd", "Chrs", " chR", "ichR", "chrs", " Chrd", "Char", "echar", " Chr", "childrt", " chor", "Chr", "chrt", " chrt", "chrl", "childr", " chrd", "ichrl", "chear"], "s": ["sam", "service", "sports", "n", "spec", "stats", "ports", "bs", "qs", "self", "services", "comm", "es", "b", "ls", "states", "ts", "ps", "changes", "l", "gs", "is", "sys", "sync", "less", "ss", "se", "sv", "store", "fs", "ds", "bis", "set", "vs", "sts", "ats", "so", "rs", "ns", "serv", "args", "sb", "S", "ins", "https", "y", "sl", "sq", "cs", "hs", "details", "js", "m", "j", "client"]}}
{"project": "FFmpeg", "commit_id": "73a60633143b7c51333a0772b45a47282ac445b6", "target": 1, "func": "static int probe_file(WriterContext *wctx, const char *filename)\n\n{\n\n    AVFormatContext *fmt_ctx;\n\n    int ret, i;\n\n    int section_id;\n\n\n\n    do_read_frames = do_show_frames || do_count_frames;\n\n    do_read_packets = do_show_packets || do_count_packets;\n\n\n\n    ret = open_input_file(&fmt_ctx, filename);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n#define CHECK_END if (ret < 0) goto end\n\n\n\n    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));\n\n    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));\n\n    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));\n\n\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        if (stream_specifier) {\n\n            ret = avformat_match_stream_specifier(fmt_ctx,\n\n                                                  fmt_ctx->streams[i],\n\n                                                  stream_specifier);\n\n            CHECK_END;\n\n            else\n\n                selected_streams[i] = ret;\n\n            ret = 0;\n\n        } else {\n\n            selected_streams[i] = 1;\n\n        }\n\n    }\n\n\n\n    if (do_read_frames || do_read_packets) {\n\n        if (do_show_frames && do_show_packets &&\n\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n\n        else if (do_show_packets && !do_show_frames)\n\n            section_id = SECTION_ID_PACKETS;\n\n        else // (!do_show_packets && do_show_frames)\n\n            section_id = SECTION_ID_FRAMES;\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_header(wctx, section_id);\n\n        ret = read_packets(wctx, fmt_ctx);\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_footer(wctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_programs) {\n\n        ret = show_programs(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_streams) {\n\n        ret = show_streams(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_chapters) {\n\n        ret = show_chapters(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_format) {\n\n        ret = show_format(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\nend:\n\n    close_input_file(&fmt_ctx);\n\n    av_freep(&nb_streams_frames);\n\n    av_freep(&nb_streams_packets);\n\n    av_freep(&selected_streams);\n\n\n\n    return ret;\n\n}\n", "idx": 1469, "substitutes": {"wctx": ["rwtxt", "walc", "wacm", "Wcmp", "wdcm", "wordctx", " wtxt", " wcontext", "wkb", "wordcontext", "wscm", "wdkb", "rwlc", " wcmp", "wordcas", "wlc", "watxt", "wsctx", " wcm", "rwcm", "wcmp", "Wcontext", "Wtx", "wordtx", "wdcmp", "rwctx", "wcm", "rwtx", "wtx", "wscmp", "wcas", "wdctx", "wskb", "Wcas", " wcas", " wtx", "rwkb", " wlc", "wcontext", "rwcmp", "Wctx", "wtxt", "wactx", "rwcontext"], "filename": ["ame", "ename", "sbm", "FN", "jpg", "fle", "src", "path", "kl", "png", "username", "kan", "fp", "nom", "prefix", "title", "file", "name", "source", "kj", "fn", "txt", "abl", "Filename", "bol", "FIL", "ln", "fil", "ames", "nm", "til", "directory"], "fmt_ctx": ["ftx_tx", "fmtkcpp", "ftx_obj", "fmtDtx", "fprintf_cpp", "fprintfkctx", "ftx_kw", "firm_resp", "fmt2ctx", "fmtTtx", "fmtDctx", "fmt___cb", "flt_cb", "fprintfkns", "fmtkns", "fmtTtz", "fmt_kw", "fmt_tz", "fmt_conn", "fmt___tx", "firm_ctx", "ftx_conn", "fmtDtz", "fmt2tx", "fmt___context", "fmt_cpp", "fprintf_ctx", "fprintf_ns", "fmt_resp", "fmt_tx", "fMT_context", "fmt___ctx", "ftx_cfg", "fmt_cb", "fmt_obj", "fmt_cfg", "flt_ctx", "flt_context", "fprintfkcpp", "fmt_chan", "fmtkctx", "fMT_ctx", "fmt5ctx", "flt_tx", "fmt_tmp", "fmtTctx", "fmt5conn", "ftx_ctx", "fmt5kw", "fmtktx", "fMT_obj", "fmt_cmd", "fmtTchan", "fprintf_tx", "ftx_context", "fmt_ns", "firm_tmp", "firm_cmd", "fmt_context", "fMT_tx", "fmt5tx", "fmt2context", "fprintfktx", "ftx_cpp", "fmtDchan", "fmt2obj"], "ret": ["rets", "hash", "nt", "re", "tr", "ll", "rm", "__", "deg", "ry", "dt", "value", "resp", "Ret", "val", "net", "cmd", "nr", "att", "status", "alt", "x", "fi", "def", "ft", "gt", "ter", "len", "jp", "cont", "mat", "index", "mt", "xt", "j", "get", "Return", "utils", "try", "arg", " Ret", "out", "rt", "elt", "reg", "set", "RET", "usr", "dr", "result", "rem", "flag", "det", "final", "vet", "gc", "ts", "mem", "arr", "reset", "res", "t", "ref", " RET", "mb", "f", "err", "red", "print", "back"], "i": ["phi", "iu", "I", "oi", "n", "bi", "cli", "iter", "li", "ui", "point", "batch", "c", "di", "ir", "ii", "im", "mi", "uri", "ki", "try", "remote", "p", "inter", "ji", "ind", "ip", "l", "ai", "ei", "is", "ij", "x", "u", "pi", "fi", "in", "ini", "info", "zi", "ic", "ims", "me", "xi", "qi", "it", "si", "ix", "ci", "t", "index", "multi", "y", "z", "f", "id", "ti", "sim", "gi", "ri", "m", "j", "io"], "section_id": ["sector_ids", "section_index", "sector_type", "section_type", "section2id", "room_ids", "section_uid", "sectionityid", "section2name", "section_mid", " section_mid", "sector_uid", "section_name", " section_ids", "section2ids", "sectionityids", "sector_id", "sector_try", "section_ID", " section_ID", "section_ids", "sector_name", " section_name", "section_try", "sector_ID", "room_id", "section_dir", "section2index", "section_num", "sectionitytype", " section_index", "room_num", "room_dir", "sectionitytry"], "selected_streams": ["selected_streamers", "selected_integis", "selected_pathis", "selected_follows", "selected_threadl", "selected_pathS", "selected_streamensions", "selected_sws", "selected_followl", "selected_paths", "selected_threadments", "selected_streameds", "selected_logS", "selected_logs", "selected_swn", "selected_streamments", "selected_followments", "selected_framess", "selected_logensions", "selected_pathn", "selected_Streamensions", "selected_reams", "selected_streamis", "selected_buildeds", "selected_builders", "selected_streamts", "selected_framesl", "selected_Streams", "selected_streamS", "selected_integs", "selected_reamts", "selected_pathensions", "selected_StreamS", "selected_swS", "selected_streamn", "selected_threadeds", "selected_framesments", "selected_threaders", "selected_reamers", "selected_streaml", "selected_reameds", "selected_integS", "selected_buildts", "selected_builds", "selected_integn", "selected_swis", "selected_threadts", "selected_threads"]}}
{"project": "qemu", "commit_id": "51b0c6065aa6e47a47094d73e24be298a4a7f3a1", "target": 1, "func": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    KVMState *s = kvm_state;\n\n    unsigned long size, allocated_size = 0;\n\n    KVMDirtyLog d;\n\n    KVMSlot *mem;\n\n    int ret = 0;\n\n\n\n    d.dirty_bitmap = NULL;\n\n    while (start_addr < end_addr) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n\n        if (mem == NULL) {\n\n            break;\n\n        }\n\n\n\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n\n        if (!d.dirty_bitmap) {\n\n            d.dirty_bitmap = qemu_malloc(size);\n\n        } else if (size > allocated_size) {\n\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n\n        }\n\n        allocated_size = size;\n\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n\n\n        d.slot = mem->slot;\n\n\n\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n\n            ret = -1;\n\n            break;\n\n        }\n\n\n\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n\n                                      mem->start_addr, mem->memory_size);\n\n        start_addr = mem->start_addr + mem->memory_size;\n\n    }\n\n    qemu_free(d.dirty_bitmap);\n\n\n\n    return ret;\n\n}\n", "idx": 1473, "substitutes": {"start_addr": ["start_ord", "startingphys", "end_hash", "target_ord", "start_block", " start_elt", "startingelt", "startlyaddr", "starting_elt", "target_addr", "st_phys", "startlyaddress", "startingaddress", "startlyhandle", " start_address", "start_pad", "startlyhash", "start_pos", "end_handle", "start_ptr", "startptaddr", "startptpos", "end_pos", "st_addr", "startpthandle", "startingaddr", " start_ord", "start_address", "start_map", "startptaddress", "startingpad", "st_address", " start_pad", "start_elt", "end_address", "starting_ord", "start_handle", "target_block", "start_hash", "target_ptr", "start_phys", "starting_addr", "starting_map", "startpthash"], "end_addr": ["endiparp", " end_arp", "endpyres", "endingipaddr", "end_address", "endiploc", "endingiploc", "endablemt", "endipres", "endingipres", "ending_addr", "endingipmt", "endableloc", "endpyloc", "end_date", "endpyaddr", "end_arp", "end_name", "endableaddr", "end_mem", "endipmt", " end_mem", "ending_res", "end_mt", " end_date", " end_address", "endipname", "endpymt", "endableres", "ending_mt", "endipaddr", "ending_loc", "end_loc", "endipaddress", " end_name", "end_res"], "s": ["sam", "n", "spec", "str", "q", "comm", "b", "c", "w", "r", "p", "ts", "ps", "i", "south", "gs", "v", "spe", "sys", "is", "socket", "ss", "g", "space", "sc", "os", "fs", "ds", "sts", "rs", "t", "ns", "state", "sm", "sb", "S", "h", "sl", "sq", "hs", "js", "m", "j"], "size": ["n", "count", "empty", "needed", "use", "length", "bytes", "see", "new", "grow", "export", "capacity", "height", "max", "cache", "sum", "type", "l", "south", "send", "offset", "sh", "ity", "ize", "number", "message", "member", "score", "info", "g", "len", "name", "space", "num", "area", "zone", "en", "news", "scope", "shift", "set", "si", "fee", "t", "zero", "city", "index", "span", "SIZE", "scale", "z", "weight", "address", "sp", "storage", "shape", "sent", "small", "chain", "dim", "Size"], "d": ["de", "ad", "dq", "n", "k", "dn", "debug", "pd", "dh", "md", "gd", "diff", "rd", "did", "b", "di", "td", " dw", "nd", "c", "dl", "w", " dr", "mod", "r", "p", "hd", "sd", "dj", "l", "ind", "v", " dd", "dc", "dd", "def", "D", "ded", "g", "df", "o", "ds", "dt", "ld", "dat", "fd", "dm", "da", "done", "bd", "h", "dict", "dr", "du", "dev", "y", "ed", "z", "f", "dump", "red", "dim", "m", "j", "result", "dx", "db"], "mem": ["nt", "metadata", "mi", "cache", "ind", "rm", "member", "deg", "go", "resp", "val", "txt", "hw", "address", "hist", "pool", "md", "lim", "memory", "sum", "am", "loc", "mat", "known", "mt", "ram", "imm", "sim", "dim", "term", "j", "data", "em", "mc", "emb", "iam", "im", "mm", "arm", "reg", "ms", "Mem", "my", " Mem", "all", "addr", "msg", "sm", "tm", "nm", "mac", "m", "mx", "alloc", "slot", "rem", "sam", "dem", "item", "temp", "gem", "met", "gc", "mp", "mop", "ann", "doc", "t", "tim", "med", "serv", "snap", "mb", "raw", "um", "js", "buff"]}}
{"project": "FFmpeg", "commit_id": "eb465b8c56d455fddf0f4f9f2625e2fe3ff7ea06", "target": 1, "func": "static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],\n\n                   int dst_stride[3], int src_stride[3], int width,\n\n                   int height, uint8_t *qp_store, int qp_stride)\n\n{\n\n    int x, y, i, j;\n\n    const int count = 1<<p->log2_count;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int is_chroma = !!i;\n\n        int w = width  >> (is_chroma ? p->hsub : 0);\n\n        int h = height >> (is_chroma ? p->vsub : 0);\n\n        int stride = p->temp_stride[i];\n\n        int block = BLOCK >> (is_chroma ? p->hsub : 0);\n\n\n\n        if (!src[i] || !dst[i])\n\n            continue;\n\n        for (y = 0; y < h; y++) {\n\n            int index = block + block * stride + y * stride;\n\n\n\n            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );\n\n            for (x = 0; x < block; x++) {\n\n                p->src[i][index     - x - 1] = p->src[i][index +     x    ];\n\n                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];\n\n            }\n\n        }\n\n        for (y = 0; y < block; y++) {\n\n            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);\n\n            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);\n\n        }\n\n\n\n        p->frame->linesize[i] = stride;\n\n        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));\n\n    }\n\n\n\n    if (p->qp)\n\n        p->frame->quality = p->qp * FF_QP2LAMBDA;\n\n    else {\n\n        int qpsum=0;\n\n        int qpcount = (height>>4) * (height>>4);\n\n\n\n        for (y = 0; y < (height>>4); y++) {\n\n            for (x = 0; x < (width>>4); x++)\n\n                qpsum += qp_store[x + y * qp_stride];\n\n        }\n\n        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;\n\n    }\n\n//    init per MB qscale stuff FIXME\n\n    p->frame->height = height;\n\n    p->frame->width  = width;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        const int x1 = offset[i+count-1][0];\n\n        const int y1 = offset[i+count-1][1];\n\n        const int x1c = x1 >> p->hsub;\n\n        const int y1c = y1 >> p->vsub;\n\n        const int BLOCKc = BLOCK >> p->hsub;\n\n        int offset;\n\n        AVPacket pkt;\n\n        int got_pkt_ptr;\n\n\n\n        av_init_packet(&pkt);\n\n        pkt.data = p->outbuf;\n\n        pkt.size = p->outbuf_size;\n\n\n\n        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];\n\n        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];\n\n        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];\n\n        p->frame->format  = p->avctx_enc[i]->pix_fmt;\n\n\n\n        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);\n\n        p->frame_dec = p->avctx_enc[i]->coded_frame;\n\n\n\n        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];\n\n\n\n        for (y = 0; y < height; y++)\n\n            for (x = 0; x < width; x++)\n\n                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];\n\n\n\n        if (!src[2] || !dst[2])\n\n            continue;\n\n\n\n        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];\n\n\n\n        for (y = 0; y < height>>p->vsub; y++) {\n\n            for (x = 0; x < width>>p->hsub; x++) {\n\n                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];\n\n                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];\n\n            }\n\n        }\n\n    }\n\n\n\n    for (j = 0; j < 3; j++) {\n\n        int is_chroma = !!j;\n\n        if (!dst[j])\n\n            continue;\n\n        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],\n\n                      width  >> (is_chroma ? p->hsub : 0),\n\n                      height >> (is_chroma ? p->vsub : 0),\n\n                      8-p->log2_count);\n\n    }\n\n}\n", "idx": 1476, "substitutes": {"p": ["n", "tp", "P", "r", "cache", "cp", "v", "br", "it", "pm", "resp", "pe", "part", "h", "pkg", "xp", "app", "rep", "q", "post", "c", "pb", "at", "dp", "pc", "command", "power", "jp", "vp", "pre", "public", "wp", "bp", "pro", "this", "np", "point", "ps", "l", "ip", "ap", "ping", "info", "current", "pp", "ctx", "op", "patch", "policy", "sp", "m", "pa", "proc", "php", "pd", "self", "up", "page", "b", "d", "local", "parent", "fp", "parse", "g", "lp", "t", "pg", "progress", "f", "o"], "dst": ["idsc", "Drc", " drc", "dsc", "iddest", "dsdest", "Ddest", "dssts", "ddest", "Dsc", "idst", "Dst", "dsts", "lsts", "ldest", "lsc", " dsts", "dsrc", "drc", "Dsts", "lst", " ddest", "dsst", "idsts"], "src": ["s", "inst", "supp", "proc", "via", "stack", "lib", "input", "bs", "rc", "iter", "str", "bin", "seq", "sec", "stock", "target", "dist", "ssl", "cur", "dest", "sn", "comp", "syn", "rect", "rl", "stream", "img", "std", "slice", "sh", "st", "sys", "stat", "reverse", "sync", "config", "in", "secure", "obs", "rt", "sc", "source", "rob", "url", "trans", "host", "addr", "sr", "loc", "rs", "sur", "load", "serv", "content", "sb", "usr", "ins", "ptr", "look", "sl", "tmp", "scene", "desc", "ch", "stab", "ser", "ctr", "sub", "buffer"], "dst_stride": ["dst_encider", "dst_stringider", "dst_strride", "dst_stringride", "dst_encride", "dst_dride", "dst_strIDE", "dst_stringIDE", "dst_drider", "dst_encide", "dst_drride", "dst_strider", "dst_encIDE", "dst_drIDE", "dst_stringide"], "src_stride": ["src_striade", "src_rider", "src_Strade", "src_stringider", "src_Strime", "src_Strider", "src_stringide", "src_strride", "src_striride", "src_striime", "src_strider", "src_strime", "src_stringride", "src_stringade", "src_rime", "src_Stride", "src_striide", "src_rride", "src_striider", "src_ride", "src_Strride", "src_strade"], "height": ["ht", "resolution", "count", "view", "hang", "length", "volume", "ih", "gh", "angle", "rank", "th", "block", "Height", "html", "yt", "he", "capacity", "dimension", "memory", "density", "window", "row", "sky", "history", "bottom", "total", "size", "h", "depth", "shape", "padding", "ty", "ch", "dim"], "qp_store": ["qp2source", "qp__base", "qop_base", "qp__source", "qp__Store", "qp2store", "qp_Store", "qp_source", "qop_source", "qp__store", "qop_Store", "qp_base", "qp2base", "qp2Store", "qop_store"], "qp_stride": ["qp_arrider", "qp_arride", "qp_trider", "qp_trride", "qp_strride", "qp_strider", "qp_lenide", "qp_lenim", "qp_trim", "qp_strim", "qp_tride", "qp_lenride", "qp_lenider", "qp_arrride", "qp_arrim"], "x": ["k", "n", "wx", "el", "time", "xes", "item", "c", "xxx", "at", "X", "w", "r", "lat", "on", "xy", "fx", "rx", "l", "v", "e", "u", "ax", "xd", "xp", "xf", "xc", "g", "cross", "mx", "xi", "xa", "o", "key", "value", "ix", "nex", "ice", "t", "px", "content", "index", "act", "xx", "ux", "h", "lex", "z", "yx", "f", "ox", "tx", "ch", "xe", "xt", "add", "m", "dx", "ex"], "y": ["iy", "ley", "yer", "wy", "yr", "entity", "ya", "yo", "iley", "ly", "page", "b", "year", "yi", "by", "ot", "block", "yt", "w", "ady", "isy", "ey", "py", "dy", "type", "xy", "hy", "row", "sky", "v", "hot", "e", "io", "kit", "my", "ys", "ay", "ies", "key", "ry", "it", "yy", "a", "ny", "ym", "Y", "yl", "oy", "index", "no", "h", "aily", "axy", "uy", "gy", "z", "yet", "ed", "ty", "ch", "ye", "vy", "o", "cy", "sy"], "i": ["n", "oi", "cli", "iter", "any", "yi", "iri", "uri", "mi", "ind", "ai", "v", "is", "ij", "ei", "ic", "wi", "history", "it", "si", "ie", "h", "id", "ti", "io", "ish", "iu", "bi", "hi", "init", "ui", "batch", "c", "di", "status", "ir", "ini", "list", "zi", "ims", "ik", "xi", "ami", "a", "iq", "iat", "index", "multi", "sim", "ri", "I", "asi", "im", "ki", "try", "l", "ip", "info", "bis", "ix", "ci", "gi", "m", "ex", "k", "li", "item", "b", "ia", "ii", "ji", "\u0438", "u", "pi", "in", "g", "me", "qi", "f", "err", "o"], "j": ["k", "n", "jc", "q", "b", "jump", "r", "ji", "l", "ind", "v", "ij", "jj", "jp", "g", "col", "it", "aj", "rel", "z", "f", "jl", "js", "ch", "J", "m", "pos"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n", "idx": 1487, "substitutes": {"nf": [" nfo", " nxf", "Nxf", "nfe", "dnF", "dnf", "nnxf", "lnxf", "nief", "nrf", "Nfr", "niefr", "nnf", "nF", "nonrf", "nnfo", "lnf", " nrf", "niefe", " nfe", " nF", "nfr", "nxf", "nnF", "Nfe", "nonfe", "niexf", "lnfe", "nonf", "dnxf", "Nf", "nfo", "lnfr", "dnfo", "Nrf"], "s": ["n", "iss", "bs", "ses", "new", "ls", "r", "als", "ts", "its", "ps", "gs", "is", "sys", "ss", "g", "ers", "space", "ms", "ys", "sv", "os", "ies", "fs", "ds", "si", "sts", "ats", "rs", "ns", "t", "sb", "S", "ins", "us", "sl", "sq", "f", "cs", "hs", "js"], "sr": ["cr", "lr", "rar", "yr", "fr", "tr", "vr", "ker", "rb", "nor", "kr", "rg", "rh", "r", "ru", "rl", "rw", "rx", "asper", "rf", "gs", "hr", "SR", "rm", "gr", "sol", "rt", "rn", "sv", "rr", "adr", "spr", "sur", "rs", "usr", "sf", "shr", "sl", "nr", "hs", "ser", "mr"]}}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1497, "substitutes": {"tcet": ["encect", " tconet", "TCette", "lcET", "TCiet", "tconet", "tcect", "TCed", "ctet", "usercect", "ucett", " tcot", "encet", "ancett", "ncet", "tcett", "ancet", "fcET", "TCet", "tced", "sicette", "ctot", "lcect", "camect", "ncect", "TCets", " tcect", "ticET", "TCect", "ncset", "TCett", "tcET", "TConet", "ctET", "cuset", "pcet", "tocet", "ancET", "lced", "cusET", "tcot", "encety", "pcset", "ticett", "usercET", "ucet", "TCET", "pcect", "tcette", "tcset", "usercette", "ticect", "ticet", "fcet", "tocect", "pcety", "fcett", "tociet", "tcets", "camet", "lcet", "camiet", "fcect", "TCot", " tcET", "tocET", "ctonet", "camET", "ncety", "ancect", " tced", "usercet", "ucets", "encset", "tciet", "ucET", "cusett", "tcety", "sicet", "sicET", "sicect", "cusets"], "ioba": [" iobe", "ioy", "xioba", "iazo", "iiouf", "tiibi", "iioby", " iob", "sioba", "iiobar", "lionga", "xioy", " iazo", " ialeb", "xiobar", "itiouf", "sialeb", "siobar", "xiob", "iobar", " iibi", "ioby", "iioy", " ionga", "iuoba", "iiob", "iuobe", "iioba", "tiowa", "iibi", "iouf", "ialeb", "iuowa", "ionga", "sionga", "itioby", " iobar", "iuibi", " iouf", "lioba", "iobe", " iowa", "itioba", "itiazo", "lialeb", "iowa", "tiobe", "tioba", " ioby", "iiazo", "liobar", " ioy", "iob"], "tce": ["fces", "pcoe", "tcer", "wce", "tmCE", "tace", "fce", "tke", "wces", "tmcer", "ktce", "tcoe", " tces", "fCE", "fke", "pcer", "mcer", "pce", "wke", "mCE", "mces", "tmace", " tace", "teCE", "Tcer", "teces", "Tce", " tCE", "pces", "cce", "TCE", "tmce", "mce", "tCE", "tece", "ccoe", "tecer", "ktcer", "ktces", " tcer", "wCE", "wcer", "ccer", " tke", "ktcoe", "Tace", "tces", "cces"], "entry": ["nt", "record", " keyword", "error", "rance", "attribute", "member", "or", "ry", "delete", "er", "Entry", "primary", "ie", "ent", "writer", " slot", "address", "import", "escape", "RY", " candidate", " row", "pair", "row", "list", "existent", "cont", "table", "index", "ace", "option", "desc", "add", "line", "ment", " argument", "ident", "ew", "see", "cell", "response", "try", "inter", " enter", "match", "aux", "ary", "search", "key", "set", " ep", "ce", "phrase", "result", " estimate", " ace", "query", "entity", "comment", "insert", " entrance", "enter", "check", "word", "e", "way", "oe", "se", "cue", "element", " office", "obj", " segment", "event", "print"]}}
{"project": "qemu", "commit_id": "f73a2575a3bce8a3c487331c918d2c0f9b2e489d", "target": 0, "func": "static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,\n\n                            target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong pteh = args[2];\n\n    target_ulong ptel = args[3];\n\n    target_ulong i;\n\n    uint8_t *hpte;\n\n\n\n    /* only handle 4k and 16M pages for now */\n\n    if (pteh & HPTE_V_LARGE) {\n\n#if 0 /* We don't support 64k pages yet */\n\n        if ((ptel & 0xf000) == 0x1000) {\n\n            /* 64k page */\n\n        } else\n\n#endif\n\n        if ((ptel & 0xff000) == 0) {\n\n            /* 16M page */\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    /* FIXME: bounds check the pa? */\n\n\n\n    /* Check WIMG */\n\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n\n        return H_PARAMETER;\n\n    }\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&\n\n                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    stq_p(hpte, pteh);\n\n\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n", "idx": 1500, "substitutes": {"env": ["em", "eas", "Environment", "init", "ew", "man", "org", "ef", "erd", "engine", "w", "map", "equ", "environment", "buf", "ec", "ve", "era", "shell", "window", "te", "v", "context", "e", "inv", "eng", "conf", "estate", "network", "ctx", "en", "conn", "origin", "code", "end", "vs", "viron", "manager", "server", "er", "den", "operator", "t", "state", "vp", "obj", "dev", "h", "setup", "policy", "uv", "sp", "cmd", "vm", "event", "con", "ah", "ev", " environment"], "spapr": ["spopR", "spoprd", "spaprs", "spapR", " spipR", "spipr", "spaprd", " spaprs", "spoprs", "spipR", " spiprd", " spaprd", "spiprd", " spapR", " spipr", "spspr", " spiprs", "spiprs", "spsprd", "spspR", "spopr", "spsprs"], "opcode": ["opsec", "opssec", "popco", "popcodes", "pcodes", "opscodes", "opsco", "popcode", "popsec", "psec", "opscode", "opco", "pcode", "opcodes", "pco"], "args": ["xs", "bs", "limits", "qs", "users", "blocks", "results", "ags", "func", "values", "atts", "facts", "ams", "arms", "modules", "arg", "ts", "points", "changes", "aux", "gs", "ras", "units", "members", "ties", "parts", "fields", "conf", "grades", "ims", "ms", "workers", "objects", "fs", "bugs", "flags", "params", "ns", "bits", "as", "related", "words", "vals", "files", "cs", "cmd", "err", "range", "js", "aws", "names", "roots", "Args", "actions"], "i": ["phi", "k", "iu", "I", "bi", "hi", "cli", "this", "li", "ui", "b", "c", "di", "ii", "d", "mi", "ni", "p", "l", "ip", "is", "v", "ei", "ai", "x", "u", "pi", "fi", "e", "in", "ini", "info", "zi", "g", "qi", "xi", "o", "it", "gu", "si", "ix", "ci", "t", "index", "multi", "y", "f", "id", "ti", "sim", "gi", "m", "j", "io"], "hpte": [" hporteng", "hsptonen", "hspte", "hpointe", "hptes", "hpointed", "hsptoneg", "hshot_", "hpten", "hpport_", "hctes", "hipten", "hpointee", "ohshot_", " hported", "hporter", "hptyeg", " hpter", "hptyest", "hcte", "hitopen", "hptyes", "Hporte", "hepted", "hitoped", "hportse", " hctes", "htopen", "hpointes", "hiptee", "hcter", "hsptor", " hportse", "hptyor", "Hptee", "htopee", "hpteng", "hipted", "hapter", "Hported", "hpute", "hpportse", "hspteg", " hporter", " hptes", " hptse", "Hpte", "hapteng", "hporte", "hportes", "Hportee", "hporten", "htope", "hptor", "hitope", "hptse", " hpted", "hptye", " hcter", "hpt_", "hpporte", "hpointer", "hputeg", "hputen", "hapte", "hptyee", " hptee", "hptest", "hporteng", "Hpted", "hapt_", " hctee", " hporte", "haptee", "hported", "hapted", "hportee", "Hpter", "Hporter", "hsptone", "hpted", " hcte", "hitopee", "hptonor", "hsptonor", "hctest", "hctee", "hepte", "haptse", "ohpt_", "haptes", "hputor", "hptyen", "hportest", " hctest", "hptoneg", "hpportee", "hptone", "hpteg", "hptee", "heptee", "hptonen", " hptest", "hpporter", "hapten", "htoped", "hipte", " hpteng", "hspten", "hpter", "hepteng", " hportee"]}}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 1507, "substitutes": {"ctx": ["wx", "stack", "Context", "kb", "np", "nt", "mc", "cmp", "gz", "cfg", "ct", "c", "ca", "func", "cu", "kt", "kl", "p", "cp", "cc", "req", "pc", "cf", "cpu", "sys", "context", "bc", "x", "cm", "cn", "jac", "kw", "jp", "xc", "rt", "sc", "nc", "conv", "history", "conn", "handle", "cb", "resp", " cx", "txt", "wd", "cv", "tc", "setup", "obj", "hw", "pkg", "ctl", "sp", "cmd", "tx", "config", "cas", "xp"], "ret": ["null", "get", "rets", "rc", "nz", "nt", "re", "uf", "ct", "status", "try", "gc", "alt", "arg", "buf", "vt", "rx", "mem", "out", "cpu", "v", "sys", "def", "rev", "gt", "jp", "ft", "rt", "reg", "elt", "reset", "conn", "ry", "expr", "resp", "Ret", "RET", "res", "t", "val", "gb", "ref", "txt", "etc", "cv", "mt", "tc", "obj", "tmp", "cmd", "tor", "buffer", "result", "rem"], "arg1": ["tag1", "argument01", "doc01", "args3", "arg25", "t3", "args1", "argument2", " arg8", "ument2", "doc0", "t2", "arg01", " arg3", "ument25", "ument3", " arg25", "argument8", " arg0", "tag2", "doc1", "arg0", "args0", "args2", "tag3", "doc8", "argument1", "argument0", "argument3", "arg3", "t25", "arg8", "ument1", " arg01"], "arg2": ["param3", "arg5", "args3", "tag1", "tag5", "args1", "args5", "argument2", " arg3", "param02", "tag02", " arg0", "tag2", " arg02", "args02", "arg02", "arg0", "args2", "tag3", "argument1", "argument0", "param2", " arg5", "arg3", "argument5", "tag0", "param1"], "add_ca": ["drawtlocal", "add__ba", "add_ba", "attach_ca", "addbedpa", "create__pa", "attach_cas", "add_aco", "addCallca", "create_uca", "create_ba", "add_cas", "add_pa", "add_Ca", "add___ca", "add__ca", "add___cu", "draw_cu", "create__ba", "add___aco", "drawtca", "add__pa", "addtca", "attach_Ca", "drawtcu", "create__ca", "addCallba", "add__uca", "addbedca", "create_pa", "add_uca", "create__uca", "add_cu", "addCallpa", "add___local", "addtcu", "draw_local", "draw_aco", "drawtaco", "draw_ca", "addCalluca", "addbeduca", "addtaco", "add_local", "addbedba", "create_ca", "addtlocal"], "compute_ca": ["comperve_ci", "comperve___ci", "compress___car", "computation_ce", "compute_ac", "comperve_ca", "compute_ci", "comperve___ca", "compress_aca", "computationableco", "computation_ac", "compute_ba", "compute___car", "computeableco", "computed_aca", "comperve___ba", "compute_car", "compress_car", "computation_ca", "computed___pa", "compute_cm", "compute___ca", "computationableca", "compute_co", "compute_mc", "computed_pa", "compress___ca", "computeablece", "computed_ca", "computed___ca", "comperve_ba", "computeableac", "compute___cm", "computation_co", "computeableba", "computeablemc", "compute_pa", "computed___aca", "compress_ca", "computeableca", "computationableac", "computationablece", "compute_ce", "comperve_mc", "compute___ba", "compute___aca", "compress___aca", "compute___pa", "compute___mc", "compress_cm", "compress___cm", "comperve___mc", "compute_aca", "compute___ci", "computeableci"], "compute_ov": ["compute___kov", "computation___ola", "compute_oss", "computeingoss", "computeateuv", "computation___av", "compUTE_uv", "compute_other", "compUTE_vo", "computation___ov", "compile_os", "compute_ola", "compute_uv", "compUTEinguv", "computeableuv", "computeingov", "computeatevo", "computeableova", "computelyother", "computeableob", "compile_av", "compUTEingvo", "compute___av", "compile_other", "computelyov", "computation_kov", "computes_ova", "computeinguv", "computes_ov", "compute_vo", "computeingvo", "compute_os", "computeablevo", "computeateov", "computeableov", "compUTE_oss", "compile_ov", "computation_ola", "computes_uv", "compute___ola", "computelyos", "computation___kov", "compUTE_ov", "computes_ob", "compute_ova", "compute_kov", "computeateoss", "compUTEingov", "computeableoss", "computation_av", "computelyav", "compute_av", "compUTEingoss", "compute___ov", "compute_ob", "computation_ov"], "t0": ["t15", "it13", "ttout", "dtok", " tale", " t2", "tok", "tt4", "tcId", "tt1", "m15", " t3", "dt0", "l1", "thk", "at0", "T000", "tZero", " t5", "tId", "wtale", "T9", " t4", "t255", "tk", "ttk", " t000", "T4", "wt13", " top", "at1", "T5", "tthis", "it0", "thale", "m2", "top", "Tthis", "wt0", "m1", "m13", "th1", "tt5", "t13", "ttZero", " t255", "Top", "dtId", "m9", "TZero", "tt15", "Tout", "T255", "t000", " tId", "m0", "at15", "p3", "p4", "t2", " tthis", "tale", "p1", "l2", "T2", "wt2", "wt15", "tt0", "mk", "dt1", " tk", "t9", "tc1", "t5", "l4", "T15", "wt1", " tout", "T3", "tout", "t3", "th2", "tcok", "T1", "T0", "ttthis", "t4", "wt255", "th255", " t9", "tc0", "tt000", "atZero", "it15", "tt255", "th0", "at3", "p2", " tok", "l0", "ttop", "Tk", "p0", "it1"], "t1": ["tone", "T01", "T3", "te8", "l01", "t3", "te0", "v001", "ptn", "v2", " t2", "teone", "p3", "rt01", "t2", " tn", "td001", "p1", "T1", "T0", "pt1", "T2", " t9", "t001", " t3", "l1", "t01", "Tone", " tone", "rt0", " t8", " tob", "td1", "td0", "Tob", "tdob", "tn", "T9", " t001", "td01", "arg0", "pt001", "p2", "t8", "l0", "v0", "v1", " t01", "tob", "t9", "T8", "p0", "tdn", "arg3", "te1", "arg9", "T001", "rt1"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t*)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    mm_end = end - 7;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            \"movq       %%mm0, %%mm6    \\n\\t\"\n\n            \"movq       %%mm3, %%mm7    \\n\\t\"\n\n\n\n            \"movq         8%1, %%mm0    \\n\\t\"\n\n            \"movq         8%1, %%mm1    \\n\\t\"\n\n            \"movq         8%1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmx_null)\n\n            :\"memory\");\n\n        /* borrowed 32 to 24 */\n\n        __asm__ volatile(\n\n            \"movq       %%mm0, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"movq       %%mm6, %%mm0    \\n\\t\"\n\n            \"movq       %%mm7, %%mm1    \\n\\t\"\n\n\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n\n\n            STORE_BGR24_MMX\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        d += 24;\n\n        s += 8;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n    }\n\n}\n", "idx": 1508, "substitutes": {"src": ["inst", "input", "rc", "b", "rb", "cur", "start", "sn", "dest", "r", "rl", "img", "ind", "out", "st", "ur", "x", "sys", "in", "ss", "obs", "rt", "sc", "rn", "source", "sv", "sr", "loc", "gb", "sur", "rs", "sb", "ins", "usr", "sw", "sl", "ctr", "RC"], "dst": ["dust", " dset", " dust", " dST", "dST", "gust", "tbl", "tust", "DST", "Dset", "dsbl", "Dst", "dsts", " dbl", "dsST", " dsts", "gst", "dbl", "Dbl", "dsset", "gsts", "gbl", "tsts", "dset", "tst", "dsst"], "src_size": ["src2size", "st2size", "src_length", " src_length", "src_range", " src_Size", "st_Size", "src2SIZE", "src_Size", "st2SIZE", "st2Size", "st_SIZE", "src2Size", " src_range", "src_SIZE", "st_size"], "end": ["ad", "END", "ff", "length", "End", "nd", "start", "w", "dest", "rest", "max", "p", "ended", "est", "offset", "v", "send", "st", "e", "eng", "se", "en", "ending", "set", "stop", "last", "t", "size", "begin", "ed", "h", "ent", "z", "id", "until", "m", "ex"], "mm_end": ["mm_ended", "mm_End", " mm_max", "mm_ends", "mm8ended", "mem_end", " mm_start", "mm8end", "mm8END", " mm_END", "mem_ends", "mm_max", " mm_End", "mm_start", "mm_END", " mm_ended", "mem_start", "mm8End"], "d": ["k", "ad", "n", "dn", "pd", "b", "c", "di", "w", "r", "p", "sd", "i", "l", "v", "st", "x", "e", "dc", "dd", "g", "D", "o", "ds", "dt", "t", "da", "dm", "fd", "h", "y", "z", "f", "id", "m", "j", "data", "dx", "db"], "s": ["n", "q", "sym", "es", "b", "c", "ls", "start", "w", "r", "p", "ts", "its", "ps", "i", "l", "gs", "v", "is", "st", "sys", "e", "u", "x", "mys", "ss", "g", "se", "ms", "ims", "source", "sv", "ies", "tes", "o", "fs", "ds", "a", "set", "si", "sts", "ats", "rs", "t", "ns", "sb", "S", "size", "ins", "h", "sl", "cs", "sp", "hs", "js", "m", "j"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 1519, "substitutes": {"opts": ["opsmits", "optionbs", "opmits", "oppx", "OPs", "opcons", "opnt", "opermes", "opbs", "ops", "operTS", "imts", "experTS", " oppt", "optbs", "opsTS", "opsouts", "optTS", "optionfs", "iopTS", "optgs", "optioncons", "props", " opmes", "iopt", "operth", "opfs", "Opmes", " opcons", " opmits", "Opth", "opsgs", "opmes", "optfs", "optcons", "Opts", "OPts", "Opnt", " opnt", "Opmits", "opspx", "ioptes", " opfs", "optnt", "opTS", "opth", " ops", "OPpt", "operts", "propt", "opouts", "imTS", "operpx", " opbs", "opsts", "opsnt", "OPps", "opgs", "opsmes", "opps", "OpTS", "opt", " opps", "prots", "iopts", "optionts", "imt", "operouts", "optts", "opttes", "pros", "opsth", "oppt", "expernt", "imtes", "optes", "expergs", "optt", "Opouts", "experts", "Oppx"], "ai": ["au", "tp", "AI", "an", " ad", "ka", "ao", "oa", "ati", "mi", "av", " mi", "i", "asm", "ei", "aug", " ta", "air", "aos", "aim", "arp", "aaa", "address", "aa", "ti", "aki", "aq", " am", "hi", "bi", "ali", "cgi", " na", "ait", "ui", "api", "di", "ha", "am", "auth", "pai", " pa", "ay", "ami", "a", "irm", "ta", "iq", "dat", " ba", "aj", "ak", "htt", " a", "add", "config", "aus", " au", "attr", "wm", "iam", "asi", "ca", "im", "hai", "admin", " bi", "iii", "aux", "trace", "arm", "info", " sa", "ar", "ae", "ain", "aci", "ci", "alias", "asc", "sa", "auc", "cas", "pa", "ais", " an", "ia", "ias", "AE", "mic", "me", "aste", "ac", "acs", "adr", "link", "server", " ac", "pac", "ua"], "peer": ["other", "inner", "proc", "tp", "attr", "this", "pool", "self", "target", "ker", "ca", "worker", "channel", "per", "remote", "rer", "family", "reader", "player", "p", "type", "i", "parent", "pc", "fp", "header", "attribute", "socket", "prefix", "context", "e", "message", "name", "pod", "group", "ctx", "server", "host", "master", "pe", "er", "ae", "part", "meta", "component", "node", "proxy", "table", "usr", "primary", "root", "user", "soc", "ptr", "package", "pkg", "ace", "actor", "address", "holder", "ser", "owner", "client", "instance"], "local": ["other", "inner", "localhost", "lib", "self", "mask", "native", "remote", "cache", "sel", "pc", "shared", "socket", "file", "link", "ac", "server", "master", "loc", "dir", "lock", "node", "primary", "raw", "lang", "loader", "global", "client"], "addr": ["au", "iter", "hash", "oa", "r", "ress", "coord", "aim", "conn", "arp", "http", "ptr", "hw", "pkg", "address", "amp", "cmd", "id", "off", "pos", "az", "str", "art", "att", "at", "map", "alt", "aer", "on", "pad", "prefix", "ord", "host", "a", "ld", "loc", "rel", "wd", "ace", "add", "urg", "ad", "attr", "eth", "admin", " address", "fx", "ip", "ap", "rt", "elt", "ar", "area", "rr", "ost", "ae", "ix", "dir", "dr", "tx", "mac", "ack", "nl", "ag", "dh", "oad", "src", "align", "aud", "offset", "Address", "bind", "arr", "url", "ac", "adr", "rs", "ns", "ref", "obj", "err", "db"], "port": ["tp", "null", "length", "ported", "target", "tr", "pr", " sport", "cp", "select", "queue", "br", "limit", "to", "part", "component", "order", "ptr", "pkg", "address", "net", "padding", "project", "pos", "test", "pool", "q", "unit", "per", "dp", "pad", "pc", "len", "file", "col", "host", "pport", "rel", "mt", "Port", "nat", "public", "version", "until", "ports", "nel", "pro", "eth", "get", "point", "export", "phone", "mobile", "p", "porter", "ip", "eport", "number", "trace", "tel", "ping", "secure", "pod", "pp", "key", " Port", "position", "proxy", "phy", "pse", "pn", "form", "page", "peg", "be", "path", "pt", "tty", "type", "timeout", "offset", "ort", "socket", "pi", "shift", "server", "total", "t", "pg", "PORT", "pid"], "uaddr": ["uaddress", " uaddress", "pusrc", "usrc", "puaddr", "puaddress", " usrc"], "uport": ["pPort", " uPORT", "pPORT", "uPort", "UPort", "uPORT", "Uport", "UPORT", "pport", " uPort"], "rc": ["ack", "init", "isc", "roc", "c", "rb", "error", "src", "cur", "rh", "r", "rec", "rl", "gc", "cc", "ec", "rx", "pc", "row", "ck", "bc", "dc", "sync", "co", "fc", "rt", "ror", "sc", "rn", "col", "nc", "rr", "ac", "ry", "cb", "loc", "resp", "cor", "res", "rs", "ro", "arc", "ref", "uc", "cs", "err", "irc", "ok", "config", "result", "RC"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_file_size(FTPContext *s)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    char *res = NULL;\n\n    const int size_codes[] = {213, 0};\n\n\n\n    snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path);\n\n    if (ftp_send_command(s, command, size_codes, &res)) {\n\n        s->filesize = strtoll(&res[4], NULL, 10);\n\n    } else {\n\n        s->filesize = -1;\n\n        av_free(res);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    av_free(res);\n\n    return 0;\n\n}\n", "idx": 1525, "substitutes": {"s": ["sam", "service", "n", "sg", "ports", "esm", "spec", "bs", "qs", "q", "ses", "self", "services", "b", "c", "ls", "sn", "w", "r", "p", "ts", "its", "ps", "l", "asm", "gs", "is", "sys", "sync", "ops", "ss", "g", "sc", "sv", "o", "bis", "fs", "ds", "eps", "set", "go", "scope", "sts", "ats", "so", "t", "ns", "rs", "http", "sb", "S", "https", "y", "h", "session", "sw", "ess", "sq", "f", "cs", "hs", "details", "js", "aws", "m", "client"], "command": ["method", "execute", "service", "clear", "empty", "config", "form", "query", "length", "normal", "error", "response", "capacity", "height", "controller", "type", "description", "condition", "attribute", "template", "prefix", "function", "message", "power", "direction", "format", "name", "menu", "history", "key", "code", "value", " Command", "position", "statement", "delete", "which", "Command", "table", "resource", "size", "call", "package", "usage", "address", "request", "cmd", "chain", "buffer", "domain", "password", "pattern", "mode", "result", "directory", "sequence"], "res": ["proc", "j", "bs", "sec", "rc", "rep", "fr", "nt", "re", "results", "RES", "r", "remote", "rest", "ret", "p", "ress", "req", "ps", "cons", "pas", "mem", "out", "pres", "sys", "gr", "respons", "rev", "arr", "reg", "ms", "reset", "ds", "rek", "ev", "vs", "resp", "er", "rs", "val", "times", "serv", "ref", "resh", "ins", "mr", "usr", "vals", "us", "des", "cs", "cmd", "err", "tx", "red", "js", "ser", "vol", "Res", "result", "pos", "resources", "rem"], "size_codes": [" size_code", "size2values", "size_bits", "size_odes", "size2odes", "size_values", " size_values", "size2code", " size_bits", "size_code", "size2codes", " size_odes"]}}
{"project": "qemu", "commit_id": "68d45bb61c5bbfb3999486f78cf026c1e79eb301", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)\n\n{\n\n    TCGReg datalo, datahi, addrlo, rbase;\n\n    TCGReg addrhi __attribute__((unused));\n\n    TCGMemOpIdx oi;\n\n    TCGMemOp opc, s_bits;\n\n#ifdef CONFIG_SOFTMMU\n\n    int mem_index;\n\n    tcg_insn_unit *label_ptr;\n\n#endif\n\n\n\n    datalo = *args++;\n\n    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);\n\n    addrlo = *args++;\n\n    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);\n\n    oi = *args++;\n\n    opc = get_memop(oi);\n\n    s_bits = opc & MO_SIZE;\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    mem_index = get_mmuidx(oi);\n\n    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);\n\n\n\n    /* Load a pointer into the current opcode w/conditional branch-link. */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);\n\n\n\n    rbase = TCG_REG_R3;\n\n#else  /* !CONFIG_SOFTMMU */\n\n    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n\n    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n\n        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);\n\n        addrlo = TCG_REG_TMP1;\n\n    }\n\n#endif\n\n\n\n    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {\n\n        if (opc & MO_BSWAP) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0));\n\n        } else if (rbase != 0) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo));\n\n            tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));\n\n        } else if (addrlo == datahi) {\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n        } else {\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n        }\n\n    } else {\n\n        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];\n\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));\n\n            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);\n\n        } else if (insn) {\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n        } else {\n\n            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n            insn = qemu_exts_opc[s_bits];\n\n            tcg_out32(s, insn | RA(datalo) | RS(datalo));\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#endif\n\n}\n", "idx": 1533, "substitutes": {"s": ["n", "stats", "single", "qs", "self", "ses", "comm", "es", "b", "c", "ssl", "ls", "w", "r", "p", "ts", "its", "ps", "south", "gs", "v", "is", "out", "sys", "x", "e", "less", "ss", "g", "ims", "space", "source", "sv", "os", "o", "fs", "ds", "a", "set", "sts", "ats", "er", "t", "ns", "rs", "as", "sm", "sb", "S", "scl", "ins", "h", "sw", "us", "y", "sq", "z", "f", "cs", "hs", "js", "simple", "m"], "args": ["posts", "stats", "ars", "axis", "qs", "limits", "ants", "blocks", "ians", "ags", "func", "atts", "seconds", "eds", "arg", "ts", "points", "icks", "tags", "changes", "aux", "gs", "members", "terms", "parts", "fields", "arr", "kw", "keys", "ims", "orders", "tests", "workers", "objects", "checks", "grades", "acs", "yrs", "flags", "faces", "params", "ats", "gets", "types", "pointers", "ns", "abis", "bits", "cats", "amps", "aw", "GS", "cs", "caps", "aws", "js", "names", "ams", "Args", "properties", "actions"], "is_64": ["Is_64", "is_24", "is_63", " is_63", "is_864", " is_864", " is_32", "Is_864", "Is_24", "is_32"], "datalo": ["datao", "ttalan", "ttahi", "codahi", "Datalan", " datalin", "Datalin", "Datalo", " datao", "datacho", " datalan", "codalo", " datacha", " datacho", "datalan", "dateao", "buffacho", "Datahi", "datla", "datalin", " datla", "codacha", "datale", "buffla", "datacha", "buffale", "ttalin", "Datla", "dateacha", "datealo", "codao", "Datacho", "Datale", "buffalo", "dateahi", "ttalo", " datale"], "datahi": ["datama", "rataxy", "dtahi", " datah", "dataxy", "catama", "ratahi", "dtama", "dtah", "dataowa", "datagi", "dataah", "dataaman", "ratagi", " dataman", "datah", "datowa", "ratama", "dtagi", "dtowa", " datowa", "cataxy", "dtaxy", "catahi", "dtaman", "dataahi", "dataman", "catagi"], "addrlo": ["alignno", "addresslo", " addrLO", "addrro", " addrso", " addrla", "addso", "ranklo", "resslo", "adno", "addressso", "offsetla", "drlo", "ressla", "offsetlo", "alignlow", "rankla", "attrhi", " addrlow", " addrloop", "rankloop", "attrlow", "attrro", "actro", "adrln", "drli", "adrlo", "offsetno", " addrno", "addrLO", "addrlow", "adrso", "orderlo", "attrlo", "addno", "addhi", "adrno", "alignli", "attrno", "orderln", "ressloop", "addrelo", "offsetelo", "addrLo", "addrno", "actLO", " addrelo", "addrloop", "alignlo", "orderLo", "actlow", " addrli", "adelo", "adrli", "attrso", "addressno", "addrso", "addrli", " addrln", "orderli", "attrLO", "addlo", " addrstro", "addrstro", "drno", "actno", "adla", "actla", "addrla", "adlo", " addrro", "actlo", " addrLo", "drlow", "addrln", "adrLo", "rankstro", "addressla", "ressstro"], "rbase": ["rarbalance", "mbase", " rbal", "lbase", "rbit", "mrbase", " rbalance", "ropad", "rcbase", "rBase", "mrBase", "robalance", " rspace", "nrdomain", " rBase", "lstore", "rbalance", "robase", "rstart", "Rstart", "rpad", "mpad", "nrbas", "nrbal", "mbas", "rarbase", " rdomain", "rstore", "rbal", "mrstart", "mrbit", " rbit", " rstart", " rbas", "lbalance", "rarpad", "rarbas", "mrstore", "mrbalance", "lBase", "mrspace", "rdomain", "Rspace", "nrbase", "rcbal", "rbas", " rstore", "robas", "rcdomain", "rspace", "rcbas", "Rbit", "Rbase", "mbalance"], "addrhi": ["addresslo", "maphi", " addrphi", "addrhei", "addHi", "addrHI", "addressHi", " addrHi", " addrhei", "maphei", "ptrlo", "addressphi", "addrhigh", "memHI", "addhi", "ptrhigh", "addresshi", "addrHi", "ptrhi", "addresshei", " addrhigh", "memlo", "maplo", "ptrhei", "maphigh", "addressHI", " addrHI", "addlo", "addrphi", "memhei", "addphi", "memhi"], "oi": ["phi", "obi", "bi", "ogi", "odi", " iso", "oji", "ilo", "itime", "ui", "afi", "oa", "asi", "avi", "iri", "ovi", "mi", "ki", "ni", "emi", "iso", "ois", "eni", " mi", "coe", "i", "osi", "oid", "ei", "rio", "eta", " tid", "ori", "pi", "obo", "ini", "oin", "xi", "udi", "bis", "ami", " ii", "si", " orient", " vi", "igi", "oni", " ki", " ni", "oci", "eric", "ti", "o"], "opc": ["opcs", "copc", "ipf", "ipcs", "opsc", "ospcp", " opcs", "osppc", "operci", "opcp", " popcs", "Oppc", "ipc", "operc", "Opc", "ospcs", "operfc", " ipcs", "opsci", "opscs", " ipc", "OPpc", "OPcp", "oppc", " opf", "ipco", "Opcs", " popc", " ipf", "opco", "operca", "OPca", "copca", " popf", "ospc", "OPf", "OPc", "opfc", " opci", "opf", "OPci", " ipco", "opca", "OPfc", "OPcs", "copfc", "opci", "opsf", "copci", " popco", "Opcp"], "s_bits": [" s_maps", "s___tops", "s_bytes", " s_its", " s_values", "s___bits", " s_flags", " s_bs", " s_bytes", "s___bytes", "s_maps", " s_tops", "s_its", "s_bit", "s_values", " s_bit", "s_bs", "s_tops", "s_flags"], "mem_index": ["mem2info", "mem67info", " mem_value", "Mem_info", "mem2value", "mem2index", " mem_position", " mem_Index", "mem_Index", "memipindex", "mem_info", "memipIndex", "mem67Index", "mem2Index", "mem_position", "memipvalue", "mem_label", "Mem_Index", "mem_value", "Mem_index", " mem_label", "mem67index"], "label_ptr": ["label__ptr", " label_pos", "label_pointer", "lab_ptr", "label_pt", " label_pointer", "lab_pt", "label_str", "label__pt", "label_pr", "lab_pointer", " label_pr", "label__str", "lab_str", "label__pointer", "label_pos"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,\n\n                                   GetBitContext *gb)\n\n{\n\n    int i;\n\n    MMCO *mmco = sl->mmco;\n\n    int nb_mmco = 0;\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields\n\n        skip_bits1(gb); // broken_link\n\n        if (get_bits1(gb)) {\n\n            mmco[0].opcode   = MMCO_LONG;\n\n            mmco[0].long_arg = 0;\n\n            nb_mmco          = 1;\n\n        }\n\n        sl->explicit_ref_marking = 1;\n\n    } else {\n\n        sl->explicit_ref_marking = get_bits1(gb);\n\n        if (sl->explicit_ref_marking) {\n\n            for (i = 0; i < MAX_MMCO_COUNT; i++) {\n\n                MMCOOpcode opcode = get_ue_golomb_31(gb);\n\n\n\n                mmco[i].opcode = opcode;\n\n                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n\n                    mmco[i].short_pic_num =\n\n                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &\n\n                            (sl->max_pic_num - 1);\n\n#if 0\n\n                    if (mmco[i].short_pic_num >= h->short_ref_count ||\n\n                        !h->short_ref[mmco[i].short_pic_num]) {\n\n                        av_log(s->avctx, AV_LOG_ERROR,\n\n                               \"illegal short ref in memory management control \"\n\n                               \"operation %d\\n\", mmco);\n\n                        return -1;\n\n                    }\n\n#endif\n\n                }\n\n                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n\n                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n\n                    unsigned int long_arg = get_ue_golomb_31(gb);\n\n                    if (long_arg >= 32 ||\n\n                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n\n                                             long_arg == 16) &&\n\n                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"illegal long ref in memory management control \"\n\n                               \"operation %d\\n\", opcode);\n\n                        return -1;\n\n                    }\n\n                    mmco[i].long_arg = long_arg;\n\n                }\n\n\n\n                if (opcode > (unsigned) MMCO_LONG) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"illegal memory management control operation %d\\n\",\n\n                           opcode);\n\n                    return -1;\n\n                }\n\n                if (opcode == MMCO_END)\n\n                    break;\n\n            }\n\n            nb_mmco = i;\n\n        }\n\n    }\n\n\n\n    sl->nb_mmco = nb_mmco;\n\n\n\n    return 0;\n\n}\n", "idx": 1540, "substitutes": {"h": ["s", "k", "ph", "ht", "hi", "this", "dh", "eh", " inh", "hm", "ih", "hl", "hh", "hp", "he", "rh", "p", "hd", "ha", "bh", "her", "l", "v", "sh", "HH", "H", "hal", "g", "o", "host", "kh", "oh", "http", "zh", "hz", "hw", "hs", "ch", "m", "j", "ah", "ssh"], "sl": ["s", "sql", "sch", "nl", "sing", "bl", "slice", "li", "spl", "lc", "ls", "hl", "ssl", "sk", "sn", "dl", "syn", "kl", "bh", "rl", "sel", "SL", "sd", "gl", "l", "spot", "sh", "sol", "Sl", "tl", "se", "sv", "fl", "sr", "so", "pl", "sm", "serv", "zh", "sb", "isl", "cl", "sw", "ln", "sp", "ml", "jl", "SSL", "sle", "slot"], "gb": ["bt", "vg", "sg", "fb", "vd", "kb", "bs", "yg", "jpg", "eb", "gz", "gd", "Gb", "uf", "bg", "gow", "cfg", "rb", "gh", "b", "pb", "rg", "html", "gc", "py", "wb", "asm", "gs", "sys", "bc", "csv", "bm", "bf", "gt", "g", "gif", "cz", "ng", "gu", "cb", "hub", "sb", "bb", "args", "goo", "pg", "GB", "gam", "mb", "eg", "storage", "vm", "gg", "tg", "gm", " GB", "db"], "i": ["n", "cli", " multi", "iri", "uri", "mi", " si", " mi", "ind", " I", "ai", "is", "ei", "ij", "ic", "it", "si", "y", "id", "ti", "phi", "iu", "bi", "hi", "init", "ui", "batch", " m", "di", "status", "x", "prefix", "ori", "fi", "ini", "list", "zi", "ims", "xi", " ti", " ii", "index", "multi", "chain", "sim", "ri", "j", "sql", "I", " li", "asi", "im", "ki", " bi", "ip", "info", " iter", "key", "ix", "ci", "gi", "m", "li", " j", "ii", "ji", "\u0438", "pi", "in", " pi", "me", "qi", "f", "series"], "mmco": ["tmcos", "mbfo", " mmCo", "mmCO", "mempo", "temCO", "MMfo", "mmcon", "mopCO", " mmso", "memcon", "mmgo", "memco", "mmmgo", " mmCO", "mopgo", "tmco", "emso", "tmfo", "mmaco", "mmcos", "mbco", "emco", "mmmfo", "temcos", "temco", "mmmo", "memso", "MMcon", "mbcos", "mmCo", " mmfo", "mmmcos", "mmpo", "memCo", "mmmpo", "mbmo", "mindco", "mmmCo", "tmpo", "mmmmo", "mbCO", " mmgo", "MMgo", "mmmCO", "memcoe", "mlCo", "mopco", "mopcos", "mindCO", " mmpo", "memaco", "mmmco", "temci", "MMco", "mbpo", "MMpo", "mbaco", "memgo", "MMcos", " mmcos", "memcos", " mmcon", "emCo", "mmcoe", "mmmcoe", "mmso", "mmmso", "memCO", "mmci", "mmmaco", "mopfo", "memmo", "memfo", "moppo", "mmfo", "emcoe", "mlcos", "mindcos", "MMso", "mlco", "mindci", "mlCO", "mopci"]}}
{"project": "qemu", "commit_id": "e40a67beeda6aa6e735546e9f08f3db41e23592a", "target": 0, "func": " void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n", "idx": 1557, "substitutes": {"s": ["n", "stats", "str", "sand", "q", "ses", "b", "c", "status", "w", "r", "p", "ts", "ps", "south", "gs", "is", "v", "sys", "st", "e", "sol", "ss", "conf", "g", "se", "space", "sc", "sv", "os", "store", "fs", "ds", "a", "set", "sts", "params", "rs", "t", "ns", "state", "esi", "sb", "S", "h", "sq", "details", "js", "aws", "m", "series"], "i": ["oi", "cli", "slice", " multi", "any", "uri", "mi", " si", " mi", "ind", " I", "loop", "ai", "ei", "is", "ij", "v", "ic", "history", "it", "si", " my", "ie", "y", "json", "ti", "io", "phi", "PI", "iu", "bi", "hi", "init", " wi", "ui", "batch", " m", "di", "x", "fi", "ini", " di", "zi", "ims", "xi", " ti", "ami", " ii", "ma", "iq", "index", "multi", "chain", "sim", "ri", "I", "this", " li", "point", "im", "ki", " index", "p", " bi", "ip", " it", "info", "ms", "my", " iter", " is", "ix", "ci", " ki", " ni", "span", "mac", "gi", "m", "ex", "li", " ex", "ii", "remote", "ji", "\u0438", "e", "pi", "in", " pi", "me", "qi", "gu", "err", "ski", "print"], "entry": ["ment", "inner", "escape", "record", "ient", "nt", "RY", "engine", "point", "see", "cell", "response", "export", "enter", "try", "pair", "inter", "check", "match", "connection", "row", "window", "attribute", "field", "e", "ary", "command", "member", "oe", "search", "or", "link", "key", "ry", "er", "component", "table", "element", "Entry", "join", "ue", "ie", "obj", "ent", "ace", "tree", "import", "print", "result", "line", "instance"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n", "idx": 1573, "substitutes": {"sum": ["sam", "n", "count", "null", "hist", "input", "hash", "Sum", "cmp", "up", "new", "c", "comment", "mon", "upper", "temp", "tu", "status", "umm", "util", "carry", "cache", "cum", "ul", "mem", "out", "mm", "good", "cal", "in", "ss", "must", "sc", "num", "upt", "ms", "shift", "doc", "go", "set", "si", "total", "msg", "share", "t", "now", "state", "med", "zero", "text", "val", "size", "subject", "uv", "us", "snap", "tmp", "raw", "mu", "ass", "unknown", "um", "mean", "add", "aw", "su", "sim", "sa", "vol", "result", "fac"]}}
{"project": "qemu", "commit_id": "45eb768c706d3a5fbe55224c589e8b4e252781d9", "target": 0, "func": "static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER */\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    /* base and limit */\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    /* Supported memory and i/o types */\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t/* VGA 16-bit decode */\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n", "idx": 1616, "substitutes": {"d": ["de", "ad", "dq", "n", "dos", "dn", "dom", "pd", "dh", "md", "dL", "q", "rd", "b", "c", "di", "td", "did", "nd", "new", "at", "dl", "dp", "mod", "r", "rest", "p", "dy", "sd", "ind", "out", "send", "dc", "dd", "D", "draw", "o", "df", "all", "ds", "end", "dt", "ld", "dat", "er", "da", "dm", "fd", "debug", "bd", "ed", "done", "dr", "du", "z", "details", "od", "add", "id", "m", "result", "dx", "db"]}}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n", "idx": 1621, "substitutes": {"pc": ["pn", "proc", "tp", " xp", "rc", " cs", "mc", "pic", "isc", "c", "lc", "pb", " p", "pt", "cu", " rc", "pr", "gc", "p", "pan", "cc", "cp", "pointer", "ec", "bc", "dc", "pi", "PC", "fc", "ic", "sc", "pp", "ac", "lp", " cc", " dc", "px", "arc", " proc", "unc", " ac", "vp", "tc", "ptr", "cs", "tx", "vc", " lac", "pid", "pa"], "tb": ["tenb", " tpb", "tbh", "ntbb", "tbd", "tebm", "ttb", "tipbl", "ertwb", "Tbl", "tdmb", "otsb", "ptb", "tmb", "tbe", "otbl", "tdb", "tdbl", "teb", "ptbl", "atbr", "tba", "tenbr", " tbd", "tbi", "tbb", "tbl", "ntbl", "otbb", "teba", "ntsb", " tbt", " tbb", "wtb", "tdsb", "tsb", "tracebd", "tdba", "tipb", "tipba", "atb", "ntb", "ptba", "temb", "tsmb", "tsba", " tbh", "traceb", "wtrb", "tbm", "atbt", "entb", "Tb", " twb", "wtbi", " trb", "trb", "tdbb", "Tbr", "tpb", "Tba", "ertbr", " tbl", "entrb", "twb", "tenbe", "ptbr", "entbi", "tbt", "entbt", "tracebb", "otb", "ertb", " tba", "tenbt", "tbr", "tracebh", "ttbr", "tipbt", "tdbm", " tbi", "entbl", " tbe", "tenbb", "tenbh", " tbr", "tenbd", "ertpb", "ttpb", "atbe", "tsbm", "ttwb", "wtba", "entba"], "ctx": ["inst", "Context", "nt", "org", "cmp", "kt", "cp", "ind", "cf", "nc", "scope", "conn", "voc", "resp", " cx", "etc", "ptr", "hw", "pkg", "cmd", "xp", "kb", "c", "lc", "pb", "worker", "cu", "anc", "req", "xy", "x", "jac", "xc", "jp", "cb", "wcs", "loc", "expr", "qa", "qt", "ctl", "wx", "np", "mc", "utils", "ca", "dl", "kl", "p", "cc", "aux", "mk", "sys", "cm", "co", "kw", "that", "addr", "bj", "cv", "tx", "ctr", "ctrl", "work", "exec", "cfg", "ct", "nd", "gc", "timeout", "bc", "context", "tz", "fc", "conf", "sc", "ns", "abc", "act", "pg", "unc", "tc", "bo"]}}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n", "idx": 1626, "substitutes": {"fd": ["ff", "rd", "td", "ind", "cf", "bf", "FD", "port", "draw", "fs", "ds", "dt", "ptr", "fed", "wind", " dur", "lf", " FD", "md", "gd", "ud", "did", "fa", "hd", "fe", "dc", "fi", "dd", "def", "ini", "ord", "ld", "dat", "cod", " d", "fn", "wd", "ctl", "desc", "vd", "fr", " ed", "dl", "sd", "fx", "elt", " ff", "df", "fl", "dir", "den", "poll", "disk", "du", "compl", " td", "proc", "form", "pd", " f", "nd", "d", "delay", "fp", "fc", "fin", "da", "unc", "bd", "dev", "f", "ffff", " fid", "cd", "pid", "db"]}}
{"project": "FFmpeg", "commit_id": "89f464e9c229006e16f6bb5403c5529fdd0a9edd", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    TiffContext *const s = avctx->priv_data;\n\n    AVFrame *const p = data;\n\n    ThreadFrame frame = { .f = data };\n\n    unsigned off;\n\n    int le, ret, plane, planes;\n\n    int i, j, entries, stride;\n\n    unsigned soff, ssize;\n\n    uint8_t *dst;\n\n    GetByteContext stripsizes;\n\n    GetByteContext stripdata;\n\n\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n\n\n    // parse image header\n\n    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid TIFF header\\n\");\n\n        return ret;\n\n    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n\n        av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    s->le          = le;\n\n    // TIFF_BPP is not a required tag and defaults to 1\n\n    s->bppcount    = s->bpp = 1;\n\n    s->photometric = TIFF_PHOTOMETRIC_NONE;\n\n    s->compr       = TIFF_RAW;\n\n    s->fill_order  = 0;\n\n    free_geotags(s);\n\n\n\n    // Reset these offsets so we can tell if they were set this frame\n\n    s->stripsizesoff = s->strippos = 0;\n\n    /* parse image file directory */\n\n    bytestream2_seek(&s->gb, off, SEEK_SET);\n\n    entries = ff_tget_short(&s->gb, le);\n\n    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)\n\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < entries; i++) {\n\n        if ((ret = tiff_decode_tag(s, p)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    for (i = 0; i<s->geotag_count; i++) {\n\n        const char *keyname = get_geokey_name(s->geotags[i].key);\n\n        if (!keyname) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);\n\n        if (ret<0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Writing metadata with key '%s' failed\\n\", keyname);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (!s->strippos && !s->stripoff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Image data is missing\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    /* now we have the data and may start decoding */\n\n    if ((ret = init_image(s, &frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->strips == 1 && !s->stripsize) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Image data size missing\\n\");\n\n        s->stripsize = avpkt->size - s->stripoff;\n\n    }\n\n\n\n    if (s->stripsizesoff) {\n\n        if (s->stripsizesoff >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,\n\n                         avpkt->size - s->stripsizesoff);\n\n    }\n\n    if (s->strippos) {\n\n        if (s->strippos >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripdata, avpkt->data + s->strippos,\n\n                         avpkt->size - s->strippos);\n\n    }\n\n\n\n    if (s->rps <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"rps %d invalid\\n\", s->rps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    planes = s->planar ? s->bppcount : 1;\n\n    for (plane = 0; plane < planes; plane++) {\n\n        stride = p->linesize[plane];\n\n        dst = p->data[plane];\n\n        for (i = 0; i < s->height; i += s->rps) {\n\n            if (s->stripsizesoff)\n\n                ssize = ff_tget(&stripsizes, s->sstype, le);\n\n            else\n\n                ssize = s->stripsize;\n\n\n\n            if (s->strippos)\n\n                soff = ff_tget(&stripdata, s->sot, le);\n\n            else\n\n                soff = s->stripoff;\n\n\n\n            if (soff > avpkt->size || ssize > avpkt->size - soff) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid strip size/offset\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,\n\n                                         FFMIN(s->rps, s->height - i))) < 0) {\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return ret;\n\n                break;\n\n            }\n\n            dst += s->rps * stride;\n\n        }\n\n        if (s->predictor == 2) {\n\n            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"predictor == 2 with YUV is unsupported\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            dst   = p->data[plane];\n\n            soff  = s->bpp >> 3;\n\n            if (s->planar)\n\n                soff  = FFMAX(soff / s->bppcount, 1);\n\n            ssize = s->width * soff;\n\n            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j++)\n\n                        dst[j] += dst[j - soff];\n\n                    dst += stride;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n\n            dst = p->data[plane];\n\n            for (i = 0; i < s->height; i++) {\n\n                for (j = 0; j < stride; j++)\n\n                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];\n\n                dst += stride;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->planar && s->bppcount > 2) {\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 1628, "substitutes": {"avctx": ["avctl", "afctx", "avectl", "avcontext", "avecmd", "avtx", "aftx", "avconn", "Avctx", "abtx", "averobj", "afctl", "airobj", "afcontext", "Avconn", "abconn", "avercu", "avercmd", "avehistory", "verconn", "ravctx", "Avcontext", "vercontext", "aircmd", "avcu", "avecu", "verctl", "abctx", "aveobj", "averhistory", "verctx", "avobj", " avcontext", "abcontext", "ravhistory", "avectx", " avctl", "aircu", "ravctl", "afcmd", "averctl", "averctx", " avconn", " avtx", "afcu", "avhistory", "Avctl", "avcmd", "afconn", "airctx"], "data": ["DATA", "first", "read", "str", "empty", "form", "bin", "only", "record", "bytes", "length", "response", "d", "frame", "block", "r", "map", "pointer", "buf", "pad", "stream", "window", "out", "offset", "body", "next", "Data", "header", "message", "format", "image", "result", "in", "file", "name", "value", "a", "dat", "feed", "t", "content", "table", "text", "ref", "size", "extra", "raw", "f", "rew", "padding", "id", "action", "buffer", "o", "ata"], "got_frame": ["got__type", "got__data", "ret_type", "got__frame", "gotacdata", "gotacnext", "ret_data", "gotacframe", "got_data", "ret_next", "got_next", "got_type", "got__next", "ret_frame", "gotactype"], "avpkt": ["avpatkt", "avPdu", "avjpmt", "avjpacket", " avpacket", "avjpdu", "avcpct", "avcpwt", "avppt", " avppt", "avopet", "avpmt", "avpacket", "avpatquet", "avpatpt", "avPet", " avpdu", "avjpet", "avjpkt", "avpatdu", "avpuf", " avPet", " avpuf", "avcpet", "avpquet", " avPacket", "avcpacket", "avopacket", "avbwt", "avjpuf", "avbet", "avPmt", " avPdu", "avcppt", " avPuf", " avPct", "avpatuf", "avpatct", "avcpkt", "avpatacket", " avpct", "avpdu", " avPpt", "avopmt", "avbkt", "avPwt", " avPkt", "avPkt", " avPmt", "avpwt", " avpmt", "avbacket", " avpet", "avPpt", " avPquet", "avPquet", "avpet", "avPuf", "avcpquet", "avPct", " avPwt", " avpwt", "avPacket", "avopkt", " avpquet", "avpct"], "s": ["n", "services", "ags", "is", "v", "ops", "parts", "ies", "fs", "ds", "bits", "sb", "h", "sq", "hs", "ars", "bs", "q", "ses", "c", "status", "ains", "ims", "ys", "sv", "os", "a", "vs", "sts", "ats", "as", "session", "ids", "details", "has", "ports", "qs", "uploads", "ps", "sys", "less", "ss", "tests", "ms", "space", "set", "params", "args", "rates", "mods", "sp", "m", "sam", "stats", "comm", "results", "es", "b", "ls", "sets", "d", "als", "ts", "its", "changes", "gs", "conf", "g", "ers", "se", "settings", "rs", "t", "ns", "ins", "S", "obj", "sw", "ess", "cs", "js", "aws"], "p": ["n", "bp", "tp", "np", "q", "b", "c", "pb", "P", "d", "w", "r", "cp", "ps", "pc", "fp", "l", "v", "ap", "jp", "g", "pp", "o", "lp", "pe", "t", "vp", "h", "f", "sp", "m", "pa"], "off": ["lf", "OFF", "of", "alf", "el", "ext", "open", "empty", "det", "offer", "ff", "half", "ew", "offs", "Off", "oa", "from", "new", "att", "start", "w", "on", "pad", "te", "offset", "out", "fun", "def", "low", "ele", "len", "shift", "reset", "xff", "ord", "un", "end", "set", "a", "addr", "op", "res", "load", "now", "t", "aj", "zero", "er", "size", "no", "dev", "eff", "raw", "cmd", "err", "ok", " OFF", "o", "pos", "line", "ex"], "le": ["de", "n", "ile", "el", "nl", "tle", "del", "ale", "li", "little", "bytes", "ly", "fle", "be", "ble", "start", "lege", "let", "la", "ell", "ll", "ve", "l", "te", "Le", "offset", "ge", "able", "lem", "e", "ler", "leg", "out", "ke", "oe", "ele", "len", "elt", "se", " l", "lt", "les", "ne", "end", "pe", "er", "ce", "t", "LE", "ue", "ed", "ole", "ptr", "lex", "lo", "sle", "line", "led"], "ret": ["alf", "flag", "ext", "del", "rets", "det", "over", "fr", "nt", "re", "tr", "prot", "att", "plain", "status", "ber", "try", "alt", "prop", "ll", " Ret", "pas", "mem", "out", "fi", "def", "rev", "ft", "gt", "ter", "rt", "elt", "deg", "port", "fin", "reset", "reg", "value", "success", "it", "resp", "Ret", "RET", "last", "res", "val", "rel", "cont", "print", "ref", "dr", "net", "red", "ure", "result", "back", "rem"], "plane": ["pipe", "flag", "axis", "spin", "slice", "flat", "mask", "frame", "pose", "png", "ve", "mode", "ge", "ane", "shift", "source", "origin", "fl", "pe", "perm", "depth", "drop", "shape", "dim", "clip", "fine", "pa"], "planes": ["ports", "anes", "images", "flat", "services", "codes", "boxes", "lists", "heads", "groups", "ops", "lines", "packages", "ips", "versions", "bands", "faces", "bits", "rows", "maps", "frames", "files", "pins", "pages", "names", "photos", "pieces"], "i": ["oi", "cli", "mi", "ni", "r", "ind", "ai", "v", "is", "ij", "ei", "ic", "it", "si", "y", "h", "id", "ti", "iu", "bi", "hi", "init", "q", "ui", "c", "di", "_", "x", "jj", "def", "ini", "zi", "xi", "ami", "iq", "cont", "index", "multi", "chain", "sim", "of", "I", "new", "im", "ki", "ip", "info", "ix", "ci", "us", "gi", "m", "k", "li", "b", "ii", "w", "ji", "\u0438", "e", "pi", "in", "g", "me", "qi", "t", "raw", "o"], "j": ["k", "n", "bi", "jc", "q", "jump", "b", "pos", "ni", "r", "dj", "ji", "l", "ind", "ij", "jj", "jac", "jp", "g", "jit", "kj", "z", "json", "jl", "js", "J", "m", "job"], "entries": [" entrys", "ientried", "Entrys", "entsries", "estents", "entrs", " entrance", "entry", "estrys", "ntries", "enties", "ntrs", "entsry", "entrance", "ientries", "estriers", "Entents", "entents", "Entrs", "entsents", "entriers", "entsies", "Entrance", "ientrys", "ENTries", "estries", "entsriers", "ENTies", "ntrance", "Entriers", "Entries", "Entry", "entried", "entsrys", "ENTry", "Entried", "ientriers", " entriers", "ENTrys", "entrys", " entrs", " entried", "ntrys", "Enties"], "stride": ["divride", "tride", "strider", "divide", "strride", "stice", "divider", "strice", "divice", "trice", "stider", "trride", "stide", "trider"], "soff": ["SOf", "sef", "sof", " soeff", "soeff", "SOffer", "SOff", "soffer", "SOeff", " soffer", " sof", "seeff", "seffer", "seff"], "ssize": ["rssiz", "sside", "ssized", "pside", "psiz", "typesiz", "typesized", "typeside", "rssized", "psized", "ssiz", "rssize", "psize", "typesize", "rsside"], "dst": ["dbct", "hbl", " dbl", " dct", "dbbl", "hst", "dbst", " dsw", "dbl", "hct", "hsw", "dsw", "dct", "dbsw"], "stripsizes": ["stripesizers", "stripesize", "striposides", "rippides", "ripsizes", "striposizers", "ripsize", "striposizes", "strippizes", "rippizers", "ripsides", "strippize", "stripsides", "rippize", "strippides", "stripsize", "stripesides", "stripesizes", "strippizers", "stripsizers", "ripsizers", "rippizes", "striposize"], "stripdata": ["clipfields", "sticksize", "solidsize", "sticktable", "clipsize", "cliptable", "soliddata", "clipdata", "striptable", "stickdata", "solidfields", "stripfields", "stripsize", "stickfields", "solidtable"], "keyname": ["keylamer", "keydame", "okeydename", "keyylamer", "okeyname", "okeydame", "keyylamed", "keyylame", "keynamed", "okeynAME", "keynname", "keynename", "keyyname", "keydAME", "keylame", "keynamer", "keyerAME", "keydamed", "keyynamed", "keydename", "kevernamer", "keylname", "keyerame", "keyamed", "okeynamed", "keyame", "keyylname", "okeydAME", "keyerename", "keyename", "kevernamed", "kevername", "keyAME", "keyeramed", "keyamer", "okeydamed", "kevernname", "keynAME", "keyynname", "keyynamer", "keylamed", "okeynename"]}}
{"project": "FFmpeg", "commit_id": "bd255f9feb4deea4c990e582f0ba3b90d7b64b4c", "target": 0, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n\n                                              int *got_picture_ptr,\n\n                                              AVPacket *avpkt)\n\n{\n\n    int ret;\n\n\n\n    *got_picture_ptr = 0;\n\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n\n        return -1;\n\n\n\n    avctx->pkt = avpkt;\n\n    apply_param_change(avctx, avpkt);\n\n\n\n    avcodec_get_frame_defaults(picture);\n\n\n\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n\n                                         avpkt);\n\n        else {\n\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n\n                                       avpkt);\n\n            picture->pkt_dts             = avpkt->dts;\n\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n\n            picture->width               = avctx->width;\n\n            picture->height              = avctx->height;\n\n            picture->format              = avctx->pix_fmt;\n\n        }\n\n\n\n        emms_c(); //needed to avoid an emms_c() call before every return;\n\n\n\n        if (*got_picture_ptr)\n\n            avctx->frame_number++;\n\n    } else\n\n        ret = 0;\n\n\n\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n\n     * make sure it's set correctly */\n\n    picture->extended_data = picture->data;\n\n\n\n    return ret;\n\n}\n", "idx": 1657, "substitutes": {"avctx": ["vrjac", "varcontext", "avjp", "avcrit", "wavjac", "navfunc", "avereq", " avpkg", "avfunc", "afcontext", "avkw", "avepkg", "navtx", "vercontext", "svjac", "avertmp", "avcc", "avcu", "avcb", "devsys", "abctx", "averkw", "avtc", "wavctx", "avecontext", " avjac", " avloc", " avconf", " avcmd", " avcb", "avcfg", "varjac", "savjp", "savcrit", " avcc", "ajsys", "wavcmd", "varpool", "actconf", "savcfg", "avcontext", "avecmd", "afctx", "vartxt", "ajcfg", "avefunc", "wavcfg", " avcrit", "navsys", "abtx", "avercontext", "avecfg", "avertxt", "ajjac", "wavtx", "avercu", " avkw", "vertx", "navwx", "aveconf", "vartx", "avejac", "actctx", "verctx", " avcontext", "abcontext", "avetmp", "vrcfg", "actpkg", " avcpu", "averctx", "averwx", "avpkg", " avcfg", "avloc", "avpool", "avetxt", "devctx", "avertx", "avecc", "averjac", "avtmp", "navtmp", "wavtmp", "ajtx", "navtxt", "avreq", "avercpu", "avtxt", "avercrit", "ajtmp", "wavcc", "wavfunc", "svctx", "wavcontext", "avectx", "savctx", "varctx", "navjac", " avtx", "afloc", "actcrit", "avcmd", "savcontext", "svcfg", "vrtx", "abcc", "abcpu", "devtc", "navcfg", "ajcu", "avtx", "vrctx", "aftx", "avsys", "avejp", "avekw", "navctx", "avercfg", "averreq", "avercmd", "ajtc", " avjp", "avconf", "acttx", "aveloc", " avreq", "aversys", "avertc", "avepool", "avcpu", "ajcontext", "avercc", "avecrit", "averpool", "devcontext", "ajctx", "navcontext", "avercb", "avjac", "avwx", "navcu", "navcb", "svtx", "navcc", "verjac", "actcontext", "avetx", "avewx"], "picture": ["friendly", "note", "support", "proof", "pict", "person", "query", "record", "pic", "iture", "summary", "style", "comment", "Picture", "frame", "pen", "pause", "family", "png", "description", "through", "feat", " Picture", "stat", "relative", "format", " profile", "pi", "def", "image", "pty", "power", "info", "video", "file", "performance", "audio", "secure", "important", "history", "position", "contact", "share", "profile", "foreign", "piece", "private", "join", "vp", "media", "feature", "policy", "pdf", "remember", "shape", "camera", "details", "import", "figure", "professional", "password", "print", "photo"], "got_picture_ptr": ["got_picture_bc", "got_picture_pos", "got_picture_offset", "got_picture_ctr", "got_picture_pointer", "got_profile_offset", "got_picture_Ptr", "got_picture_src", "got_profile_Ptr", "got_profile_pad", "got_profile_ptr", "got_profile_pointer", "got_pic_Ptr", "got_profile_ctr", "got_picture_addr", "got_pic_ptr", "got_profile_pos", "got_profile_addr", "got_pic_pointer", "got_pic_src", "got_profile_bc", "got_picture_pad"], "avpkt": ["airpacket", "avppelt", "avpackst", "avdck", "ajpackst", "ajpackmit", "avetpacket", "avpodconn", "avpayacket", "afppkt", "afppnt", "avwpelt", "avecpkl", "avpayket", "avcacket", "avpodkat", "avjpkt", "avtpnt", "ahpctx", "avPkg", "avwput", "ahjput", "avpayelt", "avPett", "avepkt", "avppnt", "ahjpck", "avpst", "airnpck", "avpodkl", "avwpkt", "ajpackkt", "avnpacket", "avPkt", "avpartkl", "avpartconn", "avjpctx", "ajpett", "ahpck", "airpkt", "ajpmit", "avppket", "afpnt", "avecpkat", "avwpctx", "avppmit", "wavpkt", "avpacket", "ahjpctx", "wavpelt", "wavpket", "avepkl", "avpett", "afppct", "avpck", "avcpck", "avtput", "airpck", "airnpacket", "avtpkg", "avetpkt", "avppacket", "avtpkt", "airpett", "avcpkl", "afpkt", "avcpkt", "avwpck", "ahpkt", "avPnt", "avpctx", "avpaykt", "avppkg", "avpkg", "avpartkat", "ahjpkt", "avecpconn", "avPct", "avpartkt", "avpct", "avpnt", "avepett", "avppck", "avcpconn", "avpket", "avnpck", "avcett", "afppkg", "airnpett", "avcpkat", "airnpkt", "avPst", "avwpket", "afpct", "avetput", "avpelt", "avppett", "wavppket", "avdacket", "avtpacket", "wavppelt", "avpconn", "avnpett", "avpackett", "avetpett", "avwpacket", "avdett", "avjpck", "avtpett", "avpodkt", "avppst", "avwpett", "avcut", "avppct", "avepacket", "avpkl", "afpkg", "avpackkt", "avpackmit", "avdkt", "wavppkt", "avepkat", "aveput", "avppkt", "avPmit", "ahput", "avpmit", "avnpkt", "wavpacket", "avckt", "ajpackett", "avpkat", "wavppacket", "avcpctx", "ajpst", "avput", "ajpkt", "avepconn", "avjput", "avtpct", "avecpkt", "avcput"], "ret": ["flag", "get", "del", "rets", "det", "final", "nt", "re", "summary", "sort", "tr", "uf", "ert", "att", "lit", "r", "gc", "alt", "pret", "ll", "pas", "mem", "out", "ort", "fun", "rm", "def", "rev", "gt", "ft", "ter", "rt", "len", "fin", "reset", "al", "success", "resp", "Ret", "report", "res", "RET", "t", "val", "cont", "cert", "ref", "usr", "mt", "desc", "reply", "print", "result", "back", "rem"], "frame_number": ["picture_number", "picture_index", "frame2num", "picture_count", "frame2index", "frame_count", "frame__num", "frame__index", "frame__number", "frame_num", "frame2count", "frame_index", "frame2number", "frame__count", "picture_num"]}}
{"project": "qemu", "commit_id": "87e459a810d7b1ec1638085b5a80ea3d9b43119a", "target": 1, "func": "static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n\n                                      MegasasCmd *cmd)\n\n{\n\n    struct mfi_pd_info *info = cmd->iov_buf;\n\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n\n    uint64_t pd_size;\n\n    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);\n\n    uint8_t cmdbuf[6];\n\n    SCSIRequest *req;\n\n    size_t len, resid;\n\n\n\n    if (!cmd->iov_buf) {\n\n        cmd->iov_buf = g_malloc0(dcmd_size);\n\n        info = cmd->iov_buf;\n\n        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n\n        info->vpd_page83[0] = 0x7f;\n\n        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info std inquiry\");\n\n            g_free(cmd->iov_buf);\n\n            cmd->iov_buf = NULL;\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info std inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {\n\n        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info vpd inquiry\");\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info vpd inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(pd_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    blk_get_geometry(sdev->conf.blk, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 1672, "substitutes": {"sdev": [" sbus", "ssdev", "sysdev", "jsdevice", "dsdevice", "sde", "sysbus", "ssdevice", " svision", "osdev", "jsdev", "dsev", "jsvision", "osde", "svision", "dsdev", "sserv", "sgu", "svdevice", "svgu", "pserv", "jsde", "osdevice", "svserv", "pdev", "sdevice", "ssbus", "osgu", "pgu", " sdevice", " sde", "sysdevice", "dsve", "pdevice", "osserv", " sve", " sev", "sve", "sev", "osvision", "sbus", "svdev"], "lun": ["llun", " loun", "leoun", "lon", "Lmun", "mLmun", " lUN", " lug", "llsun", "slon", "loud", "ploun", " lunc", "LUN", "plout", "mLun", "leoud", "lout", "plun", "lmun", "lnun", "leout", "slunt", " loud", "llon", "Lun", "Luna", "slUN", "eluna", "elUN", "Lon", "lunt", "slun", "elun", "leun", "lug", "Lunt", "lnug", " lsun", "lnunc", "lsun", "lUN", "loun", " lunt", "Lsun", "ploud", "llUN", "luna", "elmun", " lon", "mLuna", "lunc", "mLUN", "lnUN", " lout", "Lunc", "Lug"], "cmd": ["dq", "cli", "fresh", "nt", "target", "cmp", "kt", "control", "cp", "ind", "std", "cf", "crit", "kick", "conn", "resp", "dm", "txt", "pkg", "json", "range", "tab", "cr", "md", "batch", "comp", "buf", "command", "def", "kind", "mom", "force", "host", "cb", "cont", "mt", "ctl", "desc", "config", "urg", "ext", "cat", "build", "utils", "quit", "grow", "controller", "cc", "ck", "mk", "cm", "ctx", "addr", "msg", "report", "phy", "ctr", "ctrl", "Cmd", "form", "det", "exec", "comm", "cfg", "ct", "opt", "send", "bind", "news", "call", "obj", "raw", "err", "cd", "update", "job", "client"], "info": ["count", "iter", "time", "metadata", "error", "by", "cache", "i", "ind", "recent", "history", "conn", "it", "fee", "tif", "order", "dict", "json", "id", "ti", "tab", "note", "init", "app", "INFO", "api", "about", "auth", "fi", "def", "kind", "list", "bit", "num", "loc", "meta", "inf", "index", "debug", "no", "details", "config", "basic", "j", "data", "of", "ready", "help", "try", "p", "admin", "ip", "good", "name", "information", "key", "addr", "op", "state", "unknown", "notice", "Info", "det", "query", "comment", "fo", "ignore", "local", "type", "check", "mem", "stat", "conf", "important", "t", "now", "ref", "f", "buff", "update"], "pd_size": ["PD_Size", "PD_ize", "pd_len", "PD_len", "PD_size", "pd_ize", "pd_Size"], "cmdbuf": ["mdfb", " cmdBuffer", "mdwindow", "commbox", "mdbuff", " cmdbox", "ctBuffer", "commanddb", " cmdbuffer", "ctbuff", "commbuffer", "mdbuffer", "commandqueue", "commandbuff", "mdqueue", "cmdBuffer", "commandbc", " cmdbuff", "mdbuf", "commbc", " cmdbc", "cmdbuffer", "cmdwindow", "reqbuff", "cmdqueue", "commdb", "ctlbuf", " cmddb", "ctbuf", "ctbuffer", "commandBuffer", "cmdfb", "ctlfb", " cmdwindow", "cmddb", "mdbc", "ctlbuffer", "cmdbc", "commfb", "reqqueue", "reqbuf", "reqbuffer", "commbuf", "commandbuf", "commwindow", "cmdbox", "ctlbc", "mdbox", "cmdbuff", "commandbuffer", "mddb"], "req": ["dq", "wx", "repl", "eq", "ext", "str", "needed", "seq", "rep", " resp", "q", "md", "fresh", "cmp", "gz", "func", "dist", "cond", " requ", "comp", "rec", "rx", "ind", "aux", "require", "qq", "def", "jp", "crit", "conf", "rt", "par", "ctx", "rr", "expr", "resp", "iq", "msg", "res", "quest", "qt", "rel", "usr", "call", "ptr", "progress", "pkg", "sq", " requisite", "request", "requ", "tx", "red", "need", "err", "required", "desc", "js", "j", "ctr", "urg", "compl"], "len": ["lf", "lon", "el", "lib", "nl", "str", "del", "rc", "var", "wid", "seq", "length", "bytes", "cmp", "gz", "nt", "ls", "pos", "html", "dl", "comp", "lim", "ret", "gl", "ll", "l", "mem", "offset", "fun", "rev", "low", "elt", "fin", "num", "en", "all", "Len", "coll", "fl", "ld", "resp", "fn", "pl", "val", "ref", "size", "qual", "ln", "lang", "f", "sp", "err", "data", "vec", "compl"], "resid": ["Resnum", "Resids", "revnum", " resident", " resids", "revid", "Resident", "resnum", "revident", "resident", "Resid", " resnum", "resids", "revids"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 1710, "substitutes": {"ctx": ["nw", "wx", "kb", "work", "np", "nt", "mc", "cmp", "exec", "grad", "cfg", "ct", "c", "lc", "cur", "cu", "kt", "bh", "kl", "anc", "cp", "cc", "req", "check", "pc", "std", "ck", "sys", "context", "bc", "dc", "prefix", "kw", "jp", "xc", "crit", "conf", "info", "nc", "history", "conn", "cb", "kj", "wcs", "resp", "addr", " cx", "qt", "abc", "act", "etc", "tc", "cl", "hw", "pkg", "lex", "ctl", "cmd", "tx", "desc", "typ", "config", "xp", "kg"], "l1": ["t1", "l01", "t3", "mOne", "lOne", "sl81", "v01", "sl01", "v2", "L1", "m1", "sl1", "sl2", "t2", " L2", "v81", "m2", "l81", " l81", " l01", " L1", "L3", "L0", "l0", " L3", " l3", "v1", " lOne", "l3", "m3", "L2", " l0", " LOne"], "l2": ["L1", "el02", "nl0", "l6", "nl2", "Lst", " l02", "ltwo", "nltwo", "eltwo", "nl6", "li1", "l02", "nl02", "L3", "list", "L0", "el2", " l6", "L02", "el1", "l0", " l3", "L6", "li3", "l3", " lst", " ltwo", "li2", "L2", "lst", " l0", "nl1"], "mask": ["Mask", "count", "flag", "form", "hash", "filter", "mc", "wm", "sign", "tr", " Mask", "sk", "map", "gc", "cache", "sum", "type", "match", "mas", "miss", "window", "mode", "mk", "cm", "bm", "conf", "bit", "ms", "hide", "ask", "key", " masked", "ma", "flags", "bits", "lock", "zero", "perm", "bool", "mt", "pack", "mb", "mut", "scale", "weight", "mu", "fac", "ch", "label", "level", "m", " masks", "gate"], "t0": ["te2", "ozero", "t1", "p8", "t3", "te0", " t2", "p3", "tau", "tzero", " tzero", "t2", " t1", "time2000", "td2000", "p1", "f8", "f0", " t3", "thk", " t2000", " t8", "time0", "td0", "f2", " t5", "l00", "th0", " t00", "f1", "t00", "p2", "thzero", "tk", "l0", "t8", " tk", "t2000", "timeau", "td5", "p0", "time5", "te00", "o00", "tdau", "te1", "t5", "ok", " tau", "o0", "f3", "th00"]}}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_process_mem2s(struct Stream *s,\n\n                                 StreamSlave *tx_dev)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned char txbuf[16 * 1024];\n\n    unsigned int txlen;\n\n    uint32_t app[6];\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return;\n\n    }\n\n\n\n    while (1) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        if (stream_desc_sof(&s->desc)) {\n\n            s->pos = 0;\n\n            memcpy(app, s->desc.app, sizeof app);\n\n        }\n\n\n\n        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if ((txlen + s->pos) > sizeof txbuf) {\n\n            hw_error(\"%s: too small internal txbuf! %d\\n\", __func__,\n\n                     txlen + s->pos);\n\n        }\n\n\n\n        cpu_physical_memory_read(s->desc.buffer_address,\n\n                                 txbuf + s->pos, txlen);\n\n        s->pos += txlen;\n\n\n\n        if (stream_desc_eof(&s->desc)) {\n\n            stream_push(tx_dev, txbuf, s->pos, app);\n\n            s->pos = 0;\n\n            stream_complete(s);\n\n        }\n\n\n\n        /* Update the descriptor.  */\n\n        s->desc.status = txlen | SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 1712, "substitutes": {"s": ["esm", "an", "services", "ast", "r", "i", "south", "is", "v", "views", "sync", "ops", "parts", "fs", "ds", "http", "bits", "sb", "y", "h", "sq", "hs", "sports", "bs", "ses", "c", "ains", "ims", "sv", "os", "vs", "sts", "ats", "z", "details", "ports", "qs", "events", "ssl", "p", "ps", "comments", "l", "sys", "less", "ss", "search", "tests", "ms", "bis", "state", "sl", "sp", "aunts", "m", "sam", "spec", "stats", "xs", "self", "comm", "es", "b", "ls", "als", "ts", "its", "changes", "gs", "socket", "conf", "g", "se", "tes", "rs", "ns", "t", "serv", "ins", "S", "sw", "cs", "storage", "js", "aws"], "tx_dev": ["tx_Dev", "mm_Dev", "tx2Dev", "tx_link", "txxdev", "tx2div", "tx_div", "mm_ev", "TX2link", "tx2dev", "tx2device", "tx2link", "txxlink", "tx_device", "TX_link", "mm_div", "tx2ev", "TX2dev", "TX_device", "mm_dev", "tx_ev", "txxdevice", "TX2device", "TX_dev"], "prev_d": ["prev__r", "prev___v", "pre_p", "pre_r", "prev_p", "prev___d", "vious_l", "next___r", "pre___d", "prev__v", "next___v", "prev___r", "next_D", "pre___D", "prev_dh", "prev_D", "prev__D", "vious_dh", "pre_D", "prev_v", "vious_D", "next___D", "prev_l", "vious_d", "pre_d", "next_d", "prev___p", "pre___p", "next_r", "prev__d", "next_v", "prev___D", "prev_r", "next___d", "pre___r", "prev__p"], "txbuf": [" txlim", "xbuf", "ctxbuff", "txtb", "txdoc", "ctxdoc", "ctxBuffer", "xdb", "txlim", "txtstr", " txstr", "txtlim", "ctxbuffer", "TXb", " txb", "ctxbuf", " txqueue", " txbuffer", "ctxdb", "txtdoc", "txtqueue", "txtbuffer", "TXvec", " txvec", " txbuff", " txdb", "txb", " txdoc", "txBuffer", "txstr", "ctxlim", " txBuffer", "txbuffer", "ctxlen", "txtBuffer", "txvec", "txbuff", "ctxqueue", "TXbuffer", "xlen", "txdb", "txtbuf", "TXbuf", "txqueue", "xbuff", "ctxstr", "txtvec"], "txlen": ["TxLen", " txlim", " txmn", "actbuf", "xbuf", "ctxlan", "rxlf", "rxen", "txlim", "Txl", "actlf", "ctxlength", "txlf", "Txlim", "txlength", "ctxcompl", "translen", "TXen", "txlan", "ctxbuf", "txtlan", "TXlength", "transvec", "rxLen", " txlf", "rxlength", "Txlen", "transcompl", " txlength", " txen", "txLen", "transLen", "txtlen", "rxlim", "TXlen", "rxlen", "txtlength", "txl", "transmn", " txLen", "txmn", "TXmn", "TXLen", "rxbuf", "xlan", "ctxLen", "ctxlen", " txl", "rxl", "actlen", "xlength", "defLen", "actlength", "txvec", "ctxvec", "txen", "xlen", "deflen", "txtbuf", "TXbuf", "txcompl", "deflength", "translength", "txtvec", "defbuf", "txtcompl"], "app": ["sam", "proc", "stack", "attr", "ext", "j", "form", "cap", "seq", "var", "q", "display", "b", "cell", "comp", "cache", "map", "mp", "App", "p", "buf", "req", "apply", "ps", "APP", "mem", "window", "v", "out", "ap", "append", "arr", "apps", "reg", "ms", "pp", "prev", "conn", "all", "ac", "ev", "aps", "win", "msg", "acc", "res", "base", "bb", "dev", "snap", "pack", "pre", "allow", "raw", "sp", "tx", "js", "mac", "buff", "m", "tab", "db", "application"]}}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1713, "substitutes": {"avctx": ["avjp", "afcb", "Avctx", " avpkg", "afcontext", "wavkw", "avkw", "avepkg", "avcb", "averkw", "wavctx", "avecontext", "avekt", " avvals", " avcb", "afcmp", "avekb", "avvals", "evkb", "evcmp", "avaddr", "afctx", "avcontext", "avekl", "avercontext", "wavtx", "avercp", "avkb", "aveconf", " avcp", "wavpkg", " avcontext", "ajaddr", "averctx", "avpkg", "wavreq", "avecmp", "afaddr", "avertx", "afjp", " avkt", "evcontext", "avreq", " avkb", "wavcontext", "avectx", "wavcp", "averpkg", " avtx", "avervals", "avkl", "aveaddr", "avcmp", "Avcmp", "avtx", "wavvals", "aftx", "afpkg", "avejp", "avekw", "ajconf", "averreq", " avjp", "avconf", "afkt", " avcmp", "Avcontext", " avreq", "afconf", "Avcb", "ajcontext", "avcp", "avkt", "evctx", "ajctx", "averkl", "wavkl", "avetx"], "c": ["cr", "form", "rc", "mc", "cmp", "ct", "ca", "com", "lc", "at", "cu", "oc", "gc", "p", "cache", "anc", "cc", "cp", "ec", "pc", "cf", "bc", "dc", "cm", "co", "xc", "conf", "fc", "ic", "sc", "nc", "ctx", "ac", "coll", "cb", "C", "ce", "cor", "ci", "t", "ctrl", "abc", "content", "cont", "arc", "enc", "etc", "cv", "cl", "tc", "uc", "call", "unc", "cs", "vc", "ch", "chain", "config", "con"]}}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n", "idx": 1721, "substitutes": {"hci": ["rhadi", "ccci", "Hcli", " hcci", "achcci", "rhcci", "achcli", "ghadi", "khci", "heci", "Hcci", "ccu", "hece", "Hco", " hco", "hce", "rhcin", "hii", " hce", " hadi", "ghcin", "khc", "hadi", " hii", "Hci", "achci", "ghcci", "cce", " hcin", " hc", "hcli", "hco", "rhci", "cci", " hcu", "heii", "khii", "khcu", "hecu", "ghci", "hecci", " hcli", "hcu", "hcci", "achco", "hec", "hc", "hcin"], "params": ["param", "options", " p", "points", "pas", "asm", "ops", " param", "parts", "keys", "par", "docs", "pins", "json", "padding", "errors", "pretty", "actions", "pos", "pps", "styles", "lines", "ims", "vs", "Par", "types", "vals", "shape", "details", "names", "config", "properties", "data", "ports", "posts", "users", "new", " parameters", "p", "ps", "comments", "mm", "members", "terms", "info", "name", "ctx", "las", "times", "state", "args", "tmp", "ams", "cas", "result", "spec", "stats", "results", "ls", "pointer", "type", "tags", "changes", "tracks", "parse", "units", "packages", "settings", "layout", "rs", "size", "obj", "AMS"]}}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 1726, "substitutes": {"vs": ["posts", "stats", "xs", "bs", "qs", "lbs", "ics", "ses", "nets", "vr", "otes", "atts", "ls", "blogs", "lists", "ts", "fps", "its", "vt", "Vs", "gs", "v", "terms", "ks", "ss", "obs", "ims", "ms", "sv", "fs", "ds", "eps", "sts", "wcs", "vers", "rs", "ns", "serv", "sb", "ins", "vp", "VS", "vals", "cs", "hs", "caps", "vc", "qv", "js"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 1736, "substitutes": {"str": ["s", "attr", "input", "seq", "fr", "length", "tr", "b", "cur", "start", "r", "pr", "Str", "p", "buf", "i", "ind", "vol", "out", "st", "gr", "stri", "arr", "list", "len", "g", "STR", "source", "br", "doc", "end", "msg", "res", "t", "text", "txt", "ptr", "f", "cs", "sp", "chain", "buffer", "ctr", "print", "data", "pos"], "endptr": ["endedtr", "ndpointer", " endpointer", "ENDptr", "endedaddr", "endser", " endPtr", "endedreq", "endreq", " endaddr", " endvar", "ENDPtr", "endingpointer", "ENDtr", "endedPtr", " endtr", "endvar", " endser", "startptr", "endPtr", "endaddr", "startpointer", "ndtr", "endingser", "ENDreq", "endpointer", "endedpointer", "endingvar", " endreq", "endedptr", "ndaddr", "startser", "endtr", "ndptr", "endingptr", "startvar"], "err": ["cr", "attr", "rc", "iter", "fr", "erer", "cmp", "re", "tr", " res", "error", "kr", "r", "pr", "req", "i", " error", "Error", " ptr", " gr", "gr", "die", "oe", "erm", "arr", "elt", "exc", "rn", "rr", "br", " terr", " r", "ev", "or", "it", " er", "resp", "er", "msg", "der", "res", "rs", "resh", " fr", "obj", "ptr", "dr", " cr", "cer", "Er", "ox", "ch", "errors", "result", "urg", "nr"]}}
{"project": "qemu", "commit_id": "aaf89c8a49a8c1259b6b181d701070c6df83f3d7", "target": 0, "func": "static void test_migrate(void)\n\n{\n\n    char *uri = g_strdup_printf(\"unix:%s/migsocket\", tmpfs);\n\n    QTestState *global = global_qtest, *from, *to;\n\n    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;\n\n    gchar *cmd;\n\n    QDict *rsp;\n\n\n\n    char *bootpath = g_strdup_printf(\"%s/bootsect\", tmpfs);\n\n    FILE *bootfile = fopen(bootpath, \"wb\");\n\n\n\n    got_stop = false;\n\n    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);\n\n    fclose(bootfile);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcsource,debug-threads=on\"\n\n                          \" -serial file:%s/src_serial\"\n\n                          \" -drive file=%s,format=raw\",\n\n                          tmpfs, bootpath);\n\n    from = qtest_start(cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcdest,debug-threads=on\"\n\n                          \" -serial file:%s/dest_serial\"\n\n                          \" -drive file=%s,format=raw\"\n\n                          \" -incoming %s\",\n\n                          tmpfs, bootpath, uri);\n\n    to = qtest_init(cmd);\n\n    g_free(cmd);\n\n\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    global_qtest = to;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* We want to pick a speed slow enough that the test completes\n\n     * quickly, but that it doesn't complete precopy even on a slow\n\n     * machine, so also set the downtime.\n\n     */\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_speed',\"\n\n              \"'arguments': { 'value': 100000000 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* 1ms downtime - it should never finish precopy */\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_downtime',\"\n\n              \"'arguments': { 'value': 0.001 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n\n\n    /* Wait for the first serial output from the source */\n\n    wait_for_serial(\"src_serial\");\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate',\"\n\n                          \"'arguments': { 'uri': '%s' } }\",\n\n                          uri);\n\n    rsp = qmp(cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    wait_for_migration_pass();\n\n\n\n    rsp = return_or_event(qmp(\"{ 'execute': 'migrate-start-postcopy' }\"));\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    if (!got_stop) {\n\n        qmp_eventwait(\"STOP\");\n\n    }\n\n\n\n    global_qtest = to;\n\n    qmp_eventwait(\"RESUME\");\n\n\n\n    wait_for_serial(\"dest_serial\");\n\n    global_qtest = from;\n\n    wait_for_migration_complete();\n\n\n\n    qtest_quit(from);\n\n\n\n    global_qtest = to;\n\n\n\n    qtest_memread(to, start_address, &dest_byte_a, 1);\n\n\n\n    /* Destination still running, wait for a byte to change */\n\n    do {\n\n        qtest_memread(to, start_address, &dest_byte_b, 1);\n\n        usleep(10 * 1000);\n\n    } while (dest_byte_a == dest_byte_b);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n    /* With it stopped, check nothing changes */\n\n    qtest_memread(to, start_address, &dest_byte_c, 1);\n\n    sleep(1);\n\n    qtest_memread(to, start_address, &dest_byte_d, 1);\n\n    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);\n\n\n\n    check_guests_ram();\n\n\n\n    qtest_quit(to);\n\n    g_free(uri);\n\n\n\n    global_qtest = global;\n\n\n\n    cleanup(\"bootsect\");\n\n    cleanup(\"migsocket\");\n\n    cleanup(\"src_serial\");\n\n    cleanup(\"dest_serial\");\n\n}\n", "idx": 1760, "substitutes": {"uri": ["phi", "query", "ui", "unit", "uid", "iri", "path", "ir", " URI", "remote", "uu", "username", "i", "ip", "connection", "ur", "prefix", "file", "name", "nil", "url", "handle", "origin", "uni", "dir", "http", "ref", "resource", "subject", "filename", "folder", "du", "address", "URI", "id", "domain", "ri", "directory", "io"], "global": [" local", "final", "util", "remote", "gc", "cache", "local", "gl", "parent", "prefix", "io", "common", "g", "origin", "go", "gu", "master", "msg", "foreign", "external", "user", "size", "Global", "module", "tmp", "unique", "client", "general"], "from": ["of", "bound", "via", "this", "init", "form", "initial", "only", "fr", "self", "org", "normal", "new", "From", "path", "start", "by", "remote", "after", "local", "old", "out", "st", "in", "before", "source", "reset", "false", "origin", "or", "un", "end", "a", "set", "so", "state", "as", "and", "no", "us", "with", "f", "add", "range", "off", "owner", "base"], "to": ["phi", "test", "bound", "tp", "via", "pro", "toc", "target", "tt", "nt", "b", "new", "pb", "eto", "tu", "by", "at", "pt", "try", "after", "p", "ts", "bo", "timeout", "into", "To", "out", "sys", "tom", "co", "gt", "info", "two", "tz", "that", "or", "tk", "ont", "too", "it", "ta", "total", "op", "t", "table", "no", "obj", "dev", "tmp", "with", "TO", "range", "until", "o", "client", "top"], "dest_byte_a": ["dest_byte2b", "dest_byte2area", "dest_byte2a", "dest_byte_area"], "dest_byte_b": ["dest_byte2c", "dest_byte2b", "dest_byte2a"], "dest_byte_c": ["dest_word_ca", "dest_byte8c", "dest_byte_ca", "dest_byte8ca", "dest_byte_e", "dest_byte8d", "dest_word_c", "dest_word_d", "dest_byte8e", "dest_word_e"], "dest_byte_d": ["dest_char_n", "dest_char_d", "dest_byte_n", "dest_byte_data", "dest_char_data", "dest_char_c"], "cmd": ["method", "dq", "cli", "target", "nt", "cmp", "xml", "cp", "ind", "cf", "MD", "handle", "conn", "dm", "txt", "pkg", "xp", "tab", "prop", "init", "cgi", "md", "gz", "batch", "comp", "req", "command", "def", "rev", "col", "cb", "qt", "cont", "mt", "term", "data", "ext", "quit", "quick", "try", "ret", "arg", "out", "mk", "norm", "name", "ctx", "addr", "msg", "dir", "op", "args", "text", "tmp", "phy", "tx", "ctr", "Cmd", "css", "pipe", "exec", "comm", "grad", "cfg", "ct", "path", "clean", "html", "mem", "send", "bind", "fun", "conf", "url", "res", "cert", "ref", "call", "act", "obj", "raw", "err", "cd", "js", "job"], "rsp": ["rrbsp", "rpl", "pmp", "rcsp", "rcst", "rsSP", "rssp", "gSP", "grbsp", " rmp", " rpc", "rdosp", " rjp", "prserv", "srbsp", "nserv", "rcpt", "rpc", " risp", "nrpc", "rserv", "Rbsp", "mrsp", "arlp", "rrsp", "prSP", "sSP", "rdpt", "resp", "dmp", "mrmp", "qpc", "rresp", "rdst", "arSP", "srosp", " rsm", " rosp", "arsp", "rdmp", "srisp", "hsp", "hresp", "rdisp", "erSP", "dresp", "RSP", "mrSP", "msp", "Rsp", "ssp", "erjp", "srSP", " rst", "nmp", "nrsp", "mmp", "srsp", "erpl", "qsm", "grpc", "pserv", "rrSP", "prmp", "drresp", "misp", "Rlp", " rSP", "smp", "nrosp", "qosp", "grSP", "rlp", " rbsp", "rdpc", " rp", "rp", " rlp", "rdSP", "np", "prsp", " rpl", "rjp", "rpt", "risp", "qresp", "sserv", "mjp", "mrjp", "mrserv", "rrisp", "rsbsp", "qsp", "dSP", "pp", "roSP", "Risp", "qSP", "sresp", "drSP", "qlp", "rsmp", " rserv", "gsp", "nrSP", "gserv", "srmp", "mSP", "drbsp", "drsp", "ersp", "hbsp", "ropc", "nsp", "arsm", "rdsp", "rosp", "robsp", "rmp", "rbsp", " resp", "rSP", "mbsp", "rcisp", "psp", "dsp", " rpt", "srlp", "rsm", "djp", "rst", "hosp", "rrpc", "grsp", "mrpl", "Resp", "gmp", "qesp", "qbsp", "drisp", "drosp"], "bootpath": ["busfile", "bootlog", "ootdir", "ootlog", " bootlog", " bootdir", "BootPath", "diskPath", "busPath", "Bootdir", "boottime", "buspath", "ootpath", "disktime", "diskpath", "ootfile", " bootPath", "Bootpath", "bootPath", "busdir", "ootPath", "oottime", "Bootfile", "diskfile", " boottime", "bootdir", "buslog"], "bootfile": ["busfile", " bootf", "bootlog", "ootdir", "ootlog", " bootlog", " bootdir", " bootbuffer", "bootbuffer", " bootfiles", "ootfiles", "busline", "buspath", "Bootfiles", "busbuffer", "Bootf", "ootpath", "bootfiles", "ootline", "bootline", "ootfile", "Bootpath", "busdir", "ootf", " bootline", "Bootfile", "ootbuffer", "bootdir", "buslog", "bootf"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n", "idx": 1770, "substitutes": {"pkt": ["qkt", " pnt", "ppwk", "ppdu", " packet", " pct", "packnt", "rkt", "rnt", "pet", "qacket", "pemsg", "Pdu", "Pct", " pft", "rck", "packet", "qnt", "packkg", " pck", "pct", "pewk", "packwk", "pck", "Pnt", "cpnt", "cpkt", "Packet", "qct", "Pwk", "ppet", "Pmsg", "Pet", " pkg", " pmsg", "cpck", "packkt", "ppkt", "cpacket", "racket", "pnt", "pdu", "Pft", "peft", "Pkt", "Pkg", "pft", "pkg", " pwk", " pdu", "pmsg", " pet", "pwk", "pekt"], "tso_enable": ["tso_success", "tsoiforce", "tco_enable", "tsoienabled", "tso_complete", "tso_enabled", "tco_enabled", "tco_ve", "tsopleenable", "tco_complete", "tco_force", "tso_force", "tsoienable", "tsoplecomplete", "tsopleenabled", "tsopleve", "tco_success", "tsoisuccess", "tso_ve"], "l3_proto": ["l3_prol", "l3_roto", "l3_pergo", "l3_perbo", "l3_pubgo", "l3_pub", "l3_prto", "l3_progo", "l3_procb", "l3_proTO", "l3_rote", "l3_propto", "l3_propco", "l3_procTO", "l3_propbo", "l3_perco", "l3_puto", "l3_propgo", "l3_pute", "l3_pubto", "l3_prte", "l3_procl", "l3_pubco", "l3_rob", "l3_proco", "l3_groto", "l3_grol", "l3_probo", "l3_pugo", "l3_groTO", "l3_procto", "l3_prob", "l3_prote", "l3_rogo", "l3_grob", "l3_perto", "l3_pubbo", "l3_prgo", "l3_prb"]}}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    switch (cmd[0] >> 5) {\n\n    case 0:\n\n        req->cmd.xfer = cmd[4];\n\n        req->cmd.len = 6;\n\n        /* length 0 means 256 blocks */\n\n        if (req->cmd.xfer == 0)\n\n            req->cmd.xfer = 256;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        req->cmd.xfer = cmd[8] | (cmd[7] << 8);\n\n        req->cmd.len = 10;\n\n        break;\n\n    case 4:\n\n        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);\n\n        req->cmd.len = 16;\n\n        break;\n\n    case 5:\n\n        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);\n\n        req->cmd.len = 12;\n\n        break;\n\n    default:\n\n        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);\n\n        return -1;\n\n    }\n\n\n\n    switch(cmd[0]) {\n\n    case TEST_UNIT_READY:\n\n    case START_STOP:\n\n    case SEEK_6:\n\n    case WRITE_FILEMARKS:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case LOAD_UNLOAD:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n        req->cmd.xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME:\n\n        req->cmd.xfer = 1;\n\n        break;\n\n    case READ_CAPACITY:\n\n        req->cmd.xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        req->cmd.xfer = 6;\n\n        break;\n\n    case READ_POSITION:\n\n        req->cmd.xfer = 20;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        req->cmd.xfer *= 40;\n\n        break;\n\n    case MEDIUM_SCAN:\n\n        req->cmd.xfer *= 8;\n\n        break;\n\n    case WRITE_10:\n\n    case WRITE_VERIFY:\n\n    case WRITE_6:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case READ_10:\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case INQUIRY:\n\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n\n        break;\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (req->dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1783, "substitutes": {"req": ["dq", "uj", "dep", "org", "cmp", "dist", "cur", "r", "rest", "ind", "qq", "queue", "crit", "ocr", "grab", "conn", "alg", "resp", "quest", "http", "txt", "pkg", "sq", "request", "app", "var", "q", "md", "comp", "rec", "rw", "decl", "require", "prefix", "gr", "jp", "mom", "expr", "wcs", "qt", "rel", "agg", "rend", "requ", "desc", "config", "urg", "pro", "wx", "ext", "needed", "seq", "fr", "rb", "quick", "ret", "tek", "aux", "good", "inv", "rt", "exc", "reg", "ctx", "rr", "task", "addr", "rpm", "msg", "usr", "tx", "required", "compl", "proc", "eq", "query", "exec", "comm", "temp", "conf", "prev", "res", "ref", "progress", "buff", "client"], "cmd": ["dq", "cli", "dep", "fresh", "nt", "cmp", "xml", "cur", "kt", "control", "og", "rest", "cp", "ind", "std", "rm", "pay", "crit", "handle", "conn", "go", "dt", "txt", "module", "dict", "pkg", "off", "tab", "prop", "del", "init", "md", "batch", "att", "map", "buf", "old", "command", "def", "gt", "col", "force", "cb", "iq", "cod", "qt", "cont", "mt", "pack", "ctl", "desc", "term", "urg", "ext", "cat", "seq", "help", "bg", "quit", "quick", "try", "ret", "good", "mk", "inv", "low", "ctx", "wo", "addr", "msg", "op", "args", "text", "dr", "phy", "mac", "ctr", "ctrl", "Cmd", "ht", "det", "bytes", "exec", "comm", "grad", "cfg", "ct", "cond", "gen", "pt", "vt", "img", "mem", "send", "hot", "bind", "fun", "hold", "mg", "adv", "now", "content", "serv", "act", "call", "raw", "err", "js", "buff", "news", "job"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n", "idx": 1791, "substitutes": {"queue": ["dq", "collection", "stack", "flag", "empty", "que", "library", "q", "batch", "display", "future", "forced", "entry", "worker", "block", "frame", "channel", "status", "remote", "cache", "buf", "match", "thread", "select", "bar", "prefix", "trace", "context", "message", "command", "client", "archive", "list", "grid", "menu", "file", "space", "quote", "line", "force", "history", "store", "server", "manager", "master", "Q", "process", "qa", "profile", "Queue", "msg", "widget", "component", "ue", "table", "user", "priority", "database", "state", "tree", "console", "request", "buffer", "required", "complete", "sequence"], "p_data": ["p_ret", "pimybuf", "pi_buf", "pi_data", "pmyata", "post_ata", "post_value", "pimydata", "pimyret", "pmynext", "post_data", "p_next", "p_value", "post_next", "p_ata", "pmyret", "pmybuf", "pmyvalue", "p_buf", "pi_ret", "pmydata"], "p_new": ["p2next", "pOKnode", " p2new", "pfnew", "pcolynew", "polynew", "polynow", "paxydot", "pa_New", "paxyand", " p_New", " p2blank", "polyvalid", "pflocal", "p_fresh", "p_next", "p_New", "tp_and", "pa_dev", "p2blank", " p_blank", "pfold", "paxynext", "tp_next", "p2data", "pa_new", "pOKnew", "pOKblank", "p_and", "pa_dot", "p2local", " p_fresh", "p2good", "pafnew", " p_node", "p_old", "p_good", "p_valid", "p2and", " p2data", "paflocal", "pfNew", " p_non", "paxynew", "p_non", "p_dot", "pc_now", "p_now", "tp_new", "pOKdata", "pa_local", " p2node", "p_node", "pc_valid", "p_dev", "paxygood", "p2New", "p2new", "p2old", "paxydev", "pa_old", "tp_good", "p2node", "pc_new", "p_blank", "pcolyvalid", "p_local", "pcolynow", "pafNew", "pafold"], "size": ["n", "count", "empty", "length", "c", "sn", "capacity", "speed", "head", "l", "offset", "body", "number", "ize", "len", "name", "le", "state", "index", "SIZE", "z", "weight", "depth", "sent", "id", "small", "Size", "data", "pos"]}}
{"project": "qemu", "commit_id": "6977afda16c1e09dfbce4bdd877459a287269b72", "target": 1, "func": "int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n", "idx": 1802, "substitutes": {"shift_hint": ["shift_thunt", "shift_wunt", "shift_hints", "shift_hlint", "shift_hinter", "shift_hlINT", "shift_hlints", "shift_hunt", "shift_thints", "shift_wints", "shift_halt", "shift_shINT", "shift_shints", "shift_winter", "shift_wint", "shift_thint", "shift_hINT", "shift_shalt", "shift_thinter", "shift_shint", "shift_hlalt"], "ret": ["flag", "get", "rets", "iter", "det", "nz", "nt", "re", "tr", "status", "lit", "try", "r", "inter", "alt", "pret", " Ret", "out", "aux", "mem", "fun", "x", "rev", "gt", "ft", "ter", "rt", "lt", "len", "deg", "elt", "reset", "jp", "tn", "num", "code", "value", "resp", "Ret", "RET", "lv", "res", "t", "val", "print", "cont", "state", "ref", "no", "mt", "ptr", "desc", "red", "fail", "reply", "j", "result", "back", "rem"]}}
{"project": "FFmpeg", "commit_id": "dc64f203a62083c3d5f81e8201018279c29581af", "target": 1, "func": "static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n\n    PTXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n\n    uint8_t *ptr;\n\n\n\n\n\n    offset          = AV_RL16(buf);\n\n    w               = AV_RL16(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}", "idx": 1804, "substitutes": {"avctx": ["averconfig", "avjp", "cvcontext", "ajjp", "wavjac", "avhandle", " avpkg", "afcontext", "avehandle", "avepkg", "navtx", "ravcontext", "avcu", "ajpkg", "navreq", "wavctx", "avecontext", " avjac", " avconf", "ajcmd", "wavconn", "verpkg", "avcfg", "wavcmd", "afctx", "wavca", "verjp", "avcontext", "savcfg", "avecmd", "wavcmp", "avctl", "ajcfg", "savobj", "ahcontext", "avercontext", "ajjac", "averconf", "wavobj", "wavtx", "avercp", "avercu", "aveca", "ravctx", " avcp", "afcp", " avcu", "avejac", "ravcu", "wavpkg", "verctx", " avcontext", "averca", "wavctl", "averctl", "averctx", "avpkg", " avcfg", "avercmp", "ahjac", "avecmp", "aveconfig", "avecp", "avertx", "avca", "averjac", "avconfig", "avconn", "ajtx", "aveconn", "savcp", "avreq", "averhandle", "wavcontext", "avectx", "cvtx", "savctx", "wavconfig", "wavcp", "savpkg", "averpkg", "navjac", " avtx", "afreq", "avcmd", "savcontext", "savcu", "avcmp", "navcfg", "ajreq", "ajcu", "avectl", "wavhandle", "ravcp", "wavjp", "avtx", "aftx", "averjp", "afpkg", "avejp", "navctx", "avercfg", "ahctx", " avjp", "avconf", " avcmp", "cvcmp", "cvctx", "navcmp", "aveobj", "avobj", "ahcp", "ajcontext", "avcp", "savconf", "ajctx", "navconn", "avjac", "vercmp", "navcu", "avetx", "afcfg"], "data": ["DATA", "length", "record", "options", "r", "cache", "i", "next", "ops", "video", "value", "to", "done", "package", "padding", "id", "actions", "str", "empty", "batch", "map", "pad", "window", "Data", "message", "def", "list", "file", "group", "a", "dat", "feed", "rel", "table", "extra", "action", "buffer", "ata", "read", "input", "images", "bin", "frame", "channel", "body", "format", "info", "current", "name", "share", "text", "join", "root", "first", "query", "bytes", "pic", "page", "values", "d", "image", "res", "t", "content", "device", "size", "obj", "media", "raw", "f", "o"], "data_size": ["data_Size", "data_length", "data_shape", " data_length", " data_Size", " data_shape"], "avpkt": ["avvpwk", "avbppt", "avcpct", "avPwk", "avvpett", "ahvpett", "avppt", "avpwk", "avbpkt", "avvpct", " avppt", "ahvpwk", "avvpkt", "ahpct", "avpett", "avbpct", "ahvpct", "avPett", "ahvpkt", "ahpett", "avcppt", "avcpett", " avPct", "avcpkt", "ahpkt", " avpct", " avPpt", " avPkt", "avPkt", "avcpwk", "ahpwk", "avPpt", " avpwk", "avPct", " avPwk", "avbpwk", "avpct"], "buf": ["iter", "aka", "length", "tr", "cur", "cache", "wb", "late", "queue", "port", "coord", "br", "limit", "txt", "cmd", "front", "off", "pos", "bt", "bl", "empty", "batch", "uf", "pb", "rw", "pad", "window", "len", "cam", "cb", "loc", "Buffer", "desc", "buffer", "box", "bp", "seq", "bin", "rb", "Buff", "ctx", "addr", "msg", "nb", "cv", "tmp", "sofar", "result", "alloc", "orig", "cap", "que", "bytes", "b", "src", "img", "mem", "bc", "ob", "shift", "doc", "end", "ref", "cast", "raw", "broad", "err", "buff", "vec", "db"], "s": ["stats", "b", "c", "ls", "pers", "ts", "ps", "i", "comments", "is", "gs", "sys", "ss", "conf", "ms", "sv", "os", "fs", "acs", "ds", "si", "sts", "ats", "t", "rs", "ns", "sb", "S", "ess", "sq", "cs", "hs", "sp", "tx", "details", "js"], "picture": ["pict", "np", "query", "record", "conference", "pic", "protected", "point", "style", "Picture", "P", "frame", "pen", "pr", "png", "family", "img", "fp", "v", "stat", "context", "fi", "image", "info", "video", "document", "ctx", "information", "share", "profile", "piece", "vp", "media", "feature", "policy", "sp", "camera", "figure", "photo", "pa"], "p": ["pro", "tp", "rep", "np", "pic", "b", "c", "pb", "P", "m", "d", "pt", "r", "pr", "cp", "ps", "i", "pc", "fp", "l", "ip", "v", "ap", "pi", "ping", "jp", "g", "pp", "lp", "a", "op", "part", "t", "pl", "vp", "pg", "pre", "pkg", "f", "wp", "sp", "o", "j", "pa"], "offset": ["OFF", "attr", "empty", "length", "et", "offs", "point", "error", "start", "pointer", "pad", "scroll", "fp", "window", "attribute", "prefix", "format", "image", "len", "seek", "shift", "area", "reset", "coord", "xff", "origin", "code", "set", "location", "position", "addr", "end", "loc", "op", "meta", "rot", "adjusted", "zero", "ref", "size", "index", "tile", " seek", "option", "f", "Offset", "address", "crop", "padding", "sp", "skip", "reference", "buffer", "o", "off", "pos", "base", "slot", "ata"], "w": ["nw", "n", "wr", "r", "wn", "wb", "v", "wi", "we", "hw", "wt", "wa", "hi", "_", "rw", "xy", "wh", "window", "def", "iw", "a", "wcs", "wd", "wp", "buffer", "wl", "wx", "wid", "jpg", "ew", "new", "height", "png", "ww", "l", "kw", "wo", "win", "fw", "m", "ex", "W", "d", "img", "word", "wal", "g", "words", "size", "obj", "sw", "raw", "f"], "h": ["ish", "k", "ht", "n", "hi", "high", "hash", "hang", "length", "q", "hm", "b", "ih", "him", "c", "hl", "hh", "ha", "he", "bh", "height", "hd", "r", "wh", "l", "uh", "v", "sh", "hr", "H", "hei", "hal", "g", "hop", "history", "o", "it", "kh", "oh", "size", "html", "hw", "z", "hs", "ch", "m", "j", "ah"], "y": ["k", "iy", "asy", "n", "yer", "yr", "ya", "b", "c", "any", "by", "ot", "at", "yt", "ady", "try", "height", "ey", "py", "type", "ye", "xy", "i", "v", "hot", "sys", "sky", "e", "fy", "kit", "icy", "very", "my", "ies", "ay", "key", "it", "ry", "yy", "ny", "t", "Y", "index", "size", "oy", "uy", "axy", "ty", "ch", "sim", "gy", "vy", "m", "j", "cy", "sy"], "stride": ["Stride", "stie", "ride", "STRider", "stider", " strange", "Strride", "stIDE", "STRIDE", "strride", "rider", "strie", " strride", "Strange", "strange", "stide", "STRride", "strIDE", "rride", " strie", "STRide", "strider", "Strie", "rIDE", "stange"], "bytes_per_pixel": ["bytes_PER_pixel", "bytes_per_page", "bytes_per___image", "bytes_per2pixel", "bytes_per_cell", "bytes_PER_image", "bytes_per__char", "bytes_per__pixel", "bytes_Per_channel", "bytes_of_pixel", "bytes_PER_char", "bytes_Per_pixel", "bytes_PER_cell", "bytes_per_Pixel", "bytes_per___pixel", "bytes_per_tile", "bytes_per_char", "bytes_per_color", "bytes_PER_tile", "bytes_per___tile", "bytes_per_image", "bytes_per2Pixel", "bytes_Per_page", "bytes_per_chip", "bytes_of_color", "bytes_Per_Pixel", "bytes_per_channel", "bytes_per__color", "bytes_per2page", "bytes_of_chip", "bytes_PER_color"], "ptr": ["proc", "cut", "tp", "attr", "pend", "iter", "np", "rep", "tr", "vr", "td", "src", "pt", "pr", "r", "rect", "inter", "ret", "pointer", "pad", "Ptr", "fp", "row", "seek", "ctx", "handle", "br", "store", "push", "end", "copy", "addr", "loc", "pointers", "ref", "index", "obj", "dr", "tmp", "address", "inters", "cmd", "pert", "buffer", "ctr", "pos", "alloc"], "x": ["xxxxxxxx", "wx", "el", "ext", "xs", " X", "xes", " dx", " i", "xxx", "any", "m", "X", "try", "height", "lat", " xx", "on", "xy", "rx", "fx", "xxxx", "i", "v", "ax", "xd", "xf", "pixel", "xc", "mx", "xi", "my", "xa", "key", "ix", " cx", "px", " tx", "inx", "index", " ax", "xx", "ux", "z", "yx", "ox", "xt", "tx", "xp", "dx", "ex"]}}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817, "substitutes": {"bs": ["BS", "bp", "iss", "bl", "lbs", "bing", "blocks", "b", "bps", "blog", "ls", "asis", "als", "ts", "its", "ps", "aus", "gs", "bc", "bm", "ss", "obs", "bos", "aos", "bis", "fs", "ds", "vs", "ats", "ns", "bits", "sb", "cs", "hs", "js", "ubs", "bes"], "s": ["n", "spec", "stats", "ses", "comm", "es", "b", "c", " ss", "ls", "w", "als", "p", "ts", "its", "ps", "l", "gs", "v", "sys", "ops", "less", "ss", "g", "se", "ims", "sis", "sv", "os", "ies", "fs", "ds", "a", "sts", "ats", "rs", "ns", "t", "ins", "S", "y", "h", "sl", "sq", "ess", "z", "cs", "hs", "js", "aws", "m", "j"]}}
{"project": "qemu", "commit_id": "c88305027d5a8dbeaacf04ad2ceba79a5c5fb91e", "target": 1, "func": "POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    cc->has_work = cpu_has_work_POWER9;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n", "idx": 1822, "substitutes": {"oc": ["rc", "aco", "mc", "isc", "org", "oad", "roc", "c", "ot", "og", "cp", "ec", "OC", "oid", "pc", "oco", "bc", "PC", "co", "ob", "oe", "ous", "ocr", "nc", "ac", "osc", "doc", "voc", "loc", "arc", "uc", "unc", "soc", "oci", "tc", "ocation", "vc", "od", "ok", "o", "alloc"], "data": ["DATA", "ata", "bin", "dll", "di", "d", "output", "rec", "bus", "cache", " DATA", "Data", "def", "result", "doc", "ds", "dat", "res", "da", "device", "obj", "dev", "des", "mu", "raw"], "dc": ["cca", "rc", "mc", "c", "di", "lc", "ca", "d", "dp", "rec", "cp", "ec", "pc", "bc", "disc", "co", "dd", "fc", "nc", "df", "ds", "doc", "dt", "dat", "da", "dm", "uc", "tc", "dr", "DC", "desc", "vc", "cd", "mac", "iac"], "pcc": ["Pcc", " pac", "pucc", "tacc", "gfc", " ppc", " pct", "hpc", "pgc", "cucc", "yct", "Pct", "pingck", "hcc", "nck", "cck", "npc", " pck", "pCC", "pct", "pck", "cpc", "gcc", "cct", "gcca", "ppc", "cac", "gacc", "pfc", "PCC", "pingCC", "ncc", "ycc", "ccca", "cCC", "hcca", " pCC", "yacc", "Pgc", "pingct", "hfc", " pacc", "ccc", " pcca", "tct", "Ppc", "Pck", "nfc", "tcca", "tcc", "hct", "pcca", "hac", "pacc", " pgc", "pinggc", "nct", " pfc", "pac", "pingcc", "nCC", " pucc", "pingcca", "nacc", "ncca", "ycca", "pingucc"], "cc": ["cca", "rc", "mc", "isc", "roc", "ct", "c", "lc", "cu", "gc", "cp", "ec", "pc", "cf", "ck", "bc", "co", "cm", "CC", "fc", "nc", "pp", "sc", "ac", "cci", "acc", "ci", "uc", "tc", "cs", "ctl", "vc"]}}
{"project": "FFmpeg", "commit_id": "f028d4d1c393a13c66e828d45ba8412c0b4df6da", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!s->pb->eof_reached) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition->essence_offset) {\n\n                compute_partition_essence_offset(s, mxf, &klv);\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n", "idx": 1878, "substitutes": {"s": ["sports", "n", "sg", "stats", "xs", "this", "bs", "qs", "events", "self", "ses", "an", "es", "b", "c", "ls", "d", "w", "r", "p", "local", "ts", "its", "ps", "fps", "changes", "south", "gs", "is", "v", "sys", "in", "parts", "ss", "g", "ims", "ms", "tes", "source", "ctx", "os", "o", "bis", "fs", "ds", "sv", "a", "sts", "ats", "gets", "rs", "ns", "t", "http", "sb", "S", "scl", "ins", "h", "sw", "sq", "z", "f", "cs", "hs", "details", "aws", "js", "simple", "m", "j"], "ap": ["ata", "bp", "tp", "pro", "cap", "np", "ep", "up", " sp", "att", " p", "hp", "mp", "am", "ps", "tap", "ip", "pp", "ar", "aps", "al", "dat", "op", "pl", " mp", "sp", "amp", "pa"], "mxf": ["mxd", "mfe", "tmxf", "jxf", "wfx", "cmaf", "manfx", "manxe", "dxff", "yxd", "jfc", "kfx", "anfw", " mxe", "cmxf", "mailcf", "imxff", "klf", "Mxf", "mailaf", " mfo", "cmfo", "anfx", "tmfo", "yxf", "yfw", "mfw", "mtfe", " mze", "Mxe", "bmze", "maf", "bmcf", "mtfo", "rmxf", "anxd", " mlf", "rmfw", "Mfo", "tmfx", "kfo", "wxf", "jfx", "mailxf", "mcf", "imxf", "Mze", "mze", "bmxe", "mtxf", "manxd", "manlf", "wfw", "mfif", "mtxff", "mlf", "bmxf", "Mfif", "rmfc", "manfw", " mcf", "imfe", "mxff", " maf", "dxf", "wfc", " mfx", "manxf", "anxf", "mailfif", "Maf", "kxf", "tmxe", "jfw", "mxe", "manfo", "imfo", "rmfx", "Mcf", "mfo", "dfo", "mfx", "cmcf", "yfx", " mfif", "mfc", "dfe"], "klv": ["tkvl", "klr", "mkernal", "wklv", " ktif", "okvl", "klvl", "isklu", "aclu", "aklv", "kelu", "kLV", " kll", "mkLV", "ikvv", "tkLV", "akwl", "arkvv", "tklv", "mLV", "klig", "kvP", "klein", " kLV", "aclvl", " kley", "okll", "unklamm", "cklev", "asklr", "ekLV", "asklein", " klf", "wkLV", "candLV", "ekwl", "wkvv", "oklad", "unkv", "klf", "kelv", "eklv", "kv", "unklev", "ikwl", "isklv", "ekvv", "mlv", "candlamm", " kv", "unktif", " kvP", "aklf", "cklein", "ikll", "wklf", "kll", "asklv", "askll", " kvl", "arkvl", "klu", "oklv", " klad", "kley", "kelvl", "unklein", "okvv", "kls", "arklu", "kvv", "akvv", "tklf", "arklev", "klev", "oklev", "unkernal", "aklr", "mvl", "ktif", "dktif", " klvl", "eklr", "unklvl", " kls", "asklig", "mlf", "dklv", "cklv", "acvP", "akls", "dklr", "arkley", "isklr", "cklig", "dkley", "kwl", "asklev", "unkvl", "isklvl", "arkll", "unklad", "iklf", "unklu", "kvl", "candernal", "iklev", "klamm", "unklf", "mklv", "ikLV", "unklig", "unklv", "aclv", "dkll", "unklr", "ikvl", "dkv", " klu", "eklf", "klad", "iklv", "oklf", "arklr", "ekls", "arklv", "candlv", "kernal", "mklamm", " kvv", "askvl", "unkvv", " klr", "unkLV", "kevP", "dklu", "akLV", "iklr"], "metadata": ["md", "ka", "cmp", "summary", "xml", "met", "definition", "header", "eta", "csv", "info", "name", "msg", "meta", "tar", "dm", "primary", "multi", "mt", "adata", "tmp", "storage", "json", "ATA", "m", "properties", "data", "ata"]}}
{"project": "FFmpeg", "commit_id": "1577526b47439f33a999339efdec5d624b70e1da", "target": 1, "func": "static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    opj_image_cmptparm_t cmptparm[4] = {{0}};\n    opj_image_t *img;\n    int i;\n    int sub_dx[4];\n    int sub_dy[4];\n    int numcomps;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    sub_dx[0] = sub_dx[3] = 1;\n    sub_dy[0] = sub_dy[3] = 1;\n    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;\n    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;\n    numcomps = desc->nb_components;\n    switch (avctx->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}", "idx": 1883, "substitutes": {"avctx": ["afctx", "savcfg", "avcontext", "AVtx", "AVcontext", "avertx", "avtx", "avjp", "avecc", "aftx", "avconn", "averjp", "avercontext", "avecfg", "avejp", "afcontext", "avercfg", " avcmp", "AVcmp", "AVctx", "avcc", "avdesc", "averdesc", "AVconn", "averconn", " avcontext", "savcc", "avectx", "avercc", "savctx", "averctx", " avconn", "AVdesc", "afdesc", "avercmp", "avcfg", "savjp", "avcmp"], "parameters": ["pences", " parameter", "pparams", " paramparams", "parameter", "configeters", "peters", " paramences", "paramparams", "peter", "configences", "configeter", "paramences", "configparams"], "desc": ["dep", "sec", "dem", "cmp", "cfg", "dist", "comment", "util", "rec", "req", "description", "ec", "buf", "TOR", "mem", "decl", "DES", "dc", "disc", "def", "info", "conf", "crit", "esc", "reg", "sc", "driver", "col", "ctx", "cam", "or", "conn", "doc", "ds", "der", "loc", "dir", "cor", "res", "fn", "cont", "txt", "enc", "dev", "dict", "asc", "ptr", "writer", "des", "cmd", "env", "Desc", "rem"], "cmptparm": ["cmphparam", "cmptpparam", "cmptPparam", "cmphparms", "cmphoparm", "cmptParam", "cmptparam", "cmptcparms", "cmptcpparam", "cmphopparam", "cmptoparam", "cmptcparm", "cmptcparam", "cmptparms", "cmptParm", "cmphpparam", "cmphparm", "cmptParms", "cmptoparm", "cmptopparam", "cmptoparms", "cmphoparam", "cmphoparms"], "img": ["fm", "view", "ext", "orig", "images", "jpg", "np", "pic", "uf", "bg", "src", "cur", "im", "map", "mp", "ut", "buf", "image", "conv", "ref", "obj", "tmp", "imp", " im", "ch", "gm", "m", "j"], "i": ["phi", "I", "n", "bi", "li", " j", "b", "c", "di", "ii", "m", "mi", "im", "ki", "r", "p", "l", "ai", "v", "pi", " ii", "it", "si", "t", "ci", "index", "o", "j"], "sub_dx": ["ub___dx", "fun67dx", "sub_xd", "ub___dy", "ub_der", "super_dim", "Sub_dx", "fun_dy", "super_fx", "subLxd", "sub_des", "sub_xy", "subLdx", "subgrfx", "ub_dy", "ub___des", "Sub_fx", "sub_xx", "subgryx", "fun_dx", "sub___yx", "sub67dx", "sub___des", "Sub_yx", "Sub_dis", "sub_yx", "sub_wx", "sub_dim", "sub67wx", "sub_der", "sub67fx", "Sub_xd", "sub___der", "sub_dis", "subgrdx", "ub_des", "fun_yx", "sub67dy", "ub___der", "ub_dx", "Sub_xy", "fun67yx", "sub67dis", "fun67dy", "subgrdis", "sub_fx", "subLfx", "super_dx", "sub___dy", "sub67yx", "sub___wx", "sub___dx", "super_xx", "fun_wx", "fun67wx", "subLxy"], "sub_dy": ["clip42my", "sub0db", "sub67y", "sub___my", "exec_dy", "clip_lon", "sub_xy", "soc_xy", "clip_dy", "sub_ey", "clip42dy", "sub42lon", "clip42den", "sub___ty", "sub_ty", " sub_yy", "subJmy", "clip_my", "sub0dy", "sam_dy", "exec_dis", "sub_y", "subJdy", "soc_dy", "sub0dis", "subJey", "clip_den", "sub_lon", " sub_xy", "sub_dis", "exec_db", "subJy", "sub___yy", "sam_y", "sub67dy", "sub67my", "sam_ey", "sub42den", "sub_db", "sub___lon", "clip42lon", "sub_dl", "soc_slow", " sub_dl", "sam_my", "sub42my", "sub42dy", "sub_den", "sub_slow", "sub___dy", "sub___den", "sub___slow", "soc_ty", "sub___xy", "sub_yy", "sub_my", "exec_slow", "sub0slow", "sub67ey", "sub___dl"], "numcomps": ["numCOMPS", "numcomppos", "numcompms", "NUMComps", "numCOMms", "numCompos", "NUMcompos", "NUMcomPS", "numcomms", "NUMcomms", "NUMComPS", " numCompos", "numComms", " numComPS", " numcomPS", "NUMCompos", " numcomms", "numcompos", "numCOMps", " numComps", "NUMComms", " numcompos", "numcomPS", " numComms", "numCOMpos", "numComPS", "numcompps", "numcompPS", "NUMcomps", "numComps"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n", "idx": 1894, "substitutes": {"dev": ["de", "db", "ad", "proc", "pro", "spec", "app", "dem", "nt", "devices", "w", "p", "sd", "buf", "pad", "ve", "mem", "v", "def", "dd", "conf", "cam", "conn", "doc", "push", "go", "adv", "Dev", "device", "ver", "debug", "obj", "cast", "hw", "des", "raw", "DEV", "ev"], "d": ["de", "ad", "n", "dos", "dn", "dom", "pd", "dh", "md", "gd", "b", "c", "di", "did", "nd", "w", "r", "rest", "p", "sd", "ind", "l", "send", "v", "e", "dc", "dd", "D", "o", "ds", "dt", "ld", "dat", "t", "da", "dm", "fd", "done", "bd", "debug", "dict", "dr", "y", "des", "z", "f", "h", "m", "j", "dx", "db"], "pci_conf": ["pai_config", "pcgi_cfg", "pdi_con", "pci_prop", "pci_tab", "pci_config", "pdi_conf", "pci__conf", "pcm_conf", "pcm_conn", "pci_cfg", "pdi_prop", "pai_conn", "pcm_cfg", "pci__cfg", "pcgi_conf", "pdi_config", "pci__config", "pcgi_config", "pai_cfg", "pci_con", "pcgi_con", "pci__con", "pci_conn", "pci__conn", "pai_conf", "pdi_tab", "pcm_con"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 1896, "substitutes": {"fs_ctx": ["fsjrec", "os_tx", "cs_ctx", "cs_rec", "fs__tx", "fsjctx", "fs__ctx", "fs_cc", "fs_pkg", "fs__pkg", "os_cc", "fsjtx", "os_pkg", "fs_rec", "os_ctx", "fs_tx", "cs_context", "fs_context", "fs__cc", "fsjcontext", "cs_tx"], "oldpath": ["Oldth", "Oldpath", "OldPath", " olddir", "olderPath", " oldPath", "OLDname", "oldname", "Olddir", "OLDpath", "oldPath", "oldth", "OLDPath", "olderdir", " oldname", " oldth", "olderth", "olderpath", "Oldname", "olddir"], "dir_path": ["dirlyPath", " dir_name", "dir_pt", "dir2pt", " folder_Path", " dir_Path", "dir2name", "dirlypt", "dir2Path", "dir_name", "dir2path", "dir_file", "dir_Path", " folder_pt", "dir2file", " folder_file", " folder_path", "dirlypath", "dirlyfile"], "name": ["n", "ame", "ext", "nam", "time", "ident", "nu", "new", "comment", "path", "one", "type", "word", "missing", "prefix", "title", "format", "info", "file", "source", "key", "dir", "part", "node", "text", "Name", "filename", "alias", "NAME", "root", "snap", "size", "id", "nm", "names", "none", "version", "label", "data", "base"], "credp": ["cbedpy", "cpredpy", " cpredphp", " credphp", "cpredc", " credc", "crace", " crodphp", "credpy", "crodinfo", "cedc", "cprede", " crede", "creds", "cradphp", "creditphp", " credinfo", "cradinfo", "cbedc", "cradp", "crode", " cpredp", " credpi", " crode", " cedpy", " cpredpi", "cpredinfo", "cracphp", "credpi", " ceds", "cpredphp", "credinfo", "cedpy", "cracp", " creds", "creditpi", "cpreds", "crodphp", "cpredpi", "cpredp", " credpy", "credite", "cedp", " cedc", " crodp", "crede", "credphp", "credc", " cedp", "ceds", "cbedp", "cbeds", "crodp", "cracpi", " cprede", "crade", "creditp", " crodinfo"], "retval": ["reteval", "RETvals", " Retvals", "revvalue", "RetVal", " Retvalue", "reval", "retvalue", "RetVAL", "retVal", " retVAL", "RETval", "rtval", "Retval", "returnVal", "altvalue", "rtVal", "returnval", "retpol", "returnvalue", "revvals", "interval", " reteval", "returnpol", "relen", " Retval", "intervals", "revry", "reVal", " RetVal", " retVal", "Retvalue", "altVAL", "rtvalue", "rtpol", "altVal", " retry", " Retlen", "reeval", " retvals", "RETvalue", "revval", "Retpol", " Reteval", "retVAL", " retvalue", "retry", "retlen", "RETVal", "altval", "intervalue", "interry", " retlen", "retvals"], "fullname": ["longname", "fulame", "fulpath", "shortName", "longstring", "fullpath", "relname", "fulln", "relpath", "longame", "fulname", "flatname", "longn", "flatstring", "shortame", " fullstring", "flatn", " fullpath", " fullNAME", "fullnamed", "fullNAME", "fulNAME", "fullName", " fullName", "fuln", "longnamed", "longpath", "flatpath", "flatName", "fullame", " fullame", "Fullame", "shortpath", "fulName", "Fullpath", "relNAME", "FullName", "fullstring", "shortname", "flatnamed", "longName", "fulnamed", "relName", "relame", "Fullname"], "target": ["transform", "token", "null", "this", "ARGET", "normal", "mask", "path", "dest", "output", "remote", "bolt", "arg", "controller", "pointer", "type", "match", "managed", "stable", "parent", "prop", "window", "goal", "next", "template", "title", "trace", "context", "direction", "format", "gt", "peer", "port", "seek", "source", "that", "binding", "scope", "origin", "handle", "data", "location", "host", "to", "focus", "rel", "node", "table", "proxy", "component", "subject", "alias", "root", "touch", "resource", "Target", "arget", "id", "global", "range", "buffer", "result", "top"]}}
{"project": "qemu", "commit_id": "ea486926b07d2ebd73ef67315ebb1eecf39faf5a", "target": 0, "func": "static int vfio_enable_intx(VFIODevice *vdev)\n\n{\n\n    VFIOIRQSetFD irq_set_fd = {\n\n        .irq_set = {\n\n            .argsz = sizeof(irq_set_fd),\n\n            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,\n\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n\n            .start = 0,\n\n            .count = 1,\n\n        },\n\n    };\n\n    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);\n\n    int ret;\n\n\n\n    if (vdev->intx.disabled || !pin) {\n\n        return 0;\n\n    }\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */\n\n    ret = event_notifier_init(&vdev->intx.interrupt, 0);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: event_notifier_init failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);\n\n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n\n        error_report(\"vfio: Error: Failed to setup INTx fd: %m\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /*\n\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n\n     * access as a response to an interrupt and unmask the physical\n\n     * device.  The device will re-assert if the interrupt is still\n\n     * pending.  We'll likely retrigger on the host multiple times per\n\n     * guest interrupt, but without EOI notification it's better than\n\n     * nothing.  Acceleration paths through KVM will avoid this.\n\n     */\n\n    vfio_mmap_set_enabled(vdev, false);\n\n\n\n    vdev->interrupt = VFIO_INT_INTx;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    return 0;\n\n}\n", "idx": 1900, "substitutes": {"vdev": ["ivdevice", "maddr", " vgo", "ivplayer", "ovdef", " vplayer", "vmdev", "vrdev", "vdata", "vhost", "uvserv", "vDEV", "voldev", "formstore", "vdef", "tserv", "uvdev", "vinfo", "formdevice", "vvdev", "uvcast", "pev", "tvserver", " vd", "vmcam", " vdebug", "formdebug", " vctx", " vserv", "tvcam", " vcomment", "uvdevice", "vmserver", "vrde", "formpay", " vdevice", "wdev", "vcev", "vcpatch", "vcserial", "vccomment", "md", "cvgo", "whost", "vstore", " vserial", "cvdev", "mver", "mserv", "invdev", "pserv", " vinfo", "vserv", " vdes", " vvar", " vver", "pdev", "vcver", "vcinfo", "vdevice", "wdevice", "vver", "vaddr", "hdev", "vvar", "vserial", "invserver", " vpay", " vde", "vadd", "ovdev", "svdev", "formdev", "vmaddr", "vd", "vev", "vdes", "haddr", "cvdata", "vrdata", "waddr", " vev", " vadd", "mDEV", "ovadd", "vvpatch", "vmcomment", "vcapp", "wdes", "vmpatch", "wcast", "vpay", "wstore", "svdevice", "vctx", "voladdr", "tev", " vcam", " vDEV", "tvctx", "vserver", "ivdev", "vcomment", "vdebug", " vhost", "ivpay", "svDEV", " vapp", "volvar", "vde", "pdevice", "svstore", "mdevice", "formdes", "wserv", "hserv", "ivcam", "vvadd", "invcam", "uvapp", "uvserial", "wev", "vgo", "vccast", "mvar", "tdevice", " vcast", "vcaddr", "voldevice", " vstore", " vpatch", "invplayer", " vdata", " vaddr", "ivserver", "vcdevice", "cvde", "hdevice", "vvdef", " vdef", "tdev", "ivdebug", "mdev", "vpatch", "vplayer", "vchost", " vserver", "vapp", "vcam", "uvd", "vcast", "mstore", "ovpatch", "minfo", "vmctx", "vcdev", "tvdev", "vrgo"], "ret": ["locked", "flag", "nl", "cat", "rets", "det", "str", "hash", "nt", "re", "tr", "status", "alt", "ll", " Ret", "bad", "grain", "mem", "v", "out", "gt", "jp", "ter", "elt", "rt", "len", "num", "reset", "ry", "end", "Ret", "RET", "backed", "res", "t", "val", "print", "cont", "cert", "ref", "txt", "zero", "bool", "no", "mt", " RET", "err", "fail", "j", "result", "got", "compl"]}}
{"project": "qemu", "commit_id": "fc89efe693278c79273f3bbf6b581e8a749c85b0", "target": 0, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    /* mvc and memmove do not behave the same when areas overlap! */\n\n    } else if ((dest < src) || (src + l < dest)) {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if ((dest + 8 <= src) || (src + 8 <= dest)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version with byte accesses which always work */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 1902, "substitutes": {"env": ["param", "attr", "Environment", "dn", "rc", "En", "init", "ew", "et", "eh", "erd", "ef", "org", "him", "outer", "nv", "enter", "worker", "w", "environment", "vt", "ec", "buf", "req", "shell", "window", "v", "vv", "ager", "e", "context", "esc", "estate", "ctx", "EN", "en", "conn", "ami", "enh", "code", "server", "viron", "vs", "cb", "dt", "er", "manager", "msg", "gear", "qt", "usr", "ner", "vp", "pg", "obj", "dev", "h", "package", "gate", "loader", "console", "net", "err", "desc", "cmd", "vm", "config", "con", "erb", "ah", "ev"], "l": ["s", " L", "n", "el", "nl", "lr", "li", "length", "layer", "ly", "b", "c", "lu", "lc", "ls", "hl", "lit", "d", "dl", "w", "r", "kl", "p", "local", "ll", "ul", "loop", "v", "L", "x", "e", "list", "g", "len", "lt", "lin", "tl", "o", "lp", "all", "al", "vl", "fl", "ld", "loc", "le", "t", "pl", "lock", "lb", "size", "h", "cl", "sl", "z", "ln", "lang", "f", "lo", "level", "m", "j"], "dest": ["nw", "n", "null", "dep", "iter", "target", "nt", "tr", "them", "dist", "lit", "output", "r", "rest", "wb", "cp", "est", "pas", "std", "v", "deg", "port", "coord", "origin", "trans", "go", "success", "it", "to", "tif", "slave", "home", "ptr", "priv", "pos", "gate", "prop", "test", "str", "del", "comb", "site", "th", "alt", "decl", "route", "st", "nom", "dc", "gt", "num", "host", "master", "loc", "dat", "pl", "rel", "resource", "mt", "desc", "pro", "np", "Dest", "ssl", "p", "out", "good", "win", "addr", "usr", "tmp", "sp", "ser", "result", "sort", "spec", "proc", "orig", "temp", "nd", "d", "gen", "w", "remote", "local", "parent", "mem", "source", "end", "sur", "t", "obj", "dev", "err"], "src": ["inst", "tp", "via", "slice", "iter", "target", "from", "dist", "cur", "lit", "sn", "r", "rest", "ind", "std", "sync", "origin", "trans", "sr", "sb", "txt", "ptr", "sq", "scan", "inner", "test", "str", "init", "site", "th", "comp", "sel", "req", "st", "tn", "nil", "ebin", "conv", "sv", "loc", "rel", "cont", "resource", "desc", "typ", "sub", "supp", "attr", "input", "rc", "ident", "np", "rb", "start", "syn", "iv", "sys", "rt", "set", "addr", "usr", "sl", "tmp", "sp", "pri", "ser", "ctr", "RC", "sort", "s", "spec", "orig", "sec", "ipp", "rl", "img", "inc", "in", "sc", "source", "url", "SOURCE", "rs", "sur", "ins", "filename", "err"], "i": ["phi", "iu", "I", "n", "hi", "cli", "bi", "init", "iter", "li", "q", "ui", " j", "batch", "b", "di", "ii", "im", "mi", "m", "ki", "p", "ji", "\u0438", " I", "ip", "ind", "v", "ai", "ij", "is", "x", "pi", "ei", "ri", "in", "ini", "u", "zi", "ic", "me", "qi", "xi", "wi", " ti", "ami", " ii", "it", "si", "ix", "ci", "t", "index", "multi", "ie", "y", "f", "id", "ti", "sim", "gi", " x", "o", "j", "io"]}}
{"project": "qemu", "commit_id": "ba0e276db4b51bd2255a5d5ff8902c70d32ade40", "target": 0, "func": "void helper_store_fpcr (uint64_t val)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n\n#endif\n\n    switch ((val >> 58) & 3) {\n\n    case 0:\n\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n\n        break;\n\n    case 1:\n\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n\n        break;\n\n    case 2:\n\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n\n        break;\n\n    case 3:\n\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n\n        break;\n\n    }\n\n}\n", "idx": 1905, "substitutes": {"val": [" ty", "el", "VAL", " v", "item", "b", "status", " arg", " eval", "pr", "kl", "p", "sel", "buf", "vt", "V", "xy", "l", "cal", "v", "valid", "x", "def", "sol", "elt", "num", "al", "pol", "value", "resp", "fee", " aval", "pl", "Val", " value", "ref", " tx", "eval", "vals", "dev", "cl", "tx", "vc", " x", "vol", "data", "Value"]}}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n", "idx": 1909, "substitutes": {"tcet": ["acel", "TCelist", "tcelist", "tcets", " tcel", "ccet", "tcET", "ccET", "acets", "ccel", "xcets", " tcelist", "acet", "ccets", "tcel", "TCet", "acET", "xcet", " tcET", " tcets", "xcET", "TCET", "xcelist", "TCets"], "bypass": ["disablepass", "trygrade", "nonPass", "byPass", "bableghost", "bablepass", "ByPass", "bygrade", "asforce", "Byghost", "disablePass", " byswitch", "tryPass", "nonforce", "byride", "Bypass", "tryskip", "trypass", "byswitch", "asPass", "disableride", "asswitch", " byforce", "aspass", " byskip", " bygrade", "byskip", "disableghost", "bablePass", "nonswitch", "byforce", "bableride", "Byride", "nonpass", "Bygrade", "byghost", "Byskip", " byPass"]}}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_wakeup_request(WakeupReason reason)\n\n{\n\n    if (!is_suspended) {\n\n        return;\n\n    }\n\n    if (!(wakeup_reason_mask & (1 << reason))) {\n\n        return;\n\n    }\n\n    runstate_set(RUN_STATE_RUNNING);\n\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);\n\n    notifier_list_notify(&wakeup_notifiers, &reason);\n\n    reset_requested = 1;\n\n    qemu_notify_event();\n\n    is_suspended = false;\n\n}\n", "idx": 1917, "substitutes": {"reason": ["ASON", "method", "note", "flag", "re", "mask", "comment", "cond", "status", "block", "rule", "type", "req", "thread", "description", "condition", "bid", "connection", "number", "category", "template", " reasoning", "message", "kind", "command", "IND", "crit", "name", "group", "reset", "why", "code", "value", "Reason", "process", "msg", "report", "cause", "res", "state", "lock", "component", "size", "index", "no", "asons", "request", "cmd", "need", "level", "result", "because", "reply"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int rtsp_listen(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char proto[128], host[128], path[512], auth[128];\n\n    char uri[500];\n\n    int port;\n\n    int default_port = RTSP_DEFAULT_PORT;\n\n    char tcpname[500];\n\n    const char *lower_proto = \"tcp\";\n\n    unsigned char rbuf[4096];\n\n    unsigned char method[10];\n\n    int rbuflen = 0;\n\n    int ret;\n\n    enum RTSPMethod methodcode;\n\n\n\n    if (!rt->protocols) {\n\n        rt->protocols = ffurl_get_protocols(NULL, NULL);\n\n        if (!rt->protocols)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),\n\n                 &port, path, sizeof(path), s->filename);\n\n\n\n    /* ff_url_join. No authorization by now (NULL) */\n\n    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,\n\n                port, \"%s\", path);\n\n\n\n    if (!strcmp(proto, \"rtsps\")) {\n\n        lower_proto  = \"tls\";\n\n        default_port = RTSPS_DEFAULT_PORT;\n\n    }\n\n\n\n    if (port < 0)\n\n        port = default_port;\n\n\n\n    /* Create TCP connection */\n\n    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,\n\n                \"?listen&listen_timeout=%d\", rt->initial_timeout * 1000);\n\n\n\n    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,\n\n                         &s->interrupt_callback, NULL, rt->protocols)) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to open RTSP for listening\\n\");\n\n        return ret;\n\n    }\n\n    rt->state       = RTSP_STATE_IDLE;\n\n    rt->rtsp_hd_out = rt->rtsp_hd;\n\n    for (;;) { /* Wait for incoming RTSP messages */\n\n        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);\n\n        if (ret < 0)\n\n            return ret;\n\n        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,\n\n                                 sizeof(method), &methodcode);\n\n        if (ret) {\n\n            av_log(s, AV_LOG_ERROR, \"RTSP: Unexpected Command\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if (methodcode == ANNOUNCE) {\n\n            ret       = rtsp_read_announce(s);\n\n            rt->state = RTSP_STATE_PAUSED;\n\n        } else if (methodcode == OPTIONS) {\n\n            ret = rtsp_read_options(s);\n\n        } else if (methodcode == RECORD) {\n\n            ret = rtsp_read_record(s);\n\n            if (!ret)\n\n                return 0; // We are ready for streaming\n\n        } else if (methodcode == SETUP)\n\n            ret = rtsp_read_setup(s, host, uri);\n\n        if (ret) {\n\n            ffurl_close(rt->rtsp_hd);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1937, "substitutes": {"s": ["service", "n", "sg", "stats", "ses", "es", "c", "src", "ls", "ssl", "w", "r", "p", "ts", "its", "ps", "south", "gs", "is", "sys", "socket", "in", "ss", "conf", "ms", "space", "source", "sv", "os", "ctx", "fs", "ds", "server", "a", "vs", "set", "sts", "ats", "sr", "t", "ns", "rs", "as", "args", "ins", "S", "sb", "serv", "sm", "h", "sw", "sq", "f", "cs", "hs", "aws", "js", "ex"], "rt": ["bt", "ack", "ht", "rc", "rid", "nt", "tt", "et", "irt", "NT", "fr", "re", "vr", "rd", "art", "rb", "ot", "yt", "rh", "kt", "r", "rect", "rec", "rl", "rw", "rule", "opt", "vt", "apt", "rx", "ant", "te", "rf", "rm", "RW", "gt", "ft", "lt", "reg", "rn", "rr", "reflect", "adr", "dt", "rin", "sr", "rot", "res", "t", "rs", "RT", "txt", "tm", "etc", "mt", "dr", "hw", "ox", "cmd", "tx", "vc", "wt", "ro"], "proto": ["pro", "protto", "prifrom", " proname", "Proocol", "PROpo", "phyocol", "phyto", " proTO", "proo", "protpo", "PROTO", "Proco", "Proo", "prono", "proname", "PROto", "Prono", "protname", "prno", "protco", "proocol", "rtp", "protfrom", "proTO", "rocol", "PROocol", "ProTO", "procol", "protno", "propo", "protp", "rto", "profrom", "proco", "pritp", " propo", "protTO", "PROco", "phyname", "rfrom", "prito", "prto", " proocol", "Proto", "prottp", "priocol", "protocol"], "host": ["service", "null", "localhost", "center", "target", "hand", "src", "Host", "gen", "ha", "height", "ip", "window", "bind", "context", "socket", "container", "file", "name", "handler", "source", "url", "ost", "hop", "handle", "conn", "server", "addr", "origin", "loc", "http", "serv", "user", "home", "room", "subject", "root", "index", "phys", "h", "address", "chain", "domain", "owner", "client"], "path": ["Path", "test", "transform", "query", "length", "api", "p", "near", "ip", "route", "prefix", "template", "context", "message", "format", "info", "file", "name", "handler", "url", "handle", "link", "history", "loc", "dir", "text", "resource", "subject", "ath", "phrase", "alias", "package", "address", "cmd", "id", "chain", "config", "password", "pattern", "PATH", "data", "prop"], "auth": ["token", "ht", "attr", "author", "rc", "hash", "authent", "api", "afi", "iam", "ssl", "ha", "username", "cp", "arch", "pas", "ip", "aux", "stat", "info", "conf", "security", "uth", "handler", "ctx", "url", "conn", "Auth", "ac", "addr", "pass", "loc", "http", "user", "usr", "phys", "act", "ath", "cas", "h", "UTH", "lang", "cmd", "id", "acl", "config", "password", "priv", "client"], "uri": ["phi", "service", "reason", "ui", "src", "iri", "ir", " URI", "remote", "username", "description", "i", "ip", "connection", "ur", "prefix", "context", "ri", "command", "info", "file", "name", "handler", "source", "url", "handle", "origin", "link", "location", "dir", "http", "user", "ref", "resource", "subject", "filename", "usr", " ur", "address", "URI", "cmd", "id", "password", "pid"], "port": ["count", "age", "time", "length", "cp", "handle", "limit", "it", "ORT", "component", "ptr", "scale", "address", "padding", "import", "localhost", "unit", "pc", "window", "row", "message", "len", "file", "force", "pport", "index", "then", "Port", "date", "public", "option", "version", "line", "ports", "point", "duration", "export", "p", "ip", "eport", "number", "trace", "format", "position", "report", "rot", "state", "priority", "proxy", "feature", "interface", "policy", "slot", "ile", "page", "remote", "trust", "local", "type", "timeout", "connection", "ort", "socket", "pi", "peer", "server", "size", "PORT", "print", "pid", "client"], "tcpname": ["tprocname", "twpno", "tpnam", "Tcpname", " tcpnames", "tcpnames", "tappdomain", "ktcpname", "tcpName", "tprocnam", "tmpnames", "Tcpnames", " tpName", "tmpno", "Tmpname", "tappname", "ptprocnam", "timpname", "ptcpName", "twpname", "tmpdomain", "TcpName", "tccnam", " tcpnam", "ktappname", " tpname", " tpnam", "tpnames", " tcpName", "tcpno", "tmpName", "Tmpnames", "Tmpno", "ktappnam", " tpnames", "ptcpname", "tcpnam", "ktcpdomain", "tprocName", "tprocno", "ptcpnam", "tccName", "tccname", "ktcpName", "ktappName", "ktcpnam", "ptcpno", "ptprocName", "ptprocno", "tpno", "timpName", "tcpdomain", "tpName", "tccdomain", "TmpName", "ktappdomain", "tappnam", "timpnames", "tappName", "tmpname", "twpnames", "twpName", "timpnam", "Tcpno", "tpname", "ptprocname"], "lower_proto": ["lower_Prodo", "lower_Proto", "lower_protocol", "lower_transocol", "lower_protot", "lower_procdo", "lower_prococol", "lower_proocol", "lower_procto", "lower_proTo", "lower_propTo", "lower_probo", "lower_procbo", "lower_propocol", "lower_proot", "lower_transot", "lower_Probo", "lower_Proocol", "lower_protto", "lower_predo", "lower_preocol", "lower_propot", "lower_transto", "lower_preto", "lower_propto", "lower_protTo", "lower_prodo", "lower_ProTo", "lower_prebo"], "rbuf": ["robbuf", "robuff", "rcuff", "cbuffy", "rabuf", "robff", "erbuffy", "rbbuf", "bff", "cbuf", "robuffy", "rbuffy", "buf", "rcuffy", "rcuf", "cbux", "erbux", "cbuff", "rbbuff", "bbux", "rabuff", "rbuff", "erbbuff", "rbff", "erbuff", "bbuff", "rcbuf", "cbbuf", "bbbuf", "rbux", "rabuffy", "bbuf", "erbbuf", "erbff", "robuf", "robbuff", "erbuf", "rabbuf"], "method": ["service", "param", "proc", "attr", "property", "rc", "man", "mod", "type", "timeout", "mem", "command", "message", "format", "handler", "url", "mid", "Method", "METHOD", "code", "msg", "class", "module", "package", "cmd", "term", "prop"], "ret": ["flag", "ext", "str", "cat", "rets", "det", "iter", "hash", "nt", "re", "tr", "new", "att", "ber", "entry", "lit", "status", "at", "try", "r", "after", "alt", "arg", "ll", "mem", "out", "ort", "fun", "rm", "def", "rev", "ft", "gt", "ter", "elt", "len", "reset", "url", "it", "end", "ry", "run", "dt", "resp", "Ret", "RET", "pass", "res", "t", "val", "print", "ref", "usr", "il", "mt", " RET", "err", "id", "ure", "reply", "success", "j", "result", "back", "rem"], "methodcode": ["resultclass", "statusclass", "statusdesc", "statuscode", "resultdesc", "classno", "methoddesc", "classcode", "resultcode", "statusno", "classdesc", "methodno", "resultno", "methodclass", "classclass"]}}
{"project": "FFmpeg", "commit_id": "365ef88d5df4756942324b633cc439154e468276", "target": 1, "func": "int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,\n\n                            VLC *vlc, const float *level_table,\n\n                            const uint16_t *run_table, int version,\n\n                            WMACoef *ptr, int offset, int num_coefs,\n\n                            int block_len, int frame_len_bits,\n\n                            int coef_nb_bits)\n\n{\n\n    int code, level, sign;\n\n    const uint32_t *ilvl = (const uint32_t *) level_table;\n\n    uint32_t *iptr = (uint32_t *) ptr;\n\n    const unsigned int coef_mask = block_len - 1;\n\n    for (; offset < num_coefs; offset++) {\n\n        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);\n\n        if (code > 1) {\n\n            /** normal code */\n\n            offset                  += run_table[code];\n\n            sign                     = get_bits1(gb) - 1;\n\n            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;\n\n        } else if (code == 1) {\n\n            /** EOB */\n\n            break;\n\n        } else {\n\n            /** escape */\n\n            if (!version) {\n\n                level = get_bits(gb, coef_nb_bits);\n\n                /** NOTE: this is rather suboptimal. reading\n\n                 *  block_len_bits would be better */\n\n                offset += get_bits(gb, frame_len_bits);\n\n            } else {\n\n                level = ff_wma_get_large_val(gb);\n\n                /** escape decode */\n\n                if (get_bits1(gb)) {\n\n                    if (get_bits1(gb)) {\n\n                        if (get_bits1(gb)) {\n\n                            av_log(avctx, AV_LOG_ERROR,\n\n                                   \"broken escape sequence\\n\");\n\n                            return -1;\n\n                        } else\n\n                            offset += get_bits(gb, frame_len_bits) + 4;\n\n                    } else\n\n                        offset += get_bits(gb, 2) + 1;\n\n                }\n\n            }\n\n            sign                    = get_bits1(gb) - 1;\n\n            ptr[offset & coef_mask] = (level ^ sign) - sign;\n\n        }\n\n    }\n\n    /** NOTE: EOB can be omitted */\n\n    if (offset > num_coefs) {\n\n        av_log(avctx, AV_LOG_ERROR, \"overflow in spectral RLE, ignoring\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1945, "substitutes": {"avctx": ["afctx", "avctl", "avcontext", "AVcontext", "avercv", "avtx", "vrctx", "svcontext", "avercontext", "afctl", "avecfg", "vrcmp", "afcontext", "AVctl", "AVcv", "svcmp", "AVcmp", "vcfg", "vctx", "AVctx", "svctx", "vrctl", "avcv", " avcontext", "avectx", "avecontext", "vrcontext", "vcontext", "averctx", "afcmp", " avtx", " avcfg", "avcfg", "svcv", "avercmp", "avetx", "avcmp", "vtx"], "gb": ["bridge", "yg", "Gb", "td", "rg", "bn", "asm", "bf", "deg", "bits", "sb", "bb", "bool", "gg", "gin", "gm", "range", "io", "bt", "ib", "kb", "binary", "bs", "gnu", "gz", "gd", "uf", "pb", "buf", "pc", "gom", "gt", "cb", "px", "hub", "tg", "bp", "fb", "lib", "bg", "rb", "ssl", "py", "ruby", "sys", "gif", "ctx", "nb", "args", "tm", "GB", "cv", "eg", "gp", "phy", "sp", "vg", "eb", "bytes", "cfg", "b", "gh", "html", "rect", "gc", "img", "gs", "git", "bc", "csv", "g", "goo", "pg", "mb", "storage", "um", "vm", "db"], "vlc": ["wlcs", "tlt", "pllc", "flcs", "VLm", "wlc", "tllc", "tlc", "VLl", "flc", "tlm", "vll", "plm", "tlcs", "VLlc", "flci", "wlci", "vllc", "plc", "tlci", "vlcs", "VLc", "vlt", "flt", "wlt", "vlci", "tll", "pll", "vlm"], "level_table": ["level_list", "levelNamebuffer", "frame_buffer", "level2buffer", "level_cache", "run_cache", "levelNamefree", "level2table", "level_buffer", "level_tab", "level2free", "levelNamecontainer", "run_tab", "level_container", "frame_container", "frame_free", "levelNametable", "level_free", "frame_table", "level2container", "run_list"], "run_table": [" run___table", "runninglisttree", "run_total", "run___total", "runlisttree", "running_list", "runinglist", "runingtab", "run___list", "running_total", "run_tab", "running_tree", "running_table", "runlisttable", " run_list", "runninglisttable", "run___table", " run___list", " run_total", " run___total", "runingtree", "run___tab", "run2list", "runlistlist", " run_tab", "runingtable", " run___tab", "run2total", "run_tree", "run2table", "runingtotal", "runninglisttotal", "runlisttotal", "runninglistlist", "run2tab", "run_list"], "version": ["release", "vector", "flag", "supported", "support", "python", "time", "length", "point", "major", "status", "channel", "family", "sector", "type", "condition", "v", "number", "Version", "message", "power", "current", "VERSION", "versions", "server", "position", "vers", "ver", "index", "grade", "size", "order", "compatible", "feature", "package", "vision", "depth", "vert", "mode", "sequence"], "ptr": ["proc", "cut", "tp", "attr", "eth", "lr", "bp", "iter", "np", "tr", "vr", "src", "pt", "pr", "rect", "inter", "ts", "pointer", "buf", "vt", "Ptr", "ps", "pad", "pc", "fp", "pi", "bf", "arr", "rt", "elt", "ctx", "br", "adr", "addr", "expr", "loc", "pointers", "pl", "ref", "dr", "inters", "err", "pert", "ctr", "ctrl", "pos", "alloc"], "offset": ["vector", "count", "slice", "length", "error", "output", "seed", "sector", "unk", "i", "next", "attribute", "sync", "append", "port", "coord", "origin", "store", "location", "to", "order", "address", "padding", "id", "range", "off", "iterator", "pos", "top", "OFF", "cut", "batch", "at", "alt", "pad", "row", "prefix", "command", "message", "num", "loc", "table", "index", "amount", "option", "buffer", "attr", "et", "point", "outer", "start", "iso", "number", "trace", "seek", "key", "set", "position", "addr", "alias", " seek", "Offset", "scroll", "base", "slot", "instance", "flag", "encrypted", "entity", "mask", "path", "pointer", "type", "timeout", "align", "onto", "peer", "shift", "reset", "url", "end", "size", "unc", "ski", "o"], "num_coefs": ["num_coafits", "num_coafeds", "num_coffS", "num_coefS", "num_coefferences", "num_coecits", "num_coeferences", "num_coafes", "num_coeffes", "num_coaffines", "num_coaffs", "num_coafs", "num_coffes", "num_coepes", "num_coeffs", "num_coefes", "num_coeceds", "num_coefines", "num_coeffS", "num_coepS", "num_coeps", "num_cofferences", "num_coeffits", "num_coffines", "num_coeffines", "num_coafferences", "num_coefeds", "num_coefits", "num_coffs", "num_coeffeds", "num_coecs", "num_coeces"], "block_len": ["frame_length", "frame_min", " block_length", " block_Len", "frame_len", "block_size", " block_size", "block_length", "block_fl", "frame_fl", "block_Len", "block_min"], "frame_len_bits": ["frame_fin_bytes", "frame_fin_frames", "frame_len_parts", "frame_fin_its", "frame_Len_parts", "frame_Len_bytes", "frame_Len_bits", "frame_len_frames", "frame_Len_frames", "frame_len_bytes", "frame_Len_its", "frame_len_its", "frame_fin_bits"], "coef_nb_bits": ["coef_cb2bytes", "coef_nb2bits", "coef_nb2bytes", "coef_nbjits", "coef_nb3rows", "coef_nb_rows", "coef_nb_checks", "coef_nbjchecks", "coef_nr_its", "coef_nb_its", "coef_nb3bits", "coef_nb2rows", "coef_cb_rows", "coef_nr_checks", "coef_nb_bytes", "coef_cb_bits", "coef_cb_bytes", "coef_nbjbits", "coef_nr_bytes", "coef_nb3bytes", "coef_cb2rows", "coef_cb2bits", "coef_nbjbytes", "coef_nr_bits"], "code": ["ode", "test", "n", "count", "age", "zip", "sec", "length", "page", "c", "currency", "comment", "xxx", "status", "error", "frame", "remote", "cache", "coe", "iso", "cc", "type", "check", "i", "pc", "condition", "create", "number", "x", "e", "co", "change", "Code", "len", "zone", "ne", "key", "sequence", "go", "success", "value", "ce", "cod", "loc", "ice", "order", "index", "size", "ie", "call", "xx", "color", "scene", "id", "ch", "close", "cd", "cycle", "result", "line"], "level": ["tag", "test", "high", "length", "volume", "error", "status", "vel", "kl", "max", "local", "type", "cost", "variable", "l", "cal", "stage", "change", "low", "info", "len", "levels", "scope", "link", "key", "limit", "coll", "pe", "le", "loc", "Level", "val", "state", "lvl", "print", "lock", "index", "qual", "color", "pl", "role", "scale", "depth", "f", "fac", "id", "label", "vol", "line"], "sign": ["length", "cmp", "rank", "r", "ind", "change", "score", "port", "zone", "round", "value", "part", "val", "alpha", "scale", "id", "close", "pos", "min", "fix", "SIGN", "sum", "warn", "kind", "len", "bit", "ig", "index", "pack", "shape", "add", "sub", "save", "tag", "Sign", "step", "style", "sem", "mod", "sd", "dig", "condition", "body", "pres", "ser", "sa", "sort", "s", "spec", "form", "significant", "diff", "mask", "comment", "trust", "type", "inc", "se", "sc", "shift", "ann", "lock", "size", "sw", "ign", "err"], "ilvl": ["ialvr", "iolvr", "inellv", "inelkl", "iolvp", "ilvr", "iallv", "ilwl", "ialvp", "ialvl", "tilvl", "tilkl", "iollv", "illv", "iolvl", "tilwl", "illvl", "inelvl", "tilvp", "ilvp", "illwl", "ilkl", "illkl", "tillv", "tilvr", "illlv", "inelwl"], "iptr": ["istr", "iptn", "iftr", "espn", "astn", "istR", "espr", "inetn", "inetR", "iptrt", "espR", "astr", "iftR", "iptrs", "esprt", "istrt", "iptR", "iftn", "iftrs", "inetrs", "astrt", "istrs", "istn", "astR", "inetr"]}}
{"project": "FFmpeg", "commit_id": "9241cd2095fe8395e02be5556d657d06f65ba91f", "target": 0, "func": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n\n                         AVFilterInOut *open_inputs,\n\n                         AVFilterInOut *open_outputs, AVClass *log_ctx)\n\n{\n\n    int index = 0, ret;\n\n    char chr = 0;\n\n\n\n    AVFilterInOut *curr_inputs = NULL;\n\n\n\n    do {\n\n        AVFilterContext *filter;\n\n        filters += strspn(filters, WHITESPACES);\n\n\n\n        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if (filter->input_count == 1 && !curr_inputs && !index) {\n\n            /* First input can be omitted if it is \"[in]\" */\n\n            const char *tmp = \"[in]\";\n\n            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n                goto fail;\n\n        }\n\n\n\n        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        filters += strspn(filters, WHITESPACES);\n\n        chr = *filters++;\n\n\n\n        if (chr == ';' && curr_inputs) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",\n\n                   filters - 1);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        index++;\n\n    } while (chr == ',' || chr == ';');\n\n\n\n    if (chr) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",\n\n               filters - 1);\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {\n\n        /* Last output can be omitted if it is \"[out]\" */\n\n        const char *tmp = \"[out]\";\n\n        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail:\n\n    avfilter_graph_free(graph);\n\n    free_inout(open_inputs);\n\n    free_inout(open_outputs);\n\n    free_inout(curr_inputs);\n\n    return ret;\n\n}\n", "idx": 1946, "substitutes": {"graph": ["igraph", "collection", "pool", "query", "man", "self", "script", "ograph", "path", "map", "cache", "parent", "window", "connection", "context", "x", "image", "g", "document", "network", "draw", "history", "handle", "set", "widget", "raph", "Graph", "feed", "node", "zero", "subject", "pg", "h", "tree", "connect", "json", "config"], "filters": ["Filtered", "lifts", "Filters", "butters", "filors", "fifmers", "helters", "filots", "FILchers", "lifctions", "gifters", "waltered", "waltering", "fifters", "lifgers", "miters", "funtered", "FILers", "FILters", "lifers", "Filchers", "walters", "filctions", "fileners", "lifots", " filmers", "Filgers", "giftered", "colors", " Filters", "walts", "filvers", "filers", "fiftered", "colers", "fifeners", "walchers", "FILTER", "filterterms", "filtons", "butors", "Filvers", "funtering", "lifters", " filgers", "mitvers", "lifterms", "funters", "mittons", "FILners", "buttering", " filots", " Filizers", "filterms", "Filners", "lifmers", "Filtons", "fifts", "Fillets", " filts", "filgers", " fileners", "mitters", "FILors", "fillets", "buters", " Filchers", "liftering", "filtering", " Filts", "colTER", "colters", "filtertered", "Filts", "battons", "walers", "helts", "FILizers", "baters", "Filctions", "butgers", "gifgers", "filners", " filers", "filTER", "filts", "fifterms", "FILts", "FILlets", "Filers", "helctions", "fungers", "batters", "filizers", "butTER", "filterters", "filtered", " filtered", "Filizers", "batvers", " filterms", "walners", "Filots", "filtereners", "FILtered", "wallets", "filmers", "Filtering", "FILtering", "giftering", "filchers", "buttered", "heltering"], "open_inputs": ["open_interestums", "open_controls", "open_contextts", "open_inputed", "open_outputS", "open_configts", "open_configsets", "open_interestS", "open__inputs", "open_contextes", "open_controled", "open_outputes", "open__inputxs", "open_dirs", "open_outputxs", "open__outputs", "open_configes", "open_interests", "open_graphS", "open_controlts", "open_graphed", "open_streames", "open_streams", "open_outputed", "open_interestxs", "open_inputS", "open_inputums", "open_graphs", "open_graphts", "open_contexts", "open_outputums", "open_inputsets", "open_dirsets", "open_streamis", "open__outputS", "open_inputis", "open_dirts", "open_streamts", "open_inputxs", "open_contextums", "open_interestts", "open_inputts", "open_contextS", "open_dires", "open__inputS", "open__inputts", "open__outputxs", "open_inputes", "open__outputts", "open_configs", "open_controlS", "open_contextxs", "open_outputsets", "open_contextis", "open_outputis", "open_outputts"], "open_outputs": ["open_hiddenes", "open_controlds", "open_controls", "open_periodes", "open_hiddents", "open_configes", "open_inputts", "open_outputters", "open_inputS", "open_Outputters", "open_controlts", "open_pooles", "open_outputS", "open_hiddens", "open_periodties", "open_poolts", "open_configts", "open_inputters", "open_outputties", "open_hiddenS", "open_inputes", "open_Outputs", "open_Outputes", "open_Outputts", "open_controles", "open_periodts", "open_inputties", "open_outputds", "open_OutputS", "open_configs", "open_configties", "open_Outputds", "open_pools", "open_periods", "open_outputes", "open_inputds", "open_poolters", "open_outputts"], "log_ctx": ["logingkw", "logtctx", "loggrconn", "proptctx", "net_tx", "loginggz", "log2conn", "loggrcss", "link_cfg", "logdtx", "LOG_ctx", "log2tx", "com_context", "note_gz", "loggrtx", "log_tx", "log5cat", "prop_ctx", "log2gc", "prop_gc", "logtconn", "log5jp", "note_ctx", "note_kw", "net_conn", " log_conn", " log2pkg", "LOG_cat", "logpyctx", "proptgc", "log_kw", "net_css", "linkptctl", "logptctl", "linkptcfg", "logingctx", "noteingpkg", "logptconn", "logdconn", "log_obj", "logdcontext", "loglogctx", "log2pkg", " log_context", "propttx", "logtgc", "logpykt", "logpycfg", "loglogcontext", " log2context", "log2context", "logpysys", "linkptctx", "logloggc", "net_ctx", "log_sys", "link_sys", " log_tx", "note_pkg", "prop_tx", "logptctx", "log_gc", "logpyobj", "log_ctl", "noteinggz", "LOG_pkg", "com_kt", "logmyjp", "logpttx", "log2ctx", "logmycat", "link_ctl", "log5ctx", "logptcss", "log5pkg", "link_ctx", "proptconn", "logmypkg", "log_kt", " log_gc", "log_pkg", "logttx", "loggrctx", "linkptsys", "log2obj", "logmyctx", "log_css", "logingpkg", "log_context", " log2ctx", "log_gz", "logpycontext", "logptcfg", "log_jp", "prop_conn", "log_conn", "loglogpkg", "log_cat", "log2kt", " log_pkg", " log2gc", "logdctx", "com_ctx", "logptsys", "com_obj", "log_cfg", "LOG_jp", "noteingctx", "noteingkw", "logpyctl"], "ret": ["flag", "get", "del", "rets", "det", "hash", "nt", "flat", "re", "tr", "vet", "not", "att", "status", "at", "try", "opt", "compl", "gc", "alt", "arg", "ll", " Ret", "mem", "tail", "git", "fun", "rm", "def", "rev", "ft", "gt", "arr", "rt", "deg", "elt", "reg", "len", "reset", "conn", "success", "dt", "addr", "resp", "Ret", "RET", "tif", "res", "val", "cont", "cert", "ref", "txt", "mat", "bool", "mt", "progress", "dr", "net", "err", "desc", "cmd", "print", "result", "back", "rem"], "curr_inputs": ["curr_inputts", "curr_outputS", "curr_rawes", "curr_graphs", "curr_subjects", "curr_columnves", "curr_rawts", "curr_raws", "curr_outputes", "curr_outputts", "curr_pools", "curr_context_", "curr_dirs", "curr_lookries", "curr_inputves", "curr_inputries", "curr_columnes", "curr_lookts", "curr_outputves", "curr_dirts", "curr_contextries", "curr_poolves", "curr_graph_", "curr_dirles", "curr_columnts", "curr_graphS", "curr_outputles", "curr_columnS", "curr_dirS", "curr_contexts", "curr_looks", "curr_inputles", "curr_subjectS", "curr_input_", "curr_outputries", "curr_contextS", "curr_poolts", "curr_graphts", "curr_graphes", "curr_rawS", "curr_contextes", "curr_contextts", "curr_lookS", "curr_contextles", "curr_subjectts", "curr_inputS", "curr_output_", "curr_outputs", "curr_inputes", "curr_columns"], "filter": ["tag", "test", "transform", "cut", "pipe", "init", "hash", "query", "ff", "flat", "batch", "find", "block", "channel", "cache", "p", "map", "check", "match", "parent", "loop", "condition", "cf", "select", "attribute", "context", "format", "file", "handler", "conv", "handle", "link", "process", "op", "profile", "table", "tf", "root", "pkg", "f", "fil", "json", "cmd", "chain", "buffer", "config", "term", "Filter", "sort"], "tmp": ["bt", "test", "proc", "attr", "pipe", "input", "stuff", "var", "np", "tt", "cmp", "batch", "temp", "new", "src", "dest", "cache", "alt", "mp", "buf", "timeout", "fake", "img", "out", "mk", "prefix", "result", "dirty", "name", "ctx", "expr", "params", "msg", "t", "node", "table", "txt", "perm", "filename", "uv", "obj", "snap", "split", "pkg", "sp", "err", "nm", "buffer", "buff", "term", "data"], "index": ["n", "count", "read", "open", "slice", "iter", "hash", "length", "page", "error", "status", "start", "seed", "active", "height", "max", "timeout", "i", "parent", "ind", "condition", "loop", "offset", "out", "row", "number", "context", "x", "connection", "ion", "image", "list", "connected", "search", "name", "Index", "num", "ctx", "handle", "key", "success", "set", "position", "end", "location", "ix", "state", "node", "order", "size", "depth", "address", "connect", "id", "version", "level", "buffer", "j", "pos"]}}
{"project": "qemu", "commit_id": "6b9b8758c15f3bc2875dbd6e2d03c5362b8d6902", "target": 0, "func": "static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    /* This will stop vhost backend if appropriate. */\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n", "idx": 1981, "substitutes": {"qdev": [" qDev", "qval", "sqev", "eqdevice", "dqev", "qpro", "qqDev", "iqev", "qDEV", "eqdev", "iqdev", "qupay", "vDEV", "qdevice", "sqval", "qtval", "sqblock", "qpay", "qtdev", "dqblock", "dqval", "qcam", "qtev", "dqdevice", "qqDEV", "dqpay", " qev", "Qcam", "vDev", " qDEV", "dqpro", "Qdev", "qtblock", "iqdevice", "vdevice", "qev", "qblock", "qudev", "qDev", " qdevice", "dqdev", "eqpro", "qudevice", "qqdevice", " qcam", "Qev", "Qdevice", "eqpay", "sqdev", "iqcam", "qupro", "qqdev"], "n": ["nw", "note", "nl", "dn", "init", "ren", "np", "gn", "nt", "an", "normal", "comm", "na", "nu", "c", "nor", "b", "new", "nv", "ct", "sn", "w", "nav", "wn", "p", "local", "on", "ll", "l", "out", "v", "number", "nan", "cn", "g", "conf", "tn", "name", "network", "num", "ne", "mn", "en", "conn", "all", "ng", "non", "a", "nb", "t", "ns", "fn", "node", "N", "obj", "h", "y", "no", "z", "ln", "f", "net", "nn", "none", "nm", "names", "nah", "m", "j", "general", "norm"], "vdev": [" vgo", "vev", "vdes", "vcdes", " vev", "svev", "wev", "Vdef", "vgo", "vcdev", "vcdis", "qdevice", "svde", "vdef", "Vdis", "vdis", "vcdef", " vdis", "dserv", "wgo", "Vdev", "ddev", " vdef", "vserv", " vdes", "svserv", "dde", "vdevice", "qev", "wdevice", " vserv", "dev", "Vdes", "qgo", "vde", " vde", " vdevice", "wdev", "svdev"], "i": [" multi", " err", "mi", " si", " mi", "ind", " I", "ai", "ei", "is", "ij", "v", "ic", "o", "it", "si", " my", "y", "id", "ti", "phi", "iu", "bi", "hi", "init", " v", "ui", "batch", " m", "c", "di", "x", " pos", "ini", "zi", "xi", " ti", " ii", "index", "multi", " status", "chain", "sim", "ri", "j", "I", " li", "asi", "im", " count", "ki", "p", " bi", "l", "ip", "info", "my", " iter", "key", "ix", "ci", " ni", "us", "gi", "m", "ex", "li", " j", "ii", "ji", "\u0438", "pi", "in", " pi", "me", "qi", "t", "print"], "q": ["qu", "k", "dq", "eq", "ql", "que", "qs", "query", "comm", "c", "quit", "w", "p", "cp", "quant", "req", "check", "ve", "cf", "ck", "v", "x", "qq", "queue", "g", "conf", "qi", "pp", "it", "ry", "iq", "Q", "qa", "quest", "qt", "ue", "pkg", "sq", "z", "requ", "cmd", "ch", "j", "aq"], "nc": ["nl", "nz", "np", "nt", "mc", "isc", "ct", "c", "nv", "sn", "gc", "anc", "cc", "ec", "yn", "pc", "bc", "dc", "cn", "NC", "xc", "ic", "rn", "mn", "ctx", "ne", "ng", "ns", "qt", "nec", "unc", "enc", "cv", "tc", "cs", "nn", "vc", "nic"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n", "idx": 1983, "substitutes": {"dest": ["test", "transform", "spec", "null", "proc", "gov", "orig", "target", "nt", "sort", "tr", "temp", "Dest", "dist", "new", "d", "gen", "w", "rest", "req", "est", "pas", "decl", "window", "out", "v", "good", "st", "sys", "nom", "way", "deg", "port", "source", "coord", "origin", "trans", "host", "master", "dat", "msg", "foreign", "sur", "pl", "cont", "usr", "dev", "ptr", "desc", "global", "chain", "priv", "result", "gate", "prop"], "src": ["s", "sub", "inst", "inner", "supp", "proc", "via", "spec", "lib", "attr", "input", "orig", "rc", "sec", "stack", "target", "func", "dist", "cur", "start", "th", "gen", "seed", "try", "syn", "comp", "rest", "lat", "rl", "cp", "req", "cc", "iv", "warn", "img", "std", "st", "sys", "sync", "in", "gt", "rt", "sc", "source", "conv", "sv", "origin", "copy", "trans", "addr", "sr", "loc", "msg", "rs", "load", "rel", "cont", "http", "sb", "usr", "txt", "phys", "obj", "uv", "ptr", "pkg", "sq", "tmp", "ser", "scan"], "size": ["s", "n", "count", "empty", "length", "ui", "style", "c", "m", "sn", "dimension", "capacity", "sum", "type", "window", "south", "send", "v", "offset", "number", "ize", "context", "sh", "sync", "pi", "message", "format", "g", "len", "zone", "group", "network", "scope", "si", "fee", "state", "SIZE", "gravity", "scale", "weight", "shape", "sp", "small", "dim", "Size", "mode", "sort"], "u": ["k", "fu", "iu", "uci", "edu", "ui", "nu", "eu", "uid", "lu", "c", "tu", "d", "cu", "w", "uri", "p", "uu", "ut", "i", "ul", "l", "v", "g", "gu", "uni", "t", "ue", "U", "uv", "us", "du", "unic", "mu", "su", "ou", "o"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_create_branch(BDRVSheepdogState *s)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid;\n\n    char *buf;\n\n\n\n    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n\n                      SD_INODE_SIZE, 0, s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    s->is_snapshot = false;\n\n    ret = 0;\n\n    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);\n\n\n\nout:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1990, "substitutes": {"s": ["n", "sand", "an", "services", "south", "is", "v", "ops", "parts", "ies", "fs", "ds", "gets", "sb", "h", "sq", "hs", "bs", "ses", "c", "st", "ties", "ims", "sv", "os", "a", "sts", "ats", "as", "https", "details", "qs", "events", "states", "p", "ps", "l", "sys", "less", "ss", "ms", "orders", "bis", "set", "so", "state", "sm", "ex", "sam", "spec", "stats", "comm", "es", "b", "ls", "als", "ts", "its", "changes", "gs", "g", "conf", "se", "source", "settings", "rs", "ns", "serv", "ins", "S", "sw", "cs", "js", "aws"], "ret": ["rets", "nt", "re", "tr", "lit", "r", "ll", "pas", "v", "rm", "deg", "port", "it", "dt", "Ret", "val", "done", "bool", "cmd", "bt", "del", " alt", "uf", "att", "status", "at", " fut", "alt", "after", "fi", "def", "rev", "ft", "gt", "ter", "len", "tn", "sat", "ben", "backed", "cont", "tf", "mt", "nat", "tor", "j", "over", "Return", "plain", "try", "inter", " Ret", "out", "rt", "lt", "elt", "fl", "RET", "usr", "result", "flag", "nl", "det", "final", "ct", "not", "opt", "rect", "gc", "ts", "vt", "git", "fin", "reset", "res", "t", "cert", "ref", " RET", "f", "err", "red", "print", "got"], "fd": ["lf", "fm", "fb", "ff", "fr", "gz", "gd", "uf", "rd", "ud", "func", "td", "d", "dl", "kt", "fa", "hd", "pointer", "sd", "dig", "fe", "fp", "cf", "fi", "dd", "bf", "ft", "fc", "FD", "elt", "port", "fin", "handler", "ctx", "af", "df", "handle", "fs", "ds", "conn", "dt", "fl", "cb", "ld", "dat", "addr", "dir", "fn", "da", "disk", "bd", "ptr", "fred", "writer", "fed", "ln", "f", "fat", "id", "cd", "buffer", "pid", "db", "io"], "vid": ["vd", " guid", " v", "wid", "seq", " wid", "rid", "vi", "vr", "uid", "temp", " id", "vt", "lan", "tv", "feat", "oid", "bid", "von", "v", " tid", "rev", "len", "ctx", "cam", "UID", "mid", "doc", "vis", "voc", "cod", "sid", " pid", "fee", "val", " tv", "vo", " vend", "ref", "vp", "uv", "VID", "vc", "id", "kid", "ti", " virt", "vol", "virt", "pid"], "buf": ["fb", "bridge", "bp", "orig", "cap", "var", "seq", "bin", "ff", "gz", "bytes", "batch", "uf", "b", "rb", "pb", "block", "w", "Buff", "map", "wb", "cp", "img", "mem", "window", "cf", "v", "bc", "ob", "bf", "queue", "port", "cam", "ctx", "xff", "br", "alph", "doc", "cb", "msg", "bag", "ref", "txt", "cv", "bd", "Buffer", "ptr", "tmp", "raw", "f", "cmd", "err", "buffer", "buff", "tab", "data", "vec", "alloc"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "substitutes": {"dev": ["de", "ad", "proc", "pro", "dep", "md", "nt", "att", " device", "d", "w", "Device", "p", "av", "pad", "mem", "v", "dis", "ow", "cam", "os", "conn", "ac", "ach", "go", "or", "Dev", "serv", "device", "ver", "wd", "act", "hw", "od", "DEV", "priv", "ev"], "prop": ["test", "proc", "pro", "attr", "spec", "property", "sec", " Prop", "cfg", "pt", "comp", "pr", "p", "cp", "ps", "feat", "def", "conf", "col", "prev", "or", "doc", "pred", "op", "rop", "sty", "pkg", " props", "pri", "Prop", "cmd", "priv", "term", "pos"], "str": ["s", "spec", "seq", "fr", "tr", "b", "c", "w", "r", "Str", "p", "buf", "out", "st", "arr", "list", "name", "ar", "STR", "br", "doc", "msg", "res", "cont", "text", "txt", "enc", "raw", "f", "sp", "err", "desc", "chain", "ctr", "vol", "data"], "ptr": ["inst", "proc", "tp", "eth", "dep", "rep", "np", "dh", "tr", "dist", "th", "pt", "pr", "p", "inter", "ts", "pointer", "buf", "pad", "Ptr", "ps", "ind", "prime", "offset", "sh", "arr", "jp", "deg", "ctx", "handle", "addr", "t", "rel", "ref", "resh", "index", "obj", "sp", "pert", "ctr", "buffer", "pos"], "fmt": [" fMT", "tftm", "tfMT", "Fmt", "vMT", "fMT", "ftm", "vstr", "gstr", "fformat", "fstr", " fstr", "FMT", " ftm", "tfformat", "Ftm", "vformat", "gMT", "Fformat", " fformat", "Fprintf", "gmt", "tfmt", "vmt", "gformat"]}}
{"project": "FFmpeg", "commit_id": "2f76157eb05bf63725f96167feda6b2e07501c7e", "target": 1, "func": "av_cold int swri_rematrix_init(SwrContext *s){\n\n    int i, j;\n\n    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);\n\n    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    s->mix_any_f = NULL;\n\n\n\n    if (!s->rematrix_custom) {\n\n        int r = auto_matrix(s);\n\n        if (r)\n\n            return r;\n\n    }\n\n    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++) {\n\n            double rem = 0;\n\n\n\n            for (j = 0; j < nb_in; j++) {\n\n                double target = s->matrix[i][j] * 32768 + rem;\n\n                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);\n\n                rem += target - ((int*)s->native_matrix)[i * nb_in + j];\n\n            }\n\n        }\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n\n        s->native_one    = av_mallocz(sizeof(float));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((float*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(double));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((double*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        // Only for dithering currently\n\n//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n//         for (i = 0; i < nb_out; i++)\n\n//             for (j = 0; j < nb_in; j++)\n\n//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    //FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n", "idx": 1998, "substitutes": {"s": ["n", "sg", "ants", "services", "is", "v", "ops", "parts", "ies", "fs", "ds", "er", "gets", "bits", "sb", "h", "sq", "hs", "sports", "bs", "ses", "c", "status", "ains", "ties", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "details", "has", "ports", "qs", "erences", "p", "ps", "sys", "less", "ss", "tests", "ms", "bis", "set", "args", "sl", "m", "ex", "spec", "stats", "self", "comm", "es", "b", "ls", "w", "als", "ts", "its", "changes", "gs", "in", "conf", "ers", "se", "tes", "source", "acs", "settings", "alls", "rs", "ns", "t", "ins", "S", "cs", "aws", "js"], "i": ["phi", "iu", "I", "n", "hi", "bi", "cli", "li", "ui", "batch", "b", "asi", "yi", "di", "status", "ia", "ii", "im", "mi", "uri", "ki", "p", "ji", "\u0438", "ind", "ip", "is", "v", "out", "ij", "ai", "u", "x", "pi", "ei", "in", "ini", "info", "zi", "g", "ic", "ims", "me", "xi", "ik", "qi", "o", "ami", " ii", "it", "si", "ix", "ci", "index", "multi", "ie", "y", "h", "us", "id", "ti", "sim", "gi", "ri", "m"], "j": ["k", "uj", "other", "n", "note", "bi", "str", "jc", "fr", "q", "b", "c", "jump", "by", "m", "oj", "pt", "pr", "je", "p", "bo", "dj", "ji", "l", "ind", "ja", "out", "v", "ge", "ij", "next", "x", "vol", "jj", "ion", "jac", "jp", "g", "br", "key", "it", "jit", "kj", "ix", "aj", "jet", "bj", "ie", "obj", "y", "z", "json", "jl", "js", "ch", "J", "jo", "o"]}}
{"project": "qemu", "commit_id": "1a0e4c8b02ea510508970c333ee610a90b921cbb", "target": 1, "func": "void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n", "idx": 2009, "substitutes": {"ipl_cpu": ["cel____coin", "cel_cpu", "pl_process", "ipl_pu", "cel_cum", "pl_cpu", "ipl____pu", "fl_processor", "ipl_proc", "fl_proc", "ipl_cu", "cel____pu", "fl_pu", "cel____cpu", "ipl____coin", "fl_cpu", "pl_cu", "pl_pu", "cel____cum", "ipl_processor", "cel_coin", "ipl_cum", "ipl____cum", "ipl_process", "ipl_coin", "ipl____cpu", "cel_pu"]}}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        /* This is a P-frame. */\n\n        ctx->frame->key_frame = 0;\n\n        ctx->frame->pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n", "idx": 2010, "substitutes": {"ctx": ["wx", "Context", "mc", "cmp", "exec", "ka", "cfg", "ct", "c", "ca", "cu", "kt", "gc", "anc", "cp", "cc", "req", "pc", "cf", "ck", "mk", "ij", "context", "bc", "dc", "cm", "jac", "kw", "xc", "jp", "conf", "ic", "nc", "cam", "conn", "ac", "tk", "cb", "loc", " cx", "iat", "ci", "abc", "tm", "act", "cv", "tc", "setup", "obj", "hw", "pkg", "ctl", "cmd", "tx", "acl", "xp", "ctrl"], "gb": ["bt", "vg", "ib", "fb", "bridge", "kb", "yg", "bs", "eb", "gd", "Gb", "uf", "bg", "gow", "cfg", "rb", "gh", "pb", "rg", "gc", "wb", "gs", "bc", "bf", "gt", "g", "gif", "gu", "cb", "nb", "sb", "bb", "pg", "bd", "GB", "mb", "eg", "gg", "tg", "gm", "gy", "erb", "db"], "dst": [" dhost", " Dend", " Dsrc", " dsrc", "dsdest", "Dest", "Ddest", "dssrc", "ddest", "dest", "stend", "sthost", "dend", "Dst", "dsest", "stst", "Dsrc", " Dst", " Dhost", "stsrc", "dsrc", " dend", "dhost", " ddest", "dsst", " dest"], "stride": ["Stride", "strension", "Strime", "sline", "styleide", "strride", " strride", "slides", "strime", "strided", "strides", "styleension", "Strides", "strine", "windowride", "Strine", "windowided", " strime", "slime", "slide", " strension", " strides", "styleride", " strine", " strided", "windowide", "styleided", "windowension"], "block": ["k", "ack", "view", "bl", "hash", "blocks", "bin", "q", "self", "batch", "mask", "b", "byte", "array", "frame", "map", "p", "buf", "type", "check", "mem", "word", "out", "row", "ip", "field", "x", "sync", "bc", "def", "image", "list", "pixel", "Block", "bit", "line", "group", "BL", "link", "set", "load", "lock", "object", "node", "ref", "join", "obj", "cl", "snap", "pack", "chain", "buffer", "config", "bo", "data", "box"], "i": ["phi", "iu", "I", "bi", "cli", "hi", "this", "init", "li", "ui", " j", "asi", "c", "di", "yi", "status", "ii", "im", "mi", "uri", "ki", "p", " mi", "ji", " bi", "\u0438", "ind", "ip", "l", "ai", "v", "ei", "ij", "is", "x", "pi", "in", "ini", " pi", "zi", "g", "info", "me", "qi", "xi", "o", " ti", "ami", " ii", "it", "si", "gu", "ix", "iq", "ci", "t", "index", "multi", "y", " ni", "span", "id", "ti", "sim", "gi", "ri", "m", "j"], "num_coeff": ["num_COff", "num_coff", "num2Coffe", "num_coefficient", "num_cosef", "num_cosefficient", "num_Coffe", "num2Coff", "num_Coeff", "num_Coef", "num_locff", "num2coff", "num_coefficients", "num_COef", "num_loceff", "num_coffe", "num_cosefficients", "num2Coeff", "num2Coef", "num_COeff", "num_locffe", "num_coseff", "num_coef", "num_Coff", "num2Coefficient", "num2coefficient", "num2coeff", "num_Coefficient", "num_COefficient", "num_locefficient", "num2coffe", "num_Coefficients", "num_COefficients", "num2coef"]}}
{"project": "FFmpeg", "commit_id": "604c9b1196c70d79bbbc1f23e75f6a8253a74da3", "target": 1, "func": "void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    avio_close(rtpctx->pb);\n\n                }\n\n                avformat_free_context(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            ffurl_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}\n", "idx": 2027, "substitutes": {"s": ["sports", "n", "spec", "stats", "xs", "init", "bs", "self", "es", "b", "c", "ls", "ssl", "w", "r", "p", "ts", "its", "ps", "gs", "is", "sys", "st", "e", "ops", "less", "ss", "conf", "ms", "sv", "os", "fs", "ds", "set", "settings", "sts", "ats", "times", "rs", "t", "ns", "sb", "S", "sq", "cs", "hs", "js", "aws", "m", "has"], "send_packets": ["send_pagesETS", "send_pagesets", "send_packsorts", "send_messodes", "send_packsets", "sendablepacksodes", "send_payets", "send_payorts", "sendablepackETS", "sendablepackset", "sendablepacksETS", "send_packodes", "send_packagesorts", "send_pageset", "send_packETS", "send_messets", "send_packageset", "sendablepacksets", "send_payETS", "send_messet", "sendablepackets", "send_messETS", "send_payet", "send_packsETS", "send_packet", "sendablepackodes", "send_pagesodes", "sendablepacket", "send_packagesets", "send_packagesETS", "send_packset", "send_packorts", "send_packsodes"], "rt": ["bt", "ack", "ht", "tp", "rc", "tt", "nt", "et", "irt", "NT", "art", "tr", "rd", "vr", "rb", "ot", "pt", "rh", "kt", "r", "rect", "rec", "rl", "ret", "rw", "trak", "lat", "vt", "apt", "rx", "feat", "req", "hd", "aux", "rf", "st", "gt", "rn", "ctx", "rr", "it", "dt", "rin", "rot", "rs", "RT", "t", "txt", "tm", "mt", "dr", "rage", "tmp", "net", "ox", "cmd", "tx", "vc", "boot", "wt", "ro"], "i": ["phi", "iu", "I", "n", "oi", "bi", "hi", " li", "li", " multi", "ui", " j", "batch", "c", "di", "m", "im", "mi", "ii", "ki", " si", "p", " mi", "ji", " bi", "ind", " I", "ip", "ai", "v", "out", "ij", "x", "u", "pi", "fi", "in", "ini", " pi", "ic", "ims", "name", "xi", "qi", " iter", "port", "me", " ti", " ii", "it", "si", "go", "ix", "ci", "t", "print", "index", "multi", "y", " ni", "us", "id", "ti", "sim", "gi", "o", "j", "client"], "rtsp_st": ["rtspeak_sth", "rtsp3inst", "rtspc_stri", "rtsp_stan", "rtspjste", "rtsp_sh", "rtscp_est", "rtsppyst", "rtspjstatus", "rtspeak_st", "rtspn_sh", "rtsp_int", "rtsp_stri", "rtssp_st", "rtsp___stream", "rtsp0sw", "rtspc_st", "rtsppystream", "rtssp_int", "rtspkstri", "rtsp_end", "rtsp__stream", "rtsp_th", "rtspknt", "rtsping_dest", "rtsp_std", "rtsp7ST", "rtsp_ST", "rtsp_stone", "rtssp_sty", "rtsp3dest", "rtsp__st", "rtsprendist", "rtsp7stan", "rtspn_nt", "rtsp_stable", "rtspkstone", "rtsmp_obj", "rtspn0nt", "rtsmppyst", "rtsmppyobj", "rtsp_inst", "rtsp_tmp", "rtspn_sw", "rtspkste", "rtsp__obj", "rtsp3st", "rtsp_sty", "rtspn0st", "rtsp__tmp", "rtsp0nt", "rtspn0sw", "rtsppyobj", "rtsp____rest", "rtsping_st", "rtsp___obj", "rtspn_end", "rtspn0sh", "rtsp_ct", "rtsp_dest", "rtsp___tmp", "rtsmp_tmp", "rtsp0st", "rtsp7st", "rtspeak_stan", "rtsp_str", "rtsp_est", "rtspksth", "rtsmp_stream", "rtspkstable", "rtsping_str", "rtsp_ste", "rtspeak_stone", "rtsp0sh", "rtsh_obj", "rtspkst", "rtsprenst", "rtspn_st", "rtsp_dist", "rtsp_obj", "rtsh_st", "rtscp_ST", "rtspn_stable", "rtspjst", "rtsp3str", "rtspid_ct", "rtspkstatus", "rtspc_status", "rtsping_inst", "rtspn_str", "rtsppytmp", "rtsmppystream", "rtsprenth", "rtspid_dist", "rtsp____int", "rtsp_nt", "rtscp_st", "rtsmp_st", "rtsprenct", "rtssp____st", "rtsp7est", "rtspid_th", "rtspc_ste", "rtsp____st", "rtsp____sty", "rtsmppytmp", "rtsp___st", "rtspid_st", "rtssp____int", "rtssp_rest", "rtssp____sty", "rtsp_rest", "rtsp_status", "rtsp_sw", "rtscp_stan", "rtssp____rest", "rtsp_sth", "rtsp_stream", "rtspkstan", "rtspn_std", "rtsh_str", "rtspjstri", "rtspn_stri"], "rtpctx": ["randpahandler", "rtlpcas", "rtpynp", "mitpcv", "rtpinp", "randptimeout", "rtpaircache", "rtpibc", "rtlpcoll", "rtjpcoll", "rtphctx", "rtvplc", "rtpatchloc", "rtjptimeout", "irtpcache", "iterpactx", "rtpcmd", "rtptimeout", "rtpatchcache", "rtpatimeout", "rxpingtimeout", "rtlphandler", "ritpyctx", "rtvpcv", "rtpacmd", "rtpconf", "irtpcoll", "irtploc", "ritpybc", "randphandler", "rtpbctx", "rtlpctx", "rtpingcu", "rtjplc", "rtpcoll", "iterpcmd", "rxpingcu", "rtpingtimeout", "rtjpcv", "mitpfw", "ritpyconf", "rtploc", "rtplc", "rtpicv", "rxpctx", "rtphcu", "rtpatchctx", "ritpctx", "rtpnctx", "mitpilc", "rtpahandler", "rtvpcache", "iterpcas", "rtpacoll", "rtpatchcoll", "rtpyctx", "rtlpcmd", "randpctx", "rtpactx", "rtpfw", "iterpctx", "rtpyconf", "rtpingvals", "rtpaircoll", "mitplc", "iterparc", "rtvpctx", "irtvpcoll", "rtvpcoll", "rtjpctx", "rxptimeout", "irtvploc", "randpcoll", "rtprc", "irtvpcache", "randpactx", "rtpbrc", "rtpbcas", "mitpicv", "rtparc", "rtlptimeout", "rtpairctx", "mitpctx", "rtpbc", "rtphtimeout", "rxpingvals", "iterprc", "rtpcu", "rxpingctx", "iterpacmd", "rtpingctx", "ritpbc", "rtpvals", "rtpingconf", "rtpingnp", "ritpconf", "rtjphandler", "rtpilc", "rtphandler", "rtpybc", "randpatimeout", "rtpcv", "rtpntimeout", "irtpctx", "randpacoll", "rtpingbc", "rtpbcmd", "rtpictx", "rtpnvals", "rtpnp", "irtvpctx", "rtpifw", "mitpifw", "rxpvals", "rtvpfw", "rtpairloc", "rtphvals", "rtjpfw", "rtlprc", "rtpcas", "rtpcache", "iterpacas", "rtpncu", "ritpynp", "ritpnp", "mitpictx", "rtpiconf", "rxpcu", "rtvploc", "rtpacas"], "ptr": ["proc", "var", "iter", "fr", "dh", "tr", "td", "pb", "src", "pt", "ped", "pr", "p", "inter", "ts", "pointer", "buf", "Ptr", "pad", "ps", "pc", "mem", "fp", "row", "ck", "arr", "port", "ctx", "adr", "addr", "pointers", "pl", "fd", "ref", "obj", "dev", "dr", "tmp", "address", "sp", "inters", "tx", "buffer", "ctr", "vec", "alloc"]}}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n", "idx": 2047, "substitutes": {"s": ["n", "r", "i", "south", "is", "ops", "parts", "ies", "fs", "ds", "er", "gets", "bits", "http", "sb", "h", "y", "hs", "sports", "bs", "ses", "c", "st", "ims", "ys", "sv", "os", "a", "vs", "sts", "ats", "as", "https", "details", "ports", "qs", "ssl", "states", "ps", "comments", "l", "sys", "less", "ss", "tests", "ms", "bis", "set", "full", "state", "sp", "m", "bes", "spec", "stats", "xs", "self", "browser", "comm", "es", "b", "ls", "als", "local", "ts", "its", "tags", "changes", "gs", "conf", "g", "se", "rs", "ns", "t", "ins", "S", "sw", "cs", "js", "aws"], "p": ["bp", "tp", "pro", "app", "np", "php", "rep", "q", "up", "point", "post", "c", "b", "pb", "P", "d", "at", "dp", "m", "w", "r", "mp", "local", "cp", "ps", "i", "pc", "fp", "ip", "tip", "v", "ap", "x", "pi", "ping", "peer", "jp", "g", "port", "pp", "lp", "it", "resp", "pm", "op", "t", "vp", "y", "h", "patch", "pre", "pkg", "f", "wp", "gp", "sp", "o", "j", "pa"], "request": ["method", "each", "access", "child", "hello", "input", "get", "read", "time", "reason", "query", "q", "point", "Request", "response", "frame", "claim", "req", "bid", "condition", "rate", "prefix", "command", "message", "change", "seek", "reset", "task", "push", "set", "position", "question", "quest", "order", "call", "package", "address", "cmd", "requ", "reference", "version", "buffer", "event", "QUEST"], "value": ["test", "vector", "hello", "get", "ceive", "length", "see", "volume", "values", "response", "status", "VALUE", "ve", "variable", "create", "v", "attribute", "number", "multiple", "message", "command", "result", "change", "current", "example", "set", "position", "success", "operator", "val", "ue", "save", "address", "version", "action", "buffer", "update", "function", "data", "Value"], "index": ["author", "axis", "input", "query", "length", "point", "find", "error", "status", "timeout", "i", "ind", "condition", "offset", "row", "number", "prefix", "context", "ion", "info", "seek", "num", "Index", "link", "key", "success", "position", "end", "code", "loc", "set", "location", "val", "zero", "ref", "order", "size", "then", "address", "connect", "id", "update", "data", "pos"]}}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = FFALIGN(frame->height, 32);\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 2049, "substitutes": {"frame": ["error", "one", "ind", "cf", "header", "next", "video", "zone", "draw", "scope", "process", "to", "part", "component", "ie", "module", "role", "iframe", "console", "ox", "scene", "request", "close", "range", "cmd", "sample", "comp", "req", " timeframe", "window", "row", "def", "message", "list", "file", "force", "ma", "table", "session", "ace", "version", "term", "data", "line", "fb", "fr", "step", "point", "style", "response", "channel", "Frame", "stage", "trace", "format", "rame", "picture", "info", "name", "code", "ce", "msg", "state", "node", "feature", "fw", "frames", "movie", "result", "show", "base", "instance", "proc", "view", "form", "self", "page", "face", "block", "remote", "wrapper", "feat", "word", "send", "e", "shot", "pty", "image", "flow", "doc", "profile", "load", "ref", "call", "cast", "f", "cycle", "event", "update", "sequence"], "align": ["aff", "form", "length", "cmp", "angle", "margin", " alignment", "aligned", "pad", "l", "offset", "cal", "format", "in", "len", "hold", "col", "coord", "xff", "ac", "al", "rot", "rel", "join", "size", "equal", "adjust", "ign", "snap", "rac", "padding", "add", "label", "box"], "desc": ["de", "proc", "ack", "ext", "dep", "sec", "rc", "nz", "seq", "diff", "md", "cmp", "dist", "comment", "ca", "rib", "comp", "rec", "ec", "buf", "description", "feat", "req", "img", "DES", "pres", "disc", "def", "info", "crit", "esc", "name", "sc", "col", "cam", "doc", " des", "ds", "der", "msg", "cor", "res", "cont", "txt", "ref", "enc", "obj", "dev", "asc", "des", "cmd", "sub", "Desc", "vec"], "ret": ["read", "nl", "get", "rets", "det", "iter", "nt", "re", "tr", "att", "status", "lit", "try", "r", "gc", "alt", "inter", "pret", "ll", " Ret", "l", "mem", "out", "v", "aux", "ort", "def", "ft", "gt", "arr", "rt", "len", "reg", "elt", "deg", "reset", "conv", "ne", "round", "al", "limit", "it", "ry", "success", "resp", "Ret", "RET", "res", "t", "val", "print", "cont", "rel", "ref", "il", "mt", "progress", "net", "cmd", "red", "j", "result", "rem"], "i": ["n", "oi", "cli", "iter", "iri", "uri", "mi", "ind", "loop", "is", "ai", "v", "ij", "ei", "ic", "it", "si", "er", "ie", "y", "h", "id", "ti", "io", "phi", "iu", "inner", "bi", "hi", "init", "q", "ui", "batch", "di", "ir", "status", "x", "fi", "ori", "ini", "zi", "ims", "xi", "index", "multi", "chain", "sim", "ri", "j", "I", "im", "ki", "try", "p", "l", "ip", "info", "name", "key", "set", "ix", "ci", "span", "dr", "gi", "m", "li", "ii", "remote", "ji", "\u0438", "u", "pi", "in", "g", "me", "qi", "t"]}}
{"project": "qemu", "commit_id": "1eabfce6d53cb02066dbb0ac8471f8593ff24a24", "target": 0, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (has_msr_async_pf_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (has_msr_pv_eoi_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (has_msr_kvm_steal_time) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (has_msr_hv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (has_msr_hv_tsc) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_mtrr) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SVERSION:\n\n            env->msr_hv_synic_version = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2053, "substitutes": {"cpu": ["core", "tp", "cli", "machine", "CPU", "cache", "uu", "cp", "queue", "history", "conn", "process", "docker", "component", "hap", "hw", "pkg", "console", "processor", "net", "cmd", "boot", "pool", "ilo", "library", "c", "cu", "prof", "util", "comp", "req", "pc", "linux", "xc", "jp", "pixel", "os", "cum", "np", "cell", "frame", "p", "ruby", "arch", "thread", "ck", "percent", "pp", "ctx", "upt", "rpm", "pu", "disk", "mac", "alloc", "proc", "stack", "ork", "aco", "exec", "gc", "local", "kernel", "mem", "lua", "socket", "virtual", "server", "lock", "zero", "device", "hz", "hog", "clock", "gpu", "vm", "none"], "env": ["db", "proc", "spec", "attr", "ext", "gov", "ew", "eh", "ef", "cfg", "nv", "ework", "opt", "map", "environment", "buf", "ec", "vt", "except", "mem", "window", "context", "e", "inv", "eng", "def", "conf", "ctx", "en", "conn", "win", "viron", "vs", "pe", "node", "dev", "net", "cmd", "priv", "config", "con", "eas", "ev", " environment"], "msrs": ["MsRS", "Msr", "tsRS", "Msrs", " msRs", "tsrs", " msRS", "msRs", "tsr", "MsRs", "tsRs", "msRS"], "ret": ["flag", "nz", "nt", "re", "new", "mi", "ll", "mem", "out", "fi", "ft", "rt", "reset", "ry", "set", "Ret", "RET", "res", "t", "val", "vals", " RET", "net", "result"], "i": ["I", "n", "bi", "init", "b", "c", "ir", "ii", "im", "mi", "p", "l", "ip", "ai", "v", "ij", "x", "pi", "fi", "xi", "si", "ix", "t", "index", "id", "m"], "mtrr_top_bits": ["mtrr_TOP32bits", "mtrr_top_bit", "mtrr_top2bytes", "mtrr_TOP32flags", "mtrr_top_bytes", "mtrr_TOP32bytes", "mtrr_top2bit", "mtrr_top2bits", "mtrr_TOP_flags", "mtrr_top32bit", "mtrr_top_flags", "mtrr_TOP_bytes", "mtrr_top32flags", "mtrr_TOP_bits", "mtrr_top2flags", "mtrr_top32bits", "mtrr_TOP_bit", "mtrr_top32bytes", "mtrr_TOP32bit"]}}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n", "idx": 2063, "substitutes": {"mr": ["lr", "rar", "RM", "mc", "mir", "wm", "hm", "tr", "vr", "kr", "rg", " rm", "rh", "r", "drm", "pr", "rl", "mp", "older", "hr", "mk", "mar", "gr", "rm", "bm", "MT", "Mr", "MR", "mn", "rr", "rn", "br", "adr", "sr", "rs", " MR", "shr", "mt", "dr", "mor", "ml", "gm", "rem", "m", "mx"]}}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n\n{\n\n    int i;\n\n\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n\n    if (f->slice_count <= 0) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < f->slice_count; i++) {\n\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        int sx          = i % f->num_h_slices;\n\n        int sy          = i / f->num_h_slices;\n\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n\n        f->slice_context[i] = fs;\n\n        memcpy(fs, f, sizeof(*fs));\n\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n\n\n        fs->slice_width  = sxe - sxs;\n\n        fs->slice_height = sye - sys;\n\n        fs->slice_x      = sxs;\n\n        fs->slice_y      = sys;\n\n\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n\n                                      sizeof(*fs->sample_buffer));\n\n        if (!fs->sample_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2083, "substitutes": {"f": ["lf", "fm", "of", "alf", "aff", "fb", "form", "ff", "fr", "diff", "ef", "uf", "elf", "c", "b", "d", "w", "fo", "fg", "fa", "p", "fe", "fp", "cf", "rf", "v", "x", "e", "fi", "fab", "xf", "ft", "bf", "fc", "conf", "info", "file", "g", "af", "df", "ac", "flow", "all", "fl", "full", "fee", "tif", "t", "fit", "fd", "inf", "base", "sf", "ref", "tf", "h", "fw", "z", "fed", "um", "F", "m", "j", "fac"], "i": ["phi", "s", "iu", "I", "n", "oi", "bi", "cli", "li", "ui", " j", "batch", "asi", "c", "di", "yi", "gi", "ia", "ii", "im", "mi", "uli", "ki", "p", "ji", "\u0438", "ind", "ip", "l", "ai", "v", "ei", "ij", "is", "x", "e", "pi", "ori", "ini", "zi", "ic", "me", "qi", "xi", " ti", "ami", " ii", "it", "si", "ix", "iq", "to", "aci", "ci", "print", "index", "multi", "b", "y", "us", "span", "z", "id", "ski", "ti", "sim", "chain", "m", "j"], "fs": ["lf", "ports", "fb", "bs", "qs", "fr", "ics", "bytes", "uf", "uses", "ls", "fo", "ts", "fps", "ps", "cells", "rss", "cf", "gs", "fp", "sys", "sync", "bf", "ks", "fits", "less", "fc", "obs", "keys", "ims", "ms", "outs", "ys", "os", "FS", "ds", "ows", "faces", "vs", "fl", "wcs", "features", "ats", "fee", "res", "rs", "ns", "vers", "fd", "bits", "args", "sf", "ums", "vals", "files", "fw", "frames", "iffs", "cs", "irs", "hs", "Fs", "js", "flows", "css"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 2084, "substitutes": {"opaque": ["popaque", "OPque", "opque", "Opacity", "opace", "OPaques", "popace", " opc", "opacity", "paque", "orace", "oposter", "pc", "popacity", "plque", " opque", "pque", " oposter", "opc", "OPoster", "plc", "oracity", "Opace", "poplay", "paques", "plaque", "Opaque", "orlay", "oplay", " opaques", "opaques", "poster", "oraque", "Oplay", "OPaque"], "addr": ["ad", "ack", "attr", "eth", "work", "rc", "hash", "target", "src", "hl", "start", "at", "r", "map", "alt", "gc", "pointer", "pad", "align", " address", "mem", "offset", "v", "Address", "x", "seek", "ctx", "coord", "handle", "store", "adr", "ac", "arp", "host", "set", "loc", "ix", "res", "rs", "now", "ref", "order", "index", "phys", "gate", "mt", "ptr", "hw", "obj", "address", "cmd", "add", "tx", "id", "err", "off", "pos", "alloc"], "value": ["vector", "count", "hello", "property", "time", "length", "one", "v", "attribute", "direction", "port", "val", "ue", "address", "json", "padding", "Value", "test", "python", "unit", "status", "max", "memory", "x", "message", "power", "bit", "num", "ay", "operator", "index", "vp", "option", "version", "buffer", "data", "entry", "try", "rule", "VALUE", "height", " address", "create", "number", "field", "format", "name", "key", "all", "code", "position", "state", "function", "ceive", "self", "item", "values", "byte", "block", "w", "type", "parent", "word", "image", "total", "dev", "weight"], "size": ["n", "count", "vector", "length", "style", "capacity", "sum", "type", "mem", "offset", "send", "body", "ize", "number", "message", "len", "name", "space", "num", "shift", "zone", "scope", "code", "fee", "index", "SIZE", "scale", "z", "weight", "shape", "address", "sp", "padding", "buffer", "Size", "slot"], "s": ["sam", "service", "spec", "stats", "bs", "qs", "comm", "services", "utils", "es", "b", "c", "ssl", "ls", "w", "r", "p", "ts", "ps", "i", "changes", "l", "gs", "is", "sys", "socket", "sync", "sol", "ss", "g", "ms", "source", "sv", "os", "conv", "bis", "fs", "ds", "ies", "store", "vs", "params", "ats", "sts", "t", "rs", "ns", "sm", "bits", "sb", "S", "state", "h", "sl", "sq", "cs", "hs", "sp", "js", "aws", "simple", "m", "j", "sort"]}}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_mono(APEContext *ctx, int count)\n\n{\n\n    APEPredictor *p = &ctx->predictor;\n\n    int32_t *decoded0 = ctx->decoded[0];\n\n    int32_t predictionA, currentA, A, sign;\n\n\n\n    currentA = p->lastA[0];\n\n\n\n    while (count--) {\n\n        A = *decoded0;\n\n\n\n        p->buf[YDELAYA] = currentA;\n\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n\n\n        currentA = A + (predictionA >> 10);\n\n\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n\n\n        sign = APESIGN(A);\n\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n\n\n        p->buf++;\n\n\n\n        /* Have we filled the history buffer? */\n\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n\n            memmove(p->historybuffer, p->buf,\n\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n\n            p->buf = p->historybuffer;\n\n        }\n\n\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n\n        *(decoded0++) = p->filterA[0];\n\n    }\n\n\n\n    p->lastA[0] = currentA;\n\n}\n", "idx": 2093, "substitutes": {"ctx": ["k", "Context", "np", "mc", "cmp", "ct", "c", "lc", "pb", "gc", "anc", "cp", "cc", "req", "pc", "cf", "context", "bc", "x", "cm", "jac", "kw", "jp", "xc", "info", "nc", "conv", "conn", "loc", "resp", " cx", "abc", "txt", "act", "unc", "obj", "tc", "setup", "cv", "hw", "pkg", "tmp", "wp", "cmd", "tx", "config", "cas"], "count": ["n", " c", "length", "find", "c", "cond", "start", "d", "try", "cache", "check", "thread", "OUNT", "ind", " call", "number", "conf", "ount", "num", "force", "all", " cc", "code", " Count", "process", "acc", "nb", "counter", "now", "cont", "size", "call", "amount", "always", "Count", "z", "depth", " num", "f", "cmd", "add", "con"], "p": ["n", "tp", "P", "pr", "r", "cache", "cp", "i", "port", "br", "it", "pm", "er", "resp", "part", "process", "http", "h", "y", "pkg", "xp", "app", "rep", "q", "post", "c", "pb", "at", "dp", "comp", "per", "after", "pc", "power", "jp", "perm", "vp", "debug", "pre", "public", "wp", "j", "bp", "pro", "get", "np", "ps", "l", "ip", "ap", "ping", "info", "pp", "op", "patch", "policy", "sp", "m", "pa", "proc", "pd", "php", "self", "up", "d", "pt", "w", "local", "fp", "parse", "pi", "g", "lp", "t", "pg", "progress", "f", "o"], "decoded0": ["exploded2", "decoding0", "decayed2", "decode1", "decoded1", "decocateder", "decocatedZero", "depoded1", "decodedZero", "decodingZero", "depuated180", "explayedZero", "explodeder", "decayeder", "depoded0", "explodedZero", "depuated0", "deccoded2", "depoded180", "depodedZero", "decocated2", "decuated0", "decodeZero", "decoding180", "decodeder", "deccodedZero", "decayed0", "decode0", "decayedZero", "explayeder", "depuated1", "exploded0", "deccodeder", "depuatedZero", "decuated180", "decuated1", "decuatedZero", "decoded2", "decode180", "deccoded0", "decoding1", "decoded180", "explayed2", "decocated0", "explayed0"], "predictionA": ["predictionaryGA", "predisonAA", "PredictedL", "PredictionAn", "indictionSA", "PredictionAA", "PredictionA", "indictionA", "predictedA", "predictionAU", "predisonAU", "PredictedAn", "predicationSA", "PredictionL", "predictedAn", "indicationA", "predicationB", "predicionL", "preditionA", "predictedAA", "preditionAU", "predicationAA", "predictionL", "predictedGA", "indicationSA", "indictionAU", "PredictedAA", "predictionSA", "predicionB", "predicionA", "preditionSA", "predictionaryA", "predictionaryL", "predictionGA", "predisonA", "predisonSA", "indicationAU", "indicationAA", "predictionaryB", "PredictionB", "predictionaryAA", "PredictionGA", "predicationAU", "predicationA", "predicionAn", "predictedB", "predictedL", "indictionAA", "PredictedA", "PredictedGA", "predictionaryAn", "predictionB", "PredictedB", "preditionAA", "predictionAn", "predictionAA", "predicationGA"], "currentA": [" currentArray", "reportedC", "CurrentA", "currentC", "curB", "currentG", "reportedArray", "reportedAA", "currentlySA", "currentArray", "activeA", "reported_", "activeAA", " currentSA", "active_", "curCA", "reportedCA", "reportedSA", "currentlyArray", "currentAA", "reportedA", "reportedB", "currentlyC", "curG", "CurrentArray", " currentCA", "CurrentAA", "CurrentB", "reportedN", " currentAA", " currentC", "reportedG", "currentlyA", "curA", "currentB", " currentG", " currentN", "currentN", " currentB", "currentSA", "currentCA", "current_", "activeN", " current_"], "A": ["I", "AI", "AA", "AC", "ACC", "AP", "AT", "AB", "JA", "P", "AR", "X", "TA", "SA", "RA", "AS", "V", "At", "An", "H", "GA", "AF", "D", "T", "ASC", "The", "HA", "a", "E", "AN", "C", "BA", "Alpha", "This", "NA", "EA", "S", "M", "N", "U", "MA", "ACA", "PA", "CA", "R", "AU", "LA", "AM", "Array", "As", "AV", "B"], "sign": ["s", "tag", "spec", "transform", "sch", "Sign", "form", "min", "ident", "diff", "length", "fix", "mask", "grad", "angle", "comment", "style", "sk", "rank", "mod", "r", "SA", "trust", "tick", "SIGN", "sum", "type", "check", "dig", "warn", "ind", "sh", "pres", "just", "ss", "secure", "se", "sc", "shift", "ann", "space", "draw", "force", "code", "a", "operator", "state", "alpha", "S", "order", " SIGN", "act", "wrap", "sw", "ign", "pack", "scale", "sq", "save", "shape", "sp", "vert", "close", "sa", "pos", "sort"], "buf": ["bound", "aka", "cur", "fg", "bh", "cache", "bn", "wb", "av", "bf", "queue", "coord", "grab", "br", "fam", "bag", "home", "pkg", "cmd", "off", "prop", "db", "hend", "bern", "bl", "hist", "bs", "bas", "var", "gz", "batch", "uf", "comb", "blog", "lim", "req", "window", "nom", "fab", "rev", "bed", "len", "num", "cam", "bu", "cb", "loc", "ver", "desc", "buffer", "urg", "box", "plot", "ba", "fb", "rc", "seq", "bin", "emb", "bg", "rb", "Buff", "gl", "norm", "addr", "cv", "fw", "ctr", "orig", "cap", "reb", "comm", "mus", "block", "gen", "abet", "feat", "img", "rab", "bc", "arr", "doc", "obj", "um", "err", "forest", "buff", "env", "vec", "fac"]}}
{"project": "FFmpeg", "commit_id": "17ee7b5515cd1006a1f7ba4a9cced14f6526c1b0", "target": 0, "func": "static void print_report(AVFormatContext **output_files,\n\n                         AVOutputStream **ost_table, int nb_ostreams,\n\n                         int is_last_report)\n\n{\n\n    char buf[1024];\n\n    AVOutputStream *ost;\n\n    AVFormatContext *oc;\n\n    int64_t total_size;\n\n    AVCodecContext *enc;\n\n    int frame_number, vid, i;\n\n    double bitrate, ti1, pts;\n\n    static int64_t last_time = -1;\n\n    static int qp_histogram[52];\n\n\n\n    if (!is_last_report) {\n\n        int64_t cur_time;\n\n        /* display the report every 0.5 seconds */\n\n        cur_time = av_gettime();\n\n        if (last_time == -1) {\n\n            last_time = cur_time;\n\n            return;\n\n        }\n\n        if ((cur_time - last_time) < 500000)\n\n            return;\n\n        last_time = cur_time;\n\n    }\n\n\n\n\n\n    oc = output_files[0];\n\n\n\n    total_size = avio_size(oc->pb);\n\n    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too\n\n        total_size= avio_tell(oc->pb);\n\n\n\n    buf[0] = '\\0';\n\n    ti1 = 1e10;\n\n    vid = 0;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        float q= -1;\n\n        ost = ost_table[i];\n\n        enc = ost->st->codec;\n\n        if(!ost->st->stream_copy && enc->coded_frame)\n\n            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n\n        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"q=%2.1f \", q);\n\n        }\n\n        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            float t = (av_gettime()-timer_start) / 1000000.0;\n\n\n\n            frame_number = ost->frame_number;\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"frame=%5d fps=%3d q=%3.1f \",\n\n                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n\n            if(is_last_report)\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"L\");\n\n            if(qp_hist){\n\n                int j;\n\n                int qp= lrintf(q);\n\n                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))\n\n                    qp_histogram[qp]++;\n\n                for(j=0; j<32; j++)\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%X\", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n\n            }\n\n            if (enc->flags&CODEC_FLAG_PSNR){\n\n                int j;\n\n                double error, error_sum=0;\n\n                double scale, scale_sum=0;\n\n                char type[3]= {'Y','U','V'};\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"PSNR=\");\n\n                for(j=0; j<3; j++){\n\n                    if(is_last_report){\n\n                        error= enc->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0*frame_number;\n\n                    }else{\n\n                        error= enc->coded_frame->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0;\n\n                    }\n\n                    if(j) scale/=4;\n\n                    error_sum += error;\n\n                    scale_sum += scale;\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale));\n\n                }\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(error_sum/scale_sum));\n\n            }\n\n            vid = 1;\n\n        }\n\n        /* compute min output value */\n\n        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);\n\n        if ((pts < ti1) && (pts > 0))\n\n            ti1 = pts;\n\n    }\n\n    if (ti1 < 0.01)\n\n        ti1 = 0.01;\n\n\n\n    if (verbose || is_last_report) {\n\n        bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n\n\n\n        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n\n            \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\",\n\n            (double)total_size / 1024, ti1, bitrate);\n\n\n\n        if (nb_frames_dup || nb_frames_drop)\n\n          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\",\n\n                  nb_frames_dup, nb_frames_drop);\n\n\n\n        if (verbose >= 0)\n\n            fprintf(stderr, \"%s    \\r\", buf);\n\n\n\n        fflush(stderr);\n\n    }\n\n\n\n    if (is_last_report && verbose >= 0){\n\n        int64_t raw= audio_size + video_size + extra_size;\n\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\",\n\n                video_size/1024.0,\n\n                audio_size/1024.0,\n\n                extra_size/1024.0,\n\n                100.0*(total_size - raw)/raw\n\n        );\n\n    }\n\n}\n", "idx": 2110, "substitutes": {"output_files": ["Output_reports", "Output_file", "Output_files", "outputingreports", "out_fs", "out_files", "Output_tags", "outputingfiles", "out_file", "out_frames", "output_fs", "outputingfile", "output_reports", "output_file", "output_tags", "output_frames", "outputingtags"], "ost_table": ["ostlyTable", "stream_table", "ost_database", "ast_list", "ast_chain", "ostsdatabase", "ostgtable", "ostgdatabase", "oststable", "ostlylist", "stream_list", "stream_Table", "ostglist", "ost_list", "ostlydatabase", "ast_database", "stream_database", "ostgchain", "ostlytable", "ost_chain", "ostslist", "ost_Table", "ostsTable", "ast_table"], "nb_ostreams": ["nb_oststreamses", "nb_streams", "nb_ostreamfiles", "nb_streamfiles", "nb_oststreamS", "nb_ostrogS", "nb_ostreamers", "nb_ostreamls", "nb_oststreamfiles", "nb_ststreamls", "nb_ostlogers", "nb_streamS", "nb_ostreamS", "nb_osteads", "nb_osteadfiles", "nb_streamls", "nb_osteadses", "nb_oststreams", "nb_ststreams", "nb_ostREAMls", "nb_ostREAMfiles", "nb_ststreamS", "nb_ostreamses", "nb_ostrogs", "nb_oststreamers", "nb_streamses", "nb_ststreamfiles", "nb_ostlogS", "nb_oststreamls", "nb_ststreamers", "nb_ostREAMs", "nb_ostlogs", "nb_ostrogers", "nb_streamers", "nb_ststreamses", "nb_osteadls", "nb_ostREAMses"], "is_last_report": ["is_last_run", "is_last___update", "is_last___reported", "is_first_reported", "is_last___log", "is_lastflightReport", "is_lastflighttry", "is_last_reported", "is_lastfulreport", "is_first_log", "is_first_update", "is_lastfullog", "is_lastfulreported", "is_lastfulrun", "is_last_try", "is_last_Report", "is_last_print", "is_first_run", "is_lastflightreport", "is_first_try", "is_last___run", "is_lastflightprint", "is_first_Report", "is_first_report", "is_last_update", "is_last___print", "is_last_log", "is_first_print", "is_last___report"], "buf": ["iter", "tr", "cur", " buff", "bh", "cache", "bn", "wb", "queue", "br", " buffer", "bag", "txt", "etc", "pkg", "cmd", "priv", "tab", "prop", "bt", "str", "bs", "pool", "var", "gz", "foo", "batch", "uf", "pb", " cmd", "map", "rw", "window", "row", "bed", "conv", "bu", "cb", "uv", "Buffer", "desc", "buffer", "data", "box", "fb", "seq", "bin", "emb", "rb", "Buff", "bar", "vv", "ctx", "msg", "text", "usr", "cv", "tmp", "tx", "nm", "result", "proc", "orig", "cap", "eb", "b", "gc", "img", "mem", "ref", "pg", "obj", "cast", "raw", "err", "buff", "vec", "db"], "ost": ["ist", "otype", "ocol", "utt", "ogg", "ott", "ust", "nt", "org", "tt", "oad", "roc", "post", "src", "ora", "ot", "ast", "yt", "ream", "stream", "iv", "\u00f3", "est", "oid", "ind", "oster", "ict", "bott", "st", "ort", "ous", "pres", "ob", "ori", "obs", "rob", "os", "oss", "hop", "sta", "ont", "voc", "host", "or", "loc", "op", "obj", "irst", "rog", "iot", "rend", "olog", "od", "typ", "iop", "o", "OST"], "oc": ["ogg", "rc", "aco", "toc", "org", "mc", "roc", "ct", "c", "cur", "ot", "og", "rec", "anc", "cc", "ec", "OC", "oid", "pc", "oco", "bc", "dc", "ob", "co", "ocr", "ic", "nc", "aic", "os", "ac", "osc", "voc", "loc", "op", "unc", "obj", "soc", "oci", "rog", "ox", "irc", "od", "ok", "o", "nic", "alloc"], "total_size": ["private_loss", "total_number", "total_news", "total27mem", "total12size", "totalLfee", "total_scale", "max_mem", "otal_size", "max_fee", "total66news", "total_body", "total_no", "total27fee", "totallogbytes", "private_size", " total_number", "total12news", "total27time", "total_status", "total12status", "max_time", "total66no", "totallogsize", "private_body", "otal_no", "total_loss", "private_scale", "total66status", "max_size", "total12no", "total_time", "otal_status", "totalLsize", "totalLmem", "total27size", "totalLtime", "total_bytes", " total_bytes", "otal_news", "totallognumber", "total66size", "total_fee", "total_mem"], "enc": ["ack", "lib", "sec", "rc", "ew", "et", "isc", "cmp", "rent", "ct", "c", "util", "rec", "anc", "equ", "ec", "auth", "pc", "ens", "ict", "onet", "pres", "ang", "inc", "eng", "kw", "Enc", "fc", "ic", "esc", "nc", "exc", "ctx", "conv", "oder", "en", "conn", "ac", "coll", "ENC", "loc", "cod", "acc", "abc", "etc", "obj", "ent", "act", "lang", "rac", "vc", "env", "vec", "ev"], "frame_number": [" frame_position", "word_reference", " frame_reference", " frame_num", "word_number", "frame___correct", "frame_key", "frame_reference", "frame_position", "frame___number", " frame_note", " frame_correct", "frame_no", "frame_correct", "frame_num", "frame___reference", "frame___no", "word_num", "frame_note", "word_no", "frameletno", "frame_string", "frameletposition", " frame_string", "frameletnumber", " frame_no", " frame_key"], "vid": ["vd", "hi", "cat", "seq", "rid", "vi", "unit", "vr", "uid", "volume", "van", "vt", "ec", "iv", "tv", "feat", "oid", "bid", "v", "kind", "rev", "port", "cam", "ctx", "mid", "voc", "vis", "sid", "iat", "ci", "vec", "vo", "mit", "serv", "ver", "vp", "act", "uv", "cv", "VID", "vision", "pid", "voice", "vc", "id", "version", "gi", "vol", "virt", "lan", "ev"], "i": ["phi", "I", "oi", "n", "hi", "bi", "init", "li", "ri", "ui", "b", "c", "di", "iri", "ii", "im", "mi", "ki", "p", "ji", "\u0438", "ind", "ip", "ei", "v", "ai", "ij", "is", "e", "x", "pi", "jj", "fi", "in", "ini", "info", "zi", "ori", "ic", "me", "qi", "xi", "o", "it", "go", "si", "ix", "iat", "ci", "t", "index", "multi", "y", "us", "id", "ti", "sim", "gi", "chain", "m"], "bitrate": ["boardrating", " bitstep", " bitrating", "framestep", "framerating", " bitrates", "boardstep", "boardrate", "framerates", "bitrating", "framerate", "bitrates", "bitstep", "boardrates"], "ti1": ["ita2", "te2", "te0", "TI0", "ti01", "TI1", "ta0", "ti2", "te3", "ti3", "TI01", "ita1", "ta01", "ta1", "ta2", "TI3", "ita01", "ti0", "TI2", "te1", "ta3"], "pts": ["cts", "pkgps", "iptes", "pkgts", "pkges", "ctps", "ptts", "ptes", "ctes", "pkgs", "iptps", "ptps", "ipts", "ctts", "iptts"], "qp_histogram": ["qp2histric", "qp2historyric", "qp_histograms", "qp_highob", "qp2histogram", "qp_memograms", "qp_memogram", "qp_memric", "qp_highograms", "qp_historyric", "qp_historyogram", "qp2historyogram", "qp_histob", "qp2histob", "qp2historyograms", "qp_histric", "qp2histograms", "qp_highric", "qp_memob", "qp2historyob", "qp_historyograms", "qp_historyob", "qp_highogram"], "cur_time": ["curMtime", "Cur_message", "Cur_Time", "cur_Time", "cur_message", "Cur_time", " cur_id", "ctrlymemory", "ctr_times", "reqlytimer", "curlymemory", "curttime", "last_system", "ctrlysize", "curlymessage", "cur_times", "cur_system", "cur_timer", "curlytimes", "ctr_size", "req_timer", "ctrlytimes", "last_tim", "cur_ime", "cur_t", "last_time", "cur_size", "curMsize", "ctr_memory", "curlytimer", "curtime", "last_t", "curlysize", "ctrlytime", "curlytime", "cur_tim", "curlyTime", "ctr_time", "curMmemory", "cur_id", "curtid", "curMtimes", "cur_memory", "reqlysize", "req_time", "req_size", "reqlytime", " cur_ime"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_strong_loop_filter(uint8_t *src,\n\n                                                     const int step,\n\n                                                     const int stride,\n\n                                                     const int alpha,\n\n                                                     const int lims,\n\n                                                     const int dmode,\n\n                                                     const int chroma)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < 4; i++, src += stride){\n\n        int sflag, p0, q0, p1, q1;\n\n        int t = src[0*step] - src[-1*step];\n\n\n\n        if (!t)\n\n            continue;\n\n\n\n        sflag = (alpha * FFABS(t)) >> 7;\n\n        if (sflag > 1)\n\n            continue;\n\n\n\n        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +\n\n              26*src[ 0*step] + 25*src[ 1*step] +\n\n              rv40_dither_l[dmode + i]) >> 7;\n\n\n\n        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +\n\n              26*src[ 1*step] + 25*src[ 2*step] +\n\n              rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n\n        }\n\n\n\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n\n        }\n\n\n\n        src[-2*step] = p1;\n\n        src[-1*step] = p0;\n\n        src[ 0*step] = q0;\n\n        src[ 1*step] = q1;\n\n\n\n        if(!chroma){\n\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n\n        }\n\n    }\n\n}\n", "idx": 2115, "substitutes": {"src": ["inst", "ist", "tp", "via", "slice", "iter", "length", "cmp", "tr", "dist", "cur", "sn", "bh", "rest", "stream", "ind", "ij", "sync", "ic", "it", "sr", "http", "sb", "txt", "bb", "etc", "ptr", "pkg", "scan", "str", "init", "impl", "c", "th", "comp", "rec", "sel", "req", "ul", "warn", "decl", "st", "conv", "cb", "loc", "dat", "cont", "ctl", "desc", "supp", "lib", "input", "rc", "seq", "np", "bin", "ssl", "syn", "lat", "iv", "aux", "out", "sys", "secure", "rt", "ost", "bis", "addr", "usr", "phys", "bj", "sl", "tmp", "pri", "stab", "ctr", "ser", "sort", "s", "proc", "ack", "ipl", "sec", "stock", "usc", "ipp", "b", "hl", "ii", "dest", "rl", "its", "rx", "img", "stat", "bc", "fc", "sc", "source", "sur", "rs", "load", "ins", "size", "obj", "sw"], "step": ["slice", "time", "iter", "length", "error", "walk", "seed", "update", "loop", "sync", "change", "draw", "store", "trans", "push", "run", "val", "stroke", "lag", "scale", "mode", "tab", "steps", "test", "str", "STEP", "layer", "batch", "ride", "post", "status", "Step", "window", "row", "st", "group", "dat", "debug", "session", "track", "drop", "shape", "add", "version", "chain", "dim", "save", "tag", "read", "input", "start", "frame", "mod", "height", "tick", "inter", "watch", "match", "ip", "stage", "roll", "space", "key", "set", "touch", "patch", "move", "depth", "trip", "scroll", "base", "axis", "tower", "filter", "temp", "path", "d", "block", "pointer", "check", "delay", "way", "driver", "shift", "ste", "stop", "sleep", "pass", "load", "lock", "device", "split", "progress", "weight", "skip", "wait", "print"], "stride": ["stringide", "stringension", "arrides", "arrension", "strension", "STRider", "stringides", "striided", "strride", "striride", "STRided", " strride", " strider", "strided", "strides", "stide", "STRride", "stides", "striider", "arrride", "striide", "STRide", "strider", "stringride", "stension", " strided", "arride"], "alpha": ["phi", "wa", "attr", "pha", "lambda", "axis", "factor", "filter", "angle", "at", "height", "p", "la", "offset", "pi", "ho", "area", "ar", "xa", "ac", "al", "ma", "a", "si", "ta", "acc", "qa", "Alpha", "beta", "val", "da", "base", "rad", "alias", "asc", "extra", "scale", "weight", "mu", "acl", "fac"], "lims": ["Limits", "limits", "Limgs", "locgs", "lamd", "reqresses", "Limms", "locins", "tabi", " limjs", "reqs", "limts", " slimsi", "rendsd", "rendgs", "Limd", "locts", "locjs", "margments", "limS", "limments", "limins", "locs", "margfs", " limits", " slimgs", " slimments", " slimids", "reqd", "Limins", "Limsi", "lamls", "Limi", "locsd", " slims", "limfs", "Lims", "Limts", "limitsments", "limgs", "limitsfs", "limsi", "reqS", " limts", "limls", "limitsids", "margids", "LimS", "rendts", " slimi", "limresses", "locls", "lamjs", "limitss", "tabsi", "lamS", "limd", "locms", " limms", "limids", "lamresses", "lamts", "margs", "limi", "locits", " limls", "Limsd", "tabs", "lams", "limjs", "Limresses", " slimfs", "limms", "tabgs", " limins", "limsd", "rends"], "dmode": ["Dmodule", "dmod", "lmodule", " dtype", "rmod", "edmod", "dsche", "coption", "edmode", "lmode", "toption", "cMODE", " doption", " dsym", "tmodule", "Ddim", "Doption", "hmode", "Dmod", "hsche", "rmodule", "ttype", " dMODE", "ctype", "cmodule", "lmod", "dmodule", "Dsym", "rmode", "cmode", "hsym", "cdim", "doption", "DMODE", "dsym", "edmodule", "hmodule", "edsche", "dtype", "hMODE", " ddim", "ddim", "lsche", "hmod", " dmodule", "Dmode", " dmod", "dMODE", "tmode"], "chroma": ["normo", "cmpo", "cmpa", "normi", "comi", "como", "norma", "chromb", "cmpb", "chromo", "chromi", "normb", "comb", "coma", "cmpi"], "i": ["phi", "s", "iu", "I", "n", "bi", "cli", "hi", "init", "li", "ui", " j", "c", "di", "status", "by", "ii", "m", "mi", "im", "complete", "p", "inter", "l", "ip", "ai", "v", "is", "ind", "out", "x", "pi", "io", "in", "ini", "info", "zi", "ic", "me", "xi", " ti", " ii", "it", "si", "a", "go", "ix", "er", "t", "ci", "index", "multi", "ie", "h", "us", "json", "err", "id", "version", "ti", "sim", "gi", "o", "j", "series", "ex"], "sflag": ["alsflag", " sbool", "elimit", "symFlag", "sstatus", "esFlag", "tsflag", " sflags", "Sflags", "SFlag", "solean", "tsolean", "tsFlag", "esstatus", "estatus", "slimit", " solean", "statsflags", "eflags", "eflag", "statsflag", "symolean", "Sstatus", "statsFlag", "esflag", " sstatus", "esflags", "eFlag", "alsstatus", "sFlag", "symflags", "alsbool", "sflags", "tsflags", " sFlag", "Slimit", "sbool", "Sflag", "alsFlag", "statslimit", "symflag"], "p0": ["pi0", "pr000", " p000", " pnull", " p00", "pr0", "pa0", "pa15", "pt000", "ip1", "pp1", " pole", "pa90", "piole", "ptzero", "p15", "ptno", "ipno", "pingno", "P00", "ip000", " p15", "p00", "pp0", "pa000", "qnull", "pi90", "pt0", "pole", "ping000", "pno", "pr15", "pnull", "paole", "P0", "ping0", "ipzero", "p90", "pa1", "pingzero", "ip0", "P1", "p000", "pzero", "pp00", "ipnull", "pr1", " p90"], "q0": ["p5", "qtentry", "qk", "q2", "qu2", "qt1", "qor", "qu5", "g0", "q000", "quk", "por", "g5", "eq0", "sqee", " qor", "sqk", "qu1", "quZero", "g1", "qentry", "quee", "eq1", " q2", "pentry", "q5", "sq0", " qk", "quentry", "pZero", "eq000", "p000", "qZero", "quor", " qee", " qZero", "eq5", "sq2", "g000", "qu0", "qt5", "qee", "qt0"], "p1": ["ppOne", "pi81", "pp2", "q2", "pp100", "pr1", "cpone", "p100", "pp1", "pione", "P2", " pOne", "cp81", "pi1", "pr100", "qup", " pone", "pp0", "p81", "POne", "pone", "lp0", "lpone", " p81", " p2", "pi01", "prup", "p2", "P0", " p01", "pr2", "p01", "ppup", "cp1", "P1", "lpOne", "qone", "q100", "qOne", "cp01", "pOne", "pup", "lp1"], "q1": [" qone", "pn", "p10", "qn", "qun", "q10", "pone", "qu1", " q10", "quOne", "quone", "qu10", "qone", " qOne", "qOne", "qu0", " qn", "pOne"]}}
{"project": "qemu", "commit_id": "03fcbd9dc5084ff4676c153fbe04fb0fcf939d09", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n\n{\n\n    DeviceClass *dc;\n\n    const char *driver, *path;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    dc = qdev_get_device_class(&driver, errp);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}", "idx": 2124, "substitutes": {"opts": [" opouts", "opcs", " opets", "okets", "oktions", "optcs", "copts", "spetions", " opgs", "copals", "optouts", "optvals", "iops", "speets", "opgs", "OPps", "alics", "options", "optals", "opps", "copps", "proals", "OPts", "iopTS", "OPs", "optpt", " opps", "OPics", "iopcs", "prots", "optgs", "iopts", "props", "okts", "iopgs", "speTS", "opvals", "ops", "optts", "pros", "OPls", "iopvals", "oppt", "iopps", "spets", " opTS", "alps", "iopouts", "opics", "copTS", "opTS", "okTS", "proTS", "opals", " oppt", "ioppt", "iopls", " opvals", "optics", "optls", "opls", "alcs", "OPTS", "alts", "optTS", "opouts", "OPcs", " options", "opets", "optps"], "errp": ["errorpe", "rerpy", "dangerp", "ererpa", "rerP", "errpy", "ererpart", "rerv", " errcp", "terpre", "aerP", "errcp", "arrcp", " errP", "derpa", "errpress", "rerpress", "errorv", " errbp", "ererv", "dangerpre", "aerp", " errpe", "derpy", "errorp", "ererbp", "rrpt", "errpt", "derping", "tracepa", "ierp", "rerpe", "errpart", "dangerpa", "arrP", " errv", "aerpress", "rerpa", "errping", "ererP", "errpa", "arrpa", "rerp", "ererpre", "dangerpart", "ererpy", "tracebp", "derpt", "aerpart", "errP", "derpid", "errorpy", "rrping", "terpart", "terp", "arrpy", "terpa", "errorP", " errpart", "errbp", "arrp", "errpre", "arrpid", "derp", "rrpa", "ererp", "errv", "errpe", "ierping", " errpress", " errpy", "tracep", "rrp", "rerpid", "tracecp", "ierpt", " errpa", "ierpa", "rerpart", "traceP", "errpid"], "dc": ["cca", "design", "cr", "cat", "rc", "mc", "cmp", "cot", "cfg", "ct", "c", "di", "lc", "ca", "currency", "deck", "d", "dp", "gc", "controller", "cc", "cp", "ec", "pc", "cf", "ga", "bc", "disc", "cm", "dd", "kw", "fc", "nc", "sc", "ctx", "cam", "coord", "df", "ac", "draw", "ds", "coll", "dt", "doc", "dat", "dir", "fee", "da", "disk", "tc", "dr", "DC", "cs", "cmd", "desc", "vc", "cd", "ctr", "css", "db"], "driver": ["method", "db", "Driver", "test", "service", "bridge", "str", "iter", " drivers", "target", "browser", "engine", "dist", "error", "d", "finder", "control", "controller", "reader", "cp", "wrapper", "description", "river", "route", "drivers", "definition", "select", "connection", "window", "DR", "field", "direction", "kind", "dd", "prefix", "handler", "source", "url", "handle", "conn", "store", "ds", "host", "addr", "manager", "der", "dir", "operator", "class", "proxy", "device", "drive", "root", "dr", "track", "writer", "direct", "cmd", "desc", "project", "cd", "label", "config", "creator", "owner", "box"], "path": ["method", "Path", "inner", "transform", "spec", "collection", "axis", "str", "input", "form", "length", "c", "th", "pt", "p", "local", "mount", "anc", "type", "pointer", "parent", "route", "context", "template", "prefix", "cross", "kind", "name", "port", "binding", "url", "history", "key", "host", "full", "loc", "dir", "arc", "ref", "where", "cert", "ath", "root", "alias", "partial", "pkg", "raw", "cmd", "id", "chain", "config", "pattern", "PATH", "data", "box"], "dev": ["de", "ad", "db", "test", "pro", "del", "init", "var", "dem", "dep", "nt", "tr", "jump", "dist", "w", "fo", "Device", "sd", "prop", "iv", "ve", "stable", "mem", "aux", "v", "ex", "pub", "way", "dis", "dd", "def", "die", "ow", "cam", "os", "conn", "serial", "ds", "go", "gu", "ov", "develop", "adv", "res", "Dev", "development", "tech", "val", "dm", "device", "ver", "wd", "debug", "obj", "sw", "hw", "des", "priv", "cmd", "DEV", "scan", "env", "data", "ev"], "bus": ["bug", "bridge", "null", "cache", "mount", "loop", "bid", "port", "binding", "handle", "conn", "docker", "http", "home", "bool", "cus", "vc", "boot", "prop", "db", "test", "bs", "hand", "di", " BUS", "util", "bal", "bolt", "buf", "kit", "os", "host", "cb", "loc", "hub", "chain", "vol", "box", "stick", "lib", "cat", "bird", "uses", "bar", "valid", "sys", "Bus", "ctx", "full", "dir", "state", "proxy", "join", "phys", "root", "disk", "alias", "us", "tx", "proc", "jack", "b", "func", "block", "gen", "used", "local", "board", "type", "bind", "socket", "bc", "way", "handler", "ac", "BUS", "pass", "load", "lock", "cast", "buff", "bo", "back"], "err": ["test", "cr", "attr", "iter", "rc", "cfg", "error", "kr", "r", "dy", "buf", "ec", "req", "rx", "Error", "die", "rev", "arr", "conf", "exc", "rr", "conn", "cb", "der", "er", "msg", "loc", "res", "resp", "rs", "usr", "obj", "cmd", "errors", "eas", "ev", "mr"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,\n\n                              int buf_size, int buf_size2)\n\n{\n\n    RVDecContext *rv = avctx->priv_data;\n\n    MpegEncContext *s = &rv->m;\n\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;\n\n\n\n    active_bits_size = buf_size * 8;\n\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n\n    if (s->codec_id == AV_CODEC_ID_RV10)\n\n        mb_count = rv10_decode_picture_header(s);\n\n    else\n\n        mb_count = rv20_decode_picture_header(rv);\n\n    if (mb_count < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->mb_x >= s->mb_width ||\n\n        s->mb_y >= s->mb_height) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n\n    left   = s->mb_width * s->mb_height - mb_pos;\n\n    if (mb_count > left) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {\n\n        // FIXME write parser so we always have complete frames?\n\n        if (s->current_picture_ptr) {\n\n            ff_er_frame_end(&s->er);\n\n            ff_MPV_frame_end(s);\n\n            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;\n\n        }\n\n        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)\n\n            return ret;\n\n        ff_mpeg_er_frame_start(s);\n\n    } else {\n\n        if (s->current_picture_ptr->f.pict_type != s->pict_type) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n\n\n    /* default quantization values */\n\n    if (s->codec_id == AV_CODEC_ID_RV10) {\n\n        if (s->mb_y == 0)\n\n            s->first_slice_line = 1;\n\n    } else {\n\n        s->first_slice_line = 1;\n\n        s->resync_mb_x      = s->mb_x;\n\n    }\n\n    start_mb_x     = s->mb_x;\n\n    s->resync_mb_y = s->mb_y;\n\n    if (s->h263_aic) {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_aic_dc_scale_table;\n\n    } else {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n\n    }\n\n\n\n    if (s->modified_quant)\n\n        s->chroma_qscale_table = ff_h263_chroma_qscale_table;\n\n\n\n    ff_set_qscale(s, s->qscale);\n\n\n\n    s->rv10_first_dc_coded[0] = 0;\n\n    s->rv10_first_dc_coded[1] = 0;\n\n    s->rv10_first_dc_coded[2] = 0;\n\n    s->block_wrap[0] =\n\n    s->block_wrap[1] =\n\n    s->block_wrap[2] =\n\n    s->block_wrap[3] = s->b8_stride;\n\n    s->block_wrap[4] =\n\n    s->block_wrap[5] = s->mb_stride;\n\n    ff_init_block_index(s);\n\n\n\n    /* decode each macroblock */\n\n    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {\n\n        int ret;\n\n        ff_update_block_index(s);\n\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n        s->mv_dir  = MV_DIR_FORWARD;\n\n        s->mv_type = MV_TYPE_16X16;\n\n        ret = ff_h263_decode_mb(s, s->block);\n\n\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n\n        // bitstream size\n\n        if (ret != SLICE_ERROR) {\n\n            int v = show_bits(&s->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_MPV_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n", "idx": 2130, "substitutes": {"avctx": ["avctl", "afctx", "avectl", "avcontext", "avContext", "averpid", "averconfig", "navconfig", "vrctx", "avtx", "wavcfg", "avconfig", "avconn", "navtc", "awconn", "wavjac", "navkt", "afpkg", "averkt", "avecfg", "avereq", "avercontext", "awjac", "navctx", "avercfg", "vrconfig", "aveconn", "averreq", "awctl", "avreq", "awcfg", "avertc", "avetc", "wavpkg", " avcontext", " avconfig", "avtc", "avectx", "avecontext", "wavctx", " avctl", "awctx", "vrcontext", "awpkg", " avContext", "avepid", "avekt", "avkt", " avconn", "averctx", "averContext", "avpkg", "avjac", " avtx", "averctl", "avpid", "awcontext", "wavreq", "aveconfig", "avcfg", "vrtx", "avetx", "afjac", "wavpid", "afcfg", "awContext"], "buf": ["fb", "bp", "bl", "cap", "rc", "seq", "bytes", "uf", "b", "rb", "pb", "block", "Buff", "map", "wb", "img", "mem", "v", "bc", "bf", "queue", "br", "cb", "msg", " buffer", "ref", "txt", "cv", "Buffer", "tmp", "raw", "cmd", "buffer", "buff", "data", "vec"], "buf_size": [" buf_Size", "buffer_len", " buf_start", "buffer_size", "buf_time", "buf_index", "buf_Size", "buffer_time", " buf_SIZE", "buffer_index", "buffer_SIZE", "buf_SIZE", "buf_len", "buffer_ize", "buf_start", "buf_ize"], "buf_size2": ["buf_SIZE3", "buf_type4", "buf_size4", "buf_SIZE2", "buf_size3", "buf_SIZE1", "buf_type3", "buf_type2", "buf_size1", "buf_SIZE4", "buf_type1"], "rv": ["srch", "arf", "srcv", "drV", " rV", "srf", "prV", "rV", "drvr", " rvc", "srv", "rcvc", "rvc", " rch", "srvc", "arv", "prvr", "rcch", " rcv", "rf", "prcv", "arcv", "drv", " rf", "rch", " rvr", "arV", "rccv", "drcv", "prv", "rvr", "srV", "rcv"], "s": ["n", "sg", "ags", "r", "i", "south", "is", "v", "views", "parts", "sis", "ies", "o", "store", "fs", "ds", "eps", "gets", "bits", "http", "sb", "h", "sq", "hs", "actions", "ears", "sports", "bs", "ses", "ands", "c", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "https", "ids", "details", "j", "has", "ports", "qs", "events", "ssl", "states", "p", "ps", "l", "sys", "terms", "less", "ss", "tests", "ms", "ctx", "set", "params", "times", "state", "args", "us", "mods", "aunts", "m", "sam", "spec", "stats", "ads", "xs", "self", "comm", "results", "es", "b", "ls", "sets", "w", "als", "ts", "its", "tags", "changes", "gs", "g", "conf", "sc", "source", "ows", "rs", "ns", "t", "ins", "S", "obj", "sw", "cs", "js", "aws", "news"], "mb_count": ["mblltime", "mb_start", "mm_success", "bar64found", "embedashn", "embed_start", "mbitycount", "mb7found", "ob_loc", "mm_counter", "mbityCount", "mbllcounter", "mbCountcount", "mb32success", "embed_size", "ob64found", "bb_current", "mb64more", "mbllcount", "mb_len", "mb6len", "bar_count", "mb32count", "mm_time", "bb_count", "mbCountsuccess", "bb_counter", "mb7len", "mb_size", "mb67more", "mb67count", "mb_n", "mbashn", "mb_found", "bar_found", "mbCountcounter", "mb67found", "ob_count", "embed_n", "ob64loc", "embed_count", "mm32success", "mb_current", "mb32time", "mb7loc", "mm32count", "ob_len", "bb_Count", "mb_counter", "mbashstart", "mbitycounter", "mbCounttime", "mb64len", "mb_time", "mb64found", "mbitycurrent", "mb_success", "embedashsize", "embedashstart", "embedashcount", "ob_found", "mbashsize", "mb7count", "mbllsuccess", "bar64count", "bar_more", "mb6loc", "mb_Count", "ob64count", "bar64more", "mb_loc", "mm32counter", "ob64len", "mb6found", "mm32time", "mbashcount", "mb_more", "mb64loc", "mm_count", "mb64count", "mb32counter", "mb6count"], "mb_pos": ["kb_pos", "kb_loc", "mb67mon", "emb_col", "mb_start", "mb_loc", "mb_neg", "mb67info", "mb_Pos", "emb_pos", "mbacunit", "mbacpos", "jpg_mon", "mb_unit", "kb_start", "emb_neg", "mb_col", "jpg_info", "emb_Pos", "jpg_pos", "kb_unit", "mb_mon", "jpg67pos", "mbacstart", "mb67pos", "jpg67info", "mb_info", "jpg67mon", "mbacloc"], "start_mb_x": ["start_mb_ex", "start_mb_y", "start_mm_x", "start_mm_ex", "start_mm_y"], "active_bits_size": ["active_bits_ize", "active_bits_SIZE", "active_bits_type", "active_bits_max", "active_bytes_ize", "active_bytes_SIZE", "active_bytes_type", "active_bytes_max", "active_bytes_size"], "ret": ["flag", "nl", "rets", "det", "nt", "re", "tr", "new", "not", "status", "try", "alt", "ll", " Ret", "mem", "out", "fun", "def", "rev", "ft", "jp", "ter", "rt", "len", "elt", "gt", "reset", "mel", "it", "cb", "resp", "Ret", "RET", "res", "t", "val", "rel", "cont", "cert", "txt", "tf", "mt", "progress", " RET", "f", "err", "result", "back", "rem"], "mb_x": ["ib_w", "mb_ix", "mb_xy", "mb_ex", "ib_x", "emb_px", "mbxex", "mboxwidth", "mb_xs", "mboxxi", "mbajxy", "mbajy", "mbajex", "mboxix", "emb_xy", "emb_y", "mbxix", "mbxx", "mb_xi", "ib_ix", "emb_ex", "mb_px", "mboxx", "mb_width", "mb_w", "emb_x", "ib_xi", "mbxy", "emb_width", "ib_y", "ib_xs", "MB_ex", "mbajx", "MB_x", "MB_y", "ib_width", "MB_ix"], "mb_y": ["tmp_yy", "mb_ny", "mb_yy", "kbJx", "kb_x", "mb__yy", "mbJx", "mobi_cy", "kbJny", "mobi_sy", "mb__ny", "kbJya", "kb_y", "broad_y", "mbJy", "mb__y", "kb_ya", "mb_ya", "mb_height", "MB_yy", "broad_x", "mb_ye", "broad_ye", "mbJya", "MB_height", "mbJny", "broad_yy", "tmp_height", "tmp_y", "MB_x", "kbJy", "MB_y", "mb_cy", "mb_sy", "tmp_ny", "mobi_y", "kb_ny", "mb__height"]}}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n", "idx": 2133, "substitutes": {"cpu": ["proc", "core", "tp", "ork", "pool", "cmp", "c", "CPU", "bench", "cu", "prof", "frame", "comp", "gc", "p", "uu", "cp", "pc", "ck", "socket", "pai", "prefix", "linux", "jp", "queue", "runner", "pixel", "os", "copy", "physical", "process", "rpm", "component", "pu", "phys", "clock", "gpu", "hw", "pkg", "gp", "processor", "cmd", "vm", "mac", "config", "nic", "pid"]}}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n", "idx": 2142, "substitutes": {"dst": ["dhbsp", "idsrc", "idsc", "idct", "adbr", " dlist", " dST", "delct", " dsrc", "dST", "dsc", "dhict", "adST", " dx", "dlist", "bsrc", " dbn", "dsput", "drabn", " dbsp", "dhcr", "idst", "fdsts", "dsp", "dcr", "idbsp", "dbr", "bsts", "dsts", "delbr", "dx", "pdst", "draST", " dict", "idbr", "delst", " dsc", "drast", "dhst", " dsp", "drabr", "adst", "dsbr", "dsST", " dsts", "dobr", "dsrc", "bsp", "dbsp", "dobn", "dbn", "bst", "adput", " dbr", "idsp", "pdx", " dct", "dict", "fdst", "fdlist", "delsc", "idcr", "doST", "dost", "idict", "pdsts", "dput", "fdx", " dcr", "pdlist", " dput", "dsst", "dct", "idsts"], "idx": ["Idx", "IDxf", "identxc", "ridn", "identx", "Idxy", "idctx", "Idfx", "IDv", "idxs", "Idv", " idxe", " idxy", "aidxy", "idxy", "Idxe", "identxp", "ridx", " idxc", "idn", "aidxf", "indxp", "identxs", "indxc", "idfx", "ridxs", " idxs", "aidx", "Idctx", "IDxe", " idn", " idfx", "idxp", "Idxf", "idv", "IDfx", "idxf", "aidxs", "IDctx", "indn", "indx", " idxf", "Idxs", "idxc", "indxs", "IDx", " idxp", " idctx", "ridxc", "idxe", " idv"], "sign": ["tag", "sql", "spec", "sch", "flag", "Sign", "form", "var", "rc", "ident", "diff", "use", "mask", "sort", "script", "style", "comment", "status", "rank", "mod", "sum", "sd", "SIGN", "decl", "sh", "pres", "ss", "secure", "pay", "se", "sc", "shift", "sv", "draw", "code", "go", "flags", " sig", "operator", "ign", "pack", "asc", "scale", "sq", "z", "shape", "sp", "sl", "desc", "close", "add", "trade", "sa", "sub", "id", "save", "sy"]}}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}", "idx": 2148, "substitutes": {"mon": ["sam", "mer", "ston", " mu", "dom", "det", "man", " vis", " serv", " mem", "di", " matt", "mag", "mi", "met", "util", " Mon", "admin", "wat", "mint", "von", "monkey", "mm", "MON", "onet", "inv", "Mon", " man", "mons", "ann", "chron", "mn", "dat", "mun", "den", "tim", "med", "dm", "mat", "monitor", " monitor", "mt", "hog", "mut", "tem", "meter", "mu", "net", "annot", " mom", "sim", "mont", "m", "san"], "qdict": [" qd", "dqdir", "qd", "qdir", " qmap", "querydict", "querydir", "dqmap", "querymap", "dqd", "queryd", "dqdict", " qdir", "qmap"], "list": ["ist", "present", "n", "count", "null", "lam", "cli", "iter", "record", "flat", "LIST", "r", "stream", "loop", "v", "sync", "queue", "coll", "and", "pkg", "range", "scan", "detail", "top", "test", "single", "bl", "batch", "lists", "pair", "map", " playlist", "listed", "ul", "old", "row", "L", "st", "def", "len", "file", "pl", "cont", "table", "index", "pre", "add", "chain", "collection", "elist", "seq", "see", "new", "dl", "rule", "alist", "lat", "l", "out", "valid", "format", "info", "lt", "all", "copy", "code", "set", "full", "state", "List", "level", "m", "result", "spec", "stack", "view", "form", "li", "filter", "summary", "block", "local", "type", "check", "parent", "feat", "stat", "arr", "link", "lp", "t", "load", "lock", "act", "obj", "none", "print"], "err": ["test", "attr", "urg", "str", "empty", "iter", "cfg", "error", "kr", "status", "r", "oc", "buf", "req", "Error", "bar", "good", "sys", "ex", "e", "inv", "die", "oe", "arr", "conf", "exc", "rr", "coord", "coll", "aaa", "ev", "der", "er", "resp", "msg", "res", "rs", "report", "found", "usr", "order", "dr", "Er", "cmd", "ok", "errors", "notice", "result", "alloc", "mr"]}}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    TrimContext       *s = ctx->priv;\n\n    int64_t start_sample, end_sample = frame->nb_samples;\n\n    int64_t pts;\n\n    int drop;\n\n\n\n    /* drop everything if EOF has already been returned */\n\n    if (s->eof) {\n\n        av_frame_free(&frame);\n\n        return 0;\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        pts = av_rescale_q(frame->pts, inlink->time_base,\n\n                           (AVRational){ 1, inlink->sample_rate });\n\n    else\n\n        pts = s->next_pts;\n\n    s->next_pts = pts + frame->nb_samples;\n\n\n\n    /* check if at least a part of the frame is after the start time */\n\n    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {\n\n        start_sample = 0;\n\n    } else {\n\n        drop = 1;\n\n        start_sample = frame->nb_samples;\n\n\n\n        if (s->start_sample >= 0 &&\n\n            s->nb_samples + frame->nb_samples > s->start_sample) {\n\n            drop         = 0;\n\n            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts + frame->nb_samples > s->start_pts) {\n\n            drop = 0;\n\n            start_sample = FFMIN(start_sample, s->start_pts - pts);\n\n        }\n\n\n\n        if (drop)\n\n            goto drop;\n\n    }\n\n\n\n    if (s->first_pts == AV_NOPTS_VALUE)\n\n        s->first_pts = pts + start_sample;\n\n\n\n    /* check if at least a part of the frame is before the end time */\n\n    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {\n\n        end_sample = frame->nb_samples;\n\n    } else {\n\n        drop       = 1;\n\n        end_sample = 0;\n\n\n\n        if (s->end_sample != INT64_MAX &&\n\n            s->nb_samples < s->end_sample) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts < s->end_pts) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_pts - pts);\n\n        }\n\n\n\n        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);\n\n        }\n\n\n\n        if (drop) {\n\n            s->eof = 1;\n\n            goto drop;\n\n        }\n\n    }\n\n\n\n    s->nb_samples += frame->nb_samples;\n\n    start_sample   = FFMAX(0, start_sample);\n\n    end_sample     = FFMIN(frame->nb_samples, end_sample);\n\n    av_assert0(start_sample < end_sample);\n\n\n\n    if (start_sample) {\n\n        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        av_frame_copy_props(out, frame);\n\n        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,\n\n                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                        frame->format);\n\n        if (out->pts != AV_NOPTS_VALUE)\n\n            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },\n\n                                     inlink->time_base);\n\n\n\n        av_frame_free(&frame);\n\n        frame = out;\n\n    } else\n\n        frame->nb_samples = end_sample;\n\n\n\n    s->got_output = 1;\n\n    return ff_filter_frame(ctx->outputs[0], frame);\n\n\n\ndrop:\n\n    s->nb_samples += frame->nb_samples;\n\n    av_frame_free(&frame);\n\n    return 0;\n\n}\n", "idx": 2157, "substitutes": {"inlink": ["Inlinks", " inLink", "INlock", "inink", "conline", "INLink", "conink", "Inlink", "Inline", "inlinks", "InLink", "INlinks", "cincheck", " inink", "inlock", "cinink", "INline", "cinlock", "cinlink", "conlock", "cinLink", " inlinks", "INcheck", " incheck", " inlock", "inLink", "incheck", "cinline", "conlink", "INlink"], "frame": ["fb", "time", "fr", "sample", "length", "point", "fram", "page", "style", "response", "error", "face", "block", "channel", "remote", "Frame", "fps", "word", "window", "header", "e", "context", "x", "fi", "message", "rame", "image", "trace", "list", "info", "file", "video", "document", "zone", "line", "force", "show", "link", "space", "flow", "set", "process", "ce", "profile", "t", "base", "framework", "state", "component", "sf", "ence", "module", "session", "feature", "frames", "policy", "movie", "iframe", "f", "scene", "request", "vm", "range", "version", "buffer", "event", "function", "data", "sequence"], "ctx": ["k", "xs", "Context", "bs", "init", "mc", "cmp", "ct", "c", "lc", "ia", "p", "cp", "cc", "cf", "ck", "gs", "sys", "context", "cm", "xc", "tz", "nc", "sc", "conv", "conn", "ac", "ds", "cb", "loc", " cx", "t", "ns", "act", "cv", "tc", "tmp", "pkg", "cs", "cmd", "tx", "config"], "s": ["n", "time", "r", "i", "is", "v", "parts", "sis", "ies", "fs", "ds", "bits", "sb", "h", "y", "sq", "hs", "actions", "steps", "bs", "sample", "q", "ses", "c", "x", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "ids", "z", "sim", "j", "sql", "qs", "states", "p", "sd", "ps", "fps", "l", "sys", "terms", "less", "info", "ss", "space", "ms", "set", "so", "state", "sm", "args", "sl", "sp", "m", "sort", "service", "spec", "stats", "xs", "es", "b", "ls", "sets", "d", "w", "seconds", "als", "ts", "its", "changes", "gs", "e", "g", "se", "source", "settings", "t", "ns", "rs", "ins", "S", "sf", "size", "sw", "ess", "f", "cs", "js", "series"], "start_sample": ["end_sam", "start_service", "resetvalSample", "start_seed", "start_server", "start_integer", "start_tone", "end_depth", "start_sequence", "beforejerror", "end_snap", "start_channel", "startjservice", "startmysample", "startvalSample", "beforejservice", "startjsample", "end_seed", "starttsam", "start_mouse", "startaysample", "start_system", "start_sound", "starting_service", "start_error", " start_channel", "startmysystem", "before_error", " start_binary", "start_string", "end_profile", "reset_sample", "start_tile", "start_average", "beforejsample", "before_service", "art_window", "end_server", "startvalexample", "starting_string", "starting_tone", "start_Sample", "startaychannel", "start_binary", "start_snap", "startvalsample", "start_depth", "reset_integer", "before_mouse", "startmyinteger", "startaybinary", "end_sequence", "startjmouse", "starttwindow", "beforejmouse", "end_average", "starting_sequence", "reset_tile", "resetvalexample", "before_sample", "art_sample", "startmytile", "end_package", "startjerror", "starting_sam", "start_profile", "starttsample", "reset_system", "resetvalsample", "art_sam", "start_sam", "end_sample", "end_Sample", "reset_example", "start_example", "start_package", "starting_sample", "reset_Sample", "end_sound", "start_window"], "pts": ["cmds", "ptments", "ppts", "rounds", "points", "ptis", "iptss", "cts", "epts", "iptes", "ptials", "nts", "ptps", "ppords", "ppes", "ptports", "ntments", "posials", "ntports", "ointS", "ointps", "ptords", "ntss", "aptjs", "pointjs", "cmdjs", "ptS", "ntxs", "posss", "ptrsets", "cmdts", "pps", "ctss", "ointials", "ptxs", "ntords", "ctports", "iptries", "ptes", "pkgts", "eptries", "ptjs", "iptets", "iptxs", "iptjs", "pointes", "ptices", "roundts", "aptes", "posps", "ntts", "posts", "ports", "iptials", "poss", "eptts", "pointords", "iptis", "ptts", "iptS", "ctts", "aptts", "aptices", "pkges", "aptis", "ptsets", "ointss", "ipts", "ntps", "ointets", "ptres", "ptss", "apts", "posxs", "pkgices", "oints", "ptries", "portts", "ntets", "iptts", "ptrs", "ntS", "cmdis", "portxs", "pointsets", "pkgs", "iptsets", "ppjs", "ptets", "iptps", "ppices", "ppments", "ntjs", "ptrts", "ointts", "pointments", "pointts", "roundries", "iptports"], "drop": ["disable", "dust", " dropped", "stack", "null", "zip", "slice", " dropping", " Drop", "sample", "layer", " cond", "drops", "batch", "foo", "comment", "grow", "error", "paste", "pped", "dl", "dp", "try", "carry", "pause", "ignore", "stone", "delay", "throw", "loop", "create", "dropping", "trap", "field", "trace", "keep", "ion", "change", "list", "port", "hold", "hide", "driver", "col", "hop", "shift", "gap", "push", "dro", "stop", "delete", "report", "op", "rop", "leave", "burn", " clip", "dr", "pop", "allow", "move", "crop", "shape", "skip", "err", "red", "dim", "Drop", "slot"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,\n\n                               const TCGArg * const args, uint16_t dead_args,\n\n                               uint8_t sync_args)\n\n{\n\n    int flags, nb_regs, i;\n\n    TCGReg reg;\n\n    TCGArg arg;\n\n    TCGTemp *ts;\n\n    intptr_t stack_offset;\n\n    size_t call_stack_size;\n\n    tcg_insn_unit *func_addr;\n\n    int allocate_args;\n\n    TCGRegSet allocated_regs;\n\n\n\n    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\n\n    flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\n\n    if (nb_regs > nb_iargs) {\n\n        nb_regs = nb_iargs;\n\n    }\n\n\n\n    /* assign stack slots first */\n\n    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);\n\n    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & \n\n        ~(TCG_TARGET_STACK_ALIGN - 1);\n\n    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);\n\n    if (allocate_args) {\n\n        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,\n\n           preallocate call stack */\n\n        tcg_abort();\n\n    }\n\n\n\n    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;\n\n    for(i = nb_regs; i < nb_iargs; i++) {\n\n        arg = args[nb_oargs + i];\n\n#ifdef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset -= sizeof(tcg_target_long);\n\n#endif\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            temp_load(s, ts, tcg_target_available_regs[ts->type],\n\n                      s->reserved_regs);\n\n            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);\n\n        }\n\n#ifndef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset += sizeof(tcg_target_long);\n\n#endif\n\n    }\n\n    \n\n    /* assign input registers */\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    for(i = 0; i < nb_regs; i++) {\n\n        arg = args[nb_oargs + i];\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            reg = tcg_target_call_iarg_regs[i];\n\n            tcg_reg_free(s, reg, allocated_regs);\n\n\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                if (ts->reg != reg) {\n\n                    tcg_out_mov(s, ts->type, reg, ts->reg);\n\n                }\n\n            } else {\n\n                TCGRegSet arg_set;\n\n\n\n                tcg_regset_clear(arg_set);\n\n                tcg_regset_set_reg(arg_set, reg);\n\n                temp_load(s, ts, arg_set, allocated_regs);\n\n            }\n\n\n\n            tcg_regset_set_reg(allocated_regs, reg);\n\n        }\n\n    }\n\n    \n\n    /* mark dead temporaries and free the associated registers */\n\n    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n        if (IS_DEAD_ARG(i)) {\n\n            temp_dead(s, &s->temps[args[i]]);\n\n        }\n\n    }\n\n    \n\n    /* clobber call registers */\n\n    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {\n\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {\n\n            tcg_reg_free(s, i, allocated_regs);\n\n        }\n\n    }\n\n\n\n    /* Save globals if they might be written by the helper, sync them if\n\n       they might be read. */\n\n    if (flags & TCG_CALL_NO_READ_GLOBALS) {\n\n        /* Nothing to do */\n\n    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n        sync_globals(s, allocated_regs);\n\n    } else {\n\n        save_globals(s, allocated_regs);\n\n    }\n\n\n\n    tcg_out_call(s, func_addr);\n\n\n\n    /* assign output registers and emit moves if needed */\n\n    for(i = 0; i < nb_oargs; i++) {\n\n        arg = args[i];\n\n        ts = &s->temps[arg];\n\n        reg = tcg_target_call_oarg_regs[i];\n\n        assert(s->reg_to_temp[reg] == NULL);\n\n\n\n        if (ts->fixed_reg) {\n\n            if (ts->reg != reg) {\n\n                tcg_out_mov(s, ts->type, ts->reg, reg);\n\n            }\n\n        } else {\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ts->reg] = NULL;\n\n            }\n\n            ts->val_type = TEMP_VAL_REG;\n\n            ts->reg = reg;\n\n            ts->mem_coherent = 0;\n\n            s->reg_to_temp[reg] = ts;\n\n            if (NEED_SYNC_ARG(i)) {\n\n                tcg_reg_sync(s, reg, allocated_regs);\n\n            }\n\n            if (IS_DEAD_ARG(i)) {\n\n                temp_dead(s, ts);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2182, "substitutes": {"s": ["n", "sg", "stats", "spec", "self", "ses", "services", "es", "b", "c", "ls", "w", "p", "its", "ps", "gs", "is", "sys", "x", "less", "ss", "g", "conf", "ims", "sc", "ms", "source", "sv", "os", "fs", "ds", "eps", "a", "set", "sts", "rs", "ns", "t", "sb", "S", "ins", "session", "y", "h", "us", "sq", "z", "cs", "hs", "js", "m"], "nb_oargs": ["nb_itissues", "nb_ocjobs", "nb67oarg", "nb67oarr", "nb_pojobs", "nb_itarg", "nb_mochanges", "nbableochanges", "nb_poants", "nb_iissues", "nb_oads", "nb__iargs", "nb_itargs", "nb_oants", "nb_iarr", "nb_oiframes", "nb_ichanges", "nbableoargs", "nb_moarg", "nb_ooarg", "nb_ooaws", "nb_ods", "nb_ijobs", "nb67itissues", "nb_iaws", "nb__iarg", "nb_oaws", "nb__oframes", "nb_oids", "nb_oiarg", "nb__ids", "nb__oarg", "nb__oargs", "nbableoaws", "nb_oarr", "nbableooarg", "nb_ocarg", "nbableoarg", "nb_poargs", "nb_poarg", "nbableooaws", "nb_iframes", "nb__ods", "nb67itarr", "nb67itarg", "nb_ochanges", "nb_oaissues", "nb_oaarr", "nb_ooargs", "nb_moargs", "nb_ojobs", "nb67itargs", "nbableooargs", "nb_oochanges", "nb_ocants", "nb_moaws", "nb_oiargs", "nbableoochanges", "nb_oaarg", "nb67oargs", "nb_oaargs", "nb_itarr", "nb_oaframes", "nb67oissues", "nb__iframes", "nb_ids", "nb_oframes", "nb_oissues", "nb_ocargs", "nb_iarg", "nb_oarg", "nb_iants"], "nb_iargs": ["nb___iuactions", "nb_iuArgs", "nb_oitems", "nb_Iactions", "nb___iresults", "nb_ibArgs", "nb_mivalues", "nb_piorders", "nb_icargs", "nb_ivalues", "nb_iuxs", "nb_icamps", "nb___iArgs", "nb_siargs", "nb___icaux", "nb08phiassets", "nb____iargs", "nb_iresults", "nb_piarg", "nb___iatts", "nb08iarr", "nb__iargs", "nb_siitems", "nb_inievents", "nb_miamps", "nb_miresults", "nb_ievents", "nb_iarr", "nb08phiamps", "nb_iamps", "nb_iatts", "nb_ibevents", "nb_icvalues", "nb____iArgs", "nb_idorders", "nb_miitems", "nb_piargs", "nb08iamps", "nb_iniactions", "nb_oevents", "nb_tiresults", "nb_iuactions", "nb_idaux", "nb___icvalues", "nb08iargs", "nb_sievents", "nb____iuArgs", "nb08iassets", "nb08phiargs", "nb___iargs", "nb____ievents", "nb_oaux", "nb___iuArgs", "nb____iuevents", "nb_ciarr", "nb_iniargs", "nb_oorders", "nb__oargs", "nb__oArgs", "nb__oorders", "nb_phiarr", "nb_ibargs", "nb_icresults", "nb_mievents", "nb__iitems", "nb_phiassets", "nb_iaux", "nb_IArgs", "nb_phiamps", "nb_miargs", "nb__iorders", "nb___icargs", "nb_piitems", "nb_ciamps", "nb___iuargs", "nb_miaux", "nb_piaux", "nb___iuatts", "nb____ixs", "nb___icresults", "nb___iactions", "nb___ivalues", "nb_oxs", "nb_tiargs", "nb08phiarr", "nb___iaux", "nb__iArgs", "nb_ciassets", "nb_tivalues", "nb_Iargs", "nb_idargs", "nb_tiaux", "nb_iitems", "nb_iuatts", "nb_idarg", "nb_iniitems", "nb_ciargs", "nb_ixs", "nb_oArgs", "nb_iniorders", "nb_phiargs", "nb_iorders", "nb_iniArgs", "nb_icassets", "nb_iuargs", "nb_icaux", "nb_iassets", "nb_icarr", "nb_iniamps", "nb_piArgs", "nb____iuargs", "nb_iuevents", "nb_Iatts", "nb__oitems", "nb_iArgs", "nb_iarg", "nb____iuxs", "nb_siamps", "nb_oarg", "nb_ibxs", "nb_iactions", "nb_iniatts"], "args": ["stats", "xs", "qs", "users", "results", "items", "ags", "values", "atts", "ams", "arms", "its", "points", "changes", "aux", "gs", "units", "members", "terms", "fields", "parts", "keys", "arr", "grades", "tests", "ims", "orders", "ms", "objects", "fs", "data", "settings", "vs", "params", "types", "rs", "ns", "bits", "as", "rows", "amps", "vals", "frames", "ids", "cs", "js", "aws", "uments", "Args", "actions"], "dead_args": ["dead67args", "dead_flags", "deadmmargs", "dead67flags", "deadmmkeys", "dead_keys", "raw_args", "dead_posts", "raw_keys", "raw_posts", "dead67posts", "deadmmflags", "raw_flags", "dead67keys", "deadmmposts"], "sync_args": ["sync2vals", "load_arg", "sync_arg", "sync12arg", "load_args", "load_vals", "sync2flags", "sync12args", "sync12flags", "load_flags", "sync_vals", "sync12vals", "sync2args", "sync2arg", "sync_flags"], "flags": ["ports", "flag", "stats", "xs", "FLAG", "ants", "ui", "options", "mask", "ags", "items", "atts", "status", "ints", "tags", "comments", "cons", "heads", "members", "kind", "ops", "fields", "keys", "features", "fs", "params", "ats", "types", "bits", "weights", "vals", "frames", "lag", "weight", "cs", "Flags", "names", "actions"], "nb_regs": ["nb_recn", "nb_refs", "nb_Reges", "nbTregds", "nb_patternles", "nb_signs", "nb_inds", "nbptpatterns", "nb_argds", "nb_indS", "nb_mems", "nb_resS", "nb_regxs", "nb_reges", "nbptpatternles", "nb_resles", "nb_effies", "nb_regns", "nb_indxs", "nb_registerS", "nb_recS", "nb_ress", "nbTsignists", "nb_legS", "nb_regrs", "nb_resps", "nb_regS", "nb_patternns", "nbptreges", "nbTsignS", "nbptregns", "nbTregists", "nbptpatternes", "nb_signS", "nb_Regns", "nb_legists", "nbptregles", "nb_effS", "nb_locS", "nb_regles", "nb_registers", "nbTregs", "nb_legds", "nb_REGis", "nb_regn", "nb_args", "nb_recs", "nb_refis", "nb_effxs", "nb_legs", "nb_reses", "nbTsigns", "nb_regies", "nbTregS", "nbptpatternns", "nb_resns", "nbTsignds", "nb_locis", "nb_patterns", "nb_REGins", "nb_indies", "nb_regds", "nb_locs", "nb_signists", "nb_REGs", "nb_memies", "nb_locps", "nb_regins", "nb_argS", "nb_Regs", "nb_patternes", "nb_memS", "nb_REGrs", "nb_regis", "nb_Regles", "nb_argists", "nbptregs", "nb_refins", "nb_regps", "nb_registerps", "nb_regists", "nb_refrs", "nb_signds", "nb_locins", "nb_recps", "nb_memxs", "nb_effs", "nb_locrs", "nb_registern", "nb_loces"], "i": ["phi", "iu", "I", "n", "bi", "cli", "li", "ui", "point", "di", "iri", "ia", "ii", "im", "mi", "ir", "\u0438", "ind", "ip", "ai", "is", "ei", "ij", "x", "e", "pi", "fi", "u", "in", "ini", "zi", "ic", "me", "qi", "xi", "ims", "o", "it", "gu", "si", "ix", "ci", "Ni", "index", "multi", "ie", "y", "us", "id", "ti", "sim", "gi", "m", "j", "instance"], "reg": ["tag", "inst", "str", "init", "rc", "var", "re", "tr", "ct", "func", "block", "mod", "rec", "r", "gc", "ret", "ress", "req", "REG", "mem", "row", "stat", "def", "Reg", "g", "name", "region", "or", "ig", "br", "link", "addr", "loc", "res", "val", "rel", "ref", "obj", "eg", "typ", "urg", "rem"], "arg": ["tag", " act", "ack", "attr", "flag", "ag", "var", " prop", "pat", "emb", "temp", " doc", "ark", " agg", "star", "p", "ret", " prog", " var", "word", " tag", "v", "argument", "field", "parse", "ax", " cand", "gt", "arr", "g", "jp", "par", " beg", "ar", "col", "ac", "ig", " ar", "arp", "ma", "key", "op", " ag", "t", "agg", "val", "cand", "act", " ax", "Arg", "call", "ace", " aux", " pad", "ass", " exc", "f", "cmd", " marg", "j", "prop"], "ts": ["tp", "TS", "bs", "tips", "tt", "ics", "tr", "Ts", "td", "ls", "pt", "als", "its", "ps", "tops", "mint", "uts", "gs", "ss", "tz", "tl", "tes", "ms", "ims", "ys", "aps", "acs", "fs", "ds", "vs", "fts", "ats", "sts", "times", "rs", "t", "ns", "tis", "txt", "tm", "mt", "tc", "tmp", "cs", "hs", "tx", "ets", "js"], "stack_offset": ["stackxoffset", "ack_off", "Stack_length", "stack_Offset", "stack__start", "stack_off", "pack__start", "pack__index", "stack_start", "stack__index", "stack__offset", "Stack_size", "Stack_Offset", "stack__addr", "pack__addr", "stack_addr", "stack_length", "pack__offset", "stackxstart", "pack_addr", "ack_offset", "pack_start", "stackxaddr", "stack_size", "ack_start", "ack_size", "pack_offset", "stack_index", "pack_index", "stackxindex", "Stack_offset"], "call_stack_size": ["call_stackzSIZE", "call_stackzSize", "call_space_size", "call_stack_SIZE", "call_code_info", "call_code_SIZE", "call_stack_type", "call_codezSize", "call_track_depth", "call_stackzinfo", "call_code_Size", "call_track_size", "call_space_type", "call_codezsize", "call_stack_depth", "call_stack_Size", "call_space_offset", "call_space_addr", "call_track_SIZE", "call_track_Size", "call_space_Size", "call_codezinfo", "call_stack_addr", "call_stackzsize", "call_stack_info", "call_code_size", "call_codezSIZE", "call_stack_offset", "call_space_SIZE"], "func_addr": ["unc_ptr", "func__address", "func__ref", "func_ptr", "func_address", "fun_ref", "fun_address", "fun__ref", "func__addr", "func_ref", "fun__addr", "unc_addr", "fun_addr", "fun__address", "unc_address"], "allocate_args": ["alloca_args", "allocated_flags", "allocate___flags", "allocated_facts", "allocate____ags", "alloca_arg", "allocate67args", "allocate____facts", "allocate_flags", "allocate_arg", "allocated_arg", "allocated_ags", "alloca_parts", "allocate____jobs", "allocate____args", "allocate67jobs", "allocate____arg", "allocate67arg", "allocate_parts", "allocate____flags", "allocated_jobs", "alloca_ags", "allocate67facts", "allocate_ags", "allocate_facts", "allocated_args", "allocate_jobs", "allocate___args", "allocate___ags", "allocate___arg"], "allocated_regs": ["allocated_memn", "allocated_mems", "allocated_recn", "allocated_locs", "allocated_locn", "allocated_regn", "allocated_recp", "allocated_locp", "allocated_regp", "allocated_memp", "allocated_recs"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n", "idx": 2187, "substitutes": {"arg": ["ad", "param", "attr", "str", "ag", "new", "star", "og", "oc", "i", "ge", "argument", "ray", "parse", "ary", "__", "arr", "g", "reg", "ar", "group", "fire", "ay", "ac", "ig", "doc", "ng", "a", "arp", "it", "val", "agg", "args", "cand", "ref", "pg", "Arg", "ass", "event"], "s": ["sam", "spec", "iss", "str", "bs", "self", "ses", "q", "comm", "es", "b", "ares", "ls", "p", "ts", "ps", "gs", "is", "sys", "st", "less", "ss", "se", "sc", "ar", "sis", "sv", "os", "bis", "ds", "set", "a", "sts", "ats", "t", "rs", "sm", "serv", "ns", "sb", "S", "as", "state", "args", "y", "ess", "sq", "sl", "hs", "sp", "js", "aws", "sa", "m", "j"], "running": ["inner", "using", "enabled", "ready", "checked", "working", "standing", "loading", "called", "m", "active", "playing", "reading", "starting", "ered", "stable", "blocking", "l", "performing", "valid", "current", "all", "ending", "run", "available", "total", "including", "state", "multi", "done", "successful", "runs", " Running", "calling", "started", "Running", "loaded"], "r": ["n", "attr", "str", "rar", "rc", "q", " err", "re", "rd", "c", "rb", "d", "rg", "pr", "p", "ret", "i", "l", "v", "e", "u", "gr", "rt", "ror", "ar", "rn", "rr", "or", "br", "it", "run", "sr", "er", "res", "t", "rs", "h", "dr", "R", "nr", "err", "m", "result", "ro", "mr"]}}
{"project": "FFmpeg", "commit_id": "f95cfff07765912676cc613b55e2234b5d70f1bd", "target": 0, "func": "static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)\n\n{\n\n    static int hinted = 0;\n\n    int ret = 0;\n\n    AVDictionaryEntry *e;\n\n    const AVOption *o = NULL;\n\n    const char *option = NULL;\n\n    const char *codec_name = NULL;\n\n    char buff[1024];\n\n    AVCodecContext *ctx;\n\n    AVDictionary **dict;\n\n    enum AVCodecID guessed_codec_id;\n\n\n\n    switch (type) {\n\n    case AV_OPT_FLAG_VIDEO_PARAM:\n\n        ctx = config->dummy_vctx;\n\n        dict = &config->video_opts;\n\n        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_video_codec_id : AV_CODEC_ID_H264;\n\n        break;\n\n    case AV_OPT_FLAG_AUDIO_PARAM:\n\n        ctx = config->dummy_actx;\n\n        dict = &config->audio_opts;\n\n        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;\n\n        break;\n\n    default:\n\n        av_assert0(0);\n\n    }\n\n\n\n    if (strchr(opt, ':')) {\n\n        //explicit private option\n\n        snprintf(buff, sizeof(buff), \"%s\", opt);\n\n        codec_name = buff;\n\n        option = strchr(buff, ':');\n\n        buff[option - buff] = '\\0';\n\n        option++;\n\n        if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)\n\n            return ret;\n\n        if (!ctx->codec || !ctx->priv_data)\n\n            return -1;\n\n    } else {\n\n        option = opt;\n\n    }\n\n\n\n    o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n\n    if (!o && (!strcmp(option, \"time_base\")  || !strcmp(option, \"pixel_format\") ||\n\n               !strcmp(option, \"video_size\") || !strcmp(option, \"codec_tag\")))\n\n        o = av_opt_find(ctx, option, NULL, 0, 0);\n\n    if (!o) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                            &config->errors, \"Option not found: %s\\n\", opt);\n\n        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {\n\n            hinted = 1;\n\n            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,\n\n                                \"If '%s' is a codec private option, then prefix it with codec name, \"\n\n                                \"for example '%s:%s %s' or define codec earlier.\\n\",\n\n                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);\n\n        }\n\n    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt,\n\n                arg, av_err2str(ret));\n\n    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {\n\n        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))\n\n            return av_dict_set(dict, option, arg, AV_DICT_APPEND);\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors,\n\n                \"Redeclaring value of the option %s, previous value: %s\\n\",\n\n                opt, e->value);\n\n    } else if (av_dict_set(dict, option, arg, 0) < 0) {\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2188, "substitutes": {"opt": ["cho", "attr", "ext", "str", "j", "var", "iter", "ff", "bin", "options", "Opt", "pt", "alt", "p", "cp", "buf", "timeout", "pot", "mem", "tip", "aux", "offset", "OP", "prefix", "Option", "gt", "crit", "rt", "intern", "name", "ost", "opted", "it", "anon", "expr", "op", "val", "txt", "ref", "text", "etc", "obj", "tmp", "cmd", "tx", "typ", "ption", "term", "off", "optim", "prop"], "arg": ["tag", "param", "flag", "attr", "rc", "use", "bin", "target", "head", "mem", "aux", "argument", "ax", "arr", "reg", "bit", "key", "arp", "op", "val", "args", "ref", "enc", "call", "Arg", "cmd", "err", "event"], "type": ["Type", "tag", "test", "count", "null", "time", "what", "length", "style", "error", "rule", "p", "family", "parent", "kind", "ping", "format", "info", "file", "name", "or", "key", "value", "pe", "op", "types", "t", "state", "class", "size", "index", "y", "feature", "TYPE", "sp", "id", "ty", "action", "typ", "range", "buffer", "ype"], "config": ["param", "null", "cmp", "control", "cache", "ind", "attribute", "change", "history", "conn", "store", "etc", "setup", "pkg", "fig", "address", "net", "json", "cmd", "gate", "support", "init", "c", "anc", "req", "drivers", "prefix", "command", "dat", "acc", "cont", "known", "connect", "desc", "add", "figure", "Config", "complete", "con", "collection", "lib", "get", "rc", "adj", "correct", "FIG", "cc", "ec", "admin", "format", "info", "exc", "reflect", "set", "params", "state", "args", "text", "policy", "greg", "unknown", "rac", "spec", "google", "sec", "reason", "diff", "exec", "comm", "cfg", "ct", "comment", "remote", "check", "connection", "context", "bc", "conf", "network", "doc", "settings", "t", "apache", "subject", "tc", "storage", "client"], "e": ["de", "n", "el", "et", "ef", "es", "eu", "c", "p", "ei", "x", "oe", "ele", "en", "E", "ae", "pe", "er", "ue", "element", "ie", "ed", "ent", "ea", "f", "ee", "ev"], "o": ["k", "n", "oo", "et", "oa", "c", "ot", "O", "m", "d", "fo", "p", "iso", "i", "l", "out", "v", "offset", "onet", "u", "ob", "oe", "om", "mo", "oin", "os", "or", "go", "a", "op", "t", "vo", "obj", "h", "f", "lo", "bo", "j", "po", "io"], "option": ["param", "null", "ff", "put", "options", "error", "cp", "i", "attribute", "Option", "or", "value", "order", "empty", "alt", "argument", "prefix", "ion", "command", "archive", "second", "question", "table", "index", "usage", "action", "buffer", "term", "tag", "bin", "answer", "point", "consider", "section", "entry", "condition", "optional", "field", "number", "TION", "name", "menu", "key", "position", "op", "alias", "tmp", "unknown", "ption", "result", "slot", "cho", "flag", "comment", "byte", "pointer", "description", "timeout", "connection", "offset", "operation", "total", "zero", "none", "event", "OP"], "codec_name": ["codec__info", "codecnamenames", "codecnameword", "codEC__name", "codEC_id", "codec_format", "codecnamewrapper", "codecnameid", "codec_wrapper", "codEC__id", "codecNameid", "codEC_wrapper", "codecNameword", "codec_info", "codecnameinfo", "codec_word", "codecNamenames", "codec_id", "codecNamename", "codecnamename", "codEC__info", "codEC_info", "codec_names", "codec_Name", "codec__wrapper", "codEC__wrapper", "codec__name", "codEC_name", "codec__id"], "buff": ["null", "iter", "ff", "nt", "options", "selected", "i", "ind", " buffer", "txt", "bb", "enc", "h", " Buff", "ptr", "cmd", "tab", "off", "str", "bs", "batch", "uf", "pb", "buf", "uff", "window", "prefix", " buf", "len", "cb", "loc", "inf", "tf", "Buffer", "desc", "buffer", "j", "data", "box", "fb", "ext", "needed", "bin", "fr", "Buff", "p", "ret", "ip", "aux", "ary", "kw", "rt", "pp", "op", "text", "tmp", "form", "eb", "IT", "b", "comment", "temp", "nd", "flash", "mem", "offset", "bind", "ob", "font", "ref", "size", "obj", "mb", "raw", "f", "butt", "bo"], "ctx": ["k", "wx", "init", "pool", "np", "nt", "uf", "cfg", "ct", "func", "cu", "util", "kt", "p", "anc", "cp", "cc", "buf", "req", "mem", "cf", "ck", "window", "mk", "ij", "sys", "x", "bc", "context", "co", "dc", "kw", "crit", "tz", "conf", "rt", "sc", "handler", "conv", "handle", "conn", "ac", "voc", "cb", "loc", "resp", "op", "iat", "ns", "qt", "txt", "act", "unc", "cv", "obj", "tc", "hw", "pkg", "tmp", "setup", "std", "ctl", "cmd", "tx", "bo", "alloc"], "dict": ["ad", "und", "hash", "nt", "ct", "di", "cond", "d", "w", "rec", "map", "p", "hd", "buf", "mem", "ict", "bind", "context", "dd", "def", "conf", "df", "conn", "ds", "doc", "coll", "dt", "dat", "dir", "state", "inf", "table", "txt", "obj", "h", "dr", "ent", "pkg", "cmd", "tx", "details", "cd", "data", "db"], "guessed_codec_id": ["guessed_codian_name", "guessed_codec_info", "guessed_codecoeinfo", "guessed_codec_flag", "guessed_codec_link", "guessed_codecoeflag", "guessed_codec_ids", "guessed_codoc_info", "guessed_codoc_name", "guessed_codecoeid", "guessed_codian_class", "guessed_codian_link", "guessed_codoc_id", "guessed_codoc_ids", "guessed_codoc_flag", "guessed_codian_id", "guessed_codoc_type", "guessed_codec_type", "guessed_codec_name", "guessed_codecoename", "guessed_codec_class"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n\n{\n\n    CPUMoxieState *env = &cpu->env;\n\n\n\n    /* Local cache for the instruction opcode.  */\n\n    int opcode;\n\n    /* Set the default instruction length.  */\n\n    int length = 2;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    /* Examine the 16-bit opcode.  */\n\n    opcode = ctx->opcode;\n\n\n\n    /* Decode instruction.  */\n\n    if (opcode & (1 << 15)) {\n\n        if (opcode & (1 << 14)) {\n\n            /* This is a Form 3 instruction.  */\n\n            int inst = (opcode >> 10 & 0xf);\n\n\n\n#define BRANCH(cond)                                                         \\\n\n    do {                                                                     \\\n\n        int l1 = gen_new_label();                                            \\\n\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n\n        gen_set_label(l1);                                                   \\\n\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n\n        ctx->bstate = BS_BRANCH;                                             \\\n\n    } while (0)\n\n\n\n            switch (inst) {\n\n            case 0x00: /* beq */\n\n                BRANCH(TCG_COND_EQ);\n\n                break;\n\n            case 0x01: /* bne */\n\n                BRANCH(TCG_COND_NE);\n\n                break;\n\n            case 0x02: /* blt */\n\n                BRANCH(TCG_COND_LT);\n\n                break;\n\n            case 0x03: /* bgt */\n\n                BRANCH(TCG_COND_GT);\n\n                break;\n\n            case 0x04: /* bltu */\n\n                BRANCH(TCG_COND_LTU);\n\n                break;\n\n            case 0x05: /* bgtu */\n\n                BRANCH(TCG_COND_GTU);\n\n                break;\n\n            case 0x06: /* bge */\n\n                BRANCH(TCG_COND_GE);\n\n                break;\n\n            case 0x07: /* ble */\n\n                BRANCH(TCG_COND_LE);\n\n                break;\n\n            case 0x08: /* bgeu */\n\n                BRANCH(TCG_COND_GEU);\n\n                break;\n\n            case 0x09: /* bleu */\n\n                BRANCH(TCG_COND_LEU);\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /* This is a Form 2 instruction.  */\n\n            int inst = (opcode >> 12 & 0x3);\n\n            switch (inst) {\n\n            case 0x00: /* inc */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x01: /* dec */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x02: /* gsr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            case 0x03: /* ssr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_st_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* This is a Form 1 instruction.  */\n\n        int inst = opcode >> 8;\n\n        switch (inst) {\n\n        case 0x00: /* nop */\n\n            break;\n\n        case 0x01: /* ldi.l (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x02: /* mov (register-to-register) */\n\n            {\n\n                int dest  = (opcode >> 4) & 0xf;\n\n                int src = opcode & 0xf;\n\n                tcg_gen_mov_i32(REG(dest), REG(src));\n\n            }\n\n            break;\n\n        case 0x03: /* jsra */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n\n\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x04: /* ret */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                /* The new $sp is the old $fp.  */\n\n                tcg_gen_mov_i32(REG(1), REG(0));\n\n\n\n                /* Pop the frame pointer.  */\n\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n\n\n                /* Pop the return address and skip over the static chain\n\n                   slot.  */\n\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n                tcg_temp_free_i32(t1);\n\n\n\n                /* Jump... */\n\n                tcg_gen_exit_tb(0);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x05: /* add.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x06: /* push */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                tcg_gen_subi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x07: /* pop */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x08: /* lda.l */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x09: /* sta.l */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0a: /* ld.l (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0b: /* st.l */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0c: /* ldo.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0d: /* sto.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0e: /* cmp */\n\n            {\n\n                int a  = (opcode >> 4) & 0xf;\n\n                int b  = opcode & 0xf;\n\n\n\n                tcg_gen_mov_i32(cc_a, REG(a));\n\n                tcg_gen_mov_i32(cc_b, REG(b));\n\n            }\n\n            break;\n\n        case 0x19: /* jsr */\n\n            {\n\n                int fnreg = (opcode >> 4) & 0xf;\n\n\n\n                /* Load the stack pointer into T0.  */\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x1a: /* jmpa */\n\n            {\n\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1b: /* ldi.b (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1c: /* ld.b (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1d: /* lda.b */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1e: /* st.b */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1f: /* sta.b */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x20: /* ldi.s (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x21: /* ld.s (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x22: /* lda.s */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x23: /* st.s */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x24: /* sta.s */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x25: /* jmp */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x26: /* and */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x27: /* lshr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x28: /* ashl */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x29: /* sub.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2a: /* neg */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_neg_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2b: /* or */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2c: /* not */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_not_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2d: /* ashr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x2e: /* xor */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2f: /* mul.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x30: /* swi */\n\n            {\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(temp, val);\n\n                tcg_gen_st_i32(temp, cpu_env,\n\n                               offsetof(CPUMoxieState, sregs[3]));\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x31: /* div.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x32: /* udiv.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x33: /* mod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x34: /* umod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x35: /* brk */\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n            }\n\n            break;\n\n        case 0x36: /* ldo.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x37: /* sto.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x38: /* ldo.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: /* sto.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n", "idx": 2190, "substitutes": {"cpu": ["proc", "core", "ork", "np", "aco", "cmp", "ct", "CPU", "cu", "gc", "cp", "cc", "pc", "mem", "ck", "onet", "jac", "linux", "xc", "nc", "pp", "upt", "cam", "conn", "ac", "process", "node", "apache", "hap", "pu", "clock", "cv", "gpu", "hw", "processor", "cum", "aq", "alloc"], "ctx": ["proc", "wx", "Context", "np", "nt", "mc", "cmp", "cfg", "ct", "cu", "kt", "comp", "gc", "cc", "cp", "pc", "std", "window", "ck", "bc", "context", "x", "jac", "kw", "jp", "xc", "crit", "nc", "sc", "conn", "tk", "cb", "kh", "loc", "txt", "index", "act", "obj", "tc", "cv", "setup", "hw", "pkg", "ctl", "sp", "cmd", "tx", "config", "cas", "xp", "ctrl", "alloc"], "env": ["proc", "gov", "init", "neck", "eh", "cfg", "nv", "entry", "map", "equ", "environment", "ec", "vt", "buf", "window", "next", "context", "eng", "conf", "EN", "en", "conn", "scope", "end", "code", "viron", "pe", "er", "vas", "gear", "node", "obj", "dev", "ptr", "ent", "cmd", "tx", "priv", "config", "eas", "ev"], "opcode": ["hoptag", "hopcode", "optag", "operse", "coptext", "hopstr", "hopse", "opse", "OPse", "ipCode", "opercoded", "operCode", "bitse", " opc", "hoptext", "opaque", "opcoded", "wordse", "plink", "OPCode", "bitaque", "ipc", "Opc", "operc", "Opse", "coptag", "oplink", "bitcode", "pc", " opstr", "hopmode", " opCode", "opercode", "opbyte", "pcode", "opertext", "OPcode", "opCode", "opc", "Opcode", "opmode", "wordcode", "ipcode", "opermode", "OpCode", "hopbyte", " opmode", " opse", "operlink", "opertag", "opstr", "hopCode", "Opaque", "hopc", "optext", "wordcoded", "operbyte", "pse", " opcoded", "copcode", "bitCode", "operstr", "copbyte", "hoplink", "OPaque"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n", "idx": 2195, "substitutes": {"s": ["n", "sg", "stats", "bs", "qs", "q", "ses", "es", "b", "c", "tains", "ls", "w", "ains", "p", "ts", "its", "ps", "is", "gs", "v", "sys", "e", "ties", "ss", "g", "ers", "ims", "ms", "tes", "sc", "sv", "ies", "os", "fs", "ds", "vs", "sts", "ats", "er", "t", "ns", "rs", "as", "sb", "S", "ins", "h", "us", "sw", "sq", "cs", "hs", "js", "m"], "opc": ["OPcc", " opC", "ipcs", " opcs", "copC", "coppc", "iopc", "copcs", "opC", "opcu", "OPpc", "Opcs", "mpct", "optc", " opcp", "OpC", "optrc", "iopct", " opci", "ipca", "Opgc", "copfc", "oppc", "mpfc", "opcc", "opcs", "Opfc", "copc", "copsc", "ipgc", "opsc", "OPct", "hopgc", "hopct", "optfc", "mppc", "iopcs", "Opc", "copct", "copcc", "hopcs", "mpc", " opct", "hopca", "copca", "opfc", "OPci", "OPcs", "Opca", "Opsc", "hopci", "OPr", "optci", "opcp", "hopcc", "hoppc", "opgc", "OPrc", "Oprc", "Opci", "opr", "OPca", " opcu", "ipcu", "OPfc", "copci", "Opcp", "optca", "iopC", "optdc", "OPC", "iopci", "Oppc", "ipc", "opct", "Opdc", "iopr", "opdc", "hopcu", " opr", "optsc", "oprc", "OPdc", "hopc", "copcp", "OPc", "opca", "opci", "ipct"], "r": ["n", "ra", "q", "re", "b", "c", "rb", "d", "w", "ru", "pr", "p", "rx", "i", "l", "v", "e", "u", "g", "rt", "reg", "ar", "rr", "or", "ry", "er", "res", "t", "h", "y", "f", "R", "m", "ro", "mr"], "rm": ["cr", "lr", "RM", "md", "re", "rd", "rb", "mi", "rl", "mp", "rx", "rim", "mem", "mk", "bm", "arm", "cm", "rt", "reg", "rn", "mn", "rr", "xa", "mg", "cb", "pm", "rpm", "sm", "dm", "tm", "mr", "orm", "mt", "mb", "ml", "err", "tx", "xe", "nm", "rem", "m", "mx", "rom"], "x": ["n", "wx", "xs", "q", "re", "b", "X", "w", "p", "rx", "i", "xy", "l", "dx", "v", "st", "ax", "xc", "xi", "xa", "ry", "ix", "t", "y", "xx", "lex", "z", "f", "ox", "tx", "xe", "xt", "m", "mx", "ex"], "rex": ["xxxxxxxx", "eas", "wx", "rett", "el", "xs", "rison", "pex", "xes", "bytes", "maybe", "re", " ex", "rez", "wr", "com", "gex", "xb", "bolt", "ye", "rx", "xy", "xxxx", "aus", "nexus", "aux", "ck", "sky", "cre", "dis", "xd", "def", "ax", "xc", "axe", "fax", "EX", "xi", "mx", "rax", "xa", "flex", "gre", "oxy", "exe", "nex", "gb", "res", "docker", "iban", "yes", "xx", " Rex", "lex", "des", " dex", " re", "broad", "ox", "rew", "json", "xe", "Rex", "crow", "euro", "ex", "dx", "io"]}}
{"project": "qemu", "commit_id": "d0d5d0e31a874d592741a088c2c5071bae164dbf", "target": 1, "func": "qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n\n                            uint64_t bytes, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QEMUIOVector hd_qiov;\n\n    struct iovec iov;\n\n    z_stream strm;\n\n    int ret, out_len;\n\n    uint8_t *buf, *out_buf;\n\n    uint64_t cluster_offset;\n\n\n\n    if (bytes == 0) {\n\n        /* align end of file to a sector boundary to ease reading with\n\n           sector based I/Os */\n\n        cluster_offset = bdrv_getlength(bs->file->bs);\n\n        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, s->cluster_size);\n\n    if (bytes != s->cluster_size) {\n\n        if (bytes > s->cluster_size ||\n\n            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)\n\n        {\n\n            qemu_vfree(buf);\n\n            return -EINVAL;\n\n        }\n\n        /* Zero-pad last write if image size is not cluster aligned */\n\n        memset(buf + bytes, 0, s->cluster_size - bytes);\n\n    }\n\n    qemu_iovec_to_buf(qiov, 0, buf, bytes);\n\n\n\n    out_buf = g_malloc(s->cluster_size);\n\n\n\n    /* best compression, small window, no zlib header */\n\n    memset(&strm, 0, sizeof(strm));\n\n    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n\n                       Z_DEFLATED, -12,\n\n                       9, Z_DEFAULT_STRATEGY);\n\n    if (ret != 0) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    strm.avail_in = s->cluster_size;\n\n    strm.next_in = (uint8_t *)buf;\n\n    strm.avail_out = s->cluster_size;\n\n    strm.next_out = out_buf;\n\n\n\n    ret = deflate(&strm, Z_FINISH);\n\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n\n        deflateEnd(&strm);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    out_len = strm.next_out - out_buf;\n\n\n\n    deflateEnd(&strm);\n\n\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n\n        /* could not compress: write normal cluster */\n\n        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        goto success;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset =\n\n        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);\n\n    if (!cluster_offset) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    cluster_offset &= s->cluster_offset_mask;\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    iov = (struct iovec) {\n\n        .iov_base   = out_buf,\n\n        .iov_len    = out_len,\n\n    };\n\n    qemu_iovec_init_external(&hd_qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n\n    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\nsuccess:\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(buf);\n\n    g_free(out_buf);\n\n    return ret;\n\n}\n", "idx": 2213, "substitutes": {"s": ["n", "stats", "xs", "bs", "self", "ses", "es", "b", "abilities", "ls", "ssl", "states", "sn", "als", "p", "its", "ts", "ps", "i", "changes", "l", "gs", "is", "sys", "less", "parts", "ss", "ms", "sv", "os", "ies", "bis", "fs", "ds", "vs", "settings", "sts", "ats", "so", "rs", "ns", "as", "bits", "args", "sb", "S", "ins", "sw", "sq", "cs", "sp", "hs", "details", "js", "aws", "j", "bes"], "hd_qiov": ["hd_iqrir", "hd_qiour", "hd_qqigroup", "hd_qigroup", "hd_qqiour", "hd_giov", "hd_qrir", "hd_gigroup", "hd_qqrir", "hd_iqigroup", "hd_qqiov", "hd_iqiov", "hd_grir", "hd_giour", "hd_iqiour"], "iov": ["uj", "ibr", "vector", "sbm", "roman", "iro", "rolet", "ovi", "iour", "iv", "tv", "ivic", "river", "rio", "ij", "nov", "conv", "chrom", "iev", "rir", "rov", "IO", "iol", "iao", "ibl", "iop", "vec", "io"], "strm": ["trmt", "strcm", "stringsm", "crm", "strf", "srsm", "glm", " ostrmm", " strsm", "glum", "strmd", " strmat", "arrmm", "sprM", " strmp", "frmp", "srmo", "strmm", "slm", "stram", "strman", "schemt", "charum", " stmd", "stemman", "srm", "sprn", "stringmat", "strmp", "stman", "stam", " STRmd", "stemgm", "stemim", "Strmt", "frM", " stmm", "sprmt", "crM", " strgm", "schemm", "strsm", "stringmt", " strman", "stm", " STRm", "charm", "frm", " STRdm", "slsm", " STRmm", "arrsm", "strmt", "trM", "stgm", "srmat", "arrm", "strrm", "strgm", "stringam", "STRf", "stmt", "srim", "STRm", "stringmo", "frr", "crsm", "stemmp", "strdm", "stringgm", "srcm", "strum", " stm", "STRrm", "stringm", "stcm", " strim", "charf", "sprum", " strM", "crmt", "strM", "glrm", "slM", "Strm", "STRmt", "stringcm", " ostrdm", " strf", "stmo", " stdm", " ostrmd", "charmt", "strmat", "strmo", "Strsm", "trn", "schem", "sprm", "stemM", "slmt", "arrmt", "STRn", "stringim", " ostrm", "strr", "stim", "stringmm", " strum", "StrM", "trm", "stemm", "STRM", "sprrm", " strmt", "sram", "strim", "STRum", "stemr", "schesm", "glmt", "strn", " strr"], "ret": ["rets", "hash", "nt", "re", "tr", "prot", "error", "ber", "ll", "pas", "deg", "ry", "dt", "resp", "Ret", "val", "tech", "net", "cmd", "del", " alt", "ert", "att", " fut", "after", "alt", "pret", "def", "rev", "ft", "gt", "ter", "len", "sat", "backed", "cont", "mt", "desc", "j", "ext", "cat", "nz", "try", "arg", " Ret", "out", "sys", "leg", "rt", "elt", "RET", "result", "rem", "det", "pat", " resp", "summary", "vet", " res", "pt", "opt", "ts", "mem", "fun", "reset", "res", "t", "RT", "cert", "ref", " RET", "err", "red", "print", "back"], "out_len": ["out32lim", "out___loc", "out32len", " out_lim", " out_mult", "out___len", "out___mult", "out_lim", " out_loc", "out_mult", "out_loc", " out_ln", "out_ln", "out32ln"], "buf": ["fb", "bs", "init", "var", "seq", "iter", "bin", "orig", "length", "bytes", "emb", "batch", "uf", "b", "rb", "pb", "block", "Buff", "lim", "map", "wb", "img", "mem", "window", "offset", "bar", "out", "nom", "bc", "ob", "queue", "result", "len", "ctx", "xff", "br", "doc", "cb", "msg", "ref", "txt", "cv", "Buffer", "mb", "tmp", "pkg", "raw", "alloc", "cmd", "err", "buffer", "ctr", "buff", "off", "data", "vec", "box"], "out_buf": ["in_cb", "out2buf", "in_buf", "out_cb", "out2buffer", "out_uf", " out_uf", "out_buffer", " out_buffer", "out2uf", " out_cb", "in_buffer", "out2cb", " out_queue", "out_queue", "in_uf"], "cluster_offset": ["cluster_length", "clocker_offset", "cluster8Offset", "clocker_length", "cluster8position", "cluster8offset", "clust_position", "clust_pos", "cluster_Offset", "clust_origin", "cluster_position", "clust_offset", "cluster8origin", "cluster__position", "cluster_origin", "clust_Offset", "cluster_shift", "cluster_size", "clocker_shift", "clocker_size", "cluster__offset", "cluster_pos", "cluster__Offset", "cluster__origin"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229, "substitutes": {"ctx": ["wx", "bp", "xs", "kb", "work", "np", "nt", "cmp", "batch", "cfg", "ct", "today", "dl", "kt", "bh", "gc", "p", "anc", "kl", "cp", "cc", "req", "xy", "warn", "ind", "std", "cf", "ck", "cpu", "mk", "bc", "context", "x", "jac", "cm", "prefix", "kw", "xc", "jp", "gt", "nc", "sc", "history", "conn", "cb", "wcs", "kh", "iat", "abc", "txt", "act", "etc", "obj", "tc", "hw", "pkg", "tmp", "ctl", "cmd", "tx", "js", "xp", "urg"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2246, "substitutes": {"ysrc": ["iesource", "insr", "iesr", "esrc", "insusc", "sysusc", "ysr", "esusc", "inssrc", "syssrc", "insrc", "esource", "iesrc", "mysrc", "iessrc", "myssrc", "sysrc", "iesusc", "mysusc", "essrc", "mysource", "ysource", "sysr", "ysusc", "yssrc"], "usrc": [" usource", "ausource", "aussrc", "tssrc", "usource", "usersource", " ussrc", "usrt", "ausrc", "usesource", "tsrt", "usesrc", " usrt", "ussrc", "userssrc", "usrs", "ausrs", "usersrt", "usersrc", "usesrs", "tsrc", "tsource", " usrs", "usessrc"], "vsrc": ["cvrc", "vrc", "Vctr", "cvsource", " vrc", "Vaddr", "vsource", "src", " vaddr", "Vrc", " vctr", "fsource", " vsource", "frc", "saddr", "vserv", "cvsrc", "sctr", "fsrc", " vserv", "vaddr", "Vsrc", "vctr", "fserv", "cvserv", "ssrc"], "dst": ["dust", "yust", "sddest", "dodest", "dsust", "sdsts", "dST", "dsdest", "sdcr", "ddest", "yst", "dcr", "dsts", "lsts", "doust", "ldest", "dsST", " dsts", "yST", "lcr", "doST", "dost", "sdst", "lst", " ddest", " dcr", "ydest", "dsst"], "height": ["ht", "resolution", "count", "hang", "length", "build", "volume", "dist", "gh", "ih", "Height", "yt", "w", "html", "he", "family", "wh", "density", "window", "uh", "hei", " heights", "headers", "history", "ows", "inches", "radius", "zh", "size", "rows", "hz", "stroke", "h", "y", "gravity", "loss", "depth", "shape", "ty", "ch", "gy", "dim", "cy"], "lumStride": ["lumRestide", "lumSTbit", "limStbe", "lumstride", "lumRestride", "limStrride", "limStr", "limStbit", "limStrr", "lumstr", "lumRestr", "lumStbit", "lumStrrat", "lumSTide", "limStide", "lumStrbit", "lumstbe", "lumstide", "limStrrat", "lumSTride", "lumStbe", "lumStrbe", "limStride", "limStrbe", "lumstrat", "limStrbit", "limStrat", "lumRestrat", "lumStrride", "lumStrat", "lumSTbe", "lumStrr", "lumstbit", "lumStide", "lumStr"], "chromStride": ["romStride", "chromSTr", "romStine", "chromStr", "chromstr", "chromSTide", "chromChrip", "chromRestine", "romStrr", "chromStrrip", "chromChine", "chromStrr", "chromStrride", "romStide", "chromStrlen", "chromChride", "romStrip", "chromChide", "chromStine", "romStrride", "romStr", "chromRestide", "chromStide", "chromStrine", "romStrine", "chromstride", "chromSTride", "chromRestride", "chromStrip", "romStrlen", "chromstide", "chromstlen", "chromSTlen", "romStrrip", "romStlen", "chromRestrip", "chromStlen"], "dstStride": ["destStrip", "dstRestrip", "dndStr", "dstStrride", "dstRestr", "dstChr", "dstChride", "dndStide", "destStrr", "dstStrip", "dststide", "destStrride", "dndStrrip", "dstChrip", "destStr", "dststride", "destStride", "dstStr", "dndStride", "dstRestride", "dstStrrip", "dststrip", "destStide", "dndStrr", "dstChide", "dstRestide", "dststr", "destStrrip", "dstStide", "dndStrride", "dndStrip", "dstStrr"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n\n                                GAChannelMethod method, int fd)\n\n{\n\n    int ret;\n\n    c->method = method;\n\n\n\n    switch (c->method) {\n\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NONBLOCK\n\n#ifndef CONFIG_SOLARIS\n\n                           | O_ASYNC\n\n#endif\n\n                           );\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n#ifdef CONFIG_SOLARIS\n\n        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n\n        if (ret == -1) {\n\n            g_critical(\"error setting event mask for channel: %s\",\n\n                       strerror(errno));\n\n            close(fd);\n\n            return false;\n\n        }\n\n#endif\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_ISA_SERIAL: {\n\n        struct termios tio;\n\n\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n        tcgetattr(fd, &tio);\n\n        /* set up serial port for non-canonical, dumb byte streaming */\n\n        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n\n                         IMAXBEL);\n\n        tio.c_oflag = 0;\n\n        tio.c_lflag = 0;\n\n        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n\n        /* 1 available byte min or reads will block (we'll set non-blocking\n\n         * elsewhere, else we have to deal with read()=0 instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2265, "substitutes": {"c": ["s", "n", "cr", "this", "form", "rc", "self", "mc", "can", "b", "ct", "lc", "com", "cur", "d", "r", "cache", "p", "anc", "gc", "cc", "cp", "ec", "l", "cf", "v", "e", "dc", "co", "cm", "g", "fc", "sc", "cam", "ctx", "o", "ac", "code", "C", "ce", "t", "ci", "cont", "abc", "content", "cv", "cl", "h", "f", "cs", "ch", "cd", "config", "m", "con"], "path": ["Path", "eth", "rc", "bin", "self", "entry", "th", "d", "w", "pt", "r", "p", "mount", "local", "route", "prefix", "context", "template", "ex", "kind", "pattern", "format", "file", "name", "key", "host", "full", "loc", "dir", "ref", "txt", "wd", "ath", "root", "join", "ATH", "pkg", "cmd", "chain", "config", "password", "m", "PATH", "directory", "prop"], "method": ["service", "access", "via", "property", "attr", "time", "magic", "use", "md", "sign", "man", "mask", "tr", "func", "th", "status", "mod", "channel", "type", "prop", "mem", "nom", "function", "command", "message", "format", "direction", "member", "name", "port", "source", "mid", "Method", "METHOD", "hod", "go", "set", "code", "key", "manager", "process", "master", "op", "class", "sm", "med", "tm", "call", "module", "package", "id", "version", "action", "month", "level", "m", "mode", "instance", "sort"], "fd": ["dn", "ff", "erd", "td", "FH", "stream", "ind", "std", "cf", "bf", "FD", "port", "draw", "handle", "fs", "ds", "dt", "fee", "tif", "ptr", "writer", "fed", "wind", "id", "lf", "fm", "gz", "gd", "uf", "ud", "lc", "fa", "hd", "buf", "dc", "fi", "dd", "file", "dial", "cb", "ld", "dat", "fn", "wd", "ln", "dra", "ctl", "fb", "fr", " df", "dl", "sd", " ff", "ctx", "df", "fl", "dir", "disk", "dr", "form", "func", "nd", "d", " dst", "fp", "fun", "socket", "fc", "fin", "handler", "end", "unc", "bd", "f", " fid", "wait", "cd", "pid", "db"], "ret": ["rets", "verified", "nt", "re", "tr", "lit", "ured", "ll", "grain", "std", "pas", "rm", "success", "resp", "Ret", "val", "bool", "net", "failed", "ert", "status", "alt", "def", "ft", "gt", "ter", "nil", "num", "true", "sat", "backed", "cont", "mt", "nat", "fail", "desc", "j", "get", "Return", "entry", "try", " Ret", "out", "valid", "secure", "rt", "elt", "reg", "lt", "RET", "proxy", "result", "rem", "locked", "flag", "nl", "det", "final", "vet", "func", "rect", "fun", "fin", "reset", "url", "res", "t", "cert", "ref", " RET", "f", "red", "print", "got", "back"], "tio": ["tsao", "vtio", "tii", "ftii", "tempiao", "nao", "mintio", " tiao", "tempiot", "Tiot", "tios", "nia", "otiao", " tii", "tif", "Tiop", " tiot", "tIO", " tao", "vtiao", "mintiol", "vtIO", "wtios", "wtiol", "wtio", " tIO", " tios", "tsia", "vtii", "nio", "ftIO", "wtiao", "ertio", "cio", "tiop", "nios", "niol", "Tao", "cios", "niop", "tiot", " tia", "Tio", "TIO", "nIO", "ciop", "nif", "tsios", " tiol", "mintiot", "otio", "mintao", "wtif", "qtia", "otiol", "qtiao", "vtao", "tempio", "ertao", "tso", "cIO", "Tia", "tiao", "Tios", "tempao", "otIO", "ftia", "tsio", "vtia", " tso", "Tso", "tempia", "ftio", "qtiot", "nso", "ertiol", "qtio", "tao", "ertiot", "tia", " tif", "Tiol", "tiol", "wtIO"]}}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 2280, "substitutes": {"f": ["lf", "fm", "of", "fb", "ff", "fr", "q", "ef", "uf", "b", "c", "d", "w", "fo", "fx", "l", "fp", "cf", "rf", "v", "out", "e", "fi", "bf", "xf", "ft", "fc", "g", "file", "conf", "af", "df", "ac", "fs", "fn", "t", "fd", "sf", "tf", "h", "y", "fw", "z", "F", "o", "fac"], "block": ["bridge", "null", "hash", "record", "man", "an", "length", "r", "cache", "blocking", "loop", "header", "scope", "un", "part", "object", "module", "cl", "address", "range", "id", "bl", "empty", "blank", "batch", "status", "bus", "map", "buf", "row", "prefix", "def", "list", "file", "group", "BL", "book", "piece", "index", "no", "pack", "holder", "version", "chain", "buffer", "config", "line", "box", "tag", "blocks", "point", "response", "start", "frame", "channel", "condition", "ip", "mm", "out", "number", "field", "name", "OCK", "set", "position", "full", "state", "node", "join", "base", "instance", "view", "relation", "mask", "b", "volume", "byte", "commit", "comment", "model", "type", "check", "word", "offset", "bc", "image", "Block", "network", "shift", "link", "profile", "load", "lock", "snap", "mb", "raw", "um", "none", "label", "event", "bo"], "mr": ["fm", "mer", "cr", "lr", "rar", "wm", "mc", "hm", "tr", "vr", "rb", "kr", "rg", "r", "pr", "drm", "rl", "mp", "pc", "fp", "asm", "mm", "hr", "mk", "ur", "gr", "rm", "bm", "cm", "ocr", "ms", "Mr", "mn", "MR", "rr", "rn", "mid", "adr", "br", "sr", "rs", "usr", "tm", "shr", "mt", "dr", "mb", "ml", "gm", "m", "mx"], "p": ["s", "n", "bp", "tp", "press", "np", "q", "point", "art", "page", "b", "c", "pb", "P", "d", "pt", "r", "pr", "cp", "ps", "pointer", "pad", "i", "pc", "fp", "ip", "l", "v", "ap", "pi", "ping", "jp", "par", "pp", "lp", "pe", "part", "t", "vp", "ptr", "pkg", "pid", "wp", "sp", "m", "j", "pos", "pa"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2297, "substitutes": {"pkt": ["tpct", " pnt", "pconn", "preconn", "npkt", " packet", " pct", "prokt", "tpacket", "pet", "preacket", "fct", "yct", "produ", "Pct", "fkt", "cnt", "packet", "ppck", " pck", "prent", "pct", "pck", "npacket", "fconn", "yacket", "Pnt", "pact", "repacket", "repct", "Packet", "ppacket", "ppet", "ctx", "proact", "proacket", "ptx", "cacket", "prekt", "Pet", "Pck", "ppkt", "ppconn", "repkt", "pnt", "pdu", "Pkt", "Pconn", "tpwk", "facket", "ckt", " pact", "npact", " pwk", " pdu", "npdu", "ynt", "tpkt", " ptx", "ykt", " pet", "repwk", "ppnt", "pwk", " pconn", "Ptx"], "pa": ["opa", "ba", "bp", "ra", "ara", "pet", "ka", "na", "ca", "ppa", "ada", "ia", "mi", "ha", "pr", "p", "pan", "la", "ps", "pc", "ai", "ap", "eta", "pi", "pai", "pol", "lp", "ma", "ta", "pe", "pu", "apa", "ica", "ea", "PA", "Pa", "sa", "va", "po"], "len": ["lf", "n", "count", "lon", "el", "nl", "str", "cap", "wid", "li", "length", " length", "et", "cmp", "nt", "ls", "hl", "pos", "lim", "kl", " clen", "p", "pad", "ll", "lic", "l", "mem", "fp", "L", "gt", "list", " l", " le", "elt", "lt", "num", "pp", "en", "fin", "lp", "al", "Len", "all", "coll", "resp", "t", "pl", "vec", "size", "enc", "h", "pre", "ln", "sp", "padding", "wl", "lan", "compl"], "ventry": ["vestdry", " venty", "therry", "empty", "rentry", "identery", "anty", "identy", "venty", "vestri", "gentary", "victy", "questried", "therant", "genty", "virtant", "questery", " ventri", "ventre", "antry", "questry", "ventdry", " venttry", "ventery", "questy", "emptre", "identried", "thertry", "renttry", "ventried", " ventity", "gentried", "therery", "rentRY", " ventRY", "antric", "victry", "rentity", "montdry", "vestry", " ventdry", " ventary", "virtry", "ventant", "gentric", "montry", "virtery", " ventried", "vestried", "victried", "gentRY", "montried", "montri", "rentre", " ventre", "gentant", "virttry", "venttry", "emptry", "rentary", "ventRY", "ventity", "emptity", "identry", "ventri", "genttry", "gentery", "ventric", "victric", "ventary", "renty", "gentry", "antried"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *buf1, const uint16_t *ubuf0,\n\n                     const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                     const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                     const uint16_t *abuf1, uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target)\n\n{\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n\n\n        output_pixels(i * 4, Y1, U, Y2, V);\n\n    }\n\n}\n", "idx": 2298, "substitutes": {"i": ["phi", "iu", "I", "oi", "bi", "cli", "this", "li", "q", "ui", "batch", "item", "c", "di", "gi", "status", "by", "ii", "m", "mi", "im", "ki", "uri", "ia", "p", "ji", "\u0438", "l", "ip", "ind", "is", "ai", "ei", "ij", "x", "u", "pi", "in", "ini", "info", "zi", "g", "ic", "me", "qi", "xi", "my", "name", "ami", "key", " ii", "it", "si", "go", "a", "ix", "ci", "t", "index", "multi", "y", "span", "id", "ti", "sim", "chain", "ri", "o", "j", "io"]}}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,\n\n                                              int linesize,\n\n                                              int block_w, int block_h,\n\n                                              int src_x, int src_y,\n\n                                              int w, int h,\n\n                                              emu_edge_core_func *core_fn)\n\n{\n\n    int start_y, start_x, end_y, end_x, src_y_add = 0;\n\n\n\n    if (src_y >= h) {\n\n        src_y_add = h - 1 - src_y;\n\n        src_y     = h - 1;\n\n    } else if (src_y <= -block_h) {\n\n        src_y_add = 1 - block_h - src_y;\n\n        src_y     = 1 - block_h;\n\n    }\n\n    if (src_x >= w) {\n\n        src   += w - 1 - src_x;\n\n        src_x  = w - 1;\n\n    } else if (src_x <= -block_w) {\n\n        src   += 1 - block_w - src_x;\n\n        src_x  = 1 - block_w;\n\n    }\n\n\n\n    start_y = FFMAX(0, -src_y);\n\n    start_x = FFMAX(0, -src_x);\n\n    end_y   = FFMIN(block_h, h-src_y);\n\n    end_x   = FFMIN(block_w, w-src_x);\n\n    av_assert2(start_x < end_x && block_w > 0);\n\n    av_assert2(start_y < end_y && block_h > 0);\n\n\n\n    // fill in the to-be-copied part plus all above/below\n\n    src += (src_y_add + start_y) * linesize + start_x;\n\n    buf += start_x;\n\n    core_fn(buf, src, linesize, start_y, end_y,\n\n            block_h, start_x, end_x, block_w);\n\n}\n", "idx": 2300, "substitutes": {"buf": ["db", "bl", "rc", "seq", "ff", "bin", "batch", "uf", "bg", "b", "rb", "cur", "at", "block", "dest", "Buff", "bh", "cache", "map", "bn", "cp", "img", "mem", "fp", "out", "v", "bc", "queue", "port", "ctx", "cam", "coord", "br", "copy", "end", "cb", "addr", "loc", "vec", "ref", "cv", "Buffer", "pack", "ptr", "tmp", "buffer", "ctr", "buff", "pos", "alloc"], "src": ["s", "inst", "inner", "supp", "proc", "input", "bs", "rc", "bin", "bg", "b", "rb", "rol", "cur", "sn", "dest", "comp", "r", "syn", "rest", "stream", "iv", "img", "send", "buff", "sys", "stat", "ur", "sup", "sync", "st", "rt", "sc", "source", "conv", "url", "addr", "cb", "sr", "loc", "sur", "rs", "cont", "sb", "usr", "ins", "filename", "txt", "ptr", "sl", "pkg", "raw", "sq", "desc", "ser", "ctr", "sub", "buffer", "scan", "urg", "sort"], "linesize": ["pagespace", "linesization", "linesizer", "linespace", " linesized", " linesIZE", "elinesize", "pointsizer", "elinesized", "linesIZE", "filesize", "pagesize", "filespace", " linesization", "linesized", "pointsization", "pagesization", "filesized", "pointspace", " linesiz", "inesiz", "inesized", "pointsize", "inesize", "elinesiz", " linesizer", " linespace", "elinesIZE", "filesIZE", "pagesizer", "linesiz", "inespace", "inesIZE"], "block_w": ["chain_iw", "chain_wp", " block_W", " block_wh", "blockletW", "lock_width", " block_width", "blockletsw", "Block_w", "Block_wh", "block_wh", "block08h", "block_width", " block_sw", "block_sw", "blockletwe", "block_wp", "block_W", "lock_W", "block08w", "block_iw", "lock_h", " block_wx", "chain_w", "Block_W", "block08wp", "lock_w", "block_we", " block_we", "block08iw", "chain_h", "blockletw", "block_wx"], "block_h": ["block20oh", "Block_h", "Block_he", "block00h", "blocklethr", "block20he", "block5h", "device00y", " block_wh", "block_hr", "block_x", "block5y", "block20h", "block00rh", "Block_w", "bl4h", "chain_host", "block00history", "block_wh", "bl_y", " block_bh", " block_rh", "device_history", "Block_oh", "block4hi", "block_rh", "block20w", "bl_h", "device_h", "bl4y", "bl4hi", "block4h", "block5rh", "block_html", "block_he", "blocklethtml", "block48bh", "Block_html", "blockdbhtml", "Block_hr", "block4y", "bl_hi", "chain_w", "device00rh", "block_history", "block_hi", "bl_w", "chain_x", "blockdbh", "device_y", "blockleth", " block_hi", "blockdbhr", "block48w", "block48rh", "block48h", "device_rh", "block00y", "block_host", "device00h", "block5history", "block_y", "chain_h", "blockletw", "block_bh", "blockdbw", "bl4w", "device00history", "block4w", "block_oh"], "src_x": ["src__w", "src_tx", "src09xx", " src__xi", "rc_y", "sys_x", "rc_j", "rc_xi", "srcjxt", "rc_rx", "srcityw", "rc_xt", "src_xp", "rc_width", "sys_xs", "src_w", "source_x", "source_y", "rc_x", "sys_w", "src09x", "src__xi", " src_xp", "src_xs", "src_z", "start__w", "src09ex", "src09rx", "srcjwidth", "src_xi", " src_xi", "rc_ex", " src__xp", "srcabley", "source_z", "src_ex", "src_xt", "src_rx", "src_ix", "rc_xx", "src_width", "src__x", "src__xp", "srcityy", "start__y", "src_j", "src_column", "srcityx", "source_column", "src__xf", " src__y", "srcjix", "src__ex", "srcablex", "start__x", " src__x", "start_ex", "start__ex", "source_ex", "rc_w", "src00x", "sys_y", "src00xi", "srcjx", "srcabletx", "rc_tx", "srcityxs", "src__y", "source_xf", "src_xf", "src00y", "src_xx", "rc_ix", "srcablej", "src__z", "src00xp", "start_w"], "src_y": ["srcamex", " src_ye", "seedamemy", "srcptyn", "src___yy", "src__h", "src_yy", "start_ye", "src_by", "rc_y", "src___ch", "start_by", "src08y", "srcableyy", "src_ty", "src_ey", "src___hot", "rc_iy", "src__ey", "rc_ch", "seedamey", "src_h", "feat_y", "src_content", "rc_x", "srcamety", "src_yr", "seq_yy", "lit_y", "src_ry", "src_yn", "src_ye", "seq_y", "src___ly", "src08ey", "feat08y", "start_ey", "feat08ey", "src___ry", "srcabley", "srcjh", "src08yl", " src_ry", " src_hot", "src___y", "feat_yl", "srcamey", "src_ly", "src08yt", "lit_yn", "srcamemy", " src_content", "start__ey", "src___iy", "lit_h", "start__y", " src_yy", "src_ch", "seed_y", "feat_yn", "src08yn", "srcpty", "seedamex", "src___by", "srcptyr", "seed_x", "seq_yt", "src_iy", "lit_yr", "src08name", "src_my", "src_name", "src_hot", "src___ye", "start_h", "srcpth", "seed_ty", "seq_name", "src_yt", "feat08yn", "src__y", "start__h", "srcablery", "srcjey", "seedamety", "feat_ey", "seed_my", "src_yl", "src___x", "start_ly", "src08yy", "srcablehot", "feat08yl", "srcjy"], "w": ["wa", "wk", "nw", "wx", "n", "W", "ew", "wr", "tw", "wn", "r", "p", "rw", "wb", "ww", "wh", "l", "word", "window", "wal", "v", "mm", "x", "kw", "g", "iw", "ow", "wi", "win", "wcs", "wd", "sw", "fw", "hw", "raw", "aw", "wp", "weight", "rew", "wl", "m", "wt"], "h": ["ish", "k", "ph", "ht", "n", "hi", "high", "hash", "q", "hm", "b", "c", "ih", "gh", "hl", "th", "hh", "ha", "he", "bh", "height", "p", "rh", "head", "r", "hd", "l", "window", "v", "sh", "H", "hei", "x", "g", "hal", "ho", "history", "o", "host", "kh", "oh", "hub", "zh", "resh", "hz", "y", "z", "hs", "ch", "m", "ah"], "core_fn": ["core_fm", "core___fm", "core_fc", " core_unc", " core_fc", "core___unc", "core___fn", "core_func", "core___func", " core_func", " core_fm", "core_unc"], "start_y": ["start___y", "starting_yy", "start_ye", "startpyy", " start_yy", "start_Y", " start_ys", "startpyym", "start___ye", "startFY", "it_ym", "end_ny", "startxym", "itxym", "startpysy", "start_ny", "start_ym", "startxsy", "startFy", "start___yy", "start___x", "itxsy", "startFny", "end_ye", "start_ys", "starting_y", "start__y", "start__ys", "start_yy", "itxy", "it_Y", "starting_x", "end_Y", "start__x", "startpyY", "it_sy", "end_vy", "startFx", "start_vy", "starting_ry", "start_ry", "startxY", "start___ys", "start___vy", "itxY", "it_y", "start_sy", "start___Y", "start__yy", "startxy"], "start_x": ["start___y", "start_lex", "startpyxt", "start_ix", "startpyy", " start_ix", "start_xt", "startxex", "begin_lex", "begin_X", "startpylat", "end_xi", "entry_xt", "start___x", "entrypyy", "start_ox", "end_xy", "startxxi", "start___xt", "start_xy", "end_X", "startpyx", "begin_x", "entry_y", "start_xp", "entry_x", "start_ex", "end_xp", "begin_ix", "start_X", "entrypyx", "entrypylat", " start_ox", "start_xi", "end_ex", "start___lat", "start_lat", "startxx", "entrypyxt", "startxy", "entry_lat"], "end_y": ["endTey", "endJx", "end_ny", "ended_y", "endjy", "endjx", "start_ry", "endTy", "ended_Y", "endjry", "start_yy", "end___x", "end_yy", "end___ry", "endJy", "endTny", "end___y", "end_ch", "end_ya", "end___ch", "end_Y", "ended_ey", "endJya", "end_ey", "endjch", "start_Y", "endJyy", "ended_ny", "endTY", "start_ya", "end_ry", "start_ch"], "end_x": ["endxex", "END_x", "end_ox", "end___x", "END_y", "end_xi", " end_ex", "endxxp", "endxxi", "end_w", " end_ax", "END_ox", " end_ox", "END_X", "end___X", "end_ax", "endxx", "end_X", " end_w", "start_xp", "start_ex", "end_xp", "end___y", "start_xi", "end_ex", "end___ox"]}}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2325, "substitutes": {"c": ["n", "cr", "rc", "mc", "b", "ct", "lc", "com", "ca", "cur", "d", "cu", "w", "cache", "p", "anc", "gc", "cp", "cc", "ec", "pc", "cf", "v", "cal", "e", "bc", "dc", "co", "cm", "cn", "fc", "conf", "nc", "ctx", "cam", "ac", "coll", "C", "ce", "t", "ci", "cont", "abc", "enc", "etc", "cv", "tc", "h", "cl", "call", "cs", "vc", "cd", "ch", "m", "con"], "bw": [" bwd", "bld", "mw", " bW", "bgew", "bbsw", " bsw", " bld", "bbwd", " bwin", "bgw", "bwin", "bbkw", "bgwin", "bbW", "hew", "bwd", "hwin", "bgwe", "bbld", "btsw", "bbw", "bsw", "mW", "btld", "bkw", " bkw", "bew", "btW", " bwe", " bew", "hwe", "bW", "hw", "bwe", "mkw", "mwd", "btw"], "bh": ["phi", "bt", "ht", "bp", "bi", "hi", "bl", "bs", "sbm", "wid", "hang", "dh", "b", "ih", "rb", "hh", "ubb", "uh", "hr", "bang", "bc", "bm", "bf", "bone", "oth", "bis", "br", "cb", "igh", "kh", "nb", "lb", "hub", "sb", "bb", "zh", "bj", "ths", "h", "bol", "phy", "broad", "bo", "ah"], "blocks": ["sections", "bs", "limits", "users", "chains", "bytes", "ocks", "Blocks", "lets", "boxes", "books", "block", "stores", "jobs", "builders", "modules", "lists", "devices", "styles", "cells", "rooms", "views", "heads", "groups", "bc", "units", "bm", "elines", "lines", "classes", "levels", "outs", "workers", "checks", "headers", "aps", "ashes", "faces", "types", "times", "bits", "bys", "ins", "rows", "weights", "maps", "frames", "plugins", "locks", "pages", "flows", "ubis", "actions"], "i": ["n", "oi", "iter", "yi", "iri", "uri", "mi", "ind", " I", "is", "v", "ai", "ij", "ei", "ic", "it", "si", "y", "id", "ti", "phi", "iu", "bi", "init", "q", "ui", "batch", "di", "status", "x", "fi", "ini", "list", "zi", "ims", "xi", " ti", "ami", " ii", "index", "multi", "sim", "ri", "j", "I", "asi", "im", "ki", "p", " bi", "ip", "info", "name", "ms", "key", "ix", "ci", "us", "gi", "m", "s", "li", " j", "ii", "ji", "\u0438", "pi", "in", "g", "me", "qi", "source", "gu", "t", "f", "ski", "print"]}}
{"project": "qemu", "commit_id": "cf29a570a7aa7abab66bf256fdf9540873590811", "target": 1, "func": "static void quorum_vote(QuorumAIOCB *acb)\n\n{\n\n    bool quorum = true;\n\n    int i, j, ret;\n\n    QuorumVoteValue hash;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    QuorumVoteVersion *winner;\n\n\n\n    if (quorum_has_too_much_io_failed(acb)) {\n\n        return;\n\n    }\n\n\n\n    /* get the index of the first successful read */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n", "idx": 2328, "substitutes": {"acb": ["acbb", "aclbe", "aconbc", "sacgb", "sacdb", "accB", "pacrb", "aclf", "acd", "accnb", "racnb", "acong", "aconbb", "sacrb", "facb", "pacbc", " acwb", "ancbb", "sacmb", "acp", "macsb", "aconbd", "accg", "Acbb", "macnb", "actmb", "pacr", "sacb", "actb", "ancba", "acbr", "Acdb", "pacbe", "actbe", "aconr", "aclp", "aconrb", "sacbr", "accwb", "aclg", "actB", "aconf", "racsb", "pacba", "acongb", "acmb", "racrb", "accbb", "accw", "acr", "ancrb", "aclwb", "ancp", " acf", "acw", "Acp", "acsb", "acsnb", "accsb", "pacnb", "aicba", "sacB", "Acbd", "icrb", "racbd", "acssb", "accbd", " acp", "acf", "sacbe", "acba", "acB", "acbo", " acsb", "sacsb", "aclb", "acbd", "ancr", "accbr", "Acbe", "sacp", "acdb", "facsb", " acd", "facw", "abrb", "abb", "aconbar", "pacsb", "pacbar", "sacnb", "ancdb", " cacbc", "Acb", "accrb", "sacba", "aicsb", "racp", "acgb", "abw", "sacbd", " acr", "aclB", "macba", "abbo", " cacba", "Acsb", "acrb", "acbc", "macb", "acwb", "actbd", "acg", "accb", "icbe", "Acgb", "acsw", "aconwb", "acnb", "ancb", " acw", "accbe", "accmb", " cacb", "accba", "sacbb", "aconsb", "actp", "aconbe", " acbo", "facnb", "aicnb", "pacp", "accr", "aicb", "aconb", "aconba", "acond", "abdb", "aclbb", "acbar", "acbe", "icb", "aclbr", "pacbb", "aclr", "pacb", "icdb", "aclsb", "abbe", "aconp", "Acba", "acondb", " acrb", "racb", "sacwb", " cacbar", "accp", "accbo", "sacd", "pacdb", "accf"], "i": ["n", "oi", "iter", "uri", "mi", "ind", " I", "is", "ai", "v", "ij", "ei", "ic", "it", "si", "ie", "il", "y", "h", "id", "ti", "io", "phi", "ish", "iu", "hi", "bi", "init", "q", "ui", "di", "ir", "_", "x", "ori", "fi", "ini", "zi", "ims", "ik", "xi", "ami", "iq", "index", "multi", "z", "chain", "sim", "ri", "I", "this", "point", "start", "im", "try", "ki", "p", "l", "ip", "info", "name", "my", "ix", "ci", "us", "dr", "gi", "m", "ex", "li", "ia", "ii", "ji", "\u0438", "pi", "in", "me", "qi", "f", "um", "o"], "j": ["k", "uj", "other", "n", "jc", "li", "fr", "q", "jump", "b", "m", "block", "oj", "try", "pr", "je", "p", "dj", "ji", "l", "ind", "ja", "v", "ij", "next", "x", "u", "jj", "jac", "jp", "g", "br", "key", "it", "jit", "kj", "to", "aj", "res", "t", "index", "bj", "obj", "y", "z", "sp", "json", "add", "jl", "js", "J", "jo", "o", "job"], "ret": ["rets", "iter", "magic", "nt", "re", "tr", "grain", "rm", "deg", "store", "success", "it", "ry", "resp", "Ret", "val", "ptr", "priv", "prop", "repl", "rep", "status", "alt", "pub", "rex", "fi", "def", "rev", "gt", "ft", "ter", "len", "cb", "mt", "fail", "desc", "virt", "ext", "rc", "nz", "quit", "arg", "ruby", " Ret", "tail", "orum", "sys", "leg", "format", "rt", "reg", "elt", "RET", "tmp", "result", "reply", "rem", "flag", "final", "vet", "trust", "rx", "git", "fun", "reset", "res", "ref", "err", "print", "got", "back"], "hash": ["Hash", "tag", "test", "str", "final", "query", "cmp", "temp", "status", "ash", "output", "html", "rh", "sum", "tv", "out", "sh", "header", " remainder", "inv", "chip", "rev", "result", "best", "name", "buster", "shift", " hashing", "conn", "key", "success", "value", "addr", "total", "res", "tar", "state", "node", "ref", "hz", "alias", "shr", "h", "tree", "sha", "json", "tx", "id", "version", "mac", "password", "vol", "data", "ssh", "prop"], "s": ["n", "stats", "iss", "bs", "qs", "self", "ses", "es", "b", "ls", "sets", "states", "p", "ts", "its", "ps", "south", "gs", "v", "is", "sys", "ops", "less", "parts", "ss", "g", "ims", "orders", "ms", "sv", "os", "bis", "fs", "ds", "set", "settings", "a", "sts", "ats", "params", "er", "rs", "ns", "t", "as", "args", "sb", "S", "bits", "state", "h", "sw", "sl", "sq", "hs", "details", "js", "aws"], "winner": ["vector", "fresh", "above", "uno", "rank", "vote", "player", "v", "next", "ranking", "member", "history", "origin", "success", "value", "ldon", "role", "writer", "loss", "inner", "leader", "init", "wire", "won", "native", "worker", "rev", "runner", "vs", "master", "clus", "vp", "soc", "student", "Winner", "version", "vol", "initialized", "better", "latest", "outer", " winners", "von", "nie", "valid", "riot", "strength", "vette", "best", "win", "maker", "winning", "generation", "node", "root", "sett", "upper", "result", "resolution", "browser", "thanks", "volume", "hero", "stone", "wrapper", "timeout", "gain", "nov", "res", "vo", "zero", "ner", " veteran", "players", "mate", "killer", "news", "owner", " winning", "game"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    DeviceState *gpio_dev[7];\n\n    qemu_irq gpio_in[7][8];\n\n    qemu_irq gpio_out[7][8];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    I2CBus *i2c;\n\n    DeviceState *dev;\n\n    int i;\n\n    int j;\n\n\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n\n\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(system_memory, 0, flash);\n\n\n\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n\n\n\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n\n                      kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n\n        adc = qdev_get_gpio_in(dev, 0);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n\n                                       0x40030000 + i * 0x1000,\n\n                                       pic[timer_irq[i]]);\n\n            /* TODO: This is incorrect, but we get away with it because\n\n               the ADC output is only ever pulsed.  */\n\n            qdev_connect_gpio_out(dev, 0, adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n\n                                               pic[gpio_irq[i]]);\n\n            for (j = 0; j < 8; j++) {\n\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n\n                gpio_out[i][j] = NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n\n                                 pic[uart_irq[i]]);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void *bus;\n\n            DeviceState *sddev;\n\n            DeviceState *ssddev;\n\n\n\n            /* Some boards have both an OLED controller and SD card connected to\n\n             * the same SSI port, with the SD card chip select connected to a\n\n             * GPIO pin.  Technically the OLED chip select is connected to the\n\n             * SSI Fss pin.  We do not bother emulating that as both devices\n\n             * should never be selected simultaneously, and our OLED controller\n\n             * ignores stray 0xff commands that occur when deselecting the SD\n\n             * card.\n\n             */\n\n            bus = qdev_get_child_bus(dev, \"ssi\");\n\n\n\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n\n\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2329, "substitutes": {"kernel_filename": [" kernel_file", "kernelamefilename", "kernel_title", "kernelamefile", "kernelametitle", "kernel_file", "ernel_fn", " kernel_fn", " kernel_title", "ernel_filename", "kernelamefn", "ernel_model", "kernel_model", "ernel_file", "kernel_fn"], "cpu_model": ["cpu2description", "bootetymode", "boot_fine", "cpuetyModel", "cpu2models", "boot_Model", "cpu_Model", "cpuermodel", "cpuermodels", "cpuercontroller", "gpu_controller", "gpu_model", "cpuetymode", "cpuetymodel", "bootetyfine", "cpu_description", "gpu_description", "cpuerdescription", "boot_model", "cpu_fine", "cpu2controller", "cpu2model", "bootetyModel", "cpu_controller", "gpu_models", "boot_mode", "cpuetyfine", "cpu_models", "cpu_mode", "bootetymodel"], "board": ["back", "bug", "ack", "core", "fish", "BO", "style", "deck", "block", "frame", "boards", "control", "controller", "reader", "player", "check", "Board", "stream", "bolt", "loop", "window", "row", "bar", "ward", "bang", "ck", "bc", "body", "program", "image", "list", "runner", "bit", "flow", "sequence", "bro", "estro", "lock", "bank", "table", "disk", "boarding", "bd", "buffer", "bo", "boot", "box", "ro"], "uart_irq": ["uart_irqs", "uart__prqs", "uart_mrq", "uart__prqi", "uart_pirqi", "uart__irqi", "uart__prq", "uart_prq", "uart__irqs", "uart_pirQ", "uart_prqi", "uart_prQ", "uart_prqs", "uart__irQ", "uart_mrQ", "uart_mrqi", "uart_pirq", "uart_irqi", "uart_mrqs", "uart_pirqs", "uart_irQ", "uart__prQ", "uart__irq"], "timer_irq": ["timer_hrql", "timer_irque", "timer_rql", "timer_irqs", "timer_rqs", "timer_pirque", "timer_hrqs", "timer_rq", "timer_hrq", "timer_rque", "timer_hrque", "timer_irql", "timer_pirqs", "timer_pirql", "timer_pirq"], "gpio_addr": ["gpio__cmd", "gpio_res", "gpios_address", "gpio__addr", "gpio_cmd", "gpios_addr", "gpio_address", "gpio__res", "gpio__address", "gpios_cmd", "gpios_res"], "gpio_irq": ["gpio2irq", "gpio_irqs", "gpio_lrqs", "gpio_drqs", "gpio2irqq", "gpio_irQ", "gpio_drqq", "gpio_irqq", "gpio_lrqq", "gpio_drQ", "gpio2pirqs", "gpio_lrQ", "gpio2pirq", "gpio2pirQ", "gpio_pirq", "gpio_drq", "gpio2pirqq", "gpio_lrq", "gpio2irQ", "gpio_pirQ", "gpio_pirqs", "gpio_pirqq", "gpio2irqs"], "pic": ["lib", "spin", "pict", "li", "php", "ics", "peg", "script", "Picture", "pb", "pr", "syn", "gc", "p", "py", "pc", "pi", "fi", "sync", "picture", "jp", "fc", "ic", "sc", "cam", "pin", "pol", "ric", "fn", "pl", "arc", "ican", "eric", "sp", "Pic", "icc", "nic", "photo", "pa"], "gpio_dev": ["gpio2device", "gpios2addr", "gpios2device", "gpio__mem", "gpio2addr", "gpio__addr", "gpios_addr", "gpio2dev", "gpios2dev", "gpio2mem", "gpios2mem", "gpio__dev", "gpio__device", "gpios_device", "gpios_mem", "gpios_dev", "gpio_device", "gpio_mem"], "gpio_in": ["gpios_input", "gpios_in", "gpios_out", "gpio_din", "gpios_din", "gpio_input"], "gpio_out": ["gpios_in", "gpio__co", "gpio__in", "gpios_output", "gpio__output", "gpio__out", "gpios_co", "gpio_output", "gpios_out", "gpio_co"], "adc": ["adec", "adcs", "radcs", "ardcs", "radci", "ardci", "adf", "adef", "adeci", "radf", "ardc", "adecs", "radc", "ardf", "adci"], "sram_size": ["sram8capacity", "sram_scale", "sream_size", "sram8size", "sream2storage", "sgram8Size", "sgram_size", "sram2length", "sram2code", "sream_code", "samp_len", "sram_capacity", "sream2SIZE", "sream2code", "sram2size", "sgram8capacity", "samp_size", "sram2SIZE", "sram_storage", "sream_storage", "sgram_scale", "samp_length", "sram8Size", "sram2storage", "sgram_capacity", "sram8scale", "sram_len", "sram_Size", "sgram8size", "sream2size", "sram_SIZE", "sram2len", "sgram_Size", "sgram8scale", "sram_length", "sram_code", "sream_SIZE"], "flash_size": ["flash_index", " flash_Size", "flash_SIZE", "flash67Size", " flash_group", " flash_global", "flash_data", "flash67index", " flash_data", " flash_scale", "flash_global", "flash67group", "flashlexSIZE", " flash_SIZE", "flash_scale", "flash67size", "flashlexindex", "flash_group", "flashlexsize", " flash_index", "flash67data", "flash67SIZE", "flash_Size", "flashlexgroup"], "i2c": [" i2cs", " i2ca", "i1ca", " i2b", "i2cs", " i1cs", " i1b", "i4cs", "i4b", "i4c", "i2b", " i1ca", "i1b", "i3b", "i3c", "i3ca", "i2ca", " i1c", "i1cs", "i3cs", "i4ca", "i1c"], "dev": ["dem", "sd", "mem", "dc", "def", "fin", "cam", "loc", "res", "Dev", "val", "tech", "serv", "device", "disk", "sw", "des", "vision", "pri", "cmd", "tx", "ch", "DEV", "priv", "boot", "ev"], "i": ["I", "bi", "li", "b", "c", "ia", "ii", "m", "mi", "d", "p", "l", "ip", "v", "ij", "x", "u", "pi", "fi", "ik", "it", "si", "ci", "y", "z", "f", "o"], "j": ["k", "uj", "n", "jc", "q", "jump", "b", "ii", "d", "p", "ji", "l", "out", "v", "ij", "jj", "jp", "g", "it", "aj", "lock", "obj", "y", "z", "js", "J", "pos"], "sram": ["tsram", "ssgram", "tsream", "ssron", "asgram", "aslam", "sron", "rsiam", "rsram", "tslam", "tsrom", "siam", "Slam", "psrom", "psgram", "sream", "asrom", "Sram", " sron", " siam", "psream", " slam", "Sron", "rsrom", " sream", " srom", "rsgram", "psram", "sslam", "asram", " sgram", "sgram", "srom", "slam", "Sgram", "ssram", "tsgram"], "flash": ["soft", "bridge", "silver", "form", "pool", "high", "ff", "fr", "normal", "fish", "browser", "shock", "boot", "wave", "jump", "error", "Flash", "bolt", "sharp", "fps", "hero", "local", "scroll", "loop", "roll", "low", "gif", "video", "sc", "fire", "cam", "flow", "trans", "fl", "fast", "foreign", "zero", "ref", "fly", "tf", "touch", "sw", "snap", "ram", "raw", "roller", "broad", "global", "hard", "small", "buffer", "buff", "vol", "fine", "io"], "system_memory": ["system_library", "sys_management", "system2storage", "systemlystorage", "system_storage", " system_library", "system2meta", "system_mem", "system2memory", "system_region", "sys_meta", " system_mem", "sys_storage", "system2mem", " system_database", "sys_region", "system_management", "systemlymemory", "sys_memory", "systemlymeta", "systemlymem", "system_database", "sys_mem", "system_meta"]}}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}", "idx": 2334, "substitutes": {"env": ["db", "proc", "stack", "el", "open", "ew", "self", "engine", "cur", "entry", "export", "enter", "nv", "w", "equ", "local", "environment", "ec", "buf", "ve", "ja", "window", "v", "bar", "web", "next", "e", "context", "def", "here", "queue", "exc", "esc", "current", "ctx", "sv", "en", "conn", "code", "server", "viron", "end", "vs", "er", "process", "gear", "enc", "vp", "obj", "dev", "ent", "gate", "uv", "tmp", "pkg", "ptr", "desc", "event", "ev"], "penv": ["PenV", "primch", "primV", "venve", "pingvr", "phencil", "senve", "phenV", "pencil", "pnv", "fenq", "fenv", "pinl", "stenv", "pnch", "pnvt", "primvt", "penp", "pnq", "pencer", "pingv", "phenvt", "venv", "pncil", "Pencil", "penvin", "pnl", "pincer", " penp", "penq", " penf", "pench", "penl", "Pench", "pncer", " penvr", "pnvin", "Penvt", "stenvr", "senval", "pnV", "primv", "penf", "venvin", "venval", "penvr", "Penv", "penvt", "pnp", "penve", "penval", "stenve", "pingvt", "pnf", "stenvt", "fenp", "fenvr", "pnve", "pingve", "senv", "senvin", "pnval", "pnvr", "pinv", " pencer", " penl", "phenv", " penq", "pinf", "penV"], "cpu_index": ["cpu_column", "pu_column", "cpu_number", "pu_id", "cpu_no", "cpu__ind", "CPU_number", "cpu__path", "pu_no", "cpu_point", "cpuixdepth", "cpu_length", "cpuixoffset", "cpuixindex", "cpu_Index", "pu_depth", "cpu_depth", "pu_path", "cpu_path", "pu_count", "pu_Index", "cpu_count", "cpu__index", "pu_point", "cpuixid", "cpu_offset", "pu_length", "cpu_ind", "cpu_id", "CPU_Index", "pu_ind", "pu_offset", "CPU_index", "cpu__Index", "pu_index"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2348, "substitutes": {"ysrc": ["nssrc", "iesource", "iesr", "esrc", "sysusc", "ysr", "esusc", "nsusc", "syssrc", "esource", "iesrc", "mysrc", "iessrc", "myssrc", "sysrc", "iesusc", "nsrc", "mysusc", "essrc", "mysource", "nsr", "ysource", "sysr", "ysusc", "yssrc"], "usrc": [" usirc", " usource", "ossrc", "umsrc", "Ussrc", "usource", "umsurg", " ussrc", "Usrc", "osrc", "usesource", "usesrc", "ussrc", "Usource", "osurg", "usurg", " usurg", "usirc", "umsirc", "osirc", "usessrc", "umssrc"], "vsrc": ["vrc", "srs", "pst", "wsrc", " vrc", "pstr", "vsource", "vrs", "src", "vstr", "vst", "fstr", " vsource", "frc", "wrs", "fst", "prc", "ssource", "psrc", " vrs", "fsrc", " vstr", " vst", "wrc", "wsource", "ssrc"], "dst": ["dnd", "lrest", "dsdest", "diddest", "ddest", "didst", "vst", "didtt", " drest", "dtt", "vrest", "fdest", "ldest", "drest", "fnd", "fst", "vdest", "dsnd", "lput", "ftt", "didnd", "lst", "dput", " ddest", "dstt", " dput", "dsst", "vput"], "height": ["ht", "resolution", "count", "hi", "hang", "length", "build", "volume", "dist", "gh", "ih", "th", "html", "Height", "yt", "w", "he", "family", "wh", "density", "window", "uh", "HH", "hei", " heights", "headers", "history", "ows", "inches", "radius", "zh", "size", "rows", "hz", "stroke", "h", "y", "gravity", "depth", "shape", "ty", "gy", "dim", "cy"], "lumStride": ["lomStr", "lomStride", "lumSTrate", "lumLrid", "lumLr", "lumstride", "limStrride", "limStr", "limStrr", "lumstr", "limStrrate", "limStrate", "lomStrrid", "lumLide", "lumSTide", "lumStrate", "lumSTr", "limStide", "lumstide", "lomStrid", "lomStrr", "lumSTride", "lomStrride", "lumStrid", "lomStide", "lumStrrid", "limStride", "lumLride", "lumStrrate", "lumStrride", "lumstrate", "lumstrid", "lumStrr", "lumStide", "lumStr"], "chromStride": ["romStride", "chromStrange", "romStrange", "chromStr", "chromstr", "chromStrid", "chromSTide", "chromSlrange", "chromSpride", "chromSpide", "chromSTrange", "chromSlide", "chromstrip", "romStrr", "chromStrrip", "chromStrr", "chromStrrange", "chromSprip", "chromSTrid", "chromStrride", "chromSlrid", "romStide", "romStrid", "romStrrid", "chromSpr", "romStrip", "romStrride", "romStr", "chromStide", "chromstride", "chromStrip", "chromSTride", "romStrrange", "chromstide", "chromStrrid", "romStrrip", "chromSlride"], "dstStride": ["destStrip", "dstRestrip", "dstStno", "dndStr", "dstStrride", "dstRestr", "dndStide", "destStrr", "dstStrno", "dstStrip", "dststide", "destStrride", "destStr", "dststride", "destStride", "dstStr", "dndStno", "dstRestride", "dstStrrip", "dststrip", "destStide", "dndStride", "dndStrr", "dstRestide", "dstRestno", "dststr", "destStrrip", "dstStide", "dststno", "dndStrride", "dndStrno", "dstStrr"]}}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n", "idx": 2349, "substitutes": {"cmd": ["ext", "this", "init", "config", "md", "target", "cmp", "nt", "comm", "cfg", "ct", "c", "quit", "new", "cur", "from", "met", "head", "req", "parent", "ind", "send", "mk", "good", "bind", "command", "def", "crit", "handler", "ctx", "Cmd", "handle", "conn", "cb", "resp", "msg", "cod", "op", "report", "cont", "obj", "raw", "ctr", "ok", "urg"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int vqa_decode_init(AVCodecContext *avctx)\n\n{\n\n    VqaContext *s = (VqaContext *)avctx->priv_data;\n\n    unsigned char *vqa_header;\n\n    int i, j, codebook_index;;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    avctx->has_b_frames = 0;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the extradata made it */\n\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n\n\n\n\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n", "idx": 2358, "substitutes": {"avctx": ["avaddr", "afctx", "devctx", "avcontext", "wavcmp", "avcm", "avertx", "avtx", " avtmp", "averjac", "aftc", "aftx", "avconn", "abtx", "avtmp", "avercontext", "navtc", "navcmd", "afcontext", "ajtx", "navctx", "abconn", "aveconn", "apctx", "avercmd", "apcontext", "abcm", "avertmp", " avcm", "avertc", "abcp", "avejac", "abctx", "devtx", "abaddr", "navcmp", "wavcontext", "apcp", "apjac", " avcontext", "avtc", "abcontext", "avcmp", "avectx", "avecontext", "avcp", "ajcontext", "devconn", " avjac", "wavctx", "afcmd", "devcontext", "averctx", " avconn", "ajctx", "aptx", "abtmp", "avjac", " avtx", " avcmd", "wavaddr", "afcmp", "avercm", "avcmd", "aveaddr", "abcmp", "avecmp", "avercmp", "ajcp", "avetx", "afjac"], "s": ["n", "esm", "ants", "services", "ags", "views", "is", "ops", "parts", "ies", "store", "fs", "ds", "eps", "gets", "bits", "sb", "y", "h", "sq", "hs", "sports", "bs", "ses", "status", "ties", "ims", "sv", "os", "vs", "sts", "ats", "ids", "des", "details", "ports", "qs", "states", "p", "ps", "comments", "l", "sys", "terms", "less", "ss", "tests", "ms", "ar", "bis", "set", "full", "so", "sm", "state", "args", "rates", "sl", "mods", "m", "spec", "stats", "self", "comm", "results", "es", "b", "ls", "sets", "pers", "als", "ts", "its", "changes", "gs", "g", "ers", "se", "sc", "source", "aps", "settings", "rs", "ns", "t", "ins", "S", "sw", "ess", "cs", "js", "aws", "series"], "vqa_header": ["vga_token", "vqa1header", "viza_filter", "vga_format", "vaxy67header", "vqa67filter", "vqa1token", "vtk_header", "viza_header", "vqa___header", "vqa_player", "vga_filter", "vqa1filter", "vaxy_header", "vqa____var", "vqaptdict", "vqa_head", "vaxy67head", "vqa___part", "vga_part", "vqua_source", "vqa___var", "vqa_filter", "vqa___head", "vqa67magic", "vqaerplayer", "vqa____part", "vqa67body", "vqa_attribute", "vtk_headers", "vqa67dict", "vqua_header", "vqa_body", "vga_body", "vaxy67magic", "vqa67format", "vga_header", "vqaptbody", "vtk_format", "vqua_headers", "vqa67header", "vtk_offset", "vaxy_magic", "vqa_token", "viza_format", "vqa_headers", "vaxy_head", "vqaerformat", "vqa67attribute", "vqa_cache", "viza_attribute", "vqa____header", "vaxy_cache", "vqa67cache", "vaxy67cache", "vqua_version", "vqa_source", "vga_head", "vqa_var", "vqa_format", "vqa_magic", "vqa_offset", "vga_dict", "vqaerhead", "vga_player", "vqa67head", "vqa_version", "vqa___cache", "vqaerheader", "vqa67player", "vqa_part", "vqa1head", "vqa_dict", "vga_var", "vqaptheader", "vqa___magic"], "i": ["phi", "iy", "iu", "I", "oi", "bi", "cli", "hi", "init", " li", "li", "iter", "ui", "b", "di", "ia", "ii", "im", "mi", "m", "try", "r", "ki", "p", "ji", "\u0438", "iii", "ip", "ai", "v", "ei", "ij", "is", "x", "e", "pi", "in", "ini", "info", "zi", "g", "ic", "me", "qi", "xi", "ims", "ami", " ii", "it", "si", "ix", "er", "aci", "ci", "index", "ie", "multi", "y", "us", "dr", "f", "id", "ti", "gi", "o", "io"], "j": ["other", "uj", "n", "bi", "jc", "li", "fr", "q", "tr", "b", "jump", "c", "ii", "oj", "pt", "try", "pr", "r", "je", "p", "dj", "ji", "l", "ja", "out", "v", "ij", "jj", "jp", "g", "br", "it", "jit", "si", "kj", "ix", "aj", "rel", "bj", "ie", "obj", "y", "z", "f", "json", "err", "jl", "js", "J", "jo", "m", "job", "jas"], "codebook_index": ["codebook_ind", "codebook__key", "codebookTindex", "codebuf_index", "codebuf_seed", "codebook_interface", "codegroup_Index", "codeboard_label", "codebuf_address", "codegroup_ind", "codegroup_index", "codebook\u05bcindex", "codebook_level", "codebook_buffer", "coderecord_seed", "codebook\u05bcseed", "codeboard_key", "codebuf_instance", "codebook_instance", "codegroup_key", "coderecord_index", "codebook_offset", "codebook_seed", "coderecord_buffer", "codebook\u05bcaddress", "codebookTbuffer", "coderecord_interface", "codebook_key", "codebookTinterface", "codebook__label", "codebook\u064eseed", "codeboard_index", "codebook__index", "codebook\u05bcinstance", "codebook\u064ebuffer", "codebook\u064eindex", "codebook_label", "codegroup_level", "codegroup_offset", "codebookTseed", "codebook_Index", "codebook\u064einterface", "codebook_address"]}}
{"project": "FFmpeg", "commit_id": "25bcf24d4d0faf0191923be8afac8f67ca98b500", "target": 0, "func": "static int open_output_file(OptionsContext *o, const char *filename)\n\n{\n\n    AVFormatContext *oc;\n\n    int i, j, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputFile *of;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n    AVDictionary *unused_opts = NULL;\n\n    AVDictionaryEntry *e = NULL;\n\n\n\n    if (configure_complex_filters() < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error configuring filters.\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {\n\n        o->stop_time = INT64_MAX;\n\n        av_log(NULL, AV_LOG_WARNING, \"-t and -to cannot be used together; using -t.\\n\");\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {\n\n        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;\n\n        if (o->stop_time <= start_time) {\n\n            av_log(NULL, AV_LOG_WARNING, \"-to value smaller than -ss; ignoring -to.\\n\");\n\n            o->stop_time = INT64_MAX;\n\n        } else {\n\n            o->recording_time = o->stop_time - start_time;\n\n        }\n\n    }\n\n\n\n    GROW_ARRAY(output_files, nb_output_files);\n\n    of = av_mallocz(sizeof(*of));\n\n    if (!of)\n\n        exit_program(1);\n\n    output_files[nb_output_files - 1] = of;\n\n\n\n    of->ost_index      = nb_output_streams;\n\n    of->recording_time = o->recording_time;\n\n    of->start_time     = o->start_time;\n\n    of->limit_filesize = o->limit_filesize;\n\n    of->shortest       = o->shortest;\n\n    av_dict_copy(&of->opts, o->g->format_opts, 0);\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n\n    if (!oc) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n\n\n    of->ctx = oc;\n\n    if (o->recording_time != INT64_MAX)\n\n        oc->duration = o->recording_time;\n\n\n\n    file_oformat= oc->oformat;\n\n    oc->interrupt_callback = int_cb;\n\n\n\n    /* create streams for all unlabeled output pads */\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        FilterGraph *fg = filtergraphs[i];\n\n        for (j = 0; j < fg->nb_outputs; j++) {\n\n            OutputFilter *ofilter = fg->outputs[j];\n\n\n\n            if (!ofilter->out_tmp || ofilter->out_tmp->name)\n\n                continue;\n\n\n\n            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,\n\n                                          ofilter->out_tmp->pad_idx)) {\n\n            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;\n\n            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;\n\n            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;\n\n            }\n\n            init_output_filter(ofilter, o, oc);\n\n        }\n\n    }\n\n\n\n    /* ffserver seeking with date=... needs a date reference */\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int err = parse_option(o, \"metadata\", \"creation_time=now\", options);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") && !override_ffserver &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int j;\n\n        /* special case for files sent to ffserver: we get the stream\n\n           parameters from ffserver */\n\n        int err = read_ffserver_streams(o, oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n\n            ost = output_streams[j];\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if(ist->st->codec->codec_type == ost->st->codec->codec_type){\n\n                    ost->sync_ist= ist;\n\n                    ost->source_index= i;\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(\"anull\");\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(\"null\");\n\n                    ist->discard = 0;\n\n                    ist->st->discard = AVDISCARD_NONE;\n\n                    break;\n\n                }\n\n            }\n\n            if(!ost->sync_ist){\n\n                av_log(NULL, AV_LOG_FATAL, \"Missing %s stream which is required by this ffm\\n\", av_get_media_type_string(ost->st->codec->codec_type));\n\n                exit_program(1);\n\n            }\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        char *subtitle_codec_name = NULL;\n\n        /* pick the \"best\" stream of each type */\n\n\n\n        /* video: highest resolution */\n\n        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                int new_area;\n\n                ist = input_streams[i];\n\n                new_area = ist->st->codec->width * ist->st->codec->height;\n\n                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                    new_area = 1;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    new_area > area) {\n\n                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                        continue;\n\n                    area = new_area;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_video_stream(o, oc, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_audio_stream(o, oc, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, \"s\");\n\n        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    new_subtitle_stream(o, oc, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            if (map->linklabel) {\n\n                FilterGraph *fg;\n\n                OutputFilter *ofilter = NULL;\n\n                int j, k;\n\n\n\n                for (j = 0; j < nb_filtergraphs; j++) {\n\n                    fg = filtergraphs[j];\n\n                    for (k = 0; k < fg->nb_outputs; k++) {\n\n                        AVFilterInOut *out = fg->outputs[k]->out_tmp;\n\n                        if (out && !strcmp(out->name, map->linklabel)) {\n\n                            ofilter = fg->outputs[k];\n\n                            goto loop_end;\n\n                        }\n\n                    }\n\n                }\n\nloop_end:\n\n                if (!ofilter) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Output with label '%s' does not exist \"\n\n                           \"in any defined filter graph, or was already used elsewhere.\\n\", map->linklabel);\n\n                    exit_program(1);\n\n                }\n\n                init_output_filter(ofilter, o, oc);\n\n            } else {\n\n                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;\n\n\n\n                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];\n\n                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n\n                    continue;\n\n                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                    continue;\n\n                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n                    continue;\n\n                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)\n\n                    continue;\n\n\n\n                switch (ist->st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL, \"Cannot map stream #%d:%d - unsupported type.\\n\",\n\n                           map->file_index, map->stream_index);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle attached files */\n\n    for (i = 0; i < o->nb_attachments; i++) {\n\n        AVIOContext *pb;\n\n        uint8_t *attachment;\n\n        const char *p;\n\n        int64_t len;\n\n\n\n        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not open attachment file %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if ((len = avio_size(pb)) <= 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not get size of the attachment %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if (!(attachment = av_malloc(len))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Attachment %s too large to fit into memory.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        avio_read(pb, attachment, len);\n\n\n\n        ost = new_attachment_stream(o, oc, -1);\n\n        ost->stream_copy               = 0;\n\n        ost->attachment_filename       = o->attachments[i];\n\n        ost->finished                  = 1;\n\n        ost->st->codec->extradata      = attachment;\n\n        ost->st->codec->extradata_size = len;\n\n\n\n        p = strrchr(o->attachments[i], '/');\n\n        av_dict_set(&ost->st->metadata, \"filename\", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);\n\n        avio_close(pb);\n\n    }\n\n\n\n    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file\n\n        AVDictionaryEntry *e;\n\n        ost = output_streams[i];\n\n\n\n        if ((ost->stream_copy || ost->attachment_filename)\n\n            && (e = av_dict_get(o->g->codec_opts, \"flags\", NULL, AV_DICT_IGNORE_SUFFIX))\n\n            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n\n            if (av_opt_set(ost->st->codec, \"flags\", e->value, 0) < 0)\n\n                exit_program(1);\n\n    }\n\n\n\n    /* check if all codec options have been used */\n\n    unused_opts = strip_specifiers(o->g->codec_opts);\n\n    for (i = of->ost_index; i < nb_output_streams; i++) {\n\n        e = NULL;\n\n        while ((e = av_dict_get(output_streams[i]->opts, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX)))\n\n            av_dict_set(&unused_opts, e->key, NULL, 0);\n\n    }\n\n\n\n    e = NULL;\n\n    while ((e = av_dict_get(unused_opts, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n\n        const AVClass *class = avcodec_get_class();\n\n        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,\n\n                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);\n\n        if (!option)\n\n            continue;\n\n        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Codec AVOption %s (%s) specified for \"\n\n                   \"output file #%d (%s) is not an encoding option.\\n\", e->key,\n\n                   option->help ? option->help : \"\", nb_output_files - 1,\n\n                   filename);\n\n            exit_program(1);\n\n        }\n\n\n\n        // gop_timecode is injected by generic code but not always used\n\n        if (!strcmp(e->key, \"gop_timecode\"))\n\n            continue;\n\n\n\n        av_log(NULL, AV_LOG_WARNING, \"Codec AVOption %s (%s) specified for \"\n\n               \"output file #%d (%s) has not been used for any stream. The most \"\n\n               \"likely reason is either wrong type (e.g. a video option with \"\n\n               \"no video streams) or that it is a private option of some encoder \"\n\n               \"which was not actually used for any stream.\\n\", e->key,\n\n               option->help ? option->help : \"\", nb_output_files - 1, filename);\n\n    }\n\n    av_dict_free(&unused_opts);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid losing precious files */\n\n        assert_file_overwrite(filename);\n\n\n\n        /* open the file */\n\n        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,\n\n                              &oc->interrupt_callback,\n\n                              &of->opts)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (strcmp(oc->oformat->name, \"image2\")==0 && !av_filename_number_test(filename))\n\n        assert_file_overwrite(filename);\n\n\n\n    if (o->mux_preload) {\n\n        uint8_t buf[64];\n\n        snprintf(buf, sizeof(buf), \"%d\", (int)(o->mux_preload*AV_TIME_BASE));\n\n        av_dict_set(&of->opts, \"preload\", buf, 0);\n\n    }\n\n    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < o->nb_metadata_map; i++) {\n\n        char *p;\n\n        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);\n\n\n\n        if (in_file_index >= nb_input_files) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d while processing metadata maps\\n\", in_file_index);\n\n            exit_program(1);\n\n        }\n\n        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,\n\n                      in_file_index >= 0 ?\n\n                      input_files[in_file_index]->ctx : NULL, o);\n\n    }\n\n\n\n    /* copy chapters */\n\n    if (o->chapters_input_file >= nb_input_files) {\n\n        if (o->chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            o->chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i]->ctx->nb_chapters) {\n\n                    o->chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   o->chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (o->chapters_input_file >= 0)\n\n        copy_chapters(input_files[o->chapters_input_file], of,\n\n                      !o->metadata_chapters_manual);\n\n\n\n    /* copy global metadata by default */\n\n    if (!o->metadata_global_manual && nb_input_files){\n\n        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n        if(o->recording_time != INT64_MAX)\n\n            av_dict_set(&oc->metadata, \"duration\", NULL, 0);\n\n        av_dict_set(&oc->metadata, \"creation_time\", NULL, 0);\n\n    }\n\n    if (!o->metadata_streams_manual)\n\n        for (i = of->ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist;\n\n            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */\n\n                continue;\n\n            ist = input_streams[output_streams[i]->source_index];\n\n            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    /* process manually set metadata */\n\n    for (i = 0; i < o->nb_metadata; i++) {\n\n        AVDictionary **m;\n\n        char type, *val;\n\n        const char *stream_spec;\n\n        int index = 0, j, ret = 0;\n\n\n\n        val = strchr(o->metadata[i].u.str, '=');\n\n        if (!val) {\n\n            av_log(NULL, AV_LOG_FATAL, \"No '=' character in metadata string %s.\\n\",\n\n                   o->metadata[i].u.str);\n\n            exit_program(1);\n\n        }\n\n        *val++ = 0;\n\n\n\n        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n\n        if (type == 's') {\n\n            for (j = 0; j < oc->nb_streams; j++) {\n\n                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n\n                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n                } else if (ret < 0)\n\n                    exit_program(1);\n\n            }\n\n        }\n\n        else {\n\n            switch (type) {\n\n            case 'g':\n\n                m = &oc->metadata;\n\n                break;\n\n            case 'c':\n\n                if (index < 0 || index >= oc->nb_chapters) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index);\n\n                    exit_program(1);\n\n                }\n\n                m = &oc->chapters[index]->metadata;\n\n                break;\n\n            default:\n\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier);\n\n                exit_program(1);\n\n            }\n\n            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2365, "substitutes": {"o": ["n", "oi", "oo", "options", "ao", "oa", "ot", "one", "cache", "bo", "ve", "te", "v", "or", "go", "it", "to", "er", "ie", "y", "h", "ox", "io", "q", "c", "O", "on", "window", "ion", "online", "os", "a", "ta", "no", "lo", "po", "ro", "other", "yo", "oS", "iso", "l", "oid", "co", "original", "mo", "info", "ow", "so", "op", "office", "ok", "ation", "b", "d", "w", "fo", "remote", "onet", "u", "ob", "oe", "image", "t", "vo", "obj", "f", "owner"], "filename": ["n", "lr", "ame", "ename", "FN", "jpg", "ren", "length", "ocument", "ammy", "ews", "fle", "xxx", "path", "output", "r", "kl", "username", "kan", "wav", "fp", "nom", "prefix", "title", "fi", "sorry", "file", "name", "nil", "that", "println", "location", "kj", "wcs", "msg", "tif", "fn", "fd", "txt", "text", "unction", "NAME", "unc", "Filename", "FIL", "f", "fil", "json", "ames", "nm", "names", "buffer", "mson", "til", "tor", "directory"], "oc": ["oi", "oo", "toc", "org", "roc", "c", "ot", "oj", "og", "cc", "ec", "OC", "pc", "oid", "oco", "bc", "dc", "ob", "co", "ocon", "om", "ocr", "ic", "ctx", "os", "ac", "osc", "voc", "ov", "loc", "op", "oh", "arc", "unc", "uc", "obj", "soc", "oci", "ocation", "ox", "ok", "off", "alloc"], "i": ["iu", "I", "n", " li", "li", "b", "c", "ii", "mi", " bi", "ai", "v", "ij", "x", "pi", " ti", " ii", "it", "si", "ci", "t", "y", "io"], "j": ["uj", "n", "jc", "q", "b", "jump", "pos", "ji", "ja", "v", "ij", "jj", "jac", "fi", "jp", "g", "kj", "aj", "bj", "z", "json", "jl", "js", "J", "job"], "err": ["n", "attr", "lr", "cr", "str", "init", "iter", "rc", "fr", "yr", "erd", "cfg", "rb", "error", "kr", "ir", "pr", "r", "ec", "ind", "Error", "arr", "exc", "rn", "rr", "or", "it", "cb", "der", "er", "msg", "resp", "res", "txt", "ner", "usr", "obj", "dr", "Er", "ch", "errors", "result", "ev", "mr"], "file_oformat": ["file_ooutput", "file_OFormat", "file_Ooutput", "file_Oformat", "file_oform", "file_foFormat", "file_foform", "file_oFormat", "file_fooutput", "file_foformat", "file_Oform"], "of": ["oi", "oo", "ofer", "ff", "org", "oa", "from", "by", "ot", "one", "og", "orf", "\u00f3", "ll", "oft", "cf", "OF", "en", "or", "it", "ov", "to", "ol", "off", "lf", "alf", "eh", "ef", "uf", "about", "\u00f6", "own", "on", "fi", "def", "os", "iq", "oh", "omp", "other", "oof", "new", "osi", "oid", "less", "ow", "ar", "af", "wo", "df", "so", "fol", "root", "ok", "jo", "ful", "el", "ovi", "ob", "oe", "Of", "oln", "oha", "fd", "zero", "sf", "obj", "eff", " fo", "raw", "f", "owner"], "ost": ["ott", "oo", "ust", "tt", "oos", "src", "ot", "ast", "rest", "oid", "st", "ort", "ous", "sys", "ob", "om", "obs", "os", "oss", "ont", "host", "op", "unc", "etc", "olog", "od", "ok"], "ist": ["iste", "iss", "ust", "isi", "et", "ir", "ot", "istor", "pir", "aft", "ird", "its", "est", "ip", "fp", "is", "st", "ists", "ic", "wi", "ont", "IST", "umi", "il", "isl", "irst", "oci", "iop"], "unused_opts": ["unused_pros", "unused_pfs", "unused_ops", "unused_ps", "unused_prots", "unused_copms", "unused_opms", "unused_proms", "unused_cops", "unused_opfs", "unused_copfs", "unused_copts", "unused_pms", "unused_pts", "unused_profs"], "e": ["n", "el", "et", "ef", "es", "eu", "c", "d", "ec", "te", "ge", "ei", "oe", "ele", "se", "me", "en", "E", "pe", "er", "ie", "ed", "ea", "ee", "xe"]}}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 2395, "substitutes": {"result": ["test", "this", "rc", "final", "self", "answer", "results", "currency", "status", "m", "block", "output", "map", "ret", "cache", "Result", "memory", "p", "match", "arg", "out", "valid", "message", "list", "true", "df", "data", "res", "val", "table", "ult", "f", "mate", "buffer", "complete"], "immn": ["mutn", "immcn", "permcn", "mutr", "immN", "premN", " immnm", "permn", "permrn", "Immr", "immnl", "premr", "mutnl", "Immnl", "Imm1", "immrn", "iamN", " immcn", "iamrn", "imm1", "iamnm", "immnm", " immN", "Immn", "iamr", "premnm", "iamn", " imm1", " immrn", "iamcn", "permN", " immnl", "mut1", "premn"], "imms": [" imps", "limcs", "iams", "simfs", " ims", "immts", "imcs", "simps", "umm", "limmn", " imfs", "immmn", " imm", "imsps", "simms", "iamms", "immms", "IMps", "IMms", "ims", " imts", " immas", "imsts", "IMfs", "iammn", "imsms", "imts", "imfs", "limps", "simmas", "immas", "limms", "ums", "imscs", "imm", "imps", " imcs", "iamm", "ummn", "IMmas", "immcs", "imsmn", "umms"], "immr": ["armr", "imrn", "imh", "imn", "imr", " imme", " immh", "attrn", "ime", "Immr", "immh", " immd", " immp", "armd", "mmp", "mme", "attrm", "Immrn", "imme", "mmh", "immrn", "attrrn", " immm", "Immm", "mmr", "Immn", "Immd", "immm", "armm", "immd", "immrb", " immrb", "attrr", "Immrb", "imp", "imm", "immp", "armrb"], "mask": [" mirror", "hash", "cmp", "tr", " Mask", " pixel", "sk", " mc", " ma", "mount", "cf", "black", "flags", "gate", "Mask", "transform", "q", "batch", "mark", " map", " cm", "map", "sum", "window", "x", "message", " constraint", "bit", " masked", "ma", "perm", "mt", "pack", "z", "allow", "buffer", " sk", " match", " label", "mass", "p", "match", "out", " mark", " message", "cm", " chunk", "ms", " metric", "key", "set", "share", "ch", "level", "m", "flag", "clear", "form", "filter", "sign", " scale", "comment", "block", "clean", "gc", "mp", "miss", "offset", " flag", "arr", " filter", "hold", "hide", "shift", "ask", "lock", "zero", "mb", "weight", "f", "mate", "um", " key", "label", " gate", " mac"], "e": ["n", "count", "el", "ep", "es", "eu", "c", "d", "p", "ec", "i", "l", "te", "ei", "x", "u", "oe", "ele", "se", "me", "g", "elt", "en", "o", "end", "a", "E", "pe", "le", "er", "t", "ate", "element", "size", "ed", "h", "eg", "f", "err", "ee", "errors", "m"], "levels": ["ones", "n", "xs", "limits", "blocks", "xes", "es", "values", "ls", "codes", "links", "states", "ints", "ales", "modules", "ts", "points", "ps", "i", "l", "ens", "heads", "gs", "groups", "ops", "terms", "members", "fields", "lines", "ims", "ms", "keys", "mins", "checks", "ds", "eps", "flags", "vs", "times", "rs", "ns", "bits", "lvl", "ins", "rows", "vals", "frames", "depth", "level", "errors", "ples", "steps"], "s": ["n", "spec", "stats", "sing", "bs", "sec", "qs", "self", "es", "b", "ls", "p", "ts", "ps", "i", "l", "gs", "is", "sys", "st", "less", "ss", "g", "se", "ims", "sv", "os", "ds", "a", "si", "sts", "sr", "er", "le", "ats", "rs", "t", "ns", "sb", "S", "ins", "sw", "h", "sl", "sq", "z", "cs", "sp", "upper", "m", "j"], "r": ["n", "lr", "rar", "rc", "fr", "q", "re", "rd", "vr", "b", "c", "rb", "ls", "d", "w", "rec", "p", "i", "l", "rf", "v", "rate", "u", "x", "g", "rt", "reg", "ar", "rr", "sr", "er", "rs", "t", "rel", "h", "dr", "z", "f", "R", "err", "m", "j", "ro", "mr"], "len": ["lf", "n", "el", "lon", "nl", "length", " length", "bytes", "ls", "pos", "d", "dl", "kl", " clen", "ell", "ll", "l", "offset", "v", "L", "oe", "Length", "ele", " l", " le", "elt", "en", "lp", "limit", "Len", "ld", "loc", "le", "t", "pl", "size", "h", "sl", "z", "ln", "sp", "err", "level", "m", "lan", "compl"]}}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n", "idx": 2400, "substitutes": {"s": ["sam", "n", "spec", "stats", "bs", "ses", "an", "comm", "c", "ls", "r", "p", "ts", "ps", "i", "gs", "v", "is", "sys", "st", "less", "ss", "g", "conf", "ims", "space", "sc", "ctx", "sv", "os", "source", "se", "fs", "ds", "a", "sts", "rs", "t", "ns", "serv", "sb", "S", "scl", "h", "obj", "sq", "cs", "js", "m", "has"], "list": ["ist", "n", "count", "LIST", "cache", "ll", "loop", "v", "next", "video", "coll", "value", "tree", "net", "ml", "detail", "pos", "top", "test", "pool", "layer", "batch", "lists", "map", "listed", "st", "def", "file", "table", "index", "pre", "details", "chain", "config", "data", "tag", "collection", "this", "dl", "alist", "p", "l", "out", "template", "format", "info", "lt", "name", "all", "code", "set", "state", "List", "level", "result", "base", "spec", "stack", "li", "filter", "self", "summary", "page", "ls", "local", "type", "parent", "stat", "total", "t", "act", "obj", "print", "sequence"], "poc": ["moc", " pac", "proc", "propOC", "vOC", "POC", "Puc", "vpocon", "moca", "ppuc", "not", " pot", "porp", " POC", "noc", "vpOC", "puc", "pioca", "mroc", "pot", "ppoco", "ppocon", "ppOC", " pOC", "vorp", "piac", "vpoco", "propoca", " Poc", "nac", " Pocon", "pOC", "piot", "voc", "pocon", "poca", "noca", " proc", "propoc", "pac", "proproc", " Poco", " poca", "Porp", "poco", "pioc", "Poc", "vuc", "mOC", "pporp", "vpoc", "ppoc"], "ref_flag": ["ref2flag", "ref_lag", " ref_lag", " ref_Flag", "ref2flags", "ref_flags", " ref_flags", "ref_Flag", "ref2lag"], "ref": ["null", "cmp", "re", "by", "lit", "r", "pr", "cache", "rest", "v", "rm", "crit", "ne", "coord", "br", "grab", "value", "resp", "to", "val", "Ref", "range", "id", "tab", "prop", "note", "repl", "rep", "ef", "comp", "rec", "map", "alt", "req", "tip", "row", "def", "rev", "file", "ror", "col", "cb", "rel", "inf", "agg", "eval", "index", "term", "ro", "tag", "ext", "this", "seq", "find", "frame", "ret", "p", "arg", "cal", "info", "reg", "reflect", "all", "addr", "msg", "tmp", "reference", "rem", "spec", "orig", "eb", "diff", "item", "page", "b", "be", "gen", "block", "nav", "remote", "check", "img", "mem", "rf", "disc", "ob", "conf", "g", "url", "link", "doc", "res", "act", "call", "obj", "snap", "mb", "f", "REF", "err", "db"], "nb_refs": ["nb_mbl", "nb_Refs", "nb_cols", "nb_pti", "nb_refm", "nb_findns", "nb_deferences", "nb_colos", "nb_defm", "nb_mberences", "nb_colds", "nb_defl", "nb_ptts", "nb_refds", "nb_Refi", "nb_defs", "nb_findds", "nb_references", "nb_refos", "nb_References", "nb_Refos", "nb_mbm", "nb_Refm", "nb_refl", "nb_refts", "nb_Refns", "nb_colts", "nb_Refl", "nb_refi", "nb_colns", "nb_coli", "nb_Refds", "nb_Refts", "nb_finds", "nb_findi", "nb_pts", "nb_refns", "nb_ptos", "nb_mbs"]}}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n", "idx": 2415, "substitutes": {"dc": ["de", "cca", "cr", "rc", "mc", "comm", "ct", "c", "di", "lc", "td", "ca", "d", "dl", "dp", "oc", "gc", "controller", "cc", "cp", "ec", "pc", "bc", "disc", "cm", "dd", "co", "kw", "fc", "nc", "ctx", "draw", "df", "ac", "dt", "dat", "ci", "da", "dm", "tc", "dr", "DC", "ctl", "cs", "vc", "cd"], "r": ["n", "attr", "cr", "lr", "rar", "rc", "fr", "q", " err", "re", "tr", "rd", "vr", "c", "rb", "error", "kr", "entry", "rank", "d", "ir", "w", "rg", "rec", "pr", "p", "rer", "type", "req", "i", "l", "rf", "v", "hr", "row", "x", "e", "rev", "g", "rt", "ror", "ar", "rn", "rr", "o", "br", "or", "ry", "sr", "er", "res", "t", "rs", "rel", "usr", "mr", "h", "dr", "role", "f", "R", "err", "id", "range", "ri", "m", "j", "result", "nr"], "tn": [" td", "pn", "utt", "n", "token", "tp", "nz", "np", "TN", "tt", "nt", " ts", "td", "tw", "tu", " out", "sn", " tu", "kt", "wn", "bn", "ts", "vt", " tc", " TN", "out", "nut", "gt", "tl", "tz", "tun", " tf", "tk", "dt", "btn", "fn", "qt", "t", " tv", "txt", "tm", "tf", "tc", "mt", "Sn", "ln", "ctl", " t", "tg", "nn", "tx", "nm", "Tu", "wt"]}}
{"project": "FFmpeg", "commit_id": "b9fa32082c71013e90eab9e9997967d2939cf4a6", "target": 1, "func": "static int vorbis_parse_id_hdr(vorbis_context *vc){\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t bl0, bl1;\n\n\n\n    if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') ||\n\n    (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||\n\n    (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (no vorbis signature). \\n\");\n\n        return 1;\n\n    }\n\n\n\n    vc->version=get_bits_long(gb, 32);    //FIXME check 0\n\n    vc->audio_channels=get_bits(gb, 8);   //FIXME check >0\n\n    vc->audio_samplerate=get_bits_long(gb, 32);   //FIXME check >0\n\n    vc->bitrate_maximum=get_bits_long(gb, 32);\n\n    vc->bitrate_nominal=get_bits_long(gb, 32);\n\n    vc->bitrate_minimum=get_bits_long(gb, 32);\n\n    bl0=get_bits(gb, 4);\n\n    bl1=get_bits(gb, 4);\n\n    vc->blocksize[0]=(1<<bl0);\n\n    vc->blocksize[1]=(1<<bl1);\n\n    if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (illegal blocksize). \\n\");\n\n        return 3;\n\n    }\n\n    // output format int16\n\n    if (vc->blocksize[1]/2 * vc->audio_channels * 2 >\n\n                                             AVCODEC_MAX_AUDIO_FRAME_SIZE) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \"Vorbis channel count makes \"\n\n               \"output packets too large.\\n\");\n\n        return 4;\n\n    }\n\n    vc->win[0]=ff_vorbis_vwin[bl0-6];\n\n    vc->win[1]=ff_vorbis_vwin[bl1-6];\n\n\n\n    if(vc->exp_bias){\n\n        int i, j;\n\n        for(j=0; j<2; j++){\n\n            float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float));\n\n            for(i=0; i<vc->blocksize[j]/2; i++)\n\n                win[i] = vc->win[j][i] * (1<<15);\n\n            vc->win[j] = win;\n\n        }\n\n    }\n\n\n\n    if ((get_bits1(gb)) == 0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (framing flag not set). \\n\");\n\n        return 2;\n\n    }\n\n\n\n    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->previous_window=0;\n\n\n\n    ff_mdct_init(&vc->mdct[0], bl0, 1);\n\n    ff_mdct_init(&vc->mdct[1], bl1, 1);\n\n\n\n    AV_DEBUG(\" vorbis version %d \\n audio_channels %d \\n audio_samplerate %d \\n bitrate_max %d \\n bitrate_nom %d \\n bitrate_min %d \\n blk_0 %d blk_1 %d \\n \",\n\n            vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]);\n\n\n\n/*\n\n    BLK=vc->blocksize[0];\n\n    for(i=0;i<BLK/2;++i) {\n\n        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));\n\n    }\n\n*/\n\n\n\n    return 0;\n\n}\n", "idx": 2424, "substitutes": {"vc": ["tp", "tt", "ot", "kt", "av", "cp", "craft", "ant", "ve", "cf", "v", "ic", "coll", "voc", "lv", "etc", "hw", "cmd", "xp", "var", "vi", "vr", "ud", "c", "lc", "att", "pc", "dc", "gt", "xc", "sv", "irm", "wcs", "wd", "vp", "uv", "vision", "ctl", "vy", "fax", "wx", "VC", "vd", "CV", "rc", "dll", "nv", "watch", "cc", "ell", "vv", "mk", "inv", "rt", "ow", "pp", "ctx", "vl", "ce", "ci", "cv", "fw", "voice", "vert", "advert", "ht", "form", "vet", "ct", "gc", "vt", "sky", "bc", "csv", "fc", "lp", "serv", "act", "dev", "cs", "vm", "ee", "vec", "ev"], "gb": ["bt", "vg", "ib", "attr", "kb", "bs", "gnu", "eb", "Gb", "bytes", "gd", "bg", "cfg", "eu", "rb", "gh", "html", "rg", "rect", "gc", "py", "bn", "wb", "ruby", "vt", "xy", "pc", "img", "git", "gs", "sys", "csv", "bm", "bf", "linux", "gt", "g", "gif", "deg", "elt", "ctx", "gu", "cb", "nb", "px", "bits", "hub", "sb", "bb", "hz", "goo", "GB", "cv", "uv", "pg", "mb", "gpu", "eg", "raw", "gp", "phy", "storage", "um", "vm", "gg", "tg", "gm", "ch", "gy", "buff", "cd", "db"], "bl0": [" bl2", "abl00", "bl5", "block0", "gl06", "batch8", "Bl00", "ble8", "Bl3", "bl8", "bl10", "gl1", " bl10", "blinder", "pl00", "abl0", "BL0", " bl3", "gl5", "bm0", "blZero", "bl3", "bl00", "gl8", "BL1", "ble0", "bcinder", "abl06", "lb6", "abl6", "gl00", "bmZero", "lb06", "Bl0", " blinder", "gl0", " blZero", "bl6", "bl06", "gl000", " bl00", "lb0", "block1", "ble00", "ble10", "lb00", "Bl1", "gl6", "Bl10", "bl2", "ble5", "bcZero", "block3", "pl1", "BL2", "bminder", "bl000", "batch0", "bc0", "Bl2", "ble000", "batch000", "bc3", "batch5", "pl0", "bm3"], "bl1": [" bl2", "bl11", "bleOne", "bl001", " blOne", "ll3", "ll1", " bl01", "bl9", "blOne", "gl1", "ble2", "BL0", "BlOne", "abl4", "BL4", " bl3", "ll9", "ble1", "pl0", "bl3", " bln", "fl0", "batch1", "BL1", "batch3", "ble0", "gl01", "fl1", "block2", "batch4", "block9", "pl2", "lb6", "BL11", " bl001", "abl6", "ble001", "label6", "fl4", "abl3", "bl6", "ble6", "bln", "labelN", "glN", "block1", "lb1", "abl1", " bl11", "lb01", "label1", "Bl1", "blen", "blN", "gl6", "bl2", " bl9", "lbN", "fl11", "pln", "batch6", " bl4", "bl01", "ble4", "block3", "pl1", "ble01", "bl4", "Bl2", "lb001", "ll2", "label01", "ble3"], "i": ["k", "I", "n", "bi", "li", "b", "c", "ii", "mi", "r", "p", "ji", "ai", "v", "ij", "x", "pi", "g", "o", " ii", "si", "ix", "ci", "t", "y", "m"], "j": ["k", "uj", "n", "jc", "jack", "q", "jump", "c", "b", "oj", "r", "p", "dj", "ji", "ind", "l", "ja", "v", "ij", "jj", "jp", "g", "ng", "jit", "kj", "ix", "msg", "aj", "bj", "ie", "y", "z", "json", "jl", "js", "ch", "kid", "J", "jo", "m", "job", "jas"], "win": ["wk", "proc", "nw", "windows", "init", "wire", "use", "bin", "gn", "mask", "write", "w", "map", "pad", "wall", "ll", "pc", "mem", "window", "wal", "word", "sys", "gain", "draw", "Win", "lock", "wrap", "wd", "root", "pac", "pack", "hw", "loss", "weight", "cmd", "wit"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,\n\n                                         src - (stride * 2) +\n\n                                         sizeof(uint8_t), stride, dst, stride);\n\n}\n", "idx": 2429, "substitutes": {"dst": ["pst", " dsrc", "Dest", "mdest", "Ddest", "mest", "ddest", "dest", "Dst", "fdest", "Dsrc", "fst", "fest", "pput", "dsrc", "fsrc", "mput", "mst", " ddest", "dput", "pest", " dput", "pdest", " dest"], "src": ["s", "inst", "inner", "supp", "dq", "input", "str", "rc", "sec", "np", "usc", "b", "dist", "cur", "start", "sn", "dest", "comp", "r", "rec", "rl", "lat", "cc", "req", "img", "sh", "st", "sys", "ur", "bc", "in", "fc", "rt", "sc", "source", "addr", "sr", "loc", "rs", "sur", "now", "sb", "ins", "ptr", "sq", "desc", "ctr", "ser", "sub", "urg", "RC"], "stride": [" drice", "dride", "stringide", "strice", "side", "stringice", "drride", "sided", "drose", " drid", "strope", "strride", " strid", "slince", " dride", " strride", "drided", "strided", "strides", "stide", "STRride", " strose", "strose", "stides", " strince", "STRide", "sride", "drince", "stringid", " strice", "drid", "stringope", "sid", "strince", "STRides", "slide", "slose", " strides", " drope", " strope", "stice", " strided", "strid", "slride", "STRice"]}}
{"project": "qemu", "commit_id": "c1bf3531aecf4a0ba25bb150dd5fe21edf406c88", "target": 1, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n", "idx": 2451, "substitutes": {"peer": ["nw", "pro", "tp", "proc", "pool", "target", "point", "ker", "enter", "channel", "remote", "p", "parent", "pc", "connection", "socket", "context", "ter", "me", "ctx", "pp", "pod", "port", "conn", "server", "host", "pe", "er", "component", "node", "primary", "cv", "dev", "package", "pkg", "holder", "camera", "chain", "owner", "client", "instance"], "device": ["pipe", "devices", " Device", "Device", "controller", "product", "family", "description", "window", "attribute", "command", "power", " dev", "pod", "serial", "server", "location", "pe", "slave", "user", "node", "drive", "resource", "dev", "package", "address", "phy", "id", "label", "DEV", "password", "mode", "owner", "directory"], "name": ["ment", "n", "ame", "nam", "time", "length", "new", "comment", "error", "path", "phone", "w", "family", "local", "type", "parent", "mem", "word", "number", "prefix", "title", "info", "file", "port", "group", "key", "server", "location", "pass", "t", "user", "node", "text", "Name", "alias", "size", "NAME", "dev", "package", "order", "no", "address", "unknown", "id", "version", "names", "nm", "event", "password", "data"], "chr": [" chrl", "CHrs", "chrb", "chedr", "cherro", "Chdr", "Chrb", " chrb", "chR", "cherrb", "phrb", " chdr", "phr", "phrc", "chrc", "cherdr", " Char", "cher", "ChR", "Chrc", "cherl", "cherr", " chrs", " chR", "Chrs", " chrc", "cheR", "phrs", "chrs", "Char", "CHrb", "Chrl", "chro", "CHr", " Chr", "Chro", "Chr", "chrt", "Chrt", " chrt", " chro", "chrl", " Chdr", " Chrt", "CHR", "chdr"], "queues": ["requue", "requumers", "queueues", "queqs", "requves", "quesues", "quesue", "requforces", "querumers", "queueqs", "requued", "Queves", "queves", "querqs", "quesves", "queueumers", "queue", "queforces", "queumers", "Queue", "querues", "requues", "Queued", "requqs", "queued", "queueforces", "querforces", "quesued", "Queues"], "nc": ["pn", "n", "nl", "CN", "init", "nz", "np", "nt", "mc", "yo", "comm", "NT", "roc", "ct", "c", "nv", "oc", "gc", "anc", "bn", "cc", "ll", "yn", "pc", "cons", "ck", "bc", "co", "cn", "NC", "xc", "nih", "nil", "rn", "mn", "ne", "conv", "ctx", "conn", "sc", "ng", "cb", "nex", "nb", "Ns", "fn", "ns", "qt", "txt", "nec", "unc", "enc", "cv", "obj", "cus", "cs", "net", "ctl", "cmd", "nn", "nm", "auc", "con", "nic", "nr"], "s": ["sam", "n", "stats", "iss", "bs", "ses", "es", "b", "c", "ssl", "ls", "sn", "p", "ts", "uns", "ps", "is", "gs", "sys", "socket", "less", "ss", "sc", "ys", "sv", "oss", "os", "o", "acs", "fs", "ds", "set", "vs", "sts", "ats", "so", "rs", "ns", "S", "h", "sq", "cs", "sp", "hs", "js", "sa", "news", "j"], "i": ["phi", "iu", "I", "n", "bi", "hi", "cli", "li", "ui", "point", "c", "di", "ii", "im", "mi", "m", "ki", "p", "ind", " I", "ip", "is", "ai", "ei", "v", "l", "x", "number", "pi", "e", "ij", "in", "ini", "queue", "zi", "g", "ic", "ims", "ms", "xi", "qi", "me", "port", " ti", "my", " ii", "it", "si", "gu", "ix", "iq", "to", "counter", "ci", "t", "index", "multi", "y", " ni", "h", "z", "id", "ti", "sim", "gi", "o", "j", "ex"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe(AVProbeData *p)\n\n{\n\n    const uint8_t *d;\n\n\n\n    if (p->buf_size < 6)\n\n        return 0;\n\n    d = p->buf;\n\n    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {\n\n        return AVPROBE_SCORE_MAX;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2466, "substitutes": {"p": ["ad", "n", "bp", "pro", "proc", "press", "app", "pat", "rep", "pd", "np", "q", "up", "b", "c", "post", "pb", "P", "w", "dp", "pt", "r", "pers", "mp", "cp", "ps", "pc", "fp", "v", "ap", "e", "jp", "pp", "a", "op", "part", "t", "pl", "progress", "pre", "pkg", "f", "wp", "sp", "m", "j", "pa"], "d": ["ad", "dq", "n", "dos", "str", "del", "dh", "md", "q", "rd", "b", "c", "dist", "did", "new", "nd", "di", "dl", "w", "r", "sd", "dig", "ind", "l", "vol", "v", "dc", "dd", "D", "g", "df", "ord", "all", "ds", "it", "dt", "ade", "ld", "dat", "loc", "t", "da", "fd", "done", "bd", "ed", "dict", "dr", "y", "debug", "z", "dra", "f", "dump", "json", "desc", "dim", "m", "j", "data", "db"]}}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static void scsi_read_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad read tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_read_request(r);\n\n}\n", "idx": 2471, "substitutes": {"d": ["ad", "n", "del", "dn", "dep", "dh", "md", "did", "c", "b", "di", "w", "p", "sd", "l", "v", "e", "dc", "dd", "D", "g", "ds", "dt", "dat", "t", "fd", "dm", "dev", "h", "dr", "dra", "f", "m", "data", "dx", "db"], "tag": ["bug", "test", "token", "attr", "cat", "ag", "length", "peg", "error", "at", "tty", " TAG", "arg", "sum", "type", "match", "tags", "pad", "feat", "bad", "word", "tail", "offset", "row", "field", "TAG", "Tag", "reg", "name", "num", "key", "code", "value", "msg", "t", "zero", "qual", "debug", "pg", "mt", "date", " Tag", "cmd", "tg", "id", "version", "label", "term", "data", "po", "ype"], "s": ["spec", "sg", "stats", "iss", "qs", "self", "ses", "es", "c", "ls", "ts", "ps", "south", "gs", "is", "v", "sys", "st", "less", "ss", "space", "sis", "sv", "os", "ds", "set", "sts", "ats", "sr", "so", "rs", "ns", "state", "ins", "S", "h", "sl", "sq", "su"], "r": ["k", "n", "repl", "cr", "attr", "lr", "rar", "rc", "ren", "fr", "q", "re", "rd", "vr", "b", "rb", "c", "rg", "w", "rec", "pr", "p", "rw", "req", "l", "v", "ur", "u", "e", "rm", "g", "rt", "rn", "ar", "rr", "br", "run", "sr", "er", "res", "rs", "t", "rel", "h", "dr", "f", "R", "request", "err", "m", "j", "result", "ro", "mr"]}}
{"project": "FFmpeg", "commit_id": "13ccba50d45662a15777b549b2fcd9b4621b0e01", "target": 0, "func": "static void opt_output_file(void *optctx, const char *filename)\n\n{\n\n    OptionsContext *o = optctx;\n\n    AVFormatContext *oc;\n\n    int i, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    oc = avformat_alloc_context();\n\n    if (!oc) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n\n\n    if (last_asked_format) {\n\n        file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Requested output format '%s' is not a suitable output format\\n\", last_asked_format);\n\n            exit_program(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    } else {\n\n        file_oformat = av_guess_format(NULL, filename, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Unable to find a suitable output format for '%s'\\n\",\n\n                    filename);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->oformat = file_oformat;\n\n    av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        /* special case for files sent to avserver: we get the stream\n\n           parameters from avserver */\n\n        int err = read_avserver_streams(oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        /* pick the \"best\" stream of each type */\n\n#define NEW_STREAM(type, index)\\\n\n        if (index >= 0) {\\\n\n            ost = new_ ## type ## _stream(oc);\\\n\n            ost->source_index = index;\\\n\n            ost->sync_ist     = &input_streams[index];\\\n\n            input_streams[index].discard = 0;\\\n\n        }\n\n\n\n        /* video: highest resolution */\n\n        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    ist->st->codec->width * ist->st->codec->height > area) {\n\n                    area = ist->st->codec->width * ist->st->codec->height;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(video, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(audio, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    NEW_STREAM(subtitle, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];\n\n            switch (ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;\n\n            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;\n\n            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;\n\n            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;\n\n            default:\n\n                av_log(NULL, AV_LOG_ERROR, \"Cannot map stream #%d.%d - unsupported type.\\n\",\n\n                       map->file_index, map->stream_index);\n\n                exit_program(1);\n\n            }\n\n\n\n            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;\n\n            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +\n\n                                           map->sync_stream_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    av_dict_copy(&oc->metadata, metadata, 0);\n\n    av_dict_free(&metadata);\n\n\n\n\n\n    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);\n\n    output_files[nb_output_files - 1].ctx       = oc;\n\n    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;\n\n    output_files[nb_output_files - 1].recording_time = o->recording_time;\n\n    output_files[nb_output_files - 1].start_time     = o->start_time;\n\n    output_files[nb_output_files - 1].limit_filesize = limit_filesize;\n\n    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid loosing precious files */\n\n        if (!file_overwrite &&\n\n            (strchr(filename, ':') == NULL ||\n\n             filename[1] == ':' ||\n\n             av_strstart(filename, \"file:\", NULL))) {\n\n            if (avio_check(filename, 0) == 0) {\n\n                if (!using_stdin) {\n\n                    fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename);\n\n                    fflush(stderr);\n\n                    if (!read_yesno()) {\n\n                        fprintf(stderr, \"Not overwriting - exiting\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                }\n\n                else {\n\n                    fprintf(stderr,\"File '%s' already exists. Exiting.\\n\", filename);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* open the file */\n\n        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->preload= (int)(mux_preload*AV_TIME_BASE);\n\n    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);\n\n    oc->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* copy chapters */\n\n    if (chapters_input_file >= nb_input_files) {\n\n        if (chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i].ctx->nb_chapters) {\n\n                    chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (chapters_input_file >= 0)\n\n        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < nb_meta_data_maps; i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            exit_program(1);\\\n\n        }\n\n\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = oc;\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy && nb_input_files)\n\n        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n    if (metadata_streams_autocopy)\n\n        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist = &input_streams[output_streams[i].source_index];\n\n            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_width   = 0;\n\n    frame_height  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    chapters_input_file = INT_MAX;\n\n    limit_filesize = UINT64_MAX;\n\n\n\n    av_freep(&meta_data_maps);\n\n    nb_meta_data_maps = 0;\n\n    metadata_global_autocopy   = 1;\n\n    metadata_streams_autocopy  = 1;\n\n    metadata_chapters_autocopy = 1;\n\n    av_freep(&streamid_map);\n\n    nb_streamid_map = 0;\n\n\n\n    av_dict_free(&codec_names);\n\n\n\n    av_freep(&forced_key_frames);\n\n    reset_options(o);\n\n}\n", "idx": 2502, "substitutes": {"optctx": ["optcmp", "opcc", "optioncontext", " opttx", "opcontext", " optcontext", "optioncc", " optcp", "opttx", "opcp", " optcmp", "optioncmp", "optionctx", "objtx", "objcontext", "objctx", "optx", "opctx", "opcmp", "objcp", "optcp", " optcc", "optcontext", "optcc"], "filename": ["n", "null", "dn", "what", "rather", "FN", "aka", "length", "fle", "severe", "metadata", "uri", "upload", "INAL", "wav", "asm", "amen", "origin", "location", "finals", "tif", "txt", "Filename", "AME", "FIL", "stem", "json", "processor", "mson", "directory", "localhost", "ame", "ename", "status", "ername", "nom", "prefix", "file", "nil", "kj", "wcs", "existent", "master", "fn", "unction", "oval", "session", "LCS", "ames", "names", "buffer", "wine", "jpg", "kl", "png", "username", "fps", "kan", "ja", "journal", "original", "format", "name", "seek", "position", "msg", "generation", "abl", "NAME", "nm", "til", "lr", "ren", "ammy", "src", "path", "mpeg", "fp", "lua", "word", "title", "csv", "println", "SOURCE", "size", "unc", "f", "fil", "there", "wikipedia", "amer", "sequence"], "o": ["k", "n", "oo", "oa", "c", "ot", "O", "d", "w", "opt", "og", "p", "bo", "ec", "oid", "v", "u", "e", "co", "ob", "oin", "ic", "os", "go", "op", "t", "obj", "h", "f", "ox", "ou", "od", "m", "po", "io"], "oc": ["ocol", "ogg", "oo", "rc", "AC", "aco", "toc", "org", "mc", "yo", "oad", "roc", "c", "ot", "og", "opt", "anc", "cp", "ec", "OC", "oid", "pc", "oco", "bc", "dc", "ob", "co", "ocr", "ic", "nc", "ctx", "aic", "os", "ac", "osc", "doc", "coll", "voc", "go", "cms", "ko", "loc", "ce", "op", "canon", "oly", "vo", "arc", "abc", "unc", "pg", "obj", "soc", "oci", "circ", "ocation", "ox", "ico", "tx", "vc", "irc", "ok", "nic", "alloc"], "i": ["phi", "iu", "I", "bi", "init", " li", "li", "iter", "ui", "batch", "c", "di", "ii", "uri", "mi", "r", " index", " si", "p", " mi", "ji", " bi", "ind", "ip", "ai", "ei", "is", "ij", "x", "pi", "ini", " di", "zi", "me", "qi", "xi", " ti", "ami", " ii", "it", "si", "ix", " vi", "ci", "t", "index", "multi", "y", "id", "ti", "sim", "gi", " x", "m", "instance"], "err": ["bug", "test", "proc", "core", "cr", "lr", "attr", "init", "iter", "rc", "fr", "erer", "gz", "yr", "cfg", "func", "rb", "error", "kr", "ir", "rank", "ni", "try", "r", "buf", "rss", "req", "ind", "late", "Error", "ei", "pi", "ori", "rev", "score", "arr", "conf", "len", "elt", "my", "rr", "coord", "br", "eor", "aaa", "cb", "resp", "er", "msg", "fee", "res", "rs", "txt", "order", "ner", "mr", "usr", "obj", "dev", "ptr", "dr", "Er", "cmd", "ctr", "priv", "notice", "result", "ev", "nr"], "file_oformat": ["file_Omat", "file_voformat", "file_nft", "file_nFormat", "file_oiplan", "file_nform", "file____oiformat", "file_onetprintf", "file_objplan", "file_eformat", "file_Otype", "file_onetformat", "file_oform", "file_tformat", "file_objcondition", "file_oterm", "file_voversion", "file_oicondition", "file_Oform", "file_opattern", "file_tform", "file_osterm", "file_voterm", "file_Oterm", "file_omat", "file_eFormat", "file_opcondition", "file_oversion", "file_objformat", "file_oiatt", "file_opplan", "file_ntype", "file_fFormat", "file_tprintf", "file_Oformat", "file_fformat", "file_osformat", "file____oform", "file_oFormat", "file_oijoin", "file____oiform", "file_ospattern", "file_etype", "file_ocondition", "file_oft", "file_nformat", "file_osversion", "file_vomat", "file_oatt", "file_oiform", "file_onetmat", "file_ojoin", "file_Opattern", "file_onetform", "file_oprintf", "file_oplan", "file_opjoin", "file_opformat", "file____oformat", "file_fform", "file_osatt", "file_Oversion", "file_oipattern", "file____oatt", "file_osmat", "file_fft", "file_OFormat", "file_otype", "file_osform", "file_oiformat", "file_Oatt", "file____opattern", "file____oiatt", "file_osprintf", "file_eform", "file____oipattern", "file_tmat", "file_objjoin"], "ost": ["otype", "ott", "oo", "ust", "tt", "oop", "ot", "ast", "yt", "opt", "rest", "rost", "stream", "\u00f3", "vest", "oid", "oster", "bott", "st", "sys", "ous", "onet", "umn", "ob", "ocr", "os", "oth", "oss", "ont", "voc", "host", "ond", "op", " nost", "sty", "irst", "ox", "od", "OST", "rol", "unt"], "ist": ["iste", "ista", "istant", "hist", "ism", "ust", "elist", "isi", "et", "isc", "ui", "osit", "art", "isd", "dit", "ert", "ir", "ia", "pir", "ast", "ister", "istor", "alist", "exist", "est", "ind", "ip", "fp", "is", "pas", "std", "st", "rist", "ists", "ic", "wi", "pect", "it", "IST", "xit", "aci", "iat", "ilst", "irst", "oci", "htt", "wp", "irc", "iop", "isting"]}}
{"project": "qemu", "commit_id": "8653c0158c23ec592f0041ab48b83d6cc6d152fe", "target": 0, "func": "static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n", "idx": 2523, "substitutes": {"attr": ["aff", "tag", "ack", " att", "ext", "str", "cap", "var", "adj", "tt", "md", "cmp", "tr", "vr", "ct", "rb", "b", "att", "atts", "wr", "temp", "r", "pr", "opt", "p", "arg", "rl", "req", "prop", "apt", "alt", "bar", "attribute", "stat", "gr", "rm", "emp", "kw", "arr", "rt", "rr", "tk", "aaa", "addr", "params", "dat", "msg", "acc", "t", "val", "rs", "rel", "args", "txt", "ak", "abl", "perm", "obj", "mt", "ptr", "tab", "tmp", "pkg", "imm", "alloc", "cmd", "err", "desc", "typ", "ctrl", "ev", "sort"], "ret": ["flag", "cat", "rets", " alt", "et", "Return", "nt", "re", "tr", "por", "att", "status", "r", "alt", "arg", "match", "ll", " Ret", "pas", "out", "l", "rm", "rev", "gt", "ft", "ter", "rt", "elt", "len", "bis", "ry", "Ret", "RET", "res", "t", "val", "print", "cont", "cert", "rs", "usr", "bool", "mt", " RET", "err", "xt", "result", "rem"], "cur_threads": ["cur_counteds", "cur_countes", "cur_counts", "cur_cteds", "cur_Threadeds", "cur_threadries", "cur_threadeds", "cur_countries", "cur_Threadries", "cur_ctes", "cur_Threades", "cur_ctries", "cur_Threads", "cur_cts", "cur_threades"], "idle_threads": ["idle_poolries", "idle_processs", "idle_pools", "idle_pooles", "idle_threades", "idle_Threads", "idle_processes", "idle_processries", "idle_threadries", "idle_processeds", "idle_Threades", "idle_Threadeds", "idle_pooleds", "idle_Threadries", "idle_threadeds"]}}
{"project": "FFmpeg", "commit_id": "52a213865670ae69c1852d4d04cf41f8929abbd0", "target": 0, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2534, "substitutes": {"st": ["s", "ist", "inst", "ack", "sth", "str", "ust", "nt", "et", "art", "src", "nd", "start", "th", "kt", "sn", "pt", "rest", "at", "est", "stable", "stream", "std", "sh", "stat", "stage", "St", "rt", "stan", "sc", "ste", "ost", "store", "sta", "set", "stop", "sts", "t", "state", "sb", "usr", "mt", "irst", "ub", "sw", "cast", "storage", "ST", "sp", "tx"], "pkt": ["rmsg", "paynt", " pnt", "appnt", "paykt", "wkt", "rkt", "wnt", " pct", " packet", " pKT", "rnt", "pet", "wct", "Pdu", "Pct", "pKT", "packet", "PKT", "cpmit", "appwk", "pct", "opnt", "opkt", " pmit", "Pnt", "cpnt", "cpkt", "Packet", "ppacket", "opacket", "Pwk", "ppet", "Pmsg", "appKT", "Pet", " pmsg", "ppkt", "cpacket", "racket", "pnt", "pdu", "payacket", "Pkt", "opmsg", "pmit", "paymit", " pdu", " pwk", "wdu", "pmsg", "appkt", "ppmsg", " pet", "ppnt", "pwk"], "desc": ["attr", "ext", "bl", "str", "sec", "seq", "nt", "cmp", "md", "sort", " Desc", "summary", "metadata", "dist", "comment", "dl", "rec", "buf", "description", "ec", "DES", "mem", "out", "dc", "disc", "esc", "name", "sc", "ribe", "data", "ds", "doc", "set", "msg", "meta", "dir", "cont", "txt", "text", "uc", "ript", "obj", "bd", "asc", "dict", "ptr", "des", "raw", "annot", "err", "cd", "label", "sub", "Desc"], "ret": ["nl", "rets", "sec", "nz", "nt", "Return", "re", "summary", "uf", "status", "lit", "r", "gc", "alt", "buf", "ll", " Ret", "mem", "fun", "rev", "gt", "arr", "ft", "len", "rt", "elt", "lt", "jp", "resp", "Ret", "RET", "res", "val", "rel", "cont", "ref", "txt", "mt", "ptr", "tmp", "des", "err", "xt", "j", "result", "rem"], "ast": ["ad", "ist", "aid", "each", "bound", "ab", "ust", "pat", "aster", "ait", "nt", "tt", "amb", "embed", "art", "dist", "ief", "nd", "at", "active", "aft", "AST", "rest", "anc", "asting", "ts", "am", "est", "wat", "asted", "esta", "std", "asm", "old", "mast", "must", "list", "Ast", "ctx", "ost", "af", "store", "past", "sta", "ac", "a", "addr", "amd", "ma", "master", "quest", "as", "ref", "act", "ard", "and", "mt", "ed", "cast", "interface", "ess", "ace", "aw", "annot", "tx", "bart", "acl", "ah", "asts"], "sub_demuxer": ["sub_demucer", "sub_demxier", "sub_demxed", "sub_demuxER", "sub_Demluxer", "sub_demuxers", "sub_promuxer", "sub_DemluxER", "sub_demuxier", "sub_demluxe", "sub_demxe", "sub_demluxer", "sub_promxer", "sub_demluxER", "sub_demxer", "sub_promxed", "sub_demluxie", "sub_demuce", "sub_Demuxe", "sub_demuploade", "sub_demluxed", "sub_DemuxER", "sub_Demuxer", "sub_demixer", "sub_Demuxers", "sub_demuxe", "sub_demxER", "sub_promxe", "sub_demucER", "sub_demluxers", "sub_demuxie", "sub_demluxier", "sub_promuxed", "sub_demuploaders", "sub_demixe", "sub_demuxed", "sub_Demluxe", "sub_demixed", "sub_promxie", "sub_promuxie", "sub_demxie", "sub_demuploader", "sub_Demluxers", "sub_demxers", "sub_demixie", "sub_promuxe", "sub_demucers", "sub_demuploadier"], "time_base": [" time2frame", "time_area", " time_area", "time_bas", "timepobas", "time2base", "timeporeal", " time_frame", " time_bas", " time2base", "timepopad", "time_real", " time_pad", "time_frame", " time_real", "time2frame", "timepobase", "time_pad", "time2bas", " time2bas"], "pb": ["ib", "proc", "bp", "tp", "fb", "ab", "kb", "bs", "pool", "np", "eb", "emb", "uf", "b", "rb", "td", "pt", "dp", "gc", "p", "mp", "py", "cp", "buf", "tap", "apa", "pc", "fp", "bc", "ap", "ob", "jp", "pp", "ctx", "lp", "tk", "cb", "PB", "gb", "nb", "lb", "px", "sb", "bb", "bj", "pg", "vp", "tc", "ub", "patch", "cv", "pkg", "tmp", "tf", "mb", "wp", "sp", "ptr", "tx", "tg", "stab", "buffer", "tab", "erb", "db", "pa"], "pd": [" td", "dq", "ad", "tp", "vd", " od", " sd", "pat", "np", "dh", "md", " df", "edd", "ud", "td", " dw", "d", "dl", "dp", "pr", " md", "p", "sd", "dj", "ps", "cp", "dx", "pc", " dd", "pard", "pi", "dd", "xd", " PD", "pp", "ctx", "df", "ds", "dt", " pdf", " dc", "pm", " cd", "pe", "dat", " prod", "DT", "fd", "vp", "bd", " np", "pdf", "ctl", "cd", "PD", "po"]}}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n", "idx": 2535, "substitutes": {"machine": ["proc", "dem", "Machine", "mc", "engine", "achine", "model", "channel", "one", "match", "parent", "shell", "STATE", "money", "template", "command", "power", "message", "me", "handler", "zone", "value", "server", "manager", "process", "state", "sm", "node", "table", "component", "monitor", "module", "agent", "policy", "vm", "sim", "domain", "m", "base", "instance"]}}
{"project": "qemu", "commit_id": "cc68890166c2c1c5003e3eeb8535e1872e239a95", "target": 0, "func": "static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd;\n\n    TCGv tmp, tmp2;\n\n\n\n    /* M profile cores use memory mapped registers instead of cp15.  */\n\n    if (arm_feature(env, ARM_FEATURE_M))\n\n\treturn 1;\n\n\n\n    if ((insn & (1 << 25)) == 0) {\n\n        if (insn & (1 << 20)) {\n\n            /* mrrc */\n\n            return 1;\n\n        }\n\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n\n        return 0;\n\n    }\n\n    if ((insn & (1 << 4)) == 0) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n\n        return 1;\n\n    }\n\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n\n        /* Wait for interrupt.  */\n\n        gen_set_pc_im(s->pc);\n\n        s->is_jmp = DISAS_WFI;\n\n        return 0;\n\n    }\n\n    rd = (insn >> 12) & 0xf;\n\n\n\n    if (cp15_tls_load_store(env, s, insn, rd))\n\n        return 0;\n\n\n\n    tmp2 = tcg_const_i32(insn);\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        tmp = new_tmp();\n\n        gen_helper_get_cp15(tmp, cpu_env, tmp2);\n\n        /* If the destination register is r15 then sets condition codes.  */\n\n        if (rd != 15)\n\n            store_reg(s, rd, tmp);\n\n        else\n\n            dead_tmp(tmp);\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        gen_helper_set_cp15(cpu_env, tmp2, tmp);\n\n        dead_tmp(tmp);\n\n        /* Normally we would always end the TB here, but Linux\n\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n\n                (insn & 0x0fff0fff) != 0x0e010f10)\n\n            gen_lookup_tb(s);\n\n    }\n\n    tcg_temp_free_i32(tmp2);\n\n    return 0;\n\n}\n", "idx": 2538, "substitutes": {"env": ["param", "esm", "Environment", "et", "eh", "erd", "eu", "nv", "w", "esp", "equ", "environment", "ec", "vt", "buf", "ve", "te", "window", "ens", "v", "context", "e", "eng", "conf", "g", "sc", "ctx", "EN", "en", "conn", "ds", "code", "server", "viron", "vs", "ener", "er", "state", "ner", "enc", "setup", "h", "dev", "cv", "hw", "net", "sp", "cmd", "config", "eve", "ah", "ev"], "s": ["n", "sg", "stats", "spec", "proc", "qs", "self", "ses", "services", "es", "b", "c", "m", "w", "r", "p", "ts", "its", "ps", "i", "gs", "v", "is", "sys", "e", "ss", "g", "tests", "sc", "ms", "ctx", "sv", "os", "ds", "a", "vs", "settings", "sts", "er", "rs", "ns", "t", "http", "args", "sb", "S", "ins", "state", "h", "sq", "cs", "sp", "hs", "js", "j"], "insn": ["alsne", "linsgn", "linso", "lsns", "inscan", "emsn", " insnor", "pinsn", "linsyn", "retso", "statsgn", "alsn", "inso", "rstn", "INSnor", "insner", "statsner", "lsgn", "ainsn", "insnm", "outsne", "linsnum", "emsnor", "Insns", "stssn", "argsyn", "linstn", "INSnr", "Inssn", "insyn", "ainssn", "emsnm", "intersnor", "factsn", "insnr", "lsn", "intersne", "Insn", "pinsnr", "stsgn", "linsner", "argsn", "linsN", "rssn", "lssn", "INSgn", "outsgn", " insns", "csne", "INScan", "insnw", "intsnor", "ipsdn", "insgn", "ipsnor", "insnor", "stsn", "INSdn", "intsnm", "INSnum", " inssn", "csn", " insne", "linsnr", "rsn", "argssn", "pinsnum", " insN", "Insgn", "factso", "ststn", "outsn", "ipscan", "statsn", "factsnw", "csgn", "insnum", "insns", "linsn", "instn", "linsne", "pinsgn", "emsne", "INSyn", "insN", "intsne", "Insner", "pinsN", "retssn", "intersn", "linsnw", "outsnm", "pinsne", "outssn", " insgn", "INSn", "argsgn", "valsnor", "alsgn", "inssn", "ainsne", "pinsns", " insnr", "insne", "retsnw", "outsnor", "linssn", "rsgn", "ipsn", "valscan", "insdn", "linsns", "valsn", "valsdn", "statssn", "retsn", "intsn", "interssn", "outsnr", "INSsn", "factssn", "ainsnor"], "rd": [" red", "nder", "cr", "lr", "ra", "rc", "ren", "rid", "fr", "md", "erd", "rb", "td", "nd", "d", "rh", "r", "ird", "ru", "rw", "rss", "rx", "std", "rf", "hr", "rm", "xd", "dd", "rt", "rn", "rob", "round", "rr", "ord", "mid", "rust", " r", "ring", "run", "ld", "sr", " d", "rat", "rs", "fd", "ard", "bd", "ptr", "dr", "dra", "rend", "red", "cd", "ri", "rod", "RD", "mr"], "tmp": ["tp", "cow", "tt", "cmp", "nt", " sp", "tr", "td", "cache", "cp", "rup", "v", "aaa", "resp", "txt", "etc", "ptr", "pkg", "dump", "gz", "rw", "buf", "st", "nom", "appy", "emp", "jp", "tn", " ret", "utm", "perm", "vp", " np", "tg", "term", "wx", "attr", "np", "new", "rb", " cached", "p", "ret", "tv", "mint", "out", "mm", "mk", "rt", "ctx", "msg", "nb", "tar", "tm", "cv", " mp", "sp", "result", " temp", "zip", " resp", "temp", "mp", "vt", "img", "mem", "trap", "csv", "t", "obj", "tc", "snap", "mb", "tem", "buff"], "tmp2": ["mpTwo", "temp8", "tmp8", "mp_", " tmpTwo", "mp5", "tmp3", " tmp8", "td3", "tmpTwo", "tmp5", "mp3", "temp4", "cmp3", "tmp1", "tmp4", "temp_", " tmp1", "td1", "cmp1", " tmp5", "mp1", "temp2", " tmp3", "mp8", "cmp2", "temp1", "td2", "tdTwo", "temp3", "tmp_", " tmp_", " tmp4", "mp2", "mp4", "cmp5"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n", "idx": 2564, "substitutes": {"id": ["tag", "ad", "aid", "wid", "ident", "rid", "vid", "uid", "d", "ID", "oid", "ip", " tid", " rid", "name", "mid", "key", "end", "sid", "h", "ids", "cmd", "kid", "pid", "db", "Id"], "backend": ["backended", "bookender", "Backender", "bookend", "backends", "frontend", "bookended", " backender", "booketh", " backended", " backEND", "backeth", "Backends", " backends", "frontends", "BackEND", "Backend", "Backended", "backEND", "frontended", " backeth", "Backeth", "frontEND", "backender"], "ret": ["read", "det", "rc", "et", "pet", "re", "att", "lit", "ut", "vt", "mem", "pub", "def", "rev", "rt", "reg", "resp", "RET", "Ret", "res", "t", "val", "etc", "mt", "des", "back", "unt"], "errp": ["erpa", "errjp", " errjp", " Errp", " errps", " Errr", " Errjp", "errpa", "erps", " errr", "Erpa", "errps", "erp", "Erp", "erP", "errr", "Erps", " Errpa", "Err", "errP", " errpa", "ErP", "Erjp", " errP"]}}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    int fd = -1, ret;\n\n    USBHostDevice *dev = NULL;\n\n    struct usbdevfs_connectinfo ci;\n\n    char buf[1024];\n\n    int bus_num, addr;\n\n    char product_name[PRODUCT_NAME_SZ];\n\n\n\n    dev = qemu_mallocz(sizeof(USBHostDevice));\n\n    if (!dev)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"usb_host_device_open %s\\n\", devname);\n\n#endif\n\n    if (usb_host_find_device(&bus_num, &addr,\n\n                             product_name, sizeof(product_name),\n\n                             devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buf, sizeof(buf), USBDEVFS_PATH \"/%03d/%03d\",\n\n             bus_num, addr);\n\n    fd = open(buf, O_RDWR | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        perror(buf);\n\n        return NULL;\n\n    }\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"usb_host_device_open: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++)\n\n            printf(\"%02x \", dev->descr[x]);\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n    dev->fd = fd;\n\n    dev->configuration = 1;\n\n\n\n    /* XXX - do something about initial configuration */\n\n    if (!usb_host_update_interfaces(dev, 1))\n\n        goto fail;\n\n\n\n    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    printf(\"host USB device %d.%d grabbed\\n\", bus_num, addr);\n\n#endif\n\n\n\n    ret = usb_linux_update_endp_table(dev);\n\n    if (ret)\n\n        goto fail;\n\n\n\n    if (ci.slow)\n\n        dev->dev.speed = USB_SPEED_LOW;\n\n    else\n\n        dev->dev.speed = USB_SPEED_HIGH;\n\n    dev->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    dev->dev.handle_reset = usb_host_handle_reset;\n\n    dev->dev.handle_control = usb_host_handle_control;\n\n    dev->dev.handle_data = usb_host_handle_data;\n\n    dev->dev.handle_destroy = usb_host_handle_destroy;\n\n\n\n    if (product_name[0] == '\\0')\n\n        snprintf(dev->dev.devname, sizeof(dev->dev.devname),\n\n                 \"host:%s\", devname);\n\n    else\n\n        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),\n\n                product_name);\n\n\n\n#ifdef USE_ASYNCIO\n\n    /* set up the signal handlers */\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigact.sa_sigaction = isoch_done;\n\n    sigact.sa_flags = SA_SIGINFO;\n\n    sigact.sa_restorer = 0;\n\n    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: sigaction failed\");\n\n        goto fail;\n\n    }\n\n\n\n    if (pipe(dev->pipe_fds) < 0) {\n\n        perror(\"usb_host_device_open: pipe creation failed\");\n\n        goto fail;\n\n    }\n\n    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n\n    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);\n\n    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);\n\n#endif\n\n    dev->urbs_ready = 0;\n\n    return (USBDevice *)dev;\n\nfail:\n\n    if (dev)\n\n        qemu_free(dev);\n\n    close(fd);\n\n    return NULL;\n\n}\n", "idx": 2583, "substitutes": {"usb_host_device_open": ["usb_host_dev__init", "usb_host_dev_open", "usb_host_device_Open", "usb_host_dev_close", "usb_host_dev__close", "usb_host_device__open", "usb_host_device2open", "usb_host_device2close", "usb_host_device__close", "usb_host_device_init", "usb_host_dev_init", "usb_host_device__init", "usb_host_dev_Open", "usb_host_device2init", "usb_host_device__Open", "usb_host_device_close", "usb_host_dev__Open", "usb_host_dev__open", "usb_host_device2Open"], "devname": ["evno", "devnames", "camname", "evlen", "evnames", "camNAME", "camnames", " devlen", "evNAME", "devicelen", "evname", "devName", "camName", "propname", " devstr", "propName", " devnames", " devNAME", "devlen", " devno", "devno", "devicename", " devName", "evstr", "propstr", "devstr", "evName", "deviceName", "devNAME", "propno"], "ret": ["flag", "failed", "nl", "del", "rets", "det", "pat", "get", "nt", "Return", "re", "tr", "not", "att", "status", "complete", "try", "alt", " Ret", "mem", "out", "valid", "fun", "fi", "def", "rm", "ft", "gt", "rt", "len", "elt", "fin", "reset", "url", "sat", "success", "resp", "Ret", "RET", "tif", "res", "t", "val", "rel", "cont", "cert", "ref", "txt", "usr", "mt", " RET", "ptr", "nat", "backed", "tmp", "net", "err", "cmd", "desc", "result", "got", "back", "rem"], "dev": ["dn", "nt", "normal", "tr", "td", " device", "av", "ve", "v", "dis", "port", "draw", "handle", "conn", "store", "go", "ov", "slave", "val", "tech", "home", "h", "ptr", "package", "hw", "cmd", "DEV", "scan", "priv", "test", "app", "var", "api", "di", "att", "util", "hd", "req", "pad", "window", "row", "dd", "def", "command", "cam", "master", "user", "wd", "ver", "debug", "des", " Dev", "add", "data", "ad", "pro", "attr", "eth", "build", "start", "Device", "controller", "sd", "out", "sys", "ow", "serial", "all", "develop", "den", "Dev", "disk", "tmp", "unknown", "ch", "alloc", "rem", "de", "proc", "cho", "form", "det", "dem", "final", "query", "self", "temp", "comment", "d", "w", "fo", "nav", "remote", "local", "mem", "sky", "sh", "disc", "conf", "driver", "link", "doc", "gu", "ev", "server", "end", "vo", "device", "obj", "bd", "sw", "cast", "raw", "err", "od", "env", "db"], "ci": ["wa", "cli", " sd", "cgi", "li", " cs", " c", "mc", "vi", "cfg", "c", " i", "di", "lc", "ia", " cf", "ii", "mi", "cu", "ki", " mc", "ni", "ati", " si", " sc", " mi", "cc", " pci", "i", "ai", "dc", "pi", "fi", "co", "cm", "ini", " di", " pi", "info", "iw", "ic", "ctx", " ti", "ami", " cc", " ii", "cci", "si", " dc", " cd", "aci", " vi", " ki", " ni", "ace", "CI", "cs", " nic", " ca", "vc", " circ", "ti", "icc", "ctrl", "io"], "buf": ["db", "proc", "fb", "eth", "str", "cap", "rc", "var", "np", "ff", "iter", "bytes", "batch", "uf", " buffers", "b", "rb", "func", "cur", " cmd", "path", "pb", "block", "w", "Buff", " buff", "map", "p", "rw", "cp", "img", "mem", "window", "cf", "bar", "def", "queue", "cam", "ctx", "xff", "br", "data", "doc", "code", "cb", "msg", " buffer", "vec", "font", "fd", "text", "txt", "ref", "filename", "cv", "ptr", "Buffer", "tmp", "pkg", "raw", "cmd", "desc", "err", "nm", "tx", "buffer", "buff", "priv", "tab", "result", "ah", "alloc"], "bus_num": ["bus2num", "bus2Num", " bus_no", " bus_number", "BUS_mon", "bus_Num", "bus2no", " bus_Num", "bus2number", "bus_name", "BUS_name", "bus_mon", " bus2Num", "bus_number", " bus2num", " bus2number", "bus_no", "BUS_number", "BUS_num"], "addr": ["ad", "ack", "attr", "eth", "nl", "ag", "var", "att", "src", "alt", "pad", "align", "ip", "mem", "offset", "Address", "dd", "rev", "len", "rt", "name", "ar", "ctx", "url", "ord", "ac", "adr", "arp", "store", "host", "a", "loc", "dir", "iat", "now", "rel", "ref", "order", "phys", "act", "alias", "ptr", "dr", "pkg", "hw", "mt", "address", "cmd", "add", "id", "tx", "mac", "pos", "alloc"], "product_name": [" product_Name", "device_names", "component_name", " product2data", "productnamepath", "component_type", " product2name", "component_number", "product_Name", "product2Name", "device_name", " product2Name", "product2path", "productNamedata", "productnamename", " product_data", "productNameName", "productNamepath", "device_Name", "product_names", "device_NAME", "product_path", "productNamename", "productnamedata", "product_number", "product_data", "product_NAME", "product_type", " product2path", "product2name", "productnameName", "product2data", " product_path"], "x": ["qu", "xxxxxxxx", "n", "wx", "xs", "axis", " y", " v", " X", " c", "xes", " dx", "batch", "ct", " i", "xxx", "any", "X", "ey", " k", " xx", "xy", "rx", "fx", "xxxx", "i", " n", " w", "ax", "xd", "xc", "\u00e7", "mx", "xi", "ctx", "xa", "mix", "key", "ix", "nex", " cx", "t", "px", " tx", "inx", "index", " ax", "xx", "ick", "ux", "lex", "y", "yx", "ox", "tx", "xt", "xp", "j", "dx", "ex"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 2594, "substitutes": {"env": ["em", "stack", "gov", "app", "En", "ew", "ep", "org", "erd", "eh", "engine", "entry", "enter", "Ev", "esp", "environment", "ec", "her", "te", "window", "v", "e", "context", "eng", "queue", "conf", "exc", "esc", "nc", "ctx", "EN", "sc", "en", "store", "conn", "code", "server", "viron", "ov", "vs", "pe", "er", "end", "set", "serv", "sb", "enc", "obj", "dev", "h", "hw", "eg", "vm", "ee", "desc", "ah", "ev"], "arg": ["tag", "param", "flag", "ag", "target", " targ", "uf", "grad", "b", "pb", "w", "og", "p", "fe", "out", "v", "bar", "argument", "field", "ax", "in", "gt", "arr", "g", " Arg", "reg", "ann", "ar", "conn", "ig", "arp", "doc", "it", "op", "args", "ref", "Arg", "obj", "f", "cmd", "fac", "tg", " larg"], "farg": ["uagg", "uflag", "Fparam", "floatargument", "fasc", "fdargument", "barp", "margument", "fberr", "vagg", " fArg", "Farg", "fargs", " ferr", "rfarp", "floatarg", "parp", "narg", "parg", "nflag", "marg", "Fargs", "rfarc", " fargs", "vflag", "fbarg", "pArg", "fargument", "fArg", "nagg", "pargument", "fenarp", "fdparam", "fdarp", "fbargument", "fagg", " farp", "ferr", "varp", "masc", "farp", " fparam", "fflag", "fenarg", "barg", "fdarg", "rfasc", "farc", "fcall", "narp", "fbcall", "fparam", "varg", "uarp", "floaterr", "fenarc", "rfarg", "bArg", "floatcall", "marp", "fenasc", "uarg", " fargument", "fdargs", "marc", "bargument", " fcall", "margs"], "f32": [" f48", "f40", "y31", "y64", "y34", "fac32", "float34", "float40", " f31", "fac48", " f64", "fac34", "float48", "f48", "floatlet", "float64", "float32", " f34", "f31", "fc32", " flet", "faclet", "fc64", "fac64", "fac40", "f64", "y32", "fc31", " f40", "fc34", "f34", "flet"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "int gen_new_label(void)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    int idx;\n\n    TCGLabel *l;\n\n\n\n    if (s->nb_labels >= TCG_MAX_LABELS)\n\n        tcg_abort();\n\n    idx = s->nb_labels++;\n\n    l = &s->labels[idx];\n\n    l->has_value = 0;\n\n    l->u.first_reloc = NULL;\n\n    return idx;\n\n}\n", "idx": 2602, "substitutes": {"s": ["n", "spec", "bs", "qs", "q", "comm", "es", "c", "p", "ts", "ps", "south", "gs", "sys", "x", "less", "ss", "g", "conf", "se", "ms", "ims", "ctx", "sv", "os", "conv", "sc", "fs", "ds", "space", "sts", "t", "ns", "sm", "rs", "sb", "S", "sw", "ess", "sq", "sl", "cs", "hs", "tx", "js"], "idx": ["Idx", "idexs", " idy", "idxs", "idix", "idy", " fidxs", "kidix", "idexc", "kidx", " idxc", "Idy", "uiddx", " idix", "kidxs", " idxs", "Idxc", "inddx", "Idix", "iddx", " idxes", "kidy", "idex", " fidix", "indx", "Idxs", "idxc", "indxs", "uidxs", " iddx", "uidxes", "indxes", "idxes", "idey", "uidx", " fidx", "indix"], "l": ["lam", "el", "nl", "lr", "li", "dL", "b", "c", "lu", "lc", "ls", "lit", "dl", "kl", "rl", "p", "la", "ell", "ll", "i", "v", "L", "u", "lin", "g", "tl", "lp", "al", "ld", "le", "lv", "lb", "t", "pl", "yl", "ol", "il", "sl", "ln", "lang", "ml", "label", "o", "j"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n", "idx": 2604, "substitutes": {"bs": ["s", "BS", "bp", "bi", "iss", "lbs", "b", "bps", "ls", "bh", "ts", "its", "bn", "gs", "sys", "bc", "bm", "ks", "ss", "aos", "bos", "ms", "ys", "bis", "fs", "ds", "vs", "rs", "ns", "irms", "bits", "sb", "bb", "cs", "js", "ubs", "ubis", "base", "aus"], "sector_num": ["sector_loc", "sectorationnumber", "sectorPnumber", "sectorPunit", "sector_mon", "sectorPtemp", "sector2number", "sector2num", "sector___number", "section_msg", "sector_msg", "ector_temp", "sectorPnum", " sector_number", " sector_mon", "sector_pos", "sector2dec", "sector5msg", " sector_dec", "sectoritynumber", "sector2mon", "sector___temp", "sector5number", "sector_number", "sector5loc", "sector_dec", "sector___unit", "sectoritymon", "sector5num", "sector___num", "section_loc", "ector_number", "sectoripmat", "sector_mat", "sectoripnum", "sector_temp", "sectorippos", "sectorationloc", "ector_num", "sectoritynum", "sector_unit", "sectoritydec", "section_number", "sectorationmsg", "section_num", "ector_mat", "sectorationnum", "ector_unit", "ector_pos", "sectoripnumber"], "nb_sectors": ["nb_pections", "nb_severs", "nb_secs", "nb_vecs", "nb_pectors", "nb_specs", "nb_vevers", "nb_spectors", "nb_sellers", "nb_psecs", "nb_pellers", "nb_nectors", "nb_pevers", "nb_sections", "nb_vections", "nb_spegments", "nb_nevers", "nb_pegments", "nb_spellers", "nb_vellers", "nb_psections", "nb_nellers", "nb_vectors", "nb_psevers", "nb_necs", "nb_pecs", "nb_psectors", "nb_segments", "nb_vegments"], "cluster_sector_num": ["cluster_section_info", "cluster_ector_num", "cluster_section_no", "cluster_sector___loc", "cluster_sector___mon", "cluster_sector___name", "cluster_sector___number", "cluster_ser_loc", "cluster_sector___net", "cluster_ector_n", "cluster_sector_info", "cluster_ser_num", "cluster_section_n", "cluster_ser_name", "cluster_ser_number", "cluster_sector_n", "cluster_sector_name", "cluster_sector_mon", "cluster_sector_loc", "cluster_sector_number", "cluster_sector___num", "cluster_sector_no", "cluster_sector_net", "cluster_ector_name", "cluster_sector___n", "cluster_ser_n", "cluster_ector_no", "cluster_sector___info", "cluster_section_num", "cluster_ser_mon", "cluster_sector___no", "cluster_ser_net"], "cluster_nb_sectors": ["cluster_nb2pecs", "cluster_nb_pectors", "cluster_nb2severs", "cluster_nb_segments", "cluster_nb2sectors", "cluster_nb_peors", "cluster_nb_neors", "cluster_nb_pegments", "cluster_nb_nectors", "cluster_nb_vecs", "cluster_nb_pevers", "cluster_nb2secs", "cluster_nb2pevers", "cluster_nb_severs", "cluster_nb_veors", "cluster_nb_negments", "cluster_nb_vectors", "cluster_nb2peors", "cluster_nb_vegments", "cluster_nb_pecs", "cluster_nb2seors", "cluster_nb_necs", "cluster_nb_secs", "cluster_nb2pectors", "cluster_nb_vevers", "cluster_nb_nevers", "cluster_nb_seors"], "bdi": ["bDi", "obinfo", "byadi", "bsi", "ldu", "abdi", " binfo", "badi", "bDI", " bidi", "ibDi", "obdi", "bydu", "obDI", "didi", "vidi", "ibidi", "byidi", "obci", "vsi", "absi", "bci", "abidi", "bgdu", "bgadi", "dDi", "fdi", "bgidi", "abDi", "finfo", "ldi", " bsi", "dci", "bgdi", "ddi", "fci", " bci", "ladi", "bidi", " bDI", "fDI", "bdu", "ibci", "ibdi", "bydi", "vDi", "binfo", "lidi", " bDi", "vdi"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 2620, "substitutes": {"cpu": ["proc", "core", "tp", "ork", "aco", "np", "nu", "CPU", "bench", "cu", "util", "gc", "uu", "cp", "pc", "ck", "linux", "jp", "xi", "ctx", "conn", "process", "apache", "hap", "pu", "phys", "hog", "clock", "setup", "gpu", "hw", "pkg", "mu", "processor", "pri", "cmd", "mac", "cum", "boot", "aq", "alloc"], "start1": [" startone", " start01", "Start0", "partone", " start2", "readOne", "Start2", "part01", " start0", "offsetOne", "stop01", "Start01", "read01", "stop2", "stop0", "Start1", "start0", "startone", " startOne", "offset1", "read1", "start01", "stop1", "partOne", "part1", "readone", "startOne", "start2"], "length": ["phi", "collection", "count", "ENGTH", "library", "duration", "angle", "capacity", "height", "frequency", "product", "type", "pad", "l", "offset", "number", "Length", "len", "ngth", "history", "idth", "limit", "position", "available", "enth", "full", "stop", "total", "size", "amount", "h", "depth", "shape", "padding", "buffer", "term", "ength", "sequence"], "env": ["db", "proc", "stack", "Environment", "np", "ew", "entity", "eh", "ef", "emb", "org", "engine", "eu", "nv", "pen", "rule", "cache", "equ", "environment", "ec", "buf", "vt", "her", "wall", "req", "te", "window", "mem", "v", "ens", "context", "e", "eng", "ob", "oe", "here", "menu", "EN", "en", "conn", "scope", "doc", "code", "end", "viron", "vs", "pe", "den", "qa", "gear", "door", "state", "node", "txt", "order", "ner", "disk", "uv", "ent", "dev", "obj", "desc", "ee", "global", "buffer", "config", "ah", "ev"], "mmu_idx": ["mmu_randi", "mmu_Idix", "mmu_idsix", "mmu_Idxes", "mmu_uidx", "mmu_dei", "mmu_sidexc", "mmu_indy", "mmu7idx", "mmu_indxs", "mmu_needix", "mmu_partxc", "mmu_idxs", "mmu_identxes", "mmu_idsex", "mmu_ridix", "mmu_uiddx", "mmu7iddx", "mmu_randdx", "mmu_idex", "mmu_idsx", "mmu_ridx", "mmu_sidew", "mmu_den", "mmu_randx", "mmu7dedx", "mmu_needx", "mmu_Idex", "mmu_identw", "mmu_uidn", "mmu_identx", "mmu_idy", "mmu_ideix", "mmu_idez", "mmu_dedx", "mmu_idxc", "mmu7den", "mmu_idz", "mmu_sidexes", "mmu_indx", "mmu_sidex", "mmu_Idy", "mmu_idxes", "mmu_idsy", "mmu_ridz", "mmu7idi", "mmu_idn", "mmu_partx", "mmu_Idxs", "mmu_index", "mmu_randn", "mmu7dei", "mmu_idexs", "mmu_partw", "mmu_idw", "mmu_ridxs", "mmu7idn", "mmu_idsxs", "mmu_iddx", "mmu_Idx", "mmu_partxes", "mmu_dex", "mmu_needxes", "mmu_Idz", "mmu_idix", "mmu7dex", "mmu_idi", "mmu_identxc", "mmu_uidi", "mmu_needxs"], "i": ["phi", "iu", "I", "oi", "spec", "bi", "cli", "init", "li", "php", "q", "ui", "b", "di", "series", "ii", "im", "mi", "uri", "ki", "ni", "remote", "p", "MI", "\u0438", "parent", "ind", "ip", "is", "ai", "v", "ity", "ei", "x", "pi", "fi", "ri", "in", "ini", " di", "zi", "info", "ic", "ims", "qi", "xi", "me", "g", "ami", " ii", "it", "si", "gu", "ix", "iq", "to", "ci", "print", "multi", "y", "dr", "f", "dim", "ti", "sim", "gi", "chain", "m", "j", "client", "ex"]}}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 2622, "substitutes": {"s": ["sam", "bs", "es", "b", "c", "ares", "ls", "ssl", "sn", "p", "ts", "ps", "i", "gs", "v", "sys", "less", "ss", "space", "sv", "fs", "ds", "sts", "ats", "t", "rs", "ns", "sb", "S", "sl", "sq", "cs", "sp", "hs", "js", "aws", "sa", "j"], "rule": ["tag", "test", "spec", "ase", "proc", "ULE", "reason", "fr", "record", "event", "filter", "re", "sche", "section", "style", "comment", "error", "entry", "block", "trigger", "r", "rec", "rl", "match", "decl", "route", "row", "offset", "require", "callback", "condition", "parse", "co", "command", "def", "se", "ror", "file", "handler", "group", "rr", "link", "key", "run", "statement", "pe", "when", "state", "node", "order", "call", "ule", "module", "feature", "role", "policy", "ace", "option", "request", "rules", "Rule", "range", "chain", "config", "function", "line"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624, "substitutes": {"dev": ["de", "ad", "db", "proc", "pro", "spec", "dem", "nt", "md", "devices", "d", "w", "usb", "Device", "p", "sd", "buf", "pad", "ve", "mem", "window", "v", "sys", "dd", "def", "conf", "cam", "ctx", "conn", "go", "adv", "Dev", "serv", "device", "ver", "wd", "disk", "obj", "hw", "des", "DEV", "scan", "priv", "ev"], "s": ["sam", "n", "spec", "stats", "qs", "self", "ses", "comm", "services", "es", "b", "c", "ls", "d", "ast", "w", "r", "p", "ts", "sd", "ps", "i", "l", "gs", "is", "v", "e", "less", "ss", "ims", "ms", "sis", "sv", "os", "fs", "ds", "a", "sts", "params", "rs", "ns", "t", "args", "sb", "S", "session", "h", "sl", "sq", "ess", "f", "sp", "hs", "js", "aws", "m", "j"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n", "idx": 2628, "substitutes": {"s": ["n", "qs", "self", "ses", "es", "b", "c", "w", "r", "p", "ts", "ps", "i", "is", "v", "gs", "sys", "x", "sync", "ss", "g", "se", "ms", "sc", "os", "fs", "ds", "set", "sts", "t", "ns", "rs", "sm", "sb", "S", "h", "y", "sw", "us", "sq", "z", "cs", "sp", "hs", "js", "ex"], "ret": ["flag", "nl", "cat", "rets", "rc", "nt", "q", "re", "tr", "ct", "att", "status", "lit", "d", "r", "ts", "alt", " Ret", "l", "mem", "out", "std", "st", "sys", "aux", "def", "rev", "gt", "ft", "g", "rt", "reg", "len", "reset", "al", "ry", "ld", "resp", "Ret", "RET", "res", "t", "val", "ref", "usr", "mt", " RET", "dr", "ptr", "err", "red", " def", "j", "result"], "arg": ["param", "bug", "target", "r", "v", "deg", "par", "al", "arp", "alg", "val", "Arg", "lag", "cmd", "prop", "var", " targ", "at", "alt", "argument", "x", "ax", "gt", "jp", "num", " op", "ig", "loc", " ag", "pl", "agg", " args", "j", "ad", "tag", "attr", " argument", "emb", "p", "inter", "l", "out", "mm", "good", "field", "reg", "ar", "addr", "op", "args", "usr", "asc", "mac", "ok", " larg", "ack", "flag", "ag", "sec", "opt", "local", " reg", "mem", "parse", " flag", "in", "arr", "g", " Arg", "doc", "t", "ref", "act", "pg", "call", "f"]}}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "int xen_config_dev_blk(DriveInfo *disk)\n\n{\n\n    char fe[256], be[256];\n\n    int vdev = 202 * 256 + 16 * disk->unit;\n\n    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;\n\n    const char *devtype = cdrom ? \"cdrom\" : \"disk\";\n\n    const char *mode    = cdrom ? \"r\"     : \"w\";\n\n\n\n    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),\n\n\t     \"xvd%c\", 'a' + disk->unit);\n\n    xen_be_printf(NULL, 1, \"config disk %d [%s]: %s\\n\",\n\n                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);\n\n    xen_config_dev_dirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe));\n\n\n\n    /* frontend */\n\n    xenstore_write_int(fe, \"virtual-device\",  vdev);\n\n    xenstore_write_str(fe, \"device-type\",     devtype);\n\n\n\n    /* backend */\n\n    xenstore_write_str(be, \"dev\",             disk->bdrv->device_name);\n\n    xenstore_write_str(be, \"type\",            \"file\");\n\n    xenstore_write_str(be, \"params\",          disk->bdrv->filename);\n\n    xenstore_write_str(be, \"mode\",            mode);\n\n\n\n    /* common stuff */\n\n    return xen_config_dev_all(fe, be);\n\n}\n", "idx": 2632, "substitutes": {"disk": ["core", "display", "upload", "definition", "sync", "dis", "grid", "draw", "ds", "delete", "part", "docker", "transfer", "hard", "ank", "pread", "boot", "directory", "raid", "wk", "req", "band", "license", "dd", "def", "power", "file", "pick", "wd", "pack", "Disk", "github", "config", "vol", "isk", "vd", "cell", "yard", "dl", "p", "mm", "sys", "download", "info", "df", "draft", "dir", "node", "bank", "drive", "policy", "fork", "service", "spec", "work", "pd", "diff", "volume", "d", "cdn", "local", "check", "sky", "disc", "pi", "in", "image", "network", "link", "cloud", "load", "device", "dev", "pdf", "storage"], "fe": ["de", "fm", "au", "fb", "ces", "que", "ale", "eb", "fr", "ly", "fle", "eu", "ped", "Fe", "fine", "ve", "te", "ge", "eeee", "e", "ane", "fi", "bf", "oe", "vre", "bee", "ele", "fc", "se", "me", "fer", "ft", "ene", "ige", "ne", " me", "pe", "ae", "fee", "ce", "FE", "le", "ume", "ue", "ffe", "ie", "we", "ace", "ze", "eg", "f", "ife", "fre", " pe", "ee", "xe", "che", "wen", " Fe"], "be": ["de", "ode", "ome", "bi", "Be", "bl", "use", "eb", "ere", "re", "sche", "ly", "BE", "b", "com", "ble", "ber", "by", "ot", "try", "he", "one", "ut", "are", "ize", "ve", "te", "ge", "ck", "ote", "une", "mes", "ane", "e", "ute", "ob", "ke", "oe", "bf", "abe", "eng", "co", "se", "me", "ne", "en", "br", "it", "ade", "ape", "pe", "le", "ce", "ae", "bc", "ate", "ue", "bb", "ube", "we", "st", "ze", "ee", "stab", "che", "ser", "bo", "db", "ide", "bes"], "devtype": ["devType", "evType", "evtype", "devtyp", "developtyp", "developname", " devtyp", "avname", " devname", " devType", "developkind", "evname", "evkind", "developtype", "devkind", "avtype", "avype", "devype", " devkind", "devname", "avType", "evype", "evtyp", " devype"], "mode": ["de", "test", "pro", "attr", "time", "md", "mask", "metadata", "status", "path", "mod", "type", "mem", "te", "mm", "sex", "format", "command", "power", "direction", "me", "MODE", "name", "driver", "force", "key", "pe", "device", "perm", "size", "filename", "module", "dev", "role", "option", "cmd", "Mode", "m", "data", "rol"]}}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  int search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, k;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->ppc = pc_start;\n\n    dc->pc = pc_start;\n\n    dc->flags = cpu->env.cpucfgr;\n\n    dc->mem_idx = cpu_mmu_index(&cpu->env);\n\n    dc->synced_flags = dc->tb_flags = tb->flags;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"-----------------------------------------\\n\");\n\n        log_cpu_state(CPU(cpu), 0);\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    k = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_tb_start();\n\n\n\n    do {\n\n        check_breakpoint(cpu, dc);\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (k < j) {\n\n                k++;\n\n                while (k < j) {\n\n                    tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[k] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[k] = 1;\n\n            tcg_ctx.gen_opc_icount[k] = num_insns;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc->pc);\n\n        }\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n        dc->ppc = dc->pc - 4;\n\n        dc->npc = dc->pc + 4;\n\n        tcg_gen_movi_tl(cpu_ppc, dc->ppc);\n\n        tcg_gen_movi_tl(cpu_npc, dc->npc);\n\n        disas_openrisc_insn(dc, cpu);\n\n        dc->pc = dc->npc;\n\n        num_insns++;\n\n        /* delay slot */\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                dc->tb_flags &= ~D_FLAG;\n\n                gen_sync_flags(dc);\n\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n\n                tcg_gen_movi_tl(jmp_pc, 0);\n\n                tcg_gen_exit_tb(0);\n\n                dc->is_jmp = DISAS_JUMP;\n\n                break;\n\n            }\n\n        }\n\n    } while (!dc->is_jmp\n\n             && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n             && !cs->singlestep_enabled\n\n             && !singlestep\n\n             && (dc->pc < next_page_start)\n\n             && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    }\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        gen_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n            break;\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        k++;\n\n        while (k <= j) {\n\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 2634, "substitutes": {"cpu": ["proc", "core", "tp", "cli", "gnu", "pool", "uci", "aco", "np", "ilo", "library", "cmp", "nu", "c", "CPU", "cu", "util", "gc", "kernel", "cp", "cc", "pc", "ck", "onet", "sys", "chip", "linux", "jp", "cpp", "nc", "cam", "conn", "rpm", "process", "device", "pu", "phys", "clock", "gpu", "hw", "pkg", " CPU", "mu", "processor", "phy", "net", "vm", "ctl", "cmd", "mac", "cum", "ola", "boot", "nic", "alloc", "rom"], "tb": ["ptbl", "tobi", "treepb", "outbl", "tp", "tba", " tpb", "tbf", "ttbl", "treefb", "tbi", " tba", " tfb", "treeb", "itxb", "ppb", "outbe", "tbl", "ptob", "timfb", "pxb", "pb", "ttb", "portbf", "ptbi", " txb", "treebt", " tbi", "ttba", "Tbl", "ptbf", "timbi", " tbe", "timbf", "timba", "tobl", " tbt", "toba", "timbl", "Tb", "portp", "txb", "itb", "Tob", "outpb", "pbl", "itbl", "portb", "ptb", "tfb", "itpb", "timp", "tob", "tbe", "timbt", "tpb", "portbi", "timpb", "Tba", "timb", "ttob", "ptp", " tbl", "outb", "itbe", "ptba", "tbt"], "search_pc": ["searchablepb", "find_pb", "search___pb", "search___bc", " search_pb", " search_bc", "search__pc", "search__pb", "search_bc", "find_mc", "search__PC", "find_pc", "search_PC", "searchablebc", "search___cc", "search_mc", "searchablepc", "search_pb", "search___pc", "find_PC", "search__mc", " search_cc", "searchablecc", "search_cc"], "cs": ["CS", "mc", "cmp", "c", "lc", "ls", "sk", "cu", "ts", "cc", "cp", "ps", "ec", "cons", "pc", "ck", "sys", "ks", "cks", "fc", "nc", "sc", "fs", "ds", "acs", "wcs", "sts", "ci", "ns", "rs", "tc", "cus", "caps", "vc", "js", "cas", "css"], "ctx": [" td", "xs", "np", " context", "cmp", "ct", "c", "ca", "lc", "d", "cu", "dl", "gc", "cp", "cc", "parent", "pc", "cf", "gs", "sys", "context", "cm", "cn", "jac", "kw", "fc", "nc", "doc", " cc", "tk", " cx", "t", "ns", "abc", "txt", "unc", "obj", "tc", "cv", "pkg", "cmd", "tx", " ca", "css"], "dc": ["cca", "design", "cr", "cat", "rc", "nz", "mc", "central", "cfg", "c", "di", "lc", "ca", "td", "comment", "d", "currency", "dl", "dp", "rec", "drm", "gc", "cc", "ec", "pc", "ga", "mm", "bc", "disc", "cm", "dd", "def", "kw", "cn", "fc", "nc", "sc", "document", "draw", "cam", "df", "ac", "doc", "ds", "dt", "dat", "dir", "docker", "da", "tc", "dr", "DC", "wp", "ctl", "desc", "cd", "acl", "mac", "css", "dim", "db"], "gen_opc_end": ["gen_opc__start", "gen_opc__end", "gen_opc_start", "gen_opf_max", "gen_opc__max", "gen_opf_start", "gen_opc__ends", "gen_opc_ends", "gen_opf_ends", "gen_opc_max", "gen_opf_stop", "gen_opf_end", "gen_opc_stop"], "pc_start": ["pc2begin", "pc00start", "pc2stop", "pc_add", " pc00start", "pc_stop", "pc2offset", "cp2end", "cp_start", "pc00save", "tc_end", "cp_offset", "cp2start", "PC_end", "PC_start", "pc2start", " pc00end", " pc_add", "cp_end", "pc2index", "pc_index", "tc_start", " pc00save", "pc_end", "pc_begin", "pc_offset", " pc_save", "cp_index", " pc_end", "pc_save", "cp2offset", "tc_art", "pc00end", "PC_begin", "PC_stop", "pc_art", "cp2index", "pc2end"], "j": ["uj", "n", "gov", "adj", "q", "jump", "job", "start", "d", "im", "p", "max", "dj", "ji", "i", "l", "ja", "v", "ij", "x", "jj", "jp", "g", "ek", "shift", "ju", "it", "jit", "kj", "si", "aj", "t", "ak", "h", "y", "z", "sp", "json", "jl", "js", "kid", "ch", "J", "o", "pos"], "k": ["wk", "n", "ack", "ijk", "K", "q", "kk", "ka", "ikk", "c", "kr", "sk", "ark", "km", "kt", "ki", "kl", "p", "unk", "i", "kan", "dk", "tek", "ck", "mk", "jj", "ke", "ks", "kw", "kind", "g", "ik", "ek", "kick", "kn", "ask", "key", "ko", "tk", "kj", "kh", "uk", "t", "ak", "kid", "m", "ku", "isk"], "next_page_start": ["next_page_size", "next_Page_end", "next_Page_point", "next_Page_size", "next_page_top", "next_pageibtop", "next_pageixsize", "next_pageibend", "next_page_end", "next_pages_size", "next_pageixpoint", "next_pages_start", "next_pageibsize", "next_pageixend", "next_Page_start", "next_pages_top", "next_pageibstart", "next_pageixstart", "next_pages_end", "next_page_point"], "num_insns": ["num_psans", "num_minsnz", "num_inn", "num_psns", "num_invs", "num_outsnz", "num_innz", "num_outsn", "num_minsvs", "num_insn", "num_psn", "num_inamples", "num_insamples", "num_pinsn", "num_insvs", "num_outsns", "num_outsvs", "num_pinsans", "num_insnz", "num_insans", "num_inns", "num_inans", "num_pinsns", "num_psamples", "num_minsns", "num_minsn", "num_pinsamples"], "max_insns": ["max_inscs", "max_inps", "max_inns", "max_inn", "max_ainscs", "max_initni", "max_incs", "max_initns", "max_isinn", "max_ainsni", "max_isinys", "max_conys", "max_conps", "max_ainsons", "max_inons", "max_incns", "max_insims", "max_inims", "max_incn", "max_inys", "max_linsons", "max_initn", "max_inccs", "max_conns", "max_conn", "max_ainsims", "max_isinps", "max_insons", "max_initcs", "max_ainsn", "max_linscs", "max_inni", "max_isinns", "max_incims", "max_linsn", "max_ainsns", "max_insps", "max_insni", "max_insn", "max_linsns", "max_insys"], "delayed_branch": ["delayed_blanches", "delayed_brag", "delayed_drag", "delayed_blag", "delayed_broag", "delayed_broanches", "delayed_blranch", "delayed_drranch", "delayed_dranch", "delayed_brranch", "delayed_blanch", "delayed_broanch", "delayed_broranch", "delayed_dranches", "delayed_branches"]}}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    IVShmemState *s = IVSHMEM(dev);\n\n    Error *err = NULL;\n\n    uint8_t *pci_conf;\n\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\n\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n\n        error_setg(errp,\n\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n\n        return;\n\n    }\n\n\n\n    if (s->hostmem) {\n\n        MemoryRegion *mr;\n\n\n\n        if (s->sizearg) {\n\n            g_warning(\"size argument ignored with hostmem\");\n\n        }\n\n\n\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n\n        s->ivshmem_size = memory_region_size(mr);\n\n    } else if (s->sizearg == NULL) {\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    } else {\n\n        char *end;\n\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n\n            return;\n\n        }\n\n        s->ivshmem_size = size;\n\n    }\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n\n        return;\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n\n            return;\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    pci_conf = dev->config;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n\n\n    /*\n\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n\n     * bald-faced lie then.  But it's a backwards compatible lie.\n\n     */\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n\n\n\n    /* region for registers*/\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &s->ivshmem_mmio);\n\n\n\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n\n    if (s->ivshmem_64bit) {\n\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    }\n\n\n\n    if (s->hostmem != NULL) {\n\n        MemoryRegion *mr;\n\n\n\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n\n\n\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n\n                                            &error_abort);\n\n        vmstate_register_ram(mr, DEVICE(s));\n\n        memory_region_add_subregion(&s->bar, 0, mr);\n\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n\n    } else if (s->server_chr != NULL) {\n\n        /* FIXME do not rely on what chr drivers put into filename */\n\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n\n            error_setg(errp, \"chardev is not a unix client socket\");\n\n            return;\n\n        }\n\n\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                        s->server_chr->filename);\n\n\n\n        if (ivshmem_setup_interrupts(s) < 0) {\n\n            error_setg(errp, \"failed to initialize interrupts\");\n\n            return;\n\n        }\n\n\n\n        /* we allocate enough space for 16 peers and grow as needed */\n\n        resize_peers(s, 16);\n\n        s->vm_id = -1;\n\n\n\n        pci_register_bar(dev, 2, attr, &s->bar);\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n\n                              ivshmem_check_version, NULL, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                error_report(\"could not truncate shared file\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            error_setg(errp, \"could not open shared file\");\n\n            return;\n\n        }\n\n\n\n        if (check_shm_size(s, fd, errp) == -1) {\n\n            return;\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd, attr, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker);\n\n    }\n\n}\n", "idx": 2649, "substitutes": {"dev": ["de", "ad", "test", "spec", "pro", "dem", "vr", "devices", "w", "usb", "Device", "p", "sd", "pad", "iv", "ve", "mem", "v", "def", "conf", "cam", "conn", "serial", "server", "er", "adv", "Dev", "serv", "device", "ver", "vp", "ptr", "hw", "des", "env", "phy", "cmd", "DEV", "scan", "priv", "ev"], "errp": ["arrp", "arrpb", "derpa", "ererping", "errpre", "nernp", "derpb", "privp", "privP", "derp", "nersp", "ererP", "errpa", "dangerp", "errping", "errpb", "ererpa", "ererp", "dangernp", "arrpa", "errorper", "eorper", "nerp", "dernp", "errpat", "ererwp", "errorpre", "errorpat", "eorpoint", "eorpat", "eorping", "dangerper", "dangerpoint", "nerper", "eorp", "dangerpat", "errnp", "privpa", "errpoint", "errorp", "eorpre", "errorpoint", "arrping", " errpre", " errwp", " errper", "errP", "derping", "dangersp", "privwp", " errpa", "dangerping", "errsp", "dersp", "errper", "derper", "errorping", " errP", "errwp", "ererpb"], "s": ["n", "services", "r", "is", "v", "ops", "store", "fs", "ds", "eps", "gets", "bits", "sb", "h", "y", "hs", "cmd", "sports", "bs", "ses", "c", "status", "ims", "sv", "os", "vs", "sts", "ats", "des", "details", "has", "ports", "qs", "his", "p", "sd", "ps", "l", "sys", "less", "ss", "tests", "ms", "set", "params", "args", "rates", "sl", "mods", "aunts", "m", "ex", "sam", "spec", "stats", "xs", "self", "sym", "comm", "results", "es", "b", "ls", "d", "w", "als", "ts", "its", "changes", "gs", "source", "settings", "rs", "t", "ns", "ins", "S", "sw", "cs", "js", "aws"], "err": ["cr", "attr", "iter", "gz", "cfg", "error", "kr", "cur", "r", "buf", "ec", "Error", "sys", "arr", "conf", "exc", "rr", "br", "cb", "der", "er", "msg", "resp", "fee", "usr", "obj", "Er", "ev"], "pci_conf": ["pci2info", "pci__conf", "pci_cfg", "pdi__", "pci2conf", "pci_info", "pci__", "pci__cfg", "ppi_cfg", "pci2cfg", "ppi_info", "pci_Conf", "pci2Conf", "ppi_conf", "pci__info", "pci__Conf", "ppi_Conf", "pci___"], "mr": ["cr", "lr", "rar", "mc", "mir", "wm", "tr", "vr", "kr", "rg", "rh", "r", "pr", "rl", "rw", "hr", "gr", "cm", "bm", "rm", "ocr", "rn", "MR", "mn", "rr", "Mr", "br", "adr", "mid", "sr", "rs", "usr", "tm", "shr", "mt", "dr", "mor", "ml", "gm", "m"], "end": ["END", "ext", "pend", "use", "length", "post", "c", "End", "nd", "start", "export", "dest", "w", "p", "max", "ended", "buf", "est", "except", "window", "send", "v", "offset", "st", "e", "eng", "format", "append", "len", "port", "en", "ending", "set", "stop", "last", "edge", "size", "enc", "begin", "ent", "h", "z", "env", "add", "id", "close", "event", "term"]}}
{"project": "qemu", "commit_id": "ab2b9f174db088633922eaa82c2bcffd84e6bb94", "target": 1, "func": "int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)\n\n{\n\n    fprintf_function fprintf_fn = info->fprintf_func;\n\n    void *stream = info->stream;\n\n    int rc;\n\n    uint8_t insn[4];\n\n    const Lm32OpcodeInfo *opc_info;\n\n    uint32_t op;\n\n    const char *args_fmt;\n\n\n\n    rc = info->read_memory_func(memaddr, insn, 4, info);\n\n    if (rc != 0) {\n\n        info->memory_error_func(rc, memaddr, info);\n\n        return -1;\n\n    }\n\n\n\n    fprintf_fn(stream, \"%02x %02x %02x %02x    \",\n\n            insn[0], insn[1], insn[2], insn[3]);\n\n\n\n    op = bfd_getb32(insn);\n\n    opc_info = find_opcode_info(op);\n\n    if (opc_info) {\n\n        fprintf_fn(stream, \"%-8s \", opc_info->name);\n\n        args_fmt = opc_info->args_fmt;\n\n        while (args_fmt && *args_fmt) {\n\n            if (*args_fmt == '%') {\n\n                switch (*(++args_fmt)) {\n\n                case '0': {\n\n                    uint8_t r0;\n\n                    const char *r0_name;\n\n                    r0 = (op >> 21) & 0x1f;\n\n                    r0_name = find_reg_info(r0)->name;\n\n                    fprintf_fn(stream, \"%s\", r0_name);\n\n                    break;\n\n                }\n\n                case '1': {\n\n                    uint8_t r1;\n\n                    const char *r1_name;\n\n                    r1 = (op >> 16) & 0x1f;\n\n                    r1_name = find_reg_info(r1)->name;\n\n                    fprintf_fn(stream, \"%s\", r1_name);\n\n                    break;\n\n                }\n\n                case '2': {\n\n                    uint8_t r2;\n\n                    const char *r2_name;\n\n                    r2 = (op >> 11) & 0x1f;\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n", "idx": 2656, "substitutes": {"memaddr": [" memadr", "mtptr", " memoryaddress", "Memnr", "memoryptr", " memoryaddr", "memaddress", "Memaddr", " memnr", "mtaddress", "Memaddress", "mtaddr", "memoryaddr", "memptr", " memorynr", " memptr", "Memptr", "memadr", "memoryaddress", "mtadr", "Memadr", "memnr", " memaddress"], "info": ["Info", "core", "init", "time", "INFO", "warning", "help", "summary", "options", "comment", "error", "status", "start", "about", "entry", "fo", "try", "map", "local", "check", "type", "description", "i", " Info", " error", "good", "fi", "kind", "def", "list", "conf", "image", " INFO", "name", "file", "source", "history", "link", "information", "doc", "success", "code", "report", "isu", "state", "inf", "http", "order", "index", "ref", "size", " inf", "transfer", "f", "follow", "details", "id", "import", "ok", "event", "always", "data", "save", "ro", "io"], "stream": ["s", "transform", "stack", "pipe", "ack", "hook", "view", "str", "each", "form", "pool", "time", "iter", "filter", "target", "metadata", "response", "src", "path", "flash", "steam", "block", "clean", "speed", "ream", "warn", "loop", "our", "window", "row", "v", "Stream", "accept", "REAM", "ous", "context", "sync", "message", "sc", "seek", "source", "round", "os", "history", "draw", "store", "trans", "conv", "host", "load", "http", "user", "runtime", "enc", "sw", "progress", "track", "console", "send", "import", "chain", "buffer", "ok", "iterator", "line"], "rc": ["ack", " cur", "rar", " src", " err", " hr", "usc", "cmp", "roc", "rd", "rb", "cur", "src", "r", "rec", " init", " sc", "rl", "cc", "gc", "ec", "rx", " ip", "pc", "row", "ck", " enc", "rate", " cont", " rot", " sr", "co", "bc", "dc", "rt", "ror", "rn", "rob", "rr", "xff", "ac", " ov", "ry", "cb", " ans", "rin", " alloc", "loc", "rs", " rec", "ro", "arc", " proc", " ro", "uc", " ac", " cr", " exc", "rac", "err", " co", "irc", "cd", " succ", "ctr", "desc", "auc", "priv", "con", "RC", "nr"], "insn": ["minsnan", "vsnw", " insnor", " insp", " insna", "umsn", "pluginsnor", " insnw", "pluginssn", "linsnat", "itsns", "istssn", "ainsnat", "apsnote", "apsnat", "Insp", "insnm", "ainsn", "pointsnan", "insp", "vsp", "Insns", "ainssn", "pointsnor", "insna", "insnote", "itsp", "umsd", "linsnm", "pssn", "Insn", " insnat", "vsnm", "ainsnote", " insnm", "psnat", " insns", "presnote", "insnw", "Insna", "apsn", "presnan", "insnor", "minsn", " inssn", "pointssn", "umsnat", "presn", "istsnat", " insnan", " insnote", "psn", "insns", "pluginsnat", "pressn", "linsn", "minsnote", "pluginsn", "vsn", "itsna", "minsnat", "presnat", "psd", "linsnw", "apsnan", "linsp", "inssn", "insnat", "linssn", "linsd", "insd", "istsnote", "umssn", "itsn", "pointsn", "insnan", "istsn", "pluginsnan"], "opc_info": ["opc___details", "opcode_fo", "opc_details", "opc2fo", "opc__info", "opc___inf", "opc___Info", "opc2name", "opcode_details", "oppc___history", "opcode_check", "opcode_info", "opcache_fo", "oppc_history", "opcode_Info", "oppc___info", "oppc___inf", "opc_fo", "opcache_info", "opc_history", "opc_INFO", "opc__inf", "opc_iter", "opc_check", "opc_Info", "opcache_INFO", "opcode_iter", "opc___history", "opcache_name", "opc___INFO", "opc___info", "opc__history", "opc_name", "opc_inf", "opcode_INFO", "oppc_inf", "oppc_info", "opc2info", "opc2INFO"], "op": ["tp", " rep", "iter", "Op", " Op", "cmp", " sp", "oop", " p", "pr", "r", "cp", "deep", "ops", "oper", "opl", "o", "push", "it", "cmd", "top", "ope", "init", "var", " operation", "post", "at", "comp", "pc", "jp", "bit", " _", "hop", "expr", "operator", " pop", "pre", "typ", " x", "j", "omp", "cat", "im", "oc", "p", "arg", " ip", "ip", "out", "ap", "pp", "code", "msg", " ops", " oper", "sp", "ok", "ack", "stack", "up", "item", "block", "opt", " cp", "mp", "inc", "ob", " typ", "operation", "opp", "prev", "obj", " OP", "update", "OP"], "args_fmt": ["args_dmt", "args_expntax", "args_jformat", "args2mntax", "args_lmid", "args_factx", "args_vmt", "args_fstyle", "args_vMT", "args_mfm", "args_fmlt", "args_cmn", "args_exptm", "args_jmt", "args_xmt", "args_mntax", "args_xmm", "args2vmt", "args_Fmm", "args2vformat", "args2fld", "args_lmt", "args_flfm", "args_vtm", "args2fformat", "args_rformat", "args_faclt", "args2vtype", "args_vmn", "args2Flt", "args_vformat", "args_fformat", "args_jfm", "args_rmt", "args2fMT", "args_fmn", "args_fld", "args_fmmt", "args_vtype", "args_fntax", "args_flt", "args2Fmt", "args_cMT", "args2fntax", "args_Ftx", "args2Fld", "args_Ffm", "args_Flt", "args_ctype", "args_vntax", "args_fMT", "args_fmid", "args_Fmt", "args_Fstyle", "args2mtm", "args_fmtx", "args_dformat", "args_fermt", "args_fllt", "args_dMT", "args_ftype", "args_explt", "args2mmt", "args_facld", "args_ftm", "args_fmm", "args2ftm", "args_Fld", "args_ferstr", "args2mlt", "args_vlt", "args_mmn", "args_Ftm", "args_lfm", "args_lformat", "args_Fstr", "args2ftype", "args2vMT", "args_mtm", "args2flt", "args_facmt", "args_mformat", "args_ftx", "args2Ftx", "args_rfm", "args_mlt", "args_ffm", "args_cmt", "args_fltm", "args_expmt", "args2fmt", "args_mmt", "args_dtype", "args_xstyle", "args_jmid", "args_cformat", "args_fstr", "args_rmid", "args_flmt", "args_fermm", "args_clt", "args_fmld", "args2ftx", "args_ferstyle", "args_xstr"], "r0": ["rb00", "pairne", "r00", " r03", "R3", "vr3", "rt00", "rc00", "r03", " r3", "vrne", "R0", "rb0", "rt0", "rt255", "rb255", "pair3", "R1", "rc0", "vr03", "r255", "vr0", "rc255", "rne", " rne", "R03", "pair0", "vr1", "r3"], "r0_name": ["r0tnames", "r0_value", "r0___Name", "r15_title", "r0Tname", "r02___Name", "r15_name", "r02_Name", "r02___title", "r0__title", "r0_names", "r0___name", "r15_word", "r1tnames", "r0_number", "r0_tag", "r0_word", "r1_value", "r0tname", "r02_number", "r0__word", "r0Ttitle", "r0__name", "r15_tag", "r02___name", "r1tvalue", "r1tname", "r0_title", "r0__tag", "r0Ttag", "r02_title", "r0___number", "r0tvalue", "r02___number", "r1_names", "r02_name", "r0___title", "r0__value", "r0_Name", "r0Tword", "r0__names"], "r1": ["drOne", "mOne", " r4", "rOne", "m1", "r001", "rc51", " r3", "dr1", "dr3", "r51", "r01", "mr51", " rOne", "dr4", " r01", "r4", "rt001", "rc01", "err001", "errOne", "mr1", "rc4", "m4", " r001", "m3", "rtOne", "mr4", "mr01", "rc1", "r3", "err1", " r51", "rt1"], "r1_name": ["r1acclient", "r1_label", "r1xtype", "r1xno", "r100_names", "r1actype", "r1_prefix", "r01_label", "r100_no", "r1xname", "r1xnames", "r1_no", "r01_name", "r100_name", "r1xclient", "r5_label", "r1xlabel", "r5xlabel", "r5_client", "r5xname", "r1_type", "r1istname", "r01_prefix", "r1istlabel", "r5_name", "r5xtype", "r5xclient", "r1aclabel", "r1_pair", "r1acname", "r5_type", "r1_client", "r1_names", "r1istclient", "r1xpair", "r1isttype", "r100_pair", "r1_title", "r01_title"], "r2": ["rt52", "drTwo", "vr02", "dr15", "rc15", "dr52", "rt2", " rTwo", "rTwo", "vr3", "rc52", "m6", "dr2", " r62", "rt15", "rc2", "m02", "m62", " r3", "dr3", "r15", "r02", "r62", "vr2", "vr6", " r2002", " r02", "vr62", "rtTwo", "vrTwo", "vr2002", "r52", "rcTwo", "dr2002", "r6", " r6", "r3", "r2002", "m2"], "r2_name": ["r3_name", "rTwo_name", "r2__file", "r2oxname", "r2_domain", "r3_Name", "r2_number", "rTwo_file", "r2msfile", "r2idpass", "r3_number", "rTwo_domain", "r2__names", "r2oxnumber", "r2_title", "r2idname", "r2_names", "r3_pass", "r2__name", "r2msnames", "r2__domain", "r2_Name", "r2_group", "r2idName", "r2_pass", "r2idnumber", "r2msname", "r2oxpass", "r2_file", "rTwo_names", "r2msdomain", "r2oxName"], "csr": ["pscr", "csscr", "csc", "acsc", "cscr", "cssm", "cssr", "psr", "acsr", "psm", "acscr", "csm", "acsm", "psc", "cssc"], "csr_name": ["rs_", "lsf", "rsfunc", "cssf", "rsf", "ls_", "cs_", "cssfunc", "css_", "csf", "csfunc", "lsfunc"]}}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    compno = bytestream_get_byte(&s->buf);\n\n\n\n    c      += compno;\n\n    c->csty = bytestream_get_byte(&s->buf);\n\n    get_cox(s, c);\n\n\n\n    properties[compno] |= HAD_COC;\n\n    return 0;\n\n}\n", "idx": 2665, "substitutes": {"s": ["sam", "n", "xs", "this", "bs", "qs", "q", "ses", "comm", "es", "b", "ls", "d", "als", "r", "ains", "p", "ts", "its", "ps", "i", "gs", "is", "v", "sys", "less", "parts", "ss", "conf", "in", "ims", "se", "ms", "source", "ctx", "os", "ies", "o", "ds", "eps", "a", "vs", "sts", "ats", "er", "t", "ns", "rs", "serv", "sb", "S", "sf", "ins", "h", "ess", "sq", "f", "cs", "js", "aws", "m", "j"], "c": ["n", "count", "cr", "mc", "b", "ct", "lc", "com", "ca", "d", "cu", "comp", "r", "gc", "p", "cc", "cp", "ec", "i", "l", "cf", "v", "bc", "dc", "u", "cm", "co", "e", "g", "fc", "sc", "col", "ctx", "o", "ac", "a", "cb", "C", "ci", "t", "cont", "unc", "cv", "tc", "h", "z", "f", "cs", "m", "con"], "properties": ["pro", "property", "images", "events", "blocks", "bytes", "services", "options", "items", "metadata", "values", "codes", "states", "styles", "ps", "perties", "tags", "comments", "reports", "whatever", "terms", "units", "fields", "parts", "headers", "objects", "features", "flags", "settings", "params", "OPS", "types", "private", "frames", "policy", " props", "details", "names", "errors", "resources", "prop"], "compno": ["comeno", " compro", "ompNO", "omp0", "CompNo", "componentno", "Compeno", " comp0", " compeno", "cmpNO", " compNO", " recompeno", "compNo", "comNo", "cmpno", "ompno", "cmpro", "cmpNo", "cmp0", "comno", "componentNo", "Compro", "compNO", " compNo", "comko", "Compno", "comp0", "ompNo", "cmpeno", "componentNO", "compeno", "compko", " recompko", " comppos", "Comppos", " compko", "componentpos", "compro", " recompno", " recompNo", "CompNO", "comppos"]}}
{"project": "qemu", "commit_id": "615220ddaf23db4c5686053257c568b46967e4b5", "target": 1, "func": "static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n", "idx": 2673, "substitutes": {"i": ["k", "iu", "I", "n", "oi", "bi", "cli", "init", "li", "q", "ui", " j", "batch", "di", "status", "ii", "im", "mi", "ki", "p", "ji", " bi", "\u0438", "ind", "ip", "ai", "v", "ei", "ij", "x", "u", "pi", "in", "ini", "jp", "zi", "g", "ic", "me", "qi", "xi", "name", "ik", "conv", "ami", " ii", "go", "si", "it", "ix", "t", "ci", "index", "multi", "y", "h", "dr", "z", "sp", "id", "ti", "sim", "gi", " x", "m", "j", "chain"], "colour_default": ["gradient_diff", "colour_force", "gradientntdiff", "colour_switch", "gradient_default", "gradientntswitch", "colour___default", "colour_public", "gradient_public", " colour_def", "gradient_switch", " colour_force", "colourntdiff", "gradientntpublic", " colour_diff", "colour_Default", "colour___dict", "gradientntdefault", "colourntpublic", " colour_Default", "colour_def", "colour_diff", "colourntdefault", "colourntswitch", " colour_dict", "colour___diff", "colour_dict"]}}
{"project": "FFmpeg", "commit_id": "28bf81c90d36a55cf76e2be913c5215ebebf61f2", "target": 1, "func": "static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)\n\n{\n\n#ifdef HAVE_MMX\n\n\t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)\n\n    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))\n\n#else\n\n    if(sws_flags != SWS_FAST_BILINEAR)\n\n#endif\n\n    {\n\n    \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    }\n\n    else // Fast Bilinear upscale / crap downscale\n\n    {\n\n#ifdef ARCH_X86\n\n#ifdef HAVE_MMX2\n\n\tint i;\n\n\tif(canMMX2BeUsed)\n\n\t{\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha\n\n\t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF\n\n\t\t\t\"movq %%mm2, \"MANGLE(temp0)\"\t\\n\\t\"\n\n\t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src\n\n\t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1\n\n\t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\"\n\n\t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF\n\n\n\n#define FUNNY_Y_CODE \\\n\n\t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\\n\n\t\t\t\"call \"MANGLE(funnyYCode)\"\t\\n\\t\"\\\n\n\t\t\t\"movq \"MANGLE(temp0)\", %%mm2\t\\n\\t\"\\\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\n\n\n\t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16),\n\n\t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF)\n\n\t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n\n\t\t);\n\n\t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;\n\n\t}\n\n\telse\n\n\t{\n\n#endif\n\n\t//NO MMX just normal asm ...\n\n\tasm volatile(\n\n\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx\n\n\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha\n\n\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movzbl  (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\n\n\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\n\n\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\n\n\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\n\n\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\n\n\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\n\n\t\t);\n\n#ifdef HAVE_MMX2\n\n\t} //if MMX2 cant be used\n\n#endif\n\n#else\n\n\tint i;\n\n\tunsigned int xpos=0;\n\n\tfor(i=0;i<dstWidth;i++)\n\n\t{\n\n\t\tregister unsigned int xx=xpos>>16;\n\n\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n\t\txpos+=xInc;\n\n\t}\n\n#endif\n\n    }\n\n}\n", "idx": 2677, "substitutes": {"dst": ["Drc", " drc", "wnt", "pst", "pST", " dST", " dtd", "dST", "sst", " dnt", "Dest", "dest", "DST", "pct", "Dst", "Dct", "west", "adest", "adtd", "adst", "prc", "sest", "adnt", "wtd", "drc", "sST", " dct", "wst", "dnt", "dct", " dest", "dtd"], "dstWidth": ["DestW", "dtdHeight", "dxPath", "DstWidth", "DstLeft", "pstHeight", "destCut", "destW", "pSTHeight", "dstPath", " dsrcWidth", "pSTWidth", "dspwidth", "destPath", "DestHeight", "DstHeight", "dtdW", "dsrcWidth", "dSTPath", "destLeft", "dSTLeft", "dtdCut", " dstHeight", "dSTW", "pSTwidth", "dstwidth", "DestSize", "dspHeight", "dspW", "dSTHeight", "dsrcHeight", "pstwidth", "dstLeft", "dstSize", "DestLeft", " dsrcCut", " dstCut", "destHeight", "dstW", "destSize", "dxW", "drtHeight", "dxWidth", "pstWidth", "dxHeight", "drtSize", " dsrcW", "DstPath", "DstW", " dsrcHeight", "drtLeft", "dSTSize", "destWidth", "dtdWidth", "dSTwidth", " dstW", "dspWidth", "pstW", "dxwidth", "dsrcCut", "DstSize", "pSTW", "dstCut", "dstHeight", "dSTWidth", "DestWidth", "DestPath", "drtWidth", "dsrcW"], "src": ["s", "inst", "input", "slice", "rc", "dist", "cur", "hl", "dest", "sn", "rl", "img", "std", "st", "sys", "sup", "inc", "in", "rt", "sc", "source", "sv", "conv", "SOURCE", "sr", "loc", "rs", "sur", "txt", "sb", "usr", "ins", "ptr", "sl", "sq", "tmp", "ser", "ctr", "sub", "RC"], "srcW": ["stP", "destR", "destW", "destS", " srcP", " srcM", " srcH", "destH", "sourceW", "sourceH", "sourceWidth", "stR", "srcH", "stS", " srcR", "destWidth", "srcWidth", "srcS", "sourceM", " srcWidth", " srcS", "srcR", "srcM", "stW", "srcP", "destP", "destM"], "xInc": ["XINC", "xINC", "xIss", "xfInc", "checkAdd", "xInst", "checkIss", "xInit", "xxIncre", " xIss", "exEnc", "XIns", " xAdd", "xfIncre", "xfIns", "exInc", "xEnc", " xEnc", "XIss", "exIns", "xxINC", "xxInc", " xinc", "exInst", "txEnc", "xxIns", "rxIncre", "exIncre", "xIns", "Xinc", "xxDiff", " xInst", "XEnc", "txInc", "xinc", "xIncre", "xDiff", "checkIncre", "xAdd", " xIns", "txIncre", " xIncre", "rxInc", "XIncre", "checkInc", "xxInit", " xDiff", "rxINC", "exinc", "XInc", "XAdd", " xInit", " xINC", "txInst", "exINC", "xfInit", "rxDiff"], "i": ["phi", "I", "n", "oi", "bi", "cli", "li", "q", "ui", " j", "b", "c", "di", "ii", "mi", "ni", "ki", "p", "l", "ip", "ai", "v", "e", "x", "pi", "fi", "ini", "g", "zi", "qi", "xi", "it", "si", "ix", "ci", "t", "index", "y", "z", "ti", "gi", "m", "j"], "FUNNY_Y_CODE": ["FUNNY_Y_COD", "FUNNY_YJECTCSE", "FUNNY_Y__NODE", "FUNNY_Y__NOPE", "FUNNY_Y_SCOD", "FUNNY_Y_ECSE", "FUNNY_Y_CCODE", "FUNNY_Y_NONE", "FUNNY_YONCODE", "FUNNY_Y_NOD", "FUNNY_Y_ECode", "FUNNY_Y_DECRIPT", "FUNNY_Y_ECOD", "FUNNY_Y_FODE", "FUNNY_Y__CRIPT", "FUNNY_YOPSCTE", "FUNNY_Y_DECOPE", "FUNNY_YEARGNAME", "FUNNY_Y_CCOC", "FUNNY_Y_CMOC", "FUNNY_Y_ECOUR", "FUNNY_YJECTCOUR", "FUNNY_Y_ACISION", "FUNNY_YEARCCODE", "FUNNY_Y_NOPE", "FUNNY_YLECode", "FUNNY_Y__NRIPT", "FUNNY_Y_ICODE", "FUNNY_Y__CODE", "FUNNY_Y_LIME", "FUNNY_YEARCCETHOD", "FUNNY_Y_ECIDE", "FUNNY_Y_CIDE", "FUNNY_YLECODE", "FUNNY_Y_CTE", "FUNNY_YOPCOD", "FUNNY_Y_ACENT", "FUNNY_Y_CONE", "FUNNY_Y_Code", "FUNNY_Y_CETHOD", "FUNNY_Y__COPE", "FUNNY_Y_COUR", "FUNNY_Y_ECTE", "FUNNY_Y_VCONE", "FUNNY_Y_COC", "FUNNY_YEARGISION", "FUNNY_Y_VCIDE", "FUNNY_Y__NENE", "FUNNY_YOPSCENT", "FUNNY_Y_NENE", "FUNNY_Y_ICISION", "FUNNY_Y_ACTE", "FUNNY_YEARCETHOD", "FUNNY_Y_VCOUR", "FUNNY_Y_ACENE", "FUNNY_YJECTCODE", "FUNNY_YEARCCOD", "FUNNY_Y_GOD", "FUNNY_Y_CCIME", "FUNNY_Y_ECENT", "FUNNY_Y_ACOC", "FUNNY_Y_ICNAME", "FUNNY_Y_ECONE", "FUNNY_YJECTVCSE", "FUNNY_Y_ACOD", "FUNNY_YJECTCIDE", "FUNNY_Y_FOUR", "FUNNY_Y__CENE", "FUNNY_Y_CENT", "FUNNY_Y_ECODE", "FUNNY_Y_CMODE", "FUNNY_Y_COPE", "FUNNY_Y_CENE", "FUNNY_YJECTVCIDE", "FUNNY_Y_ACRIPT", "FUNNY_Y_ACNAME", "FUNNY_YEARCODE", "FUNNY_YEARCode", "FUNNY_Y_CIME", "FUNNY_YEARCNAME", "FUNNY_YOPSCOD", "FUNNY_Y_CCETHOD", "FUNNY_Y_SCENT", "FUNNY_YJECTVCODE", "FUNNY_Y_NODE", "FUNNY_Y_DECENE", "FUNNY_Y_CISION", "FUNNY_Y_LODE", "FUNNY_Y_CCONE", "FUNNY_Y_CMETHOD", "FUNNY_YOPCODE", "FUNNY_YONCIME", "FUNNY_YONCCIME", "FUNNY_Y_ICode", "FUNNY_Y_DECODE", "FUNNY_YEARCISION", "FUNNY_Y_CMOD", "FUNNY_Y_ACODE", "FUNNY_Y_LOD", "FUNNY_YEARCOC", "FUNNY_YEARCCOC", "FUNNY_Y_CRIPT", "FUNNY_YONCOD", "FUNNY_Y_CSE", "FUNNY_YJECTVCOUR", "FUNNY_YONCCONE", "FUNNY_Y_GISION", "FUNNY_Y_SCTE", "FUNNY_Y_FIDE", "FUNNY_YOPCENT", "FUNNY_YONCONE", "FUNNY_Y_CCOUR", "FUNNY_YEARCOD", "FUNNY_YOPSCODE", "FUNNY_YEARGode", "FUNNY_YONCCOD", "FUNNY_Y_FSE", "FUNNY_Y_ACETHOD", "FUNNY_Y_Gode", "FUNNY_Y_GODE", "FUNNY_Y_GOUR", "FUNNY_Y_ACOPE", "FUNNY_Y_LONE", "FUNNY_Y_VCODE", "FUNNY_Y_ACode", "FUNNY_Y_CCOD", "FUNNY_Y_VCSE", "FUNNY_YLECOD", "FUNNY_YOPCTE", "FUNNY_Y_VCOD", "FUNNY_YONCCODE", "FUNNY_YEARGODE", "FUNNY_Y_NRIPT", "FUNNY_Y_CNAME", "FUNNY_Y_VCode", "FUNNY_Y_SCODE", "FUNNY_Y_NIME", "FUNNY_Y_GNAME"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 2680, "substitutes": {"f": ["lf", "fm", "fb", "ile", "form", "fr", "q", "uf", "b", "c", "d", "w", "fo", "r", "p", "i", "l", "fp", "cf", "e", "fi", "conf", "g", "file", "fc", "af", "o", "fs", "t", "fd", "tf", "h", "fw", "F", "m", "fac"], "pv": [" pvc", "piv", "jp2", "jpq", "vpiv", "jpv", "ppv", "vpv", "paq", "pve", " piv", "pvc", "vpvc", "ppV", "vpV", " pq", "pq", "pav", "jpve", " p2", " pve", "pave", "ppvc", "p2", " pV", "pa2", "ppiv", "pV"], "size": ["n", " s", "length", " length", " scale", " Size", "m", "w", "p", "type", "mem", "ize", "st", "e", " sh", "len", "space", " len", " sizes", "pe", "fee", "ci", "h", "SIZE", "shape", "sp", "Size"], "v": ["s", "n", "var", "q", "b", "c", "nv", "d", "w", "r", "p", "av", "vt", "V", "tv", "i", "l", "vol", "u", "va", "g", "sv", "conv", "o", "a", "vs", "ov", "lv", "t", "ver", "uv", "cv", "vc", "m", "j", "ev"], "v2": [" v4", "v4", "qv1", "ev2", "Vlet", "p4", "vvsp", "p1", "ev4", "V2", "psp", " vsp", "V0", "vv1", " v1", "qv4", " vlet", "ev1", " v0", "p2", "vlet", "v0", "ev5", "v1", "vsp", "V4", "v5", "p0", "plet", "qv5", " v5", "vv2", "qv2"]}}
{"project": "FFmpeg", "commit_id": "c5f15f40b9b25f033fd9e8dd1e12763913098c11", "target": 1, "func": "static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    uint8_t nal;\n\n    uint8_t type;\n\n    int result = 0;\n\n\n\n    if (!len) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Empty H264 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    nal  = buf[0];\n\n    type = nal & 0x1f;\n\n\n\n    assert(data);\n\n    assert(buf);\n\n\n\n    /* Simplify the case (these are all the nal types used internally by\n\n     * the h264 codec). */\n\n    if (type >= 1 && type <= 23)\n\n        type = 1;\n\n    switch (type) {\n\n    case 0:                    // undefined, but pass them through\n\n    case 1:\n\n        av_new_packet(pkt, len + sizeof(start_sequence));\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n        COUNT_NAL_TYPE(data, nal);\n\n        break;\n\n\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n\n        // consume the STAP-A NAL\n\n        buf++;\n\n        len--;\n\n        // first we are going to figure out the total size\n\n        {\n\n            int pass         = 0;\n\n            int total_length = 0;\n\n            uint8_t *dst     = NULL;\n\n\n\n            for (pass = 0; pass < 2; pass++) {\n\n                const uint8_t *src = buf;\n\n                int src_len        = len;\n\n\n\n                while (src_len > 2) {\n\n                    uint16_t nal_size = AV_RB16(src);\n\n\n\n                    // consume the length of the aggregate\n\n                    src     += 2;\n\n                    src_len -= 2;\n\n\n\n                    if (nal_size <= src_len) {\n\n                        if (pass == 0) {\n\n                            // counting\n\n                            total_length += sizeof(start_sequence) + nal_size;\n\n                        } else {\n\n                            // copying\n\n                            assert(dst);\n\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n\n                            dst += sizeof(start_sequence);\n\n                            memcpy(dst, src, nal_size);\n\n                            COUNT_NAL_TYPE(data, *src);\n\n                            dst += nal_size;\n\n                        }\n\n                    } else {\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n\n                    }\n\n\n\n                    // eat what we handled\n\n                    src     += nal_size;\n\n                    src_len -= nal_size;\n\n\n\n                    if (src_len < 0)\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n\n                }\n\n\n\n                if (pass == 0) {\n\n                    /* now we know the total size of the packet (with the\n\n                     * start sequences added) */\n\n                    av_new_packet(pkt, total_length);\n\n                    dst = pkt->data;\n\n                } else {\n\n                    assert(dst - pkt->data == total_length);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 25:                   // STAP-B\n\n    case 26:                   // MTAP-16\n\n    case 27:                   // MTAP-24\n\n    case 29:                   // FU-B\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n\n               type);\n\n        result = AVERROR(ENOSYS);\n\n        break;\n\n\n\n    case 28:                   // FU-A (fragmented nal)\n\n        buf++;\n\n        len--;                 // skip the fu_indicator\n\n        if (len > 1) {\n\n            // these are the same as above, we just redo them here for clarity\n\n            uint8_t fu_indicator      = nal;\n\n            uint8_t fu_header         = *buf;\n\n            uint8_t start_bit         = fu_header >> 7;\n\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n\n            uint8_t nal_type          = fu_header & 0x1f;\n\n            uint8_t reconstructed_nal;\n\n\n\n            // Reconstruct this packet's true nal; only the data follows.\n\n            /* The original nal forbidden bit and NRI are stored in this\n\n             * packet's nal. */\n\n            reconstructed_nal  = fu_indicator & 0xe0;\n\n            reconstructed_nal |= nal_type;\n\n\n\n            // skip the fu_header\n\n            buf++;\n\n            len--;\n\n\n\n            if (start_bit)\n\n                COUNT_NAL_TYPE(data, nal_type);\n\n            if (start_bit) {\n\n                /* copy in the start sequence, and the reconstructed nal */\n\n                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n                pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n\n                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n\n            } else {\n\n                av_new_packet(pkt, len);\n\n                memcpy(pkt->data, buf, len);\n\n            }\n\n        } else {\n\n            av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H264 RTP packet\\n\");\n\n            result = AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n\n\n    case 30:                   // undefined\n\n    case 31:                   // undefined\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n\n        result = AVERROR_INVALIDDATA;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return result;\n\n}\n", "idx": 2704, "substitutes": {"ctx": ["wx", " context", "cmp", "grad", "cfg", "ct", "lc", "cu", "kt", "gc", "cp", "cc", "cf", "ck", "context", "dc", "jac", "cn", "cm", "kw", "xc", "conf", "jp", "tz", "sc", "conv", "conn", "cb", "wcs", "msg", " cx", "wd", "act", "cv", "obj", "setup", "tc", "hw", "pkg", "tmp", "lex", "ctl", "cmd", "tx", "care", "config", "cas", "course", "ctrl"], "data": ["DATA", "ata", "n", "read", "this", "str", "bin", "nt", "bytes", "length", "na", "new", "error", "start", "d", "block", "dest", "rec", "r", "cache", "p", "ret", "stream", "auth", "window", "out", "valid", "body", "next", "Data", "offset", "header", "message", "info", "image", "result", "list", "name", "source", "trans", "value", "a", "sequence", "dat", "to", "t", "content", "table", "text", "txt", "size", "enc", "obj", "no", "raw", "mu", "cmd", "tx", "padding", "version", "id", "buffer", "base"], "st": ["sam", "ist", "sth", "str", "nt", "tt", "ct", "cur", "nd", "start", "pt", "ast", "rest", "ut", "est", "std", "stage", "St", "ste", "stop", "sts", "dat", "serv", "sw", "mt", "tmp", "ST", "sp"], "pkt": ["spkt", "ntx", "opkg", " packet", " pct", "nqt", "nacket", "pet", "Ppt", "cpkg", "compet", "packet", " pck", "sptx", "pct", "pck", "opkt", "ppt", "spqt", "cpkt", "cpct", "Packet", "compacket", "ptx", "Pet", " pkg", "compkt", "cpck", "compck", "nkt", "cpacket", " pqt", "comppt", "spacket", "pqt", "Pkt", "cpwk", "pkg", "opet", " pwk", "compct", "cpet", " ppt", " ptx", " pet", "pwk", "opwk"], "timestamp": ["mestamp", "timetime", "timid", "timeestamp", "mid", "mtime", "imid", "imestamp", "timeid", "imtime", "timtime", "imetime", "metime", "timeetime"], "buf": ["proc", "bp", "read", "bl", "str", "cap", "iter", "rc", "bin", "ff", "length", "bytes", "batch", "uf", "b", "rb", "pb", "pos", "cur", "block", "Buff", "lim", "p", "wb", "pad", "loop", "mem", "out", "v", "bar", "next", "bc", "queue", "arr", "result", "en", "br", "limit", "end", "Len", "cb", "fl", "addr", "dat", "msg", "loc", "set", "txt", "ref", "cv", "obj", "Buffer", "pack", "ptr", "tmp", "pkg", "raw", "err", "cmd", "buffer", "buff", "vec", "db"], "len": ["lf", "n", "lon", "nl", "el", "str", "iter", "length", "bytes", "nt", "cmp", "ls", "pos", "hl", "dl", "lim", "kl", " clen", "alt", "ret", "p", "ll", "l", "mem", "offset", "L", " l", "elt", "fin", "en", "lp", "limit", "Len", "trans", "fl", "end", "ld", "loc", "all", "pl", "val", "ref", "size", "il", "h", "ail", "sl", "ln", "lang", "z", "sp", "lan"], "seq": ["count", "cap", "iter", "gen", "alt", "req", "stream", "loop", "sys", "next", "list", "flow", "cb", "msg", "res", "vec", "ref", "ver", "vals", "ess", "desc", "id", "acl", "ctr", "pos", "sequence"], "flags": ["s", "flag", "FLAG", "ff", "mask", "options", "ags", "status", "speed", "ts", "ps", "heads", "ops", "fields", "acts", "os", "aps", "fs", "params", "types", "times", "ns", "bits", "args", "vals", "cs", "Flags", " options"], "nal": [" nality", " nonalf", "nnale", "nnAL", "nnal", " nonal", "analf", "renAL", " nonals", "nald", "nalf", "Nald", "nale", "anality", "anals", "anAL", "anneal", "renal", "nality", " nonAL", "renality", "nals", "Nal", "anale", "renale", " nals", "Neal", "nsal", "NAL", "nsald", " nale", "nsAL", "nseal", " nalf", "annAL", "annald", "annal", " nAL", "anal", "annale", "nnalf", "annalf", "nAL", "neal"], "type": ["Type", "tag", "test", " ty", "spec", "tp", "day", "null", "flag", "time", "what", "length", "style", "error", "status", "block", "p", "family", " Type", " TYPE", "mode", "pretty", "out", "stat", "field", "e", "kind", " typ", "info", "ping", "result", "format", "file", "name", "ror", "al", "all", "set", "pe", "op", "types", "t", "class", "state", "rel", "ver", "size", "index", "TYPE", "pack", "role", "like", "broad", "sp", "ty", "none", "range", "typ", "id", "month", "con", "ype"], "dst": ["lest", "dnd", " dsrc", "lsp", "dsdest", "msp", "wct", "Dest", "sst", "mdest", "Ddest", "mest", "ddest", " dnt", "deest", "dest", "lend", "snd", "idst", "dsp", "Dst", "dend", "jnd", "Dct", "wost", "west", "dsest", "dsost", "Dsrc", "idest", "jdest", " dsp", "most", "dsct", "mnd", "sdest", "dsrc", "sest", "msrc", "jst", " dend", "idsp", "Dsp", "jost", "idend", "dsnd", "Dnd", "wst", "lnt", "lnd", "dent", "dnt", "dost", "mst", " dnd", " ddest", "lst", "Dost", "dsst", "dct", " dest"], "pass": ["ack", "proc", "access", "cat", "rc", "step", "phase", "batch", "jump", "commit", "con", "pos", " bypass", "try", "arg", "p", "password", "pas", "loop", "row", "miss", "stage", "def", "conf", "gain", "PASS", "par", "pp", "col", "pin", "ask", "task", "handle", "push", "run", "card", "Pass", "process", "acc", "pa", "res", "val", "user", "wd", "act", "cas", "alias", "session", "pack", "pg", "call", "weight", "ass", "skip", "lo", "level", "scan", "mode", "save", "prop"], "src": ["sub", "s", "inst", "inner", "supp", "proc", "input", "slice", "rc", "str", "scan", "cur", "start", "lit", "sn", "dest", "r", "syn", "rec", "rl", "sel", "stream", "img", "sys", "bc", "sup", "sync", "sc", "source", "url", "addr", "sr", "loc", "rs", "sur", "rel", "cont", "sb", "ins", "usr", "ptr", "sl", "sq", "tmp", "ser", "ctr", "buff", "rol"]}}
{"project": "qemu", "commit_id": "4cdd01d32ee6fe04f8d909bfd3708be6864873a2", "target": 0, "func": "void bdrv_refresh_filename(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QDict *opts;\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* This BDS's file name will most probably depend on its file's name, so\n\n     * refresh that first */\n\n    if (bs->file) {\n\n        bdrv_refresh_filename(bs->file->bs);\n\n    }\n\n\n\n    if (drv->bdrv_refresh_filename) {\n\n        /* Obsolete information is of no use here, so drop the old file name\n\n         * information before refreshing it */\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        drv->bdrv_refresh_filename(bs);\n\n    } else if (bs->file) {\n\n        /* Try to reconstruct valid information from the underlying file */\n\n        bool has_open_options;\n\n\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        opts = qdict_new();\n\n        has_open_options = append_open_options(opts, bs);\n\n\n\n        /* If no specific options have been given for this BDS, the filename of\n\n         * the underlying file should suffice for this one as well */\n\n        if (bs->file->bs->exact_filename[0] && !has_open_options) {\n\n            strcpy(bs->exact_filename, bs->file->bs->exact_filename);\n\n        }\n\n        /* Reconstructing the full options QDict is simple for most format block\n\n         * drivers, as long as the full options are known for the underlying\n\n         * file BDS. The full options QDict of that file BDS should somehow\n\n         * contain a representation of the filename, therefore the following\n\n         * suffices without querying the (exact_)filename of this BDS. */\n\n        if (bs->file->bs->full_open_options) {\n\n            qdict_put_obj(opts, \"driver\",\n\n                          QOBJECT(qstring_from_str(drv->format_name)));\n\n            QINCREF(bs->file->bs->full_open_options);\n\n            qdict_put_obj(opts, \"file\",\n\n                          QOBJECT(bs->file->bs->full_open_options));\n\n\n\n            bs->full_open_options = opts;\n\n        } else {\n\n            QDECREF(opts);\n\n        }\n\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n\n         * so the full options QDict should be equal to the options given\n\n         * specifically for this block device when it was opened (plus the\n\n         * driver specification).\n\n         * Because those options don't change, there is no need to update\n\n         * full_open_options when it's already set. */\n\n\n\n        opts = qdict_new();\n\n        append_open_options(opts, bs);\n\n        qdict_put_obj(opts, \"driver\",\n\n                      QOBJECT(qstring_from_str(drv->format_name)));\n\n\n\n        if (bs->exact_filename[0]) {\n\n            /* This may not work for all block protocol drivers (some may\n\n             * require this filename to be parsed), but we have to find some\n\n             * default solution here, so just include it. If some block driver\n\n             * does not support pure options without any filename at all or\n\n             * needs some special format of the options QDict, it needs to\n\n             * implement the driver-specific bdrv_refresh_filename() function.\n\n             */\n\n            qdict_put_obj(opts, \"filename\",\n\n                          QOBJECT(qstring_from_str(bs->exact_filename)));\n\n        }\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->exact_filename[0]) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n\n    } else if (bs->full_open_options) {\n\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n\n                 qstring_get_str(json));\n\n        QDECREF(json);\n\n    }\n\n}\n", "idx": 2737, "substitutes": {"bs": ["BS", "ics", "ables", "bh", "bn", "nuts", "aos", "outs", "fs", "ds", "vers", "bits", "sb", "bb", "hs", "ox", "ubs", "actions", "ils", "bi", "bl", "bas", "bing", "ses", "blog", "pb", "books", "blogs", "uts", "bed", "cks", "lines", "ims", "ys", "os", "vs", "cb", "sts", "ats", "as", "vals", "els", "banks", "aus", "ports", "bp", "lbs", "blocks", "rots", "utils", "lets", "ps", "tops", "sys", "terms", "ms", "bis", "irms", "stones", "bys", "us", "css", "bes", "stats", "ads", "xs", "eb", "bytes", "b", "bps", "otes", "ls", "boxes", "bles", "als", "ts", "its", "changes", "gs", "bc", "ks", "obs", "bos", "rs", "ns", "ins", "hz", "cs", "caps", "js"], "drv": ["drV", "Drv", "vrv", "DRvr", "DRm", "derx", "drij", "hdv", " drvs", "vrx", "drig", "DRve", "srw", "hdvd", "srm", "drw", " drm", "drvs", "Drj", "DRv", "srV", "mrvs", "hdvt", "drivr", "driw", "darvy", "driu", "srv", "drj", "drmx", "drm", "hostm", "dervr", "drmve", "drx", "hrj", "drvd", "derg", "derV", "vrm", "drmm", "hostve", "darv", " drvt", "sru", "drvt", "darvr", "hostv", " drvd", " drvr", "dru", "derv", "drvr", "vrve", "drvy", "derm", "mrvt", "driV", "hrm", "mrvd", "Drvd", "drve", "srvy", "drmv", "hrve", "srg", "hostvr", "derve", "hrvd", "darm", "hrvr", "mrv", "deru", "hdvs", "srvr", "Drvr", " drvy", "driv", "drg", "drivd", "hrv", "drim", "derw"], "opts": ["operte", "portm", " opcs", "opmits", "optns", "proters", " opttu", "oktes", "prety", "operps", "optuts", "optx", "OPss", "copns", "prete", "opttu", "opals", " oppt", " opTs", "okals", "opercs", "dropcs", "copfs", " optu", " optals", "optTS", " optx", "porths", "opcs", " opty", "OPmits", "copts", "copals", " opss", "optths", "iopTS", "operss", "opss", "props", "Opths", "prests", "Optm", "opfs", "optTs", "okuts", "OPters", "otpt", "coptes", "prevals", "opns", " opmits", "coptx", "OPTS", "optals", "Opss", "ports", " oputs", "optfs", "Opts", "opervals", "opths", " opx", "OPts", "otuts", "porss", "OPTs", "optss", "okts", "optters", " opfs", "otts", "iopps", "iopters", "opttm", "opte", "opty", " opTS", "coputs", "oputs", "opTS", " opvals", "OPpt", "operts", "precs", " optts", " opals", "opsts", " opsts", "OPps", "opps", " opte", "opttx", " opps", "prots", "prets", "opTs", "iopts", "dropts", "opermits", "opvals", "optm", "optts", "dropsts", "opttes", "opx", "oppt", "dropty", "optes", " opns", "proTS", "optu", "otps", " opters", "opters", "OPuts", "optps"], "has_open_options": ["has_close_errors", "has_open____names", "has_open_tags", "has_open____options", "has_open_errors", "has_openttags", "has_close_options", "has_valid_ops", "has_open_option", "has_valid_options", "has_open_ptions", "has_valid_option", "has_open_ops", "has_open____ops", "has_close_tags", "has_close_ops", "has_close_names", "has_open____errors", "has_opentops", "has_valid_ptions", "has_open_names", "has_opentoptions"]}}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "static inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n\n{\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n            /* exit request from the cpu execution loop */\n\n            *ret = cpu->exception_index;\n\n            if (*ret == EXCP_DEBUG) {\n\n                cpu_handle_debug_exception(cpu);\n\n            }\n\n            cpu->exception_index = -1;\n\n            return true;\n\n        } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n            /* if user mode only, we simulate a fake exception\n\n               which will be handled outside the cpu execution\n\n               loop */\n\n#if defined(TARGET_I386)\n\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n\n            cc->do_interrupt(cpu);\n\n#endif\n\n            *ret = cpu->exception_index;\n\n            cpu->exception_index = -1;\n\n            return true;\n\n#else\n\n            if (replay_exception()) {\n\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n\n                qemu_mutex_lock_iothread();\n\n                cc->do_interrupt(cpu);\n\n                qemu_mutex_unlock_iothread();\n\n                cpu->exception_index = -1;\n\n            } else if (!replay_has_interrupt()) {\n\n                /* give a chance to iothread in replay mode */\n\n                *ret = EXCP_INTERRUPT;\n\n                return true;\n\n            }\n\n#endif\n\n        }\n\n#ifndef CONFIG_USER_ONLY\n\n    } else if (replay_has_exception()\n\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n\n        /* try to cause an exception pending in the log */\n\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n\n        *ret = -1;\n\n        return true;\n\n#endif\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 2762, "substitutes": {"cpu": ["core", "tp", "cli", "cow", "what", "ka", "cmp", "CPU", "bench", "pause", "cache", "uu", "cp", "sync", "port", "conn", "physical", "process", "component", "home", "hw", "pkg", "processor", "net", "cmd", "xp", "boot", "aq", "pool", "library", "ilo", "c", "cu", "prof", "util", "comp", "pc", "program", "linux", "pixel", "jp", "runner", "os", "px", "software", "ctl", "cum", "np", "utils", "launch", "thread", "ip", "ck", "percent", "sys", "performance", "ctx", "upt", "copy", "rpm", "share", "pu", "phys", "gp", "phy", "mac", "alloc", "rom", "proc", "ork", "coin", "que", "aco", "php", "remote", "gc", "kernel", "mem", "stat", "socket", "parse", "cn", "total", "profile", "hz", "clock", "gpu", "cs", "vm", "efficiency", "update", "nic", "pid"], "ret": ["test", "flag", "eth", "cat", "rets", "rc", "nz", "hash", "det", "del", "nt", "et", "re", "tr", "vet", "att", "lit", "try", "alt", "arg", "pret", "prop", " Ret", "mem", "out", "fun", "rm", "def", "rev", "gt", "arr", "ft", "rt", "deg", "elt", "len", "fin", "reset", "url", "crit", "reg", "dt", "cb", "addr", "resp", "Ret", "RET", "res", "t", "val", "rs", "cont", "cert", "ref", "rel", "mt", "net", "cmd", "desc", "result", "rem"], "cc": ["lf", "cca", "rc", "mc", "cmp", "kk", "ct", "cell", "func", "lc", "oc", "gc", "zz", "cp", "ec", "pc", "cf", "ck", "bc", "inc", "co", "xc", "cz", "fc", "CC", "nc", "ctx", "code", "cci", "cb", "ld", "acc", "cont", "cv", "tc", "cl", "ace", "cs", "ctl", "vc", "mac", "ucc", "icc", "ctrl", "cy", "cle"]}}
{"project": "FFmpeg", "commit_id": "1169f0d0afc0454633cfcfad73643f0458521c67", "target": 0, "func": "void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)\n\n{\n\n#if HAVE_INLINE_ASM\n\n    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {\n\n        if (ctx->cid_table->bit_depth == 8)\n\n            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;\n\n    }\n\n#endif /* HAVE_INLINE_ASM */\n\n}\n", "idx": 2793, "substitutes": {"ctx": ["tp", "Context", "np", "mc", "cmp", "utils", "ct", "c", "ca", "kt", "gc", "cp", "cc", "pc", "cf", "ck", "mk", "context", "bc", "dc", "co", "cn", "kw", "xc", "crit", "jp", "nc", "sc", "conv", "mom", "conn", "ac", "tk", "cb", "loc", "resp", "unc", "act", "cv", "tc", "setup", "obj", "hw", "pkg", "tmp", "cmd", "tx", "ctr", "ctrl"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 2806, "substitutes": {"env": ["em", "proc", "stack", "open", "Environment", "forge", "ew", "org", "erd", "event", "engine", "outer", "cur", "entry", "worker", "block", "enter", "esp", "equ", "environment", "ec", "vt", "req", "wall", "her", "te", "window", "shell", "v", "context", "e", "eng", "eco", "here", "conf", "queue", "exc", "esc", "menu", "ctx", "en", "conn", "server", "code", "viron", "ov", "vs", "end", "er", "den", "msg", "manager", "gear", "node", "dev", "hw", "walker", "desc", "vm", "config", "erb", "ah", "ev", " environment"], "arg1": ["param3", "Argone", "ArgOne", "ax1", " argOne", "arg01", " arg3", " argone", "axone", "argOne", "Arg1", "param01", "ax2", "Arg2", "argone", "prop3", "axOne", "prop01", "prop1", "arg3", " arg01", "param1"], "arg2": ["args1", "argstwo", " argur", "argument2", " targur", "argumenttwo", " argtwo", "argtwo", "argur", " targ1", "args2", "argument1", "argumentur", " targ2", " targtwo"], "farg1": ["fblock001", "fument7", "fflag001", "fok64", "fargs01", " fArg3", "fagg61", " farg64", "fagg1", "fokOnce", "ftargetone", "fxarg1", "fintOne", " fargone", "fxargOne", "farg9", " fArg1", "fxint1", "fbar001", "fiter001", "floatisk1", "fxintOne", "fargs2", "fparamOnce", "ffarg91", "ufargone", "foblockized", "fbar7", "foargized", "fok1", "ffield41", "faggone", "foarg7", "floatargons", "fparam41", "fumentized", "farg3", "fargumentone", "farg01", "ftag1", "fflag1", " fargs3", " fargsOne", "fparam3", "fark1", "ufarg01", "ftarget2", "ftag64", "fparamone", " fargs64", "forarg41", " farg61", " fArgone", "fargs1", " faggOne", "fiterOne", "fargsone", "foarg001", "ufarg1", "fisk1", "fArg1", "fok3", "fArgone", "fbar1", "uftarget1", "fument1", "fark01", "uftarget2", "freg01", "forarg1", "fxarg001", " fagg9", " fagg01", "fargument3", "fparam91", " fargOne", "fok41", "ffarg1", "fflagOne", "fblock1", "fargOnce", " farg9", "fflag61", " fArgOnce", "floatiskons", "fargumentOnce", "farg64", "farkOne", "fiskons", "fagg01", "farg001", "fArg3", "fiter1", "foblock1", "ffargument3", "floatargone", "fargs3", "faggOne", "forfield1", "fargized", "foblock7", "ffargument1", " fargOnce", " fagg001", "fagg001", "ffarg41", "farg41", "fxint001", "ffargument91", "floatiskone", "foarg1", "farg91", "fument001", "fblockized", "ffarg3", "fagg91", "ftag3", "fargs64", "forfield41", "ufarg2", "floatisk001", "fblock7", "ffargument41", "fint001", "ftarget1", "floatarg1", "faggOnce", " fargs1", "fagg3", "ftagOne", "fArgOnce", "fisk001", " farg01", "farg61", "ftarget01", "faggons", " fagg1", "fokOne", "fargons", "farg7", " farg3", "fargsOne", " fagg61", "fargone", "fregOne", "freg9", "fagg2", " farg001", "uftarget01", "fiter61", "fargument001", "freg1", "fint1", "forargOnce", "fargOne", "uftargetone", "fargument1", "fiskone", "ffieldOnce", "fargument91", "foblock001", "fagg41", "forfieldOnce", "freg001", "fbarized", "fagg9", "fark9", "floatarg001", "fparam1", "fargumentOne", "fargumentons", "fargument41", "ffield1"], "farg2": ["fasc52", "fumenttwo", " freg02", "fregtwo", "cagg02", "parg2", "fvar05", "fitem2", "freg02", "fdim42", "farg36", "fcalltwo", "fargtwo", "fdim22", "fparto", "floc22", "freg36", "pargtwo", "floc05", "pArg2", "fresult256", "fpar2", "fument02", "floc2", "fargor", "fasc2", "fArgor", "fagg42", "cagg22", "farg05", "fariTwo", " fargtwo", "carg2", "fvartwo", " farg36", "fasc256", " farg02", "carg02", "floatloc52", "freg2", "vagg2", "fArg2", "fparam36", "farg256", "faggto", "fvarTwo", " freg2", "fparamtwo", "floatargTwo", "fresultall", "pArgor", "flocall", "fument2", "fvar2", "floatlocTwo", "cagg42", "fcall2", "floatargall", "fascall", "fresult2", "fpar02", "carg42", "floatarg2", "fvar22", "floatarg05", "fparam2", "fument36", "fargto", "fargall", "fvaror", "fari2", "varg2", "floatloc256", "fmbto", "floatloc22", "fitem22", "farg52", "fagg22", "fari05", "carg22", "vaggto", "floatloc2", "floatarg52", "vargto", "fitem02", "fdim2", "floatarg256", "farg02", "floatloc05", " freg36", "pArgtwo", " fregtwo", "fitem42", "floc52", "fmb02", "flocTwo", "fagg2", "fdim02", "floatlocall", "pargor", "cagg2", "fargTwo", "fari22", "farg42", "floatarg22", "varg02", "fmb2", "vagg02", "fcallor", "fagg02", "fArgtwo", "fresult52", "fparam02", "farg22", "floc256"]}}
{"project": "qemu", "commit_id": "e4d2edc9d0c58de421eb349871e90b67edec0b9c", "target": 0, "func": "static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n", "idx": 2817, "substitutes": {"async": ["asAsync", "Async", " asynchronous", "assync", "assynchronous", "Assync", "Asynchronous", "ASynchronous", "Aset", " assync", "AsAsync", "ASync", "asynchronous", "ASsync", " asAsync", "ASAsync", "aset", " aset", "asset"], "listen_addr": ["liston_address", "listened_addr", "listener_ptr", "listen_arr", "listen_data", "listened_ptr", "listen_tag", "listened_arp", "listen67address", "listen___addr", "listener_url", "listen___conn", "listen67addr", "listener_sta", "listenedurl", "listen67debug", "listen____tag", "listen_conn", "listen_debug", "listen___map", "listenableurl", "listeneddata", "listener_part", "listenableaddr", "listenedaddr", "listener_ord", "liston_debug", "listenabledata", "listeningsta", "listen_sta", "listener_arr", "listen_add", "listener_tag", "listen_part", "listen_ord", "listened_add", "listener_data", "listenptaddr", "listeningaddr", "listen_url", "listenptptr", "listen_arp", "liston_addr", "listen_map", "listenptpart", "listen____ord", "listen_ptr", "listeningarr", "listen____addr", "listener_map", "listen_address", "listener_addr", "listener_conn"], "connect_addr": ["connect___adr", "connectistaddr", " connect_mod", "connect_conn", "removeistusr", "connect_pkg", "connect___addr", "connect_map", "connectingusr", "remove_usr", "connect_usr", "connect_attr", "connect_der", "submit_attr", "conn_address", "connect___conn", "connect_mod", "connect_res", "connectableaddress", "connect_add", "removeistgrad", "connableconn", " connect_map", "remove_grad", "connableaddress", "connectistpkg", "connect_ref", "remove_pkg", "connectableconn", "connect_grad", "connect_align", "connect_adder", "connect_address", "connableaddr", "connectistusr", " connect_res", "connect_ptr", " connect_align", "connableadr", " connect_ref", "connect_adr", "remove_addr", "conn_addr", " connect_ptr", "connectinggrad", "connect___address", "submit_addr", "connectingpkg", "removeistaddr", " connect_add", "connectistgrad", "connectableaddr", "conn_conn", "connectableadr", "removeistpkg", " connect_adder", "submit_adder", "connectingaddr", "conn_adr", " connect_der"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson_cp2\";\n\n    uint32_t opc, shift_max;\n\n    TCGv_i64 t0, t1;\n\n\n\n    opc = MASK_LMI(ctx->opcode);\n\n    switch (opc) {\n\n    case OPC_ADD_CP2:\n\n    case OPC_SUB_CP2:\n\n    case OPC_DADD_CP2:\n\n    case OPC_DSUB_CP2:\n\n        t0 = tcg_temp_local_new_i64();\n\n        t1 = tcg_temp_local_new_i64();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new_i64();\n\n        t1 = tcg_temp_new_i64();\n\n        break;\n\n    }\n\n\n\n    gen_load_fpr64(ctx, t0, rs);\n\n    gen_load_fpr64(ctx, t1, rt);\n\n\n\n#define LMI_HELPER(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break\n\n#define LMI_HELPER_1(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break\n\n#define LMI_DIRECT(UP, LO, OP) \\\n\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break\n\n\n\n    switch (opc) {\n\n    LMI_HELPER(PADDSH, paddsh);\n\n    LMI_HELPER(PADDUSH, paddush);\n\n    LMI_HELPER(PADDH, paddh);\n\n    LMI_HELPER(PADDW, paddw);\n\n    LMI_HELPER(PADDSB, paddsb);\n\n    LMI_HELPER(PADDUSB, paddusb);\n\n    LMI_HELPER(PADDB, paddb);\n\n\n\n    LMI_HELPER(PSUBSH, psubsh);\n\n    LMI_HELPER(PSUBUSH, psubush);\n\n    LMI_HELPER(PSUBH, psubh);\n\n    LMI_HELPER(PSUBW, psubw);\n\n    LMI_HELPER(PSUBSB, psubsb);\n\n    LMI_HELPER(PSUBUSB, psubusb);\n\n    LMI_HELPER(PSUBB, psubb);\n\n\n\n    LMI_HELPER(PSHUFH, pshufh);\n\n    LMI_HELPER(PACKSSWH, packsswh);\n\n    LMI_HELPER(PACKSSHB, packsshb);\n\n    LMI_HELPER(PACKUSHB, packushb);\n\n\n\n    LMI_HELPER(PUNPCKLHW, punpcklhw);\n\n    LMI_HELPER(PUNPCKHHW, punpckhhw);\n\n    LMI_HELPER(PUNPCKLBH, punpcklbh);\n\n    LMI_HELPER(PUNPCKHBH, punpckhbh);\n\n    LMI_HELPER(PUNPCKLWD, punpcklwd);\n\n    LMI_HELPER(PUNPCKHWD, punpckhwd);\n\n\n\n    LMI_HELPER(PAVGH, pavgh);\n\n    LMI_HELPER(PAVGB, pavgb);\n\n    LMI_HELPER(PMAXSH, pmaxsh);\n\n    LMI_HELPER(PMINSH, pminsh);\n\n    LMI_HELPER(PMAXUB, pmaxub);\n\n    LMI_HELPER(PMINUB, pminub);\n\n\n\n    LMI_HELPER(PCMPEQW, pcmpeqw);\n\n    LMI_HELPER(PCMPGTW, pcmpgtw);\n\n    LMI_HELPER(PCMPEQH, pcmpeqh);\n\n    LMI_HELPER(PCMPGTH, pcmpgth);\n\n    LMI_HELPER(PCMPEQB, pcmpeqb);\n\n    LMI_HELPER(PCMPGTB, pcmpgtb);\n\n\n\n    LMI_HELPER(PSLLW, psllw);\n\n    LMI_HELPER(PSLLH, psllh);\n\n    LMI_HELPER(PSRLW, psrlw);\n\n    LMI_HELPER(PSRLH, psrlh);\n\n    LMI_HELPER(PSRAW, psraw);\n\n    LMI_HELPER(PSRAH, psrah);\n\n\n\n    LMI_HELPER(PMULLH, pmullh);\n\n    LMI_HELPER(PMULHH, pmulhh);\n\n    LMI_HELPER(PMULHUH, pmulhuh);\n\n    LMI_HELPER(PMADDHW, pmaddhw);\n\n\n\n    LMI_HELPER(PASUBUB, pasubub);\n\n    LMI_HELPER_1(BIADD, biadd);\n\n    LMI_HELPER_1(PMOVMSKB, pmovmskb);\n\n\n\n    LMI_DIRECT(PADDD, paddd, add);\n\n    LMI_DIRECT(PSUBD, psubd, sub);\n\n    LMI_DIRECT(XOR_CP2, xor, xor);\n\n    LMI_DIRECT(NOR_CP2, nor, nor);\n\n    LMI_DIRECT(AND_CP2, and, and);\n\n    LMI_DIRECT(PANDN, pandn, andc);\n\n    LMI_DIRECT(OR, or, or);\n\n\n\n    case OPC_PINSRH_0:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);\n\n        opn = \"pinsrh_0\";\n\n        break;\n\n    case OPC_PINSRH_1:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);\n\n        opn = \"pinsrh_1\";\n\n        break;\n\n    case OPC_PINSRH_2:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);\n\n        opn = \"pinsrh_2\";\n\n        break;\n\n    case OPC_PINSRH_3:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);\n\n        opn = \"pinsrh_3\";\n\n        break;\n\n\n\n    case OPC_PEXTRH:\n\n        tcg_gen_andi_i64(t1, t1, 3);\n\n        tcg_gen_shli_i64(t1, t1, 4);\n\n        tcg_gen_shr_i64(t0, t0, t1);\n\n        tcg_gen_ext16u_i64(t0, t0);\n\n        opn = \"pextrh\";\n\n        break;\n\n\n\n    case OPC_ADDU_CP2:\n\n        tcg_gen_add_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUBU_CP2:\n\n        tcg_gen_sub_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n\n\n    case OPC_SLL_CP2:\n\n        opn = \"sll\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRL_CP2:\n\n        opn = \"srl\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRA_CP2:\n\n        opn = \"sra\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_DSLL_CP2:\n\n        opn = \"dsll\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRL_CP2:\n\n        opn = \"dsrl\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRA_CP2:\n\n        opn = \"dsra\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    do_shift:\n\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n\n        tcg_gen_andi_i64(t1, t1, shift_max - 1);\n\n\n\n        switch (opc) {\n\n        case OPC_SLL_CP2:\n\n        case OPC_DSLL_CP2:\n\n            tcg_gen_shl_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRA_CP2:\n\n        case OPC_DSRA_CP2:\n\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n\n               we can treat SRA and DSRA the same.  */\n\n            tcg_gen_sar_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRL_CP2:\n\n            /* We want to shift in zeros for SRL; zero-extend first.  */\n\n            tcg_gen_ext32u_i64(t0, t0);\n\n            /* FALLTHRU */\n\n        case OPC_DSRL_CP2:\n\n            tcg_gen_shr_i64(t0, t0, t1);\n\n            break;\n\n        }\n\n\n\n        if (shift_max == 32) {\n\n            tcg_gen_ext32s_i64(t0, t0);\n\n        }\n\n\n\n        /* Shifts larger than MAX produce zero.  */\n\n        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);\n\n        tcg_gen_neg_i64(t1, t1);\n\n        tcg_gen_and_i64(t0, t0, t1);\n\n        break;\n\n\n\n    case OPC_ADD_CP2:\n\n    case OPC_DADD_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_add_i64(t0, t1, t2);\n\n            if (opc == OPC_ADD_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_andc_i64(t1, t2, t1);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_ADD_CP2 ? \"add\" : \"dadd\");\n\n            break;\n\n        }\n\n\n\n    case OPC_SUB_CP2:\n\n    case OPC_DSUB_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_sub_i64(t0, t1, t2);\n\n            if (opc == OPC_SUB_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 2818, "substitutes": {"ctx": ["Context", "this", "pool", "KC", "rc", "np", "self", "mc", "cmp", "cfg", "ct", "c", "lc", "cu", "kt", "anc", "cp", "cc", "req", "rx", "ij", "sys", "context", "dc", "bc", "cm", "jac", "kw", "jp", "xc", "CC", "cpp", "tz", "nc", "sc", "conv", "handle", "conn", "cci", "cb", "loc", "resp", " cx", "txt", "scl", "tm", "act", "pg", "setup", "tc", "obj", "cv", "hw", "pkg", "tmp", "ctl", "cmd", "tx", "ctr", "cas", "ctrl"], "rd": ["cr", "lr", "rc", "rid", "wr", "rb", "th", "d", "rg", "rh", "ru", "rl", "rw", "sd", "rx", "std", "rf", "hr", "rm", "dd", "RW", "rn", "rr", "rin", "ld", "gb", "lb", "usr", "cd"], "rs": ["s", "ars", "ries", "xs", "bs", "ra", "rc", "ros", "ls", "r", "ris", "ts", "ps", "orts", "ras", "rys", "Rs", "ks", "ms", "ys", "fs", "ds", "ows", "vs", "sts", "ats", "sr", "res", "ns", "rates", "ins", "rows", "cs", "hs", "ubs", "RS", "mr"], "rt": ["bt", "cr", "rc", "fr", "nt", "tt", "tr", "vr", "rb", "wr", "pt", "rh", "r", "rl", "rw", "vt", "rx", "rf", "hr", "rm", "rn", "rr", "dt", "rat", "t", "RT", "tm", "mt", "sq", "tx", "ty", "ri", "wt", "mr"], "opn": ["hopn", "opcn", "hopns", "OpN", "opnr", "OPmn", "optn", "optcn", "optnr", "oppn", " opmn", " opN", "Opc", "opmn", "opN", "OPnr", "hoppn", "OPns", "optc", " opns", "hopmn", " oppn", "optnan", " opnr", "OPpn", " opcn", "Opnan", "hopc", "OPn", "OPc", "opns", "optN", " opnan", "hopcn", "OPcn", "opnan", "Opn"], "opc": ["hopn", "opcs", " opC", "copc", "apcode", "ppcs", "copn", "OPct", " opcs", "hopct", "copC", "OPC", "copcs", "opC", "opce", "hopC", "ppc", "opct", " opct", "OPcode", " opf", "OPce", "opcode", " opcode", "copce", "apc", "OPf", "apC", "hopc", "copf", "apn", "OPn", "OPc", "ppcode", "opf", "ppn", " opce", "OPcs", "copcode"], "shift_max": ["shift_MAX", "hift_Max", "hift_min", "shift_min", "hift_max", "hift_MAX", "shift_Max"], "t0": ["t000", "tt2", " t2", "ta00", "pt2", "ta000", "T00", "ta0", "t2", "pt02", "ttb", " tee", "tt02", "t02", "T1", "T0", "tt1", "t4", "tree0", "Tums", "dt0", "tt0", " tb", "pt0", "T000", " t8", "ttee", " tums", " t00", "treeums", "t00", "tee", " t4", "t8", "dt1", "ta1", "tums", "ptee", " t02", " t000", "tree4", "dtb", "T4", "dt8", "tt8", "tree1", "tb"], "t1": ["tone", "T3", "otone", "ot91", "tONE", "dtOne", "t3", " tOne", " t31", " t2", "p3", "otOne", "t2", "p1", "T1", "T0", " t10", "T2", " t9", "tree0", " t3", "t31", " tone", "ot1", "dtone", "tcONE", "T9", "tOne", "dt91", "p2", "t91", "dt1", " tONE", "tc10", "tree9", "t9", "treeONE", "tc1", "p0", "tree31", "t10", "T31", " t91", "tree1", "tree10"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 2820, "substitutes": {"opaque": ["opque", "obque", "Opacity", "Opque", "Opaques", "opacity", "paque", "oposter", "oppaques", " opque", "oboster", "pque", "oppque", "opposter", "obaque", "pacity", " opacity", "Opaque", " opaques", "opaques", "poster", "obacity", "oppaque", "oppacity"], "fid": ["afID", "FId", "fscore", "cfId", "foid", "Fscore", "pID", "cid", "Fvalid", "tfscore", "pvalid", "afid", "Fmid", " fId", "afmid", "cfid", "Fid", "tfid", "tfoid", "fvalid", "FID", "cId", "tfId", "cID", "fId", "Foid", "cvalid", " fmid", "fID", "fmid", "cfoid", "pId", " fID", "pid", "cfscore"], "v9stat": ["v9stats", "vm9st", "v9pri", "v9str", "v6stats", "ev89decl", "vm9rat", "v98Stat", "ev9stat", "v8sat", "vm900rat", "V6Stat", "ev9status", "invninestat", "v90str", " v8stat", "f9sat", "v90stat", "v98pri", "v8pri", "inv9summary", "ev9attr", "v09rat", "v9sat", "V9Stat", "inv9stat", "v09st", "invninesummary", " v8Stat", "v09hit", "v9warn", "v999attr", "v909state", "V6stat", "v09pri", "v9attr", "v90state", "v89stat", " v8stats", "v900stat", "v970stat", "v89feat", "invninewarn", "v9dat", "v900hit", "inv9attr", "f9stat", "vnineattr", "v970dat", "v910stat", "v970feat", "V9status", "v89decl", "ev89stat", "v89attr", " v9status", " v89str", "v9state", "ev9dat", "v9rat", "v999warn", "v999summary", "vm9stat", "v09sat", "vninestatus", "v8status", "v09stat", "v8stats", " v8status", "V6status", " v9Stat", " v9state", "v910attr", "v949attr", "v89str", " v89err", "vm900st", "ev89attr", "v89err", " v9str", "v6status", " v9stats", "v6stat", " v89stat", "f8pri", "vninewarn", "vninestat", "vm900stat", "f8Stat", "v909err", "vninedat", "v9hit", "f8sat", "v90err", "v910summary", "invnineattr", "v909stat", "v999st", "ev89feat", "v909str", "v949stat", "v9st", "vninedecl", "v89state", "v8stat", "vm900hit", "v999hit", "v900st", " v89state", "v98sat", "vninefeat", "v999stat", "inv9warn", "vninesummary", "v900rat", "v970status", "v98stat", "vm9hit", "v8Stat", "V9stat", "f9Stat", "ev89status", " v9err", "v9status", "v949decl", "v910warn", "ev9feat", "v09Stat", "f8stat", "ev9decl", "v9summary", "v9feat", "v89dat", "v9err", "v9Stat", "v9decl", "v6Stat", "v999rat", "v89status", "ev89dat", "f9pri", "v949status"], "stbuf": ["ndBuffer", "STBuffer", "ostbuf", " stBuffer", "ostvec", "estvec", "estbuff", "STdoc", "Stbuf", "STuf", "stbuffer", "stBuffer", "estbuf", "ostbuff", "stvec", "estbuffer", "Stvec", "nddoc", "nduf", " stdoc", "Stbuff", "ndbuf", "stdoc", "stbuff", " stuf", "ostbuffer", "stuf", "STbuf", "Stbuffer"], "fidp": ["fidpt", " fidps", "fitps", "ufridP", " fidP", "fidper", "fIdp", "fidentps", "ufidp", "fidentq", "ufidpa", "fIdP", "fIDper", " fidpt", "FIdl", "facidentping", "fitp", "fidl", "finp", "foidl", "fidentpid", "Fidpa", "fidP", "facidentm", "foidm", "fitpt", " fitpt", "fidpre", "ufridp", " fidpa", "fitpid", "fidps", "facidentpre", " fidpid", "fidq", " fitp", "facidentp", "fridq", "fidentP", "fidentpre", "foidping", "fpidps", "fIdper", "facidping", "fridping", " fitpid", "FidP", "fidentpt", "fidpid", "Fidl", "fIDpa", "ufridq", "Fidper", "fpidpid", "fidpa", "fIDp", "fpidpt", "fIDP", "fidentping", "facidpre", "facidp", "FIdp", "foidp", "fridP", "Fidp", "foidpa", "fridm", "fidentm", "facidm", "fidentpa", "fidm", "fIdl", "fidping", "fpidp", "finpa", "ufidq", " fitps", "fidentp", "foidP", "finl", "fIdpa", "FIdpa", "finP", "fridpre", "FIdP", "foidpre", "ufridpa", "fridp", "FIdper", "ufidP", "fridpa"], "pdu": ["pkgce", " pso", "puer", "ppce", "uptu", " pkt", "aptu", "opcom", "pades", "pcui", "dpdr", "pud", " pdat", "patchuc", "formdu", " pue", "ppso", "formtu", "pdi", "ipud", "ipdem", "pkgdu", "pcdu", "opue", " pda", "opunit", "upud", "apdem", "dpdi", "apge", "apdr", "opdem", "pru", "padu", "ppkt", "pkgtu", " pdr", "ppue", "wpud", " punit", "apkt", "ipdu", "patchtu", "wpdu", " pui", "wpdi", "payru", " pcu", "punit", " pu", "ppcu", "ppdu", "pingkt", " pcom", "opge", "pda", "apdo", "patchdu", "upue", "apue", "impu", "compdu", "ipda", " pdi", "dpud", " pru", "apcu", "compkt", "patu", "dpda", "pdem", "pingtu", " ptu", "pkgdat", "impue", "patchcmd", "wpdr", "ppu", "apuc", "pge", " pdem", "pdat", "pcso", "ppda", "prdu", "apdu", "puc", "apcmd", "pce", "pcdes", "dpdem", " pdes", " pce", " pud", "apud", "pptu", "pingud", "opru", "ppud", "pu", "pingdu", "updu", "formuer", "compue", "opdu", "paydu", " pge", "pcom", " pcmd", "pue", "formdes", "prdem", "pdr", "prda", " pdo", "pdo", "prud", "patchdes", "pui", "pauer", "patchuer", "paycom", "pingda", "impdu", "pcmd", "pdes", " puc", "comptu", "pso", "ppdat", "pkt", "pingue", "impdr", "ptu", "patchdo", "ppdes", "ppui", "payunit", "ppdr", "dpdu", "pcu"], "s": ["n", "spec", "stats", "bs", "es", "b", "c", "status", "d", "w", "r", "p", "ts", "its", "ps", "i", "is", "v", "gs", "e", "ss", "g", "sv", "os", "o", "fs", "ds", "set", "sts", "t", "ns", "state", "rs", "as", "sb", "S", "ins", "h", "y", "span", "z", "f", "sp", "m"]}}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 2832, "substitutes": {"op1": ["opt2", "Op1", "hop2", "op8", "hop4", "hopl", "hopOne", "cop1", "Op2", " op4", " op01", "hopone", "OP2", "p_", "popN", " opone", "op4", "hop01", "p1", "op01", "opt1", " opOne", "pop1", "copone", "opOne", "hop1", " opN", "cop0", "OP1", "pop2", "opt4", "opt8", "opt01", "optl", "opN", "opt0", "opone", "op0", "OPOne", " op0", "pop0", "opl", "p2", "Opone", "OpOne", "copl", "OPone", " op_", "optone", "opt_", "hop0", "p0", " op8", "hop8", "pop_", "optN", "op_"], "op2": ["opt2", "op02", "op22", "hop2", "op8", "ip1", "tip1", "OP2", " optwo", "hop102", "opt1", "tip2", "optwo", "hop1", "OP8", "hoptwo", "OP1", "opt8", "ip2", "op0", "top1", " op0", " op02", "opt22", " op102", "tiptwo", "ip0", "ip02", "top02", "op102", "top0", "tip102", " op8", " op22", "OP22", "top2"]}}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 2846, "substitutes": {"of_dpa": ["of_dpo", "of_iddp", "of_vdpu", "of_didppa", "of_Dara", "of_vddp", "of_Dpa", "of_idpa", "of_vdpi", "of_Ddp", "of_idpi", "of_dpi", "of_ddp", "of_idpu", "of_dara", "of_Dpi", "of_Dppa", "of_vdpa", "of_Dpo", "of_didpo", "of_Dpu", "of_didpa", "of_dppa", "of_dpu", "of_didara"], "group": ["guard", "GROUP", "record", "display", "graph", "error", "one", "player", "v", "sync", "member", "draw", "handle", "store", "coll", "go", "process", "part", "component", "database", "order", "module", "package", "role", "global", "pattern", "db", "Group", "single", "app", "batch", "status", "map", "sum", "band", "window", "row", "message", "command", "list", "force", "host", "user", "table", "mail", "debug", "public", "chain", "config", "data", "channel", "rule", "p", "arg", "match", "field", "manager", "join", "service", "form", "filter", "comment", "block", "remote", "local", "roup", "parent", "who", "g", "network", "link", "profile", "call", "pg", "client", "game"], "group_tlvs": ["group_tlvr", "group_tlfS", "group_tlvd", "group_Tlfis", "group_Tlfs", "group_tlfss", "group_tLVd", "group_txts", "group_tlfs", "group_dlvd", "group_tlsss", "group_tlss", "group_Tlvis", "group_tyles", "group_flvS", "group_Tlfes", "group_tcoles", "group_tlfis", "group_tcols", "group_tlevr", "group_flvs", "group_tcps", "group_plvs", "group_tlves", "group_nlvS", "group_tlvis", "group_nlfS", "group_tlevss", "group_tlevs", "group_nlvr", "group_flfss", "group_nlfr", "group_dlls", "group_plfes", "group_tcpes", "group_txtr", "group_flvss", "group_tyls", "group_tcolis", "group_tlevS", "group_tlld", "group_tlvc", "group_tlfd", "group_tlsS", "group_tlfr", "group_tlvss", "group_tllc", "group_Tlvs", "group_dlvc", "group_nlvs", "group_txtS", "group_flfs", "group_tlls", "group_flfS", "group_tllis", "group_nlfs", "group_dllc", "group_dlld", "group_plves", "group_tLVc", "group_Tlves", "group_tlles", "group_tlfes", "group_plfs", "group_dlvs", "group_tLVs", "group_tlvS", "group_tlfc"], "l2_group": ["l2__part", "ltwomyuser", "l3_group", "l3_match", "l3_user", "l3__part", "ltwo_group", "l3_part", "l2myblock", "l1_group", "l2_groups", "l2_user", "l2_match", "ltwomyblock", "l2__user", "l2_block", "l2mygroups", "l3__group", "l2___group", "l2_field", "ltwomygroups", "l2___part", "l2___user", "l2_part", "l1_groups", "l1_user", "l1_field", "l3__match", "l2__match", "ltwo_block", "ltwo_groups", "ltwo_user", "l2___match", "l3__user", "l2mygroup", "l2__group", "ltwomygroup", "l2myuser"], "tlvs": ["tlvers", "tlevers", "tlfS", "etlvds", "tlevs", "twlfs", "tvvers", "tlvals", "tlvses", "latlvc", "etvvals", "tladers", "twls", "tlevfs", "etlvers", "tolfs", " tlve", "latvvs", "taves", "wlvfs", "etlvals", "tvves", "tvdS", "latvvc", " tlvS", " tbufses", "tvvals", "tlege", "tlfc", "tvvc", "latlvfs", " tbufs", "etvvs", "tbufes", "latvvfs", "latlves", "tlvds", "wlvs", "tlvS", " tlfS", "tavses", "tvvf", "tlegS", "tvds", "tavs", "tlfses", "etlvs", "tvvds", "latlvs", "tlfe", "tlves", "tlvfs", "wlvf", "twlf", "etvvers", " tlvses", "wwls", "tbufs", " tlves", "latvves", "tbufses", "tlads", "tvde", "tleves", "tlvf", "tlegs", "tvvs", " tlfs", "tlffs", "tlevds", "tlve", "tolff", "wwlfs", "tlvc", "tlevals", "tladals", "etvvds", "wwlf", "tolffs", "tlfes", "tvvfs", "tlfs", " tbufes", " tlfe", "tladds", "tlevc"], "err": ["attr", "cr", "lr", "cli", "str", "iter", "fr", "gz", "cfg", "rb", "error", "kr", "r", "ered", "l", "late", "Error", "out", "e", "gr", "oe", "race", "arr", "elt", "rn", "rr", "or", "it", "aaa", "msg", "er", "fee", "rs", "txt", "order", "usr", "ner", "ie", "dr", "nr", "Er", "ctr", "m", "result", "mr"], "i": ["oi", "cli", "eu", "uri", "mi", " si", " mi", "ind", " I", "ai", "v", "ei", "is", "ic", "it", "si", "ie", "y", "ti", "phi", "iu", "bi", "hi", "init", "ui", "batch", " m", "di", "x", "ini", " di", "zi", "ims", "xi", " ti", "ami", " ii", "index", "multi", "chain", "sim", "ri", "j", "I", "point", "im", "ki", " bi", "l", "ip", "key", "ix", "ci", "span", " ni", "us", "gi", "m", "ex", "li", " j", "ii", "remote", "ji", "\u0438", "parent", "u", "pi", "in", " pi", "me", "qi", "fire", "gu", "print"]}}
{"project": "FFmpeg", "commit_id": "8bdba1092f50d52e0af90f425811302ec91152f8", "target": 1, "func": "int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    const uint64_t fuzz_tag = FUZZ_TAG;\n\n    FuzzDataBuffer buffer;\n\n    const uint8_t *last = data;\n\n    const uint8_t *end = data + size;\n\n    uint32_t it = 0;\n\n\n\n    if (!c)\n\n        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.\n\n\n\n    AVCodecContext* ctx = avcodec_alloc_context3(NULL);\n\n    if (!ctx)\n\n        error(\"Failed memory allocation\");\n\n\n\n    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs\n\n\n\n    int res = avcodec_open2(ctx, c, NULL);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    FDBCreate(&buffer);\n\n    int got_frame;\n\n    AVFrame *frame = av_frame_alloc();\n\n    if (!frame)\n\n        error(\"Failed memory allocation\");\n\n\n\n    // Read very simple container\n\n    AVPacket avpkt;\n\n    while (data < end && it < maxiteration) {\n\n        // Search for the TAG\n\n        while (data + sizeof(fuzz_tag) < end) {\n\n            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)\n\n                break;\n\n            data++;\n\n        }\n\n        if (data + sizeof(fuzz_tag) > end)\n\n            data = end;\n\n\n\n        FDBPrepare(&buffer, &avpkt, last, data - last);\n\n        data += sizeof(fuzz_tag);\n\n        last = data;\n\n\n\n        // Iterate through all data\n\n        while (avpkt.size > 0 && it++ < maxiteration) {\n\n            av_frame_unref(frame);\n\n            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);\n\n\n\n            if (it > 20)\n\n                ctx->error_concealment = 0;\n\n\n\n            if (ret <= 0 || ret > avpkt.size)\n\n               break;\n\n\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n    }\n\n\n\n    av_init_packet(&avpkt);\n\n    avpkt.data = NULL;\n\n    avpkt.size = 0;\n\n\n\n    do {\n\n        got_frame = 0;\n\n        decode_handler(ctx, frame, &got_frame, &avpkt);\n\n    } while (got_frame == 1 && it++ < maxiteration);\n\n\n\n    av_frame_free(&frame);\n\n    avcodec_free_context(&ctx);\n\n    av_freep(&ctx);\n\n    FDBDesroy(&buffer);\n\n    return 0;\n\n}", "idx": 2857, "substitutes": {"data": ["DATA", "time", "hash", "length", "error", "output", "cache", "next", "multiple", "video", "draw", "value", "to", "done", "address", "padding", "id", "mode", "pos", "str", "empty", "batch", "at", "after", "buf", "pad", "window", "Data", "message", "len", "ord", "a", "dat", "ta", "feed", "rel", "table", "index", "no", "extra", "date", "add", "ata", "read", "this", "input", "only", "step", "new", "response", "start", "p", "out", "body", "format", "name", "all", "key", "win", "position", "state", "text", "mu", "tx", "result", "base", "first", "final", "bytes", "na", "byte", "d", "type", "timeout", "delay", "offset", "send", "context", "image", "shift", "reset", "res", "t", "load", "da", "zero", "device", "content", "raw", "none"], "size": ["tag", "spec", "count", "n", "empty", "time", "use", "length", "bytes", "unit", "style", "any", "error", "status", "start", "sn", "w", "capacity", "speed", "height", "cache", "sum", "type", "timeout", "description", "scroll", "offset", "send", "body", "ize", "st", "format", "message", "len", "name", "space", "shift", "scope", "limit", "code", "position", "iz", "set", "loc", "since", "fee", "ci", "now", "ose", "args", "index", "SIZE", "scale", "sized", "shape", "storage", "sent", "small", "Size", "notice", "pos"], "buffer": ["null", "bridge", "input", "empty", "pool", "builder", "length", "engine", "batch", "temp", "comment", "face", "channel", "cache", "gc", "memory", "buf", "timeout", "window", "row", "v", "connection", "header", "context", "template", "message", "command", "client", "queue", "fc", "image", "document", "limit", "code", "sequence", "table", "ref", "cv", "tc", "package", "Buffer", "f", "reference", "event", "buff", "base"], "last": ["count", "first", "latest", "final", "length", "self", "nd", "start", "ast", "after", "max", "cache", "buf", "est", "parent", "old", "l", "tail", "out", "st", "next", "low", "before", "best", "prev", "all", "Last", "las", "full", "total", "since", "t", "state", "vol", "base"], "end": ["ment", "hend", " End", "END", "ext", "pend", "ff", "length", "End", "nd", "start", "w", "after", "max", "p", "ended", "ec", "est", "pad", "old", "offset", "ender", "out", "next", "st", "e", "send", "eng", "append", "len", "en", "ord", "all", "ending", "set", "stop", "total", "enc", "begin", "obj", "ent", "h", "dev", "east", "rend", "add", "id", "event", "off"], "ctx": ["proc", "wx", "this", "pool", "np", "nt", "mc", "cmp", "ct", "c", "ca", "lc", "func", "cu", "kt", "gc", "cp", "cc", "buf", "req", "cf", "window", "sys", "context", "bc", "dc", "cm", "co", "jac", "kw", "xc", "fc", "jp", "rt", "tz", "nc", "sc", "conv", "conn", "ac", "cb", "addr", "wcs", "loc", "msg", "iat", "res", "qt", "ctrl", "txt", "unc", "act", "cv", "tc", "cl", "obj", "pkg", "ctl", "cmd", "tx", "err", "ctr", "buff", "con", "alloc"], "got_frame": ["seenptframe", "got_time", "got__state", "created_style", "gotptframe", "got___time", "got_range", "got_Frame", "Got_frame", "gotjstep", " got_window", "seen_component", "got_state", "gotjtag", "created_tag", "got___request", "got___channel", "got_tag", "got_request", "got_channel", "got__frame", "createdjstep", "Got_channel", "createdjframe", "got_step", "hung_range", "gotjstyle", "seen_window", "hung___range", " got_time", "got__Frame", "seen_frame", "seenptwindow", "createdjstyle", "Got_state", "Got__state", "seen_data", "got___window", "hung___point", "got___frame", "got___state", "gotptcomponent", "created_step", "got_window", "hung_channel", "createdjtag", "got___point", "hung___channel", "got__channel", "Got__frame", "Got__Frame", "got_point", "seenptdata", "gotptwindow", "Got_Frame", "gotjframe", "got___Frame", "seenptcomponent", "got_component", "got_data", "got_style", "gotptdata", "hung_frame", "created_frame", "hung___frame", "hung_point", "Got__channel", " got_request", "got___range"], "frame": ["proc", "fb", "init", " Frame", "fr", "point", "fram", "error", "face", "channel", "kt", "block", "remote", "Frame", "thread", " timeframe", "feat", "window", "row", "cf", "header", "next", "context", "fi", "def", "rame", "image", "command", "fc", "rt", " framed", " frames", "box", "draw", "reset", "flow", "uart", "code", "sequence", "process", "ce", "profile", "qt", "base", "framework", "state", "call", "feature", "frames", "ptr", "ace", "package", "iframe", "f", "scene", "cmd", "tx", "range", "chain", "function", "line", "instance"], "avpkt": ["avcpct", "averpct", "averpacket", "evpet", "avenpcmd", "avpingacket", "avpppt", "avcacket", "avPet", "avtpcmd", "vernpacket", "verpacket", "avcpet", "avparpt", "avpckg", "avcpacket", "avlpacket", "verpct", "avpcpt", "avPett", "avepkt", "vrpkg", "avprekt", "avpadwk", "averpkt", "aveopett", "avpskt", "avpackwk", "avPcmd", " avcpct", "avwpkt", "avpingkt", "avnpjson", "avpsett", "avepjson", "avnpacket", "evwpct", "evpacket", "avPkt", "vrparkt", "ahpackwk", "averlpett", "evpct", "avepwk", "avPacket", "avopkt", "evwpkt", "avenpkt", "avpjson", "vernpct", "verpett", "avpaykat", "avtipwk", "avnpwk", "averlpacket", "averlpkt", "avpwk", "evwpacket", "avopet", "avepet", "avpacket", "avepcacket", "avepcmd", "avmacket", "vrtipwk", "avmct", "avwpct", "avpett", "avtpwk", "avppwd", "aveopkt", "vrparwd", "avppacket", "avpadkt", "avcpett", "vrpwd", "avtpkt", "avpsacket", "vrtipkat", "avcpkt", "ahpkt", "avenpett", "vernpkt", "avparkt", " avcpacket", "vrtipkg", "avpqt", "avpcacket", "avwpet", "avpaykt", "avppkg", "avpkg", "avtipkat", "evpkt", "avpet", "avPct", "vrpkat", "avpkget", "avopett", "avparwd", "avpkgjson", "ahpwk", "avpadkg", "avpct", "avpckt", "avepett", "avepcct", " avcpkt", " avpacket", "vrtipkt", "averpingct", "avcett", "avPwk", "avpcwd", "vrppt", "avepckt", " avcpett", "avppt", "vrpwk", "avcct", "averlpqt", "avlpqt", "avpwd", "avpcmd", "avpkgett", "avpkgkt", "vrparpt", "avpcqt", "avopacket", "avpcett", "avppett", "avmett", "ahpackkg", "vernpett", "avpadkat", "avpcct", "aveopet", "avparkg", " avpct", "avnpct", "averpingacket", "avtipkt", "avtipkg", "avnpett", "avpsct", "aveopjson", "avpackett", "avpingett", "avnpet", "avwpacket", "avenpwk", "averpingkt", "avtpett", "avlpett", "ahpackkt", "avwpett", "avopqt", "avppct", "avepacket", "avpackkg", "avpackkt", "verpkt", "avpaywk", "avnpcmd", "avepct", "vrparkg", "avpaykg", "avlpkt", " avpett", "averpqt", "avppkt", "avpcwk", "ahpett", "avnpkt", "avprewk", "avopjson", "avckt", "avpkat", "avprekg", "ahpkg", "avpingct", "avpreett", "averpett", "ahpackett", "vrpkt", "avepcett", "avmkt", "evwpet", "averpingett"], "it": ["ist", "n", "you", "init", "iter", "what", "IT", "ait", "nt", "exec", "unit", "ct", "quit", " i", "att", "lit", "at", "ot", "im", "try", "r", "opt", "after", "p", "ut", "its", "timeout", "i", "ul", "hit", "ind", "ip", "out", "git", "ort", "format", "g", "ic", "bit", "or", "al", "set", "It", "jit", "iz", " wait", "ta", "op", "which", "t", "ate", "ect", "mit", "act", "ie", "and", "ent", "we", " t", "id", " total", "wait", "j", "ex"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 2880, "substitutes": {}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n", "idx": 2884, "substitutes": {"env": ["esm", "cap", "dem", "org", "ef", "w", "map", "environment", "vt", "buf", "ec", "shell", "mem", "te", "v", "window", "pres", "sh", "context", "e", "conf", "estate", "esc", "nc", "ctx", "sv", "en", "conn", "code", "server", "viron", "vs", "end", "er", "vp", "setup", "h", "obj", "cv", "config", "ev"], "s": ["sam", "service", "n", "sg", "stats", "spec", "ports", "bs", "qs", "q", "ses", "self", "comm", "services", "utils", "es", "b", "c", "ls", "pers", "als", "p", "ts", "ps", "i", "changes", "gs", "is", "v", "stat", "sys", "e", "ss", "g", "ims", "source", "sv", "os", "scope", "bis", "store", "ds", "fs", "set", "vs", "settings", "sts", "ats", "server", "rs", "ns", "t", "serv", "args", "sb", "S", "ins", "sw", "session", "h", "sl", "sq", "ess", "cs", "hs", "sp", "aws", "js", "j"], "insn": ["psns", "ingn", "ainsner", "linsgn", "Insner", "Insen", "pssn", "risen", "Insn", "rissn", " insgn", "linscn", "risner", "ainsen", "insner", "risn", "itsgn", "inssn", "itsns", "pscn", "Inscn", "psn", "incn", "inscn", "ainsn", "linssn", "insns", "psgn", "inn", "Insns", "linsn", "linsns", "itsn", "insgn", "ainsgn", "itssn", "insen", "Inssn", " inscn", " inssn", "ainssn"]}}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n", "idx": 2895, "substitutes": {"ot": ["ott", "tt", "et", "nt", "cot", "ct", "at", "pt", "oc", "ut", " tot", "ant", "pot", "ote", "oid", "oot", "hot", "ort", "gt", "rt", "ic", "lt", "OT", "or", "mot", "op", "ots", "rot", "t", "iat", "y", "ent", "iot", "net", "ox", "ota", "iet"], "t0": ["p5", "m5", "t000", "t1", "tnew", "tdnew", "m0", "p8", "tt2", "timenew", "t512", "tree512", " t2", "td000", "tree6", "m1", "t2", " t1", " T0", "p1", "td6", "t150", "tt1", " t512", "tree0", " t6", " t150", "tt0", "dt0", "time0", " t8", "td0", " T1", "dt150", " t5", "p150", "t6", "dtk", "tk", "m8", "t8", "dt1", " tk", "time000", " t000", "p0", "pk", " T2", "t5", " tnew", "td512"], "reg": ["tag", "sec", "rc", "rid", "nt", "org", "re", "cell", "rank", "block", "mod", "rec", "r", "gc", "ret", "rest", "req", "REG", "mem", "row", "ind", "leg", "eng", "rm", "Reg", "g", "region", "num", "round", "ord", "br", "ig", "key", "brand", "code", "addr", "loc", "res", "state", "ref", "index", "act", "eg", "net", "err", "desc", "typ", "rem"]}}
{"project": "qemu", "commit_id": "54421cb17bc744bad15f2b1adb4adefdaea83c10", "target": 0, "func": "static int hdev_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int access_flags, create_flags;\n\n    DWORD overlapped;\n\n    char device_name[64];\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        if (find_cdrom(device_name, sizeof(device_name)) < 0)\n\n            return -ENOENT;\n\n        filename = device_name;\n\n    } else {\n\n        /* transform drive letters into device name */\n\n        if (((filename[0] >= 'a' && filename[0] <= 'z') ||\n\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n\n            filename[1] == ':' && filename[2] == '\\0') {\n\n            snprintf(device_name, sizeof(device_name), \"\\\\\\\\.\\\\%c:\", filename[0]);\n\n            filename = device_name;\n\n        }\n\n    }\n\n    s->type = find_device_type(bs, filename);\n\n    \n\n    if ((flags & BDRV_O_ACCESS) == O_RDWR) {\n\n        access_flags = GENERIC_READ | GENERIC_WRITE;\n\n    } else {\n\n        access_flags = GENERIC_READ;\n\n    }\n\n    create_flags = OPEN_EXISTING;\n\n\n\n#ifdef QEMU_TOOL\n\n    overlapped = FILE_ATTRIBUTE_NORMAL;\n\n#else\n\n    overlapped = FILE_FLAG_OVERLAPPED;\n\n#endif\n\n    s->hfile = CreateFile(filename, access_flags, \n\n                          FILE_SHARE_READ, NULL,\n\n                          create_flags, overlapped, NULL);\n\n    if (s->hfile == INVALID_HANDLE_VALUE) \n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 2903, "substitutes": {"bs": ["bt", "BS", "bp", "bi", "bl", "lbs", "es", "b", "bps", "blog", "ls", "bh", "ts", "bn", "ps", "its", "gs", "bc", "bm", "bf", "cks", "obs", "bos", "aos", "ms", "os", "bis", "fs", "ds", "vs", "rs", "ns", "bits", "sb", "bb", "bd", "cs", "js", "ubs", "ubis", "bes"], "filename": ["n", "tp", "sbm", "FN", "rather", "fle", "metadata", "uri", "handle", "location", "txt", "Filename", "FIL", "dump", "json", "wit", "directory", "ame", "ename", "wire", "without", "they", "status", "family", "prefix", "knife", "archive", "file", "nil", "kj", "wcs", "fn", "unction", "ln", "LCS", "ames", "names", "latest", "jpg", "png", "username", "kan", "their", "journal", "original", "name", "rn", "position", "ilers", "doi", "where", "NAME", "files", "nm", "til", "result", "nl", "ren", "final", "ammy", "path", "assets", "mpeg", "description", "fp", "whatever", "title", "source", "println", "nature", "fd", "subject", "unc", "f", "fil", "there", "wikipedia", "label", "forth"], "flags": ["ports", "flag", "FLAG", "events", "ants", "planes", "options", "utils", "ags", "atts", "sets", "styles", "states", "ts", "fps", "reports", "tags", "comments", "olds", "heads", "members", "ops", "fields", "levels", "acts", "features", "settings", "ensions", "types", "bits", "args", "weights", "vals", "lag", "locks", "ids", "pins", "details", "Flags", "names", "properties", "actions"], "s": ["sports", "n", "stats", "qs", "self", "ses", "b", "ssl", "ls", "status", "sn", "als", "p", "ts", "its", "uns", "ps", "gs", "v", "is", "sys", "less", "ss", "g", "ms", "sis", "sv", "ies", "bis", "fs", "ds", "acs", "sts", "ats", "gets", "t", "rs", "ns", "sb", "S", "ins", "h", "locks", "cs", "js", "j", "bes"], "access_flags": [" access_mask", "access_lines", "access_locks", "usageionflags", "accessurenotes", "access2settings", " access2flags", "access_notes", "access_rules", "usage_details", "access2locks", "usageionrules", "accessionposts", "access_mask", "usage_posts", "access_flag", " access_locks", "access2flags", "accessiondetails", "access2mask", "usageiondetails", "accessureflags", "access_settings", "access2details", " access_settings", " access_lines", "accessuredetails", " access_rates", " access2settings", "usage_rules", " access2details", "access2notes", "usageionposts", "accessuresettings", " access_flag", "usage_flags", "accessionflags", " access_notes", "access_properties", " access_details", " access_properties", "access_details", "accessionrules", "access_rates", " access2notes", "access_posts", "access2flag"], "create_flags": [" create_links", "create_flag", "create_fields", " create_lines", "create_lines", " create_flag", "create2lines", "create_type", "create_files", " create_type", "create_links", "create_details", "create2flags", "create2flag", " create_files", " create_fields", " create_details", "create2details"], "overlapped": ["overflapping", "overliapping", " overlapping", "Overlcoded", "overLapped", " overlaped", "overmapped", "overlaped", "overlAPS", "overflaps", "Overlashed", "Overlaped", "overklaped", "overlaps", "overlcoded", "Overklapped", "overlcaped", "overlitapping", "overklapping", "Overlcapping", "Overlcapped", "overlitoded", " overLaps", "overliashed", "overklashed", "Overloded", "overlitapped", "Overlapped", "overmAPS", "overklapped", "overmapping", " overLaped", "overlcapped", "Overlaps", "Overklashed", " overLapped", "overkloded", "overlashed", " overlaps", " Overlaped", " Overlcaped", "Overklapping", "Overlcaped", " OverlcAPS", " OverlAPS", " Overlcapping", "overflaped", " overLapping", "overvapped", "overliapped", "overvaped", " Overlapped", "overflapped", "overvaps", "overLaped", "overlitaped", "Overklaps", " Overlcapped", "overflAPS", "Overlapping", "overlapping", "overliaps", "overlcapping", "overLaps", "overklaps", "overLapping", "overvapping", "overmaped", "overloded", " Overlapping", "overlcAPS", "overLashed"], "device_name": ["device_nm", "device_default", "objectlyfile", "dev_name", " device_path", "deviceNamename", "dev_id", "object_file", "device_list", "devicelystring", "device_info", "store_name", "volume_class", "medialyparent", "deviceNamedefault", "media_parent", "devicelyadmin", "module_default", "volume_name", "object_data", "devicelyfile", "devicelyno", "storelyorder", "object_no", "deviceNameno", "devicelyname", "medialyname", "device_no", "device_string", "object_name", "storelyadmin", "media_name", "medialylink", "dev_info", "store_admin", "storelystring", "device_parent", "objectlyname", "dev_nm", "device_order", "medialyinfo", "device_admin", "device_id", "device_link", "volume_list", "devicelydata", "media_link", "deviceNamedata", "devicelylink", "deviceNametree", "module_link", "devicelyinfo", "devicelyorder", " device_file", "module_name", "deviceNamelink", "store_string", "module_tree", "store_order", "storelyname", "objectlyno", "device_data", "device_file", "deviceNamefile", "device_tree", "objectlydata", "devicelyparent", "device_path", "device_class", "media_info", "volume_file"]}}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);\n\n        return;\n\n    }\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    /* parameter must be aligned to 1024-byte boundary */\n\n    if (si->param & 0x3ff) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (kvm_s390_store_adtl_status(cpu, si->param)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 2911, "substitutes": {"cs": ["s", "bs", "CS", "ces", "ics", "es", "c", "ls", "ts", "cp", "ps", "cc", "its", "pc", "ck", "is", "sys", "gs", "cks", "ss", "sc", "ms", "ys", "ctx", "acs", "fs", "ds", "sts", "wcs", "ci", "ns", "rs", "cus", "hs", "js", "cas", "css"], "arg": ["ad", "param", "spec", " argument", "ag", "app", "sec", "event", "from", "att", "w", "match", "sa", "i", "ai", "v", "argument", "ary", "ax", "def", "in", "arm", "info", "g", "conf", "reg", "ar", "ay", "or", "ig", "arp", "ma", "ac", "msg", "aj", "as", "args", "Arg", "cmd", "config", " args", "j", "data"], "cpu": ["proc", "core", "pro", "tp", "cli", "aco", "ilo", "c", "CPU", "cu", "gc", "p", "uu", "cp", "pc", "ck", "sky", "sys", "cn", "linux", "pixel", "nc", "sc", "ctx", "process", "device", "pu", "phys", "clock", "us", "gpu", "cus", "hw", "du", "mu", "phy", "net", "processor", "vm", "pkg", "mac", "cum"], "si": ["iu", "oi", "bi", "sie", "ali", "SI", "isi", "ui", "vi", "asi", "di", "yi", "gi", "ia", "ii", "ati", "ni", "mi", "ki", "eni", "Si", "ji", "sa", "i", "ei", "ai", "ity", "ij", "pi", "fi", "ini", "info", "zi", "qi", "xi", "sis", "ami", "gu", "ci", "esi", " ni", "ski", "ti", "sci", "ri"]}}
{"project": "qemu", "commit_id": "ff1d1977ffe1c276f5937a6ad4b6a5b6d2b1c6ae", "target": 0, "func": "static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = ldtul_p(mem_buf);\n\n\n\n    if (n < 32) {\n\n        env->active_tc.gpr[n] = tmp;\n\n        return sizeof(target_ulong);\n\n    }\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)\n\n            && n >= 38 && n < 73) {\n\n        if (n < 70) {\n\n            if (env->CP0_Status & (1 << CP0St_FR))\n\n              env->active_fpu.fpr[n - 38].d = tmp;\n\n            else\n\n              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;\n\n        }\n\n        switch (n) {\n\n        case 70:\n\n            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;\n\n            /* set rounding mode */\n\n            RESTORE_ROUNDING_MODE;\n\n#ifndef CONFIG_SOFTFLOAT\n\n            /* no floating point exception for native float */\n\n            SET_FP_ENABLE(env->active_fpu.fcr31, 0);\n\n#endif\n\n            break;\n\n        case 71: env->active_fpu.fcr0 = tmp; break;\n\n        }\n\n        return sizeof(target_ulong);\n\n    }\n\n    switch (n) {\n\n    case 32: env->CP0_Status = tmp; break;\n\n    case 33: env->active_tc.LO[0] = tmp; break;\n\n    case 34: env->active_tc.HI[0] = tmp; break;\n\n    case 35: env->CP0_BadVAddr = tmp; break;\n\n    case 36: env->CP0_Cause = tmp; break;\n\n    case 37: env->active_tc.PC = tmp; break;\n\n    case 72: /* fp, ignored */ break;\n\n    default: \n\n\tif (n > 89)\n\n\t    return 0;\n\n\t/* Other registers are readonly.  Ignore writes.  */\n\n\tbreak;\n\n    }\n\n\n\n    return sizeof(target_ulong);\n\n}\n", "idx": 2913, "substitutes": {"env": ["param", "tern", "email", "erv", "org", "erd", "cur", "ve", "era", "te", "ei", "v", "eng", "en", "conn", "er", "door", "enc", "etc", "ent", "console", "actor", "net", "cmd", "erb", "test", "Environment", "eh", "ef", "worker", "environment", "buf", "req", "window", "esc", "viron", "vs", "operator", "uv", "extra", "desc", "eas", "em", "ext", "rc", "ew", "et", "engine", "nv", "equ", "eni", "ec", "vv", "stage", "here", "estate", "ctx", "code", "addr", "manager", "ener", "msg", "gear", "el", "eb", "query", "ten", "enter", "e", "context", "oe", "client", "conf", "network", "doc", "end", "server", "ev", "ner", "obj", "dev", "ee", "vm", "event", "ah", "db"], "mem_buf": ["mem2buffer", "memvuf", "memvbuf", "memory_bl", "memvbuffer", "memvbl", "mem2bl", "memory_uf", "mem_uf", "mem2uf", "mem_buffer", "memory_buff", "mem_buff", "mem_bl", "mem2buf", "memory_buffer", "memory_buf"], "n": ["count", "nw", "note", "nl", "dn", "ren", "np", "gn", "nt", "an", "nu", "na", "c", "nor", "new", "d", "sn", "after", "p", "on", "i", "l", "v", "number", "e", "x", "nan", "cn", "next", "g", "len", "tn", "name", "nc", "num", "network", "ne", "en", "conn", "all", "ng", "un", "non", "o", "nb", "t", "ns", "fn", "node", "N", "index", "no", "y", "h", "z", "ln", "net", "nn", "nm", "names", "m", "j", "nr"], "tmp": ["slice", "nt", "cmp", "tt", " sp", "td", "cur", "cache", "managed", "cp", "v", "resp", "txt", "etc", "ptr", "pkg", "amp", "cmd", "tab", "prop", "test", "uf", "pb", "rw", "buf", "prefix", "emp", "gt", "tn", "cb", "expr", "table", "perm", "tf", " np", "tg", "data", "attr", " tcp", "np", "new", "rb", "MP", "p", "ret", "mint", "out", "mm", "mk", "rt", "ctx", "copy", "msg", "tar", "tm", "cv", "sp", "nm", "m", "result", "sam", "proc", "orig", " resp", " ob", "up", "temp", "src", " out", "html", "mp", "vt", "img", "trap", "ann", "t", "obj", "snap", "mb", "buff"]}}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n", "idx": 2914, "substitutes": {"ctx": ["qu", "inst", "via", "Context", "nt", "org", "cmp", "kt", "cp", "ind", "cf", "nc", "scope", "conn", "go", "voc", "resp", "txt", "etc", "cl", "hw", "pkg", "cmd", "xp", "pos", "pool", "cu", "anc", "buf", "req", "window", "dc", "xc", "jp", "loc", "iat", "soc", "desc", "config", "rc", "seq", "np", "ca", "p", "cc", "aux", "mk", "sys", "co", "info", "that", "addr", "cv", "tmp", "tx", "ctr", "ctrl", "proc", "xs", "pat", "aco", "exec", "comm", "cfg", "ct", "src", "pt", "gc", "timeout", "context", "bc", "conf", "fc", "ann", "sc", "doc", "ns", "act", "pg", "obj", "tc", "acl"], "cb": ["bt", "CB", "fb", "bp", "kb", "cmp", "cfg", "bg", "b", "rb", "c", "func", "pb", "cu", "xb", "gc", "cp", "buf", "wb", "cc", "fp", "cf", "ck", "callback", "bc", "ob", "bf", "cn", "kw", "conf", "fc", "nc", "conn", "nob", "gb", "nb", "lb", "fn", "cod", "sb", "bb", "unc", "etc", "cv", "obj", "tc", "cmd", "cd", "ctrl", "erb", "job"], "opaque": ["obca", "obque", "opque", "ipois", "obois", "iopacity", "ipaques", "opois", "peus", "opacity", "operacity", "ipque", "oppaques", "operois", "ipulence", "iopca", "oppulence", "oppque", "ipacity", "obaque", "obulence", "iopus", "obaques", "operca", "opulence", "opus", "peca", "ipaque", "peacity", "ipca", "ipus", "operaque", "opaques", "opca", "peaque", "obacity", "iopaque", "oppaque"], "bh": [" ph", "sbm", " inh", "rh", "bn", "pas", "hr", "bm", "bf", "binding", "br", "go", "kh", "hap", "sb", "bb", "h", "phi", "bt", "hi", "bl", "bs", "batch", "ih", " blo", " uh", "pb", "th", "hh", "hd", "buf", "bor", " Bh", " bl", "jp", "hal", "oth", "ach", "bsp", "loc", "rel", "hub", "mr", "bp", "eth", "np", "bg", "rb", "ssl", " bi", " hp", "body", "abb", "orth", "attach", " eh", "bis", "nb", "bj", "bol", "phy", " shr", " dh", "ht", "dh", "b", "hl", "ash", "sh", "hold", "rob", "BP", "bec", "hab", "igh", " rh", "lb", "bel", "zh", "hz", "bd", " ah", " HB", "bo"]}}
{"project": "FFmpeg", "commit_id": "37013fd018ae02679f177f42245f3e0e3c12d587", "target": 0, "func": "static void audiogen(void *data, enum AVSampleFormat sample_fmt,\n\n                     int channels, int sample_rate, int nb_samples)\n\n{\n\n    int i, ch, k;\n\n    double v, f, a, ampa;\n\n    double tabf1[SWR_CH_MAX];\n\n    double tabf2[SWR_CH_MAX];\n\n    double taba[SWR_CH_MAX];\n\n    unsigned static rnd;\n\n\n\n#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);\n\n#define uint_rand(x) (x = x * 1664525 + 1013904223)\n\n#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)\n\n    k = 0;\n\n\n\n    /* 1 second of single freq sinus at 1000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        a += M_PI * 1000.0 * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 1 second of varying frequency between 100 and 10000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);\n\n        a += M_PI * f * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 0.5 second of low amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 0.5 second of high amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd);\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 1 second of unrelated ramps for each channel */\n\n    for (ch = 0; ch < channels; ch++) {\n\n        taba[ch]  = 0;\n\n        tabf1[ch] = 100 + uint_rand(rnd) % 5000;\n\n        tabf2[ch] = 100 + uint_rand(rnd) % 5000;\n\n    }\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            v = sin(taba[ch]) * 0.30;\n\n            PUT_SAMPLE\n\n            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);\n\n            taba[ch] += M_PI * f * 2.0 / sample_rate;\n\n        }\n\n    }\n\n\n\n    /* 2 seconds of 500 Hz with varying volume */\n\n    a    = 0;\n\n    ampa = 0;\n\n    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            double amp = (1.0 + sin(ampa)) * 0.15;\n\n            if (ch & 1)\n\n                amp = 0.30 - amp;\n\n            v = sin(a) * amp;\n\n            PUT_SAMPLE\n\n            a    += M_PI * 500.0 * 2.0 / sample_rate;\n\n            ampa += M_PI *  2.0 / sample_rate;\n\n        }\n\n    }\n\n}\n", "idx": 2929, "substitutes": {"data": ["DATA", "input", "sample", "bytes", "batch", "results", "array", "d", "block", "channel", "r", "map", "memory", "xy", "mem", "window", "Data", "x", "image", "dat", "t", "device", "buffer", "m", "ata"], "sample_fmt": ["sample__mms", "sample_hmt", "sample__fmt", "sample__mtm", "sample_fms", "sample_hlt", "sample_mtm", "sample__mmt", "sample_flt", "sample_hms", "sample__ftm", "sample__flt", "sample_mlt", "sample_mms", "sample_ftm", "sample__fms", "sample_mmt", "sample__mlt", "sample_htm"], "channels": ["achars", "achapters", "capters", "choannels", "achairs", "quases", "chources", "chats", "chounks", "echars", "choats", "chunks", "echunks", "chairs", "quines", " chunks", "comproups", "achusters", "echusters", "chayers", "chnases", "chusters", "chnunks", "chnusters", "achources", "compannels", "chines", "achines", "cholics", "achats", "compayers", " chars", " chases", "achunks", "echapters", "chases", "achayers", "chroups", "achannels", "achroups", "echines", "quats", "chnars", "echairs", " chources", "quapters", "cairs", "chnannels", "quannels", " chines", "choapters", "chnayers", "compunks", "chars", "acholics", "chnroups", "echources", "echolics", "chnines", "quunks", "echannels", "chapters", "colics", "cannels"], "sample_rate": ["sample_mode", "sampleableradius", "sample5rating", " sample_length", "ample_frequency", "sample_rating", "versionationmonitor", "Sample_time", "ample_speed", "sample_speed", " sample_rat", "sample_force", "sample_frequency", "version_mode", "sample_process", "versionationrate", "sample_monitor", "ample2speed", "sample5rat", "sample0frequency", "sample00counter", "sample_stream", "sample00rate", "sample2Rate", "sample0rates", "sampleletprocess", "sample2rate", " sample_time", "samplemmcounter", "Sample_rates", "sample00process", " sample_counter", " sample_range", "versionationmode", "sampleablerate", "ample2rate", "sample_rat", "Sample_range", "sample_range", "ample2frequency", "version_monitor", "sample0speed", "sample_counter", "sampleationmonitor", " sample_rates", "sample2frequency", "sampleationmode", "sampleletrates", "sampleationcounter", " sample_frequency", "sampleletrate", "ample_rate", "ample_rates", "Sample_rate", "sample_radius", "samplemmmode", "sample5time", "sampleableforce", "version_rate", "sample_time", "sample2range", " sample_radius", "sampleletcounter", "samplemmrate", "sampleationrate", " sample_force", "sample0rate", "sample_Rate", "version_counter", "sample2rates", "sampleabletime", "samplemmmonitor", "sample_rates", " sample_Rate", " sample_stream", "sample5rate", "sample_length", " sample_rating", "ample2rates", "versionationcounter", "sample2speed", " sample_process", "sample00rates"], "nb_samples": ["nbitssamactions", "nb_dizes", "nbitssamamps", "nb_sforms", "nb___sensions", "nb_samamps", "nb_Sannels", "nb_spikes", "nb_Sensions", "nb___samps", "nb_Samps", "nb_isamples", "nb_Samples", "nbitssplays", "nb_samactions", "nb_dales", "nb_shamps", "nb_Sizes", "nb_statsamples", "nb_sizes", "nb_samplays", "nbitssamplays", "nb___samensions", "nb_seizes", "nb_testsamps", "nb_samamples", "nb_splays", "nb_contourses", "nb_statsourses", "nb___samikes", "nb_testsamples", "nb_seamps", "nbitssamples", "nb___sikes", "nb_testsforms", "nb_contamps", "nb_spamps", "nb_Sikes", "nb_damps", "nb_Sactions", "nb_seales", "nb_sourses", "nb_statsforms", "nb_Sforms", "nb_Splays", "nb_spamples", "nbitssamps", "nbitssamamples", "nb_damples", "nb_samikes", "nb_testsourses", "nb_sensions", "nb_Sales", "nb_Sourses", "nb_samensions", "nbitssactions", "nb_seamples", "nb_isamps", "nb_sannels", "nb___samples", "nb_shamples", "nb_statsamps", "nb_sikes", "nb_contamples", "nb_spensions", "nb_shactions", "nb___samamps", "nb_isannels", "nb___samamples", "nb_samps", "nb_shplays", "nb_sactions", "nb_contannels", "nb_isourses", "nb_sales"], "i": ["n", "cli", "by", "mi", "ind", "is", "ai", "ei", "ij", "ic", "it", "si", "er", "ie", "y", "h", "id", "ti", "io", "phi", "ish", "iu", "bi", "hi", "init", "ui", "c", "di", "at", "x", "fi", "ini", "zi", "ims", "ik", "xi", "ami", " ii", "index", "multi", "chain", "ri", "j", "I", "this", "im", "ki", "p", "iii", "ip", "mm", "ix", "ci", "us", "gi", "m", "ex", "li", "b", "ia", "ii", "ji", "\u0438", "pi", "in", "me", "qi", "II", "o"], "ch": ["qu", "ph", "count", "sch", "cha", "high", "ech", "ble", "sk", "ot", "cp", "chip", "atch", "ic", "history", "br", "go", "ry", "kh", "y", "h", "cl", "vc", "chart", "che", "ich", "bi", "chid", "q", "can", "batch", "tch", "c", "ih", "att", "th", "wh", "x", "col", "ach", "cb", "pl", "ver", "z", "chain", "con", "chn", "chan", "cell", "ca", "channel", "try", "height", "arch", "mk", "Ch", "cm", "chron", "CH", "ix", "m", "och", "ht", "cho", "form", "gh", "hl", "pt", "sky", "sh", "bc", "uch", "cht", "sc", "chrom", "zh", "cs", "client"], "k": ["wk", "n", "ack", "sch", "ijk", "K", "q", "ka", "kk", "mc", "ikk", "c", "kr", "sk", "ia", "km", "kt", "ki", "kl", "max", "p", "unk", "kan", "dk", "ck", "mk", "x", "ke", "ks", "kw", "kind", "ik", "ek", "kick", "kn", "ask", "key", "tk", "ko", "kj", "kh", "uk", "ak", "kid", "ok", "m", "j", "ku", "kg"], "v": ["var", "q", "vi", "vr", "b", "c", "nv", "w", "r", "p", "vt", "V", "ve", "tv", "l", "vv", "x", "u", "va", "g", "sv", "conv", "o", "value", "vs", "lv", "t", "vo", "ver", "vp", "uv", "y", "cv", "h", "vm", "vc", "qv", "version", "m", "j"], "f": ["fm", "fb", "ff", "fr", "q", "ef", "uf", "b", "c", "d", "at", "w", "fo", "r", "fa", "p", "fe", "l", "fp", "cf", "u", "e", "x", "fi", "bf", "fc", "g", "af", "fs", "t", "fd", "sf", "tf", "h", "y", "z", "F", "m", "j", "fac"], "a": ["wa", "au", "ata", "ba", "ab", "app", "an", "A", "ao", "b", "c", "ca", "att", "na", "ia", "at", "m", "w", "ava", "r", "p", "fa", "am", "la", "ai", "out", "ap", "u", "x", "ar", "area", "af", "o", "ac", "all", "ach", "xa", "aaa", "al", "ae", "ta", "to", "aj", "ma", "t", "alpha", "as", "ak", "act", "apa", "h", "y", "ea", "aw", "aa", "sa", "va", "j", "sta", "pa"], "ampa": ["au", "ba", "kk", "ka", "ao", "ia", "gc", "mp", "am", "loop", "ai", "ij", "ap", "jj", "pi", "ek", "xa", "xff", "ac", "key", "ko", "uk", "ta", "acc", "cv", "um", "aa", "sa", "result", "pa"], "tabf1": ["tabb2", "tabc1", "tabb8", "tabf3", "tabf8", " tabf64", "tabb5", "tabv2", " tabv8", "tabf5", "tabf64", " tabv1", " tabv5", "tabsf1", "tabv1", " tabf8", "tabc64", "tabf01", " tabsf01", " tabf3", "tabb3", " tabv2", "tabc01", "tabsf01", " tabsf64", " tabsf3", "tabb64", "tabv8", " tabsf1", "tabc3", "tabb01", " tabf5", "tabv5", " tabf01", "tabb1", "tabsf3", "tabsf64"], "tabf2": [" tabv3", "tabc2", "tabf256", "tabf3", "tabv3", "tabc0", "tabuf256", "tabv2", "tabv256", " tabv256", "tabuf0", "tabuf3", " tabf256", " tabf3", "tabv0", " tabv2", "tabf0", "tabuf2", " tabv0", " tabf0", "tabc3", "tabc256"], "taba": ["ctb", "trackea", "tabA", "trackb", "Tabb", "ctaa", "lista", "libA", "Tabao", "Tabea", "libaa", "libb", "listao", "tabaa", "tabea", "listb", "cta", "Taba", "tracka", "ctA", "TabA", "listea", "Tabaa", "trackao", "tabb", "tabao", "liba"], "rnd": [" rgd", "mrrd", "mrdd", " rrd", "rnt", "rdng", "rgd", "nrrd", "mrgd", "rrng", "rrdd", "rdnd", "rng", "rrnd", "nrmd", " rng", "nrng", "mrmd", " rdd", "mrng", "mrnt", "rdnt", "rdgd", "rdd", " rmd", "nrnd", "mrnd", "rmd", " rnt", "rrd"]}}
{"project": "FFmpeg", "commit_id": "ea97859c8c218b83ab747a7eabcb88ca446f6751", "target": 1, "func": "static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)\n\n{\n\n    CURSORINFO ci = {0};\n\n\n\n#define CURSOR_ERROR(str)                 \\\n\n    if (!gdigrab->cursor_error_printed) {       \\\n\n        WIN32_API_ERROR(str);             \\\n\n        gdigrab->cursor_error_printed = 1;      \\\n\n    }\n\n\n\n    ci.cbSize = sizeof(ci);\n\n\n\n    if (GetCursorInfo(&ci)) {\n\n        HCURSOR icon = CopyCursor(ci.hCursor);\n\n        ICONINFO info;\n\n        POINT pos;\n\n        RECT clip_rect = gdigrab->clip_rect;\n\n        HWND hwnd = gdigrab->hwnd;\n\n        info.hbmMask = NULL;\n\n        info.hbmColor = NULL;\n\n\n\n        if (ci.flags != CURSOR_SHOWING)\n\n            return;\n\n\n\n        if (!icon) {\n\n            /* Use the standard arrow cursor as a fallback.\n\n             * You'll probably only hit this in Wine, which can't fetch\n\n             * the current system cursor. */\n\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n\n        }\n\n\n\n        if (!GetIconInfo(icon, &info)) {\n\n            CURSOR_ERROR(\"Could not get icon info\");\n\n            goto icon_error;\n\n        }\n\n\n\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n\n\n\n        if (hwnd) {\n\n            RECT rect;\n\n\n\n            if (GetWindowRect(hwnd, &rect)) {\n\n                pos.x -= rect.left;\n\n                pos.y -= rect.top;\n\n            } else {\n\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n\n                goto icon_error;\n\n            }\n\n        }\n\n\n\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n\n\n\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n\n                CURSOR_ERROR(\"Couldn't draw icon\");\n\n        }\n\n\n\nicon_error:\n\n\n\n\n\n        if (icon)\n\n            DestroyCursor(icon);\n\n    } else {\n\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n\n    }\n\n}", "idx": 2946, "substitutes": {"s1": ["s3", "h2", "fs2", "s2", "h1", "s4", " s3", "c2", " s6", "h3", " s0", "s6", "fs4", "fs6", "c1", " s4", "c3", "fs1", "h0", "s0", " s2", "c0"], "gdigrab": ["ddigorab", "gdigub", "gdrogabulary", "gdircab", "gdigrad", "gdigorab", "ddigorub", "GDigrAB", "gdibrab", "ddigrab", "mdigrib", "gdigab", "gdircAb", "mdigrub", "gdibrib", "gdrigab", "ddigrob", "gdigmab", "ddigrib", "gdigrlab", "gdibrob", "gdrogib", "gdibrap", "GDrigabulary", "gdrigabulary", "GDrigAB", "GDigrab", "GDigrabulary", "ddgrub", "gdigorap", "gdigorib", "gradibrlab", "gdigrabb", "mdigab", "gdircabulary", "GDigrAb", "gdibrabb", "gdrogub", "mdigub", "gdigmap", "mdigib", "gradigrab", "ddgrib", "gdibrad", "gdibrub", "gdigob", "GDrigAb", "ddigorib", "gdgrub", "gdrogAB", "gdigrob", "gdigrabulary", "gdgrabb", "gdgrib", "gdigorob", "gdigrAb", "ddigrabb", "gdigrap", "gradigrap", "gdigorad", "gdircAB", "ddigrub", "mdigrab", "gdrigAB", "gdrigAb", "GDrigab", "gdigrub", "gdigorub", "gdigmib", "gdigad", "gdgrab", "mdigrad", "gdrogabb", "gradibrap", "gdibrlab", "gdrogAb", "gradigrlab", "gdigrAB", "gdigmlab", "ddigorob", "ddgrab", "gdrogab", "gdigrib", "ddgrabb", "mdigad", "gdigib", "gdigorlab", "gradigrib", "gradibrab", "gradibrib"], "info": ["Info", "inner", "note", "hi", "init", "INFO", "help", "ui", "error", "status", "ii", "about", "fo", "ki", "cache", "iso", "check", "i", "auth", "ip", "is", "row", "good", "stat", "pi", "fi", "ion", " INFO", "image", "conf", "list", "co", "def", "important", "os", "history", "key", "information", "it", "success", "si", "meta", "res", "ci", "isu", "state", "inf", "user", "index", "no", "f", "ico", "json", "details", "id", "none", "icon", "ti", "config", "o", "notice", "data", "io"], "pos": ["pose", "port", "zone", "coord", "o", "origin", "trans", "it", "go", "location", "neg", "resp", "to", "val", "Pos", "off", "top", "prop", "init", " POS", "post", "comp", "xy", "pc", "x", "def", "os", "loc", "meta", "px", "mat", "index", "no", "add", "po", "tag", "pro", "point", "mod", "apo", "p", "lat", "pan", "out", "pres", "co", "set", "position", "op", "rot", "state", "mit", "yes", "patch", "tmp", "slot", "spec", "form", "cond", "pt", "local", "parent", "offset", "pi", "conf", "doc", "POS", "ref", "act", "obj", "bo", " po", "pid", "client", " position"], "rect": ["attr", "ra", "dom", "tr", "vr", "path", "block", "pt", "mod", "RECT", "r", "pair", "nav", "map", "lat", "type", "Rect", "tri", "feat", "tip", "row", "rt", "reg", "port", "ror", "region", "dial", "round", "box", "area", "coord", "col", "ctx", "br", "addr", "loc", "dir", "rot", "res", "tar", "rel", "ect", "cont", "txt", "rad", "act", "color", "obj", "cl", "dict", "ptr", "err", "desc", "bo", "client", "ex"]}}
{"project": "qemu", "commit_id": "75cc7f018328e708d94cca23c3a77e85363f25dc", "target": 1, "func": "static void machine_initfn(Object *obj)\n\n{\n\n    MachineState *ms = MACHINE(obj);\n\n\n\n    ms->kernel_irqchip_allowed = true;\n\n    ms->kvm_shadow_mem = -1;\n\n    ms->dump_guest_core = true;\n\n\n\n\n    object_property_add_str(obj, \"accel\",\n\n                            machine_get_accel, machine_set_accel, NULL);\n\n    object_property_set_description(obj, \"accel\",\n\n                                    \"Accelerator list\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"kernel-irqchip\",\n\n                             NULL,\n\n                             machine_set_kernel_irqchip,\n\n                             NULL);\n\n    object_property_set_description(obj, \"kernel-irqchip\",\n\n                                    \"Use KVM in-kernel irqchip\",\n\n                                    NULL);\n\n    object_property_add(obj, \"kvm-shadow-mem\", \"int\",\n\n                        machine_get_kvm_shadow_mem,\n\n                        machine_set_kvm_shadow_mem,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"kvm-shadow-mem\",\n\n                                    \"KVM shadow MMU size\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"kernel\",\n\n                            machine_get_kernel, machine_set_kernel, NULL);\n\n    object_property_set_description(obj, \"kernel\",\n\n                                    \"Linux kernel image file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"initrd\",\n\n                            machine_get_initrd, machine_set_initrd, NULL);\n\n    object_property_set_description(obj, \"initrd\",\n\n                                    \"Linux initial ramdisk file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"append\",\n\n                            machine_get_append, machine_set_append, NULL);\n\n    object_property_set_description(obj, \"append\",\n\n                                    \"Linux kernel command line\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dtb\",\n\n                            machine_get_dtb, machine_set_dtb, NULL);\n\n    object_property_set_description(obj, \"dtb\",\n\n                                    \"Linux kernel device tree file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dumpdtb\",\n\n                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);\n\n    object_property_set_description(obj, \"dumpdtb\",\n\n                                    \"Dump current dtb to a file and quit\",\n\n                                    NULL);\n\n    object_property_add(obj, \"phandle-start\", \"int\",\n\n                        machine_get_phandle_start,\n\n                        machine_set_phandle_start,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"phandle-start\",\n\n                                    \"The first phandle ID we may generate dynamically\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dt-compatible\",\n\n                            machine_get_dt_compatible,\n\n                            machine_set_dt_compatible,\n\n                            NULL);\n\n    object_property_set_description(obj, \"dt-compatible\",\n\n                                    \"Overrides the \\\"compatible\\\" property of the dt root node\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"dump-guest-core\",\n\n                             machine_get_dump_guest_core,\n\n                             machine_set_dump_guest_core,\n\n                             NULL);\n\n    object_property_set_description(obj, \"dump-guest-core\",\n\n                                    \"Include guest memory in  a core dump\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"mem-merge\",\n\n                             machine_get_mem_merge,\n\n                             machine_set_mem_merge, NULL);\n\n    object_property_set_description(obj, \"mem-merge\",\n\n                                    \"Enable/disable memory merge support\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"usb\",\n\n                             machine_get_usb,\n\n                             machine_set_usb, NULL);\n\n    object_property_set_description(obj, \"usb\",\n\n                                    \"Set on/off to enable/disable usb\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"firmware\",\n\n                            machine_get_firmware,\n\n                            machine_set_firmware, NULL);\n\n    object_property_set_description(obj, \"firmware\",\n\n                                    \"Firmware image\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"iommu\",\n\n                             machine_get_iommu,\n\n                             machine_set_iommu, NULL);\n\n    object_property_set_description(obj, \"iommu\",\n\n                                    \"Set on/off to enable/disable Intel IOMMU (VT-d)\",\n\n                                    NULL);\n\n\n\n    /* Register notifier when init is done for sysbus sanity checks */\n\n    ms->sysbus_notifier.notify = machine_init_notify;\n\n    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);\n\n}", "idx": 2950, "substitutes": {"obj": ["inst", "esm", "nt", "org", "wr", "kr", "ot", "og", "bh", "ll", "ind", "objects", "o", "it", "resp", "object", "txt", "dict", "hw", "pkg", "net", "json", "cmd", "gm", "md", "art", "att", "req", "xy", "gr", "def", "obo", "cb", "expr", "cont", "mt", "typ", "vol", "j", "term", "stick", "attr", "ext", "obb", "dl", "try", "iso", "oid", "ck", "mk", "sys", "inv", "co", "mo", "info", "elt", "rt", "ctx", "addr", "msg", "args", "bj", "tmp", "nm", "m", "ex", "k", "orig", "det", "comm", "func", "src", "Object", "pt", "opt", "rect", "check", "onet", "ob", "obs", "opp", "mg", "t", "ns", "ref", "act", "Obj", "err", "js", "bo"], "ms": ["s", "ils", "lems", "bs", "md", "mc", "ents", "es", "ls", "mi", "mp", "ts", "mos", "MS", "mem", "mm", "Ms", "mes", "terms", "ks", "ols", "mic", "me", "ims", "mn", "ys", "os", "ems", "fs", "ma", "cms", "vs", "mg", "si", "ns", "sm", "mt", "mb", "cs", "hs", "js", "sim", "mx"]}}
{"project": "qemu", "commit_id": "d22b2f41c470067758b3636a01b452dfeda7069f", "target": 1, "func": "void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n", "idx": 2958, "substitutes": {"bs": ["BS", "bp", "bi", "iss", "bl", "bas", "lbs", "qs", "bing", "blocks", "ics", "ses", "bytes", "bps", "blog", "uses", "ls", "pb", "bles", "als", "bh", "ts", "its", "ps", "uts", "gs", "sys", "bc", "ops", "ks", "cks", "obs", "ss", "bos", "ms", "outs", "ims", "aos", "bis", "fs", "ds", "bsp", "acs", "vs", "fts", "ats", "sts", "rs", "ns", "bits", "sb", "bb", "hz", "vals", "cs", "hs", "js", "ubs", "css", "has", "bes"]}}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n", "idx": 2967, "substitutes": {"opaque": ["copzero", "OPque", "opque", "opatile", "OPity", "iopacity", "iopatile", "opzero", "OPacity", "opacity", "oplaque", " opque", "oplacity", "opity", "copacity", " opacity", "oplatile", "iopity", "oplity", "copque", "OPatile", " opzero", "iopaque", "OPzero", "OPaque", "copaque"], "status": ["null", "record", "error", "pause", "cache", "sync", "score", "ne", "handle", "store", "success", "vis", "si", "scale", "json", "id", "scan", "mode", "prom", "test", "note", "access", "str", "site", "active", "prefix", "message", "list", "os", "index", "fail", "details", "version", "sim", "config", "sql", "use", "style", "uses", "response", "ssl", "login", "atus", "sys", "ping", "ss", "current", "name", "code", "set", "report", "msg", "Status", "state", "notice", "result", "base", "compl", "s", "service", "spec", "stats", "reason", "summary", "comment", "gc", "check", "description", "wrapper", "send", "stat", "title", "me", "source", "server", "settings", "res", "content", "wait", "cess"], "info": ["ist", "iter", "options", "metadata", "error", "by", "one", "same", "i", "te", "is", "sync", "recent", "history", "success", "it", "si", "value", "fee", "tif", "http", "txt", " inf", "more", "json", "id", "import", "ti", "scan", "detail", "io", "note", "init", "INFO", "ui", "about", "fi", "def", "list", "num", "meta", "inf", "index", "no", "extra", "details", "config", "data", "of", "ready", "try", "ret", "ip", "good", "sys", "information", "report", "op", "state", "alias", "maybe", "notice", "result", "Info", "stats", "diff", "exec", "Inf", "ii", "fo", "check", "type", "stat", "in", "image", "conf", "doc", "settings", "now", "f", "none"], "progress": ["pro", "iter", "rep", "diff", "step", "sample", "summary", "page", "dist", "complete", "trust", "max", "p", "speed", " progression", "quant", "tip", "row", "percent", "good", "bar", "next", "prefix", "distance", "title", "command", "current", "par", "finished", "history", "key", "success", " progressed", "clip", "process", "report", "resp", "total", "load", "state", "poll", "priority", "content", "grade", "debug", "ptr", "scale", "pdf", " Progress", " progresses", "wait", "processing", "label", "print", "fine", "result", "Progress"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2996, "substitutes": {"code": ["ode", "test", "count", "age", "sec", "rc", "time", "ct", "c", "ca", "error", "codes", "entry", "th", "frame", "try", "one", "coe", "cc", "type", "create", "ck", "Code", "xc", "ter", "term", "here", "nc", "ne", "ay", "go", "cb", "ce", "cod", "now", "cont", "zero", "ie", "xx", "cast", "address", "cmd", "err", "xe", "close", "cd", "id", "ch", "cycle", "xxx", "desc"], "addr": ["ad", "ack", "eth", "str", "ag", "rc", "hash", "cmp", "oad", "src", "at", "gc", "alt", "arg", "pad", "ip", "mem", "offset", "Address", "bind", "asm", "x", "arr", "rt", "name", "url", "adr", "arp", "host", "a", "cb", "loc", "msg", "res", "load", "rs", "ref", "act", "obj", "mt", "ptr", "mb", "ace", "hw", "gate", "address", "sp", "pkg", "cmd", "add", "err", "id", "mac", "ok", "tx", "pos", "alloc"], "vaddr": ["pld", "haddress", "svloc", "paddress", " vadr", "svaddr", "svadr", " vadd", "haddr", "waddr", "hld", "svadd", " vld", "vcaddr", "vaddress", " vptr", "vptr", "waddress", "hptr", "vloc", "vld", "pptr", "hadd", "wadd", " vloc", "vcloc", "vadr", "wptr", "padd", "vcadr", "vcadd", "vadd"], "ram_addr": ["ram_id", "ram___id", "ram___addr", "gem_ptr", "ram_address", "sam_address", "ram_offset", "ram2map", "gem_offset", "sky_addr", "gem_addr", "sky_id", "gem_id", "sky_ptr", "ram2offset", "ram2ptr", "ram_ptr", "sam_name", "ram2addr", "sky_map", "ram_name", "sam_addr", "ram___offset", "ram2id", "ram___ptr", "ram_map", "sam_ptr"], "paddr": [" pdata", "paddress", "maddr", " padd", "pref", " pstat", "vaddress", " pref", "mptr", "apstat", "Paddress", " paddress", "Padd", "apdata", "Pptr", "pptr", "Pstat", "apptr", "pstat", "Pdata", "vref", "padd", "pdata", "maddress", "Paddr", " pptr", "vadd", "mref", "madd", "apaddr"]}}
{"project": "qemu", "commit_id": "aef172ffdc2f9c41d9cc043a55f1259e7c07e587", "target": 1, "func": "coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    struct unmap_list list;\n\n    int r = 0;\n\n\n\n    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpu) {\n\n        /* UNMAP is not supported by the target */\n\n        return 0;\n\n    }\n\n\n\n    list.lba = offset / iscsilun->block_size;\n\n    list.num = bytes / iscsilun->block_size;\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,\n\n                         iscsi_co_generic_cb, &iTask) == NULL) {\n\n        r = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {\n\n        /* the target might fail with a check condition if it\n\n           is not happy with the alignment of the UNMAP request\n\n           we silently fail in this case */\n\n        goto out_unlock;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        r = iTask.err_code;\n\n        goto out_unlock;\n\n    }\n\n\n\n    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,\n\n                               bytes >> BDRV_SECTOR_BITS);\n\n\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    return r;\n\n}\n", "idx": 3001, "substitutes": {"bs": ["bt", "BS", "ib", "bp", "bi", "bl", "lbs", "bas", "bg", "b", "bps", "blog", "abus", "pb", "bles", "bh", "ts", "bn", "its", "ps", "gs", "sys", "bc", "bm", "bf", "ss", "cks", "obs", "bos", "bis", "fs", "ds", "ns", "bits", "sb", "bb", "bd", "cs", "js", "ubs", "bes"], "offset": ["bound", "slice", "length", "et", "offs", "batch", "from", "byte", "error", "start", "at", "block", "seconds", "pointer", " offsets", "timeout", "oid", "attribute", "prefix", "command", "image", "len", "seek", "num", "origin", "set", "position", "addr", "location", "to", "base", "bits", "ref", "order", "index", "size", "amount", "mt", "no", "address", "Offset", "padding", "range", "buffer", "o", "off", "pos", "alloc", "slot", "top"], "bytes": ["s", "reads", "latest", "blocks", "nets", "offs", "ions", "es", "bps", "Bytes", "values", "sets", "byte", "uses", "devices", "seconds", "its", "gs", "units", "ops", "terms", "parts", "keys", "classes", "tes", "outs", "ys", "checks", "ies", "ips", "trans", "gets", "izes", "types", "times", "bits", "abytes", "words", "pointers", "size", "rows", "files", "loads", "odes", "mb", "pages", "names", "errors", "sofar", "pieces", "steps", "bes"], "iscsilun": ["misctilgun", "isecselmun", "isctilmun", "micsiln", "iscSilon", "ischsprmun", "iscsentut", "ihsilunt", "iscsalun", "uscsinn", " discsinon", "iscsprgun", " discsilune", "uscsilun", "iscticuna", "ischsilgun", "isciphanyun", "iscvioluno", "iscosilun", "iscsinoun", "iscselun", " discsinun", "ischsprgun", "iscfolmun", "iscSilun", "isecselon", "isciphanyund", "iscSilUn", "iscsiduna", "iscsalund", "ihsentgun", "nicsilUN", "iscsentban", "micsentn", "ircsilun", "iscSiluna", "misciphanyund", "ischsilon", "issidun", "issilban", "iscgilune", "iscsentmun", "uscsilUN", "iscslun", "iscsinn", "iscsenton", "miscsiloun", "ircsilUn", "iscselgun", "iscfolon", "iscslgun", "ircSiluna", "iscgilon", "issilut", "iscosinun", "nicsiluna", "iscsalmun", "iscssluna", "micsilgun", "ibrfoluno", "iscsilund", "miscsilUN", "ischematicgun", "ircSilur", "iscspellun", "iscviolon", "ibrsilmun", "iscslut", "iscSilUN", "iscinelmun", "miscsilund", "iscsslon", "iscsinun", "iscosinon", "isckillmun", "iscviolmun", "iscsiln", "iscsilban", "iscsimUN", "misctilUN", "iscsilut", "ibrfolun", "isckillun", "ischematicur", "ischsilun", "ischematicuna", "iscsilgun", "iscsinune", "miscsilmun", "ischsprun", "isecsilon", "iscgiluna", " discsinul", "iscsentuna", "iscsprmun", "ibrfolon", "iscselon", "iscspellur", "ischematicunt", "iscgiln", "nicsinuna", "isctiloun", "uscsinune", "iscsilul", "iscSilune", "ihsilgun", "iscsinul", "nicsilon", "iscineluna", "micsentgun", "iscsimgun", "iscsilunt", "miscsilun", "iscSiln", "isciphanymun", "iscosilune", "iscsilUn", "micsentmun", "ihsentunt", "ibrsilon", "iscsinUN", "misctiloun", "iscSilur", "isctilUn", "uscsilune", "ircsilmun", "isctilgun", "iscslmun", "iscinelun", "isctilunt", "ischematicon", "iscticut", "ischspron", "ihsilut", "misciphanyun", "iscsslur", "iscsilUN", "isctilUN", "issidut", "issidban", "iscsimoun", "isecsilun", "iscsentunt", "misciphanyuna", "isckillUn", "ircSilmun", "iscselmun", "isckillunt", "iscgilul", "nicsinon", "iscsingun", "iscsilur", "iscsentn", "iscsinon", "iscSilul", " discsinune", "ibrsiluno", "iscSilgun", "iscsiloun", "ischsilmun", "iscmilmun", "ihsilun", "misciphanymun", "iscsidun", "uscsinun", "ihsentun", " discsilul", "nicsilun", "uscsinUN", "iscmilgun", "ibrsilun", "iscspron", "iscsln", "isctilun", "iscSilmun", "iscsprun", "iscticun", "iscsidut", "iscsentgun", "iscslunt", "iscsimun", "iscmilun", "iscsentun", "isecselgun", "iscSiluno", "isecselun", "uscsiln", "iscfolun", "ircsilunt", "iscsilmun", "ibrfolmun", "iscosinune", "iscsilune", "micsilmun", "iscspellon", "iscosilur", "iscosilon", "iscsidban", "iscsaluna", "isecsilgun", "iscspellune", "ihsentut", "issilun", "ircsilon", "ircSilon", "iscinelund", "micsilun", "iscsiluno", "miscsilgun", "iscgilUN", "isecsilmun", "ircSilunt", "nicsinUN", "iscosinur", "iscmilon", "misctilun", "miscsiluna", "iscsilon", "ischematicun", "ircSilUn", "iscviolun", "issiluna", " discsilon", "iscfoluno", "ircsiluna", "ischematicut", "iscSilunt", "micsentun", "isciphanyuna", "iscsiluna", "iscticban", " discsilun", "nicsinun", "iscsinuna", "ircSilun", "issiduna", "iscgilun", "ircsilur", "iscsslun", "iscsinur"], "iTask": ["ciThread", "uiPlatform", "iBlock", "iService", " iConfig", "iiBlock", "iiWork", " iParent", "iiRunning", "uiAsset", "miParent", "hiProcess", "ciTask", " iEvent", "piTask", "itiBlock", "piEvent", "iitask", "phiNode", "hiTask", "miWork", "diJob", "jiConfig", "riAsset", "iFunction", " iWork", "miConfig", "iConfig", " iTransaction", "riTask", "iChild", "iFinish", "jiPlatform", "miJob", " itask", "litask", "riPlatform", "miCommand", "iAttempt", "hiThread", "iiProcess", " iProcess", " iNode", "iParent", "iiJob", "iThread", "iiAttempt", "uiTask", "oriNode", "liNode", "diRunning", "iNode", "ziFunction", "miPlatform", "multiNode", "iWork", "ziEvent", "ciProcess", "ziTask", "iJob", "iRunning", "liProcess", "iiThread", "uiJob", "jiCommand", " iAttempt", "cliTask", " iService", "jiEvent", "miAsset", "itask", "iiConfig", " iFunction", "jiService", "liConfig", "uiAttempt", "oriCommand", "oriChild", "jiFunction", "liChild", "oriTask", "riTransaction", "phiCommand", "itiAttempt", "miTask", "liTask", "liEvent", "miTransaction", "ititask", "liCommand", "piFinish", "piConfig", "iCommand", " iThread", "itiTask", " iJob", "phiChild", "multiAttempt", "cliFinish", "hiTransaction", "uiThread", "diThread", "liFinish", "cliEvent", "multiJob", "liJob", "uiTransaction", "ciTransaction", "iPlatform", " iRunning", "iiTask", "cliConfig", "diTask", "multiTask", "jiTask", "iEvent", "ziService", "phiTask", "iiParent", "iProcess", "iAsset", "liAttempt", " iBlock", "liPlatform", "iTransaction"], "list": ["ist", "n", "count", "flag", "spec", "form", "elist", "li", "seq", "pool", "warning", "record", "filter", "LIST", " pl", "batch", "item", "art", "new", "not", "array", "status", "block", "dl", "lists", "alist", "p", "listed", "parent", "l", "out", "v", "st", "e", "def", "member", "queue", "arr", " l", "len", "conf", "lp", "all", "set", "total", "msg", "t", "load", "table", "index", "and", "obj", "dict", "pkg", "tmp", "List", "add", "range", "label", "chain", "base"]}}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3003, "substitutes": {"cs": ["s", "bs", "CS", "ces", "qs", "ics", "ses", "es", "c", "ls", "ts", "cc", "ps", "ec", "cp", "pc", "ck", "sys", "csv", "ks", "cks", "ss", "sc", "ms", "ctx", "ys", "acs", "ds", "fs", "cms", "vs", "sts", "wcs", "rs", "ns", "ins", "cus", "hs", "caps", "js", "cas", "css"], "address": ["service", "each", " Address", "email", "absolute", "record", "point", "error", "path", "array", "uri", "r", "memory", "pointer", "ress", "description", "ip", "route", "able", "Address", "word", "attribute", "offset", "trace", "context", "prefix", "relative", "command", "message", "port", "document", "network", "region", "name", "adr", "location", "position", "addr", "host", "res", "device", "resource", "index", "private", "order", "phrase", "alias", "ptr", "ref", "resses", "ace", "interface", "shape", "request", "reference", "add", "range", "domain", "event", "password"], "rw": ["wa", "nw", "wx", "work", "ew", "rd", "rb", "wr", "write", "w", "rh", "wn", "ru", "r", "wb", "mem", "row", "rf", "offset", "RW", "rt", "iw", "ow", "adr", "addr", "resp", "rs", "usr", "wd", "sw", "ptr", "hw", "writer", "aw", "wp", "wind", "rew", "wer", "range", "wl", "writ", "nr"], "mmu_idx": ["mmu_Idxf", "mmu_inw", "mmu_midw", "mmu2idx", "mmu_pidp", "mmu_idp", "mmu_pidy", "mmu2Idx", "mmu_Idp", "mmu_pidw", "mmu_Idx", "mmu2idy", "mmu_inp", "mmu_Idz", "mmu2idz", "mmu_pidx", "mmu_idy", "mmu_idz", "mmu2Idz", "mmu_pidz", "mmu_inz", "mmu_midxf", "mmu_inx", "mmu_midx", "mmu_idxf", "mmu_Idw", "mmu_midz", "mmu_Idy", "mmu2Idy", "mmu_midy", "mmu_idw"], "cpu": ["proc", "core", "tp", "np", "aco", "CPU", "bench", "CP", "cu", "comp", "gc", "cp", "arch", "pc", "mem", "cf", "aux", "stat", "ane", "chip", "cn", "nc", "sc", "ctx", "conn", "process", "bean", "node", "apache", "pu", "phys", "setup", "tc", "clock", "hw", "gpu", "processor", "phy", "vm", "mac", "cum", "nic", "ex"], "env": ["em", "inst", "proc", "attr", "esm", "Environment", "ew", "et", "eh", "ten", "org", "engine", "ef", "cfg", "nv", "enter", "worker", "ts", "eni", "environment", "ec", "buf", "window", "next", "e", "context", "eng", "eco", "conf", "esc", "estate", "sc", "ctx", "sv", "nc", "en", "conn", "scope", "ds", "server", "viron", "vs", "cb", "pe", "er", "ce", "state", "txt", "enc", "obj", "dev", "ptr", "hw", "cv", "net", "cmd", "priv", "vm", "err", "config", "ah", "ev"], "physical": ["pn", "present", "pro", "tp", "localhost", "binary", "enabled", "np", "absolute", "protected", "target", "normal", "native", "path", "readable", "pb", "active", "remote", "p", "png", "ruby", "pointer", "local", "vt", "variable", "ip", "attribute", "relative", "sys", "virtual", "restricted", "network", "information", "server", "location", "total", "Physical", "external", "ref", "primary", "phys", "resource", "private", "vp", "http", "policy", "public", "hw", "console", "sp", "phy", "net", "effective", "config", "password", "base"], "prot": ["pn", "ocol", "proc", "tp", "eth", "pro", "ports", "supported", "ht", "pat", "np", "protected", "prototype", "tr", "notes", "att", "pb", "status", "platform", "ret", "controller", "pointer", "type", "prop", "pc", "rf", "inet", "virtual", "format", "Prot", "def", "chron", "port", "col", " PROT", "dt", "rot", "tif", "qt", "tech", "primary", "phys", "tf", "ptr", "policy", "net", "phy", "cmd", "version", " proto", "typ", "password", "pattern", "top"], "access_type": ["access_Type", " access_types", "access00TYPE", "access_types", "access00options", " access_options", "access00Type", "Access_type", "access2Type", "access_options", " access_Type", "Access_Type", "access2type", " access_TYPE", "access2types", "Access_TYPE", "access_TYPE", "access00type"]}}
{"project": "qemu", "commit_id": "e26110cfc67d48331a76e9b1e6f7fed7569e1ab3", "target": 0, "func": "static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n", "idx": 3020, "substitutes": {"type": ["Type", "otype", "test", "token", " other", " y", "time", " variable", " p", "p", "description", "variable", " error", " field", "e", "x", "kind", " structure", "member", "file", "name", "link", "key", "pe", " types", "t", "types", " e", " attribute", " value", "resource", " definition", "module", "y", "TYPE", "role", " instance", "ty", " key", "typ", " file", "function", "ype"], "l": ["s", "k", "el", "nl", "li", "b", "c", "lc", "ls", "hl", "dl", "kl", "p", "ll", "ul", "i", "v", "L", "u", "list", "tl", "g", "len", "lt", "lp", "all", "it", "fl", "ld", "loc", "le", "lb", "t", "pl", "il", "h", "sl", "z", "ln", "lang", "f", "lay", "ml", "m", "j"]}}
{"project": "qemu", "commit_id": "8bd7f71d794b93ce027b856f5b79a98f4f82e44c", "target": 0, "func": "static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n", "idx": 3040, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "f43a16049ef07585789d311f314f236a314f91f7", "target": 0, "func": "int opt_cpuflags(const char *opt, const char *arg)\n\n{\n\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n\n    static const AVOption cpuflags_opts[] = {\n\n        { \"flags\"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = \"flags\" },\n\n        { \"altivec\" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = \"flags\" },\n\n        { \"mmx\"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = \"flags\" },\n\n        { \"mmx2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = \"flags\" },\n\n        { \"sse\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = \"flags\" },\n\n        { \"sse2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = \"flags\" },\n\n        { \"sse2slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = \"flags\" },\n\n        { \"sse3\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = \"flags\" },\n\n        { \"sse3slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = \"flags\" },\n\n        { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n", "idx": 3054, "substitutes": {"opt": ["attr", "ext", "init", "var", "ff", "options", "oop", "Opt", "fg", "oc", "alt", "ts", "prop", "feat", "mem", "kw", "lt", "oss", "op", "txt", "ref", "etc", "eff", "option", "cmd", "off", "OP"], "arg": ["proc", "spec", "flag", "ext", "var", "use", "bin", "target", "star", "gen", "w", "mem", "aux", "argument", "ax", "arr", "g", "reg", "bit", "name", "all", "doc", "op", "args", "call", "Arg", "cmd", "mac"], "cpuflags_opts": ["cpuflags_procs", "cpuflags_opcs", "cpuflags_prods", "cpuflags_pts", "cpuflags_optt", "cpuflags_pcs", "cpuflags_prot", "cpuflags_opds", "cpuflags_pds", "cpuflags_optcs", "cpuflags_pt", "cpuflags_prots", "cpuflags_opt", "cpuflags_optts", "cpuflags_optds"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);\n\n}\n", "idx": 3065, "substitutes": {"dst": ["dnd", " dsrc", "Dest", "Ddest", "ddest", "dest", "Dst", "gnd", "fdest", "gest", "Dsrc", " dtr", "best", "fst", "fest", "gtr", "gst", "dsrc", "bnd", "bst", "fsrc", "dtr", "btr", " dnd", " ddest", " dest"], "src": ["s", "dq", "inner", "ipl", "input", "str", "rc", "impl", "np", "bg", "b", "cur", "hl", "dest", "sn", "comp", "r", "rl", "iv", "img", "st", "sys", "ur", "in", "rt", "sc", "source", "trans", "sr", "loc", "rs", "sb", "txt", "ins", "ptr", "sl", "gin", "ctr"], "stride": ["slue", "slid", "dride", "stritud", " strade", " stritud", "drides", "stid", "drride", " strend", "trider", "slider", "drime", " strue", "strope", "strride", "shrides", " strid", "shrride", " strride", "strend", " strider", "strime", "slade", "dritud", "strides", "stide", "STRride", "strade", "trend", "tride", "stade", "shride", "STRide", "strider", "strue", "slend", "STRope", " strime", "drope", "slime", "slide", "STRides", "slitud", "trid", "shrope", "strid", "slride", "drue"]}}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n", "idx": 3070, "substitutes": {"opaque": ["OPque", "opque", "Opity", " oplay", "OPlay", "opatile", "OPaques", "bitity", "bitaque", "Opatile", "oaques", "oroid", "oaque", "oque", "ority", " opque", "olay", "opoid", "opity", "bitoid", "oratile", "bitatile", "Opaque", "oplay", " opaques", "opaques", "Opoid", "oraque", "OPaque"], "s": ["an", "services", "r", "i", "is", "v", "sync", "parts", "sis", "store", "fs", "ds", "eps", "gets", "sb", "y", "h", "sq", "hs", "bs", "ses", "ims", "sv", "os", "vs", "sts", "ats", "as", "details", "j", "ports", "qs", "ssl", "states", "syn", "p", "ps", "l", "sys", "less", "ss", "ms", "bis", "set", "so", "sl", "bes", "spec", "stats", "comm", "es", "b", "ls", "pers", "als", "ts", "its", "changes", "gs", "g", "se", "source", "acs", "rs", "t", "ns", "ins", "S", "obj", "sw", "ess", "js", "aws"], "divider": [" divrier", "domide", "digander", "collidable", "collision", "DIVid", " dividable", "divicator", " divicator", " divid", "DIVidable", "multiplide", "divander", "DIVider", " divide", " diviator", "devidable", "provider", "indiator", "multiplier", "devider", "indIDER", " divIDER", "divator", "digision", " divander", "divid", "Divier", "digide", "DIVIDER", "devIDER", "divrier", "division", "DivIDER", "indider", "providable", "provision", "digider", "Divrier", "multiplIDER", "divide", "indide", "domator", "diviator", "domander", "collide", "Diviator", "Divider", "provide", "DIVicator", "digidable", "domider", " divator", "dividable", "divIDER", "DIVrier", "digator", " divier", "divier", "Divide", "multiplider", "devid", "Divicator", "collider"]}}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 3076, "substitutes": {"ssd": ["atspd", "ssds", "psw", "essd", "psd", "osssd", "pspd", "bssd", "tsd", "tsdk", "essdl", "rsspd", " ssw", "ssp", "sssd", "cssp", "essdk", "atsds", "ossp", " ssdk", "ossd", "essp", "SSw", "ssw", "cssds", "rssds", "rssd", "csssd", "ssdk", " sssd", "bspd", "essw", "bsd", "issp", "psds", "issd", "SSd", "ussp", "pssd", "essds", " ssds", "rsssd", "usssd", "ssdl", "issds", "esssd", "cssd", "SSds", "cssdl", "tssd", "atssd", "atsd", " ssp", "csspd", "tsp", "bsds", "sspd", "SSsd", "isssd", "ussdl", "ussd", "ossw"], "surface": ["null", "tp", "bridge", "lower", "tr", "display", "metadata", "cur", "texture", "output", "cache", "ve", "grid", "port", "store", "delete", "database", "folder", "package", "ptr", "console", "address", "directory", "empty", "ui", "uf", "sum", "window", "message", "utm", "mail", "index", "vp", "uv", "public", "buffer", "figure", "data", "save", "this", "new", "cell", "steam", "sole", "submit", "space", "document", "reflect", "manager", "report", "node", "interface", "tmp", "unknown", "result", " Surface", "instance", "flag", "view", "final", "summary", "func", "volume", "face", "wrapper", "connection", "image", "panel", "FACE", "source", "sheet", "server", "layout", "profile", "sur", "t", "subject", "filename", "plane", "pdf", "f", "storage", "airo", "fac"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750fx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 3082, "substitutes": {"env": ["nw", "esm", "gov", "org", "erd", "ka", "cur", "ve", "era", "shell", "ei", "v", "eng", "en", "conn", "origin", "store", "tk", "dt", "er", "hw", "console", "net", "cmd", "project", "chart", "erb", "eh", "site", "worker", "ut", "environment", "window", "esc", "sv", "viron", "vs", "cb", "qt", "ect", "vp", "uv", "desc", "config", "em", "forge", "ew", "et", "engine", "outer", "nv", "entry", "export", "ec", "ja", "tek", "vv", "inv", "here", "estate", "ctx", "code", "set", "addr", "manager", "msg", "den", "gear", "usr", "cv", "vert", "result", "el", "det", "dh", "ten", "enter", "e", "context", "oe", "doc", "end", "server", "serv", "esi", "da", "ner", "act", "obj", "dev", "vm", "event", "rod", "ah", "ev"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n", "idx": 3098, "substitutes": {"stream": ["test", "stack", "pipe", "read", "view", "open", "input", "str", "pool", "form", "proof", "impl", "sample", "tr", "new", "status", "path", "output", "reader", "mount", "loop", "window", "row", "out", "Stream", "REAM", "socket", "context", "sync", "file", "port", "seek", "source", "handle", "trans", "host", "poll", "progress", "sl", "console", "chain", "buffer", "event", "data", "iterator", "line"], "stream_printf": ["stream_print", "stream_put", "stream_println", "Stream_printf", "stream_width", " stream_print", "Stream_println", " stream_width", "Stream_put", "Stream_print", " stream_println"]}}
{"project": "FFmpeg", "commit_id": "9924f1bc34242bb9315c355108f3ce744c1f33c5", "target": 0, "func": "static int mkv_write_header(AVFormatContext *s)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    ebml_master ebml_header;\n\n    AVDictionaryEntry *tag;\n\n    int ret, i, version = 2;\n\n    int64_t creation_time;\n\n\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n\n        mkv->mode = MODE_WEBM;\n\n    else\n\n        mkv->mode = MODE_MATROSKAv2;\n\n\n\n    if (mkv->mode != MODE_WEBM ||\n\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n\n        version = 4;\n\n\n\n    if (s->nb_streams > MAX_TRACKS) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"At most %d streams are supported for muxing in Matroska\\n\",\n\n               MAX_TRACKS);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n\n            version = 4;\n\n    }\n\n\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n\n    if (!mkv->tracks) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n\n    end_ebml_master(pb, ebml_header);\n\n\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n\n    mkv->segment_offset = avio_tell(pb);\n\n\n\n    // we write 2 seek heads - one at the end of the file to point to each\n\n    // cluster, and one at the beginning to point to all other level one\n\n    // elements (including the seek head at the end of the file), which\n\n    // isn't more than 10 elements if we only write one of each other\n\n    // currently defined level 1 element\n\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n\n    if (!mkv->main_seekhead) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n\n    if (ret < 0) goto fail;\n\n\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n    pb = mkv->info_bc;\n\n\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n\n        else\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n\n\n        if (mkv->mode != MODE_WEBM) {\n\n            uint32_t segment_uid[4];\n\n            AVLFG lfg;\n\n\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n\n\n            for (i = 0; i < 4; i++)\n\n                segment_uid[i] = av_lfg_get(&lfg);\n\n\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n\n        }\n\n    } else {\n\n        const char *ident = \"Lavf\";\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n\n    }\n\n\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n\n        uint8_t date_utc_buf[8];\n\n        AV_WB64(date_utc_buf, date_utc);\n\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n\n    }\n\n\n\n    // reserve space for the duration\n\n    mkv->duration = 0;\n\n    mkv->duration_offset = avio_tell(pb);\n\n    if (!mkv->is_live) {\n\n        int64_t metadata_duration = get_metadata_duration(s);\n\n\n\n        if (s->duration > 0) {\n\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else if (metadata_duration > 0) {\n\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else {\n\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n\n        }\n\n    }\n\n    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    else\n\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    pb = s->pb;\n\n\n\n    // initialize stream_duration fields\n\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n\n\n    ret = mkv_write_tracks(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    for (i = 0; i < s->nb_chapters; i++)\n\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n\n\n    ret = mkv_write_chapters(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    ret = mkv_write_tags(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n", "idx": 3117, "substitutes": {"s": ["n", "services", "ags", "south", "is", "v", "views", "parts", "fs", "ds", "eps", "http", "bits", "sb", "scl", "h", "y", "cl", "pkg", "sq", "hs", "actions", "sports", "bs", "app", "ses", "ions", "c", "ims", "sv", "os", "a", "sts", "ats", "as", "https", "z", "ans", "details", "j", "sql", "ports", "qs", "events", "uploads", "these", "p", "ps", "comments", "l", "sys", "less", "ss", "ms", "bis", "times", "args", "sp", "aunts", "m", "ex", "sam", "spec", "stats", "ads", "xs", "comm", "results", "es", "b", "ls", "w", "als", "ts", "its", "changes", "gs", "ches", "ks", "g", "conf", "sc", "rs", "ns", "t", "ins", "S", "sw", "cs", "aws", "js", "o"], "mkv": ["kv", "kmV", "ckvs", "ckv", " mkvc", "skyw", "mkV", "mkch", "mkvp", " mkt", "mktv", "mkvc", "kmv", "kvs", " mkch", " mkvp", "mutv", "kmvc", "MKtv", "makech", "kV", "skyv", "skyvp", "makevs", "mkt", " mkV", "makev", " mkvs", "MKv", "makew", "makevp", "MKV", " mkw", "mutch", "kmtv", " mktv", "maket", "mutvs", "mkvs", "ckV", "MKvc", "mkw", "skyt"], "pb": ["proc", "bp", "tp", "pool", "np", "eb", "cmp", "uf", "b", "p", "mp", "pan", "cp", "buf", "pc", "fp", "pub", "dc", "cm", "bm", "ob", "jp", "pp", "ctx", "conv", "lp", "tk", "cb", "pm", "PB", "sb", "vp", "cv", "tc", "ub", "mb", "pkg", "gp", "wp", "typ", "db", "pa"], "ebml_header": ["ebxml_header", "ebxml_headers", "ebxml_version", "ebml_Header", "ebml2headers", "ebml2Header", "ebxml2headers", "ebxml2version", "ebxml2header", "ebml2header", "ebml2version", "ebxml_Header", "ebml_headers", "ebml_version", "ebxml2Header"], "tag": ["bug", "token", "attr", "cat", "ag", "record", "art", "comment", "entry", "map", "match", "tags", "feat", "word", "row", "TAG", "Tag", "reg", "name", "par", "key", "msg", "op", "tar", "table", "event", "db"], "ret": ["flag", "el", "cat", "VAL", " alt", " resp", " ok", "re", "new", "status", "alt", "match", "mem", "out", "resp", "Ret", "RET", "res", "rs", "val", "ref", "ner", " val", "mt", " RET", "result"], "i": ["phi", "iu", "I", "n", "oi", "bi", "cli", "hi", "init", "iter", "li", "ui", "batch", "di", "gi", "ir", "status", "ii", "im", "mi", "uri", "ki", "ia", "remote", "p", "ji", "\u0438", "any", "ind", "ip", "l", "ai", "v", "ei", "ij", "x", "e", "pi", "in", "ini", "info", "zi", "g", "ic", "ims", "me", "xi", "ami", "it", "go", "si", "ix", "iq", "t", "ci", "index", "multi", "y", "f", "id", "ski", "ti", "sim", "chain", "ri", "m", "j", "io"], "creation_time": ["create_time", "create_times", "creation_t", "creation_date", "creation_times", "create_t", "create_date"]}}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n", "idx": 3130, "substitutes": {"s": ["service", "n", "spec", "bs", "ses", "comm", "b", "c", "ssl", "m", "r", "als", "p", "ts", "ps", "i", "l", "gs", "is", "sys", "e", "less", "ss", "g", "conf", "se", "sis", "sv", "ies", "bis", "fs", "ds", "a", "set", "sts", "so", "rs", "t", "ns", "state", "sb", "S", "h", "session", "y", "sw", "ess", "sl", "sq", "z", "obj", "hs", "js", "o", "j"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_sws_init_swScale_mmx(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_INLINE_ASM\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        sws_init_swScale_MMX(c);\n\n#if HAVE_MMXEXT_INLINE\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        sws_init_swScale_MMX2(c);\n\n#endif\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n#if HAVE_YASM\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 3153, "substitutes": {"c": ["s", "k", "n", "rc", "mc", "b", "ct", "lc", "com", "ca", "cu", "w", "oc", "cache", "p", "gc", "cp", "cc", "ec", "l", "cf", "v", "e", "dc", "bc", "co", "cm", "fc", "conf", "sc", "ctx", "conv", "cam", "ac", "coll", "a", "C", "ce", "t", "cont", "cv", "tc", "cl", "cs", "vc", "ch", "m"]}}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget(const uint8_t **p, int type, int le)\n\n{\n\n    switch (type) {\n\n    case TIFF_BYTE:\n\n        return *(*p)++;\n\n    case TIFF_SHORT:\n\n        return tget_short(p, le);\n\n    case TIFF_LONG:\n\n        return tget_long(p, le);\n\n    default:\n\n        return UINT_MAX;\n\n    }\n\n}\n", "idx": 3158, "substitutes": {"p": ["bp", "tp", "np", "php", "q", "self", "up", "b", "post", "c", "pb", "P", "d", "pt", "w", "per", "r", "pers", "at", "cp", "ps", "pad", "pc", "fp", "ip", "out", "v", "ap", "pi", "ping", "jp", "g", "par", "pp", "pod", "lp", "pm", "op", "types", "t", "pl", "vp", "h", "pre", "pkg", "f", "wp", "sp", "m", "pa"], "type": ["Type", "otype", " ty", "what", "et", "ct", "style", "error", "ime", "th", "family", "inter", " Type", "oid", "ity", "e", "kind", " typ", "info", "ping", "file", "name", "link", "al", "code", "dt", "pe", "types", "t", "ice", "class", "ver", "y", "TYPE", "role", "like", "ty", "id", "range", "typ", "ype"], "le": ["de", " ty", "ile", "el", "tle", "del", "ale", "li", "ple", " ble", "ly", "ble", "let", "ell", " angle", "ll", "ve", "stable", "l", "Le", "te", "ge", "ity", "lem", "ler", "ke", "sol", "ele", "se", "ne", "les", "pe", "ce", "LE", "ole", "lex", "sl", " pe", " ele", "sle", "led"]}}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    int i, quant, level, orientation, quant_idx;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    DiracContext *s = avctx->priv_data;\n\n    DiracSlice *slice = arg;\n\n    GetBitContext *gb = &slice->gb;\n\n\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n\n    quant_idx = get_bits(gb, 8);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n\n            quants[level][orientation] = quant;\n\n        }\n\n    }\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (i = 0; i < 3; i++) {\n\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n\n        int64_t bits_left = 8 * length;\n\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n\n\n\n        if (bits_end >= INT_MAX) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n\n                               &s->plane[i].band[level][orientation], NULL);\n\n            }\n\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3160, "substitutes": {"avctx": ["avctl", "afctx", "avectl", "avcontext", "verjp", "avContext", "afjp", "avjp", "avtx", "aftx", "avconn", "Avctx", "wavContext", "Avconn", "ovcp", "navctx", "wavtx", "aveconn", "vercp", "vertx", "Avcontext", "navtx", "ovctx", "navContext", "afcp", "wavcontext", "verctx", " avcontext", "avectx", "avecontext", "avcp", " avctl", "wavctx", " avContext", " avconn", "navcontext", " avtx", "ovtx", "Avctl", "ovjp"], "arg": ["ad", "param", "spec", "ag", "pb", "star", "block", "rg", "gc", "p", "ge", "ang", "argument", "ray", "v", "parse", "ary", "arr", "g", "jp", "reg", "ar", "ctx", "ay", "conn", "arp", "doc", "val", "base", "agg", "args", "ref", "call", "pg", "Arg", "obj", "cmd", "range", "vol", "gate", "slot"], "i": ["phi", "k", "iy", "iu", "I", "n", "hi", "bi", "li", "q", "ui", "c", "di", "ii", "im", "mi", "p", "local", "ji", "ind", "ip", "ai", "v", "l", "ij", "ei", "x", "e", "pi", "ion", "u", "in", "ini", "info", "zi", "len", "ic", "me", "list", "xi", "o", "it", "si", "iq", "ix", "ci", "t", "index", "multi", "y", "dr", "interface", "f", "id", "chain", "gi", "sim", "m", "j", "ti", "ex"], "quant": ["qu", "quality", "spec", "cat", "qua", "final", "query", "q", "length", "quart", "volume", "mult", "charge", "cur", "series", "util", "integer", "comp", "quick", "local", "cp", "uint", "cost", "ind", "percent", "good", "quad", "frac", "qq", "pal", "multipl", "bit", "qi", "hold", "gap", "xff", "mix", "Q", "total", "qa", "load", "val", "qt", "quiet", "priority", "alpha", "qual", "scale", "imp", "depth", "direct", "requ", "sim", "Quant", "Qual", "fac", "compl"], "level": ["fall", "what", "high", "length", "ble", "mount", "cost", "ind", "loop", "member", "scope", "limit", "coll", "go", "location", "pe", "module", "role", "scale", "id", "global", "mode", "prop", "test", "quality", "hi", "layer", "finding", "lc", "status", "family", "row", "list", "len", "levels", "col", "group", "loc", "pl", "rel", "index", "fail", "lo", "version", "po", "tag", "half", "point", "style", "VEL", "height", "thread", "l", "condition", "tail", "tier", "goal", "stage", "low", "name", "all", "full", "state", "priority", "lvl", "where", "depth", "pri", "stack", "el", "volume", "vel", "frequency", "local", "type", "parent", "variable", "peer", "driver", "le", "Level", "load", "lock", "zero", "call", "broad", "label", "print", "owner", "sequence"], "orientation": ["designoration", "designation", "rotification", "elongification", "orientity", "designity", "elongator", "innization", "rientations", "innATION", "directionation", "orientuation", "rotator", "rientacy", "orientate", "layoutotation", "elongication", "layoutational", "orientoration", "rotication", "designATION", "rientmentation", "orientality", " orientination", "rientization", "orientention", "orientational", " orientate", "directionator", "elongature", "rientality", "elongration", "rientation", " orientacy", "iterity", "designotation", "iterator", "designention", "orientator", "elongization", "iterination", "orientification", "rototation", "drawization", "rientity", " orientication", "rientination", "iteruation", "rotuation", "directionoration", "rotoration", "iterotation", "rientuation", "doorention", "drawature", "doororation", "drawotation", "directionature", "layoutity", "orientotation", "rientification", "rotate", "orientations", "rientator", "rotations", "iteracy", "orientication", "orientration", "iteration", "rientoration", "designration", "rientication", "orientATION", "rotention", " orientations", "orientization", "draworation", "orientmentation", " orientality", "designization", "designmentation", " orientity", "orientacy", "innration", " orientification", "designational", "elongoration", "designification", "innation", "rientotation", "elongation", "elongATION", "orientature", "orientination", "rientATION", "elongality", "doorification", "layoutation", "designature", "directionization", "rientational", "drawator", "dooration", "drawation", "drawmentation", "rientature", "rientate", "rotation"], "quant_idx": ["quant_ridy", "quant_indxes", "quant_indx", "quant_ridxe", "quant_idexc", "quant_idex", "quant_Idz", "quant_edy", "quant_idsxe", "quant_edxe", "quant_idxs", "quant_edxs", "quant_Idxs", "quant_idsx", "quant_idsxs", "quant_indxe", "quant_idy", "quant_indxs", "quant_idexs", "quant_idxc", "quant_Idx", "quant_idxes", "quant_Idxc", "quant_idz", "quant_idsxes", "quant_indxc", "quant_ridxs", "quant_indz", "quant_edx", "quant_idxe", "quant_idez", "quant_ridx"], "quants": [" quaints", "acquANT", "acquant", "requats", "Quants", " quats", "quars", "requaints", "squants", "quANT", "Quars", "squaints", "aquats", "aquants", " quANT", "quats", "aquars", "requants", " quars", "squant", "requant", "QuANT", "acquants", "aquant", "quaints", "aquANT", "squats", "acquats", "Quant"], "MAX_DWT_LEVELS": ["MAX_DWT_LEVELPS", "MAX_DWT_LEVELOPS", "MAX_DWT_LETHOPS", "MAX_DWT_DEPVELS", "MAX_DWT_LETHS", "MAX_DWT_LEBITOPS", "MAX_DWT_LEBITPS", "MAX_DWT_DEPVELPS", "MAX_DWT_LETHINS", "MAX_DWT_DEPVELOPS", "MAX_DWT_LEFLAGS", "MAX_DWT_LEBITS", "MAX_DWT_DEPBITS", "MAX_DWT_DEPBITOPS", "MAX_DWT_LEFLAGPS", "MAX_DWT_DEPBITINS", "MAX_DWT_LEFLAGOPS", "MAX_DWT_LEVELINS", "MAX_DWT_LEFLAGINS", "MAX_DWT_DEPBITPS", "MAX_DWT_LEBITINS", "MAX_DWT_DEPVELINS", "MAX_DWT_LETHPS"], "s": ["sam", "service", "sql", "n", "spec", "stats", "single", "qs", "bs", "self", "comm", "utils", "es", "b", "c", "ssl", "ls", "w", "r", "p", "local", "ts", "sd", "ps", "its", "gs", "v", "is", "sys", "csv", "less", "parts", "ss", "g", "conf", "ims", "sc", "space", "ctx", "sv", "os", "se", "fs", "ds", "a", "vs", "set", "sts", "ats", "so", "rs", "t", "ns", "sb", "S", "scl", "https", "ins", "h", "sl", "sq", "ess", "cs", "hs", "sp", "js", "aws", "sa", "m", "j"], "slice": ["service", "spec", "cut", "single", "via", "ringe", "view", "axis", "seq", "sample", "batch", "volume", "cell", "star", "gem", "seed", "pair", "sel", "spot", "v", "ray", "parse", "Sl", "se", "sis", "source", "link", "copy", "limit", "set", "pe", "slave", "ice", "piece", "node", "rice", "join", "tile", "call", "gate", "split", "sl", "scale", "sp", "pse", "instance", "range", "ser", "sci", "scan", "clip", "save", "series", "slot", "sort"], "gb": ["vg", "sg", "kb", "bs", "gnu", "binary", "eb", "gz", "bytes", "gd", "uf", "bg", "cfg", "b", "bps", "rb", "pb", "rg", "gc", "py", "wb", "buf", "xy", "img", "gs", "sys", "csv", "gt", "g", "gif", "ctx", "cb", "gio", "nb", "bits", "hub", "sb", "args", "goo", "pg", "GB", "cv", "uv", "mb", "gpu", "eg", "tmp", "gp", "storage", "gg", "tg", "gm", "buffer", "gy", "buff", "db", "io"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_wb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRWBContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 16000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 16000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->last_bitrate    = avctx->bit_rate;\n\n\n\n    avctx->frame_size  = 320;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->state     = E_IF_init();\n\n\n\n    return 0;\n\n}", "idx": 3161, "substitutes": {"avctx": ["AVct", "avjp", "avereq", "afcontext", "wavhistory", "ravcontext", "avcu", "avcc", " avtxt", "ajpkg", "avcb", "wavpool", "ravcoll", "wavctx", "avecontext", "avprop", " avjac", "avcf", "ajhistory", "avhistory", "avcfg", "avctl", "afctx", "avcontext", "AVtx", "ajcfg", " avgc", " avheight", "wavcfg", "ravgc", "avercontext", "avecfg", "ajjac", "wavtx", "ravctx", "aveheight", "avecu", " avcu", "avercf", "avejac", "avect", "ravcu", "wavpkg", " avcontext", "ajcc", "ravhistory", "avecf", "averctx", "avpkg", " avcfg", "ravpkg", "wavreq", "avpool", "avecmp", "ajctl", "ajprop", "avetxt", "avecoll", "avertx", "avegc", "wavcu", "savcmp", "avreq", "avtxt", "AVctx", " avcoll", "wavcontext", "avectx", "avecb", "avct", "savheight", " avctl", "savctx", "wavgc", "avcoll", " avtx", "avgc", "savtxt", "avcmp", "afjac", "afcc", "ajcu", "avectl", "AVcontext", "wavjp", "avtx", " avprop", "averjp", "avergc", " avct", "wavcf", "avheight", "avercfg", "averreq", " avjp", " avcmp", "avepool", "wavcb", "aveprop", "ajcontext", "avercc", "averpool", "ajctx", "avercb", "avjac", "avetx", "afcfg"], "s": ["ports", "spec", "stats", "bs", "qs", "es", "b", "c", "ls", "d", "pers", "r", "p", "ts", "its", "ps", "i", "changes", "is", "gs", "v", "sys", "e", "ss", "g", "ms", "sv", "os", "fs", "ds", "eps", "set", "acs", "sts", "ats", "gets", "rs", "t", "as", "ns", "ins", "S", "h", "ess", "sq", "cs", "hs", "js", "aws", "m", "j"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162, "substitutes": {"q_ptr": ["q__pad", "q__ptr", "q__ref", "sq_ref", "sq_ptr", "sq__tr", "sq__pad", "q_ref", "q_pos", "q_pad", "sq_pad", " q_tr", "q_tr", "sq_tr", "sq__ptr", "sq__ref", " q_pos", " q_Ptr", "q_Ptr", "q__tr"], "num": ["n", "nam", "final", "np", "nu", "na", "mon", "mult", "temp", "p", "bn", "sum", "on", "cal", "offset", "number", "nom", "missing", "eng", "NUM", "current", "len", "en", "alph", "non", "un", "Number", "set", "total", "Num", "nb", "msg", "t", "tim", "uni", "val", "zero", "index", "done", "no", "du", "f", "net", "um", "nm", "dim", "m", "con", "result"], "den": ["dn", "dem", "length", "ten", " Den", "nu", "bill", "di", "mon", "con", "gen", "pen", "fen", "ki", "Den", " DEN", "ind", " denomin", "rown", "mem", "cal", "window", "quist", "arden", "len", "deg", " len", "mn", "fin", "en", "un", "der", "dat", "fam", "una", "DEN", "don", "mat", "perm", "dev", "dra", "ven", "wen", "dim", "zen", "zan", "mont", "rem"]}}
{"project": "FFmpeg", "commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "target": 1, "func": "void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)\n\n{\n\n    int i;\n\n\n\n    s->dts    =\n\n    s->pts    = AV_NOPTS_VALUE;\n\n    s->pos    = -1;\n\n    s->offset = 0;\n\n    for (i = 0; i < AV_PARSER_PTS_NB; i++) {\n\n        if (s->cur_offset + off >= s->cur_frame_offset[i] &&\n\n            (s->frame_offset < s->cur_frame_offset[i] ||\n\n             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame\n\n            // check disabled since MPEG-TS does not send complete PES packets\n\n            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){\n\n\n\n            s->dts    = s->cur_frame_dts[i];\n\n            s->pts    = s->cur_frame_pts[i];\n\n            s->pos    = s->cur_frame_pos[i];\n\n            s->offset = s->next_frame_offset - s->cur_frame_offset[i];\n\n            if (remove)\n\n                s->cur_frame_offset[i] = INT64_MAX;\n\n            if (s->cur_offset + off < s->cur_frame_end[i])\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 3176, "substitutes": {"s": ["ants", "services", "ags", "is", "sync", "ops", "parts", "fs", "ds", "eps", "er", "bits", "sb", "h", "y", "sq", "hs", "sports", "bs", "ses", "c", "ares", "status", "ains", "ims", "sv", "os", "vs", "sts", "ats", "as", "details", "save", "has", "aus", "sql", "ports", "qs", "ssl", "states", "p", "ps", "comments", "sys", "less", "ss", "search", "ms", "space", "bis", "set", "params", "state", "args", "aunts", "bes", "sam", "spec", "stats", "ads", "xs", "comm", "es", "ls", "pers", "als", "ts", "its", "changes", "gs", "g", "se", "acs", "rs", "ns", "t", "ins", "S", "sw", "ess", "cs", "aws", "js"], "off": ["aff", "OFF", "of", "ext", "offer", "ff", "over", "offs", "Off", "uf", "oa", "from", "start", "oc", "after", "p", "head", "pad", "on", "offset", "out", "ap", "def", "before", "shift", "reset", "ow", "push", "it", "set", "un", "ov", "end", "a", "op", "t", " offset", "eff", "extra", "raw", "f", "Offset", "cmd", "ok", "o", "pos", "ex"], "i": ["phi", "iu", "I", "oi", "n", "bi", "hi", "cli", "init", "iter", "li", "ui", "vi", "batch", "di", "status", "iri", "ii", "im", "mi", "uri", "ki", "p", "ji", "\u0438", "ind", "ip", "l", "ai", "v", "is", "ij", "x", "e", "pi", "in", "ini", "info", "zi", "g", "ic", "ims", "me", "xi", "it", "si", "ix", "ci", "index", "multi", "y", "us", "span", "dim", "json", "id", "ski", "ti", "sim", "gi", "ri", "m", "j", "chain", "series", "io"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 3179, "substitutes": {"i": ["cli", " multi", " p", "mi", " si", " mi", "ind", " I", "is", "ai", "ij", " n", "ic", "it", "si", "y", "id", "ti", "io", "phi", "iu", "bi", "init", " v", " c", "ui", "batch", " m", "di", "status", "x", " hi", "ini", " di", "zi", "list", " l", "ims", "xi", " ti", " ii", "index", "multi", "z", " t", "chain", "sim", " x", "ri", "j", "I", "this", " li", "asi", "try", "ki", " index", " bi", "ip", "info", "ix", "ci", "gi", "m", "li", " j", "ii", "ji", "\u0438", "e", "pi", "in", " pi", "me", "f", "series"], "encoded": ["encoding", "ecoder", "decached", "enressed", "Encoder", "entoder", "enoded", "encrypted", "decoded", "enoding", "enrypted", "ENCressed", "Encoded", "entoding", "entoded", "enoder", "uncrypted", "decrypted", "Encoding", "ENCoder", "enccoded", "enached", "uncached", "ecoding", "encressed", "decressed", "deccoded", "ENCoded", "encoder", "encached", "eccoded", "decoding", "decoder", "uncoded", "ecached", "Enccoded", "unccoded", "ecrypted", "entrypted", "entcoded", "ecoded", "ENCached"], "test_cases": ["test_packs", "est8cards", "testxcases", "test_cycles", "testxtests", "est_times", "testxcas", "test_series", "search_cs", "test67chains", "testenconfig", "test_config", "est8series", "testencs", "load_chains", " test_case", "load_packs", "testencases", " test_tests", "test_tests", "search_config", "load_cycles", "test8series", "test8config", "load___cycles", "testenwindows", "test_cards", "test_needs", "test___cases", "test___chains", "test67cases", "search_windows", "searchenconfig", "test_windows", "test8windows", " test_cas", "test8cs", "test8cases", "test67packs", "search_cases", "est_cases", "test__times", "test_chains", "test_cs", "est8cases", "test_cas", "load_cases", "test___cycles", "load___packs", "test___packs", "test67cycles", "test_case", "test__tests", "test8cards", "load___cases", " test_times", " test_needs", "test__case", "est8times", "testxneeds", "searchencases", "test__cases", "test_times", "est_cards", "load___chains", "test8times", "searchenwindows", "est_series", "searchencs"], "obj": ["inst", "attr", "null", "bl", "init", "orig", "adj", "nt", "cmp", "func", "rb", "xxx", "att", "con", "pos", "src", "ot", "pt", "pr", "opt", "og", "py", "ut", "alt", "bo", "buf", "xy", "ind", "ck", "out", "onet", "ob", "__", "def", "obo", "arr", "obs", "elt", "ctx", "wo", "conn", "it", "addr", "expr", "resp", "msg", "cod", "res", "t", "object", "rel", "txt", "ref", "bj", "act", "dict", "tmp", "ox", "Obj", "err", "cmd", "js", " Obj", "buff", "o", "j", "po"], "str": ["s", "n", "cr", "bl", "seq", "fr", "nt", "tr", "wr", "pt", "r", "pr", "Str", "ts", "buf", "st", "arr", "name", "STR", "br", "msg", "res", "t", "ns", "rs", "print", "cont", "text", "txt", "sw", "mt", "sl", "cs", "sp", "js", "ctr", "vol", "j"]}}
{"project": "qemu", "commit_id": "0857a06ef784783887e756d4b7b5f874512c506c", "target": 1, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n", "idx": 3180, "substitutes": {"dc": ["cca", "cr", "rc", "KC", "mc", "ct", "c", "di", "lc", "ca", "d", "dp", "oc", "gc", "cc", "cp", "ec", "pc", "cf", "bc", "disc", "cm", "fc", "ic", "nc", "sc", "ctx", "draw", "df", "ac", "ds", "cms", "dat", "ci", "da", "dm", "tc", "dr", "DC", "cs", "vc", "cd"], "sr": [" scr", "cr", "lr", "via", " Sr", "rar", "str", " sy", "yr", "fr", "rid", " hr", "sort", "tr", "vr", "rb", " rg", "kr", "ir", "hl", "src", "sn", "rg", " rm", " radius", "r", " dr", "ru", "rl", "syn", "rw", "pr", "rx", "rf", "hr", "sys", " gr", "SR", "rm", "gr", "ire", "rt", "ran", "rn", "sv", "rr", "br", "adr", "ry", "spr", "gor", "rs", "sur", "serv", " ir", "sb", "usr", "mr", "sf", "sw", " yr", " shr", "ser", "rem", "ctr", "nr"], "access": ["ache", "ACC", "display", "error", "ast", "cache", "upload", "ress", "est", "request", "priv", "xp", "az", "att", "status", "util", "ha", "route", "row", "x", "ax", "esc", "ord", "accessible", "a", "acc", "index", "usage", "ace", "allow", "z", "connect", "config", "attr", "read", "ext", "use", "Access", "ca", "export", "mod", "name", "seek", "area", "key", "state", "asc", "rage", "sa", "ex", "release", "view", "press", "ag", "exec", "path", "aud", "stat", "assert", "sc", "reach", "url", "ac", "flow", "pass", "act", "call", "sw", "cast", "aw", "cess", "ccess", "fac"], "access_text": ["access_Text", "acc_txt", "access2text", "access2ext", " access2ind", "acc_ext", "access_form", "access2TEXT", "acc_code", "access_TEXT", "Access_form", "Access_text", "Access_TEXT", " access2ext", "access___text", " access_ext", "acc_text", "Access2txt", "access_ind", "access___Text", "Access2text", "access___ext", "access2form", "access_txt", " access2text", "Access2TEXT", " access_txt", "access2txt", "Access2form", "access2ind", "access___txt", "Access_txt", " access_ind", "access2Text", "access_ext", " access2txt", "access_code", "access2code", " access_Text"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n", "idx": 3182, "substitutes": {"ctx": ["proc", "wx", "bp", "kb", "work", "np", "nt", "gz", "cmp", "cfg", "ct", "c", "ca", "lc", "cur", "today", "cu", "dl", "kt", "gc", "p", "cp", "cc", "req", "std", "cf", "ck", "cpu", "mk", "bc", "context", "x", "jac", "prefix", "cm", "kw", "jp", "xc", "crit", "conf", "cn", "nc", "sc", "conn", "cb", "wcs", "resp", " cx", "txt", "wd", "act", "pg", "cv", "tc", "etc", "unc", "hw", "pkg", "obj", "cl", "ctl", "gp", "cmd", "tx", "desc", "ctr", "cas", "xp", "ctrl"], "t0": ["t000", "tt2", "pt000", "ptZero", "ptzero", "wt0", "T00", "tzero", " tzero", "wt000", " T0", " pt2", "toot", "T19", "dt000", "T1", "T0", "dt00", "pt1", "tt1", "T2", "Tzero", " pt0", " Toot", "dt0", "pt0", "tt0", "T000", "tZero", " T1", "wtZero", " toot", " t00", "t00", " pt1", " ptoot", "dt1", " t19", "t19", " t000", " T2", "wt1", "TZero", "tt19"], "t1": ["tone", "text001", "tONE", "text2", "TOne", "T61", "tt2", " tOne", "tson", "td61", "n1", "nt1", "n001", " tson", "textone", "tt001", "T1", "tt1", " t9", "t001", " tone", "td1", "tmson", "T9", "n2", "tOne", "tm9", " t001", " t61", "ttONE", "tdOne", "t61", "temp2", " tONE", "tempONE", "t9", "temp1", "td9", "ntson", "ntONE", "none", "text1", "tm1", "nt9", "temp001", "tmONE"], "t2": ["te2", "dt3", "tttwo", "T3", "te72", "ttwo", "t3", "tt2", "t12", "ot256", "wt12", "wt72", "ot02", "pt2", " t256", "te12", "t256", "tt02", "ot2", "t02", "T1", "pt1", "l2", "T2", " ttwo", " t3", "wt2", "l1", "ottwo", "ts72", "l5", "dt2", "ts12", "tstwo", "t72", "dt1", " t02", "pt3", "l3", "tt256", "pt5", "wttwo", "T5", "t5", "dttwo", "tetwo", "Ttwo", "ts2"], "nr": ["uj", "n", "nw", "nl", "nz", "np", "nu", "nor", "wr", "kr", "nv", "sn", "ni", "r", " NR", "nie", "next", "sys", "number", "gr", "rn", "num", "ne", "rr", "br", "adr", "ng", "cb", "byter", "sr", "NR", "ny", "nb", "arity", "res", "ns", "Ni", "nir", "mr", "no", " ni", "ptr", "nn", "range", "nm", "ri"]}}
{"project": "FFmpeg", "commit_id": "c61b28e0421f0f9502dfb21495a03cda191def15", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,\n\n                        float **out_samples)\n\n{\n\n    ATRAC3Context *q = avctx->priv_data;\n\n    int ret, i;\n\n    uint8_t *ptr1;\n\n\n\n    if (q->coding_mode == JOINT_STEREO) {\n\n        /* channel coupling mode */\n\n        /* decode Sound Unit 1 */\n\n        init_get_bits(&q->gb, databuf, avctx->block_align * 8);\n\n\n\n        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,\n\n                                        JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Framedata of the su2 in the joint-stereo mode is encoded in\n\n         * reverse byte order so we need to swap it first. */\n\n        if (databuf == q->decoded_bytes_buffer) {\n\n            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;\n\n            ptr1          = q->decoded_bytes_buffer;\n\n            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)\n\n                FFSWAP(uint8_t, *ptr1, *ptr2);\n\n        } else {\n\n            const uint8_t *ptr2 = databuf + avctx->block_align - 1;\n\n            for (i = 0; i < avctx->block_align; i++)\n\n                q->decoded_bytes_buffer[i] = *ptr2--;\n\n        }\n\n\n\n        /* Skip the sync codes (0xF8). */\n\n        ptr1 = q->decoded_bytes_buffer;\n\n        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {\n\n            if (i >= avctx->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n\n\n        /* set the bitstream reader at the start of the second Sound Unit*/\n\n        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);\n\n\n\n        /* Fill the Weighting coeffs delay buffer */\n\n        memmove(q->weighting_delay, &q->weighting_delay[2],\n\n                4 * sizeof(*q->weighting_delay));\n\n        q->weighting_delay[4] = get_bits1(&q->gb);\n\n        q->weighting_delay[5] = get_bits(&q->gb, 3);\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];\n\n            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];\n\n            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);\n\n        }\n\n\n\n        /* Decode Sound Unit 2. */\n\n        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],\n\n                                        out_samples[1], 1, JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Reconstruct the channel coefficients. */\n\n        reverse_matrixing(out_samples[0], out_samples[1],\n\n                          q->matrix_coeff_index_prev,\n\n                          q->matrix_coeff_index_now);\n\n\n\n        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);\n\n    } else {\n\n        /* single channels */\n\n        /* Decode the channel sound units. */\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            /* Set the bitstream reader at the start of a channel sound unit. */\n\n            init_get_bits(&q->gb,\n\n                          databuf + i * avctx->block_align / avctx->channels,\n\n                          avctx->block_align * 8 / avctx->channels);\n\n\n\n            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],\n\n                                            out_samples[i], i, q->coding_mode);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    /* Apply the iQMF synthesis filter. */\n\n    for (i = 0; i < avctx->channels; i++) {\n\n        float *p1 = out_samples[i];\n\n        float *p2 = p1 + 256;\n\n        float *p3 = p2 + 256;\n\n        float *p4 = p3 + 256;\n\n        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);\n\n        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);\n\n        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3183, "substitutes": {"avctx": ["Avctx", "wavjac", " avpkg", "afcontext", "avepkg", "abcmd", "ravcontext", "abpkg", "ajpkg", "abgc", "abctx", "avesys", " avconfig", "wavctx", "avecontext", "ravdocument", " avcmd", "abjac", "Avtx", "avcfg", "evcmp", "afctx", "avctl", "avcontext", "avecmd", "ravconfig", "AVtx", "ajcfg", "abtx", "avecfg", "ajjac", "afca", "wavtx", "aveca", "ravctx", "AVcmp", "avejac", "avedocument", " avcontext", "abcontext", "wavctl", "ajcmp", "averctx", "avpkg", "aveconfig", "avecmp", "avercmp", "ajctl", "abctl", "avca", "averjac", "avconfig", "afgc", "ajtx", "evcontext", "AVctx", "avectx", " avctl", "absys", "averpkg", " avtx", "avgc", "avcmd", " avca", "avcmp", "avectl", "Avcmp", "AVcontext", "avtx", "ajgc", "afpkg", "afctl", "avsys", "avercfg", "avercmd", " avcmp", "Avcontext", "aversys", " avdocument", "avdocument", "evctx", "evtx", "ajctx", "avjac", "abcmp"], "databuf": ["databof", "Databull", " datobuff", "databsbuf", "datablof", "datobull", " databuch", "datABuffer", " databuff", "datABuf", "databanduch", "datablbuf", " datobuffer", "Datobuf", "databandbuf", "datahbuf", "databandulk", " datobuch", "databulk", "dataabluff", " datobbuf", "dataabuff", "datahof", "databull", " databulk", "datobuffer", " datobulk", "dataabuf", "datobbuf", "Databbuf", "datahuff", "databluff", "databbuf", " databbuf", "databsuffer", "dataablbuf", "databuch", "Datobull", "datobulk", "dataabbuf", "databluffer", "dataablof", "Databuffer", " datobuf", "databsuff", "dataabluf", "datABbuf", "datABulk", "Datobuffer", "databsull", "databsof", "databanduf", "dataabof", "databsuf", "Databuf", "Datobbuf", "datobuch", "databuffer", "datahuf", "datABull", "databuff", "databluf", "datABuch", "datobuf", " databuffer", "datobuff"], "out_samples": ["out_namps", "out_samps", "out_nings", "out_Sings", "out_namples", "out_examps", "out_nources", "out_swamples", "out_swources", "out_examples", "out_exounds", "out_sources", "out_Sources", "out_exources", "out_sounds", "out_Samples", "out_nounds", "out_swings", "out_sings", "out_Samps", "out_swamps"], "q": ["qu", "dq", "tt", "r", "cache", "cp", "ll", "ve", "cf", "v", "qq", "queue", "ry", "er", "quest", "ue", "etc", "think", "h", "y", "cl", "pkg", "sq", "ox", "qv", "gm", "aq", "kg", "quality", "c", "req", "window", "iq", "question", "qa", "qt", "z", "requ", "config", "j", "cat", "qs", "quit", "quick", "p", "quant", "l", "ck", "info", "my", "pp", "ctx", "all", "Q", "tx", "ch", "m", "quer", "k", "ht", "eq", "view", "que", "form", "query", "self", "comm", "hl", "check", "quote", "g", "conf", "qi", "t", "pg", "obj", "f", "client"], "ret": ["flag", "ext", "rets", "det", "over", "nt", "Return", "re", "tr", "not", "att", "lit", "try", "r", "alt", "ruby", "out", "mem", "rm", "def", "gt", "arr", "ter", "rt", "len", "deg", "elt", "tn", "reset", "nil", "reg", "value", "resp", "Ret", "RET", "res", "t", "val", "print", "cont", "txt", "ref", "tf", "mt", " RET", "tmp", "f", "net", "err", "xt", "j", "result", "rem"], "i": ["phi", "iu", "I", "n", "oi", "bi", "cli", "hi", "iter", "li", "mc", "ui", "b", "di", "ir", "by", "ii", "im", "mi", "at", "try", "ki", "uri", "ni", "p", "inter", "ji", "\u0438", "ind", "ip", "ai", "v", "l", "ij", "ei", "is", "e", "pi", "io", "fi", "in", "ini", "x", "zi", "g", "ic", "ims", "me", "xi", "name", "qi", "ami", "it", "si", "ix", "t", "ci", "print", "index", "multi", "y", "us", "dr", "f", "id", "ti", "sim", "gi", "ri", "m", "j", "ex"], "ptr1": ["pointer001", "ptOne", "pointer1", "ptr5", " ptr5", "pr0", "ptr3", " ptrN", "pointer91", "Ptr91", " ptr01", "pointer3", "pointer8", "pt2", " ptr3", "Ptr4", "ptr4", "addr0", "tr2", "ptr001", "trN", "tr5", " ptr91", "Ptr8", "tr4", "pointer2", "pt1", " ptr001", "addr2", "pointer01", "Ptr1", "pt0", "addr4", "addr8", "ptr01", "pt4", "ptr0", "ptr91", "pr4", "pointer4", "addr3", "Ptr2", "addr1", " ptr0", "pointer0", "tr8", "ptr8", "pr5", "pt8", "pr2", "ptrOne", "pt3", "PtrOne", "pr01", "pr001", "prN", "ptrN", "tr1", "Ptr0", "Ptr3", "pointerOne", "pr1"], "ptr2": ["ptrTwo", "var02", "pointer1", "ptTwo", "ptr5", "ptr3", "tip02", "pointer6", "pointer3", "ptr512", "trTwo", "pt2", "tr2", "pt02", "tr5", "pr6", "tip2", "pointer2", "pt1", "tipTwo", "pr02", "Ptr1", "Ptr5", "pert1", "pert5", "varTwo", "tr02", "Ptr2", "prTwo", "pointer512", "pert3", "pr5", "pr2", "pert512", "pt512", "pointer5", "var1", "pt3", "pert2", "Ptr6", "tr1", "ptr02", "ptr6", "var2", "pr1"]}}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 3184, "substitutes": {"env": ["iter", "neck", "erd", "ve", "era", "shell", "te", "ei", "v", "en", "conn", "er", "txt", "enc", "console", "global", "gate", "app", "eh", "ef", "worker", "map", "environment", "buf", "window", "eco", "ter", "esc", "viron", "vs", "operator", "uv", "desc", "config", "eas", "ew", "et", "answer", "engine", "entry", "equ", "eni", "ec", "ell", "here", "ctx", "all", "code", "addr", "manager", "den", "gear", "vert", "tx", "el", "query", "exec", "w", "local", "context", "e", "client", "peer", "ende", "end", "server", "ev", "esi", "ner", "obj", "dev", "err", "ee", "event", "eve", "ah", "db"], "val": ["test", "bl", "VAL", "ival", "seq", "q", "item", "b", "pt", "p", "arg", "local", "buf", "l", "mem", "valid", "v", "x", "elt", "al", "value", "loc", "t", "state", "serv", "Val", "ref", "eval", "vals", "z", "tx", "buffer", "vol", "data", "base"], "shift": ["transform", "count", "flag", "axis", "j", "slice", "init", "time", "use", "hash", "ff", "diff", "step", "sign", "help", "length", "mask", "tr", "start", "block", "seed", "ignore", "opt", "p", "sum", "pad", "align", "window", "offset", "sh", "out", "field", "send", "reverse", "jp", "hide", "force", "Shift", "data", "push", "set", "sleep", "loc", "share", "hift", " shifts", "index", "size", "shr", "h", "pack", "ptr", "scale", "sq", " shifted", "pop", "move", "skip", "add", "sub", "update", "off", "save"], "temp": ["em", "test", "n", "attr", "count", "orig", "cap", "time", "min", "tr", "dest", "pt", "cache", "map", "mp", "p", "memory", "ts", "local", "fake", "sum", "max", "mint", "mem", "window", "out", "v", "emp", "term", "len", "perature", "unt", "ta", "dat", "t", "tim", "txt", "size", "tm", "partial", "ptr", "pre", "tmp", "tem", "z", "make", "stem", "buffer", "m", "j", "fac", "Temp"], "result": ["test", "count", "rc", "final", "length", "relation", "tr", "results", "comb", "new", "comment", "response", "cur", "status", "error", "block", "output", "r", "integer", "cache", "ret", "p", "Result", "sum", "memory", "match", "out", "v", "next", "x", "number", "reverse", "message", "command", "power", "jp", "search", "current", "nil", "true", "data", "success", "value", "total", "res", "t", "zero", "table", "root", "done", "ptr", "pack", "tmp", "make", "mate", "sp", "fac", "buffer", "complete", "sequence"]}}
{"project": "qemu", "commit_id": "95ce326e5b47b4b841849f8a2ac7b96d6e204dfb", "target": 1, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 3205, "substitutes": {"term_hist_entry": ["term_hist___deep", "term_history_entry", "term_hist_match", "term_hist_offset", "term_hist_deep", "term_histingkey", "term_hist___entry", "term_history_offset", "term_hist_element", "term_histingentry", "term_history_key", "term_history_char", "term_hist_key", "term_history_match", "term_history_system", "term_hist_no", "term_histingmatch", "term_history_no", "term_histingno", "term_hist_system", "term_hist_id", "term_history_element", "term_history_id", "term_hist_char", "term_history_deep", "term_hist___no"]}}
{"project": "FFmpeg", "commit_id": "3d2c3ef4b46d96023d6f0d358e4d7d65568da67c", "target": 0, "func": "static int decode_cabac_mb_cbp_luma( H264Context *h) {\n\n    int cbp_b, cbp_a, ctx, cbp = 0;\n\n\n\n    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;\n\n    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;\n\n\n\n    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);\n\n    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;\n\n    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;\n\n    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;\n\n    return cbp;\n\n}\n", "idx": 3211, "substitutes": {"h": ["ph", "ht", "each", "hi", "high", "hash", "dh", "q", "eh", "hm", "comm", "b", "c", "ih", "gh", "hl", "th", "hh", "hp", "he", "bh", "p", "hd", "rh", "ha", "her", "l", "v", "header", "sh", "H", "x", "hr", "info", "here", "hal", "ho", "history", "host", "kh", "oh", "http", "zh", "hz", "dev", "hw", "hs", "ch", "ah", "has"], "cbp_b": ["cbper_b", "cbpt___rb", "cbtp_____b", "cbp___a", "cbp_ba", "cbp___b", "cbtp_____ba", "cbp_cb", "cbpt___d", "cbtp_____bb", "cbper_ab", "cbp_____b", "cbpTbs", "cbp___ba", "cbper_ba", "cbp___d", "cbpTb", "cbp_x", "cbtp_b", "cbtp_ba", "cbpt_rb", "cbtp_bb", "cbp_bb", "cbp___rb", "cbpa_bs", "cbpTa", "cbper_cb", "cbp_____bb", "cbp___ab", "cbpt_b", "cbpa_b", "cbpTsb", "cbp_ab", "cbtp_____x", "cbp_sb", "cbpt___a", "cbp_d", "cbp_rb", "cbp_____x", "cbtp_x", "cbp_____ba", "cbpa_a", "cbpa_sb", "cbpt_a", "cbp_bs", "cbpt___b", "cbp___cb", "cbpt_d"], "cbp_a": ["cbp48a", "cbc_both", "cbp_la", "cbc_sa", "cbp___a", "cbp___u", "cbp___b", "cbpa_app", "cbp_as", "cbjp_as", "cbpa_era", "cbjp___a", "cbc___oa", "cbp___ga", "cbc___a", "cbpa00la", "cbp00app", "cbpad_a", "cbc___sa", "cbjp_a", "cbp_l", "cbp___oa", "cbp_sa", "cbc_a", "cbp48oa", "cbp_era", "cbpa00app", "cbp00la", "cbp_oa", "cbp_ga", "cbjp___b", "cbp___both", "cbp00era", "cbp48both", "cbpa00a", "cbc_oa", "cbpad_l", "cbp__u", "cbp48sa", "cbpa_la", "cbjp_ga", "cbpad_u", "cbp__l", "cbp_u", "cbp00a", "cbp___as", "cbc___both", "cbjp___as", "cbp___l", "cbpad___a", "cbp_both", "cbjp___ga", "cbp___sa", "cbpad___l", "cbjp_b", "cbpa_a", "cbpa00era", "cbpad___u", "cbp__a", "cbp_app"], "ctx": ["ht", "wx", "Context", "rc", "nz", "np", "nt", "kk", "cmp", "gz", "cfg", "na", "ct", "temp", "ca", "lc", "cu", "pause", "kl", "gc", "hd", "cp", "cc", "timeout", "req", "thread", "check", "ind", "std", "window", "except", "context", "bc", "dc", "jac", "prefix", "kw", "jp", "tz", "port", "nc", "sc", "history", "conn", "doc", "addr", "kj", "kh", "loc", "wcs", "gas", "qa", "iat", "msg", "txt", "wd", "unc", "pg", "cv", "tc", "act", "obj", "ptr", "pkg", "tmp", "ctl", "cmd", "tx", "desc", "ctr", "cas", "bo", "j", "urg", "pa"]}}
{"project": "FFmpeg", "commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "target": 1, "func": "void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    QSVFrame *cur;\n\n    AVPacket pkt;\n\n    int ret = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n\n\n    if (q->reinit_pending) {\n\n        close_decoder(q);\n\n    } else if (q->engine_ready) {\n\n        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode get param error %d\\n\", ret);\n\n        }\n\n\n\n        ret = MFXVideoDECODE_Reset(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode reset error %d\\n\", ret);\n\n        }\n\n\n\n        /* Free all frames*/\n\n        cur = q->work_frames;\n\n        while (cur) {\n\n            q->work_frames = cur->next;\n\n            av_frame_free(&cur->frame);\n\n            av_freep(&cur);\n\n            cur = q->work_frames;\n\n        }\n\n    }\n\n\n\n    /* Reset output surfaces */\n\n    av_fifo_reset(q->async_fifo);\n\n\n\n    /* Reset input packets fifo */\n\n    while (av_fifo_size(q->pkt_fifo)) {\n\n        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);\n\n        av_packet_unref(&pkt);\n\n    }\n\n\n\n    /* Reset input bitstream fifo */\n\n    av_fifo_reset(q->input_fifo);\n\n}\n", "idx": 3227, "substitutes": {"avctx": ["avcontext", "ajcpp", "Avctx", "avercontext", "avecfg", " avpkg", "averhw", "avcpp", "avercfg", "ajwcs", "avecpp", "avewcs", "Avcontext", "cvcfg", "avecli", "avhw", "avercf", "cvcmp", "avcli", "avercli", "cvctx", " avcontext", "avectx", "ajcf", "avecf", "cvcli", "averctx", "avcf", " avhw", "ajctx", "avpkg", "Avhw", "averpkg", "Avpkg", "avercpp", "avwcs", "avcfg", "avecmp", "avercmp", "avcmp", "averwcs"], "q": ["qu", "k", "dq", "eq", "que", "qs", "form", "query", "self", "comm", "quit", "c", "w", "quick", "r", "cache", "p", "local", "req", "check", "i", "ve", "l", "cf", "ck", "v", "web", "e", "parse", "qq", "in", "queue", "g", "conf", "quote", "qi", "pp", "ctx", "ry", "Q", "iq", "qa", "question", "msg", "quest", "qt", "t", "lock", "ue", "subject", "h", "cl", "pkg", "sq", "z", "f", "requ", "cmd", "ch", "gm", "j", "aq", "ev"], "cur": ["ph", "count", "open", "gov", "cmp", "tr", "r", "cp", "cf", "next", "nc", "round", "coord", "ptr", "cmd", "cr", "str", "c", " curs", "comp", "rec", "max", "buf", "req", "old", "row", "gr", "rev", "col", "Cur", "loc", "last", "cor", "car", "cont", "ver", "occ", "desc", "con", "cat", "rc", "new", "grow", "try", "ret", "stable", "kw", "current", "ctx", "cv", "dr", "tmp", "pri", "ch", "ctr", "ser", "ctrl", "result", "compl", "orig", "ren", "self", "ct", " Cur", "gc", "ur", "bc", "arr", "igh", "sur", "focus", "now", "rs", "serv", "pg", "cycle", "fac"], "pkt": [" pvc", "mqt", "wacket", "twk", "wkt", "paft", " packet", " pct", "pet", "wqt", "wct", "Pct", " pft", "packacket", "packet", "pvc", " pck", "ppck", "packqt", "pct", "packwk", "pck", "pakt", "Pqt", "packvc", "paacket", "mvc", "tacket", "Packet", "mkt", "ppacket", "tet", "packkt", "ppkt", " pqt", "ppft", "pqt", "Pkt", "tkt", "macket", "pack", "pft", " pwk", " pet", "pwk"]}}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 3228, "substitutes": {"a": ["au", "n", "ba", "ab", "ra", "app", "an", "A", "oa", "c", "ca", "ia", "d", "at", "r", "p", "am", "la", "ity", "e", "va", "ar", "area", "ac", "al", "ach", "ma", "aaa", "ae", "as", "apa", "y", "ea", " A", "f", "aa", "sa", "m"], "b": ["s", "n", "ba", "fb", "bi", "ab", "bs", "eb", "c", "rb", "be", "d", "r", "p", "i", "l", "v", "e", "bc", "x", "u", "g", "o", "cb", "nb", "t", "sb", "bb", "y", "z", "f", "m", "j", "db", "B"], "x0": [" xthis", " ax1", "ox50", " ax50", "tx00", "x8", "tx5", "xarg", "tx50", "ex4", "x2", "rx1", "wx000", "txarg", "ex50", "ox00", " x2", "wx1", "wx0", "ox0", "xthis", "tx8", "x50", " x50", "xZero", " xZero", "rx2", "tx0", "wx2", "ix4", "x10", "ix1", "rx10", "rx5", "tx000", " ax0", "ex0", "ox1", "x4", "xx0", "txthis", "ix8", " x00", "ixarg", " x000", "ixthis", "tx10", "xx5", "tx1", "ex1", "tx2", "x00", "ix0", " x5", "rx0", "xx1", "x5", "exarg", "exZero", " axZero", " x10", " x8", "x000", "tx4"], "x1": ["X2", "X0", "x2", " xone", "xx7", "rx1", " x2", "wx1", "xone", "wx0", " cx0", "tx0", "ex3", "x7", "x3", "ex0", "x4", "xx3", " x01", "xx0", " cx1", "X1", "exone", "xxone", "tx1", "x01", " cx7", " cxone", "tx3", " x4", "X01", "ex1", "wx3", "wxone", "xx4", " x7", "rx0", " x3", "xx1", "rx01", "rx2", "tx4"]}}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_reset(DeviceState *dev)\n\n{\n\n    XHCIState *xhci = XHCI(dev);\n\n    int i;\n\n\n\n    trace_usb_xhci_reset();\n\n    if (!(xhci->usbsts & USBSTS_HCH)) {\n\n        DPRINTF(\"xhci: reset while running!\\n\");\n\n    }\n\n\n\n    xhci->usbcmd = 0;\n\n    xhci->usbsts = USBSTS_HCH;\n\n    xhci->dnctrl = 0;\n\n    xhci->crcr_low = 0;\n\n    xhci->crcr_high = 0;\n\n    xhci->dcbaap_low = 0;\n\n    xhci->dcbaap_high = 0;\n\n    xhci->config = 0;\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i+1);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        xhci_port_update(xhci->ports + i, 0);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numintrs; i++) {\n\n        xhci->intr[i].iman = 0;\n\n        xhci->intr[i].imod = 0;\n\n        xhci->intr[i].erstsz = 0;\n\n        xhci->intr[i].erstba_low = 0;\n\n        xhci->intr[i].erstba_high = 0;\n\n        xhci->intr[i].erdp_low = 0;\n\n        xhci->intr[i].erdp_high = 0;\n\n        xhci->intr[i].msix_used = 0;\n\n\n\n        xhci->intr[i].er_ep_idx = 0;\n\n        xhci->intr[i].er_pcs = 1;\n\n        xhci->intr[i].er_full = 0;\n\n        xhci->intr[i].ev_buffer_put = 0;\n\n        xhci->intr[i].ev_buffer_get = 0;\n\n    }\n\n\n\n    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    xhci_mfwrap_update(xhci);\n\n}\n", "idx": 3236, "substitutes": {"dev": ["de", "ad", "pro", "dem", "nt", "att", "w", "Device", "sd", "req", "pad", "ve", "mem", "v", "sys", "pi", "def", "info", "conf", "cam", "os", "conn", "ds", "go", "ach", "Dev", "serv", "device", "ver", "obj", "hw", "cmd", "hid", "ch", "DEV", "scan", "priv", "ev"], "xhci": ["xhuci", "eyheci", "xhdci", "xhlcor", "oxhcin", "oxhrcgi", "xhrci", "xhashdi", "xhecin", "rxhcit", "xshci", "xehcit", "xhslic", "oxhcit", "eyhmm", "xhecu", "xshpi", "xkhri", "rxehuci", "xxhcu", " xxhci", "eyahini", "xhmcont", "xhcor", "xhmlic", "eyehcont", "xehcor", "xhtmlmit", "xhdcu", "xmlhii", "xhmci", "rxhelic", "eyhcgi", "xehcond", "xhcheck", "xhefc", "xxxxhostlic", "wxhashcit", "xhoci", "wxhcci", "rxhlci", "rosskhmit", "xkhili", "txehcu", "xhostcu", "xehcheck", "xhmcor", "xrhoci", "xphpmm", "xhashmc", "xhacit", "xhcin", "xshuci", "xhdcit", "rxhelc", "txhcu", "xchlic", "xxxhostclient", "xhamc", "wxhcor", "mxhacor", " xthci", "xHcin", "xhrfc", "txehcli", "exehcli", "oxhrci", "rosshmcheck", " xxhcu", "xhercheck", "exehcit", "xherii", "xhmii", "eyehcond", "xxxxhostci", "xphcgi", "xehcgi", "xhce", "xxhpi", "rxhlc", "xphpci", "eyhci", "xhfc", "xhlink", "xhcci", "xhri", "xhmce", "xhecci", "xhdini", "xhpi", "eyhcond", "xhtmit", "xehlink", "xhlpi", "xehcli", "xehmc", "xhostfc", "eyhecit", "xxhci", "xhtcci", "rxehci", "xhtmlci", "xhlic", "wxhmcor", "xhdcont", "wxhashci", "eyhcin", "exhdi", "wxhcin", "mxhci", "xhostlic", "rosshili", "rxhuci", "eyahci", "xhecond", "xphci", "xxxhostdi", "xhdri", "xihcu", "xhostclient", "rxhefc", "xhsuci", "xxphcin", "lexhmii", "xmlhmii", "wxhci", "xhacin", "txhci", "xshcu", "eyhdi", "eyehcheck", "eyehdi", "xchuci", "oxhecit", "xhrcu", "wxhmci", "xhmuci", "xrhpi", "oxhecu", "xrhili", "exhki", "xihci", "rychlic", "xmlhuci", "xehlic", "exehini", "rxhecu", "eyhlim", "xhlcci", "rychuci", "rxheci", "xhaoci", "xrhcont", "xphclient", "xhecit", "xhrcli", "rosskhcin", "xhercor", " xxhcond", "xahcont", "rxhci", "rxehcu", "xrhcli", "xhashcin", "rosshci", "eyhecont", "rxhfc", "xmlhmci", "xhduci", "xhecli", "xhtcli", "txhcit", "xhmcli", "xhsci", "xhadi", "mxhcor", "xhostcgi", "wxhcit", "xHcor", "lexhmci", "xphcheck", "xhmclient", "xHcci", "xhddi", "xhspi", "xrhcu", "xxxhci", "xxxxhostcgi", "xshcit", "xhace", "xhacu", "xhaili", "xxxhcgi", "xxxxhostfc", "xhtcgi", "xehki", "eyehcgi", "xhtcor", "xxxhostci", "xhrcont", "xahclient", "xhclient", "xhki", "oxhci", "txhdi", "xmlhmuci", "xehfc", "xhashcit", "exhini", "ryhcgi", "xehpi", "xhtmlcin", "xchci", "eyehcin", "rosshcor", "eyehmm", "mxhuci", "xhdki", "eyhecu", "exehdi", "xhluci", "rosshcin", "rxhlcci", "xehmm", "xhmcu", "xxphcu", "rxhemit", "xahini", "txhcli", "xherce", "xthoci", "xhaini", "xhtci", "xhdcgi", "xehcin", "rosshmit", "txehci", "xxxxhlic", "xphpi", "xehcont", "ryhlic", "ryhuci", "rxhcont", "xehdi", "rosshcheck", "txhedi", "xhtili", "oxhuci", "xhrcit", "rxhmit", "xhscor", "xphdi", "exehki", "rxhmc", "exhcit", "xihcont", "xhsclient", "xxxxhcgi", "eyehcli", "xrhdi", "wxhmcin", "xhashini", "xxxxhci", "rxhlcu", "xhlim", "xkhcgi", "ryhci", "xhashri", "xhcit", "xhcgi", " xhili", "xehci", "xhecgi", "txhpi", "xxphpi", "eyahcit", "xhapi", "xmlhcin", "oxhruci", "xhmcci", "xthci", "rxhlcit", "exhcli", "xkhmit", "xxhcin", "lexhce", "eyhlic", "txhepi", "xhcli", "xrhci", "xkhclient", "xhashuci", "xhelc", "xxxxhfc", "mxhaci", "lexhcli", "xhelic", "xhmit", "xhacheck", "rxhecont", "xhili", "xhashlim", "xHci", "xmlhci", "rosshlink", "eyhcu", "rxhcci", "mxhapi", "xshcli", " xthoci", "xherlink", "rxehmc", "xkhdi", "wxhmcci", "xherci", "xhalim", "lexhmce", "lexhii", "eyhcont", "xshcin", "xhrlic", "xheci", "xhlc", "eyahlim", "eyehcu", "rosshmci", "oxhcgi", "xxphci", "xkhcli", "xhacli", "eyhclient", "rxhcu", "rychcgi", "xhlcu", "xhlcit", "xhaci", "xhmcond", "xxxhostcgi", "xehuci", "xhlcond", "xahcit", "eyehci", "txehcit", "xphcin", "xhmc", " xhoci", "rychci", "xhmcheck", "xhlcin", "xhmlink", "rxhlic", "xehini", " xxhmcond", " xxhmcit", "xphcu", " xthili", "xhostci", "xhecont", "xrhcin", "xhcond", "txhecli", "xhemit", "oxhrcit", "xhedi", "xkhci", "txheci", "exhci", "xhmm", "xhtcu", "xchcgi", "xhcont", "xhashki", "xthcu", "xhlci", "xhashci", "lexhci", "xehcu", "xhaii", "xhepi", " xthcu", "xphpclient", "xhrlc", "rosskhci", "xihcit", "xhtcin", "rosshmlink", "wxhashcin", "oxhecin", "xxxhdi", "xshdi", "xhcu", "eyhcit", "xhrmit", "xshii", "wxhashri", "xhmcgi", "rosshmcor", "xhauci", "xhini", "eyhini", "xphplic", "xhostdi", "xhtmlili", "xahci", "xhashcu", "xhruci", "xhdpi", "xkhcin", " xxhmci", "xehclient", "mxhpi", " xxhmcu", "xahcond", "xrhcit", "oxheci", "oxhcu", "eyhcheck", " xhcu", "lexhmcli", "xhercli", "xhdcin", "xxxhclient", "xhdmit", "eyehclient", "xahlim", "xhacor", "xhrcgi", "xhmcin", "wxhri", "xhmcit", "xmlhmcin", "xhdlc", "xkhuci", "exehci", "xhdi", "xkhcit", "eyehlic", " xxhcit", "xthili", "xhii", "rosskhili", "mxhauci", "eyhcli", "xhsmm"], "i": ["n", "oi", "cli", " multi", "iri", "by", " p", "mi", "uri", " si", " mi", "MI", "ind", " I", "loop", "ai", "ei", "is", "ij", "ic", "port", "history", "it", "si", "y", "h", "id", "ti", "io", "phi", "iu", "bi", "init", " c", " wi", "q", "ui", "batch", " m", "di", "status", "x", "jj", " pos", "fi", "ini", " di", "zi", "jp", "list", "ims", "xi", " ti", "ami", " ii", "iq", " vi", "index", "multi", "chain", "sim", "ri", "j", "I", "this", " li", "point", "im", "ki", "try", " index", "p", " bi", "iii", "l", "ip", "info", "name", "ix", "ci", " ni", "dr", "gi", "m", "ex", "s", "li", " j", "ii", "remote", "ji", "\u0438", "e", "pi", "in", " pi", "g", "me", "qi", "gu", "t", "f", "ski", "o"]}}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3237, "substitutes": {"pvr": [" pvc", "pfx", "pbr", " phr", "cfx", " ppvp", "tpserv", "ipvp", " pbr", "gfx", "cvc", "iplr", "pvc", "tphr", "iptr", "tpbr", "cver", "phr", "plr", "cvr", " ptr", " ppvr", " pvp", "pserv", "ipvr", "pphr", "gvc", "ppserv", " pfx", " pver", "gver", " pplr", "ppbr", " plr", "gvr", "tpvr", "ptr", "pver", " pptr", "ppvr", " pserv", "pvp"], "def": ["de", "Def", "day", "del", "form", "nt", "ef", "pos", "lit", "block", "buf", "prop", "req", "feat", "decl", "aux", "cal", "out", "ex", "fun", "bf", "define", "DE", "crit", "fc", "conf", "df", "push", "ds", "pass", "msg", "fam", "res", "val", "da", "ref", "dev", "DEF", "des", "f", "cmd", "desc", "DEV", "defined", "vec"], "i": ["phi", "iy", "iu", "I", "oi", "bi", "cli", " li", "li", "ui", "point", " j", "batch", "asi", "c", "di", "ii", "im", "mi", "uri", "try", "ki", "remote", " si", "p", " mi", "ji", " bi", "\u0438", "ind", "ip", "ai", "is", "ei", "ij", "v", "x", "e", "pi", "fi", "ini", "info", "list", "ic", "me", "qi", "xi", "my", " iter", "ik", "o", " ti", " ii", "it", "si", "ix", "to", "iat", "ci", "index", "multi", "y", " ni", "json", "ti", "sim", "gi", "ri", "m", "j", "series", "io"], "ret": ["bt", "alf", "flag", "rets", "det", "nt", "re", "tr", "status", "pt", "try", "alt", "inter", "match", " Ret", "out", "quad", "fi", "rm", "ft", "gt", "rt", "elt", "len", "ne", "store", "end", "Ret", "RET", "res", "t", "val", "print", "cont", "rel", "ref", "usr", "mt", " RET", "dr", "tmp", "f", "cmd", "reply", "result", "back", "rem"]}}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n", "idx": 3256, "substitutes": {"T0": [" T9", "WT1", "TN1", "TN9", "TN100", "T00", "P2", "M8", "P00", "WT0", "T1", " T00", "V2", "V0", "T2", "P9", "S9", "M2", " T1", "T9", "S00", "V8", "P8", "P0", "M0", "WT100", " T100", "P1", "T8", "WT9", "S0", "TN0", "S1", "M1", "V1", "T100"], "vaddr": [" vadr", "wcoord", " vadd", "wadr", "vvadd", "waddr", "fadr", "vaddress", "vvAddress", " vptr", "vcoord", "vvaddress", "vptr", "waddress", "vdr", "vvptr", " Vaddress", " vdr", " vaddress", "vAddress", "tAddress", " vAddress", "wadd", "wdr", "voca", "faddress", "tadd", "vadr", " vcoord", "wptr", " voca", "fadd", "faddr", " Vaddr", "vvaddr", "vvdr", "woca", "taddress", " Vcoord", "vvoca", " Vadd", "vadd", "taddr"]}}
{"project": "qemu", "commit_id": "99fd437dee468609de8218f0eb3b16621fb6a9c9", "target": 0, "func": "static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n", "idx": 3266, "substitutes": {"slot": ["service", "locked", "slice", "hash", "unit", "item", "cell", "entry", "block", "seed", "height", "sector", "pointer", "timeout", "hit", "pot", "loop", "offset", "hot", "spot", "window", "Slot", "lot", "port", "binding", "zone", "second", "handle", "key", "location", "position", "set", "layout", "loc", "share", "kh", "sid", "to", "addr", "val", "zero", "esi", "ref", "index", "size", "table", "soc", "snap", "usage", "option", "address", "sp", "padding", "id", "label", "chain", "scroll", "pos"], "ssdt_ptr": ["ssdt_eth", "ssder_pointer", "ssdat_pt", "ssdt_arr", "ssdt___Ptr", "ssdt0addr", "ssdt___ptr", "ssDT_addr", "ssdt_vr", "ssd_Ptr", "ssdat_addr", "ssdtaphtrace", "ssdtaphaddr", "ssd_addr", "ssdat_obj", "ssder_addr", "ssdt_pt", "ssdt0tr", "ssdt_addr", "ssdt___addr", "ssdt_trace", "ssDT_ptr", "ssd_vr", "ssdat_Ptr", "ssDT_Ptr", "ssdt_pointers", "ssdt___pointer", "ssdat_eth", "ssd_ptr", "ssdat_pointer", "ssdt___eth", "ssdt0ptr", "ssderaphaddr", "ssdt0pointers", "ssdt_pointer", "ssdtaphpointer", "ssder_ptr", "ssder_trace", "ssderaphptr", "ssderaphpointer", "ssdat_pointers", "ssdat_tr", "ssDT_arr", "ssdtaphptr", "ssdat_ptr", "ssdt___vr", "ssdt_Ptr", "ssdt_obj", "ssderaphtrace", "ssdt_tr"], "eject": ["eJECT", "eejected", "elect", "pejection", "Elect", "ejection", "eelect", "eleject", "eeJECT", "elejected", "peJECT", "eeject", "eejection", "elejection", "EJECT", "Eject", "ejected", "Ejected", "pejected", "elelect", "Ejection", "peject"]}}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n", "idx": 3274, "substitutes": {"main_stride": ["main_collide", "main_divine", "main_strIDE", "main_strine", "main_variIDE", "main_stide", "main_striide", "main_collice", "main_Strope", "main_stope", "main_striie", "main_Stride", "main_collick", "main_strick", "main_divide", "main_variipe", "main_Stripe", "main_Strride", "main_colline", "main_divick", "main_Strick", "main_divice", "main_variride", "main_striride", "main_Strie", "main_stie", "main_strice", "main_striope", "main_strope", "main_variide", "main_StrIDE", "main_Strice", "main_strride", "main_stripe", "main_strie", "main_Strine"], "ref": ["lib", "ext", "orig", "fr", "q", "self", "ef", "re", "block", "r", "ret", "alt", "p", "local", "req", "mem", "aux", "row", "rm", "def", "conf", "reg", "reset", "br", "master", "rot", "rel", "Ref", "f", "reference", "range", "red", "m", "tab", "base", "ro", "rem"], "ref_stride": ["ref_drategy", "ref_spride", "ref_gride", "ref_grine", "ref_strine", "ref_STRid", "ref_sprine", "ref_constide", "ref_strategy", "ref_grride", "ref_strider", "ref_Strider", "ref_Strade", "ref_dride", "ref_grade", "ref_grider", "ref_strride", "ref_strid", "ref_Strride", "ref_constride", "ref_constategy", "ref_sprider", "ref_drride", "ref_strade", "ref_constade", "ref_sprride", "ref_STRride", "ref_drade", "ref_Strid", "ref_Strategy", "ref_Stride", "ref_grid", "ref_STRade", "ref_STRide", "ref_Strine"], "height": ["visible", "ht", "count", "resolution", "high", "hash", "hang", "holes", "length", "above", " Height", "build", "volume", "style", "angle", "grow", "rank", "th", "Height", "html", "yt", "he", "capacity", "w", "max", "type", "density", "window", "row", "hei", " heights", "history", "bottom", "inches", "radius", "zh", "size", "rows", "stroke", "h", "gravity", "depth", "shape", "padding", "ty", "range", "buffer", "cy"], "temp": ["test", "get", "fact", "length", "unit", "tr", "c", "water", "pt", "w", "p", "max", "type", "vt", "fake", "mint", "create", "offset", "hot", "v", "out", "template", "current", "reset", "ac", "hum", "value", "total", "t", "tar", "txt", "tm", "index", "tc", "ptr", "pre", "tmp", "tem", "buffer", "m", "fac", "Temp"], "x": ["k", "n", "wx", "el", "xs", "ext", "axis", "q", "c", "att", "at", "X", "w", "one", "r", "p", "lat", "on", "xy", "i", "rx", "fx", "l", "xxxx", "v", "e", "ax", "xp", "xf", "xc", "g", "mx", "xi", "num", "xa", "ord", "en", "key", "ix", "column", "px", "index", "inx", "xx", "ux", "h", "yx", "f", "ox", "xt", "tx", "add", "m", "j", "dx", "ex"], "y": ["k", "iy", "n", "wy", "yr", "yo", "ly", "b", "year", "yi", "by", "ot", "yt", "w", "try", "ey", "py", "p", "ye", "xy", "i", "yn", "l", "v", "sky", "kit", "my", "ys", "col", "ies", "o", "ay", "key", "ry", "yy", "ny", "ym", "t", "Y", "yl", "index", "oy", "xx", "uy", "axy", "h", "ty", "ch", "gy", "vy", "m", "j", "cy", "sy"], "sum0": ["mem00", "um2", "Sum3", "mean00", "mem0", "mean1", " sum2", "sum00", "mean0", "sum2", "um3", "Sum2", "mean2", "mem1", "Sum0", "sum5", "um0", "Sum5", "sum3", "mem3", "mem2", " sum3", " sum5", " sum00", "um1", "um5", "Sum1"], "sum1": ["fac1", "fac0", "fac2", "um2", "Sum3", " sum4", " sumy", "mem0", " sum2", "facy", "sum2", "Sum2", "mem4", "sumy", "mem1", "Sum0", "um0", "sum3", "sum4", "mem3", "memy", "mem2", " sum3", "um1", "Sum1", "um4"], "z": ["az", "wx", "zip", "zes", "Z", "zer", "nz", "gz", "q", "uz", "ez", "c", "rez", "d", "w", "ey", "zz", "xy", "i", "zi", "cz", "tz", "g", "zo", "zone", "oz", "os", " cz", "fl", "iz", "ld", "zx", "t", "zh", "zero", "hz", "ed", "zy", "ze", "yz", "ox", "zen", "gy", "j", "cy"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n", "idx": 3278, "substitutes": {"obj": ["inst", "n", "ht", "attr", "xs", "str", "init", "np", "fr", "nt", "org", "cmp", "att", "ot", "pt", "pr", "bh", "rect", "gc", "bo", "req", "xy", "iv", "ind", "ck", "onet", "ij", "ob", "obo", "obs", "elt", "rt", "ctx", "it", "tk", "expr", "resp", "cod", "t", "object", "cont", "txt", "bj", "act", "ie", "hw", "tmp", "Obj", "cmd", "desc", "js", "typ", "o", "j", "po", "instance", "ex"]}}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279, "substitutes": {"bs": ["BS", "bp", "bl", "ab", "lbs", "ses", "b", "bps", "pb", "ls", "boxes", "bh", "ts", "its", "ps", "bo", "uts", "gs", "bc", "ops", "bm", "cks", "obs", "ss", "aos", "bos", "bes", "outs", "os", "bis", "fs", "ds", "vs", "cb", "ats", "rs", "ns", "bits", "sb", "bb", "amps", "locks", "cs", "hs", "js", "ubs", "aws", "ubis", "aus"], "options": ["ones", "stats", "Options", "events", "xes", "offs", "results", "es", "lets", "values", "issues", "atts", "uploads", "pps", "comes", "styles", "includes", "als", "ts", "its", "ps", "tops", "uts", "groups", "ops", "parts", "aches", "classes", "opens", "ims", "checks", "os", "aps", " Options", "fs", "features", "settings", "finals", "params", "times", "actions", "ption", "args", "obj", "vals", "weights", "amps", "locks", "option", "pins", "caps", "ices", "details", "rules", "tools", "roots", "errors", "IONS", "ptions", "properties", "data", "steps"], "flags": ["flag", "rets", "mask", "ents", "ags", "states", "uns", "ts", "tags", " flag", "fields", "features", "fs", "ds", "Flag", "fee", " Flags", "res", "bits", "args", "vals", "files", "lag", "weight", "cmd", "Flags", "mode"], "errp": ["erpa", "rarpar", "iterpa", "errpp", "thinkp", "thinkpar", "rrpn", "sprpa", "rrpa", "ererP", "errpa", "errpb", "ererpa", "Erpat", "ererp", "thinkpb", "Erpa", "errorper", "errpat", "erpp", "rrpb", "iterp", "thinkpn", "iterpp", "erp", "Erp", "rarpb", "erP", " errpat", "sprp", "rrP", "rrp", "sprpp", "errorpa", "errorp", "errpar", "sprP", "iterP", "ererpat", " errper", "errP", "rarp", "rarpn", " errpa", "rrpar", "rrper", "errpn", "errorP", "errper", "ErP", " errP"], "s": ["ils", "ab", "b", " ss", "ssl", "ls", "p", "ts", "its", "ps", "gs", "v", "is", "sys", "ss", "g", "ys", "sv", "os", "fs", "ds", "vs", "sts", "ats", "rs", "ns", "state", "sb", "S", "ins", "h", "sq", "cs", "sp", "hs", "js"], "opts": ["dropters", "iopms", " copj", "opsfs", " oputs", "opsts", "copts", " optes", "optj", "optfs", " opj", "icters", "popms", "opents", "dropents", "analyts", "popts", "opps", "copps", " opte", "ictions", " opt", "opt", "iopTS", " opps", "iopts", "dropts", "iopt", "opj", "opstions", "optters", "optents", "analyTS", "verts", "optts", "coptions", "opttes", "icts", "optuts", "optte", "analyt", "icents", "opfs", "popTS", "analyms", "opte", "opsents", " opTS", "optes", "coputs", "oputs", "copTS", "opms", "opTS", "opttions", "droptions", "vertions", " coptes", " opms", "popters", " opters", "opters", " copte", "copters", "copms", "verfs", "verents", " copts", "optps"], "local_err": [" local_elt", "locallyerr", "localingrr", "local5err", "foreign_res", "foreignlyerr", "localjerrors", " local_cert", "locallyusr", "foreign_iter", " local_msg", "locallyiter", "global_er", "specific_err", "local_er", "local5plain", "internal_er", "localErrr", "localingelt", "local_plain", "foreign_usr", "local_usr", "foreignlyres", "locallykr", "locallyres", "foreignlyusr", "locallydev", " local_log", "localErelt", " local_iter", "local_kr", "localjer", "local__err", "localingerr", "specific_sys", " local_er", "foreignlyiter", "localjerr", "local_errors", "local_res", "localjsys", "local_rr", "global_plain", "foreign_err", "local_log", "global_err", "internal_err", "local5er", "specific_er", "localErerr", " local_rr", "local_elt", "local__elt", "internal_elt", "local_dev", "localErer", "local_cert", "local_sys", "local_gr", " local_gr", "local_msg", "local__rr", " local_dev", "local_iter", " local_kr", "internal_rr", "specific_errors"], "ret": ["flag", "ext", "cat", "rets", "det", " alt", "nz", "over", "nt", "re", "sort", "tr", "jump", "ert", "att", "status", "lit", "try", "opt", "compl", " fut", "alt", "gc", "arg", "ll", " Ret", "pas", "out", "detail", "fun", "rm", "__", "rev", "ft", "gt", "fi", "rt", "elt", "lt", "def", "len", "reset", "af", "dt", "fl", "set", "resp", "Ret", "RET", "res", "t", "val", "print", "rel", "cert", "ref", "usr", "txt", "cont", "mt", " RET", "f", "cmd", "desc", "result", "rem"]}}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3288, "substitutes": {"s": ["n", "sg", "stats", "qs", "ses", "an", "comm", "es", "b", "c", "tains", "ls", "w", "r", "ains", "p", "ts", "its", "south", "gs", "v", "is", "sys", "x", "ties", "less", "ss", "g", "sv", "os", "ies", "fs", "ds", "a", "vs", "sts", "ats", "t", "ns", "rs", "sm", "as", "sb", "S", "scl", "ins", "h", "session", "y", "sw", "setup", "sq", "z", "cs", "hs", "js", "aws", "m"], "addrlo": ["addresslo", "addresslow", "addressLO", "addrLO", "addrlow", "AddressLo", "addressilo", "offsetLo", "ptrlo", "offsetLO", "Addresslo", "ptrLo", "addresshi", "offsetlo", " addrLo", " addrlow", "addrilo", "addressLo", "offsetilo", "addrLo", "Addresslow", "ptrilo", "ptrLO", "Addresshi"], "addrhi": ["shaupper", "clonehei", "clonehel", "cloneupper", "addrhei", "shahi", "clonehi", "ptrhi", "addrupper", "shahei", "ptrhel", "ptrupper", "shahel", "ptrhei", "addrhel"], "s_bits": [" s2bs", " s_flags", " s_bs", "s2bits", " s2flags", " s2bit", "s_bit", " s2bits", " s_bit", "s2bs", "s2bit", "s_bs", "s2flags", "s_flags"], "tlb_offset": ["tlb_off", "tlb_Offset", "tpl_Offset", "tpl_offset", "tlab_offset", "tlabptoffset", "tl_Offset", "tlab_origin", "tlbptorigin", "tlp_Offset", "tlb___offset", "tlbs_bytes", "terb___ref", "tlb67Offset", "tlb_count", "tlp_off", "tl_pos", "tlbs_offset", "tlabptOffset", "tlb67offset", "tlbs_bit", "tlb_bit", "tlb_bytes", "tlp_offset", "tlabptorigin", "terb___Offset", "terb___offset", "terb_ref", "tlab_Offset", "tlb_ref", "tlb_data", "terb_Offset", "tpl_count", "tlb___Offset", "tlbs_Offset", "tlb_size", "tlb_origin", "tlb_pos", "tlb67count", "terb_offset", "tlbptoffset", "tlbs_size", "tlbs_data", "tlbptOffset", "tl_offset", "tlb___ref"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static void qdm2_decode_super_block(QDM2Context *q)\n\n{\n\n    GetBitContext gb;\n\n    QDM2SubPacket header, *packet;\n\n    int i, packet_bytes, sub_packet_size, sub_packets_D;\n\n    unsigned int next_index = 0;\n\n\n\n    memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));\n\n    memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));\n\n    memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));\n\n\n\n    q->sub_packets_B = 0;\n\n    sub_packets_D    = 0;\n\n\n\n    average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]\n\n\n\n    init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);\n\n    qdm2_decode_sub_packet_header(&gb, &header);\n\n\n\n    if (header.type < 2 || header.type >= 8) {\n\n        q->has_errors = 1;\n\n        av_log(NULL, AV_LOG_ERROR, \"bad superblock type\\n\");\n\n        return;\n\n    }\n\n\n\n    q->superblocktype_2_3 = (header.type == 2 || header.type == 3);\n\n    packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);\n\n\n\n    init_get_bits(&gb, header.data, header.size * 8);\n\n\n\n    if (header.type == 2 || header.type == 4 || header.type == 5) {\n\n        int csum = 257 * get_bits(&gb, 8);\n\n        csum += 2 * get_bits(&gb, 8);\n\n\n\n        csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum);\n\n\n\n        if (csum != 0) {\n\n            q->has_errors = 1;\n\n            av_log(NULL, AV_LOG_ERROR, \"bad packet checksum\\n\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    q->sub_packet_list_B[0].packet = NULL;\n\n    q->sub_packet_list_D[0].packet = NULL;\n\n\n\n    for (i = 0; i < 6; i++)\n\n        if (--q->fft_level_exp[i] < 0)\n\n            q->fft_level_exp[i] = 0;\n\n\n\n    for (i = 0; packet_bytes > 0; i++) {\n\n        int j;\n\n\n\n        if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) {\n\n            SAMPLES_NEEDED_2(\"too many packet bytes\");\n\n            return;\n\n        }\n\n\n\n        q->sub_packet_list_A[i].next = NULL;\n\n\n\n        if (i > 0) {\n\n            q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i];\n\n\n\n            /* seek to next block */\n\n            init_get_bits(&gb, header.data, header.size * 8);\n\n            skip_bits(&gb, next_index * 8);\n\n\n\n            if (next_index >= header.size)\n\n                break;\n\n        }\n\n\n\n        /* decode subpacket */\n\n        packet = &q->sub_packets[i];\n\n        qdm2_decode_sub_packet_header(&gb, packet);\n\n        next_index      = packet->size + get_bits_count(&gb) / 8;\n\n        sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2;\n\n\n\n        if (packet->type == 0)\n\n            break;\n\n\n\n        if (sub_packet_size > packet_bytes) {\n\n            if (packet->type != 10 && packet->type != 11 && packet->type != 12)\n\n                break;\n\n            packet->size += packet_bytes - sub_packet_size;\n\n        }\n\n\n\n        packet_bytes -= sub_packet_size;\n\n\n\n        /* add subpacket to 'all subpackets' list */\n\n        q->sub_packet_list_A[i].packet = packet;\n\n\n\n        /* add subpacket to related list */\n\n        if (packet->type == 8) {\n\n            SAMPLES_NEEDED_2(\"packet type 8\");\n\n            return;\n\n        } else if (packet->type >= 9 && packet->type <= 12) {\n\n            /* packets for MPEG Audio like Synthesis Filter */\n\n            QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);\n\n        } else if (packet->type == 13) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = get_bits(&gb, 6);\n\n        } else if (packet->type == 14) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);\n\n        } else if (packet->type == 15) {\n\n            SAMPLES_NEEDED_2(\"packet type 15\")\n\n            return;\n\n        } else if (packet->type >= 16 && packet->type < 48 &&\n\n                   !fft_subpackets[packet->type - 16]) {\n\n            /* packets for FFT */\n\n            QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);\n\n        }\n\n    } // Packet bytes loop\n\n\n\n    if (q->sub_packet_list_D[0].packet != NULL) {\n\n        process_synthesis_subpackets(q, q->sub_packet_list_D);\n\n        q->do_synth_filter = 1;\n\n    } else if (q->do_synth_filter) {\n\n        process_subpacket_10(q, NULL);\n\n        process_subpacket_11(q, NULL);\n\n        process_subpacket_12(q, NULL);\n\n    }\n\n}\n", "idx": 3290, "substitutes": {"q": ["qu", "k", "dq", "eq", "view", "ql", "qs", "form", "que", "query", "self", "comm", "quit", "comment", "hl", "w", "pt", "quick", "rec", "r", "cache", "p", "cp", "req", "check", "ve", "cf", "ck", "v", "window", "x", "qq", "info", "queue", "conf", "g", "quote", "qi", "pp", "ctx", "ry", "iq", "Q", "qa", "question", "msg", "quest", "qt", "t", "er", "ue", "ce", "pg", "debug", "y", "h", "pkg", "sq", "z", "f", "requ", "cmd", "gm", "ch", "config", "aq", "client"], "gb": ["bridge", "attr", "lib", "kb", " gcc", "DB", "yg", "binary", "Gb", "gd", "bytes", "bg", "cfg", "b", "rb", " rg", "pb", "rg", " kb", " db", "gc", "py", "bn", "buf", "img", "ge", "git", "gs", "ga", "csv", "BB", "bm", "bf", "gt", "g", "ctx", "BG", "gu", "cb", "gio", "gue", "nb", "bits", "hub", "sb", "bb", "goo", "hog", "GB", "cv", "pg", "mb", "eg", "gp", "storage", "vm", "gg", "tg", "gm", " rgb", " GB", "buffer", "gin", "db"], "header": ["magic", "hash", "record", "metadata", "prot", "error", "cache", "head", "player", "definition", "attribute", "bm", "member", "heading", "history", "handle", "dt", "er", "part", "component", "h", "writer", "address", "request", "cmd", "padding", "detail", "note", "layer", "status", "drm", "command", "list", "len", "timer", "master", "operator", "user", "table", "ver", "index", "extra", "option", "holder", "version", "buffer", "config", "term", "data", "line", "tag", "section", "response", "entry", "rule", "match", "body", "number", "vv", "format", "info", "chron", "name", "document", "headers", "rr", "position", "msg", "column", "tar", "state", "feature", "dr", "HEAD", "sort", "spec", "flag", "author", "query", "filter", "relation", "summary", "item", "comment", "commit", "block", "type", "Header", "wrapper", "offset", "title", "peer", "handler", "lp", "server", "t", "size", "event", "client"], "packet": ["octet", "pet", "octacket", "packetter", "pets", "octets", "ppET", "packacket", "bucket", "buckET", "ppets", "pET", "packets", "ppetter", "bucketter", "ppacket", "ppet", "octkt", "ppkt", "packkt", "packET", "pkt", "buckets", "petter"], "i": ["I", "bi", "li", "b", "c", "ii", "mi", "ki", "p", " bi", "l", "ai", "v", "ij", "x", "pi", " ii", "it", "si", "ix", "ci", "t", "index", "y", "ti", "m"], "packet_bytes": ["packet_errors", "packets_bytes", "packet_size", "packed_len", "packet_Bytes", "packed_tes", "packet_len", "packed_bytes", "packed_size", "packets_Bytes", "packets_errors", "packet_tes", "packets_size"], "sub_packet_size": ["sub_packets_SIZE", "sub_packet_SIZE", "sub_packets_size", "sub_packets_bytes", "sub_packet_ize", "sub_packet_bytes", "sub_packets_ize"], "sub_packets_D": ["sub_packets_P", "sub_packet_P", "sub_packet_G", "sub_packet_DS", "sub_packet_B", "sub_packets_B", "sub_packet_D", "sub_packets_DS", "sub_packets_G"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n", "idx": 3293, "substitutes": {"c": ["s", "b", "ct", "ca", "d", "w", "p", "cc", "v", "e", "context", "dc", "g", "fc", "sc", "ctx", "ac", "a", "C", "t", "ci", "cv", "h", "tc", "f", "cs", "chain", "m"], "dst": ["rdest", " drc", "dsdest", "sst", "ddest", "dsict", "dest", "rest", "adict", "adst", "dsct", "sdest", "rrc", "rst", "sest", "drc", "adct", " dct", "dict", " ddest", "addest", "dsst", "dct", " dest", " dict"], "dstW": ["DestW", "dstsWA", "dtdL", "dstH", "dtdWA", "destW", "dstsW", "dsstsV", "ddestW", "ddestH", "destH", "DestV", "dtdW", "DestH", "ddestSize", "DestSize", "distW", "dstV", "dtdV", "dstWA", "dstSize", "distV", "dsstL", "dstL", "destSize", "dsstsL", "destV", "dsstsWA", "destL", "DstW", "distSize", "dstsV", "dstsL", "dsstWA", "dsstsW", "ddestV", "dsstW", "DstSize", "DstH", "destWA", "dsstV", "DstV", "distH"], "src": ["s", "inst", "supp", "transform", "attr", "input", "bs", "rc", "slice", "ssl", "dest", "r", "rl", "sel", "stream", "img", "std", "st", "ur", "sys", "in", "secure", "sc", "source", "conv", "trans", "sr", "loc", "sur", "rs", "sb", "ins", "usr", "sl", "fil", "ser", "ctr", "sub", "scan"], "filter": ["tag", "test", "transform", "pipe", "flag", "binary", "hash", "ff", "mask", "batch", "block", "channel", "control", "map", "cache", "match", "stream", "fp", "offset", "attribute", "pixel", "search", "bit", "sc", "source", "fl", "profile", "focus", "table", "ref", "tf", "color", "fw", "scale", "f", "fil", "skip", "range", "buffer", "config", "term", "Filter", "sort"], "filterPos": ["filterpos", " filterPOS", "matchSize", " filterpos", "FilterNeg", " filterNeg", "matchpos", "FilterSize", "filterNeg", "filpos", "FilterPos", "Filterpos", "FilterPOS", "filSize", "filPos", "filterPOS", "filNeg", "matchPOS", "matchPos"], "filterSize": ["blockCount", "matchSize", " filterSIZE", "FilterStyle", "blockHeight", "blockLength", " filterLength", "matchLength", "matchHeight", "filterHeight", "filterCount", " filterCount", "matchSIZE", "filterLength", "FilterSIZE", "FilterSize", "FilterPos", "FilterCount", " filterStyle", "blockSize", "filterSIZE", "blockSIZE", "filterStyle", "blockPos", "blockStyle", " filterHeight"], "i": ["phi", "iu", "I", "bi", "this", "li", "ui", "di", "ir", "ia", "ii", "im", "mi", "uri", "ki", "\u0438", "ind", " I", "ip", "ai", "ei", "is", "ij", "l", "x", "v", "pi", "ini", "info", "zi", "ic", "ims", "me", "xi", "wi", " ti", "or", " ii", "it", "si", "ix", "iq", "to", "ci", "index", "multi", "ie", "y", "us", "f", "um", "id", "ti", "sim", "gi", "ri", "m", "io"], "j": ["k", "uj", "other", "n", "el", " J", "bs", "jc", "jack", "fr", "q", "jump", "by", "m", "at", "oj", "pt", "r", "pr", "je", "bo", "dj", "ji", "on", "ind", "l", "ja", "v", "ij", "x", "jj", "ion", "jp", "g", "br", "ng", "it", "jit", "kj", "er", "aj", "bj", "ie", "obj", "y", "z", "json", "bot", "jl", "js", "ch", "kid", "J", "jo", "o"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n", "idx": 3320, "substitutes": {}}
{"project": "qemu", "commit_id": "25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0", "target": 1, "func": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n", "idx": 3322, "substitutes": {"sockfd": ["sixfd", "sockfs", "socksaddr", " sessfd", "sockfile", " sesspid", "sessfd", " sinkaddr", "srcptr", " sockpid", " sinkfs", "srcfd", "socksptr", " sessptr", "sockfp", "sinkaddr", "socksfile", " sockfs", "sockspid", "sesspid", "sixfs", "sixfile", "sinkfile", "socksfd", "sockaddr", " sockaddr", " sinkfd", "socksfp", "socksfs", "sessfp", "sinkfd", "sixaddr", " sockptr", " sockfile", "srcfp", "srcpid", "sockptr", "sinkfs", "sockpid", " sockfp", "sessptr", " sessfp", " sinkfile"], "iov": ["uj", "iu", "gov", "isco", "ilo", "veh", "vr", "mus", "ir", "ovi", "usb", "iper", "iour", "iv", "tv", "eur", "ivic", "river", "v", "ij", "iva", "inv", "nov", "conv", "chrom", "voc", "iev", "vo", "serv", "rov", "vp", "voice", "iol", "liv", "icon", "iop", "io"], "ret": ["rets", "iter", "re", "tr", "prime", "next", "rm", "deg", "ne", "success", "ry", "dt", "resp", "Ret", "vers", "val", "txt", "done", "ed", "ptr", "net", "sent", "cmd", "repl", "status", "alt", "buf", "def", "rev", "gt", "jp", "ter", "len", "num", "true", "ord", "ben", "mt", "xt", "desc", "buffer", "j", "data", "pro", "read", "ext", "cat", "nz", "response", "try", "out", "info", "rt", "elt", "lt", "code", "msg", "RET", "tmp", "result", "rem", "flag", "det", "not", "mem", "offset", "fun", "reset", "total", "res", "t", "progress", "err", "got", "back"]}}
{"project": "qemu", "commit_id": "e24e49e6194626e4ec9f1aecce6d6a6847320bce", "target": 1, "func": "static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n", "idx": 3327, "substitutes": {"bs": ["BS", "bp", "iss", "lbs", "qs", "bas", "ses", "bps", "blog", "ls", "bh", "ts", "its", "bn", "gs", "bc", "bm", "ks", "bf", "cks", "ss", "aos", "bos", "sis", "bis", "fs", "ds", "vs", "sts", "ns", "sb", "bb", "aks", "cs", "hs", "ubs", "bes"], "backing_file": ["backing___channel", "backding_file", "backding_url", "backding_channel", "backingphpFILE", "backing___FILE", "backing_FILE", "backing___path", "backingPpath", "backing_url", "backing___file", "backding_path", "backingphpfile", "backingPfile", "backing_channel", "backingphpchannel", "backding_FILE", "backingPurl", "backing_path", "backingphppath"], "backing_fmt": ["backing_fpid", "backing_vats", "backing_flt", "backing_Fmt", "backing_figformat", "backing_figats", "backing_Flt", "backing_Fdr", "backing_vdr", "backing_mformat", "backing_fformat", "backing_vformat", "backing_vmt", "backing_figpid", "backing_fdr", "backing_mdr", "backing_mmt", "backing_Fformat", "backing_mlt", "backing_fats", "backing_vlt", "backing_vpid", "backing_figmt"]}}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 3330, "substitutes": {"pix": [" pIX", "npixels", "pax", " pik", "Pixels", "paIX", "Px", " pw", "PIX", "pw", "npIX", "cpIX", "Pik", "cpix", "Pix", " pixels", "pIX", "cpw", "pixels", "paik", "cpixels", "cpx", "px", "npix", "pik", " px", "paix", "npx", "Pw"], "stride": ["swider", "sprke", "stine", "swension", "sprride", " strke", "strension", "stider", "strke", "swride", "divride", "trine", "sprension", " strue", "strride", " strride", " strider", "divke", "stide", "tride", "strine", "divension", "true", "strider", "strue", "divide", "stue", "trride", " strension", " strine", "swide", "stension", "spride"], "bS": ["subUS", "baseRS", "brS", "bbSeries", "bbC", "bSU", "subArray", " bWS", "bFS", "subN", " bSU", "bWS", "bbN", " bN", "nbScreen", "brFS", "bScreen", "nbEMS", "baS", "bRS", "bC", "brSU", "brWS", " bSeries", " bAS", "bAS", "bbP", "baAS", "bbS", "bgUS", " bScreen", "bEMS", "wbS", "bbSU", "bbAS", "baWS", "bbFS", "wbSeries", "brAS", "bbEMS", "baseS", "bN", "baseEMS", " bArray", " bEMS", " bP", "bgS", "subS", "bArray", "bgRS", "bP", " bC", "bSeries", "brC", "subFS", " bRS", "subRS", "nbRS", " bFS", "bUS", " bUS", "bgArray", "subEMS", "baseScreen", "baFS", "nbS", "wbP"], "qp": ["qqP", "qqd", "dqd", "dqp", "qum", "qup", "Qpad", "qqpad", "iqnp", "QP", "qpad", "qm", "iqpc", "qqm", "qupc", "qqp", "qunp", "qP", "dqm", "qnp", "qpc", "Qp", "qud", "iqp", "qqpc", "qd", " qP", " qpad", "iqm", "qqnp"], "h": ["k", "ph", "ht", "hi", "hash", "php", "dh", "eh", "hm", "comm", "b", "c", "ih", "hl", "th", "w", "hh", "hp", "he", "rh", "p", "hd", "bh", "cache", "l", "v", "header", "sh", "H", "e", "g", "hal", "ctx", "handle", "history", "o", "host", "kh", "t", "oh", "hz", "sw", "hw", "f", "hs", "ch", "m", "j", "ah"], "tc": ["cca", "rc", "toc", "tt", "mc", "cot", "temp", "c", "ca", "lc", "td", "currency", "tu", "tic", "cu", "gc", " TC", "cache", "ts", "cc", "ec", "timeout", "tv", "pc", "cf", "bc", "dc", "cm", "fc", "ic", "sc", "FC", "ctx", "ac", "cci", "ta", "acc", "tif", "times", "beta", "tim", "ci", "t", "unc", "uc", "cv", "tf", "asc", "TC", "cus", "multi", "tmp", "cs", "ctr", "icc", "cas", "ctrl", "css"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,\n\n                          const char *boot_device,\n\n                          DisplayState *ds, const char *kernel_filename,\n\n                          const char *kernel_cmdline,\n\n                          const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    unsigned int i;\n\n    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;\n\n    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,\n\n        *espdma_irq, *ledma_irq;\n\n    qemu_irq *esp_reset, *le_reset;\n\n    ram_addr_t ram_offset, prom_offset, tcx_offset;\n\n    unsigned long kernel_size;\n\n    int ret;\n\n    char buf[1024];\n\n    int drive_index;\n\n    void *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        cpu_sparc_set_id(env, i);\n\n        envs[i] = env;\n\n        if (i == 0) {\n\n            qemu_register_reset(main_cpu_reset, env);\n\n        } else {\n\n            qemu_register_reset(secondary_cpu_reset, env);\n\n            env->halted = 1;\n\n        }\n\n        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n\n        env->prom_addr = hwdef->slavio_base;\n\n    }\n\n\n\n    for (i = smp_cpus; i < MAX_CPUS; i++)\n\n        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > hwdef->max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    /* load boot prom */\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->slavio_base,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX)\n\n        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                buf);\n\n        exit(1);\n\n    }\n\n\n\n    /* set up devices */\n\n    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);\n\n\n\n    for (i = 0; i < MAX_IOUNITS; i++)\n\n        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)\n\n            iounits[i] = iommu_init(hwdef->iounit_bases[i],\n\n                                    hwdef->iounit_version,\n\n                                    sbi_irq[hwdef->me_irq]);\n\n\n\n    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],\n\n                              iounits[0], &espdma_irq, &esp_reset);\n\n\n\n    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],\n\n                             iounits[0], &ledma_irq, &le_reset);\n\n\n\n    if (graphic_depth != 8 && graphic_depth != 24) {\n\n        fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth);\n\n        exit (1);\n\n    }\n\n    tcx_offset = qemu_ram_alloc(hwdef->vram_size);\n\n    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,\n\n             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n\n\n\n    if (nd_table[0].model == NULL)\n\n        nd_table[0].model = \"lance\";\n\n    if (strcmp(nd_table[0].model, \"lance\") == 0) {\n\n        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n\n    } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n        fprintf(stderr, \"qemu: Supported NICs: lance\\n\");\n\n        exit (1);\n\n    } else {\n\n        fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n        exit (1);\n\n    }\n\n\n\n    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,\n\n                        hwdef->nvram_size, 8);\n\n\n\n    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],\n\n                          sbi_cpu_irq, smp_cpus);\n\n\n\n    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],\n\n                              nographic, ESCC_CLOCK, 1);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],\n\n              serial_hds[0], ESCC_CLOCK, 1);\n\n\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    main_esp = esp_init(hwdef->esp_base, 2,\n\n                        espdma_memory_read, espdma_memory_write,\n\n                        espdma, *espdma_irq, esp_reset);\n\n\n\n    for (i = 0; i < ESP_MAX_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_SCSI, 0, i);\n\n        if (drive_index == -1)\n\n            continue;\n\n        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);\n\n    }\n\n\n\n    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,\n\n                                    RAM_size);\n\n\n\n    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,\n\n               boot_device, RAM_size, kernel_size, graphic_width,\n\n               graphic_height, graphic_depth, hwdef->nvram_machine_id,\n\n               \"Sun4d\");\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n}\n", "idx": 3333, "substitutes": {"hwdef": ["fwDef", "swDef", "iwmd", "cmddef", "iwdev", "hawdefinition", "cmddel", "hddef", "htdefinition", "iwname", "hhDef", "fwref", "fwdef", "fwdel", "htref", "hwdefinition", "hhdef", "hawDef", "fwmd", "iwdef", "fwds", "swdef", "hwname", "cmdDef", "hwmd", "hwref", "iwref", "iwDef", "hdDef", "hwdev", "hwconf", "hawds", "hdname", "htdef", "htmd", "hwds", "hwDef", "cmdconf", "hawdef", "hwdel", "htDef", "htds", "hhconf", "swdev", "fwdefinition", "fwconf", "hhdel", "hddev", "swname"], "RAM_size": ["RAM_Size", "RAMThesend", "RAM_SIZE", "RAMLESIZE", "RAM_ize", "RAMTheSize", "RAMLEize", "Ram_size", "Ram_Size", " RAM_len", "RAMLElen", "RAMThesize", "RAM_len", "RAM_send", " RAM_ize", " RAM_SIZE", "RAMLEsize", "Ram_send"], "boot_device": ["cpu_buffer", "bootmodblock", "boot_buffer", "boot_block", "cpu_block", "bootmoddrive", "cpu_drive", "bootmoddevice", "cpu_device", "bootmodbuffer", "boot_drive"], "ds": ["de", "s", "vd", "dos", "bs", "pd", "dh", "ses", "d", "dl", "Ds", "eds", "sd", "ps", "dd", "ss", "ys", "df", "dt", "sts", "rs", "da", "dm", "du", "DS", "des", "cs", "db"], "kernel_filename": ["system_Filename", "system_filename", "system_file", "kernel_file", "system_fn", "kernel__fn", "kernel__filename", "kernel_Filename", "kernel__file", "kernel__Filename", "kernel_fn"], "kernel_cmdline": ["kernel_commandl", "kernel_workdir", "kernel_ctrline", "kernel_ctrdir", "kernel_cmddir", "kernel_cmdl", "kernel_commandline", "kernel_workline", "kernel_ctrl", "kernel_workl", "kernel_commanddir"], "initrd_filename": ["initrb_filename", "initrb_file", "initrbfilefilename", "initrdfiledll", "initrd_dll", "initrb_sid", "initrd_file", "initrbfilefile", "initrd_sid", "initrdfilefile", "initrdfilefilename", "initrbfilesid", "initrdfilesid", "initrbfiledll", "initrb_dll"], "cpu_model": ["cpuglink", "pu_Model", "cpuetyModel", "cpu_Model", "cpu_models", "cp_models", "CPU_Model", "cpuetymodels", "CPU_tree", "cp_model", "cp_policy", "cpuetymodel", "pu_model", "CPU_models", "cpugModel", "pu_link", "cpu_link", "cpu_policy", "cpugdevice", "cp_Model", "CPU_model", "CPU_link", "cpuetytree", "cpu_device", "cpugmodel", "pu_mode", "cpu_tree", "cpu_mode", "CPU_device"], "env": ["erd", "eu", "ve", "era", "shell", "ei", "v", "eng", "en", "conn", "tk", "pe", "er", "door", "txt", "enc", "h", "ptr", "console", "cmd", "gate", "var", "ef", "vr", "di", "pb", "worker", "ped", "environment", "req", "window", "def", "esc", "vs", "viron", "cb", "timer", "qt", "vp", "uv", "desc", "buffer", "eas", "box", "ext", "ew", "et", "cookie", "engine", "nv", "entry", "export", "esp", "equ", "ec", "vv", "inv", "info", "here", "menu", "ctx", "code", "manager", "gear", "usr", "cv", "policy", "proc", "el", "cfg", "vt", "mem", "e", "context", "conf", "end", "server", "ev", "obj", "dev", "sw", "err", "ee", "vm", "js", "event", "va", "ah", "db"], "envs": ["inps", " enVs", "Envas", "entvs", "endVs", "enfs", "Envs", "endfs", "EnVs", "entrs", "renv", "renps", "renves", "enves", " enfs", "Enps", " enves", "renvs", "inv", "envas", "enrs", " enps", " enrs", "endvs", "entfs", "entps", "endvas", "invs", "inves", "enVs", "Enrs", "enps", "Enfs", " envas"], "MAX_CPUS": ["MAX_CHus", "MAX_CPUUS", "MAX_CPUINS", "MAX_CAPus", "MAX__GPINS", "MAX_TPIS", "MAX_CPUIS", "MAX_MPIS", "MAX_CPIS", "MAX__GPIS", "MAX_GPINS", "MAX_CAPINS", "MAX_CPINS", "MAX_PUS", "MAX_CAPPS", "MAX_CPOS", "MAX_CHUS", "MAX_POS", "MAX_CHAS", "MAX_CAPIS", "MAX__CPINS", "MAX_GPus", "MAX_TPUS", "MAX__CPus", "MAX_TPPS", "MAX_CAPUS", "MAX_MPUS", "MAX__CPUS", "MAX_MPus", "MAX_CPAS", "MAX__GPUS", "MAX__CPIS", "MAX_CPus", "MAX_TPus", "MAX_PAS", "MAX_CHOS", "MAX_Pus", "MAX_CPPS", "MAX__GPus", "MAX_GPUS", "MAX_MPPS", "MAX_GPIS", "MAX_CPUAS", "MAX_CPUOS", "MAX_CPUus"], "i": ["n", "oi", "cli", "mi", "ind", " I", "ai", "v", "ei", "ij", "is", "ic", "it", "go", "si", "ie", "y", "id", "ti", "phi", "iu", "bi", "hi", "q", "ui", "batch", "c", "di", "x", "fi", "ini", "zi", "ims", "xi", " ti", "ami", " ii", "print", "index", "multi", "z", "sim", "ri", "j", "I", "im", "ki", "p", " bi", "l", "ip", "info", "name", "ix", "ci", "us", "dr", "gi", "m", "li", " j", "b", "ii", "ji", "\u0438", "parent", "e", "pi", "in", "g", "me", "qi", "gu", "t", "o"], "iounits": ["iumnITS", "numnit", "iowities", "iounit", "iowITS", "iunities", "nounit", "nounits", "numnits", "iunits", "iounities", "numnITS", "iumnities", "nounities", "nounITS", "numnities", "iunit", "iunITS", "iounITS", "iumnits", "iumnit", "iowit", "iowits"], "MAX_IOUNITS": ["MAX_ICounITIES", "MAX_ICounIT", "MAX_IOUNIT", "MAX_IounITIES", "MAX_IUNITIES", "MAX_ICUNITIES", "MAX_IounITS", "MAX_IUNIT", "MAX_ICounITS", "MAX_IounIT", "MAX_Iounits", "MAX_ICounits", "MAX_ICUNits", "MAX_ICUNITS", "MAX_ICUNIT", "MAX_IUNits", "MAX_IUNITS", "MAX_IOUNITIES", "MAX_IOUNits"], "espdma": [" espdMA", "espdlma", " espnca", "espnca", "espdhMA", "espdhma", " espnMA", "espdlmas", "espnmas", "espdhmas", "espdca", " espnma", "espdhca", "espdlMA", " espdca", " espnmas", "espdMA", "espnMA", "espdlca", "espnma", " espdmas", "espdmas"], "ledma": ["ledda", "oledda", "oledmas", "iledma", "ledmas", "aledma", "iledmas", "aledmas", "aledda", "oledama", "iledama", "ledama", "iledda", "oledma", "aledama"], "main_esp": ["main_exe", "primary_cp", "primary_exe", "primary_ema", "main_cp", "primary_esp", "main_ema"], "nvram": ["nvRAM", "NVgram", "nvrom", "nbram", "NVRAM", "NVrom", "nbgram", "nbrom", "ndgram", "nbRAM", "ndram", "ndrom", "ndRAM", "nvgram", "NVram"], "sbi": [" sci", "psli", "psbi", "esli", " sgi", "psci", "sci", "psgi", "sgi", "sli", "esbi", "esci", "esgi", " sli"], "cpu_irqs": ["cpu_irques", "cpu_irips", "cpu_iriqs", "cpu_arq", "cpu_rinq", "cpu_rirq", "cpu_irtqs", "cpu_pirqs", "cpu_____rirqs", "cpu_____irques", "cpu_rirls", "cpu_____irrics", "cpu_arqs", "cpu_iriques", "cpu_pirques", "cpu_____rirrics", "cpu_pirrics", "cpu_irtq", "cpu_arrics", "cpu_rirrics", "cpu_____rirques", "cpu_____rirq", "cpu_rinques", "cpu_pirls", "cpu_rirques", "cpu_rinps", "cpu_arques", "cpu_pirq", "cpu_rinqs", "cpu_pirps", "cpu_irps", "cpu_____irqs", "cpu_____irq", "cpu_irls", "cpu_irtls", "cpu_irrics", "cpu_iriq", "cpu_rirqs", "cpu_irq"], "sbi_irq": ["sbi_ireq", "sbi_mirq", "sbi_irv", "sbi_irQ", "sbi_pirq", "sbi_mirQ", "sbi_pirqs", "sbi_irev", "sbi_pirv", "sbi_ireqs", "sbi_pirQ", "sbi_mirqs", "sbi_irqs", "sbi_ireQ", "sbi_mirv"], "sbi_cpu_irq": ["sbi_cpu_rque", "sbi_cpu_virq", "sbi_cpu_virqs", "sbi_cpu_rQ", "sbi_cpu_irQ", "sbi_cpu_virque", "sbi_cpu_pirQ", "sbi_cpu_pirque", "sbi_cpu_virQ", "sbi_cpu_pirqs", "sbi_cpu_irque", "sbi_cpu_irqs", "sbi_cpu_pirq", "sbi_cpu_rqs", "sbi_cpu_rq"], "espdma_irq": ["espdma_arqs", "espdma_rirqs", "espdma_pirqs", "espdma_irqs", "espdma_arqu", "espdma_rirqu", "espdma_arresh", "espdma_rirq", "espdma_irresh", "espdma_rirresh", "espdma_pirresh", "espdma_pirqu", "espdma_pirq", "espdma_arq", "espdma_irqu"], "ledma_irq": ["ledma_irquire", "ledma_irsq", "ledma_IRquire", "ledma_IRql", "ledma_rqs", "ledma_IRq", "ledma_irsquire", "ledma_irsql", "ledma_irsqs", "ledma_irql", "ledma_IRqs", "ledma_rquire", "ledma_rq", "ledma_irqs", "ledma_rql"], "esp_reset": [" esp_set", "esp___eval", "esp___set", " esp_eval", "esp___template", " esp_template", "esp_template", "esp_eval", "esp_set", "esp___reset"], "le_reset": ["lu_mem", "lu_reset", "le_mem", "lu_offset", "lu_init", "le_offset", "le_init"], "ram_offset": ["ram_location", "ram_address", "ram2address", "RAM_address", "RAM_index", "ram2location", "ram2index", "ram2offset", "RAM_offset", "RAM_location", "ram_index"], "prom_offset": ["prom_pos", "Prom_address", "Prom_addr", "prom_addr", "Prom_pos", "Prom_offset", "prom_address"], "tcx_offset": ["tcx_index", "tcx2Offset", "tcx2index", "tcX_error", "tcx2offset", "tcX_index", "tcX_offset", "tcX_Offset", "tcx_error", "tcx_Offset", "tcx2error"], "kernel_size": ["cpu_count", "kernel2offset", "kernel_offset", "cpu_offset", "kernel2size", "cpu_size", "kernel_SIZE", "cpu_SIZE", "kernel2count", "kernel2SIZE", "kernel_count"], "ret": ["ib", "flag", "RI", "rets", "re", "status", "alt", "mem", "io", "def", "ter", "rt", "reset", "ry", "set", "si", "rin", "Ret", "RET", "res", "val", "ref", "ri", "j", "result", "rem"], "buf": ["proc", "count", "str", "cap", "var", "batch", "uf", "b", "func", "array", "block", "map", "family", "cache", "img", "code", "cb", " buffer", "ref", "cv", "Buffer", "cast", "ptr", "desc", "buffer", "buff", "off", "vec"], "drive_index": ["drive_handle", "drive_offset", "drive_id", "drive2index", "drive2handle", "disk_handle", "drive2id", "disk_offset", "disk_id", "drive2offset", "disk_index"], "fw_cfg": ["fw__config", "fw__cfg", "fw__log", "fw__fg", "FW_cfg", "fw2cfg", "fw2config", "FW_fg", "fw2fg", "fw_fg", "fw2log", "fw_config", "FW_config", "FW_log", "fw_log"]}}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)\n\n{\n\n    int num_cq_events = 0, ret = 0;\n\n    struct ibv_cq *cq;\n\n    void *cq_ctx;\n\n    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;\n\n\n\n    if (ibv_req_notify_cq(rdma->cq, 0)) {\n\n        return -1;\n\n    }\n\n    /* poll cq first */\n\n    while (wr_id != wrid_requested) {\n\n        ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n        if (wr_id != wrid_requested) {\n\n            DDDPRINTF(\"A Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                print_wrid(wrid_requested),\n\n                wrid_requested, print_wrid(wr_id), wr_id);\n\n        }\n\n    }\n\n\n\n    if (wr_id == wrid_requested) {\n\n        return 0;\n\n    }\n\n\n\n    while (1) {\n\n        /*\n\n         * Coroutine doesn't start until process_incoming_migration()\n\n         * so don't yield unless we know we're running inside of a coroutine.\n\n         */\n\n        if (rdma->migration_started_on_destination) {\n\n            yield_until_fd_readable(rdma->comp_channel->fd);\n\n        }\n\n\n\n        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {\n\n            perror(\"ibv_get_cq_event\");\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        num_cq_events++;\n\n\n\n        if (ibv_req_notify_cq(cq, 0)) {\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        while (wr_id != wrid_requested) {\n\n            ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n            if (ret < 0) {\n\n                goto err_block_for_wrid;\n\n            }\n\n\n\n            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n            if (wr_id == RDMA_WRID_NONE) {\n\n                break;\n\n            }\n\n            if (wr_id != wrid_requested) {\n\n                DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                    print_wrid(wrid_requested), wrid_requested,\n\n                    print_wrid(wr_id), wr_id);\n\n            }\n\n        }\n\n\n\n        if (wr_id == wrid_requested) {\n\n            goto success_block_for_wrid;\n\n        }\n\n    }\n\n\n\nsuccess_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return 0;\n\n\n\nerr_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3348, "substitutes": {"rdma": ["drma", "ldme", "drvm", "drta", "rdme", "rhda", "rhma", "rodMA", "redmo", "irdmad", "ldma", "rdvm", "irdna", "ordmar", "rhMA", "rodza", "rdka", "rodbase", "drbase", "drca", "rrma", "drman", "rodvm", "ordma", "redme", "redmar", "redvm", "drmad", "redman", "drmu", "irdma", "rrta", "rdman", "rdmar", "rodmu", "redta", "redma", "drka", "redza", "redda", "drMA", "rrmo", "rdca", "ldmar", "rrman", "rdMA", "rodmo", "rdmo", "ordmeta", "rdmeta", "rodca", "redMA", "rdmu", "rdmad", "ordme", "redmu", "rodman", "rwman", "rodta", "redmeta", "rdta", "irdka", "rwbase", "rwMA", "rrmad", "rrna", "redca", "rodma", "rdda", "drna", "drda", "rhmo", "rrka", "ldmeta", "rwma", "rdza", "drza", "rodda", "rdbase", "rdna"], "wrid_requested": ["wrid_threadured", "wrid_requestired", "wrid_requestable", "wrid_counted", "wrid_projectared", "wrid_requestation", "wrid_requestued", "wrid_Requesteded", "wrid_questared", "wrid_requestedIn", "wridpyrequested", "wrid_reqeded", "wrid4requestued", "wridpydownired", "wrid4requested", "wrid_requestped", "wrid4requestal", "wrid_requestred", "wrid_reqe", "wrid_processed", "wrid_accessed", "wrid_downumed", "wrid_counteded", "wrid_requesteded", "wrid_projecter", "wrid_reqed", "wrid_conditionor", "wrid_accessized", "wrid_threadable", "wrid_threadized", "wrid_Requesting", "wrid_accepte", "wrid_requestized", "wrid_threaded", "wrid_requestor", "wrid_processized", "wrid_returning", "wrid_accessable", "wrid_accessured", "wrid_accepting", "wridpydowned", "wrid_masked", "wrid_requestumed", "wrid4returned", "wrid_maskor", "wrid_goired", "wrid_weightared", "wrid_maskued", "wrid_goped", "wrid_maskal", "wrid_quester", "wrid_requester", "wridpyrequestumed", "wrid_downed", "wrid_conditioned", "wrid_beginumed", "wrid_returned", "wrid4returnor", "wrid_requestal", "wrid_returne", "wrid_goumed", "wrid_returnor", "wrid_counting", "wrid_begined", "wrid_requestared", "wrid_conditional", "wrid_requesting", "wridpydownumed", "wrid_weighted", "wrid_quested", "wrid_questedIn", "wrid_accepted", "wrid_processured", "wrid_reqing", "wridpyrequestired", "wrid_returnred", "wrid_downped", "wrid_projectedIn", "wridpyrequestped", "wrid_beginped", "wrid_downired", "wrid_requestured", "wrid_weighter", "wrid_reqation", "wrid4returnued", "wrid_goed", "wrid_returnued", "wrid4returnal", "wrid_conditionued", "wrid_counte", "wrid_Requested", "wrid_processable", "wrid4requestor", "wridpydownped", "wrid_returnal", "wrid_reqred", "wrid_weightedIn", "wrid_acceptation", "wrid_projected", "wrid_requeste", "wrid_Requeste", "wrid_Requestred", "wrid_beginired", "wrid_Requestation"], "cq": ["rcQ", "acql", "pcqu", "cachequ", " cux", "cqq", "cmp", " cqq", "dcQ", "cck", " cqu", "pcQ", "ccck", "pcq", "rcue", "xcq", "pcue", "uncq", "dcq", "cux", "cacheQ", "cue", "dcqu", " cQ", "cql", "acck", "xcql", "ccql", "cqu", "cQ", " cue", "cacheq", "acmp", "xcmp", "xcck", "uncue", "ccmp", "uncQ", "pcqq", "rcq", "pcux", "uncqu", "dcue", "rcqq", "cacheux", "acq", "ccq", "rcqu"], "cq_ctx": ["cqq_tx", "cqq_context", "cue_ctx", "cue_tx", "cq_context", "cue_addr", "cq_addr", "cqq_ctx", "cqq_cb", "cq_cb", "cq_tx", "cue_context"], "wr_id_in": ["wr_name__out", "wr_name_ins", "wr_id_inner", "wr_id___on", "wr_name__in", "wr_sid___In", "wr_name_in", "wr_id___ins", "wr_sid___input", "wr_sid_in", "wr_name__inner", "wr_id__inner", "wr_id_In", "wr_id_0", "wr_id__0", "wr_id__in", "wr_name__raw", "wr_sid_In", "wr_id___input", "wr_id___0", "wr_id_IN", "wr_sid_input", "wr_id_input", "wr_id_on", "wr_id_raw", "wr_id_out", "wr_sid___in", "wr_id__on", "wr_id___In", "wr_id__raw", "wr_id_ins", "wr_name_out", "wr_id__ins", "wr_name_IN", "wr_name_inner", "wr_id___in", "wr_id_local", "wr_id__out", "wr_name_raw"], "num_cq_events": ["num_cq_obs", "num_cqxerrors", "num_cqs_reads", "num_cqxevents", "num_cq_reads", "num_cq_event", "num_cqs_obs", "num_cqxobs", "num_cqxevent", "num_cqs_errors", "num_cqs_event", "num_cq_errors", "num_cqs_events"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t *)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    __asm__ volatile(\"pxor    %%mm7,%%mm7    \\n\\t\":::\"memory\");\n\n    __asm__ volatile(\"pcmpeqd %%mm6,%%mm6    \\n\\t\":::\"memory\");\n\n    mm_end = end - 3;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            PACK_RGB32\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r)\n\n            :\"memory\");\n\n        d += 16;\n\n        s += 4;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n        *d++ = 255;\n\n    }\n\n}\n", "idx": 3375, "substitutes": {"src": ["inst", "input", "bs", "rc", "b", "cur", "start", "sn", "dest", "r", "rl", "img", "out", "sh", "st", "ur", "x", "in", "ss", "obs", "rt", "sc", "source", "sv", "trans", "sr", "loc", "sur", "rs", "cont", "sb", "ins", "usr", "ptr", "tmp", "ctr", "sub"], "dst": ["rdest", "lsrc", " dST", " dsrc", "dST", "mcr", "Dest", "mest", "ddest", "dest", "DST", "dcr", "Dst", "rbl", "Dcr", "ldest", " dbl", "rst", "dsrc", "dbl", "lbl", " dcr", "mst", "lst", " ddest", "rsrc", " dest", "mST"], "src_size": ["rx_size", " src_num", "rx_Size", " src_Size", "rx_cache", "src_cache", "src_Size", "rx_SIZE", "src_SIZE", "src_num"], "end": ["ad", "END", "final", "ff", "length", "b", "End", "nd", "start", "w", "dest", "r", "rest", "p", "max", "ended", "wall", "est", "south", "send", "v", "out", "st", "offset", "e", "se", "en", "ending", "all", "set", "stop", "last", "t", "size", "h", "ent", "z", "f", "id", "m"], "mm_end": ["MM_offset", "mm_End", "mm_bound", "mm_ends", "mmm_end", " mm_size", "mm2END", "mm00size", "mm_size", "mm2end", "mmm_END", " mm_END", "mm2End", "mm00end", "mm00ends", "mmm_bound", "mm_offset", "mm2bound", " mm_ends", "mm_start", "mm_END", "mm00END", "MM_end", "mmm_End", "MM_start"], "d": ["de", "n", "dos", "dn", "pd", "dh", "diff", "dL", "b", "c", "di", "did", "new", "dist", "status", "ct", "w", "dp", "r", "p", " D", "sd", "i", "l", "out", "v", "send", "st", "x", "e", "u", "dis", "dd", "dc", "message", "g", "D", "draw", "o", "ds", "dt", "amd", "ld", "dat", "t", "fd", "da", "done", "bd", "h", "y", "debug", "dr", "z", "des", "f", "dra", "du", "dump", "id", "m", "j", "data", "dx", "db"], "s": ["n", "spec", "stats", "bs", "es", "b", "c", "ls", "start", "w", "r", "p", "ts", "its", "ps", "i", "l", "south", "gs", "v", "is", "st", "sys", "e", "u", "ss", "g", "se", "ms", "ims", "source", "sv", "os", "ies", "ds", "a", "ows", "si", "sts", "t", "rs", "sm", "ns", "sb", "S", "size", "ins", "rows", "h", "sl", "cs", "sp", "hs", "js", "m", "j"], "bgr": ["bbgd", "bbr", "rbbr", "BGR", "musr", "mbr", " btr", "hvr", "hbr", "bbtr", "rbgr", "bbGr", "bbGR", "bgd", " bGr", "bbbr", "blbr", "mtr", "mgd", "mgr", "mGR", "mGr", "Bdr", "Bbr", "bdr", "bvr", " bdr", "busr", " bgd", "blusr", " bGR", "hGr", "mvr", "rbdr", "btr", "bGR", "bGr", "rbGR", "blGr", "hgr", " bvr", "blgr", "bbgr", " busr", " bbr", "Bgr"]}}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n", "idx": 3392, "substitutes": {"opaque": ["obque", "opque", " oplay", "open", "opatile", "iopacity", "opute", "Opute", "opacity", "pen", "paque", "opsaque", "operacity", "Opatile", "ipque", "iopque", " opque", "opvious", "iopen", "pque", "ipacity", "opsatile", "obaque", "oblay", "OPute", "pacity", "operque", "OPvious", " opacity", "opsute", "iplay", "Opaque", "operen", "opsvious", "oplay", "ipaque", "operaque", "OPatile", "Opvious", "obacity", "iopaque", "OPaque"], "chr": ["gerrh", "cherer", "chnro", "gerr", "chrb", "chnru", "tchusr", "chrator", "cherro", "cherru", "echr", " chrb", "chusr", "chnar", "chorg", "chor", "charlr", "chR", "echrb", "chorh", "echrator", "cherh", "chrc", "tchtx", "cher", "cherc", "tchru", "cherr", "chertx", " chR", "cheR", "chrg", "tchar", "chntx", "chelr", "chorator", "chtx", "chnr", "tchro", "chnusr", "charr", "echrc", "echar", "gerrg", "cherator", "charR", "chnrator", "chro", "gerrator", "cherg", "chru", "tchrator", " chlr", "charrer", "chrh", "echusr", "chlr", "tchr", "chrer", " chrer", " chrc", "cherb", "echrer"], "d": ["de", "ad", "n", "dn", "pd", "dh", "md", "gd", "b", "c", "di", "did", "new", "nd", "m", "dl", "dp", "r", "p", "hd", "sd", "dj", "i", "l", "ind", "v", "e", "dc", "dis", "dd", "D", "g", "driver", "ord", "or", "ds", "dt", "a", "ld", "dat", "der", "dir", "t", "da", "dm", "fd", "debug", "bd", "h", "dev", "dr", "du", "z", "f", "o", "j", "db"]}}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n", "idx": 3394, "substitutes": {"s": ["qs", "self", "ses", "es", "b", "c", "ls", "states", "d", "w", "ains", "p", "ts", "its", "ps", "gs", "is", "ss", "ms", "os", "fs", "ds", "a", "sts", "ats", "rs", "ns", "t", "sb", "S", "h", "hs", "js", "aws", "has"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,\n\n                                     const uint8_t *src_in[4],\n\n                                     int srcW, int xInc, const int16_t *hChrFilter,\n\n                                     const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                     uint8_t *formatConvBuffer, uint32_t *pal)\n\n{\n\n    const uint8_t *src1 = src_in[1], *src2 = src_in[2];\n\n    if (c->chrToYV12) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    } else if (c->readChrPlanar) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst1, dst2, dstWidth);\n\n}\n", "idx": 3397, "substitutes": {"c": ["cr", "rc", "mc", "cmp", "can", "ct", "b", "lc", "ca", "com", "cur", "d", "cu", "w", "comp", "cache", "p", "gc", "anc", "cc", "cp", "ec", "pc", "cf", "cal", "v", "bc", "dc", "co", "cm", "cn", "container", "fc", "conf", "ic", "g", "sc", "nc", "cam", "ctx", "ac", "coll", "set", "cb", "C", "ce", "t", "ci", "cont", "abc", "enc", "call", "cv", "h", "tc", "cl", "etc", "unc", "uc", "f", "cs", "vc", "ch", "chain", "cd", "con"], "dst1": ["Dst1", "destOne", " dct0", "Dest1", "dct0", " dst01", " dct2", "dnd2", "dsty2", "dct2", "ddest1", "dest0", "dst01", "dv01", "ddest2", "dst0", "dnd0", "dstOne", "destIn", "Dst0", "Dest2", "dstIn", " dest1", "dsrc2", " dct01", "dsty4", "dest4", "ddestOne", "dstsA", " dest2", "dsty1", " dstOne", "dv0", "dv2", "Dst4", "Dest0", "dnd1", "dct01", "dest2", "dest1", "DstA", "dv1", "destA", "DestA", "dst4", "Dest4", "dstA", "dsts2", "ddestIn", "dstyA", " dct1", " destIn", " destOne", "dest01", "dct1", "Dst2", "dsrcIn", "dsts4", " dstIn", " dst0", "dsrcOne", "dsrc1", "dsts1"], "dst2": ["DstWidth", "dct2", "dset6", " dist4", "destTwo", "dstTwo", "dustTwo", "dest102", "Dst102", "dist1", "dct4", "duset2", "Dst02", "dset2", "dust4", "Dst2", "dST2", "Dest1", "dstB", "dostTwo", "dsetTwo", "duset4", "destB", "Dest2", "dest4", "duset6", "dstdTwo", "dstr02", "dest2", "dist4", "dSTTwo", " distWidth", "dusetTwo", "dSTWidth", "dstr1", "dst102", "DestTwo", "Dst1", "dSt1", "distWidth", "dstdWidth", "DstTwo", "Dest02", "dset4", "dSt02", "dest02", "destWidth", "dst4", "dost2", "dctTwo", "Dest102", "DestWidth", "dost4", "dust6", "dstd102", "DstB", "dstr2", "dstd2", " dst4", "dStB", " dist2", "DestB", "dst6", "dst02", "dct6", "dSt2", " dist1", "dstrB", "dest1", "dost1", "dist2", "dST102", "dust2", "dost6", "dostWidth"], "dstWidth": ["DstWidth", "dstH", "DstExp", "DsrcArea", "dsrcwidth", " drtwidth", "DstHeight", "dtdW", "dsrcArea", "dSTW", "dsnWidth", "dstwidth", "drcHeight", "destExp", " destWidth", "sdstWidth", "dsrcH", "sdspW", " destMin", "dstArea", "dstExp", "dSTMin", "dstCut", "dstHeight", "dST2", "dtdExp", "DestExp", " dstMin", "DestHeight", " dstH", "dstsWidth", " dstHeight", "dstsHeight", "dstMin", "dspHeight", "dsrcHeight", "drtwidth", " dest2", "dostPort", "dostHeight", "drtHeight", "destMin", "dest2", "drtH", "dtdMin", "dSTWidth", "dstsArea", " drtH", "destW", "destPort", "dspwidth", "DsrcWidth", "drcW", "dsrcWidth", "DstArea", "drcwidth", "dsnArea", " dstwidth", "DstPort", "sdspwidth", " destW", "DsrcCut", "dstW", "dstsCut", "destWidth", "dsrcCut", "dostExp", "DestWidth", " drtWidth", "drtWidth", "dtdWidth", "dsrcW", "dtdHeight", "DestPort", "dsnHeight", "sdstHeight", "sdspHeight", "dostH", "dsnCut", "dstPort", "dspW", "DsrcHeight", "dostwidth", "dtdPort", "destHeight", "DstCut", "drcWidth", "dtd2", "dspWidth", " dstW", "sdstW", " drtHeight", "sdspWidth", "dostWidth", "sdstwidth"], "src_in": ["src2ins", "src1i", "src2inner", "rc2ind", " src_out", "rc2out", "src_ini", "scan_In", "src_i", "src__inner", "scan_in", "scan_ini", "src2ini", "inst_out", "src2i", "src2out", "src2im", "scan_out", "src__out", "src__im", "inst__out", "src1in", "src1out", "src_inner", "rc_i", "src2IN", "rc2in", "inst_im", "inst__in", "src1ind", "src2ind", "src_im", "src_ins", "src_In", "src_IN", "rc_in", "inst_in", "src_ind", " src_ins", "src_out", "inst__im", "rc2i", "inst_inner", "rc_ind", "src2in", "inst__inner", " src_IN", "src2In", "rc_out", "src__in"], "srcW": ["srcNW", "instW", "snWC", "destW", "instw", "srcWT", "ptrNW", "snR", "instWT", " srcP", "srcV", "destH", "sourceW", "rcP", "rcV", " srcV", "snV", "rcw", "rc2", "sourceWidth", "ptrH", "destNW", "source2", "usrH", "ptrW", "srcH", "srcHTML", "srcw", "sortWT", "snW", "rcWC", " srcWC", " srcR", "usrNW", "srcWC", "usrW", "instWh", "sourcew", "sortw", "rcN", "sourceN", "sortW", " srcw", "srcN", "srcWidth", "srcWh", "rcW", " srcWidth", "sortWh", "rcWidth", " srcN", "sourceP", "srcR", "sourceV", "source1", "sourceWT", "rc1", "usrHTML", "srcP", "sourceWh", "destHTML", "ptrHTML", "rcR"], "xInc": ["XINC", "xINC", "xtIncre", "xxIncre", "xtIr", "XIns", "xEnc", " xEnc", "yxIncre", "xxInc", "xxINC", "yxEnc", "xtInc", "yxIr", "xxIns", "xIns", "xtEnc", "xIncre", "xIr", "yxInc", " xIns", " xIncre", "XIncre", "XInc", " xINC", " xIr"], "hChrFilter": ["hStrApply", "hChlerPlugin", "hChrfilter", "hChlrfilter", "hChcApply", "hHrPlugin", "hCordrfilter", "hHRPlugin", "hChdControl", "hChdrFilter", "hChlPlugin", "hChcControl", "hChlTransform", "hHRQuery", "hCorrFilter", "hStdControl", "hChdApply", "hChlFilter", "hChrPlugin", "hChlControl", "hChlrFocus", "hStdApply", "hChrApply", "hChlQuery", "hChrbfilter", "hChrFocus", "hChdTransform", "hCordrTransform", "hStrControl", "hChlrFilter", "hChrbFocus", "hHrQuery", "hChlerQuery", "hChlerTransform", "hChlerFilter", "hChRQuery", "hChrQuery", "hChdFilter", "hChcFilter", "hChdrTransform", "hChlApply", "hHrTransform", "hChrControl", "hChRTransform", "hCordrFilter", "hHrFilter", "hStrTransform", "hStdFilter", "hChRFilter", "hChrbTransform", "hCordrFocus", "hChdrfilter", "hHRTransform", "hChRPlugin", "hChdrFocus", "hStrFilter", "hStdTransform", "hCorrfilter", "hChrbFilter", "hCorrTransform", "hChlrTransform", "hChrTransform", "hChcTransform", "hCorrFocus", "hHRFilter"], "hChrFilterPos": ["hChrtFilterPos", "hChrRefOrigin", "hChrtRuleVal", "hChrHandlerSize", "hChrtRuleLoc", "hChrbHeaderPos", "hChrFilterOffset", "hChrListenerOpen", "hChrFormatOpen", "hChrRulePos", "hChrListenerOffset", "hChrFilterDir", "hChrTransformPos", "hCherrFilterOpen", "hCherrFormatOffset", "hChrHeaderSize", "hChrTestVal", "hChrListenerCos", "hChrFieldPos", "hChrFormatPos", "hChrFieldCos", "hChrRuleOrigin", "hChrFilterVal", "hChrTestLoc", "hChrFieldOffset", "hChrbFilterPos", "hChrFilterOrigin", "hChrFormatCos", "hChrHandlerLoc", "hChrRefPos", "hChrFilterCos", "hCherrFilterOffset", "hChrbFilterLoc", "hChrHeaderLoc", "hChrRefLoc", "hCherrFormatCos", "hCherrFormatOpen", "hChrListenerPos", "hChrRuleVal", "hChrHeaderPos", "hChrRefVal", "hCherrFilterCos", "hChrFormatOffset", "hCherrFilterPos", "hChrbHeaderDir", "hChrtRulePos", "hChrbFilterDir", "hChrbHeaderSize", "hChrHeaderDir", "hChrTransformLoc", "hChrbHeaderLoc", "hChrTestPos", "hCherrFormatPos", "hChrFilterLoc", "hChrHandlerPos", "hChrTestOrigin", "hChrbFilterSize", "hChrtFilterLoc", "hChrTransformDir", "hChrFilterOpen", "hChrtFilterOrigin", "hChrtRuleOrigin", "hChrHandlerDir", "hChrTransformSize", "hChrtFilterVal", "hChrRuleLoc", "hChrFieldOpen"], "hChrFilterSize": ["hChrerFilterSize", "hChrerFilterZone", "hChrerFormatSIZE", "hChlTransformSize", "hChrBlockSize", "hChrPixelSize", "hChvrPixelSize", "hChrerFilterSIZE", "hChrFormatLength", "hChrWindowSize", "hChrOverrideCount", "hChrWindowSIZE", "hChrerFormatSize", "hChlFilterScale", "hChrTransformScale", "hChrTransformLength", "hChrOverrideSize", "hChrWindowWidth", "hChvrFilterWidth", "hChlFilterSize", "hChrOverrideSIZE", "hChrPixelSIZE", "hChrTransformSIZE", "hChrFilterWidth", "hChrFilterZone", "hChrFilterCode", "hChvrFilterSize", "hChrFormatSize", "hChrFormatSIZE", "hChrFormatZone", "hChrerFormatLength", "hChvrPixelSIZE", "hChvrPixelCode", "hChvrFilterSIZE", "hChrFilterScale", "hChlTransformScale", "hChlFilterSIZE", "hChrOverrideScale", "hChlTransformSIZE", "hChrWindowCode", "hChrBlockCount", "hChrTransformZone", "hChlTransformCount", "hChrFilterSIZE", "hChrPixelCode", "hChrFilterLength", "hChvrPixelWidth", "hChrTransformCount", "hChvrFilterCode", "hChrBlockScale", "hChrerFormatZone", "hChrBlockSIZE", "hChrTransformSize", "hChrFilterCount", "hChrerFilterLength", "hChrPixelWidth", "hChlFilterCount"], "formatConvBuffer": ["formatConVMatrix", "formatConvbuffer", "formatConviBuffer", "formatConvtBuff", "formatConcText", "formatconnvBuffer", "formatConnvBuffer", "formatConnviTrack", "formatConnviBuff", "formatEnVTable", "formatEnVBuffer", "formatConfbuffer", "formatConcTable", "formatConVTable", "formatConcBuff", "formatConviBuff", "formatConvCache", "formatConfText", "formatConfTrack", "formatEncText", "formatConfCache", "formatEnvTable", "formatConnvTrack", "formatConconvText", "formatConnvBuff", "formatConviFormat", "formatconvBegin", "formatEnVBuff", "formatConvertBuff", "formatConvertBuffer", "formatConvText", "formatConvertTable", "formatConvTrack", "formatconVBuff", "formatConovFormat", "formatConvcBuffer", "formatConvBuff", "formatEnvBuffer", "formatEnvbuffer", "formatConvMatrix", "formatEnvCache", "formatConovBuffer", "formatConovBuff", "formatConovTrack", "formatConcvBuffer", "formatConjbuffer", "formatConcvMatrix", "formatConviTrack", "formatconVBuffer", "formatconvBuff", "formatConconvBuffer", "formatConfFormat", "formatConVBuff", "formatEnfBuff", "formatEnfCache", "formatConvertbuffer", "formatConvTable", "formatConjBuffer", "formatConjBuff", "formatEncBuffer", "formatEnfbuffer", "formatConfTable", "formatConvcBuff", "formatConnviFormat", "formatConvertCache", "formatEncBuff", "formatConvBegin", "formatConfBegin", "formatEnvBuff", "formatConnviBuffer", "formatConcvBuff", "formatConconvBuff", "formatConnvFormat", "formatConfBuff", "formatEnvText", "formatConVBuffer", "formatConcBuffer", "formatconvMatrix", "formatConcCache", "formatConfMatrix", "formatConvtTable", "formatEnfBuffer", "formatconvBuffer", "formatConvFormat", "formatconnvBuff", "formatConnvBegin", "formatConvtBuffer", "formatConvcBegin", "formatConfBuffer", "formatconnvBegin", "formatconVMatrix", "formatEnfTable"], "pal": ["mal", "Pal", "attr", "el", "skin", "cat", "what", "isal", "flat", "sal", "style", "pen", "bal", "local", "pill", "cal", " palette", "pres", "qq", "theme", "menu", "phil", "alph", "al", "pol", " PAL", "cil", "pl", "font", "val", " Pal", "mat", "qual", "color", "alias", "pac", "sav", "scale", "ass", "bat", "pid"], "src1": ["coll0", "src001", "srcOne", "rc3", " srcOne", " src01", "rcName", "srcName", "rc2", "sourceOne", "rc001", "rc11", "source2", "coll001", "inst1", "rc01", "rcOne", "inst2", " src3", " src11", "src11", "source0", "rcN", "sourceN", "srcN", " src001", "coll1", " src0", "src0", "src01", "inst11", " srcN", "source3", " srcName", "source1", "rc1", "rc0", "sourceName", "src3", "coll01"], "src2": ["ser2", "sys1", "src4", "ser02", "rc12", "srcB", "ser12", " src5", " src12", "sys0", "sys2", "usrTwo", "ser1", "instTwo", "sourceTwo", "rc2", "ser4", " src4", "rc02", "source02", "rc5", "source2", "inst1", "sourceB", "inst2", "stTwo", "sys12", "source0", "st2", "usr1", "serB", "src5", "rcTwo", " src0", "rc4", "src0", "st02", "usr2", "src02", "stB", "src12", "inst02", "srcTwo", "source5", "source1", "rc1", "rc0", "serTwo", "usr02"], "buf2": ["buff4", "uf2", "uf3", "buf12", " buf1", "buff8", "uf12", "bufdb", "uf1", "bufto", " bufto", " buf14", "bur256", "msg3", "msg2", "buff12", "uf8", "famdb", " buf3", " buf6", "buf256", "bagto", " buf4", "buf8", "vec12", " bufdb", "fam2", "bag14", "fam1", "buff2", "buf02", "msg02", "fam14", "vec2", "buf4", "buff3", "uf02", "vec8", "bag2", "cb2", "fam6", "vec1", "bur2", "buff1", "bur1", "cb02", "buf3", "buf14", "ufdb", "fam3", "bag6", "buf6", "cb3", "uf4", "buf1", "famto", "uf256", "buff256"]}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n{\n    BlockDriverState *bs = child->bs;\n    /* Perform I/O through a temporary buffer so that users who scribble over\n     * their read buffer while the operation is in progress do not end up\n     * modifying the image file.  This is critical for zero-copy guest I/O\n     * where anything might happen inside guest memory.\n     */\n    void *bounce_buffer;\n    BlockDriver *drv = bs->drv;\n    struct iovec iov;\n    QEMUIOVector local_qiov;\n    int64_t cluster_offset;\n    int64_t cluster_bytes;\n    size_t skip_bytes;\n    int ret;\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n                                    BDRV_REQUEST_MAX_BYTES);\n    unsigned int progress = 0;\n    /* FIXME We cannot require callers to have write permissions when all they\n     * are doing is a read request. If we did things right, write permissions\n     * would be obtained anyway, but internally by the copy-on-read code. As\n     * long as it is implemented here rather than in a separate filter driver,\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n     * it could request permissions. Therefore we have to bypass the permission\n     * system for the moment. */\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n    /* Cover entire cluster so no additional backing file I/O is required when\n     * allocating cluster in the image file.  Note that this value may exceed\n     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which\n     * is one reason we loop rather than doing it all at once.\n     */\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n    skip_bytes = offset - cluster_offset;\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n                                   cluster_offset, cluster_bytes);\n    bounce_buffer = qemu_try_blockalign(bs,\n                                        MIN(MIN(max_transfer, cluster_bytes),\n                                            MAX_BOUNCE_BUFFER));\n    if (bounce_buffer == NULL) {\n        ret = -ENOMEM;\n        goto err;\n    while (cluster_bytes) {\n        int64_t pnum;\n        ret = bdrv_is_allocated(bs, cluster_offset,\n                                MIN(cluster_bytes, max_transfer), &pnum);\n        if (ret < 0) {\n            /* Safe to treat errors in querying allocation as if\n             * unallocated; we'll probably fail again soon on the\n             * read, but at least that will set a decent errno.\n             */\n            pnum = MIN(cluster_bytes, max_transfer);\n        assert(skip_bytes < pnum);\n        if (ret <= 0) {\n            /* Must copy-on-read; use the bounce buffer */\n            iov.iov_base = bounce_buffer;\n            iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER);\n            qemu_iovec_init_external(&local_qiov, &iov, 1);\n            ret = bdrv_driver_preadv(bs, cluster_offset, pnum,\n                                     &local_qiov, 0);\n            if (ret < 0) {\n                goto err;\n            bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n            if (drv->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(bounce_buffer, pnum)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,\n                                          &local_qiov, 0);\n            if (ret < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,\n                                pnum - skip_bytes);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);\n            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,\n                                     &local_qiov, 0);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                goto err;\n        cluster_offset += pnum;\n        cluster_bytes -= pnum;\n        progress += pnum - skip_bytes;\n        skip_bytes = 0;\n    ret = 0;\nerr:\n    qemu_vfree(bounce_buffer);\n    return ret;", "idx": 3398, "substitutes": {"child": ["count", "Child", "q", "children", "batch", "b", "cell", "c", "entry", "block", "cache", "cc", "unk", "parent", "shell", "create", "v", "client", "bit", "handle", "task", "link", "ach", "server", "ac", "node", "sb", "root", "h", "cl", "cs", "add", "id", "ch", "sim", "j", "job", "base"], "offset": ["count", "slice", "encrypted", "et", "length", "offs", "batch", "byte", "error", "start", "block", "pointer", " offsets", "timeout", "parent", "oid", "fp", "attribute", "prefix", "client", "seek", "shift", "reset", "os", "handle", "origin", "key", "set", "position", "location", "addr", "bits", "node", "ref", "order", "index", "alias", "extra", "ptr", "address", "Offset", "padding", "range", "id", "buffer", "off", "owner", "pos", "base", "slot"], "bytes": ["reads", "latest", "blocks", "ays", "es", "bps", "Bytes", "values", "sets", "byte", "array", "uses", "seconds", "its", "memory", " offsets", "forms", "ops", "units", "parts", "keys", "elt", "classes", "tes", "outs", "les", "ies", "ips", "os", "ows", "eps", "ees", "settings", "times", "abytes", "bits", "rows", "maps", "files", "loads", "resses", "raw", "pages", "errors", "sofar", "pieces", "steps"], "qiov": ["qiour", " qiour", "qqiour", "quiov", " qvr", "qqvr", "quiour", "quiev", "qvr", "qiev", "qqiov", "qqiev", "quvr", " qiev"], "bs": ["s", "bt", "BS", "ib", "bp", "ba", "bi", "bl", "lbs", "qs", "b", "bps", "blog", "pb", "ls", "boxes", "bles", "bus", "bh", "its", "ts", "bn", "ps", "fps", "uts", "gs", "ubis", "sys", "bc", "socket", "bf", "bm", "obs", "bos", "aos", "outs", "os", "bis", "fs", "ds", "bsp", "vs", "cb", "sts", "nb", "lb", "rs", "ns", "bits", "sb", "bb", "hz", "cs", "js", "ubs", "bo", "base", "bes"], "bounce_buffer": ["bouncematbuff", "bounced_volume", "bounce2Buffer", "bounced_command", "bounce___Buffer", "bounced_base", "bounced_Buffer", "bounce_buff", "bounce_command", "bounce_queue", "bounced_offset", "bounce___buffer", "bounce___offset", "bouncematvolume", "bounce_volume", "bounce_offset", "bounced_buffer", "bounced_queue", "bounce___buff", "bounced_buff", "bouncematbuffer", "bouncematcommand", "bounce_Buffer", "bounce2buff", "bounce2buffer", "bounce2queue", "bounce_base"], "drv": [" drvr", " drc", " drV", "drV", "crV", "srf", "drvr", "srv", "src", " drf", "crv", "srvr", "rf", "rv", " drvs", "rvs", "srvs", "drc", "drf", "drvs", "crvs", "rvr", "srV", "crc"], "iov": ["dq", "ibr", "vector", "isco", "ilo", "cmp", "veh", "vr", "ih", " mus", "ir", "ever", "rolet", "ovi", " fav", "drm", "iour", "kov", "av", "hero", "iv", "tv", "ivic", "aux", "river", "rio", "minecraft", "ij", "communication", " mor", "inv", "iva", " commun", " voic", "jp", "nov", "iw", "nil", "ious", "conv", "iph", "uart", "lov", "voc", "iq", " civ", "vo", "serv", "nir", "rov", "vp", "pkg", "voice", "iol", "iao", "liv", "imp", "nr", "phy", " rav", "iop", "vec", "io"], "local_qiov": ["local_qqiov", "local_qsiever", "local_dqiop", "local_ueiop", "local_quantiov", "local_quimir", "local_qsiop", "local_quiev", "local_dqiev", "local_qiever", "local_dqimir", "local_quiop", "local_qiop", "local_quantiev", "local_quiov", "local_dqiever", "local_Qiov", "local_qiv", "local_quiv", "local_Qiour", "local_qqiv", "local_quantimir", "local_ueiever", "local_quiour", "local_dqiov", "local_qiev", "local_Qiop", "local_Qiv", "local_ueiov", "local_qqiour", "local_qqiop", "local_qiour", "local_qimir", "local_ueiev", "local_quantiop", "local_qsiev", "local_qsiov"], "cluster_offset": ["cluster0area", "cluster_delay", "cluster8offset", "clusterIPbytes", "clignment_bytes", "clusterIPoffset", "cluster2area", "cluster2ref", "clusters_address", "cluster_addr", "clusteripaddress", "cluster__index", "clbuster_offset", "clust_offset", "cluster___address", "clusteripentry", "clbuster_id", "clusters_Offset", "cluster_size", "clust_bytes", "cluster___size", "cluster__Offset", "cluster__bytes", "clusteripbytes", "cluster2id", "cluster___offset", "cluster0offset", "clignmentipaddress", "clbuster0offset", "clusters_delay", "clignment_entry", "cluster8id", "cluster_ref", "clusteripoffset", "clusters_store", "clusters_size", "clignmentipbytes", "cluster8ref", "clignmentipentry", "cluster_address", "cluster0ref", "clbuster0area", "clusters_addr", "cluster_entry", "cluster8area", "clbuster0ref", "cluster_Offset", "clignment_address", "clusterIPOffset", "clbuster0id", "clignment_offset", "cluster_store", "clignmentipoffset", "clusters_bytes", "clust_Offset", "clbuster_ref", "cluster__offset", "cluster2offset", "cluster0id", "clust_index", "cluster_index", "cluster___store", "clusterIPdelay", "cluster_area", "cluster_id", "clbuster_area", "clusters_offset"], "cluster_bytes": ["clust_errors", "clancer_bytes", "cluster_errors", "clusterableoptions", "clubeablesteps", "clancer7bytes", "clubeableoptions", "cluster_fixes", "cluster_es", "cluster_size", "clust_bytes", "cluster3size", "clber_bytes", "cluster_seconds", "cluster___fixes", "clusterlenbytes", "cluster_byte", "cluster_steps", "clube_steps", "cluster0seconds", "cluster0es", "clutter_pages", "clubeablebits", "clancer7seconds", "clust_total", "clusterlentotal", "cluster___versions", "clusters_Bytes", "cluster_names", "clancer7es", "cluster3bytes", "clusters_size", "cluster___errors", "cluster_options", "cluster7options", "clber_versions", "clber_fixes", "clutter_bytes", "clancer7options", "clusterablebytes", "cluster_Bytes", "clust_size", "clube_options", "cluster7seconds", "cluster_versions", "clusterlensize", "cluster_bits", "clancer_seconds", "cluster7es", "clusters_bytes", "clusterablesteps", "clutter_size", "clber_errors", "clancer_options", "cluster0options", "clancer_es", "cluster3errors", "clube_bytes", "clusterlenbits", "clust_bits", "cluster7bytes", "clubeablebytes", "cluster_total", "clube_bits", "cluster0bytes", "cluster3names", "clust_names", "clusters_errors", "cluster___bytes", "cluster_pages", "clusterablebits", "clutter_byte"], "skip_bytes": ["skip___bits", "jump___bytes", " skip_times", " skip_bits", "jump___bits", "skip_bits", "skipalllength", "skip_length", " skip_seconds", "skipallerrors", "skip_reads", "skip___length", "skip___tes", "jump_bytes", "skip_errors", "jump_tes", "skip___reads", " skip_errors", "skip___size", "skip___errors", "jump_size", "jump_bits", " skip_length", "skipallbytes", "skip_tes", " skip_reads", "skip_seconds", "skip_times", "skipallreads", "skip_size", "jump___size", "skip___bytes", "jump___tes"], "ret": ["flag", "ext", "get", "del", "rets", "final", "nt", "Return", "re", "tr", "vet", "jump", "ert", "prot", "att", "far", "status", "rect", "after", "alt", "ts", "arg", "ll", " Ret", "mem", "out", "fun", "rm", "def", "rev", "gt", "ft", "jp", "rt", "elt", "len", "deg", "fin", "reset", "ter", "num", "arr", "reg", "success", "dt", "run", "resp", "Ret", "RET", "res", "t", "val", "print", "tech", "cert", "ref", "tf", "vals", " RET", "err", "cmd", "desc", "reply", "result", "job", "back", "rem"], "pnum": ["pronum", "wanim", "pnnum", "gnum", "wnum", "gnatum", "kinenum", "pnim", "PNman", "panumm", "nnumb", "pannum", "sonum", "pinumed", "gnuma", "gnums", "PNumer", "PNums", "PNenum", "pronman", "pronumb", "pronumm", "pronumer", "pnenum", "panim", "penumer", "PNUM", "pnumb", "pinumb", "nnum", "penum", "wannum", "PNum", "gnnum", "pnuma", "pngums", "pronenum", "gnUM", "pnumm", "pngatum", "nnumm", "pinum", "kinumer", "sonuma", "panumb", "pnatum", "pnumed", "pnUM", "pnman", "pngum", "penUM", "pinumer", "panumed", "wnumer", "pennum", "kinum", "sonnum", "kinman", "panum", "wnnum", "wnUM", "panUM", "pnums", "pnumer", "pngUM", "PNatum", "pinumm", "penuma", "panumer", "pronumed", "nnumer", "gnumer", "sonumer", "gnim", "wanUM", "wanum"]}}
{"project": "qemu", "commit_id": "2cbe2de5454cf9af44b620b2b40d56361a12a45f", "target": 1, "func": "static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}", "idx": 3399, "substitutes": {"dev": ["de", "ad", "spec", "dep", "dem", "nt", "md", "di", "d", "w", "av", "pad", "iv", "mem", "sky", "v", "dis", "def", "dd", "die", "os", "ds", "doc", "adv", "Dev", "serv", "device", "ver", "wd", "home", "cast", "des", "env", "cmd", "desc", "DEV", "priv", "data", "ev"], "errp": ["lrpc", "lerps", "lrpb", "errorpb", "rrpa", "lerpt", "errpa", "erps", "errpb", "lrp", "errorpc", "errpc", "rrpb", "errps", "erp", "lerp", "erpt", "rrp", "rrsp", "errorpa", "errorp", "rrpc", "rrpt", "errpt", "errsp", "lrpa", "rrps", "ersp", "lersp"]}}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    char buf[1024];\n\n    VncShareMode mode;\n\n    int size;\n\n\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n\n    switch (vs->vd->share_policy) {\n\n    case VNC_SHARE_POLICY_IGNORE:\n\n        /*\n\n         * Ignore the shared flag.  Nothing to do here.\n\n         *\n\n         * Doesn't conform to the rfb spec but is traditional qemu\n\n         * behavior, thus left here as option for compatibility\n\n         * reasons.\n\n         */\n\n        break;\n\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n\n        /*\n\n         * Policy: Allow clients ask for exclusive access.\n\n         *\n\n         * Implementation: When a client asks for exclusive access,\n\n         * disconnect all others. Shared connects are allowed as long\n\n         * as no exclusive connection exists.\n\n         *\n\n         * This is how the rfb spec suggests to handle the shared flag.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            VncState *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 3401, "substitutes": {"vs": ["s", "ils", "ports", "vd", "xs", "stats", "ads", "bs", "qs", "lbs", "ants", "nets", "vi", "vr", "es", "otes", "values", "ls", "pps", "blogs", "styles", "lists", "ts", "its", "ps", "vt", "fps", "Vs", "changes", "views", "gs", "v", "is", "sys", "inv", "ops", "ks", "verts", "ss", "obs", "lines", "ims", "ms", "tests", "sv", "os", "fs", "ds", "versions", "vis", "docs", "sts", "wcs", "params", "eps", "gets", "vers", "rs", "ns", "ins", "ver", "vp", "VS", "cv", "vals", "cs", "hs", "caps", "vm", "vc", "js", "uds"], "data": ["DATA", "n", "clear", "empty", "rc", "hash", "bin", "bytes", "batch", "b", "values", "d", "block", "channel", "r", "map", "p", "cache", "window", "valid", "accept", "Data", "next", "message", "image", "name", "area", "key", "value", "dat", "msg", "to", "bits", "zero", "text", "done", "extra", "mu", "buffer", "m", "pos", "ata"], "len": ["bl", "str", "cap", "rc", "bin", "length", " length", "bytes", "byte", " count", "type", "ec", "l", " bl", "en", "Len", "code", "h"], "buf": ["bt", "db", "proc", "fb", "uffy", "str", "bs", "cap", "var", "iter", "orig", "fr", "bytes", "uf", "b", "rb", "cur", " cmd", "w", "Buff", " buff", "bh", "p", "wb", "pad", "img", "mem", "window", "row", "v", "fd", "next", "out", "queue", "name", "ctx", "cam", "br", "doc", "cb", "msg", " buffer", "bag", " b", "sb", "text", "txt", "vp", "cv", "Buffer", "pg", "ptr", "tmp", "pkg", "cast", "raw", "obj", "caps", "cmd", "err", "tx", "nm", "buffer", "buff", "vec", "box"], "mode": ["method", "time", "cmp", "stay", "pose", "te", "direction", "member", "tif", "ie", "module", "role", "scale", "cmd", "range", "id", "ode", "raid", "test", "md", "ui", "status", "max", "license", "nom", "command", "kind", "power", "DE", "def", "mid", "perm", "multi", "no", "mt", "option", "Mode", "version", "dim", "pro", "only", "style", "ME", "mod", "match", "mm", "stage", "format", "menu", "key", "state", "mit", "tm", "policy", "m", "de", "spec", "ase", "type", "feat", "mem", "oe", "me", "MODE", "settings", "now", "zero", "progress", "mate", "none", "acl"], "size": ["count", "empty", "time", "length", "ui", "unit", "grow", "export", " Size", "start", "capacity", " count", "speed", "height", "max", "sum", "type", "check", "window", "offset", "send", "ize", "sex", "eng", "message", "format", "member", "g", "name", "space", "shift", "notice", " sizes", "set", "fee", "index", "no", "equal", "SIZE", "scale", "loss", "storage", "sp", "shape", "address", "global", "small", "dim", "Size"], "client": ["service", "null", "cli", "open", "cap", "pat", "pool", "q", "nt", "batch", "item", "ct", "cell", "c", "cur", "entry", "start", "pb", "channel", "active", "remote", "cache", "p", "Client", "local", "player", "cp", "i", "parent", "pc", "connection", "window", "v", "out", "next", "ip", "row", "web", "co", "pty", "peer", "list", "current", "name", "port", "conn", "key", "server", "manager", "master", "to", "friend", "cod", "http", "node", "component", "user", "cv", "cl", "obj", "tab", "session", "tmp", "public", "net", "cmd", "con"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,\n\n                                                 const uint8_t *src_y,\n\n                                                 int32_t src_stride,\n\n                                                 uint8_t *dst,\n\n                                                 int32_t dst_stride)\n\n{\n\n    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;\n\n    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;\n\n    v8i16 res0, res1;\n\n    v16u8 res;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);\n\n    src_y += (5 * src_stride);\n\n\n\n    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);\n\n    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);\n\n    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);\n\n    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);\n\n\n\n    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);\n\n    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);\n\n    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,\n\n                                                          mask0, mask1, mask2);\n\n    SRARI_H2_SH(hz_out0, hz_out1, 5);\n\n    SAT_SH2_SH(hz_out0, hz_out1, 7);\n\n    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);\n\n\n\n    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);\n\n    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);\n\n    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);\n\n    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);\n\n\n\n    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);\n\n\n\n    /* filter calc */\n\n    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,\n\n                                                  src_vt3, src_vt4, src_vt5);\n\n    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,\n\n                                                  src_vt5, src_vt6, src_vt7);\n\n    SRARI_H2_SH(vert_out0, vert_out1, 5);\n\n    SAT_SH2_SH(vert_out0, vert_out1, 7);\n\n\n\n    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);\n\n    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);\n\n\n\n    SAT_SH2_SH(res0, res1, 7);\n\n    res = PCKEV_XORI128_UB(res0, res1);\n\n\n\n    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);\n\n    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);\n\n    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);\n\n    dst0 = __msa_aver_u_b(res, dst0);\n\n\n\n    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);\n\n}\n", "idx": 3416, "substitutes": {"src_x": ["src_w", "src__x", "rc_x", "src__w", "src__xy", "src__y", "rc_y", "rc_xy", "src_xy", "rc_w"], "src_y": ["source_y", "src_ies", "src__x", "rc_x", "source_x", "rc_ey", "src_yy", "src__y", "rc_ies", "rc_y", "src__ies", "src_Y", "src_ey", "rc_yy", "source_yy", "source_Y", "src__ey", "rc_xy", "src_xy"], "src_stride": ["src_depthice", "src_glride", "src_slage", "src_strice", "src_STRice", "src_drange", "src2strine", "src2glride", "src_depthide", "src_glage", "src_strage", "src_Strride", "src_strid", "src2stride", "src2glange", "src_depthride", "src_strride", "src_STRage", "src_glide", "src_slide", "src_drate", "src_glange", "src2glide", "src_dride", "src_STRride", "src_strange", "src_slate", "src2strange", "src_gline", "src_slid", "src2gline", "src_drine", "src_strine", "src_drage", "src_strate", "src2strride", "src_STRide", "src_Stride", "src_grid", "src_depthage", "src_Strine", "src_glice", "src_drride", "src_drid", "src_grage", "src_grate", "src_gride", "src_Strange"], "dst": ["edST", "dset", " dset", "dsp", "sdST", "edset", " dsp", "edsp", " dST", "sdst", "dST", "edst", "sdsp", "sdset"], "dst_stride": ["dst_strride", "dst_strid", "dst_strize", "dst_glize", "dst_tride", "dst_glide", "dst_glid", "dst_trid", "dst_trride", "dst_grid", "dst_gride", "dst_grride", "dst_glride", "dst_grize", "dst_trize"], "src_hz0": ["src_cz0", "src_mx0", "src_zz1", "src_zz0", "src_zz3", "src_mx1", "src_zz2", "src_mx2", "src_cz1", "src_cz3", "src_mx3", "src_cz2"], "src_hz1": ["src_ts5", "src_tz12", "src_hz5", "src_elt12", "src_tz0", "src_hz12", "src_elt5", "src_elt1", "src_tz5", "src_tz1", "src_ts0", "src_ts1", "src_ts12", "src_elt0"], "src_hz2": ["src_mx7", "src_kh1", "src_hs6", "src_hs7", "src_hs1", "src_hs2", "src_kh2", "src_mx1", "src_mx6", "src_mx2", "src_kh6", "src_hz6", "src_hz7", "src_kh7"], "src_hz3": ["src_css2", "src_css03", "src_zz03", "src_css3", "src_tz3", "src_tz03", "src_zz1", "src_zz3", "src_zz2", "src_tz2", "src_hz03", "src_css1", "src_tz1"], "dst0": ["dest5", "dist5", "dest0", "sdst0", "sdest3", "dist3", "sdst3", "sdst5", "sdest0", "sdest1", "dest3", "dost5", "dist1", "sdest5", "dest1", "dost1", "dist0", "sdst1", "dost3", "dst5", "dost0"], "dst1": ["Dst1", "Dest1", "Dest2", "dest4", "dsp4", "Dst4", "dest2", "dest1", "dost1", "dsp2", "dst4", "Dest4", "dost2", "Dst2", "dsp1", "dost4"], "dst2": [" dsc2", "drest2", " dst7", "dsc3", "dsc7", " dsc7", "drest7", "drest3", " dsc3", "dest3", "dest2", "dst7", "dest7", "dsc2"], "dst3": ["dST3", "drest1", " dst7", "dST1", " dST7", "dST7", " dST1", "drest7", "dst9", "dST9", " dST3", "drest3", " dst9", "dest9", "dest3", "dest1", "dst7", "drest9", "dest7", " dST9"], "src_vt0": ["src_yt0", "src_mt2", "srcJmtarg", "src_yt2", "src_vy3", "srcJvtarg", "srcJvt0", "src_vp2", "src_ytarg", "src_VT0", "src_ct3", "src_vet2", "src_vtarg", "srcJvt2", "src_t1", "src_tt5", "src_vt48", "src_vert2", "src_vy8", "src_t0", "srcJvt48", "src_vp8", "src_t3", "src_vy5", "src_VT3", "src_pt1", "src_pt5", "src_VT2", "src_t2", "src_pt0", "src_vet0", "src_vp3", "src_vet1", "src_tt3", "src_vy0", "src_mt48", "src_vc48", "src_vcarg", "src_vet3", "src_vet5", "srcJmt2", "srcJmt48", "src_vert3", "src_vp0", "src_vc0", "srcJmt0", "src_mtarg", "src_vc2", "src_yt48", "src_vert5", "src_ct0", "src_vert1", "src_mt0", "src_VT8", "src_vert8", "src_vert0", "src_ct1", "src_ct2", "src_tt0", "src_tt8"], "src_vt1": ["src_yt0", "src_vertOne", "src_vc1", "src_vt001", "src_yt6", "src___v01", "src_bt9", "src_yt4", "src_vert11", "src_qt9", "src_yt1", "src_vt9", "src_wtA", "src_vp1", "src_vtOne", "src_vert4", "src_tyA", "src_vc001", "src_vp11", "src_ct3", "src_btOne", "src_v1", "src_ty001", "src___vt01", "src_ty3", "src_ty01", "src_vet9", "src_bt7", "src_ty9", "src_ht3", "src_vert9", "src_vet4", "src_yt3", "src_vp9", "src___vt11", "src_v01", "src_vtA", "src_qt1", "src_ty1", "src_ht1", "src_vet1", "src_ty4", "src_ht6", "src_vt01", "src_vp7", "src_wt001", "src_vcA", "src_vc01", "src_wt1", "src_vert3", "src_v11", "src_wt01", "src_vt11", "src_ht0", "src_vert01", "src_vet7", "src___v11", "src_ct0", "src_vert1", "src_vp4", "src_bt1", "src_yt9", "src_vert7", "src_ct6", "src___v1", "src_vp01", "src_ct1", "src_qtOne", "src___vt1", "src_qt7"], "src_vt2": ["src___1", "src_vc1", "src_vc14", "src_vp2", "src___vt2", "src_vp1", "src___vt3", "src__vt2", "src__vp3", "src__vt7", "src___tv0", "src_tyTwo", "sort_1", "src___vtTwo", "src_vet2", "src_sys2", "src___vt0", "src_ty2", "src_ty3", "src_vp5", "src___tvTwo", "src_vtTwo", "src_vert14", "src_tv3", "src_ht3", "src_ht4", "src_vert2", "src_tv0", "src___tv3", "src_1", "src_8", "src_sys3", "sort_8", "src_vetTwo", "src_vt14", "src_ty1", "src_ht1", "src_vet0", "src___tv2", "src_vp3", "src_vet1", "src_ty4", "src_vet14", "src_ip", "src_vp7", "src___8", "src_vet3", "src_vp0", "src_ty5", "src_ht7", "src_vc0", "src__vp2", "src__vp7", "src_tvTwo", "src_ht0", "src_vc2", "src_tv2", "src_vet7", "src_sys5", "src_vert1", "src_vp4", "src___ip", "src_ht2", "src_ty0", "src__vt3", "sort_ip", "src_vert0"], "src_vt3": ["src2vt2", "src_tv1", "src2vp7", "src_vert11", "src_vt03", "src_qt9", "src_vt9", "src_vp2", "src_kt0", "src_ts3", "src_qt3", "src_pt2", "src2vt3", "src2vp5", "src_ts5", "src_ktard", "src_vs7", "src2vp2", "src_ty3", "src_vet9", "src_vp5", "src_vetard", "src_tv3", "src_pt3", "src2vt7", "src_cmd9", "src_tv0", "src_virt7", "src_cmd3", "src_ty7", "src_qt1", "src_vs11", "src_cmd03", "src_vpry", "src_pt5", "src_pt7", "src_vet0", "src_vp3", "src_vet1", "src_kt8", "src_tvard", "src_virt3", "src_vp7", "src_kt3", "src_vs8", "src_qt03", "src_virtry", "src_cmd1", "src_vet3", "src_vert3", "src_vet03", "src_vt11", "src_ts2", "src_vs3", "src_kt11", "src2vt5", "src2vp3", "src_ts7", "src_kt1", "src_vert8", "src_vert7", "src_tyry", "src_vtry", "src_kt7", "src_vtard"], "src_vt4": ["src_vt44", "src_VT4", "src_vy5", "src_tv1", "src_vc5", "src_vc1", "src_ty1", "src_VT44", "src_vertn", "src_vert44", "src_vt04", "src_vy3", "src_vet1", "src_tv44", "src_vtn", "src_ty4", "src_vy4", "src_tt3", "src_tt5", "src_vc4", "src_vert4", "src_vet4", "src_vert1", "src_vet04", "src_tt32", "src_tt4", "src_vc04", "src_ty5", "src_vet3", "src_vet5", "src_tvn", "src_tv4", "src_VTn", "src_vt32", "src_ty04", "src_vet32", "src_vy32", "src_VT1"], "src_vt5": ["src_qt1", "src_qt8", "src_qt2", "src_qt5", "src_vet1", "src_vp5", "src_vp2", "src_vp1", "src_vp8", "src_vet5", "src_vet2", "src_vet8"], "src_vt6": ["src_vtect", "src_virt4", "src_qtect", "src_vet6", "src_virt3", "src_qt6", "src_qt4", "src_vet4", "src_virtect", "src_qt3", "src_vetect", "src_vet3", "src_virt6"], "src_vt7": ["src_ts5", "src___tt5", "src___vt7", "src___vt9", "src_tt9", "src_vet9", "src_vet7", "src_vt9", "src_tt5", "src_ts7", "src___tt9", "src_tt7", "src_vet5", "src___tt7", "src_ts9", "src___vt5"], "src_vt8": ["src_tv9", "src_tv1", "src_vc1", "src_vc8", "src_vt9", "src_tvint", "src_vert9", "src_vertint", "src_vert1", "src_tv8", "src_vc9", "src_vert8", "src_vcint", "src_vtint"], "mask0": [" mask3", "mask3", "ask1", "Mask2", "Mask3", "ask0", "ask3", "Mask0", "ask2", "Mask1"], "mask1": ["filter4", " mask3", "filter3", "map0", "ask4", "mask3", "mask4", "ask1", " mask4", "miss4", "miss0", "map4", "miss1", "filter1", "ask0", "filter2", "ask3", "miss2", "ask2", "map1", "map2"], "mask2": ["miss3", "filter4", " mask3", "ask4", "mask3", "mask4", "ask1", "filter0", " mask4", "miss4", "miss1", "filter1", "ask0", "filter2", "ask3", "miss2", "ask2"], "hz_out0": ["hz_fix1", "hz_in3", "hz_mask1", "hz_mask0", "hz_mask00", "hz_mask3", "hz_in00", "hz_in0", "hz_out3", "hz_fix3", "hz_fix00", "hz_fix0", "hz_out00", "hz_in1"], "hz_out1": ["hz_out5", "hz_sum1", "hz_sum0", "hz_in5", "hz_sum5", "hz_in0", "hz_Out0", "hz_Out1", "hz_in1", "hz_Out5"], "vert_out0": ["vert_in0", "vert_mask1", "vert_in5", "vert_OUT5", "vert_in2", "vert_out2", "vert_mask5", "vert_out5", "vert_mask2", "vert_OUT1", "vert_OUT2", "vert_mask0", "vert_in1", "vert_OUT0"], "vert_out1": ["vert_bit1", "vert_in2", "vert_bit9", "vert_out2", "vert_OUT1", "vert_OUT9", "vert_out9", "vert_OUT2", "vert_in9", "vert_in1", "vert_bit2"], "res0": ["Res0", "resolution00", "req0", "resolution0", "resolution5", "Res5", "res00", "req5", "res5", "Res00", "req00"], "res1": ["Res2", "Res0", " resone", "Resone", "res2", "resone", " res2", "Res1", "maskone"], "res": ["resolution", "bs", "re", "mask", "RES", "ret", "ress", "ps", "out", "pres", "sys", "gr", "reg", "ms", "os", "wcs", "resp", "rs", "val", "bits", "resh", "des", "ch", "js", "vol", "Res", "vec"]}}
{"project": "qemu", "commit_id": "a27365265cc2fed1178bf25a205e8ee02a9c0caf", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 3440, "substitutes": {"bs": ["bt", "BS", "bp", "bl", "lbs", "bing", "es", "b", "blog", "ls", "pb", "bh", "ts", "bn", "its", "ps", "gs", "bc", "bf", "bm", "ks", "ss", "obs", "cks", "aos", "bos", "bes", "ms", "os", "bis", "fs", "ds", "vs", "sts", "rs", "ns", "bits", "sb", "bb", "hz", "cs", "hs", "js", "ubs", "boot", "aus"], "sector_num": ["sector_Num", "sector__num", " sector_index", "ector_Num", "sector__index", "sectorseqnum", "sector_number", "sectorseqindex", "sector_mon", "sector_nr", "sectorseqnumber", "sector__number", "sector_index", "sector__nr", "sectorseqnr", "ector_num", " sector_nr", " sector_number", "ector_mon", "ector_number"], "qiov": ["requiol", "queryiol", "requiov", "qiol", "queryiour", " qovi", "qiop", "qualiour", "Qiour", "queryiov", "Qiov", "qiour", "qualiop", "Qrolet", "requovi", "qrolet", "qovi", "qualrolet", "queryovi", "Qiop", "qualiov", " qrolet", " qiop", " qiour", " qiol", "requiour"], "nb_sectors": ["nb_veors", "nb_severs", "nb_veriers", "nb_rellers", "nb_seors", "nb_spectors", "nb_vevers", "nb_sellers", "nb_rectors", "nb_revisors", "nb_pseors", "nb_seriers", "nb_sevisors", "nb_spellers", "nb_reors", "nb_pseriers", "nb_vellers", "nb_speors", "nb_vectors", "nb_psevers", "nb_psectors", "nb_vevisors", "nb_spevisors"], "cb": ["CB", "fb", "bp", "rc", "eb", "cfg", "b", "rb", "c", "func", "pb", "rl", "cp", "cc", "wb", "cf", "ck", "callback", "abb", "bc", "fun", "dc", "ob", "bf", "fi", "fc", "nc", "gb", "nb", "lb", "fn", "bb", "unc", "cv", "tc", "ub", "cd", "ctrl", "job", "db"], "opaque": ["posaque", "ompac", "popaque", "OPque", "opque", "obque", "posque", "OPity", "popque", "posity", "ompque", "operity", "OPac", "posacity", "opacity", "iopac", "oppula", "opac", "iopque", "popacity", " opque", "opula", "oppque", "obaque", "popity", "opity", "oppity", "ompaque", "operque", "operula", "obity", "ompity", "iopity", "operaque", " opity", "obacity", " opula", "iopaque", "OPaque", "oppaque"], "s": ["n", "sg", "stats", "ses", "c", " ss", "ls", "p", "ts", "sd", "ps", "gs", "is", "sh", "st", "ss", "g", "se", "sv", "os", "fs", "ds", "sts", "ats", "rs", "ns", "sb", "S", "h", "sl", "sq", "cs", "sp", "hs", "js", "sa", "j"]}}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 3449, "substitutes": {"opaque": ["popaque", "opque", "iopaques", "opatile", "popque", "iopacity", "OPaques", "iopatile", "OPacity", "opacity", " opatile", "paque", "oposter", "ipque", "popacity", "pque", "ipacity", "pacity", " opacity", " opaques", "ipaque", "iposter", "opaques", "OPatile", "poster", "poposter", "iopaque", "OPaque"], "addr": ["iter", "hash", "rid", "r", "ind", "v", "coord", "handle", "arp", "ptr", "hw", "pkg", "sha", "address", "cmd", "id", "off", "pos", "gate", "var", "gz", "at", "ha", "map", "alt", "pad", "row", "x", "prefix", " ref", "ord", "host", "loc", "wd", "index", "mt", "ace", "add", "urg", "aff", "ad", "attr", "eth", "rc", "wid", "inter", " ip", " address", "ip", "rt", "elt", "seek", "rn", "ctx", "ix", "msg", " af", "alias", "dr", "sp", "tx", "mac", "alloc", "ack", "nl", "ag", "work", "pat", "src", "hl", "align", "mem", "offset", "Address", "arr", "ac", "adr", "res", "rs", "now", "act", "obj", " mac"], "val": ["ival", "cmp", "lit", "pr", "v", "al", "value", "it", "vec", "il", "Value", "pos", "prop", "test", "bl", " v", "var", "util", "comp", "alt", "sel", "buf", "x", "pal", "sol", "bit", "num", "loc", "pl", "rel", "eval", "index", "vals", "buffer", "vol", "data", "attr", "VAL", "bin", "point", "ret", "arg", "p", "l", "cal", "valid", "elt", "reg", "ctx", "key", "aval", "tx", "base", "slot", "cho", "el", "item", "func", "values", " eval", "pt", "vt", "mem", "arr", "pol", "res", "serv", "Val", " value", "ref", "rol"], "size": ["n", "count", "cap", "length", "cmp", "d", "type", "align", "l", "mem", "offset", "ize", "e", "name", "num", "en", "iz", "h", "SIZE", "z", "address", "sp", "id", "Size"], "s": ["n", "services", "r", "is", "parts", "sis", "store", "fs", "ds", "bits", "sb", "h", "sq", "hs", "sports", "bs", "ses", "status", "ims", "sv", "sts", "ats", "as", "details", "sim", "j", "qs", "ssl", "states", "p", "ps", "comments", "sys", "less", "ss", "ms", "bis", "params", "so", "sm", "rates", "sl", "m", "ex", "sam", "service", "spec", "stats", "comm", "es", "b", "ls", "als", "ts", "changes", "gs", "stat", "conf", "se", "acs", "rs", "t", "ns", "serv", "ins", "S", "sw", "ess", "cs", "js", "aws", "series"], "adsr": ["ipsR", "adrg", "adrs", "adl", "adrt", "adsrs", "agsler", "adsl", "adser", "lsr", "adrar", "aysrt", "adsm", "agsR", "ainsrc", "adsR", "aysrar", "modsrg", "modser", "ainsr", "lsm", "apssr", "adler", "adesl", "achesrc", "adesr", "aysl", "modssr", "adsrg", "agsrs", "rsm", "aysrc", "adesrt", "adesrar", "aysr", "adsrt", "adsrb", "ader", "adssr", "agsr", "modsr", "ipsrs", "ainsrb", "achesr", "adm", "adr", "adsvr", "advr", "achesrt", "adsler", "apser", "ainsrt", "aysrb", "ipsler", "rsR", "lsR", "apsrg", "apsr", "adR", "adsrar", "achesrb", "rsr", "lsvr", "rsvr", "ipsr", "adsrc"], "len": ["lf", "n", "lon", "el", "nl", "lib", "li", "seq", "length", "nt", "bytes", "cmp", "ls", "pos", "lit", "hl", "lim", "kl", "ret", "ell", "ll", "ul", "l", "mem", "offset", "L", "Length", "lin", "list", "elt", "fin", "num", "en", "lp", "limit", "Len", "ld", "loc", "le", "den", "lis", "rel", "vec", "h", "SIZE", "sl", "ln", "f", "ml", "vol", "lan"], "i": ["phi", "iu", "I", "n", "oi", "bi", "cli", "init", " li", "li", "iter", "ui", " j", " m", "di", "ii", "uri", "mi", " si", "p", "ji", " bi", "\u0438", "l", "ip", "ei", "v", "ai", "x", "e", "pi", "prefix", "u", "in", "ini", " di", "zi", "g", "ic", "ori", "qi", "xi", "o", " ti", " ii", "it", "si", "ix", "t", "ci", "multi", "y", " ni", "us", "chain", "sim", "gi", "ti", "m", "j", "client", "io"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,\n\n                                                       uint8_t alpha_in,\n\n                                                       uint8_t beta_in,\n\n                                                       uint32_t img_width)\n\n{\n\n    uint16_t out0, out1, out2, out3;\n\n    v8i16 tmp1;\n\n    v16u8 alpha, beta, is_less_than;\n\n    v8i16 p0_or_q0, q0_or_p0;\n\n    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;\n\n    v16i8 zero = { 0 };\n\n    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;\n\n    v16u8 is_less_than_alpha, is_less_than_beta;\n\n    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;\n\n\n\n    {\n\n        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;\n\n\n\n        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,\n\n                      row0, row1, row2, row3, row4, row5, row6, row7);\n\n\n\n        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,\n\n                          p1_or_q1_org, p0_or_q0_org,\n\n                          q0_or_p0_org, q1_or_p1_org);\n\n    }\n\n\n\n    alpha = (v16u8) __msa_fill_b(alpha_in);\n\n    beta = (v16u8) __msa_fill_b(beta_in);\n\n\n\n    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);\n\n    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);\n\n    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);\n\n\n\n    is_less_than_alpha = (p0_asub_q0 < alpha);\n\n    is_less_than_beta = (p1_asub_p0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than_alpha;\n\n    is_less_than_beta = (q1_asub_q0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than;\n\n\n\n    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);\n\n\n\n    if (!__msa_test_bz_v(is_less_than)) {\n\n        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);\n\n        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);\n\n        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);\n\n        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);\n\n\n\n        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);\n\n        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);\n\n\n\n        /* convert 16 bit output into 8 bit output */\n\n        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);\n\n        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);\n\n\n\n        p0_or_q0_org =\n\n            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);\n\n        q0_or_p0_org =\n\n            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);\n\n\n\n        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);\n\n\n\n        data_cb_or_cr -= 1;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 0);\n\n        out1 = __msa_copy_u_h(tmp1, 1);\n\n        out2 = __msa_copy_u_h(tmp1, 2);\n\n        out3 = __msa_copy_u_h(tmp1, 3);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n        data_cb_or_cr += img_width;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 4);\n\n        out1 = __msa_copy_u_h(tmp1, 5);\n\n        out2 = __msa_copy_u_h(tmp1, 6);\n\n        out3 = __msa_copy_u_h(tmp1, 7);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n    }\n\n}\n", "idx": 3452, "substitutes": {"data_cb_or_cr": ["data_cb_nor_ctr", "data_cb_or_r", "data_cb_nor_r", "data_cb_nor_cm", "data_cb_or__ctr", "data_cb_or_tr", "data_cb_or_cm", "data_cb_or_Cr", "data_cb_or_ctr", "data_cb_or__cr", "data_cb_nor_tr", "data_cb_or__r", "data_cb_or__Cr", "data_cb_nor_Cr", "data_cb_nor_cr"], "alpha_in": ["alphaiodin", "alpha_ins", "alpha_out", "alpha_din", "alphaioin", "alpha_IN", "acl_in", "alphaioIN", " alpha_din", "acl_out", "acl_ins", "alphaiocin", "acl_IN", " alpha_IN", " alpha_cin", "alpha_cin"], "beta_in": ["alpha_ins", "alpha_out", " beta__ind", " beta_bin", "betaixin", "beta_gen", "alpha_gen", "beta__in", "beta_ins", "betammin", "beta_out", "beta_ind", "betammout", "betaixbin", " beta__in", "betammins", "beta_bin", " beta_ind", "beta__bin", "betammgen", "betaixind", " beta__bin", "beta__ind"], "img_width": [" img_length", "image_width", "image_height", "img_height", " img_len", "img_length", " img_height", "img_len", "img_w", "image_w"], "out0": ["in1", "Out1", "in2", "Out3", "in3", "in0", "Out0", "Out2"], "out1": ["in1", "OUT8", "in01", "Out1", "Out01", "out01", "OUT01", "OUT1", "in0", "out8", "Out0", "in8", "OUT0", "Out8"], "out2": ["out02", " out02", "OUT5", " out5", "result4", "result02", "OUT2", "result2", "result5", "out5", "OUT02", "out4", "OUT4", " out4"], "out3": ["result7", "OUT4", "result4", "OUT7", "out03", "result3", "OUT03", "result03", "OUT3", "out4", "out7", " out03", " out4", " out7"], "tmp1": ["po1", "tmp9", "pi1", "pi5", "po9", "pi9", "mp1", "mp9", "tmp5", "mp5", "po5"], "alpha": ["phi", "attr", "pha", "lambda", "angle", "error", "ppa", "fa", "la", "admin", "ity", "prefix", "title", "pi", "power", "anti", "name", "area", "xa", "balance", "ac", "alph", "al", "ma", "a", "success", "ta", "acc", "Alpha", "da", "alias", "amount", "asc", "extra", "sha", "weight", "asa", "acl", "upper"], "beta": ["phi", "ba", "bi", "lr", "\u03b2", "lambda", "bs", "binary", "normal", "confidence", "nu", "b", "ava", "bet", "fa", "xy", "late", "eta", "dirty", "bis", "Beta", "ta", "uni", "meta", "fee", "secret", "minus", "extra", "gam", "mu", "gradient", "mega", "term", "fine", "base"], "is_less_than": ["is_more_after", "is_lessableafter", "is_more_about", "is_more_than", "is_lessablethan", "is_less_about", "is_lessableabout", "is_less_after"], "p0_or_q0": ["p0_or_dq0", "p0_or_dq2", "p0_or_dq1", "p0_or_q1", "p0_or_p0", "p0_or_q2", "p0_or_p2", "p0_or_p1"], "q0_or_p0": ["q0_or_q0", "q0_or_P1", "q0_or_Pk", "q0_or_qk", "q0_or_q1", "q0_or_P0", "q0_or_p1", "q0_or_pk"], "p1_or_q1_org": ["p1_or_q0_reg", "p1_or_q1__org", "p1_or_q0_org", "p1_or_q0_gen", "p1_or_q1_or", "p1_or_q1_gen", "p1_or_q1__gen", "p1_or_q1__or", "p1_or_q0_og", "p1_or_q1_og", "p1_or_q1__reg", "p1_or_q1_reg", "p1_or_q0_or"], "p0_or_q0_org": ["p0_or_q0xgen", "p0_or_q0_Org", "p0_or_q1_org", "p0_or_q1_orig", "p0_or_q0_or", "p0_or_q1_Org", "p0_or_q0xorg", "p0_or_q0_orig", "p0_or_q1_or", "p0_or_q0xgov", "p0_or_q0_gov", "p0_or_q1_gov", "p0_or_q0_gen", "p0_or_q1_gen"], "q0_or_p0_org": ["q0_or_p0_gov", "q0_or_p0_com", "q0_or_p0_og", "q0_or_p0xorg", "q0_or_p1_org", "q0_or_p1xog", "q0_or_p1_gen", "q0_or_p1_gov", "q0_or_p0xog", "q0_or_p1xorg", "q0_or_p0_or", "q0_or_p1_or", "q0_or_p0_gen", "q0_or_p1_og", "q0_or_p0xcom", "q0_or_p1_com", "q0_or_p1xor", "q0_or_p0xor", "q0_or_p0xgen"], "q1_or_p1_org": ["q1_or_p1xgen", "q1_or_p1_Org", "q1_or_p1_gov", "q1_or_p0_gov", "q1_or_p1xgov", "q1_or_p0_org", "q1_or_p1xorg", "q1_or_p1_gen", "q1_or_p0_gen", "q1_or_p2_gov", "q1_or_p2_org", "q1_or_p2_Org", "q1_or_p1xOrg"], "p0_asub_q0": ["p0_asub_Q0", "p0_asub_dq1", "p0_asub_q2", "p0_asub_dqk", "p0_asub_dq0", "p0_asub_pk", "p0_asub_Q1", "p0_asub_p0", "p0_asub_Qk", "p0_asub_dq2", "p0_asub_q1", "p0_asub_p1", "p0_asub_qk", "p0_asub_p2"], "p1_asub_p0": ["p1_asub_P0", "p1_asub_p50", "p1_asub_P1", "p1_asub_p1", "p1_asub_u50", "p1_asub_q3", "p1_asub_m1", "p1_asub_u0", "p1_asub_Parg", "p1_asub_p3", "p1_asub_q50", "p1_asub_q0", "p1_asub_P50", "p1_asub_qarg", "p1_asub_u1", "p1_asub_m0", "p1_asub_m3", "p1_asub_q1", "p1_asub_parg", "p1_asub_uarg"], "q1_asub_q0": ["q1_asub_jarg", "q1_asub_dq1", "q1_asub_j1", "q1_asub_qarg", "q1_asub_p50", "q1_asub_j50", "q1_asub_dq0", "q1_asub_p1", "q1_asub_dqarg", "q1_asub_q1", "q1_asub_p0", "q1_asub_dq50", "q1_asub_j0", "q1_asub_q50", "q1_asub_parg"], "is_less_than_alpha": ["is_less_than_asc", "is_less_than_Alpha"], "is_less_than_beta": ["is_less_than_Beta", "is_less_than_phi"], "p1_org_r": ["p1_org2R", "p1_org_org", "p1_gov_org", "p1_org_or", "p1_org2or", "p1_gov_R", "p1_org_R", "p1_gov_r", "p1_org2r", "p1_gov_or", "p1_org2org"], "p0_org_r": ["p0_reg_r", "p0_org_org", "p0_org_rd", "p0_org2org", "p0_org2rd", "p0_org_or", "p0_org2r", "p0_reg_org", "p0_reg_or", "p0_org2or", "p0_reg_rd"], "q0_org_r": ["q0_org2ro", "q0_org2rb", "q0_org2rd", "q0_org_ro", "q0_reg_rd", "q0_org_rb", "q0_reg_rb", "q0_reg_ro", "q0_reg_r", "q0_org2r", "q0_org_rd"], "q1_org_r": ["q1_orglyvr", "q1_org_vr", "q1_org2vr", "q1_orglyR", "q1_reg_R", "q1_reg_vr", "q1_reg2vr", "q1_orglyr", "q1_reg2org", "q1_org2r", "q1_org_R", "q1_reg2R", "q1_org2R", "q1_orglyorg", "q1_reg2r", "q1_reg_org", "q1_org2org", "q1_org_org", "q1_reg_r"], "row0": ["ow0", "roll1", "colfrom", "ow02", "ro00", "row00", " rowfrom", "col0", "col1", "row10", "roll5", " row00", "rowfrom", " row02", "roll3", "ow10", "rollfrom", "col3", "row02", "ro02", "ro0", "col5", "ow1", "ow5", " row10", "ow00", "ro10", "roll0"], "row1": ["roll2", " rowOne", "roll1", "ry2", "ryG", "ry1", "col0", "rollG", "col1", "roll5", "col2", "rollOne", "rowOne", "rowsOne", "rowG", "col5", "rows0", "rows1", " rowG", "ry0", "roll0"], "row2": ["roll2", "server2", "roll256", "post3", "ry2", "ry02", "ow02", "block4", "roll5", "roll02", "ow6", "server3", "server6", "ry256", "block3", "post2", "row02", "row256", "ow2", "post4", "ow5", "post5", "block2", "ow256", "block5", "ow3", "ry5", "server5"], "row3": ["roll4", "ow4", "roll1", "roll5", "cell4", "block3", "cell3", "cell43", "roll3", "ry3", "roll7", "ry4", "ow7", "ow1", "ow5", "block1", "ry43", "row43", "block5", "ow3", " row43", "block7"], "row4": ["roll4", "roll2", "ow4", "row44", "ry2", "row04", "roll5", "server3", "roll44", "roll04", "rowFour", "owFour", "ow2", "ry4", "ow44", "roll49", "ry49", "ow5", " rowFour", " row44", "row49", "ry04", "ow49", "serverFour", "ow3", "server4", "server5", "ow04"], "row5": ["rollFive", "roll68", "roll45", "ry6", "ry68", "block05", "row8", "serverFive", "roll5", "ry5", "batch05", " row45", "roll25", "batch8", " row25", "server45", " row68", "row05", "batch7", "roll6", "ow7", "row45", "ow5", "row25", "ry25", "server5", "rowFive", "block8", "ow05", "ow8", "row68", "block5", " rowFive", "batch5", "block7"], "row6": ["roll4", " row8", "row9", "rollDef", "row8", "until4", "batch6", "serverSix", "ow6", " rowDef", "batch8", "server6", "rowDef", "untilDef", "until6", "rowSix", "blockSix", "roll7", "roll6", "roll8", "ow7", " row9", "server8", "batchSix", "block6", "block8", "ow8", "roll9", "block5", "batch5", "server5", "ow9"], "row7": ["rowseven", "row07", " row67", "ow4", "view07", "box77", " row07", "row9", "viewseven", "row67", "ow67", "row625", "view6", " rowseven", "batch6", "ow6", "ow77", " row625", "box625", "box7", "view7", "roll7", "batch7", "roll6", "roll67", "ow7", " row9", "row77", "batchseven", "ow625", "roll9", " row77", "batch07", "box4", "ow9"]}}
{"project": "FFmpeg", "commit_id": "e15824e75b5549e53eb5c1ffb79766321ac8d122", "target": 1, "func": "int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                          AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                          const uint8_t *buf, int len, uint16_t seq, int flags)\n\n{\n\n    int sbit, ebit, gobn, mbap, quant;\n\n    int res;\n\n\n\n    //av_log(ctx, AV_LOG_DEBUG, \"got h261 RTP packet with time: %u\\n\", timestamp);\n\n\n\n    /* drop data of previous packets in case of non-continuous (loss) packet stream */\n\n    if (data->buf && data->timestamp != *timestamp) {\n\n        h261_free_dyn_buffer(&data->buf);\n\n    }\n\n\n\n    /* sanity check for size of input packet */\n\n    if (len < 5 /* 4 bytes header and 1 byte payload at least */) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short H.261 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n      decode the H.261 payload header according to section 4.1 of RFC 4587:\n\n      (uses 4 bytes between RTP header and H.261 stream per packet)\n\n\n\n         0                   1                   2                   3\n\n         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n\n           Start bit position (SBIT): 3 bits\n\n           End bit position (EBIT): 3 bits\n\n           INTRA-frame encoded data (I): 1 bit\n\n           Motion Vector flag (V): 1 bit\n\n           GOB number (GOBN): 4 bits\n\n           Macroblock address predictor (MBAP): 5 bits\n\n           Quantizer (QUANT): 5 bits\n\n           Horizontal motion vector data (HMVD): 5 bits\n\n           Vertical motion vector data (VMVD): 5 bits\n\n\n\n    */\n\n    sbit  =  (buf[0] >> 5) & 0x07;\n\n    ebit  =  (buf[0] >> 2) & 0x07;\n\n    gobn  =  (buf[1] >> 4) & 0x0f;\n\n    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01);\n\n    quant =  (buf[1] >> 4) & 0x0f;\n\n\n\n    /* pass the H.261 payload header and continue with the actual payload */\n\n    buf += RTP_H261_PAYLOAD_HEADER_SIZE;\n\n    len -= RTP_H261_PAYLOAD_HEADER_SIZE;\n\n\n\n    /* start frame buffering with new dynamic buffer */\n\n    if (!data->buf) {\n\n        /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */\n\n        if (!gobn  && !sbit && !mbap && !quant){\n\n            res = avio_open_dyn_buf(&data->buf);\n\n            if (res < 0)\n\n                return res;\n\n            /* update the timestamp in the frame packet with the one from the RTP packet */\n\n            data->timestamp = *timestamp;\n\n        } else {\n\n            /* frame not started yet, need more packets */\n\n            return AVERROR(EAGAIN);\n\n        }\n\n    }\n\n\n\n    /* do the \"byte merging\" at the boundaries of two consecutive frame fragments */\n\n    if (data->endbyte_bits || sbit) {\n\n        if (data->endbyte_bits == sbit) {\n\n            data->endbyte |= buf[0] & (0xff >> sbit);\n\n            data->endbyte_bits = 0;\n\n            buf++;\n\n            len--;\n\n            avio_w8(data->buf, data->endbyte);\n\n        } else {\n\n            /* ebit/sbit values inconsistent, assuming packet loss */\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, len*8 - ebit);\n\n            skip_bits(&gb, sbit);\n\n            if (data->endbyte_bits) {\n\n                data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits);\n\n                avio_w8(data->buf, data->endbyte);\n\n            }\n\n            while (get_bits_left(&gb) >= 8)\n\n                avio_w8(data->buf, get_bits(&gb, 8));\n\n            data->endbyte_bits = get_bits_left(&gb);\n\n            if (data->endbyte_bits)\n\n                data->endbyte = get_bits(&gb, data->endbyte_bits) <<\n\n                                (8 - data->endbyte_bits);\n\n            ebit = 0;\n\n            len = 0;\n\n        }\n\n    }\n\n    if (ebit) {\n\n        if (len > 0)\n\n            avio_write(data->buf, buf, len - 1);\n\n        data->endbyte_bits = 8 - ebit;\n\n        data->endbyte = buf[len - 1] & (0xff << ebit);\n\n    } else {\n\n        avio_write(data->buf, buf, len);\n\n    }\n\n\n\n    /* RTP marker bit means: last fragment of current frame was received;\n\n       otherwise, an additional fragment is needed for the current frame */\n\n    if (!(flags & RTP_FLAG_MARKER))\n\n        return AVERROR(EAGAIN);\n\n\n\n    /* write the completed last byte from the \"byte merging\" */\n\n    if (data->endbyte_bits)\n\n        avio_w8(data->buf, data->endbyte);\n\n    data->endbyte_bits = 0;\n\n\n\n    /* close frame buffering and create resulting A/V packet */\n\n    res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    return 0;\n\n}\n", "idx": 3456, "substitutes": {"ctx": ["Context", "rc", "mc", "cmp", "cfg", "ct", "kt", "gc", "cp", "cc", "cf", "ck", "context", "dc", "cm", "cn", "jac", "kw", "xc", "conf", "co", "tz", "sc", "conv", "conn", "cb", "iat", "ci", "txt", "act", "cv", "obj", "tc", "pkg", "tmp", "cmd", "tx", "config"], "data": ["DATA", "present", "time", "nt", "record", "length", "metadata", "error", "cache", "definition", "next", "video", "o", "store", "al", "handle", "resp", "delete", "to", "done", "module", "writer", "request", "cmd", "db", "test", "empty", "batch", "di", "rec", "exclusive", "window", "missing", "Data", "def", "message", "command", "list", "dd", "dat", "rel", "user", "table", "debug", "no", "partial", "extra", "date", "session", "public", "details", "action", "buffer", "complete", "ata", "ad", "read", "this", "response", "p", "reader", "out", "valid", "format", "info", "name", "report", "state", "policy", "tx", "defined", "result", "de", " Data", "form", "final", "query", "self", "exec", "relation", "results", "d", "local", "parent", "connection", "accept", " DATA", "context", "image", "important", "load", "da", "zero", "device", "content", "size", "obj", "dev", "event", "update", "client"], "st": ["sam", "inst", "sth", "ist", "str", "fr", "nt", "tt", "et", "ct", "start", "ast", "rest", "ut", "est", "std", "stage", "St", "se", "ste", "ost", "sta", "sts", "sw", "mt", "ST", "sp", "sent"], "pkt": ["ppct", "pqt", "ppqt", " pck", "ppck", "Pkt", "pct", "pck", " pct", "Pqt", "Pct", "Pck", "ppkt", " pqt"], "timestamp": ["statestamp", "Timest", "typest", "Timency", "timency", "statest", "tmestamp", "stimestamp", "timest", "stiminal", "timeest", "temestamp", "momestamp", "stimeline", "momency", "timeetime", "stimency", "momeline", "statency", "Timestamp", "mominal", "tmtime", "timeency", "typestamp", "timtime", "temency", "temtime", "typity", "temetime", "timeline", "statity", "timity", "momest", "tmest", "timeestamp", "tmeline", "Timetime", "timeity", "typency", "Timtime", "tmetime", "timetime", "teminal", "timinal", "temeline", "timeeline", "temest", "Timeline"], "buf": ["iter", "ff", "aka", "length", "tr", "cur", "cache", "bn", "wb", "cf", "queue", "deg", "port", "br", "limit", "bits", "bag", "txt", "enc", "ptr", "pkg", "cmd", "pos", "prop", "test", "str", "bs", "pool", "var", "empty", "batch", "uf", "pb", "map", "window", "nom", "bed", "cam", "conv", "xff", "bu", "cb", "loc", "uv", "Buffer", "desc", "buffer", "box", "bp", "fb", "read", "rc", "np", "bin", "half", "emb", "rb", "Buff", "bar", "good", "elt", "Len", "code", "addr", "msg", "text", "cv", "tmp", "fac", "nm", "ctr", "alloc", "proc", "orig", "cap", "bytes", "b", "func", "temp", "block", "gen", "pt", "img", "mem", "bc", "ob", "arr", "doc", "ref", "act", "obj", "mb", "raw", "f", "broad", "err", "buff", "vec", "db"], "len": ["lf", "ish", "n", "lon", "el", "nl", "str", "del", "ren", "li", "length", "nt", "bytes", "cmp", "uf", "ls", "pos", "lit", "dl", "syn", "kl", "lim", " clen", "ret", "ll", "lic", "l", "mem", "offset", "L", "e", "list", " l", "elt", "fin", "num", "en", "lp", "limit", "Len", "all", "fl", "ld", "resp", "msg", "le", "loc", "t", "vec", "fn", "val", "rel", "ref", "size", "h", "SIZE", "z", "ln", "f", "sp", "err", "lan"], "seq": [" vers", " alt", " req", " resp", " cond", " count", " id", " clen", " pref", " continuation", " ver", " sequence", " enc", " spec", " pos", " cas", " typ", " trans", " rid", " frag", " ref", " nos", " sig", " next", " status", " sup", " rev", " qual"], "flags": ["flag", "mask", "options", "ents", "ags", "status", "ts", "ps", "tags", "heads", " flag", "fields", "acts", "aps", "fs", "ds", "fl", "faces", "types", "rs", "ns", "bits", "times", "args", "vals", "cs", "Flags", " options"], "sbit": [" sket", "sBit", "tsbit", "stsbyte", "sbutt", "ssbyte", "sbt", "sbug", "sbyte", " sBit", "fsbyte", " sbutt", " sbits", "tsbin", "stsbt", "sbits", "Sbit", "Schar", "lsBIT", "Sbits", " sBIT", "jsbyte", "atsbyte", "schar", "esbits", "gsbool", "lsbutt", "Sbyte", "srot", "jsbug", "lsbit", "lsbits", "atsbug", "atsket", "tsbits", "ssbits", "SBIT", "atsbit", "gsbit", "lsbyte", "ssbit", "tsbutt", "eschar", "sket", " sbug", "stsbit", "fsbits", "fsrot", "jsket", "stsBit", "gsbyte", "sbool", "lsbool", "sBIT", " sbt", " srot", "esbyte", "sschar", " sbin", " sbyte", "fsbit", "gsbutt", "sbin", "jsbit", "esbit", "Srot"], "ebit": ["ibio", "ebitt", " ebbit", "debap", "escit", "zbiter", "rebit", "ebbit", "rebith", "ebap", "ebait", "eblit", "debit", "rebio", "zebiter", "obap", " ebap", "ebiter", "debbit", "escith", "zbait", "ibith", "zbit", "obbit", "ebith", "ebio", "escio", "embitt", "ebIT", "zebitt", "rebIT", "zbitt", "deblit", "ibIT", "escIT", "embit", "embait", "obit", "oblit", "ibit", "embiter", "zebit", "zebait", " eblit"], "gobn": ["robd", "mban", "orbd", "sbn", "robns", "sbl", "mbn", "hubl", "ombmn", "ubern", "sban", "ombl", "obmn", "dbmn", "mbl", "gobns", "orbns", "robmn", "uberd", "orbn", "obl", "uberns", "gobl", "hubmn", "dban", "goban", "gobmn", "dbn", "oban", "dbl", "omban", "sbmn", "robn", "huban", "ombn", "orbmn", "obn", "gobd", "hubn", "mbmn", "ubermn"], "mbap": ["bbap", "gbaps", "ymat", "ebat", "mpapper", "embapper", "embaps", "mbapper", "ebap", "ymap", "mbat", "obmap", "gbmap", "mpache", "mpmap", "embmap", "ymapper", "bmmap", "mpat", "bbache", "obap", "mbmap", "mbaps", "bmac", "bbac", "obapper", "mbache", "ebapper", "obaps", "gbap", "ymac", "bbmap", "mbac", "bmache", "gbapper", "mpap", "mpac", "bmap", "embap", "ebac"], "quant": ["qu", "dq", "supp", "eq", "var", "prim", "q", "nt", "cmp", "shock", "mask", "volume", "mult", "series", "prof", "util", "comp", "product", "req", "uint", "stable", "aux", "percent", "buff", "pub", "gr", "frac", "qq", "bit", "qi", "mix", "serial", "fet", "iq", "qt", "quiet", "tech", "material", "txt", "alpha", "qual", "debug", "pkg", "imp", "scale", "requ", "cmd", "sim", "Quant", "vol", "fac", "compl"], "res": ["s", "proc", "resolution", " RES", "re", "RS", "mask", "results", "RES", "func", "cond", "pers", "r", "rest", "als", "ret", "ts", "ress", "ps", "req", "i", "cons", "pas", "out", "pres", " rs", "respons", "rev", "sol", "arr", "reg", "acts", " results", "ms", "reset", " ret", "ne", "os", "fs", " Res", "expr", "resp", "rs", "val", "rel", "bits", "zero", "ver", "resh", "yes", "act", "rows", "vals", "cs", "details", "js", "Res", "result", "resources", "has", "rem"], "gb": ["lib", "kb", "yg", "bs", " eg", "Gb", "gd", "bytes", "bg", "cfg", "b", "rb", " g", " rg", "gh", "gi", "rg", " db", "rl", "gc", "py", "xy", "ge", "gs", "git", "bf", "big", "gt", "g", "gif", "ig", "ng", "gu", " pg", "cb", "gio", "ghost", "nb", "bits", "sb", "pg", "GB", "bd", "hog", "cv", "mb", " gif", "gg", "tg", "gm", " rgb", " GB", "buff", "db"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int vdpau_mpeg_start_frame(AVCodecContext *avctx,\n\n                                  const uint8_t *buffer, uint32_t size)\n\n{\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    Picture *pic             = s->current_picture_ptr;\n\n    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;\n\n    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;\n\n    VdpVideoSurface ref;\n\n    int i;\n\n\n\n    /* fill VdpPictureInfoMPEG1Or2 struct */\n\n    info->forward_reference  = VDP_INVALID_HANDLE;\n\n    info->backward_reference = VDP_INVALID_HANDLE;\n\n\n\n    switch (s->pict_type) {\n\n    case AV_PICTURE_TYPE_B:\n\n        ref = ff_vdpau_get_surface_id(&s->next_picture.f);\n\n        assert(ref != VDP_INVALID_HANDLE);\n\n        info->backward_reference = ref;\n\n        /* fall through to forward prediction */\n\n    case AV_PICTURE_TYPE_P:\n\n        ref = ff_vdpau_get_surface_id(&s->last_picture.f);\n\n        info->forward_reference  = ref;\n\n    }\n\n\n\n    info->slice_count                = 0;\n\n    info->picture_structure          = s->picture_structure;\n\n    info->picture_coding_type        = s->pict_type;\n\n    info->intra_dc_precision         = s->intra_dc_precision;\n\n    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;\n\n    info->concealment_motion_vectors = s->concealment_motion_vectors;\n\n    info->intra_vlc_format           = s->intra_vlc_format;\n\n    info->alternate_scan             = s->alternate_scan;\n\n    info->q_scale_type               = s->q_scale_type;\n\n    info->top_field_first            = s->top_field_first;\n\n    // Both for MPEG-1 only, zero for MPEG-2:\n\n    info->full_pel_forward_vector    = s->full_pel[0];\n\n    info->full_pel_backward_vector   = s->full_pel[1];\n\n    // For MPEG-1 fill both horizontal & vertical:\n\n    info->f_code[0][0]               = s->mpeg_f_code[0][0];\n\n    info->f_code[0][1]               = s->mpeg_f_code[0][1];\n\n    info->f_code[1][0]               = s->mpeg_f_code[1][0];\n\n    info->f_code[1][1]               = s->mpeg_f_code[1][1];\n\n    for (i = 0; i < 64; ++i) {\n\n        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];\n\n        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];\n\n    }\n\n\n\n    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);\n\n}\n", "idx": 3460, "substitutes": {"avctx": ["avctl", "avcontext", "camctx", "avtx", "cvcontext", "Avctx", " avpkg", "Avcontext", "camtx", "vctx", "cvctx", " avcontext", "campkg", " avctl", "vcontext", "cvtx", "vctl", "avpkg", " avtx", "cvpkg", "Avtx", "camcontext", "Avctl", "vtx"], "buffer": ["binary", "length", "batch", "uf", "face", "block", "channel", "frame", "cache", "buf", "stream", "window", "screen", "context", "bf", "message", "command", "queue", "image", "file", "document", "code", "bb", "Buffer", "buff", "result", "base"], "size": ["count", " resize", "length", "bytes", " length", " scale", " Size", "w", " count", "type", "offset", "ize", "e", " n", "len", " len", " sizes", "code", "SIZE", "scale", "z", " shape", "shape", "dim", "Size"], "s": ["n", "is", "v", "ops", "parts", "fs", "ds", "bits", "sb", "h", "y", "sq", "hs", "sports", "bs", "app", "ses", "c", "status", "ims", "sv", "os", "conv", "a", "vs", "sts", "ats", "as", "z", "details", "j", "qs", "p", "sd", "ps", "comments", "sys", "less", "ss", "ms", "set", "times", "args", "sp", "sa", "m", "ex", "sam", "spec", "stats", "xs", "sym", "comm", "es", "ls", "d", "w", "ts", "its", "changes", "gs", "g", "settings", "res", "t", "ns", "rs", "serv", "ins", "S", "obj", "sw", "ess", "cs", "js", "series"], "pic": ["capt", "proc", "pict", "cap", "mc", "peg", "ct", "c", "Picture", "pr", "gc", "p", "mp", "cp", "ps", "pc", "img", "fp", "pas", "pres", "pi", "picture", "jp", "ic", "pp", "ctx", "cam", "ac", "ig", "doc", "phot", "t", "pl", "phys", "f", "sp", "Pic", "photo", "pa"], "pic_ctx": [" pic_context", "pic2tx", " pic_pkg", " pic_tx", "picture_tx", "pic_context", "picture_context", "pic_tmp", "pic2pkg", "pic2ctx", "pic_pkg", "pic2context", "picture_tmp", "picture_ctx", "pic_tx"], "info": ["open", "time", "iter", "options", "metadata", "error", "by", "cache", "history", "o", "store", "it", "success", "er", "http", "id", "ti", "off", "io", "note", "init", "app", "INFO", "ui", "status", "about", "sum", "auth", "ion", "def", "fi", "command", "list", "num", "meta", "inf", "user", "index", "debug", "edit", "details", "version", "config", "j", "data", "help", "frame", "try", "p", "ip", "create", "out", "trace", "picture", "name", "information", "all", "code", "set", "report", "ci", "state", "alias", "follow", "notice", "result", "show", "Info", "reason", "query", "exec", "summary", "item", "comment", "fo", "local", "type", "description", "check", "mem", "stat", "pi", "image", "conf", "link", "now", "lock", "progress", "f", "event", "update"], "ref": ["cmp", "re", "r", "port", "round", "br", "resp", "val", "Ref", "ptr", "id", "range", "tab", "pos", "prop", "alf", "note", "ef", "uf", "rec", " Ref", "alt", " pref", "req", " href", "tip", "prefix", "fi", "def", "rev", " reference", "cb", " rel", " offset", "rel", "eval", "index", "virt", "Reference", "aff", "tag", "use", " referenced", "href", "point", "frame", "p", "inter", " pointer", "ret", " refer", "l", " ptr", "seek", "reflect", "af", "addr", "alias", "reference", " hint", "eb", "diff", "remote", "pointer", "mem", "rf", "conf", "url", "obj", "mb", "f", "REF", "err", "label"], "i": ["li", " j", "b", "c", "di", "ia", "ii", "m", "r", "p", " bi", "ip", "v", "ij", "e", "pi", "fi", " pi", "it", " ii", "a", "si", "ci", "t", "f", "o", "j"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_decode_init_vlc(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, \n\n                 intra_MCBPC_bits, 1, 1,\n\n                 intra_MCBPC_code, 1, 1);\n\n        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, \n\n                 inter_MCBPC_bits, 1, 1,\n\n                 inter_MCBPC_code, 1, 1);\n\n        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,\n\n                 &cbpy_tab[0][1], 2, 1,\n\n                 &cbpy_tab[0][0], 2, 1);\n\n        init_vlc(&mv_vlc, MV_VLC_BITS, 33,\n\n                 &mvtab[0][1], 2, 1,\n\n                 &mvtab[0][0], 2, 1);\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rvlc_rl_inter);\n\n        init_rl(&rvlc_rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        init_vlc_rl(&rl_inter);\n\n        init_vlc_rl(&rl_intra);\n\n        init_vlc_rl(&rvlc_rl_inter);\n\n        init_vlc_rl(&rvlc_rl_intra);\n\n        init_vlc_rl(&rl_intra_aic);\n\n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_lum[0][1], 2, 1,\n\n                 &DCtab_lum[0][0], 2, 1);\n\n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_chrom[0][1], 2, 1,\n\n                 &DCtab_chrom[0][0], 2, 1);\n\n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n\n                 &sprite_trajectory_tab[0][1], 4, 2,\n\n                 &sprite_trajectory_tab[0][0], 4, 2);\n\n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n\n                 &mb_type_b_tab[0][1], 2, 1,\n\n                 &mb_type_b_tab[0][0], 2, 1);\n\n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n\n                 &h263_mbtype_b_tab[0][0], 2, 1);\n\n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n\n                 &cbpc_b_tab[0][1], 2, 1,\n\n                 &cbpc_b_tab[0][0], 2, 1);\n\n    }\n\n}\n", "idx": 3476, "substitutes": {"s": ["sg", "es", "b", "c", "d", "w", "p", "ts", "ps", "gs", "v", "e", "ss", "g", "ims", "ms", "sc", "sv", "os", "fs", "ds", "rs", "sb", "S", "sq", "cs", "js"]}}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 3484, "substitutes": {"opaque": ["oplque", "opque", "compaque", "opatile", "compque", "Opque", "Opaques", "compaques", "compula", " opatile", "oposter", "oplaque", "oaque", "oque", " opque", "Opula", "ooster", "oatile", " oposter", "oplatile", "Opaque", " opaques", "oploster", "opaques", " opula", "opula"], "offset": ["count", "length", "et", "point", "from", "error", "start", "block", "at", "seed", "pointer", "type", "pad", "into", "align", "timeout", " offsets", "oid", "attribute", "len", "seek", "shift", "area", "origin", "limit", "set", "position", "location", "addr", "op", "t", "zero", "ref", "index", "amount", "SIZE", "address", "Offset", "sp", "padding", "buffer", "o", "off", "data", "pos", "base", "slot"], "size": ["count", "length", " length", "start", "m", "p", "type", "align", "off", "ize", "e", "message", "command", "len", "name", "shift", "set", "amount", "h", "SIZE", "z", "address", "sp", "Size"], "s": ["service", "spec", "qs", "es", "b", "c", "ls", "w", "p", "ts", "ps", "gs", "v", "is", "sys", "sol", "ss", "sv", "os", "fs", "a", "sts", "rs", "t", "ns", "sb", "S", "h", "sl", "sq", "sp", "hs", "js", "aws", "sa", "m"], "n": ["count", "note", "nl", "dn", " N", " c", "gn", "nt", "an", "np", "na", "nu", "nor", " i", "c", "d", "sn", " ng", "ni", "wn", "p", "i", "ul", "l", "ind", "out", "v", "number", "x", "e", "nan", "cn", "g", "len", " l", "tn", "nc", " len", "num", "ne", "mn", "o", "en", "non", "ng", "rn", "un", "t", "ns", "fn", "N", "no", "z", "ln", "nn", " t", "nm", "none", "m", "j", "nr"]}}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    \n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    skip_bits(&s->gb, 4);\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        s->has_b_frames = 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        mpeg1_init_vlc(s);\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n", "idx": 3499, "substitutes": {"avctx": ["Avctx", "wavjac", "avereq", " avpkg", "averclient", "avcu", "abctx", "AVconn", "avedc", "averconn", "avtc", "wavctx", "avecontext", " avjac", " avconn", " avcmd", "Avtx", "abconfig", "aveclient", "avcontext", "avecmd", "AVtx", "averobj", "avercontext", "ajjac", "abclient", " avobj", "wavtx", "avercu", "aveca", "vrconn", " avcu", "avejac", "wavpkg", " avcontext", "abcontext", "averca", "averctx", "AVdc", "avpkg", "ajobj", "aveconfig", "avertx", "avca", "avconfig", "avconn", "wavcu", "abconn", "aveconn", "evcontext", "avreq", "AVctx", "avetc", "wavcontext", "avectx", "averpkg", " avtx", "avcmd", " avca", "AVcontext", "avtx", "abdc", "vrctx", " avtc", "Avconn", "avclient", "ajca", "averreq", "avercmd", "Avcontext", "avertc", "vrreq", "AVconfig", "aveobj", "avobj", "evctx", "evtx", "ajctx", "avjac", "avdc", "evjac", "vrobj", "avetx"], "buf": ["fb", "read", "seq", "bin", "bytes", "uf", "bg", "b", "rb", "pb", "block", "w", "Buff", "p", "wb", "img", "mem", "window", "out", "bc", "bf", "queue", "ctx", "xff", "cb", "msg", "nb", "text", "ref", "cv", "Buffer", "tmp", "raw", "cmd", "buffer", "buff", "data", "db"], "buf_size": [" buf_Size", " buf1SIZE", " buf1ize", "buf1Size", "buf1size", " buf1Size", "buf2ize", "buf_Size", "buf1ize", " buf_SIZE", " buf_ize", "buf_SIZE", "buf2Size", " buf1size", "buf2SIZE", "buf2size", "buf1SIZE", "buf_ize"], "s1": [" s9", "js1", "s01", "sOne", "rsone", "rs0", "ls2", "rs2", "sone", "ls1", "gs2", "gsone", "csOne", "ssOne", "nsone", "s2", " s01", "rs1", "ns1", "ses1", " sOne", "gs1", "ns2", "rs01", "sesOne", "ss1", " s0", "ss9", "s9", "ls0", "ls01", "gs01", "cs1", "ns01", "ss2", "s0", "ses2", " s2", "jsOne", "ses9"], "s": ["n", "sg", "ants", "an", "services", "ords", "r", "is", "ops", "parts", "ies", "fs", "ds", "eps", "er", "bits", "sb", "y", "h", "hs", "sports", "bs", "c", "status", "ges", "ains", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "z", "details", "ports", "qs", "p", "ps", "l", "sys", "less", "ss", "ms", "ar", "bis", "set", "params", "sm", "us", "m", "spec", "stats", "self", "comm", "summary", "es", "b", "ls", "w", "als", "ts", "its", "changes", "gs", "e", "conf", "ers", "se", "tes", "settings", "res", "rs", "ns", "t", "ins", "S", "obj", "sw", "cs", "js", "aws", "simple"], "height": ["count", "high", "hash", "length", "above", "angle", "tight", "rank", "Height", "he", "cache", "era", "bid", "huge", "chip", "history", "location", "available", "radius", "docker", "alpha", "bits", "h", "y", "padding", "range", "quality", " Height", "ih", "th", "hung", "memory", "density", "through", "window", "row", "hei", "added", "power", " heights", "host", "table", "shape", "crop", "buffer", "dim", "input", "hang", "confidence", "style", "grow", "capacity", "lat", "here", "rows", "axy", "gravity", "depth", "scroll", "visible", "ht", "resolution", "embed", "volume", "gh", "html", "sky", "title", "ows", "bottom", "size", "ty"], "i": ["phi", "iu", "I", "n", "bi", "li", "ui", "vi", "b", "c", "di", "ii", "im", "mi", "ki", "p", "\u0438", "ind", "ip", "ai", "l", "x", "e", "pi", "u", "in", "g", "zi", "ic", "me", "qi", "xi", "o", "ami", "it", "gu", "si", "ix", "ci", "print", "index", "multi", "ie", "y", "h", "f", "id", "ti", "sim", "gi", "m"], "v": ["n", "q", "vi", "vr", "b", "nv", "m", "w", "p", "av", "vt", "V", "tv", "ve", "vv", "x", "u", "e", "g", "video", "sv", "conv", "value", "vs", "ov", "vo", "ver", "vp", "cv", "uv", "h", "y", "vm", "vc", "qv", "version", "va", "ev"], "j": ["uj", "n", "bi", "jc", "q", "jump", "b", "oj", "dj", "ji", "ja", "ij", "jj", "jac", "jp", "g", "it", "jit", "kj", "aj", "h", "z", "json", "jl", "js", "J", "job", "jas"]}}
{"project": "FFmpeg", "commit_id": "d600b18f224e02f8bfc6660bfa442e7ff3fb057c", "target": 1, "func": "void ff_rfps_calculate(AVFormatContext *ic)\n{\n    int i, j;\n    for (i = 0; i<ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n        // the check for tb_unreliable() is not completely correct, since this is not about handling\n        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.\n        // ipmovie.c produces.\n        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);\n        if (st->info->duration_count>1 && !st->r_frame_rate.num\n            && tb_unreliable(st->codec)) {\n            int num = 0;\n            double best_error= 0.01;\n            for (j=0; j<MAX_STD_TIMEBASES; j++) {\n                int k;\n                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))\n                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))\n                for(k=0; k<2; k++){\n                    int n= st->info->duration_count;\n                    double a= st->info->duration_error[k][0][j] / n;\n                    double error= st->info->duration_error[k][1][j]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(j);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, \"rfps: %f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))\n                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&st->info->duration_error);\n        st->info->last_dts = AV_NOPTS_VALUE;\n        st->info->duration_count = 0;\n        st->info->rfps_duration_sum = 0;\n    }\n}", "idx": 3502, "substitutes": {"ic": ["wic", "icing", "WC", "ics", "IC", "pic", "tt", "comm", "et", "ct", "c", "lc", "ici", "ia", "tic", "ICS", "oc", "gc", "anc", "cc", "pc", "ip", "ict", "bc", "inc", "fc", "mic", "onic", "ik", "ctx", "aic", "ac", "voc", "iq", "ric", "aci", "ci", "etc", "tc", "eric", "ico", "irc", "iac", "vc", "icc", "nic", "aus"], "i": ["phi", "iu", "I", "n", "oi", "bi", "hi", "init", "li", "ui", "batch", "di", "ii", "im", "mi", "ki", "p", "inter", "ind", "ip", "is", "ai", "v", "ij", "ei", "x", "e", "pi", "fi", "in", "ini", "info", "zi", "ims", "me", "xi", "qi", "o", "ami", " ii", "a", "si", "it", "ix", "ci", "index", "multi", "ie", "y", "us", "f", "id", "ti", "sim", "gi", "ri", "m"], "j": ["uj", "n", "tr", "pr", "ind", "v", "ij", "next", "br", "it", "go", "y", "h", "json", "off", "note", "bi", "q", "jump", "_", "oj", "dj", "xy", "x", "jj", "ion", "jac", "jp", "kj", "aj", "index", "z", "jl", "sim", "vol", "jpg", "adj", "im", "je", "p", "l", "ja", "out", "bj", "jo", "jas", "el", "jc", "jack", "b", "ii", "ji", "g", "server", "jit", "obj", "js", "J", "job"], "st": ["inst", "ist", "sth", "tt", "nt", "rd", "td", "sn", "ast", "kt", "rest", "spect", "est", "std", "store", "etc", "cl", "h", "net", "str", "art", "lc", "th", "ut", "dd", "ft", "list", "stan", "sts", "ld", "cont", "mt", "irst", "ace", "ST", "add", "lo", "sim", "mont", "step", "et", "start", "kl", "lat", "ck", "mm", "stage", "ss", "must", "rt", "lt", "ost", "sta", "set", "so", "sm", "usr", "sty", "sp", "sam", "stack", "ust", "ct", "nd", "pt", "play", "ts", "sh", "stat", "St", "se", "sc", "ste", "stop", "t", "act", "obj", "sw", "storage", "ty", "tra"], "k": ["wk", "n", "ack", "ijk", "spec", "work", "UK", "K", "q", "kk", "ka", "ikk", "c", "ark", "kr", "ger", "sk", "km", "kt", "ki", "kl", "p", "unk", "kan", "ind", "ck", "v", "mk", "x", "jj", "kit", "ke", "kind", "ks", "kw", "ik", "ek", "kick", "o", "kn", "key", "ask", "ko", "tk", "ac", "kj", "kh", "uk", "it", "acc", "t", "ak", "y", "z", "kid", "ok", "m", "ku", "isk"]}}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n", "idx": 3513, "substitutes": {"s": ["n", "sg", "qs", "ses", "comm", "b", "c", "d", "w", "p", "ts", "ps", "gs", "v", "is", "e", "in", "ss", "sv", "os", "fs", "ds", "a", "sts", "t", "ns", "rs", "as", "sb", "S", "scl", "h", "sq", "cs", "js", "m"], "reg": ["tag", "sg", "str", "rc", "re", " mem", " g", " rg", "rg", "r", "rec", "ru", "ret", "gc", "sd", "req", "REG", " registry", "mem", " region", " gp", "out", "row", "gr", "disc", "sys", "eng", "Reg", "list", "g", "grid", "region", "num", "rr", "or", "ac", " r", "istry", "addr", "ric", "msg", "res", "pc", "serv", "ref", " ro", "act", "obj", "hw", "eg", "err", "red", "rem", "ro", "ex"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->sps.direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 3517, "substitutes": {"h": ["phi", "s", "ht", "hi", "hash", "dh", "help", "hm", "c", "ih", "hl", "w", "rh", "hp", "hh", "bh", "p", "he", "ha", "util", "her", "l", "v", "sh", "H", "context", "ctx", "history", "handle", "host", "kh", "t", "oh", "http", "zh", "hw", "hs", "ch", "ah"], "sl": ["phi", "sql", "service", "nl", "bl", "str", "slice", "spl", "sche", "ls", "hl", "ssl", "lit", "sn", "dl", "syn", "kl", "bh", "rl", "sel", "SL", "la", "owl", "gl", "ll", "l", "asm", "sh", "sol", "Sl", "tl", "sil", "sc", "sv", "coll", "fl", "vl", "pl", "sm", "serv", "zh", "sb", "scl", "eval", "il", "isl", "cl", "sw", "pkg", "ln", "console", "sp", "ml", "jl"], "mb_type": ["mblyclass", "mb_Type", "mblyno", "mm_type", "mblyTYPE", "mb7ype", "mb7type", "mb_class", "mblynumber", "MB_number", "mb7Type", "mb_name", "MB_TYPE", "mb_number", "mm_class", "MB_type", "mb_TYPE", "MB_name", "mb_ype", "mm_name", "mb7name", "MB_ype", "mblytype", "mm_TYPE", "MB_no", "mblyname", "mb_no", "MB_Type"], "mb_type_col": ["mb_type_Col", "mb_types_col", "mb_type2col", "mb_type2column", "mb_types_column", "mb_type2row", "mb_type_column", "mb_types_row", "mb_type2Col", "mb_types_Col", "mb_type_row"], "l1mv0": ["l1imv0", "l1mav1", "l1imvc1", "l1imvc8", "l1mva8", "l1imv4", "l1mv8", "l1mvc4", "l1mvc1", "l1mva1", "l1imvc4", "l1mva4", "l1mav8", "l1mav4", "l1mvc8", "l1mv4", "l1imvc0", "l1mva0", "l1imv8", "l1mav0", "l1imv1", "l1mvc0"], "l1mv1": ["l1imv0", "l1mav1", "l1imvc1", "l1mvc2", "l1mV1", "l1mvc1", "l1imv2", "l1mav2", "l1imvc2", "l1imvc0", "l1mav0", "l1imv1", "l1mV2", "l1mV0", "l1mvc0", "l1mv2"], "l1ref0": ["l1reference0", "l2rel1", "l1rel1", "l1re1", "l1reference1", "l1ref2", "l1re0", "l1re2", "l2rel2", "l1rel2", "l2ref2", "l1rel0", "l2ref1", "l1reference2", "l2rel0", "l2ref0"], "l1ref1": ["l0rely", "l1reference0", "l0ref2", "l1referencey", "l1rel1", "l1rem1", "l0rel1", "l1reference1", "l0rel2", "l1rem2", "l1ref2", "l1refy", "l0refy", "l0ref0", "l1rem0", "l1rel2", "l1remy", "l0rel0", "l1rely", "l1rel0", "l0ref1", "l1reference2"], "i8": ["pi4", "pi6", "i6", "pi08", " i08", "pi8", "b4", " i6", "i08", "b8", "b08", "b6"], "i4": [" i44", "i44", "int44", "int24", "ip24", "ip44", " i24", "ip4", "int4", "i24"], "ref": ["null", "rep", "ef", "point", "map", "ret", "arg", "p", "pointer", "type", "req", "mem", "row", "out", "ap", "ob", "def", "conf", "col", "br", "all", "loc", "resp", "val", "rel", "Ref", "table", "index", "obj", "mb", "f", "REF", "reference", "id", "range", "buffer", "tab", "result", "pos", "ro"], "mv": ["Mv", "MV", "mV", "rmv", "rmV", " mV", "Mav", " mav", " mvc", "rmav", "mav", "Mvc", "mvc", "rmvc"], "list": ["ist", "count", "null", "record", "flat", "LIST", "error", "i", "loop", "ind", "header", "queue", "dict", "net", "id", "range", "detail", "test", "can", "batch", "status", "array", "lists", "map", "alt", "listed", "ul", "old", "row", "L", "st", "def", "card", "pl", "cont", "table", "index", "no", "add", "chain", "line", "entry", "dl", "try", "alist", "l", "out", "number", "low", "info", "lt", "name", "all", "code", "set", "msg", "lvl", "List", "level", "result", "base", "spec", "stack", "li", "reason", "item", "page", "comment", "commit", "block", "local", "type", "parent", "feat", "stat", "e", "call", "err", "print", "back"], "C": ["CU", "I", "W", "CV", "CS", "JC", "K", "c", "Counter", "P", "G", "CP", "O", "LC", "Chain", "V", "CL", "Cache", "L", "H", "CCC", "CC", "D", "T", "E", "Q", "N", "S", "M", "DC", "R", "CT", "CA", "CR", "F", "CG"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,\n\n        unsigned size)\n\n{\n\n    GemState *s = (GemState *)opaque;\n\n    uint32_t readonly;\n\n\n\n    DB_PRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val);\n\n    offset >>= 2;\n\n\n\n    /* Squash bits which are read only in write value */\n\n    val &= ~(s->regs_ro[offset]);\n\n    /* Preserve (only) bits which are read only in register */\n\n    readonly = s->regs[offset];\n\n    readonly &= s->regs_ro[offset];\n\n\n\n    /* Squash bits which are write 1 to clear */\n\n    val &= ~(s->regs_w1c[offset] & val);\n\n\n\n    /* Copy register write to backing store */\n\n    s->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n", "idx": 3521, "substitutes": {"opaque": [" opcache", "opcache", "opque", "iopent", "compaque", "iopaques", "compque", "iopacity", "opent", "compaques", "opacity", "bitaque", "obent", "compcache", " opque", "bitaques", "obaque", " opent", " opacity", "obaques", "bitcache", "bitque", " opaques", "opaques", "obacity", "iopaque"], "offset": ["count", "slice", "length", "secondary", "error", "attribute", "next", "scope", "origin", "value", "location", "kh", "primary", "ptr", "lag", "address", "padding", "range", "tab", "off", "pos", "OFF", "empty", "prototype", "alt", "memory", "xy", "window", "row", "len", "bit", "os", "ta", "table", "index", "mt", "option", "buffer", "attr", "needed", "point", "style", "start", "height", "optional", "field", "trace", "template", "seek", "ctx", "key", "set", "addr", "position", "op", "adjusted", "priority", "Offset", "sp", "reference", "scroll", "alloc", "slot", "locked", "flag", "frequency", "pointer", "timeout", "mounted", "peer", "locking", "shift", "reset", "layout", "t", "ref", "atomic", "linked", "o", "owner"], "val": ["count", "ival", "hash", "lit", "pr", "ve", "ind", "late", "v", "crit", "al", "value", "it", "fee", "alpha", "vec", "txt", "il", "bool", "role", "pos", "Value", "prop", "test", "bl", "empty", "var", "status", "util", "alt", "bal", "sel", "buf", "req", "xy", "echo", "x", "def", "len", "bit", "num", "mix", "loc", "rel", "eval", "oval", "index", "ver", "vals", "pre", "fail", "typ", "buffer", "vol", "data", "lib", "VAL", "bin", "new", "ret", "p", "arg", "inter", "cal", "valid", "elt", "reg", "ctx", "key", "aval", "rot", "pri", "tx", "slot", "cho", "eq", "func", "values", "block", "pt", "local", "type", "vt", "mem", "conf", "pol", "res", "serv", "Val", "ref", "zero", "dev", "err", "label", "update", "rol"], "size": ["count", "VAL", "length", "bytes", " length", " count", "type", "mem", "v", " pos", " flag", "len", " len", " whence", "value", "fee", " sig", "SIZE", " slot", "Size", "data", "slot"], "s": ["sam", "ports", "spec", "stats", "xs", "bs", "qs", "ses", "comm", "services", "es", "ls", "ssl", "states", "als", "ges", "ts", "its", "ps", "changes", "gs", "is", "sys", "sol", "less", "ss", "conf", "ims", "ms", "se", "sis", "sv", "os", "ies", "store", "fs", "ds", "eps", "set", "vs", "bis", "sts", "ats", "params", "gets", "t", "rs", "ns", "sm", "bits", "sb", "S", "ins", "serv", "rates", "sw", "session", "h", "obj", "sl", "sq", "cs", "hs", "details", "aunts", "js", "as", "m"], "readonly": ["edall", "Readflag", " readalways", "readyonly", " readwith", "readflag", "ridealways", "Readall", "readableonly", "edonly", "readerOnly", "readwith", "readOnly", "readmore", "readystatus", "readableenabled", "readablealways", " readstatus", "readenabled", "Readwith", " readflag", "ReadOnly", " readall", "readymore", " readenabled", "edwith", "readall", "readalways", "readableOnly", "readablestatus", "edOnly", " readOnly", " readmore", "readablemore", "Readonly", "rideonly", "rideOnly", "rideenabled", "readeronly", "readstatus", "readerflag", "readyOnly"], "phy_addr": ["phy_edge", "phy67edge", "pha67edge", "phy_mac", "phy67addr", "phy\u043dmac", "pha_adr", "pha_url", "phy_int", "phy\u043durl", "pha_addr", "phy___address", "phy____address", "phy___int", "ph_addr", "phone\u043dmac", "phy___adr", "phy67adr", "pha67url", "phy\u043dadr", "pha67addr", "phy\u043dloc", "ph_adr", "phone_addr", "ph_int", "pha_edge", "phy____adr", "ph_address", "phy\u043dedge", "phy_address", "phy\u043daddr", "pha67adr", "phone\u043dloc", "phy____addr", "phy_loc", "phone\u043daddress", "phone_mac", "phy\u043daddress", "phy_url", "phy67url", "phy___addr", "phone_address", "phy____int", "phy_adr", "phone\u043daddr", "phone_loc"], "reg_num": [" reg_ref", "regjref", " reg_number", "reg_ref", "regjno", "reg_no", "reg_number", " reg_no", "regjnum", "regjnumber"]}}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "void cpu_loop(CPUMIPSState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr, ret;\n\n    unsigned int syscall_num;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_mips_exec(env);\n\n        switch(trapnr) {\n\n        case EXCP_SYSCALL:\n\n            syscall_num = env->active_tc.gpr[2] - 4000;\n\n            env->active_tc.PC += 4;\n\n            if (syscall_num >= sizeof(mips_syscall_args)) {\n\n                ret = -ENOSYS;\n\n            } else {\n\n                int nb_args;\n\n                abi_ulong sp_reg;\n\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n\n\n\n                nb_args = mips_syscall_args[syscall_num];\n\n                sp_reg = env->active_tc.gpr[29];\n\n                switch (nb_args) {\n\n                /* these arguments are taken from the stack */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                case 8: get_user_ual(arg8, sp_reg + 28);\n\n                case 7: get_user_ual(arg7, sp_reg + 24);\n\n                case 6: get_user_ual(arg6, sp_reg + 20);\n\n                case 5: get_user_ual(arg5, sp_reg + 16);\n\n                default:\n\n\n\n                ret = do_syscall(env, env->active_tc.gpr[2],\n\n                                 env->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n", "idx": 3540, "substitutes": {"env": ["gov", "dn", "email", "erv", "man", "org", "erd", "cur", "cp", "ve", "era", "te", "shell", "ei", "v", "queue", "en", "conn", "ov", "er", "txt", "enc", "ie", "setup", "ent", "hw", "console", "erb", " environment", "test", "app", "Environment", "init", "ef", "editor", "worker", "environment", "req", "buf", "window", "st", "esc", "ami", "viron", "vs", "cb", "operator", "don", "vp", "uv", "desc", "buffer", "config", "em", "ext", "ew", "et", "engine", "rb", "entry", "nv", "eni", "ec", "inv", "here", "estate", "ctx", "code", "set", "manager", "addr", "den", "gear", "cv", "eb", "ten", "enter", "w", "vt", "context", "e", "client", "oe", "conf", "sc", "network", "doc", "server", "end", "ev", "t", "serv", "ner", "obj", "dev", "sw", "ee", "event", "ah", "db"], "info": ["Info", "init", "INFO", "diff", "help", "metadata", "error", "status", "entry", "ii", "about", "by", "fo", "rec", "try", "cache", "py", "local", "type", "check", "xy", "i", "auth", "admin", "ote", " Info", "is", "bar", "stat", "fi", "def", "list", "conf", "rt", "t", "result", "history", "information", "ci", "now", "state", "inf", "lock", "http", "index", "zero", "txt", " inf", "no", "table", "tab", "obj", "f", "unknown", "tx", "id", "details", "ti", "notice", "data", "base"], "trapnr": ["trapnos", " trapNR", "trapctr", "tipnr", "trapNR", "trapbyter", "tipNR", "trapnum", " trapnum", "trino", " trapbyter", "tapbyter", "tripnr", "tapnr", "tipctr", "trapno", "trinum", "tapNR", "tipbyter", "tripNR", "tripnos", "triNR", "tapnos", "tapno", "tripno", " trapctr", " trapnos", " trapno", "tapnum", "trinr", "tapctr"], "ret": ["rets", "nt", "re", "tr", "lit", "rest", "ll", "rm", "ne", "conn", "success", "it", "resp", "Ret", "val", "txt", "ptr", "net", "cmd", "alf", "jump", "status", "alt", "pret", "fi", "def", "rev", "gt", "ft", "jp", "len", "ter", "tn", "num", "cont", "mt", "xt", "desc", "lib", "ext", "get", "nz", "over", "Return", "try", "arg", "out", "rt", "elt", "lt", "all", "addr", "RET", "usr", "tmp", "result", "reply", "flag", "nl", "det", "mem", "fun", "arr", "fin", "reset", "url", "res", "t", "RT", "ref", "mb", "err", "back"], "syscall_num": ["sysall_number", "syscall_n", "syscall1nr", "syscall_Num", "syscallablenum", "syscall2no", "syscallablenumber", "syscall1Num", "syscall_number", "syscall1no", "syscall_NUM", "sysall_NUM", "sysall_Num", "sysall_nr", "syscall1num", "sysall_no", "syscall2number", "syscallableNUM", "syscall_nr", "syscallablen", "sysall_num", "sysall_n", "syscall_no", "syscall2n", "syscall2num"], "nb_args": ["nb_pres", "np_gs", "bj_args", "nb_arg", "np__gs", "np__args", "nie_vals", "nbwargs", "np_ants", "bj_tags", "nb\u0648changes", "nb\u0648args", "nie_ants", "nb\u0648tags", "nbwants", "nie_pres", "nb__gs", "np__ants", "nb\u0648arr", "nb__ants", "nb__args", "nb_arr", "nb__arg", "nie_args", "nb_changes", "nb_vals", "bj_arr", "nb_gs", "np__arg", "nb_tags", "bj_changes", "np_arg", "np_args", "nbwpres", "nbwvals", "nb_ants"], "sp_reg": ["sp55prom", "sp64reg", "sp__addr", "sp_register", "snap_Reg", " sp_ref", " sp_addr", "sp_num", " sp_rand", " sp_register", "sp_prom", "sp_ref", " sp_pre", "sp64rand", " sp_prom", "snaplReg", "sp_pre", "sp_rm", "sp5ref", "sp5register", "snaplregister", "sp_Reg", "snapladmin", "sp32admin", "sp_REG", "sp64ref", "sp1Reg", "sp5REG", "sp1mem", " sp_REG", "sp5conn", "splreg", " sp_Reg", "sp1reg", "snap_register", "sp__reg", "snap_reg", "sp55pre", "sp5rand", "splReg", "sp_mem", "sp64register", "splregister", "sp2reg", "sp_conn", "sp1num", " sp_num", "sp2mem", "sp55ref", "spladmin", "snap_admin", "sp32reg", " sp_conn", "sp32Reg", "sp55reg", "sp_addr", "sp_admin", "sp2Reg", "sp32register", "sp__REG", " sp_mem", "sp2num", "sp__rm", "snaplreg", "sp5reg", "sp_rand", " sp_rm"]}}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n", "idx": 3551, "substitutes": {"s": ["n", "stats", "bs", "qs", "q", "comm", "es", "b", "c", "ls", "d", "p", "ts", "its", "gs", "v", "is", "sys", "ss", "conf", "ms", "sc", "sv", "os", "acs", "ds", "fs", "a", "sts", "ats", "t", "ns", "rs", "as", "sb", "S", "ins", "h", "sq", "f", "cs", "hs", "aws", "js", "ex"], "stream_index": ["stream2index", "stream_Index", " stream_data", "streamityind", "channel_id", "stream_id", "streamityno", " stream_ind", " stream_no", "stream2id", "stream_no", " stream_point", "channel_ind", "stream_point", "channel_index", "streamityIndex", "stream2ind", "streamityindex", "streamitydata", "stream_data", " stream_Index", "channel_Index", "streamitypoint", "stream2Index", "stream_ind"], "timestamp": ["Timest", "transformesta", "transformest", "Timension", "timest", "timeest", "imestamp", "Timestamp", "imesta", "transformetime", "imest", "extest", "timeline", "extension", "exteline", "transformestamp", "timeestamp", "Timetime", "Timesta", "timeension", "timetime", "extestamp", "timeeline", "timesta", "timension", "Timeline", "imetime"], "flags": ["flag", " compression", "FLAG", " fmt", "options", "mask", "style", "ags", "status", "ts", "fps", "ps", "tags", "fp", "cf", " flag", "fields", "ms", " whence", "fs", "Flag", "bits", "fd", "args", "frames", "lag", "Flags", " options"], "tmv": ["tmvs", "tcv", "ttvs", "mtm", "mtl", "htmj", "htmq", "tmf", "mtx", "htmvs", "mxav", "tomq", "tmj", "mtapter", "html", "tcl", "tkf", "mxv", "temvs", "ttav", "tkj", "gmv", "mtv", "htmav", "tkv", "tml", "temj", "mtvs", "gmav", "temav", "htmx", "tmvt", "tomv", "ttv", "gmvt", "htmapter", "mxvs", "temf", "tcj", "mtq", "tmav", "mtav", "htmm", "tkm", "temm", "tmq", "tomm", "mtj", "temv", "tomapter", "temx", "tmm", "tcvs", "htmv", "ttvt", "gmvs", "htmf", "tmx", "tmapter", "mxvt"], "pos": ["pro", "spec", " Pos", "bs", "length", "nos", "start", "at", "pt", "pose", "p", "ts", "pointer", "ps", "pc", "l", "offset", "pres", "pi", "tz", "len", "Position", "port", "os", "oss", "limit", "doc", "trans", "position", "neg", "loc", "estamp", "res", "t", "val", "rot", "POS", "size", "index", "us", "tmp", "Pos", "pid", "sp", "add", "o", "off", "po", " position", "top"]}}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;", "idx": 3555, "substitutes": {"opaque": ["popaque", "boacity", "opque", " opus", "Opacity", "Opque", "popaques", "Opaques", "opacity", "Opus", "oaques", "oaque", "popacity", " opque", "opaco", "bous", "popaco", "boque", " opacity", "oacity", "opus", "Opaque", "opaques", "oaco", "Opaco", "boaque"], "addr": ["ad", "ack", " cur", "attr", "ag", " err", "att", "at", "r", "arg", "pad", "on", " address", " ip", "align", "offset", "Address", " ptr", "prefix", " add", "name", "ar", "ctx", " loc", "adr", "host", "a", "loc", "to", "res", "rs", " aid", "alias", " ax", "obj", "ptr", "dr", " a", " pad", "address", "add", "id", "tx", "pos", "alloc", " mac"], "val": ["au", "test", " ty", " v", "VAL", " resp", " serv", " al", " arg", "lit", " needle", " eval", "util", " fut", " amount", "sel", "local", " valid", "buf", "vt", "mem", "out", "v", "valid", "x", " seq", " inval", "bit", "ctx", " ret", "value", " aval", "serv", "Val", " value", " el", " tx", " update", "eval", " vel", "vals", "dev", " upd", " msg", "tx", " lac", "buffer", " x", "vol", "data", "Value"], "size": ["n", "count", "cap", "length", "c", "m", "w", "sum", "type", "align", "l", "mem", "offset", "v", "ize", "len", "name", "num", "set", "loc", "args", "h", "SIZE", "z", "address", "sp", "Size"], "s": ["n", "ses", "c", "ssl", "ls", "p", "ts", "ps", "i", "gs", "is", "sol", "less", "ss", "sis", "os", "ds", "a", "sts", "t", "rs", "sm", "ns", "state", "sb", "S", "soc", "ess", "sq", "sl", "hs", "sp", "sa", "o", "j"]}}
{"project": "FFmpeg", "commit_id": "3d5822d9cf07d08bce82903e4715658f46b01b5c", "target": 1, "func": "static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,\n\n                                  Jpeg2000CodingStyle *codsty,\n\n                                  Jpeg2000ResLevel *rlevel, int precno,\n\n                                  int layno, uint8_t *expn, int numgbits)\n\n{\n\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    int cwsno;\n\n\n\n    if (layno < rlevel->band[0].prec[precno].decoded_layers)\n\n        return 0;\n\n    rlevel->band[0].prec[precno].decoded_layers = layno + 1;\n\n\n\n    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {\n\n        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {\n\n            s->g = tile->tile_part[++(*tp_index)].tpg;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)\n\n        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);\n\n\n\n    if (!(ret = get_bits(s, 1))) {\n\n        jpeg2000_flush(s);\n\n        return 0;\n\n    } else if (ret < 0)\n\n        return ret;\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n\n            band->coord[1][0] == band->coord[1][1])\n\n            continue;\n\n        nb_code_blocks =  prec->nb_codeblocks_height *\n\n                          prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            int incl, newpasses, llen;\n\n\n\n            if (cblk->npasses)\n\n                incl = get_bits(s, 1);\n\n            else\n\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n\n            if (!incl)\n\n                continue;\n\n            else if (incl < 0)\n\n                return incl;\n\n\n\n            if (!cblk->npasses) {\n\n                int v = expn[bandno] + numgbits - 1 -\n\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n\n                if (v < 0 || v > 30) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"nonzerobits %d invalid or unsupported\\n\", v);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                cblk->nonzerobits = v;\n\n            }\n\n            if ((newpasses = getnpasses(s)) < 0)\n\n                return newpasses;\n\n            av_assert2(newpasses > 0);\n\n            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {\n\n                avpriv_request_sample(s->avctx, \"Too many passes\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((llen = getlblockinc(s)) < 0)\n\n                return llen;\n\n            if (cblk->lblock + llen + av_log2(newpasses) > 16) {\n\n                avpriv_request_sample(s->avctx,\n\n                                      \"Block with length beyond 16 bits\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            cblk->lblock += llen;\n\n\n\n            cblk->nb_lengthinc = 0;\n\n            cblk->nb_terminationsinc = 0;\n\n            do {\n\n                int newpasses1 = 0;\n\n\n\n                while (newpasses1 < newpasses) {\n\n                    newpasses1 ++;\n\n                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {\n\n                        cblk->nb_terminationsinc ++;\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)\n\n                    return ret;\n\n                if (ret > sizeof(cblk->data)) {\n\n                    avpriv_request_sample(s->avctx,\n\n                                        \"Block with lengthinc greater than %\"SIZE_SPECIFIER\"\",\n\n                                        sizeof(cblk->data));\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                cblk->lengthinc[cblk->nb_lengthinc++] = ret;\n\n                cblk->npasses  += newpasses1;\n\n                newpasses -= newpasses1;\n\n            } while(newpasses);\n\n        }\n\n    }\n\n    jpeg2000_flush(s);\n\n\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n\n            bytestream2_skip(&s->g, 2);\n\n        else\n\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found. instead %X\\n\", bytestream2_peek_be32(&s->g));\n\n    }\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {\n\n                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]\n\n                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4\n\n                ) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                        \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\",\n\n                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);\n\n                cblk->length   += cblk->lengthinc[cwsno];\n\n                cblk->lengthinc[cwsno] = 0;\n\n                if (cblk->nb_terminationsinc) {\n\n                    cblk->nb_terminationsinc--;\n\n                    cblk->nb_terminations++;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data_start[cblk->nb_terminations] = cblk->length;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 3561, "substitutes": {"s": ["sam", "service", "n", "sg", "spec", "stats", "self", "services", "comm", "es", "b", "c", "src", "ssl", "ls", "d", "w", "p", "ts", "its", "ps", "i", "changes", "gs", "v", "is", "sys", "e", "socket", "in", "less", "ss", "g", "conf", "se", "space", "ims", "source", "sv", "os", "sc", "store", "fs", "ds", "bis", "set", "settings", "sts", "t", "ns", "rs", "serv", "sb", "S", "session", "sw", "span", "h", "sl", "sq", "f", "cs", "request", "js", "sim", "m", "j", "sort"], "tile": ["ile", "tp", "google", "tle", "slice", "target", "layer", "unit", "TI", "metadata", "cell", "texture", "frame", "ite", "map", "sel", "vt", "Tile", "te", "tip", "header", "template", "title", "chip", "pixel", "grid", "file", "league", "nil", "tif", "t", "piece", "fit", "table", "tf", "skill", "plane", "tc", "feature", "mate", "phy", "lay", "ti", "complete", "detail"], "tp_index": ["txt_node", "txt67info", "npaxymax", "tpaxyIndex", "TP_num", "np_number", "tp2ind", "TP_index", "tp67index", "tpptnode", "np_index", "tp67info", "np_Index", "tp2num", "TP_number", "tp2number", "tp67amount", "txt67amount", "npaxyindex", "tp_max", "tp_info", "tpznum", "tp67node", "npaxynumber", "tp2index", "tpaxynumber", "tpaxymax", "npaxyIndex", "tpptinfo", "np_max", "tp_node", "tpptamount", "tp_number", "tpznumber", "tp_amount", "txt67node", "txt_index", "tpzindex", "tpzind", "TP_ind", "txt67index", "txt_amount", "tp_num", "tpaxyindex", "tp_ind", "txt_info", "tpptindex", "tp_Index"], "codsty": ["Codstyle", " codestyle", "odsty", "Codestyle", "codestyle", "odestyle", "codestyles", "odestyles", "codstyle", "Codsty", " codestyles", "Codestyles", " codstyle", "odstyle"], "rlevel": ["clayer", "rtserver", "rtlevel", "clvl", "srwall", "lvel", "rvel", "hvel", " rbuffer", "nrserver", "llvl", "clevel", "srlimit", "rtscope", "vrlimit", "rrwindow", "vrvel", "rscope", "rbuffer", " rserver", "rrlevel", "vrlvl", "rserver", "hlimit", "rdlevel", "rdwindow", "rlvl", "rtbuffer", "nrscope", "nrlevel", "rlevels", "rwindow", "rwall", "rlimit", "vrwall", "hlvl", " rlevels", " rlayer", " rlvl", "hlevel", "hlayer", "srlevels", "climit", " rlimit", "rrlvl", "vrlevel", " rwall", "vrlevels", " rwindow", "nrbuffer", " rscope", "hlevels", "srlevel", "rdlvl", "llevel", "rlayer", "llevels"], "precno": ["PrecNo", "prefna", "pricNo", "notecno", "predyes", "prefcNO", "notecmajor", "prefcyes", "Precno", "preveno", "prercorno", "precmajor", "prfstable", "prescorno", "PrefNO", "prekno", "prercna", "precunit", "precorno", "prikeno", "prevno", "notecunit", "predNo", "prescno", "prevNO", "prefNO", "Preceno", "prercstable", "prelcna", "precyes", "PrecNO", "notecorno", "pricyes", "prekeno", "preporno", "notepmajor", "precNO", "prefstable", "prercmajor", "prefeno", "prikno", "prescunit", "prefceno", "prepmajor", "prfno", "precstable", "pricno", "prefcNo", "preceno", "prevNo", "prercunit", "prelcstable", "prcstable", "precNo", "prescmajor", "prikyes", "prcno", "predno", "prefno", "precna", "prcna", "prercno", "notepunit", "Prefno", "prelcno", "PrefNo", "prepno", "prekNo", "Prefeno", "prefNo", "noteporno", "prikNo", "prekyes", "predeno", "prfna", "prefcno", "notepno", "prepunit", "priceno"], "layno": ["layerno", "Laybo", "rowko", "laynum", "bandko", "layoutno", "aynone", "ayno", "playko", "playnumber", "aybo", "bandbo", "layNO", "layoutNO", "layerNO", "rowNO", "layernum", "bandnone", " layNO", "layoutnumber", "bandnum", " laynum", "layerko", "laynumber", "laynone", "laybo", "Layno", "rownumber", "playNO", "layoutko", "playno", "layko", "rowno", "bandNO", "Laynone", " layko"], "expn": ["defN", "respnum", "respn", "xpn", "xpnum", "xpN", "defn", "expno", "defno", "expN", "respno", "xpno", "expnum", "defnum", "respN"], "numgbits": ["umbergitems", "numGits", "numgcits", "umbergcbytes", "umbergits", "numgcbits", "umbergcits", "umbergcbits", "numgitems", "numgmitems", "umbergbits", "numGbytes", "numgcitems", "numgmits", "numgmbytes", "umbergcitems", "numGbits", "numgmbits", "numgcbytes", "numgits", "numgbytes", "umbergbytes", "numGitems"], "bandno": ["laygo", "bandwa", "bandna", "boardno", "diskid", " bandne", "brandeno", "bandNo", "boardwa", "Bandeno", "batchko", "bandid", "bandko", "BandNO", " bandnumber", "layNO", "roadeno", "bandeno", "bandne", "batchgo", "layid", "branddo", "roadnumber", "broadname", " bandwa", " bandNO", "brandwa", "batchno", "bandname", " banddo", "brandna", "broadne", "diskko", "boarddo", " bandna", "roadno", "layko", "brandnumber", "layNo", "bandNO", "bandgo", "layeno", "Bandno", "BandNo", " bandname", "diskgo", " bandeno", "brandno", "broadno", "bandnumber", "roadna", "diskno", "batchid", "diskname", "banddo", "diskne", " bandNo"], "cblkno": ["cclkno", "cblkidnumber", "cblkeeno", "cbrkno", "cblikno", "cbljNo", "cbleknum", "cbrknumber", "cblklnumber", "cblknos", "cblckNo", "cbrkidno", "cblunkano", "cbrkstro", "cbrkidnos", "cblunkNo", "cblkidnum", "cbljeno", "cbrkidstro", "cbljano", "cblkNo", "cblklstro", "cblklno", "cblkeno", "cbliknos", "cblknum", "cblkidno", "cblkstro", "cblekNo", "cblkideno", "cblakeno", "cclkname", "cbrkidnumber", "cblkidnos", "cblklnos", "cblknumber", "cclakno", "cblunkno", "cblckeno", "cblkano", "cblckNO", "cblikstro", "cblkidNo", "cblkname", "cblkeNo", "cBlknum", "cblekno", "cclakname", "cblekNO", "cblckno", "cbrknos", "cclkeno", "cblckano", "cbliknumber", "cblkidstro", "cblkenum", "cbljno", "cblakno", "cBlkNO", "cBlkno", "cblakname", "cblcknum", "cBlkNo", "cblkNO", "cblkidname", "cblunkeno", "cclakeno"], "ret": ["flag", "nl", "ext", "rets", "det", "nz", "final", "nt", "et", "re", "status", "try", "gc", "alt", "arg", "pret", "ll", "out", "fun", "rm", "def", "format", "ft", "gt", "arr", "rt", "elt", "lt", "len", "fin", "reset", "mel", "reg", "success", "dt", "it", "resp", "Ret", "RET", "res", "t", "val", "txt", "ref", "bool", "obj", "mt", "net", "pert", "red", "fail", "result", "got", "back", "rem"], "nb_code_blocks": ["nb_code2lines", "nb_line_blocks", "nb_code_cells", "nb_codewblock", "nb_code67Blocks", "nb_co_blocks", "nb_Code_Blocks", "nb_codewunits", "nb_line2codes", "nb_code67blocks", "nb_code2block", "nb_code_Blocks", "nb_codewblocks", "nb_co_units", "nb_code2codes", "nb_co_block", "nb_code_units", "nb_codeblockblocks", "nb_code_ops", "nb_line2blocks", "nb_line2lines", "nb_code2blocks", "nb_code_lines", "nb_codeblockcodes", "nb_code2units", "nb_line_codes", "nb_co_cells", "nb_Code_ops", "nb_code_codes", "nb_Code_blocks", "nb_line_lines", "nb_code2cells", "nb_code67ops", "nb_codewcells", "nb_codeblocklines", "nb_code_block"], "cwsno": [" crsno", "cwsna", "cbsna", " cwsna", " crsNo", "crsna", " cwsNo", "cwsNo", "cwtno", "crsno", " crsna", "cbsNo", "crsNo", "cwtNo", "cwtna", "cbsno"], "band": ["bound", "bridge", "bright", "ble", "ber", "plugin", "br", "part", "bb", "module", "amber", "lag", "well", "range", "mode", "raid", "binary", "batch", "comb", "album", "array", "pair", "bolt", "bor", "brid", "window", "iband", "plug", "command", "power", "bed", " brick", "pixel", "bit", "group", "bands", "cand", "road", "bart", "version", "chain", "box", "line", "tag", "bin", "frame", "channel", "field", "stage", "co", "low", "brand", " limb", "node", "bank", "rad", "disk", "feature", " Band", "BW", "level", "fine", "station", " bands", "Band", "flag", "pipe", "dom", "work", "filter", "be", "b", "byte", "flash", "block", "beam", "word", "ring", "bd", "cast", "broad", "bo", "db"], "prec": ["prov", "pref", "PREuc", "preuc", "PREv", "Prec", "calc", "rech", "prci", "blef", " preb", "Preuc", "blec", "pec", "priv", "prics", " prepc", "calf", " prek", "metco", " preuc", "blepc", "pef", "porc", "prof", "rec", " pref", "prif", "prip", "porf", "PREc", "Pref", " prech", "Preac", "metf", "Prepc", "reco", "metc", "Preb", "blek", "calpc", "prek", "Prev", "preco", "prc", "PREf", "PREk", "preac", " preco", "prf", "calco", "pech", "prp", "preb", "PREac", "preci", "precs", " preac", "PREb", "porci", "peco", "Precs", "proc", "prep", "porp", " prev", "prech", "prepc", "pric", "prev", "prici", "ref", "metpc", "Preco", "procs", "Prek"], "cblk": ["cblkt", "lbrkt", "cbrks", "cblek", "lbrv", "cbrk", "cclk", "cclkt", "lblkt", "cblockks", "cbrek", "cblockv", "lblv", "lblks", "cblockk", "cbrv", "cbreek", "cbrekt", "cclv", "cblockkt", " cblkt", "lblk", "cclks", "cbreck", "cblck", "lbrks", "cbrck", "cblv", " cblck", " cblek", "cbrkt", "lbrk", "cblks"], "incl": [" inbytes", " in8", "out_", "inbytes", "in_", "in8", "In8", "outbytes", "Inbytes", "out8", "In_", " in_"]}}
{"project": "qemu", "commit_id": "bba4e1b591531c087fce4ae501dc1ca299d8fb42", "target": 1, "func": "static void curses_refresh(DisplayChangeListener *dcl)\n\n{\n\n    int chr, nextchr, keysym, keycode, keycode_alt;\n\n\n\n    curses_winch_check();\n\n\n\n    if (invalidate) {\n\n        clear();\n\n        refresh();\n\n        curses_calc_pad();\n\n        graphic_hw_invalidate(NULL);\n\n        invalidate = 0;\n\n    }\n\n\n\n    graphic_hw_text_update(NULL, screen);\n\n\n\n    nextchr = ERR;\n\n    while (1) {\n\n        /* while there are any pending key strokes to process */\n\n        if (nextchr == ERR)\n\n            chr = getch();\n\n        else {\n\n            chr = nextchr;\n\n            nextchr = ERR;\n\n        }\n\n\n\n        if (chr == ERR)\n\n            break;\n\n\n\n#ifdef KEY_RESIZE\n\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n\n        if (chr == KEY_RESIZE) {\n\n            clear();\n\n            refresh();\n\n            curses_calc_pad();\n\n            curses_update(dcl, 0, 0, width, height);\n\n            continue;\n\n        }\n\n#endif\n\n\n\n        keycode = curses2keycode[chr];\n\n        keycode_alt = 0;\n\n\n\n        /* alt key */\n\n        if (keycode == 1) {\n\n            nextchr = getch();\n\n\n\n            if (nextchr != ERR) {\n\n                chr = nextchr;\n\n                keycode_alt = ALT;\n\n                keycode = curses2keycode[nextchr];\n\n                nextchr = ERR;\n\n\n\n                if (keycode != -1) {\n\n                    keycode |= ALT;\n\n\n\n                    /* process keys reserved for qemu */\n\n                    if (keycode >= QEMU_KEY_CONSOLE0 &&\n\n                            keycode < QEMU_KEY_CONSOLE0 + 9) {\n\n                        erase();\n\n                        wnoutrefresh(stdscr);\n\n                        console_select(keycode - QEMU_KEY_CONSOLE0);\n\n\n\n                        invalidate = 1;\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (kbd_layout) {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS)\n\n                keysym = curses2keysym[chr];\n\n\n\n            if (keysym == -1) {\n\n                if (chr < ' ') {\n\n                    keysym = chr + '@';\n\n                    if (keysym >= 'A' && keysym <= 'Z')\n\n                        keysym += 'a' - 'A';\n\n                    keysym |= KEYSYM_CNTRL;\n\n                } else\n\n                    keysym = chr;\n\n            }\n\n\n\n            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n\n            if (keycode == 0)\n\n                continue;\n\n\n\n            keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n\n            keycode |= keycode_alt;\n\n        }\n\n\n\n        if (keycode == -1)\n\n            continue;\n\n\n\n        if (qemu_console_is_graphic(NULL)) {\n\n            /* since terminals don't know about key press and release\n\n             * events, we need to emit both for each key received */\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = curses2qemu[chr];\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n", "idx": 3582, "substitutes": {"dcl": ["rcl", "rscl", "dscl", "sdcl", "dCL", "dCl", " dscl", " dCL", " dCl", "dwl", "dbwl", "rCL", "dsCl", "sdwl", "sdCL", "dbcl", "dsscl", "dsCL", " dwl", "dbCl", "sdCl", "dbCL", "rCl"], "chr": ["ichr", "Chn", "chrb", "chedr", "chedR", "achrc", "achbr", "actsr", "cheer", "ichar", "chedrl", "echrb", "achar", "achry", "echrar", "Chrc", "ChR", "echR", "chrn", "Chsr", "chers", "schrt", " chc", "anchrc", "shr", "chrt", "achsr", "icher", "acherr", "actn", " cher", "chear", "chec", "schbr", "actr", "echrs", "anchar", "cherrb", "chedrar", "schar", "shrs", "chrc", "cherc", "chtr", "chrg", "schR", "chrs", "shR", "chg", " chrt", "echg", "chermr", "thrb", "actrb", "shry", " chrc", "thrc", "achc", "chn", "chrar", "chsr", "thr", "achtr", "chnR", "achn", "echry", "echrl", "echr", "chern", "chR", " chry", "cherr", "ichrg", "ichR", "echrc", "achr", "anchr", "chert", "achrt", "schr", "echtr", "chrl", " chrn", "chc", "echar", "ichg", "schrg", " chrg", "schrc", "Chrb", "cherrc", "chertr", "icherr", "chbr", "cherar", "chery", "chnrar", "anchrt", "echc", "achrb", "cher", " chR", "cheR", "ichbr", "chnr", "chmr", "chry", "chnrl", "ichrc", "echmr", "scherr", "Chr", "ichrn", "thR", "cheg", "achmr"], "nextchr": ["nextChar", "nextcordr", "nextechrs", "nextyar", "nextcher", "nextachr", "firstechrb", "nextchdr", "nextthp", "defaultchedr", "nextechry", " nextchdr", " nextcher", "nextchrc", "prechedrb", "prechrc", "prechr", "nextcharr", "firstchry", "nextCher", "nextachn", "nextchedrar", "nextthrc", "nextchro", "nextcurrb", " nextchar", "nextchedr", " nextechr", "nextthrb", "nextchildrc", "newthp", " nextchR", "firstechry", "trychr", "trychro", "nextcherar", "defaultchedR", "maxchr", " nextchrar", "prechrb", "nextchrs", "nextyrg", "defaultchedry", "nextcurr", "nextcorR", " nextcurdr", " nextchl", "nextChl", "nextcurp", "nextyr", "nextyrin", "nextcheer", "trychrs", "firstchr", "nextchedrt", "nextechl", " nextcorrb", "defaultchry", "newthr", "maxcharg", "nextchedro", "newchdr", "nextcheR", "nextachrar", "nextachdr", "nextachR", "nextcharry", "nextcorr", " nextcurry", "nextChn", "nextChro", "nextechr", "nextchrt", "nextchildrb", "defaultchR", "nextchp", "newthn", "nextcorrb", "firstechp", "trychdr", "nextthr", "nextachp", "nextcurry", "nextchildrt", " nextcorr", "nextchl", "defaultchrar", "nextChdr", "nextcurar", "nextchar", " nextcorR", "newchp", "prechedrt", "nextthrar", "firstechr", "nextchedrb", " nextechrb", " nextechp", "nextchildr", "nextchaar", " nextchrb", "nextcharR", "nextthn", "nextechro", "prechrt", "nextchrb", "nextechrin", "nextchedrs", "newchn", "trychedro", "nextcheddr", "maxcharin", "nextcharg", "nextechar", "nextthR", "nextcharrar", "nextcurdr", "nextchedrc", "nextcorer", "nextcorrar", "firstchp", "nextchrin", "nextachry", "nextthrt", "maxchaar", "nextechp", "nextechrb", " nextcorrar", " nextcorer", " nextchp", "nextchrg", "prechedr", "nextChrb", " nextchry", "nextechrg", "nextChp", "nextchear", "nextchedR", "newchr", "nextChr", "nextchep", " nextcordr", "nextChry", " nextechl", "maxchrg", " nextcurar", "nextchn", "maxchar", "prechedrc", "firstchrb", "nextchR", "nextcurl", "trycheddr", "nextchery", " nextcurr", "trychedrs", "nextchrar", "nextcharin", "nextchedry", "nextChrs", "maxchrin", "nextchry", "defaultchr", "nextcherb", "newthdr", "nextthdr", "defaultchedrar", "nextechdr", "trychedr"], "keysym": ["keysm", "uesymm", "ksrm", "typesyn", "kesrm", "kesyr", "handsys", "valsymm", "handsyr", "keysyr", "codesymm", "kesymm", "letsyr", "lightsyr", "keysyp", "stylesym", "openssym", "stylesyp", "lightsym", "stylessym", "opensesm", "kesyn", "letssym", "rotssym", " keysymm", "ksyp", "handsrm", "kesmem", "typesym", "codesem", "rotsym", "codesyr", "ksymm", "ksy", "keysrm", " keysem", "rotsyr", "kessym", "keysymm", "keysys", "uesyp", "kesyp", "codesys", "letsym", "uesym", "letsyn", " keyssym", " keysyn", "valuesym", "ksyn", "ksmem", "valuessym", "ksm", "handsyn", "stylesyn", "handsymm", "namessym", "valsyn", "keysesm", "kesym", "valsem", "uessym", "typesm", "lightsyn", "kesy", "namesyr", "codesyn", "keysem", "opensyn", " keysyp", "namesym", "keyssym", " keysy", "ksym", "keysy", "valuesyn", "keysyn", "codesym", "keysmem", "handsm", " keysmem", "handssym", "valuesesm", "handsyp", "kssym", "valsym", "kesesm", "rotsyn", "opensym", "lightsys", "typesyp", "handsym", "namesyn", "typessym", "lightsymm"], "keycode": ["versioncase", "charcase", "firecache", "lockcode", " keycase", "condcode", "firecode", "featurecode", "powercode", "lockcase", "charcode", "modestroke", "eycod", "switchcase", "powercase", "keycache", "charcod", " keycod", "lockcoe", "Keystroke", "echocase", "eycode", "Keycode", "versioncode", "featurecache", "keycoe", "keychange", "keystroke", "keycase", " keyno", "eycase", "eyCode", " keychange", "keycod", "versioncod", " keycycle", "echocode", " keycache", "modecod", "condcoded", "condfunction", "KeyCode", "modecode", "switchcode", "versionchange", " keycoe", " keyCode", "keyno", " keystroke", "keyfunction", "Keycase", "switchCode", "powercoe", "powercod", "keycoded", " keycoded", "fireno", " keyfunction", "charCode", "leadercoded", "eychange", "firecycle", "featurecycle", "modeCode", "keyCode", "echocoe", "Keycoe", "featureno", "lockcod", "Keychange", "switchcod", "Keycod", "leaderfunction", "echoCode", "leadercode", "keycycle", "modecase", "charchange"], "keycode_alt": ["keycode_ALT", "keycoded_alter", "keycode2Alt", "keycodes2rel", "keycodes_ALT", "keycode__alt", "keycode2rel", "keycode2ret", "keycode__rel", "keycode_offset", "keycode2offset", "keycodes_extra", "keycoded_ALT", "keycoded_alt", "keycodes2ALT", "keycode__offset", "keycode_alter", "keycycle_ALT", "keycycle_Alt", "keycode2ALT", "keycycle_alt", "keycoded_ret", "keycode__ALT", "keycodes2extra", "keycycle_offset", "keycode2alter", "keycode_Alt", "keycode__Alt", "keycodes_rel", "keycode_rel", "keycodes2alt", "keycode2extra", "keycode_ret", "keycode__extra", "keycode_extra", "keycode2alt", "keycodes_alt"]}}
{"project": "FFmpeg", "commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "target": 1, "func": "static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n", "idx": 3596, "substitutes": {"line": ["lf", "pipe", "time", "sample", "length", "point", "page", "cell", "comment", "path", "block", "LINE", "frame", "try", "liner", "pointer", "on", "l", "word", "row", "valid", "offset", "out", "online", "lane", "lin", "lines", "list", "file", "se", "port", "source", "url", "link", "handle", "limit", "position", "sequence", "code", "le", "column", "lock", "user", "text", "base", "phrase", "ine", "ln", "sp", "eline", "lo", "Line", "chain", "buffer"], "duration": ["period", "resolution", "during", "time", "length", "unit", "volume", "future", "recorded", "d", "dimension", "seconds", "frequency", "timeout", "delay", "window", "relative", "number", "distance", "Duration", "direction", "video", "document", "minimum", "position", "total", "since", "repeat", "uration", "portion", "amount", "date", "days", "trip", "event", "until", "sequence"], "start": ["ish", "first", "open", "get", "init", "str", "time", "step", "length", "point", "art", "from", "new", "error", "entry", "Start", "try", "rest", "p", "starting", "check", "match", "i", "window", "offset", "v", "next", "st", "number", "info", "before", "len", "name", "space", "source", "seek", "origin", "key", "trans", "set", "it", "stop", "store", "position", "value", "data", "part", "load", "t", "state", "val", "size", "index", "begin", "date", "wind", "sp", "started", "id", "import", "range", "result", "pos"], "end": ["ment", "ish", "hend", " End", "END", "time", "ff", "length", "End", "nd", "dest", "rest", "after", "max", "ended", "pad", "est", "offset", "send", "v", "st", "ort", "e", "len", "port", "fin", "en", "ending", "it", "stop", "last", "ue", "size", "ENDED", "begin", "eff", "ent", "add", "id", "until"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "substitutes": {"klass": ["Klass", "tkls", "ekazz", "ikkazz", "iklass", "ikklass", "klasses", "ktls", "kclass", " kls", "Klasses", "tklass", "klc", "ikls", "ikkls", "ikkclass", "ekls", " kazz", " kclass", "iklc", "klf", "ktlass", "kazz", " klc", "Klf", "eklass", "Kls", "ekclass", " klf", "tklasses", " klasses", "ktclass", "kls", "ikclass", "ktlc", "tklf"], "data": ["DATA", "ata", " Data", " sd", "bin", "di", "d", "m", "w", "rec", "r", "v", " DATA", "Data", "def", "name", "dat", " d", "res", "dev", "raw", "mu", "json", "rew", "o", "result"], "k": ["wk", "ack", "spec", "ijk", "n", "work", "K", "aka", "kk", "ka", "q", "ikk", "kr", "sk", "ark", "km", "kt", "ki", "p", "unk", "i", "dk", "ck", "mk", "u", "ks", "ke", "kw", "kind", "g", "ik", "ek", "kick", "kn", "key", "tk", "ko", "rek", "kj", "kh", "it", "uk", "ak", "kid", "ok", "m", "ku"], "dc": ["cca", "cr", "cat", "rc", "nz", "md", "mc", "c", "di", "lc", "ca", "d", "dp", "rec", "gc", "cc", "cp", "ec", "pc", "dk", "ga", "bc", "disc", "dd", "fc", "nc", "cam", "df", "ac", "ds", "doc", "dt", "da", "dm", "tc", "dr", "DC", "cs", "desc", "cd", "db"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 3602, "substitutes": {"pdev": ["tDEV", "pkgfam", "qdev", "paysw", "dDev", "pvision", " penv", "pouch", "pingdevice", "pcdev", "paydebug", " pvar", "pevar", "paddr", "patDev", " pserial", "ndevice", "cpgu", "pasw", "patchdebug", "pkgrav", "patchcast", "psgo", "tpev", "paydev", "patserial", "Pdef", "pev", "yDEV", " pDEV", "pagu", "patdebug", "Pserv", " pouch", "payouch", " pver", " pdevice", "ppdef", "lpserv", "ddevice", "paystick", "ppriv", "qgo", "qgu", "percomment", "pDev", "payaddr", "tpenv", "apdevice", "pcde", "pkgstick", "Ppriv", " pfam", "pkgvision", "pgo", "payserial", "pcve", "pastore", "payeng", "ydevice", "Ppad", "tver", " pgo", "tpdevice", "peev", "pDEV", "psdev", "pingver", "ddev", " pDev", "pcaddr", "pserv", "paddev", "pave", "PDev", "pkgcast", "perouch", "payve", "pidebug", "pingrav", "pkgdebug", "payfam", "pgu", "pde", "penv", "piver", "cpdevice", "ppad", "aprav", "ipgo", "paddevice", "pingDEV", "pidev", "paycam", "nver", "pkgdev", "peng", "pdebug", "tfam", "pppad", "pirav", "Pgu", "pkgstore", "jpdev", "psw", "yvar", "ydev", "paygo", " peng", "tenv", "pedevice", "pciver", "apdebug", "pinggu", "pcvision", "pidevice", "lppad", "pcouch", "psouch", "pstick", "lpdev", " ppriv", "pingdebug", "cpDev", "ipouch", "jppriv", "pkgiver", "ipdev", "pcast", "psvision", "pastick", "pinggo", "pver", "pdevice", "pcsw", "paaddr", "pcomment", "patdevice", "jpdef", "pfam", "pcfam", "pingfam", "pkgcam", "peDEV", "pergo", "dfam", " pcast", "patdev", "pscomment", "padfam", "pedev", " pev", "patchdev", "tdevice", "pkggu", "pve", "pacam", "psfam", "jpDev", "pcver", " pgu", "pdef", "perdev", "prav", "patfam", "payDev", "pcam", "pingDev", "apdev", "pcstore", "pvar", "tdev", "psiver", "parav", "Pdev", "pegu", " pdef", "Pver", "pade", "ppserv", "pstore", "lpdef", "patchDev", "paygu", "ppdev", "ipcomment", "qev", " pdebug", "pkgDev", "pingdev", "pego", "payver", "pkgde", "pceng", "pcrav", "nDev", "cpdev", "padev", "ndev", "pserial", "tpdev", "Pdevice", "tev"], "is_default_rom": ["is_default2ram", "is_default2chrom", "is_no_chrom", "is_default2mem", "is_no2rom", "is_no2chrom", "is_default_mem", "is_default2rom", "is_no2mem", "is_no_rom", "is_default_chrom", "is_no2ram", "is_no_mem", "is_default_ram", "is_no_ram"], "errp": ["diep", "derpa", "ererping", "errpre", "errpp", "dieP", "errorr", "derP", "derp", "errping", "ererP", "errpa", "ererp", "crpoint", "rerr", "errorpre", "rerp", "crpp", "rrr", "crp", "erp", "crpad", "rerpad", "errorpg", "ererpre", "ierpp", "errpg", "erping", "ierpad", "erP", "errr", "rerpg", "erpre", "errpoint", "rrp", "errorp", "errorpoint", "errorpp", "errpad", "rrpg", "rrpad", "errP", "derpp", "ierp", "errorpad", "ierpoint", " errpa", " errpp", "diepp", "errorP", "diepa", "errorping", " errP"], "size": ["n", "count", "IZE", "time", "length", "machine", "any", "error", "dimension", "south", "score", "zone", "too", "si", "fee", "izes", "scale", "address", "range", "Size", "pos", "empty", "sample", "speed", "max", "sum", "message", "len", "file", "num", " sizes", "city", "equal", "z", "shape", "small", "chain", "see", "export", "im", "capacity", "height", "p", "l", "body", "ize", "number", "format", "space", "area", "set", "iz", "disk", "SIZE", "ze", "sized", "sp", "s", "zip", "mini", "bytes", " Size", "type", "mem", "send", "offset", "sh", "sex", "g", "network", "zero", "storage", "password", "news"], "path": ["Path", "core", "null", "open", "length", "xml", "error", "walk", "mount", "cp", "port", "history", "location", "home", "ath", "folder", "package", "pkg", "tree", "address", "cmd", "id", "priv", "pattern", "test", "transform", "empty", "th", "prefix", "file", "cam", "loc", "cont", "resource", "index", "desc", "chain", "config", "data", "entry", "p", "template", "trace", "format", "key", "copy", "code", "full", "dir", "where", "root", "alias", "disk", "policy", "sp", "base", "ex", "zip", "form", "temp", "rect", "pointer", "type", "parent", "mem", "stat", "context", "image", "url", "link", "ref", "call", "progress", "raw", "PATH"], "ptr": ["tp", "eth", "rc", "rep", "tr", "pt", "pr", "r", "rect", "p", " pointer", "inter", "pointer", "ps", "pad", "Ptr", "pc", "mem", "fp", "offset", "pi", "port", "handle", "br", "addr", "loc", "pointers", "ref", "dr", "address", "sp", "err", "buffer", "ctr", "pos", "alloc"], "name": [" NAME", "n", "time", "normal", "length", "options", "error", "v", " Name", "value", "location", "part", "class", "order", "module", "tree", "id", "test", "ame", "str", "init", "status", "x", "prefix", "def", "file", "group", "a", "user", "no", "version", "names", "data", "tag", " names", "new", "start", "admin", "l", "out", "format", "space", "key", "code", "alias", "NAME", "base", "flag", "comment", "w", "local", "type", "parent", "mem", "word", "title", "image", "g", "t", "Name", "filename", "f", "named", "none", "label", "o"], "vmsd": ["vinspd", "vksd", "vomssd", "hmsD", "vemsds", "vomsd", "vmsds", " vmsg", " vomsds", "vomsds", "vomspd", "hMSdm", "vmmsd", " vmsde", "vMSD", "vmesD", " vomsg", "vmesdm", "vpssd", "vemsd", "vlinesd", "vysd", "vpsD", " vmssd", "vMsD", "evomspd", "vmesc", " vpsde", " vpsd", "vmssd", "vinssd", "evmsds", "vksds", "evomsd", "vinsd", "vmsg", "hmsd", "vmsD", "vmsdm", "hMSd", " vomsd", "vmsde", "vMsde", "vysg", " vmsds", "vemsg", "vmspd", "vemssd", "vMsd", "evmspd", "vlinesD", "hmsdm", "vpsde", "vMSc", " vomssd", "vlinesc", "hmsc", "vyssd", "vmesd", "vomsg", "vMssd", "vysds", "vmmd", "evomsds", "vkspd", "evmsd", "vpsd", "vMSd", " vpsD", "vkssd", "evmssd", " vpssd", "vmsc", "hMSc", "vmmde", "evomssd", "vmmD", "vMSdm", "vlinesdm", "vinsds", "hMSD", " vmsD"]}}
{"project": "FFmpeg", "commit_id": "21bffa93a6fc73e1f1859f8bc224409eaaf27658", "target": 1, "func": "static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n\n{\n\n    AVStream       *video_st    = s->streams[0];\n\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n\n    int audio_rate = audio_par->sample_rate;\n\n    // TODO: should be avg_frame_rate\n\n    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);\n\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n\n\n    avio_wb32(pb, 0x94); /* size */\n\n    ffio_wfourcc(pb, \"uuid\");\n\n    ffio_wfourcc(pb, \"PROF\");\n\n\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n\n    avio_wb32(pb, 0xbb88695c);\n\n    avio_wb32(pb, 0xfac9c740);\n\n\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n\n\n    avio_wb32(pb, 0x14); /* size */\n\n    ffio_wfourcc(pb, \"FPRF\");\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n\n\n    avio_wb32(pb, 0x2c);  /* size */\n\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x2);   /* TrackID */\n\n    ffio_wfourcc(pb, \"mp4a\");\n\n    avio_wb32(pb, 0x20f);\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_rate);\n\n    avio_wb32(pb, audio_par->channels);\n\n\n\n    avio_wb32(pb, 0x34);  /* size */\n\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x1);    /* TrackID */\n\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n\n        ffio_wfourcc(pb, \"avc1\");\n\n        avio_wb16(pb, 0x014D);\n\n        avio_wb16(pb, 0x0015);\n\n    } else {\n\n        ffio_wfourcc(pb, \"mp4v\");\n\n        avio_wb16(pb, 0x0000);\n\n        avio_wb16(pb, 0x0103);\n\n    }\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb16(pb, video_par->width);\n\n    avio_wb16(pb, video_par->height);\n\n    avio_wb32(pb, 0x010001); /* ? */\n\n}\n", "idx": 3610, "substitutes": {"pb": ["tp", "td", "pr", "cp", "rm", "tk", "resp", "PB", "pm", "sb", "bb", "pkg", "amp", "xp", "tab", "erb", "prop", "bs", "pool", "uf", "ker", "dp", "buf", "req", "pc", "prefix", "jp", "pl", "vp", "wp", "typ", "bp", "fb", "jpg", "np", "pel", "emb", "obb", "rb", "kl", "xb", "p", "py", "ps", "sys", "ap", "pp", "ctx", "rpm", "nb", "phys", "bj", "patch", "tmp", "gp", "phy", "stab", "pa", "proc", "orp", "b", "func", "bps", "pt", "mp", "fp", "ob", "peer", "lp", "gb", "lb", "apache", "pg", "obj", "tc", "ub", "um", "err", "job"], "s": ["spec", "stats", "bs", "qs", "ses", "comm", "es", "b", "c", "ls", "w", "p", "ts", "its", "ps", "gs", "v", "sys", "less", "parts", "ss", "g", "ims", "sv", "os", "fs", "ds", "vs", "sts", "ats", "times", "rs", "t", "ns", "http", "sb", "S", "https", "sl", "sq", "cs", "aws", "js", "m", "ex"], "video_st": ["video__str", "video__st", "video__ste", " video_stable", "video_trans", " video_est", " video_ste", "video__est", " video_str", "video_est", "video_sta", "video_stable", " video_sta", "video_ste", "video_str", " video_trans", "video_sty", " video_sty"], "video_par": ["videoartyse", "videoartypa", "videoartypar", "video_pr", "voice_se", "video0par", "videoartycar", "video_se", "video0se", "ideoitypar", "ideoitycomp", "ideo_par", "video_comp", "ideo_jp", "video0car", "ideoitypr", "videoitypr", "videoityjp", "videoitypar", "videolibpar", "video_jp", "videoitycomp", "videolibjp", "ideoityjp", "ideo_pr", "videolibcomp", "video0pa", "video_car", "video_pa", "ideo_comp", "voice_par", "voice_pa", "videolibpr", "voice_car"], "audio_par": ["audio_comp", "audio___par", "video_part", "audio_prep", "audioitypar", "audioitymat", "audio___rep", "audio___comp", " audio_pkg", "audio_p", "audio_pair", "audiolpar", "audiolcomp", "video_comp", "audio_mat", "audiolpair", "audiolp", "video_rep", "audioitycomp", "audio_pas", "video_pair", " audio_prep", "audioitypkg", "audio_pkg", " audio_mat", "audio_rep", "audio___part", " audio_pas", "video_p", " audio_comp", "audio_part"]}}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n", "idx": 3611, "substitutes": {"sphb": ["sPhdb", "sphdb", " spha", "sphB", "sPhB", "spgdb", " sphdb", "sPha", "sPhb", "spha", "spga", "spgb", "spgB", " sphB"], "pdev": ["dDev", "ppdevice", "pcdev", "pcgu", "postdef", "pdef", "postdevices", "postdevice", "pdevices", "dgu", " pdevices", "ddev", "PDev", "Pdev", " pdef", "postdev", "ppdevices", " pdevice", "pgu", "ppdev", "ppdef", "ddevice", "pDev", "pdevice", "pcDev", "pcdevice", "Pdevice", "Pgu"], "path": ["method", "Path", "target", "length", "mount", "port", "binding", "conn", "br", "location", "part", "home", "ath", "h", "ptr", "pkg", "address", "cmd", "id", "priv", "pattern", "pos", "prop", "phi", "transform", "localhost", "str", "empty", "c", "th", "ha", "near", "program", "prefix", "kind", "file", "cam", "loc", "mat", "index", "chain", "buffer", "ith", "data", "ports", "ready", "half", "quick", "p", "ip", "out", "valid", "template", "here", "current", "name", "ctx", "key", "set", "full", "dir", "text", "where", "root", "ex", "pat", "self", "dest", "pt", "w", "local", "pointer", "check", "parent", "context", "url", "link", "end", "cert", "ref", "call", "dev", "PATH", "pid", "client"], "buf": ["proc", "str", "cat", "pool", "iter", "cap", "seq", "bin", "bytes", "batch", "uf", "cfg", "b", "rb", "cur", "gen", "pt", "Buff", "output", "cp", "img", "mem", "out", "context", "bc", "ob", "queue", "bed", "arr", "norm", "port", "file", "result", "ctx", "conv", "cam", "conn", "br", "doc", "cb", "content", "loc", "msg", "serv", "ref", "txt", "cont", "bag", "text", "obj", "cv", "Buffer", "dev", "ptr", "pkg", "filename", "raw", "cmd", "err", "desc", "buffer", "config", "buff", "env", "data", "vec", "db", "prop"], "host": ["ich", "hook", "ac", "localhost", "str", "pool", "target", "hand", "cmp", "sche", "Host", "th", "rh", "ha", "comp", "map", "p", "local", "hd", "ip", "bind", "context", "container", "here", "port", "name", "binding", "source", "driver", "ost", "handle", "conn", "url", "hop", "server", "addr", "ghost", "physical", "loc", "hat", "http", "node", "object", "home", "ref", "index", "nick", "user", "serv", "h", "dev", "cert", "address", "hs", "cmd", "chain", "domain", "ith", "OST", "client"]}}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)\n\n{\n\n    //FIXME Optimize (just quickly writen not opti..)\n\n    int i;\n\n    for (i=0; i<dstW; i++)\n\n    {\n\n        int val=1<<18;\n\n        int j;\n\n        for (j=0; j<lumFilterSize; j++)\n\n            val += lumSrc[j][i] * lumFilter[j];\n\n\n\n        dest[i]= av_clip_uint8(val>>19);\n\n    }\n\n\n\n    if (!uDest)\n\n        return;\n\n\n\n    if (dstFormat == PIX_FMT_NV12)\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(u>>19);\n\n            uDest[2*i+1]= av_clip_uint8(v>>19);\n\n        }\n\n    else\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(v>>19);\n\n            uDest[2*i+1]= av_clip_uint8(u>>19);\n\n        }\n\n}\n", "idx": 3621, "substitutes": {"lumFilter": ["luvBlock", "lamfilter", "loomfilter", "lumaFil", "lumaRule", "llumF", "lumF", "lumFil", "llumaRule", "llumaF", "lummRule", "llumFil", "llumFilter", "lumaF", "lamFilter", "llumaFil", "luvFilter", "llumfilter", "lumafilter", "lumBlock", "luvRule", "llumBlock", "llumaBlock", "loomF", "lumfilter", "lummBlock", "lumaFilter", "lamFil", "lumRule", "lumaBlock", "lummFilter", "loomFil", "llumafilter", "llumRule", "loomFilter", "lamF", "llumaFilter"], "lumSrc": ["lumInsRC", "lumsSrs", "lumAsrs", "lumaSrc", "lumNsrc", "lumsInrc", "lumInsrc", "lumNrc", "lumaSrs", "lumInRC", "lumAsRC", "lumAsrc", "lumsInRC", "lumaSsrc", "lumInrc", "lumsSRC", "lumInrs", "lumSRC", "lumNrs", "lumsInrs", "lumInsrs", "lumaSRC", "lumNRC", "lumSrs", "lumSsrc", "lumsSrc"], "lumFilterSize": ["lumBufferStyle", "lumsFilterMode", "lumBufferInfo", "lumsFilterSIZE", "lumbChannelSize", "lumBufferSize", "lumsBlockSIZE", "lumbFilterInfo", "lumRangeStyle", "lumBlockSize", "lumFilterSIZE", "lumFilterStyle", "lumFilInfo", "lumsFilterSize", "lumBlockSIZE", "lumsBlockStyle", "lumRangeMode", "lumRangeSize", "lumRangeSIZE", "lumBufferMode", "lumFilterInfo", "lumbChannelInfo", "lumFilSize", "lumbFilterSize", "lumChannelSIZE", "lumBufferSIZE", "lumChannelInfo", "lumbChannelSIZE", "lumsBlockMode", "lumFilSIZE", "lumBlockStyle", "lumChannelSize", "lumsBlockSize", "lumFilterMode", "lumBlockMode", "lumbFilterSIZE", "lumsFilterStyle"], "chrFilter": [" chrcFilter", " chroFil", "chrarFilter", "achrFil", "chrcRule", "chrcTransform", "chnrtControl", "chrdfilter", " chroQuery", "chlControl", "chrRule", "achrcHandler", "chrfilter", "chnrtFrame", "childrgRule", "chrFormat", "chreControl", "childrRule", "chruFilter", "chnrtQuery", "achrcTransform", "achrcFil", "chrcFilter", "chlHandler", "chuControl", "childrTransform", "chuFrame", "chnrControl", "chrcBuffer", " chrcFormat", "achrHandler", "chrufilter", "chrControl", "chrtQuery", "chrFrame", "chrcFil", "chrcControl", "chrgFilter", "chreFilter", " chrFormat", "chrFil", "chrarControl", "chroQuery", "chlTransform", " chrControl", "chrQuery", "achrcFilter", "chrarQuery", "chrgRule", "childrgFilter", "chreFrame", "chrgBuffer", "chnrtFilter", "chrtFrame", " chrcFrame", "chlFil", " chrofilter", "chrdFilter", "chlFilter", "chroFil", "chrtTransform", "chrdFil", "achrFilter", "chreFormat", " chroFilter", "chlFrame", "chrtRule", "childrBuffer", "chrcFrame", "chrdQuery", "childrgTransform", "chrgTransform", "chruFil", "chrtFilter", " chrfilter", "chnrFilter", "chrBuffer", "childrFilter", "chroFilter", "chrtControl", " chrFil", "chrarFrame", "chrcHandler", "chuFormat", "chrHandler", "chruQuery", "chrcFormat", " chrFrame", "chrofilter", "chuFilter", "chrtBuffer", " chrcControl", " chrQuery", "chruHandler", "achrTransform", "chrTransform", "chnrQuery", "chruTransform", "chlQuery", "chnrFrame", "childrgBuffer"], "chrSrc": ["chrInssc", "chrtSrc", "chrPq", "chrtSsc", "chrtSvc", "chrtSRC", "chrcInsrc", "chrInsrs", "chrRessc", "chrSrs", "chrSourcesrc", "chrcSrs", "chrNq", "chrDsrc", "chrNsrc", "chrNrc", "chrtSq", "chrPrc", "chrSRC", "chrSourcerc", "chrSq", "chrResrc", "chrPsvc", "chrSourceource", "chrPsnc", "chrOutvc", "chrSsrc", "chrInrc", "chrtSnc", "chrcInsRC", "chrtPq", "chrInource", "chrSourceRC", "chrtSource", "chrInRC", "chrPRC", "chrcInssrc", "chrtPRC", "chrPsrc", "chrOutRC", "chrInsRC", "chrRessrc", "chrcSRC", "chrInssrc", "chrcSsrc", "chrNRC", "chrResRC", "chrtPsrc", "chrSource", "chrInsrc", "chrtSsrc", "chrDrc", "chrOutrc", "chrSvc", "chrcSrc", "chrcInsrs", "chrSsc", "chrOutnc", "chrPsRC", "chrtPrc", "chrDRC", "chrDrs", "chrSnc"], "chrFilterSize": ["chrsFilterType", "chrRangeSize", "chruRuleSize", "chrtFilize", "chrFilterN", "chruRuleW", "chrStreamWindow", "chrRuleSize", "chrListenerLength", "chrTransformSize", "chrFilterSIZE", "chrtFilterLength", "chrTransformN", "chrsBufferSIZE", "chrRangeScale", "chrBufferSIZE", "chrMaskSIZE", "chrFilterWindow", "chruFilterN", "chrBufferSize", "chrTransformW", "chrFilterLength", "chrtFilterize", "chrtFilSize", "chrFilterType", "chrRuleWindow", "chrsBufferSize", "chrFilterScale", "chruFilterSize", "chrStreamW", "chrtFilterSize", "chrBufferScale", "chrListenerize", "chrFilterize", "chrRuleN", "chrBufferType", "chruRuleWindow", "chruFilterWindow", "chrMaskSize", "chrTransformWindow", "chrsBufferScale", "chrRuleW", "chrRangeSIZE", "chrListenerSIZE", "chrFilSize", "chrRangeType", "chrtFilterSIZE", "chrListenerSize", "chrsFilterSIZE", "chrStreamN", "chrsBufferType", "chrsFilterSize", "chrFilLength", "chruRuleN", "chrFilize", "chrBufferLength", "chrtFilLength", "chrFilterW", "chrFilSIZE", "chrtFilSIZE", "chrsFilterScale", "chrMaskType", "chrBufferize", "chrMaskScale", "chrStreamSize", "chruFilterW"], "dest": ["ist", "transform", "cat", "iter", "target", "comb", "tr", "temp", "Dest", "dist", "src", "output", "opt", "rest", "buf", "est", "mem", "decl", "out", "st", "EST", "pi", "port", "source", "origin", "data", "trans", "end", "it", "master", "loc", "cont", "table", "ptr", "sp", "desc", "buffer", "result", "sort"], "uDest": ["iuStore", "uvNow", "uuStore", "puDest", "uDep", "tuNeg", "uNow", "uvDep", "uiDep", "uiSource", "uiDest", "uiDec", "oDest", "uSource", " uTarget", "uiStore", "uDesc", "tuDest", "iuRest", "iuDec", "oTarget", "uQueue", " uNeg", "puOrig", "oDec", "oDesc", "cuDec", "uNeg", "uuSource", "uDec", "iuOrig", "cuDest", "tuDesc", "pOrig", "uuDest", "uuRest", "pDesc", "uiDesc", "uiNeg", "puDesc", "uiRest", "uOrig", "uStore", "uvDest", "pDest", "pDec", "uiTarget", "uiQueue", "uRest", "iuDest", "cuDesc", " uQueue", "puDec", "oQueue", "iuSource", "iuDesc", "uTarget", "tuDep", " uDep", " uNow", " uDesc", "tuNow", "cuTarget"], "dstW": ["DstG", "dstN", "dstVW", "dtdSize", "dtdVW", "DistW", "DstN", "dstG", "dtdW", "distVW", "dSTW", "dostVW", "dostN", "distW", "distSW", "dostSW", "dstSize", "DstVW", "dostSize", "distG", "DistVW", "dSTN", "dSTG", "DstSW", "distN", "DstW", "distSize", "dstSW", "dSTSize", "DistSW", "dostW", "dostG", "DistN", "dtdSW", "DstSize", "DistG", "DistSize"], "chrDstW": ["chrDSTN", "chrDndN", "chrDestWP", "chrDstN", "chrDrcZ", "chrDrcSize", "chrDSTW", "chrDstSize", "chrDistWP", "chrSstV", "chrDndW", "chrDstR", "chrDistSize", "chrDstD", "chrSstWP", "chrDstrZ", "chrDSTV", "chrDrcD", "chrDrcWP", "chrDistR", "chrSistN", "chrSrcN", "chrDrcN", "chrDndV", "chrSrcW", "chrDestZ", "chrSistW", "chrSstD", "chrDestN", "chrDndR", "chrDestD", "chrDstWP", "chrSrcSize", "chrSstR", "chrSstZ", "chrSrcZ", "chrSstW", "chrSstN", "chrSistR", "chrDestSize", "chrDstrD", "chrSrcWP", "chrDistW", "chrDstV", "chrDestW", "chrDistV", "chrDSTR", "chrSrcD", "chrDistN", "chrDstZ", "chrSstSize", "chrSistV", "chrDstrW", "chrDstrSize", "chrDrcW"], "dstFormat": ["DstFormat", "drcformat", "DistMT", "Distformat", "dSTStyle", "destStyle", "drcFormat", "distFormat", "DstForm", "DSTForm", "dSTForm", "destFormat", "dstformat", "dstMT", "dSTFormat", "distMT", "Dstformat", "dSTType", "destType", "drcMT", "distStyle", "dstrStyle", "destForm", "DstMT", "DistStyle", "drcStyle", "distformat", "DSTType", "dstrFormat", "dstrForm", "dstForm", "DstType", "DSTStyle", "DSTFormat", "DstStyle", "dstStyle", "dstType", "dstrType", "DistFormat"], "i": ["n", "cli", "iter", "mi", "ni", "ind", "is", "ai", "ei", "ij", "v", "ic", "it", "si", "to", "val", "ie", "il", "y", "id", "ti", "io", "phi", "iu", "bi", "hi", "init", "medi", "ui", "batch", "c", "di", "ih", "status", "x", "ini", "zi", "ims", "ik", "xi", "ami", "iq", "iat", "user", "index", "multi", "z", "sim", "ri", "I", "this", "point", "im", "ki", "p", "iii", "ip", "info", "name", "key", "ix", "ci", "dr", "gi", "m", "iy", "li", "ia", "ii", "ji", "\u0438", "parent", "u", "pi", "in", "me", "qi", "t", "tim", "print"], "j": ["uj", "n", "them", "by", "pr", "og", "ind", "v", "ij", "jar", "br", "it", "kh", "er", "jet", "ie", "y", "json", "note", "bi", "bl", "str", "q", "jump", "di", "att", "at", "oj", "dj", "ge", "x", "jj", "ion", "jac", "jp", "mn", "kj", "aj", "z", "jl", "other", "ijk", "fr", "adj", "im", "try", "je", "py", "ja", "my", "key", "ng", "ix", "bj", "dr", "jo", "jas", "el", "jc", "jack", "Ja", "him", "gh", "pt", "ji", "g", "jit", "res", "obj", "err", "js", "J", "bo", "job"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n", "idx": 3634, "substitutes": {"n": ["nw", "note", "nl", "dn", "ren", "np", "gn", "nt", "an", "self", "comm", "nu", "na", "c", "nor", "nv", "nd", "sn", "w", "p", "on", "yn", "v", "cn", "g", "name", "nc", "rn", "num", "ne", "network", "o", "conn", "en", "ng", "mn", "un", "nb", "ns", "node", "N", "y", "ln", "net", "nn", "nm", "names", "m", "j", "nr"], "addr": ["ad", "ack", " cur", "attr", "eth", "work", "rc", "hash", "iter", "adj", " err", " amp", "b", "src", "hl", "ash", "r", "alt", "ret", "inter", "on", "pad", " address", " ip", "align", "l", "ip", "offset", "v", "Address", " ptr", "x", "arr", "rt", "len", "name", "hop", "ord", "url", "adr", "arp", "host", "to", "loc", "ix", "adv", "res", "iat", " af", "now", "usr", "wd", "index", "act", "alias", "hz", "mt", "ptr", "sw", "hw", "pkg", "dr", "address", "sp", "cmd", "add", "id", "tx", "pos", "gate", " mac"], "val": [" act", "attr", " step", " v", "VAL", "var", " resp", " iv", " res", "b", "values", "func", " arg", " eval", " count", " index", " amount", "ret", "sel", "buf", "vt", "xy", "iv", "cal", "v", "valid", " interval", "arr", "elt", " len", "num", " ret", "pol", "aval", "value", "resp", " height", " offset", "rel", "alpha", "Val", " value", " tx", "eval", "ref", " state", "vals", "act", "oval", "hz", "dev", " num", "err", " msg", "tx", "fail", " x", "vol", "pos"], "qid": ["qtry", "quId", " qmid", "dqinfo", "quident", "qumid", "iqpid", "qualmid", " qpid", "dqpid", "querymid", "qualref", "iqoid", "qqid", "itemident", "qref", "iqID", "quid", "iqm", "queryid", "eqid", "questmid", "dqid", "qoid", "itemid", " qname", "qqID", "quoid", "qId", "quref", "dqId", "queoid", "qID", "qualident", "iqtry", " qtry", "qupid", "qide", "iqmid", " qId", "qident", " qinfo", "qum", "qqname", "iqname", "qualide", "quide", "itemide", "qname", "queryId", "iqid", "queid", "qpid", "eqtry", "eqmid", "iqId", "quem", "itemmid", " qID", "qm", "qqId", "quinfo", "questid", "questide", "querypid", "qinfo", "qmid", "qualid", "questref"], "start_sqs": ["start2seqls", "start_txarts", "start_sqls", "start_seqls", "start_scS", "start_squarts", "start_txs", "start_iqs", "start_sqis", "start2seqds", "start_txis", "start2sqls", "start_aqis", "start_shS", "start_shls", "start_scls", "start_squos", "start_sqarts", "start2seqs", "start2sqches", "startfulsqos", "start_aqs", "start_iqS", "start2sqs", "start_iqds", "start_scds", "start_sqS", "start_squs", "start_squis", "start_eqches", "start_shs", "start_sqches", "start_eqs", "start_eqds", "start_txos", "start_aqarts", "start_seqds", "startfulsqs", "start2seqches", "start_seqches", "start_sqos", "startfulsqis", "start_eqls", "start_iqches", "startfulsqus", "start_iqls", "start_shds", "startfulsqarts", "startfulsquarts", "start_scs", "startfulsquis", "startfulsquos", "start_seqs", "start_sqds", "start2sqds", "start_aqos"], "cq": ["dq", "xcdq", "crq", "cqq", "ecq", "ceque", "mcquery", "crpe", "contqu", "acquery", "xcq", "mcue", " cque", "dcq", "mcqq", "cog", "cQ", "pqu", "diq", "dqu", "cinpe", "cedq", "cque", "ecqq", "crque", "acq", "contque", "cachequ", "sciq", "acqs", "dciq", "dcQ", " cqu", "catq", "cinqq", "ceq", "catque", "acQ", "cqu", "scqu", " cue", "acog", "conog", " cdq", "scq", " cog", "ncqq", "cequ", "acqq", "xcwe", "cachedq", "dqq", "lcqq", "cacheque", " cpe", "mcq", "lcue", "pQ", "catue", "ciq", "cinque", " cqs", "ecQ", "dcqu", "cwe", "nciq", "lcq", "acpe", "ncqu", "conwe", "conq", "aciq", "acqu", "cdq", " cquery", " cqq", "ecqu", " cwe", "conqq", "cquery", "pq", "cqs", "xcqq", "pqs", "dcqq", "ncq", "cue", "scqq", " cQ", "condq", "cacheq", "contq", "contue", "catqu", "cpe", "cinq", "conqs", "acue", "lcpe", "crqq"], "sq": ["qu", "s", "dq", "sql", "supp", "sg", "eq", "square", "sing", "lbs", "qs", "cap", "seq", "query", "q", "biz", "ct", "quit", "squ", "ssl", "ash", "cu", "zz", "ps", "cf", "gs", "ship", "sh", "sys", "aux", "socket", "parse", "sync", "qq", "sol", "ss", "cn", "rt", "se", "nil", "sc", "qi", "ctx", "sv", "shift", "ds", "ry", "tk", "iq", "ksh", "qa", "sid", "qt", "ns", "sb", "scl", "sf", "subject", "inqu", "she", "sl", "pkg", "mph", "cs", "hs", "cmd", "aws", "ctr", "sa", "news", "esque", "aq", "ssh"]}}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred(Indeo3DecodeContext *s)\n\n{\n\n  int i, j;\n\n\n\n  s->ModPred = av_malloc(8 * 128);\n\n\n\n  for (i=0; i < 128; ++i) {\n\n    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));\n\n    s->ModPred[i+1*128] = i ==   7 ?  20 :\n\n                          i == 119 ||\n\n                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));\n\n    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));\n\n    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));\n\n    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));\n\n    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));\n\n    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));\n\n    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));\n\n  }\n\n\n\n  s->corrector_type = av_malloc(24 * 256);\n\n\n\n  for (i=0; i < 24; ++i) {\n\n    for (j=0; j < 256; ++j) {\n\n      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :\n\n                                   j < 248 || (i == 16 && j == 248) ? 0 :\n\n                                   corrector_type_2[j - 248];\n\n    }\n\n  }\n\n}\n", "idx": 3658, "substitutes": {"s": ["service", "ports", "sg", "stats", "spec", "bs", "qs", "ants", "ses", "services", "comm", "utils", "c", "ls", "sets", "states", "status", "als", "p", "ts", "ps", "gs", "is", "sync", "ops", "less", "parts", "ss", "lines", "ers", "ims", "ms", "se", "sv", "os", "conv", "bis", "fs", "ds", "eps", "set", "a", "settings", "sts", "ats", "vs", "acs", "rs", "ns", "sb", "S", "ins", "h", "sq", "cs", "hs", "ans", "details", "js", "aws"], "i": ["oi", "cli", "eu", "yi", "iri", "ati", "uri", "mi", "ind", "is", "ai", "ei", "ij", "v", "ic", "it", "si", "er", "ie", "ed", "y", "id", "ti", "io", "phi", "iu", "bi", "hi", "init", "q", "ui", "di", "status", "at", "adi", "x", "ori", "ini", "zi", "ims", "ik", "xi", "ami", "index", "multi", "chain", "sim", "ri", "I", "this", "im", "ki", "p", "iii", "l", "ip", "info", "name", "ar", "ix", "aci", "ci", "mac", "gi", "m", "li", "ia", "ii", "\u0438", "u", "e", "pi", "in", "g", "me", "qi", "esi", "f", "um", "err", "o"], "j": ["k", "uj", "n", "bi", "bs", "jc", "li", "fr", "q", "Ja", "b", "jump", "at", "oj", "try", "r", "je", "p", "dj", "ji", "iaz", "on", "l", "ind", "ja", "v", "ij", "x", "u", "jj", "ion", "e", "jp", "g", "o", "br", "ju", "ian", "it", "jit", "kj", "or", "ix", "er", "aj", "si", "t", "bj", "ie", "obj", "y", "us", "h", "z", "json", "jl", "js", "J", "jo", "m", "job"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681, "substitutes": {"s": ["n", "sg", "stats", "bs", "q", "ses", "self", "b", "c", "w", "r", "p", "ts", "is", "v", "gs", "sys", "st", "e", "ss", "g", "space", "sc", "ctx", "sv", "os", "fs", "ds", "set", "sts", "rs", "ns", "t", "sm", "as", "sb", "S", "h", "sw", "cs", "sp", "hs", "js"], "rlow": ["rellittle", "radhigh", "mrhigh", "vlow", "rtlow", "relhigh", " rLow", "rtLow", "radlo", "rtlower", "rlo", "rtlo", "rellow", "mrlo", "vLow", "rLow", "vlo", "mrlittle", "mrlow", " rlower", " rlo", "vlower", "radlittle", "radlow", "rlower", "rello", "rlittle"], "rhigh": ["nrhigher", "Rhigh", " rhighest", "rdhigher", "rmost", "rdhigh", "rhigher", "rthighest", "rthigh", "Rhigher", "rmax", "rhighest", "nrupper", "rupper", "nrhigh", "Rmax", "Rmost", " rmost", "rdhighest", " rmax", "Rupper", "rdupper", "rtmost", "nrhighest", "rtmax", "Rhighest"], "val": ["test", "VAL", "ival", " v", "var", "b", "func", " arg", " eval", "pt", "pr", "p", "ret", "alt", "buf", "vt", "V", "xy", "l", "mem", "cal", "v", "valid", "x", "sol", "reg", "num", "ctx", "sv", "al", "key", "value", "it", "pol", "loc", "t", " aval", "pl", "Val", " value", "eval", "ref", "index", "alpha", "vals", "tx", " x", "vol", "data", "vec", "base"], "tmp": ["sam", "bt", "proc", "wx", "attr", "null", "lib", "orig", "var", "np", "tt", "nt", "cmp", "gz", " sp", "uf", "temp", "b", "grow", "td", "new", "pt", "xb", "p", "mp", "py", "ret", "buf", "vt", "xy", "tv", "cp", "timeout", "mint", "img", "mm", "out", "mk", "jj", "emp", "jp", "rt", "tn", "ctx", "cb", "resp", "msg", "gb", "t", "tar", "txt", "perm", "tm", "obj", " mp", "cv", "etc", "mb", " np", "pkg", "split", "snap", "sp", "ptr", "cmd", "tg", "gm", "buff", "m"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3691, "substitutes": {"s": ["n", "cli", "services", "sn", "i", "is", "v", "sync", "ops", "parts", "sis", "ies", "store", "fs", "ds", "bits", "sb", "h", "y", "sq", "hs", "sports", "bs", "ses", "st", "ims", "sv", "os", "vs", "sts", "ats", "details", "qs", "utils", "states", "p", "ps", "comments", "sys", "less", "ss", "ms", "bis", "sta", "set", "so", "sm", "us", "sl", "sp", "stats", "xs", "comm", "es", "b", "ls", "als", "ts", "its", "changes", "gs", "stat", "rs", "ns", "t", "serv", "ins", "S", "sw", "cs", "js", "aws"], "data": ["ad", "DATA", "str", "empty", "bin", "length", "bytes", "batch", "b", "start", "d", "block", "r", "cache", "p", "ret", "buf", "pad", "xy", "type", "mem", "out", "offset", " DATA", "Data", "next", "def", "in", "reg", "name", "mid", "ds", "value", "trans", "dat", "to", "t", "fn", "as", "bits", "val", "text", "size", "done", "partial", "extra", "ptr", "f", "mu", "rew", "id", "buffer", "m", "pos", "ata"], "len": ["n", "length", "nt", "cmp", "lit", "ll", " le", "en", "limit", "resp", "val", "enc", "h", "pos", "lan", "lf", "str", "del", "lc", "lim", "alt", "buf", "lic", "L", "rev", "gt", "list", " l", "num", "ld", "loc", "ln", "lang", "led", "seq", " length", "kl", "ret", "l", "elt", "lt", "Len", "den", "lon", "el", "nl", "cap", "li", "bytes", "lu", "ls", "hl", "gen", "mem", "offset", "fun", "lin", "fin", "lp", "end", "le", "lif", "t", "ref", "size", "err", "vec"]}}
{"project": "FFmpeg", "commit_id": "29c2fcb6776f80a0a5551bb82b43bc14c8202331", "target": 1, "func": "static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)\n\n{\n\n    int16_t icoef;\n\n    int recent = s->cdlms[ich][ilms].recent;\n\n    int16_t range = 1 << (s->bits_per_sample - 1);\n\n    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample\n\n\n\n    if (input > pred) {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] +=\n\n                s->cdlms[ich][ilms].lms_updates[icoef + recent];\n\n    } else {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] -=\n\n                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?\n\n    }\n\n    s->cdlms[ich][ilms].recent--;\n\n    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);\n\n\n\n    if (input > pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];\n\n    else if (input < pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n\n\n\n    /* XXX: spec says:\n\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;\n\n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;\n\n\n\n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n\n        seperate buffers? Here I've assumed that the two are same which makes\n\n        more sense to me.\n\n    */\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n\n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n\n\n\n    if (s->cdlms[ich][ilms].recent == 0) {\n\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n\n                follow kshishkov's suggestion of using a union. */\n\n        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_prevvalues,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_updates,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;\n\n    }\n\n}\n", "idx": 3714, "substitutes": {"s": ["n", "ants", "services", "same", "is", "ops", "parts", "ies", "store", "fs", "ds", "gets", "sb", "h", "we", "sq", "hs", "bs", "ses", "c", "ges", "ains", "ties", "ims", "sv", "os", "vs", "sts", "ats", "as", "tools", "details", "sim", "qs", "states", "ps", "comments", "l", "sys", "less", "ss", "tests", "space", "ms", "sl", "m", "bes", "sam", "ex", "stats", "self", "comm", "es", "ls", "w", "als", "ts", "its", "changes", "gs", "e", "g", "conf", "se", "ers", "acs", "ows", "settings", "rs", "ns", "serv", "ins", "S", "sw", "f", "cs", "js", "aws", "series"], "ich": ["cha", "erv", "ech", "craft", "ict", "iche", "chip", "ic", "ill", "history", "anch", "y", "h", "igr", "ick", "hw", "hs", "irc", "chart", "ull", "ish", "icht", "chid", "ait", "irt", "ih", "th", "yout", "urn", "uph", "alth", "icy", "nih", "ik", "wife", "hirt", "ach", "hum", "irm", "host", "iq", "clus", "liv", "psych", "icon", "chain", "ith", "chn", "thus", "chan", "eth", "iam", "unch", "hill", "hip", "channel", "esp", "arch", "iv", "ip", "isch", "ship", "sys", "Ch", "ether", "chant", "uth", "CH", "ix", "ight", "phy", "ch", "och", "ht", "dom", "isc", "chest", "gh", "iah", "html", "itech", " ch", "uch", "cht", "roth", "rich", "chrom", "igh", "nick", "resh", "act", "eric", "domain", "ah"], "ilms": ["filmins", "ilns", "ilm", "tilfs", "ilvs", "illmins", "ilsml", "ailml", "ialml", "ilsbs", "ailmins", "utilmes", "ailbs", "filmm", "ilijs", "ilim", "filkes", "ilks", "utilmn", "illmes", "filvs", "ailmos", "ilmm", "ilivs", "illmos", "ialms", "filems", "iljs", "ailmers", "bilmes", "ilmb", "utilmb", "utilems", "ilmos", "ailvs", "tilws", "utilms", "ilems", "tilmes", "ailks", "ilmn", "ailfs", "tilmos", "ileems", "filks", "utilvs", "filmb", "filfs", "bilkes", "ilims", "films", "ailm", "ilml", "utilkes", "ailems", "ilens", "ilimers", "filns", "utilns", "ilsms", "ilfs", "tilmins", "filjs", "kilns", "ilefs", "ilins", "ilimes", "ialbs", "ilmic", "ailms", "illmers", "ilemic", "filmos", "ilmes", "ilemins", "ilemes", "ailmic", "tilmic", "ilbs", "ilkes", "kilms", "kilmb", "utilmos", "ailjs", "filmn", "bilmn", "illm", "ilejs", "filmes", "illns", "utilmins", "utilfs", "tilmb", "ailmb", "illms", "ailmes", "illfs", "ilmers", "ilem", "ilws", "tilns", "ilimb", "iliws", "utilmers", "ailns", "utilks", "ilmins", "film", "utilmm", "bilms", "ailmm", "illmic", "ilemos", "tilms", "kilws", "filmers", "ilimic"], "input": ["inner", "supp", "read", "view", "this", "init", "rc", "form", "empty", "initial", "get", "q", "up", "c", "not", "error", "hidden", " inputs", "output", "w", "p", "local", "head", "ec", "i", "ind", "ip", "out", "img", "select", "missing", "x", "command", "in", "image", "before", "current", "expression", "bit", "shift", "history", "Input", "it", "ix", "iq", "op", "val", "state", "inf", "cont", "text", "index", "act", "yet", "raw", "unknown", "cmd", "ch", "config", "update", "data"], "pred": ["proc", "repl", "hist", "binary", "orig", "Pred", "RED", "rep", "ff", "prep", "post", "ved", "cond", "rib", "ped", "pr", "rect", "p", "selected", "req", "buf", "iv", "ind", "tip", "valid", "buff", "next", "ob", "def", "bed", "redict", "reg", "history", "false", "br", "neg", "cod", "val", "fitted", "inf", "med", "ched", "ref", "act", "ed", "xx", "dict", "ptr", "pre", "tmp", "reported", "fed", "rend", "cmd", "err", "red", "fail", "ok", "sub", "bo", "ied", "vec", "prop"], "icoef": ["stroef", "coefficient", "loeffee", "ckieless", "BOef", "icoefe", "coef", "niceph", "nicffee", "icaEF", "ckiffee", "kieff", "cif", "Coefficient", "icefficient", "iceff", "Coef", "icieph", "ckiefer", "kiEF", "eroeless", "ciefined", "ICOefe", "ICOeff", "icoeless", "loeef", "icoEF", "ciec", "imief", "icaf", "kief", "ciEF", "coalf", "ciefer", "cialf", "ericEF", "soefe", "eroefficients", "cieff", "icioeval", "ICOefficient", "ICOffee", "ICOef", "coeefficient", "icief", "ICOec", "icoefficient", "cief", "imiffee", "ericef", "stroek", "Coeff", "soefficient", "icioefficients", "imieless", "imiefer", "ciffee", "icoeph", "coeefficients", "loeefficients", "icieff", "icoek", "BOelf", "icoefficients", "icaffe", "coeef", "icoeff", "icaec", "imiefined", "icoffe", "ericefficients", "BOefficient", "icaelf", "ckief", "Coelf", "icefe", "coffee", "icoeval", "soeff", "coEF", "loeeless", "icoefined", "icef", "stroefer", "icof", "ICOefficients", "soef", "niceff", "ICOEF", "coefe", "eroef", "cof", "coeEF", "coeff", "kiefe", "icaef", "nicef", "loeeval", "iciffee", "BOeff", "stroefined", "cielf", "icoffee", "ciek", "imiek", "icoalf", "icaeff", "ericefficient", "icffee", "icoec", "coffe", "ciffe", "icoelf", "icalf", "ICOeph", "loeefer", "icoefer", "eroeval", "ICOelf", "icioef", "icioeless"], "cdlms": ["chardlcs", "condladmp", "cdlinmn", "chardlks", "cdnlms", "cdoljs", "cdlitens", "cdnlmn", "eddlnms", " cdllcs", "cddlmop", "cdllcs", "cmdlms", "cdlices", "cdllms", "eddlnns", "cdelces", "chardlitmn", "cdliwe", "caslmn", "cdlnmp", "rodlms", "casleftms", "cdlocks", "cdlces", "codlpkes", "cdnlwe", " cdlts", "cdlpmes", "cdlcms", "cdllmos", "cdlmt", "cdelts", "codlfs", " cdllems", "cdnlmes", "cdlwe", "ecdlts", "cdlkes", "cdlmos", "cdnlarms", " cdlljs", "cdlmop", "cdlarms", "cdlcmn", "cdlics", "condladmm", "cdladmm", "cdlmodules", "xdlems", "cdlens", "cplml", "chardlms", "cdlcems", "cdladmp", "cdlcts", "cdlcmop", "cdnlvs", " cdllms", "codlms", "cdlks", "cdlnems", "cdnlmp", "cdleftms", "cdlyks", "cdllarms", "codnlmes", "cdladts", "rodladml", "xdnlms", "rodladarms", "cdlbwe", "ctnlmos", "cdlimn", "cplbms", "codlpjs", "cddlmn", "codlbwe", "cdlbvs", " cdllts", "ctlmos", "rodladts", "casleftmodules", "cdllmodules", "cddelms", "cmdelces", "xdnlems", "xdlms", "chardlocms", "cdliems", "cdlymop", "chardlmop", "ecdlims", "cddlqs", "cmdelts", "ctnlts", "cdelms", "codlbms", "cdllmop", "chardlitmt", "cdlts", "cdlymn", "codnlems", "cddlmes", "ecdlits", "cplts", "cdlyms", "ctlfs", "cdnlqs", "cdlitmt", "cdlitmodules", "cplms", "ctnlfs", " cdljs", " cdllmos", "cmdlts", "cdlbms", "ecdlms", "cdllts", "codlkes", "cdnlts", "codlems", "xdnlmodules", "cdlifs", "cdnlmm", "rodlarms", "rodlml", "cdlitms", "cdlimes", "cdlbts", "codlqs", "eddlnems", "cddlcs", "cdlmn", "cdnlfs", "codlpmes", "cdllems", "cdlljs", "cdlml", "casleftens", "condlms", "rodladms", "cdolts", "cdliqs", "cdolms", "cdlimop", "cdlims", "cdlivs", "cdnlmos", "cdllfs", "eddlmn", "codlpms", "caslmodules", "xdnlts", "cdlbfs", "cdlinms", "condladmes", "cdlpms", "cdladml", " cdlmos", "cdlems", "cdlitcs", "cddelts", "cdliens", "cddlns", "cdolkes", "cdlinjs", "codnlqs", "codljs", "cdlnns", "cdlbmos", " cdlcs", "chardlmt", "cmdelms", "condladms", "condlmp", "cdolems", "cdlfs", "cdnlns", "ctnlms", "eddlnmn", "cdllml", "cdleftmodules", "cplbmos", "cdlocmop", "eddlems", "ecdlics", "eddlms", "cdljs", "ctlts", "cdolmos", "cdlns", "cdlmes", "cdlpjs", "cdnlml", "cddlms", "cdnlmodules", "xdlmodules", "caslens", "cdlcjs", "cplbts", "cdlcks", "cdlvs", "codlwe", "codlmes", "cdlbml", "cdlmm", "cdlnmm", "cddlts", "cdlitmn", "cmdelmes", "cdlcs", "chardlocks", "codlbvs", "codlbfs", "codnlms", "cdlinmes", "chardlmn", "ecdlimop", " cdlmodules", "cdlinmt", "caslms", "cdlnms", "xdlts", "cdelmes", "chardlitcs", "cdleftens", "cdleftmn", "ecdlcs", "eddlns", "cdlocms", "cdolmes", "cmdlces", "cdnljs", "cdnlcs", "cdladms", "cmdlmes", "cdladarms", " cdlems", "cdlnmes", "cdnlmt", "cdllmes", "cdladmes", "cddlems", "condlmm", "codlvs", " cdllmodules", "chardlitms", "cdlmp", "rodlts", "condlmes", "cddelems", "cdllces", "cplbml", "cdlqs", "cdlimodules", "casleftmn", "ecdlmop", "cdnlems", "cdlinkes", "cdlocmn", "cdlincs", "cddelmodules", "chardlocmn", "ctlms", "cdlpkes", "cdlits", "cdlnmn", "chardlocmop", "cplmos"], "recent": ["high", "record", "org", "dist", "today", "rank", "one", "rest", "head", "prime", "chance", "genre", "common", "history", "store", "success", "available", "foreign", "component", "order", "done", "cmd", "range", "off", "historic", "ient", "custom", "recorded", "rec", "after", "max", "req", "window", "command", "ord", "when", "known", "rend", "desc", "created", "version", "save", "this", "latest", "ready", "ident", "only", "new", "quick", "random", "quant", "valid", "good", "reverse", "Recent", "current", "reg", "region", "serial", "times", "tar", "priority", "trial", "modern", "depth", "cas", "sofar", "unique", "rem", "release", "rar", "dom", "final", "major", "confirmed", "remote", "parent", "feat", "critical", "many", "important", "server", "sid", "res", "released", "device", "progress", "raw", "domain", "client"]}}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3721, "substitutes": {"filt_ctx": ["filt_obj", "facet_cfg", "ffilter_ctx", "filt2obj", "ffilter_cas", "ffilter_cp", "fil_cp", "filt__conn", "facet_parent", "fld_tx", "filt__ct", "fil_context", "fil_pkg", "flt_obj", "filt2tx", "filt2context", "filt2ctx", "facet_tx", "filt_pkg", "filt__ctx", "flt_ctx", "fld_ctx", "flt_context", "filt_ct", "filt_tx", "fld_ct", "flt_tx", "filt_conn", "filt_context", "ffilter_context", "filt_cfg", "filt_cas", "filt__tx", "fld_conn", "fil_ctx", "fil_tx", "filt_parent", "fil_obj", "filt_cp", "facet_ctx"], "ctx": ["xs", "Context", "np", "nt", "comm", "grad", "cfg", "ct", "graph", "pt", "kt", "gc", "cc", "cp", "req", "mem", "window", "gs", "cf", "sys", "context", "x", "bc", "jac", "gt", "jp", "g", "kw", "sc", "history", "conn", "handle", "cb", "txt", "tm", "act", "pg", "cv", "tc", "obj", "unc", "hw", "pkg", "ctl", "cmd", "tx", "ctr", "config", "xp"], "index": ["param", "n", "count", "open", "iter", "point", "batch", "find", "new", "error", "status", "start", "thread", "i", "ind", "offset", "row", "valid", "number", "x", "context", "ion", "image", "info", "len", "name", "Index", "num", "set", "si", "run", "val", "ref", "order", "size", "address", "connect", "sp", "id", "update", "con", "result"], "filt_name": ["filtOname", "fld_data", "filtetricName", "fartzOname", "fitt_cache", "filt_prefix", "fld_Name", "filt__path", "filt09title", "fitt_name", "fartz_name", "filt_tree", "filt_ref", "facet_node", "fil_name", "facetOname", "fartzOlabel", "filtPname", "fld_name", "ffilter_type", "fitt_type", "filtOnode", "facet_name", "filt__node", "filtOpath", "fitt_user", "ffilter2type", "filt_user", "fartz_tree", "ffilter_prefix", "fartzOtree", "filtPtype", "filt_label", "fartz_key", "filtOName", "fitt_Name", "facetOnode", "filt_old", "ffilter2prefix", "filt09type", "filtetricname", "filt2name", "fil_title", "fitt_ref", "filt09name", "filtOkey", "filt2prefix", "facet_Name", "fartz_label", "fil_type", "filt09tree", "filt09label", "filtPcache", "filt__Name", "filt_data", "facet_path", "filt_key", "filtOtree", "ffilter2Name", "ffilter_name", "ffilter2name", "filt2Name", "filt2type", "filtPref", "fitt_old", "facetOName", "filt_path", "filtetricuser", "filtetricold", "fartzOkey", "filt_cache", "filt_title", "filt_type", "filt_node", "filt_Name", "filtOlabel", "facetOpath", "filt__name", "ffilter_Name", "filt09key"], "args": ["posts", "stats", "xs", "cards", "limits", "bs", "qs", "bytes", "options", "results", "utils", "cfg", "ags", "func", "values", "items", "atts", "arg", "ts", "points", "ps", "GV", "tags", "changes", "aux", "gs", "terms", "members", "parts", "arr", "fields", "keys", "tests", "ims", "outs", "fs", "ds", "flags", "settings", "docs", "params", "vs", "types", "ns", "bits", "ins", "rows", "amps", "vals", "weights", "locks", "GS", "cs", " arguments", "cmd", "js", "names", "Args", "actions"], "log_ctx": ["logingcss", "log_cf", "logtcf", "logtctx", "loglyjs", "log_nz", "blog_js", " log2obj", "basetcf", "prop_css", "logingcrit", "logitynz", "log2tx", "prop_nz", "base_ctx", "basetcp", "log_tx", "prop_ctx", "logingconn", "blog_ctx", "logingctx", "loglytx", "log_obj", "base_cp", "log_cp", "loglyctx", " log_context", " log2context", "log2context", "log_crit", " log_tx", "logityconn", "base_crit", "blog_tx", "basetctx", " log2tx", "logtcp", "logingcf", "log2ctx", "basetcrit", "logingcp", " log_obj", "log2obj", "log_css", "log_context", " log2ctx", "logityctx", "loglyconn", "blog_conn", "logtcrit", "logitycss", "log_conn", "prop_conn", "logingnz", "base_cf", "log_js"], "filt": ["Ffil", "flilt", "frilt", "Fil", "vilt", "Fiber", "tlt", "bilt", "filtration", "fiber", "fitt", "vil", " fil", "vfil", " fitt", "ffil", "biber", "viltration", "facilt", "bfil", " filtration", "facitt", "flil", "hil", "hiber", "frfil", "firm", " flt", " firm", "fril", "hfil", "friltration", "bil", "fliltration", "faclt", "faciltration", "facil", "flt", "tilt", "titt", " ffil", "facirm", "fil", "Filt", "hilt", "til", "flirm"], "inst_name": ["inst__key", "inst_key", " inst_NAME", "inst___name", "inst_nam", " inst_id", "inst__names", "instance_NAME", " inst_Name", "instance_nam", "instance_Name", "inst__Name", "inst_Name", "inst___nam", "inst_NAME", "instance_names", "inst___names", "inst___Name", "inst_names", "inst_id", "instance_name", " inst_names", " inst_key", "inst__name"], "tmp_args": ["tmp_xs", "tmp__lines", "emp_err", " tmp_params", "tmp67xs", "tmp__weights", "ppo_lines", "tmp___results", "temp_args", "tmp__args", "emp_flags", "tmp67params", "tmp_err", "tmp_weights", "tmp_igs", "tmp2params", "tmp___args", "tmp67arg", "ppo___results", "temp_xs", "tmp_params", "tmp_len", "tmp_results", "tmp___weights", "tmp67weights", "temp_params", "emp_igs", "tmp67len", "tmp_lines", "ppo_results", "tmp_arg", "tmp__results", " tmp_len", "tmp___lines", "temp_weights", "ppo___weights", "tmp2len", "ppo___args", "emp_args", "tmp2arg", "ppo_args", "ppo_weights", "ppo___lines", "tmp_flags", "tmp2args", " tmp_arg", "tmp67args"], "ret": ["count", "flag", "nl", "ext", "del", "rets", "det", "hash", "nt", "et", "Return", "re", "vet", "jump", "func", "att", "status", "lit", "gc", "alt", "pret", "ll", " Ret", "pas", "out", "rm", "def", "rev", "ft", "gt", "arr", "rt", "deg", "elt", "len", "fin", "reset", "reflect", "reg", "mel", "it", "value", "addr", "ry", "resp", "Ret", "RET", "res", "t", "val", "print", "last", "cont", "ref", "txt", "cert", "rel", "il", "usr", "mt", "progress", "f", "net", "cmd", "j", "result", "back", "rem"]}}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n", "idx": 3722, "substitutes": {"s": ["service", "n", "sg", "stats", "spec", "ports", "reads", "bs", "qs", "ants", "ses", "services", "comm", "results", "ls", "status", "ast", "als", "p", "ts", "its", "ps", "changes", "gs", "v", "is", "sys", "ops", "less", "parts", "ss", "conf", "ims", "ms", "se", "tes", "sv", "os", "fs", "ds", "eps", "set", "vs", "ows", "sts", "ats", "so", "gets", "rs", "ns", "as", "serv", "sb", "S", "ins", "y", "sw", "plays", "sq", "cs", "hs", "details", "js", "aws", "j", "sac", "ears", "bes"], "i": ["n", "oi", "cli", "length", "iri", "uri", "mi", "ind", " I", "is", "v", "ai", "ei", "ij", "ic", "it", "si", "to", "ie", "y", "h", "id", "ti", "io", "phi", "ish", "iu", "bi", "hi", "init", "q", "ui", "batch", "di", "integer", "pc", "x", "ini", "zi", "ims", "xi", "ami", "print", "index", "multi", "chain", "sim", "ri", "j", "I", "this", "point", "asi", "im", "ki", "p", "l", "ip", "ix", "ci", "us", "gi", "m", "k", "li", "b", "ii", "ji", "\u0438", "pi", "in", "g", "me", "qi", "t", "f", "o"], "send_coef_bits": ["send_coff_its", "send_coefficients_its", "send_coef_pins", "send_coiff_ats", "send_coef_bytes", "send_coff_bit", "send_coef__bits", "send_coeff_bytes", "send_coef__bytes", "send_coefficients_bytes", "send_coef_ats", "send_coef__its", "send_coeff_bits", "send_coef_its", "send_coff_bits", "send_coef__pins", "send_coff_bs", "send_coiff_bs", "send_coeff_pins", "send_coef__bs", "send_coiff_bit", "send_coiff_bits", "send_coef_bs", "send_coef_bit", "send_coefficients_bits", "send_coefficients_pins", "send_coeff_bs"], "cbits": [" cflags", "cplugins", "cuboxes", "xconds", "cdates", "cononds", "cnets", "cinets", "pcots", "xcots", "pcpieces", "lcbits", "ucplugins", " cits", " clocks", "pcdates", "lcdates", "cflags", "clevels", "cubits", "lcflags", "lcbis", "cibits", "conbps", " cboxes", " cplugins", "cfnets", "lcots", "gcbits", "couts", "ciouts", "pcbits", "cbps", " cpieces", "cfbits", "gcits", "xcbits", "cfouts", "lclevels", "lcnets", "cpieces", "conbis", "lclocks", "clocks", "cots", "lcplugins", "pcflags", "cilevels", "lcouts", "conds", "lconds", "cbis", "cflevels", "gclocks", "pcnets", "xcnets", "ucboxes", "lcbps", "xcbis", " cdates", "cuplugins", "cboxes", "ucbits", "xcflags", "lcpieces", "cits", "xcbps", "gcplugins", "conbits", "lcits"], "c": ["k", "n", "count", "cr", "cat", "q", "mc", "b", "ct", "lc", "ca", "con", "d", "cu", "r", "cache", "gc", "cc", "cp", "ec", "pc", "l", "cf", "v", "bc", "u", "dc", "co", "cm", "inc", "xc", "g", "fc", "ic", "nc", "\u00e7", "col", "ac", "C", "ce", "t", "ci", "cont", "unc", "uc", "cv", "tc", "h", "call", "z", "f", "cs", "add", "cd", "chain", "m", "j"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void ppc_spapr_init(ram_addr_t ram_size,\n                           const char *boot_device,\n                           const char *kernel_filename,\n                           const char *kernel_cmdline,\n                           const char *initrd_filename,\n                           const char *cpu_model)\n{\n    PowerPCCPU *cpu;\n    CPUPPCState *env;\n    int i;\n    MemoryRegion *sysmem = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    target_phys_addr_t rma_alloc_size, rma_size;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long load_limit, rtas_limit, fw_size;\n    long pteg_shift = 17;\n    char *filename;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n    if (rma_alloc_size == -1) {\n        hw_error(\"qemu: Unable to create RMA\\n\");\n        exit(1);\n    }\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n        rma_size = rma_alloc_size;\n    } else {\n        rma_size = ram_size;\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    rtas_limit = MIN(rma_size, 0x80000000);\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n    /* init CPUs */\n    if (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, cpu);\n        env->hreset_vector = 0x60;\n        env->hreset_excp_prefix = 0;\n        env->gpr[3] = env->cpu_index;\n    }\n    /* allocate RAM */\n    spapr->ram_limit = ram_size;\n    if (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n    }\n    /* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM */\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->external_htab = spapr->htab;\n        env->htab_base = -1;\n        env->htab_mask = spapr->htab_size - 1;\n        /* Tell KVM that we're in PAPR mode */\n        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        env->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(env);\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n                                           rtas_limit - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(filename);\n    /* Set up Interrupt Controller */\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    /* Set up VIO bus */\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n    }\n    /* Set up PCI */\n    spapr_create_phb(spapr, \"pci\", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (i = 0; i < nb_nics; i++) {\n        NICInfo *nd = &nd_table[i];\n        if (!nd->model) {\n            nd->model = g_strdup(\"ibmveth\");\n        }\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n            spapr_vlan_create(spapr->vio_bus, nd);\n        } else {\n            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n        }\n    }\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, \"sPAPR memory map:\\n\");\n    fprintf(stderr, \"RTAS                 : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, \"FDT                  : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (kernel_filename) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename,\n                                              KERNEL_LOAD_ADDR,\n                                              load_limit - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n            exit(1);\n        }\n        fprintf(stderr, \"Kernel               : 0x%08x..%08lx\\n\",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        /* load initrd */\n        if (initrd_filename) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}", "idx": 3731, "substitutes": {"ram_size": ["gram_addr", "gram_size", "RAM_SIZE", "gram_SIZE", "RAM_space", "ram_length", "RAM_size", "ramaxysize", "ramaxyname", "ramaxyaddr", "RAM_length", "ram_SIZE", "ram_space", "ram_name", "RAM_addr", "ramaxySIZE", "RAM_name", "gram_name", "ram_addr"], "boot_device": ["kernelableaddress", "bootableaddress", "boot_directory", "kernel_address", "bootabledirectory", "boot_dev", "bootabledevice", "kernelabledev", "kernelabledevice", "kernel_dev", "kernel_directory", "kernel_device", "boot_address", "kernelabledirectory", "bootabledev"], "kernel_filename": [" kernel___device", " kernel___file", " kernel_file", "kernel___device", "kernel___directory", "kernel_file", " kernel___directory", "kernel___file", " kernel_directory", " kernel___filename", " kernel_device", "kernel_directory", "kernel___filename", "kernel_device"], "kernel_cmdline": ["kernel_cplines", "kernel_cmdfile", "kernel_cmdlines", "kernel_commandline", "kernel_commandfile", "kernel_extlines", "kernel_cpline", "kernel_extfile", "kernel_cpfile", "kernel_commandlines", "kernel_extline"], "initrd_filename": ["initrb_filename", "initrb_file", "initrb_location", "initrd_location", "initrd__fn", "initrb_fn", "initrd__filename", "initrd_file", "initrd__location", "initrd_fn", "initrd__file"], "cpu_model": ["desktopaxyModel", "desktopaxycondition", "cpuaxyModel", "cpumyModel", "desktop_model", "cpuetymodel", "desktopaxymodel", " cpu_library", "cpu_config", "cpuaxycondition", "cpuitybase", " cpu_config", "desktop_base", "cpuitymodel", "cpu__library", "cpuitycondition", " cpu_models", "cpu_Model", "cpu_library", " cpu_Model", "desktopaxybase", "cpu__model", "cpu_link", "cpu_policy", "cpuetybase", "desktop_condition", "cpuaxybase", "cpu__models", "cpumymodel", "cpumypolicy", "cpuetymodels", "cpu_condition", "desktop_Model", " cpu_base", " cpu_label", "cpuaxymodel", "cpumylabel", "cpuetylibrary", "cpuityModel", " cpu_policy", " cpu_link", "cpu_base", "cpu__base", "cpu_label", "cpu_models"], "cpu": ["computer", "core", "proc", "cli", "cow", "python", "aco", "php", "ka", "uda", "nu", "c", "CPU", "worker", "cu", "util", "gc", "anc", "uu", "ruby", "cp", "cache", "kernel", "pc", "mem", "aux", "stat", "chip", "cn", "linux", "runner", "ctx", "cam", "conn", "uart", "process", "java", "bean", "docker", "node", "apache", "pu", "clock", "gpu", "hw", "ola", "mu", "processor", "vm", "mac", "cum", "efficiency", "nic", "mx", "alloc"], "env": ["em", "inst", "proc", "attr", "ext", "init", "Environment", "dem", "ew", "ef", "emb", "cfg", "eu", "nv", "entry", "ework", "esp", "eni", "environment", "ec", "buf", "vt", "mem", "window", "shell", "v", "ei", "next", "e", "context", "screen", "eng", "conf", "term", "exc", "esc", "ctx", "sv", "en", "conn", "scope", "server", "viron", "vs", "er", "gear", "state", "obj", "dev", "ent", "uv", "ptr", "hw", "ea", "console", "eg", "net", "priv", "config", "ev"], "i": ["phi", "sql", "iu", "I", "bi", "cli", "li", " multi", " c", "ui", " j", "batch", " m", "eu", "c", "di", "status", "im", "ii", "mi", " index", " si", "p", " mi", " bi", " I", "ip", "ai", "ei", "x", "e", "pi", "in", "ini", " pi", " di", "info", "ims", "me", "xi", " ti", "ami", " ii", "gu", "si", "it", "ix", "ci", " vi", "tim", " e", "index", "multi", "y", " ni", "us", "ti", "sim", "gi", "m", "j", "ex"], "sysmem": ["sysmemory", "ysmem", "skymb", "systemmem", "skyram", "systemram", " sysmemory", " sysram", "skymemory", " sysmb", "ysmemory", "sysram", "skymem", "ysram", "systemmemory", "ysmb", "sysmb"], "ram": ["sam", "ra", "gra", "iam", "RAM", "rum", "memory", "am", "sum", "mem", "mm", "row", "reg", "region", "cam", "ma", "gram", "res", "disk", "dev", "mb", "tem", "vm", "range", "rem", "dim", "ro", "rom"], "rma_alloc_size": ["rma_alloc_num", "rma_alloc2num", "rma_allocxsum", "rma_mem_size", "rma_alloc_sum", "rma_pos_size", "rma_cmp_size", "rma_oc_name", "rma_alloc_storage", "rma_alloc_name", "rma_allocxnumber", "rma_mem_addr", "rma_cmp_number", "rma_max_name", "rma_allocavsize", "rma_allocavlen", "rma_max_sum", "rma_oc_size", "rma_cmp_len", "rma_alloc_count", "rma_oc_SIZE", "rma_alloc2name", "rma_cmp_sum", "rma_alloc_addr", "rma_oc_count", "rma_allocxlen", "rma_pos_set", "rma_alloc_set", "rma_allocxsize", "rma_alloc_len", "rma_alloc2addr", "rma_alloc2sum", "rma_alloc_SIZE", "rma_alloc2size", "rma_mem_name", "rma_allocavnumber", "rma_pos_SIZE", "rma_alloc_number", "rma_max_size", "rma_allocavsum", "rma_mem_num"], "rma_size": ["rmaaxyscale", "rma00export", "rma_scale", "rva_align", "rMA_size", "rma___gz", "rva_gz", "rota_scale", "rma_length", "rmaaxysize", "rota_handle", "rma00align", "rma___align", "rma_align", "rma_limit", "rms_Size", "rms_length", "rms_size", "rva00gz", "rota_size", "rma_gz", "rva_size", "rms_diff", "rMA_limit", "rva00size", "rma00gz", "rva00export", "rma___size", "rma00size", "rma___export", "rma_diff", "rma_max", "rMA_scale", "rva00align", "rma_export", "rma_Size", "rmaaxyhandle", "rva_export", "rma_handle", "rMA_max"], "load_limit": ["load_delay", "load_length", "download_lim", "load_policy", "Load_limit", "load_lim", "load_margin", "Load_length", "download_margin", "download_delay", "Load_size", "download_limit", "load_size", "Load_policy"], "rtas_limit": ["rtras_limit", "rtaos____filter", "rtAs_limit", "rtas____filter", "rtAs_size", "rtas_ignore", "rtas_block", "rtas12offset", "rtaos_filter", "rtaos_offset", "rtas48limit", "rtas48wrapper", "rtas_offset", "rtas_range", "rtas48offset", "rtaszignore", "rtas_size", "rtaos____limit", "rtas12wrapper", "rtas____limit", "rtas____wrapper", "rtas_wrapper", "rtras_range", "rtas__block", "rtas_filter", "rtras_size", "rtaszrange", "rtas____offset", "rtas____range", "rtas__size", "rtas12limit", "rtaos_limit", "rtaos_wrapper", "rtas__offset", "rtaos____wrapper", "rtaszlimit", "rtas__limit", "rtAs_offset", "rtAs_block", "rtas12filter", "rtas48filter", "rtas____size", "rtras_ignore", "rtaos____offset", "rtas____ignore", "rtaszsize"], "fw_size": ["hw_info", "hw_size", "hw_Size", "fw_info", "fw_Size", "hw_SIZE", "fw_SIZE"], "filename": ["ame", "ename", "wire", "fle", "metadata", "src", "kl", "family", "username", "fp", "socket", "prefix", "kw", "file", "fs", "location", "kj", "params", "fn", "framework", "txt", "Filename", "files", "fw", "json", "nm", "buffer"]}}
{"project": "FFmpeg", "commit_id": "69d0a2922f76e4e121c9f434bdf29f55b26c0c66", "target": 0, "func": "static av_cold int sonic_encode_init(AVCodecContext *avctx)\n\n{\n\n    SonicContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    int i, version = 0;\n\n\n\n    if (avctx->channels > MAX_CHANNELS)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo streams are supported by now\\n\");\n\n        return AVERROR(EINVAL); /* only stereo or mono for now */\n\n    }\n\n\n\n    if (avctx->channels == 2)\n\n        s->decorrelation = MID_SIDE;\n\n    else\n\n        s->decorrelation = 3;\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)\n\n    {\n\n        s->lossless = 1;\n\n        s->num_taps = 32;\n\n        s->downsampling = 1;\n\n        s->quantization = 0.0;\n\n    }\n\n    else\n\n    {\n\n        s->num_taps = 128;\n\n        s->downsampling = 2;\n\n        s->quantization = 1.0;\n\n    }\n\n\n\n    // max tap 2048\n\n    if ((s->num_taps < 32) || (s->num_taps > 1024) ||\n\n        ((s->num_taps>>5)<<5 != s->num_taps))\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of taps\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    // generate taps\n\n    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));\n\n    for (i = 0; i < s->num_taps; i++)\n\n        s->tap_quant[i] = ff_sqrt(i+1);\n\n\n\n    s->channels = avctx->channels;\n\n    s->samplerate = avctx->sample_rate;\n\n\n\n    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);\n\n    s->frame_size = s->channels*s->block_align*s->downsampling;\n\n\n\n    s->tail_size = s->num_taps*s->channels;\n\n    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));\n\n    if (!s->tail)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );\n\n    if (!s->predictor_k)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < s->channels; i++)\n\n    {\n\n        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));\n\n        if (!s->coded_samples[i])\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n\n\n\n    s->window_size = ((2*s->tail_size)+s->frame_size);\n\n    s->window = av_calloc(s->window_size, sizeof(*s->window));\n\n    if (!s->window)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->extradata = av_mallocz(16);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&pb, avctx->extradata, 16*8);\n\n\n\n    put_bits(&pb, 2, version); // version\n\n    if (version == 1)\n\n    {\n\n        put_bits(&pb, 2, s->channels);\n\n        put_bits(&pb, 4, code_samplerate(s->samplerate));\n\n    }\n\n    put_bits(&pb, 1, s->lossless);\n\n    if (!s->lossless)\n\n        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision\n\n    put_bits(&pb, 2, s->decorrelation);\n\n    put_bits(&pb, 2, s->downsampling);\n\n    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024\n\n    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table\n\n\n\n    flush_put_bits(&pb);\n\n    avctx->extradata_size = put_bits_count(&pb)/8;\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n\n        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n\n\n    avctx->frame_size = s->block_align*s->downsampling;\n\n\n\n    return 0;\n\n}\n", "idx": 3743, "substitutes": {"avctx": ["avjp", "avecm", "avepkg", "avcu", "vrpkg", "abctx", " avnp", "averconn", "avtc", "wavctx", "avecontext", " avconn", "afcmp", "avcfg", "afctx", "avcontext", "avcm", "wavcmp", "ajcfg", "avercv", "abtx", "avercontext", "avecfg", "vrcmp", "ajjac", "averesp", "wavtx", "avercp", "avercu", "aveconf", " avcp", "avecpu", "afcp", "avecu", "avenp", "avejac", "wavpkg", " avcontext", "avebc", "abcontext", "ajcmp", "averctx", "avpkg", "avecmp", "avercmp", "ajbc", "avecp", " avbc", "ajnp", "avertx", "afjp", "avnp", "avconn", "afcm", "avecv", "ajtx", "aveconn", "savcp", "abcv", "afresp", "avercpu", "avresp", "avectx", "savctx", " avtx", "avercm", "savcontext", "vrtx", "avbc", "afjac", "avcmp", "abcpu", "ajcu", "ajconn", "abtc", "avtx", "vrctx", "aftx", " avtc", "averjp", "avejp", "ajconf", "avercfg", "avconf", " avcmp", "avertc", "afconf", "averresp", "savconn", "avcv", "avcpu", "avcp", "ajctx", "avjac", "avetx"], "s": ["ants", "services", "views", "is", "v", "ops", "parts", "ies", "fs", "ds", "eps", "bits", "sb", "scl", "h", "locks", "sq", "hs", "actions", "sports", "reads", "bs", "ses", "c", "status", "ims", "sv", "os", "vs", "sts", "ats", "as", "ids", "details", "j", "ports", "qs", "his", "scripts", "utils", "uploads", "states", "p", "ps", "comments", "l", "sys", "terms", "less", "ss", "tests", "ms", "ar", "bis", "set", "so", "rates", "args", "sl", "mods", "sa", "m", "spec", "stats", "ads", "xs", "self", "comm", "results", "es", "sets", "ls", "pers", "w", "als", "ts", "its", "tags", "changes", "gs", "ers", "g", "se", "tes", "ows", "settings", "t", "ns", "rs", "ins", "S", "obj", "sw", "cs", "js", "aws"], "pb": [" sk", "bp", " tmp", " pl", " sp", " pc", " subp", " p", " cp", "p", " sc", " db", " ns", " po", " pos", " buf", " pa", " ap", " tf", " salsa", "uv", " mp", " clip", " cl", " np", " pad", " prob", " proto", " pat"], "i": ["n", "oi", "cli", " multi", " p", "mi", " si", " mi", " I", "ai", "is", "ij", " n", "ic", "go", "it", "si", "h", "y", "ti", "iu", "bi", "hi", " v", "ui", " m", "c", "di", "x", " pos", " di", "zi", "ims", "xi", " ti", " ii", "index", "multi", " t", "sim", " x", "j", "I", " li", "im", "ki", " index", " id", "p", " bi", "ip", "ms", " iter", "key", "ix", "ci", "us", "dr", "mu", "gi", "m", "k", "li", " j", "ii", " counter", "u", "pi", "in", " pi", "me", "qi", " e", "f", "print"]}}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n\n{\n\n    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n\n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n\n\n    if (mode > 6U) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"out of range intra chroma pred mode at %d %d\\n\",\n\n               h->mb_x, h->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if (!(h->top_samples_available & 0x8000)) {\n\n        mode = top[mode];\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n\n        mode = left[mode];\n\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n\n                   (!(h->left_samples_available & 0x8000)) +\n\n                   2 * (mode == DC_128_PRED8x8);\n\n        }\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n", "idx": 3748, "substitutes": {"h": ["ph", "ht", "hi", "hash", "dh", "q", "eh", "hm", "comm", "b", "c", "ih", "hl", "th", "w", "rh", "hp", "he", "bh", "p", "hd", "cache", "hh", "rec", "wh", "l", "uh", "v", "sh", "header", "H", "x", "e", "here", "hal", "pp", "o", "history", "handle", "it", "host", "kh", "wcs", "t", "oh", "http", "hz", "act", "y", "hw", "f", "hs", "ch", "m", "ah"], "mode": ["method", "time", "cmp", "metadata", "pose", "loop", "te", "language", "direction", "member", "pe", "slave", "dm", "module", "role", "scale", "cmd", "range", "id", "purpose", "off", "ode", "raid", "test", "fm", "md", "phase", "status", "command", "kind", "power", "dd", "message", "def", "mom", "force", "mid", "when", "perm", "mt", "option", "ace", "Mode", "version", "chain", "mega", "dim", "gone", "style", "mod", "try", "mobile", "match", "mm", "stage", "distance", "format", "menu", "area", "key", "code", "set", "position", "mission", "state", "mit", "tm", "phrase", "feature", "depth", "mac", "m", "result", "tone", "de", "ase", "form", "enable", "mask", "type", "timeout", "send", "e", "theme", "conf", "me", "MODE", "network", "driver", "activity", "layout", "lock", "zero", "device", "size", "act", "f", "mate", "none"], "is_chroma": ["is_chromata", "is_chA", "is_romo", "is_cho", "is_chata", "is_chromA", "is_romA", "is_chromo", "is_romata", "is_roma", "is_romia", "is_chromia", "is_cha"], "top": ["first", "tp", "trop", "high", "toc", "above", "at", "pt", "alt", "mp", "tops", "tip", "tool", "onet", "ap", "title", "ops", "current", "best", "lt", "upt", "hop", "all", "bottom", "master", "to", "op", "meta", "Top", "t", "part", "user", "table", "root", "soc", "tab", "TOP", "tmp", "bot", "tools", "typ", "scroll", "client"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n", "idx": 3755, "substitutes": {"info": ["core", "iter", "metadata", "error", "one", "cache", "i", "history", "store", "it", "success", "http", "order", " inf", "setup", "address", "id", "import", "off", "test", "note", "init", "app", "INFO", "warning", "api", "status", "about", "at", "map", "sum", "auth", "warn", "ion", "def", "kind", "command", "list", "num", "loc", "inf", "index", "debug", "no", "edit", "details", "add", "config", "data", "help", "style", "entry", "start", "try", "ip", "good", "trace", "search", "information", "full", "report", "op", "ci", "state", "alias", "notice", "Info", "work", "query", "exec", "summary", "comment", "fo", "local", "check", "stat", "parse", "pi", "conf", "link", "t", "now", "lock", "content", "obj", "f", "update"], "as": ["au", "asy", "ase", "ars", "ab", "bs", "ag", "app", "aster", "an", "asha", "ais", "from", "asi", "asis", "ast", "ias", "jas", " As", "av", "am", "ps", "AS", "mas", "asm", "nas", "is", "ras", "gs", " AS", "ap", "aos", "ms", "ar", "sis", "asar", "sv", "ac", "acs", "a", "las", "asio", "ats", "pa", "rs", "ak", "asp", " a", "ass", "asa", "asia", "js", "sa", "ams", "aser", "As", "aus"]}}
{"project": "qemu", "commit_id": "4fb588e95bacb770746cc794ef165fd71a4d27ea", "target": 0, "func": "static void block_job_completed_txn_abort(BlockJob *job)\n\n{\n\n    AioContext *ctx;\n\n    BlockJobTxn *txn = job->txn;\n\n    BlockJob *other_job, *next;\n\n\n\n    if (txn->aborting) {\n\n        /*\n\n         * We are cancelled by another job, which will handle everything.\n\n         */\n\n        return;\n\n    }\n\n    txn->aborting = true;\n\n    /* We are the first failed job. Cancel other jobs. */\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        aio_context_acquire(ctx);\n\n    }\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        if (other_job == job || other_job->completed) {\n\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n\n             * them; this job, however, may or may not be cancelled, depending\n\n             * on the caller, so leave it. */\n\n            if (other_job != job) {\n\n                block_job_cancel_async(other_job);\n\n            }\n\n            continue;\n\n        }\n\n        block_job_cancel_sync(other_job);\n\n        assert(other_job->completed);\n\n    }\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        block_job_completed_single(other_job);\n\n        aio_context_release(ctx);\n\n    }\n\n}\n", "idx": 3763, "substitutes": {"job": ["bug", "gov", "work", "normal", "org", "build", "batch", "item", "jump", "cell", "new", "com", "worker", "block", "jobs", "try", "Job", "band", "row", "good", "jj", "journal", "command", "member", "image", "queue", "obs", "jp", "common", "name", "ob", "big", "task", "go", "manager", "msg", "op", "now", "node", "module", "tab", "package", "mb", "unknown", "cmd", "project", "none", "event", "jo", "j", "db"], "ctx": ["qu", "wx", "xs", "kb", "pool", "np", "nt", "mc", "cmp", "cfg", "ct", "ca", "lc", "nd", "dl", "kt", "comp", "kl", "anc", "cc", "bo", "cp", "xy", "req", "ind", "mem", "cf", "ck", "mk", "sys", "context", "bc", "jac", "co", "kw", "xc", "crit", "tz", "jp", "nc", "box", "conn", "tk", "addr", "cb", "loc", "resp", " cx", "iat", "wd", "unc", "act", "tc", "tab", "cl", "hw", "pkg", "fw", "cmd", "tx", "acl", "ctr", "xp", "ctrl", "urg"], "txn": ["xj", "actnb", "exns", "txnor", "xn", "seqns", "transon", "Txj", "timesnr", "transns", "exnt", "actne", "Txns", "txv", "txne", "transm", "exnor", "laton", "txnt", "exn", "fxnr", "taxnt", "txon", " txv", "latn", "timesn", "xne", "txout", "txnr", "taxnor", "txN", "Txn", "Txout", "transN", " txns", "xnt", "Txv", "txnw", "transj", "latnw", "seqne", "taxn", "xnb", "latns", "seqnb", " txj", "xns", "Txm", "fxn", "xon", "latnr", "txj", "latne", "xm", " txon", "Txon", "fxnw", "timesne", "txnb", "xv", "seqn", "txns", "xnor", "latout", "txm", "taxns", "transn", "TxN", "actn", "timesnw", "actns", " txN", "fxne", "xout"], "other_job": ["otherxJob", "otherJJob", "outer_word", "odd_manager", "common___cmd", "other_try", "another_car", "unknown_job", "another_org", "other_db", "wrongxword", "wrong_Job", "othererworker", "another_word", "otherlyjob", "other_band", "other___job", "other___manager", "other__process", "otherJbuilder", "another_worker", "othercurrentjob", "another___com", "anotherJdb", "othercurrentfire", "oddcurrentjob", "other_cmd", "otherJbug", "otherxword", "another___worker", "other_Job", "common___org", "other___builder", "another_bug", "other___name", "other___try", "other___package", "otherJcmd", "outer_job", "block_band", "other___car", "wrong_word", "another__word", " other___try", "odd_Job", "otherJprocess", "same_cell", " other___name", "other_manager", "othertband", "othertlink", "othercurrentmanager", "another_cor", "other_bug", "another___car", "otherThedb", "unknown_worker", "otherercmd", "another__bug", "other_request", "oddcurrentJob", "otherJworker", "unknown_package", "another__org", "other_org", "other__word", "othererbuilder", "blocktjob", "otherJorg", "wrongxrequest", "othererjob", "otherjcor", " other_db", "otherJcell", "other__job", "otherxrequest", "otherThejob", "otherThebyte", "other_worker", "othererorg", "other_batch", "wrongxJob", "block_job", "otherjjob", "odd_fire", "another_job", "otherxjob", "common___builder", "block_batch", "othercurrentJob", "another_byte", "other___worker", "other_byte", "otherjJob", "otherJmanager", "another_db", "othererlink", "same_job", "otherJcom", "common_job", "common___job", "other__bug", "other_item", " other_name", "other__cell", "common_cmd", "unknown_link", "odd_job", "block_link", "otherlybatch", "oddcurrentmanager", "common_org", "other_fire", "otherJrequest", "anotherJcor", "otherJbyte", "another___job", "another___manager", "other_package", "other_process", "other_com", "other___org", "outer_item", "other___com", "wrong_request", "otherlylink", "blocktbatch", "otherlyband", "anotherJjob", "otherJcor", "other_cor", " other_Job", "otherJword", " other___job", "otherJjob", "wrong_job", "common_builder", "otherjmanager", "otherThecor", "otherJdb", "another__job", " other_try", "other_word", "otherjdb", "blocktlink", "other__org", "other___cmd", "other_car", "other___link", "another_com", "another_manager", "same_process", "other_name", "oddcurrentfire", "othererpackage", "other_builder", "other_cell", "other_link", "same_bug", "anotherJbyte", "othertbatch", "othertjob", "blocktband", "wrongxjob", "otherjbyte", "otherjfire"], "next": ["nl", "zip", "gov", "sec", "iter", "seq", "self", "new", "nd", "buf", "req", " NEXT", "gt", "list", "jp", "current", "result", "queue", "ne", "prev", "link", "key", "ng", "fee", "fn", "state", "txt", "done", "obj", "ptr", "tmp", "Next", "chain", "news", "j", "data"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n", "idx": 3766, "substitutes": {"mr": ["lr", "rar", "RM", "mc", "mir", "tr", "vr", "kr", "rg", "r", "drm", "hr", "gr", "rm", "bm", "cm", "MT", "rt", "ocr", "Mr", "mn", "MR", "rr", "rn", "br", "adr", "irm", "sr", "rpm", "rs", "tm", "shr", "mt", "dr", "ml", "m"], "size": ["count", "empty", " length", "length", "grow", " Size", "sum", "type", "mem", "out", "ize", "g", "len", "name", "space", "area", " sizes", "code", "set", "iz", "fee", " data", "zero", "SIZE", "scale", "z", "shape", "storage", "address", "id", "Size", "data"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3770, "substitutes": {"ioc": ["piroc", "pioci", "abiocon", "ooc", "iroc", " iOC", "abiosc", "ioci", "gioci", "biosc", " ioci", "giOC", "abiocy", "itoci", " iocon", "bioc", " ioco", "siOC", "iosc", "abioc", "dioc", "ooco", "dioco", "biocon", " iocy", "gioco", " iosc", "oroc", "diroc", "oosc", "itocon", " iroc", "piosc", "sioc", "iocon", "piocon", "gioc", "iOC", "itoc", "ioco", "pioc", "diosc", "sioco", "sioci", "itroc", "biroc", "pioco", "iocy", "biocy", "bioco"], "localAddr": ["localAddressrs", " localAddrc", "localAddressl", " localAttp", " localAddrt", "localAddl", "localaddrc", "localAddressrc", " localAttrt", "localAddressr", "localAddrc", "localaddl", "localAttrc", "localPartp", "localAddp", " localAttry", " localAddry", "localaddp", "localAttrs", "localAddrt", " localAddressr", "localAttl", "localAttr", "localPartr", " localAttr", " localAddressp", "localAttp", " localAddressl", " localAddrs", "localAttrt", "localAddrs", " localAddl", " localAddressrc", " localAddp", "localAddressp", "localAddry", "localaddr", "localPartry", "localAttry", "localPartrt"], "remoteAddr": ["remotePortl", "remoteAddri", "remoteAttr", "remoteAttn", "remoteAttachl", "remoteAttR", " remoteAttp", "RemoteAddp", " remotePortr", "RemoteAddR", "remoteAddR", " remotePortl", " remoteAttri", "remoteAttl", "remotePortn", "remoteAddp", " remoteAttr", "remotePortr", "remoteAddn", "RemoteAddr", "remoteAtter", "remotePortp", "remoteAttri", "remoteAdder", "RemotePortp", "RemotePortR", " remoteAddl", "remoteAttp", " remoteAttl", "RemotePorter", " remoteAddp", " remotePortp", "remoteAttachr", " remoteAddri", "remotePortR", "remoteAttachp", "remotePorter", "RemotePortr", " remotePortn", " remoteAddn", "remoteAddl", "RemoteAdder", "remoteAttachri"], "errp": ["diepc", " errm", "diep", " errps", "errorr", "rrm", "errpa", "erps", " errr", "errorpc", "dier", "errpc", "rrr", "errps", "erp", "errorps", "errorm", "erP", "errr", "rrP", "rrp", " errpc", "errorpa", "errorp", "errm", "errP", " errpa", "err", "errorP", "diepa", " errP"], "fd": ["lf", " td", "fm", "fb", "form", "ff", " f", "gz", " df", "pd", "gd", "fr", "func", " fin", "ud", "td", "nd", "d", "dl", " fut", "FH", "hd", "dy", "fps", "sd", "dig", "fe", "fx", "fp", " fs", "cf", "fun", "fi", "dd", "bf", "FD", "fc", "elt", " ff", "fin", "df", "handle", "fs", "ds", "dt", "fl", "ld", "dat", "fee", "fn", "da", "bd", "ptr", "fed", "dra", "f", "ln", "ffff", " fid", " dur", "pid", "db"]}}
{"project": "qemu", "commit_id": "bb3cb951ef530da7d248051347c974e4d20e6ea0", "target": 0, "func": "static void dec_bit(DisasContext *dc)\n\n{\n\n    TCGv t0, t1;\n\n    unsigned int op;\n\n    int mem_index = cpu_mmu_index(dc->env);\n\n\n\n    op = dc->ir & ((1 << 9) - 1);\n\n    switch (op) {\n\n        case 0x21:\n\n            /* src.  */\n\n            t0 = tcg_temp_new();\n\n\n\n            LOG_DIS(\"src r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            if (dc->rd) {\n\n                t1 = tcg_temp_new();\n\n                read_carry(dc, t1);\n\n                tcg_gen_shli_tl(t1, t1, 31);\n\n\n\n                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);\n\n                tcg_temp_free(t1);\n\n            }\n\n\n\n            /* Update carry.  */\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x41:\n\n            /* srl.  */\n\n            t0 = tcg_temp_new();\n\n            LOG_DIS(\"srl r%d r%d\\n\", dc->rd, dc->ra);\n\n\n\n            /* Update carry.  */\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            if (dc->rd) {\n\n                if (op == 0x41)\n\n                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                else\n\n                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n            }\n\n            break;\n\n        case 0x60:\n\n            LOG_DIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x61:\n\n            LOG_DIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x64:\n\n        case 0x66:\n\n        case 0x74:\n\n        case 0x76:\n\n            /* wdc.  */\n\n            LOG_DIS(\"wdc r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0x68:\n\n            /* wic.  */\n\n            LOG_DIS(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n", "idx": 3778, "substitutes": {"dc": ["cca", "dep", "central", "td", " mc", "cache", "nc", "draw", "coord", "ds", "dt", "fee", "dm", "cus", "cmd", "vc", "cr", "c", "di", "lc", "cu", "dp", "rec", "pc", "ga", "dd", "def", "dat", "DC", "ctl", "wp", "desc", "dim", "dan", "cat", "rc", "mc", "ca", "dl", "oc", "cc", "ec", "sys", "cm", "kw", "document", "ctx", "df", "dir", "disk", "dr", "du", "iac", "mac", "de", "spec", "design", "exec", "d", "gc", "bc", "disc", "fc", "sc", " DC", "ac", "adr", "doc", "da", "device", "tc", "dev", "eric", "cs", "cd", "db"], "t0": ["t512", "dt512", "pt000", "ptZero", "lat000", " t2", "tzero", "wt000", "tt1", "dtZero", "targ", "dt0", "pt0", "at0", "tZero", "T000", "tyarg", " t8", "tcarg", "T512", "tums", " t000", "kt000", "t10", "tt08", "at000", "tc050", " t08", "ta8", "vt\t", "ty0", "t08", "kt1", "Targ", "wt0", "ta0", "dt\t", "pt1", "tyums", "tracearg", " tZero", "tMac", "trace0", "ptMac", "kt0", "trace050", "t050", "tazero", "T8", "trace1", "T08", "TZero", "T\t", "t000", "vt1", "vt512", "at2", "pt2", "lat0", "T050", "tcZero", " tzero", "t2", " t10", "ttums", "tt0", "tt10", "wtums", "vt0", "T10", "lat1", " t00", "t00", "dt1", "ty000", "tc1", "ttarg", "at00", "TMac", "t140", "T1", "T0", "Tzero", "kt140", "tc0", "tcMac", "tt000", "T140", "t\t", "t8", "wtarg", "ta1", "lat140", "pt00"], "t1": [" tor", "T01", "T3", "m0", "ter2", "t3", " t2", "m1", "t2", "tt01", "ter1", "tt001", "T1", "T0", "tt1", "T2", "wt2", " t3", "t001", "dt0", "t01", "tt0", " t127", "td384", "ter127", "f2", "td1", "td0", " t5", "f1", "wtup", " t001", "t384", "temp0", "dt384", "temp2", "dtor", "dt1", "t127", "T127", "T384", "dt5", " t01", "ter0", " tup", "m3", "temp1", "tup", "T5", "wt1", "tor", "t5", "T001", "Tor", "temp001", "fup", "m2"], "op": ["eq", "app", "Op", "ep", " Op", "cmp", "up", "oop", "lit", "ot", "mod", "comp", "opt", "oc", "p", "mp", "arg", "type", "ps", " ip", " cop", "ip", "OP", "ap", "ops", "oper", "oe", "operation", "jp", "omp", "opp", "ic", "bit", "pp", "cop", "num", "hop", "it", "operator", "ver", "perm", "ie", "yp", "pop", " OP", "sp", "cmd", "id", "typ", "ok", "o", " hop", "ype", "top"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 3795, "substitutes": {"mr": ["bp", "cr", "lr", "tp", "rar", "fr", "hm", "tr", "vr", "wr", "lc", "kr", "km", "r", "drm", "pr", "rer", "rl", "cp", "pc", "asm", "hr", "mk", "rm", "ocr", "ms", "Mr", "MR", "mn", "rr", "rn", "br", "adr", "irm", "wcs", "rpm", "sr", "rs", "usr", "tm", "shr", "mt", "dr", "mor", "nr", "ml", "nm", "ctr", "m", "mx"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n", "idx": 3811, "substitutes": {"s": ["n", "sg", "q", "b", "c", "r", "ains", "p", "ts", "ps", "is", "v", "gs", "e", "x", "in", "ss", "g", "sc", "ctx", "os", "ies", "fs", "ds", "a", "sts", "t", "ns", "rs", "as", "sb", "S", "h", "cs", "tx", "js", "m"], "insn": ["psns", "ingn", " inspn", " inssn", " insne", "tsns", "ainsun", "insun", "rsn", "linsgn", "insg", "pssn", "tscn", "Insn", "ainsyn", "INSn", "rsne", "psne", "rsns", "risg", "Inspn", " insg", " insun", "INScn", "risn", " insyn", "inssn", "rssn", "ainsne", "tsn", "psn", "insne", " insns", "inns", "incn", "rsgn", "inscn", "ainsn", "linssn", "insns", "psun", "rispn", "inn", "psgn", "Insns", "linsn", "insgn", "linsne", "inyn", "Insg", "INSns", "risns", "INSsn", "inne", "tssn", "inspn", "insyn", "ainssn"], "r1": ["t1", "t3", "cr3", "p3", "t2", "cr2", "p11", "p1", " r3", "r01", "or1", " r01", "cr1", "or3", "p2", "or2", " r11", "or01", "r3", "cr01", "r11", "t11"], "r2": ["arTwo", "rr2", " r4", " rTwo", "rTwo", "R3", " r62", " r3", "ar62", "r62", "R4", "r4", "R1", "ar2", "lr3", "rr62", "lr2", "rr4", "R2", "lr1", "lr4", "r3", "rrTwo", "ar4"], "rn": ["n", "cr", "lr", "nl", "ra", "dn", "rar", "rc", "ren", "np", "rd", "wr", "rb", "kr", "rh", "r", "drm", "rl", "rw", "rx", "fp", "rf", "orn", "rm", "cn", "rt", "rob", "rr", "lp", "arn", "rin", "rs", "fn", "cv", "ern", " re", "err", "nn", "RN", "RP", "mr"], "ofs": ["OFc", " ofc", "ofsd", " ofms", " ofsd", "\u00f3js", "offs", "Ofs", "OFjs", "\u00f3s", "Ofsd", "Ofjs", "Ofc", " ofxs", "OFts", "ofgs", "oftms", "OFxs", "\u00f3c", " ofgs", "ofts", "offts", "Ofts", "Ofgs", "ofc", "oftxs", "ofjs", "offjs", "oftjs", "OFgs", "ofxs", "\u00f3sd", " ofts", "offxs", "offms", "Ofxs", "ofms", "OFs", " ofjs"], "pre": ["tp", "PRE", "ra", "get", "fr", "et", "re", "up", "tr", "post", "ble", "pb", "pt", "per", "pr", "rec", "py", "p", "mp", "inter", "Pre", "ps", "ve", "fp", "prime", "web", "pres", "prefix", "ap", "jp", "current", "prev", "lp", "res", "fn", "rel", "ref", "wp", "pri", "tx", "j", "po", "pa"], "w": ["wa", "wk", "n", "wx", "nw", "W", "q", "re", "b", "wr", "tw", "write", "r", "p", "rw", "wb", "wh", "word", "mem", "window", "v", "u", "x", "kw", "iw", "ow", "wi", "wo", "t", "y", "h", "fw", "f", "wp", "wl", "m", "wt"]}}
{"project": "qemu", "commit_id": "2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590", "target": 0, "func": "static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value / 1000;\n\n}\n", "idx": 3815, "substitutes": {"obj": ["inst", "proc", "attr", "np", "impl", "nt", "self", "org", "att", "ot", "pr", "oid", "onet", "sys", "ob", "ctx", "os", "conn", "expr", "op", "t", "ns", "object", "ref", "act", "h", "hw", "tmp", "pkg", "imp", "Obj", "cmd", "id", "js", "o", "owner", "po", "instance", "ex"], "v": ["n", "q", "vi", "vr", "b", "c", "nv", "m", "r", "p", "vt", "V", "i", "tv", "ve", "l", "u", "e", "g", "sv", "vis", "vs", "op", "t", "vp", "cv", "uv", "f", "vm", "vc", "vy", "o", "j", "ev"], "opaque": ["opsacity", "ospient", "ocaque", "opacity", "opsaque", "ospaque", "opane", "ospane", "opsane", "ocient", "opsient", "ocane", "ocacity", "opient", "ospacity"], "name": ["other", "n", "attr", "ame", "str", "ename", "nam", " names", "new", "comment", "not", "error", "specified", "path", "family", "local", "am", "type", "on", "word", "mem", "valid", "prefix", "title", "term", " Name", "key", "a", "part", "t", "Name", "alias", "size", "NAME", "no", "dev", "unknown", "broad", "named", "id", "none", "names", "label", "m", "defined", "data"], "errp": ["erpa", "derpa", " erp", "derp", "errping", "errpa", " errr", "errorper", "rerP", "rerp", "erp", "errpg", " erper", "errr", "rrP", "rrp", "rerping", "errorpa", "errorp", " errpg", "rrpg", "derr", " errping", "errP", " errper", " errpa", "rrper", " erpg", "err", "errorP", "errper", "rerpa", "errorping", " errP"], "cpu": ["core", "proc", "tp", "ork", "np", "nu", "CPU", "cu", "prof", "gc", "p", "kernel", "cp", "pc", "mem", "ck", "onet", "sys", "aq", "pixel", "linux", "ctx", "conn", "lp", "process", "node", "pu", "phys", "cv", "clock", "gpu", "hw", "mu", "processor", "phy", "net", "cum", "mx"], "value": ["test", "count", "property", "input", "get", "min", "length", "unit", "see", "values", "byte", "status", "entry", "start", "try", "VALUE", "max", "sum", "type", "word", "number", "attribute", "context", "field", "message", "power", "image", "expression", "result", "current", "num", "key", "flow", "set", "position", "widget", "total", "fee", "val", "now", "ue", "text", "index", "size", "no", "we", "scale", "weight", "raw", "json", "range", "version", "label", "buffer", "update", "always", "data", "Value", "instance"]}}
{"project": "qemu", "commit_id": "6764579f894950afe87d8ec3b323adde8925d4fd", "target": 1, "func": "static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    struct cow_header_v2 cow_header;\n\n    struct stat st;\n\n    int64_t image_sectors = 0;\n\n    char *image_filename = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockDriverState *cow_bs;\n\n\n\n    /* Read out options */\n\n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;\n\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n", "idx": 3824, "substitutes": {"filename": ["localhost", "ame", "ename", "sbm", "ren", "FN", "jpg", "aka", "fle", "path", "kl", "png", "username", "FH", "IL", "kan", "fp", "LOC", "prefix", "knife", "amen", "file", "name", "nil", "source", "println", "bite", "SourceFile", "location", "kj", "SOURCE", "flake", "fn", "fd", "txt", "oval", "NAME", "Filename", "AME", "FIL", "f", "fil", "ames", "nm", "til", "PATH", "directory"], "opts": ["opcs", "optcs", "poppt", "iops", " opss", "operte", "options", "popts", "opps", "prot", " opcs", "optorts", " opte", " opt", "OPts", "opt", "iopTS", "OPs", "alt", "optpt", " opps", "operorts", "opss", "pross", "prots", "props", "poptions", "iopts", "optds", "OPds", "ops", "pops", "optts", "iopds", "optte", "oppt", "opte", "alps", "opTS", "opttions", "OPtions", "opercs", "OPpt", "operts", "opds", "oports", "OPTS", " oports", "alts", "optTS", "alss"], "errp": ["errorpe", "diep", "nerping", "erra", "dieP", "errorpb", "diepb", "errping", "rrpa", "derp", "errpa", "ererpe", "errpb", "ererpa", "ererp", "errpy", "nerp", "errpe", "derps", "orderps", "orderpy", "errps", "orderping", "nerps", "rrp", "derpy", "errorpa", "errorp", "rra", "dieping", "errora", " errping", "errP", "derping", "rrpe", " errpb", "nerpy", "errorP", "erera", "errorping", " errP", "orderp"], "cow_header": ["woman_comment", "usa_player", "yeah11head", "cow_Header", "craft_headers", "cowDpeer", "cow11head", "ow_header", "cow_metadata", "cow_version", "cowmmcache", "ow_version", "dylib_rule", "cow_info", "dylib_header", "cow___comment", "cow11device", "cotPevent", " cow___buffer", "ow_spec", "motionmyhead", "yeah11device", "cowDcommit", "woman_header", "cow67header", "usa_header", "cow11comment", "cow11header", "cotPmodule", "cow_iter", "cow67average", " cow___average", "cowJcomment", "cow___header", "motion_version", "usammcache", "ow_average", "cotPpeer", "ow_head", "cowMlayer", "cow___commit", "woman_commit", "cow_rule", "cow_module", "yeah_comment", "usammplayer", "cow_spec", "womanDcomment", "yeah_head", "cow2headers", "cowmyhead", "yeah11header", "womanDcommit", "cowmmheader", "cow2buffer", " cow_head", "cow_init", "cow67comment", "usammheader", "yeah_header", "Cow_head", "ow_info", "cow_event", "cowPpeer", "cow_dr", " cow___header", "cowDcomment", "usa_session", "cowmyiter", "ow_dr", "cowMversion", "cowMaverage", "cow_player", "cow_device", "cowmyversion", "cot_header", "cowPmodule", " cow_average", "usammsession", "cot_peer", "cow_filter", "cow_commit", "cowMheader", "cowDevent", "cowmyrule", "motionmycomment", "motion_header", "Cow_header", "Cow_metadata", "cow_wrapper", "cot_event", "cow___head", "cow67commit", "cow_layer", " cow___head", "cowmmplayer", "cowmycomment", "Cow_dr", "cowDaverage", "cowmmsession", "cowmyinit", "usa_cache", "cot_module", "craft_wrapper", "cowJhead", "womanDaverage", "ow_layer", "cowDheader", "cow_peer", " cow_buffer", "cowDmodule", "craft_header", "cowPheader", "cow___buffer", "cow_head", "cotPheader", "cowmyheader", "cow_session", "womanDheader", "cow2header", "cow_average", "cow_headers", "woman_average", "cow___average", "dylib_init", "motion_head", "cowJheader", "cowJdevice", "ow_filter", "cow2wrapper", "motion_comment", "cow_buffer", "cow_cache", "yeah11comment", "motionmyheader", "cow_comment", "motionmyversion", "dylib_iter", "cowPevent", "craft_buffer", "yeah_device", "ow_Header"], "st": ["ist", "sth", "inst", "stack", " St", "str", "ust", "fr", " est", "step", "tt", " sp", " ts", "ct", " ss", " ut", "nd", "start", "ast", "r", "rest", " sc", "ut", " ST", "est", " dst", "std", " enc", "stat", "stage", "sh", " net", "St", "ss", "se", "sc", " storage", "ste", "ost", " std", "sta", "it", "stop", "sts", "cont", "sw", "irst", " et", "ST", "sp", " rest"], "image_filename": ["image_stem", " image_stem", "Image_source", "image___enabled", "imageNameheader", "imageNameenabled", "memory_enabled", "image_Filename", "image_header", "image___Filename", "imageNamefilename", "image_file", "image_name", "image___fn", "memory___filename", "memory___enabled", "Image_Filename", "Image_filename", "memory_filename", "image_enabled", "image_source", "memory___header", "image___filename", " image_file", " image_fil", "Image_fil", "image___name", "memory_header", "image___source", " image_username", "image___header", "image_username", "image_fil", " image_Filename", "image_fn", "Image_name", "Image_fn", "image___fil"], "local_err": ["locallyerr", "local___css", "lang_r", "locallyobj", "local_r", "local___iter", "locallyiter", "localpyerrors", "global_er", "local__r", "lang_err", " local_attr", "localpyrr", "local_er", "localpyerr", " local_errors", " local_r", "locallysys", "local__error", "langlycss", "local___err", "langlysys", "langlyr", " local_error", "global_error", "local_css", " local_iter", "locallycss", "local__err", "lang_css", "localpyerror", "local___r", "local_errors", "local_obj", "local_rr", "local_error", "global_err", "locallyr", "local_attr", "langlyerr", " local_rr", "local___obj", "local___attr", "local___sys", "lang_sys", "local_sys", " local_obj", "locallyattr", "local_iter"], "ret": ["flag", "ext", "get", "del", "rets", "det", "nt", "Return", "re", "tr", "att", "at", "pt", "try", "gc", "alt", "inter", "after", "ll", " Ret", "mem", "out", "git", "fun", "rm", "def", "ft", "gt", "ter", "rt", "len", "deg", "elt", "fin", "reset", "reg", "lt", "arr", "tn", "mel", "ry", "run", "sat", "ben", "resp", "Ret", "RET", "res", "t", "val", "print", "cont", "cert", "usr", "ref", "mat", "mt", " RET", "nat", "net", "err", "cmd", "result", "rem"], "cow_bs": ["cow___sys", "cow_cs", "cow_BS", "cow_bg", "ow_cs", "cow_bt", "drm_bm", "cow_sys", "ow_bs", "alky___bs", "ow_gs", "ow_ba", "alky_bt", "cow___bs", "cow2bs", "cow__ba", "cow__sb", "ow_sb", "cow_bes", "cow___bt", "ow_bg", "alky_bs", "cow_sb", "drm_bs", "cow__cs", "cow_gs", "cow_ba", "alky___sys", "drm_ps", "alky___bt", "cow2bt", "alky___sb", "cow__bs", "cow2sys", "cow___sb", "alky_sys", "alky_sb", "ow_BS", "cow2sb", "drm_bes", "cow_ps", "cow_bm"]}}
{"project": "FFmpeg", "commit_id": "4a023d5b53132ced3643d0e8397baa80cf75f656", "target": 0, "func": "static av_cold int check_format(AVCodecContext *avctx)\n\n{\n\n    AVCodecParserContext *parser;\n\n    uint8_t *pout;\n\n    int psize;\n\n    int index;\n\n    H264Context *h;\n\n    int ret = -1;\n\n\n\n    /* init parser & parse file */\n\n    parser = av_parser_init(avctx->codec->id);\n\n    if (!parser) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 parser.\\n\");\n\n        goto final;\n\n    }\n\n    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;\n\n    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);\n\n    if (index < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to parse this file.\\n\");\n\n        goto release_parser;\n\n    }\n\n\n\n    /* check if support */\n\n    h = parser->priv_data;\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 8:\n\n        if (!CHROMA444(h) && !CHROMA422(h)) {\n\n            // only this will H.264 decoder switch to hwaccel\n\n            ret = 0;\n\n            break;\n\n        }\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported file.\\n\");\n\n    }\n\n\n\nrelease_parser:\n\n    av_parser_close(parser);\n\n\n\nfinal:\n\n    return ret;\n\n}\n", "idx": 3832, "substitutes": {"avctx": ["savcats", "afctx", "ajcu", "avcontext", "avercv", "avertx", "avtx", "afcpu", "avcrit", " avcrit", "avconn", "wavcats", "avercontext", "abtx", "aftx", "avecfg", "afcontext", " avcas", " avsetup", "ajtx", "avercfg", "ivercontext", "avercu", "avercmd", "avercas", "aversetup", " avcats", "avercpu", "avercrit", "avcas", "avcu", "avcb", "abctx", "iverctx", "absetup", "savconn", "wavcontext", "avcv", "ajcv", " avcontext", "avcpu", "avsetup", "abcontext", "wavctx", "avectx", "avecontext", "ajcontext", "savctx", "avecrit", "ajcpu", "afcmd", "ivercas", "averctx", " avconn", "ajctx", " avcb", "avercb", " avcfg", " avtx", "afcu", "ajcmd", "wavconn", "afcv", "avcmd", "savcontext", "avcfg", "avcats", "ivercb"], "parser": ["tp", "xml", "metadata", "pause", "cp", "player", "language", "v", "process", "er", "primary", "package", "writer", "loader", "processor", "iterator", "arson", "token", "pool", "builder", "native", "worker", "util", "pc", "program", "command", "power", "master", "timer", "ard", "public", "wp", "buffer", "basic", "pro", "ready", "p", "reader", "document", "ctx", "manager", "tar", "policy", "function", "instance", "proc", "jack", "final", "php", "aster", "pd", "func", "Parser", "rer", "local", "mpeg", "type", "wrapper", "parent", "fp", "context", "parse", "peer", "expression", "handler", "arser", "reset", "lp", "server", "t", "ner", "password", "application"], "pout": ["opin", "spOUT", "spin", " poutput", "opoutput", "pouts", "goutput", "pOUT", "opout", "opOUT", "spouts", "spout", "poutput", "ppin", "pin", "ppout", " pin", "gouts", " pouts", "ppouts", "gin", "opouts", "ppOUT", "gout"], "psize": ["tsization", "persiz", "PSiz", "ssized", "PSizes", "ssize", "psiz", "PSize", "psized", "tssize", "tsized", "psization", "sssize", "apsization", "PShare", "persize", "pshare", "psizes", "ssization", "apsized", "persizes", "pssize", "apssize", "tsize", " psizes", "pershare", " pshare", " psiz", "apsize"], "index": ["n", "count", "open", "get", "slice", "iter", "find", "error", "status", "active", "ret", "inter", "pointer", "i", "ind", "connection", "offset", "row", "out", "number", "x", "IND", "ion", "info", "len", "port", "seek", "Index", "num", "false", "key", "success", "set", "si", "position", "value", "resp", "val", "zero", "ref", "order", "size", "interface", "address", "connect", "id", "scan", "j", "pos"], "h": ["ph", "ht", "hi", "high", "hash", "dh", "eh", "hm", "b", "c", "ih", "hl", "html", "hh", "hp", "he", "bh", "p", "hd", "head", "rh", "ha", "l", "v", "hr", "header", "H", "context", "sh", "hal", "pp", "ctx", "history", "handle", "hum", "host", "kh", "t", "oh", "zh", "hz", "hw", "hs", "ch", "data", "ah"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n", "idx": 3834, "substitutes": {"dc": ["de", "cca", "spec", "design", "cr", "cat", "rc", "mc", "exec", "c", "di", "lc", "td", "ca", "currency", "d", "cu", "dl", "dp", "rank", "rec", "oc", "gc", "cc", "ec", "pc", "std", "ga", "mm", "sys", "bc", "disc", "cm", "dd", "def", "kw", "fc", "nc", "sc", "ctx", "draw", "df", "ac", " DC", "ds", "doc", "dt", "dat", "da", "dm", "cont", "tm", "tc", "session", "dr", "DC", "du", "cus", "eric", "ctl", "cs", "wp", "cmd", "desc", "vc", "cd", "iac", "mac", "icc", "nic", "db"], "insn_len": ["insn_nl", "inspan_el", "insn2ls", "insn67lan", "insn_lan", "insn_ll", "insn2ln", "insn___Len", "insn67int", "insn_Len", "insn2len", "insn___len", "insn_el", "insne_len", "insn_int", "inspn_Len", "inspan_len", "insn2Len", "insn_str", "inspan_Len", "inspan_nl", "inspan_lan", "insn67nl", "inspan_int", "insn67len", "insn2ll", "insn___el", "insne_Len", "insn___str", "inspn_ll", "insn_ln", "inspn_len", "inspn_ln", "insne_ls", "insn_ls", "inspan_str"], "t0": ["t000", "t1", "ot4", "ot0", "t3", "ptZero", " t2", "tau", "otk", "pt2", "dtau", "tmp0", "tcoval", " targ", "t2", " t1", "tbase", "st000", "otau", "T1", "T0", "t4", "pt1", "tmp1", "T2", "targ", " t3", "dt0", "tc0", "pt0", " tZero", "at0", "pt4", "stbase", "tZero", " toval", "atbase", "starg", "dtk", "tk", " t4", " tbase", " tk", "otZero", "pt3", " t000", "tc1", "tmpoval", "toval", "ot3", "at000", "atarg", " tau", "TZero", "st0"]}}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "substitutes": {"dev": ["de", "ad", "db", "pro", "app", "dem", "nt", " device", "devices", "d", "w", "usb", "Device", "p", "av", "sd", "buf", "pad", "ve", "mem", "out", "sky", "v", "def", "dd", "info", "cam", "ctx", "handle", "conn", "serial", "server", "adv", "Dev", "serv", "dm", "device", "ver", "home", "disk", "debug", "obj", "h", "ptr", "hw", "des", "raw", "phy", "cmd", "DEV", "scan", "o", "data", "ev"], "s": ["n", "an", "services", "r", "i", "is", "v", "ops", "ies", "fs", "ds", "si", "gets", "sb", "y", "h", "sq", "hs", "cmd", "steps", "bs", "ses", "c", "status", "ims", "ys", "sv", "os", "a", "vs", "sts", "ats", "as", "des", "details", "j", "ports", "qs", "scripts", "utils", "states", "syn", "p", "sd", "ps", "l", "out", "sys", "less", "ss", "tests", "ms", "copy", "set", "params", "sm", "state", "args", "sl", "mods", "sa", "ex", "sam", "spec", "stats", "self", "comm", "results", "es", "b", "ls", "sets", "w", "als", "ts", "its", "changes", "gs", "e", "g", "conf", "se", "source", "server", "settings", "rs", "ns", "t", "ins", "S", "obj", "sw", "cs", "js", "aws"]}}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n", "idx": 3845, "substitutes": {"f": ["lf", "fm", "fb", "ile", "q", "fr", "uf", "b", "c", "d", "w", "fo", "r", "p", "fa", "fe", "fx", "l", "fp", "cf", "rf", "v", "e", "fi", "bf", "xf", "fc", "file", "af", "fs", "t", "feed", "fn", "fd", "sf", "tf", "h", "F"], "opaque": [" opac", " Opac", " Opulence", "opacity", "paque", "opsaque", "opac", " oparam", "opulent", " opulence", "obaque", "pacity", " opulent", " Oparam", "pulent", " opacity", "obaques", "opulence", "opsaram", "opsulence", "oparam", "opsac", " opaques", "obulent", "opaques", "obacity", "paques", " Opaque"], "version_id": [" version_ids", " version2bit", "VERSION_Id", " version_bit", "version_start", "version_with", " version_start", "version_sid", "version_mid", "v_mid", " version_info", "version2info", "version2start", "VERSION_with", "version_bit", " version2start", "VERSION_id", "version2id", "v_ip", "VERSION_ids", "version_Id", " version2info", "version_ids", "v_no", "version_no", "v_id", " version2id", "version2bit", "version_info", " version_sid", "version_ip"], "n": ["nw", "dn", "np", "gn", " N", "nt", "an", "na", "b", "c", "nor", " gn", "nv", "d", "sn", "w", "p", "l", "v", "cn", "g", "nc", "rn", "ne", "en", "o", "ng", "t", "ns", "node", "N", "h", "nn", "nm", "m", "j"], "vdev": ["vev", "gdevice", "wdef", "vDevice", " vev", "gDevice", "vmdev", " vswitch", "gdev", "vdef", "vmdevice", "ddev", " vdef", "dDevice", " vDevice", "vmswitch", "vdevice", "wdevice", "vmdef", "ddevice", "vswitch", "dev", "wswitch", " vdevice", "gev", "wdev"]}}
{"project": "FFmpeg", "commit_id": "3f8148911c6e6e1f2a042bd4ca3ad8516a92130c", "target": 0, "func": "static int read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]={0}, ret[3]={0};\n\n    AVIOContext *f[3] = {NULL};\n\n    AVCodecContext *codec= s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path, s->img_number)<0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for(i=0; i<3; i++){\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if(i>=1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i]= avio_size(f[i]);\n\n\n\n            if(!s->split_planes)\n\n                break;\n\n            filename[ strlen(filename) - 1 ]= 'U' + i;\n\n        }\n\n\n\n        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        size[0]= 4096;\n\n    }\n\n\n\n    av_new_packet(pkt, size[0] + size[1] + size[2]);\n\n    pkt->stream_index = 0;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    pkt->size= 0;\n\n    for(i=0; i<3; i++){\n\n        if(f[i]){\n\n            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if(ret[i]>0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 3901, "substitutes": {"s1": ["S2", "js1", "rsone", "s01", "ts1", "ts01", "rs0", "s3", "ts3", "js3", "rs2", "sone", "S01", "ds0", "fs2", "s2", " s01", "ds2", "fs3", " s3", "rs1", " s0", "rs3", "ds1", "fs1", "js2", "dsone", " sone", "S0", "fs01", "js01", "s0", "S1", " s2", "ds3", "S3", "ts2"], "pkt": ["spkt", " packet", "spdu", "pet", "Pdu", "packck", "cpkg", "spet", "packet", "packacket", "packkg", " pck", "pck", "cpkt", "Packet", "Pet", " pkg", "cpck", "packkt", "cpacket", "pdu", "spacket", "Pkt", "pkg", " pdu", " pet"], "s": ["n", "south", "is", "v", "sync", "ops", "store", "fs", "ds", "bits", "sb", "h", "y", "sq", "sports", "single", "ses", "c", "status", "styles", "st", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "https", "session", "z", "details", "sim", "j", "save", "has", "qs", "ssl", "p", "sd", "ps", "comments", "sys", "less", "ss", "search", "ms", "space", "bis", "set", "state", "args", "sl", "sp", "m", "sam", "service", "spec", "stats", "comm", "es", "b", "ls", "w", "local", "ts", "changes", "gs", "g", "se", "sc", "source", "rs", "ns", "t", "ins", "S", "sw", "ess", "js", "series"], "filename_bytes": ["filename_uses", "Filename_pieces", "filename_strings", "filename_data", "filename_Bytes", "Filename_strings", "username_uses", "filename_byte", "Filename_tes", "username_pieces", "filename_pieces", "filename_binary", " filename_byte", "username_binary", "username_data", "Filename_bytes", "username_bytes", "filename_tes", " filename_Bytes"], "filename": ["n", "via", "ame", "ename", "binary", "ren", "jpg", "FN", "final", "sbm", "length", "browser", "fle", "metadata", "src", "path", "status", "uri", "output", "p", "png", "username", "mpeg", "description", "kan", "wav", "l", "fp", "river", "lua", "prefix", "title", "original", "image", "file", "name", "nil", "source", "url", "location", "kj", "position", "fn", "txt", "unc", "NAME", "subject", "Filename", "AME", "files", "tmp", "FIL", "fil", "json", "ames", "nm", "names", "buffer", "result", "directory"], "i": ["n", "oi", "cli", "iter", "uri", "mi", "r", "ind", "is", "v", "ai", "ij", "ei", "ic", "go", "it", "si", "to", "y", "h", "id", "ti", "io", "iu", "bi", "init", "cgi", "q", "ui", "batch", "c", "di", "status", "x", "ini", "list", "zi", "ims", "xi", " ii", "a", "iq", "uni", "index", "multi", "z", "chain", "sim", "ri", "j", "I", "point", "im", "ki", "p", "l", "ip", "ix", "ci", "gi", "m", "ex", "k", "iy", "li", " j", "b", "ii", "ji", "\u0438", "u", "e", "pi", "in", "g", "me", "qi", "t", "progress", "o"], "size": ["n", "count", "get", "empty", "needed", "time", "use", "form", "hash", "length", "sample", "options", "c", "status", "export", " Size", "sn", "dimension", "fo", "speed", "cache", "height", "sum", "type", "mem", "offset", "v", "send", "ize", "x", "e", "function", "message", "format", "score", "info", "g", "len", "member", "name", "space", "source", "en", "news", " sizes", "code", "set", "settings", "loc", "fee", "t", "fit", "args", "SIZE", "scale", "z", "ze", "sized", "shape", "sp", "storage", "small", "Size", "mode", "data"], "ret": ["count", "flag", "read", "empty", "rc", "reason", "response", "status", "p", "match", "mem", "send", "sys", "message", "info", "nil", "seek", "num", "en", "success", "code", "res", "t", "args", "result", "pos"], "f": ["n", "fb", "q", "fr", "uf", "b", "c", "d", "m", "w", "fo", "r", "p", "fa", "fe", "fx", "l", "fp", "cf", "rf", "v", "e", "u", "x", "fi", "bf", "xf", "g", "fc", "file", "fs", "fl", "t", "fn", "fd", "sf", "tf", "h", "y", "fw", "z", "buffer", "F", "o", "j", "fac"], "codec": ["Codect", "protc", "codedeco", "codc", "Codec", "condec", "codenc", "cvesc", "Codesc", "condc", "cvEC", "codedEC", "cvect", "codedec", " codEC", "protect", "odc", " codc", "protec", "codiac", "cdenc", "odEC", "cryptec", "challec", " codet", "codEC", "odenc", "cryptEC", "odet", "cdc", "cdect", "cdec", "codesc", "condet", "challEC", "codect", " codeco", "challect", "odec", "cryptect", "codet", "odect", "cryptiac", "condEC", "protenc", "challiac", "codeco", "CodEC", "Codiac", "cvec", "Codeco", " codect", " codesc"], "img_number": ["img___number", "img__version", "image_display", "image_size", "image_nr", "img_nr", "image_number", "imggfirst", "image_num", "img64no", "image_no", "image_name", "image_version", "img___no", "image_count", "img___num", "img_display", "img__number", "img_na", "img_no", "img_first", "img_num", "image_na", "img64first", "image_first", "imggnumber", "img64number", "img_name", "imggno", "img___size", "img_counter", "img__no", "imggnum", "img__nr", "img_size", "img64na", "image_counter", "img_version"]}}
{"project": "FFmpeg", "commit_id": "7ed47e97297fd5ef473d0cc93f0455adbadaac83", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    SmackerContext *smk = s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = avio_rl32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = avio_rl32(pb);\n    smk->height = avio_rl32(pb);\n    smk->frames = avio_rl32(pb);\n    smk->pts_inc = (int32_t)avio_rl32(pb);\n    smk->flags = avio_rl32(pb);\n    if(smk->flags & SMACKER_FLAG_RING_FRAME)\n        smk->frames++;\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = avio_rl32(pb);\n    smk->treesize = avio_rl32(pb);\n    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(s, AV_LOG_ERROR, \"treesize too large\\n\");\n//FIXME remove extradata \"rebuilding\"\n    smk->mmap_size = avio_rl32(pb);\n    smk->mclr_size = avio_rl32(pb);\n    smk->full_size = avio_rl32(pb);\n    smk->type_size = avio_rl32(pb);\n    for(i = 0; i < 7; i++) {\n        smk->rates[i]  = avio_rl24(pb);\n        smk->aflags[i] = avio_r8(pb);\n    smk->pad = avio_rl32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames);\n    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));\n    smk->frm_flags = av_malloc(smk->frames);\n    if (!smk->frm_size || !smk->frm_flags) {\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = avio_rl32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = avio_r8(pb);\n    /* init video codec */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);\n    st->duration = smk->frames;\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if (smk->rates[i]) {\n            ast[i] = avformat_new_stream(s, NULL);\n            if (!ast[i])\n                return AVERROR(ENOMEM);\n            smk->indexes[i] = ast[i]->index;\n            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (smk->aflags[i] & SMK_AUD_BINKAUD) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (smk->aflags[i] & SMK_AUD_PACKED){\n                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (smk->aflags[i] & SMK_AUD_STEREO) {\n                ast[i]->codec->channels       = 2;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                ast[i]->codec->channels       = 1;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            ast[i]->codec->sample_rate = smk->rates[i];\n            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;", "idx": 3913, "substitutes": {"s": ["k", "sam", "n", "sg", "stats", "bs", "ses", "an", "b", "c", "ls", "status", "w", "p", "ts", "its", "ps", "sa", "south", "gs", "v", "sys", "e", "ss", "g", "conf", "ims", "sc", "space", "sv", "fs", "acs", "ds", "a", "sts", "ats", "t", "ns", "as", "rs", "sb", "S", "ins", "h", "sw", "sq", "cs", "hs", "aws", "js", "simple", "m"], "pb": ["tp", "oa", "metadata", "pause", "cp", "wb", "header", "queue", "push", "tk", "resp", "PB", "pm", "lv", "sb", "txt", "bb", "pkg", "amp", "xp", "tab", "erb", "kb", "pool", "uf", "dp", "buf", "tap", "req", "pc", "jp", "conv", "apy", "cb", "meta", "pl", "vp", "pack", "pop", "wp", "buffer", "bp", "fb", "np", "pel", "emb", "rb", "p", "py", "pan", "pp", "ctx", "bank", "bj", "cv", "patch", "bot", "tx", "stab", "pa", "proc", "eb", "b", "pt", "mp", "fp", "peer", "conf", "BP", "lp", "lb", "pg", "obj", "tc", "snap", "mb", "um", "vm", "buff", "pid", "db"], "smk": [" smkk", " smtk", "esmkg", "demkl", "syg", "symtk", "smkit", "mtkit", "esmunk", "hemk", "smkt", " smik", "mmkw", " smak", "hemka", "symk", "storen", "storeark", "hemkk", "stemkick", "syv", "smork", "mkick", "memki", "mgk", "esmsk", "storekl", "demak", "stemik", "mmik", "skyok", "syok", " smkl", "spek", "mtk", "bmkk", "mkw", "mnkick", " smg", "mnkt", "smkm", "storetk", "spekick", "symsk", "smsk", "mtck", " smunk", "smv", "smkk", "mnk", "esmn", "stemkin", "smtk", "mtkt", "ismka", "symak", "mnunk", "symac", "esmj", "smq", "smark", "mtark", "symv", "mnj", "demkt", " smka", "mgkt", "symg", "ymak", "simkl", "syik", "simkg", "esmck", "esmtk", "ismki", "storek", "esmkick", "svkg", " smac", "symkick", " smork", "memk", "mnkl", "demac", "bmak", "ismkm", "smik", "symack", "memg", "bmk", "simj", "symik", "simk", "mnkit", "mnkg", "esmkit", " smkick", "esmark", " smkw", "symek", "mbkl", "esmkl", "ymkick", "simv", "stemk", "mbork", "ismkg", "mak", "smkin", "memj", "simkick", "mnck", "sykl", "memtk", " smkg", "svork", "syq", "mbk", " smkt", "bmkit", "esmkt", "mk", "symq", " smj", "smkl", "smac", "syak", "skyik", "sytk", "smunk", "mnsk", "ymkw", "smka", " smkin", "simak", "symkk", "smok", "esmk", "smck", " smn", "mtkk", "ismj", "sykick", "stemkw", "stemkl", "smkw", "symok", "demk", "simkt", "mac", "mgork", "mmkk", "smki", "smkg", "memkm", "syk", "speik", "simkk", "simik", "memak", "mnork", "smj", " smek", "demkg", "syek", " smck", "memik", "spekin", "sykg", "memkk", "sykw", "ymk", "smkick", "mbkg", "symkit", "mmk", "ismkk", "mtak", "smak", "stemak", "hemkg", " smkm", "smn", "syack", "smek", " smki", "svk", "symkw", "sykt", "sykk", "ismk", "syac", "smg", "mg", "mbtk", "mgkg", "smack", "skyack", "memkit", "simq", "svkt", "simkw", "skyk", " smark", "storekg", "simtk"], "st": ["sam", "inst", "sth", "bl", "str", "ust", "ct", "rest", "ts", "est", "std", "sh", "St", "ft", "ss", "se", "sc", "ste", "sv", "sts", "sm", "sb", "sw", "mt", "sl", "ess", "sp", "ST"], "ast": ["inst", "utt", "ata", "ist", "ust", "ep", "AST", "rest", "saw", "esp", "gc", "ream", "est", "asm", "stage", "must", "ost", "os", "ac", "sta", "ma", "op", "node", "mt", "cast", "ess", "aw", "asts"], "i": ["oi", "cli", "iter", "eu", "mi", "ind", "is", "ai", "v", "ij", "ei", "ic", "it", "si", "y", "id", "ti", "io", "phi", "iu", "bi", "hi", "init", "q", "ui", "di", "x", "ini", "zi", "ims", "xi", "ami", " ii", "iq", "index", "multi", "chain", "sim", "ri", "complete", "j", "I", "this", "mc", "im", "try", "p", "iii", "l", "ip", "info", "name", "set", "ix", "ci", "span", "us", "dr", "depth", "sp", "gi", "m", "li", "b", "ii", "ji", "\u0438", "u", "pi", "in", "g", "me", "qi", "gu", "t", "um"], "ret": ["nt", "et", "re", "uf", "new", "status", "at", "alt", "match", "ll", "mem", "fi", "ft", "gt", "rt", "elt", "reset", "conv", "Ret", "res", "val", "rel", "ref", "mt", "ri", "result"], "tbase": ["cbody", "cBase", "Tbase", "Tbody", "pBase", "tBase", "pbuffer", "TBase", "cbuffer", "Tbuffer", "cbase", "tbody", "tbuffer", "pbase", "pbody"], "frames": ["ones", "fb", "windows", "cycles", "images", "events", "blocks", "bytes", "planes", "fram", "items", "values", "ints", "states", "boxes", "frame", "seconds", "points", "fps", "cells", "tracks", "heads", "views", "parts", "fields", "hops", "obs", "lines", "Frames", "features", "fs", "flags", "faces", "times", "words", "bits", "amples", "rates", "rows", "weights", "files", "runs", "plays", "pages", "caps", "errors", "flows", "steps", "videos"]}}
{"project": "qemu", "commit_id": "9f1963b3f72521f75a549f8afd61b19e7da63c6f", "target": 0, "func": "static int coroutine_fn raw_co_discard(BlockDriverState *bs,\n\n                                       int64_t sector_num, int nb_sectors)\n\n{\n\n    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);\n\n}\n", "idx": 3920, "substitutes": {"bs": ["s", "BS", "bp", "ba", "bi", "iss", "bl", "stats", "lbs", "bas", "sbm", "ses", "b", "blog", "bps", "ls", "pb", "als", "bh", "ts", "bn", "its", "ps", "bid", "gs", "bc", "bm", "ks", "bf", "cks", "ss", "obs", "bed", "bos", "bis", "fs", "ds", "vs", "rs", "ns", "bits", "sb", "bb", "cs", "hs", "js", "ubs", "bes"], "sector_num": ["sector_Num", "sector_pub", "sector00num", " sector_dim", "sector00mon", "sector00pub", "section_number", "sector00dim", "sector2mon", "section_mon", "sector_dim", "sector_number", " sector_pub", "section2num", "section2mon", "section_num", "sector_mon", "sector2number", "sector2num", "section2Num", "section_Num", " sector_mon", "sector2Num", "section2number"], "nb_sectors": ["nb_veors", "nb_serivers", "nb_severs", "nb_SElements", "nb_SEters", "nb_SEctors", "nb_serctors", "nb_SEivers", "nb_selements", "nb_seors", "nb_vevers", "nb_servers", "nb_seivers", "nb_serors", "nb_veivers", "nb_veters", "nb_SEors", "nb_velements", "nb_vectors", "nb_SEvers", "nb_seters"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n", "idx": 3924, "substitutes": {"bs": ["s", "BS", "bp", "bi", "iss", "lbs", "bas", "b", "blog", "bps", "pb", "ls", "bh", "ts", "its", "ps", "uts", "gs", "bc", "bm", "bf", "ks", "ss", "cks", "obs", "aos", "bos", "ms", "ys", "bis", "fs", "ds", "bsp", "aps", "sts", "rs", "ns", "bits", "sb", "hz", "locks", "cus", "cs", "js", "ubs", "ubis", "aus"], "sector_num": ["sector_Num", " sector_nm", "ector_Num", " sector_um", "sector_un", "sector_mon", "sector_orig", "ector_num", "ector_sym", " sector_orig", " sector_mon", "sector_um", " sector_un", "sector_nm", "ector_mon", "sector_sym"], "nb_sectors": ["nb_veels", "nb_veors", "nb_severs", "nb_serivers", "nb_seels", "nb_svers", "nb_bectors", "nb_serctors", "nb_sels", "nb_suves", "nb_seors", "nb_veices", "nb_vevers", "nb_sors", "nb_spectors", "nb_partctors", "nb_seivers", "nb_seves", "nb_seices", "nb_partors", "nb_suctors", "nb_sexctors", "nb_serors", "nb_spegments", "nb_veivers", "nb_sexors", "nb_sctors", "nb_partices", "nb_beors", "nb_sexvers", "nb_partivers", "nb_speves", "nb_speors", "nb_serices", "nb_vectors", "nb_suors", "nb_segments", "nb_sugments", "nb_begments", "nb_sexels", "nb_beves"], "flags": ["s", "lf", "posts", "flag", "ads", "stats", "nl", "FLAG", "ants", "offs", "mask", "options", "ags", "bps", "atts", "ts", "fps", " offsets", "ps", "tags", "comments", "olds", "heads", "cf", "gs", " interests", "ops", "ols", " bits", "levels", "acts", " mods", "aps", "fs", "ds", "faces", "settings", "wcs", "ats", "rs", "bits", "args", "amps", "weights", "frames", "lag", "files", "pins", "cs", "mods", "cmd", "details", "Flags"], "cb": ["CB", "fb", "bp", "eb", "b", "rb", "c", "func", "pb", "cp", "cc", "ec", "fp", "cf", "ck", "callback", "bc", "fun", "ob", "bf", "cn", "fc", "nc", "gb", "lb", "fn", "sb", "bb", "unc", "cv", "tc", "ub", "cd", "ctrl", "erb", "db"], "opaque": ["patile", "opque", "Opacity", "opatile", "opsaques", "opsque", "Opaques", "opacity", "operatile", "openo", "paque", "opsaque", "ipeno", "Opatile", "oaques", "mopatile", "oaque", "oque", "mopaque", "oatile", "ipacity", "opsatile", "pacity", "mopaques", "operque", " opacity", "operaques", "Openo", "Opaque", "ipaque", "operaque", "opaques", "mopacity", " openo", "paques"]}}
{"project": "qemu", "commit_id": "25db9ebe15125deb32958c6df74996f745edf1f9", "target": 0, "func": "static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n", "idx": 3926, "substitutes": {"d": ["s", "ad", "de", "n", "dos", "dn", "pd", "b", "c", "did", "di", "w", "r", "p", "sd", "l", "v", "e", "dc", "dd", "g", "D", "o", "ds", "dat", "t", "da", "dm", "h", "y", "dr", "dev", "z", "des", "f", "m", "j"], "proxy": ["phi", "proc", "pro", "pipe", "shadow", "view", "cow", "flag", "pool", "target", "browser", "native", "remote", "cache", "py", "p", "controller", "cp", "ps", "wrapper", "xy", "pointer", "prime", "connection", "Proxy", "sh", "reverse", "x", "echo", "web", "weak", "ping", "command", "boss", "super", "port", "driver", "source", "pin", "force", "roxy", "server", "manager", "master", "friend", "report", "slave", "docker", "device", "primary", "index", "alias", "cast", "gp", "phy", "pse", "su", "project", "cas", "po", "client", "reply"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,\n\n                            TCGReg dst, TCGReg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIK\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = ~rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opinv;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3933, "substitutes": {"s": ["n", "sg", "bs", "qs", "ses", "an", "comm", "es", "b", "c", "w", "r", "p", "ts", "ps", "i", "is", "v", "gs", "sys", "x", "context", "bc", "cn", "ties", "in", "ss", "g", "conf", "sc", "ctx", "sv", "os", "fs", "ds", "a", "sts", "rs", "ns", "t", "S", "h", "sq", "f", "cs", "hs", "js", "m", "aus"], "cond": ["count", "cut", "sec", "rc", "CON", "cmp", "ct", "c", "comp", "ind", "condition", "bc", "co", "def", "fc", "conf", "ctx", "col", "win", "loc", "cod", "rot", "lock", "cont", "state", "ref", "Cond", "bool", "act", "circ", "dict", "mut", "pre", "cmd", "red", " Cond", "config", "bo", "con", "pos"], "opc": ["opcs", " opca", "ropc", "opcache", " opC", "copc", " opz", "optca", "ropca", " opcs", "optci", "opercache", "copC", "iopc", "opC", "ropci", "iopci", "iopcs", "operc", "ppc", "ropz", "ropcin", "optC", "opcin", "iopca", "operatorcin", "ropcode", "opcode", " opcode", "optc", "operca", "ropcache", "OPca", "ppz", "ppci", "copca", "opz", "operatorcache", "opercin", "OPc", " opci", "ppcode", "operatorc", "OPci", "opca", "OPcs", "opci", "operatorca", "copci"], "opinv": ["ompInv", "ipinv", "ompinv", "opin", " oprev", " opvec", "hopvec", "opInv", "opsrev", "ompin", "ipin", "opvec", " opInv", "ipc", "ipInv", "oprev", "opsvec", "hopInv", "ompc", "opsinv", "opsInv", "hopinv", "hoprev", " opin"], "dst": ["lest", "dnd", " dost", "sdsts", "Dest", "dssts", "dest", "lost", "Dst", "dsts", "dsost", "lsts", " dsts", "dsnd", "Dnd", "sdnd", "Dsts", "sdst", "dost", " dnd", "lst", "Dost", "dsst", " dest"], "lhs": ["Lps", " lxs", "lgs", " lgs", "rgs", "dts", " lps", "dhs", "Lst", "rps", "Lxs", "lps", "rts", "lxs", "rlgs", "rlxs", "rst", "rxs", "lts", "Lhs", " lst", "rlst", "dxs", "rlhs", "lst", " lts"], "rhs": ["arrh", " rsh", "lph", " rht", "erHS", "rgsh", "mrhs", "rph", "dts", "Rhs", "mrph", "lrh", "dhs", "dHS", "rgts", "drs", "arxs", "hhs", "hh", "rh", "rts", " rxs", "Rrs", "lHS", "rgh", "lxs", "lfs", "dfs", " rfs", "arht", "rHS", "arHS", "rxs", "hts", "rrh", " rhea", " rh", "arhs", "erht", "RHS", "mrht", " rph", " rHS", "dhea", "rrs", "errh", " rrh", " rts", "rhea", "dxs", "rghs", " rrs", "lht", "erhs", "Rts", "rsh", "lhea", "rfs", "mrHS", "rht", "hsh"], "rhs_is_const": ["rhs_Is_const", "rhs_is_cont", "rhs_is_Const", "rhs_Is_Const", "rhs_is__const", "rhs_is__cont", "rhs_Is_con", "rhs_is_con", "rhs_is_co", "rhs_is__con", "rhs_is__Const", "rhs_Is_cont"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int twl92230_init(i2c_slave *i2c)\n\n{\n\n    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);\n\n\n\n    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);\n\n    /* Three output pins plus one interrupt pin.  */\n\n    qdev_init_gpio_out(&i2c->qdev, s->out, 4);\n\n    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);\n\n    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];\n\n\n\n    menelaus_reset(&s->i2c);\n\n\n\n    return 0;\n\n}\n", "idx": 3946, "substitutes": {"i2c": ["api2cu", "api102c", " i2ca", "iu5e", "api2e", "i4d", "i2C", "i4dc", "iu5c", "i1d", "iu2c", "i1C", "i102c", "i102e", "ilete", "i2ca", "iorte", " i1c", "i3C", "i4con", "i2e", "i4e", "i5cs", "i1ce", " i1e", "i102cu", "iu5dc", " i2e", "i2dc", "api2dc", " i1d", "iletca", "iu2e", "iletce", " i1ca", "api102e", "i3e", "i2ce", " i1C", " i2C", " i2con", " i2cc", "iu5cs", "i1dc", " i1ce", "i2cu", "i1con", "i4ce", "iletc", "i4c", "iortc", "i102dc", "i4cu", "iu2dc", "i4ca", " i2d", "i2d", "i5e", "api2c", "i1ca", "i5c", " i1con", "i2cs", "api102cu", "i1e", "iu2cs", "i1cc", "api102dc", "iortcon", "i3c", "i2cc", "i5dc", "iletcc", "iortd", " i1cc", "i1cu", "i1cs", "i3dc", "i3cs", " i2ce", "i1c", "iletC", "i3cc", "i2con"], "s": ["sam", "spec", "n", "stats", "iss", "bs", "qs", "self", "ses", "an", "services", "es", "b", "c", "ls", "d", "w", "r", "p", "ts", "ps", "i", "l", "is", "gs", "v", "sys", "st", "e", "sol", "in", "ss", "g", "conf", "se", "less", "ar", "sis", "sv", "os", "source", "fs", "ds", "set", "a", "settings", "sts", "ats", "so", "rs", "ns", "sm", "t", "sb", "S", "h", "y", "sw", "sq", "f", "su", "hs", "cs", "aws", "js", "sa", "o", "j", "has"]}}
{"project": "FFmpeg", "commit_id": "e8c4df40e399fc87c6167c5557c11e0d904ca720", "target": 1, "func": "static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n    AVCodecContext *enc = trk->enc;\n\n    unsigned int samplesInChunk = 0;\n\n    int size= pkt->size;\n\n\n\n    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */\n\n    if (!size) return 0; /* Discard 0 sized packets */\n\n\n\n    if (enc->codec_id == CODEC_ID_AMR_NB) {\n\n        /* We must find out how many AMR blocks there are in one packet */\n\n        static uint16_t packed_size[16] =\n\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};\n\n        int len = 0;\n\n\n\n        while (len < size && samplesInChunk < 100) {\n\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n\n            samplesInChunk++;\n\n        }\n\n        if(samplesInChunk > 1){\n\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n\n            return -1;\n\n        }\n\n    } else if (trk->sampleSize)\n\n        samplesInChunk = size/trk->sampleSize;\n\n    else\n\n        samplesInChunk = 1;\n\n\n\n    /* copy extradata if it exists */\n\n    if (trk->vosLen == 0 && enc->extradata_size > 0) {\n\n        trk->vosLen = enc->extradata_size;\n\n        trk->vosData = av_malloc(trk->vosLen);\n\n        memcpy(trk->vosData, enc->extradata, trk->vosLen);\n\n    }\n\n\n\n    if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {\n\n        /* from x264 or from bytestream h264 */\n\n        /* nal reformating needed */\n\n        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);\n\n        if (ret < 0)\n\n            return ret;\n\n        assert(pkt->size);\n\n        size = pkt->size;\n\n    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n\n        /* copy frame to create needed atoms */\n\n        trk->vosLen = size;\n\n        trk->vosData = av_malloc(size);\n\n\n\n        memcpy(trk->vosData, pkt->data, size);\n\n    }\n\n\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n\n        if (!trk->cluster)\n\n            return -1;\n\n    }\n\n\n\n    trk->cluster[trk->entry].pos = url_ftell(pb);\n\n    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;\n\n    trk->cluster[trk->entry].size = size;\n\n    trk->cluster[trk->entry].entries = samplesInChunk;\n\n    trk->cluster[trk->entry].dts = pkt->dts;\n\n    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;\n\n\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n\n        pkt->pts = pkt->dts;\n\n    }\n\n    if (pkt->dts != pkt->pts)\n\n        trk->hasBframes = 1;\n\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n\n    trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY);\n\n    if(trk->cluster[trk->entry].key_frame)\n\n        trk->hasKeyframes++;\n\n    trk->entry++;\n\n    trk->sampleCount += samplesInChunk;\n\n    mov->mdat_size += size;\n\n\n\n    put_buffer(pb, pkt->data, size);\n\n\n\n    put_flush_packet(pb);\n\n    return 0;\n\n}", "idx": 3956, "substitutes": {"s": ["n", "sg", "stats", "spec", "xs", "bs", "qs", "ses", "comm", "es", "b", "c", "ls", "src", "w", "r", "p", "ts", "its", "ps", "i", "gs", "v", "sys", "e", "ss", "g", "conf", "sc", "os", "fs", "ds", "a", "set", "vs", "sts", "ats", "rs", "ns", "t", "ins", "S", "scl", "h", "sq", "cs", "hs", "js", "aws", "m", "j"], "pkt": ["dacket", "wacket", "tpkg", " pnt", "ppwk", "opkg", "rkt", " pct", " packet", "dkt", "wkt", "dkg", "tpacket", "nacket", "mpt", "mtx", "cpkg", "Pct", "mnt", "packet", "wwd", "nkg", "dwd", "rpt", "hkt", "pct", "opkt", "hpt", "ppt", "Pnt", "cpnt", "cpkt", "hkg", "Packet", "mkt", "ppacket", "Pwk", "opacket", "wkg", "mkg", "oppt", "rkg", "ptx", " pkg", "npt", "ppkt", "cpacket", "nkt", "racket", " pwd", "pnt", "cptx", "Pkt", "Pkg", "tpwk", "cpwk", "macket", "hacket", "pkg", " pwk", " ppt", "mct", " ptx", "tpkt", "pwd", "pwk", "ppkg", "Ptx"], "mov": [" mrav", "smOV", "mOV", "mvo", "amov", "cmove", "gmvo", "amrav", "cmrav", " mvo", "amove", "gmov", "gmOV", "amOV", "smov", "cmOV", "smvo", "move", " mOV", "cmov", " move", "gmove", "smove", "mrav"], "pb": ["bp", "tp", "fb", "bs", "pool", "np", "eb", "uf", "obb", "bps", "rb", "td", "b", "dp", "p", "mp", "pan", "cp", "buf", "wb", "vt", "pc", "fp", "ob", "jp", "pp", "ctx", "conv", "lp", "tk", "cb", "PB", "lb", "pl", "sb", "bb", "vp", "cv", "tc", "ub", "pac", "pkg", "tmp", "gp", "wp", "typ", "pid", "db", "pa"], "trk": ["tenkn", "brek", " trK", "rtkid", "trkk", "vrk", "ctrk", "vrik", " trkw", "tenka", "prm", "trck", "trak", "thk", " trik", "grak", "trch", "srkin", "trakw", "tlek", "vrka", "vrks", "TRkid", "thkk", "tarkar", "turik", "tran", "terk", "turck", "tlck", " trkm", "tenk", "ptrik", " trkid", "brK", "thka", "turk", "trkl", "brkl", "srk", "transkin", "trakm", "thK", "tlkn", "turek", "TRk", "trkin", "brck", "srck", "tlak", "prK", "tenck", "trik", "grkm", "tarkk", "trkr", "track", "trakl", "tlK", "transK", "brk", "tenkk", "Trk", "ctrkid", "grch", "trkn", "thks", "traK", "terch", "prk", "brik", "trka", "tln", " trks", "prck", "TRkr", "terik", "TRks", "trkm", "thik", "TRK", "tlik", "trks", "trkw", "grk", "transk", "Trks", "ptrk", "ctrik", "srK", "tlk", "brkn", "ptrch", "brkin", " trkr", "grik", "thm", "ptrak", "trn", "rtks", "thck", "trkar", "rtik", "TRck", "transck", "thkar", "tarik", "grK", "trkid", "brn", "grm", " trck", "tark", "ctrks", "tenkar", "grkw", "tenak", "grck", "rtk", "tarka", "trm", "Trck", "tlkid", "terak", "brak", "trK", "tlkl", "Trkr", "trek", "tarks"], "enc": ["ack", "ext", "lib", "sec", "rc", "encrypted", "ew", "et", "nt", "cmp", "isc", "crypt", "gen", "util", "kt", "rec", "oc", "anc", "buf", "ec", "auth", "iv", "ens", "ang", "inc", "eng", " Enc", "kw", "Enc", "fc", "len", "exc", "ic", "nc", "oder", "ctx", "conv", "esc", "en", "conn", "ac", "coll", "code", "ENC", "loc", "acc", "cod", "iq", "nec", "act", "obj", "ent", "cv", "hw", "eric", "lang", "desc", "env", "con", "vec", "ev"], "packed_size": [" packed_len", "packed_name", " packed2size", " packed2type", "packed2SIZE", "packed_SIZE", "packed2type", "packed2Size", " packed2name", "packed_len", "packed2name", " packed_SIZE", " packed_type", " packed_name", "packed2len", " packed2SIZE", "packed_type", "packed2size", " packed_Size", "packed_Size"], "samplesInChunk": ["samplesInCloo", "samplesinClucket", "samplesInInstard", "samplesinClunk", "samplesOutChunks", "samplesInChard", "samplesINInstunk", "samplesInClunc", "samplesINChunk", "samplesInCodunc", "samplesInChunks", "samplesINInstair", "samplesOutchucket", "samplesInchucket", "samplesInCHair", "samplesINChair", "samplesInInstoo", "samplesInInstair", "samplesinCompunks", "samplesINChucket", "samplesOutChucket", "samplesInCHoo", "samplesInCHunks", "samplesOutchunk", "samplesinchick", "samplesInchack", "samplesINInstucket", "samplesInchick", "samplesInClucket", "samplesinChucket", "samplesInChick", "samplesInChair", "samplesInClunk", "samplesInInstunk", "samplesOutChunc", "samplesInPartair", "samplesinChick", "samplesInPartunc", "samplesINInstard", "samplesInChucket", "samplesInChunc", "samplesInChoo", "samplesInchunk", "samplesInCodack", "samplesInClunks", "samplesINChard", "samplesInClack", "samplesinChoo", "samplesinChunks", "samplesOutchunks", "samplesinChunk", "samplesOutChunk", "samplesInPartick", "samplesInPartunk", "samplesinchunk", "samplesInCHard", "samplesinCloo", "samplesinClunks", "samplesInCompunks", "samplesInCHunk", "samplesInCodunk", "samplesInChack", "samplesInCompunk", "samplesInchunks", "samplesinchunc", "samplesInchunc", "samplesInCHucket", "samplesInInstucket", "samplesinCompunc", "samplesInClick", "samplesInInstunks", "samplesInPartucket", "samplesinCompunk", "samplesInPartard", "samplesInCompunc", "samplesOutchunc", "samplesinChunc"]}}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 3960, "substitutes": {"ctx": ["wx", "via", "this", "pool", "np", "nt", "cmp", "batch", "cfg", "ct", "c", "ca", "func", "cur", "hl", "cu", "kt", "bh", "gc", "height", "kl", "p", "cp", "cc", "req", "pc", "cf", "aux", "sys", "bc", "context", "cm", "jac", "kw", "jp", "xc", "sc", "nc", "conv", "scope", "conn", "history", "cb", "wcs", "resp", "msg", "loc", " cx", "iat", "qt", "txt", "wd", "act", "setup", "tc", "obj", "cv", "hw", "cl", "pkg", "tmp", "ctl", "sp", "cmd", "tx", "ctr", "ctrl"], "opc": ["opcs", "hopn", "opcn", " opcz", "popc", "popcn", " popct", " opcs", "opcz", "iopc", " popcs", "iopcs", "opct", " opct", "OPnc", "hopnc", "opnc", " popc", "hopc", "iopcz", "OPn", "iopct", "OPcn", "OPc", " popcz", "hopcn", "popn", "popnc"], "rt": ["bt", "attr", "tp", "pat", "iter", "rid", "tt", "nt", "et", "unit", "NT", "art", "fr", "vr", "rd", "start", "at", "ot", "yt", "kt", "r", "rec", "rl", "alt", "rw", "ret", "rx", "feat", "ind", "rf", "sys", "rate", "format", "gt", "quote", "ft", "port", "reset", "round", "it", "dt", "addr", "loc", "rot", "iat", "t", "RT", "rs", "rel", "qt", "index", "root", "mt", "ptr", " addr", "typ", "off", "wt"], "base": ["bt", "back", "db", "ase", "bp", "bound", "kb", "bas", "et", "unit", "b", "style", "start", "r", "p", "local", "type", "ip", "cpu", "based", "prefix", "bf", "file", "name", "se", "line", "reset", "bit", "area", "scope", "origin", "br", "set", "Base", "pe", "nb", "ref", "size", "alias", "root", "mb", "f", "address", "id", "buffer", "pa"], "offset": ["bound", "attr", "length", "et", "unit", "point", "error", "start", "block", "util", "r", "pointer", "type", "pad", "timeout", "row", "attribute", "prefix", "port", "bit", "shift", "reset", "area", "key", "end", "set", "position", "addr", "location", "ta", "op", "rot", "t", "ref", "index", "size", "mt", "ptr", "address", "Offset", "padding", "id", "range", "off", "pos", "slot"], "opn": ["pn", "opd", " opnc", "opcn", "ipn", "ipnn", "oen", "oppner", "oppcn", "appn", "pd", "optn", "opfn", "oppfn", " opnn", "ipns", "oppn", "oener", "optnn", "optns", "ippc", "ipc", "ipcn", "appc", "pc", "ippn", "opnn", " ipn", " ipc", "opnc", " opfn", "opsn", "ippnc", "appsn", "ipsn", "optc", "oecn", "ippcn", " opns", " opcn", "oefn", " opd", "opns", "appcn", "ipnc", "pnc", " opner", " opsn", " ipd", "opner", " ipnc"], "t0": [" tor", "ct0", "vtor", "T3", "ttos", "t000", "t3", "t08", "ctk", "vt1", "te0", "tezero", "Targ", " t2", "entzero", "ta00", "tzero", "ta000", "T00", "ta0", " targ", "t2", "ot2", "T1", "T0", "tt1", " tos", "T2", "targ", " t3", "tt0", "ent08", "ot0", "vt0", "tZero", "T000", "ttzero", "ttZero", " t00", "entZero", "t00", "ent0", "tt3", "tk", " tk", "ta1", "ct1", "ttk", " t000", "te08", "teZero", "ctos", "tos", "tt08", "tor", "Tor", "otarg"], "t1": ["tone", "ot01", " tor", "T01", "otone", "m0", "ot0", "TOne", "ot100", "mOne", " tOne", "to1", " t2", "m1", "T6", "ta0", "otOne", "nt1", "t2", "e0", "tree100", "T1", "T0", "Tric", "T2", "tric", "to2", "toor", " t6", "t01", "Tone", "nt0", " tone", "nt2", "e2", "e01", "ot1", "t100", "ntOne", "t6", "tOne", "e1", " t100", "to6", "ta1", " t01", "treeOne", "tree01", "taOne", "taric", "tor", "otric", "Tor", "tree1", "m2"]}}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "substitutes": {"dma": ["djma", "dmo", "mdmm", "Dma", "dme", "mma", "mna", "Dmo", "djMA", "Dwa", "mmo", "mdpa", " dpa", "dpa", "mme", " dwa", " dna", "mdmo", "mmm", "Dna", " dmm", "dwa", "dMA", " dMA", "dmm", "mdme", "djmo", " dme", "mdwa", "djpa", "mdma", "mdMA", " dmo", "dna", "mwa"], "is_write": [" is_read", " is_rw", "is2read", "is2write", "is2writer", "is_writer", "is_rw", "is_read", " is_writer", "is2rw"], "bm": ["lam", "bridge", "sbm", "arb", "mi", "bh", "cache", "bn", "cp", "asm", "rm", "bf", "br", "pm", "fam", "dm", "sb", "bb", "txt", "monitor", "il", "lamm", "hs", "gm", "bt", "bi", "bl", "bs", "pb", "drm", "bal", "am", "mn", "ay", "irm", "cb", "ym", "fn", "mt", "ram", "imm", "dim", "mr", "em", "bp", "lib", "BM", "bin", "mc", "wm", "bg", "im", "mm", "cm", "om", "bis", "ool", "nb", "umi", "sm", "bank", "abl", "tm", "bol", "phy", "nm", "m", "mx", "rem", "sam", "ht", "eb", "hm", "comm", "b", "mem", "gs", "web", "bc", "mg", "mb", "ail", "um", "vm", "bo", "db"], "s": ["n", "sg", "stats", "spec", "ports", "bs", "qs", "q", "ses", "services", "comm", "es", "c", "ssl", "ls", "states", "sn", "w", "als", "ains", "p", "ts", "sd", "ps", "its", "i", "gs", "is", "sys", "sol", "ss", "g", "ims", "ms", "ys", "sv", "os", "bis", "fs", "ds", "store", "set", "settings", "vs", "sts", "ats", "so", "rs", "ns", "sm", "serv", "sb", "S", "ins", "y", "sw", "h", "sl", "sq", "cs", "sp", "hs", "js", "sa", "m"], "pci_dev": ["pcu_div", "pci2device", "pcu_device", "pciaxyev", "pci67home", "pciaxydev", "pci_div", "pci_home", "pdi_dev", "pdi_data", "pciaxyobj", "pci_data", "ppi_dev", "pci____server", "pciaxydevice", "ppi_ev", "pci____dev", "pci____div", "ppi_obj", "pci67pad", "pci2div", "pci_obj", "pci67device", "pcu_server", "pci_ev", "pcu_home", "pci_device", "pdi_device", "ppi_device", "pdi_ev", "pci67dev", "pci2server", "pci_pad", "pci2dev", "pcu_pad", "pci____device", "pcu_dev", "pci_server"], "prd": ["pord", "pirdl", " prD", "servr", "prm", "sprr", "prod", "exprd", "prad", " prde", "port", "ptrr", " prt", "ptrn", "exprp", " prn", "Prp", "pordl", "sprds", "sprn", "exprdd", "servd", " prds", "servder", "Prad", "PRd", "PRm", "polde", "pirdx", " prdd", " prdx", "pirl", "pold", "repldd", "exprder", "Prdd", "pder", " prp", "replad", "poldx", "pird", "sprder", " prdl", "prodx", "prr", "prD", "prode", "Prl", "grl", "ptrds", "prond", "prdl", "pp", "grd", "pirdd", "Prd", "prp", "servs", " prs", "prl", "prder", "PrD", "ptrd", "exprdx", " prond", " prl", "pror", "grD", "PRr", "pd", "sprm", "prdd", "prs", "prt", "prn", " prm", "repld", "PRds", "pirt", "polr", "grp", "sprd", "sprs", "prde", "pdd", "Prond", "prds", "exprl", " prder", "pordx", "replond", "prdx", " prad", " prr"], "l": ["lf", " L", "n", "el", "nl", "li", "length", "b", "lu", "lc", "ls", "hl", "lit", "d", "dl", "kl", "local", "la", "ell", "ll", "lic", "ul", "i", "L", "v", "x", "list", "g", " le", "lt", "tl", "o", "lp", "al", "fl", "ld", "loc", "le", "lv", "lis", "pl", "lock", " el", "size", "ol", "il", "h", "sl", "z", "ln", "f", "ml", "lo", "m", "line"], "len": ["lf", "n", "el", "nl", "bl", "lib", "lon", "iter", "li", "seq", "length", "gz", "cmp", "lc", "ls", "pos", "hl", "lim", "kl", "alt", "la", "ell", "gl", "ll", "lic", "mem", "v", "L", "lin", "tl", "elt", "lt", "fin", "en", "lp", "Len", "fl", "addr", "ld", "le", "val", "size", "il", "cl", "sl", "ln", "ml", "lan"]}}
{"project": "FFmpeg", "commit_id": "5a2ad7ede33b5d63c1f1b1313a218da62e1c0d48", "target": 0, "func": "static int apply_window_and_mdct(vorbis_enc_context *venc,\n\n                                 float *audio, int samples)\n\n{\n\n    int channel;\n\n    const float * win = venc->win[0];\n\n    int window_len = 1 << (venc->log2_blocksize[0] - 1);\n\n    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;\n\n    AVFloatDSPContext *fdsp = venc->fdsp;\n\n\n\n    if (!venc->have_saved && !samples)\n\n        return 0;\n\n\n\n    if (venc->have_saved) {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memcpy(venc->samples + channel * window_len * 2,\n\n                   venc->saved + channel * window_len, sizeof(float) * window_len);\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2, 0,\n\n                   sizeof(float) * window_len);\n\n    }\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->samples + channel * window_len * 2 + window_len;\n\n\n\n            fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2 + window_len,\n\n                   0, sizeof(float) * window_len);\n\n    }\n\n\n\n    for (channel = 0; channel < venc->channels; channel++)\n\n        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,\n\n                     venc->samples + channel * window_len * 2);\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->saved + channel * window_len;\n\n\n\n            fdsp->vector_fmul(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n        venc->have_saved = 1;\n\n    } else {\n\n        venc->have_saved = 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 3971, "substitutes": {"venc": ["tenec", "vergc", "venac", "vincu", "vancu", "vincs", "vancache", "tence", "erenf", "avenci", "vetdc", "vertec", "muncache", "verc", "vetcur", "enedcu", "vehac", "erencall", "verl", "tencs", "vetgc", " vencam", "fenc", "avencu", "VENec", "vinz", " veng", " vencu", "vehcall", "avenv", "vengc", "virtc", "vinlc", " vence", "verca", "verC", "erenx", "avencs", "erenz", " venec", "venci", "vang", "vinf", "vetconf", "vinv", "avendc", "vencs", "ternfc", "vanec", "verlc", " vene", "ternc", "vinec", " vencc", "vene", "venfc", "vince", "vetec", "erencurrent", "denc", "vehc", "vercu", "fenec", "ving", "vancs", "verci", "munce", "vencer", "vetce", "vencurrent", "VENc", "avence", " vencs", "enedcall", " venC", "enedce", "vancur", "vinfc", "fendc", "vindc", "erence", "vanac", "enedcer", " venac", "venec", "vehg", "venx", "vertac", "vencam", "venconf", " vencur", " vendc", "vancam", "vinC", "erencur", "verce", "zenc", "vertc", "ovenz", "vetx", "munc", "vehce", "vanmc", "ternec", "vetc", "VENC", "enedcurrent", "avenw", "fencache", "tenv", "avencam", "verw", "vincache", " venlc", "vinmc", "ovenf", "venl", "vencache", "vandc", "avenlc", " venn", "vetfc", "venv", "dene", "vendc", "enedconf", "ovenca", "vingc", "tenc", "virtv", "VENv", "erenca", "eneddc", "zencu", "vinca", "denac", "vermc", "virtconf", "venlc", "isenw", "avenec", "vetC", "vercc", "vehcer", "vincer", "verz", "isenc", "vincur", "erenc", "avenc", "vinac", "zenn", "avene", "ovenc", "verx", "mung", "avenl", "enedca", "zenlc", "veng", "enedv", "isenl", " vencache", "vinc", " venv", "vencc", "vehca", "vencur", "vetlc", "tencer", "vancer", "vetv", "vetz", "virtce", "vehcurrent", "tenC", " venca", "vertcam", "erencu", "venca", "terncur", "vencu", "enedcc", "verec", "dencam", "vence", "vance", "vanc", "isenci", "venz", "enedc", "avenn", "vehcu", "venmc", "venw", "venn", "avenac", "venf", "venC", "vencall", "vehcs"], "audio": ["au", "ogg", "hello", "music", "input", "binary", " soundtrack", "sample", "length", "above", "batch", "wave", "volume", "recorded", "array", "native", "output", "play", "Audio", "integer", "av", "mpeg", "memory", "wav", "window", "relative", "in", "image", "current", "video", "audi", "a", "total", "amples", "speech", "vo", "alpha", "media", "voice", "sound", "data", "ogram"], "samples": ["tsources", "tizes", "rsamps", "exources", " sources", "alsaves", "Sents", "Saved", "sourses", "alsamps", "scamples", "daved", "sources", "nsaved", "atsources", "scamps", "ssamples", "scaved", "tamps", "insamps", "tsaved", "asents", "Saves", "csources", "nsamps", "sample", "atsamples", "csourses", "ssizes", " sounds", "nsamples", "Sizes", "tsaves", " samps", "scockets", "Sample", "saved", "Sounds", "csamples", "Sources", "isockets", "atsaves", "asamps", "isaves", "rsamples", " saved", "asources", " sents", "ssounds", "exaved", "saves", "insources", "insaved", "tsamps", "rsaved", "ssaves", "tsannels", "atsaved", "tsamples", "Samps", "tamples", "damples", "sents", "asamples", "isamps", "asaves", "tounds", "ssaved", "examples", "isamples", "examps", "insamples", "dannels", "exaves", "sizes", "Samples", "alsample", "alsamples", "rsents", "damps", "sockets", "ssources", "csamps", "isaved", "asample", " sourses", "Sourses", "nsockets", "samps", "ssamps", "sannels", "exannels", "sounds"], "channel": ["fall", "slice", "player", "attribute", "plugin", "member", "queue", "coord", "scope", "part", "component", "monitor", "color", "module", "actor", "console", "processor", "global", "chart", "pattern", "token", "unit", "can", "batch", "character", "worker", "window", "row", "category", "command", "pixel", "col", "cam", "group", "ord", " Channel", "user", "table", "resource", "index", "no", "version", "chain", "config", "chn", "chan", "section", "cell", "entry", "frame", "quick", "controller", "field", "container", "button", "chron", "name", "menu", "key", "manager", "column", "camera", "ch", "slot", "service", "axis", "form", "enabled", "entity", "browser", "relation", "campaign", "byte", "face", "block", "remote", "variable", "connection", "peer", "ann", "panel", "handler", "server", "cloud", "counter", "call", "broad", "annels", "label", "course", "Channel", "client"], "win": ["wa", "n", "nw", "windows", "init", "work", "bin", "won", "wm", "wt", "pos", "start", "gen", "w", "margin", "WIN", "wn", "rec", "play", "max", "local", "rw", "wb", "png", "wav", "mem", "window", "wal", "v", "sys", "inv", "gain", "len", "port", "workers", "oss", "doc", "Win", "gui", "fn", "val", "alpha", "wd", "size", "root", "snap", "hw", "loss", "ram", "aw", "wp", "wind", "wl", "scan", "pid"], "fdsp": ["dfsw", "vdsc", "pdsw", "sdsp", "ddsw", "pdgp", "ddsc", "v", "dlasp", "ddsp", "fdp", "dlp", "sdsc", "vdsp", "vdsw", "pdosp", "fdserv", "fdsw", "_", "fdsc", "def", "conv", "vdtp", "fdtp", "dfsp", "dlsw", "fdisp", "cont", "dfosp", "pdisp", "pdasp", "ddserv", "fdgp", "dfserv", "dlisp", "dlsp", "sdtp", "dlgp", "mdasp", "mdisp", "dlosp", "sdp", "dfsc", "vdp", "dfgp", "pdsp", "mdgp", "dltp", "func", "dlsc", "vdserv", "fdasp", "mdsp", "fdosp"], "offset": ["bound", "slice", "offer", "absolute", "et", "sample", "offs", "point", "mask", "batch", "error", "entry", "start", "ot", "output", "seed", "pointer", "scroll", "pad", "delay", "window", "row", "out", "attribute", "prefix", "online", "seek", "shift", "reset", "url", "key", "end", "location", "addr", "position", "set", "it", "rot", "alpha", "zero", "index", "tile", "size", "f", "address", "Offset", "padding", "range", "o", "off", "data", "pos", "slot"]}}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n", "idx": 3977, "substitutes": {"l": ["n", "el", "nl", "li", "length", "b", "c", "lc", "ls", "hl", "lit", "d", "dl", "r", "kl", "p", "local", "ll", "v", "L", "g", "len", "tl", "lt", "lp", "al", "ld", "le", "lv", "lb", "t", "pl", "lock", "h", "sl", "like", "ln", "ml", "lo", "jl", "m", "line"]}}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n", "idx": 3984, "substitutes": {"gain": ["n", "bridge", "guard", "age", "press", "ogg", "config", "wire", "jack", "gn", "bin", "won", "say", "wm", "record", "can", "sign", "grad", "query", "wave", "charge", "status", "rank", "forward", "gen", "clean", "play", "rec", "speed", "gc", "grain", "ga", "ang", "reverse", "parse", "inc", "glass", "cn", "eng", "g", "seek", "group", "conv", "conn", "win", "limit", "go", "pass", "inn", "ain", "rain", "acc", "cale", "sb", "snap", "scale", "raw", "aw", "gp", "phy", "cmd", "wait", "gg", "chain", "icon", "gi", "scan", "con", "gate", "game", "sort"], "fraction": ["Fraction", "cension", " frequency", "facault", "volean", "folean", "craction", "fortraction", "vportion", "vault", "fortractions", "Fract", " Fraction", "tractions", "facrequency", "frequency", "Fault", "traction", "vraction", " Fractions", " fractions", "fension", "fcomponent", "Frequency", " folean", "facractions", "Fractions", "fortault", "facract", "tract", " fcomponent", " fract", " fault", "faccomponent", " Fension", "vractions", "fportion", "cractions", "facraction", " Fract", "tension", "fractions", "vract", "facolean", "cract", "fault", " fportion", "fortportion", "tcomponent", "fract"], "db": ["sql", "ib", "bound", "fb", "lib", "binary", "DB", "eb", "bin", "deb", "md", "gd", "orb", "record", "bg", "b", "rb", "be", "byte", "nd", "d", "im", "dl", "og", "sd", "bor", "fd", "bind", "ob", "bm", "bf", "dB", "ord", "ig", "limit", "ds", "mg", "cb", "addr", "ld", "dat", "gb", "nb", "Db", "dir", "base", "dm", "sb", "bb", "database", "orm", "ref", "bd", "index", "pg", "mb", "buffer", "m", "fine"]}}
{"project": "qemu", "commit_id": "c641483fbe0aa08cd7c0580d019dc2d5a7e71138", "target": 1, "func": "static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n", "idx": 3988, "substitutes": {"s": ["n", "bs", "qs", "q", "ses", "es", "b", "c", "ls", "d", "r", "p", "ts", "ps", "i", "is", "v", "sh", "sys", "st", "e", "gs", "ss", "se", "sv", "os", "fs", "ds", "sts", "t", "rs", "ns", "sb", "S", "ins", "h", "sq", "z", "cs", "sp", "js", "m"], "dma_cb": ["dma____callback", "dma_cf", "dwa_callback", "dme_cue", "dwa_fn", "dwa_cf", "dme_fb", "dwa_cb", "dma____fb", "dma_cue", "dma_fb", "dma____cue", "dma____cb", "dme_callback", "dma_fn", "dme_cb", "dma_callback"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 4006, "substitutes": {"bs": ["BS", "bp", "stats", "bi", "bl", "ab", "bas", "lbs", "qs", "eb", "blocks", "bing", "bytes", "es", "b", "bps", "blog", "abilities", "ls", "pb", "boxes", "bles", "bitcoin", "als", "bh", "its", "ts", "bn", "ps", "aus", "uts", "gs", "bc", "bm", "ks", "bed", "cks", "obs", "was", "bf", "bos", "aos", "ms", "outs", "os", "bis", "fs", "ds", "vs", "cb", "sts", "ats", "las", "rs", "ns", "bits", "stones", "sb", "bb", "hz", "vals", "soc", "cs", "hs", "js", "ubs", "css", "ubis", "banks", "base", "bes"], "query_backing": ["query_groupinging", "query_forwardinging", "query_backening", "query_bookinging", "query_loadinging", "query_holdling", "query_loading", "query_backging", "query_forwardning", "query_backling", "query_forwardging", "query_holding", "query_returnging", "query_landing", "query_looking", "query_forwardding", "query_groupning", "query_returnening", "query_forwarding", "query_pointging", "query_landging", "query_loadging", "query_bookging", "query_backinging", "query_lookancing", "query_lookinging", "query_bookancing", "query_groupging", "query_loadding", "query_backning", "query_pointling", "query_groupding", "query_backding", "query_holdening", "query_booking", "query_returnling", "query_backancing", "query_pointning", "query_lookging", "query_pointing", "query_landinging", "query_groupening", "query_landancing", "query_groupling", "query_holdging", "query_returning", "query_grouping", "query_forwardling"], "s": ["n", "services", "eds", "views", "is", "v", " reports", "sync", "parts", "outs", "ies", "fs", "ds", "eps", "sb", "h", "y", "sq", "hs", "ubs", "errors", "ses", "c", "status", "ges", "uts", "ims", "ys", "sv", "os", "a", "vs", "sts", "ats", "as", "des", "details", "j", "has", "ports", "qs", "utils", "uploads", "states", "p", "ps", "l", "sys", "less", "ss", "ms", "bis", "set", "params", "args", "rows", "m", "bes", "sam", "stats", "xs", "self", "comm", "es", "b", "ls", "pers", "w", "als", "ts", "its", "changes", "gs", "ches", "stat", "conf", "se", "acs", "settings", "rs", "ns", "t", "ins", "S", "sw", "f", "cs", "js", "aws"]}}
{"project": "FFmpeg", "commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "target": 1, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, const uint8_t *src_end,\n\n                                    int width, int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *src_start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    return AVERROR_PATCHWELCOME;\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        if (end - dst < count) {\n\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            if (i+2 >= src_end - src)\n\n                return AVERROR_INVALIDDATA;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n            dst += i;\n\n        }\n\n    }\n\n    return  src - src_start;\n\n}\n", "idx": 4009, "substitutes": {"l": ["el", "nl", "lib", "li", "b", "c", "lu", "lc", "ls", "lit", "d", "dl", "r", "kl", "p", "local", "la", "ell", "ll", "v", "L", "lin", "g", "tl", "lt", "list", "ctx", "url", "lp", "al", "fl", "ld", "le", "lv", "lb", "t", "pl", "lock", "il", "cl", "h", "lag", "sl", "ln", "f", "lay", "ml", "lo", "acl", "jl", "m", "j"], "dst": ["rdest", "ldST", " dset", "dST", "iddest", "Ddest", "dtST", "Dsc", "idst", "rest", "dbr", "Dst", "dirst", " dsc", "disost", "dtest", "sdest", "dstart", "idend", "dost", "dint", "nsts", "dbend", "nest", "rsts", "dtsc", " dsrc", " dtd", "Dset", "dtst", "ldst", "lddest", "ldest", "dsbr", "Drest", "sdirst", "desp", " dbr", "Dsp", "ddst", "rend", "sdst", "ddST", "ddlist", "adbr", " dlist", "dlist", "dbdest", "Dest", "rST", "deest", "dend", "dsts", "Dirst", "Dtd", "disest", "Dsrc", "drest", " dint", "dsint", "dbST", "Dlist", "sdrest", "pset", "ntd", "dhdest", "adstart", "dhest", " dirst", "dset", "dissp", " ddest", "pest", "rsrc", "dhint", "dsst", " dstart", "disst", "pst", "pST", " dST", "dsc", "dsstart", "ddest", "dest", "DST", "dsp", " drest", "dbst", "adint", "Dint", "deost", "dhst", "adst", "nst", "rst", " dsts", "dsrc", "idST", "Dsts", "Dost", " dest", "dtd"], "src": ["inst", "iter", "target", "length", "dist", "cur", "lit", "sn", "r", "stream", "ind", "std", "sync", "trans", "it", "sr", "sb", "txt", "ptr", "sq", "scan", "inner", "str", "bs", "init", "c", "comp", "window", "st", "conv", "xff", "loc", "cont", "ln", "desc", "sub", "supp", "attr", "input", "rc", "seq", "ident", "bin", "ssl", "start", "syn", "height", "cc", "iv", "out", "screen", "sys", "sup", "secure", "rt", "region", "addr", "usr", "text", "begin", "sl", "tmp", "ser", "ctr", "sort", "s", "proc", "stack", "sec", "stock", "hl", "dest", "rl", "img", "send", "offset", "stat", "bc", "in", "sc", "source", "rs", "sur", "load", "ins", "obj", "sw", "buff"], "src_end": ["rc_end", "src_last", "rc_stop", "src_stop", "src_ends", "rc_last", "rc_ends", "rc_start"], "esc_count": [" esc_found", "escptdefault", "esc_sum", "esc_amount", "esc00Count", "esc_counter", "ec_sum", "esc_offset", "esc2count", "expr_counter", "expr_offset", "esc00found", "esc2length", "desc_counter", "esc_Count", "expr_amount", "esc___found", "esc00count", "esc_default", "desc_Count", "desc_length", "esc___counter", "escptcount", "esc_found", "desc_count", "esc___Count", "expr_count", " esc_counter", "esc2counter", "ec_count", "esc_length", "esc___count", "escptsum", "ec_default", " esc_Count", "esc2Count", "esc00counter"], "count": ["n", "core", "length", "nt", "cache", "mount", "ind", "v", "ount", "limit", "cmd", "id", " c", "q", "batch", "c", "th", "max", "sum", "list", "len", "num", "col", "force", "a", "C", "found", "cont", "index", "amount", "Count", "z", "add", "buffer", "find", "start", "height", "p", "cc", "match", "number", "current", "name", "ctx", "code", "set", "ctr", "scroll", "result", "ct", "temp", "comment", "pt", "gc", "type", "check", "offset", "e", "inc", "reset", " cc", "total", "counter", "t", "now", "size", "call", "err", "cycle"], "src_start": ["rc_end", "rc_offset", "rc_stop", "src_offset", "src_stop", "rc_start"], "end": ["hend", "bound", "END", "ext", "pend", "final", "ff", "length", "End", "nd", "start", "dest", "w", "rest", "max", "ended", "est", "ind", "window", "offset", "send", "ender", "st", "out", "e", "eng", "append", "len", "en", "ending", "all", "set", "it", "stop", "last", "size", "begin", "ent", "z", "id"], "i": ["n", "oi", "cli", "slice", "length", "uri", "mi", "r", "ind", "ai", "is", "ei", "ij", "v", "ic", "port", "it", "go", "si", "y", "h", "id", "ti", "phi", "iu", "hi", "bi", "init", "cgi", "ui", "api", "batch", "c", "di", "status", "x", "fi", "ini", "zi", "ims", "xi", "ami", " ii", "index", "multi", "z", "sim", "ri", "j", "I", "point", "start", "im", "ki", "height", "p", "ip", "info", "name", "ix", "ci", "gi", "m", "instance", "s", "li", " j", "b", "ii", "w", "ji", "\u0438", "e", "u", "pi", "in", "g", "qi", "t", "size", "f", "err", "o"]}}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static int ram_init_all(RAMState **rsp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (ram_state_init(rsp)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 4017, "substitutes": {"rsp": ["urbsp", "rcsp", "rcst", "rssp", "msc", " rvol", " rpp", "gsw", "Rserv", " rjp", "rsSp", "rrhtml", "rserv", "rvol", "rtp", "Rbsp", "rerst", "rpp", "rrsp", "relserv", "rSp", "rspr", "rersp", "rresp", "rcsi", " rsm", "gjp", "nrsi", "erst", "erSP", "RSP", "rrSp", "msp", "Rsp", " rtp", "rrpp", "erjp", "Rst", " rst", "rsc", "nrsp", "mserv", " rsw", "ursc", "rrvol", "Rsc", "mresp", "ursp", " rSP", "ertp", "rerserv", "rsvol", "relsp", "rsi", "nrst", "msw", "rsl", "rjp", "rhtml", "rcSp", "mjp", "relspr", " rhtml", " rSp", " rserv", "gsp", "rcsw", "rerjp", "ersp", "reljp", "rsw", "nrsw", " rsl", "rbsp", "urserv", "rSP", "mbsp", "rcpp", " rsi", "erserv", "rchtml", "rsm", "ersl", " rresp", "rerspr", "Rtp", "rssm", "rst", "gresp", "rersl", "rrsm", "erspr"], "local_err": [" local_log", "locedpriv", "locallyerr", "inner_err", "localitypriv", "inner_iter", "loc_attr", "locedattr", "localedattr", "local____err", "local___attr", "inner_buf", "local_Er", "localederr", "loc_cr", "localityerr", "loc_err", "local____Er", "localedcr", "locedcr", "local___priv", "local_priv", " local_Er", "locederr", "local_log", "local___err", "local____log", "localedpriv", "localityattr", "local_cr", "localitycr", "local_iter", "locallyEr", "local_buf", "locallylog", "loc_priv", "local___cr", "local_attr"], "block": ["tag", "view", "bl", "pool", "hash", "bin", "blocks", "record", "self", "unit", "batch", "art", "page", "byte", "commit", "start", "map", "cache", "local", "p", "type", "check", "wall", "loop", "word", "ip", "row", "out", "header", "number", "mm", "prefix", "sync", "bc", "def", "image", "list", "container", "window", "Block", "line", "group", "BL", "network", "link", "set", "mem", "part", "piece", "lock", "object", "table", "ref", "join", "disk", "obj", "cl", "snap", "pack", "raw", "address", "chain", "buffer", "data", "box", "instance"]}}
{"project": "FFmpeg", "commit_id": "86b0d9cd58137fc499f263267c3219ac6186b98e", "target": 0, "func": "static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 4025, "substitutes": {"pix": [" pIX", "piv", " pct", "npixels", "Pixels", "Pct", "Px", "PIX", "Piv", " piv", "npIX", "pct", "cpIX", "cpix", "cpct", "Pix", " pixels", "pIX", "cpiv", "pixels", "cpixels", "px", "npix", " px", "npx"], "stride": ["suspide", "stine", "Stride", " strade", "grider", "Strade", "stie", "stider", "divride", "Strride", "Strider", "strie", "strride", "grride", "gride", " strride", "strime", "stide", "strade", "suspride", " strie", "stade", "strine", "strider", "divide", "Strine", "suspime", " strime", "divime", "Strie", "grine"], "bS": ["bbVS", " bV", "sbR", "sbINS", "chJS", "bGS", "bbC", " dbSB", "sbS", " bGS", "ibSet", " biS", "bFS", " dbGS", "bR", "ibV", "bDS", "bINS", "bcS", "sbFS", "bSet", "bC", " biGS", "ibTS", "nbJS", "bcFS", "bbS", "bbDS", "chC", "chS", "bbR", "chVS", "bcDS", "bbSet", "bTS", "bbFS", "ibS", "bV", "bSB", " bSB", " bR", "sbC", "ibC", "sbDS", " dbS", " bIS", "bbIS", " bTS", "bbINS", " bC", "bbJS", "bcINS", "bbV", " biSB", " bVS", "bVS", "nbSet", "bIS", " bJS", "sbIS", "bbTS", "ibJS", "nbS", "bJS"], "qp": [" qpp", "qqP", "querynp", "qlpad", "questionpc", "qpp", "qup", "qqpad", "questionp", "iqnp", "qpad", "quc", "iqpc", "iqc", "queryp", "qupc", "qqpp", "qqp", "qlpp", "questionpa", "qunp", "qP", "qnp", "questionnp", "qpc", "querypa", "qlP", "qlp", "qqpc", "qc", "qpa", "qupa", "qqc", " qP", " qpad", "iqp", "querypc", "qqnp"], "h": ["k", "ph", "ht", "hash", "dh", "q", "eh", "help", "hm", "comm", "b", "c", "ih", "hl", "th", "w", "hh", "hp", "he", "rh", "p", "hd", "bh", "cache", "l", "v", "header", "sh", "H", "context", "e", "here", "g", "hal", "ctx", "handle", "history", "it", "host", "a", "kh", "t", "oh", "hz", "hw", "hs", "ch", "m", "ah"], "tc": ["rc", "aco", "toc", "tt", "mc", "ui", "cot", "temp", "c", "currency", "lc", "td", "com", "tu", "tic", "cu", "gc", " TC", "cache", "ts", "cc", "ec", "tv", "pc", "cf", "bc", "dc", "cm", "fc", "ic", "ctx", "cci", "ce", "acc", "fee", "times", "ci", "tim", "t", "unc", "uc", "cv", "tf", "asc", "TC", "cus", "etc", "cs", "ctl", "uca", "tx", "ctr", "icc", "cas", "ctrl", "css"]}}
{"project": "FFmpeg", "commit_id": "8c5cd1c9d33b4b287f85d42efb1aecfaee31de6c", "target": 1, "func": "static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,\n\n                                      int w, int h)\n\n{\n\n    ImageContext *img;\n\n    HuffReader *hg;\n\n    int i, j, ret, x, y, width;\n\n\n\n    img       = &s->image[role];\n\n    img->role = role;\n\n\n\n    if (!img->frame) {\n\n        img->frame = av_frame_alloc();\n\n        if (!img->frame)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    img->frame->format = AV_PIX_FMT_ARGB;\n\n    img->frame->width  = w;\n\n    img->frame->height = h;\n\n\n\n    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {\n\n        ThreadFrame pt = { .f = img->frame };\n\n        ret = ff_thread_get_buffer(s->avctx, &pt, 0);\n\n    } else\n\n        ret = av_frame_get_buffer(img->frame, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (get_bits1(&s->gb)) {\n\n        img->color_cache_bits = get_bits(&s->gb, 4);\n\n        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid color cache bits: %d\\n\",\n\n                   img->color_cache_bits);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,\n\n                                            sizeof(*img->color_cache));\n\n        if (!img->color_cache)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        img->color_cache_bits = 0;\n\n    }\n\n\n\n    img->nb_huffman_groups = 1;\n\n    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {\n\n        ret = decode_entropy_image(s);\n\n        if (ret < 0)\n\n            return ret;\n\n        img->nb_huffman_groups = s->nb_huffman_groups;\n\n    }\n\n    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *\n\n                                           HUFFMAN_CODES_PER_META_CODE,\n\n                                           sizeof(*img->huffman_groups));\n\n    if (!img->huffman_groups)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < img->nb_huffman_groups; i++) {\n\n        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];\n\n        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {\n\n            int alphabet_size = alphabet_sizes[j];\n\n            if (!j && img->color_cache_bits > 0)\n\n                alphabet_size += 1 << img->color_cache_bits;\n\n\n\n            if (get_bits1(&s->gb)) {\n\n                read_huffman_code_simple(s, &hg[j]);\n\n            } else {\n\n                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    width = img->frame->width;\n\n    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)\n\n        width = s->reduced_width;\n\n\n\n    x = 0; y = 0;\n\n    while (y < img->frame->height) {\n\n        int v;\n\n\n\n        hg = get_huffman_group(s, img, x, y);\n\n        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);\n\n        if (v < NUM_LITERAL_CODES) {\n\n            /* literal pixel values */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            p[2] = v;\n\n            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);\n\n            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);\n\n            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);\n\n            if (img->color_cache_bits)\n\n                color_cache_put(img, AV_RB32(p));\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {\n\n            /* LZ77 backwards mapping */\n\n            int prefix_code, length, distance, ref_x, ref_y;\n\n\n\n            /* parse length and distance */\n\n            prefix_code = v - NUM_LITERAL_CODES;\n\n            if (prefix_code < 4) {\n\n                length = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = (prefix_code - 2) >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                length = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);\n\n            if (prefix_code > 39) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"distance prefix code too large: %d\\n\", prefix_code);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (prefix_code < 4) {\n\n                distance = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = prefix_code - 2 >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                distance = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n\n\n            /* find reference location */\n\n            if (distance <= NUM_SHORT_DISTANCES) {\n\n                int xi = lz77_distance_offsets[distance - 1][0];\n\n                int yi = lz77_distance_offsets[distance - 1][1];\n\n                distance = FFMAX(1, xi + yi * width);\n\n            } else {\n\n                distance -= NUM_SHORT_DISTANCES;\n\n            }\n\n            ref_x = x;\n\n            ref_y = y;\n\n            if (distance <= x) {\n\n                ref_x -= distance;\n\n                distance = 0;\n\n            } else {\n\n                ref_x = 0;\n\n                distance -= x;\n\n            }\n\n            while (distance >= width) {\n\n                ref_y--;\n\n                distance -= width;\n\n            }\n\n            if (distance > 0) {\n\n                ref_x = width - distance;\n\n                ref_y--;\n\n            }\n\n            ref_x = FFMAX(0, ref_x);\n\n            ref_y = FFMAX(0, ref_y);\n\n\n\n            /* copy pixels\n\n             * source and dest regions can overlap and wrap lines, so just\n\n             * copy per-pixel */\n\n            for (i = 0; i < length; i++) {\n\n                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);\n\n                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);\n\n\n\n                AV_COPY32(p, p_ref);\n\n                if (img->color_cache_bits)\n\n                    color_cache_put(img, AV_RB32(p));\n\n                x++;\n\n                ref_x++;\n\n                if (x == width) {\n\n                    x = 0;\n\n                    y++;\n\n                }\n\n                if (ref_x == width) {\n\n                    ref_x = 0;\n\n                    ref_y++;\n\n                }\n\n                if (y == img->frame->height || ref_y == img->frame->height)\n\n                    break;\n\n            }\n\n        } else {\n\n            /* read from color cache */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);\n\n\n\n            if (!img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (cache_idx >= 1 << img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"color cache index out-of-bounds\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            AV_WB32(p, img->color_cache[cache_idx]);\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4029, "substitutes": {"s": ["sam", "service", "n", "sg", "spec", "stats", "scl", "qs", "self", "ses", "an", "services", "es", "b", "c", "status", "d", "r", "ts", "its", "ps", "gs", "is", "sys", "st", "e", "info", "ss", "conf", "g", "ims", "ctx", "sv", "os", "fs", "ds", "a", "set", "vs", "sts", "ats", "op", "times", "t", "rs", "ns", "as", "serv", "sb", "S", "ins", "args", "sw", "session", "sq", "cs", "js", "aws", "m"], "role": ["tag", "note", "lambda", "slice", "only", "pillar", "relation", "can", "style", "rb", "angle", "error", "by", "slot", "frame", "RO", "seed", "star", "rule", "r", "family", "type", "definition", "attribute", "fun", "user", "function", "format", "member", "image", "ke", "def", "file", "name", "binding", "group", "source", "balance", "task", "scope", "key", "origin", "br", "position", "le", "profile", "slave", "rot", "state", "node", "priority", "rel", "resource", "order", "table", "LE", "module", "ole", "root", "policy", "Role", " galaxy", "range", "label", "chain", "ti", "level", "mode", "rol", "base", "ro"], "w": ["wa", "nw", "wx", "W", "wid", "ew", "q", "b", "wr", "c", " dw", "d", "wn", "rw", "wb", "ww", "wh", "l", "wal", "kw", "iw", "ow", "wi", "win", "wd", "fw", "hw", "aw", "wp", "wl", "m", "wt"], "h": ["ish", "k", "ph", "ht", "hi", "high", "dh", "q", "b", "c", "ih", "hh", "ha", "he", "bh", "height", "hd", "wh", "l", "uh", "hei", "H", "g", "ho", "en", "o", "kh", "t", "oh", "z", "f", "ch", "m", "ah"], "img": ["inst", "org", "xml", "og", "cache", "mount", "av", "ind", "aug", "conn", "it", "alg", "ie", "shr", "hw", "pkg", "amp", "cmd", "gm", "prop", "fm", "bl", "str", "app", "init", "md", "gd", "uf", "att", "util", "am", "buf", "auth", "pub", "gr", "def", "jp", "num", "ahi", "utm", "agg", "inf", "eval", "uv", "imm", "anim", "desc", "dim", "aff", "tag", "attr", "ext", "lib", "images", "jpg", "np", "emb", "iam", "bg", "im", "png", "ip", "good", "info", "gif", "msg", "op", "dr", "imgur", "tmp", "imp", "nm", "m", "ht", "proc", "orig", "form", "ag", "embed", "mask", "comment", "imag", "html", "mp", "mem", "ob", "image", "g", "conf", "opp", "ann", "important", "url", "doc", "ref", "pg", "obj", "f", "um", "db", " imag"], "hg": ["Hgm", " hbg", "wg", " hgm", "Hg", "Hgs", " hgs", "hgs", "Hbg", "hbg", "wgs", "hgm", "wbg", "wgm"], "i": ["I", "n", "li", "b", "ir", "ii", "im", "mi", "r", "l", "ij", "in", "o", "it", " ii", "ix", "ci", "index", "f", "id", "m"], "j": ["k", "uj", "n", "jc", "q", "b", "jump", "job", "ii", "r", "dj", "ji", "l", "ij", "jj", "jp", "g", "br", "kj", "aj", "z", "jl", "js", "J", "m", "pos"], "ret": ["rets", "nt", "re", "tr", "pas", "rm", "deg", "success", "ry", "dt", "resp", "Ret", "val", "txt", "net", "cmd", "alf", "att", "status", "at", "after", "alt", "def", "ft", "gt", "jp", "len", "ter", "bit", "rel", "cont", "mat", "mt", "fail", "ure", "complete", "ext", "cat", "jpg", "nz", "Return", "new", "try", "arg", " Ret", "out", "rt", "elt", "addr", "RET", "usr", "dr", "result", "rem", "flag", "nl", "det", "final", "not", "pt", "rect", "gc", "mem", "fun", "arr", "reset", "res", "cert", "ref", "mb", "red", "print", "back"], "x": ["xs", "path", "X", "height", "lat", "xy", "rx", "fx", "l", "in", "image", "xi", "ix", "px", "yx", "f", "ox", "tx", "xt", "m", "dx", "ex"], "y": ["iy", "n", "b", "yt", "height", "py", "ey", "xy", "offset", "my", "ys", "col", "yy", "ny", "ym", "t", "Y", "sy", "yl", "axy", "ch", "m", "top"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void ff_mspel_motion(MpegEncContext *s,\n\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                               int motion_x, int motion_y, int h)\n\n{\n\n    Wmv2Context * const w= (Wmv2Context*)s;\n\n    uint8_t *ptr;\n\n    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;\n\n    int emu=0;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    dxy = 2*dxy + w->hshift;\n\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n\n    src_y = s->mb_y * 16 + (motion_y >> 1);\n\n\n\n    /* WARNING: do no forget half pels */\n\n    v_edge_pos = s->v_edge_pos;\n\n    src_x = av_clip(src_x, -16, s->width);\n\n    src_y = av_clip(src_y, -16, s->height);\n\n\n\n    if(src_x<=-16 || src_x >= s->width)\n\n        dxy &= ~3;\n\n    if(src_y<=-16 || src_y >= s->height)\n\n        dxy &= ~4;\n\n\n\n    linesize   = s->linesize;\n\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n\n\n        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos\n\n                              || src_y + h+1 >= v_edge_pos){\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,\n\n                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);\n\n            ptr= s->edge_emu_buffer + 1 + s->linesize;\n\n            emu=1;\n\n        }\n\n\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);\n\n\n\n    if(s->flags&CODEC_FLAG_GRAY) return;\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        dxy = 0;\n\n        if ((motion_x & 3) != 0)\n\n            dxy |= 1;\n\n        if ((motion_y & 3) != 0)\n\n            dxy |= 2;\n\n        mx = motion_x >> 2;\n\n        my = motion_y >> 2;\n\n    } else {\n\n        mx = motion_x / 2;\n\n        my = motion_y / 2;\n\n        dxy = ((my & 1) << 1) | (mx & 1);\n\n        mx >>= 1;\n\n        my >>= 1;\n\n    }\n\n\n\n    src_x = s->mb_x * 8 + mx;\n\n    src_y = s->mb_y * 8 + my;\n\n    src_x = av_clip(src_x, -8, s->width >> 1);\n\n    if (src_x == (s->width >> 1))\n\n        dxy &= ~1;\n\n    src_y = av_clip(src_y, -8, s->height >> 1);\n\n    if (src_y == (s->height >> 1))\n\n        dxy &= ~2;\n\n    offset = (src_y * uvlinesize) + src_x;\n\n    ptr = ref_picture[1] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);\n\n\n\n    ptr = ref_picture[2] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);\n\n}\n", "idx": 4041, "substitutes": {"s": ["n", "sg", "an", "services", "r", "south", "is", "v", "ops", "ies", "fs", "ds", "eps", "er", "sb", "y", "sq", "hs", "sports", "app", "bs", "ses", "c", "ges", "ims", "sv", "os", "a", "sts", "ats", "as", "ports", "qs", "p", "ps", "comments", "l", "sys", "less", "ss", "ms", "space", "bis", "state", "args", "sp", "aunts", "m", "ex", "spec", "stats", "self", "comm", "es", "b", "ls", "als", "ts", "its", "changes", "gs", "e", "g", "conf", "se", "settings", "t", "rs", "ns", "ins", "S", "obj", "sw", "f", "cs", "js", "aws", "o"], "dest_y": ["dest_x", "dest__x", "dest_xy", "dest__y", "dest__xy", "src_gy", "dest_gy", "src_xy", "dest__gy"], "dest_cb": ["dest_rb", "src_cm", "dest8cb", "src_rb", "dest8cm", "dest8cpp", "src_cpp", "src_cb", "dest_cpp", "dest8rb", "dest_cm"], "dest_cr": ["src_cm", "dest2cr", "destLcb", "dest2cb", "destLcm", "src_cr", "src_crop", "dest2cm", "destLcrop", "src_cb", "dest_cm", "dest2crop", "dest_crop", "destLcr"], "ref_picture": ["ref2image", "ref_frame", "refobjframe", "ref_pict", "reference_picture", "ref2profile", "reference_image", "ref_reference", "refobjprofile", "reference_frame", "ref____image", "refobjpict", "reference_reference", "refobjpicture", "ref2picture", "reference_profile", "ref____picture", "ref2frame", "ref2pict", "ref2reference", "reference_pict", "ref____reference", "ref_profile", "ref_image"], "pix_op": ["pil_hop", "pil_ops", "pix_oper", "pil_op", "pil_oper", "pix2op", "pix2oper", "pix_hop", "pix_ops", "pix2hop", "pix2ops"], "motion_x": ["ision00ox", "feature___xx", "motion08left", "motion_ex", "ision_x", "motion00ex", "ision_ex", "feature_xt", "motion00x", "ision_ox", "feature_x", "motion_left", "motion08ex", "sequence_x", "motion_xt", "feature_xx", "feature___x", "motion___y", "motion___xt", "ision00ex", "motion_xx", "feature___y", "ision_tx", "motion_ox", "ision00x", "motion08x", "sequence08left", "sequence08x", "feature_y", "motion___x", "motion08ox", "motion_tx", "sequence_ox", "feature___xt", "sequence08ox", "motion00ox", "ision00tx", "motion00tx", "motion___xx", "sequence_left", "motion08tx"], "motion_y": ["motion2yy", "motion__b", "motion2x", "motion_z", "motion2y", "motion___ey", "motion__yy", "feature_x", "music_z", "music_y", "motion__y", "motion67x", "feature___yt", "otion_y", "motion_yy", "feature___x", "motion_yt", "otion_b", "feature___ey", "music11z", "motion_ey", "motion7z", "feature___y", "motion__x", "motion11z", "motion11entity", "music_content", "feature_yt", "feature_y", "motion___yt", "motion___x", "motion2b", "motion11content", "music_entity", "motion7entity", "music11entity", "motion_content", "otion_x", "motion67yt", "motion11y", "music11content", "motion_b", "motion7y", "motion67ey", "motion67y", "otion_yy", "music11y", "feature_ey", "motion___y", "motion7content", "motion_entity"], "h": ["ish", "k", "ht", "hi", "hash", "length", "b", "ih", "c", "d", "hh", "ha", "he", "bh", "height", "p", "r", "i", "l", "loop", "uh", "v", "H", "u", "a", "kh", "t", "oh", "size", "hz", "y", "hw", "z", "f", "hs", "ch", "m", "j"], "w": ["wa", "nw", "W", "new", "c", "tw", "d", "r", "p", "rw", "wb", "wh", "mem", "window", "word", "v", "e", "RW", "kw", "g", "cam", "wcs", "t", "words", "enc", "y", "fw", "hw", "sw", "z", "writer", "weights", "wp", "m", "wt"], "ptr": ["dq", "tp", "eth", "iter", "np", "rep", "tr", "dist", "td", "src", "pt", "pr", "r", "p", "inter", "ts", "pointer", "req", "Ptr", "pad", "i", "pc", "fp", "prime", "row", "off", "ij", "trace", "jp", "seek", "shift", "br", "adr", "push", "addr", "loc", "pointers", "rel", "ref", "index", "y", "dr", "tmp", "address", "crop", "sp", "buffer", "ctr", "j", "pos"], "dxy": [" dzip", "dlate", "Dwy", "pdlate", "bdXY", "fdoxy", "fdwy", " dx", "bdoxy", "Dcoord", " doxy", "bdxy", "dcoord", "ddwy", "idxy", " dcoord", "Doxy", "fdxy", "pdxy", "ddoxy", "bdpx", "pdzip", "ddxy", "bdxf", " dwy", " daxis", "dXY", "daxis", "dpx", "idaxis", "ddXY", "doxy", "Dlate", "DXY", "fdpx", "bdwy", "pdoxy", "dwy", " dXY", " dlate", " dpx", "sdXY", "dxf", "Dxf", "sdoxy", "idXY", " dxf", "Dzip", "ddx", "bdx", "dzip", "sdcoord", "Dxy", "sdxy", "ddxf", "ddaxis", "idx", "dx"], "offset": ["center", "error", "start", "scroll", "xy", "ip", "mm", "image", "shift", "ay", "coord", "origin", "key", "location", "addr", "set", "loc", "op", "index", "tile", "size", "mt", "address", "crop", "Offset", "off", "pos"], "mx": ["wx", "tp", "xs", "mi", "mp", "rx", "fx", "mm", "mes", "ax", "xc", "mic", "ms", "mn", "ma", "px", "tm", "hz", "mt", "xx", "mph", "yx", "ml", "ox", "tx", "ex", "xp", "mr"], "my": ["sym", "mis", "by", "mi", "ias", "py", "mp", "mm", "mk", "tom", "tz", "ky", "ms", "me", "mid", "ma", "yy", "ny", "pm", "ym", "mt", "yx", "ury", "ty", "gy", "cy", "mr"], "src_x": ["rc_yx", "src___d", "attr00y", "src__ix", "attr00x", "srcpyyx", "rc_y", "attr00lat", "src___px", "rc_rx", "source_px", "rc_ry", "attr_x", "rc_wx", "source_y", "src_w", "source_x", "attr_name", "rc_x", "attr_lat", "src__rx", "src_z", "src___z", "src_d", "src_ry", "srcpyex", "srcpypx", "rc_ex", "srcpyy", "src00name", "src_px", "source_z", "src_ex", "attr_y", "src_rx", "src_ix", "src___y", "source_d", "src___xc", "src__x", "src00lat", "source_xc", "source_ox", "attr00name", "src__ex", "srcpyxc", "source_ex", "rc_w", "src_name", "src00x", "src_lat", "src_xc", "srcpyX", "src__y", "src_ox", "rc_X", "src00y", "src_yx", "src___x", "rc_ix", "src_X", "srcpyx", "src_wx", "source_rx"], "src_y": ["supp_ny", " src_ye", "inst___cy", "inst_y", "rc_ey", "inst_cy", "src___yy", "src_yer", " src_yt", "src_yy", " src_i", "src_b", "rc_y", "src_i", " src_ies", "src_ey", "source_py", "src64ies", " src_b", "source_y", "source_x", "source_b", "rc_x", "src_sy", "srcaxysy", "srcaxypy", "inst___x", "source_sy", "src_ry", "src_ye", "src_Y", "src___y", "syn_ry", "src64yer", "inst___y", "syn_cy", "srcaxyx", " src_yy", "src___cy", "inst_x", "inst_yy", "srcaxyy", "supp_ya", "syn_y", "supp_y", "src64i", "src___i", "src_xy", "src_ies", "src_py", " src_yer", "src_ny", "src_yt", "inst___yy", "syn_xy", "supp_yy", "src64y", "src___ies", "src___x", "src_ya", "source_Y", "src___yer", "src_cy"], "v_edge_pos": ["v_edge2pos", "v_ge_position", "v_ge_pos", "v_entity_loc", "v_edgeptPos", "v_node_loc", "v_edge__buf", "v_ge_pose", "v_entity___pos", "v_edge2position", "v_edge2pose", "v_node_Pos", "v_ge_Pos", "v_edge___pro", "v_entity___pose", "v_edge_pose", "v_Edge_buf", "v_edge___pose", "v_edge_loc", "v_edge_op", "v_edge_Pos", "v_edge___buf", "v_ge_op", "v_edge___loc", "v_Edge_pos", "v_edgepttag", "v_Edge_pro", "v_entity___loc", "v_edge_pro", "v_entity_pose", "v_edge2loc", "v_edge___pos", "v_edge_buf", "v_edge_tag", "v_edgeptpos", "v_ge_tag", "v_edge__loc", "v_Edge_loc", "v_entity_pos", "v_edge__pro", "v_node_pos", "v_edge_position", "v_ge_loc", "v_edge__pos", "v_node_position", "v_edgeptop"], "linesize": ["pointsized", "linesization", "linesizer", "linesate", "codesize", "platesize", "codeszie", "pointsiz", "framesizer", "levelsized", "platesizer", "framesiz", "ringsIZE", "elinesize", "platesate", "lineszie", "pointsizer", "stylesizer", "elinesate", "linesIZE", "elinesized", "stylesIZE", " lineszie", " linesization", "stylesize", "linesized", "platesiz", "pointsization", "stylesization", "levelsize", "styleszie", "framesization", "ringsize", "elinesization", "lsization", "ringsizer", "lsiz", "inesiz", "inesized", "framesize", "codesizer", "inesize", "pointsize", "inesate", "elinesiz", "levelsIZE", "lsize", "codesization", "codesiz", "elinesizer", " linesizer", "inesizer", "elinesIZE", "levelsization", "ringsization", "linesiz", "inesization", "codesIZE", "framesized", "inesIZE", "lsIZE"], "uvlinesize": ["svineszie", "uvlinesiz", "uvlinszie", "uvinesiz", "svinesize", "lvlevelsiz", "uvinesize", "uvinesized", "svinesense", "uvpointsify", "lvlevelsized", "avlsization", "uvlinesify", "uvworksify", "uvlinesense", "uvblocksiz", "uvblockszie", "uvlevelsization", "lvlinesization", "uvblocksense", "uvlinsiz", "uvpointsiz", "uvlsiz", "avlsify", "svlinesize", "uvlevelsize", "uvlsify", "svlinesense", "uvworksiz", "uvblocksize", "uvpointsize", "lvlevelsization", "svlineszie", "uvpointsization", "lvlinesiz", "uvlinesized", "uvlosize", "uvineszie", "uvlineszie", "lvlinesized", "avlinesization", "uvinesization", "uvlevelsiz", "lvlinesize", "uvlsization", "avlinesiz", "uvinesense", "avlinesify", "avlsiz", "uvlevelsized", "svlinesiz", "uvlinsize", "uvlinesization", "avlinesize", "avlsize", "uvlsize", "lvlevelsize", "uvworksize", "svinesiz", "uvlinsense", "uvlosized", "uvlosiz", "uvworksization", "uvlosization"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane,\n\n                             unsigned char *src_plane,\n\n                             unsigned char *ref_plane,\n\n                             unsigned char *decoded_plane,\n\n                             int width, int height, int src_stride, int stride)\n\n{\n\n    const AVFrame *f = s->avctx->coded_frame;\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    uint8_t *src     = s->scratchbuf + stride * 16;\n\n    const int lambda = (f->quality * f->quality) >>\n\n                       (2 * FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width  = (width  + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n        s->m.avctx                         = s->avctx;\n\n        s->m.current_picture_ptr           = &s->m.current_picture;\n\n        s->m.last_picture_ptr              = &s->m.last_picture;\n\n        s->m.last_picture.f.data[0]        = ref_plane;\n\n        s->m.linesize                      =\n\n        s->m.last_picture.f.linesize[0]    =\n\n        s->m.new_picture.f.linesize[0]     =\n\n        s->m.current_picture.f.linesize[0] = stride;\n\n        s->m.width                         = width;\n\n        s->m.height                        = height;\n\n        s->m.mb_width                      = block_width;\n\n        s->m.mb_height                     = block_height;\n\n        s->m.mb_stride                     = s->m.mb_width + 1;\n\n        s->m.b8_stride                     = 2 * s->m.mb_width + 1;\n\n        s->m.f_code                        = 1;\n\n        s->m.pict_type                     = f->pict_type;\n\n        s->m.me_method                     = s->avctx->me_method;\n\n        s->m.me.scene_change_score         = 0;\n\n        s->m.flags                         = s->avctx->flags;\n\n        // s->m.out_format                    = FMT_H263;\n\n        // s->m.unrestricted_mv               = 1;\n\n        s->m.lambda                        = f->quality;\n\n        s->m.qscale                        = s->m.lambda * 139 +\n\n                                             FF_LAMBDA_SCALE * 64 >>\n\n                                             FF_LAMBDA_SHIFT + 7;\n\n        s->m.lambda2                       = s->m.lambda * s->m.lambda +\n\n                                             FF_LAMBDA_SCALE / 2 >>\n\n                                             FF_LAMBDA_SHIFT;\n\n\n\n        if (!s->motion_val8[plane]) {\n\n            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *\n\n                                                 block_height * 2 + 2) *\n\n                                                2 * sizeof(int16_t));\n\n            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *\n\n                                                 (block_height + 2) + 1) *\n\n                                                2 * sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type = s->mb_type;\n\n\n\n        // dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mb_type = s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table                      = s->motion_val16[plane] +\n\n                                               s->m.mb_stride + 1;\n\n        s->m.dsp                             = s->dsp; // move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size      = s->avctx->dia_size;\n\n        s->m.first_slice_line = 1;\n\n        for (y = 0; y < block_height; y++) {\n\n            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n\n            s->m.mb_y                  = y;\n\n\n\n            for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                       width);\n\n                for (x = width; x < 16 * block_width; x++)\n\n                    src[i * stride + x] = src[i * stride + x - 1];\n\n            }\n\n            for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n                memcpy(&src[i * stride], &src[(i - 1) * stride],\n\n                       16 * block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x = x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line = 0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,\n\n                        CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line = 1;\n\n    for (y = 0; y < block_height; y++) {\n\n        for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                   width);\n\n            for (x = width; x < 16 * block_width; x++)\n\n                src[i * stride + x] = src[i * stride + x - 1];\n\n        }\n\n        for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n\n\n\n        s->m.mb_y = y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7 * 32];\n\n            int count[3][6];\n\n            int offset       = y * 16 * stride + x * 16;\n\n            uint8_t *decoded = decoded_plane + offset;\n\n            uint8_t *ref     = ref_plane + offset;\n\n            int score[4]     = { 0, 0, 0, 0 }, best;\n\n            uint8_t *temp    = s->scratchbuf;\n\n\n\n            if (s->pb.buf_end - s->pb.buf -\n\n                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x = x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_I ||\n\n                (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                 CANDIDATE_MB_TYPE_INTRA)) {\n\n                for (i = 0; i < 6; i++)\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],\n\n                                  7 * 32);\n\n                if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0] = vlc[1] * lambda;\n\n                }\n\n                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n\n                                         5, 64, lambda, 1);\n\n                for (i = 0; i < 6; i++) {\n\n                    count[0][i] = put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            } else\n\n                score[0] = INT_MAX;\n\n\n\n            best = 0;\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                    CANDIDATE_MB_TYPE_INTER) {\n\n                    for (i = 0; i < 6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],\n\n                                      7 * 32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb = s->reorder_pb[5];\n\n                    mx      = motion_ptr[0];\n\n                    my      = motion_ptr[1];\n\n                    assert(mx     >= -32 && mx     <= 31);\n\n                    assert(my     >= -32 && my     <= 31);\n\n                    assert(pred_x >= -32 && pred_x <= 31);\n\n                    assert(pred_y >= -32 && pred_y <= 31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5] = s->m.pb;\n\n                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy = (mx & 1) + 2 * (my & 1);\n\n\n\n                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,\n\n                                                   ref + (mx >> 1) +\n\n                                                   stride * (my >> 1),\n\n                                                   stride, 16);\n\n\n\n                    score[1] += encode_block(s, src + 16 * x, temp + 16,\n\n                                             decoded, stride, 5, 64, lambda, 0);\n\n                    best      = score[1] <= score[0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4062, "substitutes": {"s": ["n", "ants", "r", "south", "is", "v", "views", "ops", "parts", "fs", "ds", "gets", "sb", "h", "sq", "hs", "sports", "bs", "ses", "c", "ties", "ims", "sv", "os", "a", "vs", "sts", "ats", "as", "https", "ports", "qs", "states", "p", "ps", "l", "sys", "less", "ss", "ms", "ar", "bis", "set", "so", "times", "sl", "m", "bes", "ex", "spec", "stats", "self", "comm", "es", "ls", "w", "ts", "its", "changes", "gs", "e", "g", "ers", "t", "ns", "rs", "ins", "S", "sw", "cs", "js", "aws"], "plane": ["plot", "age", "slice", "planes", "mask", "angle", "face", "frame", "pose", "p", "board", "window", "ane", "port", "panel", "flow", "code", "fl", "pe", "profile", "plate", "buffer", "clip", "mode", "line", "ide"], "src_plane": ["rc_planes", "src_planes", "srclyplane", "rc_cube", "rc_source", "src_source", "rc_plane", "srclyplanes", "srclycube", "srclysource", "src_cube"], "ref_plane": ["refptplane", "ref_frame", "imglygate", "refptplanes", "REF___plane", "ref__gate", "ref___mate", "ref__plane", "ref___line", "ref__frame", "reflyframe", "img_plane", "REF_planes", "REF_plane", "img_frame", "imglyframe", "ref___plane", "img_panel", "ref___frame", "REF_mate", "reflyplane", "ref_gate", "imglypanel", "ref___gate", "ref_planes", "img_gate", "reflypanel", "REF_line", "ref_line", "imglyplane", "REF___mate", "ref___planes", "ref___panel", "ref__panel", "refptline", "REF___planes", "refptmate", "ref_mate", "REF___line", "reflygate", "ref_panel"], "decoded_plane": ["decodedatedmode", "decodedatedplanes", "decode_flat", "decoded_planes", "decodedatedflat", "decoded___planes", "decode_mode", "decode_plane", "decoded___mode", "decoded___flat", "decoded_flat", "decoded_mode", "decode_planes", "decoded___plane", "decodedatedplane"], "height": ["quality", "ht", "resolution", "how", "view", "high", "hash", "hang", "holes", "length", "above", "volume", "angle", "gh", "grow", "style", "rank", "th", "Height", "html", "capacity", "density", "window", "hei", "power", "image", " heights", "history", "ows", "bottom", "background", "host", "radius", "zh", "table", "size", "stroke", "h", "SIZE", "axy", "gravity", "weight", "depth", "shape", "padding", "ty", "range", "id", "buffer", "dim", "show"], "src_stride": ["src_slride", "src_brride", "src_slider", "src_brider", "src_strride", "src_brine", "src_slide", "src_trride", "src_strider", "src_strine", "src_trine", "src_tride", "src_trider", "src_sline", "src_bride"], "stride": ["decider", "brider", "Stride", "sprride", "divider", "Strime", "slider", "StrIDE", "slIDE", "Strride", "sprider", "Strider", "divIDE", "strride", "strime", "strided", "decide", "strIDE", "arrider", "arrided", "brime", "bride", "arrride", "decride", "strider", "divide", "slided", "decime", "slide", "divided", "sprIDE", "brride", "arrIDE", "spride", "arride"], "f": ["aff", "fm", "lf", "of", "fu", "fb", "form", "ff", "fr", "ef", "uf", "b", "c", "elf", "d", "frame", "w", "fg", "fo", "fen", "p", "fa", "fe", "feat", "l", "fp", "cf", "rf", "v", "field", "e", "fi", "bf", "xf", "fab", "ft", "fc", "def", "df", "fs", "fl", "full", "fff", "foreign", "t", "fd", "inf", "sf", "tf", "h", "fw", "F", "m", "data", "fac"], "x": ["xs", "pos", "X", "w", "r", "p", "lat", "rx", "xy", "fx", "l", "v", "col", "coord", "o", "a", "ix", "px", "ox", "tx", "m", "dx", "ex"], "y": ["iy", "yr", "b", "yi", "m", "yt", "py", "p", "ey", "xy", "e", "a", "yy", "ny", "ym", "t", "Y", "yl", "axy", "ty", "ch", "o", "cy", "sy"], "i": ["phi", "k", "iy", "I", "n", "li", "b", "c", "di", "ii", "mi", "r", "p", "l", "v", "ij", "e", "pi", "it", "si", "ci", "t", "index", "h", "id", "m", "j"], "block_width": ["mb_work", "block_write", " block_flow", "block_Width", "mb_write", "block12Width", "blockLflow", " block_Width", "block_work", "blockLWidth", "row_width", "mb_width", "block12width", " block_work", "block_length", "blockLwidth", "row_height", "row_length", "blocklexwrite", "blocklexwidth", "blocklexwork", "block12flow", "block_flow", "block12work", "blockLwork"], "block_height": ["block_capacity", "line_height", "block10capacity", "block10width", "block_ty", " block_capacity", "line_window", "block10height", "block_resolution", " block_length", " block_ty", " block_resolution", "block_window", "line_ty", "block_length", "line_density", "block_density", "block10resolution"], "level": ["tag", "k", "quality", "n", "stack", "open", "what", "high", "length", "layer", "point", "angle", "volume", "status", "vel", "frame", "block", "kl", "VEL", "family", "local", "type", "cost", "variable", "l", "loop", "ind", "v", "L", "goal", "stage", "e", "low", "len", "levels", "scope", "key", "limit", "code", "go", "all", "episode", "pe", "le", "pass", "Level", "counter", "load", "pl", "state", "priority", "lvl", "order", "index", "where", "call", "zero", "module", "user", "role", "scale", "depth", "broad", "val", "lo", "print", "mode", "po", "show", "prop"], "threshold": ["ethresh", "shail", "Threshold", "THilt", "tholerance", "thilt", "thhold", "shreshold", "THreshold", "thsensor", "Thhold", "hashhold", "Thail", "THensor", "shilt", "thsreshold", "hasholerance", "ethafety", "thsilt", "chreshold", "thsresh", "THafety", "ethhold", " thresh", "hashresh", "THhold", "cholerance", "thresh", "shensor", " thhold", "ethreshold", "chhold", "thensor", " thafety", "THolerance", "Thresh", "shhold", "shresh", "THail", "chresh", "thafety", "hashreshold", "thail", "THresh"], "src": ["inst", "input", "str", "rc", "tr", "dist", "cur", "th", "dest", "comp", "r", "rl", "buf", "stream", "iv", "img", "st", "sys", "sup", "sc", "source", "trans", "loc", "sb", "ptr", "tmp", "ctr", "buffer"]}}
{"project": "FFmpeg", "commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "target": 1, "func": "static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             int is_extradata)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    AVBufferRef *buf = NULL;\n\n    int size = 0;\n\n    uint8_t *data = (uint8_t *)\"\";\n\n    uint8_t *start;\n\n    int ret = 0;\n\n\n\n    if (avpkt->size) {\n\n        if (avpkt->buf) {\n\n            buf = av_buffer_ref(avpkt->buf);\n\n            size = avpkt->size;\n\n            data = avpkt->data;\n\n        } else {\n\n            buf = av_buffer_alloc(avpkt->size);\n\n            if (buf) {\n\n                memcpy(buf->data, avpkt->data, avpkt->size);\n\n                size = buf->size;\n\n                data = buf->data;\n\n            }\n\n        }\n\n        if (!buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n        if (!is_extradata)\n\n            ctx->packets_sent++;\n\n    } else {\n\n        if (!ctx->packets_sent) {\n\n            // Short-cut the flush logic to avoid upsetting MMAL.\n\n            ctx->eos_sent = 1;\n\n            ctx->eos_received = 1;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    start = data;\n\n\n\n    do {\n\n        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));\n\n        if (!buffer) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n\n\n        buffer->data = data;\n\n        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);\n\n\n\n        if (is_extradata)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;\n\n\n\n        if (data == start)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;\n\n\n\n        data += buffer->length;\n\n        size -= buffer->length;\n\n\n\n        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;\n\n        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;\n\n\n\n        if (!size)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;\n\n\n\n        if (!buffer->length) {\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;\n\n            ctx->eos_sent = 1;\n\n        }\n\n\n\n        if (buf) {\n\n            buffer->ref = av_buffer_ref(buf);\n\n            if (!buffer->ref) {\n\n                av_free(buffer);\n\n                ret = AVERROR(ENOMEM);\n\n                goto done;\n\n            }\n\n        }\n\n\n\n        // Insert at end of the list\n\n        if (!ctx->waiting_buffers)\n\n            ctx->waiting_buffers = buffer;\n\n        if (ctx->waiting_buffers_tail)\n\n            ctx->waiting_buffers_tail->next = buffer;\n\n        ctx->waiting_buffers_tail = buffer;\n\n    } while (size);\n\n\n\ndone:\n\n    av_buffer_unref(&buf);\n\n    return ret;\n\n}\n", "idx": 4064, "substitutes": {"avctx": ["afctx", "afcc", "avcontext", "AVcontext", "avkit", " avkit", "cvcontext", "avconn", "afcontext", "aveconn", "avekit", "avcc", "AVctx", "cvctx", "cvkit", "cvconn", "AVconn", " avcontext", "avectx", "avecontext", " avconn", "afconn", "AVcc", " avcc"], "avpkt": ["avpatvc", "avpervc", "avercpcht", "avtpck", "avperkg", "avparmk", "avewpk", "iverpaykg", "iverpkt", "iverpaykt", "avpayacket", "abwpkt", "avcpkg", "averpacket", "wavpck", "avppac", "ravpacket", "avpatchmk", "avpkgdu", "avjpkt", "averpconn", "avcpacket", "avperconn", "abpkg", "avepkt", "avppnt", "avpadwk", "iverpkl", "averpkt", "evppkl", "abwpacket", "avjpwd", "avwpkt", "comwpck", "averpac", "avPkt", "avpaywp", "avpidkg", "avpodacket", "avppmk", "aveptt", " avpnt", "avperkt", "avercpac", "avjpConn", "avpaman", "wavpdu", "ajpadConn", "comwpacket", "abptt", "avpidwk", "ravpodacket", "ajpwd", "avpwk", " avPft", "avppft", "wavpkt", "avpidmk", "avepman", "wavpadkt", "avpacket", "avwpcmd", "avcpcht", "wavcpkg", "ravpodmk", "avercpkg", "comwpkt", "avpawp", "avpakg", "avpodnton", "avparck", "avpadmk", "avpck", "avcpck", "iverpwp", "ajpadmsg", "iverpaywp", "wavwpkt", "avjpmsg", "compvc", "wavcpkt", "avtpkg", "avpatck", "avpman", "wavpkg", "avpadkt", "avppacket", "avnpft", "avpyk", "avtpkt", "avpaykl", "ajpmsg", "compkt", "ajpadwd", "avcpkt", "avparkt", "avwpck", "avpatchnton", "avpatt", "avPnt", "avpatchkt", "avpk", "averpcht", "wavpadwk", "avpaykt", "avppkg", "avpkg", "evppkt", "evpkt", "avpmsg", "abpacket", "wavwpwk", "avparConn", "avPct", "evpcmd", "avpadwd", "avparwd", "avpadkg", "avvkt", "avpayac", " avPnt", "avpct", "avpnt", "avpadtt", "avcpac", "evppkg", "avcpconn", "avwptt", "avpadConn", "wavwpdu", "avPft", "iverpkg", "avpyman", "avepk", "avwpvc", "avpadacket", "avpkgcmd", "evpkl", "avpConn", "avpodmk", "avpkgwk", "ravpnton", "avpwd", "avpcmd", "avparmsg", "ajpadkt", "avpkgkt", "avercpkt", "avwpdu", "wavcpck", "avpmk", "compacket", "avpac", "avwpman", "avnpnt", "avewpkt", "ajpConn", "avppkl", "avewptt", "compck", "avpatacket", "avparkg", " avpct", "avnpct", "avtpacket", "wavwpkg", "avpykt", "avpercht", " avPkt", "avpnton", "avpconn", "averpkg", "avpcht", "avppnton", "avwpacket", "ravpkt", "avpidkt", "wavpmk", "abwpkg", "avpodkt", "avpertt", "avpatkt", "avpakt", "avptt", "evppcmd", "avpkgkg", "avpadmsg", "wavpadmk", "avppct", "avpatchacket", "avparacket", "avpytt", "avpwp", "avpkl", "avercpconn", "ravpmk", "wavcpacket", "abpkt", "iverpaykl", "wavpwk", "wavpadkg", "avpakl", "avpaddu", "avpaykg", "avpkgkl", "avvkg", "avvconn", "avwpwk", "evpkg", "avppkt", "avnpkt", " avpft", "wavpacket", " avPct", "avewpman", "ravpodnton", "avpak", "avpdu", "avpft", "ravpodkt", "avppcmd", "avperck", "avwpkl", "avvcht", "avercpacket", "avperacket", "avwpk", "ajpkt", "avwpkg", "avparwk", "avpvc", "comwpvc", "avwpwp", "abwptt"], "is_extradata": ["is_extradATA", "is_extranATA", "is_extractATA", "is_extribATA", "is_extradaton", "is_xtradatum", "is_xtradata", "is_extributedATA", "is_extribata", "is_xtradict", "is_extrendada", "is_extradatum", "is_extracatum", "is_xtracict", "is_extrendata", "is_extracata", "is_extributedict", "is_xtradATA", "is_extranaton", "is_xtracata", "is_xtracay", "is_extrenday", "is_extraday", "is_extracATA", "is_extracada", "is_xtradaton", "is_xtracATA", "is_extracay", "is_extradict", "is_extributedaton", "is_xtracada", "is_xtradada", "is_extrendATA", "is_extranata", "is_xtracaton", "is_xtraday", "is_xtracatum", "is_extradada", "is_extracaton", "is_extranict", "is_extracict", "is_extractada", "is_extractay", "is_extribaton", "is_extranatum", "is_extractata", "is_extributedata", "is_extribatum"], "ctx": ["wx", "np", "nt", "cmp", "exec", "comm", "cfg", "ct", "func", "lc", "comp", "gc", "cp", "cc", "timeout", "req", "mem", "cf", "sys", "context", "bc", "jac", "kw", "xc", "conf", "tz", "fc", "info", "nc", "crit", "rt", "cam", "conn", "ac", "doc", "cb", "addr", "loc", "resp", "fee", "ctrl", "abc", "ref", "txt", "tm", "act", "etc", "cv", "tc", "obj", "unc", "hw", "tmp", "pkg", "cas", "setup", "ctl", "cmd", "tx", "iac", "desc", "config", "buff", "j"], "buf": ["iter", "ff", "tr", "cur", "fg", "bh", "cache", "cp", "bo", "next", "queue", "br", "fam", "txt", "ptr", "pkg", "ah", "cmd", "prop", "bl", "init", "bs", "var", "pool", "foo", "batch", "uf", "map", "max", "window", "nom", "pub", "rev", "cam", "conv", "cb", "loc", "agg", "Buffer", "desc", "urg", "box", "fb", "bp", "rc", "ready", "np", "bin", "quit", "rb", "Buff", "aux", "mk", "abb", "good", "usr", "cv", "tmp", "roller", "alloc", "proc", "orig", "cap", "cfg", "b", "temp", "func", "src", "gen", "block", "opt", "img", "mem", "callback", "bc", "fun", "arr", "conf", "t", "ref", "pg", "obj", "tc", "err", "buff", "env", "vec", "fac"], "data": ["DATA", "n", "count", "time", "length", "options", "items", "error", "output", "cache", "next", "video", "value", "flags", "to", "bits", "done", "package", "address", "json", "padding", "id", "mode", "off", "pos", "empty", "init", "batch", "map", "memory", "pad", "window", "Data", "message", "def", "before", "len", "a", "dat", "meta", "rel", "table", "index", "debug", "no", "partial", "date", "add", "version", "action", "ata", "read", "bin", "step", "height", "p", "ret", "out", "format", "info", "name", "area", "key", "addr", "msg", "text", "mu", "result", "form", "bytes", "results", "not", "d", "type", "timeout", "mem", "offset", "send", "image", "end", "t", "ns", "load", "content", "zero", "ref", "device", "size", "dev", "raw", "sequence"], "start": ["count", "first", "read", "open", "init", "time", "length", "step", "art", "from", "new", "entry", "d", "Start", "p", "starting", "head", "offset", "send", "st", "next", "info", "before", "len", "name", "seek", "shift", "origin", "key", "end", "set", "it", "stop", "addr", "to", "part", "t", " offset", "size", "index", "begin", "tmp", "address", "sp", "wind", "started", "add", "id", "pos"], "packets_sent": ["packets__used", "packes_send", "packet_used", "packet_sent", "packets__send", "packets__received", "packets_used", "packets___sent", "packets___send", "packes_received", "packets___received", "packets_received", "packet_send", "packes_sent", "packet_received", "packets__sent", "packets_send"], "buffer": ["bridge", "iter", "record", "length", "cache", "head", "loop", "header", "append", "queue", "store", "txt", "database", "ptr", "writer", "tree", "console", "directory", "binary", "builder", "batch", "uf", "pb", "map", "bolt", "memory", "window", "row", "program", "message", "command", "timer", "table", "index", "Buffer", "pack", "config", "uffer", "engine", "entry", "frame", "channel", "match", "bar", "button", "FFER", "menu", "document", "seek", "set", "position", "tar", "interface", "reference", "result", "stack", "filter", "page", "temp", "comment", "func", "byte", "face", "block", "type", "timeout", "wrapper", "mem", "callback", "context", "socket", "server", "profile", "device", "tc", "buff", "sequence"]}}
{"project": "FFmpeg", "commit_id": "969267482de97b08503d27d2fe090ec820273e40", "target": 1, "func": "static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n\n{\n\n    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;\n\n    AVCodecContext          *avctx = ost->st->codec;\n\n    int ret;\n\n\n\n    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||\n\n        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))\n\n        pkt->pts = pkt->dts = AV_NOPTS_VALUE;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {\n\n        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);\n\n        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {\n\n            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max);\n\n            pkt->pts = pkt->dts = max;\n\n\n\n\n\n    /*\n\n     * Audio encoders may split the packets --  #frames in != #packets out.\n\n     * But there is no reordering, so we can limit the number of output packets\n\n     * by simply dropping them here.\n\n     * Counting encoded video frames needs to be done separately because of\n\n     * reordering, see do_video_out()\n\n     */\n\n    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {\n\n        if (ost->frame_number >= ost->max_frames) {\n\n            av_free_packet(pkt);\n\n            return;\n\n\n        ost->frame_number++;\n\n\n\n\n    while (bsfc) {\n\n        AVPacket new_pkt = *pkt;\n\n        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,\n\n                                           &new_pkt.data, &new_pkt.size,\n\n                                           pkt->data, pkt->size,\n\n                                           pkt->flags & AV_PKT_FLAG_KEY);\n\n\n\n\n\n\n\n\n\n\n\n        if (a > 0) {\n\n            av_free_packet(pkt);\n\n            new_pkt.destruct = av_destruct_packet;\n\n        } else if (a < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\",\n\n                   bsfc->filter->name, pkt->stream_index,\n\n                   avctx->codec ? avctx->codec->name : \"copy\");\n\n            print_error(\"\", a);\n\n            if (exit_on_error)\n\n                exit_program(1);\n\n\n        *pkt = new_pkt;\n\n\n\n        bsfc = bsfc->next;\n\n\n\n\n    pkt->stream_index = ost->index;\n\n    ret = av_interleaved_write_frame(s, pkt);\n\n    if (ret < 0) {\n\n        print_error(\"av_interleaved_write_frame()\", ret);\n\n        exit_program(1);\n\n", "idx": 4070, "substitutes": {"s": ["sports", "spec", "n", "stats", "bs", "self", "ses", "es", "c", "ls", "status", "sn", "w", "r", "p", "ts", "its", "ps", "ec", "gs", "v", "is", "st", "sys", "socket", "ss", "name", "ctx", "os", "fs", "ds", "server", "a", "set", "sts", "ats", "rs", "t", "ns", "S", "h", "obj", "sq", "cs", "hs", "cmd", "js", "aws", "ser", "o"], "pkt": ["respkt", " pct", "cpkg", "Pct", "upkg", "cpmit", "payett", "upwk", "ppmit", "ppacket", " pkw", "ptxt", "ppkt", "pingcht", " pett", "payacket", "pqt", "patchkw", "pkg", "prect", " pet", "prekt", "pkw", "prtx", "wpnt", "pett", "wkt", " packet", "pingkt", "pinget", "nnt", "pet", "patchnt", "pcht", "upct", "pret", "patchkt", "respacket", "wkg", "wpkt", " pkg", " ptxt", "nkt", "cpcmd", "Pkt", "cett", "patchacket", "cpet", "ppnt", "Pkw", "wacket", "paykt", "ppwk", "cnt", "packet", "nkg", "pct", "spent", "Pqt", "Pnt", "cpkt", "Pett", "upacket", "ppet", "respnt", "prkt", " pqt", "pnt", "upkt", "spacket", "Pcmd", "Pkg", "pingkg", "paymit", "wptx", "respqt", " pcht", " ptx", " pcmd", "Ptx", "spkt", "pent", " pnt", "uptxt", "spet", "ppct", "prent", "cpett", "pcmd", "ppett", "cpnt", "Pcht", "ncmd", "Packet", " pent", "pracket", "ptx", "pptx", "cacket", "Pet", "cpacket", "pingnt", "cpent", "ckt", "pmit", " pwk", "pingacket", "wtxt", "pwk", "wpkg", "prekg"], "ost": ["ist", "ocol", "via", "oo", "the", "nt", "org", "tt", "ot", "ast", "osta", "rest", "est", "oster", "ops", "ocr", "oss", "o", "or", "store", "http", "console", "ox", "ott", "hess", "post", "yt", "ird", "drm", "st", "tto", "ous", "ori", "list", "os", "hop", "ord", "host", "vs", "sts", " nost", "mt", "irst", "htt", "wp", "omp", "utt", "et", "oc", "rost", "vest", "oid", "bott", "sys", "rt", "ctx", "that", "usr", "rog", "boost", "proc", "ust", "oad", "be", "src", "ora", "stone", "onet", "ort", "ob", "obs", "tz", "rob", "server", "ond", "od", "ty", "news", "OST"], "bsfc": ["BScf", "gscf", "ubscf", "bitscf", "bitsfn", "asfc", "jscc", "gsFC", "aslc", "jsfc", "lbstc", "cslc", "ascf", "BSfn", "bitsfc", "bstc", "lbsfc", "bispc", "bscf", "BSfc", "bscc", "bitstc", "ubspc", "ubsFC", "jslc", "bisfc", "ubsfc", "lbscf", "jscf", "bisFC", "bsFC", "gspc", "gsfc", "bsfn", "cscc", "bslc", "ascc", "biscf", "bspc", "cscf", "lbsfn", "BStc", "csfc"], "avctx": ["avcomp", "avctl", "avectl", "avcontext", "camsys", " avgc", "camctx", "avehw", "avca", "avtx", "avertx", "averjac", "avegc", "avercontext", "ravcmp", "avsys", "avergc", "avercomp", " avpkg", "averhw", "wavcf", " avsys", "varca", "verkw", "varcmp", "avekw", "varkw", "camgc", "avkw", "avepkg", "aveca", "camcmp", "ravctx", "vertx", " avcmp", "ravcomp", "aversys", "avhw", "avercf", "verctl", "avejac", " avcf", "verctx", "wavcontext", " avcontext", "varhw", "averkw", "vargc", "avectx", "ravjac", "avecontext", "wavctx", "wavctl", " avjac", " avctl", "varctx", "averctl", "averctx", " avcomp", "avcf", "avpkg", "avjac", "avgc", " avtx", "averpkg", "avecmp", "varjac", "avercmp", " avca", "avetx", "avcmp"], "ret": [" red", " continued", " alt", " resp", " ok", " mem", " res", " arg", " real", " buff", " ma", " Ret", " reply", "gt", " sa", "len", " ans", "Ret", "RET", "val", " af", " tv", "no", "ed", " RET", " total"], "frame_number": ["frameencounter", "frameenno", "frames_index", "frameennumber", "frames_number", "frame__counter", "frame_no", "frame_counter", "frame__number", "frames_counter", "frame_index", " frame_counter", "frameenindex", " frame_no", "frames_no", "frame__no"]}}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 4080, "substitutes": {"l2_cache": ["l2tcache", "l1_cover", "l1_cache", "l2_map", "ltwoptcache", "l2grcache", "l3_cache", "l2xtable", "l2_session", "l2_module", "l2_comment", "l2xreport", "l2ptmap", "l2ptcache", "l2ycover", "ltwopttable", "ltwoptparse", "l2_cover", "l3_comment", "l2pycache", "l2pyhash", "l1_table", "l2grdepth", "l1_depth", "l2grtable", "l1_module", "ltwoptmap", "l2tparse", "l2xcache", "l4_report", "l2cacheCache", "l52_cache", "l2dbcache", "l2cachecache", "l2pttable", "l2_Cache", "l2ytable", "l52_hash", "l2cachecomment", "l4_parse", "ltwo_map", "l4_cache", "l2_hash", "l2_depth", "l2ymodule", "l2_chain", "l52_cover", "l4_session", "l2cachetable", "l3_Cache", "l1_Cache", "l2ptparse", "l2tchain", "l4_table", "l2_parse", "l52_chain", "l4_chain", "l2pychain", "l2grCache", "ltwo_cache", "l3_table", "l2pycover", "l2ycache", "l2dbmodule", "l2dbtable", "l2_report", "ltwo_table", "ltwo_parse", "l2dbcover"], "l2_table": ["l2Tplain", "l3_TABLE", "l2Ttable", "l2__tab", "l2_TABLE", "l3_table", "l2__table", "l3_cache", "l2__tree", "l02_stable", "l3_page", "l2_plain", "l02_table", "l2__cache", "l2_stable", "l2_page", "l3_tree", "l3_tab", "l2Tentity", "l2TTABLE", "l02_cache", "l2_tree", "l3_plain", "l02_tree", "l2_entity", "l2_tab", "l3_entity"], "entry": ["nt", "record", "xml", "attribute", "member", "or", "ry", "delete", "Entry", "ie", "ent", "address", "id", "import", "inner", "child", "escape", "q", "RY", "row", "list", "card", "existent", "table", "index", "equal", "ace", "add", "line", "ment", "needed", "ready", "event", "rent", "see", "cell", "channel", "try", "inter", "match", "valid", "field", "ary", "info", "search", "key", "set", "ce", "node", "tmp", "office", "result", "slot", "instance", "zip", "form", "query", "entity", "comment", "insert", "byte", "enter", "check", "ENT", "offset", "e", "way", "shot", "image", "se", "link", "server", "element", "ence"], "n_entries": ["n_curies", "n_sentires", "n_endants", "n_ENTies", "n_ENTires", "n_ntants", "n_entlements", "n_contry", "n_Entities", "nappingendlements", "nappingentants", "n_ntents", "n_ntries", "n_entires", "n_contants", "n_sentities", "n_enties", "n_senties", "n_Entry", "n_Entries", "n_entities", "n_Enties", "n_endlements", "n_endents", "n_sentries", "nappingentries", "n_contlements", "n_sentriers", "n_contents", "n_entriers", "n_conties", "n_curriers", "n_endries", "nappingentlements", "nappingendants", "n_contries", "n_entants", "n_ntlements", "n_curires", "n_curries", "n_contities", "n_ENTries", "nappingendries", "n_sentry", "nappingentents", "n_ENTriers", "n_entry", "nappingendents", "n_entents"]}}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}", "idx": 4091, "substitutes": {"c": ["cr", "rc", "mc", "cmp", "can", "ct", "ca", "lc", "d", "cu", "comp", "gc", "p", "anc", "cache", "cp", "cc", "ec", "pc", "l", "cf", "cal", "v", "e", "dc", "x", "co", "cm", "bc", "container", "fc", "conf", "sc", "ctx", "cam", "conv", "ac", "coll", "C", "ce", "ci", "t", "cont", "abc", "enc", "etc", "cv", "tc", "f", "cs", "ch", "config", "m", "con"], "avctx": ["avcontext", "avecfg", " avcfg", "AVcontext", " avcontext", "AVcfg", "avecc", "avcfg", "avectx", "avecontext", " avcc", "AVcc", "avcc", "AVctx"], "high_bit_depth": ["high_bit_driven", "high_bitingdeep", "high_bits_deep", "high_byte_weight", "high_byte_height", "high_bitingdepth", "high_bitnessdist", "high_bit_level", "high_bitingdriven", "high_bits_depth", "high_byte_depth", "high_bit_weight", "high_byte_deep", "high_bit_height", "high_bit_deep", "high_bits_distance", "high_bitnessdeep", "high_byte_level", "high_bitingheight", "high_bitnessdepth", "high_bit_distance", "high_byte_driven", "high_bitnessdistance", "high_bits_dist", "high_bit_dist"]}}
