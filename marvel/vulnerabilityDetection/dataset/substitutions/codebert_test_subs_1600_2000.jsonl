{"project": "qemu", "commit_id": "cca1af8c4d2ef6449fd61494ba2cb087b838011c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n\n                            int opc)\n\n{\n\n    int addr_regl, addr_reg1, addr_meml;\n\n    int data_regl, data_regh, data_reg1, data_reg2;\n\n    int mem_index, s_bits;\n\n#if defined(CONFIG_SOFTMMU)\n\n    void *label1_ptr, *label2_ptr;\n\n    int sp_args;\n\n#endif\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(CONFIG_SOFTMMU)\n\n    uint8_t *label3_ptr;\n\n# endif\n\n    int addr_regh, addr_reg2, addr_memh;\n\n#endif\n\n    data_regl = *args++;\n\n    if (opc == 3)\n\n        data_regh = *args++;\n\n    else\n\n        data_regh = 0;\n\n    addr_regl = *args++;\n\n#if TARGET_LONG_BITS == 64\n\n    addr_regh = *args++;\n\n#endif\n\n    mem_index = *args;\n\n    s_bits = opc & 3;\n\n\n\n    if (opc == 3) {\n\n#if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n        data_reg1 = data_regh;\n\n        data_reg2 = data_regl;\n\n#else\n\n        data_reg1 = data_regl;\n\n        data_reg2 = data_regh;\n\n#endif\n\n    } else {\n\n        data_reg1 = data_regl;\n\n        data_reg2 = 0;\n\n    }\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n    addr_reg1 = addr_regh;\n\n    addr_reg2 = addr_regl;\n\n    addr_memh = 0;\n\n    addr_meml = 4;\n\n# else\n\n    addr_reg1 = addr_regl;\n\n    addr_reg2 = addr_regh;\n\n    addr_memh = 4;\n\n    addr_meml = 0;\n\n# endif\n\n#else\n\n    addr_reg1 = addr_regl;\n\n    addr_meml = 0;\n\n#endif\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    tcg_out_opc_sa(s, OPC_SRL, TCG_REG_A0, addr_regl, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_imm(s, OPC_ANDI, TCG_REG_A0, TCG_REG_A0, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_A0, TCG_REG_A0, TCG_AREG0);\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_meml);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T0, TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n    tcg_out_opc_reg(s, OPC_AND, TCG_REG_T0, TCG_REG_T0, addr_regl);\n\n\n\n# if TARGET_LONG_BITS == 64\n\n    label3_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BNE, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_memh);\n\n\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, addr_regh, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    reloc_pc16(label3_ptr, (tcg_target_long) s->code_ptr);\n\n# else\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n# endif\n\n\n\n    /* slow path */\n\n    sp_args = TCG_REG_A0;\n\n    tcg_out_mov(s, sp_args++, addr_reg1);\n\n# if TARGET_LONG_BITS == 64\n\n    tcg_out_mov(s, sp_args++, addr_reg2);\n\n# endif\n\n    tcg_out_movi(s, TCG_TYPE_I32, sp_args++, mem_index);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T9, (tcg_target_long)qemu_ld_helpers[s_bits]);\n\n    tcg_out_opc_reg(s, OPC_JALR, TCG_REG_RA, TCG_REG_T9, 0);\n\n    tcg_out_nop(s);\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xff);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 24);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 24);\n\n        break;\n\n    case 1:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xffff);\n\n        break;\n\n    case 1 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 16);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 16);\n\n        break;\n\n    case 2:\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    case 3:\n\n        tcg_out_mov(s, data_reg2, TCG_REG_V1);\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    label2_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO, 0);\n\n    tcg_out_nop(s);\n\n\n\n    /* label1: fast path */\n\n    reloc_pc16(label1_ptr, (tcg_target_long) s->code_ptr);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_V0, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addend) + addr_meml);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_V0, TCG_REG_V0, addr_regl);\n\n\n\n    addr_reg1 = TCG_REG_V0;\n\n#endif\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_LBU, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_imm(s, OPC_LB, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 1:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LHU, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 1 | 4:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n", "idx": 16352, "substitutes": {"s": ["g", "cs", "sf", "groups", "sys", "f", "secondary", "u", "js", "south", "t", "sq", "ns", "n", "i", "support", "h", "private", "r", "o", "w", "c", "p", "ts", "service", "ssl", "b", "fs", "services", "stats", "S", "m", "sec", "sets", "ses", "e", "os", "sym", "a", "spec", "ds", "qs", "sync", "settings"], "args": ["ys", "Args", "cs", "results", "flags", "groups", "aws", "limits", "ars", "ids", "ds", "asm", "axis", "orders", "conn", "argument", "reg", "parts", "alls", "vals", "ns", "ans", "enc", "aux", "config", "blocks", "bits", "init", "addr", "doc", "ig", "items", "lang", "params", "call", "loc", "gs", "all", "atts", "arms", "uments", "yrs", "ks", "func", "points", "bytes", "ass", "Arg", "sec", "fields", " arguments", "GS", "ins", "arr", "arg", "ams", "qs", "ras", "alloc", "size"], "opc": ["opdc", "oplc", "OPc", "copf", "optcs", "coplc", "ropct", "ropc", " opci", " opct", "opf", "operct", "optf", "coppc", "copct", "opct", "optct", " oppc", "opcs", "ppci", "OPf", "pppc", "ppc", "ropcu", "OPpc", "OPlc", "operc", "operdc", "ppcs", "oppc", "OPct", "opercu", "OPci", "OPcs", "opci", "ropdc", "copc", "opcu", "copdc", " opf", " oplc", "optc", "copcu", " opcs"], "addr_regl": ["addr_reml", "addr_regb", "addr_regg", "addr_recnl", "addr_rec2", "addr_mem2", "addr_registerul", "addr_re2", "addr_regL", "addr_regsl", "addr_servs", "addr_reg", "addr_memul", "addr_regul", "addr_REGs", "addr_memb", "addr_rigb", "addr_REGb", "addr_registern", "addr_refl", "addr_reb", "addr_rems", "addr_memsl", "addr_rigl", "addr_rigsl", "addr_reL", "addr_recl", "addr_memc", "addr_REGl", "addr_regnl", "addr_ref2", "addr_REGsl", "addr_registerc", "addr_REGg", "addr_res", "addr_REG2", "addr_refs", "addr_reful", "addr_mems", "addr_memg", "addr_memnl", "addr_servnl", "addr_rem2", "addr_memL", "addr_refc", "addr_refn", "addr_serv2", "addr_regs", "addr_recg", "addr_rel", "addr_regn", "addr_regc", "addr_rig2", "addr_recs", "addr_servl", "addr_memn", "addr_refg", "addr_remL", "addr_registerl"], "addr_reg1": ["addr_greg5", "addr_recS", "addr_recl", "addr_loc0", "addr_register1", "addr_structn", "addr_locN", "addr_rec2", "addr_recr", "addr_regN", "addr_REGl", "addr_loc2", "addr_struct1", "addr_rec0", "addr_gregN", "addr_recn", "addr_structS", "addr_regr", "addr_struct2", "addr_loc1", "addr_reg0", "addr_reg5", "addr_regn", "addr_origl", "addr_REGr", "addr_REG2", "addr_register2", "addr_REG0", "addr_registern", "addr_registerS", "addr_rec1", "addr_orig5", "addr_origN", "addr_greg2", "addr_orig1", "addr_loc5", "addr_greg1", "addr_gregr", "addr_REG1", "addr_regS", "addr_locl", "addr_gregl"], "addr_meml": ["addr_morphll", "addr_regb", "addr_reml", "addr_threadll", "addr_REGlc", "addr_liml", "addr_limel", "addr_lamel", "addr_servs", "addr_regd", "addr_morphkl", "addr_limb", "addr_regkl", "addr_regel", "addr_regli", "addr_reglc", "addr_regp", "addr_ramh", "addr_servlc", "addr_memkl", "addr_remb", "addr_memll", "addr_threadl", "addr_memp", "addr_REGs", "addr_memb", "addr_memd", "addr_limh", "addr_memlc", "addr_threadp", "addr_memli", "addr_memc", "addr_REGl", "addr_morphp", "addr_raml", "addr_threadkl", "addr_regll", "addr_limc", "addr_lamb", "addr_ramc", "addr_mems", "addr_memel", "addr_remc", "addr_limd", "addr_REGli", "addr_remh", "addr_servli", "addr_morphl", "addr_regs", "addr_ramb", "addr_servl", "addr_lamd", "addr_laml"], "data_regl": ["data_recL", "data_mems", "data_regs", "data_recr", "data_structs", "data_REGs", "data_corel", "data_reglate", "data_resd", "data_REGl", "data_racs", "data_regdl", "data_rets", "data_REGlate", "data_racli", "data_retn", "data_retli", "data_recn", "data_rec2", "data_regli", "data_mem2", "data_regr", "data_memr", "data_structL", "data_structl", "data_racl", "data_recdl", "data_coreli", "data_meml", "data_racn", "data_ress", "data_core2", "data_rac2", "data_corelate", "data_recd", "data_REGli", "data_memL", "data_recli", "data_resl", "data_memdl", "data_res2", "data_recl", "data_REG2", "data_retl", "data_REGd", "data_raclate", "data_regL", "data_regd", "data_structdl", "data_regn", "data_structr", "data_recs", "data_struct2"], "data_regh": ["data_rehl", "data_rugh", "data_resh", "data_rebhl", "data_gregh", "data_rego", "data_pregg", "data_refigh", "data_rugg", "data_reghl", "data_reh", "data_rengh", "data_ruh", "data_regg", "data_pregh", "data_rebgg", "data_pregin", "data_resgg", "data_recgin", "data_reck", "data_rengg", "data_gregg", "data_reggin", "data_rengin", "data_reigh", "data_recigh", "data_regin", "data_refgin", "data_recgh", "data_greigh", "data_resgin", "data_rebgh", "data_rugin", "data_resgh", "data_cregin", "data_rechl", "data_gregin", "data_prego", "data_refgo", "data_greh", "data_recgg", "data_cregg", "data_greck", "data_reggh", "data_cregh", "data_preck", "data_refgh", "data_reggg", "data_preigh", "data_creigh", "data_rebgin", "data_renck", "data_recgo"], "data_reg1": ["data_recl", "data_rel", "data_logl", "data_regone", "data_REGb", "data_REG2", "data_recb", "data_regb", "data_REG6", "data_tag2", "data_rec6", "data_register01", "data_mod2", "data_rec2", "data_tagone", "data_register2", "data_REG1", "data_modl", "data_reg81", "data_rule1", "data_log81", "data_tag1", "data_REGl", "data_re81", "data_rec1", "data_log2", "data_rec01", "data_registerone", "data_mod1", "data_modb", "data_rulel", "data_recone", "data_re2", "data_reg6", "data_rule2", "data_log1", "data_reg01", "data_re1", "data_rec81", "data_rule6", "data_register1", "data_tag01"], "data_reg2": ["data_grl", "data_recl", "data_recL", "data_rel", "data_reg62", "data_REGb", "data_REG2", "data_recb", "data_regb", "data_meml", "data_re62", "data_registerL", "data_REGL", "data_gregu", "data_recu", "data_modu", "data_rec2", "data_mod2", "data_register2", "data_mem2", "data_REG1", "data_regL", "data_modl", "data_mem1", "data_reg0", "data_register0", "data_gregl", "data_regu", "data_gr2", "data_greg1", "data_REGl", "data_rec1", "data_memb", "data_mod1", "data_greg2", "data_re2", "data_re1", "data_rec0", "data_REG0", "data_register1", "data_rec62", "data_gr1", "data_gr62"], "mem_index": ["byte_len", "alloc_ind", "mem_list", "memacindex", "mem_count", "byte_index", "mem_len", "byteaclist", "byteacindex", "memrindex", "memfindex", "byteaclength", "memrcount", "mem__index", "allocfind", "memrind", "memfcount", "allocfcount", "byteaclen", "alloc_count", "allocfindex", "mem_length", "byte_length", "memaclength", "mem__length", "memfind", "alloc_index", "mem_ind", "mem__len", "mem__list", "memaclen", "memaclist", "byte_list"], "s_bits": ["s_parts", "s__bits", "p_bits", "d_bytes", "s__parts", "p_locks", "s_bytes", "s__ops", "s_bit", "s__bytes", "s__locks", "s_locks", "d_ops", "p_bytes", "d_bits", "p_bit", "s_ops", "s__bit", "d_parts"], "label1_ptr": ["label1_pointer", "label2_tr", "label2_dr", "label2_pointer", "label1_dr", "label1_tr"], "label2_ptr": ["label2_tr", "label2_dr", "label02_ptr", "label02_dr", "label02_pointer", "label02_tr", "label2_pointer"], "sp_args": ["sp2args", " sp_arg", " sp_len", "sp_lang", " sp2arg", " sp2lang", " sp2len", " sp_lang", " sp2args", "sp__args", "sp__len", "sp_arg", "sp_len", "sp2lang", "sp__lang", "sp2arg", "sp__arg", "sp2len"], "label3_ptr": ["label1_pointer", "label3_inter", "label3_pointer", "label1_inter", "label3_tr", "label1_tr"], "addr_regh": ["addr_recgo", "addr_pregh", "addr_regg", "addr_pregg", "addr_mergh", "addr_mergg", "addr_reggo", "addr_merhs", "addr_reggh", "addr_preg", "addr_cachegh", "addr_synga", "addr_regy", "addr_prego", "addr_prehs", "addr_regin", "addr_rego", "addr_recgg", "addr_preq", "addr_cachega", "addr_resgh", "addr_reshs", "addr_syngg", "addr_reggin", "addr_recg", "addr_recgin", "addr_cachegg", "addr_merq", "addr_reg", "addr_rega", "addr_resgg", "addr_syngh", "addr_regga", "addr_syngy", "addr_reggy", "addr_resq", "addr_recgh", "addr_req", "addr_cachegy", "addr_pregin", "addr_reggg", "addr_rehs"], "addr_reg2": ["addr_res2", "addr_block2", "addrPrg2", "addr_blockall", "addrPrg8", "addr_recl", "addr_REG22", "addr_greg22", "addr_recall", "addr_reg8", "addrPrg1", "addr_rec2", "addr_REGl", "addr_rg2", "addr_res62", "addr_regsl", "addr_orig2", "addr_regall", "addr_res1", "addrPrg62", "addr_blocksl", "addr_origl", "addr_REG2", "addr_origsl", "addr_rg1", "addrPreg1", "addr_res8", "addr_recsl", "addr_rec22", "addr_rec1", "addrPreg2", "addr_rec8", "addr_rg8", "addr_origall", "addr_rg62", "addr_greg2", "addr_blockl", "addr_greg1", "addr_rec62", "addr_reg22", "addrPreg8", "addr_REG1", "addr_reg62", "addrPreg62", "addr_gregl"], "addr_memh": ["addr_moph", "addr_graml", "addr_liml", "addr_limel", "addr_reth", "addr_regr", "addr_gramul", "addr_memle", "addr_raml", "addr_reten", "addr_memb", "addr_ramh", "addr_mopr", "addr_limr", "addr_memul", "addr_regul", "addr_ramen", "addr_gramle", "addr_ramb", "addr_limh", "addr_memen", "addr_mopl", "addr_retl", "addr_mopel", "addr_regel", "addr_regle", "addr_memr", "addr_retb", "addr_gramh", "addr_memel"]}}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGLabel *lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                TCGLabel *lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_ctzi_tl(cpu_R[rd], cpu_R[ra], -1);\n\n            tcg_gen_addi_tl(cpu_R[rd], cpu_R[rd], 1);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_clzi_tl(cpu_R[rd], cpu_R[ra], TARGET_LONG_BITS);\n\n            tcg_gen_subfi_tl(cpu_R[rd], TARGET_LONG_BITS, cpu_R[rd]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 16360, "substitutes": {"dc": ["cd", "cdn", "pc", "uc", "bc", "nc", "ac", "dm", "DC", "enc", "oci", "isc", "irc", "lc", "oc", "jc", "cc", "da", "cam", "tc", "ct", "rc", "mc", "xc", "sc", "fc", "icc"], "insn": ["lsb", "insp", "lsn", "issb", "insconn", "linsnt", "atsnt", "insc", "insnan", "itsn", " insne", "atsd", "inne", "inc", "linsd", "incn", "inconn", "inssn", "incconn", "linnt", "lsconn", "linssn", "inl", "insl", " inssn", "issn", "incc", "itsne", "exn", "exsn", "insne", "issne", "issc", "atsn", "ksc", "linn", "insd", "exc", "lsne", "intsp", "inp", "intsne", "itsb", "intsl", "ind", "insnt", "linsn", "exnan", "incb", "innan", "ksne", " insp", " insnan", " insc", "ksnt", "atssn", "ksn", "intsn", "issnt", "insb", "linc", "inn", " insl", "innt", "inb", "linb", "lsc", "itsc"], "op0": ["oper6", "opt2", "opt3", "hop6", "OP2", " op4", " op6", "op4", "opt1", "OP0", "hop2", "oper0", "OP1", "op6", "opt0", "OP3", "hop0", "oper4", "op3", " op3", "oper2", "hop4"], "op1": ["hop1", "opt3", "opt2", "cop1", "OP2", " op4", " op01", "oper01", "OP01", "cop01", "oper3", "op4", "hop01", "opt1", "opt01", "hop2", "cop3", "cop4", "OP1", "OP3", "op01", "oper1", "cop2", "op3", " op3", "oper2", "hop4"], "op2": ["cop1", "OP2", " op4", "oper32", "OP4", "op4", "hop2", "cop3", "cop4", "oper0", "OP1", " op32", "OP3", "op32", "hop32", "cop2", "hop0", "oper4", "op3", " op3", "oper2", "hop4"], "ra": ["ara", "ru", "min", "alpha", "rr", "ri", "dra", "sa", "ina", "ro", "rs", "na", "po", "ta", "sr", "rar", "ran", "ka", "gra", "tar", "Ra", "r", "va", "ar", "pa", "ma", "ia", "ba", "ca", "stra", "da", "au", "ada", "cr", "up", "rg", "RA", "rap", "la", "tra", "rc", "ira", "area", "from", "a", "wa", "rad", "ria", "rt", "ras", "oa"], "rb": ["ru", "rr", "raf", "ri", "ruby", "rs", "rm", "erb", "RB", "rar", "rh", "sr", "wb", "rid", "lr", "rob", "db", "rab", "r", "pb", "rt", "rx", "adr", "usr", "sb", "rl", "nr", "rf", "b", "cr", "rg", "reb", "vr", "rc", "cb", "ab", "gb", "bf", "rn", "ril", "lb", "rw", "fb"], "rd": ["dr", "ru", "rr", "RF", "ri", "dra", "rw", "rs", "dd", "td", "rm", "lr", "sr", "rar", "rid", "rod", "rh", "d", "fd", "rob", "r", "adr", "rx", "rss", "ld", "rl", "nr", "rf", "cr", "rera", "rg", "vr", "rc", "rn", "RR", "rt", "RD", "ras"], "lab": ["local", "AB", "node", "cel", "lam", "td", "reg", "lf", "cz", "col", "obj", "train", "lib", "tab", "pub", "pl", "label", "leg", "pb", "Lab", "ob", "db", "ls", "eb", "ctx", "lc", "lang", "cell", "loc", "ca", "ref", "line", "ld", "inf", "LAB", "abc", "Label", "las", "home", "msg", "la", "nb", "cb", "ab", "gb", "fe", "lit", "sc", "lb", "bg", "bl", "fb"]}}
{"project": "qemu", "commit_id": "225d02cd1a34d5d87e8acefbf8e244a5d12f5f8c", "target": 1, "func": "int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n", "idx": 16365, "substitutes": {"timeout": ["server", "number", "this", "clock", "length", "command", "type", "cache", "global", "temp", "ticket", "window", "timer", "latest", "error", "buffer", "fee", "connection", "root", "fail", "sleep", "interrupted", "max", "duration", "init", "money", "span", "trial", "call", "always", "time", "slot", "sync", "limit", "unit", "service", "period", "delay", "try", "null", "wait", "scroll", "socket", "missing", "append", "tc", "value", "vm", "Timeout", "count", "cookie", "start", "port", "io", "outer", "event", "out", "size", "offset"], "add": ["Add", "set", "skip", "and", "number", "extra", "inc", "name", "ac", "ix", "mod", "dd", "enable", "new", "ADD", "pad", "ad", "end", "load", "d", "base", "sleep", "id", "parse", "address", "change", "build", "max", "ctl", "addr", "diff", "data", "added", "call", "next", "post", "cost", "depth", "delay", "append", "apply", "wait", "create", "event", "update", "send", "count", "num", "start", "plus", "push", "date", "sync"], "delta": ["Dota", "zelta", " dadd", " dition", "aday", "dyota", "ddelt", "zelt", "delt", "ddelta", "ddta", "adelt", "rdta", "sdelt", " dada", "adota", "ddDelta", "dota", "dition", "rdelta", "zta", "dDelta", "Delta", "sdota", "ddition", "dada", "rdadd", " dta", "zota", " day", "Delt", "detime", "adelta", "cdta", " dota", "ddetime", " detime", "cdelt", "DDelta", "sdDelta", "cdelta", "adta", "cdada", "dadd", " delt", "adada", "rdelt", "dyelta", "dyition", "ddota", "day", "dta", "dyetime", "sday", "ddadd", "cdota", "sdelta"]}}
{"project": "FFmpeg", "commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "target": 1, "func": "static int ftp_abort(URLContext *h)\n\n{\n\n    static const char *command = \"ABOR\\r\\n\";\n\n    int err;\n\n    static const int abor_codes[] = {225, 226, 0};\n\n    FTPContext *s = h->priv_data;\n\n\n\n    /* According to RCF 959:\n\n       \"ABOR command tells the server to abort the previous FTP\n\n       service command and any associated transfer of data.\"\n\n\n\n       There are FTP server implementations that don't response\n\n       to any commands during data transfer in passive mode (including ABOR).\n\n\n\n       This implementation closes data connection by force.\n\n    */\n\n\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n\n        ftp_close_both_connections(s);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    } else {\n\n        ftp_close_data_connection(s);\n\n    }\n\n\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n\n        /* wu-ftpd also closes control connection after data connection closing */\n\n        ffurl_closep(&s->conn_control);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16370, "substitutes": {"h": ["ssh", "g", "dh", "f", "http", "hi", "u", "oh", "sh", "bh", "eh", "t", "kh", "uh", "rh", "d", "H", "ch", "hw", "id", "hes", "cl", "auth", "r", "th", "hl", "hr", "w", "him", "c", "head", "k", "p", "ha", "hand", "he", "hp", "gh", "b", "ih", "z", "hh", "hd", "e", "ph", "l", "hs", "history", "ah", "hm", "ht", "v", "host", "m"], "command": ["resource", "sequence", "timeout", "operation", "database", "cmd", "Command", "name", "new", "prefix", "document", "error", "exec", "connection", "execute", "message", "sudo", "code", "input", "data", "raw", "which", "communication", "c", "response", "service", "function", "content", "comment", "three", "send", "handler", "zero", "query", "password", "a", "method", "attribute"], "err": ["dr", "str", "oller", "rr", "better", "erg", "result", "Er", " error", "runner", "temp", "off", "orig", "error", "req", "cor", "rh", "rar", "ir", " er", "magic", "message", "root", "wr", "ise", "ner", "dev", "user", "found", "ar", "r", "act", "rag", "der", "doc", "errors", "hr", "orer", "call", "iter", "all", " Err", "var", "key", "owner", "mr", "nr", "far", "resp", "er", "msg", "actor", "nor", "Error", "handler", "cb", "attr", "rage", "ev", "e", "erer", "acer", "ler", "bug", "arr", "ie", "ah", "order", "orr", "ver", "br"], "abor_codes": ["aborrorcount", "abor_count", "abor_odes", " arbitration_codes", "abor_code", "oper_codes", "abor_coded", "oper_sets", "abor_sets", "aborrorcodes", " arbitration_code", "oper_code", "aborrorcode", "aborrorsets", "oper_count", " arbitration_coded", " arbitration_odes"], "s": ["is", "g", "ssh", "cs", "server", "f", "sys", "sa", "session", "http", "ps", "ops", "cli", "x", "u", "rs", "js", "sh", "t", "ss", "sq", "sw", "d", "ns", "n", "si", "args", "ch", "cpp", "hes", "storage", "r", "data", "ls", "es", "o", "ctx", "us", "gs", "shared", "c", "p", "sb", "ks", "service", "ssl", "b", "sl", "xs", "S", "sg", "ses", "e", "os", "l", "settings", "hs", "a", "sc", "se", "ds", "qs", "an", "sync", "m"]}}
{"project": "FFmpeg", "commit_id": "a4fec9a7eab842ea5eea1b1ee98624356cb31422", "target": 1, "func": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n    written++;\n    channel_id = hdr & 0x3F;\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       return AVERROR(EAGAIN);\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;", "idx": 16385, "substitutes": {"h": ["g", "FH", "f", "http", "uc", "u", "oh", "sh", "t", "q", "eh", "bh", "uh", "rh", "d", "hum", "H", "ch", "hw", "auth", "r", "img", "hl", "hr", "w", "c", "head", "ha", "hp", "b", "gh", "ih", "hh", "context", "e", "ph", "hs", "history", "ah", "hm", "ht", "host", "m"], "p": ["cp", "f", "ap", "pt", "pc", "tp", "u", "t", "q", "d", "n", "pi", "i", "pl", "r", "w", "c", "P", "fp", "hp", "b", "e", "ph", "port", "v", "j", "m"], "chunk_size": ["chblock_capacity", "chunk4capacity", "chunk4size", "chunk_ize", "chunk4small", "chunk_small", "chblock_ize", "chunk4ize", "chblock_size", "chblock_small", "chunk_capacity"], "prev_pkt_ptr": ["prev_pkt_pointer", "prev_pkt_tr", "prev_packet_loc", "prev_packet_addr", "prev_pkt_addr", "prev_packet_tr", "prev_pkt_ref", "prev_packet_ref", "prev_pkt_loc", "prev_packet_ptr", "prev_pkt5ptr", "prev_packet_handle", "prev_packet_pointer", "prev_pkt5ref", "prev_pkt_handle", "prev_pkt5pointer", "prev_pkt5handle"], "nb_prev_pkt": ["nb_prev_pk", "nb_prev_ipk", "nb_prev_mkt", "nb_prev_ipacket", "nb_prev_mct", "nb_prev_Packet", "nb_prev_macket", "nb_prev_pck", "nb_prev_Pck", "nb_prev_Ptch", "nb_prev_Pk", "nb_prev_ipkt", "nb_prev_ipck", "nb_prev_petch", "nb_prev_mk", "nb_prev_ptch", "nb_prev_pekt", "nb_prev_Pct", "nb_prev_Pkt", "nb_prev_mck", "nb_prev_peacket", "nb_prev_mtch", "nb_prev_pect", "nb_prev_pct", "nb_prev_packet"], "hdr": ["shr", "phrt", "shrid", "third", "hhr", "shhr", "hhrc", "shdi", "Hdr", "ohdr", "bhDR", "thDR", "bhhr", " hdi", "hrid", "ohheader", "hhdr", " hheader", "shDR", "hdi", "chvr", "chrid", " hr", "chDR", "HDR", "hvr", "Hrid", "ohDR", " hhr", "hird", "hheader", "chdr", "Hdi", "hr", "bhr", "bhheader", "Hrt", " hird", "thdr", "hrt", "thrt", "bhdr", "hhheader", "hDR", "phDR", "Hvr", " hDR", "bhrc", "phheader", "phdr", "hrc", "ohrt", "shvr", " hrt", "Hird", "hhDR", " hrc", "shdr"], "buf": ["batch", "uf", "proc", "bh", "pool", "comb", "fd", "pub", "code", "pb", "begin", "r", "block", "cf", "c", "ha", "b", "done", "context", "prop", "ab", "gb", "opt", "box", "br", "ru", "queue", "pad", "img", "data", "usr", "cas", "fp", "bed", "desc", "home", "msg", "port", "fab", "bin", "cp", "f", "src", "uc", "cmd", "bc", "buffer", "conv", "config", "ctx", "cap", "rb", "bag", "func", "cb", "rc", "bu", "Buff", "header", "vec", "txt", "bd", "feat", "cur", "uh", "wb", "ba", "loc", "loop", "cv", "tmp", "seq", "bf", "mem", "cmp", "buff", "ctr", "fb"], "channel_id": ["channel2id", " channel_number", "channel_ids", "channelOident", "channel_uid", "Channel_ids", "channel33kid", "channelPids", "channel_path", "error_head", "channel_size", "channel_kid", "channelinguid", "channel2size", " channel_path", " channel_ids", "channelOhead", "channelinglike", " channel_info", "error_ID", "channelingids", "channel_type", "channel_base", "channelPident", "error_ident", "channel2info", " channel_kid", "channelingid", " channel_name", "channelxnumber", "channel2ids", "channel_side", "channelingpath", "Channel_ident", "channelOid", "channel_Id", "channel_ident", "channelxid", " channel_Id", "error_id", " channel_size", "channelingbase", " channel_like", "channel_head", "channel_info", " channel_type", "channel_number", "channel_name", "channel33number", "channel_like", "channelxkid", "channelPid", " channel_base", "channel33ids", " channel_ID", " channel_uid", " channel_side", "channel33id", "channelOID", "channelxids", "channel_ID", "Channel_id"], "timestamp": ["typetime", "typestamp", "timeest", "timeeless", "typeless", "typest", "timest", "timeless", "imestamp", "imest", "timeetime", "imetime", "timeestamp", "timetime", "imeless"], "size": ["scale", "made", "timeout", "length", "large", "extra", "sent", "name", "complete", "sized", "grade", "form", "fee", "Size", "len", "message", "version", "SIZE", "small", "si", "ize", "capacity", "storage", "speed", "max", "address", "code", "external", "data", "sum", "write", "loc", "body", "time", "sync", "channel", "unit", "content", "needed", "esc", "weight", "bytes", "count", "sec", "exclusive", "shape", "empty", "confirmed", "offset"], "ts_field": ["ps2field", "tsmatspec", "ts2field", "ts_FIELD", "ts_num", "ps_len", "strings_tag", "tx_num", "ks_bit", "ts_len", "tsxbit", "ps2layer", "ks_field", "ts_layer", "tx_level", "tsmatapi", "strings_field", "tsxfield", "tsmatfield", "ts__bit", "ts_group", "ps_layer", "ps_field", "tx_field", "tx_group", "ts2flag", "tsuufield", "ts_api", "ts_level", "tspnum", "ks_level", "ts2layer", "tsxlevel", "ps_flag", "tsggroup", "tsuuspec", "ts_spec", "strings_spec", "tsuutag", "ks_FIELD", "tsplevel", "ts__level", "tsxFIELD", "ps2flag", "ts_tag", "tspgroup", "tspfield", "tsuuapi", "tsgfield", "ts2len", "ts_bit", "ts__field", "strings_api", "ps2len", "tsglevel", "tsgnum", "ts_flag", "ts__FIELD", "tsmattag"], "type": ["val", "class", "scale", "ty", "resource", "family", "pretty", "length", "number", "option", "extra", "kind", "name", "style", "op", "x", "media", "Type", "t", "off", "error", "description", "no", "tag", "position", "version", "message", "id", "types", "offset", "state", "platform", "code", "r", "data", "block", "ping", "typ", "ype", "total", "time", "format", "P", "object", "file", "pos", "key", "unit", "pe", "related", "value", "action", "weight", "TYPE", "num", "count", "shape", "like", "other", "port", "event", "field", "title", "info"], "ret": ["RET", "reply", "val", "result", "match", "sent", "bc", "temp", "alt", "res", "success", "req", "back", "valid", "error", "no", "red", "len", "fun", "obj", "fail", " RET", "reset", "status", "code", "rx", "data", "rev", "rets", "att", "ext", "ref", "det", "nt", "def", "resp", "re", "value", "done", "en", "rc", "Ret", "bad", "arr", "lit", "out", "rt", "part", "failed"], "toread": ["toreads", "ltoreAD", "turead", "tuready", "ltareads", "toreAD", "ltaread", "ltoread", "tureAD", "tourady", "tareAD", "taready", "ltoready", "ltoreads", "tourAD", "tureads", "tareads", "taread", "tourads", "ltaready", "ltareAD", "tourad", "toready"], "prev_pkt": ["prev_punch", "prev_opacket", "prev_copaint", "prev_ipdu", "prev_opiece", "prev_pmt", "prev_racket", "prev_compacker", "prev_pet", "prev_npkt", "prev_wpaint", "prev_npce", "prev_Paint", "prev_Pmt", "prev_ipkt", "prev_chmt", "prev_wpkt", "prev_compacket", "prev_Piece", "prev_chkt", "prev_Packer", "prev_packer", "prev_reth", "prev_cpkt", "prev_chdu", "prev_wpinch", "prev_fpett", "prev_ipmt", "prev_compkt", "prev_fpkt", "prev_pakt", "prev_copacket", "prev_wpett", "prev_cpett", "prev_paint", "prev_fpeth", "prev_Packet", "prev_wpacket", "prev_copunt", "prev_copkt", "prev_opunch", "prev_pce", "prev_rett", "prev_piece", "prev_peth", "prev_opkt", "prev_Pkt", "prev_compce", "prev_wpunt", "prev_paet", "prev_cpiece", "prev_Punt", "prev_Pce", "prev_pett", "prev_punt", "prev_Pett", "prev_Pdu", "prev_ipacket", "prev_paett", "prev_npacker", "prev_rkt", "prev_Punch", "prev_Peth", "prev_npacket", "prev_cpacket", "prev_pinch", "prev_chacket", "prev_fpacket", "prev_cpunch", "prev_cpinch", "prev_cpet", "prev_packet", "prev_painch", "prev_wpet", "prev_pdu"], "written": ["started", "created", "numbered", "made", "after", "output", "seen", "loaded", "ritten", "sent", "nc", "temp", "net", "sized", "aligned", "writing", "connection", "won", "len", "fd", "generated", "memory", "writers", "wrote", "protected", "used", "byte", "writer", "added", "write", "w", "read", "wn", "broken", "ref", "wed", "unit", "needed", "locked", "printed", "wait", "current", "ended", "done", "weight", "worked", "connected", "updated", "Written", "checked", "wa", "finished", "writ", "called", "rawn"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "void eeprom93xx_write(eeprom_t *eeprom, int eecs, int eesk, int eedi)\n\n{\n\n    uint8_t tick = eeprom->tick;\n\n    uint8_t eedo = eeprom->eedo;\n\n    uint16_t address = eeprom->address;\n\n    uint8_t command = eeprom->command;\n\n\n\n    logout(\"CS=%u SK=%u DI=%u DO=%u, tick = %u\\n\",\n\n           eecs, eesk, eedi, eedo, tick);\n\n\n\n    if (! eeprom->eecs && eecs) {\n\n        /* Start chip select cycle. */\n\n        logout(\"Cycle start, waiting for 1st start bit (0)\\n\");\n\n        tick = 0;\n\n        command = 0x0;\n\n        address = 0x0;\n\n    } else if (eeprom->eecs && ! eecs) {\n\n        /* End chip select cycle. This triggers write / erase. */\n\n        if (eeprom->writable) {\n\n            uint8_t subcommand = address >> (eeprom->addrbits - 2);\n\n            if (command == 0 && subcommand == 2) {\n\n                /* Erase all. */\n\n                for (address = 0; address < eeprom->size; address++) {\n\n                    eeprom->contents[address] = 0xffff;\n\n                }\n\n            } else if (command == 3) {\n\n                /* Erase word. */\n\n                eeprom->contents[address] = 0xffff;\n\n            } else if (tick >= 2 + 2 + eeprom->addrbits + 16) {\n\n                if (command == 1) {\n\n                    /* Write word. */\n\n                    eeprom->contents[address] &= eeprom->data;\n\n                } else if (command == 0 && subcommand == 1) {\n\n                    /* Write all. */\n\n                    for (address = 0; address < eeprom->size; address++) {\n\n                        eeprom->contents[address] &= eeprom->data;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        /* Output DO is tristate, read results in 1. */\n\n        eedo = 1;\n\n    } else if (eecs && ! eeprom->eesk && eesk) {\n\n        /* Raising edge of clock shifts data in. */\n\n        if (tick == 0) {\n\n            /* Wait for 1st start bit. */\n\n            if (eedi == 0) {\n\n                logout(\"Got correct 1st start bit, waiting for 2nd start bit (1)\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"wrong 1st start bit (is 1, should be 0)\\n\");\n\n                tick = 2;\n\n                //~ assert(!\"wrong start bit\");\n\n            }\n\n        } else if (tick == 1) {\n\n            /* Wait for 2nd start bit. */\n\n            if (eedi != 0) {\n\n                logout(\"Got correct 2nd start bit, getting command + address\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"1st start bit is longer than needed\\n\");\n\n            }\n\n        } else if (tick < 2 + 2) {\n\n            /* Got 2 start bits, transfer 2 opcode bits. */\n\n            tick++;\n\n            command <<= 1;\n\n            if (eedi) {\n\n                command += 1;\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits) {\n\n            /* Got 2 start bits and 2 opcode bits, transfer all address bits. */\n\n            tick++;\n\n            address = ((address << 1) | eedi);\n\n            if (tick == 2 + 2 + eeprom->addrbits) {\n\n                logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\",\n\n                       opstring[command], address, eeprom->contents[address]);\n\n                if (command == 2) {\n\n                    eedo = 0;\n\n                }\n\n                address = address % eeprom->size;\n\n                if (command == 0) {\n\n                    /* Command code in upper 2 bits of address. */\n\n                    switch (address >> (eeprom->addrbits - 2)) {\n\n                        case 0:\n\n                            logout(\"write disable command\\n\");\n\n                            eeprom->writable = 0;\n\n                            break;\n\n                        case 1:\n\n                            logout(\"write all command\\n\");\n\n                            break;\n\n                        case 2:\n\n                            logout(\"erase all command\\n\");\n\n                            break;\n\n                        case 3:\n\n                            logout(\"write enable command\\n\");\n\n                            eeprom->writable = 1;\n\n                            break;\n\n                    }\n\n                } else {\n\n                    /* Read, write or erase word. */\n\n                    eeprom->data = eeprom->contents[address];\n\n                }\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {\n\n            /* Transfer 16 data bits. */\n\n            tick++;\n\n            if (command == 2) {\n\n                /* Read word. */\n\n                eedo = ((eeprom->data & 0x8000) != 0);\n\n            }\n\n            eeprom->data <<= 1;\n\n            eeprom->data += eedi;\n\n        } else {\n\n            logout(\"additional unneeded tick, not processed\\n\");\n\n        }\n\n    }\n\n    /* Save status of EEPROM. */\n\n    eeprom->tick = tick;\n\n    eeprom->eecs = eecs;\n\n    eeprom->eesk = eesk;\n\n    eeprom->eedo = eedo;\n\n    eeprom->address = address;\n\n    eeprom->command = command;\n\n}\n", "idx": 16406, "substitutes": {"eeprom": ["seeprm", "jeeprom", "eekroy", "eecrome", "eyproy", "seyprom", "eebrum", "aeepro", "jeepro", "eamproy", "aeypro", "eEPrim", "teecrec", "euprum", "eyprome", "eekron", "semprom", "eeproc", "eefrom", "eeprome", "eeeproy", "epprost", "peepro", "eeprec", "aeyproc", "epprim", "eekroc", "eephrome", "sempram", "peprom", "seepchrom", "pepprm", "eupprome", "seypron", "eyprob", "eekroman", "weypro", "peppdem", "peppram", "eephron", "eepro", "epprom", "eephrom", "teecrome", "eepchrom", "eeeprum", "eefrim", "euprom", "eefroc", "eypdem", "eepsron", "eekrm", "seepdem", "pecrom", "euproy", "eyprom", "eecrim", "seypro", "eEProm", "eiprim", "eefram", "eppram", "aeyprim", "eepprom", "eepram", "zeekrm", "empram", "eyprec", "peefram", "eipram", "pepro", "eegrost", "eepprum", "eyproman", "zeepro", "eypron", "eeeprm", "seeproc", "eeprum", "zeeprm", "eyproc", "eecrob", "eecrom", "eecrec", "eekro", "epproy", "eecrm", "aeecrom", "eepsrec", "eupprum", "zeeproy", "emprim", "peepdem", "seyprob", "zeekrum", "eupro", "eecro", "teeprec", "eepsroy", "aeypron", "seepram", "eEProc", "eamprom", "zeekrome", "aeeproc", "pecro", "peefrom", "peproy", "eepsrom", "eefrm", "aeeprum", "zeepsron", "eekram", "eepsrost", "jeeprum", "eeeprost", "peefrim", "epprum", "seeprob", "eecchrom", "peeprom", "aeeprm", "eyprm", "eeeproc", "aeeprec", "pecrum", "eepsroc", "eeepram", "weeprom", "zeeprome", "eebrome", "eepprm", "zeekro", "eepprost", "emprum", "eepproy", "aeeprom", "peepram", "eeprost", "eupprec", "weeprum", "peefrm", "eepdem", "aeyprec", "weeprob", "eecrum", "eepsrob", "zeeprom", "eekrome", "zeeprum", "eeeprim", "zeekron", "eiprom", "zeepram", "eefrum", "eyprum", "eiprm", "eegroy", "aeecchrom", "eebron", "eepsrum", "weepro", "eecroman", "weyprom", "emprom", "eegrom", "pepprom", "peprum", "zeepsroy", "eekrob", "jeecrom", "sempchrom", "teecrum", "seepro", "teeprom", "eekrum", "aeepchrom", "seiprom", "eppdem", "eeppram", "empchrom", "eekrom", "seepron", "pecroy", "eamprome", "epprm", "eepsrim", "eefchrom", "eeproman", "eeproy", "empro", "eepprim", "eupprom", "seeprom", "peeprim", "teecrom", "eipdem", "teeprum", "teeprome", "eepsro", "aeyprom", "eepron", "jeecro", "emprm", "aeecrum", "jeeproman", "eebrom", "zeepsrom", "aeepron", "zeekrom", "eepsrome", "jeecroman", "eecram", "eppchrom", "eefro", "epproc", "semprm", "seiprm", "eyprim", "aeeprim", "eecroy", "eeprob", "eepproc", "eiproc", "eeprm", "seipdem", "jeecrum", "eephrum", "peeprm", "eegrim", "eipro", "eypram", "zeepsrome", "seipram", "zeepron", "peefro", "eeprim", "eampron", "zeekram", "weyprum", "eeeprom", "weyprob", "aeecrm", "eypro", "eecron", "eEPro", "seiproc"], "eecs": ["peepns", "eectns", "eECsb", "eecds", "eecrs", "eekrates", "eepgroups", "peecns", "eeps", "ceecgs", "peepd", "beecgroups", "eveecrs", "eepd", "peepsym", "peeco", "eecses", "beectn", "ceks", "eefls", "eefrs", "ceecrs", "beecsync", "eecsync", "cecls", "eveekds", "eECses", "ceccs", "eecrates", "peecd", "eekf", "eefo", "eegls", " eecrs", " eecses", "eercrates", "eepls", "eercds", "ereamd", "eECs", " eeks", "ereamn", "ceekrs", "beecn", "eveecs", "eemptls", "eveekrates", "cekls", "eects", "eecd", "beectgroups", "eekgs", "peecsym", "eveekrs", "eectgroups", "eectn", "beectsync", " eekrs", "beecs", "eefds", "eeco", " eeksb", "peepgroups", "peeps", "eercgroups", "eevs", "ceekgs", "eeccs", "eercs", "peecgroups", "eevf", "eepn", "cekcs", "beects", "eekds", "eeks", "eecf", "ceecd", "eectrs", "eecn", "eveeks", "eemptcs", "eevcs", "peepls", "eectgs", "eempts", "eeksb", "eercrs", "eercd", "eegs", "eekses", "eepsync", "ceekd", "eectsync", "eefsym", "ereamsync", " eekses", "eecns", "eecls", "eekls", "eefsb", "eecsb", "eepns", "eectd", "ereams", "eekcs", "eekrs", "peepo", "eepo", "eegsym", "eecgs", "eekd", "eecgroups", "eevls", "cecs", "ereamgroups", "eveecds", "ereamrs", "ceeks", "eefrates", "cekf", "eefs", "eego", "eecsym", " eecsb", "eercns", "eveecrates", "eefses", "eepsym", "cecf", "eECrs", "peecs", "peecls", "eemptf", "ereamgs", "ceecs"], "eesk": ["ipsok", "esky", "ipsks", "esks", "ipesK", "eedsok", "elsky", "eskw", "ipeskin", "esok", "elsk", "eeskin", "eesok", "lesky", "eedsks", "lesK", "apesks", "apeskin", "eedskw", "eeskw", "lesks", "ipesks", "lesk", "ipsk", "eedsky", "eedsk", "elsks", "ipesky", "eesks", "eedsK", "apesk", "ipsK", "elskw", "esK", "eesK", "eesky", "ipesk", "eskin", "apesky", "esk"], "eedi": ["devio", "elli", "seedo", "eadiu", "ddu", "eedy", "eei", "ddo", "eediu", "efi", "eadi", "eeda", "seeda", "ddi", "eeoi", "eeo", "ello", "elloi", "eado", "expectedo", "eeio", "eeiu", "eea", "dda", "eeu", "devoi", "eqa", "devi", "eby", "seedio", "equ", "eqo", "eedo", "seedi", "eba", "efo", "ebo", "eedu", "elly", "seedy", "eee", "expectedi", "eey", "devo", "eedoi", "ebi", "expectedy", "efiu", "seedoi", "eqi", "efe", "eede", "eedio", "expectedoi", "eade"], "address": ["operator", "command", "argument", "page", "connection", "point", "position", "direction", "email", "code", "content", "enter", "socket", "comment", "package", "image", "context", "shape", "network", "order", "layer", "attribute", "mode", "server", "interface", "alpha", "name", "work", "instance", "uri", "add", "location", "message", "index", "duration", "addr", "program", "character", "object", "element", "url", "alias", "office", "date", "host", "offset", "length", "number", "route", "condition", "error", "ip", "module", "config", "pair", "id", "entry", "ace", "target", "channel", "pointer", "resource", "expression", "output", "operation", "type", "grade", "path", "align", "service", "activity", "Address", "edge", "request", "password", "reference", "device", "event", "size"], "tick": ["g", "batch", "progress", "scale", "command", "x", "axis", "window", "argument", "timer", "scope", "magic", "padding", "block", "byte", "trigger", "call", "repeat", "bang", "comment", "bytes", "charge", "shape", "task", "click", "theme", "check", "timeout", "clock", "tip", "pad", "hello", "index", "year", "kick", "s", "key", "month", "lock", "cycle", "cookie", "bug", "day", "push", "date", "sync", "ick", "sequence", "track", "token", "length", "this", "cmd", "style", "stick", "stuff", "error", "feed", "_", "module", "sleep", "config", "plot", "trial", "write", "reason", "height", "toggle", "delay", "scroll", "pointer", "nice", "step", "history", "shift", "type", "d", "tag", "pick", "hour", "hop", "ping", "loop", "all", "callback", "time", "patch", "nick", "slice", "pull", "start", "trace", "event", "paste"]}}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 16410, "substitutes": {"opaque": ["opca", "iopca", "opque", "opaco", "OPaque", " opca", "appaque", "opaques", "iopacity", "appacity", "oplaco", "oploc", "OPque", "opoc", "oplque", "opacity", "appaques", "operque", "OPaco", "oplaque", "iopaques", " opacity", "appca", " opaques", "operaque", "operoc", "iopaque", "OPoc", "operaco"], "iothread": ["uothscan", "iouthreader", "ioshwait", "atiothread", "icothwrite", "ioothread", "icoshsync", "iuthscan", "icoshread", "icothread", "ioenlock", "aoretsync", "aoretload", "ithwrite", "ioughwrite", "aothreader", "icoothwrite", "aophread", "uuthcheck", "icothloop", "xiothwrite", "ioshsync", "uothwrite", "icothwait", "uuthread", "iuthstart", "uuthwrite", "iithlock", "xiothstart", "iithread", "icothsync", "iometread", "xiothread", "iothcheck", "ioothwrite", "xiuthstart", "iothwrite", "ioothreads", "iophstart", "iophreader", "icoshloop", "xiothreader", "iuthrank", "iohmode", "ioretloop", "icoothreads", "iothlock", "iothstart", "iophreads", "iothwait", "ihedwrite", "uothreader", "iothrank", "iuthlock", "uothcheck", "iothscan", "ihedread", "iopterscan", "aoretwrite", "ithread", "ithreader", "iouthread", "iophwrite", "iithrank", "iothsync", "icothreader", "iophwait", "ioshreader", "iighthadd", "ioenrank", "ioretload", "iohwrite", "iometscan", "ioretsync", "uuthreader", "ioshcheck", "ioretwrite", "ioothreader", "iometreader", "ioretread", "iopterwrite", "atiithwrite", "iothmode", "iometsync", "atiothwrite", "atiithread", "iometwrite", "iothloop", "ioshloop", "iopterreader", "iothload", "icoshreader", "uothwait", "iuthload", "ithmode", "iophadd", "aophadd", "xiothmode", "aoretread", "ioughwait", "aothwrite", "ioretreader", "iuthsync", "iuthwait", "iouthsync", "ioshread", "iohreader", "icoothreader", "xiuthwrite", "atiothrank", "aothsync", "iuthmode", "atiithlock", "aothload", "iighthwrite", "iighthreader", "xiuthread", "iohread", "iopathstart", "ioshwrite", "ioenwrite", "ioughreader", "iouthloop", "iothreads", "iopathwait", "iopathread", "atiithrank", "iophread", "aophreader", "iothadd", "iuthcheck", "atiothlock", "iopathwrite", "ioughread", "iighthread", "uuthscan", "iopathcheck", "uothread", "iometload", "icoshwait", "xiuthmode", "icothreads", "ioenread", "aothadd", "iopterread", "icoshwrite", "xiuthreader", "iopathreader", "aothread", "iithwrite", "ihedreads", "icoothread", "iuthreader", "uuthwait", "iothreader", "iuthwrite", "iuthadd", "aophwrite", "iuthread", "ihedreader"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 16412, "substitutes": {"avctx": ["afctx", "AVcam", "afcca", "avcmp", "avcca", " avcontext", "avcontext", "audcontext", "AVcca", "AVctx", "afcam", "AVcmp", "AVcontext", "afcf", "avcf", "AVcf", "audcam", "avcam", "audctx", " avcf", "audcmp", " avcca", "afcmp", "afcontext"]}}
{"project": "qemu", "commit_id": "3c3e88a814ef4eb8b2f8bf81863baec24838d998", "target": 0, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n", "idx": 16415, "substitutes": {"obj": ["val", "src", "inst", "obb", "po", "api", "org", "boot", "j", "ut", "module", "lib", "oid", "ob", "code", "act", "emb", "img", "iv", "o", "ctx", "xxx", "ref", "orb", "object", "nt", "p", "pos", "tmp", "b", "Object", "objects", "bj", "fi", "ev", "os", "opt", "oi", "Obj", "host"], "v": ["g", "val", "client", "f", "uv", "vim", "x", "u", "t", "q", "api", "d", "conv", "n", "i", "iv", "o", "volt", "w", "c", "k", "object", "p", "s", "inv", "b", "z", "vm", "e", "l", "vv", "env", "V", "tv", "j", "m"], "name": ["NAME", "type", "x", "prefix", "no", "n", "base", "len", "memory", "word", "path", "label", "data", "space", "cap", "time", "nam", "object", "var", "key", "Name", "b", "null", "named", "image", "names", "attr", "filename", "alias", "a", "part", "size", "info"], "opaque": [" opacle", "iopec", "iopacle", "opacle", "opacs", "ospacle", "ospaque", "iopaque", "iopacs", "opec", " opec", "ospacs", "ospec", " opacs"], "errp": ["errpc", "errpi", "errP", "errorlp", " errr", "errorp", "rarp", "erP", "rrP", "rrpc", "rypi", "errorpi", "rrr", " errlp", "erp", "rrpi", "ryP", "rarlp", "rrp", "rarpc", "err", " errpc", "errorP", " errP", "errorpc", "rypc", "errr", "rarP", "errlp", "ryp"], "value": ["val", "VALUE", "scale", "min", "length", "number", "result", "large", "range", "type", "balance", "values", "array", "media", "flow", "fee", "member", "position", "message", "version", "memory", "id", "index", "va", "data", "addr", "feature", "write", "total", "format", "limit", "unit", "function", "image", "weight", "count", "element", "age", "area", "Value", "pr", "size", "offset"], "mr": ["dr", "shr", "rr", "LR", "yr", "gor", "rs", "igr", "mx", "kr", "rm", "wm", "lr", "sr", "rh", "wr", "ir", "pm", "mt", "bm", "ml", "r", "adr", "fr", "hr", "mor", "gr", "rb", "rd", "mer", "rl", "nr", "rf", "MR", "er", "rg", "mn", "m", "vr", "mir", "mc", "nm", "mm", "rt", "manager", "pr", "Mr", "br"], "dimm": [" dim", "dimp", " dimp", "Damm", "dim", "Dimp", " damm", "Digr", " dym", "sdim", "sdym", "Dym", "digr", " digr", "Dim", "sdimm", "sdimp", "Dimm", "dym", "damm"]}}
{"project": "qemu", "commit_id": "d0e7605ee0d91c3737052127a79199ddab3ff653", "target": 0, "func": "pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1)\n\n{\n\n    pflash_t *pfl;\n\n    int32_t chip_len;\n\n\n\n    chip_len = sector_len * nb_blocs;\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n    pfl = qemu_mallocz(sizeof(pflash_t));\n\n    /* FIXME: Allocate ram ourselves.  */\n\n    pfl->storage = qemu_get_ram_ptr(off);\n\n    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,\n\n                                         pfl);\n\n    pfl->off = off;\n\n    pfl->base = base;\n\n    pfl->chip_len = chip_len;\n\n    pfl->mappings = nb_mappings;\n\n    pflash_register_memory(pfl, 1);\n\n    pfl->bs = bs;\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);\n\n    }\n\n#if 0 /* XXX: there should be a bit to set up read-only,\n\n       *      the same way the hardware does (with WP pin).\n\n       */\n\n    pfl->ro = 1;\n\n#else\n\n    pfl->ro = 0;\n\n#endif\n\n    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);\n\n    pfl->sector_len = sector_len;\n\n    pfl->width = width;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    pfl->ident[0] = id0;\n\n    pfl->ident[1] = id1;\n\n    pfl->ident[2] = id2;\n\n    pfl->ident[3] = id3;\n\n    pfl->unlock_addr[0] = unlock_addr0;\n\n    pfl->unlock_addr[1] = unlock_addr1;\n\n    /* Hardcoded CFI table (mostly from SG29 Spansion flash) */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (AMD/Fujitsu) */\n\n    pfl->cfi_table[0x13] = 0x02;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x27;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x36;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write (NA) */\n\n    pfl->cfi_table[0x20] = 0x00;\n\n    /* Typical timeout for block erase (512 ms) */\n\n    pfl->cfi_table[0x21] = 0x09;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x0C;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x01;\n\n    /* Max timeout for buffer write (NA) */\n\n    pfl->cfi_table[0x24] = 0x00;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x0A;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x0D;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(chip_len);\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = sector_len >> 8;\n\n    pfl->cfi_table[0x30] = sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    return pfl;\n\n}\n", "idx": 16419, "substitutes": {"base": ["core", "bit", "server", "hard", "extra", "type", "bc", "cache", "alt", "prefix", "balance", "pad", "api", "end", "bi", "back", "front", "real", "buffer", "root", "ip", "boot", "bare", "version", "id", "reset", "beta", "offset", "index", "block", "br", "byte", "ace", "bas", "pos", "b", "up", "home", "use", "at", "fat", "ui", "bal", "zero", "ab", "bf", "area", "start", "port", "open", "io", "out", "Base", "bin", "ase", "info"], "off": ["bit", "OFF", "output", "none", "mode", "less", "rom", "type", "Off", "new", "alt", "buf", "normal", "load", "name", "end", "flow", "back", "front", "no", "info", "ip", "down", "low", "obj", "boot", "reset", "slave", "on", "ff", "online", "address", "full", "data", "block", "raw", "o", "br", "offer", "ref", "bas", "pos", "function", "up", "home", "ON", "zero", "ab", "non", "start", "unknown", "open", "offs", "remote", "empty", "out", "oa", "offset"], "bs": ["lbs", "cs", "nas", "ops", "ps", "bc", "ro", "rs", "BS", "prefix", "buf", "res", "bh", "ss", "bi", "ns", "bb", "boot", "bm", "banks", "ros", "hz", "bid", "blocks", "bits", "db", "ob", "pb", "iss", "ls", "bps", "us", "ras", "ba", "gs", "sb", "bas", "ts", "b", "ubs", "obs", "bed", "fs", "las", "bytes", "bis", "fps", "cb", "ab", "gb", "bos", "ses", "os", "sub", "outs", "lb", "bes", "bl", "sync", "bing"], "sector_len": ["comment33length", "sector33length", "area_cap", "io2len", "piece_den", "sectornlen", "io_length", "piece_span", "sectorncount", "sector64len", "sectornden", "sector64count", "sector__len", "piece_len", "io_count", "comment33limit", "sector1limit", "sector_span", "sector_length", "sector\u00b7count", "sector\u00b7length", "comment_lf", "sector64length", "sector33len", "comment_len", "area_len", "area_count", "sector_limit", "area\u00b7len", "sector64span", "sector\u00b7cap", "sector2den", "io_len", "sector64den", "sector64cap", "io2den", "sector_cap", "comment33len", "io2count", "sector2count", "sector__span", "sector_count", "sector33limit", "sector2length", "area_length", "comment33lf", "sector__den", "comment_limit", "piece_length", "sector33lf", "area\u00b7length", "sector1lf", "sector1len", "sector_lf", "sector_den", "area\u00b7count", "sector1length", "sectornlength", "comment_length", "io2length", "sector__length", "area\u00b7cap", "sector2len", "io_den", "sector\u00b7len"], "nb_blocs": ["nb_blucs", "nb_blocals", "nb_blOCments", "nb_Blociments", "nb_blOCt", "nb_blocis", "nb_Blocis", "nb_blocn", "nb_Blocs", "nb_blOCn", "nb_blOCs", "nb_flocals", "nb_blallocs", "nb_blucn", "nb_flallocs", "nb_blocit", "nb_flocn", "nb_bloggn", "nb_blOCals", "nb_Blocin", "nb_Bloct", "nb_blucments", "nb_blallocn", "nb_bluct", "nb_flocs", "nb_blallocations", "nb_blocin", "nb_blocments", "nb_flallocals", "nb_blallocals", "nb_bloct", "nb_flocations", "nb_Blocit", "nb_bloggals", "nb_bloggs", "nb_Blocn", "nb_blociments", "nb_Blocments", "nb_flallocn", "nb_blOCations", "nb_flallocations", "nb_blocations", "nb_bloggations"], "nb_mappings": ["nb_smapping", "nb_mairs", "nb_tmairs", "nb_Mairs", "nb_Mappings", "nb_tmappings", "nb2tmairs", "nb_mapped", "nb_tmapping", "nb_bmappings", "nb_Mapping", "nb_Mapped", "nb2tmappings", "nb_smocks", "nb_Mocks", "nb_bmaps", "nb_nocks", "nb_smapped", "nb2maps", "nb_smappings", "nb2mappings", "nb2mairs", "nb_napping", "nb2mapping", "nb_bmapping", "nb_maps", "nb_nappings", "nb_Maps", "nb2tmaps", "nb_tmaps", "nb2tmapping", "nb_napped", "nb_mapping", "nb_mocks", "nb_bmairs"], "id0": ["id00", "Id01", "aid0", "aid8", "sid2", "sid8", " id8", "ids8", "ids00", "sid0", "ID00", "ids01", "Id00", "Id0", "aid2", "ids0", "Id8", "ID0", "id01", "ID01", "ID8", "id8"], "id1": ["id001", "ident001", "index7", "ident7", "ID7", "kid001", "kid7", "id11", "ID1", "aid01", " idOne", "kid1", "kid01", "id7", "index1", "ID11", " id11", "aid1", "ident1", "aid7", "aid001", "indexOne", "IDOne", "id01", " id7", "idOne", "index11", "ident01"], "id2": ["ip1", "kid32", "ID2", "ID7", "id6", "ID1", "pid2", "ip6", "kid1", "id7", "pid4", "pid7", "it2", "pid1", "kid2", " id4", "it1", "ID4", "id32", "it32", "ip2", " id7", "it6", "kid6", "ip32", "id4"], "id3": ["Id3", "ip1", "uidThree", " id03", "ip15", "id15", "uid2", "Id1", "idThree", " idThree", "Id03", "Id15", " id15", "ip3", "IdThree", "ip2", "uid3", "uid03", "id03", "Id2"], "unlock_addr0": ["unlock_address2", "unlock_add1", "unlock_offset50", "unlock_address1", "unlock_dr50", "unlock_add50", "unlock_ext0", "unlock_offset0", "unlock_offset1", "unlock_dr0", "unlock_offset16", "unlock_addr50", "unlock_ext2", "unlock_dr1", "unlock_address16", "unlock_ext1", "unlock_ext50", "unlock_addr16", "unlock_address0", "unlock_address50", "unlock_add0", "unlock_add2", "unlock_dr16", "unlock_addr2"], "unlock_addr1": ["unlock_wd1", "unlock_addrOne", "unlock_address1", "unlock_drOne", "unlock_address3", "unlock_dr1", "unlock_wdOne", "unlock_wd3", "unlock_dr3", "unlock_addr3", "unlock_addressOne"], "pfl": ["qfw", "pFL", "pfall", "lpflight", "pflo", "PFl", " plu", "ppfw", " psl", "lpfl", " pkl", "bfr", " pfly", "Pflight", "ipfr", "apfly", "psfw", "PFL", "wpzl", "piflat", " pcompl", "lpflash", "postfl", "psel", "pafl", "postFL", "ppf", "lpzl", "ppfr", "pifl", "npflo", "qzl", " pfd", "pefw", "ppFl", "Pfl", "peroper", " ppl", "execflo", "perflo", "patchflush", "bFL", "spkl", "execfl", "upflash", "pFl", " pfail", "perfr", "npflush", "pflash", "Pflo", "qll", "apFL", "pfol", "purl", "piflush", "poper", "parpl", " pfx", "patchhl", "paflo", "apiFL", "peflo", "ppcompl", "ipfl", "pfx", "ppfl", "pcompl", " pFl", "ppflush", "pefly", "execf", "apifl", "pflow", "pf", " pflash", "apfw", "apfl", "pkl", "uphl", " phl", "tpflush", "ppwl", "apcompl", "pfr", "upflush", "perfly", "parFL", "tpoper", "lpfly", "ppl", "psflush", "bfl", "tpurl", "perflush", "wpflush", "pform", "ipFl", "upfail", "phl", "pwl", "pflush", "peflush", "portfly", "apflo", "portfw", "portfl", "pflat", " pzl", "peoper", "lpflo", "pefl", " pfw", " pflo", "paFL", "psl", "pesl", "pul", "ppfly", "pzl", "qflush", "Psel", "pflight", " pfle", "lpflow", "pfly", "pfd", "pall", "psfl", "postsel", "ppflo", "bpl", "peurl", "npcompl", "tpfl", "parfl", " pflow", "perurl", "spfl", "iplu", "peflat", "perwl", "lpf", "ipflow", "ppflow", "psfr", "apflush", "apsl", "Pfd", "lpform", "qflo", "lpFL", "psul", "portfall", "parfr", "pezl", "ipFL", "perform", "execcompl", "ppFL", "tpflo", "pafail", "ipfd", "plu", "pefall", "pisl", "pfail", "Pfol", "pafx", "lpflush", "wpfl", "Psl", "lpfw", "ppflash", "wpflo", "postflo", "perfl", "pslu", "apiflash", "paf", "lpfr", "patchf", "piFL", " pfol", " pfr", "ipul", "pafol", "spflo", " pflight", "ppkl", "pisel", "apfr", "pll", "patchfl", "pfw", " pflush", " pll", " pf", "ppform", "pfle", "Pf", "tpzl", "qfx", "lpfle", "spflush", "qfl", "upfle", " pul", "lpwl", "apikl", "piflo", " pflat", "peflow", "perkl", "npfl", " pFL", "tpfly", "qf", "upfl", "upf", "paflash", " pfall", "npfly"], "chip_len": ["chip_size", "chipJvec", "chip2length", "chipsln", " chip_lin", "chip2ln", "core_lon", "chip32length", "chipslen", "core_length", "chip_val", "chip00size", "chip_limit", "pixel_pos", " chip_lit", "chipJsize", " chip_val", "chip\u00b7limit", " chip_limit", "chip32ln", "chipslength", "chip\u00b7lin", "ip_vec", "chipJlen", "chip00len", "chip_li", "ip00size", "chip\u00b7len", "chip64len", "chip_lin", "ip_size", "chip_lon", "chip64lit", "ip00vec", "chip64lon", "pixel_len", "coreslength", "chip2pos", "pixel_length", "chip_length", "chip2len", "coresln", "chip_lit", "chip_vec", "coreslon", "core_len", "chip64li", "ip00len", "chip32len", "ip_len", "chip\u00b7val", "chip_pos", "core_ln", "chip32lon", "chip00vec", "coreslen", "chip2lon", " chip_li", "chipslon", " chip_lon", "chip_ln"]}}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n", "idx": 16422, "substitutes": {"s": ["is", "cs", "ils", "ops", "f", "uploads", "sys", "ps", "less", "secondary", "rs", "js", "south", "ss", "sq", "ns", "si", "state", "status", "private", "opens", "ls", "es", "o", "als", "gs", "side", "c", "sb", "ows", "p", "ts", "service", "ssl", "fs", "services", "stats", "S", "states", " fs", "sets", "ses", "e", "os", "sym", "hs", "ds", "its", "sync", "settings"], "path": ["txt", "pattern", "token", "PATH", "node", "name", "type", "parent", "rh", "test", "root", "ion", "enc", "id", "th", "user", "Path", "dir", "data", "pass", "ath", "c", "object", "p", "loader", "key", "pointer", "slice", "desc", "m", "image", "step", "prop", "text", "alias", "anc", "sc", "method"], "mode": ["none", "MODE", "phrase", "node", "type", "mod", " modes", "level", "command", "access", "grade", "perm", "d", "direction", "module", "slave", "code", "dir", "data", "ace", "ma", "mac", "de", "move", "key", "role", "Mode", "def", "cmd", "m", "ODE", "ode", "range", "lane", "term", "alias", "sym", "method", "mask", "md", "name"]}}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical (CPUState *env, mmu_ctx_t *ctx,\n\n                           target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 16431, "substitutes": {"env": ["self", "inet", "eu", "proc", "cache", "net", "global", "et", "eni", "end", "org", "exec", "act", "equ", "fen", "engine", "him", "conf", "cf", "profile", "app", "c", "loader", "vert", "context", "network", "oa", "server", "cdn", "cli", "export", "nc", "enable", "np", "Environment", "site", "dev", "ette", "pec", "esi", "ea", "err", "vm", "ne", "fi", "environment", "pect", "erv", "cmd", "ogen", "n", "ion", "config", "db", "eng", "init", "vs", "enh", "en", "vt", "viron", "ev", "dat", "ah", "info", "txt", "anne", "conn", "press", "enc", "dt", "ec", "exc", "qt", "ou", "her", "het", "edge", "e", "que", "event", "v"], "ctx": ["console", "cca", "cp", "css", "cs", "client", "sys", "grad", "pc", "src", "ck", "cli", "cmd", "bc", "nc", "na", "ci", "btn", "conn", "sq", "exec", "conv", "obj", "util", "hw", "config", "cpp", "qa", "act", "co", "wx", "cas", "lc", "exc", "loc", "ca", "cf", "c", "acs", "cc", "sci", "cv", "vc", "std", "kw", "tx", "pkg", "cfg", "context", "soc", "git", "wcs", "rc", "cb", "cmp", "ctrl", "utils", "cu", "xc", "kb", "sync", "cn"], "eaddr": ["awdress", "edddr", "ealrr", "eeder", "eddbr", "eldr", "ayDR", "eefr", "eeddr", "EWDR", "edhr", "eeddress", "eaddress", "EWrid", "EWfr", "eadbr", "edrr", "elrr", "ebDR", "eadfr", "eedder", "eedDr", "eddDR", "awDR", "ayder", "awdr", "aybr", "eedhr", "eddr", "evhr", "eedr", "ealbr", "eerid", "ebdr", "eadrr", "eadrid", "ebDr", "eedDR", "eebr", "eedbr", "evdr", "evrr", "aydr", "ealdr", "eedrr", "eadDR", "elder", "awDr", "edder", "eddder", "eeDR", "eadhr", "EWdr", "eadder", "ealder", "elhr", "eadDr", "ebdress", "ealhr", "ealDR", "evder"], "rw": ["rr", "worker", "wp", "feat", "wh", "rew", "sw", "sr", "wb", "wr", "wl", "hw", "wu", "fw", "rack", "r", "wk", "wx", "rx", "usr", "w", "ew", "wn", "ffff", "rb", "kw", "nr", "rg", "nw", "ww", "tw", "wa", "RW", "sth", "wer"], "in_plb": ["in_clbh", "in_pelp", "in_slb", "in_slab", "in_clB", "in_flB", "in_PLa", "in_flb", "in_clp", "in_PLc", "in_PLp", "in_pelb", "in_plugb", "in_plB", "in_plab", "in_PLb", "in_pla", "in_plbh", "in_sla", "in_plugbh", "in_plp", "in_plugB", "in_cla", "in_plc", "in_clb", "in_flab", "in_pelB", "in_slB", "in_pelbh", "in_clc", "in_plugp", "in_clab", "in_fla"], "ret": ["reply", "val", "RET", "let", "result", "match", "lt", "alt", "feat", "cur", "res", "success", "reg", "back", "valid", "len", "fun", "mt", "id", "reset", "pet", "fit", "r", "code", "last", "data", "addr", "rev", "pass", "rets", "att", "rb", "ref", "nt", "sb", "det", "rl", "gt", "al", "try", "def", "resp", "re", "ft", "count", "num", "Ret", "rc", "arg", "lit", "rot", "out", "rt", "part", "art"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_xvmc_field_end(MpegEncContext *s)\n\n{\n\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n\n    assert(render);\n\n\n\n    if (render->filled_mv_blocks_num > 0)\n\n        ff_mpeg_draw_horiz_band(s, 0, 0);\n\n}\n", "idx": 16437, "substitutes": {"s": ["g", "cs", "self", "styles", "ops", "session", "f", "src", "ps", "sports", "rs", "js", "t", "ss", "sq", "scope", "ns", "si", "es", "o", "ctx", "gs", "conf", "c", "details", "p", "sb", "ts", "b", "ssl", "fs", "services", "stats", "m", "context", "as", "sets", "ses", "e", "os", "request", "ds", "qs", "sync", "settings"], "render": ["hide", "material", "round", "header", "after", "author", "layout", "result", "Render", "match", "report", "style", "frame", "transform", "xml", "load", "flower", "end", "aster", "make", "record", "save", "rendered", "before", "pair", "nder", "parse", "r", "build", "replace", "draw", "plot", "cover", "design", "callback", "response", "apply", "be", "err", "run", "element", "attr", "mir", "effect", "shape", "open", "color", "use"]}}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 16449, "substitutes": {"mr": ["dr", "rr", "pc", "rw", "yr", "rs", "mx", "kr", "rm", "sr", "lr", "rh", "wr", "mi", "pm", "mt", "bm", "r", "fr", "adr", "gr", "RM", "nr", "rf", "MR", "er", "rg", "mn", "err", "ur", "vr", "attr", "mc", "mm", "rt", "manager", "md", "pr", "Mr", "m"]}}
{"project": "FFmpeg", "commit_id": "c96f3750c22ef1576a46140f3101e3585041f41f", "target": 0, "func": "pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)\n\n{\n\n    char temp[GET_MODE_BUFFER_SIZE];\n\n    char *p= temp;\n\n    static const char filterDelimiters[] = \",/\";\n\n    static const char optionDelimiters[] = \":\";\n\n    struct PPMode *ppMode;\n\n    char *filterToken;\n\n\n\n    ppMode= av_malloc(sizeof(PPMode));\n\n\n\n    ppMode->lumMode= 0;\n\n    ppMode->chromMode= 0;\n\n    ppMode->maxTmpNoise[0]= 700;\n\n    ppMode->maxTmpNoise[1]= 1500;\n\n    ppMode->maxTmpNoise[2]= 3000;\n\n    ppMode->maxAllowedY= 234;\n\n    ppMode->minAllowedY= 16;\n\n    ppMode->baseDcDiff= 256/8;\n\n    ppMode->flatnessThreshold= 56-16-1;\n\n    ppMode->maxClippedThreshold= 0.01;\n\n    ppMode->error=0;\n\n\n\n    memset(temp, 0, GET_MODE_BUFFER_SIZE);\n\n    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: %s\\n\", name);\n\n\n\n    for(;;){\n\n        char *filterName;\n\n        int q= 1000000; //PP_QUALITY_MAX;\n\n        int chrom=-1;\n\n        int luma=-1;\n\n        char *option;\n\n        char *options[OPTIONS_ARRAY_SIZE];\n\n        int i;\n\n        int filterNameOk=0;\n\n        int numOfUnknownOptions=0;\n\n        int enable=1; //does the user want us to enabled or disabled the filter\n\n\n\n        filterToken= strtok(p, filterDelimiters);\n\n        if(filterToken == NULL) break;\n\n        p+= strlen(filterToken) + 1; // p points to next filterToken\n\n        filterName= strtok(filterToken, optionDelimiters);\n\n        av_log(NULL, AV_LOG_DEBUG, \"pp: %s::%s\\n\", filterToken, filterName);\n\n\n\n        if(*filterName == '-'){\n\n            enable=0;\n\n            filterName++;\n\n        }\n\n\n\n        for(;;){ //for all options\n\n            option= strtok(NULL, optionDelimiters);\n\n            if(option == NULL) break;\n\n\n\n            av_log(NULL, AV_LOG_DEBUG, \"pp: option: %s\\n\", option);\n\n            if(!strcmp(\"autoq\", option) || !strcmp(\"a\", option)) q= quality;\n\n            else if(!strcmp(\"nochrom\", option) || !strcmp(\"y\", option)) chrom=0;\n\n            else if(!strcmp(\"chrom\", option) || !strcmp(\"c\", option)) chrom=1;\n\n            else if(!strcmp(\"noluma\", option) || !strcmp(\"n\", option)) luma=0;\n\n            else{\n\n                options[numOfUnknownOptions] = option;\n\n                numOfUnknownOptions++;\n\n            }\n\n            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;\n\n        }\n\n        options[numOfUnknownOptions] = NULL;\n\n\n\n        /* replace stuff from the replace Table */\n\n        for(i=0; replaceTable[2*i]!=NULL; i++){\n\n            if(!strcmp(replaceTable[2*i], filterName)){\n\n                int newlen= strlen(replaceTable[2*i + 1]);\n\n                int plen;\n\n                int spaceLeft;\n\n\n\n                if(p==NULL) p= temp, *p=0;      //last filter\n\n                else p--, *p=',';               //not last filter\n\n\n\n                plen= strlen(p);\n\n                spaceLeft= p - temp + plen;\n\n                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){\n\n                    ppMode->error++;\n\n                    break;\n\n                }\n\n                memmove(p + newlen, p, plen+1);\n\n                memcpy(p, replaceTable[2*i + 1], newlen);\n\n                filterNameOk=1;\n\n            }\n\n        }\n\n\n\n        for(i=0; filters[i].shortName!=NULL; i++){\n\n            if(   !strcmp(filters[i].longName, filterName)\n\n               || !strcmp(filters[i].shortName, filterName)){\n\n                ppMode->lumMode &= ~filters[i].mask;\n\n                ppMode->chromMode &= ~filters[i].mask;\n\n\n\n                filterNameOk=1;\n\n                if(!enable) break; // user wants to disable it\n\n\n\n                if(q >= filters[i].minLumQuality && luma)\n\n                    ppMode->lumMode|= filters[i].mask;\n\n                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))\n\n                    if(q >= filters[i].minChromQuality)\n\n                            ppMode->chromMode|= filters[i].mask;\n\n\n\n                if(filters[i].mask == LEVEL_FIX){\n\n                    int o;\n\n                    ppMode->minAllowedY= 16;\n\n                    ppMode->maxAllowedY= 234;\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        if(  !strcmp(options[o],\"fullyrange\")\n\n                           ||!strcmp(options[o],\"f\")){\n\n                            ppMode->minAllowedY= 0;\n\n                            ppMode->maxAllowedY= 255;\n\n                            numOfUnknownOptions--;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == TEMP_NOISE_FILTER)\n\n                {\n\n                    int o;\n\n                    int numOfNoises=0;\n\n\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        char *tail;\n\n                        ppMode->maxTmpNoise[numOfNoises]=\n\n                            strtol(options[o], &tail, 0);\n\n                        if(tail!=options[o]){\n\n                            numOfNoises++;\n\n                            numOfUnknownOptions--;\n\n                            if(numOfNoises >= 3) break;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK\n\n                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){\n\n                    int o;\n\n\n\n                    for(o=0; options[o]!=NULL && o<2; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        if(o==0) ppMode->baseDcDiff= val;\n\n                        else ppMode->flatnessThreshold= val;\n\n                    }\n\n                }\n\n                else if(filters[i].mask == FORCE_QUANT){\n\n                    int o;\n\n                    ppMode->forcedQuant= 15;\n\n\n\n                    for(o=0; options[o]!=NULL && o<1; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        ppMode->forcedQuant= val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if(!filterNameOk) ppMode->error++;\n\n        ppMode->error += numOfUnknownOptions;\n\n    }\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode);\n\n    if(ppMode->error){\n\n        av_log(NULL, AV_LOG_ERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name);\n\n        av_free(ppMode);\n\n        return NULL;\n\n    }\n\n    return ppMode;\n\n}\n", "idx": 16452, "substitutes": {"name": ["resource", "NAME", "none", "ame", "length", "type", "new", "prefix", "parent", "q", "table", "base", "n", "version", "config", "memory", "id", "word", "path", "label", "code", "max", "address", "data", "space", "block", "w", "time", "key", "Name", "current", "search", "comment", "named", "package", "image", "names", "filename", "alias", "anc", "part", "v", "size", "info"], "quality": ["val", "qual", "priority", "scale", "resolution", "quant", "Q", "style", "grade", "level", "q", "valid", "base", "version", " q", " qual", "qa", "format", "depth", "comp", "value", "weight", "lock", "Quality", "query", "custom", "quiet", "secure"], "temp": ["str", "cp", "copy", "dc", "output", "pt", "template", "wp", "type", "cel", "cache", "source", "pipe", "t", "flat", "Temp", "form", "clean", "cur", "buffer", "sw", "pool", "test", "table", "col", "base", "enc", "config", "memory", "zip", "path", "storage", "input", "data", "emp", "block", "wrap", "params", "iter", "pre", "format", "EMP", "c", "var", "tmp", "content", "null", "current", "try", "tc", "fake", "package", "context", "lock", "mem", "opt", "font", "empty", "tem", "method", "v", "ex"], "p": ["g", "cp", "f", "pc", "sp", "ps", "tp", "jp", "array", "lp", "t", "q", "it", "d", "np", "n", "pi", "offset", "path", "pp", "r", "h", "data", "params", "php", "pre", "c", "P", "s", "fp", "pos", "y", "pe", "b", "e", "l", "port", "start", "a", "v", "pr", "j", "m"], "filterDelimiters": ["filterDelimitearies", "filterDelignitserers", "filterDelimiterers", "filterDelititerters", "filterDelimalers", "filterDelimitsers", "filterDelignitsers", "filterDelimitizerers", "filterDelititeraries", "filterDelimitserers", "filterDelititerers", "filterDelimitizers", "filterDelimalings", "filterDelimiteraries", "filterDelititters", "filterDelimitizars", "filterDelititerings", "filterDelignitsars", "filterDelimitsars", "filterDelimitaries", "filterDelimalters", "filterDelimitters", "filterDelimiteers", "filterDelignitars", "filterDelimitars", "filterDelimiterters", "filterDelititers", "filterDelimiterings", "filterDelimiteerers", "filterDelimitizings", "filterDeligniterers", "filterDelimitings", "filterDelimitsings", "filterDelimitears", "filterDelimalaries", "filterDelignitings", "filterDelititings", "filterDeligniters", "filterDelititaries", "filterDelignitsings", "filterDelimiteings", "filterDelimiteters"], "optionDelimiters": ["optionDelititerters", "optionDelimiteners", "optionDelititers", "optionDelimimers", "optionDelimiterters", "optionDelimitedeners", "optionDelititeners", "optionDelimiteder", "optionDelimiter", "optionDelimitererers", "optionDelarITers", "optionDelarITer", "optionDelariters", "optionDelimimters", "optionDelimitators", "optionDelimimators", "optionDelimitedters", "optionDelamitators", "optionDelimimERS", "optionDelimitters", "optionDelimitERS", "optionDelimITERS", "optionDelititer", "optionDelimITters", "optionDelimITeners", "optionDelimimer", "optionDelarITERS", "optionDelamitederers", "optionDelamiters", "optionDelaritERS", "optionDelititerers", "optionDelititerer", "optionDelimiterers", "optionDelamiteders", "optionDelimitedERS", "optionDelimiterERS", "optionDelamitedators", "optionDelamitERS", "optionDelimitedators", "optionDelamiterers", "optionDelimitereners", "optionDelimimerers", "optionDelimiteders", "optionDelarITters", "optionDelimiterer", "optionDelimITers", "optionDelititters", "optionDelamitedERS", "optionDelimITer", "optionDelimitederers", "optionDelaritters", "optionDelititereners", "optionDelariter", "optionDelimiterators"], "ppMode": ["ppStream", "cppModel", "pxMask", "pxModule", "ppsModule", "peMode", "phpModule", "PPMode", "wpMode", "cppMac", "ampMo", "phpMo", "pCopy", "cppHalf", " ppManager", "cppConfig", "ppInfo", "bbDevice", "ppaCmd", "ppMODE", "pBlock", "plKind", " ppMech", "ppEngine", "PPEngine", "pStatus", "cppManager", "ppsManager", " ppKind", "cppMask", "pMech", "cppCmd", " ppCopy", "phpMech", "PPRole", "cppMode", "ppaConfig", "cppKind", "ppHalf", "peModule", "ppsRole", "bbModule", "PPCopy", "ppCopy", "ppsInfo", "ppaMode", "plStream", " ppStatus", "PPModule", "ppaMo", "cppEntry", "ppManager", "wpConfig", "ppMac", "ppsMode", " ppBlock", "ppaMODE", " ppMODE", "ppMech", "cppDevice", "ppCmd", "ppDevice", "PPMac", "cppMODE", "ppModule", "PPManager", "pxInfo", "ppModel", "pCmd", "ppaEntry", "PPModel", "PPOwner", " ppStream", "ppaManager", "cppSync", "pMo", "cppModule", "ppsMask", "ppEntry", "pOwner", "bbHalf", "ppConfig", "ppMo", " ppEngine", "bbSync", "ppKind", "ppOwner", "ppsEngine", "plModel", "cppRole", "cppMo", "PPCmd", "bbCmd", " ppDevice", "pMode", " ppMo", "ppSync", " ppCmd", "ppsMac", " ppSync", "ppMask", " ppModel", "pxMode", "ppRole", "PPStream", "peBlock", " ppHalf", "ampEntry", "plMode", "PPKind", "cppInfo", "wpMODE", "bbMode", "pModule", "ppBlock", " ppModule", "PPMODE", "ampManager", "pKind", "peStatus", "ampMode", "wpCmd", " ppOwner", "ppStatus", "phpMode"], "filterToken": ["FilterTokens", "FilterToken", " filterMin", "filterKey", "filNode", "filToken", "searchName", "finaltoken", "filoken", "filterMin", "filKey", " filtertoken", "searchToken", "outputValue", "outputToken", " filteroken", "searchTokens", "filtoken", "filteroken", "filterTokens", "sortName", "filMin", "FilterName", " filterKey", "filterByte", " filterNode", "outputName", "filterCode", "filByte", "filterValue", "filTokens", "finalMin", " filterCode", "searchByte", "sortCode", " filterValue", "searchNode", "searchoken", "sortTokens", " filterTokens", "outputKey", "sortToken", "finalName", "filterNode", "filValue", " filterByte", "finalToken", "filCode", "filtertoken", "filName"], "filterName": ["FilterString", "channelname", "FilterToken", " filterString", "formatText", "sortNo", "filname", "filtername", "filPart", "channelText", " filtername", "searchName", "filToken", "filterPart", "classToken", "filterString", "filterText", "FilterCode", "channelToken", "searchToken", " filterText", " filterInfo", "searchname", "sortName", "maskName", "filterNo", "FilterInfo", "formatname", "FilterName", "maskInfo", " filterPart", "filterCode", "filterInfo", " filterCode", "classNo", "maskToken", "formatName", "filString", "classname", " filterNo", "FilterPart", "sortToken", "channelName", "maskCode", "formatToken", "className", "sortname", "filName"], "option": ["section", "resource", "optim", "expression", "token", "route", "operation", "match", "type", "op", "Option", "argument", "choice", "connection", "optional", "position", "ion", "user", "change", "equ", "block", "archive", "profile", "object", "public", "key", "function", "value", "comment", "item", "update", "image", "package", "cho", "element", "attr", "ption", "term", "opt", "alias", "other", "text", "open", "custom", "event", "color", "attribute", "original"], "options": ["eps", "groups", "ops", "cache", "values", "array", "optional", "args", "config", "multiple", "Options", "errors", "classes", "files", "params", "object", "s", "value", "objects", "names", "opt", "other", "times", "settings"], "OPTIONS_ARRAY_SIZE": ["OPTIONS_AROW_MODE", "OPTIONS_ARRAY_USE", "OPTIONS_AROW_SEC", "OPTIONS_AROW_SIZE", "OPTIONS_ARRAY_MODE", "OPTIONS_ARRAY_SEC", "OPTIONS_AROW_USE"], "i": ["is", "di", "f", "u", "ci", "li", "in", "it", "d", "info", "n", "ip", "I", "pi", "id", "h", "index", "ii", "c", "b", "ni", "e", "l", "start", "j", "m"], "numOfUnknownOptions": ["numOfUnknownOP", "numofUnknownParts", "numOfunknownOptions", "numOfunknownOP", "numOfNewOption", "numofUnknownOption", "numOfunknownOption", "numOfunknownParts", "numofUnknownOP", "numOfNewParts", "numOfKnownOptions", "numofunknownParts", "numOfKnownParts", "numOfKnownOption", "numOfUnknownOption", "numofunknownOptions", "numOfNewOptions", "numofunknownOP", "numofUnknownOptions", "numOfKnownOP", "numOfNewOP", "numOfUnknownParts", "numofunknownOption"], "error": ["batch", "warning", "progress", "result", "type", "parent", "grade", "success", "fail", "version", "code", "last", "data", "errors", "block", "call", "close", "patch", "delay", "comment", "err", "loss", "Error", "row", "query", "bug", "debug", "layer", "info"]}}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16465, "substitutes": {"bs": ["lbs", "core", "cs", "css", "src", "blog", "bc", "rs", "BS", "js", "bh", "ss", "abi", "bi", "ns", "plugins", "bb", "obj", "banks", "ros", "db", "ob", "blocks", "state", "pb", "bid", "bits", "vs", "ls", "eb", "es", "iss", "us", "ec", "ba", "rb", "sb", "bas", "ks", "b", "obs", "fs", "las", "bytes", "bis", "cb", "ab", "gb", "ses", "bos", "os", "ins", "outs", "lb", "bes", "ds", "bl", "fb"], "l1_index": ["l1rIndex", "l2_address", "l1raddress", "l1_address", "l1_offset", "l2_index", "l1_i", "l1roffset", "l2_Index", "l2_i", "l2_offset", "l1_length", "l1rindex", "l2_length", "l1_Index"], "s": ["is", "cs", "f", "ops", "sys", "session", "ps", "uns", "rs", "js", "ss", "d", "ns", "n", "site", "si", "args", "state", "r", "vs", "ls", "es", "us", "w", "gs", "c", "p", "sb", "ks", "ts", "b", "ssl", "sl", "ubs", "xs", "su", "fs", "services", "stats", "S", "bis", "states", "sets", "e", "ses", "os", "sym", "ins", "spec", "ds", "qs", "v", "its", "settings"], "buf": ["vec", "bd", "af", "cat", "uf", "result", "stab", "proc", "uc", "cmd", "queue", "bc", "bh", "pad", "buffer", "Buffer", "pool", "wb", "bb", "conv", "base", "fd", "config", "aux", "fw", "ff", "db", "pb", "img", "data", "block", "cas", "ctx", "cap", "ba", "rb", "cf", "fp", "bag", "cv", "tmp", "func", "b", "Buff", "bed", "null", "fb", "bytes", "cb", "rc", "fi", "gb", "seq", "mem", "ab", "port", "bf", "ucc", "fab", "text", "box", "buff", "v", "bin", "alloc", "br"], "l1_start_index": ["l1_start1index", "l1_start64offset", "l1_start64ind", "l1_start1offset", "l1_start_point", "l1_start_position", "l1_end_position", "l1_start64index", "l1_end_value", "l1_start64size", "l1_end_index", "l1_start1size", "l1_start_size", "l1_start_end", "l1_startpposition", "l1_startpindex", "l1_end_end", "l1_start_value", "l1_end_ind", "l1_startpend", "l1_end_offset", "l1_start_ind", "l1_start_offset", "l1_start_shape", "l1_end_size", "l1_end_point", "l1_start1ind", "l1_end_shape"], "i": ["di", "f", "ri", "xi", "x", "ix", "u", "qi", "ci", "li", "in", "eni", "bi", "it", "uri", "mu", "d", "ji", "n", "len", "pi", "si", "I", "id", "h", "r", "ai", "index", "iu", "o", "lc", "ii", "k", "c", "p", "b", "z", "ui", "ni", "gi", "zi", "fi", "anti", "e", "l", "a", "io", "oi", "ini", "v", "ti", "j", "m"], "ret": ["bit", "val", "RET", "reply", "f", "cat", "get", "result", "match", "bc", "alt", "feat", "res", "success", "repl", "reg", "back", "error", "rel", "red", "len", "fun", "mt", "obj", "id", "reset", "r", "art", "rev", "pass", "rets", "rb", "att", "ext", "ref", "det", "nt", "al", "active", "rf", "def", "flag", "re", "resp", "err", "ur", "en", "ft", "run", "vr", "rc", "fi", "Ret", "bf", "num", "bad", "arr", "arg", "lit", "rt", "out", "mi"]}}
{"project": "qemu", "commit_id": "f46e9a0b9911fcfbc13f85f3a8808067990a0f5c", "target": 0, "func": "static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n\n{\n\n    uintptr_t host_start, host_map_start, host_end;\n\n\n\n    last_bss = TARGET_PAGE_ALIGN(last_bss);\n\n\n\n    /* ??? There is confusion between qemu_real_host_page_size and\n\n       qemu_host_page_size here and elsewhere in target_mmap, which\n\n       may lead to the end of the data section mapping from the file\n\n       not being mapped.  At least there was an explicit test and\n\n       comment for that here, suggesting that \"the file size must\n\n       be known\".  The comment probably pre-dates the introduction\n\n       of the fstat system call in target_mmap which does in fact\n\n       find out the size.  What isn't clear is if the workaround\n\n       here is still actually needed.  For now, continue with it,\n\n       but merge it with the \"normal\" mmap that would allocate the bss.  */\n\n\n\n    host_start = (uintptr_t) g2h(elf_bss);\n\n    host_end = (uintptr_t) g2h(last_bss);\n\n    host_map_start = (host_start + qemu_real_host_page_size - 1);\n\n    host_map_start &= -qemu_real_host_page_size;\n\n\n\n    if (host_map_start < host_end) {\n\n        void *p = mmap((void *)host_map_start, host_end - host_map_start,\n\n                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (p == MAP_FAILED) {\n\n            perror(\"cannot mmap brk\");\n\n            exit(-1);\n\n        }\n\n\n\n        /* Since we didn't use target_mmap, make sure to record\n\n           the validity of the pages with qemu.  */\n\n        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n\n    }\n\n\n\n    if (host_start < host_map_start) {\n\n        memset((void *)host_start, 0, host_map_start - host_start);\n\n    }\n\n}\n", "idx": 16483, "substitutes": {"elf_bss": ["elf_bSS", "elf_dbsl", "elf_cboss", "elf_absl", "elf_abse", "elf_fbiss", "elf_dbss", "elf_abss", "elf_gss", "elf_gsl", "elf_cbSS", "elf_dboss", "elf_bess", "elf_abSS", "elf_boss", "elf_cbss", "elf_cbass", "elf_goss", "elf_aboss", "elf_bass", "elf_biss", "elf_fbSS", "elf_dbse", "elf_bse", "elf_gse", "elf_fbss", "elf_abass", "elf_bsl", "elf_fbess", "elf_fboss", "elf_fbass", "elf_abess", "elf_abiss"], "last_bss": ["last_Bcss", "last_nbss", "last_abss", "last_lbse", "last_foss", "last_lbss", "last_abass", "last__biss", "last_nbess", "last__cbess", "last_bbse", "last_Bess", "last_cboss", "last__cbSS", "last_bess", "last_cbse", "last__bSS", "last_abiss", "last_bbess", "last_fess", "last_fcss", "last_bbSS", "last_cbiss", "last_bass", "last_lboss", "last_bbass", "last_abess", "last_fss", "last__bss", "last_bbcss", "last_Boss", "last_boss", "last_cbss", "last_bcss", "last_bbuss", "last_bboss", "last__cbss", "last_bse", "last_cbess", "last_bSS", "last_lbuss", "last_bbss", "last__bess", "last__cbiss", "last_nbSS", "last_cbSS", "last_Bss", "last_abcss", "last_aboss", "last_biss", "last_buss", "last_cbuss", "last_nbiss", "last_bbiss"], "prot": ["header", "txt", "pattern", "Prot", "cli", "two", "type", "prefix", "conn", "dim", "gap", "primary", "conv", "col", "comb", "config", " proto", "reset", "rog", "path", "platform", " protocol", "status", "afi", "fen", " protocols", "typ", "stat", "next", "fl", "ext", "pre", "format", "chron", "ref", "termin", "period", "def", "rin", "neg", "nat", "ocol", "transfer", "en", "prop", "ne", "pred", "seq", "ret", "opt", "pro", "io", "rot", "pri", "mode"], "host_start": ["hostPsize", "page_starting", "host8start", "server_end", "hostPstate", "server_starting", "host__end", "server_start", "host___part", "host00search", "hostPend", "host8size", "host_min", "host_range", "host_search", "page_size", "server_state", "host_part", "host_starting", "page_start", "hostsend", "hostPstart", "server_range", "host___count", "host00end", "host__starting", "hostsmin", "server_min", "server_size", "host___start", "host8shift", "server_search", "host_state", "host__start", "host_info", "hostsinfo", "host_shift", "host___end", "host00start", "server_info", "host_size", "page_shift", "server_part", "host8starting", "host__search", "hostsstart", "server_count", "host_count", "host00starting"], "host_map_start": ["host_list_end", "host_data_end", "host_block_start", "host_block_left", "host_block_stop", "host_block_length", "host_data_id", "host_map_max", "host_block_id", "host_data_stop", "host_list_id", "host_list_max", "host_block_cost", "host_list_start", "host_block_int", "host_map_end", "host_map_stop", "host_map_next", "host_map_id", "host_block_range", "host_map_length", "host_map_cost", "host_map_left", "host_block_ish", "host_data_next", "host_map_int", "host_map_ish", "host_map_size", "host_map_range", "host_block_end", "host_data_size", "host_data_start"], "host_end": ["host0End", "host0start", "host_length", "server_start", "port_stop", "host2ending", "host2offset", " host_End", "port_start", "host_stop", "hostsend", "host_ended", "host2end", "host2start", "server_id", "host_offset", "hostsstop", "port_end", "server_length", " host_ended", "server_offset", "host0ended", "server_ending", "host0end", "host_End", "host_ending", "hostsstart", "host_id", "server_end"], "p": ["g", "cp", "f", "ap", "pc", "sp", "ps", "jp", "tp", "wp", "op", "u", "po", "lp", "t", "api", "d", "np", "n", "pm", "pi", "i", "pg", "pp", "pa", "vp", "o", "pre", "c", "P", "s", "pe", "b", "per", "e", "l", "v", "m"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_biwgt_4x4multiple_msa(uint8_t *src,\n\n                                      int32_t src_stride,\n\n                                      uint8_t *dst,\n\n                                      int32_t dst_stride,\n\n                                      int32_t height,\n\n                                      int32_t log2_denom,\n\n                                      int32_t src_weight,\n\n                                      int32_t dst_weight,\n\n                                      int32_t offset_in)\n\n{\n\n    uint8_t cnt;\n\n    uint32_t load0, load1, load2, load3;\n\n    v16i8 src_wgt, dst_wgt, wgt;\n\n    v16i8 src0, src1, src2, src3;\n\n    v16i8 dst0, dst1, dst2, dst3;\n\n    v8i16 temp0, temp1, temp2, temp3;\n\n    v8i16 denom, offset, add_val;\n\n    int32_t val = 128 * (src_weight + dst_weight);\n\n\n\n    offset_in = ((offset_in + 1) | 1) << log2_denom;\n\n\n\n    src_wgt = __msa_fill_b(src_weight);\n\n    dst_wgt = __msa_fill_b(dst_weight);\n\n    offset = __msa_fill_h(offset_in);\n\n    denom = __msa_fill_h(log2_denom + 1);\n\n    add_val = __msa_fill_h(val);\n\n    offset += add_val;\n\n\n\n    wgt = __msa_ilvev_b(dst_wgt, src_wgt);\n\n\n\n    for (cnt = height / 4; cnt--;) {\n\n        LOAD_4WORDS_WITH_STRIDE(src, src_stride, load0, load1, load2, load3);\n\n        src += (4 * src_stride);\n\n\n\n        src0 = (v16i8) __msa_fill_w(load0);\n\n        src1 = (v16i8) __msa_fill_w(load1);\n\n        src2 = (v16i8) __msa_fill_w(load2);\n\n        src3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        LOAD_4WORDS_WITH_STRIDE(dst, dst_stride, load0, load1, load2, load3);\n\n\n\n        dst0 = (v16i8) __msa_fill_w(load0);\n\n        dst1 = (v16i8) __msa_fill_w(load1);\n\n        dst2 = (v16i8) __msa_fill_w(load2);\n\n        dst3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        XORI_B_4VECS_SB(src0, src1, src2, src3, src0, src1, src2, src3, 128);\n\n\n\n        XORI_B_4VECS_SB(dst0, dst1, dst2, dst3, dst0, dst1, dst2, dst3, 128);\n\n\n\n        ILVR_B_4VECS_SH(src0, src1, src2, src3, dst0, dst1, dst2, dst3,\n\n                        temp0, temp1, temp2, temp3);\n\n\n\n        temp0 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp0);\n\n        temp1 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp1);\n\n        temp2 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp2);\n\n        temp3 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp3);\n\n\n\n        SRA_4VECS(temp0, temp1, temp2, temp3,\n\n                  temp0, temp1, temp2, temp3, denom);\n\n\n\n        temp0 = CLIP_UNSIGNED_CHAR_H(temp0);\n\n        temp1 = CLIP_UNSIGNED_CHAR_H(temp1);\n\n        temp2 = CLIP_UNSIGNED_CHAR_H(temp2);\n\n        temp3 = CLIP_UNSIGNED_CHAR_H(temp3);\n\n\n\n        PCKEV_B_STORE_4_BYTES_4(temp0, temp1, temp2, temp3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n    }\n\n}\n", "idx": 16498, "substitutes": {"src": ["scl", "sys", "inst", "uc", "rs", "source", "cur", "feat", "transform", "sq", "secure", "req", "stack", "rib", "low", "config", "img", "ctx", "stat", "stream", "loc", "rb", "RC", "sil", "sb", "depth", "sci", "gl", "ssl", "sl", "sup", "dist", "desc", "sel", "send", "rc", "url", "cb", "dest", "gb", "seq", "filename", "scene", "sc", "rob", "comp", "ctr", "sync"], "src_stride": ["src_Strride", "src_trides", "src_trride", "src_Strided", "src_brride", "src_rride", "src_brides", "src_strided", "src_rides", "src_Stride", "src_brided", "src_strine", "src_striine", "src_trided", "src_strIDE", "src_ride", "src_striride", "src_STRide", "src_rided", "src_striided", "src_bride", "src_STRride", "src_trIDE", "src_STRine", "src_tride", "src_strides", "src_brine", "src_brIDE", "src_StrIDE", "src_strride", "src_STRided", "src_striide"], "dst": ["sdsc", "Dsc", " dsc", "Dst", "dsc", "dsts", "sdst", " dsts", "sdsts", "dsrc", "Dsts", " dsrc", "sdsrc", "Dsrc"], "dst_stride": ["dst_trided", "dst_strided", "dst_striider", "dst_strider", "dst_striided", "dst_rided", "dst_strides", "dst_ride", "dst_rides", "dst_striide", "dst_trides", "dst_tride", "dst_striides", "dst_rider", "dst_trider"], "height": ["layout", "length", "resolution", "xy", "style", "level", "Height", "dim", "window", "gap", "high", "version", "bottom", "config", "id", "th", "index", "build", "padding", "img", "input", "data", "top", "block", "upper", "repeat", "dy", "grow", "above", "depth", "y", "deep", "def", "dist", "thin", "count", "shape", "row", "history", "rows", "gpu", "size"], "log2_denom": ["log2_nanOM", "log2_Denomal", "log2_nanoc", "log2_denoms", "log2_danot", "log2_DenOM", "log2_Denorm", "log2_Denoms", "log2_Denoc", "log2_DENOM", "log2_denoc", "log2_pronOM", "log2_denomal", "log2_DENoms", "log2_denOM", "log2_nanot", "log2_danom", "log2_denow", "log2_nanoms", "log2_DENom", "log2_pronom", "log2_nanorm", "log2_DENorm", "log2_pronomal", "log2_denorm", "log2_Denot", "log2_Denow", "log2_Denom", "log2_danoc", "log2_nanom", "log2_pronow", "log2_danOM", "log2_denot"], "src_weight": ["sb64force", "srcPwidth", "sb_margin", "srcPweight", "srPwidth", "srPbalance", "sb64margin", "src_Weight", "src_mean", "src64margin", "sr_width", "sb64weight", "sb_weight", "sb_force", "srcPpool", "src_pool", "srcPbalance", "source_Weight", "source_weight", "src_force", "srPpool", "sb64mean", "srPweight", "sr_weight", "src64weight", "src64mean", "sr_pool", "sr_balance", "source_width", "sb_mean", "src_margin", "src64force", "src_width", "src_balance"], "dst_weight": ["dsrc_depth", "drc_cost", "dst_cost", "dest_weight", "dstacdepth", "dst_balance", "dstalldepth", "dst_width", "dstallload", "dstallweights", "drc_work", "dst_weights", "dest_max", "dest_width", "dst_depth", "dsrc_weights", "dsrcacload", "dst_work", "dstacweight", "dsrc_weight", "dstallweight", "dst_load", "dsrcacweights", "dst_max", "dest_balance", "drc_weight", "dsrc_load", "drc_width", "dsrcacweight", "dstacload", "dstacweights", "dsrcacdepth"], "offset_in": ["attribute_inc", "error_in", "offset_min", "reference67in", "attribute_left", "offsetPleft", "offset_win", "offset_i", "offset_left", "error_out", "offset_out", "attribute_in", "offset67in", "error_ins", "attributePin", "offsetPinc", "reference67ini", "offset_ini", "reference67t", "offset_inc", "reference_ini", "offset_bin", "offset_inner", "reference67win", "error_min", "align_inner", "align_i", "attributePleft", "offset_t", "offset67t", "reference_win", "attributePout", "reference_t", "offset67ini", "attributePinc", "align_in", "offset_ins", "reference_in", "offsetPout", "attribute_out", "offsetPin", "align_bin", "offset67win"], "cnt": ["acnt", " cnd", "acount", "gnd", "acnc", "fcount", "ncnd", "dcnd", "acNT", "cant", "cnc", "ncount", "scnd", "gant", "dcnt", "acnd", "fcnt", "cont", "ncNT", "dcant", "cnd", " count", "ncnt", "fcnd", " cnc", " cNT", "gont", "scont", "fcnc", "scant", "count", "dcont", "cNT", "scnt", "gnt"], "load0": [" load8", "loading1", "read0", "Load88", "call8", " load88", "Load2", "call1", "loading2", "call0", "read8", "load88", "call2", "Load1", "read1", "loading0", "Load0", "loading88", "read2", "load8", "Load8"], "load1": ["play3", "Load3", "play01", "read0", "load01", "read01", "loadOne", "Load2", "wait4", "wait0", "Load4", "read4", "read3", "loader1", "loaderOne", "wait1", "play2", "Load1", "read1", "Load0", "loader2", " loadOne", "read2", "load4", "Load01", "wait01", "play1", "LoadOne"], "load2": ["show2", "play0", " loadtwo", " load8", "Load2", "loader1", "play2", "Load1", " load5", "loader0", "show4", "locktwo", "Load0", "loader2", "load8", "load4", "Load8", "load5", "lock2", "show5", " load4", "showtwo", "play1", "loadtwo", "lock4", "play8", "lock5"], "load3": [" load83", "Load3", "loading1", "loading83", "loader3", "load15", "lock3", "loading2", "Load2", "loading3", "loader1", "loaderThree", " load15", "loader15", "load03", "Load83", "load83", "lock23", "loader23", "lock03", "Load1", "loadingThree", " load03", "loadThree", "loader03", "loading15", "lock1", "loader2", " load23", "load23", " loadThree"], "src_wgt": ["src_sant", "src_wsgt", "src_sgt", "src_ewnt", "src_wsant", "src_Wgt", "src_srt", "src_walrt", "src_wft", "src_wsrt", "src_wlt", "src_swnt", "src_wsg", "src_want", "src_ewgt", "src_wrt", "src_Wg", "src_wnt", "src_walgt", "src_wsgen", "src_wsgd", "src_wslt", "src_wsnt", "src_Want", "src_wgen", "src_ewlt", "src_wg", "src_sgen", "src_swft", "src_walgen", "src_swlt", "src_Wgd", "src_wgd", "src_swgt", "src_walant", "src_ewft", "src_wsft"], "dst_wgt": ["dst_wsht", "dst_wht", "dst_wrt", "dst_rht", "dst_rg", "dst_wwgt", "dst_Wgt", "dst_iwg", "dst_wnt", "dst_iwgt", "dst_Wgd", "dst_ewnt", "dst_Wg", "dst_wGT", "dst_wsGT", "dst_wsgd", "dst_ewht", "dst_wg", "dst_Wht", "dst_wagd", "dst_want", "dst_Wnt", "dst_iwht", "dst_wwht", "dst_ewGT", "dst_wsrt", "dst_wagt", "dst_iwrt", "dst_ewgt", "dst_Wrt", "dst_wart", "dst_wgd", "dst_wsnt", "dst_wwGT", "dst_wsgt", "dst_rgt", "dst_rrt", "dst_wwnt"], "wgt": ["wgs", "Wlt", " wlt", "wg", " wgz", "rwgt", "fwgs", "swgz", " wgs", "wGT", "fwg", "wgz", "rwgs", "swlt", " wGT", " wrt", "swgt", "wlt", "fwgt", "rwg", "fwrt", "swGT", "rwrt", "Wgt", "wrt", "WGT", "Wgz", " wg"], "src0": ["src00", "loc1", "src50", "rc1", "rc0", "load50", " src50", "src8", "rc2", "st8", "load00", "rc50", "loc2", "st0", "rc8", " src00", "st1", "loc8", "rc00", "st2", "loc0"], "src1": ["loc1", "loc3", "sc01", "rc1", "rc0", "src01", "rc2", "rc3", " src01", "loc2", "sc1", "rc01", "loc0"], "src2": ["rctwo", "sourcetwo", "loc1", "source4", "send4", "sendtwo", "rc1", "send0", "rc0", "source2", "send2", "loc4", "rc2", "rc4", "source1", "loc2", "srctwo", "loc0", "src4", "source0"], "src3": ["loc1", " src03", "loc3", "source4", "rc1", "rc0", "rc03", "source2", "load03", "loc4", "rc2", "rc3", "rc4", "source1", "loc2", "source3", "src4", "src03"], "dst0": ["dST8", "dst8", "sst0", "dost8", "sost8", "sost1", "dest1", "sst1", "dest8", "dest2", "dest0", "sost2", "dost0", "sst2", "sst8", "sost0", "dST0", "dST1", "dST2", "dost1", "dost2"], "dst1": ["dgest8", "dst8", "Dst1", "Dest2", "dest1", "Dst0", "dest8", "Dest0", "dest2", "dess2", "dest0", "dgest1", "Dst8", "dess0", "dgest2", "Dest1", "dgest0", "Dst2", "Dest8", "dess1", "dess8"], "dst2": ["dsc0", "dstage2", "dstage1", "dest4", "dsc1", " dstage4", "dest1", "dest2", "dest0", " dstage1", "dsc2", " dstage0", "dsc4", " dst4", "dstage4", "dst4", " dstage2", "dstage0"], "dst3": ["dsp1", "dsc5", " dsc1", "dsp5", "dsc3", "dsc1", "dsp2", "dest5", "dest1", "dest2", "dst5", "dsp3", "dsc2", " dsc3", " dsc2", " dsc5", "dest3", " dst5"], "temp0": ["weight0", "temp00", "weight00", "Temp1", "Temp0", "Temp00", "weight2", "Temp2", "tem1", "tem00", "weight1", "tem2", "tem0"], "temp1": ["level1", "level3", "Temp1", "Temp2", "level2", "Temp3"], "temp2": ["Temp4", "emp4", "emp1", " temp4", "temp4", " temp02", "Temp1", "Temp2", "temp02", "emp02", "emp2", "Temp02"], "temp3": ["tem5", "tem3", "Temp5", "Temp1", "Temp2", "temp5", "Temp3", " temp5", "tem1", "tem2"], "denom": ["denym", "decog", "denow", " denog", "Denom", "decym", " denym", "denomin", " denow", "denog", "lenomin", "DENomin", "Denomin", "DENom", "Denog", "decow", "Denym", "DENog", "lenym", "lenom", "lenog", "lenow", "DENym", "decom"], "offset": ["val", "set", "alpha", "initial", "timeout", "split", "pt", "range", "style", "balance", "axis", "ol", "et", "op", "off", "error", "no", "len", "position", "kl", "base", "frequency", "reset", "eq", "index", "padding", "o", "Offset", "align", "loc", "slot", "ref", "pos", "unit", "delay", "slice", "weight", "bal", "num", "seed", "adjust", "alias", "start", "rot", "origin", "part", "af"], "add_val": ["addAllval", " add1vals", " add_vals", "add__Val", "add1eval", "addAllvals", "add_key", " add_key", " add_pol", "add__pol", " add1val", "add1key", " add_eval", " add1key", "add__vals", " add_value", " add_Val", "addAllkey", "add_vals", "add_Val", "add_value", " add1eval", "addAlleval", "add_eval", "add_pol", "add1val", "add1vals", "add__val"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,\n\n                              TCGReg arg1, intptr_t arg2)\n\n{\n\n    int opi, opx;\n\n\n\n    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);\n\n    if (type == TCG_TYPE_I32) {\n\n        opi = LWZ, opx = LWZX;\n\n    } else {\n\n        opi = LD, opx = LDX;\n\n    }\n\n    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);\n\n}\n", "idx": 16501, "substitutes": {"s": ["g", "is", "cs", "sf", "f", "ops", "sys", "session", "secondary", "u", "js", "ions", "sq", "scope", "ns", "n", "support", "h", "r", "o", "w", "c", "p", "sb", "service", "b", "ssl", "fs", "services", "S", "bis", "sets", "ses", "e", "sv", "os", "sym", "a", "ds", "sync", "m"], "type": ["set", "class", "ty", "resource", "rule", "match", "style", "name", "op", "parent", "link", "Type", "x", "t", "error", "rel", "test", "py", "col", "i", "id", "types", "address", "r", "code", "by", "block", "target", "typ", "ype", "stat", "pre", "format", "p", "key", "y", "pe", "sy", "prot", "re", "value", "use", "TYPE", "like", "model", "sym", "open", "lit", "date", "pr", "size", "info"], "ret": ["RET", "val", "reply", "pattern", "result", "proc", "match", "alt", "res", "proxy", "reg", "buffer", "back", "red", "fun", "len", "obj", "rev", "rets", "att", "ext", "ref", "det", "store", "func", "prot", "def", "flag", "re", "fi", "Ret", "expr", "mem", "lit", "arg", "rt", "v"], "arg1": [" arg01", "par01", "argument2", "argone", "arg3", "Arg01", "Arg1", "Arg2", "Arg3", "paramone", "argument1", "par1", "par3", " arg3", "par2", "argumentone", "param1", "argument3", "arg01", "param3", " argone", "param2"], "arg2": ["arg5", "argument2", "arg6", "Arg1", "Arg2", "Arg4", "argument1", "argument4", " arg5", " arg4", "param1", "Arg6", "param6", "arg4", "param4", "Arg5", "argument5", " arg6", "param2"], "opi": ["opz", "operz", "OPc", "opb", " opxi", "ipz", " opb", "hopi", "hopb", "optbi", "operx", "operp", "optx", "hopxi", "ipi", "operbi", "hopx", "ipp", "opti", "OPp", " opz", " opbi", "operi", "optz", "opxi", " opp", "opbi", "OPb", "opc", "opp", "OPx", "ipc", "OPi", " opc", "OPxi", "ipx"], "opx": ["operxe", "opz", "operz", "ropxe", " opxi", "copxi", "copx", "ropx", "Opxi", "operxc", "OPy", "operx", "ropg", "opxe", " opxc", "OPxi", "opy", "copz", "hopz", "Opx", "Opz", "hopx", "copi", "hopxc", "copxc", " opz", " opg", "copg", "hopxe", " opxe", "OPz", " opy", "opxi", "opxc", "OPx", "OPi", "opg", "Opy", "copxe", "ropxc"]}}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16507, "substitutes": {"mon": ["ann", "meter", "bo", "mont", "domain", "mod", "Mon", "mat", "MON", "mu", "dm", "member", "base", "demon", "pm", " monitor", "module", "bm", "atom", "Monitor", "mo", "tom", "danger", "phys", "bro", "dom", "man", "mot", "monitor", "mor", "chron", "part", "mer", "mos", "mr", "login", "mini", "mn", "am", "mc", "un", "mun", "mm", "master", "mag", "mi", "m"], "qdict": [" qdatabase", "sqdict", "eqdict", " qds", " qdirectory", "sqdirectory", "eqds", "questdict", "reqds", "qdirectory", "qstr", " qstr", "queststr", "reqdt", " qdt", "eqdt", "qds", "qdatabase", "sqstr", "reqdict", "questdirectory", "qdt", "sqdatabase", "questdatabase"], "bs": ["cs", "css", "ps", "ports", "bc", "rs", "BS", "js", "bh", "ss", "conn", "bi", "abi", "ns", "bb", "base", "obj", "bm", "bid", "blocks", "ob", "db", "pb", "bits", "vs", "ls", "iss", "us", "bugs", "ba", "aos", "gs", "sb", "bas", "s", "b", "obs", "ubs", "fs", "las", "bytes", "bis", "bal", "ab", "gb", "bos", "ses", "os", "bu", "ins", "Bs", "lb", "bes", "ds", "bl", "fb", "bing"], "bs1": ["bes0", "bs2", "bes2", "osOne", "bas2", "bs3", "bs91", "bc2", "bcone", "lsone", "nsone", "ras91", "BSone", "besone", "bsOne", "bc3", "obs0", "obsone", "b1", "ps0", "BS0", "BS1", "lsOne", "ns91", "rasone", "psOne", "os1", "bc1", "ls1", "ns1", "BSOne", "bs0", "bas0", "ps1", "ras0", "ras1", "obsOne", "bes91", "osone", "bas3", "ns0", "bes1", "psone", "bas1", "bes3", "obs1", "bsone", "b0", "bc0", "bone"], "err": ["dr", "str", "progress", "inner", "rr", "sys", "good", "later", "result", "Er", "runner", "res", "arm", "error", "req", "aster", "lr", "cor", "ir", "rar", "finder", "fee", "ner", "id", "ar", "r", "der", "fr", "ace", "errors", "ee", "ore", "iter", "gr", "ext", "ref", "mr", "ind", "cr", "resp", "er", "Error", "rage", "attr", "erer", "rn", "acer", "ler", "e", "fy", "bug", "ger", "arr", "orr", "order", "fer", "ver", "br"], "name": ["str", "min", "NAME", "ame", "type", "new", "prefix", "parent", "x", "error", "description", "no", "n", "base", "len", "version", "id", "path", "label", "code", "data", "block", "pass", "key", "Name", "b", "desc", "comment", "names", "num", "url", "alias", "nm", "part", "size"]}}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n", "idx": 16521, "substitutes": {"obj": ["class", "bo", "pt", "jp", "inst", "node", "op", "mod", "instance", "po", "js", "parent", "conn", "api", "oa", "org", "off", "n", "lib", "module", "od", "cl", "ob", "tree", "data", "o", "ctx", "ext", "ref", "orb", "object", "nt", "adj", "bot", "pos", "objects", "nb", "attr", "os", "opt", "Obj", "j"], "name": ["class", "min", "NAME", "family", "none", "ame", "option", "new", "prefix", "normal", "style", "node", "parent", "old", "description", "no", "n", "base", "property", "version", "id", "word", "on", "path", "label", "full", "data", "o", "block", "call", "ext", "time", "object", "key", "Name", "missing", "create", "null", "value", "named", "package", "dot", "names", "alias", "unknown", "part", "field", "title", "size"], "type": ["val", "class", "scale", "family", "copy", "none", "rule", "length", "option", "kind", "op", "style", "source", "Type", "t", "rel", "info", "property", "version", "id", "types", "status", "index", "o", "sort", "target", "ype", "call", "ity", "pre", "time", "key", "y", "unit", "pe", "value", "comment", "TYPE", "where", "other", "part", "field", "size", "use"], "get": ["is", "check", "Get", "GET", "give", "gets", "export", "cache", "enable", "del", "access", "make", "view", "show", "parse", "init", "sort", "write", "call", "read", "all", "post", "patch", "create", "apply", "value", "update", "package", "find", "send", "invoke", "pull", "like", "fix", "comp", "field", "use"], "set": ["is", "check", "export", "op", "new", "et", "cast", "enable", "end", "add", "view", "save", "site", "low", "id", "reset", "init", "put", "change", "index", "sort", "write", "call", "read", "key", "store", "create", "apply", "value", "Set", "update", "sign", "send", "en", "un", "start", "open", "push", "size", "use"], "release": ["hide", "accept", "resource", "scale", "none", "fire", "range", "complete", "leases", "enable", "raise", "access", "scope", "rel", "view", "save", "version", "id", "require", "offset", "released", "sort", "write", "lease", "loc", "ref", "close", "move", "ignore", "create", "update", "package", "delete", "lock", "Release", "exclusive", "open", "launch", "rate", "use"], "opaque": ["opasso", "copity", "copacity", "opque", "opaco", "pity", "opaques", "catque", "paque", "operacity", "opac", "cataco", "copaques", "operac", "operasso", "operity", "opity", "paco", "opacity", "pacity", "catasso", "copaque", "spaques", "operque", "spac", "copque", "spacity", "spaque", "cataque", "copaco", "operaques", "operaque", "copasso", "copac", "operaco"], "errp": ["errpc", "erf", "errP", "rrfp", " errf", " errc", "rrf", "erP", "ErP", "rrc", "erpc", "errf", "erp", "Erpc", "erc", "erfp", "rrp", " errpc", "Erp", " errfp", "errfp", " errP", "errc", "Erc"], "prop": ["val", "cp", "class", "phi", "project", "f", "option", "cat", "proc", "ps", "jp", "node", "op", "buf", "mod", "parent", "it", "pot", "np", "root", "property", "or", "peer", "plugin", "pod", "config", "cop", "init", "pb", "data", "doc", "target", "meta", "typ", "conf", "gen", "ref", "object", "p", "var", "pos", "tmp", "key", "b", "def", "pointer", "properties", "pkg", "value", "cfg", "priv", "Prop", "pred", "attr", "fi", "cmp", "term", "opt", "pro", "dest", "rop", "mp", "foo", "lit", "part", "comp", "pr", "j", "info"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n", "idx": 16524, "substitutes": {"machine": ["self", "server", "project", "M", "session", "template", "database", "hard", "node", "instance", "motion", "page", "connection", "base", "message", "boot", "controller", "module", "slave", "state", "user", "parse", "sm", "computer", "Machine", "space", "data", "mount", "mac", "app", "game", "object", "loader", "cpu", "mobile", "part", "service", "sim", "process", "comment", "home", "m", "image", "mini", "vm", "mc", "l", "model", "bug", "device", "mom", "manager", "host", "mode"], "cpu_model": [" cpu_address", " cpu_length", "pu_model", "cpu1model", "gpu_length", "gpu_mode", "cpulexaddress", "cpusmodel", " cpu_Model", "cpu1length", "cpusfile", "cpu_mode", "cpu_size", "cpu1mode", "cpu1system", "cpussize", "pu_size", "cpu_address", "cpu_system", " cpu_size", "mem_language", "pu_mode", "cpu_view", " cpu_mode", "cpuadlength", "cpulexModel", "mem_model", " cpu_file", "gpu_system", "cpuslength", "gpu_model", "cpulexmodel", "cpu_length", "cpu_language", "cpu_file", "cpuadmodel", "cpuadsystem", "cpulexmode", "cpu_Model", "pu_view", "mem_mode", "cpuadmode"], "kernel_filename": ["kernel___username", "contextmdatabase", "kernel_name", "kernellfilename", "kernel_source", "context_description", "kernel\u00b7maximum", "cache_filename", "kernelMdescription", "context_directory", "kernelmdescription", "kernellocklength", "kernel_database", "interface_source", "interfacelsource", "cachefulllength", "kernelnfilename", "kernel_username", "kernel_maximum", "kernel\u00b7label", "kernel___filename", "context_database", "kernelMdirectory", "kernelnname", "kernelfulllength", "kernellname", "kernellockfilename", "kernelfullmaximum", "cachefullfilename", "contextmdescription", "kernel\u00b7filename", "cache_label", "kernelMfilename", "kernel_size", "interface_name", "kernel_directory", "cachefullmaximum", " kernel_size", "cache_length", "contextmdirectory", "interfacelfilename", "kernelmdirectory", "kernelMdatabase", "contextmfilename", "interfacelname", "kernel_description", " kernel_username", "kernel_label", "kernelfulllabel", "cache_maximum", " kernel_source", "kernel___size", "cachefulllabel", "kernelnsource", "kernelmdatabase", "kernellsource", "interface_description", "kernelndescription", "kernellocklabel", "kernel___source", "kernellockmaximum", "kernelfullfilename", "kernelmfilename", "interfaceldescription", "interface_filename", "context_filename", "kernelldescription", "kernel_length", "kernel\u00b7length"], "kernel_cmdline": ["kernel\u00b7coststyle", "kernel_coststyle", "kernel\u00b7cmdline", "kernel_cklin", "kernel_pathne", "kernel_rawword", "kernel\u00b7cmdword", "kernel_cmdue", "kernel_commandline", "kernel_ckfile", "kernel_cmdfile", "kernel_pathstyle", "kernel_rawne", "kernel_cmdlin", "kernel_defue", "kernel_cmdne", "kernel_classrange", "kernel_ctxline", "kernel_gradside", "kernel_costword", "kernel_classline", "kernel_commandside", "kernel_costline", "kernel_methodline", "kernel_defline", "kernel_ckue", "kernel_commandlock", "kernel_gradl", "kernel_pathword", "kernel_cmdstyle", "kernel_cmdrange", "kernel_cmdl", "kernel_programlock", "kernel\u00b7cmdstyle", "kernel_cmdside", "kernel_ctxfile", "kernel_methodlock", "kernel_ckline", "kernel_programside", "kernel_deffile", "kernel_cmdword", "kernel_rawline", "kernel_rawstyle", "kernel_classlock", "kernel_costne", "kernel\u00b7costword", "kernel_deflin", "kernel_commandrange", "kernel_gradlock", "kernel_methodrange", "kernel\u00b7cmdne", "kernel_programl", "kernel\u00b7costline", "kernel_programline", "kernel_pathline", "kernel_ctxue", "kernel_commandl", "kernel\u00b7costne", "kernel_cmdlock", "kernel_gradline", "kernel_ctxlin"], "initrd_filename": ["initrs_password", "initrd_Filename", "initradPFilename", "initrd2required", "initrt_required", "initrdlockFilename", "initrdJforward", "initradPfilename", "initrd_location", "initrdxtail", "initrt_name", "initrt_filename", "initrd2name", "initrdPfilename", "initrdJlocation", "initrd_required", "initdd_filename", "initrd_forward", "initrt_width", "initradPforward", "initrd_password", "initrd2filename", "initrdUfil", "initrdJFilename", "initrdlockfilename", "initrdUusername", "initrd_width", "initrd_name", "initradPlocation", "initrad_location", "initrdUtail", "initrad_forward", "initrd2width", "initrd_tail", "initrdUfilename", "initrdxusername", "initrd_fil", "initrs_filename", "initrdPforward", "initrdxfilename", "initrdlockpassword", "initrdJfilename", "initdd_tail", "initrdPlocation", "initrd_username", "initdd_username", "initdd_fil", "initrad_filename", "initrdPFilename", "initrdxfil", "initrad_Filename", "initrs_Filename"], "s": ["is", "cs", "server", "sf", "sys", "session", "sa", "f", "sp", "ps", "less", "ds", "rs", "t", "ss", "sq", "ns", "info", "n", "si", "state", "o", "gs", "sk", "c", "sb", "p", "y", "service", "ks", "ssl", "b", "sl", "su", "fs", "services", "S", "states", "sg", "ses", "e", "os", "sym", "se", "spec", "sync", "m"], "dinfo": ["dlinit", "dinner", "mdapi", "derror", " dfo", "sdinner", "dayinfo", "dbignore", "dayapi", "dnconf", " derror", "phand", "papi", "ddi", "dayfo", "binner", "bignore", "dfo", "sderror", "ffo", "dbinfo", "dinf", "pinfo", "pinf", " dwork", "dlsi", "bhand", "dhand", "finf", "sdinfo", "sdwork", "pfo", "mdinfo", "dninfo", "sddi", "drapi", "sdinf", "pignore", "ndinfo", "dbinf", "drfo", "dlconf", "dnsi", "mdfo", "dignore", "drinfo", "binfo", "binf", "dbhand", " dinit", "bdi", "nddi", "dninit", " dconf", "sdignore", "dconf", "fapi", "dapi", "dlinfo", " dinf", "ndignore", "dwork", "pwork", "ndinner", "dinit", "dsi", " dsi", "finfo", "drinf", "mdinf", "dayinf", " dapi"], "sysmem": ["sysreg", "systemram", "sreg", "systemlim", "smemory", "sysmemory", "systemmem", "systemdem", "ssreg", "csdem", "cslim", "systemreg", "slim", " sysram", "smem", "ssmemory", " sysdem", "systemmemory", "csmem", "sysdem", "ssmem", "csram", "sysram", " syslim", "syslim", "sslim"]}}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)\n\n{\n\nPOWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);\n\n#ifdef ALTIVEC_USE_REFERENCE_C_CODE\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));\n\n      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));\n\n      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));\n\n      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#else /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;\n\n    register vector unsigned char perm = vec_lvsl(0, pixels);\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      pixelsv1 = vec_ld(0, (unsigned char*)pixels);\n\n      pixelsv2 = vec_ld(16, (unsigned char*)pixels);\n\n      blockv = vec_ld(0, block);\n\n      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);\n\n      blockv = vec_avg(blockv,pixelsv);\n\n      vec_st(blockv, 0, (unsigned char*)block);\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#endif /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n}\n", "idx": 16536, "substitutes": {"block": ["batch", "bit", "section", "header", "inner", "check", "none", "Block", "length", "number", "clock", "range", "type", "name", "frame", "work", "x", "prefix", "off", "buffer", "point", "no", "ip", "position", "chain", "blocks", "cl", "panel", "label", "address", "year", "index", "padding", "pack", "byte", "square", "loc", "time", "height", "channel", "line", "limit", "pixel", "unit", "filter", "patch", "keep", "pos", "slice", "group", "image", "month", "lock", "blocking", "wall", "num", "row", "network", "device", "ack", "random", "mask", "layer", "bl", "sync"], "pixels": ["aports", "ppipers", "apixels", "cipes", " pipers", "bores", "ipores", "compamples", "camples", "peters", " powers", "npixel", "ppixel", " pels", "Pips", "ppels", "ppips", "apamples", "pix", " pixel", "spixels", "pipes", "bonents", "bowers", " pipes", "hows", "cix", "npix", "borts", "ponents", "powers", "Pipers", "piles", "apeters", "pamples", "compels", "Pixels", " ponents", "Pipes", "bixels", "spipers", " peters", "pores", "Pamples", "apixel", "spamples", "apips", "ciles", "bamples", "npixels", "pips", "ppixels", "pows", "compows", "npips", "cixels", "spowers", "sponents", "pixel", "pels", "cips", " ports", "Pels", "compixels", "hels", "Ponents", "pipers", " piles", "hixels", " pows", "ports", " pamples", "iponents", "aponents", "ipamples", "ipixels", "speters", " pips", "cixel", "apix", " pores", "hamples", "ppiles", "apowers"], "line_size": ["lineLogwhite", "page2size", "page_small", "line_SIZE", "lineLogscale", "double_white", "field_size", "lineLogclean", "lineLogheight", "doubleLogwhite", "line64number", "line2size", "line2shape", "line6SIZE", "lineAnumber", "double_number", "line_number", "line_shape", "line6size", "line_small", "line2SIZE", "line_white", "line_height", "line2small", "doubleLogsize", "page2small", "field_scale", "line_scale", "lineAwhite", "line6small", "line6shape", "fieldLogclean", "fieldLogsize", "line64height", "lineLognumber", "double_size", "fieldLogscale", "page_SIZE", "doubleLognumber", "doubleLogheight", "lineLogshape", "line64white", "lineAsize", "page2SIZE", "page_size", "fieldLogshape", "field_shape", "page2shape", "line64size", "double_height", "lineAheight", "field_clean", "lineLogsize", "line_clean", "page_shape"], "h": ["HH", "header", "f", "length", "x", "u", "sh", "t", "bh", "q", "end", "d", "rh", "n", "H", "ch", "r", "o", "w", "c", "k", "height", "p", "y", "hp", "b", "z", "hh", "en", "num", "e", "l", "hs", "hm", "ht", "v", "j", "m"], "i": ["phi", "di", "inner", "my", "f", "xi", "hi", "x", "u", "ix", "qi", "ci", "li", "in", "dim", "eni", "bi", "it", "mu", "uri", "d", "ji", "info", "n", "ip", "ti", "I", "pi", "si", "multi", "id", "code", "r", "ai", "index", "chi", "iu", "init", "o", "ii", "c", "k", "p", "s", "y", "b", "z", "mini", "ui", "image", "ni", "gi", "ami", "fi", "lock", "e", "l", "a", "io", "im", "ie", "ini", "v", "mi", "j", "m"], "pixelsv1": ["pixelsvron", "pipersV2", "pixelsVron", "pixelsV3", "pixelssv3", "pipersV1", "pixelsV1", "pixelsversion2", "pixelssv2", "pixelsversion1", "pipersv3", "pipersvron", "pixelsV2", "pixelsversion3", "pipersv1", "pipersv2", "pixelssv1", "pipersV3", "pixelsv3", "pixelsversionron", "pipersVron"], "pixelsv2": ["pixelsu1", "pixelsev4", "pixelsv4", "pixelsiv2", "pipersV0", "pipersV2", "pipersv0", "pipsV4", "pipersV1", "pixelsV1", "pixelsu4", "pixelsiv4", "pipsv1", "pipsv4", "pixelsev1", "pixelsev2", "pixelsv0", "pixelsV2", "pixelsu2", "pipsV0", "pixelsV8", "pixelsev0", "pixelsu8", "pixelsv8", "pipersV4", "pipersv4", "pipsV1", "pipersv1", "pipsV2", "pipersv2", "pipsv0", "pixelsV4", "pipsv2", "pipsv8", "pixelsiv1", "pixelsiv0", "pixelsV0"], "pixelsv": ["pipsb", "pipsh", " pixelsve", "pipersb", "Pipsb", " pixelsV", "pipersV", "PixelsV", "pipsvi", "pixelv", " pipsve", "Pipsv", "pipersv", "piconsve", "pixelsve", " pipsvi", "pipsV", "pixelsb", "piconsv", "pixelsvi", "pixelb", "piconsV", " pipsV", "ppagesvi", "Pixelsh", "pipsv", " pixelsvi", "Pixelsb", "pixelh", "Pixelsv", "ppagesV", "pipersh", "PipsV", "ppagesve", "ppagesv", "pipsve", " pipsv", "piconsvi", "Pipsh", "pixelsh", "pixelsV", "pixelV"], "blockv": ["diskc", "wallv", "lock\n", "blockc", "blockf", "boxv", "boxm", "wallc", " blockV", "boxu", "diskh", " blocku", "maskv", "maskV", "Blockc", "lockc", "lockV", "maskf", "chain\n", "blocku", "lockv", "boxc", " blockh", "maskc", "lockf", " blockm", "Blockv", "diskv", "wallu", "blockV", " blockf", " blockc", "BlockV", "wallm", "Blockh", "blockh", "blockm", "diskV"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n", "idx": 16542, "substitutes": {"blkdev": ["belokdevice", "blkdevice", "blakdevice", "plkdevice", "plktdev", "Blkdevice", "Blbdevice", "blkev", "blokev", "belkdiv", "plkdev", "belokdev", "Blbconn", "Blckdevice", "blkdiv", "blokDev", "Blkdiv", "blckprom", "blokconn", "blkprom", "Blkprom", "blckdiv", "blukprom", "plktprom", "plktdevice", "Blckdiv", "blkDev", "blktev", "Blbdev", "Blkdev", "blokprom", "blktdiv", "blktdevice", "blckdevice", "blakdev", "blbdev", "Blkconn", "blokdiv", "Blckprom", "blkconn", "blbdevice", "plktev", "blakDev", "blktprom", "belkdev", "blbDev", "blokdev", "Blckdev", "blokdevice", "blukdevice", "blukdev", "blckdev", "BlkDev", "blukdiv", "blktdev", "belkdevice", "blakconn", "blukev", "plkprom", "blbconn", "belokdiv", "plkev", "BlbDev"], "ioreq": ["ioorck", "iorestqu", "ioserarch", "iosequest", "pioreid", "atiorec", "iniorel", "ioresv", "pioserid", "ioryq", "ioresc", "iourq", "iosec", " ioresquest", "ioserq", "ioseq", " ioreqs", "piorearch", "ioresqs", "iorestqs", "ioryc", "atioryq", "ioresquest", "ioreqs", "iouqual", "iouc", "ioyid", "ioredl", "ioreck", " ioseq", "ioryqs", "ioredq", "iorearch", "ioserid", "ioserck", "ioryqual", " iorec", "ioriid", "iorick", "iorequal", "pioreq", "iorequ", " iosequ", "atioreqs", "atiorequal", "ioyq", "iourquest", "pioserck", "atioryqual", "iorev", "pioreck", "ioriq", " iorequest", "ioorq", "iorestquest", "ioriarch", "iorec", "iniorequest", "atioryqs", "iouq", "iosel", "inioreq", " ioseqs", "inioredck", "iosev", "inioreck", " iorev", "iorestq", "ioroqu", "ioyck", " ioresv", "inioredquest", "ioorquest", "ioresqual", " ioresq", "ioresq", "iourv", "iouqs", "inioredl", "ioroqs", "ioyarch", "ioseck", "ioorl", "atioryc", "iorequest", "atioreq", "ioredck", "iourc", "ioroquest", "ioreid", " iosequest", " iorequ", "ioroq", "iorel", "iosequ", " ioresc", "pioserq", "inioredq", "ioredquest", "ioseqs", "pioserarch"]}}
{"project": "qemu", "commit_id": "6c7565028c272c4c6f2a83c3a90b044eeaf2804a", "target": 0, "func": "static int interface_client_monitors_config(QXLInstance *sin,\n\n                                        VDAgentMonitorsConfig *monitors_config)\n\n{\n\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n\n    QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);\n\n    int i;\n\n    unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);\n\n\n\n    if (qxl->revision < 4) {\n\n        trace_qxl_client_monitors_config_unsupported_by_device(qxl->id,\n\n                                                               qxl->revision);\n\n        return 0;\n\n    }\n\n    /*\n\n     * Older windows drivers set int_mask to 0 when their ISR is called,\n\n     * then later set it to ~0. So it doesn't relate to the actual interrupts\n\n     * handled. However, they are old, so clearly they don't support this\n\n     * interrupt\n\n     */\n\n    if (qxl->ram->int_mask == 0 || qxl->ram->int_mask == ~0 ||\n\n        !(qxl->ram->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {\n\n        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,\n\n                                                            qxl->ram->int_mask,\n\n                                                            monitors_config);\n\n        return 0;\n\n    }\n\n    if (!monitors_config) {\n\n        return 1;\n\n    }\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n    /* limit number of outputs based on setting limit */\n\n    if (qxl->max_outputs && qxl->max_outputs <= max_outputs) {\n\n        max_outputs = qxl->max_outputs;\n\n    }\n\n#endif\n\n\n\n    memset(&rom->client_monitors_config, 0,\n\n           sizeof(rom->client_monitors_config));\n\n    rom->client_monitors_config.count = monitors_config->num_of_monitors;\n\n    /* monitors_config->flags ignored */\n\n    if (rom->client_monitors_config.count >= max_outputs) {\n\n        trace_qxl_client_monitors_config_capped(qxl->id,\n\n                                monitors_config->num_of_monitors,\n\n                                max_outputs);\n\n        rom->client_monitors_config.count = max_outputs;\n\n    }\n\n    for (i = 0 ; i < rom->client_monitors_config.count ; ++i) {\n\n        VDAgentMonConfig *monitor = &monitors_config->monitors[i];\n\n        QXLURect *rect = &rom->client_monitors_config.heads[i];\n\n        /* monitor->depth ignored */\n\n        rect->left = monitor->x;\n\n        rect->top = monitor->y;\n\n        rect->right = monitor->x + monitor->width;\n\n        rect->bottom = monitor->y + monitor->height;\n\n    }\n\n    rom->client_monitors_config_crc = qxl_crc32(\n\n            (const uint8_t *)&rom->client_monitors_config,\n\n            sizeof(rom->client_monitors_config));\n\n    trace_qxl_client_monitors_config_crc(qxl->id,\n\n            sizeof(rom->client_monitors_config),\n\n            rom->client_monitors_config_crc);\n\n\n\n    trace_qxl_interrupt_client_monitors_config(qxl->id,\n\n                        rom->client_monitors_config.count,\n\n                        rom->client_monitors_config.heads);\n\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);\n\n    return 1;\n\n}\n", "idx": 16566, "substitutes": {"monitors_config": ["monagers_storage", "monitorsscache", "monitors2control", "monitors_ref", "monetersaccontrol", "monitorsurecom", "monitorsallcom", "monitorsfref", "monpots_cfg", "monitorsallref", "monors_service", "monors_config", "monitorsallsource", "monagers_settings", "monters_data", "monitors_storage", "monitors_service", "monters_config", "monitors_source", "monitorsacconn", "monitors_settings", "monitors_conn", "monetersacconfig", "monitorsallstorage", "monpots_source", "monagers_config", "monpots_com", "monitors_cache", "monitorsaccontrol", "monitorsuresource", "monitorsallconfig", "monuments_cache", "monitorsfconfig", "moneters_output", "monpotsurecfg", "monitorsallcfg", "moneters_config", "monitors2output", "monitors_cfg", "monitors2data", "monitorsacdata", "monitors2conn", "monitors_fig", "monitors_com", "monpotsuresource", "monagers_ref", "monitors_output", "monpotsurecom", "monitorsfsettings", "moneters_conn", "monuments_config", "monors_cache", "monitors2fig", "monetersacoutput", "monitors2config", "monetersacconn", "monters_fig", "monitors_data", "monitorsacconfig", "monitorssservice", "monpotsureconfig", "monors_conn", "monitorssconn", "monitorsurecfg", "monitorsureconfig", "monitorsallsettings", "monuments_man", "monitors_man", "monitorssconfig", "monitors_control", "monpots_config", "monitorsacfig", "monitorsfstorage", "monitorsacoutput", "moneters_control"], "qxl": ["Qtxls", "qexL", "qulexle", "viewxls", "qxli", "qpxlc", "qxxr", "qexl", "qxle", "quxtrl", "qzln", "qxxel", "qyls", "qmxd", "qxcla", "sqzll", "qaxd", "qexlc", "queryxli", "sqxell", "qctl", "qxlc", "qtxL", "qxxd", "quxdl", "quaxv", "qzxll", "qxxli", "qxxl", "queryaxel", "sqvl", " qaxL", "sqzl", " qxsl", "queryxel", "qaxv", "qxrl", "quxel", "qzl", "quxtel", "qxeslp", "quxlp", "kexl", " qaxl", "kxl", " qxll", "qpxle", "qvli", "qmxl", "kxlp", "sqxl", "qwwel", "queryxll", "qzll", "queryzli", "quxdls", " qaxll", "Qxls", "qaxls", "qctls", "qxtl", "quaxl", "qxcl", "qdxr", "qxll", "qlexl", "sqxr", "qvl", "qxv", "qwwl", "qylp", "qoxll", "qxxlc", "qrexli", "qxls", "kexlp", "quxle", "qwxr", "viewxr", " qxle", "qxesdl", "qzxli", "qtxls", "qxdl", " qpxle", "qzli", "qdxll", "querypxr", "quaxel", "qpxr", " qxlc", "qxxll", "qtxle", "qxdls", "qulexdl", "qxesll", "qxxsl", "qzla", "qmxll", "qulexlp", " qpxl", "qctdl", "qrexll", "qxesle", "quxls", "qxell", "qpxl", "qwxl", "qdxln", "qwwla", "QxL", "quxll", "sqzln", "qdxl", "sqzr", "qmxv", "qlexdl", "qaxl", "kxls", "queryaxll", "qxcli", "qaxll", "qxxdl", "quaxd", "qxesl", "queryxle", "qexlp", "qvel", "qfxls", "quxdll", "viewuxli", " qxL", "Qxl", "qmxel", "qxla", "qlexle", "querypxle", "qoxsl", "qxel", "qxcll", "qwxla", "qxxlp", "qlexlp", "quxli", "qzr", " qpxlc", "qoxl", "queryxla", "qxlp", "qoxel", "quxddl", "qXL", "sqvli", "qrexell", "qoxell", "Qxlc", "qyl", " qaxsl", "qfxle", "sqxli", "sqxel", "sqvel", "qwxll", "queryzl", "qwwll", " qxli", "qwxel", "qXlc", "qpxli", "qwxli", "querypxli", "quxtl", "qxddl", "Qtxl", "qyll", "qfxl", "qaxla", "qxL", "viewuxr", "qwxln", "qaxsl", "qfxli", "quxd", "qyli", "qxtrl", "qulexl", "qzxl", "sqxll", "qzxrl", "qmxli", "qXls", "queryxl", "queryaxl", "quxrl", "qtxl", "qXl", " qpxli", "Qtxlc", "qxtli", "qoxli", "sqvell", "qtxli", "qxtll", "qxdll", "qfxr", "queryxr", "viewuxl", "qxsl", "qxr", "qyla", "queryzll", "qexls", "quxv", "qaxli", "qxesls", "viewuxls", "qaxr", "qctll", "quxtll", "qaxel", "qrexrl", "quxtli", "qaxL", "QtxL", "qoxL", "qxln", "kexls", "quxl", "qxtel", "queryaxla", "qvell", "qxd", "sqxln", "querypxl", "quxr", "qtxlc", "qxxle", "queryzla", "qxxL", "viewxli", "qrexel", "qrexl", "qxxv", "viewxl"], "rom": ["lim", "container", "resource", "rock", "rec", "cm", "prom", "coll", "client", "rome", "drm", "ov", "chrom", "cmd", "ro", "rim", "mod", "ray", "com", "rov", "param", "arm", "rm", "ran", "reg", "rar", "chrome", "iam", "ros", "rog", "roy", "rem", "ra", "rum", "co", "ram", "rx", "sam", "roman", "ROM", "camp", "mor", "gram", "irm", "RM", "prem", "cpu", "Rom", "crypt", "roc", "cr", "rg", "sim", "dem", "rc", "RAM", "mem", "rn", "norm", "pro", "mm", "remote", "im", "rob", "mode"], "i": ["phi", "di", "f", "ri", "xi", "cli", "qi", "ix", "x", "ci", "li", "abi", "t", "ji", "bi", "mu", "uri", "mi", "ip", "I", "pi", "si", "multi", "index", "ai", "chi", "iu", "o", "ii", "k", "p", "y", "ind", "b", "slice", "mini", "ui", "ni", "gi", "zi", "count", "ami", "fi", "yi", "e", "attr", "l", "a", "io", "oi", "ini", "v", "ti", "j", "m"], "monitor": ["resource", "meter", "client", "number", "command", "report", "type", "runner", "param", "connection", "member", "watch", "message", "record", "metadata", "Monitor", "control", "program", "block", "unit", "service", "handler", "attr", "network", "port", "device", "username", "manager"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);\n\n\n\n    /*\n\n     * virtio pci bar layout used by default.\n\n     * subclasses can re-arrange things if needed.\n\n     *\n\n     *   region 0   --  virtio legacy io bar\n\n     *   region 1   --  msi-x bar\n\n     *   region 4+5 --  virtio modern memory (64bit) bar\n\n     *\n\n     */\n\n    proxy->legacy_io_bar  = 0;\n\n    proxy->msix_bar       = 1;\n\n    proxy->modern_io_bar  = 2;\n\n    proxy->modern_mem_bar = 4;\n\n\n\n    proxy->common.offset = 0x0;\n\n    proxy->common.size = 0x1000;\n\n    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;\n\n\n\n    proxy->isr.offset = 0x1000;\n\n    proxy->isr.size = 0x1000;\n\n    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;\n\n\n\n    proxy->device.offset = 0x2000;\n\n    proxy->device.size = 0x1000;\n\n    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;\n\n\n\n    proxy->notify.offset = 0x3000;\n\n    proxy->notify.size =\n\n        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;\n\n    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus) &&\n\n        !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    } else {\n\n        /*\n\n         * make future invocations of pci_is_express() return false\n\n         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.\n\n         */\n\n        pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n", "idx": 16585, "substitutes": {"pci_dev": ["pci0dev", "pciaddevices", "pci_devices", "pci_def", "ppi_dem", "pki_devices", "pki_mod", "pciaddev", "ppi_dev", "ppi_ev", "ppi_div", "pki_device", "pci_div", "pcixdevice", "pci0mod", "pci0def", "pki_def", "pciaddevice", "pci_ev", "pki_ev", "pki_orig", "pci_device", "pcixdev", "pcixorig", "pci_mod", "pcixev", "pci0device", "pci_orig", "pciadorig", "pci_dem", "pki_dev"], "errp": ["errpc", "rorp", "nerproc", "rorpb", "rorpc", "nerpc", " errpb", "nerp", " errproc", "rorproc", "nerpb", "errpb", "errproc", " errpc"], "proxy": ["client", "component", "session", "match", "ship", "cache", "connection", "pool", "child", "plugin", "zip", "play", "XY", "cop", "byte", "phone", "engine", "roxy", "profile", "socket", "image", "docker", "PRO", "ube", "pin", "server", "copy", "project", "http", "queue", "instance", "linux", "force", "lib", "forward", "index", "p", "coe", "wrapper", "fax", "phy", "port", "alias", "model", "shield", "plus", "ghost", "clone", "sync", "route", "oe", "web", "fuel", "ip", "base", "config", "module", "address", "pa", "query", "remote", "serial", "resource", "library", "Proxy", "back", "root", "facebook", "pse", "ping", "callback", "bridge", "service", "pe", "slice", "gp", "request", "driver", "reverse", "reference", "que", "shadow"], "k": ["g", "core", " self", "kin", "client", "f", "http", "ck", "kind", "cache", "K", "lass", "connection", "child", "module", "cl", " c", "o", "ec", "sk", "c", "cc", "key", "ks", "ko", "kernel", "C", "j"]}}
{"project": "FFmpeg", "commit_id": "cf6914e27f14cf2b5a66e25f5cf3549ceabb1648", "target": 0, "func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *data_size, AVPacket *pkt)\n\n{\n\n    CDXLVideoContext *c = avctx->priv_data;\n\n    AVFrame * const p = &c->frame;\n\n    int ret, w, h, encoding, format, buf_size = pkt->size;\n\n    const uint8_t *buf = pkt->data;\n\n\n\n    if (buf_size < 32)\n\n        return AVERROR_INVALIDDATA;\n\n    encoding        = buf[1] & 7;\n\n    format          = buf[1] & 0xE0;\n\n    w               = AV_RB16(&buf[14]);\n\n    h               = AV_RB16(&buf[16]);\n\n    c->bpp          = buf[19];\n\n    c->palette_size = AV_RB16(&buf[20]);\n\n    c->palette      = buf + 32;\n\n    c->video        = c->palette + c->palette_size;\n\n    c->video_size   = buf_size - c->palette_size - 32;\n\n\n\n    if (c->palette_size > 512)\n\n        return AVERROR_INVALIDDATA;\n\n    if (buf_size < c->palette_size + 32)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp < 1)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp > 8) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    if (format) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)\n\n        return AVERROR_INVALIDDATA;\n\n    if (!encoding && c->palette_size && c->bpp <= 8) {\n\n        avctx->pix_fmt = PIX_FMT_PAL8;\n\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n\n        if (c->palette_size != (1 << (c->bpp - 1)))\n\n            return AVERROR_INVALIDDATA;\n\n        avctx->pix_fmt = PIX_FMT_BGR24;\n\n    } else {\n\n        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",\n\n                              encoding, c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    p->reference = 0;\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (encoding) {\n\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n\n                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!c->new_video)\n\n            return AVERROR(ENOMEM);\n\n        if (c->bpp == 8)\n\n            cdxl_decode_ham8(c);\n\n        else\n\n            cdxl_decode_ham6(c);\n\n    } else {\n\n        cdxl_decode_rgb(c);\n\n    }\n\n    *data_size      = sizeof(AVFrame);\n\n    *(AVFrame*)data = c->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 16602, "substitutes": {"avctx": ["alcontext", "abcontext", "navhw", "alctx", "avcci", "groundcms", "afcms", "afctrl", "avcu", "avcv", "AVc", "navconn", "aveloc", "groundctx", "ajcontext", "avecf", "groundcci", "avconn", "avectx", "avcontext", "afconn", "avcb", "avctrl", "verctx", "AVctx", "alcp", "avecontext", "abctrl", " avcms", "AVcontext", "afcci", " avcoll", "ajctrl", " avconfig", "aucontext", "groundcontext", "verloc", "afcontext", "avcoll", "avc", "navcp", "avecp", "abctx", "axctx", "alsync", "axconfig", "avloc", "avconfig", "afcb", "vercf", "avctl", "afcoll", "avecoll", "avcp", "avecv", "afcf", "afcu", "avcas", "ajcu", "afcp", "avectl", "afconfig", "axcontext", "afctl", "AVconn", "navcontext", " avcv", "afctx", "afcas", "avecb", "afcv", " avcontext", " avcas", "avec", "avhw", "auctx", "ajctx", "aucb", "avesync", " avcci", "avcf", "vercontext", "avsync", "navctx", "abcu", "avcms", "afhw", "afsync", "auctl", "afc", "aveconn", "afloc", "avehw", "axcas"], "data": ["batch", "val", "f", "x", "cache", "frame", "media", "array", "DATA", "window", "pad", "ad", "buffer", "d", "board", "video", "base", "Data", "message", "config", "memory", "code", "input", "body", "channel", "pos", "da", "response", "content", "value", "slice", "audio", "image", "bytes", "dat", "start", "a", "device", "buff", "v", "size", "m"], "data_size": ["datablockcapacity", "data_capacity", "data_source", " data_capacity", "datablockexternal", "data_external", " data_external", "datablocksize", " data_source", "datablocksource"], "pkt": ["spft", "packet", "spct", " packet", " piece", "pqt", "Pkt", "Pkg", "Pft", "pct", "fkt", "Packet", "facket", "pft", " pct", "cpkt", " pkg", "fqt", "spacket", "cpkg", " pft", "pkg", "cpacket", "cpqt", " pqt", "cpiece", "fkg", "spkt", "Piece", "Pct", "piece"], "c": ["g", "self", "coll", "dc", "x", "cache", "ci", "or", "cl", "code", "conf", "cf", "vc", "b", "content", "cr", "z", "context", "sec", "ctrl", "m", "can", "container", "cd", "cm", "nc", "u", "col", "i", "oc", "s", "current", "abc", "arc", "l", "cu", "cp", "f", "cat", "pc", "uc", "bc", "n", "config", "o", "ctx", "lc", "cc", "ct", "rc", "C", "spec", "cs", "unc", "ac", "cur", "t", "d", "ch", "enc", "co", "con", "ec", "ca", "ce", "k", "ic", "cy", "tc", "mc", "e", "anc", "xc", "sc", "v"], "p": ["g", "cp", "f", "pt", "pc", "pd", "u", "t", "d", "py", "pool", "n", "pi", "i", "r", "pb", "vp", "o", "P", "fp", "pe", "b", "l", "a", "v", "m"], "ret": ["RET", "val", "reply", "f", "cat", "get", "result", "match", "alt", "gc", "res", "success", "reg", "back", "error", "len", "fun", "mt", "ut", " RET", "status", "code", "r", "img", "rets", "att", "ext", "ref", "det", "nt", "al", "def", "resp", "re", "flag", "value", "en", " Ret", "ft", "num", "Ret", "mem", "bad", "arr", "arg", "rt", "info"], "w": ["g", "ow", "f", "wt", "x", "u", "work", "t", "wh", "q", "sw", "d", "wb", "n", "we", "hw", "fw", "aw", "r", "win", "o", "ew", "wd", "height", "k", "s", "kw", "y", "b", "wal", "z", "weight", "e", "l", "wo", "wa", "W", "v", "size", "m"], "h": ["f", "hi", "x", "u", "ul", "oh", "sh", "t", "q", "bh", "uh", "d", "rh", "n", "H", "o", "hr", "help", "height", "k", "ha", "y", "gh", "b", "ih", "z", "hd", "en", "e", "l", "ph", "hs", "wa", "ah", "hm", "ht", "v", "size"], "encoding": ["encaching", "enryption", "enording", "enhryption", "ecaging", "ecasing", "encording", "Encaching", "decoder", "enhasing", "enasing", "decaming", "encryption", "encaging", "Encoding", "incaching", "Encoder", "encaming", "enhording", "incoding", "Encasing", "decoding", "incaging", "decasing", "encasing", "Encaging", "ecoding", "engoder", "ecaching", "engasing", "enhoding", "engaming", "enoding", "engoding", "Encryption", "Encording", "encoder", "incasing", "Encaming"], "format": ["scale", "html", "family", "f", "layout", "option", "length", "mode", "template", "type", "name", "frame", "feat", "prefix", "op", "style", "t", "flat", "api", "form", "quality", "magic", "len", "version", "direction", "position", "frequency", "support", "platform", "padding", "year", "Format", "qt", "language", "file", "unit", "letter", "at", "package", "fn", "area", "filename", "term", "ant", "method", "crop", "v", "theme", "size", "offset"], "buf": ["batch", "lim", "header", "vec", "bd", "f", "uv", "src", "uf", "proc", "cmd", "uc", "bc", "queue", "feat", "array", "cur", "bh", "pad", "buffer", "wb", "conv", "coord", "comb", "fun", "len", "config", "aux", "ff", "pb", "img", "cas", "block", "ctx", "grab", "cap", "loc", "rb", "cf", "fp", "bag", "cv", "wav", "func", "b", "home", "context", "alloc", "cb", "num", "ab", "seq", "gb", "count", "port", "bu", "que", "fam", "box", "buff", "utf", "v", "fb", "br"]}}
{"project": "FFmpeg", "commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "target": 1, "func": "static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)\n\n{\n\n    uint32_t opcode_size, offset;\n\n    uint8_t *dst, *dend, mask = 0, color = 0;\n\n    const uint8_t *src, *send, *opcodes;\n\n    int i, j, op = 0;\n\n\n\n    i = bytestream2_get_byte(&c->gb);\n\n    if (i) {\n\n        if (code & 0x10) {\n\n            int align;\n\n\n\n            align = bytestream2_tell(&c->gb) & 3;\n\n            if (align)\n\n                bytestream2_skip(&c->gb, 4 - align);\n\n        }\n\n        do {\n\n            int page, val, x, y;\n\n            val    = bytestream2_get_be16(&c->gb);\n\n            page   = val >> 14;\n\n            x      = (val & 0x7F) * 2;\n\n            y      = ((val >> 7) & 0x7F) * 2;\n\n            dst    = c->frame[page] + x + y * c->width;\n\n            dend   = c->frame[page] + c->frame_size;\n\n            offset = (x & 0x7F) * 2;\n\n            j      = bytestream2_get_le16(&c->gb) + offset;\n\n            do {\n\n                offset++;\n\n                if (dst + 3 * c->width + 4 > dend)\n\n                    return AVERROR_INVALIDDATA;\n\n                read4x4block(c, dst, c->width);\n\n                if ((offset & 0x3F) == 0)\n\n                    dst += c->width * 3;\n\n                dst += 4;\n\n            } while (offset < j);\n\n        } while (--i);\n\n    }\n\n\n\n    dst  = c->frame[c->current_frame];\n\n    dend = c->frame[c->current_frame] + c->frame_size;\n\n    do {\n\n        set_src_position(c, &src, &send);\n\n        if ((src + 3 * c->width + 4 > send) ||\n\n            (dst + 3 * c->width + 4 > dend))\n\n            return AVERROR_INVALIDDATA;\n\n        copy_block4(dst, src, c->width, c->width, 4);\n\n        i++;\n\n        if ((i & 0x3F) == 0)\n\n            dst += c->width * 3;\n\n        dst += 4;\n\n    } while (i < c->video_size / 16);\n\n\n\n    opcode_size = bytestream2_get_le16(&c->gb);\n\n    bytestream2_skip(&c->gb, 2);\n\n\n\n    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    opcodes = pkt + bytestream2_tell(&c->gb);\n\n    bytestream2_skipu(&c->gb, opcode_size);\n\n\n\n    dst = c->frame[c->current_frame];\n\n\n\n    for (i = 0; i < c->height; i += 4, dst += c->width * 3)\n\n        for (j = 0; j < c->width; j += 4, dst += 4) {\n\n            int opcode, k = 0;\n\n            if (op > opcode_size)\n\n                return AVERROR_INVALIDDATA;\n\n            if (j & 4) {\n\n                opcode = opcodes[op] & 15;\n\n                op++;\n\n            } else {\n\n                opcode = opcodes[op] >> 4;\n\n            }\n\n\n\n            while (block_sequences[opcode][k]) {\n\n                offset = c->width * 2;\n\n                code   = block_sequences[opcode][k++];\n\n\n\n                switch (code) {\n\n                case 2:\n\n                    offset = 0;\n\n                case 3:\n\n                    color = bytestream2_get_byte(&c->gb);\n\n                case 4:\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_color_mask(dst + offset, c->width, mask, color);\n\n                    break;\n\n                case 5:\n\n                    offset = 0;\n\n                case 6:\n\n                    set_src_position(c, &src, &send);\n\n                case 7:\n\n                    if (src + offset + c->width + 4 > send)\n\n                        return AVERROR_INVALIDDATA;\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_src_mask(dst + offset, c->width, mask, src + offset);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 16614, "substitutes": {"c": ["g", "core", "self", "dc", "cache", "ci", "video", "chart", "cl", "h", "conf", "cf", "vc", "b", "cr", "z", "ctrl", "m", "cm", "com", "nc", "u", "gc", "oc", "center", "p", "s", "arc", "l", "cu", "fc", "cp", "f", "pc", "this", "uc", "bc", "n", "config", "ctx", "lc", "cc", "ct", "cb", "C", "cod", "icc", "cs", "ac", "cur", "t", "d", "ch", "enc", "cpp", "co", "con", "ec", "w", "ca", "course", "ce", "k", "ic", "cv", "cy", "tc", "mc", "e", "xc", "sc", "v"], "pkt": ["Pkt", "cpkt", "packet", "Pk", "cpk", "cpct", "pct", " packet", "Pct", "Packet", " pk", "pk", "cpacket", " pct"], "code": ["bit", "cm", "f", "length", " codes", " encode", "type", "nc", "bc", "source", "buffer", "ch", " co", " decode", "config", "id", "enc", "Code", "zip", " coding", "codes", "index", "co", "pack", "data", "ec", " chunk", "loc", " codec", "p", "cc", "b", "m", "image", "ode", "cb", "sec", "count", "seq", "e", "num", " cmd", "rc", "cod", " Code"], "offset": ["bit", "set", "skip", "alpha", "shift", "f", "length", "timeout", "range", "style", "alt", "axis", "off", "end", "api", "error", "ny", "gap", "info", "len", "position", "location", "si", "ip", "id", "reset", "uni", "online", "order", "index", "address", "padding", "data", "entry", "o", "ace", "Offset", "hop", "loc", "slot", "p", "line", "pos", "key", "adj", "delay", "slice", "update", "image", "ui", "unk", "ne", "num", "e", "start", "adjust", "alias", "l", "a", "origin", "attribute", "size"], "dst": ["g", "get", "sost", "Dstream", "dsts", "odst", "adsts", "Dost", "lste", "sdest", "dyend", "dost", " dste", "Dend", "sdst", "adst", " dnd", " dsts", "idst", "vdest", "sdste", "sdend", "idend", "lest", "dST", "nend", "nrest", "Dest", "srest", "nost", "s", " drest", "nst", "odost", "vdstream", "num", "DST", " dST", "odest", "vdst", "lost", "adend", "sste", "idost", "dyest", "sdstream", "dystream", "lst", "buffer", "_", "dnd", "drest", "Dsts", "sest", "dste", "dysts", "sdsts", "pos", " dost", "Dste", "idsts", " dstream", "adost", "dstream", "Dst", "idnd", "sst", "Dnd", "vdost", "idest", "pack", "dyst", "all", "odsts", " dest", "dest", "idST"], "dend": ["zEND", " dstart", "dends", "zends", "Dends", "Dnd", "dpend", "jpend", " dending", "xend", "Dstart", "dending", "xstart", "dnd", "dended", "ldended", "lense", "lstart", "zstart", "dense", "jnd", "jend", "Dended", "zended", "lend", "bended", "Dend", "mdEND", "zending", "lnd", "bend", "dstart", " dended", "bstart", "ldstart", "mdends", " dpend", "dEND", "mdend", "xnd", "ldend", " dends", "bpend", "xense", " dEND", "mdending", "ldpend", "Dpend", "zend", " dense", " dnd", "jends"], "src": ["sn", "split", "inst", "rest", "uc", "source", "sit", "uri", "req", "sr", "rib", "low", "rob", "config", "fc", "download", "img", "iv", "data", "hl", "stat", "stream", "loc", "rb", "sb", "gl", "ind", "ssl", "sl", "sup", "rin", "slice", "dist", "desc", "sel", "ui", "gz", "bis", "rc", "attr", "url", "dest", "gb", "cb", "start", "filename", "fi", "sub", "sc", "spec", "setup", "sync", "settings"], "send": ["set", "sex", "scan", "shift", "get", "sent", "range", "transform", "Send", "source", "end", "uri", "add", "feed", "config", "speed", "control", "init", "iv", "pack", "sort", "kill", "write", "call", "stream", "read", "stat", "see", "each", "push", "response", "cv", "ind", "nd", "slice", "dist", "eight", "find", "en", "rc", "sec", "seed", "dest", "start", "sc", "se", "size", "sync", "use"], "opcodes": ["catcode", "opernames", "catcodes", "opermaps", "opnames", "opmaps", "bitcodes", "opercode", "bitmaps", "opercodes", "catmaps", "bitnames", "bitcode", "catnames"], "i": ["phi", "di", "inner", "f", "ri", "xi", "qi", "u", "ix", "ci", "li", "in", "source", "ji", "bi", "it", "uri", "d", "n", "ip", "I", "si", "pi", "multi", "id", "init", "index", "r", "ai", "img", "iu", "binary", "o", "ii", "p", "ind", "b", "z", "mini", "ui", "image", "ni", "fi", "anti", "e", "l", "start", "ori", "a", "io", "ie", "ini", "v", "m"], "j": ["g", "shift", "f", "jp", "je", "js", "q", "ji", "off", "d", "n", "jl", "job", "ij", "ch", "dj", "r", "o", "br", "aj", "w", "ii", "k", "p", "adj", "pos", "jump", "uj", "b", "note", "z", "eight", "ne", "l", "J", "start", "ie", "v", "bl", "jj", "m"], "align": ["batch", "lace", "skip", "scale", "grid", "anch", "bl", "shift", "split", "match", "angle", "aff", "work", "style", "balance", "aligned", "range", "shake", "pal", "pad", "el", "gap", "rel", "border", "len", "coord", "label", " aligned", "padding", "ign", "il", "addr", "binary", "sort", "help", "call", "join", "sync", "al", " alignment", "pixel", "lead", "lock", "num", "adjust", "alias", "middle", "margin", "bin", "size", "tail"], "page": ["wave", "server", "scale", "session", "length", "number", "sp", "stall", "large", "phrase", "inc", "frame", "net", "me", "mark", "gap", "ip", "position", "site", "col", "base", "pg", "pl", "max", "index", "year", "pp", "win", "block", "aa", "hop", "next", "loc", "p", "line", "limit", "key", "pixel", "Page", "pe", "channel", "wait", "value", "pages", "edge", "image", "step", "screen", "sel", "month", "age", "num", "url", "row", "e", "port", "pid", "px", "fe", "margin", "order", "v", "fb"], "val": ["f", "VAL", "pt", "xy", "cal", "aval", "range", "bin", "pal", "ul", "cel", "grade", "el", "vals", "valid", "py", "len", "col", "base", "vi", "pl", "year", "data", "win", "fl", "loc", "Val", "ref", "p", "line", "pos", "al", "vol", "unit", "b", "eval", "sl", "key", "value", "ind", "sel", "gold", "la", "l", "pid", "v", "bl", "ver"], "x": ["g", "f", "xy", "xi", "u", "ix", "el", "d", "n", "col", "ip", "ax", "xp", "X", "h", "index", "wx", "rx", "win", "o", "w", "dx", "loc", "xxx", "height", "p", "pos", "key", "pe", "b", "z", "value", "image", "en", "xx", "area", "e", "l", "px", "ey", "xc", "v", "ex", "size"], "y": ["g", "Y", "ty", "vy", "my", "f", "xy", "u", "ci", "t", "ny", "d", "py", "yo", "n", "col", "h", "oy", "ady", "o", "w", "dy", "height", "p", "s", "cy", "sy", "b", "z", "value", "yt", "wy", "yi", "ya", "ym", "ey", "l", "size", "yy", "v", "m"], "op": ["bit", "cp", "skip", "ops", "ap", "sp", "operation", "prev", "ip", "zip", "cop", "pp", "o", "oper", "hop", "oc", "slot", "p", "lock", "seq", "cmp", "opt", "rot", "comp"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n", "idx": 16628, "substitutes": {"env": ["console", "core", "cp", "inet", "eu", "output", "jp", "export", "extra", "queue", "cache", "net", "buf", "et", "enable", "qv", "conn", "eni", "el", "np", "obj", "Environment", "hw", "enc", "config", "db", "h", "code", "init", "dict", "equ", "hl", "ef", "ec", "engine", "w", "exc", "ext", "ea", "cf", "p", "cv", "her", "ep", "impl", "er", "pkg", "err", "en", "context", "vm", "ne", "elf", "ev", "e", "cmp", "environment", "que", "manager", "v", "size"], "fptag": ["fctig", "fportage", "fsptag", " fstig", " fstang", "fpointarg", "fctad", " fntag", " fntagging", "fntame", "fntag", " fptagging", " faptag", "fppang", "fppad", "fppig", "fptage", "fptagging", "fpertagging", "fpointag", "xftak", "fppagging", "fpointime", "fptrub", "fptype", "fspointarg", "fppagged", "fftub", " fptang", "fiptag", "fctang", "fpointagn", " fptad", "fppime", "fptub", "fftext", "fftage", " fptame", "fspointag", "xftub", "fspointagn", "xptext", " fstag", "fctag", " faptype", "fftags", "fftag", "fptrak", "fpertag", "xftag", "fptagn", "faptag", "xptak", "fptad", "fntagging", "fptang", " faptage", " faptags", "fstag", " fptagged", "fppag", "fsptime", " fntagged", "fptrext", " fptig", "fptags", " fptags", "fprarg", "fppagn", "fptime", "fpragn", "fstad", "fsptagn", "fsptarg", "fspointime", "faptags", "fptak", "fprime", "fftak", "fntagged", "xptag", "fportags", "fiptext", "fiptub", "fptig", " fstad", "fprag", "fiptak", "fstig", "faptype", "fportype", " fptage", "fptarg", "faptage", "fpertame", " fptype", "xftext", " fntame", "fpertagged", "fptext", "fptrag", "fptagged", "xptub", "fptame", "fpparg", "fppame", "fftype", "fportag", "fstang"], "i": ["g", "is", "phi", "di", "f", "ri", "xi", "jp", "qi", "u", "x", "ix", "ci", "li", "in", "eni", "bi", "ji", "uri", "it", "d", "mu", "info", "n", "ip", "ti", "si", "I", "pi", "multi", "id", "vi", "ai", "iu", "o", "ii", "c", "k", "p", "y", "ind", "b", "z", "ui", "ni", "zi", "gi", "fi", "yi", "e", "l", "ori", "start", "io", "oi", "ie", "ini", "v", "mi", "m"], "j": ["g", "ja", "f", "jp", "x", "qi", "jo", "u", "je", "li", "js", "ci", "q", "ji", "d", "n", "jl", "job", "ij", "si", "jit", "dj", "kj", "r", "jet", "o", "aj", "ii", "k", "c", "jc", "p", "adj", "pos", "y", "uj", "ind", "b", "note", "z", "ne", "bj", "e", "l", "J", "ie", "v", "jj", "m"], "fpuc": ["printfusc", "fpsu", "FPcus", "bpus", "cfuc", "fnuc", "fpusc", "wpuc", "printfus", "lpsu", "vpuc", "fpud", "FPuc", "pbc", "tpuc", "fnul", "fncu", "lpus", "cfcus", "lpasc", "rfasc", "FPUC", "FPuu", "fnud", "rfUC", "cfUC", "wpus", "tpasc", "bpul", "tpUC", "fsUC", "lpuc", "vpus", "fpuu", "lpUC", "pcu", "fnbc", "fnusc", "pus", "bpbc", "fnus", "rfsu", "lpbc", "fsuc", "fnsc", "lpul", "printfuc", "rfuc", "lpcus", "pusc", "puc", "lpsc", "fsbc", "lpud", "vpud", "wpbc", "fpsc", "cfuu", "fpasc", "bpuc", "fpUC", "tpsu", "fpbc", "fpus", "fpcu", "wpUC", "vpsc", "fpcus", "fpul", "pUC", "lpuu", "fsus", "printfcu"], "fp1": ["cfuc", "FP2", "FPuc", "f1", "cf1", "p1", "dfus", "fp2", "puc", "p2", "fus", "cpus", "fpus", "cp1", "FP1", "df1", "cf2"], "fp": ["cp", "inet", "sf", "df", "f", "uf", "proc", "tp", "wp", "jp", "iper", "prefix", "buf", "lp", "py", "fm", "np", "framework", "bp", "fd", "aux", "fw", "farm", "pb", "vp", "fen", "tf", "ctx", "ec", "php", "ulp", "fl", "cf", "processor", "file", "p", "tmp", "rf", "nil", "FP", "prot", "pkg", "fs", "gp", "elf", "fn", "upp", "bf", "cmp", "filename", "utils", "io", "mp", "fc", "plugin", "fb"]}}
{"project": "FFmpeg", "commit_id": "5dbb63feefb9070d6fbb5fc16406813f14aa7f9b", "target": 0, "func": "static int decode_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic;\n\n    int err, i, ret, video_index, audio_index, subtitle_index;\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    AVFormatParameters params, *ap = &params;\n\n\n\n    video_index = -1;\n\n    audio_index = -1;\n\n    subtitle_index = -1;\n\n    is->video_stream = -1;\n\n    is->audio_stream = -1;\n\n    is->subtitle_stream = -1;\n\n\n\n    global_video_state = is;\n\n    url_set_interrupt_cb(decode_interrupt_cb);\n\n\n\n    memset(ap, 0, sizeof(*ap));\n\n\n\n    ap->width = frame_width;\n\n    ap->height= frame_height;\n\n    ap->time_base= (AVRational){1, 25};\n\n    ap->pix_fmt = frame_pix_fmt;\n\n\n\n    err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if(genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    err = av_find_stream_info(ic);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if(ic->pb)\n\n        ic->pb->eof_reached= 0; //FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < ic->nb_streams; i++) {\n\n        AVCodecContext *enc = ic->streams[i]->codec;\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n        switch(enc->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if ((audio_index < 0 || wanted_audio_stream-- > 0) && !audio_disable)\n\n                audio_index = i;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            if ((video_index < 0 || wanted_video_stream-- > 0) && !video_disable)\n\n                video_index = i;\n\n            break;\n\n        case CODEC_TYPE_SUBTITLE:\n\n            if (wanted_subtitle_stream-- >= 0 && !video_disable)\n\n                subtitle_index = i;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (show_status) {\n\n        dump_format(ic, 0, is->filename, 0);\n\n        dump_stream_info(ic);\n\n    }\n\n\n\n    /* open the streams */\n\n    if (audio_index >= 0) {\n\n        stream_component_open(is, audio_index);\n\n    }\n\n\n\n    if (video_index >= 0) {\n\n        stream_component_open(is, video_index);\n\n    } else {\n\n        if (!display_disable)\n\n            is->show_audio = 1;\n\n    }\n\n\n\n    if (subtitle_index >= 0) {\n\n        stream_component_open(is, subtitle_index);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    for(;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER\n\n        if (is->paused && !strcmp(ic->iformat->name, \"rtsp\")) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int stream_index= -1;\n\n            int64_t seek_target= is->seek_pos;\n\n\n\n            if     (is->   video_stream >= 0) stream_index= is->   video_stream;\n\n            else if(is->   audio_stream >= 0) stream_index= is->   audio_stream;\n\n            else if(is->subtitle_stream >= 0) stream_index= is->subtitle_stream;\n\n\n\n            if(stream_index>=0){\n\n                seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q, ic->streams[stream_index]->time_base);\n\n            }\n\n\n\n            ret = av_seek_frame(is->ic, stream_index, seek_target, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            }else{\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (is->audioq.size > MAX_AUDIOQ_SIZE ||\n\n            is->videoq.size > MAX_VIDEOQ_SIZE ||\n\n            is->subtitleq.size > MAX_SUBTITLEQ_SIZE) {\n\n            /* wait 10 ms */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n        if(url_feof(ic->pb)) {\n\n            av_init_packet(pkt);\n\n            pkt->data=NULL;\n\n            pkt->size=0;\n\n            pkt->stream_index= is->video_stream;\n\n            packet_queue_put(&is->videoq, pkt);\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret != AVERROR_EOF && url_ferror(ic->pb) == 0) {\n\n                SDL_Delay(100); /* wait for user event */\n\n                continue;\n\n            } else\n\n                break;\n\n        }\n\n        if (pkt->stream_index == is->audio_stream) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* disable interrupting */\n\n    global_video_state = NULL;\n\n\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        av_close_input_file(is->ic);\n\n        is->ic = NULL; /* safety */\n\n    }\n\n    url_set_interrupt_cb(NULL);\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16651, "substitutes": {"arg": ["g", "val", "arp", "AR", "pc", "inc", "ac", "ang", "param", "argument", "ad", "inter", "or", "util", "args", "ax", "lib", "config", "play", "ar", "ai", "init", "ig", "ace", "par", "loc", "oc", "ag", "var", "abc", "flag", "ay", "Arg", "arc", "rc", "fi", "arr", "amp"], "is": ["core", "ms", "get", "ri", "ais", "cache", "api", "isl", "view", "or", "play", "ar", "oper", "app", "pic", "as", "IS", "ini", "can", "ics", "http", "in", "it", "has", "state", "parse", "ai", "isa", "ik", "iss", "es", "us", "are", "esi", "oc", "p", "s", "ris", "iris", "ui", "isi", "Is", "its", "iso", "mis", "ops", "ip", "kit", "id", "ist", "irc", "init", "il", "iv", "vs", "ace", "next", "was", "lis", "bis", "iz", "ish", "info", "css", "cs", "sys", "ac", "bi", "pick", "pi", "isc", "ib", "ls", "os", "im", "ie"], "ic": ["aci", "rec", "get", "ill", "x", "ix", "ci", "mic", "exec", "icing", "cl", "ice", "ia", "app", "c", "vc", "pic", "voc", "ini", "ics", "cm", "acl", "ry", "ico", "cli", "bank", "gc", "it", "aic", "lib", "lic", "ai", "ik", "cci", "oc", "p", "isi", "fc", "pc", "bc", "ip", "irc", "init", "wx", "ace", "ici", "ctx", "lc", "cc", "sci", "cus", "iac", "ct", "IC", "icc", "cs", "sys", "inc", "ac", "wic", "conn", "bi", "isc", "co", "ib", "ig", "ec", "ce", "cy", "tc", "nic", "cit", "mc", "anc", "xc", "ie", "ican"], "err": ["g", "reply", "inner", "Er", "sr", "cor", "fun", "magic", "ar", "code", "r", "der", "last", "rx", "conf", "mr", "resp", "erer", "acer", "fe", "order", "br", "dr", "ry", "res", "kr", "req", "rh", "ir", "dev", "fr", "usr", "var", "msg", "fi", "die", "ler", "norm", "bug", "ver", "yr", " error", "orig", "error", "aster", "wr", "init", "hr", "iter", "gr", "ind", "er", "Error", "cb", "rc", "arr", "orr", "fer", "str", "rr", "result", "runner", "lr", "rar", " er", "len", "ner", "status", "doc", "try", "nor", "e", "pr"], "i": ["g", "phi", "di", "ri", "cli", "xi", "hi", "qi", "ix", "u", "x", "ci", "in", "li", "abi", "isin", "eni", "bi", "it", "uri", "end", "n", "ip", "ti", "si", "pi", "I", "jit", "id", "multi", "init", "ai", "index", "il", "ik", "ib", "chi", "iu", "ii", "iter", "c", "p", "y", "ind", "b", "m", "ui", "ni", "zi", "gi", "ami", "fi", "adi", "e", "yi", "ori", "start", "l", "io", "oi", "ie", "ini", "v", "mi", "j", "info"], "ret": ["reply", "val", "str", "RET", "bit", "let", "cat", "result", "alt", "feat", "et", "res", "success", "reg", "error", "back", "len", "fun", "mt", "ut", "id", "fin", "sat", "fit", "status", "usr", "rev", "rets", "iter", "rb", "att", "ref", "det", "nt", "bot", "gt", "rl", "hash", "def", "flag", "resp", "fat", "ft", "count", "Ret", "arr", "lit", "rt", "part", "info"], "video_index": ["video__number", "videoIdcolumn", "videoUindex", "documentIdinfo", "frame_number", "videoUcolumn", "videoUinfo", "videoxnumber", "frame_index", "videoxindex", "videoUcoll", "frame__number", "document_index", "video_number", "frame__index", "frame__level", "document_column", "videoidindex", "document_info", "documentIdcolumn", "frame_level", "videoidinfo", "video_info", "videoidcoll", "videoIdindex", "video_coll", "videoxlevel", "document_coll", "video_level", "documentIdcoll", "documentIdindex", "video_column", "video__index", "videoidcolumn", "video__level", "videoIdinfo", "videoIdcoll"], "audio_index": ["input_size", "inputIdstream", "picture_range", "audio_stream", "audioIdindex", "audio_inc", "inputIdindex", "picture_prefix", "audio_size", "input_inc", "input_stream", "audioIdsize", "audioIdinc", "audio_source", "inputIdinc", "picture_index", "audio_prefix", "picture_source", "inputIdsize", "input_index", "audioIdstream", "audio_range"], "subtitle_index": ["subscript_index", "subscript_length", "subtitle_width", "subvideo_length", "subvideo_id", "subtitle_id", "subvideo_index", "subtitle_label", "subscript_width", "subvideo_label", "subtitle_length"], "pkt1": [" packet1", "pqt4", "pke4", "Pkt0", " pkt4", "pke6", "pqt1", "packet1", "pkt4", "pkt0", "packet0", "pke2", "packet4", "Packet2", "pqt0", "Pkt4", " pkt6", " packet4", "packet2", "Pkt1", " packet2", "pkt2", " packet6", "pke1", "Pkt2", "pke0", "pvt2", "pkt6", "Packet1", " pkt2", "pqt2", "Packet4", "packet6", "Packet0", "pvt6", "pvt1", "pvt4"], "pkt": ["Pkt", "fk", "fct", " pnt", "Pk", "Pnt", "pct", "fnt", "fkt", "Pct", " pk", "pk", "pnt", " pct"], "params": ["cs", "copy", "acl", "ops", "sys", "proc", "ps", "sp", "ac", "cache", "Parameters", "lp", "param", "api", "parts", "py", "np", "ns", "ip", "pi", "args", "config", "aps", "types", "ips", "parse", "parser", "bps", "ctx", "par", "mac", "gs", "processor", "tmp", "audio", "as", "attr", "options", " parameters", "ams", " pars", "settings"], "ap": ["arp", "ape", "imp", "AP", "map", "sp", "ps", "tp", "jp", "ac", "op", "xml", "ang", "api", "apt", "gap", "Ap", "ip", "pac", "ax", "av", "aps", "aw", "ar", "pa", "ai", "asp", "art", "snap", "cap", "hop", "aj", "ak", "app", "p", "al", "adj", "au", "ep", "hap", "am", "nav", "as", "ab", "ait", "a", "mp", "wa", "apa", "ams", "rap", "af", "apy", "amp"], "timestamp": ["dimempt", "tmestamp", "momeline", "temeline", "tmempt", " timtim", "dimetz", "temestamp", "lifest", "tmeline", "dimeline", "momempt", "timtim", " timetz", "Timetz", "lifsequence", "mometz", "lifetz", "momestamp", "Timeline", "timest", "imestamp", "tmetz", "Timest", "Timetime", "Timsequence", "timetime", "dimestamp", " timest", " Timestamp", "lifestamp", "dimest", " Timetz", "timetz", "imetz", "Timestamp", "temetz", "dimetime", "timempt", "tmsequence", "tmetime", "imtim", " Timest", "tmest", "temest", "imest", "timsequence", "timeline", " Timtim"], "enc": ["rec", "coll", "dc", "session", "inc", "ac", "cache", "nc", "conn", "exec", "conv", "lib", "config", "data", "exc", "loc", "iq", "Enc", "kw", "cv", "vc", "ssl", "sl", "rc", "sec", "voc", "anc"]}}
{"project": "FFmpeg", "commit_id": "608708009f69ba4cecebf05120c696167494c897", "target": 1, "func": "static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ADPCMDecodeContext *c = avctx->priv_data;\n    ADPCMChannelStatus *cs;\n    int n, m, channel, i;\n    short *samples;\n    const uint8_t *src;\n    int st; /* stereo */\n    int count1, count2;\n    int nb_samples, coded_samples, ret;\n    nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);\n    if (nb_samples <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of samples in packet\\n\");\n    }\n    /* get output buffer */\n    c->frame.nb_samples = nb_samples;\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (short *)c->frame.data[0];\n    /* use coded_samples when applicable */\n    /* it is always <= nb_samples, so the output buffer will be large enough */\n    if (coded_samples) {\n        if (coded_samples != nb_samples)\n            av_log(avctx, AV_LOG_WARNING, \"mismatch in coded sample count\\n\");\n        c->frame.nb_samples = nb_samples = coded_samples;\n    }\n    src = buf;\n    st = avctx->channels == 2 ? 1 : 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ADPCM_IMA_QT:\n        /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).\n           Channel data is interleaved per-chunk. */\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int16_t predictor;\n            int step_index;\n            cs = &(c->status[channel]);\n            /* (pppppp) (piiiiiii) */\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n            predictor = AV_RB16(src);\n            step_index = predictor & 0x7F;\n            predictor &= 0xFF80;\n            src += 2;\n            if (cs->step_index == step_index) {\n                int diff = (int)predictor - cs->predictor;\n                if (diff < 0)\n                    diff = - diff;\n                if (diff > 0x7f)\n                    goto update;\n            } else {\n            update:\n                cs->step_index = step_index;\n                cs->predictor = predictor;\n            }\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            samples = (short *)c->frame.data[0] + channel;\n            for (m = 0; m < 32; m++) {\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n                samples += avctx->channels;\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n                samples += avctx->channels;\n                src ++;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WAV:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for(i=0; i<avctx->channels; i++){\n            cs = &(c->status[i]);\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n        }\n        for (n = (nb_samples - 1) / 8; n > 0; n--) {\n            for (i = 0; i < avctx->channels; i++) {\n                cs = &c->status[i];\n                for (m = 0; m < 4; m++) {\n                    uint8_t v = *src++;\n                    *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);\n                    samples += avctx->channels;\n                    *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 3);\n                    samples += avctx->channels;\n                }\n                samples -= 8 * avctx->channels - 1;\n            }\n            samples += 7 * avctx->channels;\n        }\n        break;\n    case CODEC_ID_ADPCM_4XM:\n        for (i = 0; i < avctx->channels; i++)\n            c->status[i].predictor= (int16_t)bytestream_get_le16(&src);\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].step_index= (int16_t)bytestream_get_le16(&src);\n            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n        }\n        for (i = 0; i < avctx->channels; i++) {\n            samples = (short *)c->frame.data[0] + i;\n            cs = &c->status[i];\n            for (n = nb_samples >> 1; n > 0; n--, src++) {\n                uint8_t v = *src;\n                *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);\n                samples += avctx->channels;\n                *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 4);\n                samples += avctx->channels;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_MS:\n    {\n        int block_predictor;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        block_predictor = av_clip(*src++, 0, 6);\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        if (st) {\n            block_predictor = av_clip(*src++, 0, 6);\n            c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n            c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        }\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n        if (st){\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n        }\n        c->status[0].sample1 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n        c->status[0].sample2 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n        *samples++ = c->status[0].sample2;\n        if (st) *samples++ = c->status[1].sample2;\n        *samples++ = c->status[0].sample1;\n        if (st) *samples++ = c->status[1].sample1;\n        for(n = (nb_samples - 2) >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_DK4:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n            *samples++ = cs->predictor;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_DK3:\n    {\n        unsigned char last_byte = 0;\n        unsigned char nibble;\n        int decode_top_nibble_next = 0;\n        int end_of_packet = 0;\n        int diff_channel;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n        c->status[0].step_index = src[14];\n        c->status[1].step_index = src[15];\n        /* sign extend the predictors */\n        src += 16;\n        diff_channel = c->status[1].predictor;\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n         * the buffer is consumed */\n        while (1) {\n            /* for this algorithm, c->status[0] is the sum channel and\n             * c->status[1] is the diff channel */\n            /* process the first predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the diff channel predictor */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n            /* process the first pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n            /* process the second predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the second pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_ISS:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v1, v2;\n            uint8_t v = *src;\n            /* nibbles are swapped for mono */\n            if (st) {\n                v1 = v >> 4;\n                v2 = v & 0x0F;\n            } else {\n                v2 = v >> 4;\n                v1 = v & 0x0F;\n            }\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WS:\n        while (src < buf + buf_size) {\n            uint8_t v = *src++;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_XA:\n        while (buf_size >= 128) {\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n                avctx->channels);\n            src += 128;\n            samples += 28 * 8;\n            buf_size -= 128;\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n        src += 4; // skip sample count (already read)\n        for (i=0; i<=st; i++)\n            c->status[i].step_index = bytestream_get_le32(&src);\n        for (i=0; i<=st; i++)\n            c->status[i].predictor  = bytestream_get_le32(&src);\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n        }\n        break;\n    case CODEC_ID_ADPCM_EA:\n    {\n        int32_t previous_left_sample, previous_right_sample;\n        int32_t current_left_sample, current_right_sample;\n        int32_t next_left_sample, next_right_sample;\n        int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n        uint8_t shift_left, shift_right;\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n           each coding 28 stereo samples. */\n        src += 4; // skip sample count (already read)\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n        for (count1 = 0; count1 < nb_samples / 28; count1++) {\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n            src++;\n            shift_left  = 20 - (*src >> 4);\n            shift_right = 20 - (*src & 0x0F);\n            src++;\n            for (count2 = 0; count2 < 28; count2++) {\n                next_left_sample  = sign_extend(*src >> 4, 4) << shift_left;\n                next_right_sample = sign_extend(*src,      4) << shift_right;\n                src++;\n                next_left_sample = (next_left_sample +\n                    (current_left_sample * coeff1l) +\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n                next_right_sample = (next_right_sample +\n                    (current_right_sample * coeff1r) +\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n                previous_left_sample = current_left_sample;\n                current_left_sample = av_clip_int16(next_left_sample);\n                previous_right_sample = current_right_sample;\n                current_right_sample = av_clip_int16(next_right_sample);\n                *samples++ = (unsigned short)current_left_sample;\n                *samples++ = (unsigned short)current_right_sample;\n            }\n        }\n        if (src - buf == buf_size - 2)\n            src += 2; // Skip terminating 0x0000\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n    {\n        int coeff[2][2], shift[2];\n        for(channel = 0; channel < avctx->channels; channel++) {\n            for (i=0; i<2; i++)\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n            shift[channel] = 20 - (*src & 0x0F);\n            src++;\n        }\n        for (count1 = 0; count1 < nb_samples / 2; count1++) {\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n                for(channel = 0; channel < avctx->channels; channel++) {\n                    int32_t sample = sign_extend(src[channel] >> i, 4) << shift[channel];\n                    sample = (sample +\n                             c->status[channel].sample1 * coeff[channel][0] +\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n                    c->status[channel].sample2 = c->status[channel].sample1;\n                    c->status[channel].sample1 = av_clip_int16(sample);\n                    *samples++ = c->status[channel].sample1;\n                }\n            }\n            src+=avctx->channels;\n        }\n        /* consume whole packet */\n        src = buf + buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_R1:\n    case CODEC_ID_ADPCM_EA_R2:\n    case CODEC_ID_ADPCM_EA_R3: {\n        /* channel numbering\n           2chan: 0=fl, 1=fr\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n        int32_t previous_sample, current_sample, next_sample;\n        int32_t coeff1, coeff2;\n        uint8_t shift;\n        unsigned int channel;\n        uint16_t *samplesC;\n        const uint8_t *srcC;\n        const uint8_t *src_end = buf + buf_size;\n        int count = 0;\n        src += 4; // skip sample count (already read)\n        for (channel=0; channel<avctx->channels; channel++) {\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n                                         : bytestream_get_le32(&src))\n                           + (avctx->channels-channel-1) * 4;\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n            srcC  = src + offset;\n            samplesC = samples + channel;\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n            } else {\n                current_sample  = c->status[channel].predictor;\n                previous_sample = c->status[channel].prev_sample;\n            }\n            for (count1 = 0; count1 < nb_samples / 28; count1++) {\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n                    srcC++;\n                    if (srcC > src_end - 30*2) break;\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n                    for (count2=0; count2<28; count2++) {\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n                        samplesC += avctx->channels;\n                    }\n                } else {\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n                    shift = 20 - (*srcC++ & 0x0F);\n                    if (srcC > src_end - 14) break;\n                    for (count2=0; count2<28; count2++) {\n                        if (count2 & 1)\n                            next_sample = sign_extend(*srcC++,    4) << shift;\n                        else\n                            next_sample = sign_extend(*srcC >> 4, 4) << shift;\n                        next_sample += (current_sample  * coeff1) +\n                                       (previous_sample * coeff2);\n                        next_sample = av_clip_int16(next_sample >> 8);\n                        previous_sample = current_sample;\n                        current_sample  = next_sample;\n                        *samplesC = current_sample;\n                        samplesC += avctx->channels;\n                    }\n                }\n            }\n            if (!count) {\n                count = count1;\n            } else if (count != count1) {\n                av_log(avctx, AV_LOG_WARNING, \"per-channel sample count mismatch\\n\");\n                count = FFMAX(count, count1);\n            }\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n                c->status[channel].predictor   = current_sample;\n                c->status[channel].prev_sample = previous_sample;\n            }\n        }\n        c->frame.nb_samples = count * 28;\n        src = src_end;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_XAS:\n        for (channel=0; channel<avctx->channels; channel++) {\n            int coeff[2][4], shift[4];\n            short *s2, *s = &samples[channel];\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n                for (i=0; i<2; i++)\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n                shift[n] = 20 - (src[2] & 0x0F);\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n            }\n            for (m=2; m<32; m+=2) {\n                s = &samples[m*avctx->channels + channel];\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n                        int level = sign_extend(*src >> (4 - i), 4) << shift[n];\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n                    }\n                }\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_AMV:\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n        c->status[0].step_index = bytestream_get_le16(&src);\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n            src+=4;\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            char hi, lo;\n            lo = *src & 0x0F;\n            hi = *src >> 4;\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n                FFSWAP(char, hi, lo);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                lo, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                hi, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_CT:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case CODEC_ID_ADPCM_SBPRO_4:\n    case CODEC_ID_ADPCM_SBPRO_3:\n    case CODEC_ID_ADPCM_SBPRO_2:\n        if (!c->status[0].step_index) {\n            /* the first byte is a raw sample */\n            *samples++ = 128 * (*src++ - 0x80);\n            if (st)\n              *samples++ = 128 * (*src++ - 0x80);\n            c->status[0].step_index = 1;\n            nb_samples--;\n        }\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n            for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] >> 4, 4, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x0F, 4, 0);\n            }\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n            for (n = nb_samples / 3; n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 5        , 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x07, 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] & 0x03, 2, 0);\n            }\n        } else {\n            for (n = nb_samples >> (2 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 6        , 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    (src[0] >> 4) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x03, 2, 2);\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_SWF:\n    {\n        GetBitContext gb;\n        const int *table;\n        int k0, signmask, nb_bits, count;\n        int size = buf_size*8;\n        init_get_bits(&gb, buf, size);\n        //read bits & initial values\n        nb_bits = get_bits(&gb, 2)+2;\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n        table = swf_index_tables[nb_bits-2];\n        k0 = 1 << (nb_bits-2);\n        signmask = 1 << (nb_bits-1);\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n            for (i = 0; i < avctx->channels; i++) {\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n                c->status[i].step_index = get_bits(&gb, 6);\n            }\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n                int i;\n                for (i = 0; i < avctx->channels; i++) {\n                    // similar to IMA adpcm\n                    int delta = get_bits(&gb, nb_bits);\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n                    int k = k0;\n                    do {\n                        if (delta & k)\n                            vpdiff += step;\n                        step >>= 1;\n                        k >>= 1;\n                    } while(k);\n                    vpdiff += step;\n                    if (delta & signmask)\n                        c->status[i].predictor -= vpdiff;\n                    else\n                        c->status[i].predictor += vpdiff;\n                    c->status[i].step_index += table[delta & (~signmask)];\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n                    *samples++ = c->status[i].predictor;\n                }\n            }\n        }\n        src += buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_YAMAHA:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n        }\n        break;\n    case CODEC_ID_ADPCM_THP:\n    {\n        int table[2][16];\n        int prev[2][2];\n        int ch;\n        src += 4; // skip channel size\n        src += 4; // skip number of samples (already read)\n        for (i = 0; i < 32; i++)\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n        /* Initialize the previous sample.  */\n        for (i = 0; i < 4; i++)\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n        for (ch = 0; ch <= st; ch++) {\n            samples = (short *)c->frame.data[0] + ch;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int index = (*src >> 4) & 7;\n                unsigned int exp = *src++ & 15;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n                    if(n&1) sampledat = sign_extend(*src++, 4);\n                    else    sampledat = sign_extend(*src >> 4, 4);\n                    sampledat = ((prev[ch][0]*factor1\n                                + prev[ch][1]*factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    prev[ch][1] = prev[ch][0];\n                    prev[ch][0] = *samples++;\n                    /* In case of stereo, skip one sample, this sample\n                       is for the other channel.  */\n                    samples += st;\n                }\n            }\n        }\n        break;\n    }\n    default:\n        return -1;\n    }\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n    return src - buf;\n}", "idx": 16664, "substitutes": {"avctx": ["adloc", "abcontext", "avalcmp", "abxc", "avqa", "avekb", "avkb", "evkb", "afctrl", "navlc", "AVcup", " avqa", "afxc", "navconn", "afqa", "akcontext", "avalcup", "avecf", "evctx", "akctx", "avconn", "navxc", "avalconf", "avcmp", "avectx", "avcontext", "afconn", "avcb", "avctrl", "verctx", "AVctx", "avecontext", "AVcontext", "avalloc", "avlc", " avconn", " avconfig", "AVcn", "afcontext", "afcup", "Avcontext", "Avconn", "aflc", "navcn", "evcontext", "avalcontext", "abctx", "afcca", "afconf", "avcca", "avcup", "avloc", "avconfig", "afcb", "akcb", "afcf", "evcmp", "avecca", "avalctx", "avxc", "afconfig", "Avctx", "Avconfig", "adctx", "navcontext", "abcf", "avectrl", "afctx", "adsync", "verconf", "avecb", "afkb", " avcontext", "AVlc", "aveqa", "adcontext", "AVcmp", "avcf", "vercontext", "avsync", "navctx", "akctrl", "avconf", "afsync", "avecmp", " avcca", "abconn", "afcn", "afcmp", "avcn", "afloc", "aveconn", "avalsync", "verconn", "avalconn"], "data": ["batch", "after", "header", "results", "alpha", "map", "length", "result", "extra", "bin", "queue", "cache", "frame", "source", "media", "DATA", "parent", "window", "load", "ad", "buffer", "d", "connection", "base", "Data", "message", "to", "config", "memory", "address", "code", "input", "reader", "next", "body", "head", "p", "response", "da", "content", "slice", "done", "image", "bytes", "dat", "start", "ata", "a", "open", "list", "buff", "v", "size"], "got_frame_ptr": ["got_frames_tr", "got_frames_ind", "got_frames_ptr", "got_frame_ind", "got_frames_pointer", "got_frame_pointer", "got_frame_tr"], "avpkt": ["avcck", "Avspkt", "abcpct", "avPacket", "abpct", "avpct", "Avpaddr", "avcct", " avcck", "avspfd", "Avpfd", "avcpkg", "avcacket", "avpsth", "avlpaddr", "avspaddr", "avPck", "avbput", "abcpkg", "avpkg", " avckt", "avbpkt", "avbkt", "avsput", "Avspaddr", "Avsput", "avcpsth", " avcacket", "avpaddr", "avcpct", "avlpkk", "avckg", "avPkk", "avbpaddr", " avckk", " avpck", "avpfd", "avlpkt", "Avput", "avlpck", "avspkt", "Avpkt", "abpkg", " avpkk", "avckt", "avpacket", "Avspfd", "avput", "abpkt", "avlpacket", "avpkk", " avpacket", "avbsth", "abpsth", "avbpfd", "avlpfd", "avbct", "avlput", "avbkg", "abcpkt", "avcpkt", "abcpsth", "avcsth", "avckk", "avpck", "avPkt"], "buf": ["batch", "vec", "bd", "uf", "cmd", "uc", "queue", "cache", "bc", "array", "pad", "buffer", "wb", "pool", "len", "fd", "offset", "pb", "img", "block", "cas", "ctx", "rb", "cf", "ref", "fp", "bag", "cv", "tmp", "b", "msg", "fb", "rc", "cb", "seq", "port", "box", "buff", "alloc", "br"], "c": ["g", "cp", "cd", "cn", "cm", "dc", "f", "cat", "pc", "bc", "nc", "cache", "ac", "ci", "cur", "t", "conn", "d", "enc", "config", "h", "code", "co", "con", "ctx", "ec", "lc", "w", "ca", "cf", "k", "ce", "p", "cc", "cv", "cy", "vc", "ic", "b", "cr", "abc", "cit", "ct", "cb", "rc", "mc", "e", "cmp", "l", "ctrl", "anc", "C", "cu", "xc", "sc", "v"], "cs": ["css", "cp", "ics", "CS", "bs", "pc", "ps", "nc", "bc", "ds", "rs", "ac", "cells", "conn", "ss", "ns", "cms", "args", "cons", "vs", "ls", "cas", "ctx", "ec", "lc", "qs", "gs", "cf", "sk", "acs", "cc", "ks", "vc", "ts", "cus", "fs", "stats", "wcs", "ces", "cb", "rc", "os", "hs", "sc", "spec", "Cs", "sync", "cn"], "n": ["f", "nc", "x", "u", "net", "d", "ns", "len", "nn", "w", "nl", "N", "k", "nt", "p", "b", "z", "ni", "nb", "num", "l", "v", "j"], "m": ["g", "cm", "f", "M", "mode", "u", "mod", "dm", "d", "fm", "um", "h", "r", "sm", "rem", "mid", "man", "p", "y", "mn", "en", "mc", "e", "l", "mon", "v", "mi", "md"], "channel": ["ann", "core", "can", "server", "resource", "Channel", "cm", "consumer", "component", "cat", "session", "category", "chan", "range", "type", "name", "nc", "bc", "source", "queue", "uc", "chat", "error", "connection", "broad", "gap", "video", "no", "col", "message", "version", "config", "cl", "client", "change", "con", "target", "course", "chron", "character", "p", "game", "cv", "unit", "sync", "ko", "group", "en", "context", "wan", "rc", "gui", "shape", "open", "que", "sc", "second", "event", "an", "size", "mode"], "i": ["di", "f", "x", "u", "ci", "li", "d", "mi", "ip", "I", "si", "pi", "ai", "index", "iu", "ii", "k", "p", "b", "ni", "im", "ini", "v", "ti", "j"], "samples": ["sample", "Sannels", "sannels", "insources", "ssample", "insamples", "ssources", "damples", "Samps", "Sample", "svample", "ssannels", "dources", "damps", "samps", "svamples", "insamps", "svannels", "Samples", "ssamples", "ssamps", "dessions", "insessions", "sessions", "sources", "ssessions", "svamps"], "src": ["sample", "sn", "component", "supp", "chrom", "inst", "bc", "source", "cur", "sq", "uri", "sr", "video", "config", "code", "img", "ctx", "sort", "stream", "loc", "rb", "RC", "sync", "sb", "origin", "sl", "sup", "slice", "dist", "sel", "rc", "cb", "url", "seq", "dest", "filename", "seed", "sec", "sub", "sc", "spec", "bg", "comp", "ctr", "bl", "host"], "st": ["set", "str", "sn", "sp", "inst", "rest", "nc", "u", "ss", "sw", "d", "St", "stack", "si", "stream", "nt", "sb", "std", "ost", "nd", "service", "store", "ind", "stage", "ST", "sta", " rest", "step", "ct", "rc", "sec", "sts", "start", "fe", "sth", "sc", "ste", "sync"], "count1": ["sum2", "sumone", "codeone", "countone", "code1", " countone", " count01", "code2", "count01", "sum1", "sum01", "code01"], "count2": ["max2", "count0", "code1", "code2", " count0", "max1", "max0", "code0"], "nb_samples": ["nb_dources", "nb_socks", "nb_salls", "nb_isources", "nb_psamps", "nb_timespaces", "nb_sympaces", "nb_sizes", "nb_sases", "nb_sidalls", "nb_eventsizes", "nb_setsiblings", "nb_psamples", "nb_eventsamps", "nb_servicesocks", "nb_Sims", "nb_sums", "nb_servicespaces", "nb_scamples", "nb_servicesacks", "nb_symacks", "nb_saves", "nb_ssocks", "nb_setsessions", "nb_psaves", "nb_shases", "nb_servicesamples", "nb\u00b7samples", "nb_sidamps", "nb_servicesores", "nb_ssamples", "nb_samps", "nb_servicesizes", "nb_ssones", "nb_Sessions", "nb_ssalls", "nb_symores", "nb_Sases", "nb_ssums", "nb_psample", "nb_damples", "nb_shamples", "nb_Sample", "nb_scases", "nb_timesessions", "nb_nizes", "nb_timesiblings", "nb\u00b7sympaces", "nb_nources", "nb_sessions", "nb_sidamples", "nb_asamples", "nb_setsamples", "nb\u00b7symamples", "nb_timesamples", "nb_sample", "nb_asamps", "nb_Sources", "nb\u00b7symores", "nb_sores", "nb_sidums", "nb_isamps", "nb_scamps", "nb_ssizes", "nb_pamps", "nb_sones", "nb_Samps", "nb_servicesamps", "nb_scims", "nb_ssamps", "nb_damps", "nb_namples", "nb_Sones", "nb\u00b7symacks", "nb_siblings", "nb_Samples", "nb_pums", "nb_setsamps", "nb_shamps", "nb_pamples", "nb_namps", "nb_isamples", "nb_isizes", "nb_palls", "nb_spaces", "nb_asaves", "nb_shims", "nb_timesacks", "nb_asample", "nb_timesamps", "nb_sims", "nb_sources", "nb_Saves", "nb_dones", "nb_symamples", "nb\u00b7sores", "nb\u00b7sacks", "nb_eventsocks", "nb_sacks", "nb_timesores", "nb_Siblings", "nb_eventsamples", "nb_ssources", "nb\u00b7spaces"], "coded_samples": ["coded_Smodels", "coded_asources", "coded_syamps", "coded_bamps", "coded_ssamps", "coded_Sills", "coded_tources", "coded_summies", "coded_asummies", "coded_sills", "coded_suamps", "coded_pample", "coded_asamples", "coded_pamples", "coded_bamples", "coded_sumodels", "coded_salls", "coded_sample", "coded_Samples", "coded_balls", "coded_suamples", "coded_pamps", "coded_insamples", "coded_tummies", "coded_syources", "coded_insockets", "coded_insamps", "coded_tamps", "coded_Samps", "coded_syamples", "coded_ssample", "coded_ssamples", "coded_sockets", "coded_examps", "coded_tents", "coded_sualls", "coded_bills", "coded_syents", "coded_sources", "coded_pills", "coded_tamples", "coded_smodels", "coded_exents", "coded_suills", "coded_exources", "coded_pockets", "coded_insample", "coded_asamps", "coded_Salls", "coded_samps", "coded_sents", "coded_examples", "coded_ssockets", "coded_pmodels"], "ret": ["RET", "reply", "val", "rec", "result", "match", "rs", "alt", "cur", "res", "success", "reg", "buffer", "error", "fun", "len", "mt", "obj", "pet", "fin", "rem", "r", "status", "last", "rev", "rets", "att", "ext", "ref", "det", "nt", "rf", "nil", "def", "resp", "re", "err", "en", "Ret", "bf", "mem", "arr", "lit", "empty", "rt", "utf", "v", "rep", "info"], "predictor": ["ptestation", " pveyors", "pvictable", "psriptitor", "predicttor", " pvictors", "pacherors", "pcriptable", "priptitor", "tppecture", "procredictable", "psributor", "psredicter", "priptor", "procpredor", "predictable", " pveyutor", "tppectors", " pvictored", "tpredictor", "ppectar", "ptesttor", "pributors", "pacherer", "pributitor", " predictable", "pveyutor", "pveyor", "pributier", "pributer", " predictored", "ppecture", "predicter", "procredictutor", "predictors", "pestar", "pributation", "pvictors", "predictitor", "tpredictors", "pveyior", "pcriptitor", "predictier", "pributtor", "psriptor", "pvaliditor", "ppreditor", "pestors", "tppectar", " pveyior", " predictors", "pesture", "tpredicture", "psributer", "predicture", "procredictor", "pveyors", "pvictor", "ppectors", "pributor", "psripttor", "psredictitor", "ppredable", "predictior", "pvalidutor", "predictored", "pacheror", "ptestor", "pvalidor", "ppredors", "ppredored", "ppredutor", "procpredutor", " pveyor", "predictar", "pvictored", " pvictable", "psredictor", "procpredable", "psredictors", " predictutor", "pvalidable", "priptation", "predictutor", "predictation", "tpredictar", "psredictier", "pestor", "procredictitor", "psriptation", "ppector", " pvictor", " predictior", "pacherier", "psredictation", "tppector", "psributors", "ptestitor", "pripttor", "ppredor", "pcriptor", "pcriptutor", "psributier", "psredicttor", "procpreditor"], "step_index": ["step_offset", "group_action", "group_offset", " step_value", "stepoutindex", "step___id", "step__value", "step_address", " step_num", "stepblockoffset", "groupxcount", "step___info", "groupxaction", "step___action", "stepoutoffset", "step_id", "stepxaction", "groupxindex", "group_address", "step___align", "step2index", "groupxinfo", "stepoutaddress", "step2length", "stepxinfo", "stepxcount", "step___index", "step2value", "stepblockindex", "stepblockposition", "step___count", "group_index", "step_align", "step__length", " step_align", "step_num", "group_info", "step__index", "group_count", "stepoutposition", " step_id", "step_position", "stepxindex", " step_length", "step_length", "step_value", "step_info", "step_count", "step__num", "step2num", "group_position", "step_action", "stepblockaddress"]}}
{"project": "qemu", "commit_id": "a38648290ee277c7cb8a53eabdcdb08bb7a9f23f", "target": 1, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16666, "substitutes": {"req": ["progress", "rec", "grad", "client", "proc", "jp", "sem", "cache", "org", "sr", "exec", "test", "tr", "view", "low", "require", "r", "rx", "call", "cf", "app", "iq", "dq", "loader", "resp", "transfer", "sec", "required", "wa", "task", "rt", "server", "check", "http", "com", "queue", "load", "res", "reg", "rh", "tar", "user", "qa", "fr", "data", "circ", "pkg", "desc", "err", "serv", "comp", "pri", "ver", "f", "this", "cmd", "rs", "q", "sq", "crit", "config", "module", "ctx", "hr", "next", "gr", "requ", "er", "per", "priv", "query", "spec", "fer", "str", "resource", "rr", "worker", "inc", "cur", "conn", "flow", "release", "download", "need", "reader", "grab", "ec", "hop", "qt", "ext", "ref", "rf", "pull", "request", "seq", "pro", "once", "ctr", "pr"], "i": ["phi", "di", "f", "ri", "xi", "hi", "x", "ix", "qi", "u", "ci", "li", "t", "ji", "bi", "eni", "uri", "mu", "d", "mi", "n", "ip", "base", "I", "si", "pi", "multi", "id", "index", "ai", "code", "ik", "iu", "ii", "k", "c", "p", "s", "y", "ind", "z", "mini", "ei", "ui", "ni", "zi", "gi", "fi", "e", "l", "io", "oi", "ie", "ini", "v", "ti", "j", "info"], "sign": ["set", "scale", "min", "scan", "shift", "check", "length", "sp", "inc", "Sign", "type", "name", "x", "script", "in", "sh", "load", "sem", "d", "feed", "n", "save", "enc", "id", "parse", "ai", "change", "act", "ign", "pack", "code", "draw", "pay", "pass", "w", "call", "sum", "align", "sk", "connect", "close", "kick", "pos", "ind", "wait", "err", "weight", "send", "pull", "SIGN", "dig", "shape", "fix", "plus", "spec", "sc", "se", "push", "shadow"], "tmp": ["sp", "proc", "cache", "page", "api", "test", "zip", "st", "app", "b", "null", "resp", "attr", "tv", "map", "ppa", "temp", "buf", "pad", "py", "np", "beta", "img", "emp", "data", "tf", "nt", "p", "sb", "fp", "acc", "mp", "j", "cp", "f", "kk", "mmm", "pty", "stuff", "db", "pp", "diff", "rb", "sup", "vt", "txt", "output", "result", "po", "t", "wb", "obj", "tab", "ff", "tt", "ptr", "tc", "gz", "cmp", "appy", "nm", "ie", "buff", "part", "v", "fb", "amp"]}}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static char *choose_pixel_fmts(OutputStream *ost)\n\n{\n\n    if (ost->keep_pix_fmt) {\n\n        if (ost->filter)\n\n            avfilter_graph_set_auto_convert(ost->filter->graph->graph,\n\n                                            AVFILTER_AUTO_CONVERT_NONE);\n\n        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)\n\n            return NULL;\n\n        ost->pix_fmts[0] = ost->st->codec->pix_fmt;\n\n        return ost->pix_fmts;\n\n    }\n\n    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {\n\n        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));\n\n    } else if (ost->enc->pix_fmts) {\n\n        const enum PixelFormat *p;\n\n        AVIOContext *s = NULL;\n\n        uint8_t *ret;\n\n        int len;\n\n\n\n        if (avio_open_dyn_buf(&s) < 0)\n\n            exit_program(1);\n\n\n\n        p = ost->enc->pix_fmts;\n\n        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };\n\n            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,\n\n                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };\n\n            }\n\n        }\n\n\n\n        for (; *p != PIX_FMT_NONE; p++)\n\n            avio_printf(s, \"%s:\", av_get_pix_fmt_name(*p));\n\n        len = avio_close_dyn_buf(s, &ret);\n\n        ret[len - 1] = 0;\n\n        return ret;\n\n    } else\n\n        return NULL;\n\n}\n", "idx": 16693, "substitutes": {"ost": ["ud", "node", "oh", "et", "org", "ods", "irst", "ort", "ob", "ocr", "oper", "st", "ot", "obs", "opt", "rob", "server", "http", "iol", "inst", "op", "dd", "otype", "add", "rod", "od", "design", "lov", "oc", "nt", "object", "boost", "ust", "\u00f3", "roc", "sta", "OST", "ober", "art", "host", "src", "rest", "ad", "old", "oster", "feed", "est", "rog", "ist", "tto", "ord", "oy", "rss", "oop", "o", "ott", "orb", "post", "oss", "sty", "ood", "pod", "gg", "rost", "rot", " nost", "osta", "boot", "ut", "oid", "osc", "word", "tt", "ont", "mot", "hyd", "hop", "ld", "ST", "ft", "ogg", "os", "ast"], "p": ["cp", "f", "pt", "pc", "sp", "ps", "tp", "jp", "wp", "x", "u", "lp", "t", "q", "py", "d", "np", "n", "bp", "pi", "i", "pp", "pa", "pb", "h", "vp", "r", "o", "c", "P", "pn", "fp", "pe", "b", "per", "e", "l", "port", "mp", "v", "pr", "m"], "s": ["g", "cs", "f", "sys", "session", "ps", "u", "ss", "sq", "ns", "n", "si", "i", "r", "o", "ctx", "w", "gs", "c", "sb", "ts", "ssl", "b", "socket", "services", "S", "sg", "e", "ses", "settings", "spec", "ds", "v", "m"], "ret": ["RET", "val", "result", "proc", "sp", "Len", "rs", "res", "q", "buffer", "back", "r", "code", "data", "att", "nt", "al", "resp", "re", "num", "Ret", "seq", "mem", "opt", "out"], "len": ["val", " n", "length", "bin", "net", "Len", "L", "lf", "fun", " clen", "fin", " el", "rev", " l", "nt", "pos", "resp", "per", "en", "count", "seq", " length", "mem", "lit", "ln", "size"]}}
{"project": "FFmpeg", "commit_id": "5e2202d6f3ac2f3afd714a62437ca6b24f75c09f", "target": 1, "func": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)\n\n{\n\n    char buffer[32];\n\n    if (time) {\n\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));\n\n        av_metadata_set2(metadata, \"creation_time\", buffer, 0);\n\n    }\n\n}\n", "idx": 16700, "substitutes": {"metadata": ["header", "component", "database", "name", "node", "cache", "media", "source", "document", "timer", "shadow", "uri", "adata", "tm", "info", "message", "module", "memory", "mo", "storage", "summary", "parser", "data", "binary", "meta", "communication", "archive", "service", "wrapper", "package", "ui", "definition", "handler", "ami", "attr", "username", "manager", "md", "attribute", "m"], "time": ["self", "now", "length", "timeout", "TIME", "clock", "name", " times", "type", "cache", "x", "t", "timer", "window", "tim", "rate", "runtime", "message", "hour", "frequency", "sleep", "user", "h", "code", "duration", "year", "data", "money", "space", "block", "call", "c", "cost", "depth", "content", "delay", "event", "value", "tc", " Time", "comment", "m", "image", "home", "am", "count", "etime", "url", "port", "Time", "im", "method", "times", "ime", "date", "mi", "size", "info"], "buffer": ["wave", "batch", "server", "header", "resource", "token", "timeout", "length", "result", "queue", "cache", "temp", "source", "buf", "array", "document", "window", "pad", "Buffer", "exec", "feed", "bb", "table", "stack", "message", "base", "memory", "code", "duration", "data", "binary", "block", "writer", "byte", "reader", "bar", "raw", "iter", "variable", "append", "event", "thread", "delay", "transfer", "image", "context", "handler", "cb", "url", "text", "reference", "buff", "offset"]}}
{"project": "qemu", "commit_id": "6982d6647ea98544f76d5ef40ddc23115ff44a77", "target": 1, "func": "static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            printf(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                return timer->config;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                return timer->config >> 32;\n\n            case HPET_TN_CMP: // comparator register\n\n                return timer->cmp;\n\n            case HPET_TN_CMP + 4:\n\n                return timer->cmp >> 32;\n\n            case HPET_TN_ROUTE:\n\n                return timer->fsb >> 32;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return s->capability;\n\n            case HPET_PERIOD:\n\n                return s->capability >> 32;\n\n            case HPET_CFG:\n\n                return s->config;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl \\n\");\n\n                return 0;\n\n            case HPET_COUNTER:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick;\n\n            case HPET_COUNTER + 4:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick >> 32;\n\n            case HPET_STATUS:\n\n                return s->isr;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16708, "substitutes": {"opaque": ["opsec", "opsaque", "OPaque", "operec", "opaques", "opec", " opec", "opac", "operac", " opac", "OPacity", "opacity", " opacle", "opsaques", " opacity", "octacle", "OPacle", "octaque", "operaques", "opacle", "opsac", " opaques", "operaque", "octacity"], "addr": ["dr", "fx", "src", "clock", "extra", "node", "x", "tick", "alt", "asm", "prefix", "ix", "pad", "ad", "arm", "end", "conn", "oster", "add", "dim", "np", "inter", "base", "coord", "len", "localhost", "config", "id", "arity", "address", "ord", "r", "adr", "data", "ace", "rx", "ctx", "mid", "hop", "mac", "align", "ext", "slot", "ref", "p", "pos", "nr", "amp", "tx", "pointer", "ptr", "slice", "sta", "rc", "url", "seq", "cmp", "start", "amd", "order", "rt", "md", "player", "host", "offset"], "s": ["g", "self", "session", "bs", "secondary", "ds", "js", "scope", "or", "r", "gs", "c", "ssl", "b", "sl", "stats", "states", "sets", "ins", "qs", "m", "results", "sf", "ments", "ions", "in", "ing", "ns", "si", "args", "i", "es", "als", "p", "sb", "y", "ts", "ks", "sie", "services", "l", "sym", "words", "irs", "its", "sync", "f", "ops", "rs", "south", "ss", "sq", "ings", "n", "ies", "o", "sers", "xs", "er", "S", "sg", "ses", "rates", "is", "cs", "ims", "aws", "t", "d", "ls", "w", "ers", "service", "ed", "e", "os", "times", "v", "settings"], "cur_tick": ["cur_nick", "Cur_time", " cur_nice", "curxtick", " cur_clock", " cur_exc", "Cur_tz", " cur_bug", "cur_clock", "cur_rx", "curxspin", "curamrx", "cur_butt", "ser_bug", "curamtime", "cur_ick", "ser_spin", " cur_nick", "Cur_tip", "ser_tick", "curamicks", "curxick", "curJkick", "curxbug", " cur_hop", "Cur_icks", "cur_tip", "cur_trial", "Cur_ick", "curJtick", "curamtick", " cur_ick", "cur_tz", "cur_hop", "curRtrial", "Cur_tick", "Cur_rx", "cur_spin", "curRtick", "curJclock", "curRnick", "ser_ick", " cur_cookie", "curJbug", "cur_icks", "curxnice", "cur_bug", "curxexc", "cur_cookie", "cur_exc", "cur_nice", " cur_token", "cur_kick", " cur_kick", "curJick", "cur_token", " cur_butt", "cur_time", "curRick", " cur_trial"], "index": ["alpha", "length", "route", "xxxx", "number", "match", "inc", "type", "x", "name", "Index", "prefix", "node", "ix", "axis", "dim", "conn", "point", "connection", "test", "len", "position", "si", "i", "id", "nn", "address", "code", "input", "diff", "ace", "host", "fff", "hop", "align", "loc", "xxx", "loop", "bridge", "height", "pos", "key", "ind", "active", "pointer", "value", "slice", "search", "socket", "weight", "find", "num", "part", "amp", "offset"], "timer": ["server", "header", "inner", "icer", "meter", "later", "timeout", "worker", "clock", "match", "cer", "roller", "runner", "tim", "buffer", "Timer", "tm", "imer", "counter", "peer", "tr", "watch", "message", "ester", "duration", "parser", "reader", "monitor", "trial", "writer", "trigger", "browser", "iter", "time", "loader", "mr", "service", "delay", "amer", "er", "sim", "tc", "ter", "handler", "ger", "term", "driver", "ipper", "task", "trace", "event", "manager", "player", "size", "m"]}}
{"project": "qemu", "commit_id": "bd8b92d5c8387c2c94f06665514c05000169fafd", "target": 1, "func": "void usb_claim_port(USBDevice *dev, Error **errp)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    assert(dev->port == NULL);\n\n\n\n    if (dev->port_path) {\n\n        QTAILQ_FOREACH(port, &bus->free, next) {\n\n            if (strcmp(port->path, dev->port_path) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (port == NULL) {\n\n            error_setg(errp, \"usb port %s (bus %s) not found (in use?)\",\n\n                       dev->port_path, bus->qbus.name);\n\n            return;\n\n        }\n\n    } else {\n\n        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), \"usb-hub\") != 0) {\n\n            /* Create a new hub and chain it on */\n\n            usb_create_simple(bus, \"usb-hub\");\n\n        }\n\n        if (bus->nfree == 0) {\n\n            error_setg(errp, \"tried to attach usb device %s to a bus \"\n\n                       \"with no free ports\", dev->product_desc);\n\n            return;\n\n        }\n\n        port = QTAILQ_FIRST(&bus->free);\n\n    }\n\n    trace_usb_port_claim(bus->busnr, port->path);\n\n\n\n    QTAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    dev->port = port;\n\n    port->dev = dev;\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n", "idx": 16717, "substitutes": {"dev": ["self", "di", "client", " device", "api", "end", "valid", "test", "child", "pub", "der", "block", "conf", "app", "gu", "prov", "comment", "adv", "prom", "name", "temp", "mod", "dd", "pad", "lib", "od", "user", "dom", "data", "sk", "p", "var", "cam", "def", "home", "die", "bug", "serv", "md", "host", "ver", "ad", "plug", "error", "sd", "pu", "iv", "diff", "Dev", "next", "pos", "dist", "ve", "dem", "priv", "ev", " def", "serial", "info", "development", "debug", "new", "conn", "flow", "d", "root", "obj", "av", "private", "pack", "w", "ref", "de", "pro", "driver", "device", "rad", "ds", "v"], "errp": ["errpc", "iersp", "errps", "krsp", " errps", " errpa", "errP", "nerps", "cersp", "ierpa", "lrp", "erP", "krpa", "cerp", "errpr", "lrps", "cerpa", "erp", "erps", "ierp", "cerpr", "ierpr", "errsp", "lrpc", "krps", " errpc", " errP", "nerp", "krp", "krpc", "krpr", "lrpa", "errpa", "nerP"], "bus": ["local", "self", "class", "session", "bs", "proc", "cache", "lo", "board", "view", "BUS", "pl", "block", "gen", "c", "b", "su", "comment", "lab", "usb", "use", "bit", "bo", "http", "ban", "lib", "data", "us", "p", "def", "home", "lock", "die", "l", "bug", "io", "se", "bin", "host", "sync", "ash", "f", "cat", "bc", "plug", "feed", "base", "hub", "kit", "config", "id", "pu", "pass", "pos", "ass", "bis", "cb", "serial", "is", "bi", "front", "back", "root", "obj", "boot", "build", "pack", "band", "mount", "miss", "loop", "bridge", "service", "os", "driver", "Bus", "device", "plugin", "product"], "port": ["self", "client", "component", "match", "PORT", "machine", "Port", "api", "end", "point", "pool", "ort", "connection", "test", "child", "position", "app", "comment", "package", "prop", "use", "m", "server", "interface", "project", "pt", "export", "name", "op", "contract", "slave", "state", "user", "data", "import", "object", "p", "key", "month", "pid", "bug", "ver", "host", "cp", "pc", "number", "allow", "rest", " sport", "ip", "version", "config", "id", "module", "address", "native", "iv", "select", "target", "pass", "next", "post", "pos", "per", "fat", "pod", "nat", "option", "report", "type", "ports", "parent", "proxy", "form", "tag", "path", "mount", "hop", "patch", "service", "function", "text", "driver", "device", "plugin", "v"], "nfree": [" ncomplete", " nrelease", "ncvalid", "Nrelease", "cused", "ncfree", "cfree", "Ncomplete", "cavailable", "ncrelease", "navailable", "nvalid", "lvalid", " nvalid", "lcomplete", "Nvalid", "lused", "lavailable", "Nused", "nrelease", "cvalid", " navailable", "Navailable", "ncomplete", "Nfree", "lfree"], "nused": ["nuse", "cavailable", " navailable", "puse", "pavailable", "pfree", "cused", "navailable", "pused", " nuse", "cfree", "cuse"]}}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static void vmxnet3_update_features(VMXNET3State *s)\n\n{\n\n    uint32_t guest_features;\n\n    int rxcso_supported;\n\n\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,\n\n                                               devRead.misc.uptFeatures);\n\n\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n\n              s->lro_supported, rxcso_supported,\n\n              s->rx_vlan_stripping);\n\n    if (s->peer_has_vhdr) {\n\n        qemu_peer_set_offload(qemu_get_queue(s->nic),\n\n                        rxcso_supported,\n\n                        s->lro_supported,\n\n                        s->lro_supported,\n\n                        0,\n\n                        0);\n\n    }\n\n}\n", "idx": 16723, "substitutes": {"s": ["g", "self", "sites", "session", "uns", "secondary", "js", "plugins", "gs", "conf", "c", "ssl", "b", "su", "fs", "stats", "states", "sets", "ins", "qs", "m", "server", "http", "u", "ns", "site", "si", "args", "i", "state", "your", "full", "es", "us", "params", "sb", "p", "ts", "ks", "services", "l", "sym", "serv", "its", "sync", "f", "ops", "sports", "rs", "ss", "sq", "native", "o", "xs", "S", "sg", "ses", "options", "spec", "is", "cs", "ims", "aws", "sys", "ps", "new", "t", "d", "storage", "status", "ls", "details", "service", "e", "os", "ds", "settings"], "guest_features": ["guest_feat", "guist_faces", "guesting_feature", "guester_features", "guester_plugins", "guesting_products", "guesting_events", "guested_results", "guist_features", "guest_needs", "guestingevents", "guess_features", "guested_flows", "guester_feature", "guesting_features", "guess_needs", "guest_faces", "guest_events", "guestingflows", "guestingresults", "guest_words", "guested_feat", "guest_classes", "guester_classes", "guestingfeat", "guested_features", "guest_products", "guess_events", "guest_feature", "guest_plugins", "guest_facts", "guestingfeature", "guestingfeatures", "guist_facts", "guist_words", "guest_flows", "guestingproducts", "guest_results"], "rxcso_supported": ["rxclo_protected", "rxcso_successful", "rxcfo_protected", "rxcso_published", "rxclo_supported", "rxcfo_successful", "rxcso_protected", "rxcso_disabled", "rxcsoxsuccessful", "rxcsoxdisabled", "rxclo_successful", "rxcfo_supported", "rxcco_supported", "rxcco_successful", "rxcso_support", "rxcco_support", "rxcsoxsupport", "rxcfo_support", "rxclo_support", "rxcsoxsupported", "rxcco_published"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int virtio_blk_exit_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n\n\n    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);\n\n    return virtio_exit_pci(pci_dev);\n\n}\n", "idx": 16724, "substitutes": {"pci_dev": ["pci_ver", "pci2device", "pki_ver", "pci__dev", "pci_private", "pciamdevice", "pci2ev", "pki_rad", "pki_device", "pci__device", "pci_rad", "pci_ev", "pki_ev", "pki_private", "pci2dev", "pci_device", "pciamdev", "pciamprivate", "pci__rad", "pki_dev"], "proxy": ["core", "server", " proxies", "copy", "client", "pc", "proc", "instance", "cache", "parent", "buf", "pipe", "library", "Proxy", "web", "super", "buffer", "connection", "pool", "root", "base", "ip", "child", "config", "slave", "cop", "block", "pse", "ca", "ref", "bridge", "service", "wrapper", "gp", "phy", "rc", "bus", "port", "pid", "driver", "io", "clone", "sync"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A = 0xffff<<14;\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]    ) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16727, "substitutes": {"ubuf0": ["abbuf8", "ubbuff0", "ubbuff3", "ubbuff2", "abuf00", "abuf2", "abuf8", "ubbuff1", "ubbuf0", "abbuf0", "ubuf2", "ubbuf00", "ubf2", "abbuf1", "ubbuf3", "ubbuf1", "ubimg1", "abbuf3", "ubbuff00", "abbuf00", "ubuf00", "ubimg00", "abuf0", "ubuf8", "ubbuf2", "abbuf2", "ubf0", "ubbuff8", "ubuf3", "ubimg3", "abuf3", "ubf1", "ubimg0", "ubf8", "abuf1", "ubbuf8"], "vbuf0": ["vufk", " vbuffer0", " vbufk", "fbuf1", " vbuf2", " vbufferk", "vbc0", "vbuff1", "vbc1", "vbuf2", "vuf1", "fbuffee", "vufee", "vbuffer2", "vbufferk", "vbuffk", " vbuffer1", "vbuffer0", "vbuff0", "vbc2", "vbufk", "fbuff1", "fbuff0", "vbufee", "fbuf2", "vbuff2", "vbuffer1", "vbuffee", "vuf2", "vuf0", "fbufee", "fbuf0", "fbuff2", "vbcee", " vbuffer2"], "i": ["phi", "di", "inner", "my", "f", "ri", "xi", "x", "u", "qi", "ix", "ci", "li", "source", "abi", "t", "eni", "bi", "uri", "it", "mu", "d", "mi", "info", "n", "ip", "I", "si", "pi", "multi", "id", "ai", "index", "iu", "w", "ii", "c", "k", "p", "y", "b", "slice", "ui", "ni", "zi", "gi", "yi", "fi", "e", "l", "io", "oi", "ie", "ini", "v", "ti", "j", "m"], "R": ["Y", "D", "M", "RP", "Q", "L", "Rh", "H", "I", "Ra", "X", "O", "r", "E", "RO", "N", "U", "RS", "RC", "GR", "P", "A", "UR", "RA", "SR", "DR", "Rs", "C", "RH", "RR", "V", "W"], "G": ["g", "Y", "GA", "D", "M", "GG", "GV", "Q", "L", "GW", "Gu", "H", "I", "X", "GD", "Group", "O", "Gr", "E", "Ge", "MG", "N", "GP", "U", "GR", "P", "F", "GH", "PG", "LG", "S", "GF", "A", "SG", "GM", "GN", "J", "C", "GB", "W", "V", "GE", "GC"], "B": ["Y", "BO", "BE", "D", "M", "AB", "BI", "Q", "WB", "MB", "L", "BC", "H", "CB", "I", "O", "BF", "NB", "E", "U", "P", "F", "Bo", "b", "A", "BG", "BY", "IB", "J", "C", "GB", "Bs", "W", "V", "DB", "BL", "BA"], "ubuf1": ["ubbuff0", "ubbuffp", "ubufs", "ubbufs", "ubbuff1", "ubbuf0", "abbuf0", "ubbufp", "ubufp", "abbufs", "ubimgp", "abufp", "abbuf1", "ubbuffs", "ubbuf1", "ubimg1", "ubimgs", "abufs", "abuf0", "abbufp", "ubimg0", "abuf1"]}}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n", "idx": 16728, "substitutes": {"packet": ["packsetter", "ackel", "packhole", "packinet", "packset", "payacket", "asacket", "payet", "acket", "encacket", "encel", "ppinet", "ackhole", "payel", "enchole", "encet", "asinet", "ppacket", "payhole", "ackacket", "packsinet", "packacket", "packel", "ppetter", "aset", "asetter", "packetter", "ppet", "packsacket"], "opaque": ["openacity", "opque", "compacity", "iopque", "compaque", "openicit", "openaque", "opacity", "openque", " opque", "copaque", "operonymous", "operque", " opacity", "copque", "opicit", " opicit", "coponymous", "operaque", "iopaque", "oponymous", "compicit", "ioponymous", "compque"], "s": ["g", "server", "sf", "sys", "f", "ops", "secondary", "south", "ss", "sq", "sw", "ns", "n", "args", "slave", "submit", "o", "params", "c", "p", "sb", "service", "ssl", "b", "sl", "socket", "fs", "services", "stats", "S", "states", "sg", "ses", "settings", "e", "os", "sym", "spec", "m"], "async": ["Asyn", " asyn", "asynchronous", " asAsync", "assAsync", "assynchronous", "acynchronous", "rasynchronous", "acync", "assync", " assync", " asynchronous", "asynchron", "rasyn", "rasync", "Asynchronous", "acyn", " asynchron", "Asynchron", "asssync", "assyn", "rasAsync", "asyn", "nasynchronous", "rassync", "acsync", "Async", "nasync", "nasynchron", "nasyn", "asAsync"]}}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n", "idx": 16735, "substitutes": {"reg": ["g", "ru", "round", "min", "rec", "map", "greg", "pattern", "cache", "mod", "orig", "req", "rar", "tag", "np", "config", "memory", "xp", "rem", "r", "data", "loc", "gr", "pre", "c", "p", "region", "Reg", "ind", "re", "rg", "dist", "rc", "num", "mem", "arr", "order", "debug", "bin", "REG", "m"], "q": ["g", "f", "quant", "Q", "qi", "x", "queue", "u", "t", "sq", "req", "ch", "i", "eq", "h", "qa", "qq", "o", "w", "qt", "iq", "c", "k", "p", "depth", "qu", "z", "count", "query", "order", "qs", "v"], "tmp": ["sample", "cp", "txt", "now", "proc", "cache", "temp", "buf", "array", "prefix", "pad", "buffer", "test", "np", "bb", "comb", "obj", "i", "config", "tab", "beta", "zip", "storage", "pb", "img", "sam", "ctx", "xt", "pre", "rb", "loc", "app", "c", "fp", "p", "prep", "nr", "sup", "mb", "tc", "mini", "nb", "cb", "rc", "num", "mem", "cmp", "mp", "nm", "mm", "buff", "crop", "ctr", "offset"], "size": ["core", "sn", "scale", "cn", "shift", "x", "sh", "sq", "form", "Size", "len", "ch", "SIZE", "enc", "small", "j", "i", "ize", "code", "loc", "k", "c", "sync", "p", "z", "use", "gn", "en", "ne", "rc", "sec", "num", "shape", "e", "mode"], "n": ["g", "sn", "cn", "min", "none", "f", "name", "x", "u", "nc", "na", "net", "t", "conn", "ny", "d", "no", "ns", "np", "len", "i", "nn", "one", "r", "o", "w", "N", "an", "k", "c", "nt", "p", "pn", "y", "nr", "b", "z", "mn", "en", "ni", "nb", "ne", "num", "fn", "un", "e", "rn", "l", "nw", "network", "dn", "nu", "inn", "nat", "v", "j", "m"], "t0": ["pt0", "T8", "ty8", "T0", "tt1", " tk", "ty1", "t100", "pt2", "ttee", "t00", " t2", "Tk", "ty50", " t100", "p100", "p0", "Tee", "tt0", "p1", "T1", "T00", " t8", "tk", "t8", "pt1", "T100", "ttk", "p50", "T2", "T50", "pt00", "p2", "p00", "t2", "tee", "t50", " t50", "ty0", " tee"], "t1": [" tone", " t4", "t7", " t7", "T0", "Tone", "TOne", " tb", " t2", "p0", "p4", "taOne", "pone", "T4", "p1", "T1", "pb", "tone", "T2", "ta0", "p2", "t4", "ta1", "t2", " t5", "at1", "tb", "at2", "ta7", "t5", "atone", "T7", " tOne", "T5", "Tb", "at5", "tOne"]}}
{"project": "qemu", "commit_id": "f892291eee376505cfec8b6cade7ccf952a6d3e0", "target": 0, "func": "static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n", "idx": 16752, "substitutes": {"dist": ["dr", "progress", "txt", "df", "grad", "src", "cli", "inst", "work", "dd", "grade", "conn", "distance", "req", "d", "Dist", "np", "obj", "sd", "config", "multi", "dev", "dj", "dt", "ist", "private", "ord", "dir", "data", "diff", "draw", "ctx", "ext", "det", "ld", "std", "missing", "nd", "def", "sup", "desc", "transfer", "ui", "dest", "dat", "md", "info"], "errp": ["errpc", "astt", "reqpa", " errpa", "asterp", "errP", " errr", "errg", "terper", "errorp", " errc", "serpa", "tert", "errpe", "asterfp", "acerp", "rrP", "rrpc", "rrc", "acersp", "erpc", "errb", "reqp", "erpe", "asterpe", "serp", " errper", "errper", "acerr", " errg", "Erpe", " errt", "acerfp", "astb", "ersp", "erp", " errb", "reqb", "terp", "errorc", "errsp", "erfp", "Erpc", "asterpc", " errsp", "rrp", "err", " errpc", " errfp", "Erp", "errorP", "errorpc", " errP", "errfp", "terb", "astper", "errr", "errt", "reqg", "Erfp", "errpa", "serg", "astp", "serb", "errc"]}}
{"project": "FFmpeg", "commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "target": 1, "func": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n", "idx": 16755, "substitutes": {"avctx": ["awmc", "gcp", "akctx", "gctx", "gmc", "akctl", "awctx", "ajcontext", "airctl", "awcontext", "avcontext", "avloc", "avmc", "akloc", "ajctx", "akcli", "AVctx", "avctl", "awcp", "avcp", "airloc", "AVcli", "ajmc", "airctx", "AVctl", "ajcp", "aircli", "avcli", "AVloc", "gcontext"], "gbc": ["gmfc", " gec", "reglic", "gsbc", "garc", "gmrc", "igec", "rgpc", "agcms", " gcb", "ggcms", "aguc", " gfc", "Gfc", "grc", "garuc", "Grc", "regec", "garbc", "igbc", "igcms", "guc", "hbc", "lbc", "aggcms", "gsfc", "gscf", "gc", "ggcb", "ggc", "ggpc", " gpc", " guc", "iguc", "gencb", "agbc", "rgbc", "ggec", "Gbc", "gec", "rgfc", "ggfc", "blc", "ggbc", "regcms", "gsuc", "gguc", "hlic", "gfc", "glc", "gglc", "gglic", "hcms", "ggcf", "gencms", "lpc", "gslic", "buc", " gcf", "blic", "lcb", "lfc", "Gcb", "aggbc", "genfc", " gc", "gcms", " glic", "gmbc", "gslc", "garfc", "gmcb", "aggcb", "gcf", "rguc", "gpc", "glic", "aggpc", "gcb", "genpc", "genbc", "regbc", "hec", "bbc", " gcms", "agec", " grc"], "pal": ["val", "chal", "Pal", "ap", "pol", "cal", "bin", "style", "ol", "array", "li", "pad", "el", "py", "base", "plan", "opal", "pl", "panel", "chi", "pel", "span", "ace", "par", "cell", "align", "app", "al", "p", "pixel", "wal", "nav", "pill", "attr", "ab", "area", "isal", "ph", "pro", "pan", "arr", "list", "color", "white"], "colors": ["colorlections", "Colors", " recolors", "collors", "filores", "colons", "Colores", "collections", "Colons", " recolons", "colores", "collORS", "filors", "collores", "Collections", " recolories", "filons", "colorors", "Colories", "colorores", " recolores", "colORS", "colllections", "ColORS", "colorORS", "filories", "colories"], "i": ["phi", "di", "f", "xi", "cli", "hi", "x", "qi", "u", "ci", "li", "eni", "bi", "mu", "d", "n", "ti", "ip", "I", "si", "pi", "multi", "index", "chi", "ai", "iu", "o", "ii", "c", "p", "y", "slice", "ui", "ni", "zi", "yi", "fi", "e", "l", "ori", "a", "io", "oi", "ini", "v", "mi", "j", "m"], "r": ["ru", "dr", "rr", "ro", "u", "rs", "x", "sr", "lr", "R", "d", "rh", "n", "ar", "fr", "rx", "br", "hr", "w", "rb", "gr", "c", "k", "p", "rl", "nr", "mr", "er", "rg", "re", "err", "ur", "vr", "rc", "gb", "e", "l", "a", "rt", "v", "pr", "m"], "g": ["gar", "gm", "f", "erg", "x", "u", "gam", "gc", "gre", "d", "mg", "n", "ge", "pg", "ig", "w", "gas", "ga", "gr", "gs", "gen", "c", "p", "s", "G", "gu", "gh", "rg", "gp", "gn", "group", "gi", "gy", "sg", "e", "gb", "l", "gg", "a", "eg", "bg", "v", "m"], "b": ["bd", "f", "B", "bs", "x", "u", "xb", "t", "wb", "d", "bb", "n", "beta", "db", "ob", "ib", "o", "eb", "bar", "w", "ba", "rb", "c", "p", "abb", "sb", "y", "mb", "nb", "cb", "ab", "bf", "e", "gb", "l", "a", "lb", "bg", "v", "bl", "fb"]}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n", "idx": 16767, "substitutes": {"a": ["alpha", "f", "sa", "ac", "ad", "d", "n", "i", "aw", "pa", "va", "ae", "ma", "aa", "asa", "ba", "ga", "ama", "ca", "c", "p", "aaa", "da", "am", "A", "la", "as", "ab", "area", "e", "an", "au"], "b": ["g", "bd", "f", "B", "bs", "x", "d", "wb", "bb", "base", "i", "db", "ob", "ib", "emb", "pb", "eb", "bar", "ba", "rb", "c", "sb", "p", "abb", "y", "be", "as", "ab", "bf", "e", "l", "other", "lb", "v", "fb"]}}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,\n\n                                      uint32_t index, int reg)\n\n{\n\n    struct kvm_cpuid2 *cpuid;\n\n    int i, max;\n\n    uint32_t ret = 0;\n\n    uint32_t cpuid_1_edx;\n\n\n\n    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {\n\n        return -1U;\n\n    }\n\n\n\n    max = 1;\n\n    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {\n\n        max *= 2;\n\n    }\n\n\n\n    for (i = 0; i < cpuid->nent; ++i) {\n\n        if (cpuid->entries[i].function == function &&\n\n            cpuid->entries[i].index == index) {\n\n            switch (reg) {\n\n            case R_EAX:\n\n                ret = cpuid->entries[i].eax;\n\n                break;\n\n            case R_EBX:\n\n                ret = cpuid->entries[i].ebx;\n\n                break;\n\n            case R_ECX:\n\n                ret = cpuid->entries[i].ecx;\n\n                break;\n\n            case R_EDX:\n\n                ret = cpuid->entries[i].edx;\n\n                switch (function) {\n\n                case 1:\n\n                    /* KVM before 2.6.30 misreports the following features */\n\n                    ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA;\n\n                    break;\n\n                case 0x80000001:\n\n                    /* On Intel, kvm returns cpuid according to the Intel spec,\n\n                     * so add missing bits according to the AMD spec:\n\n                     */\n\n                    cpuid_1_edx = kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);\n\n                    ret |= cpuid_1_edx & 0x183f7ff;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(cpuid);\n\n\n\n    return ret;\n\n}\n", "idx": 16771, "substitutes": {"env": ["core", "self", "server", "eu", "session", "proc", "worker", "export", "erv", "inst", "net", "conn", "eni", "org", "end", "api", "exec", "scope", "window", "np", "enc", "config", "dev", "osc", "db", "state", "eng", "init", "code", "emb", "vs", "ef", "ec", "engine", "exc", "esi", "conf", "ea", "cf", "ce", "ou", "loader", "esm", "inv", "ep", "er", "eve", "en", "context", "viron", "ev", "e", "environment", "que", "ah", "event", "manager", "eye"], "function": ["section", "class", "resource", "interface", "family", "expression", "rule", "sequence", "operator", "f", "number", "operation", "unc", "Function", "command", "name", "global", "range", "parent", "array", "type", "library", "document", "form", "exec", "connection", "fun", "version", "module", "word", "code", "native", "functional", "r", "program", "man", "replace", "loc", "callback", "reason", "object", "future", "public", "region", "service", "func", "role", "unit", "action", "value", "lambda", "package", "run", "handler", "fn", "activation", "method", "event", "feature", "mode"], "index": ["is", "val", "scan", "expression", "pattern", "length", "number", "inc", "Index", "name", "axis", "type", "x", "ix", "instance", "in", "end", "error", "valid", "connection", "position", "version", "ion", "location", "id", "column", "address", "diff", "call", "loc", "part", "connect", "object", "key", "ind", "pointer", "value", "search", "update", "action", "slice", "find", "image", "weight", "num", "row", "start", "fix", "custom", "ini", "pin", "original", "info"], "reg": ["g", "rec", "rule", "pattern", "proc", "result", "match", "range", "rest", "mod", "res", "tag", "fun", "len", "config", "init", "r", "rx", "addr", "loc", "Reg", "region", "func", "def", "thread", "re", "rg", "flag", "rc", "sec", "num", "ret", "row", "debug", "REG", "feature"], "cpuid": ["CPuid", "cppuu", " cpuint", "chuu", "ppupid", "cppuser", "cpsid", "copnum", "cfuid", "copupid", "cpdu", "ppuri", "CPuri", " cpuri", "compuu", "copuser", " cpuu", " cpnum", " cpsid", "pu", " cpuda", "copuid", "cpnum", "copdu", "cppu", " cpdu", "copuint", "psid", "cfupid", "pupid", "puid", "ppid", "compuid", "cppsid", "cpuu", "copuri", "ppuda", "cppupid", "CPupid", "cpuri", "cpuint", "cpu", "cppnum", "chupid", "cppdu", "compuint", "CPuu", "copuu", "copuda", "copid", "chid", " cpu", "cpid", "cppuda", "cfuu", " cpuser", " cpudi", "compid", "ppuu", "cpuda", "cpuser", "cppuri", "cpudi", "compuri", "cfudi", "cppuid", "ppuid", " cpupid", " cpid", "copudi", "cpupid", "cppid", "chuid"], "i": ["g", "phi", "di", "min", "interface", "uli", "f", "ri", "xi", "cli", "x", "ix", "qi", "u", "ci", "in", "li", "isin", "source", "eni", "end", "it", "uri", "api", "d", "info", "n", "or", "base", "I", "pi", "ip", "ti", "id", "si", "r", "ai", "iv", "status", "iu", "lc", "ii", "c", "k", "p", "y", "ind", "b", "ui", "image", "gi", "fi", "yi", "ret", "e", "start", "l", "ori", "io", "im", "ie", "ini", "oi", "v", "mi", "j", "m"], "max": ["can", "min", "rec", "range", "rest", "x", "work", "mod", "parent", "res", "end", "orig", "MAX", "est", "ax", "id", "rank", "chain", "cl", "r", "co", "last", "wrap", "w", "total", "mac", "conf", "c", "p", "limit", "key", "cr", "re", "step", "count", "num", "ret", "row", "Max", "custom", "size"], "cpuid_1_edx": ["cpuid_1_edf", "cpuid_1_idb", "cpuid_1_ledex", "cpuid_1_Edb", "cpuid_1_idw", "cpuid_1_adxa", "cpuid_1_idf", "cpuid_1_endedex", "cpuid_1_edxa", "cpuid_1_adX", "cpuid_1_endedb", "cpuid_1_idex", "cpuid_1_eedf", "cpuid_1_edex", "cpuid_1_endedxa", "cpuid_1_ledx", "cpuid_1_eedw", "cpuid_1_endedx", "cpuid_1_endedX", "cpuid_1_eedex", "cpuid_1_eedx", "cpuid_1_hedxa", "cpuid_1_edb", "cpuid_1_ledf", "cpuid_1_hedx", "cpuid_1_ledw", "cpuid_1_Edex", "cpuid_1_hedX", "cpuid_1_Edx", "cpuid_1_adx", "cpuid_1_edX", "cpuid_1_idx", "cpuid_1_EdX", "cpuid_1_edw", "cpuid_1_idX"]}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n\n                          uint8_t **bufptr, DumpState *s)\n\n{\n\n    GuestPhysBlock *block = *blockptr;\n\n    hwaddr addr;\n\n    uint8_t *buf;\n\n\n\n    /* block == NULL means the start of the iteration */\n\n    if (!block) {\n\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n\n        *blockptr = block;\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        if (bufptr) {\n\n            *bufptr = block->host_addr;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    *pfnptr = *pfnptr + 1;\n\n    addr = pfn_to_paddr(*pfnptr);\n\n\n\n    if ((addr >= block->target_start) &&\n\n        (addr + s->page_size <= block->target_end)) {\n\n        buf = block->host_addr + (addr - block->target_start);\n\n    } else {\n\n        /* the next page is in the next block */\n\n        block = QTAILQ_NEXT(block, next);\n\n        *blockptr = block;\n\n        if (!block) {\n\n            return false;\n\n        }\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        buf = block->host_addr;\n\n    }\n\n\n\n    if (bufptr) {\n\n        *bufptr = buf;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16780, "substitutes": {"blockptr": ["boxPo", "blockPo", "Blockptr", "pluginptr", " blockpointer", "boxptr", "BlockPtr", "boxpt", "lockpointer", " blockpt", "lockPtr", "pluginpointer", "blockaddr", "lockptr", "pluginPtr", "BlockPo", "Blockpointer", "boxPtr", " blockPtr", " blockaddr", "lockaddr", "boxpointer", "lockpt", "blockPtr", "blockpt", "Blockaddr", " blockPo", "blockpointer"], "pfnptr": [" pdnpointer", "cfnater", "ppfcptr", "cknater", "pdnaddr", "pfcctr", "ppfnaddr", "pconnPtr", "pfdsize", "pfnater", "pnmpointer", " pdnptr", "pdnptr", "ppfcctr", " pfnattr", "pknsize", "pfdptr", "pfnsize", "pfpaddr", " pfpctr", "pknater", "pfnpointer", "pfnPtr", "pformatrect", "pfnctr", "cknptr", "pbnaddr", "Pnmptr", "lpformatptr", "pfunater", "cknaddr", "pformatptr", "pfcaddr", " pfnpointer", "pnmattr", "pfcsize", "Pfnctr", "lpfnptr", "pknPtr", "pfpattr", "pformatPtr", "Pfnpointer", "pfdaddr", "cknpointer", "pnmPtr", "ppfnsize", "cfnaddr", "pfnattr", "pfunaddr", "pknaddr", "pfcptr", "ppfcaddr", "cfnptr", "pbnpointer", "lpformatrect", "pfunptr", "pconnptr", "pfdctr", "pdnpointer", "Pnmctr", " pdnctr", " pfpptr", "pfpptr", "lpformatPtr", " pfnctr", "pknattr", "pknctr", "lpfnPtr", "pnmptr", "ppfcsize", "pconnrect", " pfpaddr", "cfnpointer", "ppfnctr", "ppfnptr", "Pfnptr", "Pnmpointer", "pfunpointer", "pbnptr", "pfpctr", "pdnPtr", "PnmPtr", "pknpointer", "pnmctr", " pfnaddr", "pknptr", "lpfnrect", "pfnrect", "pbnater", "PfnPtr", " pdnaddr", " pfpattr", "pdnctr", "pfnaddr", "pnmaddr"], "bufptr": ["cvpointer", "bufPtr", "ctxaddr", "cbpointer", "ufaddr", "ufptr", "cbaddr", "ctxpointer", "buffPtr", "bufaddr", "ufPtr", " bufpointer", " bufdr", "cvref", "bufferPtr", "seqaddr", "bufdr", "buffaddr", "ctxptr", "ctxref", "cbPtr", "cvPtr", "seqPtr", "buffpointer", "ufdr", "cvaddr", "seqpointer", "ufref", " bufaddr", "cbptr", "buffdr", "bufref", "bufferptr", "bufferpointer", "cvptr", "bufpointer", "buffptr", "bufferaddr", "ufpointer", "seqptr"], "s": ["g", "set", "session", "ship", "js", "sh", "scope", "h", "r", "comm", "conf", "gs", "c", "ssl", "b", "sl", "ches", "su", "fs", "states", "ares", "sets", "a", "qs", "m", "server", "u", "ments", "ns", "site", "si", "has", "i", "state", "es", "views", "p", "sb", "ts", "services", "l", "sym", "its", "sync", "f", "ops", "rs", "ss", "sq", "q", "n", "id", "ips", "address", "o", "S", "en", "sg", "ses", "spec", "info", "is", "ims", "groups", "sys", "ps", "new", "t", "d", "status", "w", "side", "time", "service", "slice", "request", "e", "os", "features", "v", "ds", "an", "settings"], "block": ["batch", "set", "self", "none", "layout", "session", "node", "cache", "link", "script", "off", "page", "end", "exec", "point", "board", "view", "record", "chain", "cl", "label", "call", "close", "line", "limit", "b", "null", "comment", "update", "image", "network", "open", "box", "check", "bo", "Block", "map", "clock", "name", "work", "clean", "ban", "bb", "user", "index", "full", "object", "p", "key", "group", "month", "wall", "lock", "blocking", "num", "row", "model", "day", "list", "out", "bl", "sync", "number", "bc", "frame", "error", "buffer", "n", "base", "ip", "config", "module", "blocks", "address", "init", "next", "join", "run", "query", "ack", "spec", "info", "header", "type", "new", "tick", "flow", "down", "pack", "loc", "loop", "ref", "inv", "unit", "tx", "slice", "un", "event", "plugin", "an"], "addr": ["val", "grad", "x", "ix", " address", "ar", "byte", "ha", "amp", "attr", "amd", "rt", "oa", "az", "alloc", "mode", "dr", "alpha", "name", "pad", "add", "coord", "index", "ady", "hash", "pkg", "sta", "url", "alias", "au", "host", "offset", "src", "ad", "ip", "id", "address", "ord", "ace", "pos", "pointer", "rc", "ril", "arr", "ack", "spec", "info", "str", "rr", "type", "ac", "aug", "conn", "inter", "len", "obj", "adr", "doc", "hop", "align", "loc", "ref", "nr", "Address", "ress", "ptr", "slice", "adder", "seq", "cmp", "ast", "size"], "buf": ["batch", "lim", "vec", "af", "src", "uf", "result", "cmd", "brace", "queue", "bc", "feat", "runner", "off", "buffer", "pool", "coord", "len", "border", "fd", "config", "aux", "ff", "pb", "img", "cas", "ctx", "br", "cap", "byte", "loc", "rb", "cf", "bag", "tmp", "func", "holder", "pkg", "fb", "prop", "cb", "rc", "ab", "seq", "text", "port", "bu", "box", "buff", "bin", "alloc", "offset"]}}
{"project": "qemu", "commit_id": "280d373579558f73a8b70e329d9a6206933d3809", "target": 0, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta->nb_clusters > 0 &&\n\n            (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS)) {\n\n            qcow2_mark_dirty(bs);\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta != NULL) {\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            run_dependent_requests(s, l2meta);\n\n            g_free(l2meta);\n\n            l2meta = NULL;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    if (l2meta != NULL) {\n\n        run_dependent_requests(s, l2meta);\n\n        g_free(l2meta);\n\n    }\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 16783, "substitutes": {"bs": ["lbs", "cs", "ps", "bc", "BS", "js", "bh", "ss", "bi", "org", "its", "ns", "bb", "base", "banks", "db", "ob", "bits", "pb", "iss", "vs", "ls", "bps", "us", "sb", "bas", "ks", "b", "obs", "fs", "bytes", "bis", "cb", "ab", "gb", "ses", "bos", "os", "outs", "ins", "lb", "bes", "ds", "qs", "bl", "fb", "sync"], "sector_num": ["section_offset", "sector_no", "sectorPoffset", "sectorPnum", "section_no", "sector_index", "axis_range", "sector6offset", "sector6start", "section_start", "section_number", "axis_num", "sector_offset", "sectorPnumber", "sector_range", "section_num", "sector_start", "axis_number", "section_mult", "section_name", "sector6num", "sector_name", "sector_mult", "sector6number", "sectorPstart", "axis_index", "sector_number"], "remaining_sectors": ["remaining_seonents", "remaining_secllor", "remaining_SErets", "remaining_cegments", "remaining_suctors", "remaining_SEctors", "remaining_kegments", "remaining_SEivers", "remaining_veonents", "remaining_seriers", "remaining_surets", "remaining_kellor", "remaining_sucs", "remaining_serets", "remaining_syllor", "remaining_psecs", "remaining_secs", "remaining_spegments", "remaining_SEgments", "remaining_SEcs", "remaining_veriers", "remaining_secgments", "remaining_seivers", "remaining_vectors", "remaining_cectors", "remaining_sexes", "remaining_pseriers", "remaining_perseonents", "remaining_sygments", "remaining_psectors", "remaining_syxes", "remaining_secctors", "remaining_cecs", "remaining_persectors", "remaining_sugments", "remaining_ceivers", "remaining_psegments", "remaining_specs", "remaining_perseriers", "remaining_kexes", "remaining_syctors", "remaining_secxes", "remaining_pserets", "remaining_kectors", "remaining_segments", "remaining_persegments", "remaining_sellor", "remaining_speivers", "remaining_spectors", "remaining_pseonents", "remaining_vegments"], "qiov": ["qicho", "qiev", "quoyer", "sqoyer", " qimoto", "quimoto", "qimoto", "sqimoto", "sqiov", "qqoyer", "zilo", "zoyer", " qiev", "quiov", "qqiev", " qoyer", "qqilo", "quicho", "ziev", "qoyer", "qqiov", " qilo", "ziov", "qilo", " qicho", "sqicho"], "s": ["g", "set", "self", "sites", "lines", "session", "secondary", "js", "support", "members", "gs", "conf", "c", "b", "ssl", "sl", "su", "fs", "stats", "states", "sets", "utils", "ins", "qs", "m", "server", "http", "ns", "site", "si", "args", "tests", "state", "full", "p", "sb", "ts", "sie", "ks", "services", "sv", "sym", "words", "its", "sync", "f", "less", "rs", "ss", "sq", "n", "o", "files", "xs", "S", "sg", "ses", "hs", "spec", "is", "cs", "groups", "sys", "aws", "sa", "ps", "t", "parts", "storage", "ls", "stat", "side", "service", "comments", "e", "os", "ds", "settings"], "index_in_cluster": ["index_in_Clrome", "index_in_Clivery", "index_in_CLusters", "index_in_Cliton", "index_in_sclause", "index_in_CLuration", "index_in_Cluration", "index_in_Clica", "index_in_combusters", "index_in_warome", "index_in_velrome", "index_in_quause", "index_in_waivery", "index_in_oclusters", "index_in_scluster", "index_in_velivery", "index_in_cluration", "index_in_Clusters", "index_in_wausters", "index_in_quusters", "index_in_oclancer", "index_in_cliton", "index_in_clrome", "index_in_comborer", "index_in_clica", "index_in_ocluster", "index_in_Clorer", "index_in_chuster", "index_in_clivery", "index_in_veluster", "index_in_clusters", "index_in_wauster", "index_in_CLuster", "index_in_clorer", "index_in_combuster", "index_in_ocliton", "index_in_chancer", "index_in_chiton", "index_in_sclica", "index_in_clause", "index_in_chusters", "index_in_quuster", "index_in_clancer", "index_in_quica", "index_in_velusters", "index_in_comburation", "index_in_CLorer", "index_in_Clause", "index_in_Cluster", "index_in_Clancer", "index_in_sclusters"], "n_end": ["N_ends", "n_offset", "N_end", "n_ends", "nxend", "n2start", "n00ended", "n00offset", "nxpost", "e_set", "n00end", "nsended", "nsend", "n_start", "n2end", "n_set", "n_END", "n2ends", " n_start", "nxstart", "nIPstart", "e_ended", "nIPpost", "n00set", "n_post", "nsset", "N_start", "sn_post", "n_ending", "e_offset", "nIPEND", "sn_END", "sn_start", "nIPend", "n__ending", "n__end", "n_ended", "sn_end", " n_ended", "nxEND", "nsoffset", " n_ending", "n__ends", "e_end", " n_ends", "n2ending", "n2ended"], "ret": ["RET", "val", "bit", "result", "match", "alt", "res", "conn", "success", "reg", "back", "no", "len", "fun", "mt", " RET", "id", "fin", "code", "rev", "rets", "total", "ext", "att", "ref", "det", "nt", "gt", "hash", "flag", "re", "group", " Ret", "ft", "rc", "num", "Ret", "seq", "bf", "arg", "lit", "rt", "part"], "cur_nr_sectors": ["cur_nr_secctors", "cur_nr_vectors", "cur_nr_tevers", "cur_nr_tections", "cur_nr_vevers", "cur_nr_secgments", "cur_nr_secrets", "cur_nr_secvers", "cur_nr_verets", "cur_nr_srets", "cur_nr_serets", "cur_nr_sections", "cur_nr_tectors", "cur_nr_severs", "cur_nr_secctions", "cur_nr_segments", "cur_nr_sgments", "cur_nr_vegments", "cur_nr_vections", "cur_nr_tegments", "cur_nr_sctors"], "cluster_offset": ["cluster_num", "cluster_end", "clica_index", "cluster___offset", "cluster_size", "clusteringnumber", "clica2number", "cluster_index", "cluster2number", "clusters_size", "clusteringdone", "clusteringindex", "clica2index", "clusters_end", "clica2done", "cluster___done", "clica2offset", "clusters_num", "cluster2offset", "cluster_start", "cluster_done", "cluster2index", "cluster2done", "clusteringoffset", "clusters_offset", "cluster___number", "clica_number", "cluster___index", "clica_offset", "clica_done", "cluster_number"], "hd_qiov": ["xd_\n", "hd_qiop", "hd_\t", "hd___\n", "hd_sqiov", "hd_quiop", "hd_sqoyer", "hd_sqiop", "hd___seq", "hd_qoyer", "hd_qrolet", "hd_shiop", "xd_seq", "hd_sqrolet", "hd_quiov", "hd_\n", "hd_qurolet", "hd_Qrolet", "hd_shrolet", "hd_quoyer", "hd_Qiop", "hd_seq", "hd___\t", "hd_Qiov", "xd_\t", "hd_Qoyer", "hd_shoyer", "hd_shiov"], "cluster_data": ["cluster2info", "cluster_info", "cluster_size", "clusters_size", "cluster2size", "cluster2offset", "cluster2data", "clusters_offset", "clusters_info", "clusters_data"], "l2meta": [" l3metadata", " l4metadata", "l6data", "l2magic", "loudmagic", " l3meta", "l4Meta", " l2metadata", "loudmetadata", "d2Meta", "l2mic", "l5mic", " l3mic", "l6metadata", " l6metadata", "l2eta", "loudmeta", "l1mic", "l1metadata", " l6meta", " l4magic", " l2mic", "l5meta", "d3eta", "l4magic", "l1data", "l4data", "l6meta", "l3eta", " l4meta", "l3meta", "l6Meta", " l6Meta", " l2Meta", "l5metadata", " l6data", " l2data", "l3Meta", "d2eta", " l4eta", "l5eta", "d3metadata", " l2eta", "l2metadata", "l3magic", "d3Meta", " l3eta", "d2metadata", "d3meta", "d2meta", "l1meta", "loudeta", " l2magic", "l4meta", "l1Meta", "l1eta", "l3metadata", "l4metadata", "l4eta", "l2data", "l3mic", "l2Meta"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16787, "substitutes": {"dev": ["self", "di", "debug", "DEV", "dc", "client", "prom", "cmd", "name", "cache", "mod", "dd", "cur", "temp", "conn", "ad", "dm", "end", "error", "off", "d", "test", "fail", "sd", "config", "id", "pub", "dt", "index", "img", "dom", "data", "diff", "Dev", "doc", "pack", "w", "conf", "wd", "app", "nt", "p", "de", "cam", "gu", "ind", "def", "dist", "dem", "comment", "priv", "dep", "home", "package", "ev", "die", "mem", "pro", "bug", "device", "rad", "ds", "md", "adv", "ver", "info"], "value": ["val", "VALUE", "min", "length", "number", "result", "option", "name", "type", "values", "off", "buffer", "valid", "no", "version", "id", "max", "index", "address", "data", "byte", "total", "key", "content", "current", "image", "weight", "count", "num", "ret", "mem", "start", "port", "device", "Value", "amount", "v", "size", "offset"], "dest": ["trans", "bd", "dc", "output", "src", "result", "route", "cmd", "uc", "temp", "source", "dim", "orig", "end", "wb", "obj", "config", "path", "des", "img", "pack", "data", "doc", "target", "Dest", "gen", "ref", "de", "tmp", "def", "dist", "home", "dep", "prop", "mem", "opt", "sub", "destroy", "buff"], "len": ["val", "min", "split", "net", "lf", "valid", "fun", " ret", "last", "gen", "line", "limit", "arg", "name", "Len", "args", "index", "data", "rev", "lang", "err", "url", "l", "lin", "bin", "ln", "f", "length", "lt", "n", "base", "id", "db", "lc", "iter", "format", "pos", "en", "fn", "ret", "str", "ll", "type", "alt", "li", "el", "repl", "lon", "fin", "loc", "all", "ref", "count", "seq", " length", "part", "size"], "desc": ["val", "disc", "rec", "df", "dc", "src", "cmd", "name", "bc", "uc", "td", "conn", "req", "description", "asc", "obj", "enc", "config", "Desc", "des", "pb", "code", "dir", "data", "doc", "diff", "design", "ext", "conf", "de", "decl", "def", "dist", "esc", "acc", "dep", "sec", "pro", "sub", "sc", "info"], "buf": ["lim", "val", "cp", "vec", "bd", "map", "src", "uf", "result", "extra", "cmd", "uc", "bc", "queue", "feat", "array", "buffer", "wb", "pool", "bb", "comb", "fd", "fun", "config", "ff", "path", "db", "begin", "pb", "index", "data", "raw", "ctx", "cap", "exc", "loc", "rb", "cf", "ref", "pos", "bag", "cv", "func", "b", "null", "msg", "fb", "prop", "cb", "rc", "bus", "seq", "cmp", "bf", "text", "mem", "fab", "lb", "buff", "v", "alloc", "br"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n", "idx": 16792, "substitutes": {"machine": ["session", "proc", "node", "cache", "instance", "parent", "linux", "connection", "boot", "config", "slave", "state", "computer", "Machine", "mac", "processor", "loader", "VM", "process", "image", "vm", "mem", "device", "master", "manager", "host", "m"], "cpu": ["core", "cp", "chip", "ilo", "sys", "component", "pc", "proc", "clock", "CPU", "pty", "node", "cache", "net", "instance", "ro", "linux", "proxy", "eni", "conn", "boot", "hw", "config", "memory", "pu", "computer", "processor", "GPU", "prem", "loader", "bench", "thread", "process", "vm", " CPU", "kernel", "mem", "cmp", "disk", "device", "gpu", "uca", "setup"], "dinfo": ["dbInfo", "einf", " dfo", "dlinf", "dindex", "dlfo", " dindex", "DInfo", "dsfo", "dopen", "eInfo", "rdinfo", "rdstate", "dsindex", "popen", "dbinfo", "dfo", "dllink", "dinf", "fInfo", "pinfo", "dsinfo", " dInfo", "dslink", "pInfo", "dsInfo", "finf", "einfo", " dcheck", "fcheck", "Dopen", "dbinf", "rdinf", "rdindex", "dInfo", " dstate", " dlink", "dsstate", "dbcheck", "dscheck", " dopen", "dlinfo", " dinf", "echeck", "Dinfo", "dstate", "dcheck", "finfo", "dlink", "dsinf"], "be": ["is", "ble", "hide", "ine", "stop", "BE", "scale", "none", "ave", "range", "ome", "ro", "ben", "te", "me", "ere", "enable", "ge", "ride", "by", "Be", "replace", "ae", "ace", "eb", "byte", "ee", " BE", "ose", "are", "ste", "see", "ze", "bre", "ce", "ate", "sb", "ke", "de", " Be", "pe", "b", "ignore", "fore", "se", "beat", "ve", "leave", "le", "bee", "use", "bis", "ne", "obe", " probe", "bf", "e", "fe", "trace", "bes", "ver", "abe"], "address_space_mem": ["address_space2ram", "address_pace_dem", "address_space__memory", "address_pace_ram", "address_system_lim", "address_pace_memory", "address_space2dem", "address_space_lim", "address_space_space", "address_system_space", "address_space2mem", "address_space_memory", "address_space2memory", "address_space_dem", "address_space__mem", "address_space__dem", "address_space__ram", "address_space_ram", "address_pace_mem", "address_system_mem"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n", "idx": 16794, "substitutes": {"ctx": ["cca", "cp", "cm", "client", "pc", "cli", "bc", "nc", "ci", "gc", "conn", "connection", "obj", "config", "qa", "cas", "reader", "lc", "loc", "ca", "cf", "c", "fp", "cam", "cv", "cc", "tx", "cr", "pkg", "tc", "Context", "context", "rc", "cb", "cmp", "io", "xc", "sc"], "notifier": ["annotifer", "signification", "netify", "toolifier", "notify", "notification", "signicator", "annifier", "annify", "nticator", "toolifer", "netifer", "butifier", "noticator", "ntifer", "annoticator", "notifer", " notizer", "annification", "toolify", "signifier", "butification", "ntifier", "notizer", "ntizer", "annicator", " noticator", "netification", "annotifier", "netifier", "toolification", "butifer", "annifer", "annotizer", " notifer", "buticator", "signifer"], "is_external": ["is_internal", "isinghttps", "is_global", " is_internal", "isingExternal", "is_https", " is_External", "isingglobal", " is_https", " is_global", "is_External", "isingexternal"], "io_read": ["ioseach", " io_run", "iosreader", "event_poll", "iopreader", " io_reader", "io_reader", "iosread", " io_each", "event_reader", "iosrun", "ioppoll", "iopread", "event_read", "io_run", "io_each"], "io_poll": ["io67wait", "io_scan", "io_wait", "iofwait", "io\u00b7poll", "io2poll", "io\u00b7wait", "io2install", "io67install", "iofpoll", " io_install", " io_select", " io_wait", "io\u00b7scan", "io_select", "io_install", "iofselect", "io67poll", "iofscan", " io_scan", "io\u00b7select", "io2wait"]}}
{"project": "FFmpeg", "commit_id": "f6687bf5f8989d397cdef6d9d05bcb13a7ef8c4f", "target": 0, "func": "void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,\n\n                   uint8_t *iv, int decrypt)\n\n{\n\n    int i;\n\n\n\n    while (count > 0) {\n\n        if (decrypt) {\n\n            xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = dst[i] ^ iv[i];\n\n                memcpy(iv, src, 8);\n\n            }\n\n        } else {\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = src[i] ^ iv[i];\n\n                xtea_crypt_ecb(ctx, dst, dst, decrypt);\n\n                memcpy(iv, dst, 8);\n\n            } else {\n\n                xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n            }\n\n        }\n\n\n\n        src   += 8;\n\n        dst   += 8;\n\n        count -= 8;\n\n    }\n\n}\n", "idx": 16795, "substitutes": {"ctx": ["cca", "cp", "progress", "gru", "cm", "coll", "ck", "cli", "cmd", "bc", "buf", "ci", "linux", "conn", "exec", "conv", "obj", "hw", "config", "fw", "qa", "ocr", "cas", "concept", "lc", "mac", "loc", "ca", "cf", "c", "fp", "cc", "cv", "sci", "cam", "kw", "vc", "tx", "pkg", "cus", "tc", "context", "wcs", "rc", "cb", "voc", "cmp", "anc", "cu", "xc", "que", "sc", "cn"], "dst": ["ndrest", "udsc", " drc", " dput", "pdst", "dsts", "isdsc", "dedsts", "idsc", "cdsc", "dssc", "dsp", "dssts", "dedst", "idrest", "ydst", "sdst", "adst", "sdST", "ddsc", "ydsta", "sdsp", "dsrest", "dput", " dsts", "dedST", "ydstore", " dsta", "idst", "sdsc", "ssc", "pdstore", "dST", "lest", " dstore", "ndsts", "srest", "ydsc", "ndsc", "dstore", " drest", "pdsc", " dST", "lsc", "ndput", "ndst", "lrest", "lst", "udput", "cdst", "drest", "adrest", "isdrest", " dsp", "ddst", "sdrest", "sdsts", "idrc", "dsc", "adsc", "ndrc", "pdsta", "dsst", "lrc", " dsc", "sst", "ssts", "isdst", "dsput", "dedsc", "udst", "cdsp", "adput", "drc", "isdput", "dsest", "ddest", " dest", "udsts", "dsta", "dest", "dsrc", "cdsts", "ddput"], "src": ["core", "sn", "ruby", "inst", "rest", "uc", "riv", "source", "buf", "cur", "sq", "sr", "stack", "config", "support", "liv", "init", "r", "img", "rss", "usr", "st", "loc", "rb", "sb", "depth", "sci", "ind", "ssl", "sl", "sup", "comp", "dist", "slice", "desc", "sel", "send", "rc", "url", "sec", "dest", "seq", "cmp", "start", "obl", "sub", "sc", "rob", "secure", "ctr", "sync"], "count": ["coll", "length", "allow", "cache", "force", "counter", "n", "len", "low", "col", "ch", "child", "config", "id", "catch", "base", "th", "found", "code", "data", "repeat", "call", "sum", "conf", "c", "head", "p", "depth", "gl", "ind", "b", "deep", "current", "keep", "process", "err", "num", "seq", "cmp", "start", "l", "other", "list", "Count", "ctr", "size"], "iv": ["ivari", "coll", "uv", "ith", "ov", "lv", "inst", "riv", "Iv", "bc", "inc", "ci", "erv", "op", "ipher", "rel", "ir", "ip", "or", "rib", "iov", "hw", "enc", "av", "vi", "lib", "chain", "liv", "init", "irc", "ib", "ocr", "equ", "act", "img", "adr", "rx", "ipp", "ec", "oy", "ival", "ii", "loc", "ext", "iq", "oc", "app", "iii", "ou", "cv", "ind", "vc", "ctr", "protect", "ih", "uint", "IV", "iver", "sel", "vr", "rc", "ev", "voc", "cmp", "ie", "ract", "rol", "v", "secure"], "decrypt": [" decipher", "decract", "ecrypt", "encrypt", "defryption", "derupt", "defipher", "negcrypt", "deipher", "desccrypt", "encipher", "defrypt", "negryption", "deryption", "descrypt", "ecrypted", "derypted", " decrupt", "deccrypt", "encryption", "descipher", "decrupt", "derypt", "negipher", "negract", "descure", "negrupt", "descract", "ecipher", "decryption", " decure", "negrypt", "encrypted", "enccrypt", "decure", "descryption", " deccrypt", "decipher", "eccrypt", "declect", "eclect", "decrypted", "deflect", "encure", " decract", "ecryption", " decryption", "desclect"], "i": ["phi", "di", "uli", "f", "ri", "xi", "hi", "cli", "name", "x", "qi", "u", "ix", "ci", "li", "in", "api", "bi", "it", "uri", "ji", "d", "mu", "n", "col", "ip", "I", "pi", "si", "multi", "id", "init", "ai", "index", "iu", "o", "lc", "ii", "c", "k", "p", "y", "ind", "b", "z", "m", "ui", "ni", "zi", "gi", "fi", "yi", "anti", "e", "l", "ori", "io", "oi", "ie", "ini", "v", "ti", "j", "info"]}}
{"project": "FFmpeg", "commit_id": "6241e8a3821d971755217652dff01f3a45580820", "target": 0, "func": "static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    AVRational time_base = {1, 1000};\n\n    uint32_t start, end;\n\n    AVChapter *chapter;\n\n    uint8_t *dst = NULL;\n\n    int taglen;\n\n    char tag[5];\n\n\n\n    decode_str(s, pb, 0, &dst, &len);\n\n    if (len < 16)\n\n        return;\n\n\n\n    start = avio_rb32(pb);\n\n    end   = avio_rb32(pb);\n\n    avio_skip(pb, 8);\n\n\n\n    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);\n\n    if (!chapter) {\n\n        av_free(dst);\n\n        return;\n\n    }\n\n\n\n    len -= 16;\n\n    while (len > 10) {\n\n        avio_read(pb, tag, 4);\n\n        tag[4] = 0;\n\n        taglen = avio_rb32(pb);\n\n        avio_skip(pb, 2);\n\n        len -= 10;\n\n        if (taglen < 0 || taglen > len) {\n\n            av_free(dst);\n\n            return;\n\n        }\n\n        if (tag[0] == 'T')\n\n            read_ttag(s, pb, taglen, &chapter->metadata, tag);\n\n        else\n\n            avio_skip(pb, taglen);\n\n        len -= taglen;\n\n    }\n\n\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);\n\n    av_free(dst);\n\n}\n", "idx": 16808, "substitutes": {"s": ["g", "self", "sf", "f", "sys", "session", "ops", "proc", "ps", "tp", "http", "pc", "rs", "ds", "t", "ss", "sq", "api", "ns", "plugins", "n", "si", "i", "types", "cpp", "support", "storage", "parser", "ls", "es", "space", "ctx", "us", "gs", "c", "p", "sb", "sci", "ts", "series", "ssl", "b", "sl", "sup", "fs", "services", "stats", "m", "context", "bis", "ab", "sg", "ses", "e", "sv", "utils", "os", "sub", "sc", "se", "spec", "qs", "v", "sync", "settings"], "pb": ["cp", "sf", "PB", "bs", "pc", "uf", "proc", "tp", "jp", "pd", "phrase", "ppa", "bc", "xb", "wp", "lp", "bh", "api", "wb", "py", "np", "bb", "bp", "pm", "hub", "bm", "cpp", "pg", "db", "pl", "pp", "platform", "summary", "vp", "parser", "bps", "eb", "ctx", "typ", "rb", "sb", "p", "fp", "b", "prot", "pkg", "mb", "cb", "ab", "gb", "bf", "dp", "mp", "lab", "lb", "fc", "plugin", "fb"], "len": ["lim", "val", "min", "split", "lf", "syn", "fun", "low", "line", "limit", "sl", "ell", "lit", "ann", "Len", "lib", "duration", "data", "lang", "fl", "nt", "url", "num", "l", "ler", "pid", "list", "lin", "ln", "ver", "offset", "length", "lan", "lt", "lp", "n", "dl", "lc", "body", "pos", "en", "la", "str", "html", "ll", "feat", "alt", "del", "li", "el", "lon", "enc", "fin", "span", "ls", "hl", "loc", "all", "ld", "mer", "count", "seq", "part", "elt", "size", "tail"], "ttag": ["ntar", "ttar", "otttag", "tagger", "ottagger", "tttag", "ottar", "tar", "ottag", "nttag", "ttagger", "ntagger", "ntag"], "extra_meta": ["extra__config", "extra_config", "extra_metadata", "extra_data", "extra__metadata", " extra_metadata", " extra_data", "extra__data", "extra__meta", " extra_config"], "start": ["stop", "set", "skip", "min", "get", "starting", "length", "sp", "range", "name", "type", "op", "style", "in", "first", "ad", "old", "d", "info", "id", "parse", "init", "span", "mid", "next", "read", "pre", "time", "p", "patch", "pos", "ind", "Start", "use", "step", "count", "from", "open", "se", "part", "art", "size", "offset"], "end": ["stop", "END", "set", "after", "length", "until", "range", "ension", "eff", "off", "ad", "add", "est", "enc", "ase", "max", "index", "last", "mid", "post", "limit", "pos", "End", "ind", "ended", "nd", "append", "edge", "vert", "en", "send", "e", "from", "open", "ending", "event", "size", "offset"], "chapter": ["section", "Chapter", "podcast", "leaf", "project", "component", "session", "CHAPTER", "proc", "episode", "type", "name", "feat", "parent", "trip", "draft", "page", "paragraph", "wiki", "connection", "prev", "gap", "child", "phase", "record", "hip", "vision", "chart", "toc", "config", "pair", "ch", "job", "slave", "metadata", "cop", "year", "parser", "entry", "span", "man", "plot", "reader", "trial", "assembled", "volume", "meta", "archive", "time", "chron", "part", "book", "join", "patch", "channel", "voice", "slice", "apter", "month", "prop", "joined", "seed", "ler", "story", "finished", " section", "plugin", "comp", "title"], "dst": ["dsth", " dsts", " dsth", "ndST", "Dst", "ndst", "idost", "sdost", " ddr", "sst", "sost", "pdsp", "pdsts", "ddost", "idst", "Dsc", "domsc", "pdst", "sdr", "dsts", "idsth", "Dsts", "ddST", "ssts", "Dost", "edST", "bdsth", "dST", "bdsts", "Dsp", "dste", "dost", " dsp", "idsc", "ddst", "bdst", "edst", " dste", "sdsts", "ndsts", "dsp", "ddr", "bdST", " dost", "Ddr", "dsc", "sdst", "pdste", "domsth", "Dste", "sdST", "domst", "edsth", "DST", "ndost", "domost", "ddsts", " dST", "edsts", "Dsth"], "taglen": ["commentlen", "tagLen", "wordli", "keyli", " tagli", "commentlength", "blockLen", "modlen", "agLen", "rowlf", "blocknum", "keylen", " tagnum", "tagrel", "commentl", "agnum", "taglf", "matchlen", " taglf", "matchl", "matchlin", "keylength", "commentrel", "tasklen", "taglength", " taglength", "wordlength", "aglen", "catlon", " tagref", "rowlength", "tagl", " tagrel", "tasklength", "agrel", "wordlon", " tagl", "catlength", "agref", "wordlen", " tagLen", "taglin", "catlen", "blocklength", "tasklf", "matchln", " taglon", "taglon", "keyl", "agl", "taskLen", "rowlen", "tagnum", "tagln", "rowLen", "modln", " tagln", "modlin", "wordLen", "aglength", " taglin", "agli", "tagref", "blocklen", "modl", "wordl", "tagli", "wordref"], "tag": ["bit", "section", "class", "TAG", "tags", "token", "rule", "cat", "option", "length", "match", "type", "name", "cache", "feat", "reg", "gap", "col", "id", "word", "pl", "code", "year", "doc", "block", "stat", "pre", "loc", "post", "ag", "patch", "key", "line", "bag", "desc", "comment", "agg", "month", "Tag", "prop", "count", "attr", "row", "field", "text", "bug", "bad", "ack", "part", "date", "attribute", "tail"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n", "idx": 16812, "substitutes": {"env": ["f", "proc", "buf", "et", "conn", "exec", "buffer", "enc", "config", "path", "data", "ec", "ea", "tx", "cfg", "en", "context", "eth", "vt", "rc", "fi", "ev", "e", "opt", "environment", "tty", "v", "settings"], "ram_addr": ["gram_addr", "ramamslice", "ramladdress", "gram_slice", "ram_url", "ramwaddr", "ramladdr", "ram_slice", "gram_ref", "ram67addr", "ram_address", "gram_mode", "ramwadr", "gram_offset", "gram_host", "ram67address", "ram67arm", "ram_host", "ramlarm", "ramamaddr", "ram67mode", "ramlmode", "ram_offset", "gram_adr", "gram_url", "gram_arm", "ramwaddress", "ramamaddress", "ramwoffset", "gram_address", "ramamurl", "ram_ref", "ram_arm", "ram_mode", "ram_adr"], "page_index": ["page67span", "page__action", "change67design", " page_ticket", "pageflength", " page_action", "page__ind", "page_design", "page_position", "page67index", " page_ind", "page_action", "page__index", "page67design", "pagefposition", "page67ind", " page_Index", "change67index", "change_span", "change67span", " page_length", "page_length", "page_Index", "page_ticket", "page67action", "pagefindex", "change_index", "page_span", "change_design", "page_ind", " page_position"], "ret": ["RET", "bit", "val", "reply", "let", "result", "proc", "match", "Result", "alt", "et", "res", "success", "conn", "reg", "back", "valid", "len", "obj", "mt", "job", "fun", "ut", " RET", "id", "data", "rets", "att", "ref", "det", "nt", "al", "def", "resp", "re", " Ret", "ct", "rc", "Ret", "mem", "arg", "out", "rt", "part", "ure"], "temp": ["dc", "output", "f", "timeout", "result", "proc", "IT", "cache", "t", "Temp", "buffer", "exec", "test", "valid", "magic", "fd", "i", "input", "fff", "ec", "iter", "EMP", "tmp", "cond", "CC", "null", "current", "tc", "err", "fake", " proc", "count", "Ret", "num", "mem", " output", "EC", " temporary", "stable"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 16829, "substitutes": {"ctx": ["cca", "cs", "cp", "txt", "cm", "dc", "client", "coll", "pc", "this", "src", "jp", "cli", "cmd", "bc", "nc", "ci", "conn", "scope", "req", "exec", "cor", "obj", "hw", "cms", "config", "cpp", "fw", "cl", "qa", "cas", "lc", "kt", "cci", "loc", "ca", "cf", "c", "ce", "fp", "cam", "cv", "cc", "vc", "tx", "cr", "pkg", "cus", "tc", "Context", "context", "ct", "cb", "cmp", "ctrl", "cu", "xc", "sc", "ctr", "cn"], "pfds": [" pfda", "pfd", "pfsdc", "pcfds", "pfsd", "pfda", "pfsds", " pfsds", " pfsd", " pfd", "pfdc", "pcfd", "pcfdc", "pfsda", "pcfda", " pfsda", " pfdc", " pfsdc"], "npfd": ["wpdc", " tcpfd", "npbf", "vpfd", " tcpfc", "fpf", "npdf", "NPdf", "vpbf", "wpbf", " tcpdf", "npFD", "fpfd", "npfc", "fpFD", "npf", "wpf", "NPfd", "npdc", " tcpdc", "NPfc", "wpFD", "NPdc", "wpfd", "wpfc", "vpf", "fpbf", "vpFD", "wpdf"], "timeout": [" max", "val", "after", "name", "cache", "conn", "pool", "base", "args", "max", "duration", "block", "call", "time", "unit", "delay", "wait", "err", "Timeout", "sec", "cb", "options", "outs", "out", "size"]}}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void aarch64_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&aarch64_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {\n\n        aarch64_cpu_register(&aarch64_cpus[i]);\n\n    }\n\n}\n", "idx": 16842, "substitutes": {"i": ["g", "val", "phi", "di", "f", "ri", "length", "xi", "hi", "x", "ix", "qi", "u", "ci", "in", "li", "abi", "ji", "bi", "uri", "mu", "d", "info", "n", "ti", "I", "pi", "si", "multi", "id", "h", "index", "code", "ai", "iu", "diff", "o", "block", "lc", "ii", "k", "c", "p", "b", "z", "slice", "ui", "ni", "zi", "gi", "count", "fi", "e", "l", "start", "io", "oi", "ini", "v", "mi", "j", "m"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "substitutes": {"opaque": ["opque", "OPaque", "ospaque", "ipec", "opaques", "opec", "ospque", "paque", "operacity", "ipque", "ipaques", "copaques", "OPonymous", "OPque", "OPacity", "ospacity", "pec", "opacity", "pque", "osponymous", "copaque", "operonymous", "operque", "copque", "copec", "operaque", "ipaque", "oponymous", "paques"], "offset": ["bit", "set", "skip", "scale", "shift", "f", "length", "aque", "operation", "timeout", "option", "prefix", "parent", "off", "pad", "error", "ip", "position", "location", "oid", "reset", "address", "index", "padding", "data", "addr", "o", "Offset", "align", "slot", "p", "fp", "pos", "pointer", "num", "seed", "start", "port", "from", "alias", "reference", "attribute", "mode"], "value": ["val", "set", "scale", "none", "command", "node", "off", "page", "end", "description", "valid", "email", "va", "padding", "block", "always", "selected", "null", "comment", "done", "image", "wa", "Value", "mode", "m", "server", "timeout", "name", "values", "fee", "gap", "no", "message", "i", "memory", "hello", "max", "index", "data", "money", "key", "when", "current", "home", "element", "num", "non", "port", "VALUE", "length", "number", "style", "array", "buffer", "version", "id", "vi", "address", "native", "iv", "ue", "total", "format", "create", "area", "amount", "feature", "info", "resource", "expression", "option", "type", "complete", "media", "flow", "member", "volume", "w", "ou", "unit", "service", "function", "start", "reference", "v"], "size": ["set", "scale", "length", "type", " error", " address", " buffer", "buffer", "fee", "Size", "len", "SIZE", "ize", "address", "padding", "data", " amount", " bytes", "bytes", "count", " length"], "s": ["g", "self", "sites", "session", "secondary", "uns", "js", "plugins", "h", "r", "gs", "conf", "c", "ssl", "sl", "su", "fs", "states", "sets", "a", "ins", "m", "server", "sf", "copy", "uploads", "u", "source", "ns", "site", "si", "state", "your", "data", "strings", "es", "us", "params", "p", "sb", "ts", "services", "l", "port", "sym", "its", "sync", "f", "ops", "this", "rs", "ss", "sq", "n", "o", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "ps", "new", "t", "d", "status", "ls", "sum", "service", "comments", "e", "os", "ds", "v", "settings"]}}
{"project": "qemu", "commit_id": "3b2e934463121f06d04e4d17658a9a7cdc3717b0", "target": 0, "func": "static inline uint32_t nvic_gprio_mask(NVICState *s)\n\n{\n\n    return ~0U << (s->prigroup + 1);\n\n}\n", "idx": 16870, "substitutes": {"s": ["self", "cs", "sys", "session", "ops", "f", "secondary", "u", "rs", "south", "t", "ss", "sq", "args", "types", "private", "input", "es", "gs", "c", "sb", "p", "ts", "ssl", "services", "stats", "S", "m", "states", "sec", "sets", "ses", "settings", "request", "sym", "ds", "qs", "sync", "rates"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n", "idx": 16879, "substitutes": {"fds": ["fda", "Fks", " fls", "cd", "fks", "fns", " fipes", "forda", "cfDS", "fDS", "dfdr", "rfks", "dd", "afls", "cfks", "fordds", "afks", "fipes", " fns", "fd", "FDS", " fdd", "ffds", "cds", " fDS", "rfipes", "fdb", "rfdb", "cdds", "fdds", "fdd", "fords", "dds", "ffda", " fdds", "Fds", " fd", "dns", " fdr", "Fdds", "fls", " fks", "dfds", "afdd", "rfls", "cfds", " fdb", "dfipes", "ffdds", "fdr", "cfdds", "rfdr", "ffls", "ddds", "rfds", "afds", " fda", "rfdd", "cns", "dfdb", "forls"], "ret": ["RET", "val", "str", "reply", "bit", "f", "cat", "result", "temp", "alt", "res", "linux", "success", "repl", "reg", "back", "exec", "no", "sr", "valid", "len", "obj", "job", "rep", "mt", "fail", "id", "fd", "fun", "pet", "fin", "lib", "status", "code", "data", "rev", "rets", "next", "att", "ext", "format", "ref", "det", "nt", "sb", "active", "def", "flag", "re", "done", "ft", "run", "rc", "num", "Ret", "arr", "arg", "rt", "part", "art", "info"]}}
{"project": "qemu", "commit_id": "77a5a0001bd9eaee9da7dc8f0b69702d56b0cc67", "target": 0, "func": "static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 16888, "substitutes": {"bs": ["lbs", "cs", "sa", "ps", "bc", "bt", "rs", "BS", "bh", "ss", "ns", "bb", "obj", "bid", "pb", "iss", "vs", "ls", "ba", "gs", "sb", "ts", "fs", "bis", "bos", "ses", "os", "ds"], "offset": ["shift", "f", "timeout", "length", "off", "base", "position", "ip", "len", "reset", "address", "index", "padding", "addr", "data", "block", "Offset", "slot", "ref", "p", "fp", "pos", "limit", "pointer", "count", "num", "start", "bound"]}}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n", "idx": 16890, "substitutes": {"v": ["g", "val", "f", "uv", "lv", "x", "u", "t", "q", "d", "n", "conv", "version", "h", "r", "change", "iv", "vs", "w", "c", "k", "p", "s", "b", "value", "vt", "ev", "e", "sv", "l", "vv", "env", "V", "tv", "m"], "i": ["g", "phi", "di", "f", "ri", "xi", "hi", "jp", "x", "u", "qi", "ix", "ci", "li", "t", "abi", "page", "bi", "uri", "d", "ip", "I", "pi", "si", "id", "index", "change", "ai", "chi", "iu", "o", "ii", "c", "k", "p", "b", "z", "slice", "ui", "gi", "e", "l", "start", "a", "io", "oi", "ie", "ini", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924, "substitutes": {"oc": ["aco", "pc", "uc", "inc", "ac", "nc", "org", "toc", "config", "oid", "oci", "rog", "ob", "co", "ocr", "o", "oper", "ec", "loc", "oco", "c", "OC", "object", "usc", "oca", "roc", "abc", "auc", "acc", "soc", "oo", "rc", "mc", "voc", "anc", "ucc", "fc", "alloc"], "data": ["cd", "di", "coll", "inc", "cache", "dd", "DATA", "ad", "fee", "d", "bb", "Data", "record", "config", "co", "doc", "ee", "design", "da", "func", "def", "desc", "dat", "ds"], "occ": ["rec", "coll", "aco", "cm", "proc", "inc", "uc", "ac", "nc", "bc", "bec", "oe", "org", "Occ", "oci", "cl", "nec", "co", "ai", "ae", "ace", "aa", "ec", "account", "exc", "circ", "loc", "cci", "cf", "c", "OC", "ca", "coe", "usc", "oca", "roc", "abc", "auc", "acc", "misc", "ct", "rc", "mc", "rn", "anc", "ucc", "xc", "fc"], "cc": ["cca", "cs", "cd", "cp", "self", "cm", "coll", "kk", "client", "pc", "ck", "uc", "inc", "bc", "ac", "nc", "cast", "gc", "ci", "bec", " gcc", "cache", "ect", "DC", "cms", "config", "WC", "pg", "cl", "co", "code", "che", "con", "ctx", "ec", "lc", "cci", "ga", "ca", "cf", "c", "ce", " CC", "vc", "func", "cel", "CC", "roc", "abc", "cus", "tc", "acc", "PC", "ct", "rc", "mc", "ctrl", "ucc", "cu", "xc", "sc", "fc", "go", "cn"], "dc": ["cca", "disc", "cd", "di", "cdn", "df", "bd", "pc", "ck", "uc", "inc", "bc", "ac", "nc", "ds", "cmd", "conn", "d", "fd", "DC", "db", "dt", "director", "doc", "ec", "design", "ga", "cf", "c", "de", "da", "vc", "tc", "acc", "rc", "mc", "dat", "anc", "dn", "ucc", "duc", "fc"]}}
{"project": "qemu", "commit_id": "d99598cc9929ad6993ad3d19d9b1ec1d891f0d7f", "target": 1, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n", "idx": 16930, "substitutes": {"opaque": ["oppac", "opacs", "OPaque", "OPacs", "opaques", "operacity", "oopac", "ipaques", "oopacity", "operac", "OPonymous", "OPacity", "oppaque", "ooponymous", "oopaque", "oppacs", "ipac", "opacity", "OPac", "operonymous", "OPaques", "oppaques", "ipaque", "operaque", "oponymous", "opac", "ipacs"], "addr": ["dr", "set", "str", "server", "inet", "src", "proc", "mode", "name", "ac", "nc", "rs", "asm", "buf", " address", "array", "prefix", "conn", "ad", "base", "ip", "len", "localhost", "args", "enc", "config", "id", "address", "code", "r", "adr", "data", "ace", "ctx", "mac", "align", "ref", "p", "s", "ha", "pos", "amp", "pointer", "Address", "ptr", "socket", "eth", "attr", "seq", "start", "opt", "alias", "ast", "size", "oa", "alloc", "host", "offset"], "f": ["g", "fx", "sf", "u", "t", "form", "fo", "d", "feed", "n", "fun", "fd", "i", "fw", "h", "r", "fr", "fen", "o", "tf", "w", "cf", "file", "F", "p", "s", "fp", "inf", "rf", "b", "fa", "z", "fs", "m", "fi", "fn", "bf", "e", "l", "fe", "fc", "v", "af", "fb", "j", "info"], "c": ["cs", "cd", "cm", "dc", "pc", "unc", "uc", "x", "nc", "ac", "bc", "ci", "cache", "t", "u", "conn", "d", " rc", "n", "col", "ch", "enc", "i", "cl", "code", "r", "con", "o", "ctx", "ec", "lc", "w", "call", "cf", "ce", " C", "k", "p", "cc", "s", "cy", "b", "cr", "z", "tc", "ct", "rc", "cb", "count", "mc", "e", "l", "a", "C", "xc", "fc", "v", "m"]}}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n", "idx": 16933, "substitutes": {"dest": ["self", "class", "resource", "trans", "txt", "dc", "later", "src", "result", "this", "route", "rest", "node", "new", "temp", "inst", "parent", "feat", "folder", "access", "orig", "end", "wb", "config", "nexus", "img", "diff", "usr", "target", "Dest", "loc", "cont", " destination", "object", "tmp", "desc", "slice", "home", "done", "transfer", "dist", "delete", "package", "opt", "text", "outer", "master", "destroy", "origin", "remote"], "source": ["core", "self", "server", "resource", "interface", "inner", "project", "session", "component", "src", "result", "this", "range", "new", "parent", "grade", "secure", "scope", "uri", "site", "config", "Source", "id", "seed", "google", "ource", "sort", "feature", "target", "iter", "object", "s", "service", "unit", "current", "SOURCE", "slice", "use", "package", "ui", "subject", "e", "request", "start", "from", "scene", "effect", "text", "other", "reference", "remote", "ie", "sc", "origin", "spec", "plus", "comp", "size", "info"], "i": ["di", "uli", "f", "ri", "xi", "jp", "cli", "name", "x", "u", "qi", "ix", "ci", "li", "t", "abi", "eni", "bi", "uri", "ji", "api", "d", "it", "info", "n", "ip", "I", "si", "pi", "multi", "id", "index", "ai", "chi", "iv", "iu", "o", "lc", "ii", "k", "c", "p", "y", "b", "z", "ui", "ni", "gi", "zi", "fi", "yi", "e", "l", "a", "io", "oi", "ie", "ini", "isi", "v", "ti", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "b00fb157bae79f9735910064585fd95b8c123003", "target": 0, "func": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n\n{\n\n    const uint8_t *src_end = src + src_size;\n\n    int x = 0, y = 0;\n\n\n\n#define INC_XY(n) \\\n\n    x += n; \\\n\n    if (x >= width) { \\\n\n        y++; \\\n\n        if (y >= height) \\\n\n            return 0; \\\n\n        x = 0; \\\n\n    }\n\n\n\n    while (src_end - src >= 2) {\n\n        uint8_t v = *src++;\n\n        if (v > 0 && v < 0xC0) {\n\n            do {\n\n                int length = FFMIN(v, width - x);\n\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n\n                INC_XY(length);\n\n                v   -= length;\n\n            } while (v > 0);\n\n            src++;\n\n        } else if (v >= 0xC1) {\n\n            v -= 0xC0;\n\n            do {\n\n                int length = FFMIN3(v, width - x, src_end - src);\n\n                if (src_end - src < length)\n\n                    break;\n\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n\n                INC_XY(length);\n\n                src += length;\n\n                v   -= length;\n\n            } while (v > 0);\n\n        } else {\n\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16984, "substitutes": {"avctx": ["akpkg", "akctx", "afctx", "Avcontext", "avconn", "awctx", "airca", "awcontext", "afpkg", "awca", "Avpkg", "avcontext", "airconn", "afconn", "Avcoll", "avpkg", "afcoll", "avcoll", "avca", "akcoll", "airctx", "Avctx", "aircontext", "afcontext", "akcontext", "awconn", "afca"], "dst": ["Dst", "dirst", "lirst", "datost", "sdost", "bst", "dcp", "Ddest", "lst", "Dsc", "fdcp", "sdcp", "datst", "fdsp", "Dost", "dST", " ddest", "datsrc", " dsp", "dost", " dcp", "dsp", " dost", "fdst", "Dirst", "fdost", "ddest", "dsc", "sdst", "bsc", "dsrc", "DST", "datdest", "bST", "sdsp", "birst", " dsrc", "lST", "lsc", "Dsrc"], "src": ["uv", "x", "sr", "syn", "support", "pl", "st", "stream", "rl", "ssl", "b", "sl", "z", "insert", "image", "vr", "sec", "attr", "gb", "sub", "server", "inst", "source", "buf", "lib", "img", "https", "sb", "inf", "s", "gl", "url", "seed", "sv", "fc", "ser", "comp", "host", "sync", "sn", "length", "rest", "uc", "bc", "rs", "sq", "conv", "stack", "rib", "config", "iv", "rss", "rb", "ind", "sup", "dist", "sel", "en", "ur", "rc", "cb", "rect", "go", "supp", "cur", "hl", "loc", "cv", "sur", "slice", "gz", "dest", "seq", "start", "sc", "v"], "src_size": ["src_scale", "source_len", "source_size", "source_scale", " src_scale", "src_len", " src_len"], "height": ["length", "work", "x", "level", "Height", "window", "dim", "flow", "pad", "d", "view", "high", "h", "max", "padding", "img", "w", "dy", "depth", "y", "thin", "row", "shape", "rows", "size"], "linesize": ["pagesizing", " linesizes", " linesizing", "nosizing", "odesiz", "odesized", "rowsizing", "rulesizes", " linesized", "rulesize", "nosiz", "rowssize", "pagesize", " linesizer", "rowsize", "odesize", "linespace", "rowsizer", " linesiz", "linesiz", "linesizer", " linessize", "linesizing", "nosized", "pagessize", "worksize", "workspace", "rulespace", " linespace", "pagesizer", "worksizes", "rulesizing", "nosize", "worksizing", "linesized", "linessize", "odesizing", "linesizes"], "src_end": ["source_ends", "source_start", "source_end", "src_ending", "src_start", "src_ends", "source_ending", "rc_ending", "source_begin", "src_begin", "rc_end", "rc_ends", "rc_start"]}}
{"project": "FFmpeg", "commit_id": "9aa0606e87a221eba935ed675c1cd5ca94832e28", "target": 0, "func": "static int hls_read_seek(AVFormatContext *s, int stream_index,\n\n                               int64_t timestamp, int flags)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i;\n\n    int64_t seek_timestamp;\n\n    int valid_for = -1;\n\n\n\n    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->playlists[0]->finished)\n\n        return AVERROR(ENOSYS);\n\n\n\n    seek_timestamp = stream_index < 0 ? timestamp :\n\n                     av_rescale_rnd(timestamp, AV_TIME_BASE,\n\n                                    s->streams[stream_index]->time_base.den,\n\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n\n\n    if (s->duration < seek_timestamp)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* check first that the timestamp is valid for some playlist */\n\n        struct playlist *pls = c->playlists[i];\n\n        int seq_no;\n\n        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {\n\n            /* set segment now so we do not need to search again below */\n\n            pls->cur_seq_no = seq_no;\n\n            valid_for = i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (valid_for < 0)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* Reset reading */\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->input) {\n\n            ffurl_close(pls->input);\n\n            pls->input = NULL;\n\n        }\n\n        av_free_packet(&pls->pkt);\n\n        reset_packet(&pls->pkt);\n\n        pls->pb.eof_reached = 0;\n\n        /* Clear any buffered data */\n\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n\n        pls->pb.pos = 0;\n\n\n\n        pls->seek_timestamp = seek_timestamp;\n\n        pls->seek_flags = flags;\n\n\n\n        /* set closest segment seq_no for playlists not handled above */\n\n        if (valid_for != i)\n\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n\n    }\n\n\n\n    c->cur_timestamp = seek_timestamp;\n\n\n\n    return 0;\n\n}\n", "idx": 16986, "substitutes": {"s": ["g", "cs", "sf", "f", "aws", "sa", "sys", "u", "rs", "cache", "js", "t", "ss", "sq", "d", "ns", "n", "si", "r", "ls", "es", "o", "params", "gs", "conf", "p", "sb", "ts", "ks", "service", "ssl", "b", "sl", "xs", "su", "fs", "services", "S", "sg", "ses", "e", "sv", "settings", "l", "sets", "spec", "sc", "ds", "v", "sync", "m"], "stream_index": ["stream_offset", "draft_key", "streamssize", "draftersize", "channel_position", "channelingindex", "stream_Index", "stream_count", "streamsoffset", "stream_module", "stream_position", "channelingcolumn", "channel_index", "streamidindex", "seqingindex", "draft_offset", "streamersize", "streamerindex", "stream_key", "seq_index", "streamidcount", "seq_count", "channel_module", "streamidmodule", "streamingposition", "seqingcount", "streamerkey", "streamingIndex", "streameroffset", "stream_column", "streamingpath", "streamskey", "streamingcolumn", "streamsindex", "seq_path", "drafterkey", "draft_size", "drafterindex", "stream_path", "stream_size", "channelingmodule", "streamidpath", "seq_Index", "channel_column", "streamingmodule", "streamidposition", "streamidcolumn", "streamingindex", "drafteroffset", "streamidIndex", "seqingpath", "streamingcount", "draft_index", "channelingposition", "seqingIndex"], "timestamp": ["mometo", "momeline", "timeetime", "nameline", "dimeline", "Timoffset", "namestamp", "timeest", "momestamp", "Timeline", "nameto", "timest", "simoffset", "Timest", "Timetime", "mometime", "simestamp", "timetime", "dimestamp", "dimoffset", "timeto", " Timestamp", "dimest", "Timestamp", " Timeline", "simeline", " Timetime", "nametime", "timoffset", " Timest", "timeeline", "Timeto", "simest", "timeline", "timeestamp"], "flags": ["links", "frames", "lag", "ats", "sf", "groups", "f", "ops", "ids", "fts", "vals", "alls", "rules", "faces", "fee", "lf", "reads", "parts", "ints", "args", "fd", "locks", "types", "offset", "bits", "ips", "status", "FLAG", "vs", "strings", "items", "forces", "files", "fl", "atts", "Flags", "details", "ts", "xs", "flag", "fs", "stats", "bytes", "ants", "fps", "fields", "planes", "options", "utils", "offs", "events", "features", "mods", "mask", "settings"], "c": ["g", "cs", "cd", "cp", "self", "cm", "dc", "f", "coll", "client", "pc", "com", "bc", "ac", "cache", "u", "ci", "cur", "nc", "t", "d", "n", "ch", "enc", "config", "cl", "h", "r", "co", "con", "ctx", "ec", "lc", "ca", "cf", "conf", "ce", "k", "p", "cc", "ic", "cy", "vc", "b", "cr", "z", "context", "ct", "mc", "e", "l", "ctrl", "C", "cu", "sc", "fc", "v", "m"], "i": ["phi", "di", "min", "inner", "my", "f", "ri", "hi", "xi", "ski", "qi", "ix", "u", "x", "ci", "li", "me", "t", "eni", "bi", "uri", "ji", "mu", "d", "mi", "no", "info", "n", "ip", "len", "I", "pi", "si", "multi", "id", "init", "index", "ai", "iu", "lc", "ii", "p", "pos", "key", "y", "ind", "b", "z", "ui", "ni", "zi", "gi", "count", "fi", "yi", "anti", "e", "l", "start", "io", "oi", "ie", "ini", "v", "field", "ti", "j", "m"], "seek_timestamp": ["seek_gamment", "seek_timination", "seek_tmetr", "seek_typestamp", "seek_cometo", "seek_timeto", "seek_rimework", "seek_stimestamp", "seek_Timestamp", "seek_imetz", "seek_rimestamp", "seek_timetime", "seek_rimest", "seek_framestamp", "seek_Timetz", "seek_romest", "seek_soundeline", "seek_timension", "seek_framperature", "seek_tmest", "seek_romestamp", "seek_tmeno", "seek_timetz", "seek_frametz", "seek_tmeline", "seek_stimeto", "seek_soundetz", "seek_tmeto", "seek_stimetz", "seek_rimination", "seek_stimetr", "seek_tuneto", "seek_Timeline", "seek___timetr", "seek_imeline", "seek_meteto", "seek_gameline", "seek_timetr", "seek_imment", "seek_Timework", "seek_timperature", "seek_metension", "seek_framest", "seek_tunestamp", "seek_timeline", "seek_tmestamp", "seek_tunetime", "seek_typest", "seek_timework", "seek_timest", "seek_metestamp", "seek_timment", "seek___soundestamp", "seek_timeno", "seek_typeline", "seek_Timination", "seek_soundestamp", "seek_gametz", "seek_Timeno", "seek_tmment", "seek___timestamp", "seek___timetz", "seek_romination", "seek_imestamp", "seek___soundeline", "seek_stimetime", "seek_metest", "seek_stimeline", "seek_comestamp", "seek_soundetr", "seek_Timension", "seek_stimperature", "seek_Timperature", "seek_Timest", "seek_tmetz", "seek_comension", "seek_comest", "seek___timeline", "seek_gamestamp", "seek_tuneline", "seek___soundetr", "seek_tmetime", "seek_stimest", "seek_Timeto", "seek_romework", "seek___soundetz", "seek_typeno"], "pls": ["putb", "PLcs", "PLd", "splp", "clb", "spls", "splabs", "platformp", "plb", " pljs", "implp", " plses", "phgs", "pgs", "others", "pers", "prs", "pulls", "ppf", "peri", "pgsets", " plis", "PLs", "splcs", "pljs", "platformsets", " plgs", "plabs", "phs", "splb", "cols", "blsg", "bls", "flc", "ucds", "cli", "Plds", "fli", "flf", "plis", " plsg", "vels", "flses", "bli", "Plses", "slp", " plsets", "putsg", "PLses", "colches", " plf", " plb", "ledi", "platforms", "ucs", "plsets", "phds", "otherp", "perches", " plp", "compls", " plns", "spljs", "plp", "pulld", "velabs", "pps", "velp", "ppses", "coli", "plds", "pld", "plses", "velsets", "Pls", "PLt", "PLb", "celis", "Plp", " plds", "pullf", " plches", "implns", "plcs", "plc", "Plc", "celses", "prd", "splsets", "spld", "controls", "cels", "prb", "slis", "pht", "ppd", "plf", "splf", " pli", "plgs", " plc", "Pljs", "celp", "flb", "splds", "sls", "controlt", "plsg", "puti", "leds", "impls", "plt", "splgs", "pgp", "PLsets", "phsets", " plabs", " pld", "pli", "plches", "php", "fls", "plns", "ucp", "Plf", "compld", "ledses", "controlsets", "celi", "otherns", "putcs", "cls", "complses"], "seq_no": ["sequence_max", "seq_number", "seq_length", "sequence_number", " seq_No", "sequence_no", "seqJfrom", "seqingnumber", "seqsnumber", "seqIDfrom", "seqingmax", "sequence_from", "seqingfrom", "seq_No", "seqIDlength", "seqIDno", "seq_max", "seqgno", "seqgfrom", "seqJmax", "seqsNo", "seqglength", "seqingno", "seqJno", "sequence_length", "seq_from", "seqsno", " seq_number", "seqJnumber"]}}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assigned_initfn(struct PCIDevice *pci_dev)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    uint8_t e_intx;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    if (!kvm_enabled()) {\n\n        error_report(\"pci-assign: error: requires KVM support\");\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&\n\n        !dev->host.function) {\n\n        error_report(\"pci-assign: error: no host device specified\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * Set up basic config space access control. Will be further refined during\n\n     * device initialization.\n\n     */\n\n    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);\n\n    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);\n\n    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_BIST, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);\n\n    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);\n\n    memcpy(dev->emulate_config_write, dev->emulate_config_read,\n\n           sizeof(dev->emulate_config_read));\n\n\n\n    get_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n", "idx": 16999, "substitutes": {"pci_dev": ["pki2ev", "pci2device", "pci2ev", "pki2device", "pci_div", "pki_device", "pki_div", "pci2div", "pki2div", "pci_ev", "pki_ev", "pci2dev", "pcli_device", "pci_device", "pcli_dev", "pcli_div", "pki2dev", "pcli_ev", "pki_dev"], "dev": ["g", "self", "di", "DEV", "dc", "grad", "client", "off", "end", "exec", "valid", "pub", "h", "block", "engine", "conf", "app", "devices", "gu", "comment", "adv", "ow", "prom", "inst", "mod", "dd", "req", "hw", "dis", "od", "user", "dom", "data", "wd", "p", "var", "cam", "vol", "gh", "def", "err", "home", "compl", "prof", "die", "model", "bug", "host", "ver", "f", "this", "cmd", "ad", "error", "config", "module", "diff", "Dev", "develop", "ve", "dem", "priv", "ev", "nov", "spec", "serial", "info", "development", "ov", "result", "conn", "d", "root", "boot", "gd", "ch", "enc", "w", "de", "pro", "driver", "device", "rad", "debug", "v"], "e_intx": ["e_indx", "e_ind32", "e_nt32", "e_ntX", "e_idX", "e_int32", "e_idx", "e_ntx", "e_id32", "e_intX", "e_indX"], "r": ["ror", "f", "ry", "rs", "lr", "error", "R", "d", "n", "or", "h", "w", "c", "p", "s", "cr", "ptr", "err", "Error", "rc", "e", "l", "a", "trace", "m"], "local_err": ["global_", "Local_", "local2error", "remote_err", "local2err", "remote_exc", "local_rr", "remote_rr", " local_", "Local\n", "local2rr", "local_error", "global\n", "remote_error", " local\n", "local_", "local_exc", "local2exc", "local\n"]}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n", "idx": 17004, "substitutes": {"xendev": ["exnddev", "xnddev", "exndew", "xendingev", "wxenddev", "wxendev", "xendedov", "xndew", "exendew", "xstartev", "xendedever", "exndov", "xndov", "exndever", "xendeddev", "exendever", "wxendeddev", "xdov", "wxendedenc", "xendedep", "xendov", "xendew", "xenddev", "xdev", "xendedew", "xstartdev", "xstartov", "xendingdev", "xddev", "wxendenc", "xstartew", "exendov", "xendingenc", "wxendedep", "exendev", "xndev", "xendedenc", "exndev", "xendingep", "xdever", "xndever", "xendever", "wxendedev", "xndep", "xendedev", "xendenc", "xndenc", "wxendep", "exenddev", "xendep"]}}
{"project": "FFmpeg", "commit_id": "1e901ffc619459944ae7102428f48972cd899caa", "target": 0, "func": "static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)\n\n{\n\n    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&\n\n        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {\n\n        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&\n\n            timestamp < st->pts_wrap_reference)\n\n            return timestamp + (1ULL<<st->pts_wrap_bits);\n\n        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&\n\n            timestamp >= st->pts_wrap_reference)\n\n            return timestamp - (1ULL<<st->pts_wrap_bits);\n\n    }\n\n    return timestamp;\n\n}\n", "idx": 17009, "substitutes": {"st": ["stop", "str", "class", "sa", "src", "this", "upt", "inst", "rest", "cast", "td", "t", "ss", "sh", "end", "ad", "first", "back", "St", "stack", "sd", "est", "sed", "ut", "th", "support", "ist", "asts", "cl", "sm", "data", "gest", "vest", "stream", "rd", "sb", "s", "ld", "std", "ts", "ost", "nd", "ust", "public", "sl", "stage", "ST", "sta", "sign", "ft", "ct", "sts", "start", "ast", "sth", "sc", "ste", "stable", "bl", "art"], "timestamp": ["uupoint", "sequessed", "numest", "tmestamp", "temetime", "namestamp", "mompoint", "timest", "mometime", "timcision", "timetime", "stimetz", "timporal", "timetz", "timeless", "Timeless", "Timtime", "uuestamp", "timeline", "servuntil", "imtime", "timpoint", "Timessed", "timeest", "nampoint", "imestamp", "metestamp", "sequeless", "Timest", "timepoint", "stimeless", "numestamp", "timessed", "semempt", "impoint", "servestamp", "imest", "imporal", "magpoint", "imetime", "timeetz", "magempt", "temuration", "timtime", "timeeless", "temestamp", "tmeline", "momestamp", "momuration", "metpoint", "sempoint", "magcision", "timeuntil", "stimuntil", "Timpoint", "tmporal", "sequpoint", "temcision", "timuration", "magestamp", "timension", "semestamp", "semcision", "metetime", "uuessed", "numeline", "servetz", "temempt", "semension", "tempoint", "sequestamp", "imeline", "numporal", "serveless", "timuntil", "stimestamp", "uueless", "Timestamp", "timempt", "nametime", "imension", "semetime", "tmest", "namuration", "metension", "timeestamp"]}}
{"project": "qemu", "commit_id": "41a2b9596c9ed2a827e16e749632752dd2686647", "target": 0, "func": "static void ide_atapi_cmd_reply_end(IDEState *s)\n\n{\n\n    int byte_count_limit, size, ret;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"reply: tx_size=%d elem_tx_size=%d index=%d\\n\",\n\n           s->packet_transfer_size,\n\n           s->elementary_transfer_size,\n\n           s->io_buffer_index);\n\n#endif\n\n    if (s->packet_transfer_size <= 0) {\n\n        /* end of transfer */\n\n        ide_transfer_stop(s);\n\n        s->status = READY_STAT;\n\n        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n\n        ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n        printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n    } else {\n\n        /* see if a new sector must be read */\n\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n\n            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);\n\n            if (ret < 0) {\n\n                ide_transfer_stop(s);\n\n                ide_atapi_io_error(s, ret);\n\n                return;\n\n            }\n\n            s->lba++;\n\n            s->io_buffer_index = 0;\n\n        }\n\n        if (s->elementary_transfer_size > 0) {\n\n            /* there are some data left to transmit in this elementary\n\n               transfer */\n\n            size = s->cd_sector_size - s->io_buffer_index;\n\n            if (size > s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = s->lcyl | (s->hcyl << 8);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            if (byte_count_limit == 0xffff)\n\n                byte_count_limit--;\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 17012, "substitutes": {"s": ["g", "set", "self", "sites", "ms", "session", "secondary", "uns", "js", "plugins", "r", "gs", "conf", "c", "ssl", "ches", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "server", "u", "times", "ions", "in", "ns", "ans", "site", "si", "args", "i", "your", "full", "data", "es", "us", "params", "p", "ts", "ks", "y", "services", "sv", "l", "sym", "se", "its", "sync", "f", "ops", "this", "sports", "rs", "south", "ss", "ips", "native", "o", "xs", "S", "sg", "ses", "options", "hs", "spec", "is", "cs", "ims", "sys", "aws", "ps", "new", "t", "parts", "d", "status", "ls", "side", "service", "comments", "uses", "e", "os", "ds", "v", "settings"], "byte_count_limit": ["byte_limit_len", "byte_countinglimit", "byte_count_lim", "byte_countprelimited", "byte_countprelen", "byte_count_value", "byte_countprelimit", "byte_count_set", "byte_limitprevalue", "byte_count_position", "byte_countlexset", "byte_length_limited", "byte_length_lim", "byte_limit_limit", "byte_countlexlimited", "byte_count_len", "byte_length_no", "byte_countlexposition", "byte_countingvalue", "byte_count_limited", "byte_count_no", "byte_limitprelen", "byte_countinglen", "byte_limitprelimit", "byte_length_match", "byte_countlexlimit", "byte_limitprelimited", "byte_length_limit", "byte_count_limits", "byte_length_position", "byte_countlexmatch", "byte_countinglimited", "byte_limit_limited", "byte_limit_value", "byte_count_match", "byte_length_set", "byte_countprevalue", "byte_length_limits"], "size": ["g", "scale", "ix", "sized", "speed", "code", "c", "limit", "content", "z", "mini", "done", "weight", "send", "sec", "shape", "empty", "use", "timeout", "name", "source", "clean", "fee", "Size", "si", "ize", "max", "full", "data", "score", "key", "y", "value", "esc", "ui", "day", "offset", "security", "sn", "length", "number", "large", "style", "feed", "SIZE", "small", "capacity", "address", "grow", "nice", "en", "don", "go", "shift", "now", "type", "complete", "new", "form", "member", "len", "storage", "status", "sum", "loc", "time", "unit", "count", "e"], "ret": ["RET", "val", "reply", "bit", "let", "cat", "ry", "result", "match", "alt", "feat", "res", "success", "repl", "error", "reg", "back", "no", "sr", "fail", "len", "job", "fun", "mt", "obj", "pet", "db", "status", "code", "usr", "rets", "iter", "att", "rb", "ext", "ref", "det", "al", "rf", "resp", "re", "value", "flag", "done", "err", "en", "ft", "count", "rc", "Ret", "num", "mem", "sec", "bf", "url", "cb", "bad", "lit", "arg", "rt"], "lba": ["dlbo", "Laba", "lfa", "nva", "lva", "Lva", "gbas", " lbc", "dlva", "dlfa", "Lbo", " lbo", "gaba", " lbas", "gba", "Lfa", "Lbas", "lbas", "Lba", " lpa", "lbo", " lva", "gva", "lpa", "laba", "npa", "Lpa", " lfa", "Lbc", " laba", "nba", "dlba", "nbc", "lbc"]}}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17021, "substitutes": {"opaque": ["opatile", "oppatile", "OPc", "OPaque", "oppacity", "Opc", "opaques", " opac", "OPacity", "oppaque", "opacity", "Opac", "OPac", "OPaques", " opacity", " opatile", "oppaques", "Opaque", "opc", "OPatile", "Opaques", " opaques", "opac", " opc"], "addr": ["dr", "pc", "src", "mode", "node", "nc", "x", "alt", "dd", " address", "pad", "ad", "add", "point", "base", "len", "mt", "address", "code", "ord", "index", "ar", "adr", "data", "ace", "rx", "ctx", "hop", "mac", "align", "loc", "slot", "ref", "ld", "pos", "amp", "pointer", "ptr", "la", "attr", "cmp", "start", "alias", "amd", "arg", "rt", "oa", "host", "offset"], "val": ["grad", "VAL", "pt", "aval", "x", "ol", "el", "end", "vals", "valid", "fee", "len", "base", "enc", "data", "ee", "ival", "loc", "all", "Val", "slot", "ref", "al", "vol", "unit", "b", "eval", "value", "sel", "count", "ret", "mem", "arr", "arg", "v", "bl"], "s": ["is", "sf", "sys", "f", "sa", "aws", "session", "ps", "x", "rs", "t", "sq", "d", "ns", "si", "state", "ips", "r", "ls", "o", "es", "c", "p", "sb", "sie", "b", "ssl", "sl", "socket", "fs", "S", "e", "ses", "l", "settings", "os", "sym", "an", "sync", "m"], "saddr": [" smd", "shareaddr", "shareattr", "wsaddr", " sarr", "daddr", "paddr", "sarr", "wsattr", "wsarr", "salign", "wsaddress", "palign", "sesval", "wsval", "wsadr", "sdb", "sesaddr", "wsdb", "smd", "dval", "Smd", " sdb", "saddress", "paddress", "Salign", "pmd", "Saddr", " saddress", "dadr", "sesadr", "sadr", "sharearr", "sharedb", "Saddress", " salign", "sval", "sattr", "daddress", "sesaddress", " sattr"]}}
{"project": "qemu", "commit_id": "7ce21016b69b512bf4777965a4292318f2bc7544", "target": 0, "func": "int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors)\n\n{\n\n    int max_discard;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n\n        return -EIO;\n\n    } else if (bs->read_only) {\n\n        return -EROFS;\n\n    }\n\n\n\n    bdrv_reset_dirty(bs, sector_num, nb_sectors);\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {\n\n        return 0;\n\n    }\n\n\n\n    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;\n\n    while (nb_sectors > 0) {\n\n        int ret;\n\n        int num = nb_sectors;\n\n\n\n        /* align request */\n\n        if (bs->bl.discard_alignment &&\n\n            num >= bs->bl.discard_alignment &&\n\n            sector_num % bs->bl.discard_alignment) {\n\n            if (num > bs->bl.discard_alignment) {\n\n                num = bs->bl.discard_alignment;\n\n            }\n\n            num -= sector_num % bs->bl.discard_alignment;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_discard) {\n\n            num = max_discard;\n\n        }\n\n\n\n        if (bs->drv->bdrv_co_discard) {\n\n            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);\n\n        } else {\n\n            BlockDriverAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,\n\n                                            bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                return -EIO;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += num;\n\n        nb_sectors -= num;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17030, "substitutes": {"bs": ["lbs", "cs", "css", "nas", "http", "ps", "bin", "blog", "bc", "rs", "BS", "js", "bh", "ss", "bi", "org", "bles", "its", "ns", "bb", "base", "obj", "banks", "ros", "bid", "db", "bits", "blocks", "pb", "ob", "iss", "vs", "ls", "bps", "eb", "ba", "gs", "bot", "sb", "bas", "s", "ts", "b", "obs", "ubs", "null", "fs", "las", "bytes", "bis", "cb", "ab", "gb", "bos", "ses", "os", "bf", "bu", "outs", "ins", "lb", "bes", "ds", "qs", "ras", "bl", "fb", "sync", "bing"], "sector_num": ["tier_node", "sectoringsum", " sector_sum", " sector_nam", "sectoringnumber", " sector_number", "sectoringcommon", "sector_number", "sector6name", "sector_span", "sectoringnode", "tieringnum", "sector6info", "sector___ul", " sector_sim", "sector_name", "sector_ul", "tieringsum", "sector_begin", "sector_info", " sector_span", "sector6ul", "sector___info", "sectoringname", "sector___name", "sector_nam", "sectoringnum", "tieringnumber", "sector6num", "sector_sim", "sector___num", " sector_info", " sector_name", "sector_node", "tier_sum", "sector_common", " sector_common", "sector_sum", "tieringnode", "tier_num", " sector_ul", "tier_number", " sector_begin"], "nb_sectors": ["nb_SEctors", "nb_psements", "nb_SEcs", "nb_pegments", "nb_secsections", "nb_SEkt", "nb_secs", "nb_verets", "nb_savers", "nb_sasections", "nb_secctors", "nb_sergments", "nb_pectors", "nb_sperets", "nb_sements", "nb_pements", "nb_psegments", "nb_pector", "nb_sactors", "nb_persekt", "nb_peors", "nb_vevers", "nb_SEors", "nb_sogments", "nb_SEkers", "nb_psectors", "nb_persectors", "nb_semvers", "nb_serments", "nb_soctors", "nb_semctors", "nb_specs", "nb_sokt", "nb_serors", "nb_semsections", "nb_spegments", "nb_serctor", "nb_segments", "nb_sekers", "nb_sedctors", "nb_semgments", "nb_secvers", "nb_severs", "nb_sedvers", "nb_sekt", "nb_sagments", "nb_psector", "nb_serets", "nb_vecs", "nb_servers", "nb_pecs", "nb_serctors", "nb_sesections", "nb_SEgments", "nb_vectors", "nb_vegments", "nb_sedors", "nb_spectors", "nb_persegments", "nb_sedgments", "nb_sector", "nb_seors", "nb_sokers", "nb_perets", "nb_persekers", "nb_veors", "nb_secgments"], "max_discard": ["max_distenter", "max_dcenter", "max2iscignment", "max_dcward", "max_descarded", "max_secward", "max_discorder", "max2discward", "max2iscard", "max_iscard", "max_secussion", "max_iscorder", "max_Discard", "max_guort", "max2iscward", "max_dcarded", "max_guenter", "max_regard", "max_contorder", "max_discort", "max_distort", "max_recard", "max_Discord", "max_difforder", "max_dcard", "max_secard", "max_disort", "max_discards", "max_disord", "max_recarded", "max_recarding", "max_discward", "max_discussion", "max2iscorder", "max_distarded", "max_discarding", "max_disward", "max_regarding", "max_discignment", "max2discignment", "max_iscward", "max_diffenter", "max2discard", "max_contward", "max_contignment", "max_disussion", "max_diffward", "max_Discarded", "max_guard", "max_contard", "max_disarding", "max_iscignment", "max_secarded", "max_distard", "max2discorder", "max_guarded", "max_discenter", "max_descarding", "max_descards", "max_diffarded", "max_secord", "max_Discenter", "max_disarded", "max_secarding", "max_disards", "max_discord", "max_regarded", "max_diffignment", "max_discarded", "max_descard", "max_disenter", "max_regussion", "max_disard", "max_diffard", "max_recards", "max_Discward"], "ret": ["ann", "RET", "val", "bit", "reply", "str", "let", "grad", "cat", "result", "match", "alt", "feat", "res", "success", "orig", "reg", "back", "valid", "error", "len", "fun", "job", "lib", "ut", "id", "sat", "fin", "code", "usr", "pat", "rets", "iter", "ext", "att", "ref", "det", "nt", "part", "gt", "def", "flag", "re", "group", "ft", "rc", "count", "Ret", "fi", "mem", "arg", "lit", "order", "rt", "out", "bin", "info"], "acb": ["acsb", "acf", "rcbl", "acl", "Acsb", "ancp", " lacb", "Acb", "ancB", "ACB", " lacbl", "ACb", "rcl", "rcb", "ACl", "ancbl", " acsb", "Acp", "ancsb", " lacbb", " lacl", "ecsb", "ACsb", "ecb", " acl", "acbb", "acB", "ancf", "ecf", "Acf", "acbl", "ancb", "ancbb", "ecp", "rcbb", " acB", "ancl", "acp"]}}
{"project": "qemu", "commit_id": "aff3f0f150769ec4f97c6e2cefe91c4a0377b548", "target": 0, "func": "static void xlnx_ep108_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"Xilinx ZynqMP EP108 board\";\n\n    mc->init = xlnx_ep108_init;\n\n    mc->block_default_type = IF_IDE;\n\n    mc->units_per_default_bus = 1;\n\n    mc->ignore_memory_transaction_failures = true;\n\n}\n", "idx": 17043, "substitutes": {"mc": ["cca", "cs", "di", "cn", "cm", "dc", "coll", "acl", "pc", "inc", "uc", "bc", "ac", "nc", "xml", "mx", "mic", "conn", " MC", "DC", "bm", "ml", "co", "Mc", "mot", "ec", "lc", "ee", "mac", "cci", "ca", "cf", "oc", "c", "cc", "cy", "mr", "MC", "cus", "tc", "mn", "cfg", "PC", "rc", "arc", "cycle", "mm", "spec", "fc", "md", "mi", "m"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                             TCGReg rd, TCGReg rn, uint64_t limm)\n\n{\n\n    unsigned h, l, r, c;\n\n\n\n    assert(is_limm(limm));\n\n\n\n    h = clz64(limm);\n\n    l = ctz64(limm);\n\n    if (l == 0) {\n\n        r = 0;                  /* form 0....01....1 */\n\n        c = ctz64(~limm) - 1;\n\n        if (h == 0) {\n\n            r = clz64(~limm);   /* form 1..10..01..1 */\n\n            c += r;\n\n        }\n\n    } else {\n\n        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */\n\n        c = r - h - 1;\n\n    }\n\n    if (ext == TCG_TYPE_I32) {\n\n        r &= 31;\n\n        c &= 31;\n\n    }\n\n\n\n    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);\n\n}\n", "idx": 17048, "substitutes": {"s": ["g", "cs", "sf", "groups", "f", "sys", "ps", "secondary", "ions", "south", "t", "sq", "ns", "n", "si", "native", "opens", "o", "es", "w", "p", "ts", "ssl", "b", "xs", "fs", "services", "S", "bis", "sets", "ses", "e", "os", "outs", "spec", "qs", "sync", "settings"], "insn": ["insp", "insc", "inssn", " insns", "Insna", "insna", " inssn", "opensns", "Insp", "intssn", "inna", "insns", "inp", " insna", "opensn", " insp", " insc", "Inssn", "intsns", "intsn", "Insn", "inn", "intsc", "openssn", "opensc"], "ext": ["core", "str", "class", "txt", "f", "EXT", "extra", "rest", "type", "x", "feat", "inst", "t", "dim", "orig", "reg", "req", "exec", " extend", "test", "ir", "obj", "ch", "enc", "config", "lib", "xp", "cl", "init", "ord", "external", "data", "rx", "rev", "xt", "ec", "format", " Ext", "ind", "rf", "prot", "def", "z", "desc", "ptr", "vert", "err", "dep", "arch", "ret", "e", "text", "opt", "im", "ie", "Ext", "ctr", "ex"], "rd": ["dr", "ru", "rr", "dra", "erd", "ud", "rus", "rs", "dd", "ds", "rm", "lr", "rh", "rar", "rod", "rob", "ra", "adr", "rx", "usr", "rt", "rss", "hr", "rb", "ld", "rl", "mr", "rf", "xd", "nr", "abc", "cr", "rin", "err", "mn", "vr", "rc", "ril", "RR", "rect", "rw", "RD"], "rn": ["ru", "cdn", "ern", "rr", "ron", "nc", "ro", "rm", "sr", "rh", "rar", "rt", "rx", "nl", "rb", "RN", "pn", "nr", "rf", "roc", "rin", "cr", "rg", "abc", "mn", "err", "nv", "vr", "rc", "fn", "nw", "ril", "anc", "dn", "rw", "cn"], "limm": ["limi", "palm", "memna", "linms", "memM", "Limf", "limM", " limi", "glm", "memm", "lamn", "memf", " limM", "LimM", " limp", " lime", "linf", "Limi", "limn", "lamM", "limf", "logms", "lame", "logn", "linm", "comm", "glf", "logp", "comn", "comms", "memn", "limp", "limna", "glms", "memi", " limn", "linma", "lime", "limma", "lamm", "logna", "logM", "palma", "logm", "glp", "memp", " limf", "limms", " limna", "gln", "lamp", "palf", "palms", "meme", "comp", "Limm", "glma"], "h": ["g", "f", "x", "u", "ul", "oh", "sh", "t", "q", "bh", "rh", "d", "ir", "n", "H", "i", "cl", "hl", "o", "hr", "w", "k", "p", "y", "b", "sl", "ih", "z", "hh", "err", "en", "e", "ph", "hs", "a", "hm", "v", "j", "m"], "l": ["g", "f", "ll", "x", "u", "ul", "ol", "lp", "li", "el", "L", "d", "n", "kl", "i", "cl", "o", "dl", "lc", "w", "nl", "k", "p", "ld", "rl", "y", "b", "sl", "z", "ur", "e", "v", "ln", "j", "m"], "r": ["dr", "ru", "g", "rr", "f", "range", "ro", "u", "rs", "x", "cur", "sr", "lr", "R", "d", "rh", "ir", "n", "or", "ar", "fr", "o", "hr", "w", "rb", "k", "p", "rl", "nr", "rf", "b", "mr", "cr", "er", "re", "rg", "err", "ur", "rc", "e", "rt", "v", "pr", "j", "m"], "c": ["g", "cs", "dc", "f", "pc", "x", "u", "ci", "cur", "t", "q", "d", "n", "col", "ch", "or", "i", "enc", "ar", "o", "ec", "lc", "w", "loc", "k", "ce", "p", "y", "cy", "b", "cr", "z", "ur", "ct", "rc", "e", "C", "cu", "sc", "v", "m"]}}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  bool smm_enabled,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,\n\n                      pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->smm_enabled = smm_enabled;\n\n\n\n    pm->enable_tco = true;\n\n    acpi_pm_tco_init(&pm->tco_regs, &pm->io);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),\n\n        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 17072, "substitutes": {"lpc_pci": ["lpc_dki", "lpc_cci", "lpc_coco", "lpc_fcr", "lpc_cca", "lpc_pcu", "lpc_pdi", "lpc_lcm", "lpc_vcu", "lpc_phpcm", "lpc_lca", "lpc_ppcm", "lpc_vci", "lpc_ppoco", "lpc_lpcm", "lpc_vcm", "lpc_ldi", "lpc_fdi", "lpc_ddi", "lpc_phpci", "lpc_ccr", "lpc_cdi", "lpc_mca", "lpc_ccu", "lpc_fki", "lpc_pku", "lpc_dcr", "lpc_pki", "lpc_ppi", "lpc_phppi", "lpc_lcr", "lpc_lpi", "lpc_cki", "lpc_lki", "lpc_poco", "lpc_ppci", "lpc_lcu", "lpc_vdi", "lpc_lppi", "lpc_lpku", "lpc_lci", "lpc_loco", "lpc_lku", "lpc_mci", "lpc_mki", "lpc_lpci", "lpc_phpku", "lpc_pcm", "lpc_fci", "lpc_pca", "lpc_mcm", "lpc_ppcr", "lpc_pcr", "lpc_ccm", "lpc_dci"], "pm": ["lv", "wp", "jp", "sem", "api", "tm", "um", "mail", "pl", "pb", "gem", "mr", "period", "mi", "m", "gm", "cm", "pt", "vim", "cli", "pd", "lam", "mod", "param", "py", "rem", "ram", "program", "mand", "gram", "p", "prem", "pkg", "am", "mn", "vm", "gmail", "num", "model", "mp", "hm", "ams", "manager", "PM", "cp", "pc", "lp", "rm", "fm", "bm", "module", "db", "pp", "pa", "lc", "dem", "git", "mm", "rpm", "asm", "po", "dim", "wm", "dm", "member", "pi", "iam", "ml", "pg", "mo", "em", "km", "service", "gp", "ym", "px", "imm", "nm", "im", "plugin", "amp"], "smm_enabled": ["scm_used", "smmfEnabled", "smm_powered", "spm_disabled", "scm_Enabled", "smmfenable", "scm_enable", "smmfdisabled", "scm_disabled", "smm_enable", "spm_enabled", "scm_enabled", "smm_used", "smmfenabled", "smm_Enabled", "smm_disabled", "spm_powered"], "sci_irq": ["sci_ireque", "sci_irtce", "sci_mirv", "sci_rinq", "sci_ireq", "sci_irg", "sci_irig", "sci_rg", "sci_ireg", "sci_mirg", "sci_rquire", "sci_irequire", "sci_rq", "sci_mirq", "sci_rinv", "sci_rince", "sci_iriq", "sci_ring", "sci_irv", "sci_iriquire", "sci_mirce", "sci_irtg", "sci_irtq", "sci_irque", "sci_irquire", "sci_irique", "sci_irce", "sci_irtv", "sci_rque"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, bool isread,\n\n                       unsigned int op0, unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    const ARMCPRegInfo *ri;\n\n    TCGv_i64 tcg_rt;\n\n\n\n    ri = get_arm_cp_reginfo(s->cp_regs,\n\n                            ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP,\n\n                                               crn, crm, op0, op1, op2));\n\n\n\n    if (!ri) {\n\n        /* Unknown register; this might be a guest error or a QEMU\n\n         * unimplemented feature.\n\n         */\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch64 \"\n\n                      \"system register op0:%d op1:%d crn:%d crm:%d op2:%d\\n\",\n\n                      isread ? \"read\" : \"write\", op0, op1, crn, crm, op2);\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    /* Check access permissions */\n\n    if (!cp_access_ok(s->current_el, ri, isread)) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (ri->accessfn) {\n\n        /* Emit code to perform further access permissions checks at\n\n         * runtime; this may result in an exception.\n\n         */\n\n        TCGv_ptr tmpptr;\n\n        TCGv_i32 tcg_syn;\n\n        uint32_t syndrome;\n\n\n\n        gen_a64_set_pc_im(s->pc - 4);\n\n        tmpptr = tcg_const_ptr(ri);\n\n        syndrome = syn_aa64_sysregtrap(op0, op1, op2, crn, crm, rt, isread);\n\n        tcg_syn = tcg_const_i32(syndrome);\n\n        gen_helper_access_check_cp_reg(cpu_env, tmpptr, tcg_syn);\n\n        tcg_temp_free_ptr(tmpptr);\n\n        tcg_temp_free_i32(tcg_syn);\n\n    }\n\n\n\n    /* Handle special cases first */\n\n    switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n\n    case ARM_CP_NOP:\n\n        return;\n\n    case ARM_CP_NZCV:\n\n        tcg_rt = cpu_reg(s, rt);\n\n        if (isread) {\n\n            gen_get_nzcv(tcg_rt);\n\n        } else {\n\n            gen_set_nzcv(tcg_rt);\n\n        }\n\n        return;\n\n    case ARM_CP_CURRENTEL:\n\n        /* Reads as current EL value from pstate, which is\n\n         * guaranteed to be constant by the tb flags.\n\n         */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        tcg_gen_movi_i64(tcg_rt, s->current_el << 2);\n\n        return;\n\n    case ARM_CP_DC_ZVA:\n\n        /* Writes clear the aligned block of memory which rt points into. */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        gen_helper_dc_zva(cpu_env, tcg_rt);\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        gen_io_start();\n\n    }\n\n\n\n    tcg_rt = cpu_reg(s, rt);\n\n\n\n    if (isread) {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            tcg_gen_movi_i64(tcg_rt, ri->resetvalue);\n\n        } else if (ri->readfn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_get_cp_reg64(tcg_rt, cpu_env, tmpptr);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_ld_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    } else {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            /* If not forbidden by access permissions, treat as WI */\n\n            return;\n\n        } else if (ri->writefn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_set_cp_reg64(cpu_env, tmpptr, tcg_rt);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_st_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        /* I/O operations must end the TB here (whether read or write) */\n\n        gen_io_end();\n\n        s->is_jmp = DISAS_UPDATE;\n\n    } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n        /* We default to ending the TB on a coprocessor register write,\n\n         * but allow this to be suppressed by the register definition\n\n         * (usually only necessary to work around guest bugs).\n\n         */\n\n        s->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n", "idx": 17082, "substitutes": {"s": ["g", "is", "cs", "server", "self", "sf", "client", "sys", "f", "session", "http", "ops", "cli", "less", "rs", "js", "south", "t", "conn", "sq", "ss", "scope", "ions", "d", "ns", "n", "si", "i", "storage", "h", "r", "ls", "o", "es", "ctx", "us", "gs", "sk", "c", "p", "sb", "sci", "ks", "service", "ts", "ssl", "b", "sie", "xs", "su", "fs", "services", "sim", "stats", "S", "sets", "ses", "e", "sv", "os", "request", "sg", "spec", "sc", "ds", "qs", "sync", "settings"], "insn": ["insN", "nssn", "INSsn", "INSN", "nsN", "nsn", "nsl", "consn", "consN", "insl", "consl", "INSl", "INSn", "inssn", "conssn"], "isread": ["ireadable", "Isreading", " isplay", "isreading", "isplay", "ISwrite", "iplay", "ISread", "misread", "isiread", "isoread", "usread", "isRead", "asbroken", " isreading", "miswrite", "isreadable", " isload", " isreader", "iread", "iwrite", "isload", "asread", "isobroken", " isbroken", "isoRead", "misplay", " isRead", "isbroken", "Isload", "ISride", "isireadable", "Iswrite", " iswrite", "Isplay", "isiwrite", "Isride", "usload", "isreader", "ireader", "asRead", " isreadable", "ISplay", "Isread", "uswrite", " isride", "misreader", "iswrite", "isride", "usreading"], "op0": ["ip1", "opt3", "opt2", "OP00", "Op00", "OP2", "op00", " op4", "Op0", "opt4", "Op2", "op4", " op00", "ip4", "opt1", "OP0", "ip00", "OP1", "opt0", "OP3", "Op1", "ip2", "ip0", "op3", " op3"], "op1": ["hop1", "ip1", "cop1", "OP2", "OP4", "cop0", "op4", "ip4", "OP0", "hop2", "cop3", "cop4", "oper0", "OP1", "OP3", "oper1", "cop2", "ip2", "ip0", "op3", "oper4", "hop0", " op3", "oper2", "hop4"], "op2": ["oper02", "ip1", "hop1", "cop1", "OP2", "op02", " op4", "cop02", "hop02", "OP02", "OP4", "ip02", "op4", "ip4", " op02", "OP0", "hop2", "OP1", "oper1", "cop2", "ip2", "oper4", "hop0", "oper2"], "crn": ["CRm", " crb", "crw", " crp", "CR1", "CRb", "CRn", "crN", "CRd", " crN", "CRw", "crl", " cr1", "Crm", "crp", "CRp", " crd", "prp", "crb", "CrN", "Crn", "CRl", " crw", "prd", "cr1", "CRN", "prm", "pr1", "Crl", "Crw", "crd", " crl", "prn", "Crb"], "crm": [" crv", "CRm", "CrM", "CRv", " crp", " crM", "cfm", "CRn", "crmn", "crM", "prf", "crv", "Cr2", "crl", "cr2", "prmn", " cr2", "Crm", "CR2", "crp", "CRp", "cfn", "CRmn", "Crn", "CRl", "CRf", " crmn", "cfp", " crf", "CRM", "prm", "Crl", "crf", "cfv", " crl", "prn"], "rt": ["dr", "ru", "sn", "rat", "rr", "grad", "pt", "ry", "lt", "wt", "bt", "alt", "NT", "rs", "t", "rm", "it", "error", "sr", "rh", "rid", "ort", "reg", "mt", "lat", "tt", "r", "adr", "addr", "rx", "fr", "qt", "rb", "ot", "nt", "rd", "gt", "rl", "irt", "rf", "cr", "ptr", "yt", "vt", "ft", "vr", "rc", "attr", "ret", "rn", "RT", "ant", "rot", "rect", "ti", "offset"], "ri": ["dr", "di", "rie", "sn", "rr", "ry", "xi", "ski", "qi", "ro", "rs", "ci", "li", "abi", "eni", "rit", "uri", "sr", "rh", "rid", "ir", "ti", "rib", "si", "RI", "pi", "i", "rob", "vi", "stri", "ar", "r", "ai", "ra", "rx", "ii", "loc", "ior", "rb", "ris", "ic", "rf", "ari", "ki", "cr", "rin", "rg", "ni", "gi", "rc", "iri", "fi", "adi", "rn", "ori", "rio", "rip", "ini", "udi", "ani", "mi", "dri"], "tcg_rt": ["tcG_rx", "tcg_rn", "tcG_opt", "tcj_rt", "tcgg7rt", "tcgg_rt", "tcj_rx", "tcg_rx", "tcg_opt", "tcgg_rit", "tcj_dr", "tcg_rit", "tcg7RT", "tcj_la", "tcG_rot", "tcg__rx", "tcgg_rs", "tcG_rn", "tcG_RT", "tcg_RT", "tcg__la", "tcg__rt", "tcG_rt", "tcg__dr", "tcg7rs", "tcg_rs", "tcgg7RT", "tcgg7rit", "tcgg7rs", "tcg_la", "tcg_rot", "tcgg_RT", "tcg_dr", "tcg7rit", "tcg7rt"], "tmpptr": ["tmpltr", "tmparsr", "tmplort", "tmppr", "tomptTR", "tmopppr", "tmppTR", "TMppetr", "tomppTR", "tmappTR", "tmpTr", "tmpprom", "tmplptr", "tompsptr", "tmapptr", "TMplsr", "TMpletr", "tmppptr", "TMppsr", "tmpsr", "tmpletr", "tmpsptr", "tmpgr", "tmpgtr", "tompstr", "TMptr", "tmptcr", "tmpttr", "tmppTr", "tmptpr", "tompsr", "tmappetr", "TMppcr", "tmoppr", "TMpltr", "TMppr", "tmplrom", "tmpgort", "tmoppcr", "TMpppr", "tmappr", "tmptTR", "tmpppr", "tomppTr", "tmpartr", "tmppcr", "tmptr", "tompttr", "TMplrom", "tompport", "tmopptr", "TMpprom", "tomptr", "tmppsr", "tmparrom", "tmpstr", "TMpptr", "TMpcr", "tmptTr", "tomptTr", "tmapprom", "tmpr", "tompptr", "tmparetr", "tmplr", "tmppetr", "tmappsr", "tmappTr", "tmpsort", "tmpgptr", "tompsort", "tmpTR", "tmplsr", "tmpcr", "tmpport", "tomppptr", "tomppr", "TMpr"], "tcg_syn": ["tcg__poly", "tcg_sync", "tcG_sn", "tcg_special", "tcg_poly", "tcgm_sys", "tcgpysyn", "tcg_Syn", "tcgpysync", "tcgmpysyn", "tcg_opt", "tcgmpyopt", "tcG_rin", "tcg__sn", "tcg__sync", "tcgmpysys", "tcG_special", "tcgmpysync", "tcg_sn", "tcg_rin", "tcg__syn", "tcgm_sync", "tcG_syn", "tcG_poly", "tcg_sys", "tcg__special", "tcgpysys", "tcG_Syn", "tcg__Syn", "tcG_sync", "tcgm_opt", "tcg__rin", "tcgm_syn", "tcgpyopt"], "syndrome": ["cyntrom", "syngchrome", "Syntchrome", "syntrome", "syddchrome", "cyndrome", "syngrome", "Syntroma", "cyntchrome", "syntrim", "sydrome", "Syntrome", "cyndroma", "syndroma", "Syndchrome", "syngrom", "syundrome", "syddroma", "syundchrome", "cyntrim", "syundrom", "cyndrom", "syndchrome", "Syntrom", "syngroma", "Syndroma", "sydchrome", "cyntrome", "syntrom", "syddrim", "syndrim", "cyntroma", "syntchrome", "syntroma", "sydrim", "cyndchrome", "syundroma", "syddrom", "Syndrom", "Syndrome", "syddrome", "syndrom", "cyndrim", "sydrom"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n", "idx": 17085, "substitutes": {"data": ["batch", "self", "alpha", "json", "client", "result", "database", "type", "cache", "parent", "DATA", "window", "buffer", "valid", "test", "view", "base", "Data", "config", "init", "input", "parser", "raw", "reader", "writer", "object", "da", "null", "image", "dat", "model", "start", "text", "a", "empty"], "json_string": ["json_list", "json1list", " json_data", "json1data", "query_strings", "json2string", " json_type", "query_version", "json_data", "json2strings", "json_version", " json_list", "json_strings", "query_text", "json2version", "json_text", "query_string", "json_type", "json1type", "json1string", "json2text"]}}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n", "idx": 17092, "substitutes": {"mon": ["ann", "meter", "bo", "chan", "com", "domain", "Mon", "conn", "arm", "MON", "mu", "don", "dim", "demon", "eor", " monitor", "atom", "module", "Monitor", "mons", "con", "man", "monitor", "comm", "mor", "an", "chron", "channel", "mn", "bean", "mc", "pid", "dog", "mun", "master", "mag", "md", "mi", "m"]}}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 17101, "substitutes": {"ivgen": ["ivergen", "ocgate", "ivgate", "ivgener", "ihGen", "evGen", "ocrGen", "ihgin", "ivlif", "ovgen", "ervneg", "ocrgener", "avGen", "hrgen", "ivergeneration", "evgen", "ihget", "hrgin", "ivercon", "vlif", " ivlif", "ovGen", "ivgeneration", "vgener", "ecgate", "irgener", "occon", "eccon", "ivneg", "evgeneration", "hrget", "irGen", "ivGen", "iverGen", "ervgener", "ecGen", "evneg", "irgen", "ervgeneration", "vgen", "ihgen", "vgeneration", "ocgen", "ocrgen", "ivcon", "avgeneration", "ivergener", "evgener", " ivgener", "ervlif", "avgener", "ocrgeneration", "ervgen", "ivget", "ivgin", "ivergate", "ecgen", "irgeneration", "hrGen", "evgin", "ovgener", "avgen", "ocGen", "evget", "ervGen", " ivgeneration", "ovneg"], "key": ["copy", "match", "type", "x", "name", "cache", "KEY", "temp", "wire", "connection", "fee", "base", "message", "ip", "id", "pair", "address", "private", "code", "change", "data", "Key", "block", "sum", "cert", "k", "ce", "crypt", "hash", "value", "sign", "image", "seed", "row", "password", "secret", "v", "size"], "nkey": [" nmix", "Nhash", "Nmix", " nhex", "nchash", "nmix", "Nmac", "nskey", "nhex", "nckey", "nsmac", "Nhex", "nchex", "nmac", "ncmac", "nsmix", "Nkey", " nmac", "nshash"], "errp": ["acerb", "erpre", " err", "arrr", " errr", " errpat", " erc", "eorpre", " errc", "arrc", "eorp", "erb", "acerp", "dangerpp", "errb", "errpre", "eorpat", "eorpp", "acerfp", "erp", "dangerp", " errb", " errpy", "errpy", " erpy", "dangerpre", "arrp", "erfp", "dangerpat", "errpat", " errfp", "errpp", " errpre", "errfp", " errpp", "arrpy", "errr", "acerpre", " erp", "errc"], "salt": ["sash", "psALT", "watt", " sass", " sALT", "sodium", "osALT", "sALT", "walt", "ssass", "sass", "nsodium", "syssecret", "sysodium", "sysalt", "nssecret", "ssecret", "nsALT", "sysALT", " sodium", "osash", "ssALT", "psass", "sssecret", "wash", "osalt", " ssecret", "satt", "pssecret", "ssalt", "ssash", "psalt", "nsass", "wALT", "ssatt", "osatt"], "nhash": ["shash", "nohost", "rnhash", "cnhex", "nch", "nshex", "nobuild", "sh", "nheader", "Nhash", "nsh", "nsheader", " nhex", "ch", " nsum", " nblock", "nblock", "nh", "nshash", "rnh", "nohash", "nhost", "Nheader", "cnhash", "nekey", "chex", "cheader", "cnkey", "neurl", "nbuild", "nhex", "chash", " nbuild", " nh", "nikey", "rnhex", "nckey", "noh", "sbuild", "cnblock", "ncsum", "nurl", "niurl", "Nhex", " nhost", "rnsum", "Nh", " nurl", "nihash", "nsum", "nehash", "neh", "nih", "shost", "ncblock", "nchash", "nchex"], "nsalt": ["nsafe", "NSafe", "ainsert", "nsul", "sodium", "ainsalt", "NSALT", "sALT", "ainsodium", "netsalt", "sass", "gsodium", "nsol", "nsodium", "gsalt", "nsert", "gsert", "netshash", "netsert", "netsodium", " nsALT", "nasalt", "nsALT", "namesalt", "ssodium", "ssALT", "sort", "namesol", "namesALT", "safe", "ssafe", "sol", "namesass", "ainshash", "ssalt", "sul", " nsort", " nsul", "gshash", " nsol", "NSalt", "NSodium", "nsass", "nasALT", "nsort", "nasort", "nasul", " nsass", "nshash"], "essiv": ["essesort", "hessiv", "assiver", "essesiv", "eserv", "esive", "esrc", "ssort", "hesserv", "lessiver", "essiver", "esient", "cesserv", "essort", "esserv", "essrc", "cessive", "essesive", "esseserv", "essivation", "ssiver", "essliv", "assiv", "issivation", "ossiv", "ossort", "osserv", "cessiv", "ossivation", "essesient", "lessliv", "esiv", "lessivation", "esivation", "esiver", "essesiver", "essient", "essesenc", "cessient", "assivation", "ossrc", "essive", "essenc", "hessivation", "issiv", "issliv", "esliv", "lessiv", "sserv", "issiver", "ssiv", "asserv", "ossiver", "essesrc", "esenc", "hessiver", "cessiver", "cessenc"]}}
{"project": "FFmpeg", "commit_id": "bb6f51aeab88a252cf08f5a0ec26ab41ae2d74a2", "target": 1, "func": "static void mpeg1_encode_sequence_header(MpegEncContext *s)\n\n{\n\n        unsigned int vbv_buffer_size;\n\n        unsigned int fps, v;\n\n        int n;\n\n        UINT64 time_code;\n\n        \n\n        if ((s->picture_number % s->gop_size) == 0) {\n\n            /* mpeg1 header repeated every gop */\n\n            put_header(s, SEQ_START_CODE);\n\n            \n\n            /* search closest frame rate */\n\n            {\n\n                int i, dmin, d;\n\n                s->frame_rate_index = 0;\n\n                dmin = 0x7fffffff;\n\n                for(i=1;i<9;i++) {\n\n                    d = abs(s->frame_rate - frame_rate_tab[i]);\n\n                    if (d < dmin) {\n\n                        dmin = d;\n\n                        s->frame_rate_index = i;\n\n                    }\n\n                }\n\n            }\n\n \n\n            put_bits(&s->pb, 12, s->width);\n\n            put_bits(&s->pb, 12, s->height);\n\n            put_bits(&s->pb, 4, 1); /* 1/1 aspect ratio */\n\n            put_bits(&s->pb, 4, s->frame_rate_index);\n\n            v = s->bit_rate / 400;\n\n            if (v > 0x3ffff)\n\n                v = 0x3ffff;\n\n            put_bits(&s->pb, 18, v);\n\n            put_bits(&s->pb, 1, 1); /* marker */\n\n            /* vbv buffer size: slightly greater than an I frame. We add\n\n               some margin just in case */\n\n            vbv_buffer_size = (3 * s->I_frame_bits) / (2 * 8);\n\n            put_bits(&s->pb, 10, (vbv_buffer_size + 16383) / 16384); \n\n            put_bits(&s->pb, 1, 1); /* constrained parameter flag */\n\n            put_bits(&s->pb, 1, 0); /* no custom intra matrix */\n\n            put_bits(&s->pb, 1, 0); /* no custom non intra matrix */\n\n\n\n            put_header(s, GOP_START_CODE);\n\n            put_bits(&s->pb, 1, 0); /* do drop frame */\n\n            /* time code : we must convert from the real frame rate to a\n\n               fake mpeg frame rate in case of low frame rate */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            time_code = s->fake_picture_number * FRAME_RATE_BASE;\n\n            s->gop_picture_number = s->fake_picture_number;\n\n            put_bits(&s->pb, 5, (UINT32)((time_code / (fps * 3600)) % 24));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / (fps * 60)) % 60));\n\n            put_bits(&s->pb, 1, 1);\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / fps) % 60));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code % fps) / FRAME_RATE_BASE));\n\n            put_bits(&s->pb, 1, 1); /* closed gop */\n\n            put_bits(&s->pb, 1, 0); /* broken link */\n\n        }\n\n\n\n        if (s->frame_rate < (24 * FRAME_RATE_BASE) && s->picture_number > 0) {\n\n            /* insert empty P pictures to slow down to the desired\n\n               frame rate. Each fake pictures takes about 20 bytes */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            n = ((s->picture_number * fps) / s->frame_rate) - 1;\n\n            while (s->fake_picture_number < n) {\n\n                mpeg1_skip_picture(s, s->fake_picture_number - \n\n                                   s->gop_picture_number); \n\n                s->fake_picture_number++;\n\n            }\n\n\n\n        }\n\n        s->fake_picture_number++;\n\n}\n", "idx": 17113, "substitutes": {"s": ["g", "set", "self", "sites", "lines", "ms", "session", "bs", "uns", "secondary", "x", "js", "plugins", "r", "comm", "gs", "conf", "c", "ssl", "b", "sl", "fs", "stats", "as", "sets", "a", "ins", "qs", "m", "server", "sf", "http", "com", "ns", "site", "si", "your", "full", "strings", "es", "us", "params", "p", "sb", "ks", "ts", "y", "sie", "sis", "services", "l", "sym", "words", "se", "its", "sync", "ops", "f", "this", "sports", "rs", "ss", "sq", "o", "xs", "S", "sg", "ses", "hs", "spec", "is", "cs", "aws", "sys", "ps", "new", "t", "parts", "ls", "w", "side", "k", "service", "comments", "request", "e", "os", "features", "ds", "an", "settings"], "vbv_buffer_size": ["vbv_buffer6capacity", "vbv_buffer6size", "vbv_buffer_left", "vbv_byte_number", "vbv_buffer_capacity", "vbv_byte_size", "vbv_buffer6num", "vbv_buffer_length", "vbv_byte_num", "vbv_byte_length", "vbv_buffer_number", "vbv_buffer_num", "vbv_byte_left", "vbv_byte_capacity"], "fps": [" frames", "val", "eps", "flags", "frames", "lines", "f", "resolution", "ops", "ps", "ports", "x", "frame", "values", "hops", "ss", "vals", "fee", "frequency", "xp", "hz", "bits", "ips", "versions", "vp", "bps", "vs", "Hz", "ls", "params", "live", "details", "fp", "p", "cpu", "b", "fs", "bytes", "bis", "photos", "seq", "seconds", "life"], "v": ["g", "val", "f", "uv", "resolution", "lv", "ov", "x", "u", "q", "video", "conv", "version", "av", "vi", "vid", "h", "va", "vp", "iv", "vs", "volt", "volume", "w", "c", "k", "p", "cv", "vol", "b", "value", "z", "ve", "vert", "nv", "vt", "vr", "ev", "e", "sv", "l", "vv", "V", "tv", "ver", "m"], "n": ["g", "sn", "f", "nc", "x", "ns", "len", " fn", "nn", "vs", "w", "nl", "N", "p", "b", "ni", "nb", "ng", "fn", "num", "e", "l", " f", " N", "j"], "time_code": ["time2rate", " time_codes", "time_Code", "time2codes", "time2num", " time_zone", "time_codes", " time_Code", "time_coded", "time54codes", "time__coded", "time2Code", " time_coded", "time_index", "time_zone", "time54code", "time__index", "time_rate", " time_range", "time_num", "time2range", "time2code", "time54index", " time_rate", "time_range", " time_index", "time2zone", "time__codes", "time54coded", " time_num", "time__code"], "i": ["phi", "di", "f", "ri", "xi", "x", "qi", "ix", "u", "ci", "li", "in", "ji", "bi", "it", "eni", "mu", "mi", "uri", "info", "pi", "si", "I", "multi", "id", "h", "index", "ai", "init", "iu", "o", "ii", "k", "c", "p", "y", "ind", "ki", "b", "ui", "ni", "gi", "zi", "fi", "e", "l", "a", "io", "oi", "ini", "ti", "j", "m"], "dmin": ["Dmax", "bunit", "dminimum", "Dmin", " dlimit", "dMIN", "DMin", "pMIN", "Din", "sdminimum", "sdMIN", "dlimit", " dminimum", " dunit", "fmax", "fin", "dmini", " dMin", "cdmax", "sdmin", "fMin", "fmid", "sdmini", "dmax", " dmax", " dMIN", " dmini", " dmid", "cdmid", "plimit", "sdlimit", "cdmin", "fmin", "bmin", "pmini", "din", "dmid", "sdunit", "dMin", "bminimum", " din", "dunit", "pmin"], "d": ["g", "di", "min", "dh", "bd", "dc", "f", "D", "length", "dd", "t", "ad", "dm", "dos", "fd", "sd", "gd", "id", "dt", "dom", "diff", "dl", "dx", "dy", "ded", "wd", "rd", "p", "ld", "da", "dad", "nd", "b", "did", "ind", "def", "xd", "z", "dist", "done", "ed", "e", "dp", "dat", "l", "dn", "ds", "md", "j", "m"], "fake_picture_number": ["fake_image_rate", "fake_image_sum", "fake_picture_sum", "fake_picture_num", "fake_picture_rate", "fake_picture_size", "fake_picture\u00b7no", "fake_picture\u00b7num", "fake_picture_no", "fake_picture\u00b7number", "fake_picture\u00b7rate", "fake_image_no", "fake_image_size", "fake_image_num", "fake_image_number"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n", "idx": 17118, "substitutes": {"dst": [" dsts", "dssrc", "dsst", "Dst", " dsl", " drc", "fedst", "fedsrc", "dsts", "dssl", "Dsts", "Drc", "dsl", "drc", "dsrc", " dsrc", "fedsl", "fedrc", "Dsrc"], "src": ["grad", "supp", "rest", "inst", "bc", "source", "buf", "cur", "sr", "rib", "low", "lib", "config", "img", "st", "stream", "loc", "rb", "rd", "sync", "sb", "rl", "gl", "ssl", "b", "sur", "sl", "sup", "dist", "sel", "gz", "rc", "url", "cb", "dest", "gb", "sec", "attr", "start", "sub", "lit", "sc", "rt", "bg", "ctr", "size"], "stride": ["dride", "gride", "ctrider", "strride", "Strides", "hriden", "grided", "stide", "Stride", "Strride", "arride", "driden", "servided", "yride", "ptide", "strider", "servider", "ctride", " strided", "grides", "ptIDE", " strider", "serviden", "strIDE", "stided", "yrided", "strides", "striden", "drider", "Strone", "hride", "strone", "brIDE", "stider", "Strider", "arrone", "hrided", "bride", "arrided", "ptiden", "stides", "briden", "ctrone", "Strided", "ctrided", "servide", "drided", "stiden", " strride", "ptided", "grider", "hrIDE", "yrride", "brided", "arrider", "strided", "yrider"]}}
{"project": "FFmpeg", "commit_id": "57cd2f7777a316a447301a7d4b5d1c01da200661", "target": 0, "func": "static av_cold int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, h264_id, mps_id, ac3_id, dts_id, lpcm_id, j;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n    int audio_bitrate;\n\n    int video_bitrate;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd   =  (CONFIG_MPEG1VCD_MUXER  && ctx->oformat == &ff_mpeg1vcd_muxer);\n\n    s->is_svcd  =  (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer);\n\n    s->is_mpeg2 = ((CONFIG_MPEG2VOB_MUXER  && ctx->oformat == &ff_mpeg2vob_muxer) ||\n\n                   (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer) ||\n\n                   (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer));\n\n    s->is_dvd   =  (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer);\n\n\n\n    if (ctx->packet_size) {\n\n        if (ctx->packet_size < 20 || ctx->packet_size > (1 << 23) + 10) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Invalid packet size %d\\n\",\n\n                   ctx->packet_size);\n\n            goto fail;\n\n        }\n\n        s->packet_size = ctx->packet_size;\n\n    } else\n\n        s->packet_size = 2048;\n\n    if (ctx->max_delay < 0)     /* Not set by the caller */\n\n        ctx->max_delay = AV_TIME_BASE*7/10;\n\n\n\n    s->vcd_padding_bytes_written = 0;\n\n    s->vcd_padding_bitrate_num   = 0;\n\n\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n\n\n    mpa_id  = AUDIO_ID;\n\n    ac3_id  = AC3_ID;\n\n    dts_id  = DTS_ID;\n\n    mpv_id  = VIDEO_ID;\n\n    h264_id = H264_ID;\n\n    mps_id  = SUB_ID;\n\n    lpcm_id = LPCM_ID;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        st     = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        avpriv_set_pts_info(st, 64, 1, 90000);\n\n\n\n        switch (st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (!s->is_mpeg2 &&\n\n                (st->codec->codec_id == AV_CODEC_ID_AC3 ||\n\n                 st->codec->codec_id == AV_CODEC_ID_DTS ||\n\n                 st->codec->codec_id == AV_CODEC_ID_PCM_S16BE))\n\n                 av_log(ctx, AV_LOG_WARNING,\n\n                        \"%s in MPEG-1 system streams is not widely supported, \"\n\n                        \"consider using the vob or the dvd muxer \"\n\n                        \"to force a MPEG-2 program stream.\\n\",\n\n                        avcodec_get_name(st->codec->codec_id));\n\n            if (st->codec->codec_id == AV_CODEC_ID_AC3) {\n\n                stream->id = ac3_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_DTS) {\n\n                stream->id = dts_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_PCM_S16BE) {\n\n                stream->id = lpcm_id++;\n\n                for (j = 0; j < 4; j++) {\n\n                    if (lpcm_freq_tab[j] == st->codec->sample_rate)\n\n                        break;\n\n                }\n\n                if (j == 4)\n\n                    goto fail;\n\n                if (st->codec->channels > 8)\n\n                    return -1;\n\n                stream->lpcm_header[0] = 0x0c;\n\n                stream->lpcm_header[1] = (st->codec->channels - 1) | (j << 4);\n\n                stream->lpcm_header[2] = 0x80;\n\n                stream->lpcm_align     = st->codec->channels * 2;\n\n            } else {\n\n                stream->id = mpa_id++;\n\n            }\n\n\n\n            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).\n\n             * Right now it is also used for everything else. */\n\n            stream->max_buffer_size = 4 * 1024;\n\n            s->audio_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (st->codec->codec_id == AV_CODEC_ID_H264)\n\n                stream->id = h264_id++;\n\n            else\n\n                stream->id = mpv_id++;\n\n            if (st->codec->rc_buffer_size)\n\n                stream->max_buffer_size = 6 * 1024 + st->codec->rc_buffer_size / 8;\n\n            else {\n\n                av_log(ctx, AV_LOG_WARNING,\n\n                       \"VBV buffer size not set, using default size of 130KB\\n\"\n\n                       \"If you want the mpeg file to be compliant to some specification\\n\"\n\n                       \"Like DVD, VCD or others, make sure you set the correct buffer size\\n\");\n\n                // FIXME: this is probably too small as default\n\n                stream->max_buffer_size = 230 * 1024;\n\n            }\n\n            if (stream->max_buffer_size > 1024 * 8191) {\n\n                av_log(ctx, AV_LOG_WARNING, \"buffer size %d, too large\\n\", stream->max_buffer_size);\n\n                stream->max_buffer_size = 1024 * 8191;\n\n            }\n\n            s->video_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            stream->id              = mps_id++;\n\n            stream->max_buffer_size = 16 * 1024;\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n        stream->fifo = av_fifo_alloc(16);\n\n        if (!stream->fifo)\n\n            goto fail;\n\n    }\n\n    bitrate       = 0;\n\n    audio_bitrate = 0;\n\n    video_bitrate = 0;\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        int codec_rate;\n\n        st     = ctx->streams[i];\n\n        stream = (StreamInfo *)st->priv_data;\n\n\n\n        if (st->codec->rc_max_rate ||\n\n            st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            codec_rate = st->codec->rc_max_rate;\n\n        else\n\n            codec_rate = st->codec->bit_rate;\n\n\n\n        if (!codec_rate)\n\n            codec_rate = (1 << 21) * 8 * 50 / ctx->nb_streams;\n\n\n\n        bitrate += codec_rate;\n\n\n\n        if ((stream->id & 0xe0) == AUDIO_ID)\n\n            audio_bitrate += codec_rate;\n\n        else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            video_bitrate += codec_rate;\n\n    }\n\n\n\n    if (s->user_mux_rate) {\n\n        s->mux_rate = (s->user_mux_rate + (8 * 50) - 1) / (8 * 50);\n\n    } else {\n\n        /* we increase slightly the bitrate to take into account the\n\n         * headers. XXX: compute it exactly */\n\n        bitrate    += bitrate / 20;\n\n        bitrate    += 10000;\n\n        s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n        if (s->mux_rate >= (1<<22)) {\n\n            av_log(ctx, AV_LOG_WARNING, \"mux rate %d is too large\\n\", s->mux_rate);\n\n            s->mux_rate = (1<<22) - 1;\n\n        }\n\n    }\n\n\n\n    if (s->is_vcd) {\n\n        int64_t overhead_rate;\n\n\n\n        /* The VCD standard mandates that the mux_rate field is 3528\n\n         * (see standard p. IV-6).\n\n         * The value is actually \"wrong\", i.e. if you calculate\n\n         * it using the normal formula and the 75 sectors per second transfer\n\n         * rate you get a different value because the real pack size is 2324,\n\n         * not 2352. But the standard explicitly specifies that the mux_rate\n\n         * field in the header must have this value. */\n\n        // s->mux_rate = 2352 * 75 / 50;    /* = 3528 */\n\n\n\n        /* The VCD standard states that the muxed stream must be\n\n         * exactly 75 packs / second (the data rate of a single speed cdrom).\n\n         * Since the video bitrate (probably 1150000 bits/sec) will be below\n\n         * the theoretical maximum we have to add some padding packets\n\n         * to make up for the lower data rate.\n\n         * (cf. VCD standard p. IV-6 ) */\n\n\n\n        /* Add the header overhead to the data rate.\n\n         * 2279 data bytes per audio pack, 2294 data bytes per video pack */\n\n        overhead_rate  = audio_bitrate * 2294LL * (2324 - 2279);\n\n        overhead_rate += video_bitrate * 2279LL * (2324 - 2294);\n\n\n\n        /* Add padding so that the full bitrate is 2324*75 bytes/sec */\n\n        s->vcd_padding_bitrate_num = (2324LL * 75 * 8 - bitrate) * 2279 * 2294 - overhead_rate;\n\n#define VCD_PADDING_BITRATE_DEN (2279 * 2294)\n\n    }\n\n\n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n        s->pack_header_freq = 1;\n\n\n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* the standard mandates that there are only two system headers\n\n         * in the whole file: one in the first packet of each stream.\n\n         * (see standard p. IV-7 and IV-8) */\n\n        s->system_header_freq = 0x7fffffff;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        stream                = ctx->streams[i]->priv_data;\n\n        stream->packet_number = 0;\n\n    }\n\n    s->system_header_size = get_system_header_size(ctx);\n\n    s->last_scr           = AV_NOPTS_VALUE;\n\n    return 0;\n\n\n\nfail:\n\n    for (i = 0; i < ctx->nb_streams; i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 17120, "substitutes": {"ctx": ["coll", "client", "jp", "ds", "na", "ci", "connection", "support", "cl", "gs", "cf", "conf", "c", "vc", "Context", "cfg", "context", "CV", "ctrl", "qs", "cm", "cli", "nc", "buf", "np", "hw", "qa", "cas", "fp", "cam", "kw", "pkg", "wcs", "cu", "kb", "sync", "console", "cp", "pc", "cal", "ck", "cmd", "bc", "sq", "conv", "cms", "config", " context", "lc", "cc", "sci", "xs", "cus", "ct", "cb", "rc", "fn", "hs", "cn", "cca", "cs", "css", "sys", "conn", "cpp", "ls", "loc", "ca", "cv", "tx", "tc", "so", "cmp", "anc", "general", "xc", "sc", "event", "settings"], "s": ["g", "set", "cs", "self", "client", "sys", "session", "sa", "f", "ops", "ps", "u", "rs", "ds", "js", "t", "ss", "sq", "d", "ns", "ans", "n", "si", "args", "rates", "storage", "r", "ls", "es", "us", "gs", "sk", "conf", "c", "p", "sb", "ks", "service", "ts", "b", "ssl", "sl", "xs", "su", "fs", "services", "S", "context", "sg", "ses", "e", "sv", "sets", "hs", "settings", "a", "l", "os", "utils", "sc", "se", "spec", "qs", "v", "sync", "m"], "bitrate": ["compcount", "comprates", "bitrates", "audrate", "comprate", "bitcount", " bitcount", "audcount", " bitrates", "audrates"], "i": ["g", "f", "xi", "u", "ci", "li", "uri", "d", "info", "n", "ip", "I", "pi", "si", "id", "ai", "iu", "ii", "c", "k", "p", "b", "ni", "io", "ini", "mi", "m"], "mpa_id": ["mpca_pid", "mpca_type", "mpca_sid", "mpba_id", "mpa__pid", "mpa_sid", "mpba_key", "mpba_name", "mpca_id", "mpa__id", "mpa_key", "mpa__sid", "mpa_pid", "mpa_kid", "mpba_kid", "mpa_type", "mpa__type", "mpa_name"], "mpv_id": ["mpv_source", "mpf_source", "mpf_sid", "mpv__id", "mpf_id", "mpv_sid", "mpv__source", "mpf_type", "mpv__sid", "mpv__type", "mpv_type"], "h264_id": ["hvr_min", "hvr_name", "hvrappmin", "h264_name", "h264appname", "hvrappname", "hvrappid", "h264_source", "hvr_id", "h264appmin", "h264appsource", "h264_min", "hvrappsource", "hvr_source", "h264appid"], "mps_id": ["mds_type", "mpsOCKkid", "mps_type", "mds_kid", "mpsOCKsource", "mds_id", "mps_source", "mpsOCKtype", "mds_source", "mps_kid", "mpsOCKid"], "ac3_id": ["acwd_id", "ac3_ident", "ac3__ident", "ac3uuid", "ac3uupath", "acway_link", "ac3_aid", "ac3uulink", "ac3_ids", "acway_aid", "ac3_link", "acway_id", "acwd_ident", "acway_path", "ac3__id", "ac3uuaid", "ac3__ip", "ac3__ids", "ac3_ip", "acwd_ip", "acwd_ids", "ac3_path"], "dts_id": ["g", "dtz_kid", "dtz_name", "dtz_id", "dtz_oid", "src", "_", "dts_oid", "all", "c", "dts_name", "url", "dts_kid"], "lpcm_id": ["pcmacheid", "pmediaacheids", "pcm_error", "pcmacheident", "pcmacheids", "pcm_ids", "pcmPident", "pcm_ident", "pmedia_ids", "pmediaacheerror", "pmedia_id", "pcmPid", "pcmacheerror", "pmediaacheident", "pmediaacheid", "pcmPids", "pcmPerror", "pmedia_error", "pcm_id", "pmedia_ident"], "j": ["g", "f", "jp", "js", "jam", "q", "ji", "jl", "job", "ij", "obj", "vision", "jit", "dj", "kj", "o", "aj", "k", "pos", "uj", "note", "z", "J", "io", "v", "jj", "m"], "st": ["sn", "sa", "src", "sp", "inst", "sw", "St", "ist", "sm", "sam", "sb", "std", "tmp", "ost", "nd", "sl", "stage", "cr", "ST", "sta", "ct", "sts", "ast", "sth", "sc", "ste", "bl", "amp"], "stream": ["resource", "cm", "output", "src", "uc", "source", "media", "sw", "video", "upload", "pg", "path", "iv", "input", "data", "Stream", "w", "gram", "channel", "cv", "service", "ssl", "sl", "e", "sc", "sync", "m"], "audio_bitrate": ["audio_bitsize", "audio_bitsrate", "audio_binsize", "audio_bitssize", "audio_binspeed", "audio_bandsize", "audio_bandspeed", "audio_bitsspeed", "audio_binrate", "audio_bitspeed", "audio_bandrate"], "video_bitrate": ["video_bandsync", "video_audspeed", "video_bandsize", "video_audsync", "video_bitsize", "video_bandspeed", "video_bitsync", "video_audrate", "video_audsize", "video_bandrate", "video_bitspeed"], "audio_bound": ["video_range", "audio_limit", "video_bind", "audio_bind", "video_limit", "audio_range"], "video_bound": ["video_range", "video_bind", "audio_bind", "video___bound", "video___end", "video___bind", "video_end", "audio_end", "video___range", "audio_range"]}}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,\n\n                              int mm_flags)\n\n{\n\n    const int bit_depth      = avctx->bits_per_raw_sample;\n\n    const int high_bit_depth = bit_depth > 8;\n\n\n\n    c->prefetch = prefetch_mmx2;\n\n\n\n    if (!high_bit_depth) {\n\n        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;\n\n        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;\n\n        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;\n\n        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;\n\n\n\n        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;\n\n        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;\n\n        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;\n\n        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;\n\n    }\n\n\n\n    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {\n\n        if (!high_bit_depth) {\n\n            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;\n\n\n\n            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;\n\n            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;\n\n        }\n\n\n\n        if (CONFIG_VP3_DECODER && HAVE_YASM) {\n\n            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;\n\n            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;\n\n        }\n\n    }\n\n    if (CONFIG_VP3_DECODER && HAVE_YASM)\n\n        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;\n\n\n\n    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||\n\n                               avctx->codec_id == CODEC_ID_THEORA)) {\n\n        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;\n\n        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;\n\n    }\n\n\n\n    if (CONFIG_H264QPEL) {\n\n        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );\n\n\n\n        if (!high_bit_depth) {\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );\n\n        } else if (bit_depth == 10) {\n\n#if HAVE_YASM\n\n#if !ARCH_X86_64\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n#endif\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n#endif\n\n        }\n\n\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );\n\n    }\n\n\n\n#if HAVE_YASM\n\n    if (!high_bit_depth && CONFIG_H264CHROMA) {\n\n        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;\n\n    }\n\n    if (bit_depth == 10 && CONFIG_H264CHROMA) {\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;\n\n        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;\n\n    }\n\n\n\n    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;\n\n\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;\n\n\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;\n\n    } else {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext;\n\n    }\n\n#endif\n\n}\n", "idx": 17124, "substitutes": {"c": ["g", "cs", "cp", "self", "cm", "dc", "f", "coll", "pc", "uc", "ac", "bc", "nc", "u", "ci", "cur", "cache", "t", "conn", "x", "d", "n", "ch", "i", "config", "fc", "enc", "cl", "h", "co", "r", "con", "o", "ctx", "ec", "lc", "w", "ca", "cf", "oc", "ce", "conf", "p", "k", "cc", "s", "cy", "vc", "ic", "b", "cr", "tc", "cit", "ct", "rc", "mc", "e", "l", "ctrl", "C", "cu", "xc", "sc", "spec", "v"], "avctx": ["avscl", "afctx", "Avcontext", "abcontext", "abctx", "apcontext", "avcmp", "avcca", "avcontext", "avcb", "apcca", "Avcca", "apctx", "AVcca", "AVctx", "aphcontext", "avcp", "AVcontext", "AVcb", "apcb", "apcp", "airctx", "abcp", "afcp", "aircb", "Avctx", "abcmp", "aircontext", "Avscl", "aphscl", "aphcca", "aircca", "afcmp", "aphctx", "afcontext", "AVscl", "apcmp"], "mm_flags": [" pixel_data", "mm_settings", "mm_planes", "mm_data", " pixel_planes", " pixel_flags", " pixel_settings"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        vseq->seq_parameter_set_id = 0;\n\n\n\n        vseq->level_idc = avctx->level;\n\n\n\n        vseq->max_num_ref_frames = 2;\n\n\n\n        vseq->picture_width_in_mbs  = priv->mb_width;\n\n        vseq->picture_height_in_mbs = priv->mb_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1;\n\n        vseq->seq_fields.bits.frame_mbs_only_flag = 1;\n\n        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;\n\n        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;\n\n        vseq->seq_fields.bits.pic_order_cnt_type = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            vseq->frame_cropping_flag = 1;\n\n\n\n            vseq->frame_crop_left_offset   = 0;\n\n            vseq->frame_crop_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            vseq->frame_crop_top_offset    = 0;\n\n            vseq->frame_crop_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            vseq->frame_cropping_flag = 0;\n\n        }\n\n\n\n        vseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1;\n\n            // There is a large enum of these which we could support\n\n            // individually rather than using the generic X/Y form?\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                vseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                vseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                vseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                vseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n\n            avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||\n\n            avctx->colorspace      != AVCOL_SPC_UNSPECIFIED) {\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format             = 5; // Unspecified.\n\n            mseq->video_full_range_flag    = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            // These enums are derived from the standard and hence\n\n            // we can just use the values directly.\n\n            mseq->colour_primaries         = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coefficients      = avctx->colorspace;\n\n        }\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n\n\n        vseq->vui_fields.bits.timing_info_present_flag = 1;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->num_units_in_tick = avctx->framerate.num;\n\n            vseq->time_scale        = 2 * avctx->framerate.den;\n\n            mseq->fixed_frame_rate_flag = 1;\n\n        } else {\n\n            vseq->num_units_in_tick = avctx->time_base.num;\n\n            vseq->time_scale        = 2 * avctx->time_base.den;\n\n            mseq->fixed_frame_rate_flag = 0;\n\n        }\n\n\n\n        if (ctx->va_rc_mode == VA_RC_CBR) {\n\n            priv->send_timing_sei = 1;\n\n            mseq->nal_hrd_parameters_present_flag = 1;\n\n\n\n            mseq->cpb_cnt_minus1 = 0;\n\n\n\n            // Try to scale these to a sensible range so that the\n\n            // golomb encode of the value is not overlong.\n\n            mseq->bit_rate_scale =\n\n                av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4);\n\n            mseq->bit_rate_value_minus1[0] =\n\n                (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1;\n\n\n\n            mseq->cpb_size_scale =\n\n                av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4);\n\n            mseq->cpb_size_value_minus1[0] =\n\n                (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1;\n\n\n\n            // CBR mode isn't actually available here, despite naming.\n\n            mseq->cbr_flag[0] = 0;\n\n\n\n            mseq->initial_cpb_removal_delay_length_minus1 = 23;\n\n            mseq->cpb_removal_delay_length_minus1         = 23;\n\n            mseq->dpb_output_delay_length_minus1          = 7;\n\n            mseq->time_offset_length = 0;\n\n\n\n            // This calculation can easily overflow 32 bits.\n\n            mseq->initial_cpb_removal_delay = 90000 *\n\n                (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness /\n\n                priv->hrd_params.hrd.buffer_size;\n\n\n\n            mseq->initial_cpb_removal_delay_offset = 0;\n\n        } else {\n\n            priv->send_timing_sei = 0;\n\n            mseq->nal_hrd_parameters_present_flag = 0;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->CurrPic.picture_id = VA_INVALID_ID;\n\n        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {\n\n            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;\n\n            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;\n\n        }\n\n\n\n        vpic->coded_buf = VA_INVALID_ID;\n\n\n\n        vpic->pic_parameter_set_id = 0;\n\n        vpic->seq_parameter_set_id = 0;\n\n\n\n        vpic->num_ref_idx_l0_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_active_minus1 = 0;\n\n\n\n        vpic->pic_fields.bits.entropy_coding_mode_flag =\n\n            ((avctx->profile & 0xff) != 66);\n\n        vpic->pic_fields.bits.weighted_pred_flag = 0;\n\n        vpic->pic_fields.bits.weighted_bipred_idc = 0;\n\n        vpic->pic_fields.bits.transform_8x8_mode_flag =\n\n            ((avctx->profile & 0xff) >= 100);\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n    }\n\n\n\n    {\n\n        mseq->profile_idc = avctx->profile & 0xff;\n\n\n\n        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)\n\n            mseq->constraint_set1_flag = 1;\n\n        if (avctx->profile & FF_PROFILE_H264_INTRA)\n\n            mseq->constraint_set3_flag = 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17128, "substitutes": {"avctx": ["avectrl", "afctx", "avcm", "AVconfig", "Avcontext", "Avkb", "Avconn", "avconn", "varcmp", "abcontext", "vctx", "abctx", "avcmp", "varcm", "abkb", "avectx", " avcontext", "avcontext", "varctx", "afconn", "avctrl", "avconfig", "devkb", "vcm", "Avcu", "AVctx", "avecontext", "vcontext", "devctx", "abctrl", "varcontext", "AVcm", "avkb", "devcontext", "AVcontext", "AVcmp", "devconfig", "afctrl", "afcu", "avcu", "abconfig", " avkb", "AVcu", "Avctx", " avcu", "vcmp", "AVconn", "abconn", "aveconn", "afcontext", "AVkb"], "ctx": ["cca", "cs", "cp", "cdn", "cm", "client", "sys", "pc", "ck", "cli", "cmd", "uc", "bc", "instance", "nc", "ci", "conn", "sq", "common", "scope", "req", "exec", "conv", "hw", "cms", "lib", "config", "qa", "rx", "cas", "concept", "lc", "loc", "ca", "cf", "c", "fp", "cam", "cc", "cv", "sci", "vc", "tx", "cus", "pkg", "tc", "Context", "cfg", "context", "wcs", "cb", "fn", "rc", "mc", "cmp", "ctrl", "utils", "anc", "cu", "xc", "kb", "sc", "qs", "sync", "cn"], "vseq": ["vna", "wsequ", "revna", "voltsequ", "svsem", "lseq", "hsem", "vsem", "evsequ", "lzip", " vref", "nbuf", " vsequ", "lcomplete", "lvsequence", "msequ", "hseq", "Vmodel", "vfile", "revseq", "revscript", "tvseq", "revsequ", "nvsequence", " vframe", "versequence", " vsem", "Vvec", "nvvec", "varivec", "revparent", "vcomplete", "evframe", "Vstruct", "verseq", "lvec", "lref", "svsequ", "hgen", "Vseq", "Vclus", "fsem", " viq", "tvclus", "variclus", "revfile", "vzip", " vfeat", "nvseq", "variseq", "revvec", "Vbuf", "fsequ", "hsequ", "guvec", "lsequence", " vvec", "lclus", " vparent", "wseq", "evsequence", "vbuf", "fstruct", "fsequence", " vna", " vctx", "Vfile", " vcomplete", "fctx", "viq", "vparent", "lna", "sref", "psequence", "ssequ", "tvsequence", "vstruct", "liq", "ssequence", "vctx", "mgen", "mclus", "voltseq", "vframe", "svstruct", "guiq", "hclus", "voltsem", "vclus", " vsequence", "vsequence", "lvcomplete", "psequ", "fvec", "lvseq", "guseq", " vzip", "nsequence", "lparent", "vfeat", "nvfile", "lvsequ", "svseq", "pseq", "hsequence", "varimodel", "hscript", "evfeat", "revsequence", "Vsequence", "voltsequence", "vvec", "msequence", "gumodel", "fseq", "svsequence", "svbuf", "nseq", "vsequ", "vref", "vmodel", " vstruct", "versequ", "Vctx", "svclus", "wsem", "nstruct", "gusequence", "evseq", "Vfeat", "sseq", "evclus", " vgen", " vclus", "vgen", "pscript", "Vsequ", "lsequ", "vscript", "varisem", "wsequence", "tvzip", "Vframe", "mfeat", "vervec", "varisequence"], "vpic": ["vmac", "mctx", "mmac", "mpic", "vstruct", "svstruct", "svpic", " vctx", "svmac", "vctx", " vmac", "svctx", "mstruct", " vstruct"], "priv": ["cca", "cp", "txt", "client", "sys", "Priv", "proc", "uc", "riv", "cache", "ci", "access", "conn", "req", "obj", "ch", "util", "config", "aux", "auth", "pub", "private", "pb", "ocr", "ram", "data", "reader", "lc", "cci", "loc", "conf", "sk", "ca", "prem", "cam", "kw", "vc", "ki", "fac", "tx", "roc", "pkg", "auc", "cfg", "acc", "prof", "soc", "rc", "sec", "cb", "voc", "mc", "cmp", "gb", "utils", "anc", "pri", "rate"], "mseq": ["fmsequ", "msequ", "fmsel", "mmsequ", "mmseq", "vmsel", "msel", "vmsequence", "mmsequence", "vmseq", "fmseq", "msequence", "vmsequ", "fmsequence", "mmsel"], "i": ["batch", "f", "x", "qi", "ci", "li", "bi", "d", "n", "ip", "I", "pi", "si", "id", "ai", "index", "iu", "ii", "c", "k", "p", "ui", "count", "a", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "0d6ff71ae3c7ac3a446d295ef71884a05093b37c", "target": 0, "func": "void if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    bool from_batchq, next_from_batchq;\n\n    struct mbuf *ifm, *ifm_next, *ifqt;\n\n\n\n    DEBUG_CALL(\"if_start\");\n\n\n\n    if (slirp->if_start_busy) {\n\n        return;\n\n    }\n\n    slirp->if_start_busy = true;\n\n\n\n    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n        ifm_next = slirp->if_fastq.ifq_next;\n\n        next_from_batchq = false;\n\n    } else if (slirp->next_m != &slirp->if_batchq) {\n\n        /* Nothing on fastq, pick up from batchq via next_m */\n\n        ifm_next = slirp->next_m;\n\n        next_from_batchq = true;\n\n    } else {\n\n        ifm_next = NULL;\n\n    }\n\n\n\n    while (ifm_next) {\n\n        ifm = ifm_next;\n\n        from_batchq = next_from_batchq;\n\n\n\n        ifm_next = ifm->ifq_next;\n\n        if (ifm_next == &slirp->if_fastq) {\n\n            /* No more packets in fastq, switch to batchq */\n\n            ifm_next = slirp->next_m;\n\n            next_from_batchq = true;\n\n        }\n\n        if (ifm_next == &slirp->if_batchq) {\n\n            /* end of batchq */\n\n            ifm_next = NULL;\n\n        }\n\n\n\n        /* Try to send packet unless it already expired */\n\n        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {\n\n            /* Packet is delayed due to pending ARP resolution */\n\n            continue;\n\n        }\n\n\n\n        if (ifm == slirp->next_m) {\n\n            /* Set which packet to send on next iteration */\n\n            slirp->next_m = ifm->ifq_next;\n\n        }\n\n\n\n        /* Remove it from the queue */\n\n        ifqt = ifm->ifq_prev;\n\n        remque(ifm);\n\n\n\n        /* If there are more packets for this session, re-queue them */\n\n        if (ifm->ifs_next != ifm) {\n\n            struct mbuf *next = ifm->ifs_next;\n\n\n\n            insque(next, ifqt);\n\n            ifs_remque(ifm);\n\n\n\n            if (!from_batchq) {\n\n                /* Next packet in fastq is from the same session */\n\n                ifm_next = next;\n\n                next_from_batchq = false;\n\n            } else if (slirp->next_m == &slirp->if_batchq) {\n\n                /* Set next_m and ifm_next if the session packet is now the\n\n                 * only one on batchq */\n\n                slirp->next_m = ifm_next = next;\n\n            }\n\n        }\n\n\n\n        /* Update so_queued */\n\n        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {\n\n            /* If there's no more queued, reset nqueued */\n\n            ifm->ifq_so->so_nqueued = 0;\n\n        }\n\n\n\n        m_free(ifm);\n\n    }\n\n\n\n    slirp->if_start_busy = false;\n\n}\n", "idx": 17133, "substitutes": {"slirp": ["sliverpy", "slirdcp", "slirc", "blrisl", "slaripc", "sliren", "slrisn", "slrispc", "sliric", "selirf", "pullirpc", "blairc", "helirapo", "sliripe", "seliperpc", "sliripad", "skirdp", "sliperp", "slarenph", "sloirc", "slrispre", "slairapp", "slrisall", "slirapa", "slirib", "llirpress", "slurpc", "seloirp", "slairpc", "slir\n", "slirpatch", "slircp", "sliralper", "sliraping", "slmir\n", "Slmirn", "sliarpc", "slaril", "ellirp", "sliroper", " sliraf", "hellirp", "skircp", "slirml", "spliroc", "slpirper", "swurpe", "sloirpc", "swirr", "slirdpad", "sliripi", "delirper", "slrisl", "slurpi", "swurp", "sliripress", "skirpad", "slairc", "splirmp", "helirpc", "slirpy", "slurb", "slirtpad", "delirap", "helliralpi", "slarir", "slirtn", "ylirpc", "slirpc", "slearp", "deliraping", "deliraper", "slirpa", "pullirpi", "sloirp", "ellrispe", "sliralpi", "slirlper", "slirtr", "delirp", "ellirc", "helirp", "slwerpc", "slairpress", "slrisc", "sliripc", "slurp", "llairpress", "slairph", "delirapa", "sliropy", " slirping", "slwerpi", "slirtcp", "slirpad", "sliralph", "slirpress", "slyrpo", "slirph", "shirtr", "selirpc", "hellirpi", "slivern", "ylirpa", "skirb", "pullwerper", "slwerp", "swirpc", "helliralp", "Slirall", "slirlp", "llirper", "slirtp", "slyrpc", "slirmpatch", "sliverr", "ylearpa", "slirip", "helirapi", "splirmpc", "ylirp", "slirlpi", "slairpi", "slpirl", "slearpa", "sliperpatch", " slirap", "seloirpo", "pullirp", "slirpo", "sliralp", "slpirpre", "sliperf", "seliperf", "ellrisc", "swirpe", "slpirpe", "llirpc", "slirping", "skirdcp", "splirp", "skirp", "slpirpc", "Slir\n", "slirper", "sliperl", "slirall", "slirpi", "helliralapp", "selirc", "slarenapp", "selirpo", "slirmpc", "sliraf", "slirpe", "sliroc", "sliverpc", "helirapc", "slurpe", "ellirpre", "ellrispre", "slearpc", "slirpre", "slurc", "slarenpi", "slpirf", "shirp", "slpirpy", "slyrpa", "seliperc", "sliralpa", "spliropy", "blirpi", "seloirpc", "slpirp", "Slirn", "shirtp", "slirtpc", "ylearpi", "slirapy", "slurr", "slirdb", "splirc", "sliripy", "slirapc", "llairpc", "Slmir\n", " sliraping", "splirml", "shirtpc", "slyrpi", "slirapp", "slaripe", "llairper", "slarin", "slirtpatch", "helirpi", "sliripa", "slirf", "slirep", "slirapi", "splirl", "slmirall", "pullirper", "delirping", "slirap", "hellirapp", "slarip", "blirc", "sliarpress", "slirepe", "splirpc", "spliroper", "blirl", "llairp", "helirap", "blrispe", "ylearpc", "slirr", "slirer", "blairb", "sliricp", "pullwerpi", "slwerper", "slris\n", "slairp", "slmirn", "sliverp", "helliralph", "skirdb", "slirop", "slirepc", "splirper", "swurpc", "blirpc", "skirdpad", "splirmpatch", "slrisp", "selirp", "blrispc", "shirtn", "blirpe", "sliperc", "slpirpo", "sliralping", "ellrisp", "slirn", "slyrp", "slirl", "slrispe", "sliarp", "seliperp", "slyrper", "blrisp", "shirn", "slari\n", "blirp", "splirpy", "pullwerpc", "sliverf", "sliarper", "blairpi", " slirapy", "slirapo", "sliriper", "sliref", "sliroping", "splirop", "slirdp", "slarenp", "splirpatch", " slirpy", "seloirc", "sliripo", "slirb", "shirpc", "slearpo", "sliripre", "slirlpc", "llirp", "sliperpc", "slirtb", "sloirpo", "sliverping", "slairper", "ellirpe", "slairb", "blairp", "swurr", "slireb", "sliraper", "slearpi", "shirr", "swirp", "slpirc", "slirepi", "sliralapp", "delirpa", "slpirping", " slirf", "hellirph", "ylirpi", "slirmp", "slirec", "slirtl", "pullwerp", "Slmirall", "ylearp", "blirb", "sliropa", "slariall", "helirpo"], "from_batchq": ["from_batchquest", "from_fastQ", "from_batQ", "from_broadq", "from_queuequest", "from_broadquery", "from_banp", "from_broadr", "from_batchquery", "from_catchq", "from_fastq", "from_broadquest", "from_banq", "from_queuep", "from_batchp", "from_broadqu", "from_batchr", "from_broadp", "from_queuequery", "from_banquest", "from_catchQ", "from_catchqu", "from_batr", "from_broadQ", "from_batchqu", "from_fastr", "from_banquery", "from_fastqu", "from_queueq", "from_batq", "from_batchQ"], "next_from_batchq": ["next_from_broadqu", "next_from_batchqa", "next_from_batu", "next_from_batqu", "next_from_blockqu", "next_from_sessionp", "next_from_batchp", "next_from_bareq", "next_from_batchf", "next_from_fastg", "next_from_batchquery", "next_from_broadp", "next_from_broadw", "next_from_broadu", "next_from_groupqa", "next_from_batq", "next_from_workq", "next_from_broadqs", "next_from_bareqa", "next_from_batquery", "next_from_batf", "next_from_batchqs", "next_from_barequ", "next_from_fastp", "next_from_sessionqs", "next_from_broadquery", "next_from_combp", "next_from_fastw", "next_from_sessionu", "next_from_blockp", "next_from_workqa", "next_from_sessionquery", "next_from_combw", "next_from_groupg", "next_from_workqs", "next_from_batp", "next_from_sessionqa", "next_from_bareg", "next_from_batchw", "next_from_sessionqu", "next_from_sessionf", "next_from_fastq", "next_from_fastqu", "next_from_combq", "next_from_sessionq", "next_from_fastqa", "next_from_broadqa", "next_from_blockq", "next_from_batchg", "next_from_groupqu", "next_from_batchu", "next_from_broadq", "next_from_combqu", "next_from_broadf", "next_from_workp", "next_from_batchqu", "next_from_groupq"], "ifm": ["itert", "ilrm", "imn", "ifmt", "itf", "actm", " ifmi", "evf", "ift", "Ift", "IFdm", "IFh", " ifM", " ifmt", "ilm", "ifnm", "Ifnm", "ibmt", " ifmr", "ifmr", "ibm", " ifym", "itv", "actym", " iffm", "iterdm", "itrm", "ifp", "libp", "forn", "itp", "ipmi", "ofc", "ilr", "Ifz", "iterm", " ifp", "itermr", "ofm", "ifM", "expm", "ipM", "itnm", "evp", "iff", "ibmi", "itr", "IFv", "iterp", " ifrm", "fmt", "evmi", "elf", "iterfm", "ifh", "itc", "immr", "elh", "ilf", " ifz", "fdm", "ifz", "ifc", "ifr", "itermt", "evdm", "actp", "forz", "Ifmi", "fm", "IFm", "IfM", "libm", "iffm", "libdm", "ipm", "Ifm", "expp", "ipp", "elm", "fmi", "itM", "IFmi", "iterc", "itdm", "IFmt", "evm", "itm", "ifdm", "itn", "ifn", "imfm", "expmi", "ifv", "ith", "elv", " iff", "Ifn", "expM", "ofmt", "Ifdm", "form", " ifdm", " ifn", "ibdm", "forp", " ifnm", "IFp", "Ifp", "itern", "libM", " ift", "IFf", "ifrm", "evmt", "ifym", "itmt", "actM", "IFym", "IFM", "imm", " ifr", "ifmi", "ofdm"], "ifm_next": ["ifm_seen", "ifp_current", "ifcm_start", "ifcm__start", "ifcm__next", "ifsm_next", "ifcm_sen", "ifdm_prev", "ifdm_new", "ifcm_next", "ifm_conn", "ifm_post", "ifgm_last", "ifm_page", "ifm___next", "ifsm_parent", "ifm_new", "iffm_next", "ifgm_new", "ifm_current", "ifn_new", "ifm__current", "ifm__Next", "ifm_skip", "ifmacskip", "ifm_prev", "ifm__future", "ifp__current", "iffm_page", "ifm__start", "ifdm_future", "ifp_next", "ifcm__prev", "ifmacfuture", "ifgm_conn", "ifn_last", "iffm_seen", "ifdm_next", "ifm___adj", "ifp_prev", "ifp_future", "ifm_start", "ifm_sen", "ifn_Next", "ifsm_post", "ifp_close", "ifcm_prev", "ifgm_next", "ifm_close", "ifcm__new", "ifm__last", "ifn_next", "ifcm_current", "ifcm_future", "ifp_new", "ifm_adj", "ifm_future", "ifm_Next", "ifm___current", "ifm___prev", "ifm__prev", "ifcm_new", "ifm__close", "ifm__sen", "ifp__prev", "ifcm_adj", "ifm__next", "ifm_parent", "ifp_last", "ifmacprev", "ifmacnext", "ifcm_skip", "ifp__close", "ifsm_current", "ifm__new", "ifm_last", "ifp__next"], "ifqt": ["affqt", " ifquick", "ifqi", "Ifqi", "libquick", " ifqq", "libqq", "ifquick", "iftxt", "Ifqa", "Ifchid", "flytxt", "Ifqt", "fquick", "libqi", "fqt", "affchid", "afftxt", "ifqa", "ifchid", "fqa", "ifqq", "libqt", "flyqt", " ifqa", "flyqq", "Iftxt", "affqq", "fqq", "flychid", "libqa", "Ifqq", " ifqi"], "next": ["follow", "reply", "skip", "Next", "sequence", "client", "now", "later", "shift", "good", "style", "new", "frame", "first", "success", "page", "latest", "flow", "valid", "prev", "primary", "job", "version", "more", "again", "max", "code", "last", "full", "doc", "gov", "future", "missing", "current", "image", "dot", "step", "sec", "start", "then", "open", "foo", "second"]}}
{"project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "target": 0, "func": "static void handle_ti(ESPState *s)\n\n{\n\n    uint32_t dmalen, minlen;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_ti;\n\n        return;\n\n    }\n\n\n\n    dmalen = s->rregs[ESP_TCLO];\n\n    dmalen |= s->rregs[ESP_TCMID] << 8;\n\n    dmalen |= s->rregs[ESP_TCHI] << 16;\n\n    if (dmalen==0) {\n\n      dmalen=0x10000;\n\n    }\n\n    s->dma_counter = dmalen;\n\n\n\n    if (s->do_cmd)\n\n        minlen = (dmalen < 32) ? dmalen : 32;\n\n    else if (s->ti_size < 0)\n\n        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;\n\n    else\n\n        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;\n\n    trace_esp_handle_ti(minlen);\n\n    if (s->dma) {\n\n        s->dma_left = minlen;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        esp_do_dma(s);\n\n    }\n\n    if (s->do_cmd) {\n\n        trace_esp_handle_ti_cmd(s->cmdlen);\n\n        s->ti_size = 0;\n\n        s->cmdlen = 0;\n\n        s->do_cmd = 0;\n\n        do_cmd(s, s->cmdbuf);\n\n    }\n\n}\n", "idx": 17141, "substitutes": {"s": ["g", "self", "sites", "lines", "ms", "session", "bs", "secondary", "uns", "js", "h", "r", "gs", "conf", "c", "ssl", "b", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "server", "http", "u", "in", "ns", "ans", "site", "si", "args", "i", "state", "full", "es", "us", "params", "p", "sb", "ts", "y", "services", "sv", "l", "sym", "serv", "se", "its", "sync", "f", "ops", "sports", "rs", "ss", "sq", "n", "o", "xs", "S", "sg", "ses", "spec", "rates", "is", "changes", "cs", "ims", "sys", "aws", "ps", "new", "t", "d", "status", "ls", "stat", "side", "service", "uses", "e", "os", "ds", "v", "settings"], "dmalen": ["odmalening", "Dmaleng", "dmaceni", "dmaclen", "dphalene", "davalened", "dmilan", " davalened", "admalen", "dmilens", "dstalening", "ddatalener", "ddataleen", "dgalens", "dmafen", "dmlened", " dgalena", "dpalen", "dmilena", "dnamener", "dallen", "cstallen", "cmallen", "dmlener", "dmaen", " dnamzen", "Dmilens", "dbalens", "datalens", "dphalzen", "Dmilan", "cmalfen", "dgaleen", "ldalens", "davalen", "admadene", "ddmalener", "admaden", "dmacened", "dmalien", "dmalener", " davalpen", "Dmileng", "dmasener", " dmalener", "dstalened", "odmallen", "Dmilen", "admalene", "dmcen", "ddmalens", " dmalena", "dbilien", "admadzen", "dmalfen", "Dmalens", "dstalens", "datalener", "cstalen", " dmalens", "dmacening", "dbalened", "datalen", "dgalener", "dmlenn", "dbroaden", "dmaeno", "dgalena", "dglener", "dstalen", "dbaleng", "dmlan", "dmalan", "dmacens", "dmllen", "ldaleni", "admadener", "dmileng", "dalened", "dbilened", "dmalender", " dmaleno", "dmaener", " dgleno", " dmalfen", "dgalpen", "odmalened", "dpalzen", "dalleng", "dpalener", "dbroadender", "cmalen", "Dmalener", "dmalening", "dmclen", "ddmalen", "dgalen", " davalen", "dmallen", "dalens", "dmileni", "dmaleng", " dglener", "dmaens", "ldmalened", "davalpen", "dstallen", "odmlened", "dmaleen", "dmlening", " dglen", "dmalzen", "dmasen", "dstalener", "Dmilien", "dnamzen", "dmileno", "dmadene", "admalzen", "dallens", "dmadzen", "dgalened", "dbalien", "dmaleno", " dgalening", "dpalene", " dgalened", "dmlfen", "admalener", "dglen", "dmcened", "ddatalen", " dmalenn", "dphalen", "dgalien", "Dmilener", "dallien", "dgalening", "dnamen", "cstalfen", "dbilzen", "dmalpen", "dmalenn", "odmalen", "ldmaleni", "dnamender", "dglens", "dmilened", "dphalener", "dbroadener", " dnamender", "dmasens", "ldalened", "odmlening", "dmalened", "dstalena", "dmilen", "dbilener", "odmlen", "davalener", "dbroadzen", "ldalen", "dbalen", "dalen", "ddatalens", "ldmalens", "dgleno", "dmacen", "davalenn", " dgalien", " dnamener", "Dmalen", "dmalena", "dmasan", "daleni", "dbilender", "dmileen", "davalfen", "dmilener", "dmalene", "dmadener", "dmilien", "dmlen", "dbilen", " dmalened", " dmalien", " dmalender", "ldmalen", "cstalened", "dmaden", " dnamen", "Dmalan", "ddmaleen", "dmlens", " dgalener", "dmaenn", " dmalening", " dgalens", "dstalfen", " dmalzen", "dmcfen", " dgalen", " davalener", "dmaleni", " davalfen", "dstalien", "dbalener", "dmalens", "odmllen", " dmalpen", "Dmalien", " davalenn", " dglens", "dataleen", "dbalpen", "cmalened", "dmilening"], "minlen": ["aminrel", "aminlen", "olden", " minrel", "smallen", "MINlen", "Minval", "minen", "MINval", "Minrel", "minval", "minLen", "smallval", "Minlon", "minlon", " minen", "unen", "minlin", "unln", "oldlin", "Minen", " minpos", "miniLen", "Minln", "minipos", " minLen", " minval", "Minlin", "MinLen", "minilon", "Minpos", "minpos", "minien", " minlon", "minilin", "MINLen", "smalllen", "minln", "Minlen", "unlen", "oldlen", "aminen", " minlin", "minilen", "unlin", "minrel", "oldln"]}}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n", "idx": 17152, "substitutes": {}}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n", "idx": 17172, "substitutes": {"scon": ["nsct", "ccon", "cscon", "sinocon", " sconf", " sbc", "lsco", "ssuc", "nsbc", " sct", " sco", "Sbn", "sbn", "sbc", "csconf", " scn", "cCON", "vesocon", "sco", "sincn", "Sco", "Sun", "vesco", "sincon", "ssCON", "sconf", "sct", "sinconference", "wscon", "vescc", "lsuc", "socon", "crc", "Src", "rsocon", "csct", "cscan", " sconference", " sCON", "Scan", "lscon", "sCON", "sscon", "csocon", "sun", "csbc", "scan", "vescon", "sca", "src", "Sconf", "suc", "Scon", "tsca", "Sct", "tsun", "wsco", "Sbc", "sban", "ssco", "rsct", "nsocon", " socon", " src", "lsban", "cca", "scc", " scc", " sca", "scn", " sban", " sbn", "tsbc", "SCON", "tscon", "wscc", " sun", "rscon", "rsbc", "nscon", " scan", "Sca", "sconference", "ssban", " suc", "wsocon", "ssbn"], "buf": ["batch", "vec", "src", "uf", "cmd", "queue", "bc", "conn", "buffer", "pool", "feed", "conv", "fd", "config", "ff", "pb", "img", "data", "cas", "ctx", "fl", "rb", "ref", "fp", "bag", "cv", "func", "b", "fb", "context", "cb", "rc", "fi", "seq", "mem", "port", "buff", "alloc"], "size": ["g", "core", "scale", "length", "number", "large", "name", "x", "cache", "sized", "source", "grade", "form", "end", "fee", "Size", "n", "len", "message", "si", "SIZE", "small", "enc", "i", "ize", "capacity", "storage", "address", "code", "max", "speed", "eng", "sum", "grow", "loc", "c", "ce", "sync", "p", "unit", "content", "needed", "z", "esc", "done", "en", "send", "gz", "count", "e", "model", "password", "empty", "iz", "offset"]}}
{"project": "qemu", "commit_id": "d3aea641a4002e0abe940c65d318ef38eda245df", "target": 1, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}", "idx": 17199, "substitutes": {"opaque": ["ocga", "Opec", "OPaque", "Opaya", "opcontainer", "opec", "ocaque", "OPcontainer", "OPec", " opga", "opusga", "opedec", "opga", "opedaya", "opuswebkit", " opwebkit", "OPaya", "opedaque", "Opaque", "opaya", "opusaque", "opedcontainer", "opwebkit", "ocwebkit", "Opcontainer"], "dev": ["self", "cd", "di", "debug", "DEV", "prom", "grad", "ow", "dc", "proc", "cmd", "mod", "link", "conn", "ad", "api", "pad", "plug", "error", "req", "off", "reg", "d", "obj", "ch", "hw", "boot", "enc", "av", "od", "user", "pub", "h", "google", "img", "dom", "diff", "data", "Dev", "pack", "mount", "w", "mac", "conf", "app", "p", "var", "cam", "de", "gu", "def", "prov", "comment", "dem", "ve", "priv", "home", "prop", "ev", "die", "mem", "cmp", "port", "bug", "driver", "device", "rad", "serv", "md", "v", "adv", "ver", "info"]}}
{"project": "FFmpeg", "commit_id": "e62ef8f2dbf1ac0a197310f2be69c93b89f838c2", "target": 0, "func": "static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)\n\n{\n\n    int ch, bw_code;\n\n\n\n    if (cutoff) {\n\n        /* calculate bandwidth based on user-specified cutoff frequency */\n\n        int fbw_coeffs;\n\n        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);\n\n        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;\n\n        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);\n\n    } else {\n\n        /* use default bandwidth setting */\n\n        /* XXX: should compute the bandwidth according to the frame\n\n           size, so that we avoid annoying high frequency artifacts */\n\n        bw_code = 50;\n\n    }\n\n\n\n    /* set number of coefficients for each channel */\n\n    for (ch = 0; ch < s->fbw_channels; ch++) {\n\n        s->bandwidth_code[ch] = bw_code;\n\n        s->nb_coefs[ch]       = bw_code * 3 + 73;\n\n    }\n\n    if (s->lfe_on)\n\n        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */\n\n}\n", "idx": 17203, "substitutes": {"s": ["is", "g", "cs", "self", "sites", "sf", "f", "sys", "ps", "u", "rs", "js", "south", "t", "ss", "sq", "parts", "d", "ns", "ans", "n", "site", "si", "i", "h", "ls", "o", "es", "ctx", "us", "w", "an", "gs", "conf", "side", "c", "p", "sb", "ts", "service", "comments", "b", "ssl", "xs", "su", "fs", "services", "S", "states", "sg", "ses", "e", "sv", "os", "hs", "l", "a", "sets", "sym", "spec", "features", "ins", "settings", "ds", "qs", "v", "its", "sync", "m"], "cutoff": [" cutback", "ruboff", "ruboffs", "contractoff", "cutoffs", "caseoff", "Cutoffs", "cropoff", "Cutoffset", "contractoffset", "cutcut", "fallup", "crophalf", "catoffset", "contractoffs", "fallcut", " cutOFF", "Cutdown", "catright", "cutup", "cuthalf", "rubback", " cutOff", "cropback", "caseoffs", "rubOff", "catoff", "cutback", " cutup", "falloff", " cutdown", "catchoff", "rubdown", "Cutright", "caseOFF", " cuthalf", "cutright", "catchup", " cutoffs", "cutOff", "cutdown", "rubhalf", "cutoffset", "catchcut", "catoffs", "cutOFF", "CutOFF", "contractright", " cutcut", "cropOff", "Cutoff"], "ch": ["core", "cp", "chip", "coll", "client", "f", "cat", "zh", "chan", "work", "cel", "cur", "chat", "bh", "q", "cha", "conn", "cher", "el", "ech", "chu", "cor", "base", "col", "chart", "i", "th", "cl", "h", "code", "sch", "cry", "che", "oy", "chi", "change", "mot", "ctx", "Ch", "hop", "CH", " chunk", "cf", "chn", "c", "k", "sk", "p", "channel", "app", "ach", "game", "b", "arch", "chid", "cho", "cht", "count", "rc", "ph", "och", "ich", "v", "pr", "ver"], "bw_code": ["bwd_code", "bwh_code", "bwhscode", "bw_codes", "bww_code", "bwhscoded", "bw_Code", "bw2codes", "bw64code", "bwscodes", "bwprecodes", "bw2code", "bwa_loc", "bwscoded", "bwh_codes", "bw_loc", "bww_codes", "bw_cod", "bwd_one", "bwhscodes", "bw_count", "bw64length", "bwh_coded", "bwd_cod", "bw_coded", "bwpreloc", "bw2length", "bww64length", "bw_rate", "bww_length", "bwa_code", "bw_length", "bw2rate", "bwa_rate", "bwscode", "bww_rate", "bw64codes", "bwa_count", "bwa_codes", "bww64rate", "bww64codes", "bw_one", "bwprecode", "bwprecall", "bww64code", "bw64rate", "bwa_Code", "bw_call", "bwa_call"], "fbw_coeffs": ["fbw_coEFFi", "fbw_coffs", "fbw_coefficientss", "fbw_coffits", "fbw_coefn", "fbw_coeffn", "fbw_coEFFes", "fbw_coefficientsp", "fbw_coefes", "fbw_coffp", "fbw_coefficients", "fbw_coeffits", "fbw_coefficientsi", "fbw_coefficientsits", "fbw_coeffp", "fbw_coefits", "fbw_coEFFits", "fbw_coefficientits", "fbw_coEFFs", "fbw_coefs", "fbw_coffi", "fbw_coeffi", "fbw_coefficientsn", "fbw_coffes", "fbw_coefp", "fbw_coefficientn", "fbw_coefi", "fbw_coefficienti", "fbw_coeffes"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"movq \"MANGLE(bm01010101)\", %%mm4           \\n\\t\"\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",4), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",4), %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"movq                %%mm0, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"pand                %%mm4, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm0, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm1           \\n\\t\"\n\n        \"movd                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movd                %%mm1, (%2, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $4, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[4*i + 1];\n\n        dstV[i]= src1[4*i + 3];\n\n    }\n\n#endif\n\n    assert(src1 == src2);\n\n}\n", "idx": 17206, "substitutes": {"dstU": ["dstUV", "sstU", "drcCU", "DSTUR", "dblUV", "dstCU", "DSTI", "ddestCU", "dsrcG", "DstM", "dstsI", "dspCU", "sstI", "dsrcUR", "dstG", "dspI", "drcI", "drcU", "DstG", "srcI", "srcU", "dSTM", "dstM", "dSTUV", "ddestI", "dstsUR", "DSTUV", "dsrcUV", "drcP", "dSTI", "DSTM", "ddestU", "dstUR", "dstsO", "dstP", "DstUR", "DstUV", "dsrcM", "dspU", "dsrcI", "DSTG", "dstI", "DstI", "dSTO", "dSTU", "DstU", "dsrcO", "dSTG", "sstCU", "srcCU", "dstsU", "dSTUR", "DSTO", "sstP", "dblU", "dblG", "dblM", "DSTU", "DstO", "dsrcU", "ddestP", "srcP", "dspP", "dstO"], "dstV": ["dconstP", "DSTI", "dsrcP", " destU", "dstsI", "dconstV", "dconstU", " dSTV", "DstV", "dstsV", " dstI", "DstP", "destNV", " destR", "dstsP", "dstNV", "dSTI", " dSTI", "dstP", "dSTP", "dblV", " dstNV", " destNV", "dsrcI", "dostU", "dstI", "dstsNV", "dostI", "DstI", " dSTP", "dblNV", "dSTU", "dblR", "DstU", "dsrcV", "dstsU", " destV", "DSTP", " dstR", "dstsR", "dblU", "dconstI", "dSTV", "DSTV", "DSTU", "dostV", "destR", "destU", "dsrcU", " dstP", "destV", "dstR", "dostP", " dSTU"], "src1": ["rcOne", "sur1", "rcone", "config1", "dist2", "rc1", "src01", "source2", "sur3", "host1", "configone", "rc2", "rc3", "host2", " srcN", "sur01", "srcN", "dist1", "srcOne", "source1", "config2", " src01", "sur2", " src3", "hostN", " srcOne", "source3", "distone", "rcN", "rc01", "src3", "sourceOne", "srcone"], "src2": ["source4", "src02", "rc1", " src02", "rc0", " src4", "source2", "srcTwo", " src0", "rc2", "rc4", "source1", "src0", " srcTwo", "rcTwo", "sourceTwo", "src4", "rc02", "source0", "source02"], "unused": ["untused", "untaligned", "unchecked", "untchecked", "Uninitialized", "Unaligned", "unaused", "Unchecked", "unachecked", "Unused", "unainitialized", "unaaligned", "uninitialized", "untinitialized", "unaligned"], "i": ["phi", "di", "uli", "ri", "xi", "hi", "qi", "u", "x", "ix", "ci", "li", "abi", "ji", "bi", "mu", "uri", "it", "eni", "info", "n", "ip", "col", "I", "si", "pi", "multi", "id", "vi", "h", "index", "ai", "diff", "block", "lc", "ii", "k", "c", "var", "p", "s", "ind", "b", "z", "slice", "mini", "ui", "gi", "zi", "count", "fi", "e", "l", "io", "oi", "ini", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n", "idx": 17240, "substitutes": {"machine": ["server", "interface", "M", "database", "node", "cache", "motion", "parent", "link", "instance", "net", "connection", "base", "controller", "agent", "state", "computer", "Machine", "data", "monitor", "mount", "engine", "mac", "loader", "service", "process", "m", "image", "vm", "mc", "model", "port", "device", "manager", "mobile", "mode"]}}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,\n\n                               unsigned int len)\n\n{\n\n    unsigned int offset;\n\n    int i;\n\n\n\n    offset = 0;\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n\n                                  elem->in_sg[i].iov_len,\n\n                                  1, size);\n\n\n\n        offset += size;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++)\n\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n\n                                  elem->out_sg[i].iov_len,\n\n                                  0, elem->out_sg[i].iov_len);\n\n}\n", "idx": 17242, "substitutes": {"vq": [" vqt", "vque", "ug", "pque", "uq", "pq", " vque", "vg", "pg", " vg", "uqt", "pqt", "vqt", "uque"], "elem": ["pelements", "Eject", "jelems", " ehem", "felem", "enlem", "eel", "eele", "aelev", "elegate", "oelem", "pelem", "nehem", "elems", "notehem", "eelev", "elect", "teel", "playlems", "melem", " elegate", "peject", "iehem", "eezer", "nelement", "fehem", "playles", "aeler", "playlegate", "oeler", "evalhem", "edeolean", " ezer", "enlement", "eelement", "nelem", "eler", "aehem", "elev", "elements", "ehem", "neler", "ielem", " eles", "aeject", "nelev", "element", " elems", "ielev", "oehem", "melete", " elements", "fembol", "eolean", "noteolean", "edelem", "meolean", "eelem", "oelev", "englems", "aelements", "eelements", "eject", "edelete", "oelements", "evallect", "notelem", "telem", "evallems", "enject", "Elem", "oezer", "aelem", "zeles", "notelete", "aelement", "ielement", "englem", "jelect", "enghem", "ele", "ezer", "evallem", "tembol", "jehem", "elete", "zelem", "playlem", "eles", "zelems", "Ele", "eeject", "embol", "englect", "tehem", "pelement", "edehem", "mehem", "feel", "zelegate", "enle", "jelem", "ieel", "iembol", "Element", "eehem"], "len": ["lim", "val", "min", "length", "lan", "split", "ll", "lt", "name", "Len", "li", "el", "lf", "n", "base", "lib", "lon", "lu", "ls", "lc", "fl", "loc", "limit", "pos", "le", "en", "lock", "count", "fn", "seq", " length", "l", "mem", "list", "lin", "ln", "elt"], "offset": ["set", "shift", "f", "length", "number", "enabled", "extra", "type", "prefix", "parent", "axis", "off", "uri", "base", "position", "location", "reset", "uni", "online", "fit", "address", "index", "padding", "entry", "addr", "o", "Offset", "next", "align", "loc", "p", "fp", "pos", "limit", "delay", "pointer", "slice", "ui", "count", "zero", "area", "e", "start", "l", "adjust", "alias", "origin", "size"], "i": ["reply", "phi", "di", "inner", "ri", "hi", "xi", "x", "ix", "qi", "ci", "eni", "I", "h", "c", "b", "gi", "a", "oi", "ini", "mi", "m", "cli", "name", "u", "source", " ii", "in", "load", "uri", "it", "si", "multi", "index", "ai", "iu", "data", "p", "key", "y", "ui", "fi", "yi", "l", "io", "ti", "j", "f", "isin", "n", "base", "ip", "module", "id", "iv", "o", "lc", "ii", "ni", "zi", "info", "is", "resource", "result", "type", "li", "bi", "mu", "d", "pi", "e", "ori", "start", "ie", "v"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n", "idx": 17246, "substitutes": {"state": ["local", "is", "core", "self", "the", "str", "resource", "set", "rule", "f", "session", "style", "new", "cache", "parent", "sh", "t", "conn", "q", "STATE", "scope", "ss", "or", "State", "config", "parse", "address", "private", "code", "r", "data", "o", "ace", "pse", "st", "stat", "body", "c", "k", "sync", "p", "key", "store", "pe", "er", "slice", "err", "states", "element", "seed", "start", "os", "port", "a", "out", "se", "manager", "v", "j", "settings"], "queue": ["server", "progress", "sequence", "f", "route", "command", "Q", "cache", "pipe", "buf", "prefix", "array", "proxy", "q", "buffer", "pool", "message", "job", "Queue", "lib", "config", "status", "r", "block", "ue", "next", "callback", "c", "file", "Que", "line", "fp", "p", "menu", "group", "seq", "collection", "port", "list", "que", "ack", "event", "manager", "v", "sync"], "errp": ["errpc", "errps", " errps", " err", "errP", " errr", "rarp", "rrcp", "rrP", "erpc", "errcp", " ertp", " errtp", "erp", "rarps", "rarcp", "ertp", "errtp", "rrp", "rrps", "err", " errpc", " errP", " errcp", "errr", "rarP", " erpc", " erp"], "s": ["is", "g", "cs", "server", "sys", "session", "bs", "f", "ps", "u", "rs", "js", "ss", "sq", "d", "ns", "site", "si", "status", "ls", "es", "o", "us", "als", "gs", "c", "p", "sb", "ts", "service", "ssl", "b", "sl", "xs", "su", "fs", "services", "stats", "S", "m", "as", "states", "ges", "ares", "sg", "ses", "os", "l", "ins", "spec", "se", "ds", "qs", "its", "settings"], "i": ["g", "phi", "di", "f", "ri", "xi", "hi", "x", "u", "qi", "ci", "li", "abi", "t", "eni", "bi", "ji", "mu", "uri", "d", "wei", "info", "n", "I", "pi", "si", "multi", "id", "ai", "index", "r", "iu", "o", "esi", "ii", "c", "p", "y", "ind", "b", "err", "ui", "ni", "zi", "gi", "yi", "fi", "adi", "l", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "m"], "e": ["g", "ele", "ine", "eu", "f", "je", "me", "oe", "el", "end", "d", "ge", "n", "entity", "E", "ae", "es", "em", "o", "ue", "ee", "ec", "ze", "pse", "eb", "esi", "ea", "ce", "c", "p", "line", "pe", "ep", "be", "ade", "er", "ei", "edge", "en", "ne", "element", "ed", "ev", "l", "fe", "ie", "se", "m"]}}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n", "idx": 17258, "substitutes": {"s": ["g", "is", "cs", "self", "sf", "lines", "f", "sys", "session", "src", "ops", "ps", "x", "u", "rs", "js", "in", "t", "ss", "sq", "south", "scope", "d", "ns", "n", "site", "si", "i", "private", "r", "space", "es", "o", "us", "gs", "c", "details", "p", "sb", "ts", "service", "ks", "ssl", "b", "sl", "xs", "su", "fs", "services", "S", "as", "sets", "ses", "sg", "e", "sv", "sym", "settings", "a", "os", "spec", "se", "ds", "sync", "m"], "label_index": ["displayIdlength", "label_ind", "label__Index", "labelingnumber", " label_Index", "labellenstart", "labelIdlocation", "labellenIndex", "labelingind", "labelIdind", "abel_start", "display_ind", "label__pos", "label__number", "display_index", "label_start", "displayIdlocation", "label__index", "labelingIndex", "labelinglength", "labelingindex", "labelIdlength", "label_number", "label_location", "abel_Index", "display_location", " label_number", "display_length", "labelingpos", "labellenindex", "label_Index", "labelIdindex", " label_pos", "label_pos", "labelinglocation", "label_length", "displayIdind", "displayIdindex", "abel_index"], "l": ["g", "bl", "ll", "u", "ol", "lp", "li", "lo", "el", "L", "n", "kl", "jl", "i", "lu", "pl", "il", "ls", "o", "dl", "lc", "nl", "fl", "loc", "p", "al", "rl", "b", "sl", "ell", "le", "sel", "la", "e", "lb", "v", "ln"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n", "idx": 17266, "substitutes": {"pci_dev": ["pci_grad", "pdi_device", "pci_ev", "pdi_grad", "pci_device", "pcli_device", "pcli_dev", "pdi_dev", "pcli_ev"], "region_num": ["region__sym", " region_id", "region_id", "region4NUM", "region4name", "region__NUM", " region_NUM", "region__id", " region_sym", "region4num", " region_number", "region_number", "region__num", " region_name", "region_NUM", "region__number", "region4id", "region_sym", "region_name", "region__name"], "addr": ["g", "class", "dc", "grad", "node", "x", "xp", "ar", "code", "r", "byte", "ost", "attr", "shape", "amd", "rt", "layer", "oa", "mode", "dr", "server", "map", "acl", "butt", "name", "work", "nc", "pad", "req", "add", "coord", "nn", "od", "index", "data", "kt", "mac", "wd", "p", "pkg", "url", "l", "port", "alias", "host", "offset", "flags", "src", "route", "cmd", "ad", "error", "base", "ip", "config", "id", "address", "ord", "ace", "cap", "channel", "pos", "region", "en", "rc", "rr", "prefix", "asm", "conn", "el", "len", "mt", "adr", "hop", "align", "loc", "ext", "bridge", "ld", "nr", "Address", "ptr", "slice", "adder", "seq", "e", "cmp", "ast", "device", "amp"], "size": ["g", "scale", "length", "mode", "large", "extra", "name", "Size", "len", "args", "small", "enc", "ize", "capacity", "address", "max", "cap", "loc", "c", "pos", "unit", "bytes", "sec", "offset"], "type": ["val", "class", "ty", "length", "name", "style", "Type", "t", "buffer", "info", "config", "types", "state", "address", "block", "typ", "ype", "format", "ref", "p", "unit", "pe", "weight", "TYPE", "shape", "port", " typ", "offset"], "d": ["dr", "g", "cd", "di", "dh", "bd", "dc", "D", "f", "pd", "x", "u", "dd", "t", "dim", "ad", "dm", "dos", "n", "fd", "sd", "gd", "i", "id", "dis", "dj", "db", "dt", "h", "r", "dict", "dom", "data", "diff", "o", "dl", "w", "dy", "ded", "dB", "c", "k", "p", "de", "ld", "da", "y", "dad", "b", "z", "done", "e", "dp", "dat", "l", "day", "dn", "v", "did", "ds", "md", "j", "m"], "s": ["g", "is", "self", "server", "f", "session", "sa", "sys", "this", "u", "rs", "js", "t", "ss", "sq", "ns", "n", "si", "i", "state", "h", "r", "o", "w", "gs", "c", "p", "sb", "service", "b", "ssl", "sl", "z", "services", "stats", "S", "states", "sg", "e", "ses", "sv", "l", "os", "spec", "ds", "v", "sync", "m"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 17267, "substitutes": {"dev": ["trans", "proc", "mod", "dd", "ad", "reg", "tr", "ch", "gd", "enc", "od", "pub", "private", "der", "pack", "Dev", "conf", "gr", "de", "def", "ev", "pro", "device", "serv", "debug", "ver"], "vmsd": ["vmsdd", "vMSdd", "vmesd", " vnsd", "lmsds", "vnsdd", "vMSds", "vmmd", "vmmdy", "vimsdy", "vmesdd", "vMSdy", "vMSd", " vimsdl", "lmsd", "vnsD", " vmsdd", "vmesdx", "vmsdy", "vMSdt", "vimsd", "vmsdx", "vmmdl", "vmesdt", "vmsD", "lmsdn", " vnsD", " vmsD", "vmesdn", "lmesds", "vcsd", "vcsds", "vmesds", "lmesdn", "vimsde", "vmsdl", "lmesd", " vnsdd", "vmmde", "vimsdl", "vMSdl", "vMSdn", "vMSde", " vimsde", " vmsdt", "lmsdx", "lmesdx", "vmsdn", "vmsds", " vmsdy", "vnsd", " vmsdl", " vnsdt", "vcsdn", " vimsd", "vnsdt", "vmesD", "vMSD", " vmsde", "vMSdx", "vcsdx", "vmsde", "vmsdt", " vimsdy"], "opaque": ["copula", "oppac", "copacity", "compacity", "oppacity", "opaques", "compaques", "compaque", "operacity", "operac", " opac", " opity", "operity", "opity", "oppaque", "opacity", "ompacity", "copaque", "efficit", "ompula", "oppity", "ompac", " opacity", "opicit", "operula", "copac", "opericit", "opula", "ompaque", "effaque", "effacity", "operaques", "effaques", "operaque", "compicit", "opac"], "se": ["session", "sa", "sp", "sche", "Se", "cel", "sem", "te", "ge", "SE", "si", "sd", "sed", "parse", "isse", "entry", "ae", "pse", "es", "ace", "sle", "ze", "ste", "see", "sk", "ce", "lex", "de", "s", "ke", "pe", "sl", "sea", "be", "su", "ade", "ve", "per", "le", "so", "sel", "cle", "as", "ne", "ede", "sec", "seed", "ses", "e", "ie", "ser", "ase", "use"], "new_se": [" new_parse", "newfentry", "newfse", "new_parse", "new_SE", " new_entry", "newfSE", "new_entry", " new_sem", " new_SE", "newfparse", "new_sem"]}}
{"project": "qemu", "commit_id": "47d3df2387ed6927732584ffa4159c26d9f4dee8", "target": 0, "func": "static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n", "idx": 17274, "substitutes": {"xenfb": [" xeenfe", " xenfe", "xeenbridge", "exenfe", "xeenbf", "xennf", "xenbf", "exeenfb", "xeenfab", "exeenfe", "xeenf", "xenerbf", " xenfab", " xeenfb", "xenef", "xeenfb", "exeenf", "xennfb", "xennbridge", "exenf", "xennfe", "xenbridge", "xenf", "xennfab", " xeenfab", " xenbf", "xenfab", "exenbridge", "xeenfe", "exenfb", "xenerfb", "xenerfab", " xeenbf", "xenefb", "xennbf", "exeenbridge", "xenfe", "xenefe", "xenerfe", "xenebridge"], "rel_x": [" rel_point", " rel_xy", "relqcolor", " rel_color", "relPy", "relSxy", "rel_color", "rel_xy", "relSpoint", "relqmin", "relqx", "relqy", "relPz", "relSx", " rel_min", " rel_lat", "rel_min", "relPx", "relPlat", "relSy", "rel_lat", "rel_point"], "rel_y": ["rel2y", "ref_z", "rel2z", " rel_yo", "rel_Y", "rel2Y", "relvely", "ref_x", "relvelz", " rel_r", "relvelr", "rel_r", "relvelx", "ref_y", "ref_Y", "rel_yo", "rel2x"], "rel_z": ["rel_tz", "rel_zen", "rel64y", "rel_window", "relNwindow", "relFy", "rel64tz", " rel_tz", "relNy", "rel_style", "rel64zone", "relFwindow", "rel_zone", "relFzen", " rel_window", " rel_zen", "rel64z", "relNzen", " rel_style", " rel_zone", "relNz", "relFz"], "event": ["wave", "container", "class", "resource", "session", "result", "this", "command", "type", "instance", "name", "source", " Event", "xml", "node", "document", "window", "new", "end", "parent", "error", "date", "global", "test", "connection", "condition", "view", "message", "record", "press", "config", "show", "address", "input", "data", "ee", "ec", "script", "ce", "character", "object", "game", "move", " events", "function", "content", "ent", "advert", "update", "comment", "package", "image", "send", "context", "element", "Event", "ev", "request", "e", "shape", "effect", "text", "other", "bug", "style", "empty", "events", " EVENT", "method", "vent", "feature"]}}
{"project": "FFmpeg", "commit_id": "435535e41159fbe7423a12078d684329a554776d", "target": 1, "func": "static int read_header(AVFormatContext *s,\n\n                       AVFormatParameters *ap)\n\n{\n\n    JVDemuxContext *jv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *vst, *ast;\n\n    int64_t audio_pts = 0;\n\n    int64_t offset;\n\n    int i;\n\n\n\n    avio_skip(pb, 80);\n\n\n\n    ast = av_new_stream(s, 0);\n\n    vst = av_new_stream(s, 1);\n\n    if (!ast || !vst)\n\n        return AVERROR(ENOMEM);\n\n\n\n    vst->codec->codec_type  = CODEC_TYPE_VIDEO;\n\n    vst->codec->codec_id    = CODEC_ID_JV;\n\n    vst->codec->codec_tag   = 0; /* no fourcc */\n\n    vst->codec->width       = avio_rl16(pb);\n\n    vst->codec->height      = avio_rl16(pb);\n\n    vst->nb_frames          =\n\n    ast->nb_index_entries   = avio_rl16(pb);\n\n    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);\n\n\n\n    avio_skip(pb, 4);\n\n\n\n    ast->codec->codec_type  = CODEC_TYPE_AUDIO;\n\n    ast->codec->codec_id    = CODEC_ID_PCM_U8;\n\n    ast->codec->codec_tag   = 0; /* no fourcc */\n\n    ast->codec->sample_rate = avio_rl16(pb);\n\n    ast->codec->channels    = 1;\n\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n\n\n\n    avio_skip(pb, 10);\n\n\n\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n\n    if (!ast->index_entries)\n\n        return AVERROR(ENOMEM);\n\n\n\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n\n    if (!jv->frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    offset = 0x68 + ast->nb_index_entries * 16;\n\n    for(i = 0; i < ast->nb_index_entries; i++) {\n\n        AVIndexEntry *e   = ast->index_entries + i;\n\n        JVFrame      *jvf = jv->frames + i;\n\n\n\n        /* total frame size including audio, video, palette data and padding */\n\n        e->size         = avio_rl32(pb);\n\n        e->timestamp    = i;\n\n        e->pos          = offset;\n\n        offset         += e->size;\n\n\n\n        jvf->audio_size = avio_rl32(pb);\n\n        jvf->video_size = avio_rl32(pb);\n\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n\n\n\n        if (avio_r8(pb))\n\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n\n        jvf->video_type = avio_r8(pb);\n\n        avio_skip(pb, 1);\n\n\n\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n\n        audio_pts += jvf->audio_size;\n\n\n\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n\n    }\n\n\n\n    jv->state = JV_AUDIO;\n\n    return 0;\n\n}", "idx": 17280, "substitutes": {"s": ["g", "cs", "sf", "f", "sys", "sa", "sp", "aws", "ps", "sports", "ds", "js", "in", "t", "ss", "sq", "south", "ns", "ans", "si", "aps", "asts", "ls", "us", "an", "gs", "c", "p", "sb", "sci", "ts", "service", "ssl", "b", "sl", "sup", "su", "sim", "services", "fs", "S", "bis", "sg", "ses", "os", "a", "serv", "sc", "se", "spec", "v", "its"], "ap": ["arp", "cp", "AP", "sp", "wp", "tp", "ac", "op", "api", "np", "pi", "pac", "ax", "aps", "pl", "ar", "pa", "pp", "cap", "att", "al", "am", "ab", "mp", "ams", "au", "amp"], "jv": ["yv", "zv", "zvs", "yvr", "jaf", "jvt", "ojv", "kjf", "ojvs", "jaj", "jf", "kjv", " jvr", "ojf", "jvs", "jV", "arkV", "jvc", "kjvs", "jav", "zf", " jj", " jvc", "javs", " jV", "zj", "jvr", "yV", "ojvc", "arkv", "yvt", "kjvc", "arkvt", " jf", " jvs", "arkvr", "jj", " jvt"], "pb": ["wp", "phrase", "orp", "bh", "api", "pm", "pl", "ob", "summary", "afi", "b", "prot", "mb", "prop", "ab", "gb", "rob", "pd", "ppa", "param", "np", "bb", "bp", "aph", "platform", "vp", "eb", "params", "sb", "p", "fp", "pkg", "ub", "mp", "fc", "cp", "PB", "pc", "tp", "bc", "lp", "hub", "bm", "db", "pp", "pa", "rb", "verb", "txt", "xb", "asm", "wb", "cpp", "pg", "ib", "bps", "bsp", "ba", "typ", "ref", "bot", "cv", "gp", "bf", "dp", "lb", "plugin", "fb", "amp"], "vst": [" vste", "evsts", "svsp", "usts", "vsts", "vsl", "evstr", "evsp", " vcc", "vise", "evst", "svst", "gse", " vrest", "vest", " vstr", "wsts", "avsp", "svsts", "hsp", "evust", "avst", "ovST", "ovcc", " vST", "hST", "avsth", "gsts", "hste", " vsts", "wsp", "vste", "wsl", "hst", "Vrest", "ust", "ovrest", "evld", " vest", "gst", "ovst", "evste", "vist", "hsts", "vists", "avstd", "Vcc", "vinst", "hld", "vse", "avST", "hest", "wste", " vsl", "gste", "Vst", "wst", " vust", "avste", "svST", "svsl", "hsth", "vust", "vST", "winst", "uust", "VST", " vsp", "avse", "vstr", "vld", "wstr", "vrest", "gST", " vsth", "vsp", "vcc", "avsts", "gstd", "evest", " vld", "vistd", "ustr", "vsth", "svinst", "vstd", " vinst", "svste", "svstr"], "ast": ["ape", "node", "na", "cast", "Ast", "sh", "api", "end", "exec", "test", "ka", "aw", "ar", "act", "ard", "parser", "st", "asted", "ost", "best", "as", "AST", "ab", "a", "amd", "ann", "inst", "op", "mast", "ans", "od", "tta", "esp", "esi", "nt", "std", "ust", "sta", "at", "am", "master", "ams", "art", "host", "rest", "ad", "old", "aster", "aste", "est", "ist", "aid", "il", "rss", "ace", "ma", "att", "apache", "post", "ct", "asting", "blast", "sa", "ac", "asm", "t", "el", "ta", "mt", "asts", "tt", "asp", "hop", "stat", "all", "ref", "ld", "ST", "ft", "adapt", "ant", "sth", "ess", "an", "af", "amp"], "offset": ["skip", "alpha", "shift", "timeout", "length", "range", "parent", "pad", "off", "annot", "error", "base", "position", "ip", "len", "location", "address", "index", "padding", "entry", "data", "o", "Offset", "align", "slot", "format", "part", "pos", "origin", "pointer", "ptr", "slice", "image", "bytes", "url", "seq", "abyte", "area", "start", "alias", "rot", "order", "info"], "i": ["is", "f", "x", "ix", "u", "ci", "li", "in", "t", "end", "it", "d", "n", "ip", "I", "pi", "si", "id", "ai", "index", "r", "iu", "span", "ii", "c", "k", "p", "ind", "b", "z", "at", "ui", "ni", "num", "l", "start", "a", "ti", "j"]}}
{"project": "FFmpeg", "commit_id": "4fb3efd2c17c419cb7a170e5438b35453ceaaf30", "target": 0, "func": "static int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9\n\n    // Ref (MP4): ISO/IEC 14496-12:2012\n\n\n\n    if (track->enc->color_primaries == AVCOL_PRI_UNSPECIFIED &&\n\n        track->enc->color_trc == AVCOL_TRC_UNSPECIFIED &&\n\n        track->enc->colorspace == AVCOL_SPC_UNSPECIFIED) {\n\n        if ((track->enc->width >= 1920 && track->enc->height >= 1080)\n\n          || (track->enc->width == 1280 && track->enc->height == 720)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt709\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT709;\n\n        } else if (track->enc->width == 720 && track->height == 576) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt470bg\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT470BG;\n\n        } else if (track->enc->width == 720 &&\n\n                   (track->height == 486 || track->height == 480)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming smpte170\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;\n\n        } else {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, unable to assume anything\\n\");\n\n        }\n\n        switch (track->enc->color_primaries) {\n\n        case AVCOL_PRI_BT709:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_BT709;\n\n            break;\n\n        case AVCOL_PRI_SMPTE170M:\n\n        case AVCOL_PRI_BT470BG:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_SMPTE170M;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* We should only ever be called by MOV or MP4. */\n\n    av_assert0(track->mode == MODE_MOV || track->mode == MODE_MP4);\n\n\n\n    avio_wb32(pb, 18 + (track->mode == MODE_MP4));\n\n    ffio_wfourcc(pb, \"colr\");\n\n    if (track->mode == MODE_MP4)\n\n        ffio_wfourcc(pb, \"nclx\");\n\n    else\n\n        ffio_wfourcc(pb, \"nclc\");\n\n    switch (track->enc->color_primaries) {\n\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_PRI_SMPTE170M:\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->color_trc) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->colorspace) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_SPC_BT470BG:\n\n    case AVCOL_PRI_SMPTE170M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n\n\n    if (track->mode == MODE_MP4) {\n\n        int full_range = track->enc->color_range == AVCOL_RANGE_JPEG;\n\n        avio_w8(pb, full_range << 7);\n\n        return 19;\n\n    } else {\n\n        return 18;\n\n    }\n\n}\n", "idx": 17288, "substitutes": {"pb": ["cp", "txt", "PB", "pt", "pc", "uf", "tp", "wp", "pd", "jp", "ppa", "xb", "bc", "lp", "bh", "api", "dm", "bp", "pm", "hub", "bm", "cpp", "pg", "db", "pl", "pp", "pa", "platform", "vp", "bps", "eb", "rb", "fp", "p", "sb", "tmp", "hp", "b", "pkg", "cb", "bf", "dp", "pit", "lab", "sth", "lb", "fc", "plugin", "fb"], "track": ["skip", "progress", "rec", "coll", "rule", "session", "component", "match", "node", "cache", "test", "tm", "tr", "view", "record", "metadata", "r", "call", "stream", "tracking", "thread", "comment", "package", "Track", "tax", "order", "layer", "field", "mode", "round", "project", "work", "add", "gap", "ride", "rank", "user", "song", "current", "row", "port", "model", "roll", "sync", "token", "route", "trip", "module", "config", "sort", "trial", "post", "toggle", "gro", "stage", "note", "audio", "step", "run", "gg", "ack", "rock", "tracks", "rr", "report", "type", "transform", "grade", "cur", "form", "tag", "table", "tab", "path", "rack", "tt", "hop", "ogg", "request", "driver", "trace", "event", "sound"]}}
{"project": "qemu", "commit_id": "eaf136f9a21e02a2f55346e44d2d88df37b2cde3", "target": 0, "func": "static int slirp_socket_load(QEMUFile *f, struct socket *so)\n\n{\n\n    if (tcp_attach(so) < 0)\n\n        return -ENOMEM;\n\n\n\n    so->so_urgc = qemu_get_be32(f);\n\n    so->so_ffamily = qemu_get_be16(f);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        so->so_faddr.s_addr = qemu_get_be32(f);\n\n        so->so_fport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_faddr and so_lport\\n\");\n\n    }\n\n    so->so_lfamily = qemu_get_be16(f);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        so->so_laddr.s_addr = qemu_get_be32(f);\n\n        so->so_lport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_laddr and so_lport\\n\");\n\n    }\n\n    so->so_iptos = qemu_get_byte(f);\n\n    so->so_emu = qemu_get_byte(f);\n\n    so->so_type = qemu_get_byte(f);\n\n    so->so_state = qemu_get_be32(f);\n\n    if (slirp_sbuf_load(f, &so->so_rcv) < 0)\n\n        return -ENOMEM;\n\n    if (slirp_sbuf_load(f, &so->so_snd) < 0)\n\n        return -ENOMEM;\n\n    slirp_tcp_load(f, so->so_tcpcb);\n\n\n\n    return 0;\n\n}\n", "idx": 17301, "substitutes": {"f": ["g", "fx", "sf", "df", "uf", "fed", "u", "t", "flat", "form", "d", "lf", "fo", "fm", "info", "feed", "fun", "fd", "i", "fw", "h", "fr", "fen", "o", "tf", "w", "conf", "cf", "xf", "c", "file", "p", "F", "fp", "s", "inf", "rf", "b", "fac", "fa", "def", "fore", "fs", "elf", "handler", "fn", "fi", "bf", "e", "l", "fe", "of", "fc", "v", "af", "fb", "m"], "so": ["di", "SO", "client", "sp", "oh", "te", "sh", "lo", "sw", "or", " co", "cf", "ssl", "b", "sl", "su", "fs", "oso", "oo", "fe", "oa", "bo", "cli", "fo", "py", "no", "si", "one", "sk", "p", "s", "inf", "sb", "coe", "ki", "ko", "ui", "since", "ne", "l", "flo", "cu", "plus", "isi", "se", "sync", "iso", "kee", "pc", "this", "style", "oe", "ao", "ge", "to", "o", "ke", "shi", "le", "la", " si", "osi", "go", "info", "cs", "sa", "ski", "So", "vo", "po", "li", "ku", "obj", "ch", "pg", "mo", "za", "co", "sm", "ce", "how", "ou", "ld", "pe", "os", "from", "sc", "ds", "an"]}}
{"project": "qemu", "commit_id": "22f2e344748370b2e13888ba1057ebea2579970c", "target": 0, "func": "static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n", "idx": 17307, "substitutes": {"info": ["is", "inner", "check", "f", "now", "http", "hi", "kind", "extra", "type", "name", "op", "source", "work", "off", "api", "end", "error", "INFO", "fo", "py", "prev", "ip", "obj", "si", "args", "i", "config", "id", "aux", "fw", "show", "parse", "init", "qa", "full", "data", "diff", "tf", "next", "ii", "conf", "cf", "app", "ext", "inf", "Info", "hand", "service", "def", "update", "thin", "ui", "handler", "die", "start", "from", "of", "open", "plus", "ie", "event"], "dest": ["txt", "shift", "dc", "output", "grad", "src", "result", "route", "cli", "rest", "style", "proc", "temp", "feat", "buf", "source", "del", "flat", "wh", "end", "wb", "coord", "fun", "lib", "ident", "zip", "path", "dir", "data", "usr", "pack", "target", "Dest", "loc", "wd", "cont", "gen", "de", "tmp", "sup", "dist", "desc", "home", "done", "priv", "prop", "die", "options", "text", "opt", "dat", "sub", "lit", "buff"], "len": ["ann", "val", "str", "min", "length", "sp", "Pos", "ll", "lt", "Len", "alt", "el", "lf", "rel", "n", "fun", "fail", "enc", "fin", "user", "pl", "il", "full", "data", "ls", "span", "loc", "gen", "nt", "line", "limit", "pos", "ind", "ell", "resp", "err", "en", "la", "count", "url", "fn", "seq", "field", " length", "l", "non", "un", "num", "mun", "list", "lit", "lin", "blank", "spec", "part", "layer", "ln", "size", "offset"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)\n\n{\n\n    int next_avc    = h->is_avc ? 0 : buf_size;\n\n    int nal_index   = 0;\n\n    int buf_index   = 0;\n\n    int nals_needed = 0;\n\n\n\n    while(1) {\n\n        int nalsize = 0;\n\n        int dst_length, bit_length, consumed;\n\n        const uint8_t *ptr;\n\n\n\n        if (buf_index >= next_avc) {\n\n            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);\n\n            if (nalsize < 0)\n\n                break;\n\n            next_avc = buf_index + nalsize;\n\n        } else {\n\n            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);\n\n            if (buf_index >= buf_size)\n\n                break;\n\n        }\n\n\n\n        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,\n\n                                 next_avc - buf_index);\n\n\n\n        if (ptr == NULL || dst_length < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        buf_index += consumed;\n\n\n\n        bit_length = get_bit_length(h, buf, ptr, dst_length,\n\n                                    buf_index, next_avc);\n\n        nal_index++;\n\n\n\n        /* packets can sometimes contain multiple PPS/SPS,\n\n         * e.g. two PAFF field pictures in one packet, or a demuxer\n\n         * which splits NALs strangely if so, when frame threading we\n\n         * can't start the next thread until we've read all of them */\n\n        switch (h->nal_unit_type) {\n\n        case NAL_SPS:\n\n        case NAL_PPS:\n\n            nals_needed = nal_index;\n\n            break;\n\n        case NAL_DPA:\n\n        case NAL_IDR_SLICE:\n\n        case NAL_SLICE:\n\n            init_get_bits(&h->gb, ptr, bit_length);\n\n            if (!get_ue_golomb(&h->gb))\n\n                nals_needed = nal_index;\n\n        }\n\n    }\n\n\n\n    return nals_needed;\n\n}\n", "idx": 17308, "substitutes": {"h": ["g", "self", "header", "f", "http", "hi", "u", "oh", "sh", "t", "eh", "bh", "q", "uh", "rh", "d", "H", "ch", "hw", "hz", "img", "hl", "o", "hr", "ctx", "help", "him", "hu", "c", "p", "ha", "hand", "he", "gh", "b", "hp", "ih", "enh", "z", "hh", "home", "context", "buff", "e", "ph", "l", "hs", "ah", "hm", "ht", "v", "host", "m"], "buf": ["vec", "f", "src", "uf", "proc", "cmd", "uc", "bc", "queue", "cur", "buffer", "Buffer", "wb", "comb", "fd", "ff", "pb", "img", "data", "cas", "ctx", "grab", "loc", "rb", "cf", "fp", "abb", "bag", "cv", "tmp", "b", "auc", "home", "la", "alloc", "prop", "cb", "rc", "seq", "gb", "que", "usb", "box", "buff", "v", "Buff", "fb", "br"], "buf_size": ["buf_length", "bufallindex", "buf6size", "uf_size", "uf_ize", "bufallspeed", "buf_index", "uf_weight", "bufjindex", " buf_scale", "buf_weight", "buf6design", "bufallsize", "buf_depth", "uf_speed", " buf_length", "bufjscale", "buf_ize", " buf_index", "buf_speed", "buf_design", "uf_depth", "bufallweight", "bufjdepth", "uf_scale", "uf_design", "buf_scale", "bufjsize", "uf_index", "buf6scale"], "dst_length": ["dst_break", "dstflength", "dst__length", "dstxwidth", "dst_size", "dsts_width", "dstxsize", "dst__ength", "dst__path", "dstxbreak", "dst_width", "dsts_ength", "dsts_path", "dfront_len", "dstfwidth", "dstxlength", "dfront_shape", "dst_len", "dest_length", "dst_shape", "dst_ength", "dst_path", "dfront_length", "dsts_length", "dstfshape", "dsts_shape", "dest_width", "dest_size", "dest_break"], "bit_length": ["bitnlength", " bit_Length", "bitnlimit", "bit_type", "bitlenlength", " bit_duration", " bit_count", "bit_class", "bit___len", " bit_class", "bit_number", "bit_Length", "bit___number", "bit___type", "bit_count", "bit_len", "bit_limit", " bit_number", "bit___length", "bitlenduration", "bit_duration", " bit_type", "bitnduration", "bitlenlimit", " bit_limit", " bit_len"], "consumed": ["consored", "Conserved", "resided", "comppleted", "cosumed", "conserved", "resumption", "assided", "Consored", "compored", "comperved", "comored", "completed", "consided", "continerved", "Consumed", "comumed", "consumes", "compumed", "cosumes", " unconsumes", "consumption", " unconsumption", "continided", "continumption", "assumption", "continumed", "asserved", "cosumption", " unconsumed", " unconsided", "conspleted", "assumes", "resumed", "cosided", "reserved", "comerved", "assumed", "Conspleted"], "ptr": ["pend", "shift", "butt", "pt", "src", "proc", "length", "inst", "cache", "temp", "cur", "td", "pad", "plug", "buffer", "lf", "tr", "fd", "pair", "ff", "address", "code", "pb", "Ptr", "addr", "late", "br", "ctx", "pr", "loc", "ref", "fp", "push", "pos", "cv", "tmp", "ind", "p", "post", "prot", "pointer", "prim", "slice", "dep", "prop", "pull", "cb", "attr", "rc", "fi", "cmp", "start", "port", "ped", "rect", "buff", "alloc", "offset"], "nal_index": ["nali_path", "nabal67needed", "nal_size", "nalkavailable", "nal_available", "nal_location", "nal_di", "nal___di", "nabal67location", "nali_index", "naval_length", "nal_needed", "nal67length", "nal_offset", "nabal_index", "nal67index", "nabal_location", "nali_offset", "nal___needed", "nal67needed", "natal_di", "nal_length", "nal___index", "natal_index", "nal_path", "nabal67index", "naval_index", "nal___size", "nabal67length", "naval_position", "nalklength", "natal_needed", "nalkposition", "natal_size", "nalkindex", "naval_available", "nal_position", "nabal_length", "nal67location", "nabal_needed"]}}
{"project": "qemu", "commit_id": "e514fc7e1231c6d95011e448e6c626f2bb6f3cd8", "target": 0, "func": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n\n                             const E1000E_RxRing *rxr,\n\n                             const E1000E_RSSInfo *rss_info)\n\n{\n\n    PCIDevice *d = core->owner;\n\n    dma_addr_t base;\n\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n\n    size_t desc_size;\n\n    size_t desc_offset = 0;\n\n    size_t iov_ofs = 0;\n\n\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n\n    size_t size = net_rx_pkt_get_total_len(pkt);\n\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n\n    const E1000E_RingInfo *rxi;\n\n    size_t ps_hdr_len = 0;\n\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n\n\n\n    rxi = rxr->i;\n\n\n\n    do {\n\n        hwaddr ba[MAX_PS_BUFFERS];\n\n        e1000e_ba_state bastate = { { 0 } };\n\n        bool is_last = false;\n\n        bool is_first = true;\n\n\n\n        desc_size = total_size - desc_offset;\n\n\n\n        if (desc_size > core->rx_desc_buf_size) {\n\n            desc_size = core->rx_desc_buf_size;\n\n        }\n\n\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n\n\n        if (ba[0]) {\n\n            if (desc_offset < size) {\n\n                static const uint32_t fcs_pad;\n\n                size_t iov_copy;\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > core->rx_desc_buf_size) {\n\n                    copy_size = core->rx_desc_buf_size;\n\n                }\n\n\n\n                /* For PS mode copy the packet header first */\n\n                if (do_ps) {\n\n                    if (is_first) {\n\n                        size_t ps_hdr_copied = 0;\n\n                        do {\n\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n\n                                           iov->iov_len - iov_ofs);\n\n\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                      iov->iov_base, iov_copy);\n\n\n\n                            copy_size -= iov_copy;\n\n                            ps_hdr_copied += iov_copy;\n\n\n\n                            iov_ofs += iov_copy;\n\n                            if (iov_ofs == iov->iov_len) {\n\n                                iov++;\n\n                                iov_ofs = 0;\n\n                            }\n\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n\n\n                        is_first = false;\n\n                    } else {\n\n                        /* Leave buffer 0 of each descriptor except first */\n\n                        /* empty as per spec 7.1.5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n", "idx": 17314, "substitutes": {"d": ["g", "core", "cd", "dh", "bd", "dc", "D", "client", "f", "component", "cm", "pd", "dd", "ci", "t", "conn", "ad", "dm", "board", "dos", "ide", "gd", "id", "db", "dom", "data", "dl", "w", "ded", "c", "p", "s", "da", "dad", "ind", "b", "e", "dat", "dn", "ds", "sync"], "base": ["core", "bit", "hide", "server", "scale", "dc", "extra", "type", "name", "cache", "prefix", "bc", "buf", "na", "bat", "api", "bi", "end", "buffer", "root", "ka", "kit", "i", "id", "beta", "db", "bid", "address", "index", "pa", "last", "full", "data", "byte", "meta", "bre", "bar", "pre", "ca", "c", "bot", "p", "bas", "ha", "da", "store", "unit", "b", "create", "def", "home", "la", "bf", "area", "bu", "master", "size", "se", "Base", "bin", "ase", "info"], "desc": ["disc", "rec", "dc", "src", "uc", "name", "bc", "buf", "req", "description", "asc", "comb", "rib", "Desc", "config", "aux", "beta", "ros", "code", "des", "dir", "doc", "meta", "design", "loc", "ext", "ca", "decl", "def", "dist", "esc", "rc", "sec", " description", "seq", "dest", "sub", "anc", "sc", "ctr", "info"], "desc_size": [" desc_num", "descetunit", "desc_loc", "descetsize", "descacbody", "sub_clean", "desc_unit", "doc_size", "doc_offset", "sub_size", " desc_offset", "description_size", "description_offset", "descaclen", "doc_body", "descacsize", "sub_scale", "doc_len", "desc_scale", "descacoffset", "descetscale", "description_loc", "desc_num", "descetclean", "desc_len", "desc_clean", "sub_unit", "description_len", "desc_offset", "desc_body", " desc_len"], "iov": ["ru", "ilo", "iop", "iol", "ci", "mx", "mu", "pai", "gra", "uga", "irc", "ib", "igi", "iu", "uno", "ctx", "ia", "ii", "rb", "dq", "nr", "vre", "odi", "abc", "ei", "ahi", "fi", "io", "rob"], "rxi": [" rfi", "prbi", " rci", "prxa", "pxi", " rdi", " rbi", "rfi", "rgbi", "rgpi", "rgxa", "rpi", "rxa", "prdi", "pXi", "ppi", "Rdi", "rgfi", "rbi", " rXi", "rci", "Rxi", "prri", "Rci", "RXi", "rdi", " rxa", "rri", "pfi", "prxi", "rXi", "pci", "Rri", "prpi", "rgxi", " rpi", "Rpi", "rgci", " rri"], "ba": [" buf", "ja", "bd", "sa", "bs", " bc", "bc", "buf", "na", "aba", "bi", " b", "ta", "ka", "xa", "pa", "va", "ai", "pb", "tta", "ae", "aa", "asa", "Ba", "ga", "ca", "ea", " ac", "ha", "da", "ada", "b", "fa", "abc", " ca", "la", "ab", "area", "a", "wa", "bu", " ab", " bo", "au", "BA"], "fcs_pad": ["fcsbinit", "fcsbcount", "fcs_init", "fcs_count", "ffs_pos", "fcsbpos", "fcs_pos", "ffs_init", "ffs_count", "ffs_pad", "fcsbpad"], "iov_copy": ["oren_copy", "iov__copy", "iov__shared", "oren__shared", "oren__copy", "iov__data", "iov_size", "iov_data", "oren__data", "oren_shared", "iov_shared", "iov__size", "oren_data", "oren__size", "oren_size"]}}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static int cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n\n{\n\n    int sx = 0, sy = 0;\n\n    int dx = 0, dy = 0;\n\n    int depth = 0;\n\n    int notify = 0;\n\n\n\n    /* make sure to only copy if it's a plain copy ROP */\n\n    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||\n\n        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {\n\n\n\n        int width, height;\n\n\n\n        depth = s->vga.get_bpp(&s->vga) / 8;\n\n        if (!depth) {\n\n            return 0;\n\n        }\n\n        s->vga.get_resolution(&s->vga, &width, &height);\n\n\n\n        /* extra x, y */\n\n        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;\n\n        sy = (src / ABS(s->cirrus_blt_srcpitch));\n\n        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;\n\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n\n\n        /* normalize width */\n\n        w /= depth;\n\n\n\n        /* if we're doing a backward copy, we have to adjust\n\n           our x/y to be the upper left corner (instead of the lower\n\n           right corner) */\n\n        if (s->cirrus_blt_dstpitch < 0) {\n\n            sx -= (s->cirrus_blt_width / depth) - 1;\n\n            dx -= (s->cirrus_blt_width / depth) - 1;\n\n            sy -= s->cirrus_blt_height - 1;\n\n            dy -= s->cirrus_blt_height - 1;\n\n        }\n\n\n\n        /* are we in the visible portion of memory? */\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\n            (sx + w) <= width && (sy + h) <= height &&\n\n            (dx + w) <= width && (dy + h) <= height) {\n\n            notify = 1;\n\n        }\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n\n                      s->vga.vram_ptr + s->cirrus_blt_srcaddr,\n\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n\n\n    if (notify) {\n\n        dpy_gfx_update(s->vga.con, dx, dy,\n\n                       s->cirrus_blt_width / depth,\n\n                       s->cirrus_blt_height);\n\n    }\n\n\n\n    /* we don't have to notify the display that this portion has\n\n       changed since qemu_console_copy implies this */\n\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t\ts->cirrus_blt_height);\n\n\n\n    return 1;\n\n}\n", "idx": 17325, "substitutes": {"s": ["g", "self", "sites", "session", "uns", "secondary", "js", "plugins", "r", "gs", "conf", "c", "ssl", "b", "obs", "su", "fs", "stats", "states", "sets", "a", "qs", "m", "http", "u", "ns", "site", "si", "args", "i", "tests", "state", "your", "full", "es", "us", "an", "p", "sb", "ts", "sie", "ks", "y", "sis", "services", "l", "sym", "se", "its", "sync", "f", "less", "sports", "rs", "south", "ss", "sq", "n", "native", "o", "xs", "S", "bis", "sg", "ses", "hs", "spec", "is", "cs", "sys", "ps", "t", "status", "private", "ls", "side", "service", "uses", "e", "os", "ds", "v"], "dst": [" dsts", " dsc", "Dst", "hsc", "hbl", "dbl", " dsta", "Dsc", "adsta", "dsts", "Dcr", "fst", "Dsts", "hsta", "Dost", "Dsp", " dsp", "dost", "hst", "fsc", "dsp", " dost", " dcr", " dbl", "fcr", "dsc", "adsc", "adst", "dsta", "fsp", "adbl", "hsts", "dcr", "host"], "src": ["sn", "sys", "sid", "kk", "uc", "rs", "source", "sh", "sq", "sr", "low", "hw", "config", "img", "rx", "rss", "ctx", "st", "stream", "loc", "rb", "head", "sb", "depth", "sci", "b", "sl", "sup", "dist", "sta", "sel", "gz", "rc", "cb", "url", "dest", "gb", "obl", "sub", "sth", "sc", "rob", "bg", "sync"], "w": ["g", "wave", "ow", "f", "wt", "x", "work", "u", "sh", "wh", "window", "end", "sw", "flow", "q", "d", "wb", "n", "H", "we", "wl", "hw", "fw", "aw", "r", "max", "wx", "win", "wi", "hop", "ew", "wd", "p", "kw", "y", "b", "z", "weight", "row", "l", "ww", "wa", "W", "rw", "v"], "h": ["g", "f", "hi", "x", "u", "ul", "oh", "sh", "q", "d", "rh", "n", "H", "th", "r", "hl", "o", "hr", "hop", "c", "p", "depth", "ha", "y", "gh", "b", "ih", "z", "hh", "hd", "en", "l", "ph", "hs", "hy", "ah", "hm", "ht", "v", "m"], "height": ["arrow", "ty", "length", "resolution", "chrom", "style", "Height", "dim", "window", "distance", "inches", "quality", "view", "direction", "rank", "th", "hor", "max", "padding", "volume", "dy", "grow", "time", "depth", "y", "ows", "gh", "deep", "value", "dist", "ths", "thin", "density", "weight", "hd", "image", "shape", "row", "hang", "driver", "rows", "device", " heights", "crop", "size"]}}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17328, "substitutes": {"bs": ["lbs", "cs", "css", "bc", "BS", "js", "bh", "ss", "abi", "bi", "org", "ns", "bb", "base", "cms", "ros", "blocks", "ob", "bits", "pb", "vs", "ls", "iss", "us", "als", "rb", "bridge", "sb", "bas", "b", "obs", "ubs", "fs", "bytes", "bis", "cb", "ab", "bos", "ses", "os", "ins", "outs", "lb", "bes", "ds", "bl", "fb", "bing"], "l1_index": ["l1sstart", "l4_index", "l1pIndex", "l1poffset", "l21_element", "l21_index", "l21_start", "l1nelement", "l1nwidth", "l1sindex", "l1_offset", "l4_position", "l1_width", "l21_width", "l1swidth", "l1_element", "l1selement", "l1pindex", "l4_offset", "l4_Index", "l1pposition", "l1nstart", "l1_position", "l1_start", "l1nindex", "l1_Index"], "s": ["is", "cs", "server", "f", "sys", "session", "ps", "uns", "bc", "rs", "js", "ss", "ns", "site", "si", "args", "state", "iss", "ls", "gs", "c", "p", "service", "sie", "b", "ssl", "sl", "su", "fs", "services", "stats", "S", "bis", "as", "states", "e", "ses", "os", "sv", "ins", "spec", "ds", "qs", "sync", "settings"], "buf": ["header", "vec", "bd", "map", "src", "uf", "result", "stab", "uc", "cmd", "bc", "queue", "array", "bh", "pad", "buffer", "Buffer", "wb", "bb", "conv", "base", "fd", "config", "aux", "tab", "db", "ff", "pb", "img", "data", "block", "cas", "ctx", "grab", "cap", "rb", "ref", "bag", "cv", "tmp", "b", "append", "Buff", "fb", "bytes", "cb", "rc", "fi", "gb", "seq", "ab", "mp", "arr", "fab", "box", "buff", "af", "alloc", "br"], "l1_start_index": ["l1_end_address", "l1_end_ind", "l1_data_end", "l1_start_length", "l1_data_index", "l1_start_point", "l1_start_part", "l1_end_offset", "l1_start_ind", "l1_start_position", "l1_end_index", "l1_end_position", "l1_start_offset", "l1_data_point", "l1_end_part", "l1_end_length", "l1_start_end", "l1_start_address"], "i": ["di", "f", "ri", "xi", "hi", "x", "u", "qi", "ci", "li", "in", "t", "eni", "end", "bi", "uri", "ji", "d", "n", "len", "I", "pi", "si", "id", "h", "index", "r", "ai", "iu", "o", "ii", "c", "k", "p", "ind", "b", "ui", "en", "ni", "gi", "zi", "e", "l", "a", "io", "oi", "ini", "v", "ti", "j", "m"], "ret": ["bit", "val", "reply", "RET", "f", "result", "match", "alt", "res", "success", "reg", "back", "red", "len", "fun", "mt", "id", "db", "r", "code", "rev", "xt", "rets", "pre", "att", "rb", "ext", "ref", "det", "nt", "b", "flag", "resp", "re", "err", "fat", "rc", "num", "Ret", "fi", "mem", "cb", "bad", "arg", "lit", "rt", "art", "j"]}}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n                   VhostBackendType backend_type)\n{\n    uint64_t features;\n    int i, r;\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n        close((uintptr_t)opaque);\n        return -1;\n    }\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n        close((uintptr_t)opaque);\n        return -errno;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n    if (r < 0) {\n        goto fail;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n    if (r < 0) {\n        goto fail;\n    }\n    for (i = 0; i < hdev->nvqs; ++i) {\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);\n        if (r < 0) {\n            goto fail_vq;\n        }\n    }\n    hdev->features = features;\n    hdev->memory_listener = (MemoryListener) {\n        .begin = vhost_begin,\n        .commit = vhost_commit,\n        .region_add = vhost_region_add,\n        .region_del = vhost_region_del,\n        .region_nop = vhost_region_nop,\n        .log_start = vhost_log_start,\n        .log_stop = vhost_log_stop,\n        .log_sync = vhost_log_sync,\n        .log_global_start = vhost_log_global_start,\n        .log_global_stop = vhost_log_global_stop,\n        .eventfd_add = vhost_eventfd_add,\n        .eventfd_del = vhost_eventfd_del,\n        .priority = 10\n    };\n    hdev->migration_blocker = NULL;\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n        error_setg(&hdev->migration_blocker,\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n        migrate_add_blocker(hdev->migration_blocker);\n    }\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n    hdev->n_mem_sections = 0;\n    hdev->mem_sections = NULL;\n    hdev->log = NULL;\n    hdev->log_size = 0;\n    hdev->log_enabled = false;\n    hdev->started = false;\n    hdev->memory_changed = false;\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n    return 0;\nfail_vq:\n    while (--i >= 0) {\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n    }\nfail:\n    r = -errno;\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n    QLIST_REMOVE(hdev, entry);\n    return r;\n}", "idx": 17329, "substitutes": {"hdev": ["hmhost", "cdevice", "hdata", "ohhost", "ohdef", "shdevice", "cdi", "hod", "hdiff", "hyerror", "hrdev", "rhev", "shdev", "hmengine", "hdi", "rhconn", "herhost", "hydi", "vdev", "kdev", " hde", "hldef", "hydev", "fdc", "fdriver", " hpad", "hypad", "hlvar", "vdi", "hostdiff", "Hdev", " hdevelopment", "Hdiv", "rhpad", "Hvalid", "hdod", "bhvalid", "hdd", " hod", "hdevelopment", " hdevice", "rhdiff", "rherror", "hdevice", "fdevice", "hdhost", "ehvar", "rhdie", "herconn", "Hdevelopment", "vdef", "kdriver", " hvalid", "bhdef", "fdev", "hrdie", "hmod", "herdev", "ehdef", "rhhost", "shapp", "ohvalid", "hldev", "hvar", "herdi", "Hdef", "hldevice", " hdiv", "Hev", "hdengine", "hrdf", "Hdevice", "shev", "hldiff", "bhdev", "ohdi", "hengine", "hvalid", "rhvalid", "hgu", "ohdev", "hostdevelopment", "hhost", " hdc", " hdriver", "shdi", "hrdd", "herror", " hdi", "adhrad", "cdev", "hpad", "bhdevice", "vev", "rhapp", "adhdev", "ohdevice", "adhde", "rhdevice", "hldevelopment", "hlgu", "Hdi", " hdata", "hostdev", "hdc", " hvar", "rhdiv", "vdevice", " hdf", "hdie", "ohdevelopment", "ohdata", "rhdi", "shdiff", "hev", " hdd", " happ", "rhdata", " hhost", "kdc", "hconn", "hmdev", "fvar", "hrrad", "bhgu", "vhost", " hengine", "adhdf", " hev", "ohvar", " hdiff", "shdc", " hdef", "ohev", "hlhost", "hdiv", "bhdiv", " hconn", "hde", "hrde", "happ", "hdf", "hrdiv", "rhdd", "kdevice", "hddev", "hrad", " hrad", "hostgu", "rhdev", " herror", "ehdev", "hdriver", " hgu", "ehev", "cdc", "vvar", " hdie", "hdef", "fhost"], "opaque": ["opercode", "opaco", "OPaque", "opivalent", "openabled", "opcode", "operacity", " opaco", "operac", " opac", "OPacity", "Opivalent", "Opacity", "ipac", " openabled", "opacity", "operivalent", " opivalent", " opacle", "operacle", "ipenabled", " opacity", "OPaco", " opcode", "OPacle", "Opacle", "ipacity", "Opaque", "opacle", "ipaque", "operaque", "opac", "operenabled", "operaco", "ipcode"], "backend_type": ["backend_types", "backendaltype", "backender_type", "backender_key", "backend_name", "backendalformat", "backendalclass", "backend_format", "backend_key", "backendaltypes", "backended_format", "backended_class", "backender_name", "backended_types", "backended_type", "backend_class", "backender_types"], "features": ["g", "models", "issues", "plugins", "types", "afi", "ga", "products", "ffff", "devices", "stats", "bytes", " f", "requires", "results", "args", "lib", "resources", "tests", "versions", "ATURES", "strings", "items", "license", "bugs", "params", "facts", "s", "modules", "nets", "services", "protection", "words", "events", "fc", "eatures", "flags", "tags", "ops", "Features", "reports", "rs", "n", "config", "bits", "ips", "classes", "files", "pieces", "xs", "properties", "fn", "options", "sections", "faces", "feature", "groups", "result", "feat", "rules", "ints", "includes", "measures", "forms", "fixes", "details", "effects", " interfaces", "fields", "settings", "os", "works"], "i": ["g", "phi", "di", "f", "ri", "xi", "type", "x", "ix", "qi", "u", "ci", "li", "t", "q", "eni", "bi", "uri", "api", "it", "d", "mi", "n", "ip", "I", "pi", "si", "id", "h", "index", "ai", "iu", "o", "ii", "k", "c", "p", "y", "b", "er", "z", "err", "ui", "ni", "zi", "gi", "fi", "yi", "e", "l", "ie", "ini", "v", "ti", "j", "m"], "r": ["g", "ru", "dr", "str", "rec", "rr", "f", "result", "u", "rs", "t", "kr", "q", "sr", "error", "R", "d", "rh", "ir", "lr", "or", "rar", "h", "ar", "fr", "o", "br", "hr", "rb", "c", "rd", "k", "p", "rl", "mr", "rf", "b", "nr", "function", "cr", "er", "re", "rg", "err", "ur", "nor", "run", "rc", "e", "l", "arr", "rt", "v", "pr", "j", "m"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 17337, "substitutes": {"bs": ["lbs", "cs", "css", "ps", "bc", "rs", "BS", "js", "abi", "ss", "ns", "bb", "base", "obj", "banks", "bid", "ob", "bits", "blocks", "pb", "iss", "vs", "ls", "bps", "eb", "es", "als", "rb", "gs", "sb", "bas", "s", "ks", "b", "obs", "ubs", "fs", "las", "bytes", "bis", "cb", "ab", "gb", "ses", "bos", "os", "ins", "outs", "lb", "bes", "ds", "bl", "fb", "bing"], "sector_num": ["sectoringrange", "sectoringnom", " sector_name", "sector_nom", "section_number", "sector_param", " sector_param", "sector_range", " sector_range", "section_num", " sector_nom", "sectoringnum", "section_name", "sector_name", "sector_count", "sectoringnumber", " sector_number", "section_count", "sector_number"], "buf": ["batch", "vec", "src", "uf", "cmd", "queue", "bc", "pad", "buffer", "wb", "bb", "base", "fd", "config", "ff", "blocks", "pb", "data", "block", "cas", "ctx", "exc", "rb", "cf", "bridge", "fp", "bag", "cv", "b", "msg", "prop", "alloc", "cb", "num", "rc", "seq", "bf", "fi", "bus", "port", "fab", "que", "lb", "buff", "bags", "fb"], "nb_sectors": ["nb_SEctors", "nb_serctions", "nb_vegments", "nb_nekers", "nb_SEctor", "nb_vellers", "nb_vekers", "nb_spectors", "nb_persector", "nb_negments", "nb_persegments", "nb_verets", "nb_gerets", "nb_vector", "nb_sector", "nb_persectors", "nb_secctors", "nb_sections", "nb_gectors", "nb_spector", "nb_serets", "nb_sergments", "nb_secctor", "nb_gekers", "nb_sellers", "nb_secctions", "nb_nerets", "nb_persellers", "nb_serctors", "nb_spellers", "nb_nectors", "nb_spegments", "nb_serctor", "nb_segments", "nb_gegments", "nb_SEctions", "nb_sekers", "nb_SEgments", "nb_secgments", "nb_vectors"], "drv": ["rdv", "frvr", "srf", "drvr", "rdp", "srvs", "rdb", " drver", "trb", "drvs", "frv", " drf", " drp", "driV", "drif", "hrb", "frf", "DRver", "drp", "rrf", "yrvr", "Drf", "yrf", "Drv", "drV", "yrv", "drvv", "driv", "hrf", "druv", " drb", "rdf", "srb", "yrvv", "drf", "frvv", "truv", " drvv", "drb", "rrv", "DRv", "rrp", "DRV", "Drb", " drvr", " drvs", "hrp", "trv", "rdvs", " druv", "driver", "hrv", "trf", "srv", "drver", "DRf", " drV", "Druv", "rrb"], "ret": ["RET", "val", "bit", "reply", "f", "length", "result", "lt", "net", "alt", "Len", "cur", "res", "conn", "el", "repl", "req", "error", "lf", "fail", "base", "fun", "id", "fin", "pet", "fit", "code", "data", "rev", "rets", "ref", "nt", "elt", "def", "re", "err", "en", " Ret", "run", "count", "num", "Ret", "seq", "rc", "l", "lit", "rt", "out", "art"], "len": ["ann", "val", "min", "f", "length", "lan", "split", "lt", "alt", "Len", "li", "el", "repl", "lf", "rel", "n", "fun", "base", "lon", "fin", "il", "ls", "rev", "lc", "ref", "sil", "nt", "pos", "ld", "led", "sl", "le", "err", "fat", "en", "lif", "count", "seq", "l", "ler", "lit", "lin", "ie", "rt", "part", "ln", "elt"], "rd_ops": ["dr_ops", "dr_proc", "dr_bytes", "rd_proc", "dr_bits", "rd_bits", "rd_bytes"]}}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n", "idx": 17341, "substitutes": {"p1": ["point1", "pointOne", "P2", "P7", "c7", " p7", "c1", "pc2", "pc1", " p3", "P3", "p3", "pcOne", " pOne", "pOne", "p7", "point2", "P1", "c3", "c2"], "p2": ["P02", "ptwo", "P0", "cp0", "point1", " p0", "P2", "p8", " p8", "p0", "Ptwo", " ptwo", "cp2", "pointtwo", " p02", "cp8", "p02", "point02", "cp1", "point2", "P1", "P8"], "cdt": ["patcht", "cft", "cfpt", "CDpt", "CDt", " cdc", "CDtr", "idp", "patchrt", "cdtr", "ndt", "idt", " cdrt", " cdpt", "patchp", "cdp", "ndtree", "CDp", "ndc", "patchtree", "idtree", "cfp", "cdpt", "idc", " cdtr", "cdrt", "ndrt", "cdtree", "cdc", "ndp", " cdtree", "cftr", " cdp"], "r": ["g", "ru", "rr", "f", "ri", "x", "u", "rs", "sr", "d", "R", "rh", "n", "or", "i", "ar", "ra", "h", "fr", "o", "hr", "w", "rb", "c", "k", "p", "var", "nr", "er", "err", "ur", "e", "l", "a", "rt", "v", "pr", "j", "m"], "b": ["f", "B", "bs", "x", "u", "bh", "d", "wb", "bb", "n", "base", "i", "db", "ob", "h", "pb", "emb", "eb", "binary", "bar", "w", "ba", "rb", "body", "c", "k", "p", "sb", "y", "abc", "mb", "nb", "reb", "cb", "ab", "e", "l", "a", "lb", "v", "bin", "fb", "br"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,\n\n                        const AVFrame *ref)\n\n{\n\n    PSNRContext *s = ctx->priv;\n\n    double comp_mse[4], mse = 0;\n\n    int j, c;\n\n    AVDictionary **metadata = avpriv_frame_get_metadatap(main);\n\n\n\n    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,\n\n                      (const uint8_t **)ref->data, ref->linesize,\n\n                       main->width, main->height, comp_mse);\n\n\n\n    for (j = 0; j < s->nb_components; j++)\n\n        mse += comp_mse[j] * s->planeweight[j];\n\n\n\n    s->min_mse = FFMIN(s->min_mse, mse);\n\n    s->max_mse = FFMAX(s->max_mse, mse);\n\n\n\n    s->mse += mse;\n\n    for (j = 0; j < s->nb_components; j++)\n\n        s->mse_comp[j] += comp_mse[j];\n\n    s->nb_frames++;\n\n\n\n    for (j = 0; j < s->nb_components; j++) {\n\n        c = s->is_rgb ? s->rgba_map[j] : j;\n\n        set_meta(metadata, \"lavfi.psnr.mse.\", s->comps[j], comp_mse[c]);\n\n        set_meta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n\n    }\n\n    set_meta(metadata, \"lavfi.psnr.mse_avg\", 0, mse);\n\n    set_meta(metadata, \"lavfi.psnr.psnr_avg\", 0, get_psnr(mse, 1, s->average_max));\n\n\n\n    if (s->stats_file) {\n\n        fprintf(s->stats_file, \"n:%\"PRId64\" mse_avg:%0.2f \", s->nb_frames, mse);\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"mse_%c:%0.2f \", s->comps[j], comp_mse[c]);\n\n        }\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"psnr_%c:%0.2f \", s->comps[j],\n\n                    get_psnr(comp_mse[c], 1, s->max[c]));\n\n        }\n\n        fprintf(s->stats_file, \"\\n\");\n\n    }\n\n\n\n    return main;\n\n}\n", "idx": 17350, "substitutes": {"ctx": ["cca", "core", "cs", "cp", "cm", "client", "src", "cal", "cmd", "bc", "bt", "gc", "conn", "sq", "q", "scope", "conv", "cms", "config", "support", "cas", "comm", "mac", "ca", "cf", "conf", "acs", "cam", "cv", "sci", "tx", "tc", "Context", "context", "cb", "cmp", "ctrl", "anc", "sc", "setup"], "ref": ["local", "fact", "rec", " reference", "f", "aff", "range", "alt", "parent", "source", "cache", "end", "req", "reg", "rel", "old", "primary", "base", "obj", "config", "id", "REF", "db", "ob", "rem", "pb", "external", "fr", "diff", "full", "block", "img", "pre", "conf", "p", "b", "def", "re", "m", "arc", "ab", "mem", "wa", "reference", "remote", "part", "comp", "Ref", "af", "info"], "s": ["g", "set", "self", "sites", "lines", "client", "session", "secondary", "js", "plugins", "h", "r", "gs", "conf", "b", "ssl", "sl", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "server", "sf", "http", "u", "ns", "ans", "site", "si", "i", "full", "data", "es", "us", "p", "sb", "y", "ts", "ks", "sis", "services", "sv", "l", "sym", "shared", "its", "sync", "f", "ops", "src", "tp", "rs", "single", "ss", "sq", "n", "o", "xs", "S", "sg", "ses", "hs", "spec", "is", "ys", "cs", "sys", "aws", "sa", "ps", "t", "parts", "d", "ls", "w", "service", "comments", "e", "os", "sc", "ds", "v", "settings"], "comp_mse": ["comp_mese", "comp_mrge", "comp_Mge", "comp_rmce", "comp_cze", "comp_amge", "comp_kmisse", "comp_rse", "comp_amse", "comp_rke", "comp_mge", "comp_mpe", "comp_Mpe", "comp_amme", "comp_rmze", "comp_Mse", "comp_mte", "comp_Mze", "comp_cmke", "comp_misse", "comp_mrse", "comp_MSE", "comp_kmpe", "comp_cmce", "comp_nke", "comp_rce", "comp_cmso", "comp_amce", "comp_npe", "comp_cse", "comp_mrese", "comp_amte", "comp_nso", "comp_magese", "comp_kmze", "comp_rmte", "comp_cisse", "comp_mbe", "comp_mce", "comp_nce", "comp_mke", "comp_mSE", "comp_mme", "comp_mrme", "comp_ampe", "comp_mesh", "comp_nge", "comp_ambe", "comp_rmSE", "comp_rmesh", "comp_cmse", "comp_rmbe", "comp_mso", "comp_nse", "comp_rso", "comp_nte", "comp_Mte", "comp_mze", "comp_magme", "comp_amesh", "comp_magse", "comp_magge", "comp_cpe", "comp_rmse", "comp_kmse", "comp_amese"], "j": ["ja", "g", "section", "json", "f", "jp", "x", "u", "jo", "qi", "je", "js", "li", " ii", "t", "ji", "q", "el", "jam", "it", "d", "oj", "off", "n", "jl", "job", "ij", "obj", "syn", "i", "jit", "ch", "dj", "kj", "h", "code", "r", "fr", "jet", "jen", "o", " l", "br", "aj", "w", "jc", "k", "p", "adj", "pos", "key", "y", "uj", "b", "note", "z", "er", "err", " i", "bj", "e", "l", "J", "im", "ie", "v", "jj", "m"], "c": ["g", "cs", "cn", "cm", "dc", "f", "coll", "cat", "uc", "ac", "u", "x", "cache", "ci", "t", "q", "d", "n", "col", "ch", "i", "cl", "h", "code", "co", "r", "con", "o", "ec", "lc", "w", "cell", "ca", "cf", "k", "p", "cc", "y", "cy", "vc", "b", "cr", "z", "err", "count", "cb", "arc", "mc", "e", "l", "C", "cu", "sc", "v", "m"], "metadata": ["ann", "header", "gm", "json", "notes", "track", "session", "database", "wp", "generic", "template", "xml", "mx", "document", "music", "annot", "carbon", "metal", "uri", "adata", "tm", "np", "valid", "magic", "message", "java", "args", "bm", "metry", "memory", "met", "config", "mt", "storage", "zip", "summary", "parser", "data", "binary", "meta", "communication", "archive", "details", "note", "properties", "stats", "m", "package", "cookie", "collection", "filename", "utils", "general", "nm", "mm", "shared", "md", "sound", "info"], "nb_frames": ["nbofframes", "nbClines", "nb__lines", "nbCshots", "num_frames", "nb__shots", "num_frame", "nb_shots", "ni_shots", "num_steps", "nbofpoints", "num_points", "nbCimages", "nbofsteps", "ni_images", "nb_lines", "nb_points", "nb__frames", "nb_steps", "nb__images", "nbCframes", "ni_frames", "ni_lines", "nb_images", "nbofframe", "nb_frame"]}}
{"project": "FFmpeg", "commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "target": 1, "func": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n\n{\n\n    EbmlList *index_list;\n\n    MatroskaIndex *index;\n\n    int index_scale = 1;\n\n    int i, j;\n\n\n\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n\n        return;\n\n\n\n    index_list = &matroska->index;\n\n    index      = index_list->elem;\n\n    if (index_list->nb_elem &&\n\n        index[0].time > 1E14 / matroska->time_scale) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n\n        index_scale = matroska->time_scale;\n\n    }\n\n    for (i = 0; i < index_list->nb_elem; i++) {\n\n        EbmlList *pos_list    = &index[i].pos;\n\n        MatroskaIndexPos *pos = pos_list->elem;\n\n        for (j = 0; j < pos_list->nb_elem; j++) {\n\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n\n                                                              pos[j].track);\n\n            if (track && track->stream)\n\n                av_add_index_entry(track->stream,\n\n                                   pos[j].pos + matroska->segment_start,\n\n                                   index[i].time / index_scale, 0, 0,\n\n                                   AVINDEX_KEYFRAME);\n\n        }\n\n    }\n\n}\n", "idx": 17353, "substitutes": {"matroska": ["Matroka", "macroska", "metrska", "catrasla", "matrosya", "matronesga", "Matrockee", "catroska", "matrowoa", "matroha", "matlosya", "catraski", "matrasga", "matrosga", "matrocla", "matroseka", "catroski", "macroha", "matrasaka", "matroqua", " matrasya", "Matrosla", "Matrocka", "catrasku", "matronesla", "matrocka", "metroska", "matroya", "matrusky", " matrasaka", "Matroku", "matroaka", "macroqua", "matrusla", "matrosca", "matroneska", "catrosku", "matrsla", "matrosla", "matroski", "matroki", "matrowka", "matrocha", "matrocki", "Matroskee", "metrosoa", "Matrocku", "matrockee", "macrosky", "matrooa", "matrska", "Matrosku", "matroky", "matraska", "Matrokee", "macroka", "matrokee", "matrasya", "Matrosaka", "matrosky", " matrasga", "matrskee", "matronesya", "matrocaka", "matraskee", "matroseca", "macroaka", "matrasla", "metrosya", "metrosla", "matrola", "matrsya", "macrosqua", "matrasku", "matrosekee", "matrosequa", "catrosla", "Matroaka", "matruska", "matloska", " matrosya", "matrusqua", "matroseku", "macrosha", "matrowla", "Matroska", "matroseaka", "Matrosca", "matrosela", "matroku", "matronesaka", "matrocku", " matrosaka", "matlosaka", "matraski", "matrsku", "catraska", "Matrola", "matlosga", "matrosha", "matroneskee", "matroka", "metrsya", "matrocca", "matrosku", "matrsoa", "matrosqua", "metrsoa", "Matrocca", "matrosoa", "matroskee", "matrowya", "macrosaka", "metrsla", " matraska", "macroky", "matroseha", "macrola", " matrosga", "matrsca", "macrosla", "matrosaka", "matroseky"], "index_list": ["indexerlist", "num_lists", "indexingtable", "index_source", " index_pair", "index_cont", "indexentree", "indexentable", "indexensource", "index_base", " index_tree", "num_queue", "indexenlist", "indexingcont", "indexertable", "indexerList", " indexingtree", "index_tree", "index_info", "indexerlists", "posinginfo", "index_lc", "num_List", " index_base", "posinglc", "posinglist", "index_loop", "indexingsource", "indexersource", "pos_info", "index_table", "index_List", "indexingqueue", "numerList", "num_list", "indexertree", "posingloop", "index_lists", "pos_loop", "numerqueue", " index_lc", " index_source", "indexinglist", " index_table", "indexinglc", "indexingtree", " indexingtable", "indexinglists", " index_cont", "indexingList", "indexerqueue", "indexingpair", " indexingsource", "index_pair", "indexinginfo", "pos_lc", " indexinglist", "index_queue", "indexingbase", "numerlist", "numerlists", "indexingloop"], "index": ["match", "x", "cache", "link", "page", "end", "connection", "point", "view", "position", "record", "edit", "zip", "summary", "block", "call", "connect", "thread", "search", "action", "update", "comment", "image", "weight", "open", "order", "server", "project", "queue", "instance", "source", "multi", "data", "draw", "object", "key", "current", "value", "find", "num", "model", "list", "master", "office", "date", "sync", "example", "route", "frame", "array", "stack", "version", "config", "module", "address", "change", "input", "diff", "entry", "sort", "pass", "write", "body", "ind", "query", "header", "output", "inc", "Index", "type", "document", "include", "table", "press", "word", "unit", "slice", "event"], "i": ["di", "f", "ri", "xi", "x", "u", "ix", "qi", "ci", "li", "eni", "bi", "ji", "uri", "d", "info", "n", "ip", "I", "si", "pi", "id", "ai", "iv", "iu", "ii", "k", "c", "p", "y", "b", "ki", "z", "ui", "ni", "zi", "gi", "fi", "yi", "e", "l", "start", "a", "io", "oi", "im", "ini", "ie", "v", "mi", "m"], "j": ["ja", "g", "f", "jp", "xi", "x", "u", "jo", "qi", "je", "li", "js", "t", "q", "ji", "oj", "jl", "n", "obj", "ij", "job", "dj", "kj", "h", "r", "fr", "jet", "o", "br", "pr", "aj", "w", "cell", "ii", "k", "jc", "p", "adj", "key", "uj", "y", "ind", "b", "note", "z", "gi", "bj", "e", "l", "J", "ie", "v", "jj", "m"], "pos_list": ["objectllist", "posingList", "pos2list", "pos_listed", " posinglist", "pos2List", "objectllists", "object_list", "pos_lists", "object_lists", " posinglisted", " pos_status", "pos_status", "poseslc", " pos_listed", "object_l", "poseslist", "pos_List", "pos_lc", " pos_table", "pos2listed", "objectllisted", "pos_table", "posllisted", "objectll", "posestable", " pos_lc", "posinglisted", " pos_List", "posinglist", "posesstatus", "object_listed", " posingList", "pos_l", "posllists", "posll", "posllist"], "pos": ["val", "pres", "min", "pt", "pc", "length", "ps", "Pos", "range", "type", "x", "axis", "source", "po", "t", "param", "end", "form", "point", "no", "tag", "rel", "coord", "len", "position", "obj", "to", "press", "POS", "col", "r", "pack", "diff", "data", "block", "sort", "pass", "loc", "all", "zone", "slot", "time", "ref", "object", "p", "line", "depth", "patch", "unit", "sl", "def", "pointer", "z", "neg", "points", "ass", "prop", "pose", "seq", "start", "pid", "port", "os", "list", "ack", "rot", "spec", "part", "comp", "field", "offset"], "track": ["dr", "seek", "round", "skip", "progress", "rec", "tracks", "token", "coll", "project", "session", "route", "rr", "match", "contact", "type", "work", "transform", "source", "trip", "form", "gap", "tag", "tr", "record", "module", "rank", "zip", "play", "path", "rack", "r", "host", "sort", "hop", "stream", "song", "cost", "tracking", "stage", "thread", "comment", "strip", "package", "group", "Track", "step", "tax", "row", "port", "roll", "road", "ack", "trace", "comp", "field", "sound"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;\n\n    }\n\n}\n", "idx": 17357, "substitutes": {"samples": ["imodels", "ssages", " smodels", "Sacks", "pays", "pongs", "asipes", "summies", " ssample", "pamp", "ssample", "ismodels", "suppiments", "iances", "piments", "isances", "ssamples", " samps", "siments", "iamps", "samp", "ssifiers", "ssaces", " says", "asages", "suppamples", " siments", "packs", "hesamples", "famps", "sances", "Saces", "suppifiers", " sipes", "usamples", "psample", "asamps", "pamples", "sipes", " saces", "fongs", " sacks", "says", " samp", "sample", "pample", "ssiments", "smodels", "pummies", "asample", "famples", "asamples", "sacks", " schanges", "hesamps", "heschanges", "songs", "samps", " sample", "pamps", "asiments", "ssamp", "iamples", " sages", "Samp", "hesays", "fample", "Samps", "Sample", "isiments", "isamples", "saces", "suppamps", "sifiers", "usamps", "pchanges", "iiments", "Samples", " songs", "ssamps", "sages", "ssipes", " sances", "iummies", "ussample", "schanges", "usamp"], "i": ["g", "phi", "di", "inner", "my", "uli", "f", "ri", "xi", "hi", "cli", "x", "u", "qi", "ix", "ci", "li", "in", "api", "bi", "mu", "it", "uri", "d", "mi", "info", "ip", "I", "si", "pi", "multi", "id", "h", "index", "ai", "init", "iv", "iu", "o", "ii", "c", "p", "key", "y", "b", "ki", "slice", "mini", "ui", "gi", "zi", "ami", "fi", "anti", "e", "l", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "fb506e701e9bafa3e0685747c1c98962c52d1962", "target": 1, "func": "static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 17362, "substitutes": {"s": ["is", "g", "cs", "self", "sf", "sys", "f", "session", "ops", "ps", "secondary", "rs", "ds", "js", "t", "ss", "sq", "parts", "d", "ns", "plugins", "i", "tests", "state", "ips", "r", "private", "ls", "es", "o", "params", "gs", "c", "details", "p", "sb", "ts", "ks", "service", "ssl", "fs", "services", "S", "states", "sets", "ses", "e", "os", "l", "hs", "a", "ins", "spec", "its", "sync", "m"], "errp": ["errpc", "errps", "resultp", " errps", "erf", "errP", " errr", "irp", "verr", "rrpre", " errc", " errf", "verps", "rrP", "rrc", "erpc", "resultr", "errpre", "irc", "errf", "irP", "erp", "erps", "verf", "resultpc", "rrp", "resultps", "err", " errpc", "irpre", " errpre", " errP", "errr", "verp", "errc"], "x86_iommu": ["x86_iromo", "x86_iormuit", "x86_uomur", "x86_kommur", "x86_kommu", "x86_kommui", "x86_uiomuit", "x86_iomu", "x86_kommU", "x86_iommur", "x86_uiomu", "x86_iompur", "x86_iommbu", "x86_iromu", "x86_komui", "x86_iommui", "x86_iCommu", "x86_uiommuit", "x86_iCommur", "x86_irombu", "x86_iormu", "x86_uiomus", "x86_iammu", "x86_komuit", "x86_kommuit", "x86_iomur", "x86_uommbu", "x86_iomuit", "x86_iromur", "x86_iompo", "x86_komur", "x86_iomo", "x86_uommo", "x86_iompu", "x86_iombur", "x86_uiommu", "x86_iammur", "x86_uommu", "x86_kommo", "x86_iomui", "x86_iompU", "x86_iombu", "x86_iombo", "x86_uiommur", "x86_komU", "x86_iCommU", "x86_iCommui", "x86_iammus", "x86_iommo", "x86_iormbu", "x86_iombuit", "x86_iomus", "x86_iormo", "x86_iommU", "x86_iormus", "x86_iompui", "x86_uommur", "x86_iommus", "x86_komo", "x86_komu", "x86_uomu", "x86_uomo", "x86_iommuit", "x86_uiommus", "x86_iompuit", "x86_uiomur", "x86_iormur", "x86_uombu", "x86_iomU", "x86_iammuit"]}}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n", "idx": 17370, "substitutes": {"hw": ["hhh", "ow", "lv", "drm", "inst", "haw", "igh", "wm", "sw", "rh", "wb", "craft", "wu", "fw", "hz", "aw", "h", "wx", "ctx", "hop", "w", "him", "ew", "gio", "how", "hm", "kw", "wav", "vc", "hp", "gt", "ih", "iw", "hh", "gp", "eth", "nw", " HW", "gg", "wo", "tw", "mm", "rw", "ht"], "as": ["is", "asu", "nas", "aws", "ap", "sa", "ars", "ais", "ac", "asc", "ans", "inas", "ays", "aw", "ar", "ai", "asa", "AS", "an", "gs", "was", "acs", "ach", "ay", "las", "am", "ass", "asse", "As", "os", "a", "ast", "ams", "pas", "ras", "au"]}}
{"project": "FFmpeg", "commit_id": "fe6eea99efac66839052af547426518efd970b24", "target": 1, "func": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n\n{\n\n    NSVContext *nsv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st[2] = {NULL, NULL};\n\n    NSVStream *nst;\n\n    AVPacket *pkt;\n\n    int i, err = 0;\n\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n\n    uint32_t vsize;\n\n    uint16_t asize;\n\n    uint16_t auxsize;\n\n\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\n\n\nnull_chunk_retry:\n\n    if (pb->eof_reached)\n\n        return -1;\n\n\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n\n        err = nsv_resync(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state == NSV_FOUND_NSVS)\n\n        err = nsv_parse_NSVs_header(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n\n        return -1;\n\n\n\n    auxcount = avio_r8(pb);\n\n    vsize = avio_rl16(pb);\n\n    asize = avio_rl16(pb);\n\n    vsize = (vsize << 4) | (auxcount >> 4);\n\n    auxcount &= 0x0f;\n\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n\n           auxcount, vsize, asize);\n\n    /* skip aux stuff */\n\n    for (i = 0; i < auxcount; i++) {\n\n        uint32_t av_unused auxtag;\n\n        auxsize = avio_rl16(pb);\n\n        auxtag = avio_rl32(pb);\n\n        avio_skip(pb, auxsize);\n\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n\n    }\n\n\n\n    if (pb->eof_reached)\n\n        return -1;\n\n    if (!vsize && !asize) {\n\n        nsv->state = NSV_UNSYNC;\n\n        goto null_chunk_retry;\n\n    }\n\n\n\n    /* map back streams to v,a */\n\n    if (s->nb_streams > 0)\n\n        st[s->streams[0]->id] = s->streams[0];\n\n    if (s->nb_streams > 1)\n\n        st[s->streams[1]->id] = s->streams[1];\n\n\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n\n        nst = st[NSV_ST_VIDEO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n\n        av_get_packet(pb, pkt, vsize);\n\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n\n        pkt->dts = nst->frame_offset;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        for (i = 0; i < FFMIN(8, vsize); i++)\n\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n\n                   i, pkt->data[i]);\n\n    }\n\n    if(st[NSV_ST_VIDEO])\n\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n\n\n    if (asize && st[NSV_ST_AUDIO]) {\n\n        nst = st[NSV_ST_AUDIO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n\n        /* read raw audio specific header on the first audio chunk... */\n\n        /* on ALL audio chunks ?? seems so! */\n\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n\n            uint8_t bps;\n\n            uint8_t channels;\n\n            uint16_t samplerate;\n\n            bps = avio_r8(pb);\n\n            channels = avio_r8(pb);\n\n            samplerate = avio_rl16(pb);\n\n            if (!channels || !samplerate)\n\n                return AVERROR_INVALIDDATA;\n\n            asize-=4;\n\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                   bps, channels, samplerate);\n\n            if (fill_header) {\n\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n\n                if (bps != 16) {\n\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n\n                }\n\n                bps /= channels; // ???\n\n                if (bps == 8)\n\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n\n                samplerate /= 4;/* UGH ??? XXX */\n\n                channels = 1;\n\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                       bps, channels, samplerate);\n\n            }\n\n        }\n\n        av_get_packet(pb, pkt, asize);\n\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n\n            /* on a nsvs frame we have new information on a/v sync */\n\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n\n                   nsv->avsync, pkt->dts);\n\n        }\n\n        nst->frame_offset++;\n\n    }\n\n\n\n    nsv->state = NSV_UNSYNC;\n\n    return 0;\n\n}\n", "idx": 17381, "substitutes": {"s": ["g", "is", "cs", "self", "server", "sf", "client", "f", "session", "sa", "http", "proc", "ps", "sys", "ds", "south", "t", "ss", "sq", "sr", "ns", "plugins", "n", "si", "support", "storage", "r", "native", "parser", "space", "span", "o", "ctx", "us", "gs", "c", "p", "sb", "sci", "ts", "service", "sie", "ssl", "b", "xs", "sl", "sup", "su", "sim", "services", "S", "bis", "sg", "ses", "e", "sv", "sym", "sc", "se", "spec", "qs", "v"], "fill_header": ["v_header", " enc_header", "v_version", "v_channel", " enc_channel", " enc_back", " enc_version", "v_back"], "nsv": ["lsv", "tsf", "netsvs", "nesf", "csver", "csvs", "lsvi", "csvi", "nsvin", "nsk", "consk", " nsvp", " nstv", "nesV", "csV", "ssv", "ksf", " nsf", "nsvi", "ssvin", "nastv", "msv", "csf", "xsk", "nasvp", "lsvc", "ysvp", "consv", "nsvp", "netssv", "ssvp", "nasf", "snv", "nsvs", "msvp", "xsv", "nesvi", "xsvc", "NSvc", "nesv", "NSv", "lsvs", "ysvin", "nsf", "lssv", "consver", "NSvs", "ksvs", "sntv", "nsV", "tsv", "nsvc", "ysv", "msvs", "tsvs", "netsv", "csvp", "snvp", "lsV", "netsf", "lsvp", "nasv", "lsf", "nstv", "tsvp", "nsver", "consvc", "ysvs", "nssv", "csvc", "xsvs", "msf", "NSf", "ksv", "csvin", "kssv", "ssvs", "csv", "xsver", "csk", "snf", "xsf"], "pb": ["sf", "PB", "bs", "pc", "uf", "pt", "tp", "wp", "pd", "phrase", "ppa", "bc", "queue", "asm", "lp", "jp", "bh", "api", "wb", "py", "np", "bb", "bp", "pm", "hub", "rob", "si", "bm", "obj", "cpp", "pg", "types", "db", "pub", "pl", "pp", "pa", "summary", "vp", "platform", "parser", "eb", "phys", "ctx", "typ", "rb", "sb", "p", "fp", "cv", "b", "ssl", "prot", "pkg", "proc", "prop", "nb", "cb", "ab", "gb", "ses", "bf", "dp", "port", "pro", "utils", "ub", "mp", "kb", "lb", "fc", "plugin", "fb"], "st": ["sn", "sa", "src", "sp", "pc", "inst", "rest", "ss", "sw", "St", "storage", "sb", "std", "ost", "store", "sl", "stage", "cr", "ST", "ft", "ct", "sts", "fe", "ast", "sth", "sc", "se"], "nst": ["nct", "nssc", "nsct", " nct", "nsc", "nsst", "nsste", " nsc", " nste", "pct", "pste", "pst", "nste", "psc"], "pkt": ["Pkt", "Pkg", "ppst", " pkg", " pst", "ppct", "ppkt", "Pst", "pct", "ppkg", "pst", "Pct", "pkg", " pct"], "i": ["phi", "di", "f", "ri", "xi", "cli", "hi", "type", "x", "qi", "ix", "ci", "li", "t", "abi", "eni", "bi", "uri", "it", "ji", "d", "mu", "info", "n", "ip", "base", "I", "pi", "ti", "multi", "id", "si", "code", "r", "ai", "index", "iu", "o", "esi", "ii", "c", "k", "p", "y", "ind", "b", "ki", "z", "slice", "mini", "err", "ui", "ni", "zi", "gi", "count", "fi", "ami", "yi", "e", "start", "l", "oi", "ie", "ini", "v", "mi", "j", "m"], "auxcount": ["afCount", "cfcount", " auxiliaryCount", "auxsum", "aultsum", "afsize", " auxCount", " auxiliarysize", "uxcheck", " auxcheck", "auxCount", "cfCount", " auxiliarylast", " auxsum", "aulength", "aultdepth", " auxiliaryall", "auxall", "uxcount", "uxsize", " auxiliarydepth", " auxdepth", "uxall", "auxlast", "auxdepth", " auxlast", "auCount", "aucount", "afcount", "aultsize", " auxlength", "cfsize", "auxcheck", " auxall", " auxiliarylength", "uxCount", " auxiliarysum", "uxlast", "auxlength", " auxiliarycount", "aultcount", "ausize", " auxiliarycheck"], "vsize": ["nvwidth", "vcapacity", "avscale", "vwidth", "cvbytes", "avsize", "vshape", " vshape", "vgrow", "tvwidth", "avize", "lvshape", "Vscale", "vpscale", "svscale", "vSize", " vcount", " vsmall", "vpsize", "vbytes", "vsmall", "avcenter", "svcapacity", "vpname", "vccenter", "auxgrow", "auxwidth", " vwidth", "evSize", "Vcount", "cvname", " vscale", " vbytes", "svsmall", "vcenter", "VSize", " vcenter", "nvname", "cvsize", "nvgrade", "vscale", "evsize", "nvgrow", "Vsize", " vize", "nvize", "nvsize", "vcize", "nvscale", "svsize", " vcapacity", "vcsize", "auxize", "cvgrade", "tvscale", "vpgrade", "vize", "cvscale", "vname", "evcount", "evscale", "lvcapacity", "cvsmall", "lvsize", "tvname", "tvsize", "vcount", "vgrade", " vname", " vgrow", "svshape", "lvscale", " vSize", "vcscale", "svbytes"], "asize": ["g", "asized", "asiz", " asizable", "ASsize", "asizable", "rassize", "this", "assize", "ASizable", " asized", "ASIZE", "end", "askssize", "ASized", " asIZE", "rasizable", "arsize", "_", "rasIZE", "id", "arsized", "r", " assize", " aspect", "aspect", "write", "Aspect", "asIZE", "rasize", "all", "Asized", "Assize", "asksized", "arspect", "ASiz", "ASize", "asksiz", "ansiz", "ansize", "ansized", "anssize", "arssize", "Asize", "asksize"], "auxsize": ["aushell", " auxSize", " auxiliaryize", "auxsum", "afsize", "aultsum", " auxcore", " auxiliarysize", "auxcore", "vcore", " auxsum", "actualsize", "luxshell", "afsum", "uxsize", " auxiliarycore", "luxsize", "auxhandle", " auxiliarystyle", " auxize", "uxsum", "auxstyle", "actualsum", " auxshell", "vhandle", "aucount", "auxSize", " auxiliaryhandle", "afcount", "aultsize", "auxshell", "afize", "auSize", "uxstyle", " auxhandle", "auxize", " auxiliarysum", "luxcount", "aultcount", "ausize", "aultize", "vize", "luxSize", "actualstyle"], "av_unused": ["av_lensec", "av_uncuse", "av_uncinitialized", "av_unsuse", "av_uncsec", "av_unuse", "av_unsec", "av_unsused", "av_uninitialized", "av_unsinitialized", "av_lenuse", "av_uncused", "av_leninitialized", "av_lenused", "av_unssec"], "NSVStream": ["NSVTStream", "NSVConnection", "NSVAObject", "CSVObject", "CSVLChannel", "CSVStream", "NSVLChannel", "NSVTObject", "NSVLConnection", "NSVObject", "NSVChannel", "NSVAStream", "CSVLConnection", "NSVLObject", "CSVConnection", "NSVAConnection", "CSVLStream", "NSVTChannel", "NSVTConnection", "CSVChannel", "NSVLStream", "CSVLObject", "NSVAChannel"], "priv_data": ["priv2txt", "private_txt", "private_ctx", "priv_txt", "priv_record", "privprectx", "priv_ctx", "private_data", "privpredata", "priv2ctx", "privpretxt", "priv2record", "private_record", "priv2data", "privprerecord"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411, "substitutes": {"f": ["g", "self", "fx", "sf", "df", "x", "t", "form", "front", "d", "fo", "feed", "info", "fm", "fd", "i", "fw", "h", "r", "fr", "fen", "o", "tf", "w", "cf", "xf", "c", "k", "file", "fp", "p", "F", "ref", "rf", "b", "fa", "fs", "elf", "fn", "bf", "e", "l", "fe", "fc", "v", "fb", "m"], "opaque": ["oboc", "Ooc", "ipoc", "ophole", "ipfac", "iphole", "ipaque", "obfac", "opoc", "obhole", "Oaque", "opfac", "Ofac", "obaque", "Ohole"], "ret": ["RET", "val", "reply", "let", "cat", "result", "hard", "match", "alt", "part", "res", "success", "orig", "reg", "back", "valid", "error", "sr", "fail", "len", "fun", "mt", "bare", "red", "reset", "pet", "fin", "db", "fit", "code", "art", "data", "pat", "rev", "pass", "rets", "iter", "att", "ext", "ref", "det", "nt", "rb", "active", "gt", "post", "rf", "def", "flag", "re", "value", "true", "en", "ft", "run", "num", "Ret", "bf", "url", "bad", "arg", "lit", "rt", "out", "rep"]}}
{"project": "FFmpeg", "commit_id": "51e1cc16d3e89a785f3231065c4eb898a0401a93", "target": 1, "func": "matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            assert(size>0); // size <=3 is checked before size-=3 above\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n                uint8_t *pkt_data = data;\n                if (matroska->tracks[track]->encoding_scope & 1) {\n                    switch (matroska->tracks[track]->encoding_algo) {\n                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n                        offset = matroska->tracks[track]->encoding_settings_len;\n                        break;\n                    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n                        pkt_data = NULL;\n                        do {\n                            ilen = lace_size[n];\n                            olen = pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data,\n                                                  pkt_size+LZO_OUTPUT_PADDING);\n                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);\n                        if (result) {\n                            continue;\n                        }\n                        pkt_size -= olen;\n                        break;\n#ifdef CONFIG_ZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n                        z_stream zstream = {0};\n                        pkt_data = NULL;\n                        if (inflateInit(&zstream) != Z_OK)\n                            continue;\n                        zstream.next_in = data;\n                        zstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            zstream.avail_out = pkt_size - zstream.total_out;\n                            zstream.next_out = pkt_data + zstream.total_out;\n                            result = inflate(&zstream, Z_NO_FLUSH);\n                        } while (result==Z_OK && pkt_size<10000000);\n                        pkt_size = zstream.total_out;\n                        inflateEnd(&zstream);\n                        if (result != Z_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n#ifdef CONFIG_BZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n                        bz_stream bzstream = {0};\n                        pkt_data = NULL;\n                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n                            continue;\n                        bzstream.next_in = data;\n                        bzstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n                            result = BZ2_bzDecompress(&bzstream);\n                        } while (result==BZ_OK && pkt_size<10000000);\n                        pkt_size = bzstream.total_out_lo32;\n                        BZ2_bzDecompressEnd(&bzstream);\n                        if (result != BZ_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n                    }\n                }\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, pkt_size+offset) < 0) {\n                    av_free(pkt);\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                if (offset)\n                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n                memcpy (pkt->data+offset, pkt_data, pkt_size);\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n                matroska_queue_packet(matroska, pkt);\n            }\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "idx": 17412, "substitutes": {"track": ["dr", "seek", "sn", "round", "skip", "rec", "tracks", "token", "session", "coll", "mode", "project", "quant", "route", "match", "report", "type", "work", "transform", "trip", "form", "gap", "tag", "tr", "record", "train", "nn", "rank", "play", "path", "rack", "tt", "index", "host", "sort", "hop", "call", "stream", "course", "time", "cost", "patch", "tracking", "gro", "stage", "thread", "dist", "strip", "m", "Track", "race", "step", "month", "group", "tax", "check", "port", "roll", "claim", "road", "mm", "trace", "ack", "order", "event", "field", "sync", "info"], "st": ["stop", "str", "sn", "rec", "session", "sa", "src", "sp", "stab", "pt", "inst", "rest", "t", "ss", "end", "sw", "d", "station", "St", "stack", "est", "play", "ist", "state", "tt", "fr", "stream", "nt", "sb", "s", "stim", "std", "tmp", "service", "nd", "ost", "sl", "stage", "ST", "sta", "ptr", "dist", "step", "ct", "sts", "start", "fe", "ast", "sth", "sc", "ste", "art"], "pkt": ["Pkt", "Pkg", "apkt", " pkg", " pst", "apkg", "Pst", "pct", "apst", "apct", "pst", "Pct", "pkg", " pct"], "origdata": ["margdata", "Origwindow", "realata", "origData", "Origdata", " origata", "OrigData", " origwindow", "originalData", "margData", " origdat", "originalwindow", " origfile", "originaldat", "margfile", "realdat", "originaldata", "Origata", "margmedia", "origfile", "Origdat", "origdat", "margdat", "realdata", "origwindow", " origData", "Origmedia", "realData", "Origfile", "origata", " origmedia", "origmedia"], "block_time": ["block\u00b7rate", "update_size", "block_value", "lock_speed", "block_length", "update_value", "lock_times", "block_times", "update_time", "update\u00b7rate", "update\u00b7time", "update\u00b7size", "update_rate", "block\u00b7value", "block_rate", "block_size", "update\u00b7value", "lock_length", "block_speed", "lock_time", "block\u00b7size", "block\u00b7time"], "lace_size": ["blockmaxsize", "blockmaxlen", "lace_len", "lace_time", "block_style", "blockmaxtime", "blockmaxstyle", "block_size", "block_len", "lace_style"], "n": [" ng", "g", "sn", "cn", "f", "number", "name", "nc", "u", " ni", "t", "ny", "d", "no", "ns", "len", "i", "j", "nn", "span", "o", "N", "c", "k", "nt", "p", "s", "pos", "y", "nr", "b", "z", "mn", "en", "ni", "nb", "ne", "count", "l", "dn", "nu", "v", "size", "m"], "flags": ["links", "frames", "lines", "lag", "tracks", "ops", "ids", "times", "feat", "ds", "dates", "vals", "alls", "parts", "len", "reads", "fd", "args", "ints", "locks", "types", "tests", "bits", "ips", "status", "codes", "FLAG", "data", "strings", "errors", "members", "files", "atts", "Flags", "details", "comments", "flag", "fs", "stats", "bytes", "ags", "steps", "states", "fields", "options", "utils", "acks", "rows", "features", "checks", "mods", "mask", "settings"], "num": ["batch", "f", "du", "number", "inc", "node", "nc", "Num", "name", "net", "tu", "dim", "common", "mu", "orig", "form", "no", "coord", "position", "nom", "len", "multi", "id", "uni", "max", "index", "mult", "umi", "con", "uu", "sort", "sum", "NUM", "loc", "pos", "unit", "b", "su", "ni", "nb", "count", "fn", "norm", "nm", "nu", "mon", "bin", "offset"], "stream_index": ["trackskey", "record_id", "pipeflowindex", "stream_ind", "streamingposition", "pipe_index", "streamsindex", "record_loc", "streamflownum", "stream_num", "streamxprefix", "record_index", "track_index", " stream_prefix", "streamerind", "stream_conn", "streamingnumber", "stream_target", "pipe_target", "stream_address", "stream_loc", "streamskey", "streamflowtarget", "track_key", "streamingindex", "track_position", "streamsinstance", "tracksinstance", "pipe_ind", "track_instance", "streamerindex", "pipeflownum", "flow_target", "stream_number", "streamingind", "streamxnumber", "tracksindex", "stream_instance", "record_conn", "track_ind", "pipeflowind", "flow_address", "streamingprefix", "streamxindex", "stream_position", "stream_key", "pipe_num", "stream_id", "stream_prefix", "streamflowindex", " stream_number", "streamertarget", "flow_index", "streamernum", "pipeflowtarget", "flow_key", "streamflowind"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)\n\n{\n\n    c->high = 255;\n\n    c->bits = -16;\n\n    c->buffer = buf;\n\n    c->end = buf + buf_size;\n\n    c->code_word = bytestream_get_be24(&c->buffer);\n\n}\n", "idx": 17413, "substitutes": {"c": ["g", "cs", "cm", "dc", "f", "pc", "unc", "nc", "ac", "u", "cache", "ci", "gc", "cur", "t", "d", "n", "ch", "enc", "i", "con", "o", "ctx", "ec", "lc", "call", "ca", "cf", "oc", "ce", "p", "cc", "ic", "cy", "vc", "b", "cr", "cus", "tc", "ct", "rc", "mc", "e", "l", "C", "cu", "xc", "sc", "fc", "v", "m"], "buf": ["batch", "cp", "vec", "bd", "length", "src", "uf", "uc", "queue", "cache", "bc", "array", "cur", "buffer", "Buffer", "pool", "wb", "bb", "feed", "fd", "pb", "padding", "img", "data", "binary", "rb", "cf", "ref", "xff", "sb", "fp", "cv", "b", "home", "alloc", "cb", "rc", "ab", "gb", "seq", "count", "num", "port", "text", "dest", "box", "buff", "utf", "bin", "fb", "br"], "buf_size": ["buf_len", "queue_len", "queue_size", "queue_low", " buf_sum", "buf_low", "buf__len", "buf__low", "buf_sum", " buf_len", "buf__size"]}}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "int vring_pop(VirtIODevice *vdev, Vring *vring,\n\n              VirtQueueElement **p_elem)\n\n{\n\n    struct vring_desc desc;\n\n    unsigned int i, head, found = 0, num = vring->vr.num;\n\n    uint16_t avail_idx, last_avail_idx;\n\n    VirtQueueElement *elem = NULL;\n\n    int ret;\n\n\n\n    /* If there was a fatal error then refuse operation */\n\n    if (vring->broken) {\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* Check it isn't doing very strange things with descriptor numbers. */\n\n    last_avail_idx = vring->last_avail_idx;\n\n    avail_idx = vring->vr.avail->idx;\n\n    barrier(); /* load indices now and not again later */\n\n\n\n    if (unlikely((uint16_t)(avail_idx - last_avail_idx) > num)) {\n\n        error_report(\"Guest moved used index from %u to %u\",\n\n                     last_avail_idx, avail_idx);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* If there's nothing new since last we looked. */\n\n    if (avail_idx == last_avail_idx) {\n\n        ret = -EAGAIN;\n\n        goto out;\n\n    }\n\n\n\n    /* Only get avail ring entries after they have been exposed by guest. */\n\n    smp_rmb();\n\n\n\n    /* Grab the next descriptor number they're advertising, and increment\n\n     * the index we've seen. */\n\n    head = vring->vr.avail->ring[last_avail_idx % num];\n\n\n\n    elem = g_slice_new(VirtQueueElement);\n\n    elem->index = head;\n\n    elem->in_num = elem->out_num = 0;\n\n    \n\n    /* If their number is silly, that's an error. */\n\n    if (unlikely(head >= num)) {\n\n        error_report(\"Guest says index %u > %u is available\", head, num);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    if (vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(&vring->vr) = vring->vr.avail->idx;\n\n    }\n\n\n\n    i = head;\n\n    do {\n\n        if (unlikely(i >= num)) {\n\n            error_report(\"Desc index is %u > %u, head = %u\", i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        if (unlikely(++found > num)) {\n\n            error_report(\"Loop detected: last one at %u vq size %u head %u\",\n\n                         i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        desc = vring->vr.desc[i];\n\n\n\n        /* Ensure descriptor is loaded before accessing fields */\n\n        barrier();\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            ret = get_indirect(vring, elem, &desc);\n\n            if (ret < 0) {\n\n                goto out;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        ret = get_desc(vring, elem, &desc);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        i = desc.next;\n\n    } while (desc.flags & VRING_DESC_F_NEXT);\n\n\n\n    /* On success, increment avail index. */\n\n    vring->last_avail_idx++;\n\n    *p_elem = elem;\n\n    return head;\n\n\n\nout:\n\n    assert(ret < 0);\n\n    if (ret == -EFAULT) {\n\n        vring->broken = true;\n\n    }\n\n    if (elem) {\n\n        vring_unmap_element(elem);\n\n        g_slice_free(VirtQueueElement, elem);\n\n    }\n\n    *p_elem = NULL;\n\n    return ret;\n\n}\n", "idx": 17428, "substitutes": {"vdev": ["hdevice", "vde", " vdevice", "gdevice", " vde", "ldevice", "evdev", "gpack", "hbus", "evdevice", "gdev", "evde", "hdev", " vpack", "hde", "gcam", "lcam", "vpack", "vdevice", " vcam", "ldev", "vcam", "vbus", " vbus", "lpack", "evbus"], "vring": ["vrings", "lding", "lrings", "Vping", "flling", "gping", " vstring", "gstring", " vsetting", "vringe", "flray", " vray", "gray", " vlic", "vstring", "Vsetting", "avping", "lsetting", "grings", "Vstring", "varining", " vringe", "flring", "avtesting", "vling", "varring", "avring", "evding", "evling", "lstring", "vsetting", "gding", "varringe", "evring", "pray", "avding", "lray", "pring", "svray", "vlic", "varding", "avining", " vping", "pding", "lling", "flding", "plic", "lring", "psetting", "gring", "vping", "Vring", "lping", "pping", "avray", "vray", "vtesting", "evray", " vrings", "Vray", " vding", "svtesting", "svring", " vining", "vining", "Vlic", "avringe", "Vtesting", "vding", "svping"], "p_elem": ["p_elements", "p_eelement", "p_belem", "p_selement", "p_element", "p_eelev", "p_elev", "p_belements", "p_selev", "p_selem", "p_eelem", "p_selements", "p_belev", "p_belement", "p_eelements"], "desc": ["disc", "class", "rec", "dc", "src", "name", "oe", "end", "req", "reg", "description", "asc", "prev", "child", "obj", "Desc", "config", "id", "des", "code", "dict", "summary", "dir", "diff", "doc", "entry", "rev", "ec", "meta", "sum", "next", "loc", "ext", "ript", "de", "cv", "ind", "def", "dist", "esc", "Description", "comment", "dep", "sel", "rc", "dest", "seq", "text", "sub", "sc", "info"], "i": ["phi", "di", "f", "ri", "xi", "hi", "type", "x", "qi", "u", "ix", "ci", "in", "li", "t", "eni", "bi", "uri", "d", "n", "ip", "I", "pi", "si", "multi", "id", "ai", "index", "iu", "ii", "c", "p", "y", "ind", "b", "ui", "ni", "zi", "num", "fi", "yi", "e", "start", "l", "io", "ie", "ini", "mi", "j"], "head": ["set", "header", "inner", "check", "client", "du", "length", "f", "none", "ck", "dc", "rest", "name", "x", "ix", "inc", "in", "cur", "load", "off", "conn", "end", "form", "back", "front", "n", "root", "view", "position", "before", "id", "max", "index", "h", "init", "input", "doc", "block", "us", "target", "call", "HEAD", "miss", "gen", "c", "reason", "post", "body", "depth", "pos", "ind", "thread", "heads", "find", "run", "count", "num", "Head", "rc", "row", "start", "commit", "then", "fix", "mm", "ack", "push", "tail"], "avail_idx": ["avail_ipx", "avail_Idz", "avail_endxx", "avail_idz", "avail_idec", "avail_idpe", "avail_countpe", "avail_ipz", "avail_idxx", "avail_idsxc", "avail_idX", "avail_midy", "avail_endX", "avail_Idc", "avail_endy", "avail_timex", "avail_idsc", "avail_idexc", "avail_ideX", "avail_countX", "avail_idsx", "avail_timexx", "avail_countz", "avail_midx", "avail_idxc", "avail_idy", "avail_ipX", "avail_endxs", "avail_Idy", "avail_idc", "avail_countx", "avail_idex", "avail_endz", "avail_midxx", "avail_idxs", "avail_timey", "avail_midxs", "avail_IdX", "avail_Idpe", "avail_endx", "avail_idsX", "avail_ipy", "avail_timexs", "avail_endc", "avail_Idx"], "last_avail_idx": ["last_avail_endx", "last_avail_idex", "last_avail_Idx", "last_avail_Idy", "last_avail_endX", "last_avail_idc", "last_avail_idez", "last_avail_inc", "last_avail_Idz", "last_avail_inX", "last_avail_ideX", "last_avail_idy", "last_avail_idec", "last_avail_idew", "last_avail_idey", "last_avail_IdX", "last_avail_idw", "last_avail_endz", "last_avail_idz", "last_avail_endy", "last_avail_endc", "last_avail_iny", "last_avail_idX", "last_avail_inz", "last_avail_inw", "last_avail_Idc", "last_avail_inx"], "elem": ["oelee", "gelement", "selde", " eject", "selev", "oeler", "Elev", "oelegate", "gelem", "Elee", "jeler", " element", "aelev", "eject", "elegate", "oelem", " elde", "eleg", "jelegate", "selem", "nelem", "eli", "eler", "elev", " eli", "seli", "elde", "oelde", "seject", "seleg", "oeject", " eler", "Elem", " eleg", "jeject", "geject", " elee", "aeject", "oelement", "nelee", "nelev", "aelem", "Eleg", "elee", "element", "aelement", "jelem", " elev", " elegate", "gelev", "Element", "selee", "selement", "nelement", "Eli"], "ret": ["RET", "val", "bit", "vet", "let", "cat", "pt", "result", "match", "lt", "alt", "feat", "res", "success", "conn", "reg", "req", "red", "len", "fun", "mt", "ut", "fin", "fit", "rev", "pass", "rets", "att", "ref", "det", "nt", "gt", "def", "resp", "re", "fat", "ft", "ct", "rc", "num", "Ret", "mem", "opt", "lit", "arg", "rt", "part", "art", "info"], "found": ["received", "seen", "f", "length", "loaded", "number", "sent", "inc", "new", "first", "success", "expected", "old", "front", "finder", "len", "fd", "index", "used", "iter", "loc", "pos", "Found", "missing", "current", "search", "defined", "done", "find", "count", "given", "fi", "fe", "finding", "confirmed", "failed", "lost"]}}
{"project": "FFmpeg", "commit_id": "bc29acdc76fdbf70700cdc2f85fc2afb46e19e47", "target": 0, "func": "static int ftp_connect_control_connection(URLContext *h)\n\n{\n\n    char buf[CONTROL_BUFFER_SIZE], opts_format[20];\n\n    int err;\n\n    AVDictionary *opts = NULL;\n\n    FTPContext *s = h->priv_data;\n\n    const int connect_codes[] = {220, 0};\n\n\n\n    s->conn_control_block_flag = 0;\n\n\n\n    if (!s->conn_control) {\n\n        ff_url_join(buf, sizeof(buf), \"tcp\", NULL,\n\n                    s->hostname, s->server_control_port, NULL);\n\n        if (s->rw_timeout != -1) {\n\n            snprintf(opts_format, sizeof(opts_format), \"%d\", s->rw_timeout);\n\n            av_dict_set(&opts, \"timeout\", opts_format, 0);\n\n        } /* if option is not given, don't pass it and let tcp use its own default */\n\n        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,\n\n                         &s->conn_control_interrupt_cb, &opts);\n\n        av_dict_free(&opts);\n\n        if (err < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Cannot open control connection\\n\");\n\n            return err;\n\n        }\n\n\n\n        /* consume all messages from server */\n\n        if (!ftp_status(s, NULL, connect_codes)) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP server not ready for new users\\n\");\n\n            err = AVERROR(EACCES);\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_auth(s)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP authentication failed\\n\");\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_type(s)) < 0) {\n\n            av_dlog(h, \"Set content type failed\\n\");\n\n            return err;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17439, "substitutes": {"h": ["g", "dh", "f", "http", "hi", "u", "oh", "sh", "bh", "eh", "t", "q", "kh", "uh", "rh", "d", "H", "hw", "th", "r", "hl", "o", "hr", "w", "him", "c", "k", "p", "ha", "hand", "he", "hp", "gh", "b", "ih", "hh", "home", "hd", "handler", "e", "ph", "l", "hs", "history", "ah", "hm", "ht", "v", "host", "m"], "buf": ["batch", "vec", "src", "uf", "cmd", "uc", "bc", "queue", "array", " buffer", "bh", "pad", "off", "buffer", "Buffer", "wb", "conv", "fun", "fd", "config", "ff", "path", "pb", "img", "addr", "data", "raw", "block", "binary", "ctx", "loc", "rb", "fp", "bag", "cv", "tmp", "func", "b", "pkg", "msg", "prop", "la", "cb", "rc", "ab", "seq", "bf", "text", "port", "lb", "box", "buff", "v", "fb", "br"], "opts_format": ["opt_type", "opts_space", "opters_length", "optr_function", "optr_form", "opcs_Format", "optr_format", "opts_printf", "opts_Format", "opcs_format", "opt_format", "opcs_printf", "opts_type", "opt_space", "opts_form", "opters_format", "opts_function", "opts_length", "opters_form"], "err": ["val", " self", "inner", "Er", "off", "test", "magic", "or", "ar", "code", "r", "der", "ee", "mr", "content", "cr", "resp", "attr", "erer", "acer", "order", "dr", "hide", "server", "icer", "later", "temp", "kr", "req", "rh", "fee", "ir", "message", "dev", "user", "rag", "late", "var", "msg", "num", "url", "ler", "bug", "ver", "yr", " error", " len", "orig", "error", "aster", "id", " resp", "iter", "gr", "ind", "far", "er", "Error", "ev", "arr", "ah", "orr", "go", "str", "rr", "result", "type", "runner", "lr", " rc", "len", "ise", "ner", "more", " result", "doc", "reader", "orer", "ec", "loc", "notice", " Err", "her", "nr", "try", "nor", "count", "e", "fy", "pr"], "opts": [" opt", "operts", "opls", "OPters", "optcs", "opter", "OPts", "opters", "ops", "OPtr", "optr", "roptd", "ottr", "OPter", "opttr", "otts", "opcs", " opls", "optter", "ropts", " copters", "operter", "ott", "operters", "opert", " copls", "rops", "OPtd", "optters", "optt", "OPt", " copts", "optd", "otcs", "OPcs", "OPs", " opters", " copt", "opt", "optls", "ropt", "optts", "opttd"], "s": ["g", "is", "ssh", "cs", "self", "f", "sys", "ops", "aws", "http", "ps", "x", "rs", "js", "sh", "t", "ss", "sq", "d", "ns", "n", "site", "si", "args", "i", "j", "r", "ls", "es", "o", "ctx", "us", "w", "an", "gs", "conf", "c", "p", "sb", "y", "service", "ssl", "b", "sl", "xs", "su", "fs", "services", "home", "stats", "S", "m", "sg", "ses", "e", "os", "l", "sets", "sym", "a", "spec", "ds", "qs", "v", "sync", "settings"], "connect_codes": ["connect_errors", "connect_chains", "conn_codes", "connectallstatus", "conn_ids", "connect_status", "connect_code", "connectallcode", "conn_status", "conn_chains", "connectallids", "connectionchains", "connect_ids", "connectioncodes", "conn_errors", "connectioncode", "connectallcodes", "connectionerrors", "conn_code"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449, "substitutes": {"dev": ["di", "DEV", "grad", "temp", "mod", "dd", "pad", "ad", "plug", "end", "error", "d", "test", "valid", "gd", "hw", "enc", "pub", "img", "diff", "Dev", "engine", "w", "conf", "app", "de", "var", "cam", "gu", "def", "comment", "dem", "priv", "ev", "bus", "die", "mem", "driver", "bug", "device", "rad", "debug", "adv", "ver", "info"], "data": ["val", "shift", "src", "cache", "parent", "DATA", "window", "ad", "pad", "buffer", "d", "Data", "base", "address", "index", "img", "input", "addr", "reader", "next", "read", "pos", "da", "def", "bytes", "zero", "bus", "dat", "start", "a", "device", "empty", "arr", "size", "offset"], "buf": ["batch", "lim", "vec", "length", "src", "uf", "cmd", "bc", "queue", "window", "off", "orig", "buffer", "base", "fd", "aux", "config", "db", "ff", "addr", "raw", "ctx", "cap", "loc", "rb", "ref", "fp", "bag", "func", "b", "bytes", "cb", "seq", "mem", "lb", "buff", "v", "bound", "alloc"], "len": ["lim", "val", "str", "f", "length", "lan", "bin", "name", "Len", "off", "el", "lf", "n", "base", "fd", "fun", "enc", "fin", "ff", "cl", "addr", "block", "cap", "fl", "all", "nt", "line", "pos", "ind", "z", "en", "la", "num", "fn", "seq", "mem", "l", "ln", "size", "offset"]}}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static int is_intra_more_likely(ERContext *s)\n\n{\n\n    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;\n\n\n\n    if (!s->last_pic.f || !s->last_pic.f->data[0])\n\n        return 1; // no previous frame available -> use spatial prediction\n\n\n\n    undamaged_count = 0;\n\n    for (i = 0; i < s->mb_num; i++) {\n\n        const int mb_xy = s->mb_index2xy[i];\n\n        const int error = s->error_status_table[mb_xy];\n\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n\n            undamaged_count++;\n\n    }\n\n\n\n    if (s->avctx->codec_id == AV_CODEC_ID_H264 && s->ref_count <= 0)\n\n        return 1;\n\n\n\n    if (undamaged_count < 5)\n\n        return 0; // almost all MBs damaged -> use temporal prediction\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    // prevent dsp.sad() check, that requires access to the image\n\n    if (CONFIG_MPEG_XVMC_DECODER    &&\n\n        s->avctx->xvmc_acceleration &&\n\n        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)\n\n        return 1;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs\n\n    is_intra_likely = 0;\n\n\n\n    j = 0;\n\n    for (mb_y = 0; mb_y < s->mb_height - 1; mb_y++) {\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int error;\n\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n\n\n            error = s->error_status_table[mb_xy];\n\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n\n                continue; // skip damaged\n\n\n\n            j++;\n\n            // skip a few to speed things up\n\n            if ((j % skip_amount) != 0)\n\n                continue;\n\n\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n\n                int *linesize = s->cur_pic.f->linesize;\n\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n\n                    // FIXME\n\n                } else {\n\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n\n                }\n\n                is_intra_likely += s->mecc->sad[0](NULL, last_mb_ptr, mb_ptr,\n\n                                                   linesize[0], 16);\n\n                is_intra_likely -= s->mecc->sad[0](NULL, last_mb_ptr,\n\n                                                   last_mb_ptr + linesize[0] * 16,\n\n                                                   linesize[0], 16);\n\n            } else {\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n\n                   is_intra_likely++;\n\n                else\n\n                   is_intra_likely--;\n\n            }\n\n        }\n\n    }\n\n    return is_intra_likely > 0;\n\n}\n", "idx": 17452, "substitutes": {"s": ["g", "self", "sites", "session", "uns", "secondary", "js", "r", "gs", "conf", "c", "ssl", "b", "su", "fs", "stats", "sets", "a", "ins", "qs", "m", "server", "sf", "http", "ns", "site", "si", "your", "es", "als", "us", "sb", "p", "ts", "ks", "current", "services", "sv", "l", "sym", "se", "its", "sync", "f", "ops", "this", "rs", "ss", "sq", "n", "o", "sharing", "xs", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "aws", "ps", "t", "ls", "service", "comments", "e", "os", "features", "ds", "v", "settings"], "is_intra_likely": ["is_intras_likely", "is_intra__certain", "is_intra_large", "is_intra_info", "is_intra_confirmed", "is_intra_certain", "is_intra__info", "is_intras_confirmed", "is_intras_large", "is_intra_lit", "is_intras_info", "is_intra__confirmed", "is_intras_lit", "is_intra__likely", "is_intras_certain", "is_intra__lit", "is_intra__large"], "i": ["di", "f", "ri", "xi", "ski", "x", "qi", "ix", "u", "ci", "li", "ji", "eni", "bi", "uri", "d", "info", "n", "ip", "ti", "I", "si", "ij", "jit", "id", "pi", "multi", "ai", "chi", "index", "ik", "iu", "ii", "k", "p", "key", "y", "ki", "b", "ih", "z", "mini", "ui", "ni", "zi", "gi", "ami", "fi", "yi", "e", "l", "ori", "io", "oi", "ie", "ini", "v", "mi", "m"], "j": ["ja", "section", "shift", "f", "jp", "jo", "li", "js", "q", "ji", "it", "d", "n", "jl", "job", "si", "ij", "ch", "jit", "obj", "offset", "dj", "kj", "h", "index", "jet", "o", "br", "aj", "w", "ii", "k", "jc", "p", "adj", "key", "y", "ind", "jump", "b", "uj", "note", "z", "bj", "count", "num", "l", "J", "jobs", "v", "bl", "jj", "m"], "undamaged_count": ["undamagedetlength", "undamaged_counter", "undamaged64length", "undamaged__code", "undamagedingcount", "undamored_id", "undamaged24length", "undamagedingnumber", "undamaged__base", "undamaged_id", "undamagement_length", "undamagedentime", "undamored_count", "undamaged24len", "undamagementetchild", "undamored_cache", "undamaged_weight", "undamagement_count", "undamaged2count", "undamaging_length", "undamaged64len", "undamagement_len", "undamaged_child", "undamagedenlength", "undamagedingcounter", "undamaged_base", "undamagement_child", "undamagedetlen", "undamaged_code", "undamaged2weight", "undamage_code", "undamaged2length", "undamagedenweight", "undamaged_len", "undamaged24child", "undamaged_time", "undamaged24count", "undamagementetlen", "undamaged_length", "undamage_base", "undamaging_weight", "undamagedencount", "undamaging_count", "undamaged_cache", "undamaged2time", "undamage_count", "undamagedetchild", "undamagedetcount", "undamaged64child", "undamagementetcount", "undamaged__count", "undamaging_number", "undamagementetlength", "undamaging_counter", "undamaging_time", "undamaged64count", "undamaged_number"], "skip_amount": [" skip_number", "skipedamount", "skip2number", "skipedAmount", " skip_period", "skip00counter", "skipingamount", "skipednumber", "skipingrate", "skip_Amount", "skipingperiod", " skip_rate", "skip\u00b7Amount", "skip___number", "skip2weight", "skip\u00b7rate", "skip___Amount", "skip_number", " skip_Amount", "skip2amount", "skip00number", "skip2Amount", "skip00Amount", "skip_weight", "skipingAmount", "skip_counter", " skip_weight", "skip\u00b7period", "skip00amount", "skip___amount", "skipedweight", " skip_counter", "skip_period", "skip\u00b7amount", "skip_rate", "skip___counter"], "mb_x": ["mp_wy", "mp_xy", "mb_z", "mb_wy", "mp_w", "mp_z", "mp_ye", "ym33yi", "mb33yi", "mbIdyk", "mb33x", "mp_num", "mp_yk", "ym_ex", "mbIdx", "mb_yi", "mb_ex", "mp_y", "ym33no", "mb8ex", "ym33x", "mbIdy", "mb8x", "mb33ex", "mb_no", "mb8yi", "mb_yk", "ym_x", "ym33ex", "mb_num", "mb_ye", "mb8no", "mb_xy", "ym_yi", "ym_no", "mb33no", "mbIdz", "mp_x", "mb_w"], "mb_y": ["mp_xy", "mbPy", "emb_y", "mb_z", "mb_py", "mp_z", "emb_ya", "mb_yl", "mb_yah", "mb_yo", "mb_oy", "mp_py", "mbPyo", "mp_y", "mbPvy", "mp_oy", "mb_ya", "mp_yah", "mb_vy", "mbPx", "mp_yl", "mb_gy", "mp_vy", "mp_gy", "mp_yo", "emb_z", "mb_xy", "emb_x", "mp_x"], "AV_PICTURE_TYPE_I": ["AV_PICTURE_TYPE_SI", "AV_PICTURE_Type_II", "AV_PICTURE_TYPE_DI", "AV_PICTURE_TYPE_II", "AV_PICTURE_Type_DI", "AV_PICTURE_Type_SI", "AV_PICTURE_Type_IJ", "AV_PICTURE_TYPE_IO", "AV_PICTURE_Type_I", "AV_PICTURE_TYPE_IJ", "AV_PICTURE_Type_IO"], "error": ["warning", "ror", "none", "operator", "extra", "node", "valid", "magic", "eor", "code", "block", "ee", "call", " exception", "line", "comment", "image", "attr", " Error", "ception", "order", "layer", "attribute", "server", "op", "no", "message", "user", "data", "errors", "object", "p", "key", "owner", "missing", "value", "err", "element", "row", "bug", "date", "offset", "f", "route", "ip", "ion", "ERROR", "Error", "rage", "other", "query", "ack", "serial", "original", "info", "resource", "debug", "rr", "option", "result", "type", "complete", "parent", "grade", "success", "back", "root", "util", "danger", "ise", "loc", "callback", "patch", "slice", "event", "an"], "linesize": ["insizing", " linessize", " linesizes", " linesizing", "linesizing", "inssize", "imagesize", "linessize", "insize", "imagessize", "imagesizes", "imagesizing", "insizes", "linesizes"]}}
{"project": "FFmpeg", "commit_id": "4d321bff85cf1e9b6a18b915af185494b5ea94b6", "target": 1, "func": "void Release(void *ctx)\n\n{\n\n    ContextInfo *ci;\n\n    ci = (ContextInfo *) ctx;\n\n\n\n    if (ci->cache) {\n\n        imlib_context_set_image(ci->cache->image);\n\n        imlib_free_image();\n\n        av_free(ci->cache);\n\n    }\n\n    if (ctx) {\n\n        if (ci->imageOverlaid) {\n\n            imlib_context_set_image(ci->imageOverlaid);\n\n            imlib_free_image();\n\n        }\n\n        ff_eval_free(ci->expr_x);\n\n        ff_eval_free(ci->expr_y);\n\n        ff_eval_free(ci->expr_R);\n\n        ff_eval_free(ci->expr_G);\n\n        ff_eval_free(ci->expr_B);\n\n        sws_freeContext(ci->toRGB_convert_ctx);\n\n        sws_freeContext(ci->fromRGB_convert_ctx);\n\n        av_free(ctx);\n\n    }\n\n}\n", "idx": 17480, "substitutes": {"ctx": ["cca", "cs", "cp", "cm", "pc", "src", "cli", "unc", "jp", "x", "bc", "parent", "conn", "config", "fw", "qa", "co", "cas", "lc", "cci", "loc", "ca", "cf", "c", "fp", "cc", "sci", "cv", "vc", "tx", "qu", "cus", "pkg", "tc", "Context", "context", "ct", "rc", "cb", "mc", "cmp", "anc", "cu", "xc", "fc", "sync", "cn"], "ci": ["cca", "cp", "aci", "di", "cm", "pc", "cli", "xi", "qi", "cache", "li", "conn", "eni", "uri", "cor", "ku", "si", "pi", "i", "config", "oci", "reci", "ai", "cgi", "co", "uci", "lc", "cci", "ii", "loc", "ca", "cf", "c", "jc", "ce", "ic", "sci", "cc", "vc", "cy", "ki", "coe", "odi", "cus", "cia", "ui", "ni", "zi", "cit", "ct", "CI", "osi", "cu", "isi", "que", "ini", "cod", "sc", "ani"]}}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n", "idx": 17482, "substitutes": {"node": ["core", "self", "server", "cdn", "anch", "inner", "none", "route", "result", "worker", "this", "name", "op", "parent", "source", "load", "document", "annot", "valid", "tag", "root", "child", "n", "enc", "id", "nn", "od", "slave", "path", "native", "tree", "host", "block", "target", "hop", "call", "gen", "ref", "live", "object", "post", "missing", "content", "holder", "null", "function", "wrapper", "edge", "handler", "fn", "nw", "num", "open", "nm", "remote", "master", "outer", "event", "Node"], "ret": ["RET", "val", "reply", "bit", "result", "match", "type", "lt", "alt", "res", "flat", "success", "sr", "valid", "len", "fun", "mt", "obj", " RET", "id", "pet", "code", "data", "pat", "pass", "rets", "iter", "att", "ext", "ref", "det", "nt", "part", "rb", "gt", "wait", "re", "flag", "en", "ft", "num", "Ret", "ait", "opt", "lit", "arg", "rot", "rt", "out", "art"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n", "idx": 17513, "substitutes": {"s": ["cs", "sf", "sys", "session", "sa", "ops", "ps", "fts", "ss", "sq", "r", "params", "c", "p", "sb", "service", "ssl", "b", "services", "m", "bis", "sets", "ses", "e", "os", "sac", "sc", "settings"], "pb": ["cp", "PB", "pc", "proc", "wp", "pd", "ppa", "bc", "lp", "bh", "wb", "bp", "pm", " p", "cpp", "pl", "pa", "vp", "bps", "rb", "sb", "p", "fp", "abc", "PC", "ab", "ub", "fb"], "in": ["min", "inner", "f", "inc", "x", "IN", "source", "d", "id", "r", "input", "data", "c", "ref", "p", "inf", "In", "image", "query", "a", "ins", "bin", "m"], "out": ["wave", "bit", "inner", "copy", "check", "into", "output", "project", "timeout", "option", "result", "extra", "inc", "name", "new", "prefix", "source", "array", "work", "flat", "parent", "off", "cache", "error", "point", "no", "hidden", "word", "again", "one", "init", "r", "OUT", "index", "data", "o", "raw", "block", "binary", "pass", "w", "params", "only", "call", "Out", "part", "object", "p", "line", "post", "b", "scroll", "up", "update", "at", "err", "group", "image", "query", "password", "outs", "outer", "io", "plus", "sync", "m"], "scaled": ["escased", " scased", "shaled", " scaling", "shased", "escaled", "shaling", "escitched", " scitched", "shitched", "escaling", "scaling", "scased", "scitched"], "size": ["scale", "shift", "cm", "resolution", "large", "name", "six", "Size", "len", "si", "SIZE", "small", "ize", "capacity", "address", "code", "loc", "time", "c", "unit", "weight", "sec", "shape", "norm", "sc", "crop", "mode"], "scale_idx": ["scale_indr", "scale_Idx", "scale_indxs", "scale_Idr", "scale_Idg", "scale_Idxs", "scale_ridx", "scale_indx", "scale_indg", "scale_ridxs", "scale_idg", "scale_idxs", "scale_ridr", "scale_ridg", "scale_idr"], "cb": ["core", "batch", "cd", "dc", " bc", "bc", "nc", "buffer", "bb", "CB", "cl", "blocks", "code", "repeat", "circ", "loop", "cf", "callback", "quad", "ref", "cc", "cond", "b", "nb", "rc", "fn", "bf", "confirmed", "ctr"], "lambda": ["phi", " lam", "LA", "alpha", " omega", "shift", "dc", "lam", "pad", "mu", "phase", "fun", "partial", "beta", "lu", "cl", "da", "std", "inv", "func", "function", "abc", "mega", "la", "appa", "wa", "pha"], "uplim": ["uflime", "uselim", "uflims", "uclim", "uplime", "Uplim", "uflim", "Uplig", "uclig", "uclims", "Uflim", "uplims", "Uplime", "uselime", "Uplims", "Uflims", "uclime", "Uflime", "Uflig", "uflig", "uplig", "uselims", "uselig"], "bits": ["bit", "batch", "flags", "frames", "hours", "groups", "weights", "ops", "bs", "gets", "pins", "dates", "parts", "plugins", "ns", "reads", "ints", "locks", "blocks", "ips", "lins", "codes", "forces", "bugs", "details", "pos", "acts", "b", "pieces", "bytes", "bis", "steps", "fps", "planes", "ins", "rows", "features", "cycles", "outs", "bands", "jobs", "offs", "its", "settings"], "ROUNDING": ["RoundingATING", "RRECTED", "WRECTING", "RoundingLESS", "RRECTATING", "WOUNDING", "WRECTATING", "RoundingING", "RANGATING", "RANGED", "WOUNDLESS", "RoundingED", "WRECTED", "RANGING", "WOUNDATING", "RANGLESS", "WRECTLESS", "WOUNDED", "RRECTING", "ROUNDLESS", "ROUNDATING", "RRECTLESS", "ROUNDED"], "i": ["is", "phi", "di", "interface", "inner", "uli", "f", "xi", "cli", "qi", "u", "x", "ix", "ci", "li", "t", "abi", "api", "bi", "it", "uri", "d", "n", "base", "ip", "I", "pi", "si", "id", "temp", "uni", "init", "ai", "last", "data", "diff", "o", "pass", "ii", "c", "iii", "p", "ind", "b", "slice", "at", "ui", "ni", "gi", "zi", "fi", "e", "l", "a", "io", "list", "oi", "ie", "ini", "v", "ti", "j", "info"]}}
{"project": "qemu", "commit_id": "dbb7405d8caad0814ceddd568cb49f163a847561", "target": 1, "func": "static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}", "idx": 17518, "substitutes": {"dev": ["development", "self", "DEV", "dc", "grad", "mod", "dd", "conn", "dim", "dm", "ad", "error", "ch", "gd", "r", "der", "dom", "diff", "data", "Dev", "ga", "conf", "app", "devices", "de", "p", "cam", "var", "def", "ve", "dem", "comment", "priv", "ev", "nov", "die", "driver", "bug", "dn", "device", "rad", "debug", "serial", "md", "adv", "ver", "info"], "d": ["g", "dr", "cd", "di", "debug", "dh", "bd", "dc", "D", "grad", "f", "pd", "mod", "dd", "td", "t", "ad", "dm", "n", "fd", "gd", "sd", "i", "id", "od", "db", "dt", "r", "dom", "diff", "draw", "dl", "w", "dy", "ded", "c", "p", "s", "ld", "de", "da", "dad", "nd", "b", "done", "e", "die", "dat", "l", "driver", "dn", "rad", "device", "v", "ds", "md", "m"], "pci_conf": ["pcu_conn", "pcifConf", "pcu_Conf", "pcm_conf", "pcifcom", "pcu_cfg", "pci_con", "pcifconf", "pcm_com", "pcm_Conf", "pca_conf", "pca_conn", "pcu_config", "pcm_config", "pdi_conf", "pci_config", "pca_cfg", "pdi_config", "pcifconfig", "pci_conn", "pca_config", "pci2config", "pcu_con", "pcu_conf", "pci_Conf", "pci2conn", "pdi_cfg", "pci_com", "pci2conf", "pci2cfg", "pci_cfg"]}}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n", "idx": 17534, "substitutes": {"pkt": ["pwk", "packet", "Pcht", " packer", " packet", "gpkg", "Pkt", "fct", "Pkg", "gpacket", "tacket", "pct", "fkt", "tkt", "gpkt", "Packet", "facket", "ppkt", " pct", "tkg", " pkg", "ppct", "Packer", "pkg", "ppacket", "packer", "tacker", "fkg", "ppkg", "pcht", "Pct", "gpcht", "Pwk", " pwk", " pcht", "ppwk"], "buf": ["cp", "fx", "vec", "bd", "raf", "f", "src", "uf", "cmd", "queue", "bc", "cache", " buffer", "bh", "flow", "buffer", "Buffer", "pool", "wb", "feed", "conv", "base", "obj", "aux", "fw", "ff", "path", "db", "pb", "img", "data", "block", "cas", "ctx", "cap", "rb", "cf", "ref", "fp", "bag", "tmp", "cv", "func", "b", "pkg", "msg", "fb", "cb", "fn", "fi", "seq", "fab", "fam", "box", "buff", "Buff", "alloc", "br"], "res": ["core", "val", "str", "results", "pres", "rez", "css", "resolution", "result", "rus", "rs", "nos", "js", " Res", "error", "reg", "req", "rh", "rar", "red", "rel", "obj", "RES", "Res", "rem", "des", "r", "rx", "rss", "rev", "pre", "gr", "response", "ris", "mr", "func", "sol", "cr", "resp", "re", "ress", "err", "rc", "ret", "Rs", "arr", "ras", "ex", "rep", "ver"], "fd": ["fx", "cd", "sf", "df", "dc", "f", "bd", "raf", "length", "uf", "temp", "dd", "draft", "buffer", "lf", "d", "connection", "exec", "fun", "position", "id", "fw", "FD", "db", "ff", "director", "dir", "data", "fff", "dl", "writer", "fl", "cf", "format", "file", "fp", " fid", "ld", "cond", "func", "ind", "fa", "pointer", "socket", "fs", "ptr", "handler", "cb", "fn", "fi", "die", "port", "pid", "fe", "driver", "io", "flo", "fc", "md", "fb"], "buf_descriptor": ["buf_decription", "buf_decriptor", "buf_desccriptore", "buf_desccriptour", "buf_descriptractor", "buf_desriptractor", "buf_descributors", "buf_description", "buf_descstruction", "buf_descstructore", "buf_deccriptore", "buf_descriptors", "buf_descorors", "buf_decriptors", "buf_descributractor", "buf_desriptor", "buf_descructore", "buf_deccription", "buf_descstructour", "buf_desccription", "buf_deccriptors", "buf_descributor", "buf_descriptour", "buf_descryptractor", "buf_deccriptor", "buf_desccriptractor", "buf_descstructor", "buf_descorore", "buf_descoror", "buf_descructors", "buf_descruction", "buf_descstructors", "buf_decriptore", "buf_descriptore", "buf_descorractor", "buf_descryptors", "buf_desriptour", "buf_desccriptors", "buf_descructor", "buf_descryptor", "buf_descributore", "buf_descryptour", "buf_desccriptor", "buf_desriptore", "buf_descributour", "buf_desriptors"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 17548, "substitutes": {"opaque": ["opatile", "openacity", "copacity", "ipec", "opaques", "octaques", "opec", " opec", "openonymous", "copatile", "copaques", "openec", "openaque", " oponymous", "opacity", "octatile", "copaque", " opacity", " opatile", "iponymous", "octaque", "ipacity", " opaques", "ipaque", "oponymous", "octacity"], "c2": ["cTwo", "c02", "b2", "f2", "ac0", "C0", "cpTwo", "cSecond", "f1", "c0", "c1", "bSecond", "cp2", "arcSecond", "C2", "arc2", "arcTwo", "ac2", "arc02", "cpSecond", "C1", "b02", "cp02", "f0", "ac1", "bTwo"]}}
{"project": "qemu", "commit_id": "9217e26f43df4aab7deaea35b21caacc1f1f854b", "target": 1, "func": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n", "idx": 17553, "substitutes": {"bs": ["cs", "sa", "ps", "bc", "rs", "BS", "js", "bh", "ss", "ns", "bb", "bits", "blocks", "state", "pb", "vs", "ls", "es", "iss", "rb", "gs", "sb", "ts", "b", "obs", "ubs", "fs", "las", "bytes", "bis", "fps", "gb", "bos", "os", "bes", "ds", "bl", "fb"], "sector_num": ["sector1num", "sector_id", " sector_info", "sector_info", " sector_id", "sector1number", "sector1id", "sector1info", " sector_number", "sector_number"], "buffer": ["batch", "header", "timeout", "queue", "source", "buf", "array", "window", "Buffer", "bb", "slave", "address", "padding", "input", "data", "block", "binary", "writer", "iter", "ref", "comment", "transfer", "seed", "port", "device", "buff", "bin"], "nb_sectors": ["nb_sygments", "nb_sygment", "nb_segment", "nb_secgment", "nb_syctors", "nb_semissions", "nb_sigments", "nb_secctors", "nb_symissions", "nb_sictors", "nb_secmissions", "nb_simissions", "nb_sigment", "nb_segments", "nb_secgments"], "s": ["g", "is", "sys", "ops", "sa", "ps", "secondary", "u", "rs", "t", "sq", "ns", "n", "state", "status", "r", "iss", "es", "o", "us", "gs", "c", "p", "sb", "ts", "b", "ssl", "sl", "services", "stats", "S", "as", "states", "ses", "e", "os", "settings", "sync", "rates"]}}
{"project": "FFmpeg", "commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "target": 1, "func": "static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n", "idx": 17554, "substitutes": {"fmt_ctx": ["frt_pkg", "fmt_pkg", "fmt_conn", "fmt_lc", "frt_cp", "fmt_cp", "fmtfpkg", "frt_context", "fmtflc", "fmt_cm", "frt_cm", "fmtfcontext", "fmtfcm", "fmtfsci", "frt_ctx", "fmt_context", "fmtfctx", "fmtfconn", "frt_lc", "fmtfcp", "frt_conn", "fmt_sci", "frt_sci"], "pkt": ["packet", "Pnt", " packet", "wct", "fett", "Pkt", "fet", "fct", "Pkg", "bpnt", "Pett", "Pet", "pct", "fkt", "pett", "pet", "Packet", "facket", "pnt", " pct", "ppkt", "bpacket", " pnt", " pet", "ppct", "ppett", "wkt", "ppacket", "pkg", "wacket", "wkg", "fkg", "bpct", "bpkt", "Pct"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17576, "substitutes": {"s": ["is", "g", "changes", "cs", "self", "ms", "sys", "f", "ops", "this", "ps", "uns", "new", "u", "rs", "js", "south", "t", "ss", "sq", "parts", "d", "ns", "n", "si", "args", "state", "storage", "status", "r", "ls", "es", "o", "us", "php", "gs", "conf", "c", "p", "sb", "ts", "service", "sie", "ssl", "b", "ks", "xs", "current", "fs", "services", "stats", "S", "states", "sets", "ses", "e", "settings", "os", "sym", "hs", "a", "l", "ds", "qs", "rates", "its", "sync", "m"], "value": ["val", "set", "VALUE", "scale", "expression", "shift", "length", "number", "result", "timeout", "range", "type", "name", "u", "values", "array", "balance", "end", "flow", "buffer", "fee", "d", "info", "message", "version", "si", "id", "state", "address", "status", "index", "max", "data", "money", "byte", "w", "total", "response", "key", "store", "content", "current", "image", "start", "text", "Value", "v", "offset"], "size": ["g", "security", "set", "scale", "shift", "now", "length", "timeout", "name", "style", "type", "sized", "ci", "six", "fee", "Size", "len", "si", "SIZE", "small", "ize", "capacity", "storage", "address", "code", "data", "time", "c", "unit", "z", "ui", "sec", "from", "ish", "offset"], "i": ["is", "di", "f", "length", "x", "u", "ix", "ci", "li", "t", "ji", "eni", "it", "bi", "d", "mi", "n", "ip", "I", "si", "pi", "multi", "id", "index", "r", "ai", "iv", "data", "iu", "o", "ia", "ii", "c", "k", "p", "b", "z", "ui", "ni", "zi", "fi", "e", "l", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "m"], "data_count": ["dataarddepth", " data_size", "data_data", "dataacdepth", "dataarddata", " data_offset", "data\u00b7count", "dataacdata", "data_width", " data_length", " data_counter", " data_width", "data_cache", " data_current", "data_offset", "data_counter", " data_cache", "data_depth", " data_depth", "data_size", "data_current", "data\u00b7depth", "data\u00b7size", "data\u00b7current", "dataardcount", "dataacsize", "data_length", " data_data", "dataaccount", "dataardsize"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 17581, "substitutes": {"opaque": ["oclacity", " opace", "opque", "iopaya", "oclaque", "operec", "opaques", "opec", "oclaya", " opec", "iopacity", "operacity", "ipque", "opace", "oclonymous", "operace", "opacity", " opque", "ipopaque", "operonymous", "operque", " opacity", "ipopacity", "operaya", "ipacity", "ipace", "operaques", "ipopec", " opaques", "opaya", "ipopaques", "operaque", "ipaque", "iopaque", "oponymous", "ioponymous"], "addr": ["fx", "node", "x", "ar", "code", "r", "padding", "rx", "byte", "ha", "eth", "attr", "amd", "empty", "arg", "order", "rt", "layer", "oa", "mode", "dr", "server", "name", "work", "pad", "reg", "add", "coord", "args", "index", "data", "kt", "mac", "slot", "p", "url", "port", "alias", "host", "offset", "length", "route", "src", "cmd", "ad", "error", "buffer", "ip", "config", "id", "address", "ord", "ace", "target", "pos", "pointer", "en", "cb", "ack", "anne", "alt", "asm", "prefix", "grade", "conn", "len", "arity", "adr", "hop", "align", "ext", "ref", "nr", "ptr", "adder", "edge", "seq", "cmp", "part", "amp"], "size": ["g", "sn", "scale", "shift", "length", "timeout", "large", "name", "type", "x", "sized", " address", "six", "Size", "n", "len", "SIZE", "small", "ize", "capacity", "address", "code", "data", "align", "loc", "c", "err", "en", "bytes", "send", "rc", "e", "shape", "from", "empty", "offset"], "s": ["g", "is", "cs", "self", "results", "sf", "sys", "session", "f", "ops", "aws", "ps", "uns", "secondary", "u", "rs", "ds", "js", "south", "t", "ss", "sq", "ions", "scope", "ings", "ns", "si", "i", "support", "r", "ls", "o", "es", "als", "w", "gs", "conf", "c", "p", "sb", "ts", "service", "comments", "ssl", "b", "sl", "ks", "socket", "fs", "services", "su", "S", "states", "sg", "e", "ses", "l", "sets", "sym", "os", "a", "ins", "rows", "spec", "qs", "v", "its", "sync", "m"], "ret": ["RET", "val", "bit", "f", "result", "alt", "feat", "res", "t", "success", "repl", "reg", "buffer", "red", "len", "fun", "r", "art", "code", "data", "rev", "rets", "att", "ext", "ref", "det", "nt", "al", "part", "def", "flag", "value", "re", "desc", "en", "rc", "num", "Ret", "arg", "lit", "rt", "out", "v", "rep"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n", "idx": 17587, "substitutes": {"dev": ["self", "di", "dc", "mod", "dd", "dm", "d", "valid", "ch", "gd", "hw", "pu", "od", "dt", "des", "dom", "data", "Dev", "w", "ded", "conf", "app", "devices", "de", "p", "cam", "def", "ve", "dem", "priv", "prof", "fi", "ev", "bus", "os", "pro", "driver", "dn", "device", "rad", "spec", "v", "ds", "serial", "md", "ver"], "s": ["is", "g", "cs", "css", "self", "server", "sf", "sys", "f", "sa", "session", "ps", "u", "rs", "js", "south", "t", "ss", "sq", "d", "ns", "plugins", "n", "si", "sd", "i", "blocks", "r", "vs", "ls", "o", "es", "us", "w", "gs", "c", "p", "sb", "ts", "service", "b", "ssl", "sl", "su", "fs", "services", "S", "bis", "sg", "ses", "e", "sv", "os", "sets", "l", "settings", "spec", "ds", "v", "sync", "m"], "dinfo": ["vdinfo", " dfo", " did", "dfo", "dinf", "dsinfo", "odinfo", " dInfo", "odInfo", "dfi", "mdinfo", "adInfo", "Dfi", "dsfi", "vdfo", "odINFO", "dsid", "ldinfo", "mdfi", "dInfo", "adinfo", " dstate", "mdfo", "vdinf", "Did", "ldfi", "dINFO", "ldinf", "odstate", "adINFO", " dinf", "Dinfo", " dfi", " dINFO", "dstate", "vdfi", "mdinf", "did", "adstate", "Dinf"], "bs": ["cs", "bd", "ops", "ps", "bc", "rs", "BS", "js", "bh", "ss", "bi", "ns", "bb", "base", "lib", "banks", "db", "ob", "blocks", "bid", "pb", "des", "iss", "ls", "vs", "ba", "gs", "sb", "bas", "ks", "b", "ubs", "fs", "uds", "bis", "bytes", "cb", "bus", "gb", "bf", "bos", "os", "ses", "ab", "Bs", "android", "lb", "bes", "ds", "bl", "fb", "sync"]}}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n", "idx": 17596, "substitutes": {"data": ["g", "self", "di", "results", "alpha", "client", "rule", "cat", "and", "this", "database", "extra", "result", "style", "work", "parent", "media", "DATA", "na", "li", "ad", "api", "end", "it", "exec", "d", "test", "feed", "valid", "root", "base", "Data", "fail", "i", "config", "id", "one", "parse", "init", "qa", "change", "dict", "code", "input", "parser", "last", "aa", "reader", "writer", "script", "pass", "next", "ga", "final", "p", "post", "da", "missing", "ui", "la", "as", "window", "dat", "model", "a", "wa", "empty", "builder", "first", "info"], "human": ["local", "family", "json", "author", "modern", "utf", "veh", "http", "large", "ov", "client", "uc", "name", "canon", "parent", "clean", "reach", "valid", "high", "own", "low", "small", "user", "path", "liv", "hello", "native", "huge", "external", "dom", "full", "ouch", "raw", "upper", "man", "cover", "humans", "pure", "mother", "head", "urn", "public", "liter", "han", "sov", "Human", "home", "hou", "father", "woman", "individual", "remote", "custom", "method", "username", "serial", "ghost", "person", "host"]}}
{"project": "FFmpeg", "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7", "target": 0, "func": "static int get_riff(AVFormatContext *s, AVIOContext *pb)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    char header[8];\n\n    int i;\n\n\n\n    /* check RIFF header */\n\n    avio_read(pb, header, 4);\n\n    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */\n\n    avi->riff_end += avio_tell(pb); /* RIFF chunk end */\n\n    avio_read(pb, header+4, 4);\n\n\n\n    for(i=0; avi_headers[i][0]; i++)\n\n        if(!memcmp(header, avi_headers[i], 8))\n\n            break;\n\n    if(!avi_headers[i][0])\n\n        return -1;\n\n\n\n    if(header[7] == 0x19)\n\n        av_log(s, AV_LOG_INFO, \"This file has been generated by a totally broken muxer.\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 17597, "substitutes": {"s": ["cs", "self", "server", "sf", "f", "sa", "bs", "u", "ds", "js", "t", "ss", "sq", "ns", "n", "si", "storage", "parser", "o", "es", "ctx", "an", "c", "p", "sb", "sci", "ts", "sie", "service", "ssl", "b", "sl", "su", "fs", "services", "stats", "ses", "e", "sv", "os", "a", "sc", "se", "spec", "v", "settings"], "pb": ["cp", "PB", "bs", "pc", "tp", "jp", "pd", "ppa", "xb", "bc", "lp", "bh", "api", "wb", "py", "np", "pai", "fm", "bp", "pm", "hub", "bm", "config", "fc", "cpp", "pg", "db", "pl", "platform", "pa", "summary", "vp", "parser", "bps", "eb", "ctx", "rb", "sb", "p", "fp", "abb", "b", "prot", "cb", "ab", "gb", "dp", "mp", "fab", "lb", "usb", "rob", "fb"], "avi": ["ave", "sa", "vim", "ac", "media", "ci", "jam", "abi", "api", "audi", "bi", "video", "pi", "si", "av", "multi", "vi", "opus", "avan", "airo", "ai", "afi", "iv", "umi", "aj", "ii", "archive", "aaa", "sb", "cam", "wav", "mini", "audio", "ui", "ami", "fi", "adi", "ori", "ati", "oi", "avia", "ani", "mi", "oga"], "header": ["extra", "phrase", "bh", "page", "end", "record", "metadata", "h", "code", "padding", "summary", "parser", "block", "head", "line", "content", "context", "layer", "dr", "server", "name", "headers", "buf", "border", "message", "fourth", "forward", "column", "index", "data", "writer", "cover", "four", "character", "fp", "response", "holder", "quarter", "num", "title", "offset", "pc", "Header", "frame", "buffer", "version", "config", "next", "rb", "body", "channel", "info", "section", "output", "document", "back", "tag", "table", "reader", "meta", "rf", "request", "text", "tail"], "i": ["phi", "di", "uli", "f", "ri", "xi", "qi", "x", "axis", "u", "ci", "li", "ix", "t", "eni", "bi", "uri", "mu", "d", "ip", "I", "pi", "si", "multi", "id", "ai", "index", "iv", "iu", "o", "lc", "ii", "c", "p", "y", "b", "ui", "ni", "gi", "zi", "yi", "adi", "fi", "e", "io", "oi", "ie", "ini", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t dsthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *src_addr)\n\n{\n\n    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);\n\n    struct ip6_option_hdr opthdr;\n\n    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);\n\n\n\n    while (bytes_left > sizeof(opthdr)) {\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read, optlen;\n\n\n\n        if (input_size < opt_offset) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,\n\n                                &opthdr, sizeof(opthdr));\n\n\n\n        if (bytes_read != sizeof(opthdr)) {\n\n            return false;\n\n        }\n\n\n\n        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1\n\n                                               : (opthdr.len + sizeof(opthdr));\n\n\n\n        if (optlen > bytes_left) {\n\n            return false;\n\n        }\n\n\n\n        if (opthdr.type == IP6_OPT_HOME) {\n\n            size_t input_size = iov_size(pkt, pkt_frags);\n\n\n\n            if (input_size < opt_offset + sizeof(opthdr)) {\n\n                return false;\n\n            }\n\n\n\n            bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                    opt_offset + sizeof(opthdr),\n\n                                    src_addr, sizeof(*src_addr));\n\n\n\n            return bytes_read == sizeof(src_addr);\n\n        }\n\n\n\n        opt_offset += optlen;\n\n        bytes_left -= optlen;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 17611, "substitutes": {"pkt": ["packet", "ipacket", "pakt", " packet", "bet", "ipkt", "Pkt", "rkt", "Pkg", "Pett", "Pet", "pct", "bkt", "pet", "paelt", "pett", "Packet", " pct", "cpkt", "ipet", " pkg", "Pelt", " pet", "ipett", "kacket", "cpkg", "cpet", "kkt", "pelt", "pkg", "cpacket", "belt", "kelt", "paacket", " pelt", "racket", "rkg", "pamt", "rct", "Pct", " pett", "backet", "kmt", "Pmt", "pmt"], "pkt_frags": ["pkt_frackets", "pkt_frats", "pkt_drages", "pkt_rangeages", "pkt_grags", "pkt_grages", "pkt_frages", "pkt_drats", "pkt_brags", "pkt_drags", "pkt_grats", "pkt_drag", "pkt_frag", "pkt_brats", "pkt_drackets", "pkt_brages", "pkt_rangeackets", "pkt_rangeags", "pkt_grag", "pkt_rangeats", "pkt_brag"], "dsthdr_offset": ["dsthr_off", "dsthr_offset", "dsthr_addr", "dsthdr_entry", "dsthr_entry", "dsthdr_len", "dsthdr_addr", "dsthr_index", "dsthdr_index", "dsthr_len", "dsthdr_size", "dsthr_size", "dsthdr_off"], "ext_hdr": ["ext_phdr", "ext__hhdr", "ext_hsder", "ext_hhdr", "ext_hsard", "ext_vdr", "ext_bhder", "ext_wdr", "ext_wder", "ext_hrr", "ext_phr", "ext__hhder", "ext_htr", "ext_khder", "ext_ghard", "ext_hr", "ext_fDR", "extshtr", "extshrs", "ext_thtr", "ext_khdr", "ext__hdr", "ext_hsrr", "ext_phder", "extsthrs", "ext_fst", "ext__hhr", "ext_bhdr", "extsthder", "extshder", "ext_hsdr", "ext_hhr", "ext_ghdr", "ext_khrr", "extshdr", "ext_hder", "ext_hrs", "extsthdr", "ext_hDR", "ext_vder", "ext_ghder", "ext_khard", "ext__hr", "ext_hard", "ext_phDR", "ext_bhr", "ext_hst", "ext_thrs", "ext_wrs", "ext_vtr", "ext_thdr", "ext_hhder", "ext_phst", "ext_thder", "ext_fdr", "ext_vrs", "extsthtr", "ext_wtr", "ext__hder", "ext_ghrr"], "opthdr": ["OPther", " opthadr", " opghdr", "opTHdr", "OPthrim", "opshadr", "opsthrid", "optthrid", "opithrid", "opkhadr", "opethDR", "oppthDr", "opthsrid", "opathrid", "oppthdr", "opthr", "OPthDR", "oppthsDR", "opTHDR", "opthrin", " copsthr", "opthinrin", "opthDr", "OPpher", "opthinicit", "oputhrim", " copthr", "opphdr", "copghicit", "OPphstr", "optthdr", "oppthDR", "opTHicit", "opghadr", "opTHadr", "opthrim", "hopthrim", "opkhicit", "ophgr", "oppthrid", " copsthdr", "opkhDR", "oputhhr", "optthhr", "optsthDR", "hoputhsr", "ipthDR", "opsthDr", "ipethDR", "ipethdr", "opghicit", "opthhr", "opethstr", " opghstr", "optuthicit", "opphrim", "OPphDR", "opphDr", "oputhicit", "opathdr", "copthicit", "opsther", "opthDR", "opthrid", "opphrin", "optsthdr", "opsthhr", "ophstr", "opthindr", "OPsthdr", "opshstr", "hoputhadr", "opkhar", "opthsr", "OPsthstr", "opthsdr", "opkhdr", " opthstr", "copthdr", "optuthhr", "opithDR", "OPthstr", "opthstr", "opathhr", "optrsr", "ophr", "opathicit", "opythdr", "opkhstr", "opshdr", "hopthsr", "OPsthDR", "optuthrid", "opythstr", "opsthicit", "opythicit", "OPphicit", " copsthgr", "opTHrim", "ipthar", "hopthdr", "opsthstr", "ipthdr", "optrdr", "opphDR", "opthadr", "opghstr", "opthgr", "oputhadr", "opthsDr", "opkhrim", "opether", "OPphrim", " copthdr", "optradr", "opghdr", "opTHrid", "oppher", "opsthDR", "oputhrid", "opethdr", "opthar", "opsthr", "opphstr", "opethar", " copthgr", "copthrin", "optthicit", "oppthsDr", "oputhdr", "opther", "copghrin", "ophdr", " opghadr", "opghrin", "opithdr", "optsthicit", "optsthrid", "opthsDR", "ipethar", "copghdr", "opythrim", "optuthdr", "oppthsdr", "optrrim", "opithar", "opTHsr", "opsthgr", "hopthadr", "hoputhrim", " copsthstr", "oppthsrid", "hoputhdr", "opthicit", "OPphdr", "opithicit", "OPthdr", "opsthdr", " copthstr", "OPthicit", "opphicit", "opghgr", "optthDR", "oputhsr", "opphrid", "opghr"], "bytes_read": ["bytes___need", "seconds_find", " bytes_feed", " bytes_add", "seconds2find", "lines_add", "bytes_start", "ns_left", "seconds2read", "seconds2start", "bytes_ok", "lines_need", "seconds_length", "bytes___length", "bytes_need", "seconds_start", "bytes_find", "bytes_end", "bytes_feed", "ns_read", "bytes2start", "ns_end", "ops_write", "bytes_add", "lines_read", "bytes2read", "bytes___read", "bytes___add", "ns_ok", "ops_read", " bytes_write", "bytes2find", "bytesfstart", "bytesflength", "ops_left", "lines_length", "seconds2length", "bytes_left", "bytesfread", "bytes_write", "bytesffind", "bytes_length", "bytes2length", "seconds_read"], "optlen": ["opsl", "optLen", "iterlc", "oplc", "optline", " optsl", "oplan", " optLen", "ossln", "optsl", "iterln", "logline", "opln", "osspos", "opl", "altl", "ortln", "optlin", " optrel", " optln", "optionlen", " optlan", "ortlan", "optrel", "optimlen", "ossrel", "ortsl", "logl", " optpos", "altlen", "templen", "optel", "optionLen", " optel", "ortl", "altlin", "optlc", "optimLen", "optionel", "optionlan", "templn", "loglin", "optln", "templ", "oplin", "ortrel", "templc", "altline", "optl", "optpos", "oplen", "optlan", "osslen", "optimel", "ortlen", "loglen", "iterl", "iterlen", " optl", "opline", "ortpos", "optimlan"]}}
{"project": "FFmpeg", "commit_id": "582552fb56ba6559cb1d094a7e7ae5dde3073c5c", "target": 0, "func": "static int altivec_uyvy_rgb32 (SwsContext *c,\n\n\t\t\t       unsigned char **in, int *instrides,\n\n\t\t\t       int srcSliceY,\tint srcSliceH,\n\n\t\t\t       unsigned char **oplanes, int *outstrides)\n\n{\n\n  int w = c->srcW;\n\n  int h = srcSliceH;\n\n  int i,j;\n\n  vector unsigned char uyvy;\n\n  vector signed   short Y,U,V;\n\n  vector signed   short vx,ux,uvx;\n\n  vector signed   short R0,G0,B0,R1,G1,B1;\n\n  vector unsigned char  R,G,B;\n\n  vector unsigned char *out;\n\n  ubyte *img;\n\n\n\n  img = in[0];\n\n  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);\n\n\n\n  for (i=0;i<h;i++) {\n\n    for (j=0;j<w/16;j++) {\n\n      uyvy = vec_ld (0, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);\n\n\n\n      uyvy = vec_ld (16, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);\n\n\n\n      R  = vec_packclp (R0,R1);\n\n      G  = vec_packclp (G0,G1);\n\n      B  = vec_packclp (B0,B1);\n\n\n\n      //      vec_mstbgr24 (R,G,B, out);\n\n      out_rgba (R,G,B,out);\n\n\n\n      img += 32;\n\n    }\n\n  }\n\n  return srcSliceH;\n\n}\n", "idx": 17615, "substitutes": {"c": ["g", "cs", "cd", "cp", "self", "cm", "dc", "f", "pc", "com", "ac", "nc", "cache", "ci", "gc", "cur", "t", "d", "ch", "config", "h", "co", "con", "ctx", "ec", "lc", "w", "ca", "cf", "oc", "ce", "k", "p", "cc", "y", "vc", "b", "cr", "tc", "m", "context", "cit", "ct", "rc", "mc", "e", "l", "C", "cu", "xc", "sc", "icc", "cn"], "in": ["ine", "min", "inner", "cm", "nin", "cli", "inc", "ac", "IN", "source", "isin", "conn", "include", "connection", "config", "id", "r", "index", "con", "input", "win", "data", "pass", "In", "login", "inside", "up", "pin", "din", "a", "ins", "lin", "ini", "inn", "bin", "m"], "instrides": ["inputstide", "inputstided", "instiders", "inbride", "inputstides", "inStrided", "inputstriders", "instrided", "inStride", "inStrides", "inputstrides", "instide", "instided", "inputstrided", "inputstride", "instriders", "instides", "inStriders", "inputstiders", "instride", "inbriders", "inbrides", "inbrided"], "srcSliceY": ["srcFliceY", "srcSlaceY", "srcFlaceY", "srcSliseX", "srcSliseY", "srcSlideY", "srcSlaceX", "srcSliceW", "srcFlaceW", "srcFliceX", "srcSliceG", "srcSlaceH", "srcSlineX", "srcSliseH", "srcSlideW", "srcFlaceG", "srcFliceW", "srcSlaceW", "srcSlineY", "srcSliseW", "srcSlineH", "srcSlideX", "srcFliceG", "srcSliceX", "srcSlaceG", "srcFlaceX", "srcSlineW", "srcSlideG", "srcSlineG"], "srcSliceH": ["srcPlineN", "srcSlaceY", "srcPlineL", "srcSliseY", "srcSlaceN", "srcSlaceL", "srcSlideY", "srcSliceW", "srcPliceH", "srcSlaceH", "srcPlineY", "srcPlineW", "srcPlineH", "srcSliseH", "srcSliceL", "srcSlideW", "srcPliceY", "srcSlaceW", "srcSliceN", "srcSlideN", "srcSlineY", "srcSliseW", "srcPliceN", "srcSlineH", "srcPliceL", "srcSlineL", "srcSlineW", "srcPliceW", "srcSlineN", "srcSlideH", "srcSliseL"], "oplanes": ["oblides", "dylane", "oblips", "ospanes", "oclides", "oblane", "oplips", "ospides", "oplipes", "oclanes", "plipes", "oplades", "oplane", "dylips", "ospane", "oplides", "ospades", "oblanes", "oclades", "dylipes", "dylanes", "oblades", "plane", "oclane", "planes", "oblipes", "plips"], "outstrides": ["Outstrades", "outStriding", "outstrided", "outStrided", "Outstides", "Outstriders", "outstriding", "outstrases", "Outstriding", "outdriding", "outstrades", "outstiding", "OutStriders", "outbriders", "Outstrides", "outdriders", "outbrases", "outSTRides", "OutStrides", "OutStrided", "outstases", "outbriding", "Outstiding", "outbrides", "outdrides", "outstades", "Outstades", "OutStriding", "outstides", "outStrides", "Outstrases", "outSTRiding", "outdrided", "Outstrided", "outstriders", "outbrades", "outSTRases", "outSTRades", "Outstases", "outbrided", "outStriders"], "i": ["is", "phi", "di", "f", "xi", "x", "u", "qi", "ci", "li", "eni", "bi", "ji", "d", "n", "ip", "I", "si", "pi", "vi", "h", "ai", "r", "chi", "index", "iu", "ii", "k", "p", "y", "b", "z", "ui", "ni", "zi", "gi", "ami", "yi", "e", "l", "ori", "a", "io", "im", "ie", "ini", "v", "mi", "m"], "j": ["g", "ja", "di", "f", "jp", "x", "u", "qi", "je", "js", "li", "t", "jam", "ji", "d", "n", "jl", "ij", "ch", "jit", "h", "r", "jet", "o", "aj", "w", "dy", "ii", "k", "jc", "p", "y", "uj", "b", "z", "e", "l", "J", "im", "ie", "v", "jj"], "uyvy": ["kyy", "zydy", "gyzy", "uyoy", "hubtsy", "hubny", "yourdy", " blahvette", "oypine", "oyzy", "zypine", "gycy", "zyyo", "zyvette", "oyvy", "uuoy", "uuvette", "ouvy", "hubppy", "zyvey", " blahvy", "ouvey", "udvette", "ueppy", " uoy", "uuny", "gruvy", "kyvey", "ouy", "uevy", "uyvey", "ugdy", "oyny", "ouny", "yuny", "yuvy", "uypine", "ueny", "uetsy", "zyny", "gyny", "gruy", "uycy", "kycy", "uuzy", "zytsy", "uyzy", "uuvy", "udvy", " uvette", " uvy", "uupine", "oycy", "gyvey", "uezy", "kydy", "uyny", " blahny", "yourvy", "udzy", "chyzy", "chyvette", "zyvy", "gruny", "yourvey", " blahoy", "gyvy", "youry", "uyppy", "chydy", "kyzy", "hubvey", "oyvey", "uyy", "hubvy", "zyzy", "uydy", "uuyo", "uevey", "hubzy", "yuy", " uny", "uytsy", "ouppy", "uyyo", "uddy", "ugvey", "gyyo", "chyvy", "ugy", "gruovy", "kyvy", "ouovy", "uyvette", "uyovy", "ugvy", "yuovy"], "Y": ["Ni", "Up", "D", "M", "NY", "YE", "OU", "Q", "Col", "K", "IP", "Z", "L", "Yu", "H", "Bu", "I", "Gy", "YP", "SH", "X", "YY", "O", "XY", " y", "E", "Ch", "CH", "N", "Ky", "IE", "T", "P", "F", "YC", "y", "cy", "MY", "YA", "S", "A", "Py", "BY", "Cy", "Year", "IO", "IA", "Ty", "J", "C", "Hy", "W", "My"], "U": ["Up", "UP", "D", "M", "UID", "OU", "Q", "u", "UD", "Tu", "L", "H", "I", "X", "O", "Su", "UC", "LU", "MU", "UI", "N", "T", "P", "F", "Ub", "CU", "UU", "UX", "Lu", "S", "A", "UR", " u", "UL", "Us", "UV", "US", "C", "W", "Cu", "Ut"], "V": ["VA", "D", "M", "GV", "OU", "Q", "VK", "Iv", "UD", "L", "H", "I", "VER", "Vari", "X", "VT", "E", "Vs", "VL", "N", "Val", "TV", "P", "F", "VC", "AV", "UX", "S", "UL", "VW", "UV", "CV", "J", "GU", "C", "W", "v"], "vx": ["Vy", " vy", "vz", "Vx", "vy", " vX", " vz", "VX", "uvy", "uvX", "Vz", "vX", "uvz"], "ux": ["ru", "vec", "RGB", "src", "xy", "ud", "uc", "sq", " x", "uz", "aux", "X", "UC", "wx", "rx", "uu", "ue", "xxx", "RC", "VC", "vc", "XX", "UX", "lux", "xx", " u", "ww", "foo", "au"], "uvx": ["cvx", "vpy", "vy", "vpx", "vpX", "uvy", "uvX", "cvy", "vX", "cvX"], "R0": ["GOrigin", "ROrigin", "R18", "B10", "B2", "B18", "R10", "R00", " GOrigin", "G18", "R2", "G2", "G00", "V1", " R10", "V00", "V0", "G10", "V18", " R2", " ROrigin", "B00"], "G0": ["U00", " G8", "B3", "R30", "U1", "R00", "U30", "U000", "G30", "B30", "B25", "G00", "U0", "B8", " G25", "R000", "G000", "R3", "R25", "U3", "G3", "B000", "G8", "R8", "G25", "B00"], "B0": ["B3", "B2", "B18", "V2", "L000", "V000", "R00", "F0", "N1", "F2", "F1", "G18", "N00", "L3", "F18", "V3", "G2", "V1", "V00", "L0", "R000", "V0", "R3", "V18", "B000", "N0", "L1", "B00", "L00"], "R1": ["RPU", " RK", "C8", "GK", "UPU", " RPU", "COne", "U1", "V8", "ROne", " RId", "UK", "RId", "V1", " ROne", "GPU", "GId", "U0", "B8", "AId", "VOne", "C1", "A0", "A1", "GOne", "AOne", "RK", "R8", "BOne"], "G1": [" Gone", "R81", "V5", " G5", " GOne", "VName", "U1", "GName", " G6", "B5", "GeName", "GAP", "G6", "Gone", "ROne", " GName", " GIT", "UAP", " GAP", "B6", " G81", "Ge1", "U81", "G81", "V1", "GeIT", "G5", "Bone", "Vone", "V6", "RAP", "VOne", "GIT", "GOne", "VIT", "GeOne", "UOne"], "B1": [" B001", "B2", "VOnce", "R61", " BOne", "R001", "B81", "ROne", "L001", "Y1", "GOnce", "R2", " B2", "G2", "J1", "YOnce", "G81", "G61", "J61", "V1", "B61", "B001", "Y81", "LOne", "L2", "V81", "J2", "L1", "BOne", "BOnce"], "R": ["D", "M", "RGB", "Q", "K", "L", "H", "I", "X", "O", "r", "E", "N", "RC", "T", "P", "GR", "F", "S", "A", "RA", "J", "SR", "RL", "C", "Rs", "RH", "W", "RR"], "G": ["g", "GA", "D", "M", "IG", "GV", "GG", "Q", "L", "Gu", "H", "I", "X", "VG", "E", "Ge", "GP", "GI", "F", "GR", "GL", "PG", "LG", "A", "GF", "GN", "J", "GS", "C", "GB", "W", "GE"], "B": ["D", "AB", "BI", "Q", "Bi", "BS", "WB", "SB", "MB", "L", "BC", "EB", "BM", "H", "I", "X", "O", "BF", "E", "HB", "N", "F", "b", "A", "BG", "J", "C", "Bs", "GB", "W", "DB", "BL", "BA"], "out": ["bit", "inner", "output", "result", "extra", "cmd", "new", "cache", "transform", "buf", "prefix", "IN", "array", "flat", "Image", "n", "lib", "again", "OUT", "input", "o", "draw", "call", "ref", "p", "In", "tmp", "err", "image", "opt", "outs", "io", "Output", "bin", "Out"], "img": ["bl", "imp", "tif", "cm", "f", "uv", "src", "aff", "buf", "aug", "dim", "orig", "big", "conv", "ch", "gd", "small", "config", "ff", "medium", "input", "hr", "ii", "rb", "irm", "ref", "imag", "tmp", "inv", "gif", "z", "up", "image", "ng", "rc", "cb", "upp", "gb", "norm", "io", "arr", "im", "ie", "bg", "ctr", "picture", "br"]}}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static void inc_refcounts(BlockDriverState *bs,\n\n                          BdrvCheckResult *res,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0)\n\n        return;\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17627, "substitutes": {"bs": ["cs", "ms", "ops", "src", "ps", "bc", "rs", "BS", "js", "ss", "ns", "bb", "base", "bits", "blocks", "pb", "vs", "ls", "es", "gs", "sb", "ts", "b", "fs", "las", "bis", "cb", "gb", "bos", "ses", "os", "ins", "outs", "ds", "qs", "bl", "sync"], "res": ["val", "cs", "results", "pres", "rez", "ms", "sys", "resolution", "result", "ps", "ons", "report", "rus", "rs", "nos", "js", "req", "vals", "rh", "reg", "args", "RES", "cons", "ros", "pers", "Res", "rem", "r", "des", "rss", "rev", "gr", "RS", "details", "ours", "response", "def", "resp", "re", "ress", "err", "rc", "ret", "arr", "spec", "ras", "ex"], "refcount_table": ["refcount_tab", "refcounterlist", "refCountingtree", "refcountntree", "refCount_array", "refCount_tab", "refcountingtree", "refcountntype", "refCount_tree", "refcountingtable", "refcount_array", "refCount_file", "refCountingfile", "refcount_type", "refcountertab", "refCount_table", "refcount_list", "refCountingtable", "refcountedfile", "refcountingfile", "refcountnfile", "refCount_type", "refcount2table", "refcount2tab", "refcountingtype", "refcountedtable", "refcountedtype", "refcount2list", "refcountntable", "refCount_list", "refCountingtype", "refcountertable", "refcount_file", "refcount2array", "refcountedtree", "refcount_tree", "refcounterarray"], "refcount_table_size": ["refcount_table_len", "refcount_table_name", "refcount_table_capacity", "refcount_table_scale", "refcount_table_small", "refcount_window_name", "refcount_cache_size", "refcount_window_size", "refcount_window_scale", "refcount_window_small", "refcount_cache_len", "refcount_cache_capacity"], "offset": ["set", "initial", "shift", "timeout", "number", "length", "range", "prefix", "first", "off", "end", "error", "base", "position", "location", "len", "i", "reset", "address", "index", "padding", "addr", "entry", "Offset", "align", "loc", "slot", "ref", "format", "part", "p", "pos", "limit", "pointer", "slice", "edge", "count", "origin", "tail"], "size": ["cs", "set", "after", "scale", "shift", "cm", "length", "timeout", "range", "name", "sized", "six", "end", "Size", "n", "len", "args", "SIZE", "small", "ize", "capacity", "storage", "address", "code", "max", "year", "sum", "time", "c", "sync", "p", "score", "unit", "needed", "use", "send", "count", "sec", "e", "ey", "fe", "empty", "sc", "se"], "s": ["g", "is", "cs", "server", "self", "sys", "ops", "sa", "f", "ps", "http", "less", "rs", "js", "south", "t", "ss", "sq", "d", "ns", "site", "si", "i", "state", "ls", "o", "es", "w", "gs", "side", "c", "p", "sb", "ts", "b", "ssl", "sl", "sup", "xs", "services", "stats", "S", "states", "sets", "ses", "e", "os", "sv", "sym", "l", "spec", "se", "ds", "qs", "its", "sync", "settings"], "start": ["stop", "set", "after", "skip", "scale", "min", "shift", "check", "get", "starting", "f", "range", "work", "cur", "first", "off", "end", "error", "old", "add", "back", "n", "base", "before", "id", "state", "init", "max", "index", "st", "next", "pre", "pos", "slice", "Start", "step", "count", "from", "se", "part", "ish", "art", "info"], "last": ["after", "later", "length", "range", "parent", "cur", "first", "end", "latest", "old", "scope", "prev", "ort", "base", "bottom", "est", "small", "before", "max", "full", "next", "total", "loc", "final", "sync", "close", "cost", "nd", "needed", "Last", "se", "so", "since", "count", "cycle", "zero", "ultimate", "from", "empty", "ending", "j", "use"], "cluster_offset": ["clusteringoptional", "clustereroffset", "cluster_size", "clust_offset", "cluster_limit", "clusteringentry", "clusteralleft", "clard_left", "cluster_count", "cluster_origin", "clionacaddress", "clusterxaddress", "clure_offset", "clust_off", "cluster_entry", "cluster_Offset", "clustereroff", "cluster_address", "clancer_align", "cluster_end", "cluster__origin", "clion_prefix", "clust_size", "clusteringsize", "clion_offset", "clusteripalign", "cluster_prefix", "cluster_optional", "cluster__offset", "cluster_off", "clusteripoptional", "clusteringalign", "clusteringoff", "clusteringlimit", "clusteracprefix", "clusteracaddress", "clustererorigin", "clionacprefix", "cluster__size", "clard_Offset", "cluster_align", "clust_origin", "clusterxprefix", "clard_count", "cluster_left", "clure_off", "clusterersize", "clancer_optional", "clusteraloffset", "clusteralOffset", "clusteracoffset", "clionacoffset", "clard_offset", "clure_size", "clancer_size", "clusterxoffset", "clusteringoffset", "cluster_error", "clusteripoffset", "clard_error", "clure_end", "cluster__off", "clancer_offset", "clusteripsize", "clion_address"], "k": ["g", "kn", "kat", "kk", "f", "length", "number", "ck", "range", "work", "x", "u", "K", "q", "end", "d", "ku", "n", "i", "j", "id", "max", "r", "ik", "o", "sk", "c", "p", "ke", "kick", "key", "y", "ks", "kw", "b", "z", "ko", "unk", "count", "kid", "ask", "ok", "ek", "v"], "check_errors": ["check__error", "test_steps", "test__failed", "check__steps", "checkouterrors", "checkoutsteps", "test_errors", "test__error", "check_failed", "checkouterror", "test_failed", "check_steps", "check__failed", "test__steps", "check__errors", "check_error", "test__errors", "test_error", "checkoutfailed"], "corruptions": ["crruptures", "corruptibles", "crruptibles", "corruptes", "cremptes", "corributions", "crruptes", "corritions", "corributibles", "coremptibles", "corrites", "cremptures", "corruptures", "coremptures", "coremptions", "crruptions", "coremptes", "corritures", "cremptions", "corributures", "corributes", "corritibles", "cremptibles"]}}
{"project": "qemu", "commit_id": "733f0b02c80c3a7106d8327a83948ab68db10ea7", "target": 0, "func": "void stw_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t v = tswap16(val);\n\n    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);\n\n}\n", "idx": 17641, "substitutes": {"addr": ["dr", "grad", "src", "pc", "proc", "intel", "node", "x", "pad", "ad", "point", "inter", "base", "fd", "address", "index", "adr", "data", "ace", "target", "kt", "align", "slot", "ref", "p", "cpu", "pointer", "Address", "ptr", "eth", "attr", "port", "alias", "amd", "device", "rt", "layer", "host", "offset"], "val": ["f", "VAL", "x", "el", "vals", "d", "test", "valid", "fee", "base", "len", "r", "index", "data", "all", "Val", "slot", "ref", "xxx", "p", "al", "vol", "unit", "b", "eval", "sl", "value", "sel", "count", "sec", "ret", "l", "arr", "arg", "V", "v", "bin", "m"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                int l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 17653, "substitutes": {"ctx": ["client", "grad", "proc", "jp", "chan", "wp", "ci", "scope", "exec", "connection", "cl", "ocr", "conf", "cf", "c", "vc", "Context", "cfg", "context", "ctrl", "cm", "cli", "nc", "linux", "req", "np", "hw", "qa", "cas", "cci", "mac", "fp", "cam", "kw", "pkg", "msg", "wcs", "cu", "kb", "gpu", "fc", "sync", "cp", "pc", "src", "ck", "cmd", "uc", "bc", "conv", "cms", "config", "input", "wx", "concept", "lc", "cc", "cpu", "sci", "xs", "cus", "ct", "git", "cb", "fn", "history", "cases", "cn", "cca", "cs", "css", "txt", "sys", "conn", "cpp", "loc", " cx", "ca", "cv", "tx", "tc", "cmp", "anc", "xc", "que", "sc"], "insn_bytes": ["insn_blocks", "insn_byte", "insc__byte", "insn__lines", "insc_seconds", "insn_bits", "insn__seconds", "insn__bits", "insn__blocks", "insc_byte", "insc__seconds", "insc_bytes", "insc_blocks", "insc__bits", "insn__byte", "insc_bits", "insc__bytes", "insn_seconds", "insn__bytes", "insn_lines", "insc_lines"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n", "idx": 17664, "substitutes": {"slirp": ["sliru", "clirtpc", "plirtP", "slirc", "slibrpa", "sliren", "plirc", "slirn", "plirf", "slirln", "slironpd", "plirtpc", "slibrper", "shirp", "slpirb", "slrrp", "slirtc", "slirsp", "urrpa", "urrper", "shirapd", "urru", "slpirp", "plirtf", "slirtpc", "shirpi", "clirtp", "slirtpi", "shirap", "slirspa", "clirpc", "slibru", "plpirc", "slorep", "slirtf", "slirapc", "plirP", "sliref", "clirp", "slirlp", "shirapi", "shirpd", "slrpc", "slireP", "slironp", "slirsper", "uirpa", "slirpd", "slirtp", "slrrper", "slirb", "slrrpa", "urrp", "slirq", "shirpc", "plirpc", "slibrp", "plirtq", "slrru", "slrp", "slironpi", "slirlpi", "slirlpc", "uirper", "plirp", "slirlc", "slirtpd", "slirP", "plirn", "slrb", "slirf", "slirep", "slirtq", "plpirp", "slirapi", "slireq", "plpirpc", "slrc", "shirapc", "slirlP", "slirap", "clirtc", "clirpi", "slireb", "slorepc", "uiru", "sloref", "plirq", "plirtp", "slpirc", "slirepi", "slirsu", "slirtn", "slpirpc", "slirper", "slirpi", "slirec", "uirp", "slirpc", "slirpa", "slirapd", "plpirb", "slirepc", "slironpc", "clirc", "plirb", "clirtpi", "plirtn", "sloreq", "slirtP"]}}
{"project": "qemu", "commit_id": "eda470e41a753070e057380a9a71e2ad7347f667", "target": 0, "func": "void scsi_req_abort(SCSIRequest *req, int status)\n\n{\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->ops->cancel_io) {\n\n        req->ops->cancel_io(req);\n\n    }\n\n    scsi_req_complete(req, status);\n\n    scsi_req_unref(req);\n\n}\n", "idx": 17670, "substitutes": {"req": ["progress", "grad", "proc", "jp", "sem", "exec", "tr", "require", "r", "rx", "call", "conf", "iq", "cf", "dq", "loader", "mr", "needed", "sec", "required", "wa", "ok", "task", "rt", "dr", "ru", "check", "http", "op", "mod", "rh", "quest", "fail", "tar", "user", "qa", "fr", "p", "def", "pkg", "desc", "err", "comp", "ver", "f", "this", "cmd", "rs", "q", "sq", "crit", "error", "cgi", "wx", "hr", "ctx", "next", "rb", "gr", "requ", "cb", "spec", "str", "resource", "rr", "cur", "conn", "flow", "qt", "ext", "ref", "rf", "pull", "request", "seq", "pro", "ctr", "pr"], "status": ["security", "str", "server", "skip", "progress", "received", "sys", "result", "worker", "Status", "name", "source", "access", "success", "error", "sr", "state", "code", "full", "stat", "ity", "response", "score", "service", "current", "wait", "resp", "fs", "uses", "msg", "stats", "err", "sec", "STAT", "sync"]}}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n", "idx": 17678, "substitutes": {"i": ["di", "f", "ri", "xi", "hi", "x", "qi", "u", "ix", "ci", "li", "in", "t", "bi", "mu", "uri", "d", "mi", "info", "n", "ip", "I", "si", "pi", "multi", "id", "index", "ai", "iu", "diff", "o", "ii", "c", "k", "p", "y", "b", "z", "ui", "zi", "gi", "yi", "fi", "e", "l", "start", "a", "io", "oi", "ie", "ini", "part", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 17682, "substitutes": {"entry": ["session", "result", "cache", "Entry", "info", "module", "config", "card", "path", "parse", "index", "parser", "data", "reader", "engine", "cell", "line", "def", "comment", "sec", "row", "cmp", "spec", "se", "debug", "plugin", "mode"], "dsdt": ["dsDT", "dsecd", "dsqt", "osdt", "oskt", "dstd", "nasdm", "ssdl", "stsdt", "ysdt", "ststd", "fstd", "dsdat", "desdm", "stsdh", "DSecd", "dlecd", "DStd", "psDT", "ksdat", "vsdt", "ddds", "dscb", "dldm", "kskt", "kstd", "pscb", "vsDT", "dskt", "ystd", "pskt", "ksdm", "nskt", "dcb", "sskt", "psdat", "desdl", "ysqt", "psdt", "vskt", "std", "osqt", "ssdt", "jstd", "yskt", "dsdl", "sdat", "ddt", "vsds", "nsdt", "ddm", "dsdm", "pstd", "nastd", "dldt", "ddecd", "ddDT", "nsdh", "sdt", "fsdt", "dkt", "dlDT", "DSdh", "destd", "skt", "dsds", "ssdm", "dddt", "stsds", "DSdat", "DSdt", "dddm", "jskt", "fsdm", "naskt", "jsdat", "nstd", "nasdt", "dsdh", "ddtd", "dtd", "sstd", "DSkt", "ksDT", "nscb", "dlkt", "dqt", "ostd", "dltd", "stskt", "DSDT", "desdt", "ksdt", "ddkt", "fsdl", "vstd", "jsdt"], "sb_scope": ["www_scope", "lb_scope", "sb67spec", "sbthescale", "lb_sc", "sb__region", "gb_scope", "sbthemodule", "sb_module", "bs_project", "sb_depth", "blog_scope", "sbthespec", "lb_secret", "www67spec", "www67scope", "sb_project", "sb67scope", "lb_module", "sbthescope", "sb67module", "gb_module", "sb__sc", "sb_spec", "sb_region", "sb__scope", "sb_session", "sb67scale", "blog_stack", "sb_secret", "www_spec", "bs_spec", "lb_context", "sb_parent", "sb__depth", "sb_stack", "lb_parent", "sb_context", "sb_window", "www67scale", "sb__module", "www_module", "bs_scope", "blog_secret", "www_scale", "gb_depth", "bs_window", "www67module", "sb__secret", "gb_region", "sb_sc", "blog_session", "sb_scale"], "scope": ["core", "scale", "resource", "project", "range", "style", "prefix", "source", "error", "tag", "root", "controller", "module", "path", "code", "index", "engine", "loc", "depth", "ope", "context", "model", "environment", "device", "sc", "spec", "mode"], "dev": ["development", "di", "self", "DEV", "prom", "project", " device", "dc", "kind", "cmd", "dd", "pad", "end", "error", "d", "test", "pub", "private", "der", "data", "diff", "Dev", "block", "engine", "conf", "develop", "app", "devices", "de", "var", "loader", "depth", "gu", "push", "def", "dist", "ve", "package", "err", "priv", "dem", "dep", "home", "comment", "md", "ev", "die", "bug", "env", "driver", "device", "debug", "serial", "v", "adv", "ver", "mode"], "method": ["class", "serial", "session", "cmd", "op", "prefix", "mod", "tr", "module", "auth", "user", "path", "block", "raw", "time", "app", "depth", "comment", "package", "prop", "url", "port", "roll", "school", "plugin", "METHOD", "mode"], "field": ["coll", "rule", "f", "style", "instance", "prefix", "cache", "tag", "message", "module", "path", "input", "mount", "time", "file", "loader", "var", "def", "comment", "package", "fields", "port", "mm", "debug", "plugin", "Field"], "pkg": ["cp", "proc", "cmd", "prefix", "mod", "pool", "plugin", "lib", "module", "kg", "pub", "pack", "dir", "mount", "lang", "app", "fp", "loader", "prov", "package", "arch", "install", "cmp", "utils", "packages", "spec", "mag", "comp"], "crs": ["Crc", "grs", " crc", " cris", "gris", "Cris", " crd", "grc", "Crs", "cris", "crd", "crc", "Crd", "grd"], "mem_ranges": ["mem_brange", "mem_rebaps", "mem_brays", "mem_bays", "mem_branges", "mem_rebanges", "mem_baps", "mem_raps", "mem_banges", "mem_rebange", "mem_rays", "mem_rebays", "mem_bange", "mem_braps", "mem_range"], "io_ranges": ["ioingregounds", "io_brange", "io_ralls", "io_tanges", "io_tounds", "io_reganges", "ioingregalls", "ioingregrange", "ioingrrange", "ioingranges", "io_bounds", "ioingreganges", "io_regounds", "io_banges", "io_rounds", "io_regrange", "io_regalls", "ioingrounds", "io_rrange", "ioingralls", "io_trange", "io_balls", "io_talls"], "pcms": ["dcps", "bcps", "bcMS", "mcMS", "dcma", "mcps", "pcps", "pcMS", "bcma", "pcma", "dcms", "mcma", "mcms", "dcMS", "bcms"], "bus": ["session", "machine", "cache", "connection", "board", "boot", "plugin", "config", "BUS", "block", "mount", "engine", "bridge", "cpu", "service", "unit", "lock", "port", "disk", "driver", "Bus", "bug", "device", "usb", "serial", "bin"], "i": ["is", "f", "u", "in", "li", "bi", "it", "info", "ip", "n", "I", "pi", "si", "r", "iu", "ii", "c", "p", "b", "z", "e", "l", "a", "io", "v", "j", "m"]}}
{"project": "qemu", "commit_id": "3d6f761713745dfed7d2ccfe98077d213a6a6eba", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch64(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    unsigned int new_el = env->exception.target_el;\n\n    target_ulong addr = env->cp15.vbar_el[new_el];\n\n    unsigned int new_mode = aarch64_pstate_mode(new_el, true);\n\n\n\n    if (arm_current_el(env) < new_el) {\n\n        if (env->aarch64) {\n\n            addr += 0x400;\n\n        } else {\n\n            addr += 0x600;\n\n        }\n\n    } else if (pstate_read(env) & PSTATE_SP) {\n\n        addr += 0x200;\n\n    }\n\n\n\n    switch (cs->exception_index) {\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        env->cp15.far_el[new_el] = env->exception.vaddress;\n\n        qemu_log_mask(CPU_LOG_INT, \"...with FAR 0x%\" PRIx64 \"\\n\",\n\n                      env->cp15.far_el[new_el]);\n\n        /* fall through */\n\n    case EXCP_BKPT:\n\n    case EXCP_UDEF:\n\n    case EXCP_SWI:\n\n    case EXCP_HVC:\n\n    case EXCP_HYP_TRAP:\n\n    case EXCP_SMC:\n\n        env->cp15.esr_el[new_el] = env->exception.syndrome;\n\n        break;\n\n    case EXCP_IRQ:\n\n    case EXCP_VIRQ:\n\n        addr += 0x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n", "idx": 17699, "substitutes": {"cs": ["cp", "css", "ics", "CS", "sys", "pc", "ck", "cli", "bc", "ix", "ds", "rs", "ci", "js", "cache", "conn", "ss", "ns", "args", "enc", "cons", "codes", "ocr", "pec", "vs", "ls", "cas", "ctx", "ec", "lc", "qs", "cf", "sk", "c", "acs", "ce", "s", "cc", "ks", "vc", "cus", "fs", "wcs", "rc", "ses", "sc", "spec", "Cs", "ras", "sync", "cn"], "cpu": ["gpu", "core", "cp", "cm", "dc", "component", "pc", "cal", "clock", "CPU", "cli", "intel", "bc", "cache", "nc", "conn", "eni", "np", "boot", "cpp", "pu", "ctx", "ec", "lc", "cf", "processor", "c", "ea", "coe", "cv", "bench", "cow", "en", "vm", "cmp", "anc", "sc", "fc", "cn"], "env": ["core", "inet", "eu", "session", "extra", "cache", "net", "global", "eni", "end", "scope", "org", "exec", "exe", "equ", "fen", "ench", "engine", "conf", "cf", "c", "loader", "cfg", "eve", "context", "network", "oa", "server", "icer", "cli", "forge", "export", "nc", "enable", "req", "np", "Environment", "site", "args", "agent", "esi", "ea", "err", "vm", "ne", "environment", "pect", "eye", "console", "kn", "cal", "erv", "bc", "qv", "config", "db", "eng", "init", "vs", "ace", "ctx", " environment", "stage", "energy", "er", "en", "cb", "viron", "ev", "cn", "output", "skin", "conn", "el", "enc", "osc", "dt", "estate", "ec", "exc", "qt", "ext", "ce", "cv", "esm", "her", "edge", "gui", "csv", "nw", "e", "anc", "que", "event", "v"]}}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n", "idx": 17700, "substitutes": {"obj": ["self", "pt", "src", "proc", "jp", "inst", "instance", "po", "conn", "api", "org", "py", "base", "boot", "module", "id", "ob", "pl", "act", "emb", "data", "o", "ctx", "ref", "object", "p", "bot", "pos", "tmp", "nt", "objects", "so", "nb", "cb", "os", "arr", "office", "Obj", "art", "j"], "errp": ["armpp", " errpb", " errpp", "arrpb", "errr", "arrr", " errr", "arrp", "armp", "armpb", "errpb", "arrpp", "armr", "errpp"], "pcms": ["cems", "lcps", "fcMS", "pcMs", " pcMs", "cps", "lcms", "pcns", " pcMS", "cms", "pcMS", " pcps", "cMs", "pcems", "fcps", "cMS", "pcps", " pcems", "fcns", " pcns", "lcMs", "cns", "lcems", "fcms"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n", "idx": 17710, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "3dfbdb328ed9e88cebc6462c56cfe61e55850b2e", "target": 0, "func": "static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n\n{\n\n    int v;\n\n    int i = 0;\n\n    uint8_t state[CONTEXT_SIZE];\n\n\n\n    memset(state, 128, sizeof(state));\n\n\n\n    for (v = 0; i < 128; v++) {\n\n        unsigned len = get_symbol(c, state, 0) + 1;\n\n\n\n        if (len > 128 - i)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        while (len--) {\n\n            quant_table[i] = scale * v;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < 128; i++)\n\n        quant_table[256 - i] = -quant_table[i];\n\n    quant_table[128] = -quant_table[127];\n\n\n\n    return 2 * v - 1;\n\n}\n", "idx": 17723, "substitutes": {"c": ["cs", "cp", "cm", "dc", "f", "pc", "unc", "bc", "nc", "ac", "u", "d", "ch", "r", "code", "ec", "lc", "cf", "oc", "ce", "p", "cc", "ic", "cy", "b", "cr", "cus", "ct", "rc", "cb", "mc", "e", "l", "C", "xc", "sc", "fc", "icc", "m"], "quant_table": ["quantityheader", "quantstree", "useritytable", "qual_scale", "volume_cache", "quant0source", "user_cache", "quant_tree", "user_table", "quantsscale", "quantisttable", "component_cache", "quantisttest", "quant_part", "quant_list", "useritybottom", "quant_buffer", "quantentable", "query_table", "querysbuffer", "qual_table", "quant_cache", "query_header", "quantenmodule", "qual_list", "volumeisttable", "quant0cache", "componentingsource", "quant0iterator", "useritypart", "quantistcache", "quant_source", "quantitytree", "quant_module", "componentingiterator", "user_bottom", "quantslist", "volume_test", "quantingtable", "quantingsource", "quant_count", "queryitymodule", "component_source", "volume_table", "quantitycache", "queryitytable", "quantenheader", "componentingcache", "quantstable", "qual_count", "queryityheader", "query_buffer", "quant0table", "quantistTABLE", "quantsbuffer", "useritycache", "quantitymodule", "component_iterator", "component_table", "quantscount", "quant_test", "quantscache", "querystable", "quant_bottom", "quantitypart", "query_tree", "volumeistcache", "componentingtable", "volumeistTABLE", "quantingiterator", "quant_iterator", "quant_header", "quantitybottom", "queryitytree", "quantentree", "query_cache", "quantitytable", "query_module", "volume_TABLE", "quantingcache", "querystree", "queryscache", "quant_scale", "volumeisttest", "quant_TABLE", "user_part"], "scale": ["alpha", "shift", "rule", "range", "u", "transform", "grade", "error", "factor", "Scale", "ale", "fee", "base", "si", " Scale", "pi", "beta", "ize", "offset", "cale", "co", "data", "repeat", "unit", "delay", "sup", "value", "slice", "se", "seed", "shape", "e", "start", "norm", "alias", "adjust", "gain", "order", "size", "rate", "mode"], "v": ["g", "val", "f", "uv", "length", "lv", "x", "u", "ci", "li", "t", "q", "n", "conv", "pi", "si", "id", "vi", "vid", "h", "va", "iv", "vp", "vs", "o", "w", "ii", "k", "p", "s", "limit", "vc", "b", "value", "z", "ver", "ui", "nv", "count", "e", "l", "sv", "a", "size", "V", "j", "m"], "state": ["is", "core", "g", "resource", "output", "session", "length", "result", "range", "style", "cache", "instance", "source", "parent", "cur", "param", "conn", "STATE", "scope", "buffer", "connection", "ch", "State", "j", "memory", "config", "address", "code", "private", "r", "data", "block", "ctx", "stat", "p", "channel", "store", "pointer", "value", "slice", "err", "context", "states", "seed", "e", "start", "trace", "size", "sync", "use"], "len": ["val", "vec", "min", "length", "split", "Len", "li", "el", "L", "lf", "n", "base", "j", "id", "lu", "pl", "code", "il", "hl", "rev", " l", "dl", "lc", "iter", "ii", "fl", "line", "limit", "pos", "ind", "sl", "le", "en", "count", "e", "l", "ler", "lit", "lin", "ie", "ln", "size"], "i": ["phi", "di", "f", "length", "xi", "qi", "u", "x", "ix", "ci", "li", "t", "q", "api", "bi", "uri", "it", "ji", "d", "info", "n", "ip", "si", "I", "pi", "id", "vi", "h", "ai", "index", "r", "iu", "o", "lc", "ii", "iter", "k", "p", "line", "limit", "y", "b", "z", "ui", "ni", "gi", "yi", "fi", "e", "l", "a", "io", "ie", "ini", "mi", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "1eb57e1d9b59db0aa63348c21bf3290bd3f5efcb", "target": 0, "func": "static int tb_unreliable(AVCodecContext *c)\n\n{\n\n    if (c->time_base.den >= 101L * c->time_base.num ||\n\n        c->time_base.den <    5L * c->time_base.num ||\n\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n        c->codec_id == AV_CODEC_ID_H264)\n\n        return 1;\n\n    return 0;\n\n}\n", "idx": 17735, "substitutes": {"c": ["g", "cs", "cp", "cm", "dc", "f", "coll", "client", "pc", "unc", "uc", "nc", "ac", "u", "ci", "t", "exec", "d", "n", "ch", "enc", "co", "con", "ctx", "ec", "lc", "call", "ca", "cf", "oc", "ce", "k", "p", "s", "cc", "ic", "cv", "vc", "tc", "ct", "cit", "rc", "mc", "e", "cmp", "l", "anc", "C", "cu", "a", "sc", "fc", "m"]}}
{"project": "FFmpeg", "commit_id": "0232f788b6b0855db1771dbf8d7174e2eda2ff45", "target": 1, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n\n\n    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);\n\n    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);\n\n    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);\n\n    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->in_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->out_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;\n\n\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\nav_assert0(s-> in.ch_count);\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n    s->in_buffer= s->in;\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count=\n\n        s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n\n\n\n\n\n    if(s->rematrix)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 17737, "substitutes": {"s": ["g", "session", "js", "plugins", "h", "r", "gs", "conf", "c", "b", "ssl", "su", "fs", "as", "states", "sets", "a", "qs", "m", "server", "sf", "u", "in", "ions", "ns", "site", "si", "args", "i", "user", "strings", "es", "us", "params", "p", "sb", "ts", "ks", "services", "l", "sym", "serv", "se", "its", "sync", "f", "ops", "this", "rs", "ss", "sq", "n", "native", "phys", "vs", "xs", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "ps", "t", "parts", "d", "ls", "w", "details", "service", "uses", "request", "e", "os", "ds", "an", "settings"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int svq1_decode_init(AVCodecContext *avctx)\n\n{\n\n    MpegEncContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    MPV_decode_defaults(s);\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width+3)&~3;\n\n    s->height = (avctx->height+3)&~3;\n\n    s->codec_id= avctx->codec->id;\n\n    avctx->pix_fmt = PIX_FMT_YUV410P;\n\n    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames\n\n    s->flags= avctx->flags;\n\n    if (MPV_common_init(s) < 0) return -1;\n\n\n\n    init_vlc(&svq1_block_type, 2, 4,\n\n        &svq1_block_type_vlc[0][1], 2, 1,\n\n        &svq1_block_type_vlc[0][0], 2, 1);\n\n\n\n    init_vlc(&svq1_motion_component, 7, 33,\n\n        &mvtab[0][1], 2, 1,\n\n        &mvtab[0][0], 2, 1);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        init_vlc(&svq1_intra_multistage[i], 3, 8,\n\n            &svq1_intra_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_intra_multistage_vlc[i][0][0], 2, 1);\n\n        init_vlc(&svq1_inter_multistage[i], 3, 8,\n\n            &svq1_inter_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_inter_multistage_vlc[i][0][0], 2, 1);\n\n    }\n\n\n\n    init_vlc(&svq1_intra_mean, 8, 256,\n\n        &svq1_intra_mean_vlc[0][1], 4, 2,\n\n        &svq1_intra_mean_vlc[0][0], 4, 2);\n\n\n\n    init_vlc(&svq1_inter_mean, 9, 512,\n\n        &svq1_inter_mean_vlc[0][1], 4, 2,\n\n        &svq1_inter_mean_vlc[0][0], 4, 2);\n\n\n\n    return 0;\n\n}\n", "idx": 17742, "substitutes": {"avctx": ["maccf", " avcam", "AVsync", "ovcontext", "ovsync", "afvoc", "avci", "avconv", "ajconv", "navcf", "ajloc", "avcu", "awvoc", "afcfg", "avcv", "ajcfg", "airsync", "aircli", "AVloc", "ajcontext", "macctx", "avecf", "avconn", "mpconn", "svctx", "mpcontext", "awcontext", "avectx", " avvoc", "avcontext", "afconn", "AVctx", "avecontext", "svconv", "afci", "avcfg", "AVcontext", " avcoll", "avlc", "afcontext", "avcoll", "awcf", " avloc", "avecp", "mpci", "aflc", "avvoc", "awctx", " avhw", "ajcv", "avloc", "mpcam", "ajlc", "afcoll", "avecoll", "avcp", "ajsync", "afcf", "afcu", "afcp", "machw", "AVcv", "mpcf", "ovctx", "navcontext", "avcli", " avcv", "afctx", "avecu", "navcu", " avcontext", "AVlc", "avhw", "ajctx", "mpctx", " avci", "afcam", "maccontext", "afconv", "avcf", "airctx", "svcontext", "avsync", "navctx", "afhw", "avcam", "afsync", "aircontext", " avcf", "svcfg", "ovcli", " avcp", "aveconn", "afcli"], "s": ["g", "cs", "server", "sf", "f", "session", "sys", "http", "aws", "ops", "secondary", "ds", "js", "t", "ss", "sq", "d", "ns", "n", "si", "storage", "h", "private", "data", "ls", "es", "o", "ctx", "an", "gs", "conf", "c", "p", "sb", "ts", "service", "ssl", "b", "xs", "sup", "fs", "services", "stats", "S", "bis", "sec", "sg", "ses", "e", "os", "l", "sym", "a", "spec", "qs", "v", "sync", "m"], "i": ["g", "phi", "di", "inner", "uli", "f", "ri", "xi", "hi", "cli", "type", "qi", "u", "ix", "x", "ci", "li", "t", "abi", "eni", "bi", "uri", "it", "q", "d", "mi", "api", "ip", "pi", "I", "si", "multi", "id", "ai", "chi", "iv", "ik", "iu", "ia", "lc", "ii", "p", "ic", "key", "y", "ind", "b", "ki", "slice", "ui", "image", "ni", "gi", "zi", "fi", "yi", "e", "ori", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "info"]}}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n\n                                     AVStream *st, RMStream *ast, int read_all)\n\n{\n\n    char buf[256];\n\n    uint32_t version;\n\n    int ret;\n\n\n\n    /* ra type header */\n\n    version = avio_rb16(pb); /* version */\n\n    if (version == 3) {\n\n        unsigned bytes_per_minute;\n\n        int header_size = avio_rb16(pb);\n\n        int64_t startpos = avio_tell(pb);\n\n        avio_skip(pb, 8);\n\n        bytes_per_minute = avio_rb16(pb);\n\n        avio_skip(pb, 4);\n\n        rm_read_metadata(s, 0);\n\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n\n            // fourcc (should always be \"lpcJ\")\n\n            avio_r8(pb);\n\n            get_str8(pb, buf, sizeof(buf));\n\n        }\n\n        // Skip extra header crap (this should never happen)\n\n        if ((startpos + header_size) > avio_tell(pb))\n\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n\n        if (bytes_per_minute)\n\n            st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        st->codec->sample_rate = 8000;\n\n        st->codec->channels = 1;\n\n        st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = AV_CODEC_ID_RA_144;\n\n        ast->deint_id = DEINT_ID_INT0;\n\n    } else {\n\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n\n        int codecdata_length;\n\n        unsigned bytes_per_minute;\n\n        /* old version (4) */\n\n        avio_skip(pb, 2); /* unused */\n\n        avio_rb32(pb); /* .ra4 */\n\n        avio_rb32(pb); /* data size */\n\n        avio_rb16(pb); /* version2 */\n\n        avio_rb32(pb); /* header size */\n\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n\n        avio_rb32(pb); /* ??? */\n\n        bytes_per_minute = avio_rb32(pb);\n\n        if (version == 4) {\n\n            if (bytes_per_minute)\n\n                st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        }\n\n        avio_rb32(pb); /* ??? */\n\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n\n        st->codec->block_align= avio_rb16(pb); /* frame size */\n\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n\n        avio_rb16(pb); /* ??? */\n\n        if (version == 5) {\n\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n\n        }\n\n        st->codec->sample_rate = avio_rb16(pb);\n\n        avio_rb32(pb);\n\n        st->codec->channels = avio_rb16(pb);\n\n        if (version == 5) {\n\n            ast->deint_id = avio_rl32(pb);\n\n            avio_read(pb, buf, 4);\n\n            buf[4] = 0;\n\n        } else {\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n            ast->deint_id = AV_RL32(buf);\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n        }\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(buf);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n\n\n        switch (st->codec->codec_id) {\n\n        case AV_CODEC_ID_AC3:\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            break;\n\n        case AV_CODEC_ID_RA_288:\n\n            st->codec->extradata_size= 0;\n\n            ast->audio_framesize = st->codec->block_align;\n\n            st->codec->block_align = coded_framesize;\n\n            break;\n\n        case AV_CODEC_ID_COOK:\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        case AV_CODEC_ID_ATRAC3:\n\n        case AV_CODEC_ID_SIPR:\n\n            if (read_all) {\n\n                codecdata_length = 0;\n\n            } else {\n\n                avio_rb16(pb); avio_r8(pb);\n\n                if (version == 5)\n\n                    avio_r8(pb);\n\n                codecdata_length = avio_rb32(pb);\n\n                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            ast->audio_framesize = st->codec->block_align;\n\n            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {\n\n                if (flavor > 3) {\n\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n\n                           flavor);\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ff_sipr_subpk_size[flavor];\n\n            } else {\n\n                if(sub_packet_size <= 0){\n\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ast->sub_packet_size;\n\n            }\n\n            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0)\n\n                return ret;\n\n\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            avio_rb16(pb); avio_r8(pb);\n\n            if (version == 5)\n\n                avio_r8(pb);\n\n            codecdata_length = avio_rb32(pb);\n\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                return -1;\n\n            }\n\n            if (codecdata_length >= 1) {\n\n                avio_r8(pb);\n\n                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0)\n\n                    return ret;\n\n            }\n\n            break;\n\n        default:\n\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n\n        }\n\n        if (ast->deint_id == DEINT_ID_INT4 ||\n\n            ast->deint_id == DEINT_ID_GENR ||\n\n            ast->deint_id == DEINT_ID_SIPR) {\n\n            if (st->codec->block_align <= 0 ||\n\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n\n                ast->audio_framesize * sub_packet_h < st->codec->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n        switch (ast->deint_id) {\n\n        case DEINT_ID_INT4:\n\n            if (ast->coded_framesize > ast->audio_framesize ||\n\n                sub_packet_h <= 1 ||\n\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_GENR:\n\n            if (ast->sub_packet_size <= 0 ||\n\n                ast->sub_packet_size > ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_SIPR:\n\n        case DEINT_ID_INT0:\n\n        case DEINT_ID_VBRS:\n\n        case DEINT_ID_VBRF:\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown interleaver %X\\n\", ast->deint_id);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (read_all) {\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            rm_read_metadata(s, 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17752, "substitutes": {"s": ["cs", "sf", "scl", "client", "sys", "ops", "sa", "f", "bs", "ps", "cli", "session", "ds", "rs", "t", "ss", "sq", "ns", "types", "support", "parser", "ls", "es", "c", "p", "sb", "ssl", "b", "sl", "fs", "bis", "ses", "e", "os", "sv", "sc", "se", "spec", "sync", "settings"], "pb": ["cp", "txt", "PB", "pt", "pc", "src", "uf", "tp", "wp", "pd", "jp", "xb", "ppa", "bc", "lp", "bh", "SB", "api", "plug", "wb", "um", "bp", "pm", "hub", "bm", "fc", "cpp", "pg", "db", "pl", "platform", "summary", "vp", "parser", "bps", "phys", "eb", "posts", "ctx", "lc", "typ", "loc", "rb", "bot", "sb", "fp", "p", "hp", "b", "prot", "pkg", "proc", "prop", "nb", "cb", "ab", "bf", "dp", "gb", "pro", "mp", "lab", "fab", "wikipedia", "lb", "usb", "rob", "plugin", "fb"], "st": ["stop", "set", "str", "sn", "pt", "sa", "src", "rest", "inst", "et", "cast", "td", "sh", "ss", "St", "sd", "est", "ut", "th", "ist", "cl", "tt", "put", "fr", "kt", "rd", "sb", "ld", "std", "ts", "ost", "nd", "sl", "ST", "sta", "ft", "ct", "vd", "sts", "l", "sth", "sc", "ste", "ess", "bl", "art"], "ast": ["sa", "rest", "node", "ac", "asm", "cast", "na", "Ast", "ad", "end", "ta", "aster", "test", "ans", "est", "oid", "aps", "od", "ist", "asts", "ar", "tta", "rss", "addr", "sam", "doc", "ma", "host", "ace", "att", "ref", "post", "ts", "ost", "nd", "dist", "sta", "at", "am", "ST", "as", "ct", "AST", "ab", "asting", "a", "amd", "master", "ess", "an", "af", "art", "amp"], "read_all": ["reader_total", "reader_raw", "reader_all", "readbyall", "readbydata", "read_total", "readbytotal", "readbyraw", "read_raw", "reader_data", "read_data"], "buf": ["batch", "cp", "txt", "bd", "map", "bo", "src", "uf", "uc", "cmd", "queue", "bc", " buffer", "pad", " b", "buffer", "Buffer", "wb", "feed", "bb", "fd", "config", "db", "ff", "data", "block", "binary", "ctx", "cap", "ba", "loc", "rb", "xff", "fp", "bag", "cv", "tmp", "pos", "b", "bytes", "prop", "cb", "rc", "seq", "text", "buff", "v", "bin", "fb", "br"], "version": ["Version", "section", "class", "server", "generation", "software", "project", "f", "length", "mode", "number", "option", "type", "name", "compatible", "release", "description", "connection", "tag", "message", "vision", "position", "tun", "beta", "support", "platform", "code", "versions", "VERSION", "format", "channel", "depth", "brand", "cv", "available", "stage", "ver", "package", "ception", "shape", "driver", "python", "size", "plugin", "v", "feature", "info"], "ret": ["RET", "val", "class", "result", "complete", "res", "success", "error", "no", "conv", "dev", "status", "max", "con", "rev", " resp", "lang", "gen", "final", "resp", " success", "rc", "num", "Ret", "seq", "quiet", "info"], "bytes_per_minute": ["bytes_per_double", "bytes_PER_minute", "bytes_Per_min", "bytes_Per_minute", "bytes_per_mand", "bytes_Per_second", "bytes_per_month", "bytes_per_second", "bytes_Per_month", "bytes_per_min", "bytes_PER_day", "bytes_per_day", "bytes_Per_double", "bytes_PER_second"], "flavor": ["flavour", "fluavor", " flavored", "FLavor", "Flavorite", "flendor", "Flavored", "Flavour", "flavorite", "fluavour", " flavorite", "FLavored", "fluavorite", "flavored", " flavour", "Flavor", "FLendor", "Flendor", "fluendor", " flendor", "FLavour"], "sub_packet_h": ["sub_packacket_count", "sub_packet_count", "sub_packacket_length", "sub_packacket_size", "sub_packet_length", "sub_packacket_h"], "coded_framesize": ["coded_flowsize", "coded_wordssize", "coded_filessize", "coded_boardssize", "coded_capsizable", "coded_framsize", "coded_wordsize", "coded_flowsization", "coded_timesization", "coded_wordsized", "coded_flowssize", "coded_flowsizable", "coded_framizing", "coded_filesizable", "coded_timessize", "coded_timesize", "coded_filesize", "coded_framesizable", "coded_boardsize", "coded_boardsized", "coded_frameization", "coded_capsize", "coded_framize", "coded_capsized", "coded_frameize", "coded_framessize", "coded_framesized", "coded_wordsizing", "coded_framesization", "coded_boardsizable", "coded_capssize", "coded_frameizable", "coded_framized", "coded_timesizable", "coded_filesized", "coded_framesizing"], "sub_packet_size": ["sub_packet_name", "sub_packacket_name", "sub_packacket_size", "sub_packacket_sized", "sub_packet_sized", "sub_packetlistsize", "sub_packetlistname", "sub_packetlistsized"], "codecdata_length": ["codecframeaccapacity", "codecframe_type", "codecdataaclength", "codecdata_total", "codecframeaclength", "codecframe_length", "codecdataaccapacity", "codecframeactype", "codecdataactype", "codecdataqcapacity", "codecdataqtype", "codecdataactotal", "codecframe_total", "codecdataqtotal", "codecdata_type", "codecframe_capacity", "codecdataqlength", "codecdata_capacity", "codecframeactotal"]}}
{"project": "FFmpeg", "commit_id": "c5be6192f0a50eb8a2134c32b7d57f1d88736adf", "target": 1, "func": "int show_license(void *optctx, const char *opt, const char *arg)\n\n{\n\n    printf(\n\n#if CONFIG_NONFREE\n\n    \"This version of %s has nonfree parts compiled in.\\n\"\n\n    \"Therefore it is not legally redistributable.\\n\",\n\n    program_name\n\n#elif CONFIG_GPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_GPL\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 2 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_LGPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU Lesser General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#else\n\n    \"%s is free software; you can redistribute it and/or\\n\"\n\n    \"modify it under the terms of the GNU Lesser General Public\\n\"\n\n    \"License as published by the Free Software Foundation; either\\n\"\n\n    \"version 2.1 of the License, or (at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\"\n\n    \"Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public\\n\"\n\n    \"License along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#endif\n\n    );\n\n\n\n    return 0;\n\n}\n", "idx": 17765, "substitutes": {"optctx": ["propctx", "propcontext", " optcontext", " optcb", "optcas", "optcontext", "optioncas", "propcas", " optcas", "optioncb", "optioncontext", "optionctx", "optcb", "propcb"], "opt": ["optim", "cat", "option", "type", "op", "cut", "parent", "Option", "asm", "param", "crit", "job", "config", "path", "color", "program", "target", "ext", "value", "image", "prop", "dest", "expr", "options", "text", "mem", "mp", "Opt"], "arg": ["val", "proc", "inc", "asm", "param", "argument", "reg", "exec", "args", "enc", "ax", "lib", "word", "path", "ar", "doc", "par", "call", "mac", "gen", "var", "func", "flag", "prop", "Arg", "arc", "amd", "amp"]}}
{"project": "FFmpeg", "commit_id": "62c3c8ca78ee2da7dc20c2d6371866266c82966d", "target": 1, "func": "int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n\n                              int lower_transport, const char *real_challenge)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int rtx = 0, j, i, err, interleave = 0, port_off;\n\n    RTSPStream *rtsp_st;\n\n    RTSPMessageHeader reply1, *reply = &reply1;\n\n    char cmd[2048];\n\n    const char *trans_pref;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        trans_pref = \"x-pn-tng\";\n\n    else\n\n        trans_pref = \"RTP/AVP\";\n\n\n\n    /* default timeout: 1 minute */\n\n    rt->timeout = 60;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n     * RTSP stream */\n\n\n\n    /* Choose a random starting offset within the first half of the\n\n     * port range, to allow for a number of ports to try even if the offset\n\n     * happens to be at the end of the random range. */\n\n    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);\n\n    /* even random offset */\n\n    port_off -= port_off & 0x01;\n\n\n\n    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {\n\n        char transport[2048];\n\n\n\n        /*\n\n         * WMS serves all UDP data over a single connection, the RTX, which\n\n         * isn't necessarily the first in the SDP but has to be the first\n\n         * to be set up, else the second/third SETUP will fail with a 461.\n\n         */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n\n             rt->server_type == RTSP_SERVER_WMS) {\n\n            if (i == 0) {\n\n                /* rtx first */\n\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n\n                    if (len >= 4 &&\n\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n\n                                \"/rtx\"))\n\n                        break;\n\n                }\n\n                if (rtx == rt->nb_rtsp_streams)\n\n                    return -1; /* no RTX found */\n\n                rtsp_st = rt->rtsp_streams[rtx];\n\n            } else\n\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n\n        } else\n\n            rtsp_st = rt->rtsp_streams[i];\n\n\n\n        /* RTP/UDP */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n\n            char buf[256];\n\n\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n\n                port = reply->transports[0].client_port_min;\n\n                goto have_port;\n\n            }\n\n\n\n            /* first try in specified port range */\n\n            while (j <= rt->rtp_port_max) {\n\n                ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n\n                            \"?localport=%d\", j);\n\n                /* we will use two ports per rtp stream (rtp and rtcp) */\n\n                j += 2;\n\n                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,\n\n                               &s->interrupt_callback, NULL))\n\n                    goto rtp_opened;\n\n            }\n\n\n\n            av_log(s, AV_LOG_ERROR, \"Unable to open an input RTP port\\n\");\n\n            err = AVERROR(EIO);\n\n            goto fail;\n\n\n\n        rtp_opened:\n\n            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n\n        have_port:\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;\", trans_pref);\n\n            if (rt->server_type != RTSP_SERVER_REAL)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                     \"client_port=%d\", port);\n\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n            /* For WMS streams, the application streams are only used for\n\n             * UDP. When trying to set it up for TCP streams, the server\n\n             * will return an error. Therefore, we skip those streams. */\n\n            if (rt->server_type == RTSP_SERVER_WMS &&\n\n                (rtsp_st->stream_index < 0 ||\n\n                 s->streams[rtsp_st->stream_index]->codec->codec_type ==\n\n                    AVMEDIA_TYPE_DATA))\n\n                continue;\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/TCP;\", trans_pref);\n\n            if (rt->transport != RTSP_TRANSPORT_RDT)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                        \"interleaved=%d-%d\",\n\n                        interleave, interleave + 1);\n\n            interleave += 2;\n\n        }\n\n\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;multicast\", trans_pref);\n\n        }\n\n        if (s->oformat) {\n\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n\n                   rt->server_type == RTSP_SERVER_WMS)\n\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n\n        snprintf(cmd, sizeof(cmd),\n\n                 \"Transport: %s\\r\\n\",\n\n                 transport);\n\n        if (rt->accept_dynamic_rate)\n\n            av_strlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd));\n\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n\n            char real_res[41], real_csum[9];\n\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n\n                                              real_challenge);\n\n            av_strlcatf(cmd, sizeof(cmd),\n\n                        \"If-Match: %s\\r\\n\"\n\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n\n                        rt->session_id, real_res, real_csum);\n\n        }\n\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n\n            err = 1;\n\n            goto fail;\n\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n\n                   reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n\n                reply->transports[0].transport != rt->transport) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->lower_transport = reply->transports[0].lower_transport;\n\n            rt->transport = reply->transports[0].transport;\n\n        }\n\n\n\n        /* Fail if the server responded with another lower transport mode\n\n         * than what we requested. */\n\n        if (reply->transports[0].lower_transport != lower_transport) {\n\n            av_log(s, AV_LOG_ERROR, \"Nonmatching transport in server reply\\n\");\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        switch(reply->transports[0].lower_transport) {\n\n        case RTSP_LOWER_TRANSPORT_TCP:\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n\n            char url[1024], options[30] = \"\";\n\n\n\n            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)\n\n                av_strlcpy(options, \"?connect=1\", sizeof(options));\n\n            /* Use source address if specified */\n\n            if (reply->transports[0].source[0]) {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n\n                            reply->transports[0].source,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            } else {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            }\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n\n                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            /* Try to initialize the connection state in a\n\n             * potential NAT router by sending dummy packets.\n\n             * RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n", "idx": 17766, "substitutes": {"s": ["cs", "server", "sf", "sys", "sa", "rs", "t", "ss", "sq", "sit", "ns", "si", "sed", "storage", "private", "ls", "sam", "gs", "c", "acs", "sb", "sci", "ts", "ks", "service", "ssl", "sl", "su", "fs", "services", "S", "sec", "sg", "ses", "sv", "os", "spec", "se", "ds"], "host": ["server", "header", "component", "http", "domain", "node", "prefix", "link", "Host", "proxy", "conn", "uri", "test", "ip", "localhost", "auth", "path", "address", "mac", "nick", "service", "ssl", "socket", "remote", "username", "method"], "port": ["cp", "server", "route", "PORT", "ports", "type", "pipe", "Port", "uri", "point", "ort", "ip", "message", "path", "address", "code", "phone", "hop", "stream", "profile", "file", "p", "channel", "pod", "method", "plugin"], "lower_transport": ["lower_ranspt", "lower_streampace", "lower_userport", "lower_ransort", "lower_streampt", "lower_ransrule", "lower_transfile", "lower_ranssource", "lower_usersource", "lower_ransport", "lower_ransPort", "lower_mailpt", "lower_transp", "lower_transports", "lower_middleport", "lower_ransports", "lower_streamort", "lower_streamport", "lower_mailpace", "lower_mailport", "lower_ranspace", "lower_userrule", "lower_userp", "lower_middleports", "lower_hostfile", "lower_hostPort", "lower_ransp", "lower_transsource", "lower_middlePort", "lower_middlefile", "lower_transort", "lower_ranp", "lower_transrule", "lower_ranport", "lower_hostports", "lower_ransource", "lower_transPort", "lower_transpt", "lower_mailort", "lower_transpace", "lower_ranrule", "lower_ransfile", "lower_hostport"], "real_challenge": ["realparentchallplay", "real_protonge", "real_protenge", "realparentopenplay", "realparentopenonge", "real_openenge", "realparentchallpe", "real_openpe", "real_dupe", "real_duplay", "real_challplay", "realparentchallonge", "real_duenge", "realparentopenenge", "real_openonge", "real_openplay", "realparentopenpe", "realparentchallenge", "real_challpe", "real_challonge", "real_duonge", "real_protpe", "real_protplay"], "rt": ["dr", "ru", "rat", "txt", "rr", "grad", "sett", "pt", "tp", "rs", "bt", "NT", "feat", "t", "sr", "apt", "rh", "error", "ort", "tr", "tm", "boot", "mt", "gd", "ut", "urt", "od", "dt", "tt", "r", "adr", "rx", "fr", "mot", "ott", "kt", "qt", "rb", "att", "rd", "nt", "ot", "gt", "rl", "irt", "rf", "nd", "tx", "yt", "hd", "vt", "ft", "ct", "vr", "rc", "ret", "rn", "RT", "ant", "dat", "rot", "rect", "ht", "art"], "j": ["g", "ja", "f", "jp", "xi", "x", "qi", "li", "t", "q", "ji", "d", "n", "jl", "job", "ij", "si", "jit", "dj", "h", "r", "index", "jet", "o", "aj", "w", "ii", "k", "jc", "p", "adj", "y", "ind", "uj", "b", "z", "l", "J", "v", "jj", "m"], "i": ["phi", "di", "f", "ri", "xi", "cli", "hi", "x", "qi", "u", "ci", "li", "eni", "ji", "bi", "uri", "api", "d", "it", "n", "ip", "ti", "pi", "si", "I", "jit", "id", "ij", "uni", "ai", "index", "r", "iu", "o", "ii", "c", "p", "y", "b", "ki", "z", "ei", "ui", "ni", "gi", "zi", "yi", "fi", "e", "l", "ori", "io", "ie", "ini", "v", "mi", "m"], "err": ["dr", "str", "server", "rr", "ry", "result", "error", "req", "init", "status", "ai", "fr", "aa", "next", "aaa", "y", "ind", "nil", "resp", "er", "e", "ie", "ini", "out", "go"], "port_off": ["port6diff", "portfleft", "port___max", "port2offset", "port_offset", "port_id", "portenoa", "port6off", "port_max", "key67length", "key67left", " port_id", "port_on", "port_and", "port_data", "portenlength", "key67off", "key_length", "portflength", "portfand", "portenoff", "port64name", "port2off", "portendata", "portenand", "ort_off", "port_oa", "ort_Off", "portenleft", "port_Off", "port___off", "port64id", "portaloff", "port_length", "port2pos", "port67length", "post_off", "portaloa", "post_offset", "key67and", "port2diff", "port_pos", " port_oa", "port_name", "key_left", " port_name", "port67and", "ort_max", "portfoff", "post_pos", "port_diff", "port6pos", "port67off", "portaldata", "port_left", "port___Off", "port___on", "key_and", "ort_on", "port6offset", "port67name", "post_diff", " port_data", "port64off", "port67left", "key_off", "port67id"], "rtsp_st": ["rtsnp_se", "rtsp_sl", "rtspec_st", "rtsp__stream", "rtsnp_st", "rtsp_se", "rtsnp_str", "rtsp_const", "rtspec_stream", "rtspec_est", "rtsp__se", "rtsper_const", "rtsp__st", "rtsp_sts", "rtsnp_sl", "rtsnp_stream", "rtsp_est", "rtsp_str", "rtsp_ST", "rtspec_stim", "rtsper_sts", "rtsp_stim", "rtsper_stack", "rtsp__str", "rtsper_st", "rtsp_stream", "rtsnp_ST", "rtsp_stack"], "reply1": ["reply2", "answer3", "Reply2", " reply3", "response3", "response1", "reply0", "next0", " reply2", "Reply1", "Reply0", "next1", "reply3", "next2", "answer2", "response2", " reply0", "answer1"], "reply": ["route", "result", "match", "frame", "prefix", "link", "proxy", "Reply", "connection", "address", "code", "pack", "entry", "respond", "write", "next", "reason", "answer", "flash", "response", "resp", "comment", " replies", "transfer", "msg", "send", "respons", "ack"], "cmd": ["batch", " req", "proc", "command", "req", " mac", "root", "config", "auth", "bid", " auth", "ctx", "cap", "mac", "comm", "loc", "unit", "msg", "Cmd", "rc", "seq", "opt", "box", "buff", " command", "bin", "alloc", "mode"], "trans_pref": ["trans_reef", "trans_proc", "trans_Prefer", "trans_perc", "trans_brefs", "trans_forefer", "trans_brec", "trans_foref", "trans_prof", "trans_perf", "trans_forec", "trans_foreef", "trans_prefs", "trans_peref", "trans_bref", "trans_ref", "trans_perfor", "trans_prec", "trans_Prec", "trans_prefer", "trans_perfer", "trans_profer", "trans_profor", "trans_Prefs", "trans_refer", "trans_perfs", "trans_forefor", "trans_preef", "trans_rec", "trans_brefer", "trans_prefor", "trans_Pref"], "transport": ["transort", "ransport", "teleort", "interport", "transform", "ransporter", "interort", "transtext", "teleport", "transp", "Transform", "Transtext", "Transp", " transform", "ransform", "teleporter", " transtext", "ransports", " transp", "interporter", "ransp", "teleports", "ranstext", "Transport", "transporter", "interports", "transports", "ransort"], "rtx": ["RTX", "ttxb", "ytex", "rtX", "rtc", "rotwy", "rcX", "qtX", "RTv", "dtx", "rtxs", "gtX", "rtxb", "rtz", "ttxs", "retxc", "rtv", "vrwx", "retc", "retfx", "rrwork", "rcfx", "rtwy", "rdX", "dtv", "aptfe", "rotx", "rtix", "ntX", "RTxy", "RTxb", "RTxc", "ttxc", "rotxb", "ortx", "ttwy", "rrx", "vrfx", "rtwx", "rtxp", "ortz", "gtxy", "rcxa", "rotix", "ntwork", "ntxc", "ytxc", "RTxes", "gtx", "rrxc", "rcx", "ttx", "rtfe", "rtxes", "aptX", "RTwx", "RTfe", "rtxc", "rtfx", "retix", "qtx", "rtxy", "retx", "retxp", "aptx", "aptxes", "retX", "rtwork", "retex", "rtxa", "drxc", "ntz", "qtxes", "RTfx", "RTc", "qtfe", "drex", "retxa", "rdx", "ortxc", "rotxp", "RTx", "rrX", "RTwy", "rcxp", "dtxy", "ortxs", "RTwork", "rotxa", "rdxc", "rcwx", "drfx", "drx", "dtX", "rcix", "vrx", "ttX", "rotX", "rtex", "vrX", "ytx", "rdc", "ttz", "ntxs", "gtv", "ntx", "ytfx"], "buf": ["batch", "map", "uf", "proc", "bin", "queue", "bc", "pad", "Buffer", "buffer", "wb", "pool", "conv", "base", "block", "cap", "ba", "bag", "func", "b", "cb", "num", "mem", "box", "buff", "Buff", "alloc", "br"]}}
{"project": "FFmpeg", "commit_id": "24130234cd9dd733116d17b724ea4c8e12ce097a", "target": 0, "func": "static int parse_fmtp(AVFormatContext *s,\n\n                      AVStream *stream, PayloadContext *data,\n\n                      const char *attr, const char *value)\n\n{\n\n    AVCodecParameters *par = stream->codecpar;\n\n    int res, i;\n\n\n\n    if (!strcmp(attr, \"config\")) {\n\n        res = parse_fmtp_config(par, value);\n\n\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (par->codec_id == AV_CODEC_ID_AAC) {\n\n        /* Looking for a known attribute */\n\n        for (i = 0; attr_names[i].str; ++i) {\n\n            if (!av_strcasecmp(attr, attr_names[i].str)) {\n\n                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {\n\n                    *(int *)((char *)data+\n\n                        attr_names[i].offset) = atoi(value);\n\n                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)\n\n                    *(char **)((char *)data+\n\n                        attr_names[i].offset) = av_strdup(value);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17786, "substitutes": {"s": ["g", "cs", "server", "sys", "f", "session", "src", "ps", "rs", "sq", "d", "n", "r", "parser", "o", "w", "c", "p", "fs", "e", "sv", "a", "sc", "spec", "v", "m"], "stream": ["server", "resource", "trans", "rec", "coll", "src", "transform", "source", "cur", "document", "form", "sw", "feed", "view", "config", "path", "iv", "input", "ream", "raw", "Stream", "reader", "writer", "ctx", "fr", "w", "cont", "object", "context", "row", "port", "ack", "sc", "spec"], "data": ["di", "resource", "alpha", "rec", "session", "length", "this", "database", "extra", "name", "style", "cache", "type", "xml", "parent", "media", "DATA", "array", "na", "api", "li", "uri", "reg", "req", "d", "buffer", "error", "base", "Data", "record", "config", "memory", "address", "parser", "input", "addr", "ma", "reader", "writer", "ctx", "aa", "pre", "p", "decl", "da", "ada", "def", "ui", "bytes", "context", "la", "dat", "ata", "shared", "size", "offset"], "attr": ["ann", "val", "str", "rr", "option", "name", "type", "ac", "prefix", "feat", "op", "style", "kr", "api", "uri", "apt", "rel", "asc", "tag", "property", "config", "spr", "address", "code", "r", "adr", "addr", "rt", "typ", "atts", "att", "format", "var", "at", "acc", "prop", "url", "cmp", "expr", "opt", "air", "arr", "arg", "method", "spec", "attribute", "pr", "offset"], "value": ["val", "VALUE", "server", "resource", "expression", "option", "number", "name", "type", "values", "parent", "array", "media", "param", "uri", "buffer", "description", "valid", "property", "message", "version", "pair", "address", "r", "pa", "parser", "reader", "target", "write", "variable", "format", "object", "p", "var", "key", "service", "func", "content", "function", "null", "image", "context", "request", "field", "sv", "text", "model", "reference", "Value", "comp", "v", "attribute", "feature", "info"], "par": ["dr", "cp", "Par", "cat", "pol", "sp", "ps", "proc", "jp", "pc", "pal", "parent", "po", "cur", "param", "req", "rel", "peer", "pi", "pair", "parse", "ar", "pp", "pa", "r", "parser", "reader", "cap", "params", "pre", "p", "var", "prep", "pe", "car", "per", "cmp", "pro", "mp", "arr", "arg", "serv", "spec", "comp", "pr"], "res": ["core", "val", "cs", "results", "pres", "css", "min", "eps", "ms", "resolution", "result", "ps", "rest", "ids", "rs", "nos", "js", " Res", "reg", "vals", "req", "rh", "rar", "reed", "RES", "cons", "id", "reset", "Res", "rem", "r", "rss", "es", "rev", "errors", "ries", "gr", "powers", "p", "resh", " results", "ris", "sol", "resp", "re", "ress", "err", "rc", "ares", "ret", "os", "rows", "arr", "ras", "rep"], "i": ["di", "uli", "f", "ri", "xi", "cli", "qi", "idi", "u", "ix", "ci", "li", "source", "t", "eni", "bi", "uri", "ji", "it", "d", "mi", "ip", "si", "I", "pi", "multi", "id", "init", "index", "iv", "iu", "o", "lc", "ii", "c", "k", "p", "key", "y", "ind", "b", "ui", "ni", "gi", "adi", "fi", "anti", "e", "yi", "ori", "l", "io", "oi", "ie", "ini", "v", "ti", "j", "info"]}}
{"project": "FFmpeg", "commit_id": "4c8ca76965b1c29758246624940cbc529e7141f0", "target": 0, "func": "static int ffserver_set_int_param(int *dest, const char *value, int factor,\n\n                                  int min, int max, FFServerConfig *config,\n\n                                  const char *error_msg, ...)\n\n{\n\n    int tmp;\n\n    char *tailp;\n\n    if (!value || !value[0])\n\n        goto error;\n\n    errno = 0;\n\n    tmp = strtol(value, &tailp, 0);\n\n    if (tmp < min || tmp > max)\n\n        goto error;\n\n    if (factor) {\n\n        if (FFABS(tmp) > INT_MAX / FFABS(factor))\n\n            goto error;\n\n        tmp *= factor;\n\n    }\n\n    if (tailp[0] || errno)\n\n        goto error;\n\n    if (dest)\n\n        *dest = tmp;\n\n    return 0;\n\n  error:\n\n    if (config) {\n\n        va_list vl;\n\n        va_start(vl, error_msg);\n\n        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, error_msg, vl);\n\n        va_end(vl);\n\n    }\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 17787, "substitutes": {"dest": ["di", "trans", "txt", "dc", "output", "later", "option", "src", "route", "proc", "result", "rest", "name", "node", "temp", "transform", "source", "feat", "buf", "trip", "dim", "orig", "wb", "len", "comb", "dev", "path", "data", "target", "Dest", "loc", "cont", "std", "sup", "dist", "desc", "done", "prop", "opt", "master"], "value": ["wave", "val", "VALUE", "number", "range", "name", "type", "temp", "values", "source", "parent", "array", "prefix", "end", "valid", "test", "property", "message", "version", "address", "vector", "data", "diff", "input", "target", "anything", "format", "object", "key", "unit", "content", "function", "null", "element", "num", "start", "Value", "amount", "part", "v", "attribute", "size"], "factor": ["round", "fact", "scale", "multipl", "f", "operator", "length", "number", "fort", "currency", "force", "base", "fd", "version", "frequency", "mult", "frac", "span", "digit", "feature", "cover", "total", "format", "ffff", "character", "cost", "limit", "std", "unit", " factors", "rf", "fac", "period", "per", "actor", "weight", "prop", "bf", "Factor", "fe", "tier", "radius", "size", "amount", "fc", "part", "rate"], "min": ["val", "skip", "mins", "number", "range", "lower", "mod", "po", "in", "first", "len", "low", "small", "init", "diff", "mid", "span", "just", "only", "pre", "pos", "limit", "MIN", "unit", "mean", "up", "little", "count", "start", "from", "minimum", "pri", "size", "Min"], "max": ["val", "scale", "alpha", "length", "range", "ension", "x", "mod", "q", "end", "flow", "MAX", "d", "n", "base", "ax", "last", "frac", "w", "total", "gen", "height", "final", "p", "limit", "std", "up", "step", "count", "Max", "out", "size", "part", "v", "az", "ver"], "config": ["console", "core", "client", "project", "output", "acl", "src", "proc", "inc", "queue", "contract", "cache", "source", "ci", "bc", "conn", "param", "reg", "exec", "connection", "test", "front", "req", "lib", "Config", "path", "storage", "init", "control", "qa", "data", "ctx", "license", "fig", "lc", "design", "conf", "ext", "ca", "c", "channel", "service", "manager", "content", "comment", "cfg", "context", "ct", "gui", "cb", "subject", "network", "text", "driver", "que", "ini", "sc", "fc", "plugin", "attribute", "settings"], "error_msg": ["error2doc", "error_html", "ror_msg", "error_doc", " error_html", "error_cmd", "error_message", " error_Msg", " error_doc", "ror_cmd", "ror_message", "ror_err", "error2Msg", " error_message", "error_Msg", "error2msg", "error2message", "error_err"], "tmp": [" buf", "proc", "wp", " temp", "Temp", "api", "test", "pb", "frac", "abb", "done", "prop", "attr", "opt", " property", "TB", "temp", "buf", "pad", "force", "fee", "np", "bb", "beta", "duration", "emp", "tf", " backup", " ff", "sb", "fp", "var", "nb", "term", " amp", "mp", "foo", " param", "cp", "f", "kk", "src", "route", "tp", "stuff", " len", "nom", "treatment", " obj", " proto", "mult", "diff", " resp", "target", "rb", "elt", "sup", "dist", "vt", "cb", "area", "mm", " src", "amount", " temporary", "txt", "now", "bt", "prefix", "t", "perm", " addr", "obj", " result", "storage", "tt", "bps", "loc", "ext", "ref", "fac", "ptr", "tc", "bf", "cmp", "part", "fb", "amp"], "tailp": [" tailP", "fatbp", "leadP", "tailbp", "footf", "terminp", "footp", "tailprop", "letterpo", "fatP", "tailpart", "tailpo", "letterprop", "terminpoint", "ailpo", "leadp", " tailpart", "fatp", " tailbp", "pullpoint", "leadpo", "pullp", "letterpart", "tailf", " tailpo", "terminf", "tailP", "ailpart", "tailar", "terminar", "pullf", "leadbp", "pullar", "fatpo", "ailp", "ailprop", "footar", " tailprop", "footpoint", "tailpoint", "letterp"], "vl": ["uv", "lan", "lv", "ll", "aml", "cel", "owl", "lp", "li", "vel", "lr", "isl", "lf", "kl", "bp", "wl", "ml", "liv", "pb", "vp", " ls", "adr", "ls", "hl", " l", "ue", "dl", "lc", "nl", " li", "fl", "fp", "var", "rl", "vol", "vc", "LV", "sl", "ve", "las", "le", "vm", "la", "ql", "l", "lvl", "tl", "sv", "vv", "kb", "ln"]}}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n\n{\n\n    unsigned int tag;\n\n    int64_t size;\n\n\n\n    for (;;) {\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n        size = next_tag(pb, &tag);\n\n        if (tag == tag1)\n\n            break;\n\n        wav_seek_tag(pb, size, SEEK_CUR);\n\n    }\n\n    return size;\n\n}\n", "idx": 17792, "substitutes": {"pb": ["peg", "PB", "bs", "pc", "uf", "proc", "jp", "bc", "ppa", "xb", "lp", "bh", "api", "np", "bp", "obj", "pm", "hub", "fc", "cpp", "pg", "db", "pl", "platform", "pa", "ib", "bps", "eb", "ctx", "lc", "rb", "p", "sb", "fp", "abb", "cv", "hp", "b", "prot", "pkg", "tc", "cb", "ab", "bos", "dp", "mp", "lb", "rob", "fb"], "tag1": ["name1", "type1", "tag0", "TAG2", "code1", "code11", " tag0", "tagOne", "tag2", " tagOne", "TAG0", "name2", "name11", " tag11", "nameOne", "code2", " tag2", "TAG1", "type2", "codeOne", "type0", "tag11"], "tag": [" format", "peg", "TAG", "token", "length", "number", "category", "match", "type", "ac", "name", "style", "feat", "reg", "or", "len", " version", "id", " bug", "word", "offset", "code", "year", "ee", "loc", "c", "head", "p", "ag", "pos", "key", "patch", "pe", " count", " match", "comment", "sign", "use", "image", "month", "Tag", "count", "age", " type", "e", " length", "attr", "bug", "date", "tail"], "size": ["g", "scale", "length", "timeout", "number", "name", "type", "style", "sized", "cache", "six", "fee", "Size", "n", "len", "SIZE", "small", "id", "ize", "capacity", "speed", "address", "code", "index", "year", "ec", "sum", "loc", "body", "time", "c", "sync", "pos", "unit", "content", "z", "slice", "weight", "send", "bytes", "count", "sec", "shape", "e", "start", "empty", "offset"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_6REGS && HAVE_INLINE_ASM\n\n    if (INLINE_AMD3DNOWEXT(cpu_flags)) {\n\n        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;\n\n    }\n\n    if (INLINE_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul_window = vector_fmul_window_sse;\n\n    }\n\n#endif\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_sse;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;\n\n        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;\n\n        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;\n\n        fdsp->butterflies_float   = ff_butterflies_float_sse;\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_avx;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_avx;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;\n\n    }\n\n}\n", "idx": 17803, "substitutes": {"fdsp": ["fedsi", "fxsb", "fcsi", "dfst", "fdss", "fdbc", "dcsp", "dlserv", "fxsym", "ffscope", "fxso", "fcspec", "fdservice", "ffservice", "dlservice", "FDbc", "ffpy", "fxsh", "fedsh", "FDsh", "dlsp", "fxcp", "dlsync", "lfstatic", "fordsp", "fedscope", "dlso", "dfss", "cfscope", "dfapp", "fdsup", "fdsb", "dcserv", "fdso", "dfhtml", "fedsk", "dcst", "fdserv", "fxspe", "dfsb", "FDsp", "fedSp", "dlsb", "fxsr", "fdsi", "dfsp", "fxsk", "fdcp", "ffsh", "dlsi", "fcsb", "dfsi", "fxspec", "fdscope", "dfsh", "pdhtml", "fcserv", "dfserv", "ffspace", "ffsym", "fdSp", "fordsup", "fdspace", "fxsync", "FDsr", "dlsh", "fxbc", "ddsp", "fedsb", "FDSp", "dcbc", "dfspec", "ddso", "fcsh", "fxscope", "dlpy", "fedservice", "fwsp", "fordsh", "dlhtml", "dfcp", "pdsi", "pdsp", "fedpy", "fcstatic", "lfsh", "cfserv", "fdsh", "fwsh", "fxhtml", "ddspe", "fdsk", "dlbc", "fedspe", "fxsp", "dlst", "cfsp", "fcsk", "FDss", "fxsi", "dfbc", "dfscope", "dlstatic", "fwspace", "cfspec", "dlcp", "fordsr", "fdspe", "fdspec", "fwsym", "dlspec", "FDscope", "fdsym", "dfsr", "dlsr", "fcsr", "fdstatic", "fdpy", "dlapp", "fxspace", "lfscope", "fdapp", "dfsync", "ffsr", "fdhtml", "ffsup", "FDserv", "fedss", "dfso", "fedsp", "fcscope", "FDsk", "dlspe", "dfSp", "dlscope", "ffsp", "fdsr", "pdapp", "fcsup", "fxserv", "ddsync", "fdst", "dfsk", "fdsync", "FDspe", "lfsp", "dfspe", "fcsp"]}}
{"project": "qemu", "commit_id": "096685fc2a955ea17d5363ab452e301be2b43873", "target": 1, "func": "static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n\n\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* INTC_REVISION */\n\n        return s->revision;\n\n\n\n    case 0x10:\t/* INTC_SYSCONFIG */\n\n        return (s->autoidle >> 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}", "idx": 17805, "substitutes": {"opaque": ["pcode", "obcode", "opque", "opaco", "OPaque", "opcode", "opaques", "paque", " opaco", "obaque", "obaques", "OPque", " opque", "pque", "copaque", "OPaco", "copque", " opcode", "copaco", "obque", " opaques", "paques"], "addr": ["dr", "sid", "src", "mode", "node", "x", "prefix", "asm", " address", "pad", "ad", "ock", "point", "len", "mt", "oid", "address", "code", "r", "afi", "adr", "data", "byte", "ace", "mid", "hop", "mac", "align", "ref", "pos", "nr", "ada", "Address", "pointer", "ptr", "ocol", "eth", "rc", "seq", "alias", "amd", "setup", "amp", "offset"], "size": ["length", "number", "type", "Size", "len", "args", "SIZE", "ize", "blocks", "address", "data", "block", "align", " bytes", "bytes", "a", "offset"], "s": ["g", "self", "sites", "lines", "client", "or", "support", "h", "r", "parser", "gs", "c", "b", "ssl", " services", "ches", "socket", "fs", "su", "sets", "a", "outs", "ins", "m", "server", "sf", "http", "u", "ments", "ions", "ing", "ns", "si", "i", "your", "es", "als", "an", "sk", "p", "sb", "y", "ks", "ts", "services", "sv", "l", "sym", "words", "se", "its", "sync", "f", "ops", "this", "rs", "south", "single", "ss", "sq", "ings", "n", "ies", "o", "sky", "xs", "er", "S", "sg", "ses", "spec", "is", "cs", "sys", "aws", "sa", "ps", "new", "t", "d", "banks", "storage", "ls", "space", "w", "ers", "ic", "service", "comments", "ed", "e", "settings", "os", "ant", "acks", "sc", "ds", "v", "rates"], "bank_no": ["bankFyes", "codeIDname", "rule_code", "bankIDyes", "bankIDmo", " bank_number", "bank_state", "bank_id", "Bank_id", "bank_yes", "bank_eno", "line_mo", "code_yes", "bank_count", "code_nor", "bankIDnor", "bank_number", "work_number", "line_name", "bankFid", "bankIDno", "line_count", "bankFno", " bank_eno", "codeIDyes", "Bank_code", "work_yes", "bank_name", "code_name", "work_no", "bankJeno", "Bank_no", "codeIDnor", " bank_num", "bank_NO", " bank_NO", "code_no", "bank_mo", "bank_nor", "bankFcode", "bankIDcount", "bank_note", "Bank_yes", "bankJstate", "bankIDname", " bank_state", "bank_num", "codeIDno", "bankJnumber", "bank_code", "work_nor", "rule_note", "rule_no", "bankJno", "rule_number"], "line_no": ["flow_size", "bank_na", "Line_no", "block_number", "line_size", "Line_number", "block_nr", "flow_num", "flow_no", "flow_No", "line_number", "bank_number", "line_nr", "line_name", "Line_sn", "bank_name", "line_No", "line_na", "block_num", "line_num", "line_eno", "block_no", "line_sn", "Line_eno"], "bank": ["g", "core", "rec", "rule", "session", "match", "command", "node", "machine", "cache", "board", "view", "child", "record", "plugin", "support", "parser", "block", "byte", "account", "ga", "conf", "app", "b", "comment", "package", "issue", "order", "field", "can", "bo", "project", "com", "name", "work", "u", "bird", "ban", "bb", "plan", "rank", "parse", "data", "sk", "p", "sb", "key", "acc", "group", "cookie", "Bank", "model", "se", "bin", "sn", "scan", "abi", "q", "bn", "error", "buffer", "feed", "base", "bm", "config", "module", "pa", "ank", "input", "pay", "book", "file", "sky", "ve", "query", "spec", "go", "rate", "feature", "sa", "type", "pal", "prefix", "parent", "library", "bi", "root", "table", "banks", "bid", "storage", "pack", "camp", "ca", "k", "bridge", "ic", "service", "ay", "gp", "ant", "anc", "sc", "shadow", "an"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n", "idx": 17807, "substitutes": {"s": ["g", "self", "ms", "client", "session", "js", "same", "h", "gs", "conf", "c", "b", "ssl", "su", "fs", "stats", "as", "states", "sets", "qs", "m", "sf", "http", "u", "ns", "site", "si", "i", "your", "es", "us", "p", "sb", "ts", "ks", "y", "services", "l", "sym", "se", "its", "sync", "f", "ops", "rs", "ss", "sq", "n", "o", "sky", "xs", "sim", "S", "bis", "sg", "ses", "spec", "is", "cs", "sys", "aws", "ps", "t", "parts", "d", "ls", "w", "service", "e", "os", "features", "ds", "an"], "range": ["lim", "hide", "val", "ange", "scale", "resource", "rule", "f", "timeout", "length", "route", "cal", "domain", "type", "cache", "array", "ang", "grade", "end", "scope", "force", "gap", "no", "ge", "base", "view", "version", "low", "chain", "max", "r", "fr", "diff", "span", "binary", "repeat", "call", "dy", "side", "live", "line", "limit", "role", "update", "err", "use", "ne", "num", "row", "query", "Range", " Range", "ranged", "date", "offset"], "xmin": ["ixmin", " xMin", "yspan", "ixmax", "xstart", "Xid", " xpart", "xid", "ystart", "xMin", "Xstart", "xpart", "ypart", " xid", "axpart", "xspan", "axmin", "ixspan", " xspan", "Xmin", "yMin", "axstart", " xstart", "yid", "Xmax", "axmax", "ixMin"], "ymin": ["xmit", "xmid", " ymid", "Ymon", "rystart", "eymin", " ystart", " ymit", " ymon", "rymini", "mystart", "mymax", "mymin", "xstart", "rymon", "ymid", "xmon", "chmit", "ymini", "chmax", "mymid", "ystart", "eymini", "Ystart", "Ymini", "chmon", "ymon", "Ymin", "ymit", "eystart", "rymin", "eymon", "chmin"], "xmax": ["rxmax", "fxmax", "mxlast", "xlast", "XMAX", "xend", "yend", "fxmin", "hend", "mxmin", "mxend", "xxend", "hmin", "xdev", "Xdev", "mxmax", "xMAX", "xxmin", "xxmax", "mxdev", "Xmin", "xxdev", "hlast", "hmax", "yMAX", " xMAX", "Xlast", "rxlast", "fxend", "Xend", "rxdev", "ylast", "rxmin", "Xmax", "fxlast"], "ymax": ["smoo", "emad", "smax", "smase", "ymand", "tmatch", "ymazon", "ymmad", "pmad", "ymmatch", "immaz", "smazon", "ymatch", "iemase", "iemax", "mxase", "immase", "tmazon", "ymmmax", "ymoo", "pmmax", "mxazon", "ymmit", "ymaz", "ymase", "smaz", "smatch", "tmax", "immax", "immoo", "iemoo", "ymmase", "dimazon", "ymmax", "ymmand", "dimax", "emand", "pmand", "emmax", "ymit", "tmit", "ymad", "ymmazon", "pmax", "dimatch", "mxax", "dimit", "mxatch", "iemaz", "emax"], "f_code": ["f6codes", "fqcode", "c_id", " f_count", "f_id", "c_count", "f__count", "f6cod", " f_cod", "fqcount", "fqcodes", "f6count", "f__id", "f__code", "fqid", "f6code", "c_code", "f__codes", "c_codes", "f_codes", "f_cod", " f_codes", "f_count"]}}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "static int device_try_init(AVFormatContext *ctx,\n\n                           enum AVPixelFormat pix_fmt,\n\n                           int *width,\n\n                           int *height,\n\n                           uint32_t *desired_format,\n\n                           enum AVCodecID *codec_id)\n\n{\n\n    int ret, i;\n\n\n\n    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);\n\n\n\n    if (*desired_format) {\n\n        ret = device_init(ctx, width, height, *desired_format);\n\n        if (ret < 0) {\n\n            *desired_format = 0;\n\n            if (ret != AVERROR(EINVAL))\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    if (!*desired_format) {\n\n        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n\n            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||\n\n                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {\n\n                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",\n\n                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),\n\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));\n\n\n\n                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;\n\n                ret = device_init(ctx, width, height, *desired_format);\n\n                if (ret >= 0)\n\n                    break;\n\n                else if (ret != AVERROR(EINVAL))\n\n                    return ret;\n\n                *desired_format = 0;\n\n            }\n\n        }\n\n\n\n        if (*desired_format == 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"\n\n                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",\n\n                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,\n\n                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    *codec_id = avpriv_fmt_v4l2codec(*desired_format);\n\n    av_assert0(*codec_id != AV_CODEC_ID_NONE);\n\n    return ret;\n\n}\n", "idx": 17808, "substitutes": {"ctx": ["cca", "cp", "cs", "progress", "txt", "cm", "client", "coll", "component", "dc", "cal", "grad", "ck", "jp", "cli", "wp", "uc", "bc", "instance", "media", "ci", "gc", "na", "conn", "api", "exec", "connection", "cor", "conv", "hw", "cms", "config", "cpp", " context", "fw", "support", "session", "qa", "wx", "cas", "concept", "kt", "lc", "qt", "ga", "loc", "ca", "cf", "mac", "c", "ce", "cam", "cv", "sci", "vc", "kw", "cc", "tx", "pkg", "tc", "Context", "context", "git", "wcs", "cb", "cmp", "ctrl", "anc", "xc", "kb", "sc", "event", "sync", "cn"], "pix_fmt": ["pix_tffm", "pix_fwt", "pix_fformat", "pix_formfm", "pix_fMT", "pix_formwt", "pix_formformat", "pix_formmt", "pix_tfMT", "pix_bMT", "pix_ftt", "pix_bmt", "pix_defwt", "pix_deftt", "pix_bfm", "pix_tfformat", "pix_tfmt", "pix_bformat", "pix_defmt", "pix_btt", "pix_ffm", "pix_bwt", "pix_defformat", "pix_formMT", "pix_formtt"], "height": ["ty", "layout", "length", "resolution", "tight", "Height", "images", "dim", "window", "inches", "gap", "view", "high", "bottom", "direction", "h", "build", "padding", "huge", "input", "upper", "volume", "w", "above", "depth", "y", "gh", "stroke", "deep", "thin", "density", "image", "pull", "row", "shape", "hold", "history", "thumbnails", "rows", " heights", "crop", "size"], "desired_format": ["deserved_unit", "desired_layout", "desired24audio", "desire_unit", "desired_attribute", "desirednversion", "desire_form", "desired__transform", "desirable_version", "desired_version", "desired_scale", "deserved_version", "deserved_spec", "desired_form", "desired_language", "desirednattribute", "desired24spec", "desired_type", "desiring_scale", "desired__version", "desire_format", "desired_service", "desired_width", "desiring_unit", "desired_flat", "desire_transform", "desire_version", "desiring_type", "desired__format", "desiring_version", "desirednflat", "desirable_attribute", "desired24version", "desiring_width", "desired_audio", "desiring_service", "desired24format", "desiring_format", "desired_spec", "desire_layout", "desiring_language", "desirable_format", "desirednformat", "deserved_audio", "desired_unit", "desired_transform", "desirable_flat", "desire_type", "desiring_transform", "deserved_format"], "codec_id": ["codec_ref", "codic_id", "codec2ident", "codec_ident", "codec2ip", "codecSid", "codecSip", "codec_def", "codec_ids", "codef_id", "coduc_in", "codec2name", "codef_ident", "codec_info", "codef2name", "codef2ip", "codEC_type", "codEC_id", "codec_in", "coduc_ref", "codef2ident", "codef_ip", "codecSID", "codic_info", "codec_name", "coduc_type", "codef_name", "codec_ip", "codEC_ids", "codec_type", "codic_ID", "codEC_def", "codecSinfo", "coduc_id", "codef2id", "codic_ip", "codec_ID", "codec2id"], "ret": ["reply", "val", "get", "match", "x", "sr", "valid", "fun", "pet", "code", "r", "pat", "rl", "flag", "lit", "arg", "rt", "bit", "let", "res", "reg", "req", "py", "red", "fail", "fit", "full", "data", "usr", "rev", "nt", "sb", "def", "value", "desc", "url", "art", "RET", "f", "cat", "lt", "error", "id", "db", "entry", "pass", "iter", "att", "rb", "format", "pret", "en", "rc", "Ret", "arr", "rep", "info", "str", "html", "result", "alt", "feat", "t", "success", "back", "len", "obj", "mt", " result", "status", "rets", "ref", "det", "active", "gt", "rf", "re", "ft", "bf", "bad", "part"], "i": ["g", "phi", "di", "inner", "f", "ri", "xi", "jp", "qi", "ix", "u", "ci", "li", "abi", "eni", "mu", "uri", "bi", "it", "d", "mi", "ir", "n", "ip", "si", "I", "pi", "id", "multi", "module", "init", "ai", "index", "iu", "o", "lc", "ii", "iii", "p", "y", "ind", "ki", "b", "slice", "m", "ui", "ni", "zi", "gi", "fi", "yi", "e", "l", "io", "oi", "ie", "ini", "part", "v", "ti", "j", "info"]}}
{"project": "qemu", "commit_id": "2f0772c5b4818d4b2078be9dace0036d1030faee", "target": 1, "func": "static void lsi_soft_reset(LSIState *s)\n\n{\n\n    lsi_request *p;\n\n\n\n    DPRINTF(\"Reset\\n\");\n\n    s->carry = 0;\n\n\n\n    s->msg_action = 0;\n\n    s->msg_len = 0;\n\n    s->waiting = 0;\n\n    s->dsa = 0;\n\n    s->dnad = 0;\n\n    s->dbc = 0;\n\n    s->temp = 0;\n\n    memset(s->scratch, 0, sizeof(s->scratch));\n\n    s->istat0 = 0;\n\n    s->istat1 = 0;\n\n    s->dcmd = 0x40;\n\n    s->dstat = LSI_DSTAT_DFE;\n\n    s->dien = 0;\n\n    s->sist0 = 0;\n\n    s->sist1 = 0;\n\n    s->sien0 = 0;\n\n    s->sien1 = 0;\n\n    s->mbox0 = 0;\n\n    s->mbox1 = 0;\n\n    s->dfifo = 0;\n\n    s->ctest2 = LSI_CTEST2_DACK;\n\n    s->ctest3 = 0;\n\n    s->ctest4 = 0;\n\n    s->ctest5 = 0;\n\n    s->ccntl0 = 0;\n\n    s->ccntl1 = 0;\n\n    s->dsp = 0;\n\n    s->dsps = 0;\n\n    s->dmode = 0;\n\n    s->dcntl = 0;\n\n    s->scntl0 = 0xc0;\n\n    s->scntl1 = 0;\n\n    s->scntl2 = 0;\n\n    s->scntl3 = 0;\n\n    s->sstat0 = 0;\n\n    s->sstat1 = 0;\n\n    s->scid = 7;\n\n    s->sxfer = 0;\n\n    s->socl = 0;\n\n    s->sdid = 0;\n\n    s->ssid = 0;\n\n    s->stest1 = 0;\n\n    s->stest2 = 0;\n\n    s->stest3 = 0;\n\n    s->sidl = 0;\n\n    s->stime0 = 0;\n\n    s->respid0 = 0x80;\n\n    s->respid1 = 0;\n\n    s->mmrs = 0;\n\n    s->mmws = 0;\n\n    s->sfs = 0;\n\n    s->drs = 0;\n\n    s->sbms = 0;\n\n    s->dbms = 0;\n\n    s->dnad64 = 0;\n\n    s->pmjad1 = 0;\n\n    s->pmjad2 = 0;\n\n    s->rbc = 0;\n\n    s->ua = 0;\n\n    s->ia = 0;\n\n    s->sbc = 0;\n\n    s->csbc = 0;\n\n    s->sbr = 0;\n\n    while (!QTAILQ_EMPTY(&s->queue)) {\n\n        p = QTAILQ_FIRST(&s->queue);\n\n        QTAILQ_REMOVE(&s->queue, p, next);\n\n        g_free(p);\n\n    }\n\n    if (s->current) {\n\n        g_free(s->current);\n\n        s->current = NULL;\n\n    }\n\n}\n", "idx": 17833, "substitutes": {"s": ["g", "ms", "session", "js", "h", "r", "gs", "conf", "c", "ssl", "b", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "results", "http", "u", "ments", "in", "ns", "ans", "site", "si", "args", "has", "i", "tests", "your", "data", "addr", "es", "us", "params", "an", "ts", "y", "ks", "services", "l", "sym", "its", "sync", "the", "ats", "ops", "f", "this", "rs", "ss", "sq", "n", "_", "by", "vs", "o", "xs", "S", "sg", "ses", "is", "cs", "sys", "ps", "type", "new", "t", "parts", "d", "status", "ls", "w", "sum", "all", "service", "ctr", "seq", "e", "os", "features", "ds", "v", "settings"], "p": ["f", "pc", "sp", "ps", "tp", "proc", "wp", "jp", "op", "t", "param", "q", "d", "pers", "r", "data", "o", "w", "params", "pre", "c", "P", "fp", "e", "os", "port", "v", "m"]}}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n", "idx": 17877, "substitutes": {"s": ["g", "core", "self", "sites", "lines", "js", "plugins", "gs", "conf", "c", "b", "ssl", "obs", "su", "fs", "stats", "states", "sets", "ins", "qs", "m", "sf", "u", "ns", "np", "site", "si", "full", "es", "us", "p", "sb", "ts", "ks", "sis", "current", "services", "sv", "l", "sym", "sync", "f", "ops", "this", "south", "ss", "sq", "o", "ctx", "sky", "xs", "sup", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "aws", "ps", "t", "parts", "ls", "side", "service", "comments", "e", "os", "features", "ds", "settings"], "icoef": ["ilief", "icoiff", "icoeb", "icoEF", "ilialf", "ichoefined", "icaouf", "ICOEF", "icoefined", "iciefined", "iliEF", "iciff", "icief", "coEF", "coeff", "ichoef", "ICOeff", "cief", "icoalf", "icoeff", "ichoeff", "icaef", "iscef", "icef", "icaEF", "ichoiff", "iliouf", "ICOef", "ICOeb", "icaalf", "icefined", "cieff", "iscEF", "cieb", "ciEF", "icoouf", "icieff", "coef", "iceff", "iscalf", "iscouf", "iciiff", "coeb"], "pred": ["core", "val", "vec", "rec", "surv", "result", "report", "cast", "success", "expected", "reg", "repl", "Pred", "test", "valid", "feed", "red", "old", "obj", "prev", "fitted", "sd", "support", "fit", "code", "dict", "proof", "data", "redict", "stat", "pre", "loc", "callback", "gen", "object", "p", "post", "score", "prep", "pos", "ind", "future", "lex", "def", "dist", "fb", "tested", "gold", "prop", "eddy", "fn", "ab", "seed", "ed", "model", "pro", "text", "sub", "pect", "arr", " predict", "ped", "cod", "confidence", "confirmed", "cept", "rep", "info"], "ich": ["g", "di", "chip", "ICH", "ill", "x", "ix", "qi", "ci", "sh", "iche", "h", "code", "act", "ench", "c", "ait", "rich", "cm", "rh", "ai", "ik", "img", "dom", "che", "Ch", "chn", "icy", "ach", "arch", "host", "fact", "imp", "orient", "anch", "f", "intel", "hard", "aff", "q", "igh", "ip", "config", "icht", "irc", "init", "interest", "ii", "channel", "ind", "cot", "ct", "ht", "ish", "isch", "inch", "dim", "ch", "ocl", "isc", "ict", "chi", "ig", "mot", "hop", "egg", "ic", "ike", "ih", "ei", "chid", "cht", "och", "im", "ie"], "i": ["g", "phi", "di", "f", "ri", "xi", "cli", "hi", "jp", "qi", "ix", "u", "x", "ci", "li", "in", "t", "eni", "bi", "uri", "api", "it", "ir", "ip", "ti", "I", "pi", "ch", "si", "id", "multi", "ai", "index", "chi", "ik", "iu", "o", "ii", "c", "k", "p", "ic", "y", "ind", "b", "ki", "ih", "sup", "ei", "ui", "ni", "zi", "gi", "ami", "yi", "fi", "e", "ori", "l", "a", "io", "isi", "ie", "ini", "oi", "im", "v", "mi", "j", "m"]}}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n", "idx": 17883, "substitutes": {"ds": ["ys", "cs", "cd", "dh", "df", "dc", "bs", "ps", "plays", "pd", "rs", "dd", "ss", "dm", "d", "ns", "gd", "sd", "dt", "db", "Ds", "ls", "dds", "DS", "dl", "gs", "ld", "da", "ks", "xd", "xs", "fs", "hd", "uds", "sts", "dn", "md"], "src_x": [" src_work", "src_image", "src_no", "src00no", "src00x", "src00xy", "src00work", "src_xy", "src00y", " src_image", " src_xy", " src_no", "src_work", "src00image"], "src_y": ["src_ny", " src_ny", "src_oy", "src_Y", "dest_y", "dest_oy", "dest_x", "src_z", "dest_z", " src_Y"], "dst_x": ["dst00x", "dest_id", "dst00ux", "dst_name", "ddest_X", "dst00y", "dst_ux", "dest_on", "dsts_y", "dst_X", "dst00name", "dsts_ux", "dsts_x", "dsts_name", "dst_id", "dest_y", "ddest_x", "ddest_y", "dest_x", "dst_ix", "ddest_ix", "dst_on"], "dst_y": ["dst00x", "dst_ny", "dst_yl", "dst__x", "dest_by", "dst00ny", "dst__yi", "dst00y", "dst__y", "dstJy", "dstJyl", "dest_yl", "dst_yi", "dst__by", "dstJx", "dest_vy", "dst_vy", "dstJvy", "dest_ny", "dstJz", "dest_y", "dest_yi", "dst00yi", "dst_z", "dest_x", "dstJby", "dst_by", "dst__vy", "dest_z", "dst__ny"], "w": ["ow", "f", "wt", "x", "u", "t", "q", "wh", "sw", "d", "wb", "n", "we", "wl", "hw", "fw", "aw", "r", "max", "wx", "win", "o", "ew", "wd", "c", "k", "p", "y", "b", "iw", "z", "wy", "e", "l", "ww", "tw", "a", "wa", "W", "rw", "v", "m"], "h": ["g", "f", "hi", "x", "u", "oh", "sh", "t", "q", "bh", "uh", "d", "H", "ch", "hw", "i", "r", "o", "help", "c", "k", "p", "ha", "y", "gh", "b", "z", "hh", "hd", "en", "e", "l", "ph", "hs", "wa", "hm", "ht", "v", "host", "m"], "vd": ["dr", "dh", "df", "dc", "lv", "ud", "pd", "dd", "d", "sd", "gd", "vid", "db", "dt", "va", "vp", "dl", "wd", "sb", "ld", "vg", "VD", "vc", "nd", "xd", "hd", "nv", "vt", "vm", "vr", "sv", "dn", "VS", "v"], "vs": ["ys", "dr", "cs", "eps", "ils", "verts", "ves", "styles", "vas", "ms", "ops", "bs", "ov", "ps", "plays", "pps", "docs", "rs", "ss", "sr", "vals", "alls", "prev", "ns", "plugins", "vi", "fg", "vid", "vers", "asts", " VS", "va", "versions", "vp", "ls", "es", "forces", "Vs", "iss", "gs", "sk", "ums", "s", "vg", "ks", "vc", "cv", "ts", "obs", "xs", "oss", "fs", "vt", "vm", "vr", "cb", "sts", "sv", "os", "otes", "VS", "qs", "v"]}}
{"project": "qemu", "commit_id": "da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56", "target": 1, "func": "static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n", "idx": 17885, "substitutes": {"base": ["local", "core", "server", "class", "rule", "handle", "name", "type", "cache", "prefix", "parent", "mod", "instance", "super", "old", "buffer", "Base", "id", "state", "db", "status", "address", "build", "ace", "block", "lc", "ca", "loop", "c", "file", "object", "bas", "store", "b", "create", "home", "zero", "area", "model", "bu", "builder"], "card": ["core", "self", "class", "coll", "rule", "dc", "component", "node", "cache", "cast", "valid", "view", "record", "play", "cl", "code", "ard", "cards", "call", "cf", "gen", "c", "game", "gu", "thread", "car", "comment", "field", "can", "server", "check", "carry", "mod", "load", "add", "parse", "Card", "cas", "man", "draw", "cell", "role", "element", "arc", "die", "row", "bug", "day", "list", "host", "cat", "this", "ck", "old", "module", "entry", "pass", "lc", "book", "file", "cc", "create", "custom", "parent", "back", "controller", "word", "read", "ca", "ce", "service", "star", "cart", "event"], "vevent": ["VEevent", "eveevent", " vecf", "VEcf", "vection", "evegent", "evecf", "teder", "vegent", "tegent", "eveder", "pection", "pegent", "veder", "evevent", "peder", "tevent", "veevent", "VEquest", "vequest", "vecf", "VEvent", "evequest", "evection", " veevent", "tection", "pevent", " vequest"]}}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n", "idx": 17893, "substitutes": {"h": ["header", "http", "oh", "sh", "bh", "q", "eh", "t", "rh", "n", "H", "ch", "hw", "i", "cpp", "hl", "ctx", "ec", "w", "him", "c", "p", "ha", "he", "hp", "gh", "b", "ih", "hh", "hd", "image", "ahi", "context", "e", "ph", "hs", "ah", "hm", "ht", "v", "host", "m"], "qscale": ["qcale", "bitscale", " qcale", "qslice", "bitcale", "qqscale", "qqcale", "bitset", "eqslice", "qshape", "qualscale", " qshape", "qualslice", "eqscale", "qset", "bitslice", "wscale", "wshape", "eqcale", "qqshape", "eqset", "wcale", "qualset", "qualcale"]}}
{"project": "FFmpeg", "commit_id": "fe8c9420dd5bbc7a0c545e479da9118bcf311dd2", "target": 1, "func": "int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)\n\n{\n\n    int e;\n\n    int bit_count_start = get_bits_count(gb_host);\n\n    int header;\n\n    int bits_consumed;\n\n    GetBitContext gbc = *gb_host, *gb = &gbc;\n\n\n\n    header = get_bits1(gb);\n\n    if (header) {     //enable_ps_header\n\n        ps->enable_iid = get_bits1(gb);\n\n        if (ps->enable_iid) {\n\n            int iid_mode = get_bits(gb, 3);\n\n            if (iid_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"iid_mode %d is reserved.\\n\",\n\n                       iid_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_iid_par    = nr_iidicc_par_tab[iid_mode];\n\n            ps->iid_quant     = iid_mode > 2;\n\n            ps->nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];\n\n        }\n\n        ps->enable_icc = get_bits1(gb);\n\n        if (ps->enable_icc) {\n\n            ps->icc_mode = get_bits(gb, 3);\n\n            if (ps->icc_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"icc_mode %d is reserved.\\n\",\n\n                       ps->icc_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_icc_par = nr_iidicc_par_tab[ps->icc_mode];\n\n        }\n\n        ps->enable_ext = get_bits1(gb);\n\n    }\n\n\n\n    ps->frame_class = get_bits1(gb);\n\n    ps->num_env_old = ps->num_env;\n\n    ps->num_env     = num_env_tab[ps->frame_class][get_bits(gb, 2)];\n\n\n\n    ps->border_position[0] = -1;\n\n    if (ps->frame_class) {\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = get_bits(gb, 5);\n\n    } else\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = (e * numQMFSlots >> ff_log2_tab[ps->num_env]) - 1;\n\n\n\n    if (ps->enable_iid) {\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_iid_data(avctx, gb, ps, ps->iid_par, huff_iid[2*dt+ps->iid_quant], e, dt))\n\n                goto err;\n\n        }\n\n    } else\n\n        memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n\n\n    if (ps->enable_icc)\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_icc_data(avctx, gb, ps, ps->icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))\n\n                goto err;\n\n        }\n\n    else\n\n        memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n\n\n    if (ps->enable_ext) {\n\n        int cnt = get_bits(gb, 4);\n\n        if (cnt == 15) {\n\n            cnt += get_bits(gb, 8);\n\n        }\n\n        cnt *= 8;\n\n        while (cnt > 7) {\n\n            int ps_extension_id = get_bits(gb, 2);\n\n            cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);\n\n        }\n\n        if (cnt < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"ps extension overflow %d\\n\", cnt);\n\n            goto err;\n\n        }\n\n        skip_bits(gb, cnt);\n\n    }\n\n\n\n    ps->enable_ipdopd &= !PS_BASELINE;\n\n\n\n    //Fix up envelopes\n\n    if (!ps->num_env || ps->border_position[ps->num_env] < numQMFSlots - 1) {\n\n        //Create a fake envelope\n\n        int source = ps->num_env ? ps->num_env - 1 : ps->num_env_old - 1;\n\n        int b;\n\n        if (source >= 0 && source != ps->num_env) {\n\n            if (ps->enable_iid) {\n\n                memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));\n\n            }\n\n            if (ps->enable_icc) {\n\n                memcpy(ps->icc_par+ps->num_env, ps->icc_par+source, sizeof(ps->icc_par[0]));\n\n            }\n\n            if (ps->enable_ipdopd) {\n\n                memcpy(ps->ipd_par+ps->num_env, ps->ipd_par+source, sizeof(ps->ipd_par[0]));\n\n                memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));\n\n            }\n\n        }\n\n        if (ps->enable_iid){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (FFABS(ps->iid_par[ps->num_env][b]) > 7 + 8 * ps->iid_quant) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"iid_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        if (ps->enable_icc){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (ps->icc_par[ps->num_env][b] > 7U) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"icc_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        ps->num_env++;\n\n        ps->border_position[ps->num_env] = numQMFSlots - 1;\n\n    }\n\n\n\n\n\n    ps->is34bands_old = ps->is34bands;\n\n    if (!PS_BASELINE && (ps->enable_iid || ps->enable_icc))\n\n        ps->is34bands = (ps->enable_iid && ps->nr_iid_par == 34) ||\n\n                        (ps->enable_icc && ps->nr_icc_par == 34);\n\n\n\n    //Baseline\n\n    if (!ps->enable_ipdopd) {\n\n        memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n        memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    }\n\n\n\n    if (header)\n\n        ps->start = 1;\n\n\n\n    bits_consumed = get_bits_count(gb) - bit_count_start;\n\n    if (bits_consumed <= bits_left) {\n\n        skip_bits_long(gb_host, bits_consumed);\n\n        return bits_consumed;\n\n    }\n\n    av_log(avctx, AV_LOG_ERROR, \"Expected to read %d PS bits actually read %d.\\n\", bits_left, bits_consumed);\n\nerr:\n\n    ps->start = 0;\n\n    skip_bits_long(gb_host, bits_left);\n\n    memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n    memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n    memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n    memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    return bits_left;\n\n}\n", "idx": 17904, "substitutes": {"avctx": ["evctx", "afctx", "aflc", "avconn", "afContext", "evcontext", "AVContext", "devcf", " avcontext", "avcontext", "AVlc", "devcu", "afconn", "verctx", "AVctx", "vercf", "evlc", "devctx", " avContext", " avlc", "AVcontext", "devcontext", "vercu", "avcu", "avlc", "avcf", "AVcf", "vercontext", "AVcu", "AVconn", "evconn", "avContext", "afcontext"], "gb_host": ["sb_address", "rgamhost", "rgamsource", "sb_host", "rgamaddress", "rg_host", "gb_conn", "gg_host", "gb_source", "gbamaddress", "rg_address", "sb_conn", "gb_server", "gg_server", "gbamhost", "sb_server", "gg_port", "gb_component", "gb_address", "gbamserver", "rgamserver", "rg_server", "rg_source", "gg_component", "gb_port", "gbamsource"], "ps": ["maps", "self", "lines", "ms", "bs", "sp", "wp", "ds", "js", "plugins", "pes", "aps", "pers", "pl", "cop", "posts", "gs", "fs", "points", "ins", "qs", "eps", "pres", "pt", "http", "ples", "ppa", "ns", "tests", "als", "params", "sk", "p", "ks", "ts", "its", "cp", "pex", "ats", "ops", "pc", "pps", "tp", "style", "Ps", "rs", "ss", "ups", "ips", "pp", "pa", "vs", "amps", "pass", "files", "pre", "pos", "per", "options", "ras", "ys", "changes", "cs", "css", "ims", "ports", "parts", "PS", "pg", "ls", "pse", "details", "pe", "pull", "times", "pr"], "bits_left": ["bitsScount", "bits_content", " bits_right", " bits_count", "bitsSright", "bitsSleft", "bits_count", " bits_content", "bits_right", "bitsScontent"], "e": ["g", "eu", "x", "end", "or", "code", "r", "ee", "c", "line", "z", "bytes", "ey", "fe", "layer", "m", "je", "add", "i", "es", "eb", "ze", "esi", "ea", "p", "s", "y", "ade", "ne", "element", "l", "se", "comp", "j", "f", "this", "oe", "error", "buffer", "n", "ge", "_", "est", "config", "entity", "E", "o", "ace", "ue", "body", "pos", "er", "en", "ev", "ele", "el", "d", "dt", "ae", "ec", "see", "all", "ce", "de", "pe", "event", "edge", "ei", "ie", "eg", "debug", "v"], "header": ["dr", "server", "skip", "numbered", "rr", "f", "length", "result", "type", "Header", "frame", "headers", "parent", "source", "grade", "error", "buffer", "aster", "valid", "bb", "border", "table", "position", "version", "metadata", "config", "auth", "forward", "h", "duration", "index", "padding", "data", "binary", "writer", "reader", "meta", "cover", "body", "ref", "head", "bridge", "fp", "channel", "p", "comment", "err", "request", "vv", "master", "event", "layer", "player", "offset"], "bits_consumed": ["bits_comerved", "bits_Consovered", "bits_conserved", "bits_consovered", "bits_comovered", "bits_Consume", "bits_Conserved", "bits_comume", "bits_colume", "bits_columed", "bits_Consumed", "bits_consume", "bits_colerved", "bits_comumed", "bits_colovered"], "gb": ["g", "gm", "gru", "gin", "pc", "bc", "gam", "gc", "bn", "bb", "hd", "bp", "hub", "gd", "boot", "bm", "lib", "gal", "pg", "db", "storage", "cgi", "eb", "ctx", "ga", "gs", "gram", "rb", "gnu", "game", "sb", "abb", "ha", "vg", "gl", "mb", "rg", "gp", "cfg", "agg", "ui", "gz", "gae", "gi", "git", "gy", "cb", "nb", "buff", "sg", "bf", "gg", "ub", "GB", "kb", "lb", "usb", "gom", "bg", "sync"], "num_env": ["nb_enc", "num_exe", "num_en", "num_win", "num_environment", "max_environment", " num__env", " num_exe", "numallenv", "numallenvironment", "numMen", " num_environment", "max_extra", "nb_vs", " num_vs", "numallextra", "num__env", " num__vs", "num_vs", "max_env", "nb_win", " num_enc", "num__en", "max_enc", "nb_env", " num__exe", "numallenc", "numMexe", "numMenv", " num__en", "num__exe", "num__vs", "num_enc", " num_en", "numMvs", "num_extra"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        int size;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 17908, "substitutes": {"s": ["g", "cs", "f", "sys", "ops", "t", "sq", "d", "ns", "si", "i", "storage", "parser", "o", "w", "gs", "c", "p", "ssl", "b", "fs", "S", "sec", "sets", "e", "spec", "m"], "st": ["str", "sn", "sf", "pt", "src", "sp", "sa", "inst", "rest", "td", "t", "ss", "d", "St", "sd", "est", "mt", "ist", "ctx", "kt", "stat", "stream", "nt", "sb", "ld", "std", "ts", "ost", "nd", "sl", "stage", "ST", "sta", "ft", "ct", "sts", "fe", "a", "sth", "sc", "ste", "art"], "pkt": ["nct", "wpct", "mkt", "packet", "Pcht", "wpcht", "Ppt", " packet", "hacket", " ppt", "pskt", "Pkt", "ppt", "psct", "Pett", "Pk", "tke", "tcp", "tacket", "pct", "tkt", "pett", "hett", "Packet", " pk", "hct", "Pke", " pct", "pcp", "pspt", "hkt", "pke", "nk", "psacket", " pke", "pk", "tct", "wpacket", "mpt", " pcp", "wpkt", "macket", "Pcp", "mct", "nacket", "nkt", "pcht", "Pct", " pett", " pcht"], "desc": ["str", "rec", "txt", "df", "dc", "src", "proc", "uc", "name", "bc", "feat", "buf", "success", "req", "description", "asc", "Desc", "aux", "id", "config", "code", "des", "dir", "doc", "data", "rev", "meta", "lc", "loc", "ext", "ref", "std", "cv", "def", "ptr", "esc", "dist", "done", "sel", "en", "cb", "rc", "sec", "seq", "cmp", "dest", "text", "sub", "empty", "sc", "pert", "info"], "ret": ["RET", "val", "reply", "rec", "cat", "result", "match", "alt", "feat", "gc", "res", "cur", "success", "nz", "error", "reg", "back", "len", "fun", "offset", "status", "des", "data", "rev", "xt", "rets", "ext", "att", "ref", "det", "nt", "score", "gt", "std", "def", "resp", "re", "en", "rc", "num", "Ret", "seq", "mem", "sec", "opt", "lit", "info"], "ast": ["ap", "sa", "rest", "inst", "ac", "node", "op", "asm", "cast", "alt", "Ast", "mast", "ad", "end", "it", "ta", "add", "aster", "test", "exec", "aste", "est", "atom", "od", "ist", "asts", "ar", "aw", "act", "ard", "parser", "addr", "host", "ace", "ma", "sam", "esp", "att", "nt", "post", "std", "ost", "nd", "sta", "at", "am", "eth", "as", "AST", "ab", "asting", "a", "anc", "amd", "ess", "af", "art", "amp"], "sub_demuxer": ["sub_demployeri", "sub_demxler", "sub_promxer", "sub_demverseri", "sub_demuxers", "sub_promuxeder", "sub_promxe", "sub_demluxer", "sub_promployed", "sub_promuxe", "sub_promuxed", "sub_promployer", "sub_demploye", "sub_promuxeri", "sub_demuxeri", "sub_promxeder", "sub_deuxer", "sub_demployler", "sub_demxeri", "sub_demluxeder", "sub_promxers", "sub_demuxeder", "sub_demuxed", "sub_promployers", "sub_dexeri", "sub_demployer", "sub_dexler", "sub_deuxler", "sub_demxeder", "sub_dexer", "sub_promuxers", "sub_demuxler", "sub_deuxers", "sub_demversler", "sub_demxers", "sub_demxer", "sub_demuxe", "sub_demversed", "sub_dexers", "sub_demversers", "sub_demxe", "sub_demployeder", "sub_deuxeri", "sub_demployed", "sub_demxed", "sub_demluxe", "sub_demverser", "sub_demluxers", "sub_demployers", "sub_promuxer", "sub_promployeri"], "time_base": ["TIME_cache", "TIME_base", "TIME_builder", "time__cache", "TIME_buffer", "time_builder", "time__buffer", "time_cache", "time__base", "time_buffer", "time__builder"], "size": ["g", "core", "scale", "who", "sent", "extra", "x", "sized", "ci", "sh", "end", "position", "speed", "code", "last", "c", "content", "weight", "bytes", "send", "sec", "shape", "empty", "mode", "use", "name", "clean", "fee", "Size", "message", "si", "args", "i", "ize", "max", "data", "score", "value", "esc", "ui", "loss", "num", "term", "day", "sync", "offset", "sn", "f", "length", "large", "n", "sd", "SIZE", "small", "capacity", "address", "body", "file", "channel", "pos", "en", "ng", "rc", "iz", "go", "grade", "form", "len", "enc", "storage", "sum", "loc", "time", "unit", "gz", "count", "e", "start", "sc"], "pb": ["cp", "txt", "PB", "pt", "pc", "uf", "stab", "jp", "wp", "bc", "xb", "buf", "lp", "bh", "abi", "wb", "np", "primary", "bp", "pm", "hub", "rob", "bm", "pg", "db", "pl", "platform", "pa", "ib", "summary", "vp", "bps", "parser", "eb", "ctx", "lc", "typ", "rb", "bot", "fp", "sb", "p", "tmp", "b", "prot", "pkg", "nb", "cb", "ab", "bf", "gb", "dp", "lab", "sub", "ub", "kb", "lb", "fc", "plugin", "fb"], "pd": ["cp", " cp", "cd", "cdn", "bd", "raf", "PB", "pc", "ud", "wp", "tp", "cmd", "ppa", " dc", "dd", "lp", "po", "td", " prod", " td", "ad", "d", " rc", "py", "np", "bb", "pm", "fd", "sd", "pi", "gd", "pg", "od", " da", " cd", " disp", "pp", "pa", "dt", " sd", "edd", "data", "db", "PD", "wk", "dl", "wd", " DP", "p", "ld", "da", "xd", " df", "pe", " dd", "pkg", " d", "hd", " ta", "vd", "pod", " def", "dp", "pid", "DP", "px", "ds", "plugin", "md", " data"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n", "idx": 17909, "substitutes": {"d": ["dr", "cd", "dh", "bd", "dc", "D", "f", "cmd", "dd", "t", "ad", "fd", "sd", "gd", "id", "dev", "od", "dt", "db", "dom", "data", "draw", "o", "dl", "w", "c", "p", "ld", "da", "std", "dad", "nd", "z", "vd", "e", "dat", "l", "dn", "did", "ds", "md", "m"]}}
{"project": "FFmpeg", "commit_id": "ac726a4f0cd2fb8619b478af51312a4282215f0e", "target": 0, "func": "static int movie_request_frame(AVFilterLink *outlink)\n\n{\n\n    AVFilterBufferRef *outpicref;\n\n    MovieContext *movie = outlink->src->priv;\n\n    int ret;\n\n\n\n    if (movie->is_done)\n\n        return AVERROR_EOF;\n\n    if ((ret = movie_get_frame(outlink)) < 0)\n\n        return ret;\n\n\n\n    outpicref = avfilter_ref_buffer(movie->picref, ~0);\n\n    ff_start_frame(outlink, outpicref);\n\n    ff_draw_slice(outlink, 0, outlink->h, 1);\n\n    ff_end_frame(outlink);\n\n    avfilter_unref_buffer(movie->picref);\n\n    movie->picref = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 17913, "substitutes": {"outlink": ["outstream", "againLink", "actstyle", " outl", "downstyle", "againink", "inLink", "inl", "inload", "oplink", "outload", " outLink", "againlinked", "againline", "outink", "opframe", " outlog", "againlog", "outline", "atline", "oplock", "atlink", "downlive", " outlock", "antlog", "upline", "outframe", "atLink", "againstream", "newstream", "antlock", "inlink", "outlive", "againloop", "offlink", "downlog", " outstyle", "uplinked", "opink", "outlinked", "newlinked", "newLink", "antloop", " outlinked", "newload", "serverlive", "serverlink", "outl", "downframe", "outlock", "outstyle", "actlink", "outlog", "antlink", "offlinked", "actlive", " outload", "atl", "outloop", "outLink", "serverlog", "againframe", " outloop", "newlink", "downink", "downlink", "offstyle", "offLink", "downlock", "upload", "inlinked", "uplink", "newstyle", "againlink", " outline", " outstream", "actlog", "againload", "serverstyle", "againlock"], "outpicref": ["outpicall", "Outpicurl", "outnicRef", "outnicref", "outpictref", "outfcRef", "inpicref", "inpicRef", "outfcreference", "outpicreference", "outlcreference", "Outpicref", "outlcref", "inPicRef", "outfcref", "inpicall", "Outnicref", "outPicreference", "outlcRef", "inPicreference", "Outnicurl", "outnicreference", "Outpicreference", "outlcall", "outpictreference", "outnicurl", "inpicreference", "outPicref", "inPicall", "Outnicreference", "outPicRef", "outpicRef", "outPicurl", "outpictRef", "outpicurl", "OutpicRef", "OutnicRef", "outpicturl", "outPicall", "inPicref", "outfcall"], "movie": ["hide", "camera", "coll", "tv", "mpeg", "episode", "lot", "style", "motion", "frame", "media", "film", "music", "error", "video", "make", "module", "play", "show", "cop", "parse", "youtube", "ani", "img", "Movie", "doc", "money", "anim", "voice", "game", "file", "flash", "channel", "cam", "move", "nick", "loader", "comment", "fake", "rama", "image", "cow", "fi", "mc", "die", "picture", "hero", "bug", "pie", "ie", "manager", "rame", "player"], "ret": ["RET", "val", "reply", "result", "alt", "res", "success", "end", "reg", "valid", "red", "len", "fun", "job", "obj", " RET", "fin", "rem", "code", "art", "rev", "rets", "att", "ext", "ref", "det", "nt", "def", "flag", "re", "en", " Ret", "run", "rc", "Ret", "mem", "bad", "arr", "arg", "lit", "rt", "out", "rep"]}}
{"project": "FFmpeg", "commit_id": "89d4d7d759a59e8535b267b7f5af757f731da712", "target": 1, "func": "static void process_client(AVIOContext *client, const char *in_uri)\n\n{\n\n    AVIOContext *input = NULL;\n\n    uint8_t buf[1024];\n\n    int ret, n, reply_code;\n\n    uint8_t *resource = NULL;\n\n    while ((ret = avio_handshake(client)) > 0) {\n\n        av_opt_get(client, \"resource\", AV_OPT_SEARCH_CHILDREN, &resource);\n\n        // check for strlen(resource) is necessary, because av_opt_get()\n\n        // may return empty string.\n\n        if (resource && strlen(resource))\n\n            break;\n\n\n    }\n\n    if (ret < 0)\n\n        goto end;\n\n    av_log(client, AV_LOG_TRACE, \"resource=%p\\n\", resource);\n\n    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n\n        reply_code = 200;\n\n    } else {\n\n        reply_code = AVERROR_HTTP_NOT_FOUND;\n\n    }\n\n    if ((ret = av_opt_set_int(client, \"reply_code\", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        av_log(client, AV_LOG_ERROR, \"Failed to set reply_code: %s.\\n\", av_err2str(ret));\n\n        goto end;\n\n    }\n\n    av_log(client, AV_LOG_TRACE, \"Set reply code to %d\\n\", reply_code);\n\n\n\n    while ((ret = avio_handshake(client)) > 0);\n\n\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    fprintf(stderr, \"Handshake performed.\\n\");\n\n    if (reply_code != 200)\n\n        goto end;\n\n    fprintf(stderr, \"Opening input file.\\n\");\n\n    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n\n        av_log(input, AV_LOG_ERROR, \"Failed to open input: %s: %s.\\n\", in_uri,\n\n               av_err2str(ret));\n\n        goto end;\n\n    }\n\n    for(;;) {\n\n        n = avio_read(input, buf, sizeof(buf));\n\n        if (n < 0) {\n\n            if (n == AVERROR_EOF)\n\n                break;\n\n            av_log(input, AV_LOG_ERROR, \"Error reading from input: %s.\\n\",\n\n                   av_err2str(n));\n\n            break;\n\n        }\n\n        avio_write(client, buf, n);\n\n        avio_flush(client);\n\n    }\n\nend:\n\n    fprintf(stderr, \"Flushing client\\n\");\n\n    avio_flush(client);\n\n    fprintf(stderr, \"Closing client\\n\");\n\n    avio_close(client);\n\n    fprintf(stderr, \"Closing input\\n\");\n\n    avio_close(input);\n\n\n}", "idx": 17929, "substitutes": {"client": ["local", "core", "batch", "container", "server", "consumer", "project", "session", "cat", "http", "pc", "worker", "cli", "uc", "ac", "cache", "prefix", "clean", "parent", "global", "conn", "api", "connection", "product", "child", "chrome", "util", "config", "path", "cl", "Client", "google", "private", "con", "reader", "ctx", "cell", "call", "mac", "c", "ce", "connect", "public", "service", "ssl", "current", "socket", "wrapper", "image", "context", "request", "port", "open", "remote", "custom", "cod", "plugin", "secure", "host", "cn"], "in_uri": ["In_ri", "inpURI", "In_URI", " in_URI", "In_uri", "In_binary", "invaluri", " in_filename", "in_path", " in_path", "invalcollection", "in_collection", "inppath", "inpri", "invalURI", " in_resource", "in_filename", " in_collection", "inpuri", "in_URI", "in_resource", "in_binary", "in_ri", "invalfilename", " in_ri"], "input": ["batch", "local", "container", "server", "accept", "interface", "inner", "output", "session", "dc", "http", "cat", "cli", "command", "uc", "inc", "queue", "temp", "instance", "source", "ac", "in", "api", "form", "include", "buffer", "connection", "back", "view", "child", "util", "i", "config", "id", "storage", "init", "qa", "act", "img", "data", "entry", "binary", "reader", "Input", "stream", "import", "active", "ssl", "current", "socket", "image", "context", "pull", "url", "request", "text", "list", "event", "plugin", "field", "bin"], "buf": ["batch", "header", "vec", "map", "output", "uf", "uc", "cmd", "bc", "cache", "queue", "temp", " buffer", "window", "buffer", "Buffer", "pool", "wb", "fd", "config", "ff", "pb", "data", "raw", "block", "ctx", "cas", "cap", "rb", "c", "bag", "cv", "tmp", "b", "err", "msg", "fb", "context", "rc", "cb", "seq", "port", "text", "box", "buff", "alloc", "br"], "ret": ["detail", "reply", "val", "match", "sr", "fun", "pet", "pat", "nl", "al", "rl", "prot", "resp", "flag", "lit", "arg", "rt", "br", "timeout", "ry", "res", "reg", "fail", "red", "job", "reset", "rem", "usr", "rev", "nt", "sb", "store", "def", "err", "nb", "ne", "url", "out", "art", "j", "RET", "cat", "rest", "error", "old", "db", "iter", "att", "rb", "post", "er", "ur", "en", "rc", "Ret", "info", "str", "result", "alt", "cur", "t", "success", "repl", "back", "len", "obj", "mt", "ut", " RET", "ner", "fin", "rets", "ext", "ref", "det", "bot", "rf", "sur", "re", "ft", "bf", "mem", "part"], "n": ["g", "sn", "not", "cn", "min", "none", "f", "number", "node", "nc", "name", "x", "na", "t", "conn", "d", "no", "ns", "len", "i", "ner", "nn", "r", "o", "nl", "N", "body", "c", "k", "nt", "p", "pn", "s", "pos", "y", "nr", "b", "z", "gn", "en", "ni", "nb", "ne", "ng", "nor", "num", "fn", "un", "e", "l", "rn", "count", "dn", "nu", "size", "nat", "an", "j", "m"], "reply_code": ["replyScode", "replySline", "reply_start", "response_number", "reply67code", "reply_count", "reply_handler", "replyflowcod", "replyingcod", "response_handler", "replyalcode", "reply_class", "replyingcodes", "reply_number", "response_cod", "repl_start", "replyIPcount", "replyxcode", "replyaccount", "replyIPhandler", "replyachandler", "repl_codes", "reply_line", "repl_class", "reply_cod", "repl_code", "reply_Code", "reply67codes", "reply_coded", "replyIPcoded", "replyflowcode", "replyaccode", "replyflowCode", "replyingcode", "replyaccoded", " reply_codes", " reply_text", "response_codes", "reply67count", "response_code", "replyalcount", "replyalnumber", "reply67text", "replyflowcodes", "replyflownumber", "replySnumber", "replyIPcode", "replyalline", "replyxhandler", " reply_count", "reply_codes", "replyxcodes", "response_coded", "response_line", "response_count", "replyingnumber", "response_Code", "reply_text", "replyScount", "replyflowhandler", "replyxCode"], "resource": ["reply", "core", "server", "progress", "output", "rule", "ruby", "src", "result", "number", "range", "type", "rest", "operation", "prefix", "source", "parent", "media", "res", "document", "name", "uri", "sr", "buffer", "scope", "connection", "error", "record", "message", "config", "id", "resources", "ri", "Resource", "address", "r", "index", "data", "replace", "byte", "reader", "project", "ref", "character", "file", "channel", "response", "region", "token", "content", "event", "pointer", "re", "value", "rg", "search", "context", "rage", "url", "request", "query", "password", "reference", "remote", "rect", "random", "attribute", "offset"]}}
{"project": "FFmpeg", "commit_id": "cec939597722663f322941b4c12e00a583e63504", "target": 1, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int16_t (*l1mv1)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[1][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int8_t *l1ref1 = &h->ref_list[1][0].ref_index[1][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n\n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col)\n\n               && (   (l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1)\n\n                   || (l1ref0[0]  < 0 && l1ref1[0] == 0 && ABS(l1mv1[0][0]) <= 1 && ABS(l1mv1[0][1]) <= 1\n\n                       && (h->x264_build>33 || !h->x264_build)))){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n\n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n\n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && (   l1ref0[x8 + y8*h->b8_stride] == 0\n\n                                              || (l1ref0[x8 + y8*h->b8_stride] < 0 && l1ref1[x8 + y8*h->b8_stride] == 0\n\n                                                  && (h->x264_build>33 || !h->x264_build)))){\n\n                    const int16_t (*l1mv)[2]= l1ref0[x8 + y8*h->b8_stride] == 0 ? l1mv0 : l1mv1;\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0] >= 0 ? h->map_col_to_list0[0][l1ref0[0]]\n\n                                                : h->map_col_to_list0[1][l1ref1[0]];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n                const int16_t (*l1mv)[2]= l1mv0;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n\n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                if(ref0 >= 0)\n\n                    ref0 = h->map_col_to_list0[0][ref0];\n\n                else{\n\n                    ref0 = h->map_col_to_list0[1][l1ref1[x8 + y8*h->b8_stride]];\n\n                    l1mv= l1mv1;\n\n                }\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17932, "substitutes": {"h": ["g", "dh", "f", "http", "hi", "x", "u", "oh", "sh", "bh", "q", "eh", "t", "sw", "rh", "d", "n", "H", "ch", "hw", "i", "cpp", "th", "r", "hl", "o", "hr", "w", "c", "k", "p", "ha", "y", "he", "hp", "gh", "b", "ih", "z", "hh", "home", "en", " H", "e", "ph", "l", "hs", "a", "ah", "hm", "ht", "v", "host", "m"], "mb_type": ["mb___comp", "mp_types", "bb_comp", "mb___key", "mp_id", "mb_var", "mc_count", "mc_var", "mc_val", "mb_name", "mp_name", "mb_types", "mb_id", "mb_col", "mc_type", "mp_type", "mb_index", "bb_role", "mb_comp", "mb___type", "bb_key", "motion_col", "motion_type", "bb_type", "mb_val", "mb_role", "motion_index", "mb_count", "motion_types", "mb___role", "mb_key"], "s": ["g", "is", "server", "client", "f", "ps", "x", "u", "ions", "sh", "t", "ss", "in", "sq", "d", "rh", "ns", "ages", "n", "location", "si", "i", "support", "storage", "r", "ls", "es", "o", "us", "w", "an", "gs", "conf", "c", "k", "p", "y", "ts", "b", "sl", "fs", "services", "stats", "S", "e", "ses", "l", "settings", "sym", "hs", "a", "os", "spec", "ds", "qs", "v", "m"], "l1mv0": ["l1mm0", "l1mf2", "l1mmfe", "l1mm2", "l1mf50", "l1mw0", "l1Mv2", "l1Mffe", "l1mffe", "l1mw2", "l1mwfe", "l1Mf0", "l1mv2", "l1Mv0", "l1Mv50", "l1mf0", "l1Mf50", "l1mvfe", "l1Mf2", "l1mw50", "l1mv50", "l1mm50", "l1Mvfe"], "l1mv1": ["l1pfb", "l1mfb", "l1mc1", "l1mc0", "l1mx3", "l1mf1", "l1mx0", "l1mv3", "l1pf3", "l1pvb", "l1pf0", "l1mc3", "l1mf0", "l1mx1", "l1pv0", "l1mvb", "l1pv1", "l1mf3", "l1mcb", "l1mxb", "l1pv3", "l1pf1"], "l1ref0": ["l1ref5", "l1pos50", "l6reference5", "l6reference0", "l6ref0", "l1pos0", "l6ref10", "l1q5", "l1pos10", "l1pos5", "l6ref5", "l6ref50", "l1q0", "l1ref10", "l1reference0", "l1q10", "l1q50", "l1reference5", "l1ref50", "l1reference50", "l6reference50", "l1reference10", "l6reference10"], "l1ref1": ["l1defn", "l1Ref1", "l1refn", "l1l1", "l2Ref1", "l1Refn", "l2ref2", "l1ln", "l1l2", "l1def1", "l2refn", "l2ref1", "l1Ref2", "l2Refn", "l1def2", "l2Ref2", "l1ref2"], "sub_mb_type": ["sub_mb2", "sub_mm2", "sub_MB_name", "sub_MB_type", "sub_mb_key", "sub_bb0", "sub_MB2", "sub_mb__type", "sub_MB\n", "sub_mb__id", "sub_mm_id", "sub_mb__call", "sub_MB_types", "sub_bb\n", "sub_mb_types", "sub_mm\n", "sub_MB0", "sub_mm_call", "sub_mm_key", "sub_mb__key", "sub_mb0", "sub_mb_id", "sub_bb2", "sub_mm_type", "sub_mb__name", "sub_mm0", "sub_mb\n", "sub_mb__types", "sub_mb_call", "sub_mb_name"], "i8": ["l8", " i6", "i20", "i16", "p16", "p20", "i6", "l20", " i16", "l6", "l16", "p6", " i20", "p8"], "i4": ["xi8", "xi24", "p4", "p24", "p12", "i24", "xi4", " i12", " i24", "i12", "p8", "xi12"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        error_setg(errp, \"Image not in QED format\");\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        /* image uses unsupported feature bits */\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bdrv_get_device_name(bs), \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Round down file size to the last cluster */\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) /\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    /* Header size calculation must not overflow uint32_t */\n\n    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    /* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 17953, "substitutes": {"bs": ["lbs", "cs", "css", "ms", "aws", "sa", "src", "ps", "http", "bc", "rs", "BS", "bt", "js", "bh", "ss", "bi", "ns", "bb", "base", "ros", "bid", "blocks", "bits", "state", "pb", "status", "vs", "ls", "es", "iss", "als", "us", "stat", "gs", "bot", "sb", "bas", "ks", "ts", "b", "obs", "ubs", "fs", "stats", "bytes", "bis", "cb", "ab", "gb", "bos", "ses", "os", "settings", "ins", "outs", "lb", "bes", "ds", "bl", "fb", "bing"], "options": ["cs", "ops", "op", "js", "linux", "obj", "ch", "args", "lib", "config", "bits", "Options", "o", "params", "conf", "details", "ts", "fs", "stats", "cb", "fn", "settings", "opt", "os", "outs", "io", "info"], "flags": ["cs", "ops", "mode", "reg", "parts", "reads", "len", "ints", "args", "config", "bits", "ips", "status", "data", "opens", "errors", "files", "Flags", "ts", "flag", "fs", "stats", "bytes", "utils", "features", "mask", "settings"], "errp": ["errpc", "acerpb", "errP", "acerv", " errpo", " errr", "Erv", "errpb", "errpo", "errpe", "erP", "errv", "acerp", "acerpe", "erpc", "derpb", "rorP", "Erpe", "erp", "nerr", "derv", "nerpc", "derp", "rorpo", "erfp", "Erp", " errfp", "err", "derpe", "rorp", " errP", "errfp", " errpc", "rorfp", "nerp", "Erpb", "errr", "erpo", "nerP"], "s": ["g", "self", "ms", "session", "uns", "js", "h", "r", "gs", "conf", "c", "b", "ssl", "sl", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "http", "u", "ns", "site", "si", "args", "i", "state", "strings", "es", "us", "p", "sb", "ts", "ks", "services", "sv", "l", "sym", "rows", "its", "sync", "ops", "f", "rs", "ss", "sq", "vs", "o", "xs", "S", "bis", "sg", "ses", "spec", "is", "cs", "sys", "sa", "ps", "new", "t", "parts", "d", "ls", "service", "uses", "e", "os", "ds", "v", "settings"], "le_header": ["le_pair", "le_layer", "le___head", "le_cover", "le___header", " le_dr", "LE_pair", "ile_header", "le_name", "LE_head", "le_manager", " le_buffer", "le_bridge", "le___handler", "LE_handler", "ile_name", "ele_head", " le_layer", "ele_header", "le___pair", "le_dr", "ile_bridge", "ele_manager", "le_handler", "le_buffer", "le_head", "LE_header", "ile_layer", "ele_cover"], "file_size": ["file_sn", "file_adjust", "field_len", "file_range", "file64error", "fileFrange", "ile_adjust", " file_source", "file64size", "file_length", "file_speed", "fileacrange", "table_Size", " file_speed", "filelexsize", "table_sized", "filepsize", "files_Size", "file___length", "file___location", " file_length", "field_range", "fileaclen", " file_location", "ile_align", "filelexlocation", "file_align", "file___Size", "field_size", "fileFlen", "field_sn", "fieldaclen", "file___source", "fileacsn", "file_location", "ile_name", "filelexsource", "file_len", "files_sized", "file\u00b7align", "fileperror", "ile_size", " file_error", "files_name", "files_size", "fieldacrange", "file_source", "file64speed", "filepspeed", "table_depth", "file\u00b7adjust", "file\u00b7size", "fieldacsize", "file_Size", "file___depth", "filelexlength", "file_name", "file_sized", "fieldacsn", "file___sized", "table_size", "file_error", "file_depth", "file\u00b7name", "fileFsn", "file___size", "fileFsize", "fileacsize"], "ret": ["RET", "val", "bit", "reply", "let", "f", "pt", "result", "match", "x", "alt", "res", "t", "success", "reg", "error", "back", "no", "fail", "len", "fun", "mt", " RET", "fin", "pet", "status", "code", "data", "pat", "pass", "rets", "att", "ext", "ref", "det", "nt", "al", "rl", "def", "flag", "re", "err", "en", " Ret", "ft", "run", "rc", "count", "Ret", "num", "arr", "lit", "rt", "out", "art", "offset"], "buf": ["header", "vec", "src", "uf", "result", "proc", "uc", "cmd", "queue", "bc", "feat", "temp", " buffer", "pad", "buffer", "wb", "fd", "config", "aux", "ff", "path", "data", "addr", "block", "byte", "wrap", "cap", "doc", "ctx", "exc", "raw", "loc", "rb", "cf", "ref", "fp", "bag", "cv", "tmp", "b", "msg", "fb", "bytes", "la", "rc", "cb", "fi", "seq", "mem", "text", "buff", "bin", "alloc", "br"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_8w_msa(src - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 8);\n\n}\n", "idx": 17954, "substitutes": {"dst": [" dsc", "Dst", " drc", "delrc", "delST", "delsrc", "idst", "adST", "adsrc", "idsrc", "idST", "dST", "Drc", "idsc", "drc", "dsc", "delst", "adsc", "adst", "dsrc", "DST", " dsrc", " dST", "Dsrc"], "src": ["grad", "supp", "inst", "rest", "lower", "rs", "source", "buf", "secure", "sq", "sr", "low", "lib", "config", "img", "rt", "st", "loc", "rb", "rd", "sb", "gl", "ssl", "b", "sur", "sl", "sup", "dist", "sel", "send", "gz", "rc", "url", "cb", "dest", "gb", "sec", "start", "sub", "lit", "sc", "rob", "bg", "comp", "sync"], "stride": ["strite", "strride", "Stride", "STRite", "Strride", "arride", "STRided", "STRride", "vertide", "slided", "yride", "strider", "strend", " strided", "vertided", " strider", "arrend", "strise", "Strise", "yrided", "strade", "slise", "Strite", "Strider", "vertend", "vertider", "yrade", "arrided", "slider", "STRide", "slide", "Strided", " strise", " strite", " strride", "yrider", "Strade", "Strend", "slade", "strided", "arrider"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 17972, "substitutes": {"id": ["sid", "f", "proc", "name", "ids", "in", "window", "uri", "root", "ip", "fd", "i", "oid", "ID", "ident", "path", "data", "ctx", "stat", "file", "fs", "uid", "desc", "url", "fn", "seq", "pid"], "backend": ["frontride", "backride", "Backends", " backride", " backended", "backended", "Backend", "Backride", " backends", "frontended", "Backward", "backender", "frontends", " backward", "backward", "Backender", "backends", "frontender", "Backended", "frontward", "frontend", " backender"], "ret": ["RET", "val", "sys", "output", "proc", "result", "buf", "res", "success", "conn", "buffer", "fin", "status", "data", "rets", "w", "al", "def", "re", "fs", "desc", "en", "fi", "Ret", "mem", "out"], "errp": [" Errps", "errps", " errps", "rylp", "errP", " errr", " Errp", "errorp", " errf", "erP", "erlp", "errorf", " Errf", "errf", " errlp", "erp", "ryr", "ryP", "errorps", "err", "errorP", " errP", " ErrP", "errr", "errlp", "ryp"], "opts": [" opt", "operts", "OPTs", "OPtes", "opertes", "OPters", "OPts", "opters", " optes", "optTs", "opTs", "opcs", "opercs", "optes", "fpt", "opert", "optters", "optt", "OPt", "fpts", "fpTs", "OPcs", "fpters", "opt", "optts", " opcs"], "filename": ["kn", "ils", "sn", "txt", "f", "dll", "sid", "cmd", "name", "prefix", "buf", "feat", "wb", "n", "kl", "fd", "i", "enc", "directory", "path", "il", "binary", "Filename", "til", "o", "files", "which", "file", "fp", "rl", "nil", "b", "fil", "fn", "url", "l", "tty", "username"], "chr": ["Chr", "Chsr", "gyrb", "CHr", " chrr", "Chri", "chrb", "chcr", "chert", "ichp", "chntr", " chp", "ichsr", "gyr", "gyru", "charrc", "motrt", "shr", "colr", " chri", "cherb", "charrf", "chri", "chnr", " chrc", "Chrb", "ichru", "chnru", " chrf", "chtr", " chpr", "shrf", "ichcr", "chrc", "Chru", " chcr", "ichrr", "CHru", "Chrf", "CHrb", "motrc", "chsr", "Chtr", " chrt", "colrt", "anchru", "charr", "shrc", "chrr", "chepr", "checr", "colrr", "chrt", "colar", "ichrt", "cherf", "anchrb", "ichrf", "motr", "ichrb", "cheru", "anchrt", "anchr", "chp", "motpr", "chrf", "Chp", "ichr", "cher", " chru", "CHtr", "ichar", "charri", " chrb", "chnrb", "cherc", " chsr", "chru", "shri", "gyrf", "ichri", "chpr"], "s": ["g", "is", "self", "sn", "sf", "f", "sys", "ops", "http", "src", "sid", "u", "rs", "ds", "south", "t", "ss", "sq", "d", "ns", "n", "si", "i", "state", "storage", "ips", "h", "r", "o", "w", "params", "gs", "c", "p", "sb", "y", "b", "ssl", "sl", "socket", "su", "fs", "S", "sg", "ses", "e", "share", "os", "settings", "a", "spec", "v", "sync", "m"]}}
{"project": "qemu", "commit_id": "7bbcb0afe715c36545bbbd872441c473927c1a4e", "target": 0, "func": "uint32_t HELPER(clz)(uint32_t x)\n\n{\n\n    int count;\n\n    for (count = 32; x; count--)\n\n        x >>= 1;\n\n    return count;\n\n}\n", "idx": 17981, "substitutes": {"x": ["val", "fx", "check", "length", "number", "xy", "xi", "ix", "xb", "u", "t", "exec", "n", "ax", "xp", "X", "xa", "max", "index", "wx", "rx", "data", "ctx", "xt", "w", "xxx", "xf", "c", "time", "p", "y", "xs", "tx", "z", "xx", "num", "cross", "xe", "e", "l", " xx", "xc", "event", "v", "ex", "size", "m"], "count": ["core", "val", "length", "number", "pc", "match", "allow", "type", "cache", "name", "parent", "force", "test", "counter", "child", "base", "len", "col", "i", "id", "catch", "max", "code", "index", "sum", "call", "loop", "c", "p", "cc", "depth", "key", "cond", "ind", "process", "weight", "race", "num", "e", "start", "list", "Count", "size", "offset"]}}
{"project": "qemu", "commit_id": "96c9cff0ab986f3a0606e1a96c5b00e6a7c675c6", "target": 0, "func": "static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,\n\n                                       struct kvm_ppc_smmu_info *info)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    memset(info, 0, sizeof(*info));\n\n\n\n    /* We don't have the new KVM_PPC_GET_SMMU_INFO ioctl, so\n\n     * need to \"guess\" what the supported page sizes are.\n\n     *\n\n     * For that to work we make a few assumptions:\n\n     *\n\n     * - If KVM_CAP_PPC_GET_PVINFO is supported we are running \"PR\"\n\n     *   KVM which only supports 4K and 16M pages, but supports them\n\n     *   regardless of the backing store characteritics. We also don't\n\n     *   support 1T segments.\n\n     *\n\n     *   This is safe as if HV KVM ever supports that capability or PR\n\n     *   KVM grows supports for more page/segment sizes, those versions\n\n     *   will have implemented KVM_CAP_PPC_GET_SMMU_INFO and thus we\n\n     *   will not hit this fallback\n\n     *\n\n     * - Else we are running HV KVM. This means we only support page\n\n     *   sizes that fit in the backing store. Additionally we only\n\n     *   advertize 64K pages if the processor is ARCH 2.06 and we assume\n\n     *   P7 encodings for the SLB and hash table. Here too, we assume\n\n     *   support for any newer processor will mean a kernel that\n\n     *   implements KVM_CAP_PPC_GET_SMMU_INFO and thus doesn't hit\n\n     *   this fallback.\n\n     */\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO)) {\n\n        /* No flags */\n\n        info->flags = 0;\n\n        info->slb_size = 64;\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[0].page_shift = 12;\n\n        info->sps[0].slb_enc = 0;\n\n        info->sps[0].enc[0].page_shift = 12;\n\n        info->sps[0].enc[0].pte_enc = 0;\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[1].page_shift = 24;\n\n        info->sps[1].slb_enc = SLB_VSID_L;\n\n        info->sps[1].enc[0].page_shift = 24;\n\n        info->sps[1].enc[0].pte_enc = 0;\n\n    } else {\n\n        int i = 0;\n\n\n\n        /* HV KVM has backing store size restrictions */\n\n        info->flags = KVM_PPC_PAGE_SIZES_REAL;\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            info->flags |= KVM_PPC_1T_SEGMENTS;\n\n        }\n\n\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->slb_size = 32;\n\n        } else {\n\n            info->slb_size = 64;\n\n        }\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[i].page_shift = 12;\n\n        info->sps[i].slb_enc = 0;\n\n        info->sps[i].enc[0].page_shift = 12;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n        i++;\n\n\n\n        /* 64K on MMU 2.06 and later */\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->sps[i].page_shift = 16;\n\n            info->sps[i].slb_enc = 0x110;\n\n            info->sps[i].enc[0].page_shift = 16;\n\n            info->sps[i].enc[0].pte_enc = 1;\n\n            i++;\n\n        }\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[i].page_shift = 24;\n\n        info->sps[i].slb_enc = SLB_VSID_L;\n\n        info->sps[i].enc[0].page_shift = 24;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n    }\n\n}\n", "idx": 18015, "substitutes": {"cpu": ["core", "cp", "css", "chip", "sys", "pc", "proc", "clock", "CPU", "PF", "cli", "node", "nc", "cache", "jp", "ci", "gc", "linux", "conn", "eni", "np", "boot", "hw", "config", "cpp", "pu", "ocr", "ctx", "uci", "uu", "lc", "processor", "c", "vc", "hp", "roc", "cus", "process", "gp", "cow", "vm", "CP", "rc", "kernel", "cmp", "px", "utils", "pid", "gpu", "cn"], "info": ["di", "inner", "extra", "command", "cache", "ci", "off", "api", "end", "INFO", "child", "h", "conf", "app", "available", "fs", "update", "comment", "image", "gi", "buff", "setup", "check", "http", "name", "op", "source", "uri", "fo", "py", "job", "si", "args", "user", "state", "index", "qa", "data", "tf", "guide", "inf", "Info", "key", "thin", "ui", "fi", "num", "where", "bug", "offset", "iso", "f", "ops", "orig", "error", "base", "config", "id", "init", "by", "diff", "help", "bar", "ii", "post", "hand", "ignore", "note", "information", "cb", "options", "txt", "now", "result", "type", "obj", "php", "ext", "all", "rf", "ami", "start", "event", "part"], "env": ["core", "eu", "net", "cache", "global", "eni", "org", "scope", "end", "exec", "code", "dict", "ef", "engine", "conf", "profile", "app", "gu", "cfg", "context", "opt", "oa", "server", "cli", "forge", "nc", "np", "site", "args", "agent", "dev", "pec", "iss", "esp", "ea", "inf", "err", "ui", "ne", "age", "environment", "console", "cal", "style", "config", "db", "eng", "ctx", "stage", "energy", "en", "rc", "ev", "kernel", "dat", "ani", "skin", "inc", "conn", "visor", "enc", "dt", "estate", "ec", "exc", "qt", "ext", "ce", "ou", "edge", "e", "anc", "event", "v"], "cs": ["css", "cp", "self", "CS", "sys", "bs", "pc", "ck", "ps", "proc", "nc", "bc", "rs", "conn", "ss", "ns", "si", "cms", "args", "state", "co", "vs", "ls", "cas", "ctx", "ec", "qs", "ca", "sk", "c", "acs", "cc", "ks", "fs", "wcs", "rc", "gb", "spec", "sc", "ds", "Cs", "sync", "cn"], "i": ["g", "phi", "di", "ri", "xi", "qi", "x", "ix", "cache", "ci", "I", "c", "b", "mini", "gi", "a", "oi", "ini", "mi", "m", "cli", "inst", "u", "in", "it", "uri", "si", "args", "multi", "ai", "index", "iu", "p", "y", "ui", "fi", "anti", "l", "io", "ti", "j", "ji", "n", "ip", "_", "id", "init", "iv", "o", "ii", "func", "ni", "zi", "ski", "li", "bi", "d", "pi", "ij", "all", "e", "start", "ie", "v"]}}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n", "idx": 18020, "substitutes": {"shift": ["set", "length", "src", " offset", "carry", "ix", "transform", "off", "pad", "buffer", "ip", "small", "i", " shifts", "reset", "config", "slave", "init", "address", "index", "pack", "input", "data", " shifted", "next", "center", "pixel", "pointer", "slice", "hift", "Shift", "pull", "seed", "start", "push", "size", "offset"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n", "idx": 18038, "substitutes": {"bh": ["batch", "dh", "BT", "acl", "zh", "bs", "http", "xb", "bt", "sh", "abi", "bi", "kh", "uh", "rh", "bp", "ch", "aph", "hw", "bm", "hub", "cpp", "h", "pa", "pb", "hl", "adh", "rb", "sb", "p", "fp", "hp", "b", "gh", "ih", "hap", "pkg", "hh", "beh", "bf", "ph", "hs", "sth", "lb", "ah", "hm", "bg", "ht"], "ctx": ["cp", "cs", "cm", "client", "grad", "timeout", "pc", "src", "ck", "cli", "chan", "cmd", "queue", "ci", "gc", "conn", "sq", "scope", "exec", "np", "obj", "hw", "bm", "config", "multi", "cpp", "module", "qa", "rx", "cas", "lc", "loc", "ca", "cf", "graph", "c", "fp", "cc", "cv", "kw", "vc", "tx", "pkg", "tc", "Context", "cfg", "context", "cb", "cmp", "ctrl", "cu", "xc", "kb", "sc", "alloc", "sync", "cn"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)\n\n{\n\n    SpiceTimer *timer;\n\n\n\n    timer = qemu_mallocz(sizeof(*timer));\n\n    timer->timer = qemu_new_timer(rt_clock, func, opaque);\n\n    QTAILQ_INSERT_TAIL(&timers, timer, next);\n\n    return timer;\n\n}\n", "idx": 18044, "substitutes": {"func": ["val", "f", "pc", "this", "unc", " function", "Function", "name", "nc", "proc", "worker", "arf", "in", "exec", "fee", "n", "fun", "obj", "util", "job", "exe", "r", "code", "data", "lc", "xxx", "callback", "c", "function", "b", "apply", "slice", "wrapper", "lambda", "as", "handler", "cb", "fn", "attr", "expr", "a", "ln", "sync"], "opaque": [" oprobe", " opace", "opque", "opaques", "oprobe", "operacity", "Opque", "opace", "coaque", "coque", "Opacity", "opacity", "operace", "operrobe", "Opace", "coacity", "operque", " opacity", "Oprobe", "Opaque", "operaques", "Opaques", "operaque", "coaques"], "timer": ["server", "oller", "inner", "icer", "txt", "f", "later", "timeout", "theme", "clock", "worker", "result", "roller", "tick", "cache", "runner", "walker", "temp", "tim", "buffer", "Timer", "icker", "imer", "finder", "inter", "peer", "message", "counter", "or", "izer", "fit", "duration", "starter", "writer", "reader", "ee", "trial", "browser", "next", "iter", "trigger", "ext", "loop", "time", "processor", "fp", "loader", "pointer", "er", "wrapper", "tc", "err", "item", "ter", "acker", "handler", "cb", "cookie", "ger", "term", "acer", "ler", "outer", "event", "manager", "player"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n", "idx": 18067, "substitutes": {"proxy": ["core", "server", "resource", "client", "project", "http", "route", "node", "queue", "cache", "parent", "library", "Proxy", "super", "uri", "buffer", "connection", "pool", "base", "ip", "plugin", "module", "config", "cop", "pb", "pse", "bridge", "p", "service", "socket", "wrapper", "image", "vm", "phy", "bus", "port", "pro", "driver", "model", "io", "python", "remote", "que", "manager"], "queue_no": [" queue_number", "queue__number", " queue_offset", "que_len", "queue_len", "que_number", " queue_No", "queue_number", "queue_No", "queue__len", "queue__no", "que_no", "queue_offset"], "vector": ["vec", "sequence", "token", "creator", "number", "timeout", "command", "node", "queue", "prefix", "buf", "uri", "buffer", "connection", "version", " generator", "card", " protocol", "native", "virtual", "iv", " vendor", "binary", "reader", " router", "prot", "pointer", "letter", "network", "iterator", "port", "driver", " matrix", "manager", "Vector", "v"], "msg": ["g", "reply", "vec", "ms", " MSG", "route", "command", "cmd", "node", "new", "name", "queue", "op", "uri", "req", "message", "Message", "config", "Msg", "mail", " message", "data", "gen", "response", "manager", "def", "sim", "cfg", "send", "vm", "request", "seq", "mem", "text", "sym", "nm", "event", "out", "v", "m"], "vq": [" vque", "pq", " vQ", "vvqa", "vQ", "tvque", "tvq", "gq", "vqa", "tvc", "gqa", "Vc", "tvqa", "mq", "mqa", "vqq", "vvch", "pqq", "tvQ", " vqi", "vque", " vqa", "gqq", " vc", "giq", " vch", "piq", "miq", "tvch", "vc", "vch", "vqi", "viq", "tvqi", "Vq", "Vqi", "pqa", "vvq", "vvque", "VQ", "mqq"], "n": ["g", " ng", "sn", "cn", "f", "number", "nc", "t", "d", "ns", "np", "i", "nn", "r", "o", "w", "nl", "N", "c", "pn", "p", "s", "y", "nr", "b", "z", "mn", "gn", "nor", "en", "nb", "ne", "num", "nw", "network", "l", " N", "dn", "nm", "nu", "v", "j", "m"], "irqfd": ["arinqfin", "irequfun", "irhfen", "irarchfd", "ierqFD", "ireqfen", "arinqudf", "arinqufd", "irqadf", "yrarchdf", "iersqbd", "irpatchfn", "ireqFD", "irquFD", "yrarchfd", "irekfen", "irhfc", "irqufin", "irqudf", "arinqfd", "irarchdf", "irwallfd", "irtqufl", "yrarchcdn", "irsqFD", "irancefront", "irvfen", "irqfed", "irchdf", "ircFD", "iranceFD", "iraqufan", "irqfen", "iraqfd", "ierqbd", "irchfd", "irekfc", "irsqbd", "irqafan", "irtqFD", "irqads", "irqfl", "irpfen", "irequfd", "iraqds", "irancebd", "irhfd", "irekfd", "irqufd", "iersqfront", "irqds", "iriqfd", "irqafen", "irqafd", "irkfd", "irsqfront", "irtqudir", "irtquFD", "iersqfd", "irquestdf", "yrarchfen", "irchfin", "irekFD", "irwallfed", "irwallfun", "irqFD", "irqufan", "irvdf", "yrqfen", "irquestfen", "irqfc", "iraqfan", "irqfront", "irkfen", "iriqds", "irvcdn", "yrqfd", "ireqfn", "irancefd", "irchfen", "arinqufin", "ireqfed", "irtqfd", "irtqfl", "irequfed", "irqufl", "irkFD", "arinqufen", "iraqufin", "irqacdn", "irequfn", "ircbd", "irqufed", "ircfl", "irqbd", "irqafin", "ircfd", "irsqfd", "ierqfront", "ireqfun", "ireqfc", "iriqfan", "irwallfn", "irarchfen", "ierqfd", "yrqdf", "irquestfin", "irquds", "irpatchfun", "irqdir", "irqudir", "irpatchfd", "irpfd", "irkfc", "irpFD", "irpatchFD", "iersqFD", "ircfront", "iraqfin", "irqfan", "irquestfd", "irqfin", "arinqfen", "iraquds", "irarchcdn", "ircdir", "irqcdn", "irpatchfed", "irpatchfl", "irhFD", "iriqfin", "iraqufd", "irtqufd", "irvfd", "irtqdir", "irqufn", "irpatchdir", "irqufen", "irqfn", "irqdf", "irqufun", "irpfc", "yrqcdn", "ireqfd", "irqfun", "arinqdf"], "ret": ["reply", "val", "RET", "bit", "f", "cat", "ry", "result", "hard", "match", "type", "x", "alt", "res", "t", "success", "repl", "reg", "back", "error", "red", "fun", "len", "job", "mt", "rep", "obj", "reset", "pet", "db", "code", "usr", "pat", "rev", "pass", "rets", "rb", "ext", "att", "ref", "nt", "active", "rf", "def", "flag", "re", "try", "value", "done", "err", "ft", "run", "rc", "url", "Ret", "bf", "fi", "mem", "opt", "secret", "lit", "arg", "rt", "part", "art", "ver", "info"], "users": ["lines", "workers", "groups", "mins", "docs", "ports", "models", "ids", "pins", "rules", "plugins", "runners", "locks", "vers", "blocks", "masters", "versions", "items", "leaders", "members", "classes", "drivers", "files", "bugs", "views", "Users", "devices", "parents", "apps", "modules", "stars", "pages", "units", "names", "packages", "projects", "jobs"]}}
{"project": "FFmpeg", "commit_id": "ddd86a2924b9bc67c406cd66ebb1fc8915cd60f7", "target": 1, "func": "static int output_packet(InputStream *ist,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    }\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_ostreams; i++) {\n\n        OutputStream *ost = &ost_table[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18077, "substitutes": {"ist": ["set", "progress", "wp", "et", "iste", "ird", "irst", "edit", "support", "act", "ard", "gest", "st", "xt", "nd", "best", "elect", "ait", "dr", "ush", "pt", "inst", "work", "dit", "it", "add", "usr", "ists", "kt", "wd", "nt", "ust", "sta", "at", "pect", "imet", "isi", "list", "art", "empt", "lect", "rest", "ad", "old", "est", "ord", "IST", "ace", "ctx", "att", "post", "ind", "oss", "er", "dist", "ism", "osi", "ht", "istor", "txt", "feat", "artist", "back", "pick", "isd", "pg", "ict", "tt", "asp", "ont", "mot", "ext", "ld", "adder", "ft", "pop", "alist", "start", "ast", "aint", "ess", "part"], "ost_table": ["oc_source", "oc_col", "ost_col", "ost_file", "ost_source", "oc_file", "oc_table"], "nb_ostreams": ["nb_ostreamd", "nb_octstreamd", "nb_ostreamlist", "nb_octreamlist", "nb_ostocold", "nb_octreamd", "nb_ostinputs", "nb_octstreams", "nb_ostinputgroups", "nb_oststreams", "nb_octstreamgroups", "nb_ostocols", "nb_octreams", "nb_octreamgroups", "nb_oststreamgroups", "nb_ostocolgroups", "nb_ostinputlist", "nb_oststreamlist", "nb_octstreamlist", "nb_ostinputd", "nb_ostreamgroups", "nb_ostocollist", "nb_oststreamd"], "pkt": ["tpcht", "cpett", "cpcht", " packet", "tsth", "delt", "jpcht", "mnt", "bkt", "pett", "pet", "pnt", "bwk", "Ptch", " psth", " pet", "bcht", "Pqt", "opacket", "cpet", "prent", "tpkt", "paramwk", "tpqt", "mwk", "Pct", "paycht", "apcht", "paramacket", "apqt", "ppnt", "Pcht", "Pnt", "opett", "rkt", "jpacket", "payacket", "cpct", "fwk", "pct", "paramnt", "ppkt", "apkt", " pnt", "ppct", "fsth", "paramkt", "melt", "dacket", "opcht", "cpacket", "preacket", "rtch", "dcht", "jpkt", "mkt", "prewk", "tcht", "pqt", "psth", "dkt", "tacket", "fkt", "Packet", "facket", "fcht", "opelt", "paytch", "ppacket", "opkt", "ptch", "racket", "cpqt", "macket", "backet", " pcht", "pwk", "packet", "prekt", "mcht", "Pkt", "tpelt", "rcht", "paykt", "Pet", "tkt", " pct", "cpkt", "pelt", " pqt", "jpett", "pcht", "cpelt", "apelt", " pelt"], "i": ["di", "inner", "f", "xi", "ci", "li", "t", "it", "d", "n", "ip", "ti", "I", "pi", "si", "ai", "ii", "c", "p", "ind", "slice", "mini", "ui", "gi", "fi", "io", "mi", "j"], "got_output": ["getting_response", "got___response", "got_response", "got_download", "getting_output", "getting_download", "got___download", "got___output", " got_input", "got_input", "got___input", " got_Output", "got_Output", "getting_input"], "avpkt": ["aveccht", "avvetsk", "avdpacket", "avfwk", "caltpwk", "avnpiece", "avpetsk", "avcpnt", "evcpk", "avopqt", "avfkt", "Avppkt", "avcpcht", "evcpnt", "avpqt", "avmkt", "evpkt", "avcpk", "avgiece", "caltpkt", "avfett", "avaft", "avipacket", "avegkt", "adpkt", "avpnt", "avipkt", "avppact", "avlpk", "avpwk", "avppkt", "avopk", "avpiece", "avcpkt", "avvkt", "Avppact", "avdpunct", "avPkt", "avmqt", "calpunct", "avdpkt", "avvacket", "ovpetsk", "avspet", "avgkt", "avbacket", "avnpft", "avecct", "avcct", "avfnt", "adlpqt", "avepiece", "avfct", "avlpett", "avakt", "avepcht", "avpk", "Avpact", "avbnt", "avepft", "avPk", "avgke", "avaiece", "avgft", "avlpqt", "adpk", "avnpcht", "avmk", "avspcp", "avfunct", "AVpcht", "calpkt", "Avppacket", "avparamcht", "ovbacket", "evcpkt", "avpet", "avdpwk", "avspkt", "avciece", "ovpacket", "avopett", "avpacket", "avspcht", "AVcpcht", "avckt", "avPqt", "avpact", "avepke", "avpett", "avPnt", "ovbetsk", "Avppwk", "avfiece", "ovbkt", "avipwk", "Avpkt", "avbetsk", "avnpkt", "evpk", "avtpacket", "Avpwk", "calpacket", "avppwk", "Avpacket", "evpqt", "avake", "avopkt", "adpqt", "adlpk", "aveciece", "AVpcp", "avvnt", "caltpacket", "avtpwk", "avtpkt", "avcpcp", "avccht", "avegft", "avcpqt", "avpft", "adlpkt", "avpunct", "avpcht", "avparamcp", "avpct", "avfacket", "evcpqt", "avnpct", "avegke", "avfact", "AVpet", "avfetsk", "avtpunct", "ovpnt", "ovpkt", "avparamkt", "ovbnt", "calpwk", "avfcht", "avepct", "avbkt", "avegiece", "avfqt", "avnpke", "adlpett", "adpett", "avmnt", "avpcp", "AVcpcp", "avlpkt", "AVcpet", "evpnt", "AVpkt", "avparamet", "aveckt", "avipact", "avpke", "avppacket", "caltpunct", "avfk", "avepkt", "AVcpkt", "avcpet"], "duration": ["g", "lag", "f", "timeout", "result", "valid", "gap", "d", "fun", "id", "total", "gr", "T", "G", "unit", "wait", "resp", "desc", "err", "group", "loss", "sec", "num", "sg", "start", "debug", "m"]}}
{"project": "FFmpeg", "commit_id": "af2ee6fc4921a81133c0915985e05781505c2ff8", "target": 0, "func": "static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n\n                                       SingleChannelElement *sce,\n\n                                       const float lambda)\n\n{\n\n    int q, w, w2, g, start = 0;\n\n    int i, j;\n\n    int idx;\n\n    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];\n\n    int bandaddr[TRELLIS_STAGES];\n\n    int minq;\n\n    float mincost;\n\n    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;\n\n    int q0, q1, qcnt = 0;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        float t = fabsf(sce->coeffs[i]);\n\n        if (t > 0.0f) {\n\n            q0f = FFMIN(q0f, t);\n\n            q1f = FFMAX(q1f, t);\n\n            qnrgf += t*t;\n\n            qcnt++;\n\n        }\n\n    }\n\n\n\n    if (!qcnt) {\n\n        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n\n        memset(sce->zeroes, 1, sizeof(sce->zeroes));\n\n        return;\n\n    }\n\n\n\n    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n    q0 = av_clip_uint8(log2(q0f)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n    q1 = av_clip_uint8(log2(q1f)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n    if (q1 - q0 > 60) {\n\n        int q0low  = q0;\n\n        int q1high = q1;\n\n        //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped\n\n        int qnrg = av_clip_uint8(log2(sqrt(qnrgf/qcnt))*4 - 31 + SCALE_ONE_POS - SCALE_DIV_512);\n\n        q1 = qnrg + 30;\n\n        q0 = qnrg - 30;\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n        if (q0 < q0low) {\n\n            q1 += q0low - q0;\n\n            q0  = q0low;\n\n        } else if (q1 > q1high) {\n\n            q0 -= q1 - q1high;\n\n            q1  = q1high;\n\n        }\n\n    }\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n\n\n    for (i = 0; i < TRELLIS_STATES; i++) {\n\n        paths[0][i].cost    = 0.0f;\n\n        paths[0][i].prev    = -1;\n\n    }\n\n    for (j = 1; j < TRELLIS_STAGES; j++) {\n\n        for (i = 0; i < TRELLIS_STATES; i++) {\n\n            paths[j][i].cost    = INFINITY;\n\n            paths[j][i].prev    = -2;\n\n        }\n\n    }\n\n    idx = 1;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {\n\n        start = w*128;\n\n        for (g = 0; g < sce->ics.num_swb; g++) {\n\n            const float *coefs = sce->coeffs + start;\n\n            float qmin, qmax;\n\n            int nz = 0;\n\n\n\n            bandaddr[idx] = w * 16 + g;\n\n            qmin = INT_MAX;\n\n            qmax = 0.0f;\n\n            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                if (band->energy <= band->threshold || band->threshold == 0.0f) {\n\n                    sce->zeroes[(w+w2)*16+g] = 1;\n\n                    continue;\n\n                }\n\n                sce->zeroes[(w+w2)*16+g] = 0;\n\n                nz = 1;\n\n                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {\n\n                    float t = fabsf(coefs[w2*128+i]);\n\n                    if (t > 0.0f)\n\n                        qmin = FFMIN(qmin, t);\n\n                    qmax = FFMAX(qmax, t);\n\n                }\n\n            }\n\n            if (nz) {\n\n                int minscale, maxscale;\n\n                float minrd = INFINITY;\n\n                //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n                minscale = av_clip_uint8(log2(qmin)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n                maxscale = av_clip_uint8(log2(qmax)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);\n\n                maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);\n\n                for (q = minscale; q < maxscale; q++) {\n\n                    float dist = 0;\n\n                    int cb = find_min_book(sce->sf_idx[w*16+g], sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);\n\n                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                        FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                        dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],\n\n                                                            q + q0, cb, lambda / band->threshold, INFINITY, NULL);\n\n                    }\n\n                    minrd = FFMIN(minrd, dist);\n\n\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + dist\n\n                               + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                for (q = 0; q < q1 - q0; q++) {\n\n                    if (!isinf(paths[idx - 1][q].cost)) {\n\n                        paths[idx][q].cost = paths[idx - 1][q].cost + 1;\n\n                        paths[idx][q].prev = q;\n\n                        continue;\n\n                    }\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            sce->zeroes[w*16+g] = !nz;\n\n            start += sce->ics.swb_sizes[g];\n\n            idx++;\n\n        }\n\n    }\n\n    idx--;\n\n    mincost = paths[idx][0].cost;\n\n    minq    = 0;\n\n    for (i = 1; i < TRELLIS_STATES; i++) {\n\n        if (paths[idx][i].cost < mincost) {\n\n            mincost = paths[idx][i].cost;\n\n            minq = i;\n\n        }\n\n    }\n\n    while (idx) {\n\n        sce->sf_idx[bandaddr[idx]] = minq + q0;\n\n        minq = paths[idx][minq].prev;\n\n        idx--;\n\n    }\n\n    //set the same quantizers inside window groups\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])\n\n        for (g = 0;  g < sce->ics.num_swb; g++)\n\n            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)\n\n                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];\n\n}\n", "idx": 18095, "substitutes": {"avctx": ["ajpkg", "verpkg", "AVpkg", "avcontext", "ajcas", "AVcontext", "AVcas", "AVctx", "verctx", "ajctx", "ajcontext", "avcas", "vercontext", "vercas", "avpkg"], "s": ["cs", "server", "client", "sys", "session", "sa", "rs", "space", "o", "c", "ts", "service", "ssl", "b", "sl", "fs", "services", "S", "sec", "e", "ses", "os", "a", "sc", "spec", "sync"], "sce": ["mcel", "dcel", "inscing", "scast", "veste", "jscing", "wsced", "insce", " ske", "dcf", " sCE", "jsce", "wsCE", "vesce", "sCE", "scel", "insCE", "scf", "scing", "wsge", "vescast", "wsce", "dscf", "jsCE", "ssCE", "jsced", "wske", "dce", "rsge", "Sge", "dces", "rsCE", "mce", "mge", "exced", "openste", "openscast", "sincing", "opensced", "excast", "sced", "wscing", " sces", " sge", "Sces", "inske", "rsces", " scing", "opensce", "ssce", "Sce", "vesced", "ske", "sinCE", "exce", "ssge", "mces", "dscel", "sge", "wscel", "since", " scf", "sces", "Scel", "sinced", "wsces", " scel", "dsces", "ste", "rsce", "dsce", "ssces", "exte"], "lambda": ["phi", " lam", "scale", "alpha", " omega", " func", " function", "ta", "fee", " gamma", " beta", "fun", " weight", " fn", "beta", " delta", " costs", "frac", "da", "func", "function", "b", " Phi", "weight", " formula", "loss", " loss", " L"], "q": ["f", "quant", "Q", "qi", "x", "sq", "req", "d", "quest", "ip", "ch", "cl", "max", "qa", "qq", "qt", "iq", "k", "c", "dq", "p", "qu", "z", "count", "qs", "v"], "w": ["f", "wt", "x", "u", "wh", "d", "n", "we", "h", "max", "r", "win", "k", "c", "p", "y", "b", "z", "weight", "l", "wa", "W", "v", "m"], "w2": ["qii", "x2", "w0", "q2", "x0", "wii", "wa2", "x1", "wa0", "w1", "xii", "wa1", "waii"], "g": ["gm", "f", "x", "u", "d", "n", "h", "gs", "c", "k", "p", "G", "y", "b", "z", "gp", "group", "gn", "sg", "e", "l", "v", "go", "m"], "i": ["is", "di", "uli", "f", "ri", "xi", "x", "u", "ix", "ci", "in", "li", "t", "eni", "ji", "uri", "it", "d", "info", "n", "ip", "ti", "I", "si", "pi", "multi", "id", "h", "r", "index", "ai", "iu", "o", "ii", "k", "c", "p", "y", "b", "z", "ui", "ni", "zi", "gi", "yi", "fi", "e", "l", "start", "io", "oi", "ie", "ini", "mi", "m"], "j": ["f", "jp", "x", "u", "li", "ji", "d", "n", "jl", "ij", "h", "r", "o", "k", "c", "p", "pos", "y", "b", "z", "e", "l", "J", "v", "m"], "idx": ["idw", " idz", "Idw", "idX", "midw", " idw", "Idz", "midX", "midz", " idX", "midx", "idz", "Idx", "IdX"], "paths": ["pathls", "strs", "bufs", "Pathls", "strses", "bufes", "pathes", "bufls", "stres", "pathses", "bufses", "Pathses", "strls", "Pathes", "Paths"], "TRELLIS_STAGES": ["TRELLIS_STGES", "TRELLIS_Stages", "TRELLIS_StGES", "TRELLIS_STRGES", "TRELLIS_StAGES", "TRELLIS_STRAGE", "TRELLIS_STATES", "TRELLIS_STRages", "TRELLIS_StATES", "TRELLIS_STAGE", "TRELLIS_STRATES", "TRELLIS_STRAGES", "TRELLIS_INSTAGE", "TRELLIS_INSTATES", "TRELLIS_StAGE", "TRELLIS_INSTages", "TRELLIS_STages", "TRELLIS_INSTAGES"], "bandaddr": ["wavework", "cmptr", "Bandwork", "bandwork", "cmpad", "bandptr", "waveptr", "wavepad", "cmwork", "bandpad", "cmaddr", "Bandaddr", "waveaddr", "Bandpad", "Bandptr"], "minq": ["minp", " minp", "minimumqa", "Minq", "Minqa", "minimumq", " minqa", "minimump", " mindq", "Minp", "minqa", "Mindq", "mindq", "minimumdq"], "mincost": ["initcost", "initprice", "subprice", "subfee", " minfee", "initfee", "minprice", "subq", "subcost", " minprice", "initq", "minfee"], "q0": ["qu2", "qq00", "qa00", "iq0", "dq00", "dq4", "query00", "q00", "sq1", "qifrom", "que9", "que2", "iq1", "qu50", "qi00", "p0", "questfrom", "qu4", "query2", "Qie", "quest0", "qu0", "dq6", "qie", " q6", "qa6", "dq2", "qu00", "dq0", "sq0", "qa1", "p1", "qa50", "qa2", "query4", "qq50", "qu1", "qi0", "query9", "que00", "sq00", " q50", "q2", "q4", "dq9", "questie", "qu6", "query1", "p2", "q9", "query0", "p00", " q00", "qq2", " q2", "que0", "quest00", "q50", "qq0", "Qfrom", "iq4", "sq2", "sq6", "qiie", "sq4", "qfrom", "query6", "qa0", "q6", "Q00", "iq00", "Q0"], "q1": ["eq1", "sq1", "Q8", "p8", " q6", "quend", "eq10", "qqone", "sqOne", "queryend", "qub", "q2", "q10", "que11", "qqb", "query1", "quest1", "quest8", "quest2", "q13", "qOne", "qu61", "quest7", "eq61", "quone", "qa10", "qu8", "eqone", "eq2", "p0", "qqOne", "qu13", "Q1", "qa8", "pone", "sq61", "p1", "eq7", "qu1", "eq6", " qone", "Q7", "q9", "que1", " q01", "sq01", "sq6", "qa9", "q6", "eq9", "qu2", "q11", "sq13", " q8", "qone", " q9", "q7", "qa1", "qq1", "query0", "queend", " q2", "qq2", "eq8", "que0", "eq01", "eq13", "sq2", "qq01", "query11", "q61", "qu0", "qend", "q8", " q10", "qu11", "qu01", "sqone", "q01", "qb", "Q2", "quOne", " qb"], "qcnt": ["qlcrt", "qpcNT", "qscnt", "qrcrt", " qlcnt", "qpcno", "qrcNT", "qCrt", "qlcret", " qcnd", "qlcno", "qecct", "qncno", "qpcrt", "qdcrt", "qcret", " qlcNT", " qcct", "qecrt", " qscrt", " qlcnd", "qpcant", "qncrt", "qncct", "qncant", " qscant", "qscant", "qpcnd", " qlcno", "qdcant", " qcno", " qncnt", "qpcret", "qcrt", "qlcNT", " qncNT", "qcant", "qlcant", " qcret", "qpcnt", " qlcret", "qecnt", "qecant", " qscct", " qcrt", "qdcnd", " qscnt", "qcnd", "qlcnd", " qncno", "qncNT", "qCno", "qcno", " qcant", "qrcno", " qlcant", " qlcrt", "qrcnt", "qcct", "qdcnt", "qncnt", " qcNT", "qCNT", " qncrt", "qscrt", "qCnt", "qscct", "qlcnt", "qncret", "qcNT"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    /* Add footer to total size */\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 18138, "substitutes": {"fd": ["fx", "cd", "sf", "df", "bd", "f", "dc", "handle", "fed", "dd", "draft", "ad", "d", "wb", "lf", "feed", "fc", "fw", "FD", "db", "fin", "dir", "dl", "reader", "fl", "rb", "cf", "wd", "c", "file", "fp", " fid", "xd", "ptr", "fs", "hd", "fat", "handler", "fi", " FD", "fn", "buff", "driver", "flo", "tty", "io", "cod", "ds", "fb"], "buf": ["batch", "vec", "bd", "f", "src", "uf", "bc", "queue", " buffer", "buffer", "Buffer", "wb", "fin", "db", "ff", "data", "ctx", "loc", "rb", "fp", "cv", "tmp", "b", "ptr", "bytes", "alloc", "cb", "fi", "rc", "bf", "seq", "buff", "v", "fb"], "total_size": [" total_loc", "total_capacity", "total_SIZE", "totalacspeed", " total_speed", " total_capacity", "total_speed", "total64loc", "total64size", "totalaccapacity", " total_SIZE", "total_loc", "totalacsize", " total_bytes", "total64SIZE", "total_bytes"]}}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n", "idx": 18142, "substitutes": {"ctx": ["cp", "cs", "cm", "pc", "jp", "bc", "ci", "conn", "exec", "conv", "obj", "fw", "rx", "cas", "lc", "exc", "loc", "conf", "cc", "vc", "tx", "pkg", "Context", "context", "rc", "cb", "cmp", "utils", "xc"], "fs": ["cs", "fx", "df", "raf", "f", "sys", "bs", "cache", "ds", "flows", "FS", "rs", "Fs", "feed", "ns", "obj", "fd", "cms", "fw", "vs", "ls", "es", "files", "cf", "acs", "fp", "s", "ks", "tx", "os", "fc", "qs", "fb", "irs"], "entry": ["inner", "ry", "array", "cur", "end", "Entry", "feed", "inter", "record", "si", "id", "ident", "data", "reader", " Entry", "ries", "cell", "archive", "import", "deep", "try", "ent", "enter", "insert", "element", " entries", "row", "e", "ie", "se", "event", "info"], "result": ["results", "resource", "inner", "match", "Result", "report", "instance", "array", "res", "success", "end", "valid", "counter", "record", "pair", "card", "r", "dict", "der", "data", "raw", "successful", "final", "future", "response", "desc", "comment", "err", "rc", "ret", "arr", "list", "master", "event"]}}
{"project": "qemu", "commit_id": "368d25881c94f9e09ef19a3d93e8fec797dbcd05", "target": 0, "func": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n\n                                        int w, int h)\n\n{\n\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n\n    size_t bytes;\n\n    int zywrle_level;\n\n\n\n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n\n        if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {\n\n            zywrle_level = 0;\n\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n\n        } else if (vs->tight.quality < 3) {\n\n            zywrle_level = 3;\n\n        } else if (vs->tight.quality < 6) {\n\n            zywrle_level = 2;\n\n        } else {\n\n            zywrle_level = 1;\n\n        }\n\n    } else {\n\n        zywrle_level = 0;\n\n    }\n\n\n\n    vnc_zrle_start(vs);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 1:\n\n        zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n\n        break;\n\n\n\n    case 2:\n\n        if (vs->clientds.pf.gmax > 0x1F) {\n\n            if (be) {\n\n                zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 4:\n\n    {\n\n        bool fits_in_ls3bytes;\n\n        bool fits_in_ms3bytes;\n\n\n\n        fits_in_ls3bytes =\n\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n\n\n\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n\n                            vs->clientds.pf.gshift > 7 &&\n\n                            vs->clientds.pf.bshift > 7);\n\n\n\n        if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n\n            if (be) {\n\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n\n          }\n\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n\n            if (be) {\n\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n    }\n\n    break;\n\n    }\n\n\n\n    vnc_zrle_stop(vs);\n\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n\n    vnc_write_u32(vs, bytes);\n\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n\n    return 1;\n\n}\n", "idx": 18150, "substitutes": {"vs": ["verts", "lines", "ves", "ms", "uv", "bs", "lv", "wp", "net", "js", "plugins", "va", "posts", "gs", "ums", "vc", "obs", "fs", "vert", "stats", "vr", "utils", "ins", "VS", "qs", "blogs", "eps", "styles", "http", "orts", "values", "ns", "dev", "vers", "state", "versions", "vp", "iss", "opens", "es", "views", "sk", "s", "ks", "vol", "ts", "nets", "pages", "services", "fps", "sv", "env", "serv", "ver", "ils", "flags", "ops", "pps", "rs", "ss", "vi", "iv", "rss", "ens", "vis", "ii", "pos", "oss", "xs", "vt", "ev", "otes", "hs", "ys", "cs", "css", "vas", "ov", "ps", "ports", "vals", "alls", "rules", "pg", "ls", "Vs", "cv", "vg", "iffs", "las", "nav", "os", "px", "ds", "v", "settings"], "x": ["fx", "f", "xy", "xi", "ix", "u", "na", "in", "t", "d", "py", "n", "i", "id", "lat", "X", "on", "one", "code", "index", "wx", "rx", "win", "o", "data", "xt", "dx", "c", "k", "p", "line", "pos", "ic", "b", "xs", "tx", "z", "up", "image", "wy", "xx", "e", "l", "px", "wa", "a", "v", "ex", "m"], "y": ["ys", "Y", "vy", "f", "ry", "xy", "ish", "u", "t", "ny", "d", "py", "yo", "yn", "n", "ch", "i", "ies", "ye", "oy", "win", "o", "zy", "dy", "c", "p", "cy", "sy", "b", "sky", "ay", "z", "yt", "wy", "yi", "ya", "e", "l", "ey", "a", "yy", "v", "j"], "w": ["ow", "f", "wp", "wt", "u", "sh", "wh", "q", "wm", "sw", "wb", "d", "wr", "n", "we", "wl", "hw", "way", "i", "wu", "fw", "aw", "r", "wx", "win", "ew", "wn", "wd", "c", "p", "b", "wal", "iw", "z", "wy", "wall", "wan", "ww", "l", "wo", "wa", "a", "W", "rw", "v", "wid"], "h": ["g", "dh", "f", "hi", "u", "oh", "sh", "bh", "q", "wh", "kh", "uh", "rh", "H", "ch", "hw", "i", "th", "hl", "c", "height", "k", "p", "how", "ha", "s", "he", "gh", "b", "hp", "ih", "z", "hh", "home", "hd", "en", "e", "l", "ph", "hs", "ah", "hm", "ht", "v", "m"], "bytes": ["cm", "ops", "ents", "amples", "complete", "len", "args", "ips", "bits", "data", "iff", "byte", "ls", "ii", "all", "lements", "ables", "odes", "gb", "os", "io", "out", "Bytes", "elt"], "zywrle_level": ["zywrle_where", "zywrke_level", "zywrli_all", "zywrle_vel", "zywrge_vel", "zywrl_layer", "zywrla_vel", "zywrole_vel", "zywrli_level", "zywrla_level", "zywrble_where", "zywrle_weight", "zywrl_lvl", "zywrle_lvl", "zywrge_level", "zywrle0weight", "zywrleaclevel", "zywrle__line", "zywrle0all", "zywrle__level", "zywrble_line", "zywrl_line", "zywrke_inc", "zywrge_depth", "zywrle_depth", "zywrle_inc", "zywrleacvel", "zywrle_limit", "zywrle_letter", "zywrke_levels", "zywrl_level", "zywrble_limit", "zywrle_value", "zywrle_line", "zywrble_level", "zywrle__limit", "zywrle_all", "zywrge_levels", "zywrle_levels", "zywrleaclayer", "zywrole_where", "zywrleacvalue", "zywrke_depth", "zywrle__where", "zywrole_level", "zywrl_vel", "zywrle0level", "zywrla_lock", "zywrla_limit", "zywrble_letter", "zywrl_value", "zywrle_lock", "zywrle_layer", "zywrli_weight"], "fits_in_ls3bytes": ["fits_in_ls1pieces", "fits_in_ls3bits", "fits_in_las6seconds", "fits_in_las3bits", "fits_in_las3pieces", "fits_in_ls1bits", "fits_in_ls6pieces", "fits_in_lsdunits", "fits_in_ls6bytes", "fits_in_lsdbytes", "fits_in_ns3bits", "fits_in_ls32pieces", "fits_in_lsthreeunits", "fits_in_nsdunits", "fits_in_nsdbytes", "fits_in_las3bytes", "fits_in_ns3bytes", "fits_in_las3seconds", "fits_in_las6bits", "fits_in_ls1seconds", "fits_in_ls32bits", "fits_in_lsthreebytes", "fits_in_lsdbits", "fits_in_las6bytes", "fits_in_ls6seconds", "fits_in_ls3units", "fits_in_ls6bits", "fits_in_lsthreebits", "fits_in_ls2bits", "fits_in_ns3units", "fits_in_ls32bytes", "fits_in_ls1bytes", "fits_in_ls2units", "fits_in_ls2bytes", "fits_in_nsdbits", "fits_in_ls3pieces", "fits_in_ls3seconds", "fits_in_ls32seconds", "fits_in_las6pieces"], "fits_in_ms3bytes": ["fits_in_les6bytes", "fits_in_msdbits", "fits_in_les3bytes", "fits_in_ms2bytes", "fits_in_les3byte", "fits_in_ms6bits", "fits_in_ms6byte", "fits_in_ms2byte", "fits_in_msdbytes", "fits_in_les6bits", "fits_in_les6byte", "fits_in_ms3bits", "fits_in_ms2bits", "fits_in_msdbyte", "fits_in_les3bits", "fits_in_ms3byte", "fits_in_ms6bytes"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n", "idx": 18159, "substitutes": {"opaque": [" opace", "OPace", "OPaque", "opaco", "ipec", "opec", " opec", " opaco", "opace", "ipaco", " opac", "OPacity", "ipac", "opacity", "OPac", "copaque", " opacity", "copec", "ipacity", "copaco", "ipace", "opc", "copc", "ipaque", "ipc", "opac", " opc"], "addr": ["dc", "src", "type", "work", "pad", "ad", "base", "len", "args", "config", "address", "ord", "data", "ace", "byte", "cap", "ref", "pos", "da", "nr", "ada", "pointer", "Address", "ptr", "seq", "part", "oa", "host"], "size": ["length", "number", "type", "Size", "len", "args", "SIZE", "small", "ize", "capacity", "offset", "address", "data", "c", " Size", " sizes", "unit", "desc", " bytes", "bytes", "shape", " length", "empty", "mode"], "s": ["g", "f", "session", "ops", "secondary", "ds", "ss", "sq", "scope", "d", "n", "si", "i", "state", "submit", "h", "r", "o", "c", "p", "service", "ssl", "b", "sl", "fs", "services", "S", "request", "e", "ses", "settings", "sym", "hs", "a", "spec", "sync", "m"]}}
{"project": "qemu", "commit_id": "e37e6ee6e100ebc355b4a48ae9a7802b38b8dac0", "target": 0, "func": "void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n", "idx": 18161, "substitutes": {"env": ["eu", "net", "cache", "global", "et", "eni", "org", "exec", "exe", "code", "dict", "equ", "fen", "ef", "engine", "conf", "app", "loader", "enter", "eve", "context", "oa", "server", "forge", "nc", "enable", "req", "np", "Environment", "ea", "err", "vm", "environment", "manager", "eye", "console", "bc", "eh", "config", "fg", "db", "eng", "vs", "entry", "iter", "energy", "er", "enh", "impl", "en", "viron", "ev", "dat", "ah", "output", "vel", "conn", "el", "here", "obj", "enc", "ner", "ec", "exc", "qt", "eur", "ext", "ou", "cv", "esm", "her", "event", "gui", "e", "que", "debug", "v"], "addr": ["di", "handle", "extra", "node", "x", "off", "eni", "xp", "ar", "r", "rx", "ha", "enter", "rg", "eth", "attr", "amd", "order", "layer", "oa", "player", "dr", "server", "work", "dd", "add", "coord", "site", "location", "index", "usr", "kt", "mac", "ea", "p", "url", "port", "alias", "host", "offset", "route", "src", "intel", "ip", "localhost", "config", "address", "ord", "ace", "target", "pointer", "rc", "arr", "ack", "size", "rr", "result", "worker", "asm", "conn", "inter", "len", "obj", "word", "adr", "hop", "align", "loc", "ext", "ref", "nr", "Address", "adder", "ptr", "edge", "slice", "e", "cmp", "device", "part", "amp"], "i": ["phi", "di", "min", "f", "ri", "xi", "cli", "type", "qi", "u", "x", "ix", "ci", "li", "name", "t", "source", "eni", "mu", "uri", "it", "d", "ip", "si", "pi", "I", "id", "multi", "site", "address", "index", "ai", "diff", "iu", "o", "ii", "c", "p", "line", "key", "y", "b", "ui", "gi", "yi", "field", "e", "l", "a", "io", "ie", "ini", "v", "ti", "j", "info"]}}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "void ff_slice_thread_free(AVCodecContext *avctx)\n\n{\n\n    ThreadContext *c = avctx->thread_opaque;\n\n    int i;\n\n\n\n    pthread_mutex_lock(&c->current_job_lock);\n\n    c->done = 1;\n\n    pthread_cond_broadcast(&c->current_job_cond);\n\n    pthread_mutex_unlock(&c->current_job_lock);\n\n\n\n    for (i=0; i<avctx->thread_count; i++)\n\n         pthread_join(c->workers[i], NULL);\n\n\n\n    pthread_mutex_destroy(&c->current_job_lock);\n\n    pthread_cond_destroy(&c->current_job_cond);\n\n    pthread_cond_destroy(&c->last_job_cond);\n\n    av_free(c->workers);\n\n    av_freep(&avctx->thread_opaque);\n\n}\n", "idx": 18171, "substitutes": {"avctx": ["avlib", "akctx", "afctx", "AVconfig", "aflc", "abcontext", "abctx", "apcontext", "awctx", "avcmp", "awcontext", "afcv", "avectx", "avcontext", "AVlc", "aveca", "avconfig", "apctx", "akca", "AVlib", "AVctx", "avecontext", "awlib", "awcmp", "avca", "AVcmp", "AVcontext", "avecv", "avlc", "aflib", "apconfig", "afconfig", "abcmp", "avcv", "ablc", "afcmp", "afcontext", "akcontext", "akcv", "afca", "apcmp"], "c": ["g", "can", "cs", "cp", "self", "cm", "dc", "f", "coll", "pc", "this", "uc", "nc", "bc", "ac", "u", "ci", "cur", "t", "conn", "d", "n", "config", "cl", "h", "co", "con", "ctx", "ec", "lc", "ca", "cf", "oc", "k", "ce", "p", "s", "cc", "vc", "b", "cr", "tc", "m", "ct", "count", "arc", "mc", "e", "cmp", "l", "ctrl", "anc", "C", "cu", "xc", "sc", "fc", "v", "icc", "cn"], "i": ["phi", "di", "f", "ri", "xi", "hi", "x", "u", "qi", "ix", "ci", "li", "t", "bi", "uri", "d", "mi", "info", "n", "I", "si", "pi", "multi", "id", "h", "ai", "r", "index", "iu", "o", "ii", "k", "p", "b", "z", "ui", "gi", "zi", "count", "yi", "fi", "e", "l", "a", "io", "oi", "ini", "v", "ti", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0", "target": 1, "func": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 18175, "substitutes": {"avctx": ["ajc", "afctx", "abcontext", "abctx", "ajcontext", "afcv", "ajcv", "avcontext", "avloc", "avci", "ajctx", "AVctx", "afci", "AVcontext", "ajloc", "abc", "abcv", "avcv", "afc", "ajci", "AVci", "AVloc", "afloc", "afcontext", "avc"], "data": ["progress", "alpha", "map", "length", "mode", "result", "name", "complete", "cache", "frame", "media", "parent", "DATA", "type", "source", "window", "pad", "ad", "buffer", "d", "connection", "base", "Data", "message", "id", "memory", "address", "code", "padding", "input", "addr", "draw", "reader", "next", "body", "p", "pos", "da", "missing", "content", "ada", "pointer", "value", "image", "bytes", "dat", "start", "ata", "a", "open", "empty", "part", "size", "offset"], "got_sub_ptr": ["got_sub_pointer", "got_subipptr", "got_sub_addr", "got_subippointer", "got_subxpointer", "got_subipdim", "got_subxptr", "got_subxaddr", "got_sub_dr", "got_subipaddr", "got_sub_dim", "got_subxdr"], "avpkt": ["avspqt", "upvpkt", "avnkg", "avfwk", "avPcht", "afpkt", "avPcp", "avfkt", "avprcp", "afPcp", "avpacht", "upvpka", "abpacket", "avpqt", "avmkt", "avvpkt", "abpkg", "avvpka", "avpnt", "uppkt", "ajpkt", "avpwk", "avvkt", "avpawk", "avPkt", "ajpcht", "avPacket", "avvacket", "avprkt", "avnqt", "avvpacket", "avfnt", "avfet", "avpaacket", "abfkg", "avpant", "avvqt", "avpkg", "avspcp", "avprct", "avvkg", "abfwk", "abpwk", "afpcp", "avpet", "avnacket", "avspkt", "avpake", "avpacket", "avPqt", "avfkg", "avfka", "upvpet", "uppet", "avmet", "ajpake", "avpcwk", "afPkt", "abfnt", "ajpacht", "avpcacket", "abfkt", "avvpet", "avpka", "avnkt", "avfke", "afpqt", "avPct", "abpkt", "avpcnt", "avpckt", "avpcht", "ajpacket", "afPct", "avpct", "avspct", "avPke", "ajpke", "avfacket", "afPqt", "avpakt", "abfacket", "abpqt", "ajpakt", "afpct", "uppka", "avmacket", "avfcht", "avprqt", "avfqt", "avmka", "avpcp", "abfqt", "uppacket", "ajpaacket", "upvpacket", "avpke", "abpnt"], "ptr": ["dr", "shift", "pointers", " pointer", "pt", "src", "length", "proc", "inst", "temp", "buf", "cur", "pad", "req", "buffer", "point", "tr", "coord", "fd", "tell", "address", "index", "Ptr", "addr", "ctx", "loc", "ext", "ref", "p", "fp", "pos", "patch", "tmp", "depth", "pointer", "slice", "desc", "context", "attr", "start", "port", "tty", "buff", "ctr", "alloc", "offset"], "len": ["lim", "val", "str", "vec", "min", "length", "split", "name", "lt", "Len", "li", "el", "req", "lf", "n", "base", "fun", "low", "i", "lon", "lib", "id", "fin", "code", "span", "rev", "hl", "dl", "ls", "doc", "lc", "lang", "dy", "iter", "loc", "all", "pre", "fl", "c", "line", "pos", "led", "ell", "sl", "z", "le", "en", "bytes", "count", "url", " el", "seq", "l", "ler", " length", "start", "lit", "ie", "part", "ln", "elt", "size", "offset"], "dialog": ["defog", "colocation", "defogging", "logit", "Dialogue", "logogue", "diffogging", "Dialogo", "dialocation", "dialocol", "dialit", "diffogs", "collog", "dialogs", "logogo", "chalogging", "dialogue", "Dialit", "llog", "collogo", "defogue", "logocation", "dialogo", "collit", "chalog", "chalogue", "chalogs", "colocol", "logocol", "cologue", "collogue", "defogs", "llocol", "colog", "diffogue", "dialogging", "llocation", "llogue", "logog", "Dialog", "diffog"]}}
{"project": "qemu", "commit_id": "5e003f17ec518cd96f5d2ac23ce9e14144426235", "target": 1, "func": "static int init_blk_migration(QEMUFile *f)\n\n{\n\n    BlockDriverState *bs;\n\n    BlkMigDevState *bmds;\n\n    int64_t sectors;\n\n    BdrvNextIterator it;\n\n    int i, num_bs = 0;\n\n    struct {\n\n        BlkMigDevState *bmds;\n\n        BlockDriverState *bs;\n\n    } *bmds_bs;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n    block_mig_state.bulk_completed = 0;\n\n    block_mig_state.zero_blocks = migrate_zero_blocks();\n\n\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n        num_bs++;\n\n    }\n\n    bmds_bs = g_malloc0(num_bs * sizeof(*bmds_bs));\n\n\n\n    for (i = 0, bs = bdrv_first(&it); bs; bs = bdrv_next(&it), i++) {\n\n        if (bdrv_is_read_only(bs)) {\n\n            continue;\n\n        }\n\n\n\n        sectors = bdrv_nb_sectors(bs);\n\n        if (sectors <= 0) {\n\n            ret = sectors;\n\n\n            goto out;\n\n        }\n\n\n\n        bmds = g_new0(BlkMigDevState, 1);\n\n        bmds->blk = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n\n        bmds->blk_name = g_strdup(bdrv_get_device_name(bs));\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = migrate_use_block_incremental();\n\n\n\n        assert(i < num_bs);\n\n        bmds_bs[i].bmds = bmds;\n\n        bmds_bs[i].bs = bs;\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n\n\n    /* Can only insert new BDSes now because doing so while iterating block\n\n     * devices may end up in a deadlock (iterating the new BDSes, too). */\n\n    for (i = 0; i < num_bs; i++) {\n\n        BlkMigDevState *bmds = bmds_bs[i].bmds;\n\n        BlockDriverState *bs = bmds_bs[i].bs;\n\n\n\n        if (bmds) {\n\n            ret = blk_insert_bs(bmds->blk, bs, &local_err);\n\n            if (ret < 0) {\n\n                error_report_err(local_err);\n\n                goto out;\n\n            }\n\n\n\n            alloc_aio_bitmap(bmds);\n\n            error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n            bdrv_op_block_all(bs, bmds->blocker);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    g_free(bmds_bs);\n\n    return ret;\n\n}", "idx": 18187, "substitutes": {"f": ["sf", "df", "t", "fo", "d", "feed", "info", "fd", "fu", "fr", "tf", "xf", "c", "F", "fp", "p", "file", "b", "fa", "fs", "fn", "fi", "e", "l", "filename", "fe", "fc", "m"], "bs": ["lbs", "cs", "css", "bo", "src", "http", "ps", "blog", "bc", "rs", "BS", "js", "bh", "ss", "ns", "bb", "feed", "base", "obj", "boot", "hub", "lib", "banks", "bid", "state", "bits", "blocks", "pb", "db", "ob", "vs", "ls", "eb", "iss", "bps", "hop", "ba", "browser", "loc", "gs", "loop", "bot", "sb", "bas", "s", "ts", "b", "obs", "ubs", "bed", "fs", "las", "stats", "bis", "cb", "ab", "gb", "bos", "ses", "os", "fe", "bu", "ins", "lb", "bes", "ds", "bl", "fb", "bing"], "bmds": ["bmdirs", " bmms", "bdde", "libmds", "bmdi", " bnds", " bcmds", " bmde", "bmdb", "binmds", "bmdn", "bindils", "brefns", "bmunqs", "biddses", "bmmps", "bcmds", "bcmdi", "libmads", "baldqs", "bcmdb", "fmds", "bmdses", "bmlqs", "bmgils", "bcmdjs", "bMDns", "baldn", "bcmdc", "bmacs", "bndb", "Bmdps", "bMDi", "bgmacn", "bmdls", "bmadches", "binds", "vmadns", " bmme", "bgmdlines", "fmdirs", "Bmds", "bcmdlines", "bmadns", " bmdl", "bgmacs", "bcmde", "Bcmds", "vmadps", "Bmde", "b\n", "Bmdc", "bddps", "bmadabs", " bcmdn", "fcmds", "bhardb", "bgmaclines", "bmade", "brefabs", "biddss", "bmdl", "bdefns", "bnds", " bmdss", " bcmdqs", "bmdches", " bmdjs", " bmdqs", "bmgs", "B_", "bcmdirs", "bmunls", " bg", "bmme", "bdefabs", " bndb", "bmmn", " bMDses", "bdds", "bMDps", "bmadss", "bmde", "bmmlines", "bcmdps", "binmdls", "bMDs", "bmdjs", "brefches", "bmln", "binmunls", "bmacn", "bdefches", "bMDss", " b_", " b\n", " bMDs", "bmdss", "bgmds", "Bcmdc", "bndqs", "bdefs", "bddc", "bidds", "libmadches", "bdrps", "vmdps", "libmadns", "bmdils", "bMDses", "Bcmde", "binmuns", "bindirs", "fmdils", "vmads", "bmlses", "bmdns", "libmdns", "bmadps", "vmade", "bmads", "bmuns", "bcmdl", "fcmdils", " bmdb", "bndjs", " bmdi", "binmdqs", "bmdc", "bhardjs", "bcmdses", " bMDe", "bdrs", "B\n", "bndls", "bg", "bcg", "bmdqs", "bMDe", "bmdlines", "vmde", "bhards", "brefs", "libmdches", " bmdses", "libmdabs", "Bg", " bmdn", " bndjs", "bgmdn", "bmdps", "vmds", " bmmi", "libmadabs", "bcmdn", "baldses", " bndl", "bmls", "bmgirs", "bhardl", "vmdns", "bmmc", "b_", "bmdabs", "fcmdirs", "bdrns", "bmadses", "bdre", "bcmdils", "bc_", "bcmdls", "binmunqs", "bmms", "bmaclines", " bMDss", "bcmdqs", "Bcmdps", "bc\n", "bidde", "balds", "bmmi", " bcmdses", "bndl"], "sectors": ["serets", "selements", "cectors", "perets", "Sector", "gerets", "gelements", "gexes", "secs", " sector", "spegments", "segment", "gefs", " sexes", "iectors", "pegments", "gegment", " segments", "tector", " sefs", "specs", "Sections", "celements", "spexes", "vexes", "vections", " sections", "gectors", "spectors", "sefs", "iegment", "cections", "iefs", "spelements", "pections", "telements", "Sectors", "vectors", "tections", " segment", " secs", "vecs", "spections", "Selements", "cerets", "sector", "pecs", "iexes", "tectors", "segments", "sections", "pectors", " selements", "gections", "pelements", "sexes"], "it": ["bit", "ble", "let", "itter", "mit", "IT", "ite", "ac", "op", "ci", "in", "ul", "t", "sit", "rit", "reg", "exec", "its", "dit", "ort", "feed", "n", "ip", "si", "jit", "edit", "It", "init", "you", "quit", "iter", "loc", "join", "p", "bas", "ic", "unit", "iti", "b", "item", "ct", "sec", "ait", "pit", "l", "ins", "hit", "lit", "ie", "iz", "itted", "bin", "ti", "j"], "i": ["is", "phi", "di", "uli", "ri", "cli", "xi", "hi", "qi", "x", "u", "ci", "li", "in", "eni", "bi", "uri", "wei", "d", "mi", "n", "base", "I", "pi", "si", "ij", "id", "vi", "h", "index", "ai", "ib", "chi", "iu", "ii", "c", "k", "p", "y", "ind", "b", "ki", "z", "mini", "ui", "ni", "zi", "gi", "fi", "yi", "e", "l", "start", "ori", "io", "ie", "ini", "v", "ti", "j"], "bmds_bs": ["bmdqs_bc", "bmdsJbody", "bmda_bs", "bmds_b", "bmds2bs", "bmds_bits", "bmdps_body", "bmds_ls", "bmds_bas", "bmda_ls", "bmds_abs", "bmds_bc", "bmds2body", "bmds_body", "bmdqs_bas", "bmda_ns", "bmdps_b", "bmds__bs", "bmds2ns", "bmdps_bs", "bmdqs_abs", "bmdds_bas", "bmdsJns", "bmds_ns", "bmdds_bs", "bmdps_ns", "bmdds_b", "bmds__bc", "bmds__bas", "bmdsJbs", "bmds__abs", "bmds2b", "bmdqs_bs", "bmda_bits", "bmdds_ls", "bmdsJb"], "local_err": ["localallerr", "localalldiff", "local7error", "local_diff", " local_data", "local_error", " local_diff", "local7diff", "local_data", "local7err", "localalldata", " local_error", "local7data", "localallerror"], "ret": ["RET", "val", "section", "result", "x", "rs", "res", "success", "conn", "reg", "exec", "back", "fun", "len", "multi", " RET", " resp", "rets", "esi", "ext", "det", "nt", "al", "std", "selected", "def", "resp", "re", " res", "sel", " Ret", "rc", "sec", "Ret", "fi", "mem", "bus", "seq", "arr", "lit", "list", "out", "rep", "info"], "num_bs": [" num_ses", "numXbytes", "numXblocks", "num__blocks", "num_bytes", " num_vs", "num__ns", "num__os", "numDbs", "numDsections", "num_bc", " num_blocks", "multi_bs", " num_ns", "num__ls", "num_vs", "multi_ns", "numXns", "num__bs", " num_bytes", "numXbs", "num_ns", "multi_ls", "num_ls", "numDblocks", "num_ses", "num__ses", " num_bc", "num_sections", "num_os", "numDvs", " num_sections", "num_blocks", "multi_os", "num__bc"]}}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "substitutes": {"vs": ["ys", "cs", "verts", "ils", "css", "lines", "vas", "ops", "bs", "ov", "http", "ps", "lv", "rs", "js", "ss", "vals", "alls", "ns", "vers", "va", "vp", "ls", "es", "views", "gs", "sk", "sb", "s", "ums", "cv", "ks", "ts", "vc", "obs", "xs", "fs", "services", "las", "stats", "vt", "vr", "sts", "ses", "sv", "env", "outs", "VS", "ds", "qs", "v"], "y": ["ys", "Y", "ky", "vy", "ry", "ish", "type", "yr", "u", "t", "iy", "ny", "d", "py", "yo", "yn", "col", "ch", "i", "ye", "year", "oy", "zy", "w", "dy", "c", "height", "p", "key", "cy", "sy", "sky", "ay", "z", "yt", "gy", "yi", "ya", "e", "ym", "ey", "l", "hy", "a", "yy", "v", "j"], "last_x": [" last_y", " last_ex", "last_xp", "last_z", " last_xy", "last__w", "prev_index", "prev_x", "last_y", " last_xp", "last_index", "prev_w", "last_ex", "last__ex", "last__z", " last_w", "last__xy", "last_w", "prev_y", "last__x", "last_xy", "last__xp", "last__y", " last_z"], "x": ["f", "xy", "xi", "ix", "u", "t", "q", "d", "n", "_", "i", "ax", "X", "index", "max", "rx", "w", "dx", "xf", "c", "p", "pos", "xs", "z", "en", "xx", "e", "l", "px", "wa", "v", "ex", "m"], "h": ["g", "ho", "hhh", "dh", "f", "hi", "u", "oh", "sh", "bh", "q", "t", "eh", "kh", "uh", "d", "rh", "n", "H", "ch", "i", "id", "code", "max", "hl", "o", "hr", "w", "c", "k", "height", "p", "his", "ha", "han", "he", "hp", "b", "gh", "ih", "z", "hh", "home", "hd", "e", "l", "ph", "hs", "hy", "ah", "hm", "ht", "v", "j", "m"], "tmp_x": ["last_rx", "tmp__y", " tmp_xs", "last_ix", " tmp_pe", "tmp_X", "last_X", "tmp_rex", "tmp_ex", "tmp_pe", "tmp__pe", " tmp_y", "tmp_ix", "tmp_rx", " tmp_X", "tmp_xs", "tmp_y", "tmp_xi", "tmp_name", " tmp_xi", " tmp_rex", " tmp_ex", "tmp__x", " tmp_name", "tmp__xi"]}}
{"project": "qemu", "commit_id": "a0067da1577e3eb0c60758384282568f4b2328fe", "target": 1, "func": "static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}", "idx": 18195, "substitutes": {"req": ["self", "progress", "rec", "grad", "proc", "cache", "org", "exec", "rel", "require", "ar", "r", "rx", "qq", "call", "dq", "loader", "attr", "required", "arg", "rt", "dr", "ru", "http", "ry", "work", "load", "res", "reg", "rh", "args", "urg", "cook", "qa", "fr", "respond", "var", "response", "def", "pkg", "desc", "err", "row", "push", "comp", "art", "f", "this", "cmd", "q", "crit", "config", "id", "hr", "par", "ctx", "gr", "rb", "requ", "er", "cb", "query", "ack", "spec", "str", "rr", "worker", "report", "cur", "conn", "form", "root", "qt", "ref", "pull", "request", "e", "pro", "ctr"], "resp": ["reply", "val", "progress", "rec", "grad", "session", "sp", "proc", "jp", "wp", "cache", "api", "page", "exec", "rel", "zip", "r", "Response", "call", "comm", "Resp", "work", "temp", "res", "reg", "rh", "bb", "args", "cook", "fr", "data", "rev", "respond", "esp", "params", "object", "p", "response", "pkg", "err", "model", "respons", "serv", "comp", "f", "cmd", "q", "error", "wx", "rss", "ctx", "gr", "ev", "ret", "remote", "rep", "resource", "html", "rr", "result", "ll", "report", "inc", "conn", "repl", "wb", "obj", "download", "hop", "ref", "patch", "sol", "re", "request", "buff", "part"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void add_index_entry(AVStream *st,\n\n                            int64_t pos, int64_t timestamp, int flags)\n\n{\n\n    AVIndexEntry *entries, *ie;\n\n    \n\n    entries = av_fast_realloc(st->index_entries,\n\n                              &st->index_entries_allocated_size,\n\n                              (st->nb_index_entries + 1) * \n\n                              sizeof(AVIndexEntry));\n\n    if (entries) {\n\n        st->index_entries = entries;\n\n        ie = &entries[st->nb_index_entries++];\n\n        ie->pos = pos;\n\n        ie->timestamp = timestamp;\n\n        ie->flags = flags;\n\n    }\n\n}\n", "idx": 18200, "substitutes": {"st": ["str", "sn", "sf", "sa", "src", "sp", "inst", "rest", "td", "t", "ss", "sw", "sr", "St", "stack", "est", "osc", "ist", "asts", "cl", "ace", "stat", "stream", "sk", "c", "lex", "sb", "ld", "std", "ts", "ost", "ust", "nd", "sl", "stage", "ST", "sta", "ft", "ct", "sts", "dest", "start", "ast", "sth", "sc", "ste", "rt", "art"], "pos": ["val", "pt", "pc", "length", "Pos", "clock", "timeout", "Position", "cache", "axis", "po", "tag", "len", "position", "base", "obj", "POS", "address", "index", "addr", "diff", " position", "loc", "slot", "ref", "time", "patch", "pointer", "neg", "ptr", "prop", "count", "seq", "pose", "os", "pid", "start", "port", "opt", "open", "rot", "spec", "part", "comp", "pri", "size", "offset"], "timestamp": ["tunpoint", "timence", "gueline", "stimempt", "typestamp", "timpoint", "immempt", "timeeness", "guestamp", "dimet", "typet", "Timeline", "stimeline", "stimetime", "tunette", "Timetime", "dimette", "typpoint", "timetime", "dimestamp", "timet", "stimestamp", "immeline", "Timeness", "gueness", "Timestamp", "tunestamp", "timette", "timempt", "timeness", "typette", "Timempt", "Timence", "guence", "tunet", "immestamp", "timeeline", "immetime", "timeence", "timeline", "timeestamp", "dimpoint"], "flags": ["links", "frames", "lag", "tags", "tracks", "lines", "f", "ops", "leases", "times", "fts", "issues", "vals", "lf", "parts", "faces", "fee", "ints", "args", "locks", "types", "includes", "tails", "bits", "status", "FLAG", "strings", "items", "members", "files", "fixes", "atts", "Flags", "s", "comments", "flag", "properties", "fs", "stats", "bytes", "ags", "fps", "ants", "fields", "options", "features", "events", "mods", "mask", "offset"], "entries": ["encries", "questries", "antries", "endrys", "Entrys", "ntities", "antities", "entrants", "Entlements", "questrants", "endries", "outrance", "antrys", "entsries", "rentrance", "entlements", "ntrys", "encrys", "nties", "outrys", "questrance", "rentrys", "rentrants", " entrys", "encories", "outries", "Enties", "entsrys", "antrance", "eventries", "contles", "entles", "contities", "Entrants", "entsities", "entrance", "ntries", " entities", "ntles", "Entries", "outities", "endies", " entles", "rentries", "eventrys", "endlements", "entsories", "ntlements", "endrance", "eventories", "enties", "contries", "Entrance", "contrys", "questrys", "eventities", "entrys", "entities", "endities", "encities", "entories"], "ie": ["ine", "rie", "lie", "tie", "ite", "net", "ci", "je", "li", "oe", "el", "ji", "eni", "bi", "ge", "ip", "kie", "nie", "si", "ies", "zip", "entry", "zie", "ace", "ice", "eb", "ee", "ze", "ii", "ext", "IE", "ce", "lex", "ke", "sie", "ell", "sea", "ade", "ei", "edge", "le", "zi", "ne", "e", "fe", "pie", "se", "elt", "ide", "info"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    MpegEncContext *s = avctx->priv_data;\n\n    AVFrame *pict = data;\n\n    int i, ret;\n\n    int slice_count;\n\n    const uint8_t *slices_hdr = NULL;\n\n\n\n    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (!avctx->slice_count) {\n\n        slice_count = (*buf++) + 1;\n\n        buf_size--;\n\n\n\n        if (!slice_count || buf_size <= 8 * slice_count) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice count: %d.\\n\",\n\n                   slice_count);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        slices_hdr = buf + 4;\n\n        buf       += 8 * slice_count;\n\n        buf_size  -= 8 * slice_count;\n\n    } else\n\n        slice_count = avctx->slice_count;\n\n\n\n    for (i = 0; i < slice_count; i++) {\n\n        unsigned offset = get_slice_offset(avctx, slices_hdr, i);\n\n        int size, size2;\n\n\n\n        if (offset >= buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (i + 1 == slice_count)\n\n            size = buf_size - offset;\n\n        else\n\n            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;\n\n\n\n        if (i + 2 >= slice_count)\n\n            size2 = buf_size - offset;\n\n        else\n\n            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;\n\n\n\n        if (size <= 0 || size2 <= 0 ||\n\n            offset + FFMAX(size, size2) > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)\n\n            return ret;\n\n\n\n        if (ret > 8 * size)\n\n            i++;\n\n    }\n\n\n\n    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {\n\n        ff_er_frame_end(&s->er);\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->last_picture_ptr);\n\n        }\n\n\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *got_frame = 1;\n\n        }\n\n\n\n        // so we can detect if frame_end was not called (find some nicer solution...)\n\n        s->current_picture_ptr = NULL;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 18202, "substitutes": {"avctx": ["ajpkg", "avnp", "abcontext", "avcci", "ajnp", " avpkg", "afvoc", "avercli", "afctrl", "abpkg", "verpkg", "aucf", "AVloc", "ajcontext", "akcontext", "auconn", "evctx", "akctx", "aupkg", "avepkg", "avconn", "avcmp", "avalcci", "avectx", "avtx", "avecli", "avcontext", "afconn", "avctrl", "avalkw", "verctx", "AVctx", "avecontext", "avpkg", "abctrl", "AVcontext", "afcci", "AVcf", " avconn", "ajctrl", "aucontext", "afcontext", " avloc", "ajvoc", "Avcontext", "avalnp", "avvoc", "evcontext", "avalcontext", "abctx", "avercontext", "afpkg", "afnp", "avloc", "ajcci", "akcli", "aftx", "avctl", "afcf", "evcmp", "Avcmp", "avalctx", "Avctx", "afctl", "avkw", "avalcli", "airvoc", "avcli", "Avctl", "abcf", "afctx", "ajcli", "vertx", "aircci", "averkw", " avcontext", "auctx", "ajctx", "afkw", "averctx", "auctrl", "evctl", "avcf", "airctx", "vercontext", "akctrl", "aircontext", " avcf", "abconn", "aveconn", "afcmp", "afloc", "afcli", "autx"], "data": ["sample", "val", "client", "f", "result", "frame", "cache", "media", "DATA", "parent", "load", "window", "array", "pad", "api", "ad", "buffer", "d", "connection", "video", "base", "Data", "message", "memory", "address", "code", "padding", "input", "o", "reader", "next", "body", "p", "channel", "response", "da", "tmp", "au", "content", "value", "slice", "package", "image", "bytes", "dat", "start", "a", "empty", "buff"], "got_frame": ["bufvalwidth", "received_frame", "buf_frame", "buf_image", "buf_width", "received_frames", "bufvalimage", "bufvalframe", "bufvalframes", "received_image", "received_width", "buf_frames"], "avpkt": ["avcck", "avvpct", "abcpct", "avPacket", "abpct", "avcpfd", "evfacket", "evpacket", "avpct", "avfacket", "avffd", " avppKT", "avvpacket", " avppck", "avbpsth", "abpfd", " avpk", "avpsth", "avfct", " avppk", "avPkg", "abcpfd", "avpk", "avfkt", "avcpacket", "avck", "avvpfd", "avpKT", "abpacket", "avcKT", " avpKT", "avbpkt", "avpkg", "evpsth", "evpkt", "avcpct", "avvpkt", "avPsth", "evpkg", " avppkt", "avvpKT", " avpck", "avpfd", "avfsth", "evfkt", "abcpacket", "avbpkg", "avckt", "avpacket", "evfkg", "avppkt", "abpkt", "avppk", "avppck", "avvpk", "avppKT", "avcpkt", "avbpacket", "abcpkt", "avvpck", "evfsth", "avfkg", "avpck", "avPkt"], "buf": ["lim", "cp", "header", "vec", "shift", "src", "uf", "result", "proc", "uc", "cmd", "queue", "bc", "feat", "array", "cur", "window", "off", "buffer", "wb", "front", "pool", "conv", "len", "config", "av", "aux", "pb", "img", "pack", "block", "ctx", "cas", "cap", "uu", "loc", "rb", "cf", "xff", "bag", "cv", "pos", "ha", "func", "b", "pkg", "true", "home", "la", "alloc", "cb", "num", "rc", "seq", "cmp", "port", "wa", "box", "buff", "ctr", "fb", "br"], "s": ["g", "is", "cs", "server", "self", "sys", "session", "sa", "aws", "sp", "ps", "http", "ss", "d", "ns", "args", "storage", "gs", "conf", "c", "sync", "p", "service", "ssl", "sl", "services", "stats", "S", "ses", "sv", "utils", "os", "a", "sub", "sc", "se", "spec", "v", "j", "m"], "pict": ["wave", " fa", "feat", "arf", "in", "fo", "fm", " fr", "fw", "ff", "aw", "img", "fr", "w", "fl", " ff", "ref", "F", "cv", " w", "rf", "fa", "fs", " img", "image", "ft", "rn", " r", " f", "af"], "i": ["g", "is", "phi", "di", "inner", "my", "f", "xi", "hi", "name", "qi", "ix", "u", "x", "ci", "li", "in", "ji", "bi", "it", "uri", "eni", "api", "mi", "ip", "si", "pi", "I", "multi", "id", "uni", "offset", "h", "index", "code", "r", "chi", "ai", "iu", "init", "esi", "ii", "c", "p", "y", "ind", "z", "slice", "mini", "ui", "image", "ni", "zi", "gi", "ami", "fi", "e", "l", "io", "oi", "ie", "ini", "part", "field", "ti", "j", "info"], "ret": ["reply", "val", "RET", "bit", "result", "match", "alt", "res", "success", "reg", "back", "error", "red", "len", "fun", "mt", "fin", "status", "r", "img", "xt", "rets", "iter", "ext", "rb", "ref", "det", "nt", "def", "flag", "re", "value", "mini", "desc", "en", " Ret", "ft", "rc", "fi", "Ret", "bf", "mem", "bad", "arg", "lit", "rt", "mi", "info"], "slice_count": [" slice_limit", "slice67count", "slicexloop", "slice0size", "field54count", "sliceablesize", "slicexcount", "sliceablenumber", " slice_size", "byte67size", "slice4size", "byte_size", "slice0offset", "slice_loop", "sliceOstart", "slice_queue", " slice_label", "slice_type", "sliceNset", "slice4ref", " slice_length", "slice54count", "byte_div", "slice4count", "slice_sum", "sliceOlength", "field_size", "sliceNsize", "slice54size", "slice_size", "slice_limit", "slice67size", "sliceOstate", "slice0number", "slice67label", "byte67div", " slice_set", "slice_length", "slice54number", "field54number", " slice_group", " slice_ref", "sliceNcount", "field_number", " slice_sum", " slice_queue", "byte67count", "slice_set", " slice_state", "slice_start", "byte_count", "slice_label", "field_count", "field54offset", "field_offset", " slice_number", "slice0count", "slice_ref", " slice_loop", "slicexgroup", " slice_type", "slice67div", "slice_number", "field54size", "slice_group", " slice_start", "sliceablelimit", "sliceOcount", "slice_div", "slice_state", "slice54offset", "sliceablecount", "slice_offset"], "slices_hdr": ["slices_hier", "slices_archaddr", "slices_ctr", "slices_hpaddr", "slices_hhtr", "slices_Hr", "slices_shard", "slices_fhr", "slices_hhDR", "slices_hhr", "slices_harhr", "slices_frt", "slices_phict", "slices_hpdr", "slices_hrt", "slices_hardr", "slices_shDR", "slices_htr", "slices_adhdr", "slices_archider", "slices_HDR", "slices_Hier", "slices_cdr", "slices_card", "slices_adhstr", "slices_phdr", "slices_adhict", "slices_shtr", "slices_harrt", "slices_hddr", "slices_hict", "slices_hard", "slices_hdier", "slices_shdr", "slices_phstr", "slices_hpDR", "slices_haddr", "slices_archDR", "slices_hr", "slices_hpider", "slices_hhard", "slices_Haddr", "slices_cDR", "slices_hhdr", "slices_hider", "slices_fdr", "slices_hstr", "slices_Hdr", "slices_archdr", "slices_Hider", "slices_hDR"], "buf_size": ["buf16center", "buff_max", "bufssize", "buf00small", "buff64use", "bufckcontent", "buf64use", "buf67number", "uf_size", "buflexcount", "img_size", "buf_external", "buf00channel", "buflexexternal", "buflexuse", "buff_external", "buf_small", "buf_capacity", "bufckize", "buff64external", "buf67size", "buf_center", "queue_channel", "bufxsize", "buf64ize", "bufcksmall", "uf_center", "uf_ize", "buf00count", "cap67offset", "uf_count", "uf_capacity", "buf_send", "uc_line", "cap67number", "bufckscale", "buf64count", "buf_line", "buf64external", "img_scale", "buflexsize", "buf64set", "buf_number", "queue_size", "cap_offset", "buf67offset", "buf_use", "queue_small", "buf64line", "queue_count", "buff64size", "buf_offset", "img_send", "bufxset", "uc_ize", "buf16size", "bufckchannel", "buf00size", "img67send", "bufckcount", "img67size", "uf_content", "bufxline", "buff_count", "buf_ize", "buf67scale", "img_sync", "img67scale", "cap_size", "uf_sec", "buff_use", "buf16use", "uf_scale", "bufcksize", "buf67sync", "buf_sync", "cap67len", "bufxize", "buf67send", "buf64size", "buf67len", "img67sync", "buf_channel", "buf_len", "uc_set", "cap67size", "cap_number", "bufsmax", "buff_number", "buf_scale", "buf_sec", "buff64count", "buf_count", "buf_content", "bufsnumber", "buf_set", "buf_max", "cap_len", "uf_use", "buff_size", "buf16scale", "uc_size"], "size": ["core", "set", "scale", "any", "handle", "sized", "page", "video", "position", "speed", "code", "last", "ice", "content", "mini", "image", "weight", "send", "shape", "empty", "use", "mode", "timeout", "name", "fee", "Size", "si", "ize", "full", "value", "esc", "err", "ui", "age", "sync", "offset", "length", "large", "frame", "SIZE", "small", "capacity", "address", "sort", "cap", "body", "pos", "en", "area", "second", "iz", "shift", "new", "el", "member", "len", "storage", "sum", "loc", "time", "unit", "izes", "slice", "gz", "count", "e", "from"], "size2": ["name1", "address1", "length82", "address2", "ize3", "ize162", " size1", " size5", " size62", "speedTwo", "ize02", "scale1", "addressTwo", "ize4", "length2", "ize62", " size82", " size8", "size1", "ize8", "name2", "speed62", " size3", "size8", "length02", "size82", "scaleTwo", "scale82", "sizeTwo", "ize1", "size62", "scale3", "scale2", "size4", " size162", "scale162", "izeTwo", "size5", " size4", "ize2", "size162", "length1", "address4", "size02", "nameTwo", "size3", "speed2", " size02", " sizeTwo", "lengthTwo", "speed1", "name8", "length5", "ize5"]}}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,\n\n                           AVStream *st, RMStream *rst, int codec_data_size)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(st->codec, AV_LOG_ERROR, \"Unsupported video codec\\n\");\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n//        av_log(s, AV_LOG_DEBUG, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,\n\n                  0x10000, fps, (1 << 30) - 1);\n\n        st->avg_frame_rate = st->r_frame_rate;\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 18203, "substitutes": {"v": ["g", "val", "f", "uv", "lv", " V", "x", "u", "t", "q", "d", "conv", "n", "version", "i", "vi", "vid", "h", "r", "change", "va", "vp", "vs", "volt", "c", "p", "s", "cv", "vol", "b", "value", "ve", "vert", "ver", "nv", "vt", "vr", "ev", "e", "sv", "l", "vv", "V", "j", "m"], "size": ["g", "f", "sent", "reg", "n", "len", "SIZE", "small", "enc", "i", "max", "code", "loc", "fl", "s", "desc", "esc", "sel", "en", "rc", "sec", "e", "mi"], "codec_pos": ["codesc_loc", "codesc_size", "codec_type", "codesc_pos", "codec__len", "codesc_len", "codec__size", "codec_position", "codec__type", "codec_loc", "codec__pos", "codesc_position", "codec_len", "codesc_type", "codec_size"], "ret": ["RET", "val", "reply", "f", "result", "match", "ben", "alt", "res", "success", "reg", "back", "valid", "red", "fun", "len", "mt", "obj", "fail", "ut", "id", "pet", "fit", "status", "rev", "rets", "att", "ext", "ref", "det", "nt", "def", "flag", "re", "resp", "en", "rc", "sec", "Ret", "mem", "bad", "arg", "lit", "rt", "utf", "rep"], "fps": ["progress", "flags", "f", "frame", "gc", "res", "success", "fast", "buffer", "valid", "back", "test", "len", "fin", "status", "pass", "loop", "gen", "live", " res", "resp", "cb", "rc", "rep"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 18211, "substitutes": {"f": ["g", "fx", "df", "x", "lf", "d", "feed", "obj", "fd", "i", "fw", "ff", "h", "fr", "o", "tf", "conf", "c", "ref", "file", "p", "F", "inf", "fp", "rf", "b", "fa", "fs", "fat", "fi", "e", "l", "fe", "a", "m"], "pv": ["Pv", "fpv", "pV", "pf", "cpf", "Pb", "fpf", "pb", "PV", " pV", " pf", "fpV", "Pf", "cpv", "cpb", " pb"], "size": ["g", "val", "large", "x", "d", "Size", "len", "SIZE", "small", "ize", "h", "iv", "data", "fff", "w", "c", "k", " sizes", "fp", "z", "e", "shape", "l", "fe", "m"], "v": ["g", "val", "uv", "lv", "x", "u", "t", "q", "n", "conv", "i", "j", "vi", "iv", "vp", "data", "vs", "o", "volume", "k", "c", "p", "s", "inv", "b", "value", "ve", "vt", "vd", "e", "sv", "l", "vv", "V", "tv", "m"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n", "idx": 18220, "substitutes": {"json": ["ja", "server", "jack", "output", "result", "new", "global", "temp", "xml", "array", "js", "fruit", "parent", "api", "py", "feed", "obj", "java", "module", "config", "status", "build", "tree", "data", "pack", "raw", "journal", "aj", "xxx", "body", "object", "son", "response", "key", "javascript", "current", "value", "update", "twitter", "JSON", "j"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_record_dump(void)\n\n{\n\n    PCRecord **pr, *r;\n\n    int i, h;\n\n    FILE *f;\n\n    int64_t total, sum;\n\n\n\n    pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n\n    i = 0;\n\n    total = 0;\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {\n\n            pr[i++] = r;\n\n            total += r->count;\n\n        }\n\n    }\n\n    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n\n\n\n    f = fopen(\"/tmp/kqemu.stats\", \"w\");\n\n    if (!f) {\n\n        perror(\"/tmp/kqemu.stats\");\n\n        exit(1);\n\n    }\n\n    fprintf(f, \"total: %\" PRId64 \"\\n\", total);\n\n    sum = 0;\n\n    for(i = 0; i < nb_pc_records; i++) {\n\n        r = pr[i];\n\n        sum += r->count;\n\n        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",\n\n                r->pc,\n\n                r->count,\n\n                (double)r->count / (double)total * 100.0,\n\n                (double)sum / (double)total * 100.0);\n\n    }\n\n    fclose(f);\n\n    free(pr);\n\n\n\n    kqemu_record_flush();\n\n}\n", "idx": 18231, "substitutes": {"pr": ["dr", "val", "str", "rec", "rr", "pt", "pc", "pol", "ps", "rs", "po", "kr", "repl", "sr", "lr", "rel", "py", "wr", "tr", "col", "rep", "pair", "spr", "pl", "ra", "pa", "pp", "fr", "ar", "adr", "rev", "hr", "par", "PR", "pre", "gr", "ref", "p", "pos", "pe", "por", "cr", "per", "prop", "pull", "vr", "attr", "pred", "rc", "pro", "mp", "arr", "rt", "Pr", "j", "br"], "r": ["dr", "ru", "g", "str", "resource", "rec", "rr", "result", "range", "x", "u", "rs", "cur", "kr", "sr", "lr", "R", "d", "rel", "ir", "tr", "rh", "rar", "or", "wr", "ner", "ra", "ar", "fr", "usr", "adr", "br", "rev", "hr", "o", "entry", "w", "rb", "c", "rd", "k", "p", "var", "rl", "nr", "rf", "b", "mr", "cr", "er", "re", "rg", "err", "ur", "vr", "rc", "attr", "e", "row", "l", "master", "rt", "v", "m"], "i": ["is", "phi", "di", "inner", "ri", "hi", "xi", "name", "x", "u", "qi", "ix", "ci", "li", "eni", "bi", "d", "n", "ip", "ti", "I", "si", "pi", "ai", "index", "init", "iu", "o", "ii", "c", "p", "limit", "y", "ind", "b", "z", "ui", "ni", "gi", "count", "fi", "yi", "e", "l", "start", "a", "io", "oi", "ie", "ini", "v", "mi", "j", "info"], "h": ["dh", "hi", "x", "u", "ul", "oh", "sh", "t", "q", "bh", "eh", "kh", "uh", "d", "rh", "n", "H", "ch", "id", "th", "o", "hr", "w", "c", "k", "p", "ha", "y", "he", "b", "hash", "ih", "z", "hh", "hd", "e", "l", "ph", "hs", "ah", "hm", "ht", "v", "j", "m"], "f": ["g", "fx", "sf", "df", "x", "t", "form", "fo", "fm", "lf", "d", "feed", "fun", "fd", "fw", "ff", "fit", "fr", "fen", "full", "o", "tf", "w", "conf", "cf", "xf", "c", "file", "F", "fp", "p", "s", "func", "function", "b", "fa", "rf", "fore", "fs", "fi", "fn", "bf", "e", "buff", "l", "fe", "fc", "v", "af", "fb", "j", "m"], "total": ["local", "di", "scale", "net", "valid", "summary", "percent", "null", "dot", "tax", " max", "alpha", "pretty", "quant", "average", "temp", "fo", "no", "si", "toc", "parse", "max", "index", "full", "data", "nt", "current", "num", "non", "ph", "cu", "mon", "offset", "cat", "length", "tp", "gross", "ss", "error", "base", "diff", "ma", " final", "Total", "post", "fat", "ass", "mm", "info", "otal", "now", "result", "type", "complete", "parent", "li", "t", "mu", "ta", "pi", "tt", " totals", "doc", "meta", "stat", "all", "final", "cost", "count", "start", "part", "size"], "sum": ["scale", "min", "alpha", "session", "sa", "length", "sp", "cal", "average", "net", "cache", "li", "sh", "gross", "ss", "error", "fee", "no", "um", "info", "len", "si", "dev", "max", "index", "summary", "percent", "diff", "doc", "us", "stat", "miss", "all", "cost", "pos", "s", "vol", "mean", "up", "comment", "sal", "fat", "weight", "loss", "ass", "count", "num", "mem", "Sum", "start", "a", "mm", "sc", "se", "out", "size", "offset"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 18254, "substitutes": {"opaque": ["opatile", "ophole", "oppatile", " opace", " opesc", "OPaque", "oppacity", "iopesc", "iopacity", "operacity", "opace", "operatile", "OPhole", "OPacity", "oppaque", "Opacity", "opacity", "Opace", " opacity", "Opesc", "opphole", "opesc", "Opaque", "OPatile", "operaque", "operhole", "iopaque", "iopace"], "buf": ["header", "vec", "f", "uf", "proc", "cmd", "uc", "queue", "bc", "cache", "window", "buffer", "wb", "pool", "Buffer", "len", "fd", "enc", "config", "pb", "data", "cas", "byte", "ctx", "block", "cap", "loc", "rb", "cf", "fp", "bag", "cv", "tmp", "b", "home", "fb", "prop", "cb", "rc", "fi", "seq", "gb", "mem", "port", "text", "que", "box", "buff", "bl", "alloc", "br"], "size": ["g", "scale", "sent", "extra", "x", "cache", "sized", "page", "speed", "code", "c", "content", "needed", "weight", "send", "bytes", "sec", "shape", "fe", "empty", "use", "mode", "timeout", "name", "source", "fee", "Size", "si", "args", "ize", "max", "huge", "full", "data", "esc", "negative", "ui", "num", "sync", "offset", "security", "sn", "length", "large", "buffer", "SIZE", "small", "capacity", "eng", "address", "grow", "ng", "go", "complete", "six", "form", "len", "storage", "sum", "loc", "time", "unit", "count", "sc"], "s": ["g", "local", "self", "sites", "lines", "client", "session", "secondary", "js", "plugins", "types", "r", "comm", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "stats", "states", "sets", "a", "qs", "m", "server", "sf", "http", "times", "ions", "ns", "site", "si", "multi", "tests", "state", "es", "us", "sb", "services", "l", "sym", "hm", "its", "sync", "f", "rs", "south", "ss", "sq", "n", "small", "native", "o", "xs", "er", "S", "bis", "sg", "ses", "spec", "is", "sys", "ps", "t", "parts", "d", "submit", "private", "w", "side", "k", "details", "service", "request", "e", "os", "v", "ds", "an", "settings"], "buf1": ["buffern", "uf2", "bufn", "buffone", "ufn", "bufone", "buffer1", "buf0", " buf2", "buf2", "buffer0", "uf1", "buff2", "buff0", " bufone", "uf0", " bufn", "buffer2", "bufferone", " buf0", "buff1"], "remaining": ["resaining", "romoding", "romaining", " remend", "resoding", "remend", "remoding", "resend", " remoding", "romend"], "rmd": ["Rsha", "rrmb", "rrarm", " rMD", " rsha", "rcmb", "prld", " rld", "RMD", "rrcmd", "prcmd", "Rcmd", " rcmd", "rcMD", " prcmd", "rcmd", "prarm", "rccmd", "rrMD", " prmd", " prsha", "Rmd", "rrld", "rld", "rsha", "rMD", " prMD", "prmd", "rmb", "rarm", " rarm", " rmb", "rrmd"], "i": ["phi", "di", "ri", "xi", "qi", "ix", "x", "u", "ci", "li", "bi", "uri", "mu", "it", "mi", "n", "ip", "si", "pi", "I", "multi", "ai", "index", "iu", "o", "ii", "c", "ind", "z", "mini", "ui", "ni", "gi", "zi", "fi", "anti", "e", "io", "im", "ini", "ti", "j", "info"], "nrda": ["nrssae", "Nrdb", "nldia", " nrdae", "nldo", "nrlas", "nrsas", "nrsar", " nrsar", "Nldb", "nrdb", "Nrdia", " nrdb", "nldae", " nldae", "nrandia", "nranda", " nrdar", "nrssa", "nrusa", "nrandb", "nlda", "nldas", "nrdas", "Nlda", "nrsso", "nrlar", "nldb", "nrsa", " nrsas", "nrsb", "nrssas", "nrdo", " nrdo", "nrandas", "nrdar", "nrlb", "nrusas", "nruso", " nlda", "nrdia", "nddb", "ndda", " nldo", " nrsa", " nrsb", "Nldia", "nddas", "nrusae", "Nrda", "Nrdas", "nrdae", "Nldas", "nldar", "nrla", "nddia", " nldas", " nrdas"], "rcvrc": ["rcpRC", "rchrc", "rcpsc", "rcvprt", "rcfunrc", "rchrec", "rcpsrc", "rckra", "RCfrr", "rchRC", "RCvra", "rcfunru", "RCvsrc", "RCfrf", "rcfrt", "rcverrc", "rckrc", "rcfunRC", "rcvmRC", " rcversrc", "rcsvrc", "rcvrs", "RCfras", "rcVrc", " rcverRC", "RCfsrc", "RCfrc", "RCfra", "RCvgd", "rcVgd", "rcvvras", "rcsvrec", "rcvpRC", "rcfsrc", "rcnrr", "rcVrs", "rcfras", "rcprc", "rcvrec", "rcvvrs", "rcfrc", "rcvsrc", "rcvprc", "rcvpra", "RCfrs", " rcversc", "rcvras", "rcprr", "rcfru", "rcvvrf", "rcvgd", "RCvRC", "RCvras", "rcvrt", "rcfrr", "rcverRC", "RCvrs", "rcfrs", "rckrt", "rcfra", "RCfrec", "rcvrf", "RCvrec", "rcvmgd", "rcvru", "rcnrc", "RCvrf", "rcVsrc", "rcVRC", "rcfunrf", "RCfRC", "RCvrt", "rcvrr", "rcvra", "rcnRC", "rcfrec", "RCvrc", "rcfgd", "rcvvRC", "rcfRC", "rcversrc", "RCvru", "rckRC", "rcsvRC", "rcnsrc", "rcvvru", "rcvmsrc", "rcversc", "RCfrt", " rcvsrc", " rcvRC", "RCvrr", "rchrt", "rcsvrt", "rcvRC", "rcvsc", "rcfrf", "rcVras", " rcverrc", "RCfgd", " rcvsc", "rcvvrc", "rcvmrc", "RCfru", "rcfsc"], "CSR_RCVRC": ["CSR_RCFRT", "CSR_RCvRC", "CSR_RCVDRC", "CSR_RCPRC", "CSR_RRVRR", "CSR_RCVDRL", "CSR_RCVDRS", "CSR_RRVRT", "CSR_RRvRT", "CSR_RCVVR", "CSR_RCPRR", "CSR_RCVRS", "CSR_RRVRS", "CSR_RRvRC", "CSR_RRvRL", "CSR_RCvRL", "CSR_RRvRS", "CSR_RCVDVR", "CSR_RRvRR", "CSR_RCPRL", "CSR_RCFRL", "CSR_RCvVR", "CSR_RCFRR", "CSR_RCVRL", "CSR_RRVRL", "CSR_RCFRC", "CSR_RRVVR", "CSR_RCFRS", "CSR_RCvRS", "CSR_RCvRT", "CSR_RRVRC", "CSR_RRvVR", "CSR_RCVRT", "CSR_RCPRS", "CSR_RCFVR", "CSR_RCVRR", "CSR_RCvRR"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        /* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         */\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  */\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n", "idx": 18267, "substitutes": {"opaque": ["opque", "OPaque", "pc", "opaques", "opusac", "paque", "copaques", " opque", "pcel", "pque", "opcel", "OPac", "opuscel", "copaque", "OPaques", "copque", "opusaques", "opc", "copc", "OPcel", " opaques", "opusaque", "opac", " opc", "paques", "pac"], "s": ["is", "g", "cs", "self", "ops", "server", "ms", "sys", "session", "aws", "http", "f", "ps", "client", "uns", "u", "rs", "js", "south", "t", "ss", "sq", "d", "ns", "plugins", "n", "si", "args", "r", "ls", "o", "es", "w", "gs", "conf", "c", "p", "sb", "ks", "ts", "service", "ssl", "b", "sl", "comments", "xs", "su", "fs", "services", "socket", "S", "sg", "ses", "e", "os", "sets", "sym", "settings", "l", "a", "spec", "se", "ds", "qs", "its", "sync", "m"], "i": ["is", "phi", "di", "f", "ri", "xi", "name", "x", "qi", "ix", "u", "ci", "li", "type", "t", "bi", "it", "uri", "d", "ti", "si", "pi", "I", "id", "h", "r", "index", "ai", "iu", "esi", "ii", "iter", "c", "p", "y", "ind", "b", "ki", "z", "mini", "m", "ui", "ni", "gi", "fi", "yi", "e", "l", "a", "io", "oi", "ie", "ini", "v", "mi", "j", "info"], "ret": ["reply", "val", "RET", "bit", "f", "cat", "result", "match", "x", "alt", "in", "t", "success", "reg", "len", "fun", "mt", "id", "pet", "fin", "r", "code", "art", "pat", "rev", "rets", "iter", "att", "ext", "ref", "det", "nt", "b", "flag", "re", "err", "en", "ft", "rc", "fi", "Ret", "num", "mem", "l", "arg", "ie", "rot", "lit", "rt", "v", "mi", "j"]}}
{"project": "FFmpeg", "commit_id": "5e5f75cf8abd76ada3011790a9b4f0762a72e41a", "target": 0, "func": "static void ffm_write_data(AVFormatContext *s,\n\n                           const uint8_t *buf, int size,\n\n                           int64_t pts, int header)\n\n{\n\n    FFMContext *ffm = s->priv_data;\n\n    int len;\n\n\n\n    if (header && ffm->frame_offset == 0) {\n\n        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;\n\n        ffm->pts = pts;\n\n    }\n\n\n\n    /* write as many packets as needed */\n\n    while (size > 0) {\n\n        len = ffm->packet_end - ffm->packet_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(ffm->packet_ptr, buf, len);\n\n\n\n        ffm->packet_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        if (ffm->packet_ptr >= ffm->packet_end) {\n\n            /* special case : no pts in packet : we leave the current one */\n\n            if (ffm->pts == 0)\n\n                ffm->pts = pts;\n\n\n\n            flush_packet(s);\n\n        }\n\n    }\n\n}\n", "idx": 18268, "substitutes": {"s": ["g", "cs", "self", "server", "client", "f", "session", "sys", "http", "this", "ops", "secondary", "u", "rs", "instance", "ds", "js", "south", "t", "ss", "sq", "d", "ns", "n", "i", "storage", "submit", "h", "r", "span", "es", "ctx", "w", "gs", "conf", "c", "p", "sb", "ts", "service", "ssl", "b", "su", "services", "sg", "ses", "e", "sv", "request", "a", "sc", "v", "spec", "secure", "an", "sync", "m"], "buf": ["lim", "vec", "bd", "map", "f", "length", "src", "uf", "cmd", "uc", "queue", "bc", "off", "flow", "buffer", "Buffer", "wb", "bb", "base", "fd", "offset", "ff", "path", "data", "addr", "block", "cas", "ctx", "loc", "rb", "cf", "callback", "ref", "fp", "bag", "limit", "func", "b", "msg", "fb", "context", "cb", "count", "seq", "gb", "port", "buff", "alloc", "br"], "size": ["core", "scale", "cm", "length", "range", "name", "sized", "source", "el", "end", "page", "buffer", "fee", "Size", "n", "low", "position", "SIZE", "small", "ize", "offset", "capacity", "address", "code", "max", "speed", "data", "lc", "loc", "fl", "body", "time", "c", "limit", "line", "pos", "content", "en", "bytes", "count", "url", "shape", "l", "term", "e", "empty", "iz", "mode"], "pts": ["ntn", "PTns", "ptsets", "PTblocks", "pgs", "paths", "aptts", "ctn", "PTsets", "ctp", "ppabs", "ntd", "PTfs", "eptt", "ptts", "montsets", "oints", "pgts", "ctd", "periodt", "cols", "ptfs", "ntts", "eptp", "epts", "PTd", "ntsets", "montts", "colns", "ntabs", "ntp", "PTsm", "aptt", "reqs", "aptp", "eptgs", "PTs", "ptblocks", "monts", "cold", "pps", "cts", "pathns", " ptblocks", "ppgs", "ointsets", "periodts", "montabs", "apts", " ptfs", "ppts", "ptabs", "ppp", "ppsets", " ptsets", "ptt", "ointblocks", "reqn", "ptsm", "reqp", "pggs", "reqd", "pgp", "periodp", "colsm", "periods", "ptns", "pathd", "nts", "ointfs", "ptgs", "eptts", "ptn", "ptp", "pathsm", "ptd"], "header": ["dr", "server", "inner", "shift", "f", "number", "Header", "name", "headers", "parent", "buffer", "aster", "counter", "border", "n", "version", "table", "forward", "h", "code", "padding", "block", "writer", "cover", "body", "center", "head", "final", "channel", "line", "response", "holder", "er", "err", "handler", "tail", "outer", "master", "layer", "offset"], "ffm": ["fxim", "iffarm", "effbm", "uffM", "fxm", " ffmo", "ufbm", "iffmin", "efdm", "fxn", "buffcm", "uffcm", "effsm", "affmc", "lfmc", "ffd", "ppm", "offcm", "ufl", "ffmm", "lfcm", "ffl", "offm", "effg", "ffg", "iffcm", "ufmo", "fxmd", "buffl", "uffdm", "fxd", "uffom", "iffmu", "offg", "effm", "effarm", "effp", "ffdm", "ufmc", "ppn", "effmu", "effM", "effmin", "buffmm", "offl", "fxg", "ffM", "ffmodule", "offmc", "buffm", "efff", "uffarm", "effam", "ufcm", "buffdm", "uffd", "ffmc", "effmd", "lfm", "ffmin", "affl", "ffmu", "efm", "ufmodule", "effcm", "offom", "uffam", "iffsm", "ffn", "ffmd", "effmodule", "ffam", "efM", "uppmin", "uffmc", "iffm", "lfmo", "uffmodule", "uffsm", "ffarm", "effim", "ffim", "fxmm", "ffbm", "uffm", "buffam", "uppmu", "iffn", "offf", " ffcm", "effmm", "effn", "buffbm", "ppd", "uffn", "ppdm", "fxf", "buffmodule", "effdm", " ffmc", "ffmo", "efn", "effd", "uppm", "ffsm", "efd", "ffom", "iffim", "fxdm", "fff", "iffdm", "uffbm", "affm", "uffp", "ffcm", "uppcm", "affom", "bufff", "efp", "ufm", "ffp", "uffl", "uffmd", "fxcm"], "len": ["lim", "val", "vec", "coll", "f", "length", "lan", "sp", "ll", "Len", "lp", "li", "el", "lf", "n", "fun", "low", "base", "lon", "lu", "fin", "il", "data", "ls", "span", "hl", "dl", "rev", "late", "lc", "fl", "loc", "pre", "line", "pos", "limit", "ld", "led", "sl", "z", "le", "en", "la", "count", "url", "l", "ler", "lit", "lin", "ie", "ln", "elt"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n\n                struct vmsvga_cursor_definition_s *c)\n\n{\n\n    QEMUCursor *qc;\n\n    int i, pixels;\n\n\n\n    qc = cursor_alloc(c->width, c->height);\n\n    qc->hot_x = c->hot_x;\n\n    qc->hot_y = c->hot_y;\n\n    switch (c->bpp) {\n\n    case 1:\n\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,\n\n                        1, (void*)c->mask);\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n\n#endif\n\n        break;\n\n    case 32:\n\n        /* fill alpha channel from mask, set color to zero */\n\n        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,\n\n                        1, (void*)c->mask);\n\n        /* add in rgb values */\n\n        pixels = c->width * c->height;\n\n        for (i = 0; i < pixels; i++) {\n\n            qc->data[i] |= c->image[i] & 0xffffff;\n\n        }\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n\n#endif\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n\n                __FUNCTION__, c->bpp);\n\n        cursor_put(qc);\n\n        qc = cursor_builtin_left_ptr();\n\n    }\n\n\n\n    dpy_cursor_define(s->vga.ds, qc);\n\n    cursor_put(qc);\n\n}\n", "idx": 18272, "substitutes": {"s": ["g", "is", "cs", "sf", "f", "sys", "rs", "south", "t", "ss", "ns", "si", "storage", "r", "o", "params", "gs", "p", "ts", "service", "ssl", "sl", "su", "sim", "services", "S", "states", "sec", "sets", "ses", "e", "settings", "os", "spec", "v", "sync", "m"], "c": ["core", "cs", "cp", "cm", "dc", "coll", "f", "pc", "uc", "ac", "u", "nc", "cache", "ci", "cur", "x", "t", "conn", "bc", "d", "n", "or", "ch", "config", "enc", "cl", "h", "co", "con", "o", "ec", "lc", "w", "call", "ca", "conf", "oc", "ce", "k", "p", "cc", "ic", "cy", "vc", "b", "cr", "cus", "tc", "ct", "cf", "sec", "arc", "mc", "e", "l", "a", "cu", "C", "anc", "sc", "v", "m"], "qc": ["questcur", "qun", "calcur", "sqrc", "sqci", " qci", "sqc", "Qci", "questlc", "pubcp", " qn", "reql", " qcur", "sqcr", " qcr", "qub", "pubn", " qf", "quickc", "quc", "sql", "questc", "pubc", " qpc", "Qpc", "questct", " qct", "calcr", "qcur", "sqcur", " qcm", "sqct", " qdc", "reqc", "sqca", "qcr", "qucp", "reqpc", "qupc", "Qrc", "quci", "questpc", "qdc", "sqn", "sqpc", "qcp", "questca", "quxc", "qucs", "ql", "qrc", "sqp", "sqcu", "chf", " qcf", "commentcr", "sqf", "Qc", "commentcf", " qec", "qucur", "qucf", "pubec", "quca", "qcm", " qrc", "qca", "reqb", "chpc", "quct", "calc", "qcf", "qp", "qch", "Qxc", " qch", "qct", " qcp", "calf", " qp", "calpc", "qsc", "qec", "qcu", "qlc", "questsc", "qulc", "quickcf", "questcs", "sqlc", "commentcm", "commentc", "qucu", "chxc", "reqn", "qci", " qcu", "quickcr", " qxc", "quec", "reqp", "sqsc", "qcs", " qcs", "questcf", "qxc", "qn", "qurc", "quickcm", "qusc", "chc", "sqdc", " ql", "calct", "reqch", "reqf", "qb", "qf", "calcu", " qb", "sqxc", "reqxc", "Qdc", "quch", "qpc"], "i": ["phi", "di", "f", "ri", "xi", "x", "u", "ix", "qi", "ci", "li", "t", "abi", "eni", "bi", "ji", "uri", "mu", "d", "it", "n", "I", "pi", "si", "multi", "id", "uni", "ai", "index", "data", "o", "ii", "k", "p", "b", "z", "ui", "ni", "zi", "gi", "yi", "adi", "fi", "e", "l", "a", "oi", "ini", "v", "ti", "j", "m"], "pixels": [" pints", "uints", "spixels", "pints", "ports", "Powers", "pips", "ppixels", "spips", "pii", "cixels", "uixels", "uips", "spowers", "Pints", "Picks", "cowers", "powers", " pips", "Pips", "cicks", "ppips", " pii", "picks", "cips", "Pii", "Ports", " ports", "spicks", "Pixels", "ppii", "uorts"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,\n\n                                          ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    for(i=0; i<4; i++){\n\n        pixel v = pix[-1];\n\n        pix[0]= v += block[0];\n\n        pix[1]= v += block[1];\n\n        pix[2]= v += block[2];\n\n        pix[3]= v +  block[3];\n\n        pix+= stride;\n\n        block+= 4;\n\n    }\n\n}\n", "idx": 18279, "substitutes": {"_pix": ["_PIX", "_pox", "_Pinch", "_pinch", "_cpox", "_jpixels", " _pox", "_paox", "_paix", "_cpIX", "_cpixels", " _Pixels", " _Pinch", "_pIX", " _Pox", "_paixels", "_jpox", "_pixels", " _Pix", "_Pixels", " _pinch", "_Pix", "_jpix", " _pixels", "_paIX", "_jpinch", "_cpix", "_Pox"], "_block": ["_image", " _image", " _bin", "_group", " _batch", " _Block", "_batch", "_Block", "\u00a0Block", " _group", "\u00a0image", "\u00a0group", "_bin"], "stride": ["dride", "Strides", "Strine", "tride", "stide", "Stride", "trime", "slie", " strie", "drides", "Strie", "strider", "StrIDE", " strided", " strine", " strider", "strIDE", " strides", "drIDE", "stided", "trider", "strides", "strime", "stider", "Strider", "stime", "strine", "slider", "slide", "drided", "Strided", " strime", "sline", "trided", " strIDE", "strided", "strie"], "i": ["phi", "di", "f", "xi", "x", "u", "ix", "qi", "ci", "li", "t", "eni", "bi", "uri", "d", "info", "n", "ip", "I", "pi", "si", "multi", "id", "vi", "ai", "iu", "o", "ii", "c", "k", "p", "pos", "pixel", "y", "b", "ki", "z", "ui", "ni", "zi", "gi", "ami", "fi", "e", "l", "a", "io", "oi", "ie", "v", "j", "m"], "pix": ["bixels", " pish", "apius", "pox", "cpix", "Pix", "apixel", "cpox", "bil", " pip", "ptix", " pixel", "spixels", "bip", "pricon", "xix", "ipich", "spix", " pil", "ipix", "pris", "pip", " pox", "mpik", "cpik", "ptox", "mpius", "ptixels", "bix", "Pius", "pius", "ipis", "mpix", "ipixels", " picon", "mpox", "ptish", "pixels", "xixels", "apix", "ipx", "pixel", " pich", " pis", "cpius", " pius", "pil", " pixels", "Px", "pish", " px", "spixel", "prix", "xip", "Pich", "Pixel", "bius", "prixels", "Pixels", "pich", "px", "apox", "picon", "pis", "pik", "ipicon", " pik", "spius", "Pish", "bixel", "cpixel", "Pox", "xil"], "block": ["batch", "section", "container", "bl", "rock", "check", "map", "Block", "none", "length", "number", "type", "node", "cache", "work", "tick", "clean", "bc", "off", "page", "end", "error", "buffer", "point", "board", "um", "border", "ip", "position", "col", "config", "offset", "chain", "cl", "label", "panel", "padding", "full", "pack", "byte", "bar", "book", "ref", "object", "line", "pos", "unit", "comment", "group", "image", "lock", "cross", "wall", "num", "row", "disk", "device", "plus", "list", "box", "plugin", "bin", "sync", "info"]}}
{"project": "qemu", "commit_id": "6ca8d0fd51154c37b571ea74dd0b3e7a60ab847a", "target": 0, "func": "static void set_proc_name(const char *s)\n\n{\n\n#ifdef __linux__\n\n    char name[16];\n\n    if (!s)\n\n        return;\n\n    name[sizeof(name) - 1] = 0;\n\n    strncpy(name, s, sizeof(name));\n\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n\n       This simple way is enough for `top'. */\n\n    prctl(PR_SET_NAME, name);\n\n#endif    \t\n\n}\n", "idx": 18282, "substitutes": {"s": ["g", "is", "str", "sf", "f", "ops", "say", "u", "array", "in", "ss", "d", "ns", "n", "si", "args", "i", "small", "h", "r", "address", "data", "strings", "o", "c", "p", "sb", "b", "slice", "sign", "S", "bytes", "names", "sg", "e", "l", "sym", "a", "spec", "ds", "v", "sync", "m"], "name": ["val", "str", "class", "self", "sn", "NAME", "none", "f", "ame", "number", "type", "x", "prefix", "array", "new", "d", "no", "ns", "info", "n", "len", "root", "base", "args", "id", "word", "path", "address", "code", "data", "block", "o", "w", "call", "nam", "c", "object", "p", "key", "Name", "missing", "null", "value", "named", "image", "names", "num", "e", "start", "alias", "a", "part", "size", "m"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 18285, "substitutes": {"client": ["local", "core", "container", "server", "self", "cdn", "consumer", "project", "session", "cm", "pc", "http", "cli", "command", "contact", "ac", "cache", "parent", "clean", "queue", "bird", "conn", "api", "cur", "front", "connection", "child", "lib", "config", "id", "Client", "private", "code", "co", "con", "google", "win", "ace", "ctx", "friend", "cell", "call", "c", "ce", "connect", "close", "public", "ic", "current", "socket", "context", "admin", "custom", "remote", "cod", "method", "manager", "cn"], "request": ["question", "set", "self", "server", "received", "resource", "get", "session", "route", "worker", "command", "report", "work", "complete", "type", "queue", "parent", "Request", "instance", "q", "proxy", "frame", "xml", "req", "buffer", "connection", "error", "quest", "child", "base", "message", "job", "view", "record", "config", "pair", "method", "id", "user", "hello", "input", "QUEST", "friend", "call", "read", "head", "object", "post", "requ", "response", "patch", "create", "apply", "enter", "re", "event", "er", "transfer", "send", "delete", "issue", "query", "open", "reference", "order", "push", "use"], "reply": ["hide", "server", "rr", "sys", "ry", "route", "http", "match", "report", "prefix", "link", "proxy", "repl", "error", "force", "Reply", "buffer", "back", "child", "base", "record", "root", "reset", "parse", "address", "r", "replace", "entry", "respond", " replied", "ping", "write", "call", "read", "notice", "answer", "post", "flash", "response", "bot", "ignore", "related", "be", "apply", "resp", "comment", " replies", "err", "transfer", "send", "delete", " response", "query", "list", "bill", "order", "part", "sync", "info"], "ret": ["RET", "val", "bit", "ary", "cat", "ry", "result", "alt", "et", "res", "success", "conn", "reg", "buffer", "valid", "back", "sr", "py", "len", "fun", "mt", "job", "id", "pet", "r", "code", "data", "pat", "ig", "rev", "rets", "all", "att", "rb", "ref", "det", "nt", "al", "response", "rf", "resp", "flag", "re", "err", "en", "ft", "rc", "count", "Ret", "num", "mem", "arr", "arg", "lit", "order", "rt", "part", "art", "ver"]}}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n\n                                      CL_TRUE,CL_MAP_READ, 0, buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(dst_buf, mapped, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18304, "substitutes": {"dst_buf": ["dst_buffer", "drc_queue", "dst_queue", "drc_buffer", "dsrc_buff", "dsrc_buffer", "dsrc_queue", "drc_buf", "dst_buff", "dsrc_buf", "drc_buff"], "src_cl_buf": ["src_clmbuffer", "src_clpbuffer", "src_cl_buff", "src_clpbuf", "src_pl_uf", "src_pl_queue", "src_cl_cb", "src_pl_buff", "src_pl_buffer", "src_clpcb", "src_clpuf", "src_cl_uf", "src_clmuf", "src_cl_buffer", "src_clpbuff", "src_cl_queue", "src_clmbuff", "src_clmbuf", "src_pl_buf", "src_pl_cb"], "buf_size": [" buf2capacity", "buflensize", "buf_send", "buf_len", " buf_capacity", " buf_num", "buf_num", "buf2capacity", "buflensend", "buflenSize", "buf2len", "buflenlen", " buf_send", "buf_capacity", "buf2size", "buf_Size", " buf_len", " buf2len", " buf_Size", " buf2size"], "status": ["skip", "progress", "session", "sp", "xml", "js", "sw", "sr", "magic", "java", "speed", "code", "summary", "login", "ssl", "sl", "update", "comment", "stats", "image", "gly", "STAT", "server", "cli", "name", "temp", "source", "gc", "si", "args", "state", "index", "full", "sb", "s", "score", "response", "current", "wait", "wrapper", "err", "msg", " success", "num", "url", "date", "sync", "security", "json", "example", " stat", "ss", "error", "id", "pre", "reason", "stage", "step", "size", "spec", "received", "html", "sex", "result", "complete", "type", " Status", "success", "stat", "ity", "service", "process", "uses", "expr", "start", "Status", "settings"], "mapped": [" mapping", "mmached", "Mamped", "smapping", "cmapped", " mached", "maked", "mmaped", "mmamped", "smached", "moved", " maped", "Moved", "mapping", "maped", "Mapping", "mamped", "smaped", "smapped", "Maked", "Mapped", "smaked", " maked", "cmamped", "mached", " moved", "Maped", "cmaped", "smoved", "Mached", "mmapped", "cmached"]}}
{"project": "FFmpeg", "commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "target": 1, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id > sc->stsd_count)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 18311, "substitutes": {"c": ["cs", "cp", "cm", "dc", "coll", "f", "pc", "uc", "bc", "nc", "ac", "cache", "ci", "u", "cur", "t", "n", "ch", "enc", "cl", "co", "con", "ctx", "ec", "lc", "w", "conf", "cf", "ca", "ce", "k", "p", "cc", "cv", "cy", "vc", "ic", "cus", "tc", "ct", "rc", "arc", "mc", "l", "ctrl", "C", "cu", "xc", "fc", "icc", "m"], "pb": ["cp", "PB", "pc", "src", "tp", "jp", "pd", "uc", "bc", "ppa", "xb", "lp", "bh", "wb", "py", "bb", "bp", "pm", "hub", "rob", "bm", "config", "cpp", "pg", "db", "pl", "platform", "pa", "pp", "summary", "bps", "eb", "ctx", "lc", "typ", "rb", "bot", "sb", "p", "fp", "cv", "b", "prot", "pkg", "tc", "cb", "rc", "ab", "gb", "bf", "dp", "pro", "ub", "mp", "lab", "fab", "kb", "lb", "fc", "fb"], "atom": [" acc", "cm", " app", " Atom", "com", "bc", " em", " cm", " am", " arr", " com", " ac", " mom", "orb", " parent", "abc", " program", " slab", "am", " ap", " subp", " atoms", " form", " ab", " ax", "mom", " plat", " om"], "st": ["sn", "sa", "pc", "sp", "src", "inst", "uc", "bc", "cur", "t", "ss", "sw", "St", "ch", "sd", "osc", "SC", "cl", "r", "lc", "nt", "sb", "s", "p", "std", "sci", "cv", "sl", "cr", "se", "ST", "sta", "ft", "ct", "sec", "sts", "sth", "Sc", "ste", "fc", "sync"], "sc": ["core", "dc", "client", "sp", "match", "sw", "scope", "exec", "cl", "ga", "cf", "cr", "sec", "gb", "ctrl", "sub", "cm", "cli", "nc", "contract", "asc", "SC", "sb", "desc", "esc", "acc", "fc", "sync", "src", "pc", "uc", "bc", "ss", "sq", "hub", "config", "ctx", "lc", "cc", "sci", "cus", "ct", "rc", "Sc", "spec", "icc", "go", "sche", "cs", "cer", "inc", "cur", "capt", "ch", "enc", "ced", "osc", "pg", "isc", "co", "ec", "loc", "ca", "cont", "cv", "usc", "tc", "soc", "mc", "anc"], "i": ["g", "phi", "di", "ri", "xi", "hi", "x", "qi", "idi", "ix", "ci", "eni", "api", "I", "h", "r", "limit", "b", "z", "mini", "gi", "oi", "ini", "field", "mi", "m", "cli", "u", "in", "uri", "it", "si", "multi", "ai", "index", "data", "iu", "esi", "p", "s", "y", "ui", "fi", "yi", "anti", "l", "ti", "j", "f", "length", "abi", "ji", "n", "ip", "id", "init", "iv", "entry", "ii", "ni", "zi", "info", "ski", "type", "li", "t", "bi", "mu", "d", "pi", "ij", "slice", "count", "e", "start", "ie", "v"], "entries": ["rentresses", " entants", "ENTants", "ENTrs", "Entrys", "integries", "gentries", "entrants", "entrs", "integlements", "Entlements", "entures", "gentresses", "entlements", "Entrs", "gentry", "ntures", "entues", "ntrys", "gentues", "nties", "entresses", "ENTrants", "centrys", "integry", "rentrys", " entrys", "infrants", "infants", "ntresses", "centures", "gentrants", "Enties", "entry", "estry", "ntues", "Entrants", "estresses", "centries", "ENTrys", "ntries", "infrys", "Entries", " entlements", "entants", "rentries", "ENTresses", "ntry", "ntrs", "centues", "centrs", "enties", "ENTry", " entrants", "gentures", "centrants", " entrs", "ntrants", "centry", "integrs", "gentrys", "entrys", "integrys", "estrants", "rentrs", "centies", "estries", "infries", "integrants", "ENTries"]}}
{"project": "FFmpeg", "commit_id": "8c013a9e55d9065793ef7ca6459d1178927a2b35", "target": 0, "func": "static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,\n\n                        uint32_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    char key[5]     = { 0 };\n\n    char *value;\n\n\n\n    size += (size & 1);\n\n\n\n    if (size == UINT_MAX)\n\n        return AVERROR(EINVAL);\n\n    value = av_malloc(size + 1);\n\n    if (!value)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, value, size);\n\n    value[size] = 0;\n\n\n\n    AV_WL32(key, tag);\n\n\n\n    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,\n\n                       AV_DICT_DONT_STRDUP_VAL);\n\n}\n", "idx": 18323, "substitutes": {"s": ["is", "cs", "self", "sf", "f", "sys", "sa", "src", "ps", "rs", "t", "ss", "sq", "d", "ns", "si", "i", "storage", "ls", "sam", "es", "ctx", "space", "w", "gs", "c", "p", "sb", "sci", "service", "ssl", "b", "xs", "sl", "su", "services", "stats", "S", "e", "cmp", "sv", "os", "ses", "start", "a", "spec", "sc", "se", "ds", "v"], "st": ["str", "client", "sa", "src", "stab", "inst", "rest", "td", "t", "ss", "d", "St", "stack", "obj", "sd", "est", "storage", "code", "r", "sam", "stream", "c", "rd", "stim", "sb", "std", "ts", "ost", "store", "tmp", "sl", "stage", "cr", "se", "ST", "sta", "ptr", "step", "ct", "sts", "start", "ast", "sth", "sc", "ste", "ds"], "tag": ["scale", "TAG", "tags", "token", "length", "mode", "number", "match", "name", "type", "tick", "prefix", "parent", "scope", "root", "id", "word", "max", "code", "year", "block", "byte", "ig", "loc", "format", "pos", "unit", "use", "Tag", "count", "row", "bug", "date", "tail"], "size": ["g", "set", "scale", "length", "timeout", "number", "style", "name", "type", "sized", "cache", "false", "six", "fee", "Size", "n", "len", "position", "SIZE", "small", "si", "i", "ize", "capacity", "speed", "address", "code", "max", "sum", "loc", "time", "c", "score", "unit", "content", "weight", "bytes", "count", "zero", "shape", "empty", "offset"], "pb": ["cp", "PB", "bs", "pc", "uf", "jp", "pd", "ppa", "bc", "lp", "bh", "api", "py", "fm", "mi", "wb", "bp", "pm", "hub", "metadata", "rob", "bm", "obj", "cpp", "pg", "db", "platform", "pl", "pa", "summary", "vp", "parser", "eb", "ctx", "meta", "typ", "rb", "sb", "fp", "p", "cv", "b", "prot", "cb", "attr", "ab", "dp", "mp", "lb", "fc", "fb"], "key": ["val", "str", "section", "rule", "length", "match", "name", "ac", " error", "op", "type", "KEY", "prefix", "ro", "link", "date", "error", "fee", "root", "or", "message", "keys", "version", "property", "id", "pair", "word", "index", "code", "entry", "Key", "block", "data", "ee", "mac", "loc", "time", "k", "esc", "sign", "prop", "count", "row", "start", "text", "ie", "field"], "value": ["wave", "val", "section", "VALUE", "scale", "json", "output", "length", "number", "result", "large", "range", "name", "type", "complete", "values", "media", "parent", "buf", "array", "flow", "end", "error", "buffer", "valid", "fee", "member", "message", "version", "memory", "vi", "word", "one", "address", "index", "max", "data", "entry", "byte", "block", "w", "total", "format", "object", "p", "response", "unit", "content", "function", "null", "create", "current", "image", "element", "text", "Value", "v"]}}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)\n\n{\n\n    int i, j;\n\n    for (i = 0; i < 5; i++) {\n\n        for (j = 0; j < 38; j++) {\n\n            in[i][j+6][0] = L[0][j][i];\n\n            in[i][j+6][1] = L[1][j][i];\n\n        }\n\n    }\n\n    if (is34) {\n\n        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);\n\n        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);\n\n        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);\n\n        for (i = 0; i < 59; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+32][j][0] = L[0][j][i+5];\n\n                out[i+32][j][1] = L[1][j][i+5];\n\n            }\n\n        }\n\n    } else {\n\n        hybrid6_cx(in[0], out, f20_0_8, len);\n\n        hybrid2_re(in[1], out+6, g1_Q2, len, 1);\n\n        hybrid2_re(in[2], out+8, g1_Q2, len, 0);\n\n        for (i = 0; i < 61; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+10][j][0] = L[0][j][i+3];\n\n                out[i+10][j][1] = L[1][j][i+3];\n\n            }\n\n        }\n\n    }\n\n    //update in_buf\n\n    for (i = 0; i < 5; i++) {\n\n        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));\n\n    }\n\n}\n", "idx": 18324, "substitutes": {"out": ["g", "val", "not", "min", "inner", "x", "net", "cache", "off", "h", "r", "code", "block", "call", "gen", "c", "line", "b", "flag", "up", "update", "image", "dot", "outs", "outer", "order", "ex", "Out", "use", "bit", "copy", "name", "work", "op", "flat", "req", "no", "lib", "user", "index", "data", "p", "y", "store", "at", "err", "loss", "ne", "lock", "io", "plus", "lin", "list", "bin", "f", "route", "IN", "error", "n", "version", "id", "again", "init", "input", "win", "o", "pass", "trial", "channel", "In", "en", "ret", "our", "after", "gin", "output", "inc", "new", "t", "conn", "d", "OUT", "sum", "align", "all", "ext", "part", "v", "size"], "in": ["bit", "val", "min", "scan", "kin", "inner", "gin", "f", "nin", "inc", "x", "IN", "new", "ac", "isin", "t", "conn", "el", "it", "old", "d", "n", "lib", "id", "config", "again", "on", "init", "r", "index", "input", "data", "win", "con", "diff", "pass", "call", "all", "gen", "c", "line", "ic", "In", "login", "b", "rin", "up", "at", "err", "thin", "image", "pin", "as", "pull", "l", "din", "a", "ins", "plus", "lin", "inn", "ini", "v", "bin", "vin", "use"], "L": ["LP", "LA", "D", "B", "M", "LR", "ln", "LI", "Q", "IN", "el", "Lin", "LE", "R", "n", "H", "I", "DL", "FL", "X", "O", "LT", "LU", "E", " l", "VL", "EL", "N", "Long", "U", "LIN", "T", "P", "F", "LL", "SL", "G", "IL", "Layer", "LG", "Lu", "S", "A", "LM", "LB", "dL", "UL", "l", "List", "J", "NL", "C", "list", "CL", "W", "V", "XL", "v", "BL"], "is34": ["isa33", "isi33", "p33", "is35", " is67", "IS33", "isa345", "isi34", "Is345", "isi345", "p34", "p67", "IS35", "is67", " is33", "IS67", "Is33", "is33", " is35", "isa34", "is345", "p35", "IS34", "Is34"], "len": ["lim", "val", "min", "split", "net", "end", "lf", "syn", "fun", "low", "fen", "block", "gen", "line", "limit", "z", "lit", "layer", "Len", "den", "lib", "lu", "data", "rev", "lang", "dy", "fl", "err", "lif", "light", "lock", "num", "l", "norm", "lin", "bin", "ln", "f", "length", "zen", "n", "base", "win", "dl", "lc", "pre", "pos", "dist", "le", "en", "la", "str", "ll", "LI", "li", "dim", "el", "lon", "fin", "all", "ld", "seq", "size"], "i": ["phi", "di", "my", "ri", "xi", "hi", "x", "qi", "ix", "ci", "eni", "api", "I", "c", "b", "z", "mini", "gi", "a", "oi", "ini", "mi", "m", "cli", "name", "u", "source", "it", "uri", "site", "si", "ai", "index", "ik", "iu", "p", "key", "y", "ki", "ui", "fi", "yi", "l", "io", "\u0438", "ti", "f", "isin", "ji", "n", "ip", "id", "vi", "o", "ii", "ind", "ni", "zi", "info", "is", "li", "bi", "mu", "d", "pi", "chi", "k", "slice", "ami", "e", "ori", "im", "ie", "v"], "j": ["ja", "g", "jp", "xi", "qi", "x", "ix", "ci", "js", "oj", "java", "h", "aj", "adj", "b", "z", "J", "a", "br", "m", "pt", "u", "op", "je", "it", "job", "si", "ik", "fr", "p", "key", "uj", "y", "ui", "l", "io", "jj", "jet", "f", "q", "ji", "n", "dj", "o", "jen", "ii", "ju", "note", "ni", "jo", "li", "t", "el", "bi", "d", "jl", "obj", "ij", "ch", "k", "jc", "bj", "e", "ie", "v", "pr"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 18326, "substitutes": {"f": ["fx", "sf", "df", "aff", "t", "lf", "fm", "feed", "fo", "d", "n", "fd", "i", "fw", "ff", "h", "fr", "ef", "o", "tf", "w", "ref", "c", "file", "p", "inf", "fp", "F", "rf", "fs", "bf", "e", "l", "fe", "v", "fb", "j", "m"], "limit": ["lim", "skip", "timeout", "limits", "route", "length", "match", "type", "cache", "source", "lp", "policy", "page", "include", "buffer", "len", "base", "ip", "position", "i", "id", "limited", "path", "index", "target", "iter", "format", "file", "inf", "unit", "filter", "Limit", "image", "lock", "url", "l", "io", "size", "pin", "rate", "offset"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 18329, "substitutes": {"v": ["g", "self", "f", "uv", "ov", "vim", "x", "u", "t", "q", "vin", "d", "i", "vi", "r", "iv", "vp", "o", "volt", "w", "vis", "k", "c", "p", "vol", "b", "value", "vert", "vm", "e", "l", "sv", "vv", "V", "j", "m"], "name": ["val", "self", "str", "resource", "NAME", "none", "f", "ame", "option", "type", "x", "prefix", "parent", "new", "error", "d", "no", "n", "i", "id", "word", "on", "path", "data", "o", "call", "ext", "time", "object", "key", "Name", "b", "null", "comment", "named", "names", "e", "unknown", "anc", "a", "nm", "part", "size"], "obj": ["val", "bo", "output", "ops", "type", "nc", "op", "prefix", "parent", "po", "js", "otype", "oa", "old", "args", "j", "lib", "ocl", "path", "ob", "init", "act", "o", "ctx", "ref", "orb", "object", "pos", "tmp", "func", "Object", "objects", "cb", "expr", "os", "opt", "arr", "bool", "clone", "Obj", "art", "amp"], "errp": ["gerlp", "errpc", "errpi", "drpi", "drP", "errP", " errr", "nerlp", "drp", "erP", "erb", "rrP", "rrpc", "errpr", "nerpr", "erpc", "errb", "erpi", " errpr", "gerr", "rrr", "drr", " errlp", "erp", "gerp", "nerr", " errb", "rrpi", "rrp", "err", " errpc", "gerpr", "nerp", "errr", "errlp", "rrb"], "qiv": ["qsvoc", "questiv", "qvoc", "qoid", "questive", "quoid", "qive", "qsive", "qou", "Qiv", "questvoc", "Qerv", "Qvoc", "qerv", "quive", " qou", "querv", "qsiv", "quou", " qerv", " qvoc", "quvoc", "questoid", "qsoid", "Qou", "quiv"], "qobj": ["sqobb", "qobject", "quobj", "reqbo", "sqbb", "pobb", "Qbo", " qbuff", "qorb", "qlib", "qubb", "Qobj", "quobject", "reqorb", " qorb", "qutmp", "qbb", "pobj", "pobject", "qobb", "qulib", "qtmp", "qbo", "reqobj", "pbb", "ptmp", "reqbuff", "sqobject", "sqlib", " qbo", "Qorb", "sqtmp", "Qbuff", "sqobj", "qbuff", "plib", "quobb"], "qbool": ["quurl", "qobject", "qubo", "qbis", "questbis", "questbool", "questbin", "qubf", "qubin", "dqvoid", "questbf", "qbit", "qbo", "dqval", "qaobject", "dqobject", " qbis", "squrl", "chvoid", "sqbo", "chbo", "questbo", "sqobject", "sqbin", "qubool", "qabool", " qbo", " qbit", "qval", "qvoid", "qavoid", "qurl", "qubis", " qbf", "dqbool", "qboot", "chbit", "sqbit", "sqvoid", "quboot", "sqval", "qbf", " qvoid", "qaval", "chbool", "questurl", "questboot", "sqboot", "qbin", "sqbool"]}}
{"project": "qemu", "commit_id": "860643bc5aa902f9b736c57b66e301ef08a2b68e", "target": 0, "func": "int kvm_arch_get_registers(CPUState *cs)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_one_reg reg;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    int i, r;\n\n\n\n    /* get the PSW */\n\n    env->psw.addr = cs->kvm_run->psw_addr;\n\n    env->psw.mask = cs->kvm_run->psw_mask;\n\n\n\n    /* the GPRS */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->regs[i] = cs->kvm_run->s.regs.gprs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->regs[i] = regs.gprs[i];\n\n        }\n\n    }\n\n\n\n    /* The ACRS and CRS */\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];\n\n            env->cregs[i] = cs->kvm_run->s.regs.crs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = sregs.acrs[i];\n\n            env->cregs[i] = sregs.crs[i];\n\n        }\n\n    }\n\n\n\n    /* The prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        env->psa = cs->kvm_run->s.regs.prefix;\n\n    }\n\n\n\n    /* One Regs */\n\n    reg.id = KVM_REG_S390_CPU_TIMER;\n\n    reg.addr = (__u64)&(env->cputm);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_CLOCK_COMP;\n\n    reg.addr = (__u64)&(env->ckc);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_TODPR;\n\n    reg.addr = (__u64)&(env->todpr);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    if (cap_async_pf) {\n\n        reg.id = KVM_REG_S390_PFTOKEN;\n\n        reg.addr = (__u64)&(env->pfault_token);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFCOMPARE;\n\n        reg.addr = (__u64)&(env->pfault_compare);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFSELECT;\n\n        reg.addr = (__u64)&(env->pfault_select);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18344, "substitutes": {"cs": ["core", "css", "nas", "ics", "CS", "sys", "ms", "bs", "pc", "ck", "bc", "nc", "cache", "ci", "js", "cells", "conn", "ns", "cms", "args", "cons", "ced", "cers", "ums", "co", "TS", "vs", "ls", "cas", "cks", "ctx", "Cs", "ec", "lc", "ace", "cing", "gs", "sk", "cf", "c", "acs", "ce", "ca", "s", "cc", "ks", "vc", "ts", "acts", "ches", "cus", "fs", "tc", "ces", "rc", "wcs", "cb", "mc", "acks", "ins", "spec", "sc", "cases", "ds", "qs", "ras", "sync", "cn"], "cpu": ["core", "cp", "cm", "pc", "cal", "clock", "CPU", "cli", "uc", "node", "bc", "nc", "proc", "cache", "net", "gc", "linux", "conn", "eni", "np", "hw", "pu", "ocr", "ace", "ctx", "uci", "lc", "processor", "c", "cv", "cus", "cow", "vm", "kernel", "cmp", "nic", "gpu", "sync", "cn"], "env": ["core", "chal", "inet", "eu", "session", "proc", "extra", "cache", "net", "global", "et", "eni", "org", "scope", "end", "exec", "exe", "dict", "equ", "engine", "conf", "cf", "c", "loader", "ssl", "cfg", "eve", "context", "utils", "oa", "server", "cdn", "armor", "cli", "export", "den", "enable", "np", "Environment", "site", "args", "iss", "esi", "ea", "eval", "assets", "err", "ne", "age", "environment", "manager", "console", "cal", "erv", "style", "stack", "config", "db", "eng", " environment", "cot", "stage", "energy", "en", "ass", "viron", "ev", "ani", "shell", "header", "output", "skin", "vel", "conn", "el", "enc", "osc", "estate", "ec", "exc", "ext", "cv", "her", "gui", "e", "que", "v"], "reg": ["g", "core", "rec", "pc", "proc", "name", "mod", "conn", "param", "org", "or", "ig", "block", "stat", "gr", "all", "Reg", "arch", "num", "sec", "mem", "eg", "spec", "REG"], "sregs": ["dsreco", "dsrecs", "sregd", "sstatns", "srecd", "pstates", "nsconnns", "nsregi", "srolh", "srealobs", "csregh", "dsregd", "pstats", "sregcs", "pregs", "sstats", "srecg", "pregns", "srecves", "srecs", "sregi", "sreces", "sorgo", "srealcs", "csregcs", "dsrecl", "sorgl", "srealh", "dsrego", "sstates", "sgregh", "sregl", "sregns", "nsregns", "sbads", "sconnns", "srolcs", "sregg", "spredl", "sreco", "sreci", "nsconns", "sstatg", "srego", "sconnves", "sconni", "nsregs", "srecns", "nsregves", "sreges", "sorgs", "sregobs", "pstatg", "sorgd", "csregobs", "dsregl", "sregh", "pstatns", "dsrecd", "csrealobs", "srecl", "sgregobs", "preges", "sregves", "csreals", "sgregs", "csrealh", "srols", "srolobs", "spreds", "sbadns", "sargs", "pregg", "spredd", "sarges", "nsconnves", "csregs", "nsconni", "sreals", "spredo", "sconns", "sargg", "csrealcs", "dsregs", "sargns", "sbadves", "sbadi", "sgregcs"], "regs": ["rega", "rolcs", "gregns", "regf", "memis", "regports", "loggs", "grege", " regns", " regb", "secp", "greggs", "REGs", "statgs", "gregions", " regions", "threadcs", "stats", "recb", "secf", "colgs", "cols", "gregs", "signns", "grego", "binds", "gregb", "rege", "secs", "regp", "privp", "recp", "privgs", "logcs", "priva", "funns", "logns", " regsym", "privs", "REGb", "colports", "regis", "gregcs", "rols", "gregwords", "memsym", "rolgs", "recions", "threadports", "regb", "funcs", "privsym", "fungs", "REGo", "threads", "signs", "bindf", "gregports", " rege", "recs", "statwords", "privis", " regp", "gregp", "gregf", "REGp", "colcs", "logs", "memp", "signe", "reco", "funs", "threadgs", "regsym", "regions", "privwords", "gregis", "signis", " regis", "regcs", "grega", "bindp", "mems", "regwords", "regns", "rolns", "reggs", "rego", "stata"], "i": ["phi", "di", "my", "ri", "xi", "hi", "x", "qi", "ix", "ci", "eni", "api", "I", "c", "b", "gi", "adi", "a", "oi", "ini", "field", "mi", "m", "cli", "name", "u", "source", "uri", "it", "site", "si", "multi", "ai", "index", "iu", "data", "esi", "p", "s", "key", "y", "current", "ui", "fi", "yi", "anti", "l", "io", "isi", "ti", "j", "uli", "f", "isin", "abi", "ji", "n", "ip", "module", "id", "vi", "init", "o", "lc", "ii", "ni", "zi", "info", "resource", "li", "t", "bi", "mu", "d", "pi", "k", "slice", "ei", "e", "ori", "device", "ie", "v"], "r": ["g", "dr", "ru", "str", "rr", "f", "result", "range", "u", "rs", "t", "q", "sr", "lr", "R", "d", "rh", "ir", "n", "or", "error", "rar", "j", "ner", "h", "ar", "fr", "rt", "br", "o", "hr", "w", "rb", "all", "c", "rd", "p", "var", "rl", "mr", "rf", "b", "nr", "cr", "re", "rg", "er", "z", "err", "ur", "reb", "rc", "e", "rn", "l", "a", "arr", "rw", "pr", "ver", "m"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 18345, "substitutes": {"p": ["g", "cp", "f", "ap", "pc", "sp", "ps", "tp", "jp", "wp", "type", "name", "u", "lp", "t", "q", "param", "d", "point", "np", "n", "ip", "bp", "i", "pair", "path", "h", "pa", "r", "pp", "vp", "parser", "data", "pb", "o", "ar", "par", "pre", "c", "P", "s", "fp", "pe", "b", "e", "l", "python", "v", "m"], "model": ["core", "self", "client", "get", "session", "author", "lv", "pattern", "command", "models", "global", "xml", "link", "script", "scope", "connection", "view", "child", "record", "cl", "email", "code", "block", "ga", "app", "live", "line", "gu", "sl", "null", "comment", "package", "image", "mode", "m", "server", "copy", "cm", "Model", "project", "template", "name", "bank", "mod", "source", "message", "user", "data", "cell", "language", "store", "where", "cookie", "method", "this", "style", "feed", "base", "module", "config", "id", "db", "entry", "ma", "lc", "file", "serial", "shell", "resource", "type", "parent", "media", "document", "el", "form", "table", "ml", "sm", "reader", "service", "pe", "product"], "opts": [" opt", " opps", "operts", "ops", " oputs", "OPts", "optps", "optcs", "otta", "optents", "opents", " opents", " opouts", "ota", "otts", "opcs", "opta", "operouts", "optta", "opert", "OPuts", "optuts", "oputs", "ots", "opps", "optt", "OPt", "opouts", "otcs", "operents", "opt", "optts", "optouts", "otps", "ocs", "OPps"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n", "idx": 18351, "substitutes": {"vdev": ["Vdd", "Vgd", "vnd", "Vdev", " vdevice", "svnd", "Vdi", "svq", "Vdevice", "ldevice", "vgd", "svdev", "vev", "vdef", "vdd", "Vnd", "verdevice", " vev", " vdef", "svdef", "verdi", " vtr", "ldef", "vdevice", "svdd", "svdevice", " vconf", "vdi", "svconf", " vdd", " vdi", "svtr", "ldev", " vnd", "Vq", "ltr", "verev", "verdev", "vtr", "Vev", "Vconf", "svgd", "vconf", " vgd"], "vq": [" vque", " vQ", "vqu", "hQ", " viq", "vQ", "svq", "Vw", "tvq", "enq", " vqt", "vquest", "wg", "viewque", " vw", "viewq", "mq", "svk", "tvw", " vg", "tvQ", "qQ", "hdev", "eng", "Vqu", "svqt", "viewiq", "qq", "hq", "vque", " vqu", "tvqu", "wq", "qquery", "vk", "hg", "mQ", "vg", "wQ", " vk", "vquery", "sviq", "mquest", "viq", "vw", "Vq", "svg", " vquery", "wdev", "enqt", "enque", "svque", "qquest", " vquest", "vqt", "VQ", "mquery", "viewk"], "s": ["g", "self", "server", "cs", "sys", "f", "sa", "session", "ops", "ps", "aws", "uns", "sh", "t", "ss", "d", "n", "state", "storage", "r", "ls", "o", "w", "params", "gs", "conf", "c", "p", "sb", "service", "b", "su", "services", "S", "states", "e", "ses", "os", "ins", "sc", "spec", "v", "m"], "elem": ["elete", "eelem", "Elev", "belem", "nelete", "pelev", "eelements", " element", "pelem", "belement", "eelement", "nelem", "eelee", "elev", "elements", "elems", "eelev", "Elements", " elete", "Elem", "pelement", "eelete", " elee", "nelev", "nelements", "elee", "belements", "element", "eelems", " elems", " elements", " elev", "belev", "Element", "pelements", "belee", "belems"], "section": ["set", "session", "ray", "ect", "script", " address", "page", "connection", "description", "test", "child", "view", "block", " parent", "line", "search", "comment", " option", " replacement", "definition", "sec", "sector", " sec", "sub", " part", "server", "instance", " component", "location", "division", "Section", "character", "part", "key", "protection", "esc", "group", "element", "row", "ler", "port", "se", "j", "sect", "large", "array", "ment", "iner", "ion", "small", "config", "module", "address", "entry", "ace", "lc", "region", "step", "area", "size", "sections", " extension", "setting", "sa", "option", "parent", "form", "tag", "member", "vision", "storage", "ec", "loc", "patch", " intersection", "service", "pe", "function", "mission", " segment", "sign", "e", " structure", "sc", "shadow", "piece"], "pfn": ["ppfn", "spbn", "pfl", "ppfl", "Pfp", "ppfd", "pfd", "Pnm", " pnm", "tpbn", "tpfn", " pfl", "spkn", " pkn", "bpfen", "pbn", "bpfn", " pfd", "spfn", "tpfp", " pfp", "vpnm", " pbn", "bpfl", " pfen", "vpfp", "ppfen", "Pfn", "vpfn", "pkn", "tpkn", "spfp", "pfp", "pfen", "bpfd", "pnm"], "pa": ["ara", "cp", "sa", "pc", "jp", " Pa", "ppa", " PA", "prefix", "po", "lp", "api", "ta", "pai", "ota", "pi", "si", "pu", "address", "tta", "pb", "qa", "ai", "ma", "ia", "ba", "pre", "Pa", "ca", "ref", "pn", "p", "fp", "ha", "sb", "pe", "opa", "fa", "pointer", "PA", "appa", "area", "port", "wa", "ista", "apa", "oa", "pr", "offset"], "addr": ["cp", "pc", "route", "x", "asm", "pad", "eni", "ad", "arm", "oa", "conn", "coord", "base", "ip", "xp", "address", "qa", "r", "afi", "adr", "byte", "ace", "ady", "hop", "align", "loc", "ref", "p", "ag", "pos", "ha", "store", "nr", "pointer", "ptr", "edge", "ar", "rc", "attr", "url", "seq", "area", "alias", "port", "fe", "wa", "nm", "rt", "part", "layer", "au", "amp", "offset"]}}
{"project": "FFmpeg", "commit_id": "5602a464c9f9e3c0922f5cfeccaf2fa1c40b2401", "target": 0, "func": "static av_cold int vorbis_decode_init(AVCodecContext *avccontext)\n\n{\n\n    vorbis_context *vc = avccontext->priv_data;\n\n    uint8_t *headers   = avccontext->extradata;\n\n    int headers_len    = avccontext->extradata_size;\n\n    uint8_t *header_start[3];\n\n    int header_len[3];\n\n    GetBitContext *gb = &vc->gb;\n\n    int hdr_type, ret;\n\n\n\n    vc->avccontext = avccontext;\n\n    ff_dsputil_init(&vc->dsp, avccontext);\n\n    ff_fmt_convert_init(&vc->fmt_conv, avccontext);\n\n\n\n    if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;\n\n        vc->scale_bias = 1.0f;\n\n    } else {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_S16;\n\n        vc->scale_bias = 32768.0f;\n\n    }\n\n\n\n    if (!headers_len) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata missing.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = avpriv_split_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata corrupt.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[0], header_len[0]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 1) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"First header is not the id header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_id_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Id header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[2], header_len[2]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 5) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Third header is not the setup header.\\n\");\n\n        vorbis_free(vc);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_setup_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Setup header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    if (vc->audio_channels > 8)\n\n        avccontext->channel_layout = 0;\n\n    else\n\n        avccontext->channel_layout = ff_vorbis_channel_layouts[vc->audio_channels - 1];\n\n\n\n    avccontext->channels    = vc->audio_channels;\n\n    avccontext->sample_rate = vc->audio_samplerate;\n\n    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;\n\n\n\n    avcodec_get_frame_defaults(&vc->frame);\n\n    avccontext->coded_frame = &vc->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18371, "substitutes": {"avccontext": ["avctonstext", "avcconst", "avccorTEXT", "avconTEXT", "avdconystruct", "avCContex", "avccONcurrent", "avccONte", "avcONfig", "avccorstruct", "avccONtex", "avcconssystem", "avcconyconnection", "avccoconnect", "avmconte", "avccondst", "avrcanonter", "avcconernect", "avccONstruct", "avccONpath", "avccolontext", "avccanoncurrent", "avccetnt", "avCCONTEXT", "avccontstruct", "avctonsstruct", "aveconsride", "aveconsystem", "avccatvert", "avdconyconnection", "avcconner", "avctonstruct", "avrcanontext", "avccynstruct", "avccettext", "avcONtext", "avcconenect", "avccynnect", "avdconyconfig", "avcconnt", "aveconTEXT", "avccaonnect", "avccanontext", "avccanonnect", "avccentext", "avcconsTEXT", "avcconsnect", "avCConner", "avCConscontext", "avccanonstruct", "avccorfig", "avccaonnt", "avrconter", "avcconte", "avccONconnection", "aveconsnect", "avcconytext", "avdconconnection", "avconnect", "avmcatte", "avccocontext", "avdconconfig", "avconstruct", "avccattext", "avccastertext", "avccronconfig", "avcontext", "avdconytext", "aveconssystem", "avccetstruct", "avccONconfig", "avccONnect", "avccenstruct", "avcconcontext", "avccynfig", "avcconTEXT", "avccONter", "avccnnect", "avccennt", "avccasterstruct", "avccoloncurrent", "avcconyride", "avcconter", "avconcurrent", "avmcattex", "avcONTEXT", "avecontext", "avconpath", "avccronfig", "avccoconstruct", "avccaontstruct", "avCConcontext", "avrconstruct", "avccONner", "avccnstruct", "avcONstruct", "avcconride", "avccyntex", "avccetTEXT", "avcconerpath", "avccronstruct", "avcconstruct", "avconvert", "avccronTEXT", "avcconscontext", "avccennect", "avCCONner", "avrconnect", "avccONtext", "avcconttext", "avccronnect", "avccatTEXT", "avCConsnect", "avcconest", "avmcontext", "avccontnt", "avcconconfig", "avccatte", "avccondstruct", "avcconertext", "avccattex", "avccONnt", "avctontext", "avccolonnect", "avcconpath", "avcconyTEXT", "avcconsstruct", "avCContext", "avmconstruct", "aveconnect", "avctonsnect", "avccoconsystem", "avcONpath", "avcconerTEXT", "avccnter", "avCConfig", "avrcanonnect", "avCCONtext", "avconfig", "avcconsner", "avcconystruct", "avcconsride", "avcconstex", "avmcatstruct", "avccntext", "avccrontext", "avccronconnection", "avcconvert", "avccensystem", "avCConnect", "avCConTEXT", "avmcattext", "avccONst", "avCConstext", "avccatstruct", "avccaontext", "avccetvert", "avccaontnt", "avccontnect", "avcconcurrent", "avmcontex", "avccONTEXT", "avcONst", "avcconnect", "avccoconTEXT", "avccONvert", "avcconerner", "avrcontext", "avcconetext", "aveconride", "avccaonttext", "avccasterpath", "avdcontext", "avcconestruct", "avccyncontext", "avccondnect", "avccroncontext", "avccasternect", "aveconsTEXT", "avcconconnection", "avccanonter", "avctonnt", "avcconfig", "avconst", "avrcanonstruct", "avctonnect", "avccontex", "avcconyconfig", "avcconerstruct", "avcconstext", "avdconstruct", "avccatnect", "avccoconride", "avCConsfig", "avccoconfig", "avccaonstruct", "avctonsnt", "avccynte", "avcconynect", "avcconsystem", "avcONvert", "avccolonstruct", "avccONfig", "avccyntext", "avcconsfig", "avcONcurrent", "aveconstext", "avcconertex", "avccondtext", "avccaontnect", "avccetnect", "avccortext", "avCCONtex", "avccenTEXT", "avcONnect", "avcconsnt"], "vc": ["cca", "cs", "cp", "vec", "coll", "dc", "client", "uv", "lv", "cmd", "ac", "cache", "bc", "ci", "conn", "api", "req", "bb", "util", "hw", "gd", "fc", "fw", "auth", "db", "vp", "input", "wx", "vs", "ctx", "lc", "cci", "ga", "cf", "wd", "c", "nt", "VC", "var", "cc", "cv", "vg", "ic", "ou", "service", "nv", "vt", "vm", "vr", "rc", "vd", "voc", "sv", "ant", "ctrl", "vv", "cu", "serv", "rt", "ht", "v"], "headers": ["dr", "header", "frames", "lines", "groups", "limits", "tp", "reports", "cells", "vals", "parts", "ns", "plugins", "ints", "args", "types", "blocks", "bits", "codes", "data", "ls", "strings", "drivers", "files", "ers", "gs", "xxx", "devices", "details", "ts", "xs", "heads", "fs", "services", "uds", "cb", "fields", "rows", "rings", "events", "bands", "ds", "qs", "irs"], "header_start": ["writer_enable", "headerMenable", "driverFnext", "headerMend", "writer_change", " header_end", "headerMchange", "header_add", "headerFchange", "header5clean", "header_change", "headeralllen", " header2count", " header2end", "headeralllist", "headerCnext", "header2count", "headerCclean", "headerallstart", "headerFclean", "driverFclean", " header_count", "writerFenable", "driverFadd", "headerFend", "writerFend", "headerallmin", "driver_clean", "headerPend", "headerCadd", "writer_end", "header_end", "headerPstart", " header2start", " header_min", " header2next", "header2start", "headerPnext", "headerCstart", "headerPcount", "driverFstart", "writer_start", "headerFenable", "header_count", "driver_start", "driver_next", "driver_add", "writerFstart", "writerFchange", "header_enable", "header5start", " header_list", "headerFadd", "headerFstart", "header5next", "header_next", "header_list", "header_min", "header5add", "headerMstart", " header_next", "header2end", "headerFnext", "header_clean", "header2next"], "header_len": ["header_Len", "entryaclen", "header_depth", "header_offset", "headerPloc", "entryacloc", "headerkstop", "header___Len", "entry_loc", "headerkbody", "header_body", "urationMlog", "uration_Len", "headerCpos", "entry_len", "header_pos", "headerPl", "header0len", "driver_pos", "urationMLen", "header___log", "uration_log", "headeracoffset", "header_stop", "urationMlen", "headerPlen", " header_size", "header_size", "uration_no", "headeracl", "header_log", "headerMLen", "headeracloc", "headeraclen", "header_loc", "urationMno", "header___no", "header0depth", "entry_l", "driverCstop", "header_no", "header54len", "headerMlen", "headerCstop", "driverCbody", "headerkpos", "driver_stop", "headerCbody", "header_l", "driver_len", "driverClen", "driver_body", "uration_len", " header_depth", "header0size", "entryacl", "headerClen", "headerklen", "header___len", "header0start", "header54depth", "header54start", "headerPoffset", "headerMno", "entryacoffset", "headerMlog", "header54size", "entry_offset", "driverCpos"], "gb": ["g", "gm", "bd", "dc", "du", "uv", "gin", "pc", "cli", "bc", "gc", "bn", "py", "bb", "hub", "gd", "metadata", "bm", "hw", "lib", "db", "storage", "ctx", "ged", "ga", "rb", "gs", "gram", "sb", "abb", "hm", "cv", "gt", "vg", "gh", "mb", "rg", "gp", "cfg", "hd", "ui", "gz", "vt", "agg", "gy", "rc", "vd", "cb", "bf", "sg", "gg", "buff", "mc", "GB", "kb", "cod", "fc", "bg"], "hdr_type": ["hr_id", "hdr_name", "hdrrlength", "hDR_name", "hdr_pos", "hdr_id", "hr_type", "hDR_part", "hdr2type", "hDR_id", "hr_length", "hdrrtype", "hdr2pos", "hdr_no", "hdr2id", "hdr2name", "hdrrid", "hDR_type", "hdrrno", "hr_no", "hdr_part", "hdr_length"], "ret": ["RET", "bit", "val", "reply", "let", "cat", "result", "match", "alt", "feat", "cur", "res", "success", "reg", "back", "aud", "valid", "fail", "fun", "obj", "base", "len", "ut", "pet", "fit", "img", "usr", "pat", "rev", "pass", "rets", "att", "ref", "det", "nt", "bot", "al", "def", "flag", "re", "resp", "value", "ur", "en", "ft", "count", "url", "Ret", "bf", "mem", "bad", "arr", "arg", "lit", "rt", "utf", "info"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n", "idx": 18384, "substitutes": {"f": ["g", "self", "fx", "sf", "df", "uf", "t", "form", "front", "lf", "d", "feed", "fo", "info", "fd", "i", "fc", "fw", "ff", "h", "r", "fr", "fen", "tf", "w", "cf", "xf", "c", "k", "file", "p", "F", "fp", "inf", "rf", "b", "func", "fac", "fore", "fs", "elf", "ft", "fn", "fi", "e", "l", "fe", "buff", "v", "af", "fb", "j", "m"], "blk": ["clck", "brck", "blok", "ilk", "ilok", " blck", "plak", "blq", "elck", "mlok", "plq", "belok", "clb", "alkg", "plkg", "belk", "mlq", "plb", "plke", "lukg", "luc", "elK", "blke", "alk", "ilK", "elok", "brkg", "Blq", "alke", "mlk", " blok", " blkg", "bkg", "plk", " blke", " blak", "bk", "Blok", "ilck", "luke", "Blck", "elk", "brke", "mlck", "alc", "bck", "clak", " blq", " blb", "bke", "blK", "plok", " blc", "blck", "Blk", "blak", "blc", "luk", "plck", "clk", "belck", "brk", "belq", "plK", "blb", "blkg"], "len": ["lim", "val", "str", " lang", "lag", "length", "lan", "sp", "ll", "lt", "Len", "lp", "li", "el", "L", "lf", "n", "lon", "id", "fin", " lib", "il", "ls", "span", " l", "dl", "lc", "lang", "dy", "fl", "line", "pos", "limit", "led", "sl", "flag", "z", "le", "en", "la", "lock", "count", " length", "l", "ler", "lit", "ie", "lin", "part", "ln", "size", "offset"]}}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 18409, "substitutes": {"err": ["dr", "str", "server", "rr", "sys", "erg", "ry", "Er", "runner", "conn", "orig", "error", "req", "rh", "aster", "rar", "ir", "reg", "or", "eor", "lr", "ner", "dev", "ar", "r", "der", "fr", "usr", "doc", "rev", "reader", "call", "iter", "gr", "conf", "rb", "mr", "nil", "ind", "cr", "resp", "er", "cfg", "gz", "eth", "rc", "attr", "ev", "fi", "ret", "rn", "acer", "ler", "e", "bug", "ast", "arr", "ie", "orr", "order", "rt", "ctr", "br"], "mounts": ["ountongs", "configses", "dird", "dirs", "mountedp", "mountedes", "dirses", "mountp", "mountl", "configes", "configd", "paths", "upts", "ntes", "ountains", "hostes", "dirls", "pathl", "hostches", "mountd", "Mountses", "mountches", "threades", "mountgs", "mountses", "mountsets", "uptes", "threadls", "ountgs", "pathes", "mounteds", "ntsets", "Mountains", "mountains", "configs", "lses", "les", "threadl", "dirp", "configches", "threads", "emptgs", "empts", "mountedd", "ntses", "ounts", "emptongs", "mountedl", "mountongs", "mountedls", "mountes", "hostses", "uptses", "lsets", "configp", "pathls", "configls", "uptsets", "Mounts", "ls", "funds", "fundses", "nts", "emptains", "mountls", "dires", "hosts", "Mountongs", "dirches", "Mountgs"], "mount": ["follow", "track", "f", "component", "option", "project", "proc", "handle", "match", "mont", "cache", "link", "parent", "source", "connection", "valid", "child", "own", "root", "boot", "fail", "hw", "config", "pair", "dev", "multi", "user", "pg", "path", "od", "entry", "block", "monitor", "account", "target", "call", "lc", "c", "sync", "p", "patch", "Mount", "service", "pkg", "group", "find", "lock", "attr", "url", "mounted", "field", "mem", "cmp", "port", "device", "mm", "part", "md", "host", "m"], "local_err": ["localxer", "localxmagic", "local_tx", "local7state", "localxerror", "local7er", "local_ir", "http_error", "locallytx", "shared_rr", "localapprr", "localxtx", "local_er", "local7error", "local_error", "locallyorder", " local_error", "locallyerror", "http_log", "local_req", "local_log", "http_err", "http_ir", "local_rr", "shared_error", "local_order", "local_cor", "localxerr", "local7err", "local__ir", "local_state", " local_magic", "local__err", "locallyerr", "shared_err", " local_order", " local_cor", "local_magic", "local__error", "localapperror", "localxorder", " local_tx", "local__log", " local_er", " local_state", " local_rr", "localapperr", "shared_req", "localappcor"], "fd": ["fx", "cd", "FH", "sf", "df", "dc", "f", "bd", "handle", "fed", "pipe", "buf", "dd", "ds", "draft", "conn", "d", "lf", "feed", "wb", "fm", "len", "fun", "sd", "gd", "fw", "FD", "db", "zip", "ff", " fin", "dir", "fen", "dl", "fff", "reader", "writer", "fl", "wd", "cf", "c", "file", "fp", " fid", "ld", "cond", "nd", "wind", "fa", "socket", "fs", " d", "hd", "fat", "handler", "cb", "fi", " FD", "bf", "fn", "vd", " f", "pid", "fe", "dn", "io", "fc", "md", "ln", "fb"], "i": ["phi", "val", "di", "f", "result", "qi", "u", "x", "ci", "li", "abi", "t", "it", "counter", "n", "len", "I", "si", "pi", "id", "init", "index", "ai", "ib", "r", " ret", "ii", "c", "nt", "p", "limit", "key", "ind", "b", "mini", "ui", "ni", "count", "fi", "num", "ret", "e", "l", "io", "ini", "out", "v", "mi", "j", "info"]}}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n", "idx": 18412, "substitutes": {"fdt": ["vdt", "fdx", "lfnt", "lfta", "vdnt", "lft", "lfx", "dfd", "ndd", "dftt", "cdtt", "ndtt", "dlnt", "fdta", "dltt", "fdd", "dfta", "ndct", "cdt", "ndt", "cdta", "vdta", "dfct", "cdnt", "vdtt", "fdnt", "fdct", "dft", "dlct", "dlta", "dfx", "dlt", "dlx", "dfnt", "fdtt", "dld"], "node_path": ["node_name", "nodebookpointer", "nodebookprop", " node_data", "node_prop", "node_data", " node_name", "nodebookpath", " node_pointer", "node_pointer", "nodebookname", " node_prop"], "property": ["set", "section", "resource", "expression", "integer", "option", "number", "range", "type", "name", "node", "prefix", "Property", "parent", "description", "root", "position", "location", "path", "address", "data", "variable", "object", "p", "key", "function", "pointer", "properties", "value", "letter", "item", "package", "prop", "element", "attr", "term", "filename", "part", "field", "attribute", "feature"], "offset": ["set", "inet", "alpha", "shift", "f", "output", "length", "timeout", "layout", "number", "operation", "range", "type", "node", "prefix", "et", "off", "api", "end", "error", "no", "info", "phase", "position", "len", "location", "notation", "i", "optional", "online", "address", "index", "padding", "addr", "data", "o", "sort", "Offset", "align", "loc", "slot", "ref", "part", "object", "p", "fp", "pos", "missing", "append", "null", "pointer", "value", "count", "url", "start", "alias", "unknown", "empty", "absolute", "attribute", "size"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n", "idx": 18426, "substitutes": {"rc": ["cca", "core", "cs", "rec", "coll", "dc", "src", "pc", "result", "uc", "bc", "ac", "rs", "nc", "cur", "rh", "config", "fc", "irc", "r", "rx", "ctx", "lc", "loc", "rb", "RC", "c", "oc", "cc", "cv", "abc", "roc", "auc", "tc", "context", "cb", "arc", "gb", "cmp", "ctrl", "anc", "xc", "sc", "rt", "icc", "sync"], "porder": [" pair", "prorder", "upordered", "Pordering", "rordered", "npaddress", "rcount", "preorders", "Porders", "varm", "rair", "cordering", "corders", "prorders", "upair", "Porder", " porders", " pordering", "vorders", "lporder", "porders", " pordered", "pair", "preorder", "uporders", "ncount", "norder", "poder", "rorder", "upordering", "nair", "npair", " pake", "lpake", "Parm", "pcount", "pake", "corder", "pordered", "upoder", "paddress", "lpair", "preoder", "nordered", " paddress", "lparm", "preair", "lpaddress", " poder", "vordering", "lpordering", "parm", "vorder", "cordered", " pcount", "npake", "lporders", "nporder", "prordering", "uporder", "pordering"], "sums": ["psamples", "Subs", " samples", "suma", "psales", "sups", "subs", " sus", "pum", "psum", "psums", "Sups", "samples", "asus", " sups", " suss", " sults", "suss", "pales", " subs", " sales", "sesubs", "sum", "asuma", " sum", "Sums", "sus", "Sults", "sults", "pums", "pamples", "sesums", "Suss", "asums", "sesuss", "asups", "Suma", "sesults", " suma", "sales", "Sus"], "n": ["g", "sn", "cn", "f", "number", "node", "nc", "u", "net", "x", "in", "t", "conn", "d", "no", "ns", "len", "nn", "span", "o", "N", "c", "nt", "p", "pn", "s", "b", "z", "mn", "en", "ni", "nb", "ne", "num", "fn", "un", "e", "network", "l", "non", "nm", "v", "an", "j", "m"], "pred_order": ["predfrank", "pred__orders", "cmp_orders", "pred__Order", "cmpforder", "cmpforders", "predPorders", "pred_ordered", "cmpfrank", "predforders", "pred_Order", "pred__rank", "predforder", "predPkey", "predPorder", "predfordered", "pred__order", "Pred_key", "predPordered", "Pred_order", "Pred_orders", "pred_rank", "cmp_Order", "predfkey", "cmp_rank", "cmp_order", "Pred_ordered", "pred_key", "cmpfOrder", "pred_orders", "predfOrder"], "i": ["di", "f", "ri", "xi", "x", "u", "qi", "ix", "ci", "li", "in", "abi", "q", "api", "bi", "it", "uri", "mu", "d", "ji", "info", "ti", "ip", "I", "pi", "si", "multi", "id", "h", "r", "index", "ai", "init", "o", "ii", "c", "p", "s", "y", "b", "ki", "slice", "mini", "ui", "ni", "gi", "zi", "fi", "e", "l", "io", "oi", "ie", "ini", "v", "mi", "j", "m"], "k": ["g", "kn", "kin", "kat", "f", "kk", "ck", "kind", "work", "x", "u", "K", "kr", "q", "kh", "mk", "d", "dk", "ka", "id", "r", "ik", "o", "ijk", "w", "ak", "sk", "c", "p", "ke", "kick", "key", "ks", "y", "kw", "ki", "b", "ko", "unk", "kid", "e", "ask", "ek", "ok", "v", "j", "m"], "cnt": ["acnt", " cnd", "ucnn", "cct", "CNT", "pcrt", "cnn", "cpt", "conNT", "pcnt", " cno", "dcnd", "cwd", "Cant", "dcrt", "acNT", " cct", "cant", "dcpt", "cnc", "pcpt", "conent", "pcnn", "dcnt", "ucct", " cant", "cno", "Cnt", " cent", "ucnt", "crt", " cwd", "dcnc", "dcant", "cnd", " crt", "ucant", "dcNT", "Cno", "dcnn", "ucnc", " cnn", " cnc", "acwd", " cNT", "dcct", " cpt", "cent", "connt", "ucnd", "cNT", "dcno", "conwd", "acent"], "part": ["val", "section", "round", "min", "f", "number", "pc", "type", "x", "parent", "po", "pad", "Part", "minute", "parts", "d", "point", "no", "force", "len", "base", "pi", "position", "pair", "partial", "id", "max", "change", "year", "span", "space", "block", "pre", "half", "p", "patch", "pos", "limit", "b", "PART", "step", "count", "seed", "start", "order", "v", "art", "j", "m"], "all_bits": [" all_parts", "all_params", "all_bit", "all_pins", "allCbits", " all_pieces", "all_pieces", " all_params", "all_bytes", "all__pieces", " all_bytes", " all_pins", "all__bytes", "allCparams", "allCpieces", "all__parts", "all__bits", "allCbytes", "all_parts", " all_bit"]}}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n", "idx": 18437, "substitutes": {"common": ["security", "core", "foreign", "server", "resource", "cm", "client", "component", "session", "com", "generic", "name", "node", "global", "mod", "normal", "cache", "command", "new", "standard", "document", "stack", "record", "util", "low", "central", "lib", "control", "summary", "con", "diff", "full", "ctx", "comm", "conf", "loader", "public", "create", "comp", "pkg", "context", "Common", " Common", "COM", "from", "remote", "master", "shared", "recent", "sync"], "state": ["core", "set", "self", "the", "resource", "rule", "output", "session", "component", "cal", "style", "type", "instance", "name", "media", "parent", "grade", "work", "cache", "conn", "param", "STATE", "form", "scope", "tag", "info", "or", "State", "config", "module", "parse", "status", "address", "data", "ace", "are", "stat", "call", "all", "object", "post", "patch", "manager", "slice", "update", "comment", "use", "ass", "states", "element", "seed", "start", "port", "list", "spec", "master", "event", "part", "date", "art", "j", "settings"]}}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n", "idx": 18438, "substitutes": {"pointers": ["maps", "eps", "lines", "styles", "tracks", "weights", " pointer", "notes", "limits", "holes", "tips", "ps", "ports", "pins", "pad", "inters", "parts", "rh", "toc", "ints", "locks", "ipes", "path", "ips", "codes", "padding", "opens", "cuts", "posts", "amps", "ctx", "balls", "details", "p", "pos", "ices", "pieces", "xs", "pointer", "pages", "ptr", "points", "steps", "wcs", "fields", "sets", "books", "roots", "thumbnails", "rows", "rings", "offs", "cases", "faces", "angles"], "linesizes": [" linesizing", "linedamples", "lineizations", "linizations", "linesamples", " linesets", "lesizes", "lineize", "linesize", "lineizing", "inesizations", "lesamples", "linesizations", "linedizing", "lineizers", "lesizing", " linesizations", "linesizers", "linedizations", " linesamples", "linizers", " linesizers", "linsize", "linsizers", "linizes", "linesets", "inesizes", "inesamples", "linesizing", "linsizing", "linedizes", "lineizes", "linets", "linsamples", "lesizations", "inesets", "linedize", "inesizers", "linizing", " linesize", "linsizes", "linsizations"], "w": ["f", "wt", "x", "u", "temp", "window", "wh", "sw", "d", "wb", "n", "we", "hw", "fw", "aw", "r", "max", "win", "o", "wrap", "ew", "all", "wd", "c", "p", "s", "y", "b", "z", "nw", "l", "wa", "a", "W", "rw", "v", "m"], "h": ["g", "f", "hi", "x", "u", "oh", "sh", "bh", "q", "t", "uh", "rh", "n", "H", "ch", "hw", "offset", "cl", "path", "r", "padding", "hr", "help", "loc", "c", "height", "head", "p", "ha", "y", "gh", "b", "ih", "pointer", "z", "hh", "hd", "l", "ph", "hs", "ah", "hm", "ht", "v", "host", "m"], "pix_fmt": ["pix2frrt", "pix_fcMT", "pix_tfrt", "pix2fMT", "pix_funMT", "pix_lformat", "pix_freemat", "pix_fformat", "pix_tfkt", "pix_fMT", "pix_lprintf", "pix_fcprintf", "pix_lmat", "pix2fformat", "pix_funmt", "pix_formkt", "pix_formmat", "pix_frt", "pix_lmt", "pix2frMT", "pix_funformat", "pix_formformat", "pix2frmt", "pix_formmt", "pix_fcmt", "pix_tfMT", "pix_frformat", "pix2fmt", "pix_tfprintf", "pix_freert", "pix_freeformat", "pix2frformat", "pix_tfformat", "pix_funkt", "pix_lrt", "pix_fmat", "pix_fkt", "pix_fprintf", "pix_frmt", "pix_tfmt", "pix_lMT", "pix2frt", "pix_formrt", "pix_frrt", "pix_frMT", "pix_formMT", "pix_fcformat", "pix_freemt"], "align": ["lace", "arrow", "ail", "shift", "f", "angle", "aff", "style", "work", "cache", "aligned", "array", "x", "balance", "pad", "ignment", "coord", "len", "border", "ff", "padding", "img", "ign", "addr", "diff", "wrap", "help", "format", "ref", "xff", "al", " alignment", "ag", "pixel", "amp", "attr", "adjust", "alias", "margin", "IGN", "mag", "size", "offset"], "i": ["phi", "di", "f", "ri", "xi", "type", "x", "ix", "u", "qi", "ci", "li", "in", "t", "eni", "it", "uri", "d", "n", "ip", "I", "pi", "si", "multi", "id", "r", "ib", "ai", "index", "iu", "o", "ii", "c", "k", "p", "s", "y", "ind", "b", "z", "ui", "ni", "gi", "zi", "fi", "e", "l", "io", "oi", "ini", "v", "ti", "j", "m"], "ret": ["reply", "val", "uf", "proc", "match", "end", "fun", "fd", "aux", "pet", "replace", "flag", "prop", "buff", "opt", "arg", "lit", "rt", "ru", "let", "res", "nz", "reg", "fail", "red", "reset", "img", "addr", "usr", "rev", "nt", "def", "value", "fi", "art", "offset", "RET", "f", "cat", "hard", "error", "buffer", "base", "id", "entry", "wrap", "pass", "att", "rb", "fat", "run", "Ret", "rep", "plain", "result", "complete", "alt", "feat", "success", "back", "len", "obj", "fin", "ff", "status", "rets", "ext", "ref", "re", "ft", "count", "bf", "mem", "bad", "debug", "part", "af"], "buf": ["vec", "bd", "f", "src", "uf", "result", "uc", "bc", "queue", "temp", "cur", "pad", "off", "plug", "buffer", "Buffer", "wb", "pool", "back", "fun", "obj", "fd", "aux", "ff", "pb", "img", "data", "br", "cas", "ctx", "ba", "loc", "rb", "callback", "ref", "xff", "fp", "bag", "tmp", "cv", "func", "b", "ptr", "alloc", "rc", "cb", "ab", "seq", "mem", "port", "lit", "lb", "box", "buff", "v", "Buff", "fb", "offset"]}}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n", "idx": 18439, "substitutes": {"s": ["local", "g", "is", "self", "sf", "f", "session", "sys", "u", "js", "t", "ss", "sq", "scope", "ns", "site", "si", "state", "status", "iss", "o", "stat", "gs", "conf", "side", "c", "sb", "p", "service", "sie", "ssl", "b", "su", "fs", "services", "S", "states", "ses", "e", "l", "os", "sym", "se", "sync", "settings"], "index": ["val", "coll", "match", "range", "x", "ix", "axis", "window", "end", "point", "connection", "view", "position", "block", "append", "action", "update", "insert", "image", "weight", "zero", "shape", "fe", "name", "instance", "level", "fee", "i", "forward", "column", "addr", "draw", "design", "object", "key", "value", "lock", "element", "row", "office", "date", "offset", "f", "length", "condition", "error", "version", "id", "address", "input", "ace", "body", "ind", "pointer", "feature", "info", "expression", "inc", "Index", "type", "success", "include", "path", "fff", "loc", "loop", "active", "slice", "edge", "part", "iframe"], "frame": ["hide", "scale", "frames", "family", "f", "length", "clock", "range", "Frame", "raise", "window", "flow", "orig", "scope", "point", "info", "position", "version", "forward", "state", "code", "ace", "fram", "block", "next", "iframe", "loc", "loop", "cf", "time", "c", "close", "line", "ind", "series", "function", "append", "thread", "slice", "update", "image", "row", "e", " Frame", "fe", "trace", "event", "feature", "offset"]}}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n", "idx": 18447, "substitutes": {"vdev": [" vprom", "vnd", "fdevice", " vdevice", "vprom", "svnd", "fnd", "ldevice", "fdef", "svdev", "vdef", "lprom", "fdev", "vci", " vdef", "ldef", "vdevice", "svdevice", " vnd", "fci", "ldev", "fprom", " vci", "svci"], "vq": [" vque", " vQ", "vqu", "vQ", "svq", "tvq", "guq", "invdq", " vdq", "svue", "gudq", " vue", "tvQ", "sveq", "vue", "vque", " vqu", "veq", "tvue", "svQ", "vdq", "invq", "invqu", "invque", " veq", "tveq", "guqu", "guque"], "s": ["g", "is", "core", "cs", "server", "self", "sf", "f", "sys", "ops", "http", "secondary", "new", "js", "t", "ss", "sq", "q", "scope", "d", "ns", "n", "si", "i", "dev", "support", "storage", "r", "o", "w", "an", "sk", "c", "p", "sb", "service", "ssl", "sup", "su", "socket", "services", "S", "ses", "e", "share", "sv", "sym", "hs", "a", "spec", "sc", "ds", "secure", "v", "sync", "m"]}}
{"project": "qemu", "commit_id": "1a20a032ccbb5800bfdfc75accfcff2ac67f5bcb", "target": 1, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct usb_device_info bus_info, dev_info;\n\n    USBDevice *d = NULL;\n\n    USBHostDevice *dev;\n\n    char ctlpath[PATH_MAX + 1];\n\n    char buspath[PATH_MAX + 1];\n\n    int bfd, dfd, bus, address, i;\n\n    int ugendebug = UGEN_DEBUG_LEVEL;\n\n\n\n    if (usb_host_find_device(&bus, &address, devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buspath, PATH_MAX, \"/dev/usb%d\", bus);\n\n\n\n    bfd = open(buspath, O_RDWR);\n\n    if (bfd < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to open usb bus - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n    bus_info.udi_addr = address;\n\n    if (ioctl(bfd, USB_DEVICEINFO, &bus_info) < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to grab bus information - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s\", bus_info.udi_devnames[0]);\n\n#else\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s.00\", bus_info.udi_devnames[0]);\n\n#endif\n\n\n\n    dfd  = open(ctlpath, O_RDWR);\n\n    if (dfd < 0) {\n\n        dfd = open(ctlpath, O_RDONLY);\n\n        if (dfd < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to open usb device %s - %s\\n\",\n\n                   ctlpath, strerror(errno));\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (dfd >= 0) {\n\n        if (ioctl(dfd, USB_GET_DEVICEINFO, &dev_info) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to grab device info - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            goto fail;\n\n        }\n\n\n\n        d = usb_create(NULL /* FIXME */, \"usb-host\");\n\n        dev = DO_UPCAST(USBHostDevice, dev, d);\n\n\n\n        if (dev_info.udi_speed == 1)\n\n            dev->dev.speed = USB_SPEED_LOW - 1;\n\n        else\n\n            dev->dev.speed = USB_SPEED_FULL - 1;\n\n\n\n        if (strncmp(dev_info.udi_product, \"product\", 7) != 0)\n\n            pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                    dev_info.udi_product);\n\n        else\n\n            snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                     \"host:%s\", devname);\n\n\n\n        pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\");\n\n        pstrcat(dev->devpath, sizeof(dev->devpath), dev_info.udi_devnames[0]);\n\n\n\n        /* Mark the endpoints as not yet open */\n\n        for (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\n           dev->ep_fd[i] = -1;\n\n\n\n        ioctl(dfd, USB_SETDEBUG, &ugendebug);\n\n\n\n        return (USBDevice *)dev;\n\n    }\n\n\n\nfail:\n\n    return NULL;\n\n}\n", "idx": 18457, "substitutes": {"devname": [" devName", "evName", " devno", " devNAME", "Devname", "Devno", "devno", "evNAME", "evname", "devicenames", "deviceno", "deviceName", "devNAME", "DevName", "DevNAME", " devnames", "devnames", "Devnames", "devicename", "devName"], "bus_info": ["driverallfo", " usbginfo", "driverallinf", "bus_Info", " usb_ref", " bus_object", " usb_info", "usb_area", "bus_area", "bus_object", " buserobject", " usb_Info", " bus_auto", "busjref", " usbgInfo", "busallstart", "usb_start", " buserinfo", "buserauto", "bus_INFO", "driver_fo", "driver_info", " buserauto", " usb_INFO", "busgINFO", "driver_start", "busallinfo", "driver_inf", "busgref", "driverallstart", " usbgref", "dev_inf", "bus_inf", "busallinf", "driverallinfo", "bus_auto", "bus_ref", "usb_info", "usb_id", " usbgINFO", "bus_fo", "buserobject", "dev_now", "bus_id", "buserinfo", "busallfo", "busgInfo", "busjINFO", "bus_now", "busginfo", "busjinfo", "busjInfo", "bus_start"], "dev_info": ["Dev_info", "Dev_INFO", " dev_INFO", " dev_Info", " dev_inf", " dev_num", "Dev_inf", "dev_num", "devsInfo", "dev_INFO", "dev_inf", "devsinf", "devsinfo", "dev_Info"], "d": ["g", "di", "cd", "dh", "bd", "dc", "D", "f", "dd", "t", "ad", "dm", "n", "fd", "sd", "gd", "dt", "h", "dict", "dl", "w", "ded", "c", "p", "std", "b", "def", "z", "e", "dat", "l", "driver", "dn", "device", "v", "ds", "md", "m"], "dev": ["g", "di", "dc", "proc", "sh", "off", "api", "pub", "block", "conf", "app", "gu", "attr", "adv", "cd", "temp", "mod", "dd", "res", "linux", "fo", "hw", "od", "max", "dom", "data", "nt", "p", "s", "def", "home", "die", "bug", "gpu", "md", "ver", "console", "f", "ad", "error", "_", "sd", "config", "init", "diff", "Dev", "o", "raw", "next", "dist", "ve", "ev", "serial", "info", "bd", "D", "dm", "ch", "gd", "private", "w", "de", "cost", "start", "driver", "device", "debug", "v"], "ctlpath": ["catPath", "configath", "ditinfo", "sslath", "ctlkey", "sudopath", "configenc", "configparent", "ctrlkey", "controlPath", "controlath", "ditpath", "configPath", "ditath", "lcpath", "dlath", "bccase", "ctlstr", "ctlenc", "configPATH", "controlcase", "sslPath", "gitcase", "ctlPATH", "sudoath", "dlstr", "catath", "configcase", "configpath", "fdPath", "ctlinfo", "configkey", "ctlcase", "ctlath", "dlPath", "catcase", "sslpath", "gitpath", "sudoPath", "ctrlenc", "ctlPath", "fdenc", "ditPath", "bcpath", "ctrlpath", "ditstr", "ctlparent", "fdkey", "controlpath", "catpath", "bcPATH", "configstr", "gitPATH", "sudoinfo", "fdpath", "dlpath", "bcparent", "lcath", "gitparent", "lcinfo", "ctrlPath"], "buspath": ["busPath", "busroot", "driverfull", "buscat", "usbpath", "passconfig", "passroot", "passfull", "switchfull", " busath", "blockcat", "bridgeroom", "busfull", "blockfull", "bootpath", "ctlath", "ctlinfo", "passpath", "drivercat", "bootinfo", "ctlPath", " businfo", "bridgepath", "usbroot", "driverpath", "bridgefull", "switchpath", "usbfull", "blockroom", "businfo", "switchconfig", "busroom", "driverroom", "bootath", "busconfig", "busath", "usbconfig", " busPath", "bridgecat", "bootPath", "blockpath", "switchroot"], "bfd": ["rbdf", "lfd", "baseFD", " bfc", "bcd", "Bdc", " bFD", "bfc", "ffa", "rbcd", "bfa", " bdf", "Bfd", " bfa", "rbfd", "bFD", "rbfc", "fdd", "ffc", "fdc", "ffd", " bcd", "basedc", " bdc", "ldf", "lcd", "bdd", "lfc", "bdf", "basefd", "Bfc", "Bdd", "BFD", " bdd", "Bfa", "bdc", "basefc"], "dfd": ["cfyd", "ddf", "afd", "dfdy", "depd", "dfyd", "afdh", "pdfdb", "depdy", "cfd", "cfD", "rawdb", "ufd", "fdb", "fddh", "fdd", "afD", "DFt", "uft", "rawcd", "DFl", "bdd", "cfb", "ufl", "DFd", "cfl", "ddds", "bbD", "dfdb", "eft", "DFdh", "ddd", "cfs", "rawD", "fdf", "ufds", "depD", "dff", "pdfd", "dfds", "dfD", "dfsd", "DFb", "cfds", "dft", "fcds", "fdcd", "defcd", "dfl", "fcl", "DFds", "fddb", "fcD", "depsd", "mdD", "mdd", "efl", "DFD", "mdsd", "dfb", "dfcd", "dfs", "deff", "bds", "fdD", "fcd", "bbd", "bbsd", "efd", "dfdh", "DFyd", "defd", "fdds", "efds", "mddy", "rawd", "pdfcd", "ddcd", "pdfD", "afb", "bdyd", "defds", "bdb", "DFs", "bbdy"], "bus": ["class", "interface", "serial", "cat", "length", "route", "type", "name", "cache", "plug", "uri", "connection", "board", "base", "boot", "hub", "controller", "lib", "config", "id", "BUS", "path", "us", "mount", "bridge", "object", "b", "def", "os", "port", "driver", "Bus", "bug", "device", "usb", "plugin", "host"], "address": ["server", "interface", "length", "number", "route", "name", "type", "instance", "array", "api", "end", "uri", "ip", "position", "message", "base", "location", "config", "id", "path", "index", "ai", "addr", "ace", "target", "bridge", "p", "service", "Address", "ress", "package", "audio", "image", "url", "shape", "network", "port", "alias", "a", "device", "reference", "master", "order", "attribute", "host", "offset"], "i": ["is", "di", "interface", "cli", "instance", "ci", "li", "in", "api", "uri", "ip", "I", "pi", "id", "init", "ai", "index", "iu", "ii", "c", "p", "b", "ui", "ni", "fi", "ini", "info"]}}
{"project": "FFmpeg", "commit_id": "98b377004d9c6fa1c1756c814efe9882b65f96b9", "target": 0, "func": "static av_cold int twin_decode_init(AVCodecContext *avctx)\n\n{\n\n    int ret;\n\n    TwinContext *tctx = avctx->priv_data;\n\n    int isampf, ibps;\n\n\n\n    tctx->avctx       = avctx;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    if (!avctx->extradata || avctx->extradata_size < 12) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = AV_RB32(avctx->extradata    ) + 1;\n\n    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;\n\n    isampf          = AV_RB32(avctx->extradata + 8);\n\n\n\n    if (isampf < 8 || isampf > 44) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (isampf) {\n\n    case 44: avctx->sample_rate = 44100;         break;\n\n    case 22: avctx->sample_rate = 22050;         break;\n\n    case 11: avctx->sample_rate = 11025;         break;\n\n    default: avctx->sample_rate = isampf * 1000; break;\n\n    }\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",\n\n               avctx->channels);\n\n        return -1;\n\n    }\n\n    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO :\n\n                                                   AV_CH_LAYOUT_STEREO;\n\n\n\n    ibps = avctx->bit_rate / (1000 * avctx->channels);\n\n\n\n    if (ibps > 255) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((isampf << 8) +  ibps) {\n\n    case (8 <<8) +  8: tctx->mtab = &mode_08_08; break;\n\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n\n        return -1;\n\n    }\n\n\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if ((ret = init_mdct_win(tctx))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        twin_decode_close(avctx);\n\n        return ret;\n\n    }\n\n    init_bitstream_params(tctx);\n\n\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n\n\n    avcodec_get_frame_defaults(&tctx->frame);\n\n    avctx->coded_frame = &tctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18462, "substitutes": {"avctx": ["akconv", "navkb", "afdc", "alcontext", "abcontext", " avsci", "avecn", "alctx", "avcci", "aveclient", " avpkg", "abcca", " avcmp", "avconv", "ajconv", "verxc", " avcn", "avekb", "avkb", "akcoll", "afctrl", "navctrl", "avcu", "verpkg", "akcu", "afxc", "aveloc", "avalcdn", "avcdn", "avecmd", "AVloc", "ajcontext", "akcontext", "akctx", "avepkg", "avconn", "avecci", "akcomp", "aucp", "avcmp", "vercas", "ajcomp", "avectx", "avcontext", "avalsync", "afconn", "avctrl", "avalclient", "verctx", "airxc", "AVctx", "avecontext", "avpkg", "aucu", "AVcontext", "aircf", "avalsys", "afcci", "avlc", "avalctrl", "airlc", "verclient", "avalcf", "ajconn", " avcu", "avalcmd", "ablc", "aucontext", "ajcoll", "afcontext", "avcoll", "alcmp", "avc", "avcmd", "ajcn", "navcp", "avecp", "aflc", "akcn", "akcca", "avalcontext", "abctx", " avxc", "afcca", "avcca", "afpkg", "avloc", "versync", "ajcci", "avconfig", "akcli", "vercf", "afcoll", "avcp", "avecoll", "aveconf", "afcf", "navconf", "vercu", "afcu", "afclient", "avecca", "avcas", "ajcu", "avxc", "avalctx", "afcp", "afconfig", "avsci", "verconfig", "AVconn", "navcca", "navcontext", "avcli", "AVpkg", "abconf", "afloc", "afctx", "avecu", "avaldc", "AVsci", "navcu", "avectrl", "alpkg", "ajcli", "verdc", "afcas", "avcomp", "avesys", "afkb", " avcontext", "avec", " avcas", "navcdn", "avsys", "AVlc", "afsci", "auctx", "ajctx", "AVcca", "avalc", "avedc", "AVcmp", " avlc", "afcomp", "avdc", "afconv", "afsys", "avcf", "airctx", "vercontext", "avsync", "AVcmd", "avclient", "navctx", "abcu", "ajdc", "aveconfig", "afsync", "aircontext", "avconf", "AVxc", "avecmp", "afc", " avcca", "aircu", "afcn", "afcmp", "aveconn", "avcn", "afcli", "afcdn", "avalconn"], "ret": ["RET", "val", "result", "Num", "res", " rc", "no", "len", " RET", "id", " result", "code", " resp", "Val", "nt", "var", "Return", " res", "resp", "rc", "Ret", " r", "arr"], "tctx": ["trctx", "mbatch", "mcontext", "tlc", "tconn", "vctx", "tconf", " tconn", " tcontext", "attcmp", "vqa", "mlc", "trlc", " ttx", "tcontext", "attconn", "vcontext", " tqa", " txc", "tbatch", "atconn", "atctx", "tcmp", "trxc", "attcontext", "trbatch", "mtx", "trqa", " tbatch", " tlc", "tqa", "mctx", "mconf", "trcontext", "attctx", "atcmp", "vxc", "ttx", "trconf", "trtx", "atcontext", "txc", " tconf", " tcmp"], "isampf": ["isappl", "hisampF", "issarpl", "isarpl", "isumpfo", "isampv", "isambf", "issepfs", "isapf", "bisampfor", "isapfor", "isarpe", "isarpp", "isapfe", "isarpc", "isaprf", " isampF", " isapc", " isapf", "issampfe", "isarpfs", "bisampF", "isapl", " isarpc", "issarpfe", "isapv", "isappfe", "isarpfor", "isapF", "isumpF", "isappf", " isapfs", "isambe", "isampe", "ismpfe", "isumpfor", "issarpv", "isampc", " isarpf", " isampfo", "issepfe", "isumpp", "isarpform", "isapfs", "issarpf", "hisaspform", "isumpfs", "isappv", " isarpsf", "bisaprf", "ismpf", "issepF", "hisaspfe", "isumpsf", "isumpfe", "intarpf", "intarpe", "issampfs", "isamprf", "intampe", "ismpfs", "isaspF", "hisampf", "isarprf", "isampfe", "ismpF", "isppf", "isarpfo", "bisampf", "issepf", "isampfs", "isppfe", "isumpe", "intampp", "bisapF", "isumpf", "isapfo", "isambp", " isampsf", "isarpv", "isapsf", "intarpfs", "hisaspF", "hisaspf", "intampfs", " isarpF", "isarpF", "issampv", "isarpsf", "isaspfe", "isaspform", "isepfe", "isppform", "isapc", "hisampform", "isepF", "isepf", "isampF", " isapfo", "isambfs", "bisapf", "bisamprf", "isampfo", "isaspf", "issampl", "issampF", " isampc", "isampl", "issampf", " isampfs", "isumpc", "isppF", "isampp", "isarpf", "isumprf", "bisapfor", "hisampfe", "isarpfe", "isampform", "isampfor", "isepfs", "intampf", "intarpp", "isampsf"], "ibps": ["ambpes", "IBfs", "ubfs", "ibfs", "habps", "habpes", "ambps", "obp", " ibops", "ebp", "ilibps", "abpes", "IBpps", "habops", "iwps", "ubpps", "ibs", "iwaps", " ibpes", "abps", "iwpped", "obpps", "obops", "ibaps", "ibPS", "ebpp", "ibops", "ibpp", "iwpes", "habs", "abops", "ambpped", "ebfs", "ilibpps", "ibpps", "ebps", " ibaps", "obpes", "ambaps", " ibPS", " ibpps", "ubops", "obs", "IBPS", "ilibpp", "ibp", "ubps", "ibpped", "IBps", "IBops", "obps", "ibpes", "ebpps", " ibpped", "ebops", "ilibp", "obPS", "obpp"]}}
{"project": "FFmpeg", "commit_id": "18ff4d20201ae69fdeb2da2c90bdcbd33f7ac025", "target": 1, "func": "static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)\n\n{\n\n    AVFormatContext *is = ifile->ctx;\n\n    AVFormatContext *os = ofile->ctx;\n\n    int i;\n\n\n\n    for (i = 0; i < is->nb_chapters; i++) {\n\n        AVChapter *in_ch = is->chapters[i], *out_ch;\n\n        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,\n\n                                       AV_TIME_BASE_Q, in_ch->time_base);\n\n        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :\n\n                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);\n\n\n\n\n\n        if (in_ch->end < ts_off)\n\n            continue;\n\n        if (rt != INT64_MAX && in_ch->start > rt + ts_off)\n\n            break;\n\n\n\n        out_ch = av_mallocz(sizeof(AVChapter));\n\n        if (!out_ch)\n\n            return AVERROR(ENOMEM);\n\n\n\n        out_ch->id        = in_ch->id;\n\n        out_ch->time_base = in_ch->time_base;\n\n        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);\n\n        out_ch->end       = FFMIN(rt, in_ch->end   - ts_off);\n\n\n\n        if (copy_metadata)\n\n            av_dict_copy(&out_ch->metadata, in_ch->metadata, 0);\n\n\n\n        os->nb_chapters++;\n\n        os->chapters = av_realloc(os->chapters, sizeof(AVChapter) * os->nb_chapters);\n\n        if (!os->chapters)\n\n            return AVERROR(ENOMEM);\n\n        os->chapters[os->nb_chapters - 1] = out_ch;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18474, "substitutes": {"ifile": ["IFil", "IFilt", "IFile", "IFILE", "ifilt", "OFetch", " ifil", "OFil", "Ifle", "ifetch", "fetch", " ifilt", "IfILE", "Ifile", "OFuture", "ifILE", "IFuture", "ifail", " ifILE", "IFail", "IFime", "file", "future", "ifuture", "IFle", "OFile", "afile", "afime", "afil", "fil", "ifime", "IFetch", "Ifilt", "ifle", "ifil", "afail", " ifime", " ifle", " ifail"], "ofile": ["offil", "offilia", " ofactory", "alfime", "affile", "ofil", "OFil", "ofime", " ofili", " ofilia", "OFime", "ofili", "alffile", "offilt", "afili", "offile", "Ofilt", "ofilt", "OFilia", "Offile", "Ofime", "ofactory", " ofime", "alfilt", "Ofactory", " offile", "OFile", "alfil", "afile", "offactory", "offfile", "afil", "afime", " ofil", "ofilia", "offime", "Ofile", "alfile", "alfili"], "copy_metadata": [" copy_adata", "copy__data", " copy_filename", "copy__adata", "copy_meta", "copy_filename", "copy__filename", " copy_meta", "copy__meta", "copy__metadata", " copy_data", "copy_data", "copy_adata"], "is": ["iso", "cs", "mis", "ics", "ri", "bs", "ais", "op", "in", "js", "it", "isl", "ns", "ir", "has", "kit", "id", "isc", "ar", "ib", "ai", "fr", "iss", "ace", "ois", "us", "are", "isu", "ii", "iq", "was", "acs", "ot", "lis", "p", "s", "ris", "iris", "obs", "sis", "fs", "so", "image", "bis", "as", "IS", "ins", "isi", "ie", "its", "info"], "os": ["iso", "cs", "css", "oS", "ow", "ms", "sys", "OS", "ops", "cat", "proc", "ps", "bs", "op", "net", "ol", "et", "js", "conn", "ss", "org", "Os", "ns", "base", "obj", "si", "boot", "kit", "oid", "osc", "ros", "oos", "los", "rss", "vs", "o", "mot", "us", "oper", "es", "oc", "acs", "ot", "object", "ou", "s", "pos", "p", "ks", "cot", "obs", "oss", "at", "so", "as", "bos", "ori", "otes", "osi", "io", "ds", "out"], "i": ["phi", "di", "ri", "xi", "hi", "x", "qi", "u", "ix", "ci", "li", "dim", "eni", "bi", "it", "uri", "mi", "n", "ip", "si", "pi", "I", "multi", "id", "index", "ai", "chi", "r", "iu", "o", "ii", "k", "c", "p", "y", "ki", "b", "mini", "ui", "ni", "zi", "gi", "ami", "fi", "yi", "e", "l", "start", "io", "oi", "ie", "ini", "v", "ti", "j", "info"], "in_ch": ["out_che", "linekche", "inacche", "in_cho", "in1ich", "out_chn", "name_che", "in__che", "namexch", "inkch", "out_cher", "inacch", "in__cht", "out_ich", "out_char", "line_tch", "name_ach", "inPchn", "line_ch", "in__cha", "in_che", "inxch", "linekch", "inxchip", "namexach", "inqch", "in_chip", "inktch", "linektch", "inxche", "inxach", "inacchn", "name_cho", "inPchar", "namexcho", "in_chn", "inqchn", "inPsch", "inxtch", "inacich", "in_cha", "in_ich", "in_ach", "inkche", "out_sch", "line_che", "in__ch", "in1chn", "in1che", "in_chi", "inPche", "inkchip", "in_char", "line_chip", "in_ech", "in_cher", "name_ch", "in_tch", "out_chi", "inqsch", "out_cht", "inPch", "in_cht", "out_cha", "in_sch", "namexche", "inPcher", "inxcho", "linekchip", "out_ech", "in1ch", "inqche"], "out_ch": ["out_che", "out_chn", "outxchan", "in_chan", "in_cur", "again_sch", "outxcha", "out_ich", "out_chip", "again_chip", "again_chart", "out_char", "in_che", "again_ch", "outPcha", "out_ach", "outxCh", "outedchan", "in_Ch", "in_chn", " out_Ch", "out_chart", "out_cur", "in_cha", "in_ich", "outerch", "in_ach", "out_sch", "outPche", "out_chan", "in_chi", "outerchar", "outedch", " out_chip", "in_char", "outPch", "outxch", "outedCh", "out_Ch", "out_chi", "out_cht", "in_cht", "out_cha", "outPchar", "outerche", " out_chan", "in_sch", "outercha", "outedchip"], "nb_chapters": ["nb_achangers", "nb_shapters", "nb_chants", "nb_hars", "nb_anchisodes", "nb_shannels", "nb_choases", "nb_changers", "nb_quats", "nb_Chants", "nb_anchannels", "nb_Chars", "nb_cheors", "nb_chatisodes", "nb_achannels", "nb_shants", "nb_Chapters", "nb_cheisodes", "nb_anchases", "nb_achats", "nb_Channels", "nb_cheannels", "nb_chatapters", "nb_chatannels", "nb_chases", "nb_chators", "nb_choapters", "nb_anchors", "nb_chars", "nb_chisodes", "nb_chors", "nb_channels", "nb_quannels", "nb_quangers", "nb_achapters", "nb_cheapters", "nb_hants", "nb_hapters", "nb_chats", "nb_cheats", "nb_cheases", "nb_choannels", "nb_choors", "nb_anchapters", "nb_quapters", "nb_shars", "nb_cheangers", "nb_hannels"]}}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 18477, "substitutes": {"rec": ["disc", "track", "ck", "inc", "ac", "cache", "xml", "cur", "form", "reg", "exec", "rel", "prev", "req", "bb", "record", "enc", "Record", "cl", "rem", "irc", "co", "change", "con", "doc", "win", "data", "ctx", "ec", "exc", "pre", "oc", "ref", "c", "ic", "Rec", "abc", "resp", "re", "comment", "acc", "rc", "mc", "REC", "history", "ack", "sync"], "event": ["received", "resource", "command", "type", "name", " Event", "instance", "xml", "source", "x", "document", "date", "error", "view", "message", "record", "id", "address", "index", "input", "data", "ace", "exc", "time", " exception", "ce", "object", " record", "value", "update", "package", "image", "handler", "Event", "ev", "issue", "ception", "row", "events", "vent", "attribute"], "datasize": [" datasiz", "datacite", "datacizing", " datacite", "datassize", "datacsize", "datatssize", "datASizes", "datASize", " datasIZE", " datacsize", "datasesize", " datasizes", "datasesiz", "datASIZE", "datasiz", "datasesIZE", "datasesizes", "datatsizing", " datasite", "datalsize", "datacize", "datarsite", "datatsite", "datasite", "datasizes", " datacizing", "datASiz", " datacize", " datasizing", " datASizes", " datassize", "datarsizing", "datalsizes", "datalsIZE", " datASiz", "datasIZE", "datarssize", "datarsize", "datatsize", "datalsiz", "datasizing", " datASize", " datASIZE"], "idx": ["IDxc", "inx", " idxc", "idxp", "Idc", " idc", " idxp", "indx", " idf", "IDf", "Idx", "Idxs", "indX", "Idf", "inxc", "Idz", "idxs", "idf", "Idxc", "idex", "IdX", "sidx", " idxs", "Idxp", "IDx", "indxc", "inX", "idxc", "idexc", "IDz", " idz", "sidxc", "ideX", "indxp", "idX", "idc", "sidX", "sidxs", " idX", "inxs", "idec", "idz"], "rec_off": ["recFoff", "rec8offset", "recFoffs", "rec_none", "Rec_offset", "recdover", " rec_wo", "rec_end", "rec___oa", "recPoffer", "recdoffer", "rec_wo", "record_on", "rec__OFF", "Rec_len", "REC_off", "Rec_Off", "Rec_none", "rec__off", "rec__offs", "rec_oa", " rec_oa", "record_offs", " rec_len", "Rec_offs", "RECdOff", "rec2OFF", "record_output", "REC_Off", "rec_over", "recPOff", "REC_over", "REC_offer", "rec_num", "rec___num", "rec_OFF", "RECdoff", "Rec_online", "recfonline", "Rec_OFF", "rec2offs", " rec_online", "rec_offs", "receroff", " rec_offer", "rec_on", "recdOff", "rec_output", "Rec_offer", "rec8on", "rec_len", " rec_offs", "rec8off", "rec8offs", "rec2off", "rec8offer", "recfoff", "rec_Off", " rec_end", "record_OFF", "recdoff", "rec_online", "rec_offset", "recPoff", "recernone", "rec___offs", "recFon", "rec2len", "Rec_off", "recFoutput", "rec___off", "recfoffer", "record_off", "RECdover", "rec8len", "rec__len", "Rec_on", "receronline", "record_len", "recfend", "rec8Off", "rec_offer", "receroffs", "recPover", " rec_num", "RECdoffer"], "old_idx": ["old_indg", "old_ridxc", "old_idex", "old_idxs", "old_idexe", "old_itxs", "old_index", "old_itx", "old_indx", "old_ridxx", "old_ridxe", "old_vidx", "old_itex", "old_endc", "old_itexc", "old_idxx", "old_idux", "old_endg", "old_Idx", "old_ridx", "old_itg", "old_idz", "old_indxe", "old_Idxc", "old_indxx", "old_vidxc", "old_indy", "old_idc", "old_itc", "old_idy", "old_endxs", "old_idxc", "old_vidxi", "old_vidxx", "old_itez", "old_idg", "old_idxi", "old_indn", "old_vidy", "old_Idux", "old_idexx", "old_indc", "old_videx", "old_idn", "old_iden", "old_iteux", "old_ridn", "old_vidz", "old_indxs", "old_Idz", "old_endx", "old_indxi", "old_ridz", "old_idxe"], "new_idx": ["new_pidy", "new_intx", "new_ipy", "new_Idy", "new_indz", "new_Idxc", "new_Idn", "new_indx", "new_indv", "new_aidpx", "new_Idx", "new_Idz", "new_Idpx", "new_aidy", "new_pidz", "new_Idv", "new_intpx", "new_idxc", "new_ipx", "new_idv", "new_indX", "new_aidx", "new_ipw", "new_IdX", "new_aidn", "new_pidxc", "new_idw", "new_Idw", "new_ipz", "new_idX", "new_inty", "new_pidx", "new_idz", "new_idpx", "new_idy", "new_idn", "new_intn"]}}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 18493, "substitutes": {"zSign": ["jSign", "zenSk", "ZDig", "tzSign", "xBig", " zRound", "zSc", "xReg", "zoRound", "zSize", "zBig", "tzStep", "ZExp", "zoneSc", "zoDig", "xSk", "zRound", "xSpec", "xSc", " zStep", "jSpec", "zenSpec", "zSpec", "zoneReg", "jBig", "zoneSign", "zenStep", "tzExp", "zReg", "jSc", "zoExp", " zDig", "zDig", " zSize", "zenSc", "zenBig", "ZSign", "zenSign", "zStep", "ZRound", "tzSize", "zenSize", "xSign", "zSk", "zoneSk", "zenExp", "zenReg", "zoSign"], "zExp": [" zScale", "zhSc", "zhSec", "zenScale", "zeExp", "izExpl", "izInc", "zhPlus", " zexp", " zEnd", "zenExpl", "zenSc", "zenexp", "zInc", "zenFe", " zEXP", "zExec", "zeSec", "izDiv", "zhRes", "zhStep", "zeScale", "zhLeg", "zSc", "zhExpl", "izEnc", "ZExp", "zPos", " zPos", "zEXP", "zipRes", "zhExec", "ziEx", "zenEx", "izImp", "zhImp", "ZEnd", " zSec", "zExpl", "izStep", "zhEx", " zExec", "zImp", "zenExp", "zScale", "zSec", "wPos", "izLeg", "zEnd", "izEx", "zEnc", "ziDiv", "zenExec", "zenSec", "zhexp", "zhPos", " zEm", "zFe", "zipInc", "zEm", "zPlus", "zexp", " zSc", "izPlus", "zenPlus", "zeFe", "izSec", "zenEm", "zRes", " zEnc", "zStep", "zenImp", "izRes", "wExp", "zipExp", "zLeg", " zEx", " zDiv", " zStep", "wexp", " zFe", "izExp", " zLeg", "zEx", "wEXP", "Zexp", "zhInc", "ziEnc", "zenEnd", "ziExp", "ZEm", "zhExp", "zDiv", "zhEXP", "zipSec"], "STATUS_PARAM": ["STATUS_ARAMS", "STATUS_PARAME", "STATUS_VAR", "STATUS_ARAR", "STATUS_PARAMS", "STATUS_ARAM", "STATUS_VAM", "STATUS_PAR", "STATUS_PAMS", "STATUS_ARAME", "STATUS_PAM", "STATUS_PAME", "STATUS_VAMS", "STATUS_PARAR", "STATUS_VAME"], "roundingMode": ["boundingOperation", "roundningKind", "rounddingEngine", "roundgingStyle", "roundeningOperation", "roundningMODE", "tungingMode", "roundeningEngine", "roundningOperation", "roundeningModule", "roundeningStyle", "callningMode", "roundationConfiguration", "roundingStyle", "roundeningKind", "callingMODE", "tuningMode", "pooleringMac", "accountingEngine", "roundpingMODE", "accountingConfiguration", "callningModule", "boundingModule", "boundingMODE", "roundlingKind", "tuningMODE", "roundgingEngine", "roundingMac", "roundgingMac", "roundingKind", "roundtingMac", "roundgingMethod", "roundlingModule", "roundingConfiguration", "roundingMethod", "poolingMode", "pooleringMode", "roundningModule", "accountdingEngine", "roundationEngine", "roundpingStyle", "boundingEngine", "callningMODE", "accountdingMode", "tungingMethod", "boundlingMode", "roundgingMODE", "roundningStyle", "tungingStyle", "rounddingMODE", "roundpingMode", "roundingOperation", "roundpingMethod", "boundeningMODE", "roundlingOperation", "poolingMODE", "roundtingMODE", "accountdingConfiguration", "rounddingStyle", "boundeningMode", "roundingEngine", "boundlingModule", "roundningMode", "rounderingMODE", "rounderingMac", "roundningEngine", "tuningStyle", "roundlingMode", "roundingModule", "accountingMode", "rounderingMode", "boundingStyle", "roundingMODE", "roundtingMode", "rounddingConfiguration", "tuningMethod", "rounddingMethod", "roundeningMODE", "roundeningMode", "boundeningStyle", "boundlingOperation", "boundeningEngine", "pooleringMODE", "boundingKind", "roundgingModule", "roundationMode", "roundgingMode", "boundingMode", "poolingMac", "callingMode", "tungingMODE", "boundlingKind", "roundgingConfiguration", "rounddingMode", "callingModule"], "roundNearestEven": ["roundNeutralEven", "roundNehesteven", "roundNaresteven", "roundNeesteven", "roundNearereven", "roundnearesteven", "roundNelderEnd", "roundnearestHalf", "roundNearestHalf", "roundneestOne", "roundNeestEven", "roundNeutralOne", "roundnearestEven", "roundNearesteven", "roundneesteven", "roundNeutralEnd", "roundNeestOne", "roundNarestEven", "roundNeestHalf", "roundNehestOne", "roundNearestOne", "roundneestHalf", "roundNeldereven", "roundNearestEnd", "roundNeuristiceven", "roundnearestOne", "roundNehestHalf", "roundNeutralHalf", "roundNutraleven", "roundNearerEven", "roundNutralEven", "roundNelderEven", "roundNeuristicEven", "roundneestEven", "roundNehestEven", "roundNeutraleven", "roundNeuristicEnd"], "roundIncrement": ["roundIncreasemental", "roundDecrement", "RoundincreMENT", "roundDecrements", "roundInterution", " roundIncrese", " roundIncregment", "Roundincrements", "roundFragment", "roundAugution", "roughIncrements", "roundDecreution", "roundSegment", "roundIncreant", " roundIncreasese", "roundAugmentation", "roundFragmented", "roundIncremental", "rowSegmentation", "roundSegreement", "rollIncrement", "roundIncreaseMENT", " round\n", "roundMeasurements", "roundincrementation", "rowInterment", "roundFragse", "Roundincremented", "roundIncrementation", "roundIncreution", "roundincrement", "roundn", " roundn", "roundSegmented", "rollIncrese", "roundIncregment", "row\n", "roughIncrelex", "rowInterration", "RoundIncremented", "rollDecrementation", "roundAdjustments", "roundincrements", "rowIncreant", "roundSegmental", "rowIncrereement", " roundIncremental", "roll\n", "rowSegment", "roundDecregment", "RoundIncrement", "rowSegments", "roundIncreasese", "roundInterant", " roundIncreasementation", "roundSegments", "roundAdjustlex", "rowIncrement", "roundAugmented", "roundSegMENT", "roundAugMENT", "rollDecrese", "roundincrereement", "roundIncreMENT", "roundInterment", "roundincreMENT", "rollIncreMENT", " roundIncreasement", "rown", "roughMeasureral", "rollDecrement", "roundIncreaseution", "roundSegmentation", " roundIncrementation", "roundAugse", "roundIntermentation", "roughMeasurements", "roundDecreMENT", " roundIncremented", "roundIncreasement", "roundFragmentation", "roughMeasurement", "roundMeasurement", "roundAdjustment", "roundIncrereement", "roughIncreral", "RoundIncrements", "roundDecrereement", "roundIncreaseration", "roundAugment", "roundIncrese", "rowInterant", "Roundincrement", "round\n", "roundIncreration", "roughIncrement", "rollIncreution", "rowIncrementation", "roundIncreasegment", "roundDecrementation", " roundIncreasegment", "rowSegreement", "rolln", "roundDecremented", "rollDecreMENT", "roundincreration", "roundincreant", " roundIncreasemented", "roundInterration", "rollIncremented", "roundDecrelex", "roundIncrelex", "roundIncremented", "roundMeasurelex", "roundIncreasemented", "roundFragmental", "rowIntermentation", "rowIncrements", "rowIncreration", "RoundIncreMENT", "roundMeasureral", " roundIncreasemental", "rollIncrementation", "rollDecremented", "roundDecrese", "roundIncreral", "roundAuggment", "roughMeasurelex", "roundAdjustral", "roundIncreaseant", "roundincremented", "rollDecreution", "roundIncreasementation", "roundDecreral", "roundIntermented", "roundincrese", "roundIncrements"], "roundBits": ["rowBITS", " roundBBizes", "sortBBits", "roundKites", " roundBandits", " roundBandbits", "roundSBizes", "roundBsit", "roundRITS", "roundFounds", "sortBBITS", "roundBsITS", "sortBith", "roundBITS", "rowBugs", "roundWbits", " roundBounds", " roundBBatches", "roundBith", "roundFuts", "rowBit", " roundBITS", "roundRit", "sortBBith", "roundBugs", "roundFITS", " roundBizes", "roundClith", "roundSBatches", "roundWith", " roundBites", "roundbugs", "roundPbits", "roundSBites", "roundBBizes", " roundBBites", "roundKits", "roundBit", "roundBBbits", "roundbITS", "roundFit", "roundRits", " roundBBits", "roundWits", " roundBbits", "rowBits", "roundBBites", "roundBandbits", " roundButs", "rowbITS", "rowbits", "roundBounds", "rowbugs", "roundBatches", "roundBandits", "roundPITS", "roundBsits", "roundBbits", "roundPits", " roundBandITS", "roundBandit", "roundClits", "roundBsugs", " roundBanduts", "roundClbits", "roundBBITS", "roundSBits", "roundButs", " roundBit", "roundbits", "roundBBits", "roundKatches", "roundFbits", "roundBBatches", "sortBits", "sortBbits", "sortBITS", "roundKizes", "roundPuts", "roundClITS", "roundBizes", "roundBandugs", "roundBanduts", "roundWITS", " roundBatches", "sortBBbits", "roundBites", "roundBandITS", "roundbit", "roundFits", "roundRounds", "rowbit", "roundBBith"], "isTiny": ["isTwig", "isWig", "isTiger", "isNick", "isTig", "IsTidy", "isPunky", "IsNotiger", "IsNotick", "isWick", "IsTiger", "isNotiger", "isNotiny", " isTig", "isDick", "isDidy", "isDiny", "isPig", "isWiny", "isPidy", "isDiger", "isPiny", "isNig", "IsNotiny", "isNiny", " isPunky", "isPick", " isTng", " isTick", " isPig", "isNotick", "IsTiny", "isNotidy", "IsTick", "IsNotidy", "isTick", "isWunky", "isTwick", " isPiny", "isTunky", "isPng", "isTwiny", "isTidy", "isNng", "isPiger", " isPick", " isTunky", "isTng", "isTwunky"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "substitutes": {"entry": ["inner", "get", "component", "session", "match", "extra", "command", "cache", "end", "connection", "view", "record", "plugin", "parser", " Entry", "engine", "enter", "comment", "insert", "package", "item", "image", "update", "existing", "server", "ry", "export", "name", "source", "it", "add", "si", "parse", "index", "data", "cell", "archive", "import", "key", "lock", "element", "row", "se", "comp", "the", "cat", "error", "Entry", "feed", "ge", "module", "config", "entity", "address", "ace", "lc", "ries", "post", "ent", "info", "option", "inc", "cel", "cur", "member", "table", "enc", "ae", "reader", "ce", "service", "try", "e", "ie", "event"], "size": ["core", "set", "scale", "handle", "cache", "sized", "sh", "speed", "code", "block", "engine", "c", "limit", "content", "strength", "weight", "bytes", "send", "sec", "shape", "empty", "use", "mode", "cm", "timeout", "name", "gc", "fee", "Size", "location", "si", "memory", "ize", "max", "external", "data", "s", "ui", "num", "sync", "offset", "security", "sn", "length", "number", "large", "SIZE", "small", "capacity", "address", "body", "file", "shift", "new", "six", "member", "len", "storage", "path", "sum", "loc", "time", "unit", "gz", "count", "e", "from", "password"], "address_index": ["position_index", "ip__id", "address_id", "address2id", "position2offset", " address_position", " address_slice", "position_prefix", "address2slice", "address_prefix", "address_slice", "position2prefix", "ip__slice", "address_offset", "address2Index", "address_list", "position_offset", "address2prefix", "ip_slice", " address_address", "position2Index", "position_Index", "address__index", "address__slice", "address__address", "ip__index", "ip_start", "ip_index", "ip__start", " address_ind", "address__id", "address_position", "address_address", " address_list", "address_start", "position2index", "address_length", "address__list", "address__start", "address__ind", "ip_id", "address_ind", " address_length", "address2index", "address_Index", "address2offset", "address2start"], "vaddr_base": ["vaddr_based", "vsp__count", "vsp__base", "vaddr_bas", "vaddr_index", "vaddr__len", "vsp_base", "vsp_Base", "vad_bi", "vad_Base", "vrt_area", "vaddr__count", "vsp__len", "vad_full", "vattr_address", "vaddr2base", "vaddress_bas", "vdr_prefix", "vaddr_address", "vaddr_bi", "vdr_index", "vaddr_home", "vaddr2Base", "vaddr_area", "vsp__Base", "vaddr_cache", "vsp_count", "vaddress_based", "vaddr_prefix", "vaddr__Base", "vrt_bas", "vaddr_len", "vaddress_home", "vsp_len", "vaddr_Base", "vad_base", "vattr_bas", "vdr_bas", "vattr_full", "vaddr2cache", "vaddr_full", "vattr_base", "vaddr_count", "vaddress_base", "vdr_base", "vrt_base", "vaddr__base", "vaddr2area"], "pfns": ["vfxnes", "psfirs", "pfcn", "pfsails", "pdefnc", "pfxnes", "pafn", "pdfns", " pfts", "Pcfails", "pofails", "tfls", "vfnes", "pfn", "pfdfs", "pdefns", "tfcns", "pfails", "pdfnc", "prefks", "psfns", "pfks", "pcfails", "pafns", "prefirs", "vfks", "poffs", "pfsls", "pofls", "pcfbs", "tfcn", "tfn", "pfcnc", "Pfbs", "pfxns", "pofns", "pfcls", "Pcfbs", "pafls", "pfnc", "Pfks", " pfnc", "vfirs", "pfxks", " pdefns", "prefnes", "pfirs", "vfxirs", "Pcfks", "pfsns", "pafnc", "pfcns", "pcfts", " pdefts", "pofks", "pcffs", " pdefls", "pdfts", "pfdks", "prefns", "tfcnc", "psfks", "pfsbs", "pffs", "vfxns", "psfnes", "Pcffs", "pcfn", "Pfns", "pcfnc", "tfns", "vfns", "pcfns", "pfts", " pdefnc", "Pcfns", "pfnes", "pdefls", "pfdls", "pofbs", "tfcls", "tfnc", "pfls", "pfdns", "pcfls", "Pffs", "pdefts", "Pcfls", "pfbs", "Pfls", " pfls", "pfxirs", "pcfks", "pdfls", "vfxks", "Pfails"], "err": ["dr", "phi", "str", "inner", "icer", "rr", "f", "erg", "result", "sp", "inc", "Er", "yr", "runner", "res", "arm", "error", "lr", "rh", "req", "test", "ir", "rar", "len", "eor", "ch", "finder", "aster", "ise", "ner", "ar", "r", "status", "der", "fr", "late", "errors", "aa", "iter", "loc", "gr", "conf", "p", "ind", "mr", "nr", "resp", "er", "msg", "nor", "Error", "rc", "attr", "fi", "cb", "rage", "rn", "acer", "ler", "bug", "ok", "arr", "ini", "order", "fer"], "i": ["phi", "di", "inner", "f", "ri", "xi", "hi", "x", "qi", "ix", "u", "ci", "li", "in", "ji", "bi", "eni", "uri", "mu", "d", "it", "info", "ip", "n", "pi", "I", "si", "len", "id", "ti", "multi", "init", "r", "index", "ai", "chi", "iu", "o", "ii", "c", "p", "y", "b", "z", "mini", "ei", "ui", "ni", "zi", "gi", "fi", "yi", "e", "l", "ori", "start", "a", "io", "oi", "ie", "ini", "v", "mi", "j", "m"]}}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n", "idx": 18513, "substitutes": {"dev": ["local", "self", "di", "server", "development", "debug", "prom", "grad", "f", "this", "cmd", "dd", "conn", "plug", "dm", "end", "error", "d", "test", "valid", "ch", "sd", "config", "av", "pu", "user", "pp", "img", "pack", "data", "diff", "Dev", "block", "raw", "w", "conf", "app", "de", "var", "b", "current", "def", "dist", "dem", "package", "dep", "priv", "home", "ev", "dp", "pro", "driver", "bug", "dn", "device", "v", "ds", "plugin", "md", "ver", "info"], "p": ["g", "cp", "client", "f", "ap", "pc", "sp", "ps", "tp", "wp", "jp", "queue", "op", "u", "pipe", "lp", "po", "t", "param", "q", "api", "point", "d", "np", "py", "n", "bp", "ip", "press", "plugin", "i", "pi", "pm", "pg", "cop", "pp", "pa", "pb", "pl", "vp", "parser", "o", "w", "pre", "app", "c", "P", "fp", "s", "patch", "post", "pe", "b", "er", "process", "per", "gp", "e", "l", "port", "pid", "dp", "a", "mp", "part", "v", "pr", "j", "m"], "ep": ["EP", "eps", "cp", "imp", "yp", "ap", "pc", "sp", "tp", "wp", "jp", "queue", "op", "pipe", "inc", "lp", "eff", "el", "org", "exec", "point", "ip", "peer", "job", "enc", "xp", "kg", "eng", "pp", "vp", "ef", "eb", "ec", "ee", "esp", "ew", "loc", "ext", "sk", "app", "ak", "P", "fp", "channel", "pe", "er", "gp", "elf", "ng", "element", "Ep", "ev", "e", "dp", "ek", "mp", "env", "eg", "ah", "amp"], "ret": ["RET", "reply", "val", "html", "f", "cat", "pt", "result", "fire", "ben", "alt", "res", "success", "repl", "reg", "sr", "len", "fun", "mt", " RET", "pet", "code", "r", "pat", "rev", "xt", "rets", "att", "ref", "det", "nt", "bot", "sb", "mer", "hash", "resp", "re", "ur", "en", " Ret", "ft", "rc", "Ret", "bf", "mem", "arg", "lit", "rt", "rep"]}}
{"project": "FFmpeg", "commit_id": "64e105e051ca3e5088b0db64551244482b2836b4", "target": 0, "func": "static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)\n\n{\n\n    DynBuffer *d = opaque;\n\n    int new_size, new_allocated_size;\n\n    UINT8 *new_buffer;\n\n    \n\n    /* reallocate buffer if needed */\n\n    new_size = d->pos + buf_size;\n\n    new_allocated_size = d->allocated_size;\n\n    while (new_size > new_allocated_size) {\n\n        if (!new_allocated_size)\n\n            new_allocated_size = new_size;\n\n        else\n\n            new_allocated_size = (new_allocated_size * 3) / 2;\n\n    }\n\n    \n\n    if (new_allocated_size > d->allocated_size) {\n\n        new_buffer = av_malloc(new_allocated_size);\n\n        if (!new_buffer)\n\n            return;\n\n        memcpy(new_buffer, d->buffer, d->size);\n\n        av_free(d->buffer);\n\n        d->buffer = new_buffer;\n\n        d->allocated_size = new_allocated_size;\n\n    }\n\n    memcpy(d->buffer + d->pos, buf, buf_size);\n\n    d->pos = new_size;\n\n    if (d->pos > d->size)\n\n        d->size = d->pos;\n\n}\n", "idx": 18518, "substitutes": {"opaque": ["opca", "apacity", "opusacity", "OPca", "OPaque", "ospaque", "operec", "opaques", "opec", "operacity", "operca", "OPec", "OPacity", "ospacity", "opacity", "opusga", "apga", "operga", "opga", "opusaques", "ospca", "ospec", "apaque", "apaques", "operaques", "opusaque", "operaque"], "buf": ["header", "vec", "map", "f", "src", "uf", "cmd", "uc", "queue", "bc", "array", "window", "buffer", "wb", "fd", "pub", "pb", "img", "ctx", "loc", "rb", "c", "xff", "pos", "cv", "b", "fb", "rc", "cb", "num", "seq", "bf", "gb", "buff", "v", "alloc", "offset"], "buf_size": ["buf2loc", "grab_SIZE", "buf64num", "buf_loc", "buf_name", "buf64name", "exc_Size", "bufksize", "grab_sized", "uf_size", "buf64large", "exclexSize", "uf_large", "buflexSize", "grab_loc", "bufkloc", "grabkSIZE", "bufksized", "buf_num", "grabksize", "buf_sized", "buflexsized", "buflexsize", "exc_size", "exc_large", "buf_SIZE", "grab_size", "uf_name", "uf_num", "bufkSIZE", "buf2sized", "exclexlarge", "grabksized", "buf64size", "buf_large", "exclexsize", "grabkloc", "buflexlarge", "buf2size", "exc_sized", "buf_Size", "buf2SIZE", "exclexsized"], "d": ["g", "dr", "self", "cd", "di", "dh", "bd", "dc", "D", "f", "ud", "pd", "new", "x", "u", "dd", "del", "td", "t", "ad", "dm", "end", "old", "dos", "n", "fd", "gd", "sd", "i", "id", "od", "db", "dt", "r", "dom", "data", "diff", "dl", "mad", "w", "ded", "wd", "c", "p", "s", "ld", "da", "dad", "nd", "b", "xd", "did", "z", "defined", "done", "vd", "ed", "e", "dp", "l", "dat", "dn", "v", "ds", "plugin", "md", "j", "m"], "new_size": ["uniquelexshape", "next_size", "new_width", "new67size", "newworklocation", "next_position", " new_shape", "new___size", "newlwidth", "new5shape", "newlexlocation", "large_shape", "newWorklocation", "large_sum", "newlexchannel", "new_loc", "new___timeout", "new_sum", " new_scale", "newWorkshape", "new_shape", "unique_size", "new_sized", "unique_shape", "fresh_size", "new67shape", "fresh___size", "newlexshape", "newlposition", "unique_location", "new_channel", "fresh_sized", "new5size", "large_size", "newworkshape", "new67sum", "new_ize", "newworkchannel", "new_location", "next_loc", "new___ize", "new___sized", "new53size", "newWorksize", "uniquelexsize", "uniquelexchannel", "new5sum", "fresh_ize", "fresh___sized", "uniquelexlocation", "new53loc", "newlsize", "newlexscale", "newlexloc", "new_timeout", "next_width", "newWorkchannel", "unique_channel", "large_ize", "new_position", "fresh_timeout", " new_loc", "newlloc", "new53shape", "newworksize", "new53scale", "new_scale", "new67ize", "newlexsize", "fresh___timeout", "new5ize", "fresh___ize"], "new_allocated_size": ["new_allocated_line", "new_allocation_scale", "new_allowed_size", "new_allocatedacsize", "new_allocated_name", "new_allocatedsize", "new_allocated_scale", "new_allocatedalname", "new_allocation_name", "new_allocatedallsize", "new_allocation_cap", "new_allocation_eni", "new_allocated_eni", "new_allocatedlexoffset", "new_allocatedableaddress", "new_allocated_ize", "new_allocated_offset", "new_allocatedallcap", "new_allocatedaleni", "new_allocatedallcapacity", "new_allocatedacize", "new_allocated_needed", "new_allocatedalsize", "new_allocatedxsize", "new_alloc_size", "new_allocated_cap", "new_allocatedityscale", "new_allocation_offset", "new_allowed_count", "new_allocation_ize", "new_allocatedssize", "new_allocatedxsized", "new_allocation_line", "new_allocatedablecapacity", "new_allocation_length", "new_alloc_capacity", "new_allocated_length", "new_allocated_sized", "new_allowed_address", "new_alloc_scale", "new_allocation_unit", "new_allocateditysize", "new_allocated_unit", "new_allocatedacline", "new_allocation_capacity", "new_allocation_address", "new_allocated_count", "new_allocatedlexize", "new_allocatedsline", "new_allocation_needed", "new_allocation_size", "new_allocated_address", "new_alloc_address", "new_allocated_capacity", "new_allocatedxneeded", "new_allocatedityunit", "new_allocation_sized", "new_allowed_capacity", "new_allocatedlexsize", "new_allocatedablecount", "new_allocatedablesize"], "new_buffer": [" new_byte", "old_size", "new__buffer", " new_position", "new___size", "newJcapacity", "newtheslice", "new_surface", "newthebuffer", " new_buff", " new_extra", "new__position", "new_byte", "new64slice", "new_capacity", "new__size", " new_slice", "new___buffer", "old_buff", "newworkslice", "newlexdevice", "new__byte", "new64size", "newlexbuffer", "newJbuffer", "newthesize", " new_capacity", "old_buffer", "newlexbuff", "old_device", "newthesurface", "newworkbuffer", "new___extra", "newJsize", "new_position", "new64capacity", " new_surface", "new_extra", "newworksize", "newworksurface", "new_buff", "new64buffer", "newJslice", "newlexsize", "new_device", "new___buff", "new_slice"]}}
{"project": "FFmpeg", "commit_id": "20da77449d4427a7152b80e4f9acce6a8c93ee7d", "target": 0, "func": "static inline int RENAME(yuv420_rgb24)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*3 > dstStride[0]) h_size-=8;\n\n    \n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\nYUV2RGB\n\n\t/* mm0=B, %%mm2=G, %%mm1=R */\n\n#ifdef HAVE_MMX2\n\n\t\t\t\"movq \"MANGLE(M24A)\", %%mm4\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(M24C)\", %%mm7\t\\n\\t\"\n\n\t\t\t\"pshufw $0x50, %%mm0, %%mm5\t\\n\\t\" /* B3 B2 B3 B2  B1 B0 B1 B0 */\n\n\t\t\t\"pshufw $0x50, %%mm2, %%mm3\t\\n\\t\" /* G3 G2 G3 G2  G1 G0 G1 G0 */\n\n\t\t\t\"pshufw $0x00, %%mm1, %%mm6\t\\n\\t\" /* R1 R0 R1 R0  R1 R0 R1 R0 */\n\n\n\n\t\t\t\"pand %%mm4, %%mm5\t\t\\n\\t\" /*    B2        B1       B0 */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G2        G1       G0 */\n\n\t\t\t\"pand %%mm7, %%mm6\t\t\\n\\t\" /*       R1        R0       */\n\n\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* G2        G1       G0    */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"psrlq $8, %%mm2\t\t\\n\\t\" /* 00 G7 G6 G5  G4 G3 G2 G1 */\n\n\t\t\t\"pshufw $0xA5, %%mm0, %%mm5\t\\n\\t\" /* B5 B4 B5 B4  B3 B2 B3 B2 */\n\n\t\t\t\"pshufw $0x55, %%mm2, %%mm3\t\\n\\t\" /* G4 G3 G4 G3  G4 G3 G4 G3 */\n\n\t\t\t\"pshufw $0xA5, %%mm1, %%mm6\t\\n\\t\" /* R5 R4 R5 R4  R3 R2 R3 R2 */\n\n\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm5\t\\n\\t\" /* B5       B4        B3    */\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" /*       G4        G3       */\n\n\t\t\t\"pand %%mm4, %%mm6\t\t\\n\\t\" /*    R4        R3       R2 */\n\n\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" /* B5    G4 B4     G3 B3    */\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"pshufw $0xFF, %%mm0, %%mm5\t\\n\\t\" /* B7 B6 B7 B6  B7 B6 B6 B7 */\n\n\t\t\t\"pshufw $0xFA, %%mm2, %%mm3\t\\n\\t\" /* 00 G7 00 G7  G6 G5 G6 G5 */\n\n\t\t\t\"pshufw $0xFA, %%mm1, %%mm6\t\\n\\t\" /* R7 R6 R7 R6  R5 R4 R5 R4 */\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"pand %%mm7, %%mm5\t\t\\n\\t\" /*       B7        B6       */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G7        G6       G5 */\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm6\t\\n\\t\" /* R7       R6        R5    */\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\\\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 16(%1)\t\t\\n\\t\"\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\n\n#else\n\n\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm0, %%mm5\t\t\\n\\t\" /* B */\n\n\t\t\t\"movq %%mm1, %%mm6\t\t\\n\\t\" /* R */\n\n\t\t\t\"punpcklbw %%mm2, %%mm0\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"punpcklbw %%mm4, %%mm1\t\t\\n\\t\" /* 0R0R0R0R 0 */\n\n\t\t\t\"punpckhbw %%mm2, %%mm5\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpckhbw %%mm4, %%mm6\t\t\\n\\t\" /* 0R0R0R0R 2 */\n\n\t\t\t\"movq %%mm0, %%mm7\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"movq %%mm5, %%mm3\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpcklwd %%mm1, %%mm7\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"punpckhwd %%mm1, %%mm0\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"punpcklwd %%mm6, %%mm5\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"punpckhwd %%mm6, %%mm3\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"movq %%mm7, %%mm2\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"psllq $40, %%mm7\t\t\\n\\t\" /* RGB00000 0 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* RGB00000 1 */\n\n\t\t\t\"psllq $40, %%mm5\t\t\\n\\t\" /* RGB00000 2 */\n\n\t\t\t\"psllq $40, %%mm3\t\t\\n\\t\" /* RGB00000 3 */\n\n\n\n\t\t\t\"punpckhdq %%mm2, %%mm7\t\t\\n\\t\" /* 0RGBRGB0 0 */\n\n\t\t\t\"punpckhdq %%mm6, %%mm0\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"punpckhdq %%mm1, %%mm5\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"punpckhdq %%mm4, %%mm3\t\t\\n\\t\" /* 0RGBRGB0 3 */\n\n\n\n\t\t\t\"psrlq $8, %%mm7\t\t\\n\\t\" /* 00RGBRGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* GB000000 1 */\n\n\t\t\t\"por %%mm0, %%mm7\t\t\\n\\t\" /* GBRGBRGB 0 */\n\n\t\t\tMOVNTQ\" %%mm7, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\n\n\t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */\n\n\t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */\n\n\t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n#endif\n\n\t\t     \n\n\t\t     \"add $24, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\t\t     \n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n    return srcSliceH;\n\n}\n", "idx": 18523, "substitutes": {"c": ["g", "cs", "cd", "cp", "cm", "f", "pc", "cal", "ac", "nc", "u", "ci", "t", "conn", "d", "n", "ch", "enc", "h", "con", "ctx", "ec", "lc", "w", "ca", "conf", "oc", "ce", "k", "p", "s", "cc", "cv", "cam", "vc", "b", "tc", "m", "ct", "rc", "mc", "e", "l", "ctrl", "C", "cu", "xc", "cn"], "src": ["scl", "grad", "bs", "proc", "reflect", "inst", "uc", "source", "sq", "sr", "req", "conv", "lib", "config", "support", "img", "pack", "rss", "usr", "iv", "ctx", "st", "loc", "rb", "sb", "cv", "gl", "ssl", "sur", "sl", "sup", "dist", "desc", "sel", "rc", "url", "sec", "dest", "seq", "scenes", "upp", "scene", "text", "attr", "sub", "start", "sc", "rob", "rect", "secure", "host"], "srcStride": ["srcStrride", "rcStrite", "srcStrate", " srcScrite", " srcStro", "srcScbit", "srcCride", "srcStandute", "srcStandrip", " srcScide", "srcStandroute", "srcStandride", "srcStrip", "rcScrite", "rcScbit", "rcStrate", "srcSlride", "srcStri", " srcStrite", "srcstr", "srcStrbit", "srcEstrite", "srcstro", "srcStrrite", "srcstride", "gradSTute", "srcScri", "srcSTrip", "srcStro", "srcScrite", "rcScrate", "srcCide", " srcScride", "srcStroute", "rcStride", "srcSTroute", "srcStute", "srcStide", "rcStrip", "srcStgrade", "srcstide", "srcEstide", "srcStandgrade", "rcScride", "srcSlr", "srcScride", "srcStandide", "gradSTrip", "srcScrip", "srcEstride", "gradSTride", " srcScri", "rcScide", "srcStrite", "srcStr", "gradStride", "srcSlide", "rcStbit", "gradStrip", "srcShride", "srcScide", " srcStgrade", "srcShrip", " srcStr", "srcShroute", "srcSTbit", "srcSlro", "srcCrip", "srcEstgrade", " srcStide", "gradStroute", "srcSTride", "srcShute", "srcStbit", "srcEstri", "rcStide", " srcStri", "gradSTroute", "srcStandrite", "srcScrate", "srcCri", "srcCrite", "srcStrrate", "srcSTrite", "srcSTrate", "rcScrip", "srcSTute", "gradStute"], "srcSliceY": ["srcFliceY", "srcSlaceY", "srcSlenseB", "srcSlenseY", "srcSlaceB", "srcPliceB", "srcSlaceX", "srcSlICEY", "srcSlaseB", "srcSliceW", "srcSlenseH", "srcFliceX", "srcPliceH", "srcSlaceH", "srcFliceB", "srcSlICEX", "srcPlaseB", "srcPliceY", "srcFliceW", "srcSlaseX", "srcSlashW", "srcSlaceW", "srcSlaseY", "srcFlICEX", "srcSlaseH", "srcSliceB", "srcSlashB", "srcFlICEW", "srcSlICEW", "srcPlaseY", "srcPliceX", "srcSliceX", "srcPlaseH", "srcFlICEB", "srcPlaseX", "srcSlashY", "srcSlashX", "srcSlICEB", "srcFlICEY", "srcSlenseX"], "srcSliceH": ["srcFliceY", "srcSlaceY", "srcSlideY", "srcSlICEY", "srcSlaceX", "srcSliceW", "srcFliceX", "srcSlaceH", "srcSlICEV", "srcSlineX", "srcFliceV", "srcSlICEX", "srcSlICEH", "srcSlideW", "srcFlICEH", "srcFliceW", "srcSlaceW", "srcSlineY", "srcFlICEV", "srcFlICEX", "srcSlineH", "srcFliceH", "srcFlICEW", "srcSlaceV", "srcSlICEW", "srcSliceX", "srcSliceV", "srcSlideV", "srcSlineW", "srcFlICEY", "srcSlideH"], "dst": [" dsts", " dsc", "Dst", " drc", "inst", "lst", "Dsc", "dsts", "insts", "Dsts", "insrc", "lsts", "Drc", "drc", "dsc", "inrc", "lsrc", "dsrc", " dsrc", "lsc", "Dsrc"], "dstStride": ["dstStend", "dststride", "dstSyncrite", "dstTri", "dsrcstrite", "dstSyncube", "drcStride", "dstCride", "dstCrib", "dsrcStend", "dststend", "dstCrite", "dstStope", "drcCrib", "dstRerve", "dsrcStrite", "drcStrite", "dstScri", "dststube", "dstScrip", "dstScride", "dsrcstube", "dstSterve", "dstScope", "dsrcstend", "dstStrite", "drcStrib", "drcStri", "dstWerve", "dstSTrite", "dstRride", "dstStrip", "drcCerve", "dsrcStride", "dstStri", "dststrite", "dstUride", "dstSyncride", "dstRrite", "dstSTride", "dsrcStube", "dstSyncend", "dstUrip", "drcCride", "dstStube", "dstUri", "dstTride", "drcSterve", "dstWrib", "drcStope", "dstWride", "dstStrib", "drcScride", "dstSTend", "drcCrite", "dstTrip", "dstCerve", "drcStrip", "dstTope", "dstWrite", "drcScri", "dstRrib", "dsrcstride", "dstUope", "drcScrip", "drcScope", "dstSTube"], "y": ["ys", "Y", " Y", "ty", "ky", "vy", "yl", "my", "f", "uy", "ry", "type", "x", "yr", "t", "iy", "ny", "d", "py", "yo", "n", "i", "h", "ye", "year", "oy", "wx", "ady", "zy", "w", "dy", "p", "cy", "sy", "sky", "ay", "z", "yt", "wy", "yd", "xx", "count", "yi", "ya", "gy", "ym", "ey", "hy", "l", "yu", "yy", "yer", "j", "m"], "h_size": ["p_scale", " h_sized", "h2sized", "h2width", " h_loc", "h_SIZE", "h_loc", "h2size", " h_name", "h_width", "p_width", "h2address", " h_scale", "h_sized", " h__scale", " h__SIZE", " h_width", "h_name", " h__ize", " h_SIZE", "h__size", "p_address", "p_size", " h__loc", "h__SIZE", "h2name", "h__scale", " h__name", "h_ize", "h_scale", "h__name", "h2scale", "h__ize", " h__size", "h_address", " h_ize", "h__loc"], "_image": ["ximage", "_jpg", "_img", "ximg", "xjpg", "jimg", "_px", "xpx", "jimage", "jjpg", "jpx"], "_py": [" _di", "_di", "_px", "tph", "_ph", "tpx", "tpy", "tdi", " _px", " _ph"], "_pu": ["__pu", "__pl", "__px", " _pl", "_px", "_gpu", "__gpu", " _gpu", " _px", "_pl"], "_pv": ["_kv", "_ksv", "_kd", "_px", "_psv", "_cpx", "_cpd", "_mpv", "_mpd", "_mpsv", "_pd", "_cpv", "_mpx", "_cpsv", "_kx"]}}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int hex_to_data(uint8_t *data, const char *p)\n\n{\n\n    int c, len, v;\n\n\n\n    len = 0;\n\n    v = 1;\n\n    for(;;) {\n\n        skip_spaces(&p);\n\n        if (*p == '\\0')\n\n            break;\n\n        c = toupper((unsigned char)*p++);\n\n        if (c >= '0' && c <= '9')\n\n            c = c - '0';\n\n        else if (c >= 'A' && c <= 'F')\n\n            c = c - 'A' + 10;\n\n        else\n\n            break;\n\n        v = (v << 4) | c;\n\n        if (v & 0x100) {\n\n            if (data)\n\n                data[len] = v;\n\n            len++;\n\n            v = 1;\n\n        }\n\n    }\n\n    return len;\n\n}\n", "idx": 18529, "substitutes": {"data": ["self", "alpha", "map", "f", "result", "type", "new", "temp", "cache", "parent", "buf", "DATA", "li", "window", "api", "ad", "pad", "array", "buffer", "d", "base", "Data", "i", "memory", "code", "index", "input", "block", "o", "ma", "body", "pos", "da", "b", "value", "slice", "e", "dat", "ata", "a", "wa", "size", "m"], "p": ["g", "cp", "f", "ap", "pc", "sp", "ps", "tp", "jp", "wp", "u", "op", "lp", "po", "t", "q", "api", "py", "point", "np", "d", "n", "bp", "ip", "pi", "i", "pair", "pp", "code", "pa", "vp", "pat", "o", "P", "fp", "s", "pos", "pe", "b", "pointer", "at", "e", "l", "a", "python", "m"], "c": ["g", "cs", "cp", "cm", "dc", "f", "pc", "uc", "x", "u", "ac", "nc", "ci", "bc", "t", "cur", "q", "d", "n", "col", "ch", "i", "enc", "cl", "h", "code", "r", "o", "ec", "lc", "w", "ca", "cf", "k", "ce", "s", "cc", "cy", "vc", "y", "b", "cr", "tc", "ct", "count", "mc", "e", "l", "C", "cu", "xc", "sc", "fc", "m"], "len": ["val", "min", "f", "length", "lv", "split", "ll", "x", "u", "Len", "li", "t", "el", "vin", "d", "n", "base", "i", "id", "r", "code", "rev", "lc", "dy", "iter", "loc", "pre", "fl", "pos", "y", "limit", "line", "b", "sl", "vc", "z", "vert", "le", "en", "count", "e", "cmp", "l", "lin", "size", "ln", "j"], "v": ["g", "val", "f", "uv", "length", "lv", "x", "u", "ci", "t", "vin", "d", "n", "conv", "i", "vi", "h", "r", "va", "iv", "vs", "o", "lc", "w", "k", "s", "y", "vc", "vol", "b", "value", "z", "ve", "vert", "count", "ev", "e", "l", "sv", "vv", "C", "size", "V", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "fa30a0a54854cd291008c065dfaf45d610e3cd04", "target": 0, "func": "static int RENAME(dct_quantize)(MpegEncContext *s,\n\n                            int16_t *block, int n,\n\n                            int qscale, int *overflow)\n\n{\n\n    x86_reg last_non_zero_p1;\n\n    int level=0, q; //=0 is because gcc says uninitialized ...\n\n    const uint16_t *qmat, *bias;\n\n    LOCAL_ALIGNED_16(int16_t, temp_block, [64]);\n\n\n\n    av_assert2((7&(int)(&temp_block[0])) == 0); //did gcc align it correctly?\n\n\n\n    //s->fdct (block);\n\n    RENAME_FDCT(ff_fdct)(block); // cannot be anything else ...\n\n\n\n    if(s->dct_error_sum)\n\n        s->denoise_dct(s, block);\n\n\n\n    if (s->mb_intra) {\n\n        int dummy;\n\n        if (n < 4){\n\n            q = s->y_dc_scale;\n\n            bias = s->q_intra_matrix16[qscale][1];\n\n            qmat = s->q_intra_matrix16[qscale][0];\n\n        }else{\n\n            q = s->c_dc_scale;\n\n            bias = s->q_chroma_intra_matrix16[qscale][1];\n\n            qmat = s->q_chroma_intra_matrix16[qscale][0];\n\n        }\n\n        /* note: block[0] is assumed to be positive */\n\n        if (!s->h263_aic) {\n\n        __asm__ volatile (\n\n                \"mul %%ecx                \\n\\t\"\n\n                : \"=d\" (level), \"=a\"(dummy)\n\n                : \"a\" ((block[0]>>2) + q), \"c\" (ff_inverse[q<<1])\n\n        );\n\n        } else\n\n            /* For AIC we skip quant/dequant of INTRADC */\n\n            level = (block[0] + 4)>>3;\n\n\n\n        block[0]=0; //avoid fake overflow\n\n//        temp_block[0] = (block[0] + (q >> 1)) / q;\n\n        last_non_zero_p1 = 1;\n\n    } else {\n\n        last_non_zero_p1 = 0;\n\n        bias = s->q_inter_matrix16[qscale][1];\n\n        qmat = s->q_inter_matrix16[qscale][0];\n\n    }\n\n\n\n    if((s->out_format == FMT_H263 || s->out_format == FMT_H261) && s->mpeg_quant==0){\n\n\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            MOVQ\" (%2), \"MM\"5                   \\n\\t\" // qmat[0]\n\n            \"pxor \"MM\"6, \"MM\"6                  \\n\\t\"\n\n            \"psubw (%3), \"MM\"6                  \\n\\t\" // -bias[0]\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            \"psubusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat), \"r\" (bias),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }else{ // FMT_H263\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            MOVQ\" (%3, %%\"FF_REG_a\"), \"MM\"6     \\n\\t\" // bias[0]\n\n            \"paddusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            MOVQ\" (%2, %%\"FF_REG_a\"), \"MM\"5     \\n\\t\" // qmat[i]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] + bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat+64), \"r\" (bias+64),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }\n\n    __asm__ volatile(\n\n        \"movd %1, \"MM\"1                     \\n\\t\" // max_qcoeff\n\n        SPREADW(MM\"1\")\n\n        \"psubusw \"MM\"1, \"MM\"4               \\n\\t\"\n\n        \"packuswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#if COMPILE_TEMPLATE_SSE2\n\n        \"packsswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#endif\n\n        \"movd \"MM\"4, %0                     \\n\\t\" // *overflow\n\n        : \"=g\" (*overflow)\n\n        : \"g\" (s->max_qcoeff)\n\n    );\n\n\n\n    if(s->mb_intra) block[0]= level;\n\n    else            block[0]= temp_block[0];\n\n\n\n    if (s->idsp.perm_type == FF_IDCT_PERM_SIMPLE) {\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x08] = temp_block[0x01]; block[0x10] = temp_block[0x08];\n\n        block[0x20] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x18] = temp_block[0x09]; block[0x04] = temp_block[0x02];\n\n        block[0x09] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x14] = temp_block[0x0A]; block[0x28] = temp_block[0x11];\n\n        block[0x12] = temp_block[0x18]; block[0x02] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1A] = temp_block[0x19]; block[0x24] = temp_block[0x12];\n\n        block[0x19] = temp_block[0x0B]; block[0x01] = temp_block[0x04];\n\n        block[0x0C] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x11] = temp_block[0x0C]; block[0x29] = temp_block[0x13];\n\n        block[0x16] = temp_block[0x1A]; block[0x0A] = temp_block[0x21];\n\n        block[0x30] = temp_block[0x28]; block[0x22] = temp_block[0x30];\n\n        block[0x38] = temp_block[0x29]; block[0x06] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x21] = temp_block[0x14];\n\n        block[0x1C] = temp_block[0x0D]; block[0x05] = temp_block[0x06];\n\n        block[0x0D] = temp_block[0x07]; block[0x15] = temp_block[0x0E];\n\n        block[0x2C] = temp_block[0x15]; block[0x13] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x0B] = temp_block[0x23]; block[0x34] = temp_block[0x2A];\n\n        block[0x2A] = temp_block[0x31]; block[0x32] = temp_block[0x38];\n\n        block[0x3A] = temp_block[0x39]; block[0x26] = temp_block[0x32];\n\n        block[0x39] = temp_block[0x2B]; block[0x03] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x25] = temp_block[0x16];\n\n        block[0x1D] = temp_block[0x0F]; block[0x2D] = temp_block[0x17];\n\n        block[0x17] = temp_block[0x1E]; block[0x0E] = temp_block[0x25];\n\n        block[0x31] = temp_block[0x2C]; block[0x2B] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x36] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x23] = temp_block[0x34]; block[0x3C] = temp_block[0x2D];\n\n        block[0x07] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x0F] = temp_block[0x27]; block[0x35] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x2E] = temp_block[0x35]; block[0x33] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x27] = temp_block[0x36];\n\n        block[0x3D] = temp_block[0x2F]; block[0x2F] = temp_block[0x37];\n\n        block[0x37] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else if(s->idsp.perm_type == FF_IDCT_PERM_LIBMPEG2){\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x04] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x0C] = temp_block[0x09]; block[0x01] = temp_block[0x02];\n\n        block[0x05] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x09] = temp_block[0x0A]; block[0x14] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1C] = temp_block[0x19];\n\n        block[0x11] = temp_block[0x12]; block[0x0D] = temp_block[0x0B];\n\n        block[0x02] = temp_block[0x04]; block[0x06] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0A] = temp_block[0x0C]; block[0x15] = temp_block[0x13];\n\n        block[0x19] = temp_block[0x1A]; block[0x24] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x2C] = temp_block[0x29]; block[0x21] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1D] = temp_block[0x1B]; block[0x12] = temp_block[0x14];\n\n        block[0x0E] = temp_block[0x0D]; block[0x03] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0B] = temp_block[0x0E];\n\n        block[0x16] = temp_block[0x15]; block[0x1A] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x25] = temp_block[0x23]; block[0x29] = temp_block[0x2A];\n\n        block[0x34] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x3C] = temp_block[0x39]; block[0x31] = temp_block[0x32];\n\n        block[0x2D] = temp_block[0x2B]; block[0x22] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x13] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1B] = temp_block[0x1E]; block[0x26] = temp_block[0x25];\n\n        block[0x2A] = temp_block[0x2C]; block[0x35] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x39] = temp_block[0x3A]; block[0x3D] = temp_block[0x3B];\n\n        block[0x32] = temp_block[0x34]; block[0x2E] = temp_block[0x2D];\n\n            block[0x23] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2B] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x36] = temp_block[0x35]; block[0x3A] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x33] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3B] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else{\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x01] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x09] = temp_block[0x09]; block[0x02] = temp_block[0x02];\n\n        block[0x03] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x0A] = temp_block[0x0A]; block[0x11] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x19] = temp_block[0x19];\n\n        block[0x12] = temp_block[0x12]; block[0x0B] = temp_block[0x0B];\n\n        block[0x04] = temp_block[0x04]; block[0x05] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0C] = temp_block[0x0C]; block[0x13] = temp_block[0x13];\n\n        block[0x1A] = temp_block[0x1A]; block[0x21] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x29] = temp_block[0x29]; block[0x22] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x14] = temp_block[0x14];\n\n        block[0x0D] = temp_block[0x0D]; block[0x06] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0E] = temp_block[0x0E];\n\n        block[0x15] = temp_block[0x15]; block[0x1C] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x23] = temp_block[0x23]; block[0x2A] = temp_block[0x2A];\n\n        block[0x31] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x39] = temp_block[0x39]; block[0x32] = temp_block[0x32];\n\n        block[0x2B] = temp_block[0x2B]; block[0x24] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1D] = temp_block[0x1D]; block[0x16] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1E] = temp_block[0x1E]; block[0x25] = temp_block[0x25];\n\n        block[0x2C] = temp_block[0x2C]; block[0x33] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x3A] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x34] = temp_block[0x34]; block[0x2D] = temp_block[0x2D];\n\n        block[0x26] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2E] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x35] = temp_block[0x35]; block[0x3C] = temp_block[0x3C];\n\n        block[0x3D] = temp_block[0x3D]; block[0x36] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3E] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }\n\n    end:\n\n    return last_non_zero_p1 - 1;\n\n}\n", "idx": 18545, "substitutes": {"s": ["g", "self", "sites", "client", "session", "secondary", "js", "support", "h", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "stats", "states", "sets", "ins", "outs", "qs", "m", "server", "sf", "http", "u", "ions", "ns", "si", "args", "i", "strings", "es", "us", "p", "sb", "ts", "ks", "services", "l", "sym", "se", "its", "sync", "f", "ops", "this", "sports", "rs", "ss", "sq", "native", "phys", "o", "xs", "sim", "S", "sg", "ses", "spec", "rates", "is", "cs", "sys", "ps", "t", "parts", "d", "ls", "k", "service", "comments", "e", "os", "features", "ds", "v", "settings"], "block": ["batch", "section", "bit", "round", "check", "none", "Block", "session", "f", "map", "number", "clock", "type", "work", "cache", "frame", "node", "x", "name", "bc", "off", "clean", "load", "buffer", "board", "view", "ip", "record", "tick", "enc", "config", "word", "chain", "blocks", "cl", "input", "pack", "byte", "o", "w", "time", "k", "object", "p", "channel", "line", "filter", "null", "slice", "comment", "group", "image", "lock", "blocking", "run", "row", "device", "ack", "box", "event", "bl", "sync"], "n": ["g", "sn", "f", "nc", "x", "u", "t", "d", "ns", "np", "i", "nn", "h", "nl", "N", "c", "k", "nt", "p", "y", "b", "z", "en", "nb", "count", "num", "e", "network", "l", "v", "j", "m"], "qscale": ["sqdrop", "qucale", "quarea", "Qdelay", "sqcale", "qdrop", "quphase", "Qsize", "qualitycale", "eqcos", "sqclip", "Qseed", "Qcale", "eqscale", "eqzone", "eqcale", "eqtotal", " qseed", "sqdepth", "qualitydrop", "qatile", "qcos", "kcale", "dqscale", "questparse", "kdrop", "sqpack", " qsize", "Qdepth", "qualitypack", "kpack", "qsquare", "qparse", "quscale", "qualityscale", "sqdelay", "qarea", "qdepth", "eqsquare", "dqtotal", "kscale", "sqscale", "questscale", "qudelay", "qusquare", "sqcos", "Qtile", "Qscale", "qtotal", "qcale", "qseed", "qualityphase", "questarea", "qualitysquare", " qmode", "qacale", "Qzone", "qzone", "eqphase", "qudepth", "pscale", "pmode", "qpack", "eqarea", "eqclip", "qucos", "dqarea", "questtotal", "qclip", "eqtile", "qtile", "qsize", "qmode", "eqparse", "qazone", "pseed", "qutile", "qphase", "qascale", "psize", "dqparse", "Qmode", "quclip", "qdelay", "sqtile", "qualityarea"], "overflow": ["Overload", "undercharge", "underload", "underride", " overcharge", "Overflow", " overload", "Override", " override", "Overcharge", "override", "overload", "overcharge", "underflow"], "last_non_zero_p1": ["last_non_zero_q2", "last_non_zero_c3", "last_non_zero_p3", "last_non_zero_r11", "last_non_zero_c1", "last_non_zero_q3", "last_non_zero_q1", "last_non_zero_P2", "last_non_zero_P3", "last_non_zero_q0", "last_non_zero_q11", "last_non_zero_c2", "last_non_zero_r2", "last_non_zero_r1", "last_non_zero_qone", "last_non_zero_p11", "last_non_zero_pone", "last_non_zero_Pone", "last_non_zero_rone", "last_non_zero_c0", "last_non_zero_p2", "last_non_zero_P1", "last_non_zero_P11", "last_non_zero_p0", "last_non_zero_P0"], "q": ["g", "bit", "scale", "f", "length", "quant", "Q", "type", "qi", "temp", "u", "x", "level", "t", "sq", "d", "quality", "ch", "i", "id", "eq", "h", "qa", "qq", "w", "qt", "iq", "k", "c", "quad", "p", "dq", "depth", "limit", "y", "qu", "z", "weight", "count", "charge", "query", "qs", "v", "offset"], "qmat": ["qatransform", "qtransform", "qmit", "queryatt", "qqdim", "qumat", "qdim", "qqcrit", "qadim", "qumit", "sqmat", "sqtransform", "qpath", "qstat", "qanat", "sqpath", " qstat", "querymit", "qunat", "querystat", "qustat", "quscale", "quatt", "qudim", " qatt", "qacrit", "qqnat", " qhat", "qnat", "pmat", "qcrit", "pscale", "querymat", "qucrit", "quhat", "queryscale", "sqscale", "qqmat", "ppath", "qascale", "queryhat", " qmit", "qamat", "qhat", "ptransform", "qatt", "qapath"], "bias": ["dasing", "bac", "cius", "Basing", " baria", "cbasing", "Bix", "Bias", "baria", "dias", "cabel", "barix", "dius", "binding", "cac", "bix", "Bscale", "Binding", "basing", "dinding", " bscale", "Bac", "barscale", "bscale", "barias", "Baria", " bius", " babel", "Babel", "bararia", "cias", " binding", "lias", "cbias", " basing", "bius", "Bius", " bac", " bix", "lius", "cbius", "babel", "lasing"], "dummy": ["sdumb", "dumb", " dumper", "Dangling", "sdumper", "Dummy", " dangling", " dairy", "dumper", "Dumper", "sdummy", "Dumb", "dairy", "dabbage", "dangling", "Dairy", "sdabbage", "Dabbage"]}}
{"project": "FFmpeg", "commit_id": "491eaf35ae1f9b619441314bec33766e31580184", "target": 1, "func": "static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)\n\n{\n\n    int channel, stereo, phase, exp;\n\n    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;\n\n    int local_int_14, stereo_exp, local_int_20, local_int_28;\n\n    int n, offset;\n\n\n\n    local_int_4 = 0;\n\n    local_int_28 = 0;\n\n    local_int_20 = 2;\n\n    local_int_8 = (4 - duration);\n\n    local_int_10 = 1 << (q->group_order - duration - 1);\n\n    offset = 1;\n\n\n\n    while (1) {\n\n        if (q->superblocktype_2_3) {\n\n            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {\n\n                offset = 1;\n\n                if (n == 0) {\n\n                    local_int_4 += local_int_10;\n\n                    local_int_28 += (1 << local_int_8);\n\n                } else {\n\n                    local_int_4 += 8*local_int_10;\n\n                    local_int_28 += (8 << local_int_8);\n\n                }\n\n            }\n\n            offset += (n - 2);\n\n        } else {\n\n            offset += qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2);\n\n            while (offset >= (local_int_10 - 1)) {\n\n                offset += (1 - (local_int_10 - 1));\n\n                local_int_4  += local_int_10;\n\n                local_int_28 += (1 << local_int_8);\n\n            }\n\n        }\n\n\n\n        if (local_int_4 >= q->group_size)\n\n\n\n\n        local_int_14 = (offset >> local_int_8);\n\n\n\n\n\n        if (q->nb_channels > 1) {\n\n            channel = get_bits1(gb);\n\n            stereo = get_bits1(gb);\n\n        } else {\n\n            channel = 0;\n\n            stereo = 0;\n\n        }\n\n\n\n        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);\n\n        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];\n\n        exp = (exp < 0) ? 0 : exp;\n\n\n\n        phase = get_bits(gb, 3);\n\n        stereo_exp = 0;\n\n        stereo_phase = 0;\n\n\n\n        if (stereo) {\n\n            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));\n\n            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));\n\n            if (stereo_phase < 0)\n\n                stereo_phase += 8;\n\n        }\n\n\n\n        if (q->frequency_range > (local_int_14 + 1)) {\n\n            int sub_packet = (local_int_20 + local_int_28);\n\n\n\n            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);\n\n            if (stereo)\n\n                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);\n\n        }\n\n\n\n        offset++;\n\n    }\n\n}", "idx": 18556, "substitutes": {"q": ["question", "g", "core", "f", "cal", "quant", "ck", "Q", "cmd", "qi", "queue", "u", "cache", "sh", "t", "sq", "req", "d", "quest", "aq", "ch", "config", "cl", "h", "qa", "input", "qq", "ue", "qt", "conf", "iq", "c", "quad", "k", "dq", "p", "requ", "ou", "ce", "qu", "z", "gui", "query", "que", "qs", "v", "m"], "duration": ["sequence", "timeout", "length", "component", "resolution", " dur", " bc", "mode", "nc", "number", "name", "dim", "window", "Duration", "buffer", "d", "gap", "bb", "video", "len", "version", "direction", "i", "id", "frequency", "dt", "db", "mult", "span", "uu", "repeat", "days", "time", "c", "depth", "y", "unit", "nd", "nr", "period", "stage", " d", "m", "nb", "cb", "e", "seconds", "v", "date", "rate", "br"], "gb": ["cca", "gm", "gru", "bd", "cm", "gin", "pc", "cli", "bc", "gam", "gc", "bn", "bb", "bp", "hub", "gd", "bm", "lib", "db", "storage", "kj", "cgi", "eb", "ctx", "ga", "gio", "rb", "gs", "gnu", "gram", "bridge", "sb", "abb", "gu", "gh", "mb", "rg", "gp", "cfg", "nb", "gy", "cb", "bf", "gg", "ub", "GB", "kb", "usb", "lb", "hm", "bg"], "b": ["g", "batch", "bit", "bd", "f", "B", "bc", "buffer", "d", "bb", "base", "boot", "h", "r", "ib", "eb", "binary", "bar", "w", "rb", "c", "k", "p", "sb", "s", "nb", "cb", "ab", "bf", "e", "l", "a", "bg", "v", "bin", "j", "m"], "channel": ["batch", "bit", "scale", "Channel", "f", "component", "session", "chan", "name", "bc", "queue", "source", "nc", "type", "normal", "error", "connection", "gap", "broad", "message", "version", "ch", "button", "config", "byte", "lc", "slot", "depth", "pixel", "unit", "service", "socket", "group", "context", "rc", "shape", "event", "color", "layer", "size", "mode"], "stereo": ["STrobe", "structure", "estealing", "Stealing", "estereo", "mastadium", "stamber", "strobe", "constamber", "constadium", " stamber", "mastructure", "estadium", "Stamber", "Structure", " stadium", "Strobe", "constereo", "STereo", "stealing", "Stereo", "STadium", "STructure", "mastereo", " stealing", "Stadium", "constructure", "estructure", " structure", "stadium", "mastrobe"], "phase": ["sample", "wave", "scale", "component", "type", "name", "level", "dim", "scope", "description", "location", "version", "direction", "format", "unit", "stage", "slice", "image", "step", "seq", "shape", "norm", "layer", "mode"], "local_int_4": ["local_int84", "local_int679", "local_Int_14", "local_int8four", "local_int_44", "local_int674", "local_int67four", "local_int6720", "local_Int_7", "local_int89", "local_int_40", "local_ind_4", "local_Int_four", "local_Int_40", "local_Int_20", "local_Int_9", "local_Int_10", "local_int_9", "local_ind_44", "local_int820", "local_Int_04", "local_Int_8", "local_Int_44", "local_Int_4", "local_ind_8", "local_int_7", "local_ind_04", "local_int_four", "local_int_04"], "local_int_8": ["local_ints6710", "local_int328", "local_ints_10", "local_int_16", "local_ints6708", "local_Int_08", "local_bit_14", "local_int6725", "local_int_08", "local_int6716", "local_Int_88", "local_int_25", "local_intP08", "local_bit_128", "local_ints_16", "local_ints_08", "local_int_88", "local_bit_10", "local_inst_18", "local_ints_8", "local_int6720", "local_int3220", "local_int6710", "local_bit_8", "local_bit_25", "local_bit_08", "local_inst_8", "local_bit_20", "local_ints10", "local_ints8", "local_inst_2", "local_int_128", "local_bit_9", "local_ext_4", "local_int3210", "local_intP128", "local_inst_10", "local_bit_2", "local_Int_28", "local_int_9", "local_ints08", "local_ints16", "local_intP10", "local_int_2", "local_intP8", "local_Int_8", "local_bit_88", "local_int6708", "local_int678", "local_ext_14", "local_ext_10", "local_int_18", "local_int3225", "local_ext_8", "local_ints6716", "local_ints678"], "stereo_phase": ["struction_phase", "struction_exp", "struction_version", "stereo_version", "stereo_seq", "struction_seq"], "local_int_10": ["local_Int_15", "local_intsconfig", "local_int328", "local_int_5", "local_Int_11", "local_ints20", "local_Int_config", "local_nt_8", "local_Int_14", "local_int_25", "local_int968", "local_Int_5", "local_int_15", "local_int6420", "local_int6412", "local_int96data", "local_int9612", "local_int28", "local_int3211", "local_ints10", "local_nt_15", "local_int_11", "local_ints8", "local_Int_20", "local_int210", "local_Int_25", "local_int3228", "local_int6410", "local_int3210", "local_int212", "local_int_data", "local_Int_10", "local_Int_28", "local_int_config", "local_int648", "local_Int_data", "local_nt_4", "local_int6415", "local_int_12", "local_Int_8", "local_Int_12", "local_int9610", "local_int64config", "local_int3225", "local_int3214", "local_nt_10", "local_int2data"], "local_int_14": ["local_int6414", "local_int214", "local_int_12", "local_Int_8", "local_int_13", "local_int6428", "local_Int_13", "local_bit_28", "local_int6412", "local_int228", "local_bit_12", "local_bit_14", "local_int6413", "local_int212", "local_bit_8", "local_int28", "local_Int_28", "local_Int_14", "local_int648"], "stereo_exp": ["stropy_exp", "stereo_scale", "stropy_phase", "stereo_full", "stropy_scale", "stropy_full"], "local_int_20": ["local_int6414", "local_int214", "local_int6418", "local_int_0", "local_int6420", "local_nt_18", "local_int480", "local_int_18", "local_int4820", "local_nt_20", "local_int4810", "local_int28", "local_nt_14", "local_nt_0", "local_nt_8", "local_int220", "local_int648", "local_nt_10", "local_int218", "local_int488"], "local_int_28": ["local_Int_15", "local_int832", "local_int2514", "local_int_5", "local_int1256", "local_int6427", "local_inc_29", "local_bit_14", "local_ind_48", "local_int6429", "local_Int_14", "local_int2515", "local_int2528", "local_int1232", "local_int_15", "local_int6428", "local_int_56", "local_ind_27", "local_inc856", "local_int828", "local_int2429", "local_inc829", "local_int856", "local_bit_8", "local_inc832", "local_ind_4", "local_int_29", "local_int2448", "local_int_27", "local_int829", "local_ind_28", "local_int1229", "local_bit_5", "local_int_32", "local_Int_28", "local_int648", "local_intA5", "local_ind_29", "local_Int_8", "local_intA14", "local_int_48", "local_int2428", "local_intA28", "local_bit_28", "local_ind_8", "local_int244", "local_inc828", "local_inc_32", "local_intA8", "local_inc_28", "local_inc_56", "local_int258", "local_int1228"], "n": ["g", "sn", "none", "f", "number", "node", "x", "nc", "u", "na", "t", "conn", "d", "no", "ns", "len", "i", "nn", "h", "r", "span", "o", "N", "loc", "c", "k", "nt", "p", "pn", "adj", "y", "unit", "nr", "z", "mn", "m", "en", "nor", "nb", "ne", "count", "num", "fn", "e", "un", "l", "dn", "nu", "v", "j", "cn"], "offset": ["set", "skip", "scale", "layout", "range", "off", "api", "end", "position", "frequency", "online", "padding", "limit", "append", "image", "outer", "layer", "attribute", "bit", "alpha", "af", "timeout", "fee", "gap", "no", "optional", "location", "i", "beta", "index", "slot", "part", "p", "seed", "alias", "sync", "iso", "f", "length", "number", "aff", "style", "error", "address", "entry", "o", "Offset", "pos", "delay", "pointer", "step", "area", "shift", "option", "operation", "type", "aligned", "parent", "alt", "member", "len", "align", "loc", "function", "slice", "start", "event", "bound", "size"]}}
{"project": "qemu", "commit_id": "ff472a5badf8e6d964455de39ca67ea3a7758dea", "target": 1, "func": "static void cuda_receive_packet(CUDAState *s,\n\n                                const uint8_t *data, int len)\n\n{\n\n    uint8_t obuf[16] = { CUDA_PACKET, 0, data[0] };\n\n    int autopoll;\n\n    uint32_t ti;\n\n\n\n    switch(data[0]) {\n\n    case CUDA_AUTOPOLL:\n\n        autopoll = (data[1] != 0);\n\n        if (autopoll != s->autopoll) {\n\n            s->autopoll = autopoll;\n\n            if (autopoll) {\n\n                timer_mod(s->adb_poll_timer,\n\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n\n                               (get_ticks_per_sec() / CUDA_ADB_POLL_FREQ));\n\n            } else {\n\n                timer_del(s->adb_poll_timer);\n\n            }\n\n        }\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_6805_ADDR:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_SET_TIME:\n\n        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];\n\n        s->tick_offset = ti - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_TIME:\n\n        ti = s->tick_offset + (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        obuf[3] = ti >> 24;\n\n        obuf[4] = ti >> 16;\n\n        obuf[5] = ti >> 8;\n\n        obuf[6] = ti;\n\n        cuda_send_packet_to_host(s, obuf, 7);\n\n        break;\n\n    case CUDA_FILE_SERVER_FLAG:\n\n    case CUDA_SET_DEVICE_LIST:\n\n    case CUDA_SET_AUTO_RATE:\n\n    case CUDA_SET_POWER_MESSAGES:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_POWERDOWN:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case CUDA_RESET_SYSTEM:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_reset_request();\n\n        break;\n\n    case CUDA_COMBINED_FORMAT_IIC:\n\n\n        obuf[1] = 0x5;\n\n\n\n\n        break;\n\n    case CUDA_GET_SET_IIC:\n\n        if (len == 4) {\n\n            cuda_send_packet_to_host(s, obuf, 3);\n\n        } else {\n\n\n\n\n\n\n        }\n\n        break;\n\n    default:\n\n\n\n\n\n\n        break;\n\n    }\n\n}", "idx": 18559, "substitutes": {"s": ["is", "g", "cs", "server", "self", "sf", "sys", "session", "f", "http", "ops", "ps", "rs", "js", "south", "t", "ss", "sq", "ions", "d", "ns", "n", "site", "si", "state", "private", "r", "your", "ls", "es", "stat", "gs", "conf", "side", "c", "p", "sb", "ts", "sie", "service", "ssl", "ks", "b", "y", "su", "fs", "services", "stats", "S", "states", "sg", "ses", "e", "sv", "l", "hs", "sym", "sets", "serv", "spec", "se", "ds", "sync", "m"], "data": ["sample", "batch", "results", "after", "di", "alpha", "xy", "result", "split", "style", "cache", "array", "dd", "DATA", "load", "na", "window", "api", "pad", "ad", "buffer", "d", "Data", "message", "args", "i", "config", "multi", "code", "index", "input", "pack", "block", "aa", "next", "xxx", "body", "devices", "p", "post", "response", "da", "key", "missing", "delay", "value", "slice", "done", "package", "image", "bytes", "send", "ui", "la", "zero", "request", "dat", "start", "ata", "a", "wa", "device", "empty", "date", "size", "info"], "len": ["val", "length", "src", "type", "nc", "Len", "el", "end", "n", "base", "SIZE", "enc", "lib", " clen", "fin", "code", "all", "pos", "en", "count", "seq", " length", "l", "size", "offset"], "obuf": [" obboard", "abub", "abbuf", " obuffer", " obaf", "OBub", "ouuf", "obuc", "abuf", "oabuf", "ablu", " obum", "obbuff", "odaf", "obbuffer", "Obboard", "odault", " obbuff", "oabuff", " ibush", "obbuf", "Obaf", "ouume", " ibuf", "braf", "OBuff", "obume", " obust", "ocdf", "oduf", "ouush", " obdf", "abuff", " obuff", " obub", " obull", "abum", "OBaf", "abull", " obume", "skuf", "Obuf", "obub", "bruffer", "Obbuffer", "oauff", "OBuffer", " ibbuf", " oblu", "obull", "obsbuffer", "obaf", "brub", "OBault", "abbuff", "Obbuf", "abdf", "objectush", "Obuffer", "obush", "objectust", "oduc", "Obub", "obault", "obdf", " obush", "skub", "obuffer", " obault", "OBuc", "ocbuf", "Obush", "obsboard", "obboard", "obum", " obbuffer", "ocuf", "ocum", "skuff", "obsuf", "sklu", "OBuf", "OBbuff", "OBull", "obuff", "objectume", " ibdf", "bruf", " obbuf", "oauf", "objectuf", "Obdf", "oblu", " obuc", "obsuffer", "obust", "ouust"], "autopoll": ["autompone", "autobol", "autohol", " autofoller", "autofll", "autophol", "autobone", "autipoll", " autopool", "autophell", "autoholl", "octopool", "octopoll", "autocloller", "autocell", "autocll", "autoclell", "autompool", "autopll", "autopoller", "autompll", " autompll", "autohock", "autocock", "autipool", " autompollo", " autompock", "octompoller", "autocollo", " autompool", " autompone", " autofoll", " autompell", "autopholl", "autobollo", "octompol", "autocol", "autofollo", "autobell", "autopell", "autompoller", "autopool", "autofol", "autompock", "autocloll", "autophone", "octompoll", "autocoll", " autopoller", "autipoller", " autofool", "autipol", "autofool", " autofollo", "autofoller", "autoboller", " autompoll", "autompol", "autoclol", " autopll", " autopock", "autopone", "autompoll", "octopol", " autopone", " autopol", " autopollo", " autompoller", " autopell", "autofell", "octompool", "autohollo", "autoboll", "autompollo", "octopoller", " autompol", "autopollo", "autofoll", "autobool", "autopock", "autompell", "autopol"], "ti": ["phi", "di", "tif", "xi", "ski", "hi", "qi", "ci", "li", "oti", "tu", "te", "eni", "bi", "t", "ta", "uri", "tm", "oni", "tis", "si", "pi", "tin", "i", "multi", "vi", "tta", "chi", "ai", "edi", "wi", "ita", "ii", "uti", "sil", "tti", "ki", "shi", "ui", "ni", "zi", "ami", "yi", "iri", "adi", "ori", "ati", "TI", "osi", "isi", "nu", "ini", "lit", "mi"]}}
{"project": "qemu", "commit_id": "b6b75a99dab760c902c3d355519e0dc2616872e1", "target": 1, "func": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);", "idx": 18562, "substitutes": {"bm": ["gm", "bd", "bo", "cm", "map", "om", "bc", "bank", "bt", "buf", "bh", "rm", "wm", "bn", "bi", "buffer", "BM", "tm", "fm", "bb", "bp", "pm", "mi", "obj", "db", "pb", "img", "sb", "mr", "b", "mb", "nb", "cb", "gb", "bf", "ym", "nm", "kb", "lb", "hm", "bg", "md", "bin", "fb", "m"]}}
{"project": "FFmpeg", "commit_id": "513a3494396d0a20233273b3cadcb5ee86485d5c", "target": 1, "func": "static int vp6_parse_coeff(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = s->ccp;\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->idct_scantable;\n\n    uint8_t *model1, *model2, *model3;\n\n    int coeff, sign, coeff_idx;\n\n    int b, i, cg, idx, ctx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    if (c->end >= c->buffer && c->bits >= 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"End of AC stream reached in vp6_parse_coeff\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 1;    /* code type */\n\n        int run = 1;\n\n\n\n        if (b > 3) pt = 1;\n\n\n\n        ctx = s->left_block[ff_vp56_b6to4[b]].not_null_dc\n\n              + s->above_blocks[s->above_block_idx[b]].not_null_dc;\n\n        model1 = model->coeff_dccv[pt];\n\n        model2 = model->coeff_dcct[pt][ctx];\n\n\n\n        coeff_idx = 0;\n\n        for (;;) {\n\n            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {\n\n                /* parse a coeff */\n\n                if (vp56_rac_get_prob_branchy(c, model2[2])) {\n\n                    if (vp56_rac_get_prob_branchy(c, model2[3])) {\n\n                        idx = vp56_rac_get_tree(c, ff_vp56_pc_tree, model1);\n\n                        coeff = ff_vp56_coeff_bias[idx+5];\n\n                        for (i=ff_vp56_coeff_bit_length[idx]; i>=0; i--)\n\n                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;\n\n                    } else {\n\n                        if (vp56_rac_get_prob_branchy(c, model2[4]))\n\n                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);\n\n                        else\n\n                            coeff = 2;\n\n                    }\n\n                    ct = 2;\n\n                } else {\n\n                    ct = 1;\n\n                    coeff = 1;\n\n                }\n\n                sign = vp56_rac_get(c);\n\n                coeff = (coeff ^ -sign) + sign;\n\n                if (coeff_idx)\n\n                    coeff *= s->dequant_ac;\n\n                idx = model->coeff_index_to_pos[coeff_idx];\n\n                s->block_coeff[b][permute[idx]] = coeff;\n\n                run = 1;\n\n            } else {\n\n                /* parse a run */\n\n                ct = 0;\n\n                if (coeff_idx > 0) {\n\n                    if (!vp56_rac_get_prob_branchy(c, model2[1]))\n\n                        break;\n\n\n\n                    model3 = model->coeff_runv[coeff_idx >= 6];\n\n                    run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);\n\n                    if (!run)\n\n                        for (run=9, i=0; i<6; i++)\n\n                            run += vp56_rac_get_prob(c, model3[i+8]) << i;\n\n                }\n\n            }\n\n            coeff_idx += run;\n\n            if (coeff_idx >= 64)\n\n                break;\n\n            cg = vp6_coeff_groups[coeff_idx];\n\n            model1 = model2 = model->coeff_ract[pt][ct][cg];\n\n        }\n\n\n\n        s->left_block[ff_vp56_b6to4[b]].not_null_dc =\n\n        s->above_blocks[s->above_block_idx[b]].not_null_dc = !!s->block_coeff[b][0];\n\n    }\n\n    return 0;\n\n}\n", "idx": 18578, "substitutes": {"s": ["g", "is", "cs", "sf", "f", "sys", "aws", "u", "ds", "rs", "js", "south", "t", "ss", "sq", "d", "ns", "n", "site", "si", "support", "r", "ls", "es", "space", "o", "gs", "conf", "p", "sb", "ks", "service", "ts", "ssl", "sl", "xs", "su", "sim", "services", "S", "states", "sec", "sg", "ses", "e", "sets", "sv", "os", "sym", "a", "settings", "l", "se", "spec", "qs", "v", "sync", "m"], "c": ["g", "cs", "cp", "self", "coll", "dc", "f", "com", "uc", "bc", "ac", "u", "nc", "ci", "cur", "cache", "t", "conn", "d", "n", "col", "ch", "enc", "config", "cl", "r", "con", "ec", "lc", "cell", "ca", "cf", "oc", "ce", "k", "p", "cc", "ic", "cy", "vc", "tc", "rc", "mc", "e", "l", "a", "C", "cu", "v", "m"], "model": ["g", "core", "server", "cm", "coll", "Model", "f", "mode", "models", "bank", "mod", "cache", "global", "source", "document", "scope", "view", "base", "bm", "module", "config", "ml", "lib", "db", "sm", "code", "data", "man", "block", "engine", "cell", "ga", "ca", "cf", "center", "p", "cc", "gu", "service", "sl", "package", "image", "mc", "l", "query", "general", "mm", "custom", "manager", "v", "mi", "m"], "permute": ["compute", "computation", "smute", "computes", "permutes", "mut", "smutes", "mutation", "mutes", "permutation", "permut", "comput", "mute", "smut", "smutation"], "model1": ["modulen", "models3", "form1", "Model1", "form2", "form4", " modeln", "Model4", "model4", "moduleOne", "module3", "model_", "modelOne", "modeln", " model_", "models1", " modelOne", "modelsn", "Model8", "form_", "Model3", "module1", "module8", "Model_", "module2", " model8", " model4", "Model2", "modelsOne", "model8"], "model2": ["modeltwo", "keyTwo", "Model1", "key5", "layer3", "image2", "Model4", "link5", "model4", "linkTwo", "image4", "module3", "block2", "link2", "layer1", " model0", "method2", " modelSecond", " model5", "model5", "layertwo", "link1", "modelTwo", "module4", "Model3", "module1", "method4", "methodSecond", "block0", "modelSecond", "module8", "layer2", "model0", "module2", " model8", "key2", " model4", "method5", "image5", "imageSecond", "block8", "block4", "Model2", "moduletwo", "key1", " modeltwo", " modelTwo", "module0", "model8"], "model3": ["model4", "image6", "image3", "module2", "image4", "module3", "model6", " model4", " model6", "module4", "image2", "module6"], "coeff": ["colefficient", " coff", "koeff", "koff", "poef", "coleff", "Coff", "colef", "koefficient", "poeff", " coefficient", "poefficient", "colff", "Coeff", "Coefficient", "poff", "koef", "coff", "Coef", "coef", "coefficient", " coef"], "sign": ["round", "scale", "min", "mod", "ss", "rib", "enc", "init", "act", "ign", "iv", "diff", "iss", "pass", "sum", "circ", "cost", "pos", "ind", "sup", "err", "weight", "sec", "shape", "roll", "sc"], "coeff_idx": ["coeff_Idx", "coeff_idw", "coeff_inz", "coeff_indz", "coeff_numz", "coeff_indx", "coeff_idj", "coeff_pidz", "coeff_idz", "coeff_inst", "coeff_numX", "coeff_Idw", "coeff_idX", "coeff_pidx", "coeff_Idz", "coeff_inx", "coeff_indst", "coeff_idst", "coeff_pidX", "coeff_numj", "coeff_Idj", "coeff_numx", "coeff_pidw", "coeff_Idst", "coeff_IdX"], "b": ["f", "B", "bs", "x", "bc", "bt", "u", "bh", "t", "d", "wb", "bb", "n", "base", "boot", "db", "ob", "h", "r", "pb", "emb", "ib", "eb", "bar", "w", "rb", "k", "bot", "p", "sb", "bas", "y", "be", "mb", "nb", "cb", "ab", "bf", "e", "gb", "l", "a", "lb", "v", "bl", "fb", "j", "br"], "i": ["g", "phi", "di", "my", "f", "ri", "xi", "hi", "qi", "x", "ix", "u", "ci", "li", "t", "eni", "bi", "it", "uri", "mu", "d", "info", "n", "ti", "ip", "I", "si", "pi", "multi", "id", "h", "index", "ai", "ib", "chi", "iu", "o", "ii", "k", "p", "y", "z", "value", "mini", "ui", "ni", "gi", "fi", "e", "start", "ori", "l", "io", "oi", "ini", "v", "mi", "j", "m"], "cg": ["catgs", "ccgi", " cw", "ccg", "cw", "catw", "cgs", "catgi", " cgi", "ccgs", " cgs", "cgi", "ccw", "catg"], "idx": ["inx", "odx", "idez", "idn", "midx", "idi", "indx", "odz", " idf", "Idx", "indz", "indf", "iden", "pidz", " idi", "ody", "iny", "Idz", "idf", "idef", "idex", "IdX", "Idy", "idey", "inX", " idxes", "midX", "midn", "idei", " idz", "idxes", "midy", "ideX", "idX", "odxes", "Idn", "pidx", "idy", "inz", "pidX", " idy", "pidy", " idX", "indi", "idz", "Idxes"], "ctx": ["cca", "cp", "cs", "cm", "dc", "kk", "pt", "pc", "unc", "cmd", "nc", "bc", "temp", "parent", "ci", "x", "q", "conn", "sq", "config", "qa", "cas", "lc", "loc", "ca", "cf", "ref", "nt", "cc", "cv", "kw", "vc", "tx", "thread", "tc", "context", "ct", "cb", "rc", "cmp", "ctrl", "port", "cu", "xc", "kb", "sc", "fc", "sync", "cn"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n", "idx": 18583, "substitutes": {"s": ["g", "core", "is", "cs", "self", "sf", "client", "f", "session", "aws", "sys", "ops", "ps", "secondary", "u", "fts", "js", "south", "t", "ss", "d", "ns", "n", "si", "storage", "r", "your", "ls", "es", "o", "us", "w", "gs", "conf", "c", "p", "sb", "ts", "service", "ks", "ssl", "b", "xs", "socket", "fs", "services", "su", "S", "sets", "ses", "e", "os", "settings", "sym", "hs", "a", "ds", "qs", "rates", "sync", "m"], "res": ["reply", "changes", "cs", "results", "pres", "resource", "rez", "rec", "progress", "ms", "resolution", "ry", "result", "ons", "rest", "range", "rus", "ids", "rs", "ix", "ray", "req", "reg", "rh", "vals", "error", "prev", "args", "RES", "id", "reset", "ros", "Res", "blocks", "rem", "r", "des", "rx", "rev", "es", "errors", "ries", "params", "pre", "gr", "details", "response", "ris", "content", "def", "resp", "re", "ress", "err", "rc", "ret", "e", "os", "ins", "rows", "remote", "arr", "ras", "rep", "info"], "start": ["min", "get", "starting", "sp", "range", "x", "test", "show", "r", "mid", "Start", "open", "use", "check", "name", "work", "source", "in", "add", "parse", "max", "p", "key", "seed", "se", "date", "art", "offset", "length", "rest", "style", "ad", "error", "old", "id", "init", "diff", "next", "pre", "pos", "ind", "step", "info", "stop", "str", "started", "shift", "type", "grade", "first", "d", "root", "space", "time", "k", "cost", "patch", "count", "e", "from", "ie", "part", "size"], "end": ["END", "stop", "set", "after", "inner", "length", "range", "ension", "rest", "name", "ad", "add", "d", "info", "n", "ion", "est", "enc", "id", "max", "r", "index", "h", "last", "change", "address", "code", "begin", "next", "all", "c", "p", "post", "pos", "End", "ended", "b", "append", "value", "edge", "use", "en", "send", "e", "then", "open", "ending", "order", "v", "offset"], "i": ["is", "di", "min", "rec", "shift", "f", "ri", "xi", "hi", "qi", "ix", "x", "u", "ci", "in", "li", "t", "eni", "bi", "uri", "api", "d", "mi", "abi", "it", "n", "len", "ip", "I", "pi", "ti", "si", "id", "multi", "one", "code", "ai", "r", "index", "iv", "iu", "rev", "o", "w", "ii", "iter", "c", "p", "y", "ind", "b", "ui", "gi", "fi", "e", "ori", "l", "io", "oi", "ie", "ini", "v", "pri", "j", "m"], "command": ["resource", "sequence", "pattern", "operation", "cmd", "Command", "prefix", "array", "script", "document", "exec", "connection", "execute", "description", "message", "usage", "directory", "power", "code", "data", "call", "c", "game", "response", "function", "content", "comment", "m", "send", "request", "text", "query", "password", "custom", "method", "event", "attribute", "mode"], "epsv_codes": ["epsv_errors", "epsi_flags", "epsi_errors", "epsi_codes", "epsi_lines", "epsi_code", "epsv_flags", "epsv_cod", "epsv_lines", "epsi_cod", "epsv_code"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_enqueue_packet(VLANClientState *sender,\n\n                                const uint8_t *buf, int size,\n\n                                NetPacketSent *sent_cb)\n\n{\n\n    VLANPacket *packet;\n\n\n\n    packet = qemu_malloc(sizeof(VLANPacket) + size);\n\n    packet->sender = sender;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n\n}\n", "idx": 18596, "substitutes": {"sender": ["issorter", "ssending", "Sener", "spender", "issender", " sener", "sent", "Senders", "spendor", "Send", "Sender", " senders", "ssend", "sener", "sendor", "Sendor", "dendor", "Susher", " sorter", "ssener", "susher", "Sent", "issend", "dent", "siver", "spent", "senders", " send", "Sending", "dender", "denders", "spenders", " susher", "send", "ssender", "sending", " siver", "sorter", "issiver", " sending"], "buf": ["batch", "lim", "vec", "bd", "length", "src", "uf", "cmd", "queue", "bc", "frame", "window", "flow", "buffer", "pool", "feed", "len", "base", "fd", "enc", "config", "pb", "pack", "data", "ctx", "fp", "cv", "b", "msg", "fb", "bytes", "context", "cb", "rc", "gb", "seq", "box", "buff", "alloc"], "size": ["g", "set", "server", "scale", "cm", "length", "timeout", "large", "sent", "export", "name", "complete", "type", "sized", "source", "six", "end", "fee", "Size", "len", "args", "SIZE", "enc", "small", "ize", "capacity", "offset", "address", "code", "pack", "data", "sum", "loc", "time", "c", "sync", "unit", "content", "use", "send", "en", "rc", "count", "e", "shape", "empty", "iz", "mode"], "sent_cb": [" sent_callback", "sentityfunction", "sentingfun", "sentingcallback", "sent2callback", "sentitycallback", "sent_function", " sent_fun", "sent_rb", "sent2cb", "send_cb", "sent_fun", "send_callback", "send_rb", "sentitycb", "send_sec", " sent_handler", "sent_handler", " sent_function", "sent2rb", "sent2sec", "sent_sec", "sentityfun", "sent_callback", "sentingfunction", "sentingcb"], "packet": ["octeting", "compette", " packette", "packen", "plugett", "passette", "vieweting", "octacket", "packlet", " packlet", "appeter", "assacket", "compett", " packeter", "packset", "packeting", "compet", "viewacket", "compat", " packen", "packageet", "octet", "maceter", "passacket", "plugen", "vieweter", "macacket", "packat", "compen", " packew", "appacket", "packeter", " packett", "assel", "octeter", "maceting", "packageette", "assat", "viewet", "packageacket", "compel", "macet", "appset", "packageel", "packette", "asset", "packageat", "packagelet", "competer", "appet", "compacket", "packacket", "packel", "pluget", "plugacket", "packew", " packacket", "packett", "complet", "compew", "passeter", "passet", "packageew", "packageeter", "viewset", "octset"]}}
{"project": "qemu", "commit_id": "7d6b1daedd00b35e50ce87ea835f662b36a23160", "target": 0, "func": "static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n", "idx": 18597, "substitutes": {"env": ["txt", "proc", "style", "bc", "buf", "scope", "np", "obj", "enc", "config", "dev", "init", "code", "dict", "iv", "dir", "ctx", "ec", "conf", "ptr", "err", "en", "context", "cb", "ev", "e", "environment", "bg"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n", "idx": 18598, "substitutes": {"length": ["family", "number", "Length", "match", "range", "type", "cur", "end", "buffer", "len", "position", "ch", "word", "th", "address", "duration", "code", "build", "padding", "h", "block", "sum", "loc", "cost", "weight", "count", "url", "seq", "shape", "l", "port", "text", "buff", "size", "offset"], "proto": ["pex", "Prof", "protf", "preto", "procer", "pref", "peto", "precer", "proco", "protx", "preb", "protco", "Proto", "Proocol", "prox", "protb", "proocol", "Prob", "prof", "protto", "peco", "preco", "preocol", "prob", "protcer", "protocol", "pecer", "prex"], "addrs": ["adls", " addros", "adrs", " addr", "addresses", "attresses", "adros", "adr", "addr", "adresses", " addresses", "attls", "ddresses", "ddr", "attrs", "addros", "ddls", "attr", "addls", "attros", "ddrs"], "buf": ["header", "vec", "src", "uf", "cmd", "queue", "array", "cur", "pad", "buffer", "pool", "len", "aux", "config", "address", "padding", "data", "addr", "binary", "raw", "mount", "rb", "cf", "each", "cv", "b", "uint", "cb", "rc", "seq", "port", "text", "buff", "ctr", "alloc", "br"]}}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n", "idx": 18614, "substitutes": {"env1": ["enc1", "en5", " env7", "environment1", "environmentone", "excOne", " env5", "env2", "envone", "env7", "enc5", "encone", "enc2", "environmentOne", "en1", " envone", "env5", " env2", "en7", "excone", "envOne", "environment2", "enc7", "encOne", "exc1", " envOne"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void ppc_hw_interrupt (CPUPPCState *env)\n\n{\n\n    int raised = 0;\n\n\n\n#if 1\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                __func__, env, env->pending_interrupts,\n\n                env->interrupt_request, msr_me, msr_ee);\n\n    }\n\n#endif\n\n    /* Raise it */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        /* External reset / critical input */\n\n        /* XXX: critical input should be handled another way.\n\n         *      This code is not correct !\n\n         */\n\n        env->exception_index = EXCP_RESET;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        raised = 1;\n\n    }\n\n    if (raised == 0 && msr_me != 0) {\n\n        /* Machine check exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n            env->exception_index = EXCP_MACHINE_CHECK;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n            raised = 1;\n\n        }\n\n    }\n\n    if (raised == 0 && msr_ee != 0) {\n\n#if defined(TARGET_PPC64H) /* PowerPC 64 with hypervisor mode support */\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            env->exception_index = EXCP_HDECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);\n\n            raised = 1;\n\n        } else\n\n#endif\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            env->exception_index = EXCP_DECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            raised = 1;\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->exception_index = EXCP_40x_PIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            raised = 1;\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->exception_index = EXCP_40x_FIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            raised = 1;\n\n        /* Watchdog timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->exception_index = EXCP_40x_WATCHDOG;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            raised = 1;\n\n        /* External interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            env->exception_index = EXCP_EXTERNAL;\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            raised = 1;\n\n#if 0 // TODO\n\n        /* Thermal interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->exception_index = EXCP_970_THRM;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            raised = 1;\n\n#endif\n\n        }\n\n#if 0 // TODO\n\n    /* External debug exception */\n\n    } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->exception_index = EXCP_xxx;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        raised = 1;\n\n#endif\n\n    }\n\n    if (raised != 0) {\n\n        env->error_code = 0;\n\n        do_interrupt(env);\n\n    }\n\n}\n", "idx": 18619, "substitutes": {"env": ["console", "core", "shell", "server", "inet", "eu", "cdn", "txt", "client", "output", "session", "extra", "export", "style", "nc", "cache", "global", "net", "et", "enable", "conn", "el", "end", "scope", "exec", "np", "n", "Environment", "site", "args", "enc", "config", "dev", "db", "state", "eng", "status", "qa", "init", "dict", "vs", "data", "ec", "engine", " environment", "exc", "qt", "conf", "ext", "ea", "loader", "cv", "her", "stage", "er", "err", "en", "context", "vm", "ne", "viron", "ev", "nw", "e", "environment", "que", "event", "manager", "v", "oa"]}}
{"project": "qemu", "commit_id": "23979dc5411befabe9049e37075b2b6320debc4e", "target": 0, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    struct DisasContext ctx;\n\n    struct DisasContext *dc = &ctx;\n\n    uint32_t next_page_start, org_flags;\n\n    target_ulong npc;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    qemu_log_try_set_file(stderr);\n\n\n\n    pc_start = tb->pc;\n\n    dc->env = env;\n\n    dc->tb = tb;\n\n    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;\n\n\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->jmp = 0;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->cpustate_changed = 0;\n\n    dc->abort_at_next_insn = 0;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3)\n\n        cpu_abort(env, \"Microblaze: unaligned PC=%x\\n\", pc_start);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n#if !SIM_COMPAT\n\n        qemu_log(\"--------------\\n\");\n\n        log_cpu_state(env, 0);\n\n#endif\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    do\n\n    {\n\n#if SIM_COMPAT\n\n        if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);\n\n            gen_helper_debug();\n\n        }\n\n#endif\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n                        gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        dc->clear_imm = 1;\n\n\tdecode(dc);\n\n        if (dc->clear_imm)\n\n            dc->tb_flags &= ~IMM_FLAG;\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                if (dc->tb_flags & DRTI_FLAG)\n\n                    do_rti(dc);\n\n                 if (dc->tb_flags & DRTB_FLAG)\n\n                    do_rtb(dc);\n\n                if (dc->tb_flags & DRTE_FLAG)\n\n                    do_rte(dc);\n\n                /* Clear the delay slot flag.  */\n\n                dc->tb_flags &= ~D_FLAG;\n\n                /* If it is a direct jump, try direct chaining.  */\n\n                if (dc->jmp != JMP_DIRECT) {\n\n                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (env->singlestep_enabled)\n\n            break;\n\n    } while (!dc->is_jmp && !dc->cpustate_changed\n\n         && gen_opc_ptr < gen_opc_end\n\n                 && !singlestep\n\n         && (dc->pc < next_page_start)\n\n                 && num_insns < max_insns);\n\n\n\n    npc = dc->pc;\n\n    if (dc->jmp == JMP_DIRECT) {\n\n        if (dc->tb_flags & D_FLAG) {\n\n            dc->is_jmp = DISAS_UPDATE;\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n            sync_jmpstate(dc);\n\n        } else\n\n            npc = dc->jmp_pc;\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Force an update if the per-tb cpu state has changed.  */\n\n    if (dc->is_jmp == DISAS_NEXT\n\n        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n        if (dc->is_jmp == DISAS_NEXT)\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, gen_opc_ptr - gen_opc_buf);\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n", "idx": 18620, "substitutes": {"gen_opc_end": ["gen_opcs_end", "gen_opc_END", "gen_opcs_begin", "gen_opcu_start", "gen_opc_len", "gen_opcu_end", "gen_opc_begin", "gen_opcu_len", "gen_opcs_start", "gen_opc2End", "gen_opc2begin", "gen_opc_End", "gen_opcu_END", "gen_opc2end", "gen_opc_start", "gen_opcs_End", "gen_opc2start"], "pc_start": ["arc_id", "vc_started", "pc__size", "pc67size", "pc__end", "pc0count", "pc64start", "pcPstarted", "pcPstart", "PC_end", "pc67end", "vc_pos", "pc67id", "pc__start", "pc__done", "cpu_part", "pc64last", "vc67started", "arc_start", "pc_count", "page_id", "pc_size", "pc_done", "pc_add", "cpu_add", "cpu_started", "pcMdone", "cpu_count", "pc_stop", "pc67pos", "pcMid", "pcMpos", "pc_part", "pc0end", "pc64started", "vc67start", "page_start", "pc67start", "arc_size", "page_stop", "pc64pos", "pc_id", "pc67started", "page_end", "pc_last", "pc_pos", "pcPadd", "pc67last", "PC_done", "pcPend", "PC_start", "arc67pos", "pc_started", "arc_pos", "vc67pos", "pcMend", "PC_size", "cpu_end", "pcMstart", "pc_end", "pc0start", "pcMsize", "pc0part", "arc67start", "vc67last", "vc_start", "pc67add", "arc67id", "cpu_start", "arc67size", "vc_last"], "j": ["jp", "x", "js", "n", "obj", "ij", "job", "i", "kj", "r", "jen", "aj", "ii", "jc", "p", "adj", "uj", "z", " i", "lock", "num", "l", "J", "im", "out", "v", "jj"], "lj": ["lji", "lbb", "lckey", "lcjl", "ljl", "lljl", "lkey", " lkey", "lljp", "lcj", "lbji", " ljl", "ljp", " lb", "lbJ", " lji", "lcji", "lcjp", "lcb", "lJ", " ljp", "lbj", "llj", "lcJ", " lJ", "llkey", "lb"], "ctx": ["cca", "cp", "class", "cm", "cmd", "bc", " gcc", "nc", "cache", "ci", "conn", "exec", " rc", "lib", "config", "aux", " context", "ctl", " c", "cas", "ec", "lc", " cx", "ca", "c", "fp", "cc", "kw", "func", "null", "tx", "cfg", "Context", "context", "cb", "rc", "cmp", "ctrl", "cu", "xc"], "dc": ["g", "di", "client", "wp", "exec", "r", "ga", "cf", "c", "vc", "enter", "thread", "auc", "cfg", "context", "ctrl", "dr", "cd", "cdn", "acl", "nc", "gc", "draw", "design", "mac", "ea", "da", "abc", "die", "fc", "disc", "pc", "uc", "bc", "_", "config", "id", "db", "input", "dir", "uci", "lc", "cc", "func", "git", "rc", "dat", "cca", "df", "ac", "feat", "conn", "dm", "d", "controller", "DC", "enc", "dt", "director", "doc", "ec", "loc", "all", "jc", "de", "tc", "mc", "dest", "seq", "device", "sc", "ctr"], "next_page_start": ["next_page___stop", "next_page2size", "next_page_size", "next_page2st", "next_page___start", "next_page_send", "next_page___end", "next_page_stop", "next_page_end", "next_page2start", "next_page___send", "next_page2end", "next_page_st"], "org_flags": ["org__flags", "org__rules", " org_alls", "org_alls", " org_rules", " org_flag", " org_ops", "orgityrules", "orgityops", "org_ops", "org_settings", "orgityalls", "org_items", " org_items", " org_settings", "org_rules", "org__alls", "orgityflags", "org__ops", "org_flag"], "npc": ["ndcpu", "lc", "npd", "lpd", "ncpu", "unpc", "ndpd", "ndc", "lcpu", "unc", "ndpc", "nc", "uncpu", "lpc", "unpd"], "num_insns": ["num_inscs", "num_outens", "num_insnos", "num_inens", "num_insens", "num_incs", "num_innos", "num_asinn", "num_outns", "num_intsens", "num_asinni", "num_intsns", "num_asinns", "num_outcs", "num_outn", "num_incn", "num_intscs", "num_incni", "num_insn", "num_incns", "num_intsn", "num_inns", "num_incnos", "num_insni", "num_asinnos", "num_inn", "num_inni"], "max_insns": ["max_innn", "max_incnis", "max_vinNs", "max_inks", "max_insnes", "max_incs", "max_insnis", "max_linns", "max_inNs", "max_linnes", "max_innnes", "max_innis", "max_minsn", "max_winns", "max_minsns", "max_minsnis", "max_linn", "max_inn", "max_innns", "max_lincs", "max_incks", "max_incNs", "max_inncs", "max_minscs", "max_links", "max_vinn", "max_innes", "max_winn", "max_wincs", "max_inns", "max_insks", "max_insNs", "max_insn", "max_vinks", "max_incns", "max_vinns", "max_winks", "max_incn", "max_inscs", "max_inccs"], "delayed_branch": ["delayed_blant", "delayed_branc", "delayed_frant", "delayed_tranc", "delayed_franch", "delayed_blanch", "delayed_blruction", "delayed_blanc", "delayed_frruction", "delayed_trruction", "delayed_brant", "delayed_tranch", "delayed_franc", "delayed_trant", "delayed_brruction"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n", "idx": 18624, "substitutes": {"dst": [" dsts", "dssrc", "dsst", "Dst", "rdst", "rdsts", "dbl", " dput", "dsST", "Dput", "udsrc", "dsts", "adST", "adsrc", "sdbl", "sdfe", "dST", "sdput", "rdST", "udbl", "udst", " dfe", "udST", " dbl", "dssts", "dsbl", "rdsrc", "sdst", "adst", "Dfe", "dfe", "dsrc", "adbl", " dsrc", " dST", "dput", "Dbl"], "src1": ["seqA", " srca", "seq2", "srca", "sc0", "rc1", "seqb", "rc0", "source2", "rcb", "rc2", "sourceb", "rc3", "sc3", "scb", "srcb", "source1", "src0", " srcb", "sc1", " srcA", "rca", "rcA", "source3", "srcA", "sourceA", "src3", "seq1", "sourcea", "source0"], "src2": [" srctwo", " src82", "loadb", "srcB", "gb02", "rcB", "src02", "rc1", " src02", "rc0", "loadB", " srcB", "source2", "load1", "gb2", " src0", "load2", "rcb", "rc2", "gb82", "sourceb", "config82", "srcb", "source1", "config02", "config2", "src82", "src0", " srcb", "srctwo", "source0", "configtwo", "gbtwo"], "w": ["g", "wave", "ow", "f", "wt", "x", "u", "t", "wh", "window", "q", "sw", "wei", "wb", "d", "n", "we", "wl", "hw", "fw", "aw", "h", "max", "r", "wx", "win", "ew", "c", "k", "p", "kw", "wed", "iw", "z", "weight", "nw", "ww", "l", "tw", "wa", "W", "v", "m"], "i": ["phi", "di", "f", "ri", "xi", "hi", "cli", "qi", "u", "x", "ix", "ci", "li", "in", "t", "abi", "ji", "bi", "mu", "uri", "it", "d", "api", "n", "ti", "pi", "si", "I", "multi", "id", "ai", "index", "ib", "iu", "o", "lc", "ii", "k", "c", "p", "y", "b", "z", "m", "ui", "ni", "gi", "zi", "yi", "fi", "adi", "e", "l", "a", "io", "oi", "ie", "ini", "v", "mi", "j", "info"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 18629, "substitutes": {"bs": ["cs", "css", "lines", "ms", "http", "ps", "bc", "rs", "BS", "js", "bh", "ss", "bi", "org", "ns", "bb", "plugins", "base", "obj", "ros", "bits", "pb", "iss", "vs", "ls", "rss", "bps", "gs", "sb", "bas", "ris", "ts", "ks", "b", "obs", "ubs", "oss", "fs", "las", "bis", "cb", "gb", "bos", "ses", "os", "ins", "outs", "bes", "ds", "ras", "bl", "fb", "bing"], "res": ["reply", "changes", "cs", "pres", "results", "rez", "resource", "rr", "sys", "ms", "resolution", "ry", "result", "ps", "report", "rest", "rus", "rs", "js", "ss", "req", "reg", "rel", "reed", "vals", "RES", "reset", "ros", "resources", "Res", "rem", "r", "rx", "rss", "rev", "us", "gr", "ref", "details", "resh", "response", "ris", "mr", "tx", "resp", "re", "ress", "def", "err", "rc", "rys", "os", "rows", "spec", "ras", "ver", "rates"], "fix": ["check", "result", "op", "ix", "prefix", "add", "valid", "prev", "force", "back", "config", "before", "reset", "init", "r", "change", "diff", "replace", "next", "call", "fixes", "conf", "FIX", "patch", "correct", "b", "delay", "def", "apply", "re", "update", "err", "pull", " Fix", "Fix", "start", "commit", "bug", "mask"], "rebuild": ["reshold", "reboot", "preuild", "resupdate", "renboot", "refbreak", "refbuild", "restall", "rehold", " unreuild", "reuild", " unrebuild", "Reupdate", "refhold", "Rebreak", " unreboot", "prebuild", "resbuild", "prestall", "preboot", "renuild", "renstall", "reupdate", " unrestall", "refupdate", "Rebuild", "resbreak", "rebreak", "Rehold", "renbuild"], "refcount_table": ["refcount_Table", "refcountabletable", "refcountenarray", "reflastpletable", "refCount_array", "refgroupent", "reflastpleinteger", "reflastplesession", "refpool_t", "refcountxwindow", "refcount_result", "refcounttinteger", "refount_cache", "refCount_Table", "refcount_required", "refcountenresource", "refcount1table", "refcounterservice", "refcount_time", "reflastplet", "refcount1array", "refcount_service", "refCount_time", "refcount_window", "refcountingrequired", "refCount_required", "refcounttt", "refprocessingtab", "refCount_cache", "refcount_cache", "refcountentable", "refcountplet", "refcount_database", "refcountgtotal", "refcountingtime", "refCount_database", "refcounterrequired", "refcount_session", "refcounttmodule", "refcount1t", "refcountNresult", "refcountingtable", "refcountpleinteger", "refcountablet", "refgroupentable", "refcount24service", "refcount1resource", "refcounttsession", "refprocess_table", "refcount24required", "refcount24tab", "refcountNTable", "refcount_TABLE", "refprocess_required", "refcountertable", "refprocess_service", "refcount24table", "refgroup_t", "refcount_integer", "refcountNtable", "refpool_module", "refcount_total", "refpool_table", "refcountgtable", "refcountplesession", "refCount_total", "refCount_window", "refcountingtab", "refcount_array", "refount_table", "refcountertab", "refCount_table", "refcountableresource", "reflast_integer", "refcountablearray", "refcountingTable", "refprocessingservice", "refcountingarray", "refcountxtotal", "refprocessingtable", "refcountgwindow", "refgroup_resource", "refcount_tab", "refpool_TABLE", "refcount_resource", "refcountent", "refcounttTABLE", "refcount_module", "reflast_t", "refcountxtable", "refgroupenarray", "refcountingservice", "refcountgdatabase", "refprocessingrequired", "reflast_session", "refcountpletable", "refcountxdatabase", "reflast_table", "refgroupenresource", "refCount_result", "refgroup_table", "refgroup_array", "refcount_t", "refount_tab", "refcountttable", "refcountingcache", "refprocess_tab"], "nb_clusters": ["nb_lcusters", "nb_glients", "nbovclibraries", "nb_spluster", "nb_CLibraries", "nb_flodes", "nboseclros", "nb_spliffs", "nb_galluster", "nb_CLusters", "nb_plusters", "nb_clodes", "nb_plients", "nb_gluster", "nb_slusters", "nb_splodes", "nb_clients", "nb_fliffs", "nb_plores", "nb_ulows", "nb_Clusters", "nb_CLores", "nbovcluster", "nb_clicas", "nb_clibraries", "nb_licusters", "nb_shorders", "nb_Clients", "nb_ulibraries", "nb_Cluster", "nbosesplappers", "nb_slambers", "nb_shuster", "nb_licayers", "nb_slayers", "nb_colambers", "nbosespluster", "nbovclows", "nb_splusters", "nballclambers", "nb_uluster", "nb_colers", "nb_clores", "nb_lcappers", "nb_CLicas", "nb_clers", "nb_shambers", "nballclers", "nb_clros", "nboseclappers", "nballlicayers", "nb_sclusters", "nb_splros", "nb_CLros", "nb_CLows", "nb_clorders", "nballclayers", "nb_shusters", "nb_flusters", "nbovulows", "nb_CLambers", "nbosesplros", "nb_pluster", "nballlicers", "nb_ulappers", "nb_cliffs", "nb_gallows", "nb_colayers", "nb_cluster", "nbosecluster", "nb_ulusters", "nballlicusters", "nb_lciffs", "nb_scluster", "nbovulusters", "nb_kluster", "nb_clambers", "nb_gallores", "nb_sclambers", "nb_CLients", "nb_Clicas", "nb_clayers", "nbosesplusters", "nb_CLorders", "nb_gallusters", "nb_sclorders", "nbovclusters", "nbovulibraries", "nballclusters", "nb_clows", "nb_clappers", "nb_lcodes", "nb_plows", "nballlicambers", "nb_glusters", "nb_splappers", "nbovuluster", "nb_ulros", "nb_klibraries", "nb_licers", "nboseclusters", "nb_CLuster", "nb_CLappers", "nb_colusters", "nb_plicas", "nb_licambers", "nb_Clores", "nb_slers", "nb_klusters", "nb_glores", "nb_klows", "nb_flappers"], "s": ["g", "self", "sites", "session", "secondary", "js", "h", "r", "gs", "c", "b", "ssl", "sl", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "server", "results", "http", "ns", "ans", "si", "state", "full", "es", "us", "als", "p", "sb", "ts", "y", "services", "l", "sym", "its", "ops", "f", "rs", "ss", "n", "o", "ubs", "xs", "S", "bis", "sg", "ses", "spec", "is", "cs", "css", "sys", "ps", "ls", "details", "service", "e", "settings", "os", "ds", "v", "rates"], "i": ["phi", "di", "ri", " pri", " inf", "xi", "qi", "ix", "x", "ci", "eni", " fi", "I", "h", " li", "c", "gu", "z", "mini", "gi", " j", "ini", "mi", " mi", "name", "u", " ii", " pi", "it", "uri", "si", "ai", "index", " fin", "ik", "iu", "p", "key", "y", "ki", " rest", "ui", "fi", "yi", "l", "io", "ti", "j", "ji", "n", "ip", "id", "vi", "o", "ii", "ni", "zi", " si", "info", "is", " err", " bi", " rep", "li", " reply", "bi", "mu", "d", "pi", " index", "ib", "chi", " ie", "k", " info", "ami", "e", "ie", "v"], "sn": ["kn", "sf", "scl", "sid", "sa", "sp", "ski", "na", "li", "sh", "eni", "sw", "bn", "ny", "sr", "ns", "n", "syn", "si", "sd", "SN", "nn", "cl", "sm", "sch", "span", "sam", "ii", "sk", "sb", "nr", "sl", "su", "ni", "nb", "ne", "fn", "sv", "Sn", "dn", "sc", "an", "sync", "cn"], "ret": ["reply", "val", "match", "et", "off", "end", "valid", "test", "fun", "pet", "code", "flag", "done", "true", "opt", "arg", "lit", "rt", "bit", "let", "pt", "it", "reg", "req", "py", "red", "fail", "job", "reset", "fit", "data", "rev", "nt", "key", "def", "value", "err", "group", "num", "url", "out", "art", "ver", "RET", "f", "cat", "hard", "lt", "error", "base", "pass", "pre", "att", "format", "post", "pret", "en", "run", "rc", "Ret", "rep", "info", "str", "result", "alt", "feat", "success", "repl", "len", "obj", "mt", "ut", "over", " result", "status", "rets", "ext", "ref", "det", "gt", "ber", "rf", "re", "ft", "bf", "debug", "part"], "check_errors": ["check_fixes", "check___error", "check___fixes", "checking_error", "checking_codes", "checking___errors", "checkingfixes", "check___codes", "checkingcodes", "checking___fixes", "checking___codes", "checking___error", "checkingerror", "checking_errors", "check_error", "checking_fixes", "check_codes", "check___errors", "checkingerrors"]}}
{"project": "qemu", "commit_id": "40545f84cfcbe4b73cca040b3043a1c2de935762", "target": 1, "func": "static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    NE2000State *s = opaque;\n\n    int offset, page;\n\n\n\n    addr &= 0xf;\n\n#ifdef DEBUG_NE2000\n\n    printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val);\n\n#endif\n\n    if (addr == E8390_CMD) {\n\n        /* control register */\n\n        s->cmd = val;\n\n        if (val & E8390_START) {\n\n            s->isr &= ~ENISR_RESET;\n\n            /* test specific case: zero length transfert */\n\n            if ((val & (E8390_RREAD | E8390_RWRITE)) &&\n\n                s->rcnt == 0) {\n\n                s->isr |= ENISR_RDC;\n\n                ne2000_update_irq(s);\n\n            }\n\n            if (val & E8390_TRANS) {\n\n                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);\n\n                /* signal end of transfert */\n\n                s->tsr = ENTSR_PTX;\n\n                s->isr |= ENISR_TX;\n\n                ne2000_update_irq(s);\n\n            }\n\n        }\n\n    } else {\n\n        page = s->cmd >> 6;\n\n        offset = addr | (page << 4);\n\n        switch(offset) {\n\n        case EN0_STARTPG:\n\n            s->start = val << 8;\n\n            break;\n\n        case EN0_STOPPG:\n\n            s->stop = val << 8;\n\n            break;\n\n        case EN0_BOUNDARY:\n\n            s->boundary = val;\n\n            break;\n\n        case EN0_IMR:\n\n            s->imr = val;\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN0_TPSR:\n\n            s->tpsr = val;\n\n            break;\n\n        case EN0_TCNTLO:\n\n            s->tcnt = (s->tcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_TCNTHI:\n\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RSARLO:\n\n            s->rsar = (s->rsar & 0xff00) | val;\n\n            break;\n\n        case EN0_RSARHI:\n\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RCNTLO:\n\n            s->rcnt = (s->rcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_RCNTHI:\n\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_DCFG:\n\n            s->dcfg = val;\n\n            break;\n\n        case EN0_ISR:\n\n            s->isr &= ~(val & 0x7f);\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN1_PHYS ... EN1_PHYS + 5:\n\n            s->phys[offset - EN1_PHYS] = val;\n\n            break;\n\n        case EN1_CURPAG:\n\n            s->curpag = val;\n\n            break;\n\n        case EN1_MULT ... EN1_MULT + 7:\n\n            s->mult[offset - EN1_MULT] = val;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 18640, "substitutes": {"opaque": ["opatile", "opque", "iopque", "iopacity", "operacity", "operatile", "opacity", " opque", "opera", "operque", " opacity", " opatile", "opa", " opa", "iopatile", "iopa", "operaque", "iopaque"], "addr": ["dr", "sid", "src", "mode", "route", "cmd", "node", "nc", "x", "prefix", "inst", "inc", "pad", "ad", "point", "d", "coord", "ip", "len", "layer", "mt", "lon", "id", "address", "index", "ord", "padding", "code", "adr", "data", "ace", "hop", "align", "mac", "loc", "ext", "slot", "ref", "pos", "amp", "pointer", "ptr", "vr", "rc", "attr", "url", "cb", "num", "port", "alias", "env", "amd", "device", "debug", "md", "oa", "host"], "val": ["local", "grad", "VAL", "split", "aval", "x", "end", "exec", "valid", "test", "pl", "byte", "ee", "Val", "live", "al", "ssl", "sl", "update", "prop", "sec", "arg", "lit", "pt", "ul", "buf", "py", "fail", "index", "data", "fl", "slot", "p", "key", "vol", "nil", "eval", "role", "def", "value", "url", "pid", "serv", "bool", "bl", "au", "cal", "buffer", "base", "config", "db", "il", "win", "ctx", "pre", "format", "sil", "pos", "ind", "sel", "ret", "arr", "rot", "pal", "alt", "ol", "dim", "el", "vals", "len", "util", "doc", "stat", "loc", "all", "ref", "ld", "sol", "unit", "count", "start", "v", "elt"], "s": ["g", "self", "sites", "ms", "session", "uns", "js", "scope", "h", "r", "gs", "conf", "c", "ssl", "b", "sl", "fs", "stats", "as", "states", "sec", "sets", "a", "ins", "qs", "m", "server", "http", "u", "ns", "site", "si", "args", "i", "state", "your", "es", "us", "p", "sb", "ts", "sie", "y", "services", "l", "port", "sym", "serv", "se", "its", "sync", "f", "this", "rs", "south", "ss", "sq", "o", "xs", "S", "bis", "sg", "ses", "hs", "spec", "is", "cs", "sys", "aws", "ps", "new", "t", "d", "status", "ls", "stat", "service", "request", "e", "os", "v", "ds", "an", "settings"], "offset": ["bit", "set", "header", "orient", "number", "operation", "mode", "range", "type", "net", "et", "off", "pad", "end", "fee", "phase", "ip", "len", "base", "position", "location", "reset", "address", "index", "padding", "o", "offer", "Offset", "hop", "align", "loc", "slot", "ref", "nt", "line", "pos", "p", "ptr", "count", "num", "seq", "start", "port", "rot", "order", "part", "layer"], "page": ["server", "f", "pc", "sp", "number", "inc", "x", "net", "pen", "end", "phase", "ip", "len", "site", "n", "col", "pg", "pl", "pp", "code", "next", "loc", "ref", "p", "line", "limit", "pos", "key", "Page", "wait", "value", "pages", "step", "count", "num", "url", "age", "row", "e", "port", "pid", "size", "order", "v", "ver"]}}
{"project": "FFmpeg", "commit_id": "0a359cf157957f3eb37760f731fa75dd320fd659", "target": 0, "func": "static int vc1_filter_line(uint8_t* src, int stride, int pq){\n\n    int a0, a1, a2, a3, d, clip, filt3 = 0;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n\n    if(FFABS(a0) < pq){\n\n        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;\n\n        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;\n\n        a3 = FFMIN(FFABS(a1), FFABS(a2));\n\n        if(a3 < FFABS(a0)){\n\n            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;\n\n            clip = (src[-1*stride] - src[ 0*stride])/2;\n\n            if(clip){\n\n                filt3 = 1;\n\n                if(clip > 0)\n\n                    d = av_clip(d, 0, clip);\n\n                else\n\n                    d = av_clip(d, clip, 0);\n\n                src[-1*stride] = cm[src[-1*stride] - d];\n\n                src[ 0*stride] = cm[src[ 0*stride] + d];\n\n            }\n\n        }\n\n    }\n\n    return filt3;\n\n}\n", "idx": 18646, "substitutes": {"src": ["grad", "uv", "bs", "proc", "split", "sr", "view", "support", "cl", "pl", "st", "stream", "app", "head", "b", "ssl", "sl", "attr", "gb", "sub", "use", "http", "inst", "source", "bb", "hw", "lib", "img", "usr", "us", "sb", "gl", "uint", "msg", "url", "obl", "fc", "comp", "host", "sync", "sn", "scan", "kk", "uc", "rest", "bc", "rs", "sit", "sq", "conv", "stack", "config", "iv", "rss", "ctx", "rb", "sup", "impl", "dist", "sel", "rc", "fn", "cb", "upp", "ack", "rect", "spec", "secure", "go", "supp", "chrom", "feat", "cur", "pack", "grab", "loc", "cont", "cv", "usc", "sur", "pull", "seq", "dest", "text", "sc", "ctr"], "stride": ["sprided", "staine", "Stride", "staide", " straine", "strides", "striden", "Strider", "variine", "bride", "hrine", "instider", "Strided", "divide", "sline", " stripe", "yrride", "arrider", "strride", "strode", "Strine", "divided", "Striden", "stide", "stridi", "arride", "slided", "stidi", " strider", "stided", "stripe", "sliden", " strand", "variider", "staider", "stand", "striding", "slipe", "sprine", "instine", "stiding", "instride", " stridi", "slode", "yrider", "cline", "bridi", "Strides", "clipe", "clide", "Straine", "yride", "strand", "strider", "staride", " strine", " strides", "Striding", " strande", "hride", "instide", "stider", "hrided", "arriden", "Stripe", "variipe", "stode", "sprider", "brided", "strided", "strine", "spride", "stande", "Strride", "stine", " striding", "yrande", " strided", "instand", "staided", "straine", "Strode", "instided", "hrider", "brider", "brine", "divider", "variided", "arrided", "slider", "bripe", "slide", "brride", "clider", "brides", " strride", "strande", "stipe", "variide", "divipe"], "pq": ["Pq", "jpQ", "jpcharge", " pqa", "tpqq", "PQ", "pQ", "tpqa", "Pcharge", "pqq", " pQ", "jpqu", "jpq", "tpQ", "tpqu", " pqu", "pqu", "jpqq", "pqa", "Pqq", "pcharge", "jpqa", "tpcharge", "tpq"], "a0": ["A5", "ae9", " a4", "ga9", "alpha2", "va5", "ga5", "p080", "p0", "alpha1", "a4", "aa1", "ia2", "ae2", "ga05", "ae1", "A8", "alpha0", "ga2", "p1", "a00", "aa0", "a9", "ae0", "ia0", " a00", "ga00", "va0", "aa8", " a9", "A2", "a8", "alpha9", "ga4", "a05", "va05", "p2", "alpha5", "a080", "va00", "aa5", "ga0", " a05", "A0", "A1", "A080", "ia1", " a5", "ia080", "a5", "alpha4", " a8"], "a1": ["A5", "ac4", " a4", "alpha2", "na5", "alpha4", "sa1", "ac3", "ac5", "a4", "alpha1", "am0", "am5", "am1", "alpha0", "sa0", "sa2", "na4", "na3", "A2", "am2", "A0", "A1", "sa5", " a5", "ac1", "na1", "a5", "A4"], "a2": ["ac4", " a4", " a62", "A3", "an3", "sa3", "am42", "an8", "a4", "an2", " a42", "ac62", "an4", "am8", "sa4", "am4", "sa0", "ac8", "sa2", "A2", "a8", "ac2", "am2", "an0", "A0", "a42", "ac42", "a62", "an62", "A4", " a8"], "a3": [" a15", "ar8", " a23", "A5", "A3", "sa6", "a03", "an3", "ar15", "a6", "an83", "p23", "A23", "A83", "sa3", "an8", "p0", "aa03", "an6", "ar3", " a83", "a83", "aa1", "aa3", "an2", "ar83", "A6", "sa0", "an5", " a03", "aa8", "aa83", "A2", "a8", "a15", "a23", "p2", "p3", "aa15", "an0", "A0", "A1", "an03", "sa5", "an1", "a5", " a8"], "d": ["g", "dr", "cd", "di", "min", "dh", "bd", "dc", "f", "D", "du", "x", "u", "dd", "del", "t", "pad", "ad", "dim", "q", "dos", "n", "fd", "sd", "i", "id", "dt", "h", "dom", "diff", "data", "dl", "dx", "dy", "w", "ded", "c", "p", "s", "depth", "ld", "da", "dad", "nd", "b", "delay", "ind", "y", "z", "dist", "md", "yd", "e", "die", "l", "dat", "a", "v", "ds", "did", "j", "m"], "clip": ["ape", "skip", "scale", "none", "split", "x", "sh", "low", "zip", "cl", "pl", "block", "c", "close", "limit", "b", "keep", "sl", "z", "up", "strip", "shape", "tool", "az", "ide", "hide", "copy", "op", "tip", "load", "pad", "gap", "job", "qa", "iff", "p", "plane", "lock", "push", "comp", "clone", "sync", "cp", "f", "large", "cut", "q", "ad", "ip", "id", "diff", "dl", "ipp", "cap", "kill", "around", "ignore", "apply", "crop", "stop", "bd", "du", "cel", "flow", "drop", "pick", "grab", "loop", "pe", "slice", "pull"], "cm": ["core", "container", "cd", "cp", "cdn", "gm", "map", "uv", "com", "cmd", "rom", "bc", "sem", "ci", "mx", "rm", "wm", "fm", "pm", "iam", "bm", "config", "module", "cl", "img", "con", "ram", "ctx", "lc", "comm", "ca", "cf", "km", "c", "cc", "cv", "cam", "cr", "am", "m", "vm", "cb", "rc", "mc", "cmp", "ym", "ctrl", "mm", "im", "don", "CM", "ctr", "cn"]}}
{"project": "FFmpeg", "commit_id": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb", "target": 0, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n                      int src_count, int src_size, int dest_len)\n\n{\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            return 0;\n\n        *pd++ = bytestream2_get_byteu(&gb);\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            break;\n\n        l = bytestream2_get_byteu(&gb);\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)\n\n                return bytestream2_tell(&gb);\n\n            bytestream2_get_bufferu(&gb, pd, l);\n\n            pd += l;\n\n        } else {\n\n            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)\n\n                return bytestream2_tell(&gb);\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n            }\n\n            bytestream2_skip(&gb, 2);\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return bytestream2_tell(&gb);\n\n}\n", "idx": 18648, "substitutes": {"src": ["split", "uc", "inst", "rs", "source", "cur", "sq", "sr", "rib", "gd", "config", "ources", "storage", "img", "ctx", "loc", "rb", "sb", "inf", "ssl", "sl", "sur", "slice", "dist", "sel", "image", "gz", "rc", "url", "cb", "attr", "sub", "sth", "sc", "buff", "sync"], "dest": ["cp", "class", "trans", "dc", "later", "large", "route", "rest", "uc", "source", "dd", "standard", "wh", "end", "d", "wb", "comb", "gd", "config", "dev", "ident", "slave", "path", "pb", "img", "data", "usr", "target", "Dest", "wd", " destination", "sb", "de", "tmp", "std", "sup", "dist", "desc", "done", "slice", "home", "ptr", "delete", "remote", "lit", "destroy", "buff", "v", "sync", "mode"], "src_count": ["source_len", "src_length", "source_sum", " src_order", "src__length", "src__len", "src_limit", "source_size", "src64count", "src__sum", "src64length", "src_sum", "src64size", " src_length", "src_low", " src_limit", "src__low", "src_order", "srcqlength", "srcqcount", "src__id", "src__count", "src_len", "srcqorder", "srcqsize", " src_id", "src__size", "source_count", "src_id", "src__limit", "src64order", " src_low"], "src_size": ["src_length", "src2length", "src2size", " src_length", "src_len", "src2len", "src2name", " src_len", " src_name", "src_name"], "dest_len": ["Dest_size", "dest_l", "Dest_pos", "Dest_length", "dest_size", "Dest_len", "dest_line", "dest_length", "dest_pos", "Dest_l", "Dest_line"], "pd": ["cp", "cd", "cdn", "bd", "grad", "dra", "pc", "ud", "lv", "wp", "tp", "ppa", "dd", "lp", "po", "td", "ci", "li", "api", "d", "py", "dk", "bb", "wb", "pm", "fd", "gd", "sd", "pi", "god", "lib", "pg", "od", "dt", "db", "pl", "pb", "edd", "data", "parser", "PD", "dl", "lc", "php", "wd", "p", "sb", "ld", "fp", "da", "std", "xd", "pkg", "slice", "hd", "dL", "vd", "pod", "bf", "dp", "sv", "pid", "pro", "wa", "sg", "sth", "ds", "md"], "i": ["g", "phi", "di", "f", "ri", "split", "ll", "xi", "cli", "hi", "x", "u", "qi", "ix", "ci", "li", "in", "t", "el", "bi", "L", "ji", "uri", "d", "n", "ip", "ti", "I", "pi", "si", "id", "ai", "index", "r", "iu", "o", "dl", "lc", "ii", "c", "k", "p", "y", "ind", "b", "z", "ui", "ni", "gi", "count", "fi", "yi", "e", "start", "io", "list", "ie", "ini", "v", "mi", "j", "m"], "l": ["g", "bl", "f", "length", "ll", "u", "ul", "ol", "lp", "li", "lo", "t", "el", "L", "d", "lf", "n", "len", "kl", "col", "lu", "pl", "h", "r", "il", "ls", "o", "dl", "lc", "nl", "fl", "all", "c", "k", "p", "s", "line", "b", "sl", "ell", "z", "le", "la", "e", "tl", "lb", "v", "ln", "j", "m"], "dest_end": ["Dest_limit", "destalend", "dest___len", "src_last", "destallstart", "destalllimit", "src_start", "Dest_enc", "destalname", "dest_enc", "dest_last", "destalstart", "Dest_name", "destaclast", "dest___start", "Dest_start", "dest_name", "Dest_end", "destacstart", "Dest_len", "destallend", "destacend", "dest_limit", "dest___enc", "src_tail", "src_end", "dest_start", "destallname", "dest_tail", "destallimit", "destactail", "dest___end"], "gb": ["g", "cd", "gru", "gm", "gin", "bo", "greg", "pc", "cli", "range", "git", "bc", "gam", "ci", "gow", "gc", " rc", "bb", "hub", "gd", " GB", "bm", "boot", "gal", "gom", "pg", "db", "storage", "Gb", "eb", "lc", "ga", "gio", "rb", "gram", " rg", "gs", "sb", "gt", "gu", "gl", "gh", "b", "sl", "gi", "mb", "rg", "gp", "cfg", "gn", "hd", "gz", "ui", "nb", "gae", "gy", " storage", "cb", "rc", "bf", "yg", "gg", " db", "phy", "ub", "GB", "kb", "usb", "ds", "bg", " rgb"]}}
{"project": "FFmpeg", "commit_id": "1dff9adcb934175fe1beb14ee139ad0636daa29d", "target": 0, "func": "static int recheck_discard_flags(AVFormatContext *s, int first)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i, changed = 0;\n\n\n\n    /* Check if any new streams are needed */\n\n    for (i = 0; i < c->n_playlists; i++)\n\n        c->playlists[i]->cur_needed = 0;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n\n        if (st->discard < AVDISCARD_ALL)\n\n            pls->cur_needed = 1;\n\n    }\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->cur_needed && !pls->needed) {\n\n            pls->needed = 1;\n\n            changed = 1;\n\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n            pls->pb.eof_reached = 0;\n\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n\n                /* catch up */\n\n                pls->seek_timestamp = c->cur_timestamp;\n\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n\n                pls->seek_stream_index = -1;\n\n            }\n\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n\n        } else if (first && !pls->cur_needed && pls->needed) {\n\n            if (pls->input)\n\n                ff_format_io_close(pls->parent, &pls->input);\n\n            pls->needed = 0;\n\n            changed = 1;\n\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n\n        }\n\n    }\n\n    return changed;\n\n}\n", "idx": 18649, "substitutes": {"s": ["is", "g", "cs", "server", "f", "sys", "sa", "aws", "session", "ps", "http", "less", "u", "rs", "ds", "js", "t", "ss", "sq", "ns", "ans", "n", "si", "args", "h", "r", "es", "o", "us", "gs", "conf", "sts", "p", "sb", "ks", "service", "ts", "ssl", "b", "sl", "su", "fs", "services", "stats", "S", "as", "sg", "e", "ses", "sv", "os", "sets", "l", "a", "ins", "settings", "events", "sc", "se", "spec", "qs", "v", "its", "sync", "m"], "first": ["based", "alpha", "initial", "leaf", "now", "seen", "f", "split", "latest", "end", "error", "prev", "root", "before", "one", "found", "max", "change", "last", "full", "used", "top", "repeat", "next", "only", "always", "final", "p", "correct", "missing", "current", "count", "start", "required", "empty", "second", "once", "First", "use"], "c": ["g", "cs", "cd", "cp", "cm", "dc", "f", "coll", "pc", "uc", "bc", "ac", "u", "nc", "ci", "cur", "t", "conn", "d", "n", "ch", "enc", "config", "h", "r", "co", "con", "o", "ctx", "ec", "lc", "ca", "cf", "conf", "k", "ce", "p", "cc", "ic", "vc", "b", "cr", "cus", "tc", "ct", "mc", "e", "l", "ctrl", "C", "cu", "sc", "v", "m"], "i": ["g", "is", "phi", "di", "my", "f", "ri", "changed", "xi", "hi", "cli", "name", "x", "u", "qi", "ix", "ci", "li", "in", "isin", "abi", "eni", "bi", "it", "uri", "mu", "d", "mi", "n", "ip", "I", "si", "pi", "multi", "id", "init", "index", "ai", "h", "iv", "iu", "o", "lc", "ii", "k", "p", "y", "ind", "b", "m", "ui", "ni", "gi", "zi", "ami", "yi", "fi", "e", "l", "start", "ori", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "info"], "st": ["stop", "str", "sn", "stal", "sa", "pt", "sp", "src", "inst", "rest", "sh", "ss", "sw", "sr", "St", "stack", "si", "sd", "est", "ist", "fr", "rss", "ace", "sb", "ld", "std", "pe", "cr", "be", "su", "se", "ST", "sta", "ft", "ct", "sec", "sts", "start", "ast", "sth", "sc", "ste"], "pls": [" plsb", "lld", "clg", "PLd", "splp", "spls", "plsb", "ynos", "implp", " plses", "ynp", "pgs", "relp", " plg", "feeds", "logi", " plis", "yng", "PLs", " plos", "yns", "pgi", "phs", " plS", "plss", "cli", "plws", "plis", "slp", "llp", " plsets", "Plsets", "feedp", "implops", "plS", "PLi", "plsets", " plss", " plws", "logsb", " plp", " Pli", " Pld", "splsb", "splg", "phses", "celsets", "plp", "pps", "plds", "pld", "plses", "Pls", "splss", "PlS", "Plp", "spli", " plds", "plops", "splws", "ptds", "cls", "feedsets", "celses", "splsets", "spld", "logs", "cels", "controls", "splos", "ppp", " pli", "plg", "celp", "ppds", "splds", "sls", "relss", "lls", "ynws", "puti", "putS", "yni", "impls", "pgis", "splops", "pgp", "phsets", " pld", "pgses", "pli", "php", "slsets", "clp", "logd", "pts", "clis", "rels", " plops", "controlsets", " Pls", "ptp", "Pli", "controlses", "sld", "plos"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_transfer(int tpm_fd,\n\n                                         const TPMLocality *locty_data)\n\n{\n\n    return tpm_passthrough_unix_tx_bufs(tpm_fd,\n\n                                        locty_data->w_buffer.buffer,\n\n                                        locty_data->w_offset,\n\n                                        locty_data->r_buffer.buffer,\n\n                                        locty_data->r_buffer.size);\n\n}\n", "idx": 18673, "substitutes": {"tpm_fd": ["tPM_FD", "tpm_writer", "tpmfid", "tpm_db", "tpmfdb", "tpmfd", "tPM_writer", "tPM_id", "tPM_d", "tpm_d", "tpm_FD", "tpm67db", "tPM_fd", "tpm67id", "tpm67d", "tpm67fd", "tpmffd", "tPM_db", "tpm_id"], "locty_data": ["loctyuserui", "loctyMdata", "locty_size", "locti_parent", "loctory_writer", "locty2buffer", "loctory_buffer", "loctiy_ui", "locty_writer", "locty_result", "loctyd_reader", "loctyPparent", "locti_data", "loctory_data", "locty2writer", "locty_reader", "locti_size", "loctiy_result", "loctya_size", "loctiy_data", "loctyd_data", "loctyuserdat", "loctyPimage", "loctyPdata", "loctory2resource", "loctya_data", "locty_database", "loctysdata", "locty_dat", "loctysreader", "locty_image", "loctory2writer", "loctya_database", "loctyMcache", "locty_parent", "loctyuserresult", "loctiy_dat", "loctyd_args", "locty_cache", "locty_buffer", "loctysargs", "loctyPsize", "locty_resource", "locty_args", "loctya_cache", "loctyuserdata", "loctysbuffer", "loctory2buffer", "loctyd_buffer", "loctory_resource", "loctyMdatabase", "locty2data", "locty2resource", "locty_ui", "loctory2data", "locti_image", "loctyMsize"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n", "idx": 18675, "substitutes": {"flags": ["frames", "lag", "styles", "notes", "f", "orts", "reports", "ports", "linux", "vals", "alls", "rules", "plugins", "len", "allows", "fd", "args", "ints", "locks", "caps", "types", "bits", "tools", "codes", "lins", "FLAG", "opens", "strings", "errors", "files", "atts", "all", "Flags", "ffff", "powers", "details", "s", "tones", "comments", "fires", "flag", "fs", "stats", "pants", "ags", "states", "count", "ants", "planes", "options", "utils", "fe", "requires", "words", "features", "checks", "mask", "rep", "info"]}}
{"project": "qemu", "commit_id": "f85da3081d001909929a19e530e69cea0487f00e", "target": 1, "func": "void sh4_translate_init(void)\n\n{\n\n    int i;\n\n    static const char * const gregnames[24] = {\n\n        \"R0_BANK0\", \"R1_BANK0\", \"R2_BANK0\", \"R3_BANK0\",\n\n        \"R4_BANK0\", \"R5_BANK0\", \"R6_BANK0\", \"R7_BANK0\",\n\n        \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\n\n        \"R0_BANK1\", \"R1_BANK1\", \"R2_BANK1\", \"R3_BANK1\",\n\n        \"R4_BANK1\", \"R5_BANK1\", \"R6_BANK1\", \"R7_BANK1\"\n\n    };\n\n    static const char * const fregnames[32] = {\n\n         \"FPR0_BANK0\",  \"FPR1_BANK0\",  \"FPR2_BANK0\",  \"FPR3_BANK0\",\n\n         \"FPR4_BANK0\",  \"FPR5_BANK0\",  \"FPR6_BANK0\",  \"FPR7_BANK0\",\n\n         \"FPR8_BANK0\",  \"FPR9_BANK0\", \"FPR10_BANK0\", \"FPR11_BANK0\",\n\n        \"FPR12_BANK0\", \"FPR13_BANK0\", \"FPR14_BANK0\", \"FPR15_BANK0\",\n\n         \"FPR0_BANK1\",  \"FPR1_BANK1\",  \"FPR2_BANK1\",  \"FPR3_BANK1\",\n\n         \"FPR4_BANK1\",  \"FPR5_BANK1\",  \"FPR6_BANK1\",  \"FPR7_BANK1\",\n\n         \"FPR8_BANK1\",  \"FPR9_BANK1\", \"FPR10_BANK1\", \"FPR11_BANK1\",\n\n        \"FPR12_BANK1\", \"FPR13_BANK1\", \"FPR14_BANK1\", \"FPR15_BANK1\",\n\n    };\n\n\n\n    for (i = 0; i < 24; i++) {\n\n        cpu_gregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, gregs[i]),\n\n                                              gregnames[i]);\n\n    }\n\n    memcpy(cpu_gregs + 24, cpu_gregs + 8, 8 * sizeof(TCGv));\n\n\n\n    cpu_pc = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pc), \"PC\");\n\n    cpu_sr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, sr), \"SR\");\n\n    cpu_sr_m = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_m), \"SR_M\");\n\n    cpu_sr_q = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_q), \"SR_Q\");\n\n    cpu_sr_t = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_t), \"SR_T\");\n\n    cpu_ssr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, ssr), \"SSR\");\n\n    cpu_spc = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, spc), \"SPC\");\n\n    cpu_gbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, gbr), \"GBR\");\n\n    cpu_vbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, vbr), \"VBR\");\n\n    cpu_sgr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, sgr), \"SGR\");\n\n    cpu_dbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, dbr), \"DBR\");\n\n    cpu_mach = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, mach), \"MACH\");\n\n    cpu_macl = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, macl), \"MACL\");\n\n    cpu_pr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pr), \"PR\");\n\n    cpu_fpscr = tcg_global_mem_new_i32(cpu_env,\n\n                                       offsetof(CPUSH4State, fpscr), \"FPSCR\");\n\n    cpu_fpul = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, fpul), \"FPUL\");\n\n\n\n    cpu_flags = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t       offsetof(CPUSH4State, flags), \"_flags_\");\n\n    cpu_delayed_pc = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t\t    offsetof(CPUSH4State, delayed_pc),\n\n\t\t\t\t\t    \"_delayed_pc_\");\n\n    cpu_delayed_cond = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State,\n\n                                                       delayed_cond),\n\n                                              \"_delayed_cond_\");\n\n    cpu_ldst = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t      offsetof(CPUSH4State, ldst), \"_ldst_\");\n\n\n\n    for (i = 0; i < 32; i++)\n\n        cpu_fregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, fregs[i]),\n\n                                              fregnames[i]);\n\n}\n", "idx": 18696, "substitutes": {"i": ["phi", "di", "f", "ri", "xi", "hi", "qi", "x", "ix", "u", "ci", "li", "abi", "t", "ji", "bi", "uri", "mu", "eni", "it", "mi", "info", "n", "ip", "I", "pi", "si", "multi", "id", "uni", "ai", "index", "iu", "o", "hei", "ii", "c", "p", "s", "key", "y", "ind", "b", "z", "slice", "mini", "ui", "gi", "zi", "fi", "yi", "anti", "e", "l", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "m"], "gregnames": ["structnames", "rgnames", "gramnam", "rgNames", "gregNames", "rgname", "regname", "regnames", "gregnam", "structname", "structNames", "gramnames", "rgnam", "gramNames", "regNames", "gramname", "regnam", "gregname", "structnam"], "fregnames": ["fdebugnames", "fdebugname", "fregisterspec", "fgregname", "fregisterdef", "gregdef", "fgregnames", "ggregnames", "gregspec", "fdebugspec", "fdebugdef", "fregisternames", "ggregspec", "fregistername", "fregdef", "ggregname", "ggregdef", "fregname", "fregspec", "gregname", "fgregspec", "fgregdef"]}}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    st = av_new_stream(oc, 1);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not alloc stream\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* find the MP2 encoder */\n\n    codec = avcodec_find_encoder(codec_id);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n    c = &st->codec;\n\n    c->codec_type = CODEC_TYPE_AUDIO;\n\n\n\n    /* put sample parameters */\n\n    c->bit_rate = 64000;\n\n    c->sample_rate = 44100;\n\n    c->channels = 2;\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* init signal generator */\n\n    t = 0;\n\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n\n\n\n    audio_outbuf_size = 10000;\n\n    audio_outbuf = malloc(audio_outbuf_size);\n\n\n\n    /* ugly hack for PCM codecs (will be removed ASAP with new PCM\n\n       support to compute the input frame size in samples */\n\n    if (c->frame_size <= 1) {\n\n        audio_input_frame_size = audio_outbuf_size / c->channels;\n\n        switch(st->codec.codec_id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            audio_input_frame_size >>= 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    } else {\n\n        audio_input_frame_size = c->frame_size;\n\n    }\n\n    samples = malloc(audio_input_frame_size * 2 * c->channels);\n\n\n\n    return st;\n\n}\n", "idx": 18700, "substitutes": {"oc": ["rec", "coll", "dc", "pc", "uc", "bc", "ac", "mic", "org", "toc", "oci", "osc", "isc", "irc", "ocr", "o", "ctx", "mot", "ec", "circ", "loc", "cf", "OC", "acs", "cc", "usc", "cot", "roc", "auc", "ocol", "soc", "rc", "ogg", "voc", "anc", "ucc", "fc"], "codec_id": ["codec0ID", "codec0type", "codroc_type", "codef_name", "codroc___name", "codroc___id", "codroc_id", "codec___id", "codroc___type", "codoc_code", "codroc_vid", "codec___name", "codec0id", "codec0ids", "codec0name", "codec_vid", "codef_ids", "codroc___vid", "codec_type", "codec___type", "codoc_type", "codoc_id", "codoc_name", "codroc_name", "codec_ID", "codec_ids", "codec_code", "codef_id", "codec___vid", "codec_name", "codef_ID", "codec0code"], "codec": ["cedef", "codeec", "codbc", " codEC", "pedEC", "labec", "Codoc", "cilec", "odesc", "cilect", "Codroc", "odect", "codoc", "compesc", "odac", "Codeca", "codac", "odeca", "codeoc", "cedec", "codef", " codbc", "labesc", "compef", " codoc", "Codesc", " codect", "pedesc", "codesc", "labac", "codeesc", "pedoc", "compbc", " codesc", " codef", " codeca", "odec", "Codec", "codEC", "chesc", "compec", "cilac", " codac", "CodEC", "odbc", "codect", "pedec", "labect", "cedect", "chroc", "odef", "codeca", "coderoc", "codroc", "Codac", "cedeca", "cilesc", "chec", "choc"], "c": ["g", "cs", "self", "rec", "coll", "dc", "f", "client", "cm", "pc", "uc", "ac", "cache", "nc", "u", "ci", "bc", "t", "exec", "d", "n", "col", "ch", "i", "config", "enc", "chain", "cl", "h", "code", "r", "co", "con", "o", "ctx", "ec", "lc", "call", "ca", "cf", "jc", "k", "p", "s", "cc", "ic", "cy", "vc", "b", "content", "abc", "tc", "m", "ct", "rc", "cb", "mc", "e", "l", "ctrl", "anc", "C", "cu", "xc", "spec", "cod", "fc", "v", "icc", "cn"], "st": ["stop", "str", "sn", "pt", "sa", "sp", "src", "inst", "rest", "td", "t", "ss", "form", "sw", "back", "d", "test", "spect", "St", "stack", "obj", "est", "ut", "ist", "cl", "put", "r", "fr", "ace", "stream", "stand", "nt", "sb", "stim", "ld", "std", "tmp", "ost", "pe", "ust", "sl", "cr", "stage", "se", "ST", "sta", " est", "step", "ct", "sec", "sts", "e", "start", " St", "fe", "ast", "sth", "sc", "ste", "rt", "stable", "art"]}}
{"project": "FFmpeg", "commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "target": 1, "func": "static av_cold int libopenjpeg_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibOpenJPEGContext *ctx = avctx->priv_data;\n\n    int err = AVERROR(ENOMEM);\n\n\n\n    opj_set_default_encoder_parameters(&ctx->enc_params);\n\n\n\n    ctx->enc_params.cp_rsiz = ctx->profile;\n\n    ctx->enc_params.mode = !!avctx->global_quality;\n\n    ctx->enc_params.cp_cinema = ctx->cinema_mode;\n\n    ctx->enc_params.prog_order = ctx->prog_order;\n\n    ctx->enc_params.numresolution = ctx->numresolution;\n\n    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;\n\n    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;\n\n    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;\n\n    ctx->enc_params.tcp_numlayers = ctx->numlayers;\n\n    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;\n\n\n\n    if (ctx->cinema_mode > 0) {\n\n        cinema_parameters(&ctx->enc_params);\n\n    }\n\n\n\n    ctx->compress = opj_create_compress(ctx->format);\n\n    if (!ctx->compress) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the compressor\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    ctx->image = mj2_create_image(avctx, &ctx->enc_params);\n\n    if (!ctx->image) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the mj2 image\\n\");\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating coded frame\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    memset(&ctx->event_mgr, 0, sizeof(opj_event_mgr_t));\n\n    ctx->event_mgr.info_handler    = info_callback;\n\n    ctx->event_mgr.error_handler = error_callback;\n\n    ctx->event_mgr.warning_handler = warning_callback;\n\n    opj_set_event_mgr((opj_common_ptr) ctx->compress, &ctx->event_mgr, avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opj_destroy_compress(ctx->compress);\n\n    ctx->compress = NULL;\n\n    opj_image_destroy(ctx->image);\n\n    ctx->image = NULL;\n\n    av_freep(&avctx->coded_frame);\n\n    return err;\n\n}\n", "idx": 18719, "substitutes": {"avctx": ["avconnection", "navkb", "avnp", "AVnp", "avecn", "avcrit", "avchan", "AVctrl", "avekb", "avca", "avkb", "avecrit", "svca", "afctrl", " avkb", "verctrl", "avpc", "aveloc", "airconnection", "AVloc", "Avkb", "avconn", "svctx", "avcmp", "AVcrit", "avectx", "avcontext", "afconn", "avcb", "avctrl", "avepc", "verctx", "AVctx", "avecontext", "varcontext", "AVcontext", "aircf", "airlc", "avlc", "AVcf", "afconnection", "AVcn", "afcontext", "svctrl", " avloc", "navchan", "Avcontext", "aflc", "varnp", "varctx", "avloc", "afcb", "vercf", " avpc", "Avcb", "Avcmp", "Avctx", "AVconn", "AVchan", "navcontext", "AVkb", "avectrl", "afctx", "Avchan", "AVca", " avcontext", "AVlc", "avenp", "aveca", "varctrl", "AVpc", "AVcmp", "AVcb", "avcf", "airctx", "AVconnection", "svcontext", "vercontext", "navctx", "aircontext", " avcrit", "avecmp", "airctrl", "afcn", "afcmp", "aveconn", "avcn"], "ctx": ["coll", "client", "component", "chan", "na", "ci", "bh", "exec", "connection", "fw", "support", "cl", "act", "cf", "c", "vc", "cfg", "context", "voc", "ctrl", "utils", "cm", "acl", "cli", "nc", "gc", "req", "np", "hw", "qa", "cas", "fp", "cam", "kw", "pkg", "wcs", "cu", "kb", "fc", "sync", "cp", "cat", "pc", "cal", "ck", "cmd", "bc", "sq", "crit", "conv", "cms", "config", "concept", "lc", "cc", "sci", "cus", "la", "ct", "git", "cb", "rc", "fn", "cn", "cca", "cs", "txt", "sys", "prefix", "conn", "co", "loc", "ca", "cv", "tx", "tc", "cmp", "anc", "xc", "sc"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n", "idx": 18724, "substitutes": {"flags": ["lag", "f", "ops", "ids", "values", "vals", "parts", "rules", "ints", "args", "caps", "types", "bits", "blocks", "FLAG", "members", "files", "atts", "Flags", "powers", "comments", "flag", "properties", "fs", "heads", " Flags", "stats", "bytes", "ags", "states", "ants", "little", "fields", "planes", "options", "features", "cycles", "mask", "settings"]}}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n", "idx": 18727, "substitutes": {"machine": ["core", "mode", "proc", "template", "hard", "mom", "node", "cache", "instance", "net", "motion", "linux", "connection", "base", "message", "boot", "module", "config", "pu", "slave", "state", "computer", "Machine", "space", "program", "data", "mac", "processor", "game", "object", "loader", "service", "process", "image", "vm", "mem", "model", "device", "gpu", "manager", "host", "m"], "cpu_model": ["cpuLoglayout", "cpu__mode", "gpu_mode", "cpuLogmodel", "cpu___model", "currency_view", "currency_model", "cpu_mode", "cpu_description", "currencyLogview", "cpu___layout", "currencyLogmodel", " cpu_module", "cpu_scope", "cpu__module", "cpu___view", "cpu_module", "gpu_module", "cpu_format", "cpu_view", " cpu_mode", "cpulexvariable", "gpu_model", "cpulexmodel", "gpu_variable", "cpulexmodule", "cpu_models", "currency_layout", "currencyLoglayout", "cpuLogview", "cpulexmode", "gpu_models", " cpu_url", "cpuLogdescription", "cpu_layout", "gpu_scope", "currencyLogdescription", "currency_description", "cpu_url", "gpu_format", "cpu__model", "cpu_variable", "cpu___description"], "kernel_filename": ["storageblockprofile", "kernelblockname", "templateFlength", "gpu_theme", "gpuingfiles", "storageblockname", "storage_filename", "templateFdirectory", "kernelingtheme", "kernel_theme", "template_length", "templateFdescription", "template_directory", "kernel_directory", "kernelblockprofile", "storage_profile", "kernel_profile", "kernelblockfilename", "kernelingfilename", "kernel_name", "kernellogfiles", "storageblockfile", "gpu_fil", "gpuingtheme", "kerneljdirectory", "gpu_files", "kernelblockfile", "kerneljfilename", "templateFfilename", "kernel_file", "kernelingfil", "kernellogfil", "kernel_fil", "storageblockfilename", "kerneljlength", "gpuingfilename", "kernellogtheme", "kernelFdirectory", "kernellogfilename", "storage_file", "kernelFdescription", "kernel_description", "kernelingfiles", "kernel_files", "gpu_filename", "kernelFfilename", "storage_name", "kerneljdescription", "kernel_length", "template_filename", "gpuingfil", "template_description", "kernelFlength"], "cpu": ["core", "cp", "chip", "gru", "cm", "none", "component", "lan", "pc", "proc", "clock", "CPU", "ana", "cli", "node", "cache", "net", "jp", "gc", "mx", "linux", "eni", "flow", "pool", "board", "boot", "hw", "config", "lu", "pu", "platform", "computer", "program", "uu", "uci", "lc", "mac", "processor", "GPU", "c", "prem", "loader", "cam", "null", "bench", "roc", "thread", "process", "image", "vm", "kernel", "mc", "mem", "cmp", "px", "performance", "cu", "python", "lb", "nic", "gpu", " CPU", "cn"], "ram": ["core", "resource", "scan", "cm", "lan", "pc", "rom", "range", "ray", "net", "gam", "ro", "lam", "jam", "array", "param", "dim", "gra", "hw", "memory", "ra", "rum", "program", "sam", "ream", "pack", "space", "sum", "mac", "mor", "gram", "nam", "Ram", "channel", "cam", "region", "thread", "sim", "process", "am", "image", "cow", "vm", "RAM", "mc", "row", "mem", "disk", "mm", "sc", "gpu", "rame", "mode"], "n": ["g", "sn", "min", "cn", "f", "name", "nc", "x", "net", " ni", "u", "na", "t", "d", "no", "ns", "syn", "i", "ner", "nn", "span", "o", "w", "N", "k", "c", "nt", "pn", "p", "nr", "b", "mn", "nor", "ni", "nb", "ne", " i", "en", "num", "nw", "fn", "un", "l", "network", " N", "dn", "nu", "inn", "nat", "an", "j", "m"]}}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "static void ohci_reset(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci_bus_stop(ohci);\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev) {\n\n            usb_attach(&port->port, port->port.dev);\n\n        }\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n", "idx": 18741, "substitutes": {"opaque": ["indace", "opatile", "ovaque", "ovatile", "indatile", "indaque", "Opcot", "opque", "OPaque", "ipcot", "opaques", "indacity", "operacity", "Opque", "ipque", "ipaques", "opace", "opcot", "operatile", "OPque", "ovace", "operace", "ovacity", "opacity", "OPaques", "Opaque", "Opaques", "ipaque", "operaque", "OPcot"], "ohci": ["ovcci", " ohcu", "oylc", "ochki", "ophc", "ehlc", "ovco", "hlcin", "hopcu", "ihai", "hdi", "hopki", "ovlc", "oycu", "hlc", "ehpi", " ohcci", "uhlc", "hlcu", "ihii", "ochii", "ohlc", "ochcu", "ohii", "hci", "ovcit", "hcin", "ehki", "hcu", "oksci", "ohcu", "ehci", "ohni", "hco", " ohcin", "ahcu", "oshii", "hcci", "ophsci", "ihcci", " ohcit", "OHki", "ahco", "ohc", " ohco", "ovki", "ehce", "hcit", "oshci", "ovc", "howlc", "ahci", "ehcu", "ohsci", "ohcci", "howco", "ehii", "ohdi", "howce", "oypi", " ohki", "ihci", "ahc", "howcci", "OHcci", "oshcu", "uhni", "howcu", "ohCI", "oyki", "ihcu", "OHci", "ehdi", "ovce", "ihcit", "hopcin", "ehcin", "howci", "ophii", "ohco", "ihCI", "ohpi", "ovci", "okco", "ehsci", "ehcci", "ihcin", "ihni", "okci", " ohdi", "ahsci", "oyco", "ohki", "oycin", "ophcu", "ihpi", "ahcit", "oyni", "hlni", "OHcu", "hopci", "hlCI", "uhco", "ophcin", "ochci", " ohlc", "ahlc", "ehc", "ohcit", "ehco", "hlai", "ihce", " ohce", "ihlc", "ohce", "ehcit", " ohsci", "ovsci", "hldi", "okcit", "oyci", "hopco", "ahki", "hlci", "ophci", "ohai", "oshcin", "ahCI", "ihki", "uhci", "ihdi", "hai", "ovcu", " ohni", "hni", "ihco", "ahdi", "ohcin"], "port": ["component", "match", "PORT", "machine", "Port", "end", "connection", "point", "ort", "pool", "child", "direction", "plugin", "oper", "stream", "app", "transfer", "image", "prop", "pin", "server", "interface", "project", "pt", "export", "name", "contract", "source", "dev", "slave", "state", "import", "object", "p", "public", "plane", "group", "pid", "host", "feed", "ip", "ion", "config", "module", "pair", "id", "address", "control", "select", "target", "post", "pod", "bus", "nat", "option", "report", "ports", "type", "pipe", "parent", "proxy", "tag", "table", "controller", "path", "mount", "bridge", "patch", "service", "unit", "dp", "driver", "device", "part"], "i": ["phi", "di", "f", "ri", "xi", "name", "qi", "ix", "u", "x", "ci", "li", "ji", "bi", "eni", "uri", "d", "mi", "info", "ip", "n", "I", "pi", "si", "multi", "id", "index", "ai", "iu", "o", "ii", "c", "k", "p", "s", "key", "y", "gu", "b", "z", "slice", "mini", "ui", "ni", "gi", "zi", "count", "yi", "ami", "e", "l", "a", "io", "ie", "ini", "udi", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 18744, "substitutes": {"env": ["console", "shell", "chal", "kn", "keeper", "eu", "txt", "session", "cal", "proc", "forge", "erv", "queue", "cache", "global", "conn", "eni", "here", "np", "Environment", "enc", "config", "db", "eng", "code", "fen", "iss", "ec", "engine", "exc", "qt", "him", "conf", "ext", "ea", "c", "bot", "loader", "her", "chev", "energy", "er", "enh", "enter", "dep", "en", "context", "cb", "viron", "ev", "e", "environment", "que", "ah", "manager", "oa"], "arg1": [" arg01", "Argone", "argument2", "argone", "Arg1", "Arg2", "argb", "paramone", "argument1", "argumentone", "Argb", "args01", "param1", "argsone", "arg01", "args2", " argb", "paramb", "argument01", "args1", " argone", "param2"], "arg2": ["ig1", "argument0", "argument2", "Arg1", "Arg2", "Argtwo", "argb", "ark0", "argument1", "ig2", "argument4", "ark1", "igb", "Argb", " arg4", " argtwo", "ark4", "argtwo", "arg4", " arg0", " argb", "ark2", "arg0", "igtwo"], "farg1": ["infag61", " fargsb", "infgen100", "fArgone", "fArg2", "infgen1", "farm01", "fig1", "frarg1", "fval1", "fplayone", "infagone", "fvar61", "fresult1001", "fArgb", "fdef51", "floarg1", "fArg1", "fargspart", "infag1", "fvar1", "fvarart", "fresultone", "frmag1", "flodef51", "fax1", "fplayth", " fargth", "fregone", "farg1001", "farg01", "flodef8", "figone", "fgen01", "farm2", "fargumentth", " fArgone", "fgenart", "fvar100", "fargs3", "farm91", " farg01", "farg100", " fargone", "fargument100", "fmag1", "fgen91", "fax01", "fagn5", "faxone", "fgen41", "fdef1", "infarg61", " fArg81", "fagone", "fArg81", "farg8", "fmag41", "ferg1", "farg51", "infarg1001", "farm41", "frarg41", "fresult61", "fig3", " farg3", "fresult1", "fargart", " fArgth", "farg81", "ferg5", "farg5", "fargument61", "fvalone", "frarg01", "infargone", "fagnb", "infag1001", "fargpart", "fagn1", "fargumentart", "farmone", " fargs5", "fgen100", "farm1", "frmag01", "fargument1", "floarg51", "frmag41", "fmag91", " fArg1", "fargone", "fplay1", "infarg100", "fargsone", "farg91", "infarg1", "fgen1", " fargs1", "fdef2", "fargsb", "frarg91", "freg2", "flodef1", "fmag8", "fax61", "fargb", "farg3", "fag1001", "infgen61", "fvalpart", "fargument81", "fplay81", "fdef8", "freg1", "frmag91", "farg41", "freg3", "fArgth", "fag1", " farg5", "faxb", "fmag51", "fargumentone", "infgenart", " fargspart", "fArg01", "fax1001", " farg81", "fargs5", "figpart", "floarg8", " fargpart", "fmag01", "fergb", "infargart", "fgen61", "fagnpart", "fergpart", "fax2", " fargsone", "fmag2", "fag61", "farm3", "fargs1", "flodef2", "floarg2", "fval3", " fargs3", "farg61", "fargth", " fargb"], "farg2": ["fuseii", "fuse7", "fgen3", " fax1", " finc2", "fArg2", " fang2", "fig1", "fargtwo", "fang22", " fax02", "fArgSecond", " finctwo", "fregsecond", "figsecond", " fang3", "frock92", "fArgb", "fang3", "fcall92", "fplay22", "farg92", "fgen2", "fax1", " finc9", " faxb", "fcall7", "afargb", "fargSecond", "afig1", "fcall2", "figb", "fplay02", " fcall2", "fargii", "frockii", "afargTwo", "afarg1", "afargSecond", " fcall92", " farg22", " farg02", "fcallii", "figSecond", "faggTwo", " finc02", " farg3", "frock7", "afigTwo", "fplay3", "farg02", "farg22", "fuse92", " fargii", "fargTwo", " farg92", "frock2", "fagg02", "figTwo", "fmag9", "finctwo", " fang02", "fargs02", "finc2", "afigsecond", "afigb", "fargsecond", "faggb", "fgen22", "fang2", " fang22", "fargsb", "afigSecond", "fargs2", "freg2", "fargb", "fArgTwo", "farg3", "fmag02", " farg7", "fmagtwo", "freg1", "afigtwo", "fplay2", "fregtwo", "fax02", "faxb", "faggSecond", "afargsecond", " farg9", "afarg2", "fuse2", "figtwo", "afargtwo", "fang02", "afig2", "fgen02", "finc9", " fcallii", " fargtwo", "fagg2", "farg9", " fax2", "finc02", " fcall7", "fax2", "fig2", "fmag2", "farg7", "fargs1", "fagg9", "faggtwo", " fargb"]}}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_connect_init(NetClientState *peer,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            if (errno == EINTR || errno == EWOULDBLOCK) {\n\n                /* continue */\n\n            } else if (errno == EINPROGRESS ||\n\n                       errno == EALREADY ||\n\n                       errno == EINVAL) {\n\n                break;\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(peer, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 18759, "substitutes": {"peer": ["server", "pri", "client", "http", "pc", "worker", "proc", "cer", "node", "ppa", "parent", "proxy", "address", "pb", "reader", "friend", "p", "loader", "fp", "owner", "pe", "ssl", "er", "socket", "gp", "vr", "seed", "request", "port", "pro", "remote", "master", "ker", "manager", "player", "host"], "model": ["server", "resource", "cm", "client", "Model", "mode", "models", "instance", "media", "source", "proxy", "param", "base", "message", "plugin", "bm", "module", "config", "db", "address", "block", "ctx", "reader", "object", "loader", "brand", "ssl", "stage", "prov", "image", "context", "port", "que", "manager", "layer", "host", "m"], "name": ["self", "server", "str", "NAME", "family", "none", "client", "type", "x", "prefix", "parent", "connection", "no", "n", "version", "config", "id", "word", "path", "address", "data", "space", "block", "time", "nam", "object", "key", "Name", "named", "image", "names", "anc", "size", "part", "host"], "host_str": ["hostacStr", "hostacset", "hostacstring", "host_Str", "host_string", "host2str", " host_set", "host2Str", "host2string", "host2set", " host_string", "host_set", " host_Str", "hostacstr"], "s": ["ys", "g", "is", "cs", "sn", "server", "sys", "session", "sa", "bs", "sp", "ps", "ops", "uns", "f", "rs", "js", "south", "ss", "conn", "sq", "d", "ns", "n", "obj", "si", "args", "state", "ls", "es", "o", "gs", "conf", "c", "sb", "p", "ts", "func", "ssl", "obs", "sl", "comments", "socket", "su", "services", "fs", "stats", "S", "sec", "sg", "sts", "ses", "os", "e", "sym", "sc", "se", "ds", "aws", "qs", "an", "sync"], "fd": ["fx", "cd", "sf", "df", "dc", "f", "bd", "client", "fed", "pd", "temp", "pipe", "dd", "td", "draft", "conn", "ad", "d", "connection", "lf", "sd", "gd", "fc", "fw", "FD", "db", "fin", "dt", "ff", " fin", "fen", "dl", "stream", "fl", "cf", " ff", "wd", "connect", "fp", " fid", "ld", "da", "ind", "nd", " df", "xd", "fa", "wind", "function", "socket", "fs", "hd", "fb", "handler", "cb", "fn", "fi", " FD", " f", "fe", "dn", "ds", "ln", " conn"], "connected": ["started", "client", "loaded", "enabled", "supported", "handled", "controlled", "sent", "bc", "running", " closed", "conn", "reg", "connection", "valid", "fun", "bound", "Connect", "config", "closed", "index", "disabled", "con", " disconnected", "registered", "circ", "broken", "connect", "initialized", "established", "active", "selected", "opened", "ended", "cond", "locked", "ind", "current", "socket", "en", "count", "ed", "updated", "checked", "seq", "open", "finished", "sc", "owned", "confirmed", "called", "sync"], "ret": ["RET", "val", "bit", "reply", "not", "bd", "result", "bc", "temp", "alt", "res", "conn", "success", "reg", "sr", "connection", "no", "red", "len", "fun", "obj", "ner", "found", "status", "con", "rev", "rets", "att", "rb", "ref", "det", "connect", "nt", "cond", "resp", "re", "rc", "Ret", "num", "count", "cb", "rt", "j"], "saddr": ["serviceaddr", "skylayer", "ddb", "dafi", " svr", "_host", "gaddr", "jsaddr", "gaddress", "caddress", "naddr", "jsafi", "syncaddr", "_address", "chost", "daddress", "sport", "caddr", "ssaddress", "ssaddr", "daddr", "serverAddress", "naddress", "servicelayer", "skyadr", "slayer", " safi", "serveraddress", " saddress", "svr", "wAddress", "jsdb", "shost", "sAddress", "syncattr", "cport", "gentry", "jsaddress", "_port", "skyentry", "nhost", "waddr", "sdb", "syncadr", " sdb", "sshost", " shost", "nport", "safi", "serveraddr", "synclayer", "wvr", "ssladdress", "ssladdr", "skyattr", "skyaddr", "serviceattr", "_addr", "serviceadr", "gattr", "sslAddress", "ssvr", "sentry", "saddress", "waddress", " sentry", "whost", "skyaddress", "sadr", "sattr", " sattr"]}}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 18773, "substitutes": {"kernel_entry": ["program_cell", "program_service", " kernel_low", "kernelacconfig", "loader_archive", "kerneldstart", "kernel_low", "loader_ident", "program_entry", " kernel_start", "kerneldconfig", "kernelallident", "loader_entry", "kernelacsystem", "kernel_end", "kernel_system", "kernelalldata", " kernel_system", "kernel_data", "kerneldsystem", "loader_data", "kernel_archive", " kernel_end", "kernel_config", "kernelacentry", "kerneldentry", "program_depth", " kernel_config", "kernel_depth", "kernelallarchive", "kernel_ident", "kernelacstart", "kernel_start", "kernel_service", "kernelallentry", "kernel_cell"], "kernel_high": ["system_mid", "machine_high", "kernelachigh", "machine_large", "kernel_low", "kernel7high", "machine_source", "kernelacsource", "machineactarget", "kernel7source", "machineaclocation", "kernel_location", "machine_location", "kernel7target", "kernel_source", "kernel_mid", "machineacsource", "system_large", "kernel7location", "kernel_large", "kernel_target", "machineachigh", "kernel_end", "machine_entry", "kernelaclocation", "system_low", "system_high", "kernelactarget", "machine_target", "machine_end"], "initrd_size": ["initrl_name", "initrdaclength", "initrd_body", "initrd___name", "initrdFshape", "initrr_name", "initri_size", "initrdFsize", "initrd_address", "initddFsize", "initdd_shape", "initrl___score", "initrl___size", "initrd_data", "initrd_shape", "initddFdata", "initri_area", "initrdacSIZE", "initrdacbody", "initdd_size", "initrl_size", "initrdCsize", "initld_scale", "initrl___name", "initld_body", "initrd_ize", "initrd_width", "initrd_name", "initrd_SIZE", "initrl_score", "initrd_scale", "initld_name", "initrr_address", "initrd_score", "initrr_ize", "initrd_unit", "initld_SIZE", "initdd_data", "initddFshape", "initld_size", "initrdCdata", "initrd_area", "initrd_length", "initri_width", "initrr_size", "initrdCshape", "initrdacsize", "initrdFdata", "initrd___score", "initrd_sum", "initri_sum", "initld_length", "initrd___size", "initld_unit"], "initrd_offset": ["initrd_position", "g", "get", "proc", "initrd67slot", "initrdXfrom", "initrd_entry", "initrost_size", "initrdFsize", "initrodxoffset", "initrd67Offset", "initrd_loc", "initrodxsize", "initrdxfrom", "initrost_offset", "initrd67offset", "initrost_entry", "initrdXsize", "initrd_skip", "initrost_skip", "initrt_Offset", "linux", "initrdFoffset", "initrost_position", "initrod_from", "initrdxoffset", "s", "initrd_slot", "initrt_position", "initrod_size", "initrd_from", "initrodxfrom", "this", "initrdxstart", "initrdFloc", "_", "initrt_offset", "initrod_offset", "initrd_Offset", "cpu", "initrost_loc", "initrdXstart", "initrt_entry", "initrdFskip", "initrd_start", "initrt_size", "new", "initrod_start", "initrdxsize", "all", "initrdXoffset", "initrt_slot", "process", "initrodxstart"], "big_endian": ["big_endedlic", "big_endingIAN", "big_pendien", "big_endric", "big_endsIAN", "big_endlic", "big_stopian", "big_stopio", "big_endingians", "big_endedrian", "big_stopians", "big_endsig", "big_endien", "big_pendio", "big_pendian", "big_endsians", "big_endig", "big_endingig", "big_endedian", "big_endedric", "big_endingric", "big_endio", "big_endingian", "big_endians", "big_endIAN", "big_pendians", "big_endinglic", "big_endedians", "big_stopien", "big_endrian", "big_endingrian", "big_endsian"], "prom_buf": ["prom_buffer", "prom2alloc", "rem_buf", "rem_buff", "prom_buff", "prom2buffer", "prom_alloc", "rem_buffer", "rem_alloc", "prom2buff", "prom2buf"], "prom_size": ["prom67size", "ram_name", "promacsize", "prom67mode", "prom_name", "promacname", "ram_size", "promacindex", "prom67index", "prom67name", "ram_mode", "prom_mode", "promacmode", "ram_index"], "xlate_to_kseg0": ["xlate_to_ksega50", "xlate_to_ksegin1", "xlate_to_ksegment1", "xlate_to_kseg2", "xlate_to_ksegment3", "xlate_to_ksega0", "xlate_to_ksegin10", "xlate_to_ksegam10", "xlate_to_ksegin3", "xlate_to_kseg3", "xlate_to_ksega4", "xlate_to_ksegm4", "xlate_to_kseg4", "xlate_to_ksegment4", "xlate_to_ksegam0", "xlate_to_ksegin50", "xlate_to_kseg10", "xlate_to_ksegam1", "xlate_to_ksega10", "xlate_to_ksegin0", "xlate_to_kseg50", "xlate_to_ksegment2", "xlate_to_ksegm1", "xlate_to_ksega3", "xlate_to_kseg1", "xlate_to_ksegm0", "xlate_to_ksegment0", "xlate_to_ksegin2", "xlate_to_ksega2", "xlate_to_ksega1", "xlate_to_ksegam50"], "opaque": ["ipbuffer", "ompcode", "operbuffer", "operac", "ompbuffer", "opercode", "ompac", "opbuffer", "ipaque", "opcode", "operaque", "ompaque", "opac", "ipac", "ipcode"], "addr": ["map", "src", "proc", "extra", "x", "array", "args", "address", "data", "byte", "pos", "null", "Address", "ptr", "image", "seq", "alloc", "host"], "prom_index": ["gram_pos", "prom_addr", "gram_addr", "prom_pos", "gram2no", "gram2index", "prom2index", "prom2no", "gram2pos", "prom2addr", "gram_no", "gram2addr", "prom2pos", "prom_no", "gram_index"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_anon(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n", "idx": 18781, "substitutes": {"data": ["self", "txt", "f", "this", "result", "style", "temp", "u", "media", "parent", "DATA", "buf", "t", "window", "api", "li", "buffer", "d", "test", "valid", "base", "Data", "record", "i", "config", "init", "parser", "input", "o", "reader", "xxx", "p", "da", "def", "done", "fake", "dat", "start", "empty", "m"], "unused": ["Unuse", "unuse", " uninitialized", " unus", " unbused", " unbinitialized", "Unus", "Uninitialized", "unus", "Unused", " unbuse", "uninitialized", " unuse", " unbus"], "tmp": ["self", "verb", "copy", "txt", "f", "uv", "kk", "lv", "tp", "jp", "temp", "buf", "array", "po", "t", "api", "Temp", "wb", "test", "np", "obj", "metadata", "cpp", "tt", "pb", "ctx", "st", "rb", "c", "p", "var", "sb", "cv", "b", "amp", "tc", "fake", "nv", "vt", "vm", "dest", "cmp", "vv", "mp", "tv", "fb", "j"], "v": ["g", "f", "uv", "lv", "u", "temp", "t", "q", "d", "test", "n", "conv", "obj", "version", "i", "vi", "h", "va", "vp", "iv", "vs", "o", "w", "vu", "fl", "c", "k", "p", "cv", "vc", "z", "ve", "nv", "vt", "vm", "vd", "e", "sv", "l", "ant", "vv", "V", "tv", "j", "m"], "errp": ["rrpr", " erps", "errps", "erpre", "erf", "errP", "rrpre", "rrf", "errpo", "erP", "ErP", "rrP", "errpr", "enerpr", "errpre", "Erpo", "enerpre", "errf", "erp", "erps", " erpre", " erP", "rrpo", "iterp", "iterpr", "rrp", "iterpre", "rrpa", "rrps", "Erp", "iterpa", "enerp", " erp", "errpa", "enerpa", "erpo", "Erf"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n", "idx": 18799, "substitutes": {"dev": ["development", "di", "self", "DEV", "dc", "client", "node", "cache", "mod", "dd", "conn", "ad", "end", "d", "valid", "info", "root", "hw", "gd", "db", "der", "data", "diff", "Dev", "block", "engine", "w", "conf", "app", "de", "var", "gu", "def", "comment", "ev", "die", "bug", "device", "rad", "debug", "v", "ver", "md"], "vq": ["pq", " vQ", "svqi", "vmquest", "vqu", " viq", "vmqi", "vQ", "tvque", "pdq", "svq", "nvqa", "tvq", "variqu", "svquery", "eviq", "vquest", " vdq", "vcquest", "pQ", "nvp", "evq", "svp", "vqa", "pquest", "variquery", "varique", "vp", " vqi", "vque", "tvqu", " vqa", "svqu", "svquest", " vquest", "vcQ", "vqi", "vquery", "nviq", "viq", "vcq", "nvq", "vmp", "nvquest", "vdq", "evqa", "vcdq", "nvqi", "tvquery", "variq", "svque", "evqi", "vmq"], "n": ["g", "sn", "f", "number", "name", "x", "nc", "node", "na", "u", "t", "d", "ns", "i", "nn", "init", "r", "index", "o", "w", "N", "c", "k", "p", "s", "b", "en", "nb", "ne", "num", "e", "network", "l", "a", "nm", "nat", "v", "m"]}}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)\n\n{\n\n    AVFilterContext  *ctx = inlink->dst;\n\n    ATempoContext *atempo = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n\n\n    int ret = 0;\n\n    int n_in = src_buffer->nb_samples;\n\n    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);\n\n\n\n    const uint8_t *src = src_buffer->data[0];\n\n    const uint8_t *src_end = src + n_in * atempo->stride;\n\n\n\n    while (src < src_end) {\n\n        if (!atempo->dst_buffer) {\n\n            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);\n\n            if (!atempo->dst_buffer)\n\n                return AVERROR(ENOMEM);\n\n            av_frame_copy_props(atempo->dst_buffer, src_buffer);\n\n\n\n            atempo->dst = atempo->dst_buffer->data[0];\n\n            atempo->dst_end = atempo->dst + n_out * atempo->stride;\n\n        }\n\n\n\n        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);\n\n\n\n        if (atempo->dst == atempo->dst_end) {\n\n            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /\n\n                             atempo->stride);\n\n            ret = push_samples(atempo, outlink, n_samples);\n\n            if (ret < 0)\n\n                goto end;\n\n        }\n\n    }\n\n\n\n    atempo->nsamples_in += n_in;\n\nend:\n\n    av_frame_free(&src_buffer);\n\n    return ret;\n\n}\n", "idx": 18812, "substitutes": {"inlink": ["outcall", " inlog", "innmachine", "innstyle", "inclog", "incstyle", "inLink", "innercall", "incall", "inlog", "inmachine", "instyle", "innerlink", " inmachine", " instyle", "inclink", "innlink", "outLink", "innerline", "innerLink", "incmachine", "innlog", " incall", " inLink", "outline"], "src_buffer": ["src_layer", "src_buff", "src_cache", "source_uffer", "src_reference", "source_layer", "rc_cache", "rc_buff", "src_handler", "src_buf", " src_buf", "src00buffer", "src__buf", "src__queue", " src_queue", "rc_handler", "source_buffer", "source_source", "source_reference", "src2buf", "src__buffer", "src_queue", "src_uffer", "rc_queue", "source_queue", "src2buffer", "src2queue", "src_source", "rc_buffer", "src00handler", "src00queue"], "ctx": ["cca", "cs", "cp", "cm", "jp", "cli", "cmd", "bc", "instance", "ci", "btn", "conn", "exec", "conv", "obj", "hw", "config", "cpp", "fw", "init", "act", "cas", "lc", "loc", "ca", "cf", "conf", "c", "ref", "cc", "cv", "tx", "cus", "pkg", "tc", "Context", "context", "rc", "cb", "cmp", "ctrl", "utils", "anc", "xc", "cn"], "atempo": ["edomota", "ameno", "aimapo", "ommpa", "adempo", "tomapo", "ammpa", "idempo", "imo", "dempi", "atemcho", "ormapo", "amypi", "tomcho", "iempa", "iampa", "iemapo", "ymmpo", "impos", "ymcho", "temo", "amenpo", "iampi", "mmpos", "idempi", "ommpos", "demo", "iempos", "tmote", "ymmapo", "dempo", "ormpos", "atempos", "temota", "gampi", "iempi", "gampo", "edomo", "tempos", "impi", "ommo", "omo", "adempos", "empos", "edompo", "ammo", "iempo", "temote", "ammote", "ademppo", "atemo", "gampos", "ormpo", "impo", "iemote", "immpos", "dempos", "atemppo", "iampos", "amyo", "temapo", "tmpos", "ammapo", "atempa", "dempe", "amenpos", "immpo", "aimpo", "tmpo", "atempi", "tmapo", "iamo", "ommppo", "emanpos", "tmpe", "aimo", "ymapo", "ammpi", "tempo", "emanpo", "idempa", "atembo", "tempa", "empo", "amypo", "empi", "demppo", "emanpa", "tmpi", "atemota", "mmpo", "ymbo", "iempe", "mmote", "ommapo", "atempe", "ormote", "ymmbo", "ommpe", "mmo", "tompo", "iampe", "idempos", "iampo", "adempi", "impe", "ompi", "ademota", "atemapo", "edompos", "tmpa", "emo", "ademote", "ommpi", "emanpi", "aimpos", "ammpos", "immote", "adempe", "ymmcho", "immo", "emapo", "ademapo", "ommpo", "amypos", "emanpe", "ammpo", "gampe", "tempi", "adempa", "ympo", "impa", "amenpi", "iemo", "ademo", "ompos", "atemote", "ompo", "tombo", "ammpe"], "outlink": [" outloop", "againLink", "maindo", "mainLink", "outdo", "outlinks", " outdo", " outlinked", "mainlink", "offLink", "OutLink", "Outload", "mainlinked", "inlinks", "offdo", "againlink", "Outlink", "offlinked", " outline", " outload", "outloop", "outLink", "outload", " outLink", "againline", " outlinks", "againload", "inloop", "againlinks", "againloop", "offlink", "Outline", "outline", "outlinked"], "src": ["core", "rec", "sys", "length", "proc", "inst", "uc", "rest", "bc", "rs", "source", "cur", "sit", "sq", "uri", "sr", "req", "rib", "config", "ources", "again", "img", "ource", "data", "rss", "st", "stream", "loc", "rb", "RC", "head", "sb", "tmp", "rl", "ssl", "sur", "sup", "sl", "dist", "sel", "send", "rc", "url", "cb", "dest", "gb", "sec", "filename", "scene", "start", "text", "sub", "username", "sc", "rob"], "src_end": ["src_entry", " src_close", "src0end", "src_ending", "src_start", " src_start", "src_ends", "src0ends", "src0start", "src_ended", " src_entry", "src0ending", "src_close", " src_ends", " src_ending", "rc_end", "rc_ended", "rc_start"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "struct vhost_net *vhost_net_init(VhostNetOptions *options)\n\n{\n\n    int r;\n\n    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 18819, "substitutes": {"options": ["none", "session", "global", "cache", "scope", "exec", "connection", "or", "content", "null", "image", "cho", "steps", "opt", "utils", "outs", "ex", "results", "http", "name", "op", "ions", "optional", "args", "lib", "resources", "Options", "full", "data", "es", "params", "object", "s", "public", "ts", "current", "io", "words", "ets", "its", "json", "ops", "example", "this", "config", "ips", "o", "classes", "pre", "pos", "names", "other", "info", "changes", "css", "after", "ims", "initial", "groups", "option", "type", "ports", "li", "six", "rules", "obj", "co", "final", "details", "comments", "e", "os", "pro", "times", "ES", "settings"], "r": ["dr", "ru", "resource", "rr", "f", "result", "range", "rw", "x", "u", "rs", "res", "kr", "t", "q", "end", "sr", "lr", "d", "R", "rh", "error", "n", "or", "rar", "ir", "i", "ner", "ar", "h", "br", "hr", "w", "rb", "c", "rd", "k", "p", "var", "rl", "nr", "rf", "b", "cr", "er", "re", "rg", "z", "err", "ur", "en", "run", "rc", "attr", "e", "rn", "l", "like", "arr", "rt", "v", "pr", "j", "m"], "net": ["core", "set", "not", "inet", "client", "global", "cache", "et", "na", "page", "connection", "ort", "nit", "act", "virtual", "connect", "dot", "network", "nu", "ann", "server", " Net", "NET", "nc", "ns", "np", "site", "lib", "dev", "user", "data", "nt", "p", "key", "nets", "vm", "ne", "num", "non", "io", "serv", "out", "pot", "art", "ver", "cat", "mat", "web", "Net", "n", "ip", "kit", "config", "module", " network", "db", "mult", "target", "next", "channel", "fat", "en", "ni", "dat", "nat", "plain", "cn", "resource", "output", "parent", "conn", "tun", "boot", "ut", "ner", "dt", "mot", "unit", "function", "rn", "text", "nic"]}}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n", "idx": 18820, "substitutes": {"usb_msd_init": ["usb_msd_set", "usb_msd_config", "usb_msl_set", "usb_msd_fix", "usb_msl_fix", "usb_msl_config", "usb_msl_init"], "filename": ["dll", "phrase", "description", "whatever", "fd", "metadata", "suff", "sql", "package", "setup", "ename", "sf", "enabled", "generic", "name", "ppa", "source", "uri", "location", "message", "directory", "duration", "Filename", "params", "fp", "p", "nil", "fil", "url", "l", "username", "method", "title", "kn", "material", "sequence", "f", "length", "src", "mpeg", "pty", "sound", "folder", "linear", "il", "binary", "files", "format", "file", "named", "maximum", "brush", "fn", "tty", "jpg", "lace", "txt", "initial", "database", "prefix", "asm", "feat", "document", "wb", "kl", "download", "word", "path", "exist", "application", "subject", "sheet", "password", "utf", "size"], "id": ["bit", "str", "sid", "cat", "src", "name", "ids", "type", "parent", "in", "pad", "ad", "end", "it", "uri", "rid", "root", "ip", "base", "fd", "i", "Id", "ID", "oid", "bid", "path", "auth", "init", "code", "aid", "db", "data", "mid", "ctx", "ref", "head", "file", "key", "desc", "uid", "url", "kid", "seq", "num", "start", "pid", "text", "did", "info"], "opts": [" opt", " opments", "obts", "OPtes", "hopted", "otments", "OPters", "ops", "OPts", "optcs", "opters", " opte", "optics", " optes", "roplets", "optst", " optr", " optt", "optr", "lockcs", " opst", "ropte", " optts", "hoptes", " optics", "ottes", "opttr", "roptr", "otts", " oplets", "opcs", " optst", "opments", "ropts", "optes", "ottics", " opted", "hopts", "optte", "oplets", "locktics", "opst", "otte", "optters", "optments", "optt", "opte", "lockte", "OPt", "obted", " ops", "otcs", "OPcs", "obments", "OPs", "lockts", " opters", "hopments", "optlets", "opt", "optts", "obtes", "OPte", "opttes", " opttes", "opted", " opcs"], "dinfo": [" dfo", "dlfo", "adfo", "dsfo", "dnInfo", "dfo", "adservice", "ffo", "dinf", "fInfo", "dsinfo", " dInfo", "dsInfo", "finf", "fstate", "adInfo", "dninfo", "dlservice", "dlInfo", "dnstate", " dcheck", "fcheck", "dservice", "dInfo", " dstate", "adinfo", "xdcheck", "xdinfo", "xdinf", " dservice", "xdInfo", "dlinfo", " dinf", "dstate", "finfo", "dcheck", "dsinf"], "dev": ["self", "di", "cd", "server", "DEV", "prom", " device", "result", "proc", "cache", "mod", "dd", "sh", "conn", "ad", "plug", "pad", "d", "fo", "root", "obj", "ch", "hw", "gd", "sd", "boot", "pub", "der", "data", "diff", "Dev", "block", "ee", "w", "conf", "app", "nt", "de", "p", "cam", "gu", "def", "dist", "comment", "home", "err", "priv", "prop", "rc", "vd", "ev", "bus", "die", "pro", "driver", "bug", "dn", "device", "debug", "serial", "md", "ver", "info"], "fatal_error": ["fatal_Error", "fatal_type", "fault_error", "fatalptype", "fatal__break", "fatalpError", "fatal__ror", "fault_break", "fatal__err", "fault_err", "fault_ror", "fatalperror", "fatalperr", "fatal__error", "fatal_ror", "fatal_break", "fatal_err"], "p1": ["P0", "f01", "point1", "P01", " p0", "pp1", "f2", "P2", " p4", "p8", "POne", "p5", " p8", "p0", "f1", "p4", "param5", "P5", "param01", "pp2", "ppOne", "r0", "f8", "r2", " p5", "r4", "p01", "param1", "point01", "P3", "p3", "P4", " pOne", "point3", "pp0", " p01", "f3", "pOne", "f0", "point2", "P1", "r1", "param2", "P8"], "fmt": ["cfmb", "Fmt", "funmt", "funMT", " fformat", " flt", "frt", "filt", "Fformat", "tfrt", " fmb", " frt", "sfmt", "Frt", "fnt", "sftm", "tfnt", " ftm", "cflt", "sfilt", "sfMT", "fMT", "sfnt", "funformat", "tfmb", "tfmt", "tfMT", "fmb", "sfformat", "FMT", "Filt", "ftm", "cfmt", "tflt", "cfrt", " fMT", " fnt", "tfformat", "funilt", "tftm", "fformat", "flt"], "nr": ["sn", " n", "rec", "rr", "number", " resid", "src", "range", "nc", "yr", " ni", " no", " NR", "sr", "req", "lr", "wr", " fn", " seq", "nn", "ner", "chain", "dir", "rx", "adr", "addr", "nl", "next", "gr", "nob", "rl", "mr", "nir", "NR", "nor", "ni", "nb", "ng", "nw", "seq", "rn", " r", "arr", "rw"], "p2": ["P02", "P2", " p4", "f2", "p8", " p8", "f1", "p4", "f8", "r2", "PTwo", "paTwo", "pa8", "r4", " pTwo", " p02", " p3", "r02", "pa2", "p02", "P3", "p3", "P4", "pa1", "pTwo", "f4", "f3", "P1", "r1", "P8"]}}
{"project": "FFmpeg", "commit_id": "aacf6b3a2fd8bc8603e3deaa6e612ea03cf08707", "target": 1, "func": "static inline void rv34_mc(RV34DecContext *r, const int block_type,\n\n                          const int xoff, const int yoff, int mv_off,\n\n                          const int width, const int height, int dir,\n\n                          const int thirdpel, int weighted,\n\n                          qpel_mc_func (*qpel_mc)[16],\n\n                          h264_chroma_mc_func (*chroma_mc))\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    uint8_t *Y, *U, *V, *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride + mv_off;\n\n    int is16x16 = 1;\n\n\n\n    if(thirdpel){\n\n        int chroma_mx, chroma_my;\n\n        mx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) / 3 - (1 << 24);\n\n        my = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) / 3 - (1 << 24);\n\n        lx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) % 3;\n\n        ly = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) % 3;\n\n        chroma_mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        chroma_my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = (chroma_mx + (3 << 24)) / 3 - (1 << 24);\n\n        umy = (chroma_my + (3 << 24)) / 3 - (1 << 24);\n\n        uvmx = chroma_coeffs[(chroma_mx + (3 << 24)) % 3];\n\n        uvmy = chroma_coeffs[(chroma_my + (3 << 24)) % 3];\n\n    }else{\n\n        int cx, cy;\n\n        mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] >> 2;\n\n        my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] >> 2;\n\n        lx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] & 3;\n\n        ly = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] & 3;\n\n        cx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        cy = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = cx >> 2;\n\n        umy = cy >> 2;\n\n        uvmx = (cx & 3) << 1;\n\n        uvmy = (cy & 3) << 1;\n\n        //due to some flaw RV40 uses the same MC compensation routine for H2V2 and H3V3\n\n        if(uvmx == 6 && uvmy == 6)\n\n            uvmx = uvmy = 4;\n\n    }\n\n    dxy = ly*4 + lx;\n\n    srcY = dir ? s->next_picture_ptr->f.data[0] : s->last_picture_ptr->f.data[0];\n\n    srcU = dir ? s->next_picture_ptr->f.data[1] : s->last_picture_ptr->f.data[1];\n\n    srcV = dir ? s->next_picture_ptr->f.data[2] : s->last_picture_ptr->f.data[2];\n\n    src_x = s->mb_x * 16 + xoff + mx;\n\n    src_y = s->mb_y * 16 + yoff + my;\n\n    uvsrc_x = s->mb_x * 8 + (xoff >> 1) + umx;\n\n    uvsrc_y = s->mb_y * 8 + (yoff >> 1) + umy;\n\n    srcY += src_y * s->linesize + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    if(   (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4\n\n       || (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4){\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 22 * s->linesize;\n\n\n\n        srcY -= 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, (width<<3)+6, (height<<3)+6,\n\n                            src_x - 2, src_y - 2, s->h_edge_pos, s->v_edge_pos);\n\n        srcY = s->edge_emu_buffer + 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(uvbuf     , srcU, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        s->dsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n    }\n\n    if(!weighted){\n\n        Y = s->dest[0] + xoff      + yoff     *s->linesize;\n\n        U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }else{\n\n        Y = r->tmp_b_block_y [dir]     +  xoff     +  yoff    *s->linesize;\n\n        U = r->tmp_b_block_uv[dir*2]   + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = r->tmp_b_block_uv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }\n\n\n\n    if(block_type == RV34_MB_P_16x8){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8;\n\n        srcY += 8;\n\n    }else if(block_type == RV34_MB_P_8x16){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8 * s->linesize;\n\n        srcY += 8 * s->linesize;\n\n    }\n\n    is16x16 = (block_type != RV34_MB_P_8x8) && (block_type != RV34_MB_P_16x8) && (block_type != RV34_MB_P_8x16);\n\n    qpel_mc[!is16x16][dxy](Y, srcY, s->linesize);\n\n    chroma_mc[2-width]   (U, srcU, s->uvlinesize, height*4, uvmx, uvmy);\n\n    chroma_mc[2-width]   (V, srcV, s->uvlinesize, height*4, uvmx, uvmy);\n\n}\n", "idx": 18830, "substitutes": {"r": ["dr", "g", "f", "result", "rs", "res", "kr", "q", "sr", "lr", "R", "rh", "d", "ir", "n", "ar", "rt", "rx", "fr", "o", "w", "rb", "gr", "c", "p", "rl", "rf", "b", "cr", "er", "re", "rg", "rc", "e", "rw", "v", "j", "m"], "block_type": ["frame2block", "block_name", "frame_block", "block2name", "block2type", "frame2type", "block2block", "frame_type", "block8Type", "block8block", "block8type", "block_Type", "block8name", "frame2Type", "frame_name", "frame_Type", "block2Type", "block_block", "frame2name"], "xoff": ["XOff", "xOff", " xOff", "xyoff", "xOFF", "xoffs", "xyOff", "xyOFF", "Xoffs", " xoffs", "xyoffs", "Xoff", " xOFF", "XOFF"], "yoff": ["yoffs", "xyoff", "xOFF", "xoffs", "xyoffs", "xyOFF", "yOFF", "dyoffs", "dyoff", "dyOFF"], "mv_off": ["mvpopen", "mv_on", "mv__on", "mf_type", "mv2off", "mvptype", "mv__off", "mv_mode", "mvpon", "mvarktype", "mvpoff", "mv_open", "mvarkoff", "mf_on", "mv__mode", "mv2mode", "mv_pos", "mov_on", "mv2pos", "mv2on", "mf_off", "mov_off", "mvarkon", "mv__pos", "mov_pos", "mv_type", "mf_open", "mvarkopen", "mov_mode"], "height": ["ty", "layout", "length", "resolution", "style", "Height", "window", "dim", "fw", "th", "max", "padding", "img", "w", "dy", "depth", "gh", "deep", "def", "thin", "density", "row", "rows"], "dir": ["dr", "di", "class", "orient", "rec", "coll", "dc", "f", "du", "handle", "name", "alt", "level", "cur", "folder", "dim", "uri", "req", "rel", "d", "ir", "n", "or", "direction", "lib", "config", "id", "module", "directory", "dt", "path", "h", "duration", "diff", "doc", "sort", "dy", "loc", "Dir", "ref", "file", "DIR", "c", "depth", "det", "y", "ind", "def", "dist", "desc", "m", "dep", "group", "url", "dest", "direct", "dn", "order", "spec", "manager", "md", "mode"], "thirdpel": ["thirdpal", "threepel", "Thirdlace", "Thirdpel", "threelace", "quadlace", "thirdpl", "Thirdchal", "Thirdpal", "quadpl", "quadpel", "thirdchal", "Thirdpl", "threepl", "quadpal", "thirdlace", "threepal"], "weighted": ["processned", "weighting", "wnable", "processed", "weightned", "maskned", "wned", "masking", "wning", "masked", "processable", "processing", "weightable", "wnned", "maskable"], "qpel_mc": ["qpal_mc", "qpal_pc", "qpel_pc", "qpel2cos", "qpel2lc", "qpel_cos", "qpal_lc", "qpel_lc", "qpel2mc", "qpal_cos", "qpel2pc"], "chroma_mc": ["chroma_mic", "chromama_mic", "chroma_lc", "chromama_mc", "chromama_mm", "chromama_lc", "chroma_mm"], "s": ["g", "self", "session", "sp", "js", "scope", "h", "gs", "conf", "c", "b", "ssl", "sl", "su", "fs", "a", "qs", "m", "server", "sf", "http", "u", "ns", "site", "si", "i", "your", "full", "es", "us", "p", "sb", "y", "ts", "services", "l", "sym", "se", "j", "f", "ops", "rs", "ss", "sq", "n", "o", "sup", "sim", "S", "bis", "sg", "ses", "share", "spec", "is", "cs", "sys", "ps", "t", "d", "ls", "space", "w", "service", "e", "os", "sc", "ds", "v", "size", "settings"], "Y": ["D", "M", "B", "Q", "x", "Z", "L", "R", "H", "I", "X", "YY", "XY", "O", "INT", "CH", "N", "T", "P", "F", "G", "y", "MY", "S", "A", "C", "W"], "U": ["D", "M", "B", "Q", "u", "K", "UD", "L", "Z", "R", "H", "I", "X", "O", "E", "N", "T", "P", "F", "G", "UU", "S", "A", "UV", "C", "W"], "V": ["D", "M", "B", "Q", "L", "Z", "R", "H", "I", "X", "O", "XY", "VT", "E", "N", "T", "P", "F", "G", "S", "A", "UV", "VW", "J", "C", "W", "v"], "srcY": ["srcXY", "srcN", "sourceXY", "sourceN", "rcX", "rcN", "rcY", "sourceX", "sourceY", " srcXY", " srcN", "rcXY", "srcX", " srcX"], "srcU": ["srcN", "sourceN", " srcX", "rcU", "rcN", "rcX", "sourceX", "rcM", " srcM", " srcN", "srcM", "srcX", "sourceU", "sourceM"], "srcV": ["srcI", "sourceI", "rcV", "rcU", " srcI", "sourceV", "rcM", " srcM", "srcM", "rcI", "sourceU", "sourceM"], "dxy": ["dwx", "dwy", "fxy", "Dwy", "Dpx", "fpx", "fwx", "dpx", " dpx", "Dxy", " dwx", " dwy", "fwy", "Dwx"], "mx": ["fx", "cm", "ms", "xy", "x", "xml", "me", "mic", "wm", "dm", "mu", "py", "mus", "bm", "ml", "nn", "dj", "wx", "rx", "dy", "mr", "y", "mos", "yx", "tx", "mb", "mn", "vm", "la", "mc", "ym", "px", "zx", "mp", "mm", "MX", "mag", "md", "mi", "m"], "my": ["ky", "any", "vy", "ms", "ury", "mmm", "gray", "mic", "me", "bi", "ny", "py", "pm", "lly", "ml", "mph", "mys", "why", "ram", "zy", "ma", "dy", "y", "mia", "MY", "mini", "mn", "gy", "ami", "mc", "ym", "fy", "sym", "mm", "My", "md", "mi", "m"], "umx": ["emy", "pmx", "umh", "emx", "pmz", "pmy", "mz", "umw", "ufx", "ulw", "omy", "ulx", "omw", "mX", "ufy", "emX", "ulh", "ufh", "omx", "umz", "uly", "omh", "pmX", "umX", "ufw", "emz"], "umy": ["ucx", "ucb", "upx", "amb", "amz", "umh", "uch", "umb", "amy", "upy", "upb", "ufx", "ufz", "uph", "amh", "ufy", "upz", "ucy", "ufh", "umz", "amx"], "lx": ["elw", " lz", "sly", "slx", " lw", "elx", "ely", "elz", "slh", "ilw", "lw", "ulx", "lh", "ilh", "ily", "slw", "ulh", "uly", "ilx", "ulz", "ulw", "lz"], "ly": ["ky", "vy", "bly", "lv", "xy", "ry", "li", "lo", "iy", "py", "yo", "pm", "bm", "lu", "ml", "wx", "zy", "lc", "dy", "lex", "y", "hh", "maybe", "gi", "la", "gy", "wy", "yi", "ym", "fy", "px", "hy", "zx", "mm", "ply", "yy", "bl", "mi"], "uvmx": ["vvmh", "vvmx", "uvmm", "upmh", "vvmm", "upmy", "ubmh", "uVMm", "ubmx", "uvmh", "uVMx", "vbmm", "ubmm", "vbmh", "uVMh", "upmx", "vbmx", "upmm", "uVMy", "ubmy", "vbmy", "vvmy"], "uvmy": ["umd", "uvmm", "cvmm", "udmm", "cvmi", "cvmy", "uvmi", "udmi", "cvmd", "uvmd", "udmy", "udmd", "umi", "umm"], "src_x": [" src_i", "src_i", " src_id", "src_id"], "src_y": ["dest_py", "dest_i", "src_i", "dest_y", "dest_x", "src_py"], "uvsrc_x": ["uvsource_h", "uvsource_m", "uvsource_y", "uvsrc_m", "uvsource_x", "uvsrc_h"], "uvsrc_y": ["uvsrc1i", "uvsrc1z", "uvsrc1x", "uvsrc_z", "uvsrc_i", "uvsrc1y"], "chroma_mx": ["chroma_mus", "chroma_mn", "chroma__rx", "chroma_main", "chromaacym", "chroma__ym", "chroma_ym", "chroman_mn", "chromaacmn", "chromaacmx", "chroman_ym", "chroman_mus", "chromaacmain", "chroma_cp", "chroman_main", "chroman_cp", "chroma__mx", "chroma_rx", "chroma_mm", "chroman_rx", "chroma__mn", "chroman_mm", "chroma__main", "chroma__mm", "chroman_mx"], "chroma_my": ["chroma_mi", "chroma_My", "chromama_mis", "chroma67my", "chroman_mos", "chroma67mi", "chroma_nm", "chroma67mx", "chromama_my", "chroman_my", "chroma__mis", "chroma67mos", "chroma_mos", "chroma__my", "chromama_mi", "chromama_My", "chroma__mi", "chroma__mx", "chromama_mx", "chromama_nm", "chroma_mis", "chroman_mi", "chroman_mx"]}}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 18833, "substitutes": {"s": ["is", "g", "cs", "self", "server", "sf", "sys", "f", "session", "http", "ps", "less", "u", "rs", "js", "south", "t", "ss", "sq", "d", "ns", "plugins", "n", "si", "args", "i", "state", "submit", "status", "storage", "your", "ls", "es", "o", "params", "gs", "side", "c", "p", "sb", "ts", "service", "y", "ssl", "b", "sl", "su", "fs", "services", "stats", "S", "states", "sg", "ses", "e", "os", "sets", "sym", "l", "settings", "options", "spec", "se", "ds", "qs", "v", "sync", "m"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)\n\n{\n\n    uint64_t VCO_out, PLL_out;\n\n    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;\n\n    int M, D0, D1, D2;\n\n\n\n    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */\n\n    if (cpc->pllmr & 0x80000000) {\n\n        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */\n\n        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */\n\n        M = D0 * D1 * D2;\n\n        VCO_out = cpc->sysclk * M;\n\n        if (VCO_out < 400000000 || VCO_out > 800000000) {\n\n            /* PLL cannot lock */\n\n            cpc->pllmr &= ~0x80000000;\n\n            goto bypass_pll;\n\n        }\n\n        PLL_out = VCO_out / D2;\n\n    } else {\n\n        /* Bypass PLL */\n\n    bypass_pll:\n\n        M = D0;\n\n        PLL_out = cpc->sysclk * M;\n\n    }\n\n    CPU_clk = PLL_out;\n\n    if (cpc->cr1 & 0x00800000)\n\n        TMR_clk = cpc->sysclk; /* Should have a separate clock */\n\n    else\n\n        TMR_clk = CPU_clk;\n\n    PLB_clk = CPU_clk / D0;\n\n    SDRAM_clk = PLB_clk;\n\n    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;\n\n    OPB_clk = PLB_clk / D0;\n\n    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;\n\n    EXT_clk = PLB_clk / D0;\n\n    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;\n\n    UART_clk = CPU_clk / D0;\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);\n\n    /* Setup time-base clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);\n\n    /* Setup SDRAM clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);\n\n    /* Setup UART clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);\n\n}\n", "idx": 18838, "substitutes": {"cpc": ["cppl", " cpcu", "pullcs", "cfe", "ckc", "cpcon", "pplc", "cpcu", "cyc", "epcs", "hpc", "pkgcon", "pprc", "CAPcu", "pushk", "ppb", "cppk", "pgc", "cpe", "ppf", "appce", "cyrc", "ppm", "CPlc", "ppnc", "zipcs", " cpl", "appcs", "cpb", "pkgca", "ppdc", "copc", "ckpc", "cppcs", "ppbc", "CAPc", "pkgdc", "ipc", "pdc", "cpdc", "cycon", "hpdc", "pullpc", "zippc", "ppk", "appl", "cppnc", " cpdc", "CAPct", "cpct", "copl", "epc", " cpcs", "pkgl", "pkgnc", "arpcs", "cpbc", "copbc", "cppg", "ppcs", "cppc", "cfdc", " cplc", "ppl", "CPl", "pcs", "pkgc", "ziprc", "CPc", "cppf", "ppce", "cpm", "ppg", "pc", "pkgbc", "zipcu", "cync", "appc", "CPdc", "cpf", "cpk", "pgca", "ipm", "pkgrc", "ppc", "ppca", "ppcu", "pkgcu", "cpnc", "pullrc", "ckct", "iprc", "pkge", "ppcon", "cprc", "pushcon", "copdc", "cppdc", "pkgct", "pkgm", "pkgpc", "cppce", "epl", "ppp", "cpce", "cpca", "cfc", "pushc", "hpcs", "arppc", "cppcon", "cff", "arpdc", "pullc", "pkgb", "cppe", "cpp", "pushg", "pgp", "pppc", "cpl", "zipc", "cpcs", "cppb", "CAPpc", "pkgp", "epcu", "arpc", "hpcu", "pge", "cpg", "cplc", "ppe", "zipl", "ippc", "ckcu"], "VCO_out": ["VCO_name", "VCE_IN", "VCOM_in", "Vco_out", "VCOM_orig", "VCO_num", "VCo_id", "VCOPin", "VCO_co", "VGO_out", "VGO_name", "VCE_call", "VCo_co", "VCOPcall", "VCOPIN", "VCO_conn", "VCOM_error", "VCO_Out", "VGO_num", "Vco_Out", "Vco_conn", "VCO_in", "VCOM_out", "VCo_out", "VCO_call", "Vco_in", "VCE_out", "VCO_id", "VCO_IN", "VCO_error", "VGO_in", "VCE_in", "VCO_orig", "VCOPout"], "PLL_out": ["PLS_out", "PLL_prefix", "PLL_OUT", "PLLFcache", "PLLFout", "PLL_Out", "PML_out", "PML_all", "PLL_cache", "PLS_OUT", "PLL64again", "PLL_ex", "PLLFprefix", "PML_again", "PML_Out", "PCL_Out", "PPL_cache", "PPL_call", "PCL_again", "PLS_ex", "PLL64ex", "PLL_all", "PLS_again", "PLL64out", "PPL_prefix", "PLL_again", "PPL_out", "PCL_out", "PLL64OUT", "PLLFcall", "PLL_call"], "CPU_clk": ["CPU_llks", "CPU_Clk", "CPU_aclck", "CPU_elok", "CPU_plkk", "CPU_elck", "CPU_elkk", "CPU_flck", "CPU_Clkk", "CPU_llok", "CPU_Clks", "CPU_flk", "CPU_elks", "CPU_plck", "CPU_elk", "CPU_slk", "CPU_clks", "CPU_elke", "CPU_Clck", "CPU_llke", "CPU_aclk", "CPU_clky", "CPU_plk", "CPU_plks", "CPU_CLkk", "CPU_CLck", "CPU_slck", "CPU_slok", "CPU_aclky", "CPU_aclok", "CPU_flke", "CPU_llk", "CPU_clok", "CPU_clck", "CPU_flok", "CPU_CLk", "CPU_CLke", "CPU_CLok", "CPU_clke", "CPU_llck", "CPU_slkk", "CPU_plky", "CPU_Clky", "CPU_clkk", "CPU_CLks", "CPU_plke", "CPU_plok", "CPU_Clok"], "TMR_clk": ["TMR_CLik", "TMR_mlke", "TMR_classk", "TMR_plok", "TMR_rlke", "TMR_Clik", "TMR_clik", "TMR_classki", "TMR_clck", "TMR_clok", "TMR_Clke", "TMR_CLck", "TMR_plk", "TMR_classck", "TMR_ClK", "TMR_CLk", "TMR_chk", "TMR_chki", "TMR_clke", "TMR_chck", "TMR_Clck", "TMR_clK", "TMR_mlK", "TMR_classc", "TMR_Clc", "TMR_clki", "TMR_rlK", "TMR_plik", "TMR_chc", "TMR_CLok", "TMR_Clk", "TMR_mlk", "TMR_rlck", "TMR_Clki", "TMR_plck", "TMR_mlck", "TMR_rlk", "TMR_clc", "TMR_Clok"], "SDRAM_clk": ["SDRAM_clks", "SDRAM_plks", "SDRAM_CLok", "SDRAM_CLk", "SDRAM_Clks", "SDRAM_Clik", "SDRAM_plik", "SDRAM_plck", "SDRAM_plok", "SDRAM_clck", "SDRAM_plk", "SDRAM_CLck", "SDRAM_clik", "SDRAM_elks", "SDRAM_Clk", "SDRAM_elok", "SDRAM_elik", "SDRAM_clok", "SDRAM_Clck", "SDRAM_elk", "SDRAM_CLks", "SDRAM_elck"], "PLB_clk": ["PLB_combok", "PLB_CLk", "PLB_plck", "PLB_plok", "PLB_CLck", "PLB_CLik", "PLB_plk", "PLB_plks", "PLB_combku", "PLB_clck", "PLB_flku", "PLB_pln", "PLB_CLks", "PLB_flk", "PLB_Clck", "PLB_CLn", "PLB_Clku", "PLB_clik", "PLB_Clik", "PLB_flik", "PLB_flks", "PLB_CLku", "PLB_Clok", "PLB_Clks", "PLB_CLok", "PLB_combks", "PLB_cln", "PLB_clok", "PLB_plik", "PLB_Clk", "PLB_clks", "PLB_clku", "PLB_combk", "PLB_Cln"], "OPB_clk": ["OPB_Clck", "OPB_collk", "OPB_ecok", "OPB_plks", "OPB_CLks", "OPB_Clk", "OPB_plk", "OPB_clok", "OPB_clkn", "OPB_collck", "OPB_CLkn", "OPB_CLok", "OPB_collks", "OPB_clck", "OPB_CLkg", "OPB_CLk", "OPB_plkn", "OPB_clks", "OPB_eck", "OPB_Clkg", "OPB_eckg", "OPB_ecck", "OPB_CLck", "OPB_Clok", "OPB_plck", "OPB_clkg", "OPB_collkn"], "EXT_clk": ["EXT_clkk", "EXT_logkk", "EXT_logke", "EXT_Clk", "EXT_cleck", "EXT_CLkk", "EXT_CLk", "EXT_logk", "EXT_plks", "EXT_flok", "EXT_flk", "EXT_clke", "EXT_flks", "EXT_CLck", "EXT_Clke", "EXT_Clok", "EXT_cleke", "EXT_clek", "EXT_flke", "EXT_plok", "EXT_clks", "EXT_clok", "EXT_plk", "EXT_plke", "EXT_CLke", "EXT_clck", "EXT_Clks", "EXT_clekk", "EXT_logck"], "UART_clk": ["UART_clb", "UART_CLck", "UART_Clck", "UART_plok", "UART_klky", "UART_CLok", "UART_clik", "UART_CLk", "UART_clck", "UART_klk", "UART_CLky", "UART_plky", "UART_plik", "UART_plk", "UART_Clb", "UART_clky", "UART_plck", "UART_klck", "UART_clok", "UART_plb", "UART_Clik", "UART_klok", "UART_Clk"], "M": ["Y", "IM", "D", "B", "MT", "Q", "K", "MN", "L", "Z", "MON", "R", "MS", "MO", "H", "I", "MF", "MD", "SM", "X", "O", "E", "MM", "MI", " m", " D", "N", "U", "T", "P", "F", "RM", "G", "MC", "S", "A", "LM", "J", " N", "C", "W", "V", " L", "m"], "D0": ["D14", "D4", " D63", "MD2", " D192", "Do6", " DZero", "D00", "M13", " D029", "V0", " D4", "d6", "DO180", "FZero", "D080", "DD0", "Do63", "d255", "DO14", " D6", "Do50", "Do0", "R0", "d90", " D86", "Do125", "d13", "D180", "DO255", "d192", "d00", "DD029", "DO0", "D029", "d2", "D90", "Do192", "D3", "L080", "d3", "D6", "V6", "D50", "V080", "d0", "Do14", " D255", "Do1", "R255", "M6", "d14", "M0", "F0", "d125", "M63", "D125", " D180", " D50", "d4", "Do4", "Do2", "DD255", "V00", "M50", "L0", "MD90", "M90", "M86", "d86", "MD0", " D13", " D125", " D3", " D14", "DoZero", "d50", "M00", "D13", "R029", "L6", "d180", "D255", "D86", " D00", "F1", "Do3", "F50", "DZero", "M2", "D192", "Do080", "D63", "Do00", "L00"], "D1": ["F7", "D4", "Do1", "Do0", "M01", "M6", "P2", "d1", "V2", "Do01", "M3", "M0", "F0", "F4", "F2", "F1", "D01", "M1", "d2", "P1", "V7", "V1", "d4", "D3", "Do2", "P3", "F01", "d3", "D6", "V4", "P6", "M2", "D7", "d6", "d7"], "D2": [" D6", " D5", "X32", " D20", "M6", "d20", "X2", "F3", "d1", "D02", "D9", "M0", "d5", "F0", "F2", "MD2", "F1", " D9", "M02", "X02", "d2", "M5", "D20", "M9", "d9", "d32", "D3", "D32", "d3", "D6", "D5", "d02", "MD3", "M2", "M20", "d6", "MD1", "d0", "MD0", "X5", "M32"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n", "idx": 18853, "substitutes": {"opaque": [" oprobe", "ovaque", "opusacity", "OPaque", "opusrobe", "ocacle", "opaques", "opusac", "ocaques", "ocaque", "oprobe", "operacity", "operac", " opac", "ovaques", "opacity", "operrobe", "ovacle", "OPaques", " opacity", "OPacle", "opacle", "opusaque", "operaque", "opac"], "addr": ["dr", "dc", "src", "mode", "node", "alt", "pad", "ad", "point", "len", "base", "fd", "args", "config", "state", "address", "code", "ord", "index", "adr", "data", "byte", "ace", "hop", "align", "ext", "pos", "patch", "pointer", "ptr", "adder", "slice", "md", "rc", "seq", "cmp", "port", "lvl", "amd", "rt", "part", "layer", "oa", "host", "offset"], "size": ["g", "sn", "scale", "length", "timeout", "large", "type", "x", "sized", "parent", " address", "six", "fee", "Size", "len", "or", "args", "SIZE", "small", "si", "ize", "capacity", "eng", "address", "code", "data", "align", "loc", "c", " Size", " sizes", "s", "en", "bytes", "send", "count", "sec", "e", "shape", "empty", "offset"], "cmd646bar": ["cmd626server", "cmd646server", " cmd646bars", "cmd16Bar", "cmd346bar", "cmd512bars", "ct512bars", " cmd646bart", "cmd512Bar", "cmd346bart", " cmd156bart", "cmd512server", "cmd156bart", "cmd646bars", "cmd6server", "cmd626Bar", "cmd346Bar", "cmd156Bar", "ct512Bar", "cmd156bar", "ct512bar", " cmd156bars", "cmd6Bar", "ct512server", "cmd626bar", "ct646bars", "cmd6bar", "cmd626bars", "cmd16bars", " cmd156Bar", "cmd16bart", "cmd646Bar", "cmd646bart", "cmd346bars", "ct646server", "cmd512bar", " cmd646Bar", "ct646Bar", "cmd6bars", " cmd156bar", "ct646bar", "cmd156bars", "cmd16bar"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t hpet_ram_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    HPETState *s = opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            return timer->config;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            return timer->config >> 32;\n\n        case HPET_TN_CMP: // comparator register\n\n            return timer->cmp;\n\n        case HPET_TN_CMP + 4:\n\n            return timer->cmp >> 32;\n\n        case HPET_TN_ROUTE:\n\n            return timer->fsb;\n\n        case HPET_TN_ROUTE + 4:\n\n            return timer->fsb >> 32;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return s->capability;\n\n        case HPET_PERIOD:\n\n            return s->capability >> 32;\n\n        case HPET_CFG:\n\n            return s->config;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl\\n\");\n\n            return 0;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick >> 32;\n\n        case HPET_STATUS:\n\n            return s->isr;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 18892, "substitutes": {"opaque": ["OPc", "opque", "opacs", "OPaque", "OPacs", "opaques", "ocaques", "ocaque", "ipque", "ocque", " opac", "OPque", "ipac", " opque", "OPac", "operc", "operque", "OPaques", "opc", "operaques", "occ", "operaque", "ipaque", "opac", "ipacs", " opacs"], "addr": ["dr", "val", "fx", "dc", "src", "clock", "work", "x", "node", "alt", "asm", "prefix", "ix", "pad", "arm", "ad", "dim", "conn", "coord", "base", "len", "i", "config", "id", "db", "address", "code", "padding", "ord", "adr", "data", "ace", "rx", "ctx", "ady", "hop", "mac", "align", "ext", "slot", "ref", "channel", "pos", "p", "nr", "amp", "delay", "tx", "pointer", "ptr", "slice", "sta", "url", "seq", "cmp", "start", "host", "offset"], "size": ["length", "x", " error", " len", "Size", "len", "SIZE", "address", "data", " c", "ctx", " sizes", "pointer", " bytes", "bytes", " mem", " length", " args", " data"], "s": ["g", "local", "lines", "client", "session", "secondary", "uns", "js", "plugins", "or", "r", "gs", "c", "ssl", "ches", "sl", "b", "socket", "stats", "states", "sets", "a", "ins", "m", "results", "server", "sf", "http", "ments", "times", "ions", "in", "ing", "ns", "site", "si", "args", "i", "multi", "tests", "state", "your", "es", "als", "p", "sb", "ts", "sie", "y", "current", "services", "l", "sym", "words", "its", "sync", "f", "ops", "rs", "south", "ss", "sq", "ings", "ies", "address", "o", "xs", "sim", "S", "sg", "ses", "options", "spec", "rates", "is", "cs", "ims", "aws", "sys", "ports", "complete", "t", "parts", "storage", "status", "ls", "w", "ers", "service", "comments", "slice", "ed", "request", "e", "features", "ds", "v", "settings"], "cur_tick": ["curLday", "curJcall", "curxhop", "curVday", " cur_tag", "cur_stick", "curxtick", " cur_clock", "curVcheck", "curJstick", " cur_check", "curFtick", "cur_clock", "curjcycle", "curVtick", " cur_sync", " cur_stick", "curwcycle", " cur_year", "cur_lock", "cur_val", "cur67stick", "cur_dt", "curFclock", "curVtime", "cur_ick", "prev_val", "curJdt", "curjtick", "curFkick", "prev_tick", "curJspin", "curxsync", "curRcycle", " cur_time", " cur_day", "curLtime", "curwval", "curjstick", "curLcheck", " cur_hop", " cur_call", "cur_day", "curjyear", "cur67year", "curxstick", "curRlock", "cur_tag", "curjtag", "cur_sync", "curjsync", "curjkick", "curFick", "curJtick", "cur67tag", " cur_ick", "cur_hop", " cur_spin", "curJcookie", "cur_spin", "curRtick", " cur_cookie", "curLtick", "curxcookie", "cur_call", " cur_trigger", " cur_cycle", "cur_trigger", "cur_cookie", "cur_cycle", "curwdt", "cur67tick", "prev_cycle", "cur_kick", " cur_kick", "curJick", " cur_lock", "cur_check", "curxtrigger", "curjclock", "curRtrigger", "curJhop", "curwtick", "curjick", "curJcycle", "curJval", "cur_year", "curxcycle", "cur_time", "prev_dt", "curjtrigger"], "index": ["val", "alpha", "dc", "example", "length", "number", "xxxx", "route", "match", "inc", "Index", "x", "type", "axis", "name", "ix", "prefix", "dim", "conn", "connection", "point", "fee", "test", "len", "position", "si", "i", "id", "nn", "address", "code", "diff", "ace", "host", "fff", "hop", "align", "loc", "xxx", "loop", "height", "pos", "key", "ind", "active", "pointer", "value", "slice", "update", "search", "insert", "weight", "find", "element", "num", "seq", "shape", "amp", "offset"], "timer": ["server", "header", "inner", "icer", "meter", "later", "timeout", "aer", "worker", "match", "clock", "cer", "roller", "runner", "times", "tim", "buffer", "Timer", "test", "tm", "imer", "counter", "peer", "message", "si", "watch", "ester", "user", "duration", "parser", "writer", "reader", "monitor", "trial", "trigger", "browser", "time", "processor", "loader", "mr", "service", "amer", "thread", "er", "sim", "tc", "wrapper", "err", "maker", " timers", "ter", "handler", "ger", "term", "acer", "text", "ler", "driver", "device", "ipper", "trace", "event", "manager", "player", "m"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,\n\n                            uint16_t vendor, uint16_t device,\n\n                            uint16_t class_code, uint8_t pif)\n\n{\n\n    uint8_t *config;\n\n    uint32_t size;\n\n\n\n    proxy->vdev = vdev;\n\n\n\n    config = proxy->pci_dev.config;\n\n    pci_config_set_vendor_id(config, vendor);\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n", "idx": 18893, "substitutes": {"proxy": ["core", "phi", "server", "resource", "ghost", "client", "project", "bo", "ruby", "http", "proc", "component", "queue", "cache", "instance", "source", "parent", "library", "Proxy", "linux", "cube", "web", "shadow", "force", "connection", "pool", "py", "child", "base", "lib", "module", "slave", "db", "zip", "cop", "index", "pse", "engine", "ping", "roxy", "ca", "callback", "profile", "bridge", "apache", "coe", "service", "pe", "slice", "wrapper", "gp", "image", "PRO", "phy", "rc", "bus", "request", "port", "pro", "driver", "model", "io", "ube", "remote", "alias", "que", "plugin", "clone"], "vdev": ["svdiff", "lvself", "vmdevice", "vow", "lvdc", " vde", "hdi", "fprof", "vdiff", "nvvalid", " vdc", "pdev", " vev", "udevice", " vdef", "vmpriv", "pserv", "vconn", "nvdevice", "fdi", "svdevice", "Vdiv", "nvow", "vmod", "vdi", "ldev", "nvdef", "vself", " vdata", "Vev", "pev", "fdevice", "hdevice", "Vdev", "nmod", "nvconn", " vpriv", "lvdevice", "vdef", "vdd", "fdev", "hdev", "vserv", "vmvalid", "udev", "lvdiv", "ldef", "nself", "pver", "vmdata", "lmod", "ppriv", "udi", "vdc", " vdevice", "lvpriv", "svver", "vpriv", " vserv", "nvdc", "vprof", "vev", "svdev", "lvow", "lvdev", "ndef", "pde", "vvalid", "nvdiff", "vdevice", "pconf", "nvdev", "npriv", " vow", "Vserv", "ndev", "svvalid", "hconn", "vmdev", "vconf", "vdiv", "pdiv", "vde", "vver", "lconn", "ldevice", "vmdd", "pself", "ndiv", "vmdiff", "pdata", " vdiv", " vver", " vconf", "svconf", "uprof", " vdd", " vmod", "pdd", "vdata", "svde", "hprof", "hdef"], "vendor": ["svoven", "lvoice", "uvender", "navnc", "virgin", "lvender", " voven", "cendor", "qudev", "quoice", " voy", "soven", "uvirgin", "foice", "lvirgin", "sirgin", "sendor", "cirgin", "bendor", "voy", "uvoven", "navoven", "ivendor", "ivdev", "quendor", "svirgin", " virgin", "svender", "ivoy", "fendor", "voice", "coice", "vnc", " vnc", "birgin", "vender", "lvendor", " voice", "navirgin", "fender", "boven", "uvendor", "svendor", "navendor", "firgin", "voven", "bnc", "quoy", "cender", "ivoice", "sender"], "device": ["di", "dc", "component", "project", "domain", "node", "d", "connection", "description", "version", "vision", "direction", "module", "dev", "directory", "address", "dir", "feature", "target", "engine", "mac", "devices", "mobile", "unit", "service", "package", "drive", "model", "disk", "driver", "password", "dn", "Device", "serial", "md", "attribute", "mi", "product", "mode"], "class_code": [" class_desc", "classercodes", "class_codes", "class_message", "classercode", "classblockmessage", "class_id", "classblockcoded", "class_desc", "classblockcode", " class_two", "class_coded", " class_coded", "classermessage", "classblockcodes", "class_two", "classercoded", " class_codes", " class_id", " class_message"], "pif": ["fifer", " pip", "fif", " pifer", "fIF", "Piff", "fiff", "pip", "pIF", "Pifer", "Pif", "fip", "Pip", "pifer", "piff", " piff", " pIF", "PIF"], "config": ["set", "class", "not", "client", "session", "cache", "exec", "connection", "pool", "view", "support", "code", "block", "account", "conf", "cf", "app", "c", "connect", "content", "cfg", "image", "context", "sec", "attribute", "project", "name", "contract", "source", "load", "access", "args", "lib", "state", "index", "qa", "data", "man", "license", "design", "p", "desc", "comp", "host", "json", "f", "cat", "bc", "Config", "capacity", "address", "control", "init", "input", "body", "ct", "rc", "options", "custom", "spec", "fig", "info", "section", "gate", "css", "output", "supp", "inc", "feat", "conn", "front", "controller", "ch", "path", "ext", "ca", "service", "gui", "settings", "text", "driver", "password", "sc", "plugin", "tail"], "size": ["security", "core", "set", "server", "scale", "shift", "length", "number", "large", "timeout", "name", "complete", "cache", "sized", "type", "ci", "six", "form", "fee", "Size", "member", "len", "si", "args", "SIZE", "small", "ize", "capacity", "storage", "address", "code", "speed", "max", "full", "data", "sum", "loc", "time", "c", "sync", "limit", "key", "value", "z", "mini", "weight", "count", "sec", "shape", "e", "empty", "iz", "offset"]}}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static int usb_device_add(const char *devname, int is_hotplug)\n\n{\n\n    const char *p;\n\n    USBDevice *dev;\n\n\n\n    if (!free_usb_ports)\n\n        return -1;\n\n\n\n    if (strstart(devname, \"host:\", &p)) {\n\n        dev = usb_host_device_open(p);\n\n    } else if (!strcmp(devname, \"mouse\")) {\n\n        dev = usb_mouse_init();\n\n    } else if (!strcmp(devname, \"tablet\")) {\n\n        dev = usb_tablet_init();\n\n    } else if (!strcmp(devname, \"keyboard\")) {\n\n        dev = usb_keyboard_init();\n\n    } else if (strstart(devname, \"disk:\", &p)) {\n\n        BlockDriverState *bs;\n\n\n\n        dev = usb_msd_init(p, &bs);\n\n        if (!dev)\n\n            return -1;\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {\n\n                dev->handle_destroy(dev);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (!strcmp(devname, \"wacom-tablet\")) {\n\n        dev = usb_wacom_init();\n\n    } else if (strstart(devname, \"serial:\", &p)) {\n\n        dev = usb_serial_init(p);\n\n#ifdef CONFIG_BRLAPI\n\n    } else if (!strcmp(devname, \"braille\")) {\n\n        dev = usb_baum_init();\n\n#endif\n\n    } else if (strstart(devname, \"net:\", &p)) {\n\n        int nic = nb_nics;\n\n\n\n        if (net_client_init(\"nic\", p) < 0)\n\n            return -1;\n\n        nd_table[nic].model = \"usb\";\n\n        dev = usb_net_init(&nd_table[nic]);\n\n    } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) {\n\n        dev = usb_bt_init(devname[2] ? hci_init(p) :\n\n                        bt_new_hci(qemu_find_bt_vlan(0)));\n\n    } else {\n\n        return -1;\n\n    }\n\n    if (!dev)\n\n        return -1;\n\n\n\n    return usb_device_add_dev(dev);\n\n}\n", "idx": 18915, "substitutes": {"devname": ["guName", "domno", " devName", "deviceNAME", "devicenum", "evno", "driverstart", "pubName", "plugcase", "busnamed", "propno", "Devname", "deviceid", "divName", "plugname", "evnamed", "devstart", "driverno", "devnum", "gustart", "bugname", " devcase", "drivername", "DevName", "divnum", "busno", "plugName", "guname", "bugstart", "devid", "devcase", "bugame", " devid", "defno", "propName", "evname", "deviceno", "deviceName", "defid", "busName", "evstart", "pubstart", "DevNAME", "devicename", "devame", "guno", "divno", "propname", " devno", "devno", "plugno", "driverame", "defName", "divname", "propstart", "pubname", "domname", " devnum", "devNAME", "devnamed", "domstart", "devName", "evName", " devnamed", "busname", "defname", " devNAME", "pubno", "evcase", " devstart", "evame", "bugno", "devicestart"], "is_hotplug": ["is_hotsplug", "is_hotspl", "is_hotsPlug", "is_deadlog", "is_nitpl", "is_hotpl", "is_HotPlug", "is_hotPlug", "is_hotsplugin", "is_hotslog", "is_nitplugin", "is_hotlog", "is_Hotlog", "is_nitplug", "is_liveplugin", "is_hotplugin", "is_liveplug", "is_deadplug", "is_deadPlug", "is_Hotplug", "is_livepl"], "p": ["g", "self", "cp", "client", "f", "ap", "pt", "pc", "sp", "ps", "tp", "jp", "proc", "this", "wp", "op", "lp", "po", "t", "q", "api", "param", "pad", "d", "point", "np", "py", "n", "ip", "bp", "pi", "plugin", "i", "args", "pot", "path", "pp", "pa", "r", "h", "vp", "pb", "data", "o", "par", "params", "pre", "c", "P", "fp", "s", "pe", "b", "per", "e", "l", "port", "part", "v", "pr", "j", "m"], "dev": ["di", "DEV", "dc", "grad", "cache", "off", "end", "valid", "test", "pub", "block", "conf", "app", "gu", "comment", "adv", "ow", "inst", "mod", "dd", "req", "fail", "lib", "od", "user", "img", "dom", "data", "var", "cam", "def", "err", "die", "bug", "serv", "md", "ver", "f", "cmd", "ad", "plug", "error", "db", "diff", "Dev", "develop", "dist", "ve", "dem", "priv", "ev", "nov", "bus", "info", "development", "df", "result", "conn", "d", "root", "obj", "ch", "gd", "boot", "controller", "av", "w", "de", "cmp", "driver", "device", "rad", "debug", "v"], "bs": ["cs", "css", "bd", "ms", "sa", "ps", "bc", "rs", "BS", "bh", "ss", "bi", "its", "ns", "bb", "bp", "bm", "state", "blocks", "db", "bid", "pb", "vs", "ls", "iss", "bps", "us", "ba", "gs", "sb", "bas", "s", "ks", "b", "sl", "mb", "fs", "bis", "cb", "fps", "bus", "gb", "bos", "os", "ins", "lb", "sc", "ds", "bl", "fb", "br"]}}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {\n\n        return;\n\n    }\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_schib_valid(&schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, &schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 18931, "substitutes": {"cpu": ["core", "cp", "css", "chip", "cm", "pc", "proc", "intel", "CPU", "cli", "uc", "machine", "jp", "cache", "net", "linux", "conn", "connection", "boot", "config", "fc", "cpp", "pu", "pl", "pp", "computer", "program", "ctx", "uci", "lc", "mac", "processor", "GPU", "c", "fp", "prem", "loader", "p", "hp", "roc", "pkg", "process", "gp", "cow", "vm", "CP", "rc", "kernel", "mem", "performance", "cmp", "python", "lb", "gpu", "cn"], "reg1": ["REG3", "rcfirst", "regb", "region1", "region2", "rc1", "arc1", "regionfirst", "rc2", "reg3", " regb", "rg2", "rgfirst", "REGb", "arcb", " reg3", "regfirst", "REG1", "rg1", "arc3", "reg2"], "ipb": [" ipa", " ipB", " ipn", "opb", "ipv", " ipl", "IPn", "IPB", "ipsl", "IPl", "ipB", "ipl", "ipsa", " ipv", "ipsb", "IPv", "opa", "opn", "IPa", "ipn", "IPb", "ipsB", "opv", "ipa"], "cssid": ["nskid", "jsID", "hesside", "jsid", "ssID", "ssname", "nsID", "rssit", "rssid", "cssit", "lsId", "rssids", "lside", "passide", "csside", "hessid", "rssId", "cssID", "ssit", "lsids", "jside", "cssids", "rssname", "passID", "passid", "passname", "nsids", "nside", "nsid", "nsId", "csskid", "hessname", "hessID", "cssname", "lsid", "rsside", "hessit", "jskid", "sskid", "cssId", "sside"], "ssid": ["cssite", "ssID", "ssname", "rssid", "osside", "csids", "cssiden", "cside", "ossite", "csname", "spid", "cslit", "ssite", "passide", "csid", "csside", "rsskid", "spids", "skkid", "ssids", "spname", "cssID", "sslit", "sklit", "skid", "skide", "rssname", "cssids", "ossid", "passid", "spID", "csslit", "passname", "passkid", "csiden", "csskid", "ossiden", "cssname", "rsside", "ssiden", "csID", "csite", "sskid", "sside", "cskid"], "schid": ["skip", "ssname", "chip", "ski", "cssip", "ssinfo", "ssbit", "ssi", "skname", "schbit", "chi", "schinfo", "skid", "ssit", "chit", "schi", "schname", "cssinfo", "schit", "schip", "cssname", "skbit", "chid", "chbit", "skit", "ssib", "skinfo", "skib", "chib", "ssip"], "m": ["g", "cm", "f", "M", "mode", "machine", "om", "sh", "dm", "mu", "d", "fm", "n", "pm", "ch", "i", "module", "bm", "config", "h", "sm", "r", "man", "o", "w", "c", "p", "s", "y", "mr", "b", "am", "vm", "md", "mc", "e", "mem", "l", "ym", "a", "im", "hm", "manager", "v", "mi"], "sch": ["ssh", "cs", "sn", "shop", "css", "cm", "zh", "sp", "chan", "cer", "inst", "cur", "sh", "kr", "inch", "ss", "conn", "kh", "rh", "ch", "si", "sd", "sm", "chi", "che", "wk", "co", "Ch", "hop", "loc", "conf", "sk", "Sch", "c", "chn", "k", "sb", "ach", "her", "gh", "ssl", "sky", "sl", "cr", "arch", "chid", "soc", "cht", "mc", "gb", "ph", "och", "sc", "se", "ah", "ich", "sche"], "schib": ["chob", "skip", "khIB", "chip", "khab", " schob", "chIB", "schIB", "skIB", "chie", "chab", "scheig", "chig", "schelib", " schbi", "chbi", "scheie", "scheib", "schig", "scheip", "skie", "schob", "ssbi", "skid", "chlib", "schab", "schie", "scheIB", "ssob", "scheab", "schip", " schip", "schbi", "sklib", "schlib", "skig", "chid", "ssib", "khip", "skib", "khib", "chib", "ssip", "scheid"], "addr": ["ann", "rr", "acl", "src", "ars", "node", "ac", "x", "rs", "asm", "dd", " address", "pad", "arm", "ad", "oa", "reg", "add", "inter", "base", "ip", "fd", "args", "len", "id", "az", "address", "code", "ord", "afi", "adr", "data", "ace", "rx", "mac", "call", "align", "ext", "ref", "ag", "amp", "rac", "hash", "Address", "ptr", "sta", "adder", "rc", "attr", "url", "cmp", "amd", "arr", "ack", "order", "rt", "part", "au", "art", "host", "offset"], "cc": ["cca", "cs", "coll", "dc", "kk", " ecc", "pc", "lv", "ck", "match", "unc", "uc", "inc", "bc", "ac", "nc", "ci", "dd", "success", "fee", " rc", "ff", "isc", "co", "code", " ret", "ec", "pass", "cci", "call", "cf", "RC", "ce", "c", "result", "cost", " succ", " CC", "func", "vc", "CC", "sup", "comment", "cmd", "acc", "weight", "PC", "ct", "xx", "rc", "count", "cb", "seq", "ret", "cmp", "bug", "ucc", "sc", "fc"], "env": ["console", "core", "shell", "cp", "server", "ern", "eu", "inet", "proc", "cli", "erv", "style", "nc", "cache", "net", "global", "asm", "enable", "conn", "eni", "exec", "np", "obj", "hw", "enc", "config", "agent", "state", "eng", "code", "dict", "equ", "estate", "ctx", "ec", "engine", "esp", "exc", "conf", "cf", "ea", "c", "loader", "pe", "ep", "er", "ei", "cfg", "err", "priv", "en", "context", "vm", "eve", "gui", "viron", "ev", "e", "cmp", "environment", "python", "que", "ini", "oa", "eye"], "ar": ["ara", "arp", "str", "AR", "ary", "ap", "aer", "ars", "dar", "iar", "inc", "ac", "rs", "array", "arm", "ad", "arn", "har", "el", "rar", "ir", "inter", "base", "or", "args", "tar", "Ar", "ra", "r", "ai", "ard", "adr", "ace", "aa", "par", "are", "c", "al", "ada", "ari", "arat", "cr", "car", "at", "arch", "as", "arc", "area", "a", "air", "arr", "arg", " array", "art", "amp"]}}
{"project": "qemu", "commit_id": "7e5f90fa3ff32ea31548666d57a78005555ecf34", "target": 1, "func": "int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n\n                int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 18942, "substitutes": {"filename": ["FH", "txt", "figure", "tif", "f", "dll", "acl", "name", "ppa", "prefix", "source", "uri", "lf", "wb", "kl", "wl", "download", "directory", "path", "il", "binary", "Filename", "files", "rb", "file", "fp", "rl", "nil", "fil", "fn", "url", "tty", "username", "jpg", "utf", "original"], "ep": ["EP", "eps", "cp", "imp", "yp", "ap", "sp", "wp", "ppa", "op", "isp", "el", "root", "ip", "enc", "xp", "cl", "pp", "email", "ream", "ef", "ec", "esp", "esi", "ext", "fp", "channel", "p", "up", "dep", "elf", "rc", "Ep", "ev", "seq", "e", "dp", "ek", "env", "mp", "offset"], "loadaddr": ["lockaddr", "lockoffset", "laddress", "packptr", "loadoffset", "packaddr", "lockaddress", "lptr", "loadaddress", "loffset", "packoffset", "laddr", "packaddress", "lockptr", "loadptr"], "is_linux": ["is2Linux", "is_mac", " is_boot", " is_local", " is_pkg", "is___local", " is_ubuntu", "is_boot", "is___linux", "is_binary", "is_ubuntu", "is2cpu", "is___ubuntu", " is_mac", " is_intel", "is___binary", "is2mac", "is_Linux", "is_local", "is2linux", " is_cpu", "is_pkg", "is_cpu", "is_intel", " is_Linux", " is_binary"], "fd": ["fx", "cd", "FH", "sf", "df", "bd", "f", "dc", "dra", "handle", "fed", "pd", "ds", "dd", "buf", "pipe", "draft", "ird", "form", "d", "lf", "feed", "wb", "len", "sd", "fw", "FD", "db", "dir", "fr", "dl", "reader", "writer", "fl", "wd", "file", "fp", " fid", "ld", "cond", "nd", "xd", "wind", "fa", "ecd", "fs", "hd", "fat", "handler", "fi", "fn", "vd", "bf", "dat", "dn", "flo", "fc", "md", "ln", "fb"], "size": ["g", "sn", "scale", "any", "f", "length", "large", "name", "temp", "sized", "cache", "sh", "form", "fee", "Size", "n", "len", "si", "SIZE", "small", "i", "enc", "speed", "ize", "capacity", "code", "address", "sum", "loc", "body", "time", "sync", "unit", "content", "z", "err", "fat", "en", "weight", "count", "sec", "shape", "empty", "iz", "mode"], "h": ["g", " dh", " self", "header", "f", " hash", "hi", "sh", "bh", "eh", "rh", "d", " uh", "H", " hr", "r", "hr", "w", " dw", "c", "p", "hp", "ih", " ah", "z", "hh", "hd", " hp", "handler", " H", " header", "e", " eh", "ph", "hs", "ah", "hm", "ht", "v", "host", "m"], "hdr": ["handvd", "rhder", "handrid", "hod", "hydr", "phstr", "hrid", " hpr", "hyDR", "hdi", "shDR", "ghcart", "ihdr", "adhdr", "hhmr", "chdr", "khstr", "ghrid", "hvd", "hrcart", "bhdr", "ghrec", "Hder", "ohder", "khrid", "hyr", "hhDR", " hmr", "href", "hymr", " hod", "thrr", "adhDR", "rhdr", "ihrid", "hder", "avdr", "phrec", "archder", "hadr", "hfr", " hder", "hiDR", " hr", "rhrec", "mdr", "hrdr", "hild", "archdr", "hmr", "khdr", "adhrid", "mrec", "ghdr", "bhrr", "rhadr", "handdr", "shrec", " hstr", "herder", " hld", "hrrid", "shdr", "hlrec", "shadr", "thder", "khld", "mhr", "ohfr", "shdi", " hrr", "Hdr", "chder", "hrrec", "rhDR", "hld", " hdi", " hvd", "hhdr", "hlpr", " hrid", "avrec", "hirid", "chDR", "mdi", " hhr", "hldr", "Hdi", "hlrr", "hr", "hider", "ohrec", "rhfr", "hlod", "adhder", "avvd", " href", "herdr", " hrec", "handrec", "herfr", "hlrid", "httpDR", "httpdr", " hadr", "avrid", "hlDR", "hhr", "bhder", "shhr", "hidr", "Hstr", "ohdr", "hstr", "httpdi", "shpr", "archstr", "ihod", "HDR", "hldi", "shref", "hcart", "hrec", "ihDR", "ihder", "hlcart", "thdr", "hpr", "Hrec", "histr", "hDR", "phDR", "archDR", " hDR", "phdr", "ihrr", "herrec", "chdi", "httpref", "hrr"], "data": ["batch", "di", "progress", "rec", "inner", "none", "extra", "sent", "cache", "window", "end", "valid", "zip", "aw", "actions", "block", "byte", "nd", "content", "append", "done", "image", "zero", "a", "wa", "empty", "results", "alpha", "timeout", "source", "dd", "buf", "pad", "no", "multi", "memory", "aa", "p", "response", "da", "missing", "value", "sample", "json", "array", "buffer", "feed", "base", "Data", "partial", "input", "binary", "raw", "next", "body", "format", "broken", "pos", "la", "dat", "ata", "arr", "str", "output", "result", "complete", "new", "parent", "media", "DATA", "d", "len", "download", "dt", "reader", "read", "final", "slice", "start", "ds"], "compressed_data": ["compressed___data", "compested_result", "compested___dist", "compested_data", "compodedingsize", "compodedingresponse", "compressederdat", "compressederdata", "compressedingdat", "compodedingdat", "compoded_data", "compressed___result", "compoded_response", "comprated_body", "compodedingdata", "compested_dist", "compressed_memory", "compressedingbody", "compoded_size", "compressedingresponse", "compested___result", "compressed_byte", "compratedingsize", "compratedingbyte", "compressed_dat", "compressedingbyte", "comprated_data", "comprated_size", "compoded_dat", "compressedingsize", "compressed_dist", "compressed_size", "compested___data", "compratedingbody", "compressedingdata", "compested___memory", "compressed_result", "compressed___dist", "compressed_body", "compressed_response", "compressedersize", "compressederresponse", "compratedingdata", "compressed___memory", "comprated_byte", "compested_memory"], "max_bytes": ["max2bytes", "maxingbits", " max_pages", "maxingseconds", "max_pages", "maxingframes", "max_days", "max__seconds", " max_bits", "max_bits", "max_seconds", "min_bytes", "max2bits", "max67bytes", "maxingbytes", "max67seconds", " max_seconds", "max67days", "max__bytes", " max_blocks", "max__pages", "max_blocks", "min_days", " max_frames", "max_groups", "max67groups", "max2seconds", "max_frames", "min_groups", "min_seconds", "max2blocks"], "bytes": ["results", "lines", "ops", "bs", "loads", "amples", "complete", "values", "parent", "cells", "parts", "ns", "video", "reads", "len", "args", "blocks", "ips", "bits", "code", "codes", "binary", "byte", "raw", "items", "ec", "files", "body", "content", "pieces", "pages", "steps", "units", "seq", "seconds", "outs", "words", "Bytes"]}}
{"project": "FFmpeg", "commit_id": "2e5195646dc5578e1751004b0ac6e787d18637e4", "target": 1, "func": "static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MPCContext *c = s->priv_data;\n\n    int ret, size, size2, curbits, cur = c->curframe;\n\n    int64_t tmp, pos;\n\n\n\n    if (c->curframe >= c->fcount)\n\n        return -1;\n\n\n\n    if(c->curframe != c->lastframe + 1){\n\n        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);\n\n        c->curbits = c->frames[c->curframe].skip;\n\n    }\n\n    c->lastframe = c->curframe;\n\n    c->curframe++;\n\n    curbits = c->curbits;\n\n    pos = url_ftell(s->pb);\n\n    tmp = get_le32(s->pb);\n\n    if(curbits <= 12){\n\n        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;\n\n    }else{\n\n        tmp = (tmp << 32) | get_le32(s->pb);\n\n        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;\n\n    }\n\n    curbits += 20;\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n\n\n    size = ((size2 + curbits + 31) & ~31) >> 3;\n\n    if(cur == c->frames_noted){\n\n        c->frames[cur].pos = pos;\n\n        c->frames[cur].size = size;\n\n        c->frames[cur].skip = curbits - 20;\n\n        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);\n\n        c->frames_noted++;\n\n    }\n\n    c->curbits = (curbits + size2) & 0x1F;\n\n\n\n    if (av_new_packet(pkt, size) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->data[0] = curbits;\n\n    pkt->data[1] = (c->curframe > c->fcount);\n\n\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pts = cur;\n\n    ret = get_buffer(s->pb, pkt->data + 4, size);\n\n    if(c->curbits)\n\n        url_fseek(s->pb, -4, SEEK_CUR);\n\n    if(ret < size){\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n    pkt->size = ret + 4;\n\n\n\n    return 0;\n\n}", "idx": 18963, "substitutes": {"s": ["g", "is", "cs", "sites", "sf", "ms", "f", "aws", "session", "http", "ops", "bs", "ps", "sys", "ds", "rs", "js", "ions", "t", "ss", "sq", "d", "ns", "n", "site", "si", "r", "ls", "es", "us", "gs", "conf", "p", "sb", "ks", "service", "ts", "ssl", "b", "sl", "y", "su", "fs", "services", "S", "as", "states", "sg", "e", "sets", "ses", "sv", "sym", "settings", "l", "ins", "os", "sc", "se", "spec", "qs", "v", "sync", "m"], "pkt": ["pKT", "packet", "pracket", "spke", " packet", "prekt", "plke", "Pkt", "fet", "Pkg", "Pett", "psth", "opct", "Pft", "Pet", "pct", "fkt", "pett", "pet", "Packet", "Pdt", "facket", "pft", "Pke", "ppkt", " pct", "prkg", "placket", "opkg", "PKT", " psth", "plett", " pkg", " pet", "prft", "pdt", "pke", "opacket", "spacket", " pft", "ppKT", "prkt", "Psth", "ppacket", "pkg", "opkt", "preacket", "predt", " pdt", "prekg", " pKT", "ppsth", "spkt", "fkg", "plkt", "Pct", "spett"], "c": ["g", "cs", "cp", "cm", "dc", "f", "cat", "coll", "pc", "unc", "uc", "ac", "cache", "nc", "u", "x", "cur", "ci", "t", "bc", "conn", "q", "d", "n", "col", "ch", "enc", "i", "config", "chain", "cl", "h", "co", "code", "r", "con", "o", "ec", "lc", "w", "ca", "cf", "oc", "ce", "k", "p", "cc", "ic", "cy", "vc", "y", "b", "cr", "cus", "z", "tc", "m", "ct", "sec", "mc", "e", "l", "C", "cu", "xc", "sc", "fc", "v", "cn"], "ret": ["RET", "val", "reply", "f", "length", "result", "uf", "match", "temp", "cache", "Len", "buf", "alt", "res", "flat", " len", "len", "fun", "obj", "pet", " result", "code", "data", " resp", "rets", "att", "det", "nt", "def", "resp", "re", "ft", "rc", "num", "Ret", "seq", "mem", "arr", "lit", "rt", "part", "info"], "size": ["g", "skip", "scale", "sp", "handle", "sent", "extra", "sized", "sh", "sw", "speed", "code", "r", "used", "weight", "send", "bytes", "sec", "shape", "empty", "use", "name", "temp", "buf", "ny", "fee", "Size", "si", "ize", "parse", "max", "data", "num", "se", "offset", "sn", "length", "error", "buffer", "feed", "n", "_", "SIZE", "small", "capacity", "write", "en", "len", "enc", "sum", "loc", "read", "time", "unit", "count", "e"], "size2": ["name1", "position1", " size1", " size5", "speedTwo", "length32", "speed32", "size56", "time1", "length2", "rateTwo", "size1", " size56", "name2", " size3", "time4", "sizeTwo", "ize1", "rate1", "positionTwo", "length3", "speed3", "rate2", "size4", "size5", " size4", "rate32", "ize2", " size32", "position56", "length1", "name4", "length56", "size3", "speed2", "time2", " sizeTwo", "position2", "size32", "lengthTwo", "speed1", "length5", "ize5"], "curbits": ["lcribites", "caudits", "cribases", "cribals", "curbats", "scurbIT", "curtins", "scurbit", "scurbITS", "curbIT", "cuffites", "cribITS", "scurtites", "curbases", "caurIT", "coblites", " caudits", "caurals", "curbids", "scaurIT", "lcaurite", "bcurbins", "scaurit", "criborts", " curbited", "cribins", "lcribases", "curborts", "caurats", "cobliting", "cuffins", "caudases", "scurbits", "cribit", "bcribits", "caurbits", "curtIT", "bcurbids", "lcribients", "caurit", "lcurbases", "lcurbites", "crubits", "lcaurites", "scurbints", "bcurbbits", "lcurbbits", "cuffits", "crubins", "caudites", "cribIT", "bcurbits", "culpins", " caudIT", "lcribits", "lcurbits", "lcaurins", "curIT", "curites", "cribits", "bcribats", "lcurtites", "scauriting", "lcaurIT", "curlbits", "bcriborts", "scaurites", "caurins", "culpites", "bcribins", "cuffbits", "cribats", "culpit", "lcurbients", "curbbits", "lcurbIT", "cuffids", "cribites", "scurbiting", "bcribals", "cribited", "curbints", "lcurbite", "lcurtITS", "bcribbits", "culpits", "cribite", "curbiting", " curbites", "scaurits", "cauriting", "scurtints", "curins", "cribids", "caurits", "curlits", "cobbins", "lcurbITS", "coblits", "scurtits", "crubites", "caurients", "cribients", "curbite", " caudites", "lcribITS", "caudited", "scribits", "cribbits", "scurtins", "lcaurits", "bcurbals", "coblIT", "curbited", "bcurborts", "cuffints", "lcaurbits", "caurite", "crubients", "curbites", "lcurbins", "curtints", "curlids", "curbITS", "caudals", "curbit", "bcribids", "scribites", "scurbites", "caurases", "cufforts", "bcurbats", "scribITS", "caudITS", "scurbins", "caurites", "lcurtits", "caurints", "scaurins", "curbins", "curtited", "curtITS", "curtbits", "scribins", "lcribins", "curits", " curbIT", "curlorts", "curbals", "curtites", "lcurtins", "curbients", " caudited", "cobbIT", "caudins", "cobbites", "caudats", "caurITS", "caudIT", "curtits", "caudite", "cribiting", "cobbits"], "tmp": ["ape", "uv", "uf", "proc", "sp", "jp", "wp", "cache", "api", "zip", "abb", "su", "fb", "temp", "buf", "pad", "np", "bb", "bp", "data", "nt", "p", "sb", "fp", "vm", "nb", "mp", "uple", "foo", "offset", "cp", "trans", "kk", "src", "tp", "obb", "stuff", "buffer", "rb", "body", "vt", "cb", "txt", "now", "po", "perm", "ock", "obj", "tab", "mo", "storage", "meta", "cro", "ptr", "tc", "cmp", "appy", "buff", "v", "elt", "amp"], "pos": ["val", "pres", "skip", "min", "pt", "pc", "sp", "proc", "Pos", "type", "x", "temp", "op", "cache", "po", "nos", "res", "end", "rel", "no", "len", "position", "pi", "POS", "fin", "state", "pl", "index", "doc", "data", "block", "addr", "stat", "loc", "pre", "conf", "slot", "ref", "all", "p", "line", "unit", "pointer", "neg", "prop", "count", "sec", "pose", "start", "pid", "port", "os", "pro", "rot", "spec", "part", "pri", "offset"], "curframe": ["curimage", "curfamily", "Curmodule", "prevfram", " curframes", "persample", "curframes", "forefamily", "urmodule", "urframe", "currentmodule", "cursample", "foreframe", "persequence", "currentframe", "prevsample", " curmodule", "Curfamily", "prevcycle", "prevframes", "currentfram", " curflower", " curFrame", " curfamily", "foreflower", "Curflower", "perfram", " cursequence", "lastsequence", "vercycle", "lastfram", "permodule", "perframe", "currentsequence", "curfram", "prevframe", "firstimage", "catfram", "firstframe", "curflower", "currentframes", "Curfram", "curFrame", "urfram", "Curframe", "percycle", "prevFrame", " curimage", "catsequence", "curcycle", "Curcycle", "catframe", "vermodule", "currentimage", "cursequence", "currentthread", "catthread", "firstsequence", "curmodule", "currentFrame", "firstFrame", "urcycle", "curthread", "verframe", "lastframe", "verfram", " curfram", " curthread", "Cursample", "firstfram", "forefram"], "frames_noted": ["frames_NOTized", "frames_NOTed", "frames_noteds", "frames__NOTeds", "frames__notized", "frames_notized", "frames_naated", "frames_parted", "frames__notmed", "frames_NOTned", "frames_NOTmed", "frames_annized", "frames_partated", "frames_notuned", "frames__noteds", "frames__NOTed", "frames_partned", "frames_nauned", "frames_annmed", "frames_NOTated", "frames__NOTmed", "frames_naed", "frames_notmed", "frames__noted", "frames_notated", "frames_NOTeds", "frames_notned", "frames_partuned", "frames_naned", "frames_NOTuned", "frames__NOTized", "frames_anneds", "frames_anned"]}}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,\n\n                            uint32_t value)\n\n{\n\n    int i;\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_readl(opaque, addr);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x \\n\", timer_id);\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n                timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n                if (new_val & HPET_TN_32BIT) {\n\n                    timer->cmp = (uint32_t)timer->cmp;\n\n                    timer->period = (uint32_t)timer->period;\n\n                }\n\n                if (new_val & HPET_TIMER_TYPE_LEVEL) {\n\n                    printf(\"qemu: level-triggered hpet not supported\\n\");\n\n                    exit (-1);\n\n                }\n\n\n\n                break;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n                break;\n\n            case HPET_TN_CMP: // comparator register\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP \\n\");\n\n                if (timer->config & HPET_TN_32BIT)\n\n                    new_val = (uint32_t)new_val;\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffff00000000ULL)\n\n                                  | new_val;\n\n                if (timer_is_periodic(timer)) {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffff00000000ULL)\n\n                                     | new_val;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_CMP + 4: // comparator register high order\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffffULL)\n\n                                  | new_val << 32;\n\n                else {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config\n\n                                & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffffULL)\n\n                                     | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_ROUTE + 4:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_ROUTE + 4\\n\");\n\n                break;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n                break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return;\n\n            case HPET_CFG:\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n                s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n                if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Enable main counter and interrupt generation. */\n\n                    s->hpet_offset = ticks_to_ns(s->hpet_counter)\n\n                                     - qemu_get_clock(vm_clock);\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        if ((&s->timer[i])->cmp != ~0ULL)\n\n                            hpet_set_timer(&s->timer[i]);\n\n                }\n\n                else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Halt main counter and disable interrupt generation. */\n\n                    s->hpet_counter = hpet_get_ticks();\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        hpet_del_timer(&s->timer[i]);\n\n                }\n\n                /* i8254 and RTC are disabled when HPET is in legacy mode */\n\n                if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_disable();\n\n                } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_enable();\n\n                }\n\n                break;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG+4 write \\n\");\n\n                break;\n\n            case HPET_STATUS:\n\n                /* FIXME: need to handle level-triggered interrupts */\n\n                break;\n\n            case HPET_COUNTER:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)\n\n                                  | value;\n\n               DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            case HPET_COUNTER + 4:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)\n\n                                  | (((uint64_t)value) << 32);\n\n               DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            default:\n\n               DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n               break;\n\n        }\n\n    }\n\n}\n", "idx": 18969, "substitutes": {"opaque": ["Opramid", "ophole", "opacs", "opaco", "OPaque", "ospaque", "opaques", "opramid", "operacity", " opaco", "operramid", "ospaques", "OPhole", "ospacity", "OPacity", "Opacs", " opramid", "Opacity", "opacity", "operacs", "opera", " opacity", "OPaco", "opa", " opa", "Opaque", "operaques", "ospa", " opaques", "operaque", "operhole", " ophole", "operaco", " opacs"], "addr": ["fx", "grad", "node", "x", "ix", "window", "point", "xp", "code", "padding", "afi", "rx", "socket", "image", "context", "attr", "rt", "oa", "mode", "dr", "pad", "arm", "coord", "data", "mac", "slot", "sta", "url", "alias", "md", "host", "offset", "src", "ad", "oster", "base", "config", "id", "address", "ord", "ace", "ctx", "pos", "pointer", "arr", "ack", "size", "alt", "asm", "prefix", "conn", "dim", "len", "adr", "hop", "align", "loc", "xxx", "ref", "ld", "nr", "tx", "ptr", "seq", "cmp", "start", "device", "amp"], "value": ["VALUE", "server", "example", "length", "number", "range", "name", "type", "work", "values", "array", "flow", "end", "buffer", "valid", "test", "message", "version", "memory", "address", "max", "padding", "data", "target", "write", "format", "function", "null", "image", "port", "wa", "reference", "Value", "v", "size", "offset"], "i": ["f", "Index", "x", "ix", " ii", "d", "n", "len", "I", "si", "id", "address", "r", "ii", "c", "p", "ind", "z", "ui", "e", "l", " j", "a", "v", "j", "offset"], "s": ["g", "sf", "sys", "session", "ops", "f", "ss", "sq", "scope", "ns", "si", "args", "state", "r", "space", "es", "o", "params", "gs", "conf", "c", "p", "sb", "service", "ssl", "sl", "socket", "fs", "services", "S", "m", "states", "sg", "ses", "e", "spec", "v", "sync", "settings"], "old_val": [" old_eval", "old_value", "new_data", "new_value", "old__value", "new_Val", "old__Val", "old__eval", "old_Val", "old__data", "old_eval", " old_Val", " old_value", "old_vals", "old__val", "old_data", " old_vals"], "new_val": ["old_value", "new_valid", "newxvals", "NEWJVal", "NEWJval", "new__Val", "newxVal", "NEW_value", "newxval", "old_vals", "newJval", "new_eval", "newJvalue", "NEW_VAL", "new_Val", " new_vals", "new67vals", "NEWJVAL", "new__valid", " new_value", " new_serv", "new_value", "new67val", "new67reg", "newxserv", "old_valid", "new_reg", "new_vals", "newJVal", "new__val", "new__eval", "new_VAL", "new_serv", " new_eval", "NEWJvalue", "new67value", "old_reg", " new_Val", "newJVAL", "NEW_Val", "old_Val", "old_eval", "NEW_val", "new__value"], "val": ["local", "timeout", "cal", "aval", "bc", "cache", "pal", "el", "end", "reg", "vals", "valid", "buffer", "test", "exec", "evaluate", "len", "base", "play", "change", "pb", "data", "ctx", "trial", "ee", "call", "loc", "pre", "Val", "slot", "ref", "live", "al", "unit", "func", "role", "eval", "sl", "delay", "slice", "item", "sel", "element", "ret", "seq", "serv", "v", "offset"], "index": ["section", "alpha", "dc", "length", "route", "number", "match", "inc", "Index", "x", "type", "ix", "prefix", "dim", "conn", "old", "error", "point", "connection", "len", "position", "si", "id", "nn", "address", "ace", "ctx", "hop", "align", "loc", "xxx", "ref", "bridge", "height", "pos", "key", "ind", "pointer", "search", "slice", "socket", "weight", "find", "element", "num", "part", "amp", "offset"], "timer": ["editor", "inner", "eri", "walker", "roller", "tim", "Timer", "icker", "tm", "tr", "gem", "trigger", "loader", "mr", "thread", "acer", "outer", "task", "theme", "player", "yer", "server", "gm", "icer", "caster", "later", "timeout", "clock", "temp", "counter", "message", "duration", "tg", "writer", "monitor", "zer", "oker", "amer", "immer", "wrapper", "err", "ter", "eddy", "cookie", "term", "ler", "manager", "white", "buffer", "watch", "tom", "trial", "iter", "er", "sim", "ger", "mom", "builder", "txt", "worker", "cer", "tick", "runner", "imer", "peer", "span", "reader", "uner", "browser", "time", "stim", "service", "maker", "tc", "acker", "driver", "trace", "event"]}}
{"project": "qemu", "commit_id": "2af3da91839c04a5d73643b4eacce4cd93b9d428", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n", "idx": 18988, "substitutes": {"env": ["console", "server", "inet", "eu", "txt", "export", "net", "et", "enable", "conn", "eni", "exec", "np", "obj", "Environment", "site", "args", "enc", "config", "db", "eng", "code", "iv", "equ", "fen", "ef", "ctx", "ec", "engine", "exc", "ext", "ea", "profile", "c", "loader", "cv", "inv", "er", "err", "en", "vt", "context", "ne", "viron", "nw", "ev", "e", "environment", "password", "que", "manager", "v", "settings"], "f": ["fx", "t", "d", "fm", "feed", "n", "fd", "fw", "ff", "h", "r", "fr", "fen", "o", "tf", "w", "cf", "xf", "c", "F", "p", "file", "fp", "rf", "b", "func", "fa", "fs", "fn", "e", "l", "fe", "fc", "v", "af", "fb", "j", "m"], "cpu_fprintf": ["cpu_bprint", "cpu_forprint", "cpu_fwrite", "cpu_bcall", "cpu_cwrite", "cpu_cprintf", "cpu_Fprint", "cpu_fdump", "cpu_rfprintf", "cpu_fordump", "cpu_fcall", "cpu_fprint", "cpu_rfdump", "cpu_rfprint", "cpu_cprint", "cpu_ddump", "cpu_forwrite", "cpu_fprintln", "cpu_Fprintf", "cpu_cprintln", "cpu_bprintf", "cpu_bwrite", "cpu_dwrite", "cpu_dprint", "cpu_forprintf", "cpu_rfwrite", "cpu_Fprintln", "cpu_dprintf", "cpu_rfcall", "cpu_Fwrite", "cpu_ccall"], "flags": ["lag", "ops", "ports", "linux", "vals", "fun", "len", "ints", "args", "bits", "ips", "FLAG", "nl", "Flags", "ffff", "func", "flag", "fs", "Flag", "stats", "ants", "settings", "options", "features", "mask", "offset"], "i": ["phi", "di", "ri", "length", "number", "split", "xi", "name", "x", "u", "qi", "type", "ci", "li", "t", "eni", "bi", "uri", "d", "n", "ip", "I", "si", "pi", "multi", "id", "h", "index", "ai", "code", "data", "iu", "o", "ii", "c", "k", "p", "s", "b", "pointer", "ui", "ni", "zi", "gi", "count", "fi", "e", "l", "start", "a", "io", "oi", "ie", "v", "ti", "j", "m"]}}
{"project": "qemu", "commit_id": "8d0bcba8370a4e8606dee602393a14d0c48e8bfc", "target": 0, "func": "int net_init_socket(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    Error *err = NULL;\n\n    const NetdevSocketOptions *sock;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);\n\n    sock = opts->socket;\n\n\n\n    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 19003, "substitutes": {"opts": [" opps", "obts", "otters", " opks", "ops", "optcs", "OPts", "optps", "opters", "ottt", "octers", " optt", "obcs", "otts", "opcs", "opks", "opds", "optt", "ocks", "ots", "OPds", "opps", "otks", "otcs", "OPcs", "optds", "octs", "OPs", "octt", "optks", " opters", "otds", "obks", "obps", "optts", " opcs"], "name": ["str", "server", "self", "resource", "NAME", "client", "none", "ame", "large", "type", "node", "prefix", "parent", "new", "temp", "style", "conn", "common", "old", "connection", "no", "n", "ip", "version", "base", "id", "word", "on", "path", "hello", "address", "addr", "space", "cap", "call", "time", "nam", "active", "key", "Name", "sea", "up", "mini", "comment", "named", "am", "home", "ni", "names", "url", "like", "filename", "port", "options", "alias", "nm", "username", "size", "part", "host"], "peer": ["server", "client", "pc", "proc", "worker", "http", "node", "type", "instance", "source", "parent", "wheel", "conn", "wire", "scope", "buffer", "connection", "point", "pool", "phase", "root", "message", "slave", "state", "chain", "address", "addr", "fork", "reader", "rb", "part", "channel", "loader", "owner", "pe", "ssl", "er", "socket", "pkg", "wrapper", "package", "context", "vr", "cb", "attr", "seed", "request", "port", "pro", "remote", "master", "ker", "plugin", "layer", "player", "host", "mode"], "errp": ["nerps", "errps", "erp", "nerr", "erps", "nerp", "errr", "rrr", "rrp", "rrps"], "err": ["dr", "str", "rr", "sys", "cer", "Er", "inc", "runner", "kr", "conn", "req", "error", "rh", "fee", "rar", "ir", " er", "lr", "eor", "or", "ise", "dev", "db", "ar", "r", "der", "fr", "doc", "rx", "reader", "ee", "exc", "iter", "dy", "gr", "conf", "rb", "ref", "loc", "mr", "ind", "cr", "resp", "er", "msg", "Error", "rage", "cb", "ev", "attr", "fi", "rn", "acer", "ler", "e", "bug", "fe", "rc", "md", "ln"], "sock": ["alsoke", "servong", "servigh", "sesocks", "bocket", " sigh", "dah", " siv", "say", "youriv", "hsocket", "osoup", "nigh", "absock", "dsock", "high", "unsolve", "octoke", "hocket", "toco", "ansocket", " sig", "inoke", "opensocket", "hocks", "inock", "sesocket", " scho", "insink", "opensock", " sct", "insock", "alsocket", " sck", " solve", "confoc", "ssleth", "sslig", "holl", "alsolve", "unsell", "tock", " slock", " sah", "socket", "sinock", "gsigh", "osock", "fsiv", "conflock", "bock", "nsock", "symock", "absocket", "sesock", "alscall", "gsell", "hsock", "slink", "tocket", " sib", "inoup", "nib", "svock", "svc", "gsong", "hsoll", "passoke", "soy", "soke", "svvc", "alsell", "opensoke", "nsoke", "sod", "sink", "dock", "sck", "sct", "psoy", "slocket", "alsock", "pocks", " soco", "fsoc", "obsock", "pck", "song", "dsct", "absink", "symink", "sig", "confock", "noco", "sloke", "socol", "hsocks", "nsoy", "youroc", " socks", "soco", "sinoc", "gsolve", "unsock", " socket", "yourock", "scho", "sesong", " socol", "ansoy", "sect", "sigh", "fsock", "insocket", "tong", "slock", "octock", "dong", "psocket", "ansock", "symvc", "dect", " soc", " sect", "svink", "sell", "insoy", "ensod", " song", "opensoc", "soup", "symsocket", "hock", "pock", "soll", "boy", "dsigh", "noy", "socks", "ensock", "gscall", "sinocks", "alsoy", "inocket", "hoco", "ansoke", "enssocket", "seth", "siv", "slib", "gsock", "gsoke", "tigh", "symig", "ensvc", "absoke", "nocket", " say", "sib", "solve", "obsoco", "sloy", "sslock", "scall", "passink", "gsoco", "dsoco", "symod", "sinocket", " sink", "sinong", "tah", "sinoke", "servoke", " seth", "octink", " sod", "insoke", "psoke", "symeth", "fsay", " svc", " ssocket", " soke", "inscho", "osocket", "psock", "unscall", "symoke", "passocol", "insoup", "svoke", "servock", "gsink", "nsocket", "obsolve", "dsocks", "passock", "sslink", " soy", "slocol", "osoke", "nock", "sesvc", "pink", "tocks", "sah", "soc", "sesct", "confoke", "gscho", "tect", "boke", "ssocket", "youray", "octocket", "dsvc", "gsocket", "obsoke"], "fd": ["wat", "fx", "cd", "bd", "df", "dc", "f", "timeout", "fee", "fed", "pd", "nc", "pipe", "dd", "buf", "conn", "d", "lf", "wr", "bind", "connection", "fun", "fm", "sd", "wb", "fw", "FD", "db", "ff", "dt", "fin", "dir", "dl", "write", "dy", "fl", "wd", "cf", "fp", " fid", "da", "nd", "func", "fa", "socket", "fs", "poll", "handler", "cb", "fn", "fi", "bf", " f", "pid", "fe", "driver", "dn", "flo", "port", "fc", "md", "ln", "fb"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 19005, "substitutes": {"v": ["g", "val", "self", "client", "f", "uv", "lv", "vim", "this", "x", "u", "t", "api", "vic", "conv", "view", "i", "h", "vp", "iv", "vs", "o", "w", "vis", "c", "k", "p", "var", "vc", "value", "vt", "vm", "ev", "e", "sv", "l", "vv", "V", "tv", "j", "m"], "obj": ["val", "self", "class", "node", "type", "prefix", "parent", "po", "js", "otype", "api", "args", "lib", "ob", "init", "code", "emb", "o", "ctx", "rb", "att", "ref", "det", "object", "adj", "sb", "bot", "tmp", "b", "Object", "objects", "image", "nb", "lock", "cb", "office", "Obj", "j"], "name": ["val", "self", "NAME", "none", "type", "x", "prefix", "parent", "common", "no", "n", "base", "word", "path", "label", "data", "block", "o", "time", "nam", "object", "var", "key", "Name", "null", "comment", "nice", "named", "ni", "names", "attr", "alias", "nm", "part", "info"], "errp": ["errpc", "errps", " errps", "ercp", "asterp", "errP", "irp", "refP", " errc", "irlp", "erP", "refp", "erpc", "errcp", "erlp", "refc", " errlp", "irP", "erp", "refps", "erps", "erc", "erpp", "asterpc", "asterpp", " errpc", "errpp", " errP", " errcp", " errpp", "asterP", "errlp", "errc", "ircp"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)\n\n{\n\n    int d;\n\n    for( d = 0; d < 8; d++ ) {\n\n        const int p0 = pix[-1*xstride];\n\n        const int p1 = pix[-2*xstride];\n\n        const int q0 = pix[0];\n\n        const int q1 = pix[1*xstride];\n\n\n\n        if( FFABS( p0 - q0 ) < alpha &&\n\n            FFABS( p1 - p0 ) < beta &&\n\n            FFABS( q1 - q0 ) < beta ) {\n\n\n\n            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */\n\n            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */\n\n        }\n\n        pix += ystride;\n\n    }\n\n}\n", "idx": 19011, "substitutes": {"av_flatten": ["av_ffatten", "av_ffand", "av_ffatt", "av2ffash", "av_slatt", "av2fland", "av_sland", "av_lfash", "av2ffand", "av2ffatten", "av_lfatt", "av_lfatten", "av_flatt", "av_fland", "av2flash", "av_slash", "av2ffatt", "av_slatten", "av_ffash", "av2flatt", "av_lfand", "av_flash", "av2flatten"], "pix": ["paitch", "pike", " pike", "pani", " pip", "cpix", "Pix", "cpicks", "cpox", "prike", " pixel", "spixels", "PIX", "paican", "spican", "qix", "spiped", "spix", "pixed", "npixels", "pican", "pip", " pox", "Pani", "paixels", "spox", "npitch", "npix", "cpixels", " pican", "Pius", " picks", "pius", "npixed", "piped", "Picks", " piped", " pitch", "paixed", "paix", " pani", "Pip", "pIX", "pixels", "pixel", " pixed", " pius", "spip", "picks", " pixels", "prani", "priped", "qicks", "spixel", "prix", "qIX", "Pixel", "Pixels", "prixels", "spike", "paius", "qixels", "pitch", "prixel", "spius", " pIX", "pox", "Pox"], "xstride": ["xstaided", "xbrider", "xetrides", "ystide", "xstaide", "Xstrride", "xbride", "Xstrided", "Xstride", "XStride", "xStrided", "xstaride", "xSTRide", "xStrride", "xbrice", "xStrider", "ystrride", "xSTRip", "XStrider", "XStrides", "xstide", "Xbrided", "ystider", "xstrider", "xstaice", "xSTRided", "xSTRides", "xstides", "ystided", "xstip", "xstrride", "ystrip", "ystrider", "Xbrice", "xStrides", "xStride", "ystrides", "ystides", "xstrides", "Xstrides", "Xstrice", "ybride", "xbrides", "Xbrride", "xbrride", "xstider", "xstrip", "ybrided", "xstrided", "xstice", "Xstrider", "xstrice", "ystip", "ystrided", "xbrided", "xetride", "xetrider", "xetrided", "xstided", "Xbride", "XStrided", "ybrides", "ybrride"], "ystride": ["yStrides", "ystriide", "ystide", "ystredge", " ystrride", "yvariedge", " yvariide", "yvariide", "ystrride", "yStrided", "xstided", " yvariride", "xstide", "yvariride", "yvariided", "xstides", "ystided", "xstrride", "ystedge", "yStride", "ystrides", "ystides", "xstrides", "ystriride", "ystriides", "ybride", "ybrided", "xstrided", "yStrride", "ybredge", "ystrided", " yvariided", "ystriided", " ystrided", " ystredge", " yvariedge", "ybrride"], "alpha": ["scale", "f", "angle", "inc", "ac", "u", "na", "igma", "ta", "asc", "si", "i", "Beta", "ra", "ar", "r", "qa", "space", "aa", "asa", "Alpha", "p", "da", "lambda", "amin", "acc", "audio", "A", "as", "appa", "area", "a", "pha", "amp", "offset"], "beta": ["phi", "\u03b1", "scale", "xb", "bc", "ac", "abi", "pad", "igma", "bi", "ta", "asc", "phase", "bp", "base", "border", "si", "Beta", "i", "qa", "pa", "eb", "aa", "\u03b2", "ba", "ii", "Alpha", "rb", "c", "p", "b", "lambda", "negative", "mega", "appa", "zero", "a", "margin", "pha", "size", "offset"], "d": ["g", "di", "dh", "dc", "f", "D", "du", "pd", "x", "u", "dd", "t", "dim", "dm", "dos", "n", "fd", "i", "id", "dt", "r", "dom", "dl", "w", "dy", "dx", "c", "p", "s", "ld", "da", "ind", "nd", "b", " dd", "z", "e", "l", "dat", "dn", "ds", "md", "j", "m"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n\n{\n\n    char local[13];\n\n\n\n    memcpy(local, version, 12);\n\n    local[12] = 0;\n\n\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n\n    if (vs->major != 3 ||\n\n        (vs->minor != 3 &&\n\n         vs->minor != 4 &&\n\n         vs->minor != 5 &&\n\n         vs->minor != 7 &&\n\n         vs->minor != 8)) {\n\n        VNC_DEBUG(\"Unsupported client version\\n\");\n\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n\n     * as equivalent to v3.3 by servers\n\n     */\n\n    if (vs->minor == 4 || vs->minor == 5)\n\n        vs->minor = 3;\n\n\n\n    if (vs->minor == 3) {\n\n        if (vs->auth == VNC_AUTH_NONE) {\n\n            VNC_DEBUG(\"Tell client auth none\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_client_init(vs);\n\n       } else if (vs->auth == VNC_AUTH_VNC) {\n\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_auth_vnc(vs);\n\n       } else {\n\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n            vnc_flush(vs);\n\n            vnc_client_error(vs);\n\n       }\n\n    } else {\n\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n\n        vnc_write_u8(vs, 1); /* num auth */\n\n        vnc_write_u8(vs, vs->auth);\n\n        vnc_read_when(vs, protocol_client_auth, 1);\n\n        vnc_flush(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19023, "substitutes": {"vs": ["verts", "ves", "lines", "ms", "client", "bs", "lv", "wp", "net", "js", "plugins", "va", "act", "forces", "posts", "gs", "cf", "ums", "vc", "obs", "fs", "stats", "vr", "utils", "ins", "outs", "VS", "qs", "eps", "server", "http", "ns", "args", "dev", "vers", "versions", "vp", "iss", "es", "views", "params", "sk", "s", "var", "ks", "ts", "pages", "services", "vm", "sv", "env", "events", "its", "ver", "ils", "flags", "ops", "pps", "docs", "rs", "ss", "prev", "ues", "pos", "oss", "xs", "vt", "sts", "ses", "otes", "hs", "ys", "is", "changes", "cs", "css", "vas", "ov", "ps", "ports", "conn", "vals", "alls", "pg", "ls", "Vs", "las", "os", "ds", "plugin", "v", "settings"], "version": ["Version", "section", "val", "server", "scale", "serial", "length", "option", "match", "type", "name", "prefix", "parent", "latest", "release", "connection", "vision", "code", "VERSION", "data", "feature", "target", "format", "final", "channel", "patch", "public", "available", "current", "value", "up", "update", "ver", "package", "url", "remote", "event", "plugin", "v", "secret"], "len": [" max", "val", " lang", " enc", " encoding", " n", "length", "Len", "base", " clen", " lib", " count", " avail", " bits", " cur", "seq", " length", "size"], "local": ["val", "self", "server", "initial", "serial", "client", "copy", "http", "result", "match", "Local", "new", "global", "temp", "parent", "prefix", "cache", "standard", "el", "latest", "old", "same", "valid", "buffer", "parts", "back", "child", "base", "we", "location", "localhost", "small", "partial", "state", "private", "build", "full", "data", "raw", "binary", "lang", "total", "loc", "final", "post", "public", "active", "missing", "current", "up", "update", "home", "joined", "lock", "where", "other", "l", "a", "empty", "remote", "custom", " locals", "shared"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 19027, "substitutes": {"base": ["core", "cp", "server", "scale", "resource", "f", "pc", "type", "x", "ix", "frame", "prefix", "cache", "name", "temp", "net", "pad", "q", "bi", "scope", "buffer", "py", "root", "ip", "si", "site", "kit", "i", "config", "id", "state", "db", "address", "index", "status", "padding", "r", "addr", "space", "ace", "ba", "total", "ii", "pre", "c", "p", "bas", "ada", "ases", "b", "null", "sea", "home", "m", "ased", "area", "gb", "bf", "start", "e", "os", "a", "size", "v", "Base", "ase", "info"], "env": ["eu", "f", "nc", "cache", "net", "enable", "conn", "eni", "oa", "scope", "end", "py", "np", "n", "enc", "config", "db", "state", "path", "status", "r", "h", "init", "es", "ctx", "ec", "w", "exc", "conf", "ea", "zone", "c", "p", "energy", "er", "z", "m", "en", "context", "viron", "ev", "e", "ses", "ey", "network", "environment", "manager", "v", "ex", "sche", "settings"], "s": ["g", "sites", "session", "js", "sh", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "socket", "fs", "z", "states", "sets", "qs", "m", "sf", "http", "u", "ns", "site", "si", "i", "state", "es", "us", "sk", "p", "sb", "ks", "y", "ts", "sis", "services", "l", "sym", "se", "its", "sync", "f", "rs", "south", "q", "sq", "ss", "n", "init", "vs", "o", "series", "S", "en", "sg", "ses", "spec", "secure", "is", "cs", "sys", "ps", "t", "d", "storage", "ls", "w", "service", "e", "sing", "os", "ds", "v", "settings"], "iomemtype": ["igmemsize", "iasmademweight", "iomigcolor", "iomimerstyle", "iomembtype", "iomeltype", "igmemlike", "iomextype", "igmeltypes", "iomemsize", "iasmademstyle", "iomimertype", "iomEMpy", "iomempy", "igmeltype", "pixeligpy", "igmellike", "iomembweight", "iasmemweight", "pixelemcolor", "iomigType", "iomembtypes", "pixeligType", "iomemweight", "iomigtype", "iomEMcolor", "iomigpy", "iomemertypes", "iomemertype", "iomemerlike", "iomellike", "igmelsize", "iomimerlike", "iasmemtypes", "iomemtypes", "iomemlike", "iomademtype", "pixeligtype", "iomexType", "iomEMtype", "iasmemtype", "igmemtypes", "iomelsize", "igmemtype", "iomexcolor", "iomemstyle", "iomademweight", "pixelemtype", "iomimersize", "iomemcolor", "iomademstyle", "iomimerweight", "pixeligcolor", "pixelempy", "iasmemstyle", "iomexpy", "pixelemType", "iomEMType", "iomimertypes", "iomademtypes", "iasmademtypes", "iasmademtype", "iomemersize", "iomembstyle", "iomemType", "iomeltypes"], "qi": ["di", " bi", "cli", "jp", "ci", "li", " ii", "q", "sq", "bi", "eni", "agi", "qua", "wei", "mu", " iii", "pai", "si", "i", "iaz", " q", "ai", "qa", "chi", "cgi", "fen", "iana", "qq", "ace", "iu", "ctx", "qt", "ii", "esi", "cci", "iq", "cf", "quad", "dq", "p", "sci", "shi", "ei", "ahi", "zi", "ni", "gui", "fi", "yi", "query", "qs", " Qi"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static int mp_decode_frame(MPADecodeContext *s, OUT_INT **samples,\n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    int i, nb_frames, ch, ret;\n\n    OUT_INT *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);\n\n\n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        skip_bits(&s->gb, 16);\n\n\n\n    switch(s->layer) {\n\n    case 1:\n\n        s->avctx->frame_size = 384;\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        s->avctx->frame_size = 1152;\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n        s->avctx->frame_size = s->lsf ? 576 : 1152;\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n\n\n        if (nb_frames < 0)\n\n            return nb_frames;\n\n\n\n        s->last_buf_size=0;\n\n        if (s->in_gb.buffer) {\n\n            align_get_bits(&s->gb);\n\n            i = get_bits_left(&s->gb)>>3;\n\n            if (i >= 0 && i <= BACKSTEP_SIZE) {\n\n                memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);\n\n                s->last_buf_size=i;\n\n            } else\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid old backstep %d\\n\", i);\n\n            s->gb           = s->in_gb;\n\n            s->in_gb.buffer = NULL;\n\n        }\n\n\n\n        align_get_bits(&s->gb);\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        i = get_bits_left(&s->gb) >> 3;\n\n\n\n        if (i < 0 || i > BACKSTEP_SIZE || nb_frames < 0) {\n\n            if (i < 0)\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid new backstep %d\\n\", i);\n\n            i = FFMIN(BACKSTEP_SIZE, buf_size - HEADER_SIZE);\n\n        }\n\n        assert(i <= buf_size - HEADER_SIZE && i >= 0);\n\n        memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n\n        s->last_buf_size += i;\n\n    }\n\n\n\n    /* get output buffer */\n\n    if (!samples) {\n\n        av_assert0(s->frame != NULL);\n\n        s->frame->nb_samples = s->avctx->frame_size;\n\n        if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n        samples = (OUT_INT **)s->frame->extended_data;\n\n    }\n\n\n\n    /* apply the synthesis filter */\n\n    for (ch = 0; ch < s->nb_channels; ch++) {\n\n        int sample_stride;\n\n        if (s->avctx->sample_fmt == OUT_FMT_P) {\n\n            samples_ptr   = samples[ch];\n\n            sample_stride = 1;\n\n        } else {\n\n            samples_ptr   = samples[0] + ch;\n\n            sample_stride = s->nb_channels;\n\n        }\n\n        for (i = 0; i < nb_frames; i++) {\n\n            RENAME(ff_mpa_synth_filter)(&s->mpadsp, s->synth_buf[ch],\n\n                                        &(s->synth_buf_offset[ch]),\n\n                                        RENAME(ff_mpa_synth_window),\n\n                                        &s->dither_state, samples_ptr,\n\n                                        sample_stride, s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * sample_stride;\n\n        }\n\n    }\n\n\n\n    return nb_frames * 32 * sizeof(OUT_INT) * s->nb_channels;\n\n}\n", "idx": 19041, "substitutes": {"s": ["g", "self", "ms", "session", "bs", "uns", "js", "support", "h", "r", "gs", "conf", "c", "ssl", "b", "su", "fs", "stats", "as", "sets", "a", "ins", "qs", "m", "server", "sf", "ns", "site", "si", "your", "strings", "es", "us", "p", "sb", "ts", "ks", "services", "sv", "l", "sym", "serv", "se", "sync", "f", "ops", "sports", "rs", "south", "single", "ss", "sq", "n", "vs", "o", "xs", "er", "sim", "S", "bis", "sg", "ses", "hs", "spec", "is", "cs", "css", "sys", "aws", "ps", "t", "six", "d", "ls", "w", "side", "service", "comments", "request", "e", "os", "v", "ds", "an", "settings"], "samples": ["sample", "slamps", "samps", " samps", "slamples", " sample", "slample", "slacks", "sacks", " sacks"], "buf": ["batch", "vec", "length", "src", "uf", "uc", "bc", "queue", "cur", "window", "off", "buffer", "pool", "feed", "len", "fd", "config", "ff", "max", "pb", "data", "block", "rb", "cf", "xff", "c", "sb", "cv", "b", "ptr", "tc", "fb", "cb", "rc", "ab", "seq", "gb", "num", "count", "port", "buff", "alloc", "br"], "buf_size": [" buf_count", "buf1rate", "buf_SIZE", "buf1size", "uber_start", "buf0count", "bufjrate", "buf_\n", "uber_size", "uber_rate", "bufjdesc", "buf0SIZE", "buf_eni", "buf_ize", " buf_\n", "src_ize", "src_SIZE", "buf_rate", "buf1start", "buf_desc", "buf_start", "buf1desc", "uber_desc", "src_eni", "buf_count", "bufjsize", " buf_SIZE", "buf0size", "src_size", "bufjstart"], "i": ["phi", "di", "f", "ri", "length", "xi", "hi", "cli", "type", "x", "qi", "u", "ix", "ci", "li", "in", "t", "eni", "mu", "bi", "uri", "it", "d", "mi", "n", "ip", "I", "pi", "si", "multi", "id", "ai", "index", "chi", "iu", "ii", "c", "p", "pos", "y", "ind", "b", "ki", "z", "slice", "mini", "ui", "ni", "zi", "gi", "count", "fi", "adi", "anti", "e", "yi", "start", "l", "ori", "io", "ie", "ini", "v", "ti", "j", "info"], "nb_frames": ["nb___planes", "nb00cycles", "rb_frames", "NB_images", "nb7cycles", "NB_classes", "nbJframes", "nb___bits", "nb_features", "rbJpages", "nb67frames", "nb_games", "nbNframes", "nb_classes", "cb_bits", "nb_bits", "nb48frames", "NB48classes", "nbNflows", "nbxframes", "NB_frames", "nn_events", "nb67weights", "rbJbits", "nb48classes", "nb___values", "nb00planes", "nbJimages", "nb67images", "nb___frames", "nb00frames", "num_features", "nb___classes", "nb___rows", "nbxbits", "nn_planes", "NB_values", "nb7images", "nbJbits", "rbJfeatures", "nb__features", "nn_rows", "nb_rows", "nb__images", "NB48values", "nb00games", "nb67tracks", "nb48values", "nb_pages", "nbJpages", "nb48images", "nb__flows", "rbJframes", "nb_flows", "num_frames", "nbJclasses", "cb_frames", "nb00frame", "rb_bits", "NB_tracks", "nb_cycles", "num_flows", "nb___pages", "nb_tracks", "nb00images", "nbJfeatures", "nb_events", "nb7frames", "ni_frames", "nb48tracks", "nb_images", "NB_weights", "nbNimages", "nbJvalues", "nbNfeatures", "NB48frames", "nb___events", "num_images", "rb_pages", "ni_planes", "cb_games", "cb_frame", "rb_features", "nb00events", "NB48images", "nb___features", "nb_values", "nb___images", "nb48weights", "ni_images", "nb__frames", "nb00rows", "nbxpages", "nb_weights", "nb7planes", "nb_planes", "nbxfeatures", "nn_frames", "nb_frame", "ni_cycles", "nb00bits"], "ch": ["batch", "f", "ry", "chan", "bc", "cur", "res", "conn", "col", "enc", "ff", "h", "code", "r", "conf", "c", "channel", "done", "err", "rc", "fi", "cb", "seq", "row", "bg", "info"], "ret": ["val", "flags", "result", "bc", "cur", "res", "back", "len", "enc", "aux", "fin", "sil", "nt", "prot", "def", "re", "en", "bis", "rc", "fi", "sec", "seq", "mem", "num", "cb"], "samples_ptr": ["samples_port", "sample_port", "samples_addr", "samples_size", "sample_ptr", "sample_size", "sample_addr"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}", "idx": 19075, "substitutes": {"options": ["eps", "results", "flags", "ops", "option", "http", "op", "xml", "ions", "linux", "optional", "args", "lib", "config", "resources", "ips", "Options", "opens", "o", "params", "mac", "details", "ors", "pos", "ts", "points", "objects", "cho", "settings", "opt", "os", "env", "io", "offs", "info"], "errp": ["errpc", "errps", "errpi", " errps", " errpa", "erf", " err", "asterp", "errP", " errr", " errf", "asterb", "aerpa", "erP", "asterpa", "rrP", "asterpr", "rrpc", "errpr", " erpi", "errb", " errpr", "rrr", " erf", "errf", "erp", " errb", "erps", " erP", "rrpi", "aerb", "aerpr", "rrp", "rrps", "err", " errpi", " errpc", " errP", "aerp", "errr", " erpc", "errpa", " erp"], "inet": ["ether", "interface", "route", "inel", "net", "prefix", "et", "eni", "el", "connection", "ip", "obj", "i", "config", "oid", "dt", "ips", "liv", "address", "pton", "adr", "host", "binary", "ctx", "ec", "target", "qt", "hole", "iot", "loc", "ea", "nt", "unit", "nil", "ssl", "ind", "prot", "socket", "encrypted", "eth", "ni", "ne", "tz", "rn", "ant", "iterator", "oi", "rt", "ets", "elt", "ipt"], "addr": ["dr", "server", "airs", "acl", "route", "src", "number", "ars", "node", "rs", "array", "xml", "dd", "alt", "prefix", "buf", "ad", "oa", "error", "len", "ip", "args", "enc", "config", "pair", "od", "address", "code", "ord", "act", "afi", "adr", "data", "ace", "rx", "offer", "kt", "params", "mac", "addons", "ext", "wd", "ea", "loc", "xxx", "p", "amp", "pkg", "adder", "actor", "eth", "rc", "attr", "url", "opt", "acks", "env", "ast", "arr", "amd", "ack", "size", "order", "rt", "part", "layer", "setup", "host"], "crumpled_addr": ["crumpered_pointer", "crumpered_layer", "crumpered__addr", "crumpled67addr", "crumpled__dr", "crumpered__host", "crumpled___address", "crumpered_message", "crumpered_addr", "crumpled__addr", "crumpled___dr", "crumpled__host", "crumpled_pointer", "crumpered_dr", "crumpled_layer", "crumpped_host", "crumpped_address", "crumpled__address", "crumpled__layer", "crumpled67message", "crumpered_address", "crumpled67address", "crumpled_dr", "crumpled_address", "crumpled___pointer", "crumpered__address", "crumpled_host", "crumpered__dr", "crumpered_host", "crumpled_message", "crumpped_addr", "crumpled67host", "crumpled___addr"], "iv": ["ith", "uv", "ov", "erv", "riv", "Iv", "ci", "ive", "eni", "it", "exec", "ir", "ip", "ivo", "iov", "hw", "i", "enc", "av", "vi", "oid", "liv", "irc", "ib", "il", "adr", "ik", "ipl", "ig", "act", "ec", "ii", "iter", "loc", "iq", "oc", "ou", "iva", "vc", "ind", "ih", "iw", "IV", "iver", "actor", "rc", "iri", "ev", "voc", "opp", "anc", "io", "oi", "v"], "local_error": ["localingaddress", "local_address", "local_grade", "localacerror", "local_ror", "localacgrade", " local_err", "standard_danger", "localabletype", "localamerr", "standard_ror", "local_bug", "localableerr", "standardamdanger", " local_bug", "localingror", " local_type", "standard_error", "local_danger", "localamerror", " local_ror", "localamror", "localinggrade", "standardamror", "local_err", "localamdanger", "standard_err", " local_address", "localacror", "localablekey", "local_key", "localableerror", " local_key", "standardamerror", "localacaddress", "local_type", "standardamerr", "localingerror", " local_grade"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 19082, "substitutes": {}}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n", "idx": 19090, "substitutes": {"ioc": ["ciocation", "cioc", "iocl", "iniocl", "icOC", "iooc", "icoc", "ioid", "ciocl", "uOC", "abioc", "inioc", "aioci", "sios", "abiog", "xioc", "iniocation", "sioci", "abioci", "ioci", "uocl", "abios", "xiocation", "iocon", "ioocl", "sioc", "uoc", "icoid", "iooid", "aioc", "ciocon", "uoid", "ioOC", "iOC", "xiocon", "xiocl", "aiog", "iniocon", "iog", "icocl", "aios", "iocation", "siog"], "buffer": ["batch", "server", "header", "length", "queue", "cache", "source", "array", "buf", "window", "Buffer", "pool", "base", "message", "capacity", "address", "input", "FFER", "data", "block", "writer", "reader", "iter", "read", "uffer", "fp", "channel", "b", "ptr", "slice", "transfer", "shape", "reference", "buff", "layer"], "size": ["g", "sn", "scale", "length", "timeout", "large", "export", "name", "gc", "fee", "Size", "len", "si", "SIZE", "small", "ize", "capacity", "storage", "speed", "address", "code", "max", "sum", "time", "c", "s", "content", "weight", "send", "en", "sec", "shape", "empty", "sync", "offset"], "ret": ["RET", "val", "reply", "str", "get", "timeout", "lv", "result", "match", "temp", "alt", "gc", " reply", "res", "success", "exec", "py", "_", "fun", "len", "base", " result", "data", "addr", "ig", "wrap", "iter", "read", "att", "ext", "live", "sb", "std", "rl", "def", "resp", "re", "wait", "value", "rc", "fi", "Ret", "mem", "wa", "arr", "arg", "rt"], "watch": ["g", "can", "ann", "batch", "server", "skip", "scan", "copy", "cat", "lv", "result", "clock", "worker", "work", "x", "temp", "cache", "Watch", "t", "sw", "war", "warn", "sleep", "aw", "tt", "change", "full", "wx", "block", "wrap", "writer", "par", "lc", "w", "call", "app", "live", "patch", "push", "store", "service", "wait", "comment", "guard", "err", "ct", "lock", "rc", "bug", "wa", "serv", "W", "event", "sync"]}}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n", "idx": 19102, "substitutes": {"opaque": ["ocacity", "opsaque", "opsacity", "ospaque", "op666", "opaques", " opaca", "ocaques", "ocaque", "ipaques", "ospaques", "plaque", "ip666", "ospacity", "ocaca", "opacity", "osp666", "pl666", "opsaques", "opaca", " opacity", "opsaca", "ipacity", "placity", " opaques", "plaques", "ipaque"], "ret": ["RET", "val", "reply", "bit", "cat", "result", "x", "alt", "cur", "res", "t", "sr", "back", "reg", "no", "inter", "len", "red", "mt", "fun", "id", "fin", "pat", "rev", "xt", "rets", "ext", "att", "ref", "det", "nt", "gt", "sur", "pret", "re", "desc", " Ret", "ft", "rc", "num", "Ret", "sec", "mem", "arg", "lit", "rot", "rt", "rep"], "ctx": ["gru", "client", "grad", "component", "wp", "jp", "command", "chan", "ci", "scope", "exec", "connection", "fw", "cl", "rx", "qq", "cf", "c", "cfg", "context", "ctrl", "utils", "alloc", "cm", "cli", "nc", "gc", "req", "np", "hw", "lib", "qa", "cas", "fp", "kw", "pkg", "wcs", "cu", "kb", "fc", "sync", "cp", "cmd", "bc", "sq", "crit", "conv", "config", " context", "cgi", "wx", "lc", "cc", "sci", "cus", "git", "cb", "cn", "cca", "css", "sys", "unc", "prefix", "parent", "conn", "six", "obj", "exc", "qt", "loc", "ca", "ce", "cv", "tx", "tc", "cmp", "anc", "general", "xc", "que", "sc", "ctr"], "t2": [" t4", "temp3", "ptwo", "T0", "t0", "dt1", "t02", "f2", "p0", " t3", "f1", "temp1", "ttwo", "dtii", "temp2", "T4", "p1", "T1", "Ttwo", "ta2", "dt4", "tii", "T2", "TTwo", " t1", " t02", "ta0", "p2", "t4", "t3", "ta1", "tatwo", "Tii", "T3", "t1", "dt2", "f4", "tempTwo", " tTwo", "f3", " tii", "dt02", "T02", "tTwo"], "cmp_buf": ["mp_buf", "cmpingalloc", "cmp_uf", "comp_buffer", "cmp2buff", "cp_buf", "cp_buffer", "mp_uf", "comp_alloc", "comp_buf", "cmp_cb", "cmp2buf", "mp_cb", "mp_buffer", "cmpingrc", "cp_cb", "cmp2cb", "cmp_buff", "cmpingbuf", "cmp_alloc", "cmp_rc", "mp_buff", "cp_buff", "cmp2buffer", "cmp_buffer", "comp_rc", "cmpingbuffer"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 19108, "substitutes": {"ctx": ["cca", "cp", "txt", "cm", "client", "src", "cli", "cmd", "bc", "parent", "ci", "conn", "exec", "connection", "obj", "config", "cpp", "qa", "cgi", "cas", "lc", "cci", "loc", "ca", "c", "fp", "cam", "cv", "cpu", "vc", "cc", "tx", "pkg", "tc", "Context", "context", "rc", "cmp", "anc", "cu", "xc", "sc", "gpu", "sync"], "gprn": ["gptb", " gprns", "gPRb", "gprb", " gPrN", "gbrn", " gprN", "gprne", "gprp", " gptb", " gprp", "gPrn", "gPrN", "gptne", "gprns", " gPrns", "gbrne", " gprb", " gprne", "gPrp", "gsprN", "gptn", "gbrb", "gbrp", "gsprns", "gPrns", " gptne", " gPrn", "gsprn", "gprN", " gptn", " gPrp", "gPRn", "gsprp", " gptp", "gptp", "gPRp", "gPRne"], "sprn": [" prname", " sprN", "sprb", " prb", " sprname", "prN", "prb", "sprN", " prN", " sprb", " prn", "prn", "prname", "sprname"]}}
{"project": "qemu", "commit_id": "732b530c1bd064bdcc29975c0b78fc6de8c47e7f", "target": 0, "func": "static void nvdimm_build_common_dsm(Aml *dev)\n\n{\n\n    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;\n\n    uint8_t byte_list[1];\n\n\n\n    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);\n\n    function = aml_arg(2);\n\n    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);\n\n\n\n    /*\n\n     * do not support any method if DSM memory address has not been\n\n     * patched.\n\n     */\n\n    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));\n\n\n\n    /*\n\n     * function 0 is called to inquire what functions are supported by\n\n     * OSPM\n\n     */\n\n    ifctx = aml_if(aml_equal(function, aml_int(0)));\n\n    byte_list[0] = 0 /* No function Supported */;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    /* No function is supported yet. */\n\n    byte_list[0] = 1 /* Not Supported */;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    /*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     */\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    /*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     */\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n", "idx": 19115, "substitutes": {"dev": [" self", "global", "instance", "library", "param", "exec", "lib", "module", "private", "ram", "data", "block", "call", "gram", "app", "var", "loader", "def", "comment", "package", "lambda", "attr", "ev", "model", "env", "amd", "device"], "method": ["self", "class", "session", "api", "um", "view", "position", "record", "java", "cl", "h", "block", "call", "update", "true", "package", "comment", "send", "mode", "m", "use", "Method", "name", "instance", "op", "rh", "message", "user", "full", "man", "cell", "object", "public", "value", "wrapper", "effect", "model", "METHOD", "math", "length", "array", "orig", "module", "sort", "pass", "region", "func", "fn", "history", "python", "feature", "resource", "expression", "option", "result", "operation", "type", "document", "form", "modified", "member", "util", "build", "callback", "each", "slice", "process", "sign", "pull", "text", "event", "plugin"], "ifctx": ["ipcu", "afctx", "IFconfig", "Ifconfig", " ifcontext", "ifcu", " ifconfig", "IFcontext", "ifcontext", "IFcb", "tifctx", "Ifcb", "ipcontext", "Ifctx", "Ifcontext", "ifconfig", "ifcb", "tifqa", "afcb", "tifcontext", "tifcu", "IFctx", "ipctx", "ifqa", " ifcu", " ifqa", "afconfig", " ifcb", "ipqa", "afcontext"], "function": ["section", "self", "resource", "interface", "family", "f", "option", "number", "length", "operation", "Function", "command", "name", "new", "range", "array", "parent", "normal", "library", "document", "connection", "fun", "version", "module", "code", "functional", "program", "call", "loc", "callback", "object", "region", "unit", "func", "service", "action", "value", "process", "lambda", "package", "handler", "fn", "feature"], "dsm_mem": ["dsm_lim", "dsm_hw", "dcm__mem", "dmi_min", "dsm___min", "dvm_ref", "dsm_min", "dvm_num", "dsm_mode", "dsm___mem", "dsm_num", "dvm_mem", "dsm_memory", "dcm_mode", "dcm__mode", "dmi___arm", "dsm_arm", "dcm_ram", "dmi___mem", "dsm_ram", "dcm_mem", "dvm_Mem", "dsm___hw", "dmi_mem", "dmi___hw", "dsm__mode", "dvm_mm", "dvm_lim", "dcm_memory", "dsm_ref", "dvm_ram", "dsm___arm", "dmi_arm", "dmi_hw", "dcm__ram", "dsm_mm", "dsm_Mem", "dsm__mem", "dmi___min", "dsm__memory", "dcm__memory", "dsm__ram"], "unpatched": ["uncathed", "uncatced", " unmatched", " unmatected", "unattured", "unpatected", "Unbathed", "unpache", "unpitected", "unPathed", "synpahed", "unpached", "unapatured", "UnPatcher", "unafetced", "synpatche", "unattched", "unatthed", "Unpathed", "unpatcher", "Unbatched", "unpatured", "unmatected", "unmatched", " unpatured", "unpathed", "unlicche", "synpached", "unfetced", "uncatches", "unafetured", "UnPathed", "unapatced", "unpatced", "Unbatced", "uncatcher", "unapathed", "UnPatches", " unpatced", " unpatected", "unbatced", "unpaches", "synpatched", "unpatche", "unpahed", "Unbatches", "unfethed", "Unpatched", " unmatced", "unfetected", "Unpatced", "unPatched", "uncatched", "unbatched", "unbatured", "Unpatches", "unfetched", "unafetched", "unbathed", "unmatured", "unmatced", "synpathed", "unpitured", "unpatches", "unpitced", "unPatches", "unlicced", "unbatcher", "unPatcher", "Unpatcher", "unapatched", "unbatche", "UnPatched", "unpaced", "unlicched", "unbatches", "synpaced", "unfetured", " unmatured", "unattced", "unpitched", "unafethed", "synpatced", "synpache", "unliched"], "result_size": ["result_weight", "resultPsize", " result_speed", " result_rate", "memory64len", "result64number", "result_loss", "result_capacity", "memory_size", "result_time", "memory_len", "result_sized", "result64capacity", "result64shape", "resultPaddress", "response_sum", "result64loss", "memory64number", "order64size", " result_start", "result_sum", "result_rate", "result_address", " result_Size", "order_shape", "resultlexname", "order_size", "result64size", "response_weight", "order64capacity", "order_loss", "order64loss", "resultlexsize", "resultPstart", "result64rate", "result64data", "result_speed", "response_scale", "result64name", "response_color", "result64speed", "memory_data", "memory64size", "order64shape", "result_color", "result_Size", " result_name", "result_data", "result_start", "result_len", "result_name", "resultlexspeed", "result_shape", "resultPSize", "result_number", "response_time", "result_scale", "order_capacity", "memory_number", " result_address", "resultlexrate", "response_sized", "response_size", "memory64data", "result64len"], "byte_list": ["memberensize", "byte9size", "byteerpair", "byte_set", "byteetlists", "byte9set", "byteerList", "memberentest", "byteenlist", "sliceetpart", "byte2size", "memberenset", "byteentest", "byteenset", "byteetlist", "byte_range", "character_stack", "byte_size", "byte_pair", " byte_map", "byteetname", "byte_map", "byteetList", "member_set", "slice_part", "byteablerange", "byte9list", "byteetpair", "byteablebatch", "byteerlists", "byte_test", "byte_stack", "byteetpart", "byte2test", "byte_List", "byte2list", "character_range", "member_list", "byte2set", " byte_batch", "sliceetlist", "byteablelist", "byte_part", "sliceetname", " byte_lists", "slice_list", "slice_name", "slice_set", "byteerlist", "character_list", "byte_member", "byteensize", " byte_pair", " byte_range", "byteetset", "byte9test", "character_member", "member_test", "byte_name", "member_size", "byteablemap", " byte_List", "byte_batch", "byte_lists", "sliceetset", "memberenlist"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n", "idx": 19116, "substitutes": {"anon_cred": ["anon_kld", "anon_csp", "anon_Crib", "anon_Credits", "anon_crypt", "anon_scrib", "anon_acred", "anon_Csp", "anon_acrib", "anon_krib", "anon_acld", "anon_Crypt", "anon_fcld", "anon_configred", "anon_acret", "anon_configredit", "anon_cret", "anon_fcred", "anon_fcid", "anon_ksp", "anon_ctret", "anon_Cid", "anon_kred", "anon_configrib", "anon_scred", "anon_acsp", "anon_acredits", "anon_acredit", "anon_ctredit", "anon_credit", "anon_cid", "anon_Cred", "anon_fcredits", "anon_ctred", "anon_Cld", "anon_scredits", "anon_acrypt", "anon_cld", "anon_crib", "anon_scrypt", "anon_acid", "anon_credits", "anon_ctrib", "anon_configret"], "ret": ["RET", "val", "f", "result", "match", "alt", "cur", "res", "conn", "success", "end", "reg", "back", "req", "fail", "len", "fun", "mt", "job", "red", "lib", "id", "db", "virt", "code", "rets", "ext", "ref", "det", "nt", "gt", "resp", "re", "flag", "pret", "en", "rc", "num", "Ret", "die", "mem", "sec", "bad", "arg", "lit", "rt", "art", "ver"]}}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 19119, "substitutes": {"bs": ["lbs", "cs", "css", "ms", "sa", "bc", "ac", "BS", "js", "bh", "ss", "abi", "bi", "ns", "bb", "plugins", "base", "banks", "ros", "bits", "ob", "bid", "pb", "vs", "ls", "iss", "es", "us", "bps", "ec", "gs", "sb", "bas", "ts", "b", "obs", "ubs", "fs", "las", "bis", "cb", "fps", "gb", "bos", "ses", "os", "ins", "outs", "lb", "bes", "ds", "ras", "bl", "fb", "sync"], "offset": ["bit", "inet", "initial", "timeout", "length", "clock", "prefix", "off", "table", "base", "position", "len", "location", "optional", "reset", "slave", "address", "index", "padding", "addr", "data", "Offset", "align", "slot", "part", "fp", "pos", "store", "pointer", "url", "seed", " offsets", "start", "utils", "alias", "reference", "alloc", "size"], "nb_clusters": ["nb4splards", "nb_blodes", "nb_glicas", "nb_bluster", "nb_clancers", "nb_clards", "nb_conurs", "nb_CLusters", "nb_plusters", "nb_conards", "nb_slows", "nb_clodes", "nb_blicas", "nb_conroups", "nb_chards", "nb_gluster", "nb_slusters", "nb_ccusters", "nb_nodes", "nb_collusters", "nb_clurs", "nb_sluster", "nb_plodes", "nb_CLores", "nb_clicas", "nb_blances", "nb_nusters", "nb4clards", "nb_ccards", "nb_ccocations", "nb4splocations", "nb_churs", "nb_glances", "nb_collows", "nb_splusters", "nb_clocations", "nb_CLances", "nb4clows", "nb_clores", "nb_CLicas", "nb_slores", "nb_shards", "nb_nancers", "nb_clroups", "nb_shurs", "nb_CLows", "nb_blubes", "nb_shusters", "nb_flusters", "nb_flows", "nb4splusters", "nb_shroups", "nb_clubes", "nb_cluster", "nb_plancers", "nb_collores", "nb_flards", "nb_colluster", "nb_blancers", "nb_clows", "nb_conusters", "nb_ccows", "nb_splards", "nb_chusters", "nb_splocations", "nb4clocations", "nb_glusters", "nb_CLuster", "nb_blusters", "nb_chroups", "nb_flocations", "nb_splows", "nb_nubes", "nb_plubes", "nb_clances", "nb4clusters", "nb4splows"], "s": ["is", "g", "cs", "server", "sys", "session", "sa", "ps", "js", "t", "ss", "ns", "site", "si", "state", "storage", "ls", "o", "us", "gs", "c", "p", "sb", "ts", "service", "sie", "b", "ssl", "sl", "su", "services", "stats", "S", "bis", "states", "ses", "e", "os", "sv", "sym", "a", "spec", "se", "ds", "sync", "settings"], "l2_table": ["l2_count", "l2amtab", "l2__table", "ltwo_tab", "l12_result", "l2tresult", "l2ftable", "l4_comment", "l2fresult", "l2_comment", "l1_body", "l2__tree", "ltwotquery", "l2_chain", "l2ttab", "l12ttable", "l1_table", "l2_tab", "l1_count", "ltwo_result", "l1_chain", "l2_body", "l42_module", "ltwottab", "l12tcache", "l1_index", "l42amtable", "l2_cache", "l2tcache", "ltwotresult", "l4_table", "l2ttable", "l42_table", "l2fquery", "l2_interface", "l4_result", "l2ammodule", "l42_tab", "l12tresult", "l42amtab", "l12_interface", "l2_module", "ltwo_table", "l2__cache", "l2amcache", "l42amcache", "l12tinterface", "l1_module", "l4_list", "ltwottable", "l2_tree", "l2tinterface", "l42ammodule", "ltwo_query", "l12_cache", "l2tquery", "l2_list", "l12_table", "l42_cache", "l1_tree", "l2__body", "l1_cache", "l2_result", "l2ftab", "l2amtable", "l2_query"], "l2_index": ["l2_count", "ltwojoutput", "l2Eindex", "l2joutput", "l2_size", "lto_position", "l1_count", "l2Eshape", "l6_pointer", "l2_shape", "l2_output", "l6_position", "l21_index", "l2jalias", "l2_lock", "ltwo_output", "l21Eindex", "l96__index", "l1_index", "lto_action", "ltwojalias", "l96_index", "ltwo_alias", "l21Edate", "l2__index", "ltwojindex", "l2_style", "l21_lock", "l96__shape", "l21Eshape", "l2Elock", "l2__shape", "l96__style", "l2_alias", "l2_length", "l2__style", "l2Edate", "l2jindex", "l21Elock", "ltwojlock", "l2_action", "l21_shape", "lto_size", "ltwo_index", "l2_position", "l6_index", "l96_style", "l1_size", "l6_size", "l2_date", "l96_shape", "l21_date", "l1_length", "lto_index", "l2jlock", "ltwo_lock", "l2_pointer"], "ret": ["reply", "val", "fun", "pub", "pat", "rl", "b", "flag", "arg", "lit", "rt", "bit", "res", "reg", "fail", "reset", "fit", "full", "rev", "nt", "hash", "def", "err", " Ret", "num", "out", "art", "j", "RET", "f", "cat", "hard", "error", "_", "base", "id", "db", "pass", "iter", "pre", "att", "post", "en", "run", "rc", "Ret", "info", "result", "complete", "alt", "success", "conn", "back", "len", "mt", "fin", "rets", "ext", "ref", "det", "bot", "active", "gt", "ber", "re", "ft", "bf", "bad", "part", "af"], "i": ["is", "val", "di", "uli", "f", "ri", "xi", "qi", "u", "x", "ix", "ci", "li", "abi", "eni", "bi", "it", "uri", "mu", "d", "mi", "n", "len", "base", "I", "si", "ti", "pi", "id", "reset", "ip", "multi", "init", "r", "ai", "index", "iu", "ii", "ref", "c", "p", "y", "b", "ki", "current", "slice", "m", "ui", "en", "ni", "gi", "zi", "fi", "yi", "e", "l", "start", "io", "oi", "ie", "ini", "out", "v", "rep", "j", "info"], "old_offset": ["old_object", "oldappattribute", "old_address", "old__object", "oldaclocation", "oldapppointer", " old_error", "old_index", "old__auto", "old_auto", "old_Offset", "old__location", "cond_attribute", "oldacaddr", "cond_pointer", "low_Offset", "oldacoffset", "old_location", "oldacaddress", "condapppointer", "old_error", " old_auto", "old__attribute", "condappoffset", "condappattribute", "old_pointer", "cond_offset", "low_offset", "old_addr", "oldappobject", "low_addr", "cond_object", "oldappoffset", "condappobject", "oldacauto", "oldacOffset", "low_address", "old_attribute", " old_location", " old_Offset", " old_index", "old__pointer", "old__offset"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    S390pciState *s = opaque;\n\n\n\n    return &s->pbdev[PCI_SLOT(devfn)].as;\n\n}\n", "idx": 19126, "substitutes": {"bus": ["gate", "proc", "bc", "cache", "buf", "abi", "plug", "board", "boot", "plugin", "config", "BUS", "us", "mount", "engine", "bridge", "pos", "cus", "las", "bis", "os", "port", "driver", "Bus", "io", "usb", "serial"], "opaque": ["ophole", "opaco", "ospulence", "ospaque", "iopride", " opulence", "uppaque", "operacity", " opaco", "iopaco", "operulence", "iopc", "ospacity", "opulence", "uppaco", "uppride", "opacity", "uppc", " opacity", "opride", "osphole", "opc", " opride", "operaque", "operhole", "iopaque", " ophole", " opc"], "devfn": ["deffunction", "Devfn", "Devfee", "deffn", "DEVFN", " devFN", "devf", "evf", "DevFN", "devfun", " devf", "DEVfun", "deffee", "DEVfn", "defFN", "devfee", "devFN", "evfn", "Devfun", "evFN", "DEVfee", "deffun", " devfunction", "devfunction", "evfunction", "deff"], "s": ["g", "f", "session", "ops", "http", "secondary", "u", "js", "ss", "sq", "scope", "d", "n", "i", "state", "h", "r", "address", "o", "php", "c", "p", "ssl", "b", "sl", "socket", "services", "S", "m", "states", "e", "sym", "hs", "v", "sync", "settings"]}}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_info_commands(void)\n\n{\n\n    char *resp, *info, *info_buf, *endp;\n\n\n\n    info_buf = info = hmp(\"help info\");\n\n\n\n    while (*info) {\n\n        /* Extract the info command, ignore parameters and description */\n\n        g_assert(strncmp(info, \"info \", 5) == 0);\n\n        endp = strchr(&info[5], ' ');\n\n        g_assert(endp != NULL);\n\n        *endp = '\\0';\n\n        /* Now run the info command */\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", info);\n\n        }\n\n        resp = hmp(info);\n\n        g_free(resp);\n\n        /* And move forward to the next line */\n\n        info = strchr(endp + 1, '\\n');\n\n        if (!info) {\n\n            break;\n\n        }\n\n        info += 1;\n\n    }\n\n\n\n    g_free(info_buf);\n\n}\n", "idx": 19128, "substitutes": {"resp": ["reply", "html", "rec", "json", "rr", "http", "result", "proc", "jp", "ll", "report", "cache", "res", "conn", "api", "error", "req", "rh", "prev", "news", "coord", "obj", "Response", "fr", "rx", "data", "rev", "respond", "ctx", "esp", "ref", "response", "re", "err", "gi", "ret", "seq", "cmp", "request", "Resp", "serv", "remote", "buff", "part", "comp"], "info": ["detail", "rec", "inner", "hi", "extra", "api", "end", "INFO", "fw", "zip", "show", "afi", "conf", "app", "close", "comment", "update", "ok", "open", "check", "http", "name", "work", "op", "source", "fo", "py", "no", "bb", "about", "si", "i", "found", "parse", "index", "qa", "data", "tf", "part", "p", "inf", "Info", "fi", "where", "alias", "bug", "offset", "iso", "json", "f", "aff", "orig", "error", "id", "quick", "init", "diff", "help", "total", "ii", "hand", "ignore", "information", "handler", "is", "txt", "now", "result", "type", "new", "obj", "pi", "php", "loc", "time", "ref", "slice", "count", "start", "buff"], "info_buf": [" info_box", "info_bytes", "info2done", "inf__buf", "inf_buf", " info_buffer", "inf_buffer", "info__buf", "info_uf", "infopybuffer", "info__buffer", "info__done", "inf__done", "info2uf", "infopyuf", " info_bytes", "infopydone", "info2buffer", " info_cb", "inf__uf", "inf__buffer", "infopybuf", "info_done", "inf_done", "inf_uf", "info_cb", "info_box", "info2buf", "info__uf", "info_buffer"], "endp": ["adp", "endpoint", "startpoint", "adP", "endc", "startP", "endedpoint", "idi", "endedP", "startr", "startc", "endP", " endr", "idp", " endi", "endn", "adpoint", " endn", "endingP", "Endi", "endingp", "endedn", "Endps", "idpoint", "startp", "endedc", "endedr", "endps", "endedi", "endedp", "EndP", "endr", "adn", "idP", "adi", " endps", "endi", "endingps", " endc", "starti", " endpoint", "endingi", "Endp", " endP"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "substitutes": {"s": ["g", "is", "cs", "self", "sf", "f", "session", "sys", "src", "this", "new", "u", "x", "js", "in", "t", "ss", "sq", "ions", "scope", "d", "ns", "info", "n", "site", "si", "args", "i", "r", "es", "o", "ctx", "us", "w", "gs", "c", "p", "sb", "ts", "ks", "service", "b", "ssl", "xs", "su", "fs", "services", "S", "context", "sec", "sg", "ses", "e", "os", "a", "spec", "se", "ds", "v", "sync", "m"], "type": ["class", "ty", "f", "style", "name", "parent", "Type", "t", "py", "rel", "enc", "id", "types", "path", "typ", "ype", " t", "p", "pe", "prot", "def", "re", "TYPE", "sub", " typ", "spec"], "ret": ["RET", "reply", "val", "str", "sys", "f", "ry", "result", "proc", "match", "alt", "res", "reg", "sr", "rel", "tr", "inter", "fun", "obj", "args", "ar", "usr", "rev", "target", "rets", "att", "ext", "ref", "al", "store", "def", "flag", "re", "err", "sel", "rc", "fi", "Ret", "sec", "mem", "opt", "arr", "rt"], "arg": ["g", "val", "str", "rec", "grad", "result", "cmd", "rest", "alt", "param", "argument", "orig", "arm", "reg", "tag", "inter", "args", "enc", "ar", "addr", "ig", "target", "mac", "ext", "all", "ref", "ag", "b", "flag", "re", "err", "Arg", "arc", "rc", "Ret", "sec", "arr", "debug"], "old_code_ptr": ["old_code2pointer", "old_code_rep", "old_codeJrep", "old_code_ref", "old_code_pointer", "old_code\u00b7ptr", "old_code\u00b7rep", "old_code_tr", "old_codeJpointer", "old_code2pointers", "old_call_ptr", "old_line_ptr", "old_codeJptr", "old_code\u00b7length", "old_code2addr", "old_line_ref", "old_code\u00b7pointer", "old_call_length", "old_call_rep", "old_line_tr", "old_code_addr", "old_code_pointers", "old_code_length", "old_code2ptr", "old_codeJlength", "old_line_pointer", "old_call_pointer"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 19133, "substitutes": {"s": ["g", "ms", "session", "bs", "sp", "js", "plugins", "support", "h", "r", "gs", "conf", "c", "ssl", "b", "su", "fs", "as", "sets", "ins", "qs", "m", "server", "sf", "u", "ns", "site", "si", "i", "es", "us", "sb", "ts", "ks", "y", "services", "sv", "l", "sym", "se", "its", "sync", "f", "ops", "this", "rs", "ss", "sq", "n", "ips", "native", "vs", "o", "xs", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "aws", "ps", "new", "t", "parts", "d", "ls", "w", "service", "e", "os", "ds"], "p": ["g", "cp", "f", "ap", "pc", "sp", "ps", "tp", "jp", "wp", "proc", "u", "op", "lp", "script", "t", "q", "api", "d", "py", "np", "n", "bp", "ip", "pi", "press", "i", "cop", "pp", "pa", "pb", "h", "vp", "r", "data", "o", "pre", "c", "P", "fp", "post", "y", "pe", "b", "up", "gp", "per", "e", "l", "pro", "mp", "v", "j", "m"], "request": ["header", "resource", "initial", "session", "result", "command", "report", "name", "complete", "frame", "queue", "type", "work", "Request", "access", "condition", "q", "demand", "xml", "req", "back", "buffer", "ip", "message", "config", "pair", "id", "require", "user", "hello", "order", "address", "input", "data", "call", "callback", "requ", "response", "key", "store", "rf", "create", "desc", "pull", "url", "query", "claim", "open", "method", "event", "use"], "value": ["sample", "wave", "set", "val", "VALUE", "server", "resource", "rule", "output", "option", "number", "result", "length", "range", "name", "complete", "values", "media", "off", "flow", "end", "buffer", "fee", "view", "property", "message", "version", "pair", "show", "hello", "change", "money", "data", "ue", "volume", "response", "key", "function", "update", "ve", "element", "dollar", "wa", "Value", "v", "info"], "index": ["val", "min", "length", "match", "inc", "Index", "x", "type", "in", "condition", "include", "end", "success", "valid", "len", "position", "i", "id", "edit", "address", "input", "data", "call", "connect", "pos", "key", "ind", "append", "search", "slice", "update", "action", "weight", "context", "pull", "element", "num", "where", "area", "open", "part", "size", "offset"]}}
{"project": "qemu", "commit_id": "a193b0f0a8d7735f4eb2ff863fd0902a5fa5eec6", "target": 0, "func": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,\n\n                                      int64_t offset, uint64_t bytes,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BlockBackend *blk = job->common.blk;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t start, end; /* bytes */\n\n    int n; /* bytes */\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);\n\n    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);\n\n\n\n    trace_backup_do_cow_enter(job, start, offset, bytes);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start += job->cluster_size) {\n\n        if (test_bit(start / job->cluster_size, job->done_bitmap)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(job->cluster_size, job->common.len - start);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = blk_blockalign(blk, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,\n\n                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = blk_co_pwrite_zeroes(job->target, start,\n\n                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = blk_co_pwritev(job->target, start,\n\n                                 bounce_qiov.size, &bounce_qiov,\n\n                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        set_bit(start / job->cluster_size, job->done_bitmap);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->bytes_read += n;\n\n        job->common.offset += n;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, offset, bytes, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 19160, "substitutes": {"job": ["ja", "batch", "gru", "session", "jp", "match", "command", "node", "machine", "api", "org", "exec", "connection", "pool", "child", "low", "java", "plugin", "jar", "ob", "summary", "block", "line", "obs", "b", "mb", "image", "JO", "sub", "order", "layer", "big", "server", "project", "http", "com", "work", "queue", "name", "jam", "py", "np", "site", "lib", "emb", "full", "slot", "lock", "url", "model", "bug", "manager", "sync", "j", "cp", "f", "route", "cmd", "base", "hub", "config", "module", "db", "address", "rb", "run", "cb", "jobs", "resource", "output", "result", "worker", "jo", "member", "status", "build", "Job", "mor", "service", "function", "process", "ie", "lb", "event", "part"], "offset": ["stop", "set", "server", "started", "initial", "shift", "starting", "length", "timeout", "prefix", "off", "error", "phase", "base", "position", "location", "boot", "len", "id", "reset", "address", "index", "begin", "padding", "order", "init", "addr", "Offset", "align", "next", "loc", "slot", "part", "fp", "pos", "limit", "slice", "done", "url", "seed", "from", "reference", "offs", "origin", "layer", "size"], "bytes": ["flags", "lines", "ops", "limits", "length", "gets", "values", "nos", "parts", "fee", "ns", "reads", "base", "boot", "args", "len", "locks", "bits", "blocks", "ips", "init", "bps", "data", "items", "binary", "byte", "classes", "es", "files", "errors", "total", "s", "limit", "tes", "steps", "units", "sec", "seq", "count", "os", "seconds", "outs", "rows", "size"], "error_is_read": ["error_isocwrite", "error_isocreader", "error_is_closed", "error_isocread", "error_is_reader", "error_is_write", "error_is_readable", "error_is_sync", "error_isocreadable"], "is_write_notifier": ["is_write_nonizer", "is_write_generiser", "is_write_disifier", "is_write_notizer", "is_write_serialifying", "is_write_generformer", "is_write_serializer", "is_write_generification", "is_write_notformer", "is_write_notifying", "is_write_notifer", "is_write_disification", "is_write_notiser", "is_write_disiser", "is_write_notification", "is_write_nonifer", "is_write_nonifying", "is_write_generifier", "is_write_serialifer", "is_write_disformer", "is_write_serialifier", "is_write_nonifier"], "blk": ["ilk", "clck", "brck", "BLK", " blck", "clkt", "brkt", "plke", "BLck", "blke", " blK", "ilK", "ilks", "BLks", "BlK", "blkt", "plk", "plks", "Blck", "brke", "ilke", " blks", "blK", "Blks", "blks", "blck", "Blk", "plck", "clk", "BLk", "clke", "plkt", "brk", "plK", " blkt", "Blke", " blke"], "cow_request": ["cow_response", "cow_method", "cow_req", "cowapprequest", "cow_order", "boot_response", "hw_request", "boot_method", "bootallmethod", "cowappresponse", "bootallrequest", "cowallresponse", "cowappmethod", "hw_order", "cow_begin", "hw_req", "cowallbegin", "cowallmethod", "boot_begin", "cowappbegin", "bootallbegin", "cowallrequest", "bootallresponse", "boot_request"], "iov": ["iago", "gru", "ilo", "iop", "imedia", "drm", "iol", "chrom", "ilib", "\u00ef", "ixon", "micro", " cohort", "minecraft", "yout", "iev", "ominium", "nox", "icho", "obo", "ij", "hw", "irin", "liv", "oyer", "arrison", "uno", "ovi", "ibl", "lov", "gio", "voice", "iii", "dq", "ibr", "iris", "wav", "vg", "vre", "roc", "odi", "oren", "iro", "rolet", "soc", "dyl", "voc", "sbm", "io", "club", "inn", "wikipedia", "rob", "userc", "gener"], "bounce_qiov": ["bounce_qilo", "bounce_dliv", "bounce_qoyer", "bounce_poyer", "bounce_knox", "bounce_kilo", "bounce_qqiov", "bounce_kiov", "bounce_qqilo", "bounce_backliv", "bounce_piop", "bounce_piov", "bounce_sqiov", "bounce_backiov", "bounce_qliv", "bounce_dnox", "bounce_sqiop", "bounce_giov", "bounce_sqliv", "bounce_qiop", "bounce_qqovi", "bounce_diop", "bounce_gilo", "bounce_qqiop", "bounce_qnox", "bounce_qovi", "bounce_backiop", "bounce_backovi", "bounce_diov", "bounce_quiov", "bounce_quliv", "bounce_quiop", "bounce_qqoyer", "bounce_pliv", "bounce_gliv", "bounce_giop", "bounce_kliv", "bounce_pnox", "bounce_kiop", "bounce_sqovi", "bounce_quoyer", "bounce_qqliv"], "bounce_buffer": ["botation_length", "bounced_buf", "bouncelogbuffer", "bounce_buff", "battery_buffer", "bounce_Buffer", "bounce2Buffer", "botation_buffer", "bouncemembuffer", "bounceplength", "bouncegreader", "bounced_Buffer", "bouncememreader", "bouncepbuffer", "bouncelogvalue", "bounce_reader", "bounce2buf", "bounce32buffer", "bouncegbuffer", "bouncepbreak", "bounced_buffer", "bouncelogbuf", "botation_break", "bounce32number", "bounce_size", "bouncememlength", "bounce2buff", "benge_buffer", "bouncegbreak", "battery2value", "bouncepreader", "botation_reader", "benge_size", "bounced_buff", "bounce_value", "bounce32size", "bounce_number", "bouncemembreak", "bounce_break", "botationmemreader", "botationmemlength", "bounce_buf", "bounce_length", "battery_buf", "battery2buffer", "battery_value", "bounce2buffer", "bounce2value", "botationmembuffer", "battery2buf", "bounceglength", "benge_number", "botationmembreak"], "start": ["set", "skip", "scale", "get", "starting", "sp", "x", "speed", "show", "mid", "st", "c", "Start", "send", "open", "use", "check", "work", "name", "source", "enable", "in", "pad", "it", "add", "i", "state", "parse", "index", "sk", "p", "key", "current", "seed", "l", "se", "comp", "art", "length", "rest", "style", "ad", "base", "ip", "id", "init", "diff", "help", "next", "pos", "ind", "en", "step", "like", "ish", "info", "stop", "started", "shift", "now", "type", "grade", "cur", "d", "len", "boot", "sum", "read", "try", "count", "from", "ie", "part", "size"], "end": ["stop", "END", "set", "after", "inner", "and", "until", "alt", "eff", "ad", "add", "ort", "ion", "est", "enc", "id", "ff", "max", "index", "begin", "last", "entry", "win", "post", "close", "pos", "limit", "ind", "nd", "ended", "append", "End", "except", "z", "edge", "en", "send", "e", "open", "ending", "event", "size"], "n": ["g", "sn", "f", "number", "nc", "net", "x", "t", "conn", "d", "ns", "len", "i", "nit", "nn", "init", "r", "o", "nl", "N", "c", "k", "nt", "p", "adj", "s", "y", "b", "z", "en", "ni", "nb", "ne", "nor", "num", "un", "e", "rn", "l", "nm", "nu", "size", "nat", "v", "j", "m"]}}
{"project": "qemu", "commit_id": "d157ed5f7235f3d2d5596a514ad7507b18e24b88", "target": 0, "func": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n", "idx": 19184, "substitutes": {"bs": ["cs", "ms", "aws", "ps", "bc", "rs", "BS", "abi", "ss", "bi", "ns", "bb", "cms", "bid", "bits", "pb", "vs", "iss", "ls", "ba", "rb", "sb", "bas", "b", "fs", "as", "ab", "gb", "ses", "os", "outs", "ins", "lb", "ds", "fb"], "rule": ["ru", "section", "val", "resource", "rr", "f", "ri", "route", "result", "token", "match", "fire", "range", "style", "name", "lr", "rules", "tag", "root", "child", "record", "ule", "ride", "Rule", "config", "module", "user", "state", "r", "entry", "o", "block", "sort", "feature", "trial", "call", "rb", "file", "line", "rl", "service", "role", "function", "event", "er", "slice", "update", "ULE", "comment", "item", "gi", "run", "element", "statement", "request", "row", "e", "model", "plugin", "rol", "sche", "use"], "s": ["is", "cs", "sn", "ops", "f", "sa", "ps", "rs", "js", "ss", "sq", "ns", "si", "args", "state", "iss", "ls", "o", "gs", "c", "sb", "p", "ks", "sie", "b", "ssl", "sl", "fs", "services", "S", "states", "sg", "ses", "e", "sv", "os", "ds", "qs", "v"]}}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        /* Set the device in I/O access mode */\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        /* read mode */\n\n        switch (cmd) {\n\n        case 0x00: /* ??? */\n\n            goto reset_flash;\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: /* Block erase */\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; /* Block erase error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0x50: /* Clear status bits */\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: /* Block (un)lock */\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: /* Status Register */\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: /* Read Device ID */\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: /* CFI query */\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: /* Write to buffer */\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0xf0: /* Probe for AMD flash */\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: /* Read array mode */\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: /* Block erase */\n\n        case 0x28:\n\n            if (cmd == 0xd0) { /* confirm */\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { /* read array mode */\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n", "idx": 19198, "substitutes": {"pfl": ["pfc", "lpll", "pFL", "tcl", "tfx", "pflo", "ppfe", "ppsl", "gFL", "ppfw", "lpfl", " psl", " pfly", "gflash", "PFL", "tfly", " pcol", "pbf", "tpFL", "copFL", "ppf", "peFL", "execflash", "Ppl", "Pfl", "execflo", " ppl", "wpf", "Pfe", "copflo", "prefly", "execfl", " pcoll", " pform", "pfi", "pflash", "Pflo", " pfc", "gfl", "tpsl", "tfr", "wpfly", "precol", "percoll", " pfx", "copfly", "pfx", "ppfl", "lpfe", "ppflush", "pf", "tfl", "tFL", " pull", "gflo", "Pbf", "wFL", "pfr", "gsl", "Pfr", "wpl", "pecol", "lpull", "ppl", "pform", "pfe", "pflush", "Pflash", "pcoll", " pzl", "pcl", "lpflo", "pefl", " pfw", " pflo", "preflo", "psl", " pfi", "execFL", "pzl", "prefi", "pfly", "gfe", "gbf", "gfw", "ppflo", "lpfi", "tpbf", "lpfx", "tpfl", "perFL", "tfe", "ppfc", "wpFL", "perf", "peull", "tll", "lpFL", " pcl", "copfr", "copfl", "ppFL", "tpflo", "wfl", "Pform", "Pcoll", "pcol", "wpfl", "lpflush", "Psl", "Pzl", "Pcl", "perfl", "Pfc", "copsl", "gf", "pll", " pflush", "pfw", "lpcol", " pll", " pfe", " pf", "ppform", "ppzl", "Pf", "pull", "Pfly", "presl", "Pflush", "tpfly", " pFL", "wcl", "prefl"], "offset": ["initial", "shift", "layout", "f", "length", "number", "timeout", "enabled", "mode", "range", "operation", "op", "off", "pad", "end", "api", "annot", "info", "phase", "len", "position", "location", "i", "usage", "online", "address", "index", "padding", "data", "addr", "entry", "o", "attribute", "Offset", "align", "loc", "slot", "ref", "part", "fp", "limit", "pos", "pointer", "slice", "ptr", "image", "count", "num", "attr", "area", "start", "port", "adjust", "alias", "l", "origin", "af", "size"], "value": ["wave", "val", "set", "VALUE", "scale", "output", "length", "option", "mode", "command", "range", "type", "complete", "op", "values", "array", "buf", "name", "off", "window", "flow", "end", "buffer", "message", "version", "memory", "usage", "max", "native", "index", "padding", "data", "write", "w", "format", "function", "create", "current", "content", "update", "image", "weight", "start", "port", "text", "Value", "v", "size"], "be": ["bit", "val", "op", "cut", "buf", " buffer", "pad", "buffer", "bits", "code", "cap", "w", "write", "loop", "s", "pos", "b", "le", "count", "port", "buff", " mode", "mode"], "p": ["g", "f", "ap", "pc", "sp", "tp", "jp", "x", "u", "cache", "array", "op", "parent", "t", "q", "d", "point", "np", "n", "bp", "ip", "i", "h", "r", "pb", "data", "o", "w", "pre", "c", "P", "fp", "pe", "b", "pointer", "z", "e", "l", "port", "v", "j", "m"], "cmd": ["grad", "component", "command", "kind", "fun", "cl", "code", "byte", "qq", "call", "cf", "content", "update", "cfg", "Cmd", "send", "opt", "ctrl", "mode", "bit", "cd", "acl", "cli", "generic", "name", "carry", "op", "mod", "buf", "req", "force", "state", "mac", "def", "pkg", "msg", "gn", "url", "cookie", "method", "md", "cp", "cat", "bind", "MD", "config", "id", "module", "init", "wx", "ctx", "target", "help", "reason", "cc", "func", "cb", "custom", "ack", "cod", "bg", "header", "sid", "type", "prefix", "status", "align", "stat", "read", "ref", "seq", "cmp", "mem", "text", "plugin", "ctr"], "wcycle": ["fwcycl", "awyear", " wcycl", "xuse", "awcycle", " wcle", "ewstage", " wsec", " wuse", " wsync", "wyear", "awsec", "swcle", "xcycl", "xcycle", "wcycl", "xcle", " wstage", "wsync", "rwstage", "fwsec", "fwcycle", " wyear", "wsec", "swcycl", "swcycle", "wstage", "wcle", "swuse", "rwcycle", "ewcycle", "awcycl", "rwsync", "fwyear", "wuse", "ewsync"]}}
{"project": "qemu", "commit_id": "4c055ab54fae39b6329c57bcb5334d59b920463e", "target": 0, "func": "int kvm_init_vcpu(CPUState *cpu)\n\n{\n\n    KVMState *s = kvm_state;\n\n    long mmap_size;\n\n    int ret;\n\n\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\n    if (ret < 0) {\n\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_fd = ret;\n\n    cpu->kvm_state = s;\n\n    cpu->kvm_vcpu_dirty = true;\n\n\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (mmap_size < 0) {\n\n        ret = mmap_size;\n\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\n                        cpu->kvm_fd, 0);\n\n    if (cpu->kvm_run == MAP_FAILED) {\n\n        ret = -errno;\n\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n\n        s->coalesced_mmio_ring =\n\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n\n    }\n\n\n\n    ret = kvm_arch_init_vcpu(cpu);\n\nerr:\n\n    return ret;\n\n}\n", "idx": 19204, "substitutes": {"cpu": ["core", "cp", "cs", "css", "eu", "consumer", "sys", "f", "pc", "proc", "clock", "CPU", "cli", "uc", "node", "nc", "cache", "u", "instance", "net", "gc", "bc", "linux", "conn", "np", "boot", "hw", "config", "fc", "cpp", "pu", "lu", "platform", "computer", "us", "ctx", "uci", "lc", "uno", "mac", "hu", "cf", "processor", "c", "p", "loader", "null", "bench", "su", "cow", "vm", "phy", "fi", "mc", "gb", "cmp", "os", "px", "cu", "lb", "gpu", "comp", " CPU", "cn"], "s": ["g", "gpu", "is", "cs", "css", "server", "ssh", "sf", "f", "session", "sys", "http", "proc", "sa", "ps", "ops", "u", "ds", "rs", "js", "t", "ss", "sq", "d", "ns", "n", "site", "si", "i", "cons", "state", "r", "es", "spot", "o", "us", "w", "params", "stat", "gs", "conf", "c", "p", "sb", "ts", "sie", "service", "ssl", "b", "sl", "socket", "fs", "su", "services", "stats", "S", "states", "sg", "ses", "settings", "e", "l", "sym", "share", "os", "spec", "v", "sync", "m"], "mmap_size": ["mmapping_length", "mmap_number", "mmap_scale", "mmape_length", "mmcap_sec", "mmape_Size", "mmape_number", "mmap_sec", "mmap_small", "mmape_len", "mmape_num", "mmcap_clean", "mmap_clean", "mmape_size", "mmcap_size", "mmapping_count", "mmape_scale", "mmap_Size", "mmcap_small", "mmap_num", "mmapping_size", "mmapping_number", "mmap_length", "mmap_count", "mmap_len"], "ret": ["reply", "val", "get", "match", "net", "sr", "valid", "fun", "pet", "code", "pat", "used", "al", "flag", "resp", "sec", "arg", "lit", "rt", "ann", "bit", "let", "res", "reg", "req", "py", "job", "fit", "rev", "nt", "std", "def", "err", " Ret", "num", "fi", "out", "art", "j", "RET", "cat", "hard", "base", "sat", "att", "fat", "en", "run", "rc", "Ret", "result", "alt", "feat", "success", "conn", "repl", "len", "obj", "boot", "mt", "ut", " RET", "fin", "rets", "ext", "ref", "det", "final", "bot", "gt", "rf", "re", "ft", "bf", "mem", "af"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}", "idx": 19216, "substitutes": {"cs": ["core", "css", "cp", "ics", "cm", "CS", "sys", "bs", "pc", "ps", "ck", "cal", "cer", "nc", "ix", "ds", "rs", "ci", "bc", "js", "conn", "alls", "ns", "cms", "args", "cons", "ced", "codes", "vs", "ls", "cas", "cks", "ctx", "ec", "lc", "qs", "ca", "cf", "sk", "c", "ce", "acs", "s", "cc", "ks", "vc", "ts", "cus", "fs", "ces", "wcs", "cmp", "utils", "ins", "sc", "cases", "spec", "Cs", "ras", "sync", "cn"], "cpu": ["gpu", "core", "console", "cp", "css", "chip", "cm", "component", "pc", "cal", "proc", "CPU", "cli", "clock", "jp", "bc", "nc", "cache", "instance", "runner", "uc", "linux", "conn", "eni", "np", "boot", "hw", "config", "cpp", "pu", "platform", "ctx", "uci", "ec", "lc", "mac", "cf", "processor", "c", "loader", "roc", "bench", "cus", "auc", "process", "orc", "cow", "vm", "kernel", "mc", "cmp", "os", "anc", "cu", "nic", "fc", "cn"], "env": ["core", "inet", "eu", "extra", "cache", "net", "et", "eni", "scope", "exe", "code", "engine", "conf", "cf", "loader", "cfg", "eve", "context", "opt", "oa", "cdn", "icer", "cli", "export", "nc", "np", "Environment", "site", "args", "hw", "agent", "iss", "ea", "err", "vm", "ne", "environment", "eye", "console", "kn", "cal", "style", "bc", "stack", "config", "module", "db", "eng", "vs", "ace", "ctx", " environment", "energy", "impl", "enh", "en", "ass", "viron", "ev", "sys", "skin", "conn", "el", "enc", "osc", "ec", "exc", "ext", "ce", "cv", "esm", "edge", "csv", "nw", "e", "anc", "que", "ds", "v", "settings"], "depend": ["dependent", " depended", "reflect", " dependence", " react", " Depend", " dependency", "ependence", " dependent", "data", "draw", "respond", "react", "depending", "sil", "ind", "Depending", "ependent", " dep", "desc", "cript", "dep", " independ", "cend", " insist", "epend", "Dep"], "the": ["my", "and", "f", "length", " The", "this", "team", "match", "type", "new", "\u00eb", "in", "t", "wh", "page", "what", "same", "it", "d", "test", "broad", "no", "n", "to", "_", "natural", "or", "member", "them", "th", "one", "by", "last", "your", "you", "their", "total", "display", "all", "ethe", "public", "he", "pe", "function", "that", "THE", "current", "het", "true", "since", "eth", "as", "end", "non", "ev", "then", "athe", "The", "an", "with", "ure"], "of": ["Of", "sf", "oft", "component", "OF", "number", "less", "name", "new", "type", "source", "during", "in", "outside", "n", "own", "or", "on", "one", "by", "channel", "that", "at", "without", "e", "from", "with"], "caused": ["tauses", "accated", "accused", "Causes", "taated", "Caated", "caated", "accued", "Caused", "caued", "Caued", "causes", "accuses", "taued", "taused"], "exception": ["exexc", "ceptionchange", "Exparent", "EXparent", "EXception", "externalevent", "extceptions", "extvention", "excception", "lexception", "execceptions", "EXposition", "pexception", "externalception", "excposure", "extception", "exerror", "EXposure", "externalchange", " exformer", " exacket", "Exposition", "expresserror", "exceptions", "exvention", "EXvention", "pexexc", "extposition", "pexevent", "EXacket", "lexexc", "Exceptions", "exacket", "exposure", "execformer", "extparent", "excevent", "exformer", "exparent", "excvention", "exchange", "ceptionevent", "Exception", "execacket", "expressception", "excexc", "lexevent", "EXformer", "excposition", "EXceptions", "extposure", "exposition", " exceptions", "exevent", "externalerror", "ceptionerror", "ceptionception", "expressevent", "execception", "expresschange"], "not": ["is", "set", "match", "et", "t", "it", "no", "n", "or", "about", "Not", "found", "by", "all", "ot", "nt", "NOT", "note", "at", "nor", "ne", "non", "un", "bad", "but"], "target": ["supported", "match", "export", "rest", "average", "new", "source", "parent", "test", "real", "root", "site", "config", "platform", "external", "effective", "top", "next", "unit", "current", "lead", "master", "arget", "nat", "host", "tail"], "level": ["class", "scale", "sequence", "rule", "length", "number", "type", "name", "style", "scope", "error", "point", "stack", "location", "id", "path", "status", "index", "line", "depth", "limit", "stage", "value", "levels", "lvl", "layer", "Level"], "so": ["can", "and", "now", "who", "So", " So", "say", "also", "new", "no", "ans", " which", "co", "because", "you", "see", "xxx", "how", "s", " thus", "since", "e", "thus", "then", "plus"], "be": ["is", "ape", "BE", "ome", "te", "make", "to", "play", "stay", "co", "Be", "ae", "st", "help", "call", "see", "always", "se", "le", "en", "fe", "ste", "bes", "bl", "use"]}}
{"project": "qemu", "commit_id": "e3f30488e5f802547b3a60e40cebaef3b4ec16a3", "target": 1, "func": "static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))\n\n        return;\n\n\n\n    if (n->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(n->tx_vq, 0);\n\n        return;\n\n    }\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        ssize_t ret, len = 0;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        unsigned hdr_len;\n\n\n\n        /* hdr_len refers to the header received from the guest */\n\n        hdr_len = n->mergeable_rx_bufs ?\n\n            sizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\n            sizeof(struct virtio_net_hdr);\n\n\n\n        if (out_num < 1 || out_sg->iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* ignore the header if GSO is not supported */\n\n        if (!n->has_vnet_hdr) {\n\n            out_num--;\n\n            out_sg++;\n\n            len += hdr_len;\n\n        } else if (n->mergeable_rx_bufs) {\n\n            /* tapfd expects a struct virtio_net_hdr */\n\n            hdr_len -= sizeof(struct virtio_net_hdr);\n\n            out_sg->iov_len -= hdr_len;\n\n            len += hdr_len;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,\n\n                                      virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(n->tx_vq, 0);\n\n            n->async_tx.elem = elem;\n\n            n->async_tx.len  = len;\n\n            return;\n\n        }\n\n\n\n        len += ret;\n\n\n\n        virtqueue_push(vq, &elem, len);\n\n        virtio_notify(&n->vdev, vq);\n\n    }\n\n}\n", "idx": 19223, "substitutes": {"n": ["g", "sn", "not", "cdn", "inner", "none", "f", "node", "nc", "net", "u", "na", "in", "t", "conn", "bn", "d", "ns", "np", "yn", "syn", "tun", "enc", "i", "nn", "on", "init", "o", "w", "N", "an", "c", "nt", "pn", "p", "s", "adj", "y", "b", "z", "mn", "m", "gn", "en", "nor", "nb", "ne", "ng", "fn", "num", "un", "e", "network", "rn", "l", "non", "nov", "dn", "nm", "nu", "nat", "v", "ln", "j", "cn"], "vq": ["vqs", "evqs", " vque", " vQ", " viq", "vqu", "vQ", "nqu", "evQ", "fQ", "eviq", "nq", "qqs", "evq", "quque", "vqa", "fqs", " vue", "nqs", "nque", "qq", "vue", "vque", "cqa", " vqu", " vqa", "fq", "qiq", "nQ", "cq", "quq", "qque", "cue", "cque", "viq", "niq", "quQ", "nue", "nqa", "ququ", " vqs", "fiq"], "elem": ["gelement", "bele", "felements", " elez", "oelete", "ielements", "belem", "bely", "gele", "gelem", " ehem", "felegate", " ely", "felem", "inelem", " element", "eele", "elegate", "oelem", "pelem", "belement", "ielez", "telev", "elems", "eelev", "oeject", " elee", "gelems", "oelement", "belements", " elev", " elete", "nelement", " ele", "elez", "peld", "inele", "inelems", "eelement", "nelem", "elev", "ehem", "elements", "ielem", "ield", "nelev", "elee", "element", "eelez", "eely", "pehem", "eelem", "eelements", "ely", "eject", "telem", "eld", "Elements", "eeld", "Elem", "ielement", "belev", "belee", "ele", "ielete", " eject", "elete", "felement", "pelev", "telement", "eelee", "Elegate", "eeject", "inelement", "tehem", "pelement", "eelete", "eelegate", "nelements", "eelems", "Element", "pelements"], "ret": ["RET", "val", "str", "bit", "reply", "let", "get", "cat", "match", "lt", "alt", "del", "res", "success", "el", "reg", "back", "no", "red", "len", "fun", "mt", "obj", "fin", "db", "data", "rev", "ig", "rets", "total", "all", "att", "rb", "ref", "final", "nt", "urn", "ext", "hash", "def", "resp", "re", "flag", "err", "fat", "en", "lock", "count", "num", "Ret", "seq", "mem", "rc", "url", "ok", "empty", "arg", "lit", "rt", "out", "bin"], "out_num": ["outXsu", "outXnumber", "outxsu", "int_number", "out_su", "in_name", "outFsize", "outlexnu", "out_size", "out_nom", "outlexnom", "in_info", "outxnom", "in_num", "in_sg", "outlexsu", "out_name", "outXsg", "out_number", "out_nu", "outxnum", "in_len", "in_su", " out_nom", "outFno", "int_size", "outlexnum", " out_number", "out_len", "out_info", "in_number", "outFnumber", "out_no", "outXnum", "int_num", "outFnum", " out_nu", " out_su", "int_no", "outxnu"], "out_sg": ["outlexmsg", "in_msg", "in_session", "out_su", "out_rg", "outLogsg", "out_alloc", "out_tg", " out_desc", " out_nb", "in_num", "in_sg", "outlexsu", "outPsu", "out_nb", " out_general", "outlexrg", " out_tg", "outlexsg", "in_si", " out_node", "outPnode", "out_desc", "outPsg", "out_msg", "out_general", "outLogalloc", "outDgeneral", "outlexsession", "outLognum", " out_rg", "outlexnum", "outLoggeneral", "out_session", "outlexdesc", "outDalloc", " out_alloc", "outDsg", " out_su", "in_desc", "out_si", "out_node", "outDnum", "outPnb"], "hdr_len": ["hdr64val", "hdr_Len", "hrt_lon", "hrt_len", "hdr_num", "hdr64line", "hdr_en", "hgr_len", "hrid_lib", "hdr5num", "hhr_len", "hdr_lin", "hrid_ler", "hadr_ln", "hrid_lon", "hdr_length", "hdr64lin", "hdr5len", "hdr_ln", "hrt_lin", "hgr_num", "hdr64len", "hdr_lon", "hdr_line", "hdr_val", "hrt_en", "hdr54Len", "hdr54lin", "hrt_lim", "hdr5lon", "hdr_ler", "hdr7lib", "hgr_l", "hrt_line", "hdr54count", "hadr_len", "hdr64lim", "hdr_count", "hdr7ler", "hadr_val", "hadr_length", "hdr_lib", "hgr_ler", "hdr_l", "hdr64length", "hhr_lon", "hrt_val", "hdr_lim", "hdr5lin", "hdr64ln", "hrid_len", "hdr54len", "hdr7len", "hhr_num", "hdr7lon", "hhr_lin"]}}
{"project": "qemu", "commit_id": "a1c5975270f2335e1d7129c084a6e562d7b99bdd", "target": 1, "func": "static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n", "idx": 19237, "substitutes": {"port": ["server", "interface", "rule", "project", "component", "pt", "match", "PORT", "export", "ports", "type", "report", "pipe", "parent", "source", "contract", "proxy", "Port", "end", "scope", "point", "ort", "feed", "child", "ip", "table", "tag", "bind", "slave", "state", "address", "select", "data", "target", "import", "bridge", "object", "p", "patch", "public", "post", "service", "period", "null", "pointer", "transfer", "prop", "pod", "pid", "plugin", "host"], "discard": ["confcard", "discarding", "disccard", "Discarding", "recarded", "aincard", "reccard", "recress", "Discard", " discarding", "ainard", " Discard", "discards", "discarded", " discarded", "ainarded", "ainarding", " discards", "recards", " Discarded", "Discarded", "recarding", "confress", "recard", " Discress", " Disccard", "discress", "Discards", "confard", " disccard", "confarded"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static int hdev_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n\n\n\n\n\n\n    const char *filename = qdict_get_str(options, \"filename\");\n\n    char bsd_path[MAXPATHLEN] = \"\";\n\n    bool error_occurred = false;\n\n\n\n    /* If using a real cdrom */\n\n    if (strcmp(filename, \"/dev/cdrom\") == 0) {\n\n        char *mediaType = NULL;\n\n        kern_return_t ret_val;\n\n        io_iterator_t mediaIterator = 0;\n\n\n\n        mediaType = FindEjectableOpticalMedia(&mediaIterator);\n\n        if (mediaType == NULL) {\n\n            error_setg(errp, \"Please make sure your CD/DVD is in the optical\"\n\n                       \" drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        ret_val = GetBSDPath(mediaIterator, bsd_path, sizeof(bsd_path), flags);\n\n        if (ret_val != KERN_SUCCESS) {\n\n            error_setg(errp, \"Could not get BSD path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If a real optical drive was not found */\n\n        if (bsd_path[0] == '\\0') {\n\n            error_setg(errp, \"Failed to obtain bsd path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If using a cdrom disc and finding a partition on the disc failed */\n\n        if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 &&\n\n            setup_cdrom(bsd_path, errp) == false) {\n\n            print_unmounting_directions(bsd_path);\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        qdict_put(options, \"filename\", qstring_from_str(bsd_path));\n\n\n\nhdev_open_Mac_error:\n\n        g_free(mediaType);\n\n        if (mediaIterator) {\n\n            IOObjectRelease(mediaIterator);\n\n        }\n\n        if (error_occurred) {\n\n            return -ENOENT;\n\n        }\n\n    }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n        if (*bsd_path) {\n\n            filename = bsd_path;\n\n        }\n\n        /* if a physical device experienced an error while being opened */\n\n        if (strncmp(filename, \"/dev/\", 5) == 0) {\n\n            print_unmounting_directions(filename);\n\n        }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 19238, "substitutes": {"bs": ["lbs", "cs", "ps", "bc", "rs", "BS", "js", "bh", "ss", "bi", "ns", "bb", "bp", "base", "banks", "bid", "pb", "vs", "ls", "iss", "bps", "als", "es", "sb", "ks", "ts", "b", "obs", "fs", "bis", "gb", "bos", "ses", "os", "outs", "Bs", "lb", "bes", "ds", "bl", "fb"], "options": ["results", "eps", "lines", "styles", "json", "ops", "acl", "option", "http", "ports", "style", "values", "array", "ions", "linux", "scope", "vals", "plugins", "args", "enc", "config", "resources", "includes", "ips", "bits", "Options", "opens", "o", "es", "als", "errors", "params", "details", "ors", "ts", "properties", "points", "stats", "states", "fps", "settings", "bos", "opt", "os", "outs", "times", "rates", "info"], "flags": ["ils", "frames", "lag", "lines", "groups", "ops", "orts", "ports", "fts", "vals", "parts", "rules", "faces", "lf", "plugins", "reads", "ints", "args", "locks", "types", "tails", "bits", "ips", "status", "tools", "codes", "versions", "FLAG", "items", "errors", "files", "fl", "Flags", "format", "details", "flag", "properties", "fs", " Flags", "stats", "bytes", "states", "fps", "fields", "utils", "features", "mask", "settings"], "errp": ["errpc", "errps", " errps", "armpc", "errP", "rrfp", " errr", "armp", "armpe", "Err", " errf", "rrpre", "rrf", "Erps", "errpe", "erP", "ErP", "rrP", "aerpc", "aerP", "rrpc", "aerpe", "derpa", "errpre", " erf", "errf", "frP", "derP", "erp", "arrpa", "erps", " erpre", " erP", "derp", "arrp", "Erpc", "derpc", "rrp", "frpa", "arrP", "Erp", " errfp", "err", " errpc", "errfp", " errP", "derpe", "armP", "aerp", "arrpe", " errpre", "errr", "frp", "Erfp", "errpa", " erp", "frpe"], "s": ["is", "cs", "sn", "sys", "session", "sa", "ops", "ps", "secondary", "f", "rs", "ss", "sq", "ns", "si", "ls", "o", "es", "gs", "c", "p", "sb", "ts", "service", "sie", "ssl", "b", "sl", "fs", "services", "stats", "S", "states", "sets", "ses", "sg", "sv", "os", "e", "a", "spec", "qs", "its"], "local_err": ["remote_err", "Local_err", "local_rr", "local_status", "local_er", "remote_status", "local_order", "Local_rr", "remote_order", "remote_er", "Local_er"], "ret": ["RET", "val", "str", "bit", "result", "match", "alt", "res", "success", "reg", "len", "fun", " RET", " result", "status", "data", "rets", "rb", "att", "ref", "det", "nt", "al", "final", "rl", "Return", "resp", "re", "flag", " Ret", "rc", "fi", "Ret", "mem", "arr", "lit", "rt", "rep"], "filename": ["kn", "json", "tif", "dll", "length", "acl", "f", "unc", "phrase", "name", "prefix", "source", "document", "buffer", "kl", "fd", "java", "location", "word", "path", "tools", "il", "data", "binary", "Filename", "files", "params", "which", "SourceFile", "file", "fp", "loader", "fil", "bytes", "url", "fn", "username", "jpg", "utf", "settings"], "bsd_path": ["bsd6value", "bsd2pointer", "bsd_prefix", "bsd_loc", "bsl_path", "bssd_pointer", "bsdxpath", "bsdxname", "bsd00pointer", "bsd2stream", "bsl_pointer", "bsd_enc", "bsdd_data", "bsdxfull", "bscd_clean", "bsl_ath", "bsdd_stream", "bsd2data", "bsd_name", "bsl_prefix", "bsd00loc", "bsd24stream", "bsvd_value", "bsd2path", "bssd_name", "bsd24url", "bssd_ath", "bsd_url", "bsds_name", "bsds_path", "bssd_path", "bsd00enc", "bsd_full", "bsd00path", "bsdd_path", "bsd_ath", "bssd_loc", "bsdd_pointer", "bsd24clean", "bsd_stream", "bsds_data", "bsvd_path", "bsd6name", "bscd_stream", "bsd6path", "bsd24path", "bsd_pointer", "bsds_ath", "bsvd_name", "bscd_url", "bssd_full", "bsd_value", "bsdxath", "bssd_enc", "bscd_path", "bsd2name", "bsd_data", "bsd_clean", "bsd2ath"], "mediaType": ["laType", "memoryType", " mediaSource", "mediaClass", " mediaClass", "materialName", "memoryTypes", "audioType", "resourceClass", "memoryClass", "audioName", "resourceType", "mediaStyle", "resourceName", "mediaName", "memoryName", "audioUnit", "videoType", "imageClass", "imageName", "resourceUnit", "materialType", "materialStyle", " mediaName", "laClass", "videoUnit", "imageTypes", "audioClass", "memorySource", "audioSource", "mediatype", "laUnit", "videoName", "audioStyle", "videoClass", " mediatype", " mediaStyle", "mediaSource", "audioTypes", "latype", "imageType", "mediaUnit", "mediaTypes", "materialClass", "audiotype", " mediaUnit", " mediaTypes"], "ret_val": ["respgmsg", "respgval", "ret_Val", "ret2vals", "retgmsg", "ret_obj", " ret_obj", "respgarr", " ret2vals", "ret_msg", "ret64Val", "retayarr", "retaymsg", " ret_vals", "ret2obj", "retaycount", "retayval", "retvalarg", "retvalval", "resp_count", "ret64val", " ret2Val", "ret_count", "retvalvals", " ret_Val", "ret_value", "ret64vals", "retvalvalue", "retgval", "respgcount", " ret2obj", "ret_vals", "resp_val", "ret64obj", " ret_value", " ret2val", "ret2val", "resp_arr", "retgcount", "retgarr", "resp_msg", "ret2Val", " ret_arg", "ret_arr", "ret_arg"]}}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n", "idx": 19243, "substitutes": {"bus": ["class", "serial", "cat", "session", "http", "this", "proc", "bc", "cache", "plug", "connection", "board", "feed", "product", "base", "boot", "hub", "controller", "lib", "config", "module", "dev", "user", "BUS", "build", "data", "block", "us", "mount", "loop", "book", "bridge", "nt", "object", "service", "series", "comment", "las", "lock", "os", "driver", "Bus", "io", "bug", "usb", "plugin", "sync", "use"], "loc": ["local", "lim", "rec", "coll", "src", "route", "global", "parent", "reg", "error", "rel", "valid", "root", "or", "location", "util", "col", "lib", "lat", "state", "co", "LOC", "los", "dir", " location", "data", "ctx", "lc", "lang", "iter", "loop", "c", "lex", "bas", "region", "vol", "tx", "Loc", "desc", "las", "la", "rc", "num", "voc", "where", "l", " Loc", "remote", "lit", "spec", "info"], "dinfo": ["dlinit", "vdinfo", "dlstate", "lapi", "ldid", "dafi", "dlinf", " did", "dldata", "ldafi", "ddata", "dinf", "Dafi", "linf", "dsinfo", " dInfo", "vdapi", "dsInfo", " ddef", "vddef", "dsid", "cdinfo", "ldinfo", "dInfo", "ddef", "vdinf", "vdInfo", "dsstate", "ldInfo", "vdinit", "dldef", "dsdata", "cdstate", "ldinf", " dinit", "cddata", "dapi", "dlinfo", " dinf", "Dinfo", " dafi", "cdinf", "dstate", "dinit", "linfo", "did", " dapi", "dsinf", "lInfo", "Dinf"], "unit": ["scale", "min", "rule", "component", "number", "route", "category", "type", "name", "u", "temp", "parent", "style", "domain", "dim", "condition", "mu", "uri", "force", "connection", "no", "station", " units", "position", "base", "direction", "site", "i", "module", "version", "nit", "uni", "label", "index", "address", "year", "block", "target", "col", "format", "file", "pos", "key", "limit", "Unit", "value", "weight", "ui", "units", "num", "element", "un", "port", "model", "device", "order", "part", "nat", "size"]}}
{"project": "FFmpeg", "commit_id": "fbd97184f8b68b2074b79a1698e4d9404292f7ca", "target": 1, "func": "static int link_filter_inouts(AVFilterContext *filt_ctx,\n\n                              AVFilterInOut **curr_inputs,\n\n                              AVFilterInOut **open_inputs, AVClass *log_ctx)\n\n{\n\n    int pad = filt_ctx->input_count, ret;\n\n\n\n    while (pad--) {\n\n        AVFilterInOut *p = *curr_inputs;\n\n        if (!p) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Not enough inputs specified for the \\\"%s\\\" filter.\\n\",\n\n                   filt_ctx->filter->name);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        *curr_inputs = (*curr_inputs)->next;\n\n\n\n        if (p->filter) {\n\n            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)\n\n                return ret;\n\n            av_free(p->name);\n\n            av_free(p);\n\n        } else {\n\n            p->filter = filt_ctx;\n\n            p->pad_idx = pad;\n\n            insert_inout(open_inputs, p);\n\n        }\n\n    }\n\n\n\n    if (*curr_inputs) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Too many inputs specified for the \\\"%s\\\" filter.\\n\",\n\n               filt_ctx->filter->name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    pad = filt_ctx->output_count;\n\n    while (pad--) {\n\n        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));\n\n\n\n        currlinkn->filter  = filt_ctx;\n\n        currlinkn->pad_idx = pad;\n\n        insert_inout(curr_inputs, currlinkn);\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 19245, "substitutes": {"filt_ctx": ["filtrloc", "facet_ca", "flt_context", "filtingcontext", "filt_lib", "filtflc", "facet_lib", "filt_pkg", "flt_tx", "flt_anc", "flt_cn", "filt_conn", "filt_cu", "filt2ctx", "filt_context", "filterwcs", "filt2loc", "filtertx", "filt_cn", "filt_loc", "filt2context", "flt_ctx", "flt_conn", "flt_pkg", "flt_obj", "filt2obj", "filtloglc", "filtflib", "filtingctx", "flt_loc", "filtlogctx", "filtlogcontext", "filterctx", "filtfcu", "filtrcontext", "filt_obj", "filt_cache", "filtlogcache", "filtingtx", "filt_anc", "filt_ca", "filtrobj", "filtrctx", "filt_wcs", "facet_lc", "facet_context", "filtfctx", "filtfanc", "filtingconn", "facet_ctx", "flt_cu", "flt_wcs", "filtfcontext", "facet_cache", "filt_tx", "filtercontext", "filt_lc"], "curr_inputs": ["curr_contextes", "curr_inces", "curr_contexts", "curr_outputb", "curr_outputes", "curr_columnb", "curr_intes", "curr_pulls", "curr_outputerences", "curr_butd", "curr_outputd", "curr_inputw", "curr_controls", "curr_contextb", "curr_inputments", "curr_refes", "curr_pullments", "curr_inputerences", "curr_controles", "curr_controlws", "curr_outputments", "curr_refs", "curr_pullions", "curr_intws", "curr_intp", "curr_selectb", "curr_butes", "curr_butions", "curr_columnerences", "curr_pulld", "curr_turnb", "curr_inputions", "curr_incb", "curr_refments", "curr_columns", "curr_columnw", "curr_turns", "curr_pulles", "curr_outputs", "curr_turnw", "curr_selectes", "curr_selects", "curr_inputp", "curr_refd", "curr_pullb", "curr_ints", "curr_inputd", "curr_inputes", "curr_outputions", "curr_incs", "curr_outputw", "curr_controlp", "curr_inputws", "curr_inputb", "curr_buts", "curr_outputws", "curr_turnerences", "curr_outputp"], "open_inputs": ["open_inputes", "open_intes", "open_subjectes", "open_inputfs", "open_ints", "open_outputs", "open_pulles", "open_outputings", "open_inputings", "open_outputsets", "open_inputfeatures", "open_columnings", "open_subjectfeatures", "open_intfs", "open_outputfeatures", "open_inputsets", "open_outputes", "open_pulls", "open_subjects", "open_subjectsets", "open_columnfs", "open_columns", "open_pullsets", "open_intings", "open_columnes", "open_pullfeatures", "open_outputfs"], "log_ctx": ["loggci", "Log_ctx", "log_config", "logkcontext", "log_cas", "loggctrl", "jobingcas", "log_ctrl", "logvalctx", "logvalctrl", "lex_xc", "jobingctrl", "logingctx", "loggctx", "log_ci", "log_tx", "Log_config", "logingcas", "logksys", "logkxc", " log_tx", "log_sys", "job_ctrl", "logkctx", "logingctrl", "loggcas", "loggcontext", "job_cas", " log_context", "logensys", "Log_context", "lex_ctx", "job_tx", "lex_sys", "jobingtx", "jobingctx", " log_ci", "logencontext", "logvalcas", "logenxc", "logallctx", "job_ctx", "logenctx", "log_xc", "logallcmp", "logvaltx", "log_context", "logallconfig", "logingtx", "logallcontext", "log_cmp", "loggtx", "Log_cmp", "lex_context"], "ret": ["RET", "val", "reply", "get", "cat", "result", "match", "hard", "alt", "res", "success", "reg", "back", "no", "red", "len", "fun", "obj", "job", "reset", "pet", "r", "entry", "pat", "rets", "pre", "att", "ext", "ref", "det", "nt", "al", "rf", "def", "flag", "re", "resp", "value", "ft", "run", "rc", "Ret", "mem", "arr", "arg", "empty", "rt", "rep"], "pad": ["arp", "pend", "scale", "adding", "sid", "length", "pc", "sp", "pt", "type", "cel", "tick", "style", "dd", "ad", "off", "end", "buffer", "add", "gap", "ip", "len", "pick", "press", "sd", "id", "reset", "pg", "db", "address", "index", "padding", "ady", "adr", "addr", "span", "pat", "cap", "ping", "added", "mad", "pre", "att", "sk", "quad", "patch", "depth", "prep", "pos", "var", "ada", "Pad", "delay", "post", "pointer", "ptr", "fake", "pod", "kid", "start", "adjust", "pid", "port", "blank", "push", "part", "crop", "paste", "amp", "offset"], "p": ["cp", "f", "ap", "pc", "sp", "ps", "tp", "wp", "jp", "proc", "u", "op", "parent", "lp", "t", "param", "api", "point", "d", "np", "primary", "n", "ip", "bp", "pi", "plugin", "i", "pair", "pl", "pp", "pa", "r", "vp", "data", "o", "pre", "c", "P", "k", "fp", "s", "patch", "post", "pe", "b", "up", "per", "at", "e", "l", "port", "a", "part", "v", "pr", "m"], "currlinkn": ["currLinkyn", "curreLinknw", "currclinkconn", "currlinkp", "currlinkj", "currkeyyn", "currlinkyn", "currwalkin", "currLinken", "currclinkj", "curreLinkin", "currlinens", "currcheckconn", "currelinke", "currclinkedconn", "currclinkn", "curreLinkn", "currwalken", "currlinkedp", "curreLinkner", "currelinkyn", "currkeyp", "currelinkner", "currLinkn", "currlinknw", "currclinkedj", "currkeyconn", "currswitchnw", "currLinke", "currelinken", "currswitchner", "currLinkin", "currswitchn", "curreLinke", "currlinken", "currLinknw", "currLinkner", "curreLinkyn", "currlinkedconn", "currkeyen", "currlinkner", "currelinkn", "currcheckp", "currkeyner", "currwalknw", "currlinkin", "currelinknw", "currlinke", "curreLinkns", "currcheckn", "currLinkns", "currlineyn", "currcheckj", "currkeyj", "currlinee", "currwalkner", "currlinen", "currclinkedn", "currwalkns", "curreLinken", "currlineen", "currlinkconn", "currlinkedj", "currwalkn", "currlinkns", "currclinkp", "currelinkns", "currclinkedp", "currlinkedn", "currwalke", "currelinkin", "currlinener", "currswitchin", "currkeyn"]}}
{"project": "qemu", "commit_id": "46232aaacb66733d3e16dcbd0d26c32ec388801d", "target": 0, "func": "static void x86_cpu_common_class_init(ObjectClass *oc, void *data)\n\n{\n\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    xcc->parent_realize = dc->realize;\n\n    dc->realize = x86_cpu_realizefn;\n\n    dc->bus_type = TYPE_ICC_BUS;\n\n    dc->props = x86_cpu_properties;\n\n\n\n    xcc->parent_reset = cc->reset;\n\n    cc->reset = x86_cpu_reset;\n\n    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;\n\n\n\n    cc->class_by_name = x86_cpu_class_by_name;\n\n    cc->parse_features = x86_cpu_parse_featurestr;\n\n    cc->has_work = x86_cpu_has_work;\n\n    cc->do_interrupt = x86_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;\n\n    cc->dump_state = x86_cpu_dump_state;\n\n    cc->set_pc = x86_cpu_set_pc;\n\n    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = x86_cpu_gdb_read_register;\n\n    cc->gdb_write_register = x86_cpu_gdb_write_register;\n\n    cc->get_arch_id = x86_cpu_get_arch_id;\n\n    cc->get_paging_enabled = x86_cpu_get_paging_enabled;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_memory_mapping = x86_cpu_get_memory_mapping;\n\n    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;\n\n    cc->write_elf64_note = x86_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;\n\n    cc->write_elf32_note = x86_cpu_write_elf32_note;\n\n    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;\n\n    cc->vmsd = &vmstate_x86_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->debug_excp_handler = breakpoint_handler;\n\n#endif\n\n    cc->cpu_exec_enter = x86_cpu_exec_enter;\n\n    cc->cpu_exec_exit = x86_cpu_exec_exit;\n\n}\n", "idx": 19253, "substitutes": {"oc": ["cca", "aco", "output", "pc", "ck", "unc", "uc", "ac", "bc", "nc", "mic", "org", "bb", "toc", "oid", "oci", "ob", "isc", "co", "ocr", "o", "oper", "ec", "mac", "loc", "oco", "c", "OC", "object", "usc", "oca", "roc", "cus", "tc", "acc", "soc", "rc", "ogg", "mc", "voc", "anc", "ucc", "ok", "alloc"], "data": ["di", "rec", "inc", "cache", "dd", "load", "DATA", "fee", "board", "d", "Data", "config", "input", "raw", "da", "func", "def", "desc", "rc", "fi", "dat", "device", "ds", "alloc"], "xcc": ["xcuc", "Xcc", "xccf", "xescc", " xec", "fcf", "Xcca", "exec", "rxcf", "rxuc", "rxcca", "xec", "XCC", "xesCC", "Xuc", "xccca", " xcca", "xccc", "exCC", "xuc", "fuc", "fcca", "xcca", "rxcc", "xescca", "excca", "xcCC", "xesuc", "Xec", " xCC", "xCC", "fcc", "xcf", "excc"], "cc": ["g", "cca", "cs", "cd", "cm", "client", "kk", "pc", "lv", "ck", "uc", "cmd", "bc", " gcc", "ac", "nc", "cache", "cast", "ci", "bec", "cur", "BC", "conn", "bb", "DC", "config", "pg", "cl", "co", "code", "ctl", "ctx", "inc", "ec", "lc", "cci", "mac", "ga", "ca", "cf", "c", "ce", "RC", "vc", "CC", "tc", "acc", "PC", "rc", "cb", "mc", "cmp", "ctrl", "ucc", "cu", "xc", "sc", "fc", "comp", "go", "cn"], "dc": ["cca", "disc", "cd", "di", "cdn", "df", "cm", "ck", "uc", "inc", "bc", "ac", "ds", "gc", "conn", "dm", "d", "DC", "db", "dt", "director", "doc", "ec", "lc", "design", "ga", "cci", "ca", "cf", "c", "mac", "de", "da", "vc", "CC", "cr", "tc", "acc", "rc", "mc", "dat", "dn", "duc", "sc", "fc"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    audsettings_t obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 19256, "substitutes": {"hw": ["gpu", "ow", "aws", "zh", "sys", "lv", "wp", "rw", "aff", "haw", "instance", "cli", "sh", "bh", "conn", "wh", "wm", "sw", "wei", "wire", "rh", "np", "war", "wl", "iov", "wu", "fw", "h", "wk", "wx", "qq", "wi", "ctx", "lc", "w", "hop", "him", "gio", "wn", "wd", "dq", "ha", "kw", "vc", "hp", "iw", "hh", "gp", "cow", "vm", "wy", "wcs", "num", "nw", " HW", "ww", "cmp", "wo", "hs", "tw", "wa", "cu", "mm", "nu", "hm", "ohm", "ht"], "as": ["is", "asu", "nas", "ms", "aws", "ap", "sa", "ps", "ais", "ac", "rs", "asm", "asc", "ans", "or", "av", "auth", "aw", "ar", "ai", "jas", "asp", "act", "rss", "mas", "asa", "ma", "AS", "an", "asi", "conf", "acs", "s", "bas", "ach", "ts", "ay", "at", "am", "ass", "As", "os", "alias", "ast", "a", "ams", "pas", "ras", "au", "ase"], "error": ["core", "self", "warning", " err", "ror", "rr", "f", "result", "type", "name", "op", "parent", "success", "orig", "valid", "rh", "no", "root", "magic", "message", " e", "danger", "r", "last", "data", "ae", "errors", "ace", "o", "call", "exc", "loc", "all", "ERROR", "notice", "var", "comment", "err", "Error", "rc", " Error", "row", "e", "bug", "unknown", "bad", "order", "debug", "info"], "ss": ["ssh", "css", "sn", "cs", "server", "sf", "sa", "bs", "ps", "pps", "rs", "na", "sq", "sw", " s", "ns", "hess", " ps", "si", "config", "pb", "asp", "uss", "rss", "iss", "ls", "vs", "cas", "es", "\u00df", "params", "conf", "sk", "sb", "s", "ks", "pe", "ssl", "oss", "se", "su", "fs", "ass", "SS", " iss", "tz", "sts", "ses", " SS", "spec", "ess", "sc", "ds", "ross", "au", "settings"], "pa": ["ja", "cp", "sa", "pc", "ana", "ps", "jp", "pd", "ppa", "bank", "na", "lp", "po", "media", "api", "qua", "ta", "ao", "pai", "ka", "bp", "ota", "pi", "si", "pm", "base", "pu", "pb", "va", "qa", "pse", "ma", "ctx", "ia", "lc", "ba", "ama", "Pa", "ampa", "ca", "pn", "p", "sb", "pe", "opa", "fa", "pha", "PA", "gp", "audio", "appa", "la", "ph", "pan", "a", "python", "apa", "pas", "an", "au", "pr", "ua"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)\n\n{\n\n    CPU_DoubleU farg;\n\n    int isneg;\n\n    int ret;\n\n    farg.ll = arg;\n\n    isneg = float64_is_neg(farg.d);\n\n    if (unlikely(float64_is_nan(farg.d))) {\n\n        if (float64_is_signaling_nan(farg.d)) {\n\n            /* Signaling NaN: flags are undefined */\n\n            ret = 0x00;\n\n        } else {\n\n            /* Quiet NaN */\n\n            ret = 0x11;\n\n        }\n\n    } else if (unlikely(float64_is_infinity(farg.d))) {\n\n        /* +/- infinity */\n\n        if (isneg)\n\n            ret = 0x09;\n\n        else\n\n            ret = 0x05;\n\n    } else {\n\n        if (float64_is_zero(farg.d)) {\n\n            /* +/- zero */\n\n            if (isneg)\n\n                ret = 0x12;\n\n            else\n\n                ret = 0x02;\n\n        } else {\n\n            if (isden(farg.d)) {\n\n                /* Denormalized numbers */\n\n                ret = 0x10;\n\n            } else {\n\n                /* Normalized numbers */\n\n                ret = 0x00;\n\n            }\n\n            if (isneg) {\n\n                ret |= 0x08;\n\n            } else {\n\n                ret |= 0x04;\n\n            }\n\n        }\n\n    }\n\n    if (set_fprf) {\n\n        /* We update FPSCR_FPRF */\n\n        env->fpscr &= ~(0x1F << FPSCR_FPRF);\n\n        env->fpscr |= ret << FPSCR_FPRF;\n\n    }\n\n    /* We just need fpcc to update Rc1 */\n\n    return ret & 0xF;\n\n}\n", "idx": 19274, "substitutes": {"arg": ["arp", "g", "val", "lag", "f", "option", "result", "inc", "work", "asm", "ang", "array", "aug", "param", "argument", "orig", "reg", "inter", "len", "args", "ax", "config", "play", "ar", "input", "addr", "ig", "par", "target", "call", "next", "p", "ag", "var", "func", "flag", "ark", "agg", "Arg", "arc", "agn", "opt", "arr", "alloc", "amp"], "set_fprf": ["set_bprfs", "set_bprc", "set_fprfx", "set_fPRf", "set_bprf", "set_rfprF", "set_ftrf", "set_fwrf", "set_rfprfx", "set_fwrfx", "set_bPRf", "set_fcrf", "set_bPRfs", "set_fcrc", "set_ftrc", "set_fPRfs", "set_ftrF", "set_bPRc", "set_fprc", "set_rfprc", "set_fcrfs", "set_rfprf", "set_fprF", "set_ftrfx", "set_fwrc", "set_fPRc", "set_fprfs", "set_fwrF"], "farg": [" fack", " fgen", " fargument", "fnarg", "ifgen", " fall", " fark", "ofag", "Fargs", "forall", " fArg", "tplay", "fault", " fplay", "farc", "forarc", "forarg", "fgen", "ifark", "forark", "fack", "fargument", "frarg", "bvar", "fArg", "Farg", "fark", "farm", "ofarc", "fgrad", "frgen", "fruse", "ifag", "ifarg", "forag", "forgrad", "forarm", "targs", "ofarg", "frvar", "barg", "forargument", "fnvar", "frag", " farc", "frack", "ifarm", "ball", "fall", "frplay", "frark", "tArg", "ofault", "fnag", " farm", "fplay", "ifgrad", "fvar", " fuse", "fag", " fgrad", " fvar", " fargs", "forvar", " fag", "targ", "bargument", "tag", "fargs", "fnuse", "fuse", "ifuse", "ifarc", "tack", "ofark", " fault", "forault", "FArg"], "isneg": ["issnegative", "isrel", "silpred", "isspred", "osminus", " isbad", " isgen", "ispred", " isnegative", "misbad", "ipnegative", "misneg", "Isgen", "Isnegative", " iscoll", " isminus", "Isneg", "isminus", "IsNeg", "Isbad", "silrel", "iscoll", "misnegative", "silneg", "issNeg", "isgen", " isNeg", "isnan", "ipbad", "isnegative", "risnan", " ispred", "risnegative", "osnan", "issrel", "ipneg", "miscoll", "risminus", "isscoll", " isrel", "issbad", "silNeg", "issneg", "risneg", "osnegative", "isNeg", "isbad", "issgen", " isnan", "osneg"], "ret": ["reply", "val", "match", "ort", "fun", "pet", "code", "pat", "xt", "rl", "flag", "opt", "lit", "rt", "bit", "let", "res", "reg", "red", "job", "fit", "data", "usr", "rev", "nt", "eval", "def", "value", " Ret", "out", "art", "offset", "RET", "cat", "hard", "lt", "error", "id", "db", "ert", "att", "format", "pret", "rc", "Ret", "arr", "info", "result", "alt", "feat", "cur", "success", "back", "len", "mt", "ut", "status", "rets", "sum", "ext", "ref", "det", "final", "gt", "re", "ft", "bf", "mem", "part"]}}
{"project": "qemu", "commit_id": "df8002103c3e262dc40d7b5e0eb2171ba28b1d63", "target": 0, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {\n\n            if (s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n                /* can always write bit 4 of CR7 */\n\n                if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 19290, "substitutes": {"opaque": ["opatile", "opacs", "opaques", "opedonymous", "operacity", "operatile", "opoc", " oponymous", "Opacs", "opacity", " opoc", "Oponymous", " opacity", " opatile", "opedoc", "catatile", "opedacs", "Opoc", "cataque", "opedaque", "catacity", "Opaque", "operaques", " opaques", "operaque", "oponymous", "cataques", " opacs"], "addr": ["dr", "server", "interface", "rr", "sid", "src", "route", "mode", "cmd", "node", "x", "prefix", "buf", "asm", "pad", "ad", "ip", "fd", "oid", "db", "address", "code", "ord", "r", "adr", "ace", "hop", "kt", "align", "mac", "loc", "xxx", "ext", "slot", "ref", "pos", "amp", "pointer", "socket", "ptr", "slice", "arch", "eth", "rc", "attr", "url", "seq", "port", "alias", "ast", "amd", "device", "ack", "part", "layer", "alloc", "host", "offset"], "val": ["local", "vl", "VAL", "aval", "x", "exec", "valid", "pl", "byte", "Val", "live", "al", "b", "sl", "update", "vert", "item", "arg", "Value", "lit", "bit", "bo", "pt", "pol", "values", "buf", "py", "fail", "col", "lib", "data", "fl", "slot", "p", "var", "key", "vol", "nil", "eval", "def", "value", "serv", "bl", "cal", "buffer", "base", "pos", "ind", "func", "sel", "vt", "ret", "arr", "rot", "alt", "ol", "dim", "el", "vals", "len", "stat", "loc", "all", "xxx", "ref", "ld", "sol", "unit", "tx", "slice", "mem", "v", "elt"], "s": ["g", "set", "self", "sites", "client", "session", "secondary", "uns", "js", "h", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "stats", "as", "states", "sets", "a", "ins", "qs", "m", "server", "sf", "http", "u", "ns", "site", "si", "args", "i", "tests", "state", "your", "full", "es", "us", "sk", "p", "sb", "ts", "ks", "y", "services", "l", "sym", "se", "its", "sync", "f", "rs", "south", "ss", "sq", "n", "o", "xs", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "aws", "ps", "new", "t", "d", "status", "ls", "w", "service", "comments", "request", "e", "os", "ds", "an", "settings"], "index": ["match", "node", "x", "end", "valid", "point", "position", "label", "byte", "connect", "search", "update", "insert", "weight", "image", "instance", "level", "site", "i", "column", "full", "data", "slot", "object", "key", "value", "find", "element", "num", "list", "date", "host", "sync", "offset", "f", "length", "number", "condition", "error", "ion", "version", "config", "module", "id", "address", "input", "ctx", "sort", "body", "pos", "ind", "pointer", "run", "section", "output", "inc", "Index", "new", "prefix", "dim", "success", "member", "len", "path", "fff", "align", "loc", "xxx", "loop", "active", "unit", "slice", "edge", "count", "size"]}}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 19291, "substitutes": {"nc": ["cs", "sn", "cdn", "dc", "pc", "unc", "bc", "NC", "conn", "ns", "n", "enc", "nn", "osc", "nec", "ctx", "ec", "lc", "kt", "c", "nt", "sb", "cc", "cv", "cus", "ct", "ne", "rc", "ng", "nw", "mc", "rn", "nm", "sc", "nic", "fc", "cn"], "s": ["is", "g", "cs", "sn", "self", "ms", "f", "ops", "sys", "src", "http", "ps", "sports", "u", "rs", "js", "ss", "sq", "parts", "d", "ns", "n", "si", "i", "state", "ls", "o", "es", "als", "gs", "c", "k", "p", "sb", "ks", "ts", "ssl", "sis", "sl", "b", "xs", "fs", "services", "stats", "S", "states", "sg", "ses", "e", "os", "hs", "sym", "a", "spec", "ds", "qs", "v", "sync", "settings"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n", "idx": 19301, "substitutes": {"buf": ["batch", "cp", "header", "f", "length", "uf", "uc", "queue", "cache", "array", "buffer", "Buffer", "pool", "np", "bp", "fd", "config", "path", "r", "pb", "padding", "data", "binary", "br", "ctx", "rb", "ffff", "c", "fp", "bag", "tmp", "b", "ptr", "slice", "rc", "cb", "num", "seq", "count", "mem", "port", "buff", "v", "alloc", "m"], "size": ["sn", "scale", "length", "cache", "sized", "page", "end", "six", "Size", "n", "SIZE", "enc", "small", "i", "ize", "capacity", "code", "data", "loc", "c", "s", "pos", "z", "en", "rc", "sec", "count", "e", "num", "l", "from", "v", "offset"], "pmsg_type": ["pmessage_no", "pmessage_types", "pmsg_types", "pmsg_id", "pmsgfno", "pmessage_set", "pmessage_id", "pmsgfport", "pmessage_unit", "pmessage_type", "pmsg_set", "pmsgfid", "pmsg_no", "pmessage_port", "pmsg_port", "pmsgftype", "pmsg_unit"], "p": ["g", "cp", "progress", "f", "ap", "length", "pc", "sp", "ps", "tp", "jp", "proc", "wp", "x", "u", "cache", "lp", "po", "op", "t", "param", "api", "d", "py", "np", "point", "n", "bp", "pi", "ip", "i", "j", "pair", "pm", "pp", "r", "pb", "pa", "padding", "parser", "data", "code", "o", "pre", "c", "P", "fp", "patch", "pos", "pe", "b", "ep", "pointer", "per", "at", "e", "dp", "l", "pid", "port", "python", "v", "m"], "p_end": ["P_start", "p_start", " p_begin", "p_ad", " p_enter", "p0start", "p00ending", "p_begin", "P_ad", "p_ended", "p0end", "p_offset", "p_End", "p0ad", "p_max", "P_end", " p_ending", "P_max", "p00begin", "p00end", "P_offset", "p00enter", "P_End", "p_ending", "p0offset", "p_enter", "P_ended"], "len": ["val", "str", "min", "f", "length", "sp", "bin", "name", "Len", "lp", "li", "po", "el", "end", "lf", "n", "enc", "lon", "lib", "id", "pl", "label", "code", "data", "rev", "lc", "lang", "loc", "pre", "fl", "ref", "c", "line", "pos", "limit", "le", "en", "fat", "la", "count", "num", "seq", "l", "ler", "pid", "lit", "lin", "part", "field", "ln"], "tag": ["class", "TAG", "token", "cat", "length", "match", "type", "name", "style", "op", "feat", "po", "cache", "date", "end", "reg", "gap", "col", "enc", "id", "word", "code", "r", "year", "co", "data", "block", "par", "hop", "lang", "lc", "stat", "loc", "pre", "format", "ref", "c", "patch", "pos", "ag", "var", "key", "pe", "post", "line", "comment", "use", "month", "Tag", "prop", "count", "num", "seq", "bug", "bad", "ack", "method", "field", "feature", "tail"]}}
{"project": "qemu", "commit_id": "ddb603ab6c981c1d67cb42266fc700c33e5b2d8f", "target": 0, "func": "static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n\n{\n\n    XHCITRB *trb_setup, *trb_status;\n\n    uint8_t bmRequestType;\n\n\n\n    trb_setup = &xfer->trbs[0];\n\n    trb_status = &xfer->trbs[xfer->trb_count-1];\n\n\n\n    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,\n\n                              xfer->epctx->epid, xfer->streamid);\n\n\n\n    /* at most one Event Data TRB allowed after STATUS */\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n\n        trb_status--;\n\n    }\n\n\n\n    /* do some sanity checks */\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n\n                TRB_TYPE(*trb_setup));\n\n        return -1;\n\n    }\n\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n\n                TRB_TYPE(*trb_status));\n\n        return -1;\n\n    }\n\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n\n        return -1;\n\n    }\n\n    if ((trb_setup->status & 0x1ffff) != 8) {\n\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n\n                (trb_setup->status & 0x1ffff));\n\n        return -1;\n\n    }\n\n\n\n    bmRequestType = trb_setup->parameter;\n\n\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n\n    xfer->iso_xfer = false;\n\n    xfer->timed_xfer = false;\n\n\n\n    if (xhci_setup_packet(xfer) < 0) {\n\n        return -1;\n\n    }\n\n    xfer->packet.parameter = trb_setup->parameter;\n\n\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n\n\n    xhci_try_complete_packet(xfer);\n\n    if (!xfer->running_async && !xfer->running_retry) {\n\n        xhci_kick_epctx(xfer->epctx, 0);\n\n    }\n\n    return 0;\n\n}\n", "idx": 19307, "substitutes": {"xhci": ["Xhki", "XHcci", "XHci", "xhki", "xhski", "xhcci", "Xhdi", "Xhcci", "XHki", "xhdi", "xHki", "xhscci", "xHci", "xHcci", "xhsdi", "XHdi", "xhsci", "Xhci", "xHdi"], "xfer": ["g", "fxfr", "elfer", "reply", " xclude", "elference", "get", "lexfer", "exfer", "pxfer", "crossporter", " xtransfer", "hyporter", "xxference", "hyference", "helfort", "crossFER", "rxf", "axcer", "sexiter", "uxiter", " xfeature", "extransfer", "xformer", "fxference", "workference", "wafeature", "xfar", "xf", "crosscer", "c", "fxfer", "xputer", "xfr", "yce", " xferred", "xiter", " xce", "workpire", " xcer", "pxtransfer", "send", "excer", "rfer", "transfer", "hyfer", "lexference", "yxfer", "sexfer", "axfer", "axfr", "imformer", "helporter", "rxpire", "yf", "axcf", "xsference", "xxfer", "axclude", "rcf", " xf", "crossference", " xfar", "ylferred", "add", "yference", "axference", "xFER", "xxfar", "yxference", "rputer", "yxfar", "workfer", " xference", "yxFER", "ylf", "pxference", "addr", "waporter", "txFER", "xsfen", "workporter", "ycer", "wfen", " xpire", "rfar", "pxformer", "xfort", "xfit", "crossfer", "worktransfer", "axper", "xtransfer", "lexporter", "nexfer", "axfar", "crossfit", " xformer", "workfar", "workf", " xFER", "rxfer", "xcf", " xcf", "waference", "yputer", "xce", "wference", "this", "helference", " xporter", " xfen", "txfer", "fxiter", "uxper", "nexcer", "ylfen", "ylfer", "nexporter", "lextransfer", "_", "sexporter", "config", "id", "hyfar", "helfer", "yporter", "sexper", "txference", " xputer", "xsfer", "nexference", "nexfit", "wfer", "lexcer", "axputer", "func", "uxporter", "exference", "yferred", "workfen", "rxporter", "xpire", "crossce", "uxfer", "xference", "yfort", "lexclude", "wporter", "helfr", "elporter", "xxFER", "lexfeature", "xclude", "heliter", "elfort", "xcer", "hyfit", " xfr", "imfer", "yltransfer", "axporter", "xferred", "xfeature", "crossfar", "imtransfer", "xxfr", "xfen", "ylce", "ylference", "txfr", "xporter", "xper", "fxfar", "fxporter", "imference", "function", "yfer", "wafer", "crossf", "xsporter", "event", "axiter"], "trb_setup": ["trbb_summary", "trb_config", "trb_info", "trb__settings", "trf_Setup", "trb_summary", "trr_trigger", "trb_sync", "trb_set", "trb2setup", "trb_Setup", "trbJupdate", "trr_update", "trbb_spec", "trb2set", "trb_site", "trbi_settings", "trf_status", "trbi_boot", "trf_lock", "trb_lock", "trbJsetup", "trb_settings", "trbJtrigger", "trb2boot", "trf_settings", "trf_info", "trb_update", "trbi_setup", "trx_set", "trb__Setup", "trbJset", "trbi_config", "trf_setup", "trx_site", "trf_set", "trb__lock", "trf_sync", "trf_login", "trb__info", "trb__status", "trr_set", "trx_setup", "trbb_config", "trx_update", "trbb_setup", "trb_boot", "trb2config", "trbi_set", "trr_setup", "trbi_status", "trb_login", "trb_trigger", "trb__setup", "trb_spec"], "trb_status": ["trb_score", "trf_type", "trbs_prefix", "trb_summary", "trB_update", "trf_state", "trr_complete", "trb_type", "trb2setup", "trB_setup", "trr_id", "trb2stat", "trb_id", "trf_status", "trf_mode", "trb2status", "trb_state", "trbs_source", "trb_update", "trb_stat", "trB_source", "trr_stat", "trb_complete", "trb_progress", "trr_status", "trB_status", "trb_source", "trr_setup", "trb_mode", "trr_score", "trb2complete", "trb_prefix", "trbs_status", "trbs_summary", "trB_progress", "trB_stat"], "bmRequestType": ["bmRequestInfo", "bmCommandTypes", "bmMessageTypes", "nbRequestTypes", "cmRequestID", "bmResponseType", "nbRequestType", "BMResponseTypes", "cmRequestTypes", "BMRequestTypes", "cmResponseTypes", "bmrequestInfo", "BMResponseType", "bmMessageID", "bmOperationID", "bmRequesttype", "cmResponseTyp", "nbCommandTypes", "bmMessageType", "bmrequestTypes", "BMResponseStyle", "bmrequesttype", "nbCommandtype", "bmMessageTyp", "cmRequestType", "nbRequestInfo", "BMResponseInfo", "bmOperationType", "nbCommandInfo", "cmResponseType", "BMRequestType", "bmOperationTyp", "bmRequestTyp", "bmRequestID", "bmCommandStyle", "bmCommandtype", "bm_Type", "bm_Info", "bmRequestTypes", "bmCommandInfo", "bmResponseTypes", "bmRequestStyle", "bm_type", "BMRequestStyle", "bmResponseInfo", "bmResponseStyle", "cmResponseID", "cmRequestTyp", "bmOperationTypes", "bmResponseTyp", "bmrequestStyle", "bm_Types", "bmCommandType", "BMRequestInfo", "bmResponseID", "nbRequesttype", "nbCommandType", "bmrequestType"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n", "idx": 19322, "substitutes": {"ts": ["cs", "str", "ats", "ims", "ics", "arts", "ms", "bs", "ps", "ents", "ports", "rs", "ds", "js", "t", "ss", "alls", "ns", "tis", "types", "tests", "tt", "Ts", "TS", "ls", "atts", "gs", "acs", "ks", "tx", "fs", "ptr", "tc", "tes", "ags", "acks", "ters", "times", "qs", "rates"]}}
{"project": "FFmpeg", "commit_id": "816577716bc6170bccfea3b9e865618b69a4b426", "target": 1, "func": "static av_cold int dvdsub_close(AVCodecContext *avctx)\n\n{\n\n    DVDSubContext *ctx = avctx->priv_data;\n\n    av_freep(&ctx->buf);\n\n    ctx->buf_size = 0;\n\n    return 0;\n\n}\n", "idx": 19353, "substitutes": {"avctx": ["afctx", "avrc", "afcca", "avcmp", "avcca", "AVrc", " avcontext", "avcontext", " avcmp", "AVcca", "AVctx", " avrc", "AVcmp", "AVcontext", " avcca", "afcmp", "afcontext", "afrc"], "ctx": ["cca", "cp", "cs", "cm", "client", "acl", "component", "src", "ck", "cmd", "bc", "buf", "ci", "conn", "sq", "obj", "config", "aux", "qa", "data", "cas", "lc", "loc", "ca", "cf", "c", "cam", "cv", "cc", "kw", "vc", "tx", "pkg", "tc", "Context", "context", "wcs", "cb", "cmp", "ctrl", "anc", "cu", "xc", "comp", "alloc", "cn"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return toclen;\n\n}\n", "idx": 19373, "substitutes": {"req": ["ru", "str", "resource", "rec", "rr", "f", "grad", "http", "src", "proc", "jp", "cmd", "rw", "sem", "ro", "rs", "Request", "res", "cur", "q", "sq", "org", "crit", "sr", "rh", "exec", "ir", "low", "ch", "tar", "config", "require", "ra", "r", "wx", "rx", "fr", "input", "qq", "qt", "call", "comm", "rb", "gr", "conf", "ref", "dq", "requ", "mr", "rf", "def", "resp", "desc", "err", "sec", "request", "seq", "required", "pro", "wa", "query", "spec", "rob", "comp", "ver"], "outbuf": ["offbuf", "outbuffer", " outbuff", "upuf", "outfb", " outuf", " outbuffer", "outfunc", " outcb", "outuf", "outputbuff", " outvec", "OUTvec", "wordbuf", "inbuffer", "infb", "execbuf", "cachebuff", "OUTfb", "upbuf", "Outcb", "Outbuffer", "wordbuff", "OUTbuffer", "execbuffer", "incv", "intbuf", "execvec", "Outbuf", "OUTuf", "outputbuf", "Outbuff", "execuf", "intuf", "Outuf", "OUTbuff", "offuf", "incb", " outfunc", "upcv", "wordcb", "inuf", "outputuf", "upbuff", "outvec", "outcv", "inbuf", "outcb", "cacheuf", "intfunc", "inbuff", "OUTfunc", "offbuff", "worduf", "outputbuffer", "outbuff", "cachebuf", "cachecv", "OUTbuf", "offfb"], "s": ["g", "sys", "session", "sa", "http", "f", "ds", "js", "south", "t", "ss", "sq", "d", "sr", "ns", "n", "si", "storage", "r", "ls", "o", "w", "conf", "gs", "c", "p", "sb", "ts", "service", "ssl", "sis", "sl", "b", "z", "su", "fs", "sim", "services", "S", "sg", "ses", "e", "sym", "serv", "sc", "spec", "v", "sync", "m"], "start_track": ["start_tracking", " start_tracks", "end_track", "end_tracks", " start_trace", "end_tracking", "start_mode", "start_tracks", "start_trace", "start_rack", " start_mode", "end_rack", " start_tracking"], "format": ["scale", "html", "pattern", "f", "layout", "option", "pretty", "length", "template", "operation", "range", "type", "style", "frame", "prefix", "source", "feat", "transform", "name", "pad", "form", "gap", "quality", "len", "position", "version", "magic", "base", "direction", "frequency", "offset", "status", "duration", "padding", "space", "sort", "feature", "Format", "ext", "time", "file", "unit", "period", "function", "stage", "value", "letter", "package", "fn", "term", "size", "method", "spec", "host", "mode"], "msf": ["msl", "msfs", "psl", "emsf", "lesf", "apsf", "msv", "csc", "MSc", "msc", "cusfo", "csf", "msaf", "Msl", " msfe", "lesfs", "cusm", " msfx", "mesv", "MSl", " msaf", "apsaf", " msfs", " msF", "psf", "ssn", " msv", " msc", "csfe", "MSfe", " msn", "lescf", "msF", "msfe", "ssf", "Msf", "ssfe", "lesaf", "msn", "mscf", "apsfs", "msfx", "Msfx", "ssl", " msm", "cusf", "cusF", "Msv", "emsfo", " msfo", " msl", "mesf", "msm", "MSf", "psfe", " mscf", "apscf", "emsm", "mesl", "msfo", "mesfx", "emsF", "psn", "csl"], "toclen": ["pclength", "gzln", "oclength", "tcLen", "pcsize", "lclen", "tocln", "disclength", "ocsize", "ocfat", "tclength", "gzLen", "aclen", "cotfat", "pcfat", "discLen", "pclen", "cotlength", "gzlength", "oclf", "uclen", "tocLen", "lclon", "aclength", "pclon", "cotsize", "ocLen", "tclf", "disclen", "pcLen", "gzlen", "ocln", "toclength", "oclon", "ucLen", "tocfat", "discln", "uclength", "tclen", "lclength", "cotLen", "uclf", "lcLen", "cotlen", "aclon", "acLen", "toclon", "toclf", "tocsize", "cotlon", "oclen"], "nb_sectors": ["nb_cections", "nb_pections", "nb_mections", "nb_mectors", "nb_vegments", "nb_mesections", "nb_pegments", "nb_chgments", "nb_secs", "nb_chctors", "nb_vections", "nb_ceors", "nb_megments", "nb_peivers", "nb_chivers", "nb_chctions", "nb_vector", "nb_sector", "nb_gexes", "nb_cegments", "nb_sections", "nb_gectors", "nb_pexes", "nb_vesections", "nb_vecs", "nb_seors", "nb_geors", "nb_seivers", "nb_gections", "nb_pecs", "nb_sexes", "nb_cectors", "nb_gecs", "nb_pesections", "nb_pectors", "nb_veivers", "nb_vexes", "nb_gector", "nb_segments", "nb_gegments", "nb_veors", "nb_sesections", "nb_vectors", "nb_pector"]}}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 19380, "substitutes": {"bs": ["cs", "css", "ps", "bin", "blog", "bc", "cache", "rs", "BS", "js", "bh", "ss", "abi", "bi", "bn", "its", "ns", "bb", "plugins", "base", "obj", "facebook", "banks", "bid", "blocks", "bits", "db", "pb", "vs", "ls", "iss", "bps", "als", "us", "br", "ba", "gs", "bot", "sb", "bas", "s", "ts", "ks", "b", "obs", "ubs", "abc", "xs", "fs", "las", "bytes", "bis", "cb", "bus", "gb", "bos", "ses", "os", "bf", "bu", "ins", "outs", "lb", "bes", "ds", "qs", "bl", "fb", "sync", "bing"], "errp": ["errpc", "errps", "erpre", "errP", "serverpre", " errr", "Err", "Ercp", "Erv", "rrpre", "serverps", "rrcp", "erP", "errv", "rrP", " errv", "rrpc", "erpc", "errcp", "errpre", "rrr", "erp", "erps", "serverp", "serverr", "rrv", "rrp", "rrps", " errpc", "err", "Erp", " errP", " errcp", "errr"], "local_err": ["global_error", "localWerror", "local6error", "localWerrors", "local_iter", "local_errors", " local_iter", "local_error", "local6result", " local_error", "localWmagic", "local6errors", "local_rr", "local_result", " local_Er", "local6err", "localWerr", " local_magic", " local_result", "local_magic", " local_errors", "global_err", "global_rr", "local_Er", " local_rr"], "ret": ["RET", "val", "bit", "let", "f", "cat", "result", "match", "bc", "alt", "feat", "res", "success", "reg", "back", "req", "no", "len", "fun", "mt", "id", "fin", "db", "dt", "code", "rev", "rets", "iter", "att", "ext", "ref", "det", "nt", "gt", "rl", "sur", "flag", "re", "done", "ft", "rc", "num", "Ret", "sec", "mem", "lit", "arg", "rt"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 19389, "substitutes": {"dev": ["development", "self", "DEV", "grad", " device", "kind", "mod", " Dev", "dd", "conn", "error", "req", "d", "test", "reg", "ch", "pub", "virt", "der", "dom", "diff", "data", "Dev", "block", "engine", "w", "conf", "app", "gu", "def", "desc", "comment", "dem", "err", "priv", "md", "ev", "cmp", "device", "rad", "spec", "Device", "debug", "serial", "v", "adv", "ver", "info"], "s": ["g", "is", "server", "sf", "f", "session", "sys", "rs", "js", "sh", "t", "south", "sq", "ss", "d", "n", "si", "state", "storage", "r", "o", "w", "conf", "c", "p", "sb", "service", "ssl", "b", "sl", "services", "S", "sg", "ses", "e", "sv", "sub", "a", "serv", "sc", "se", "spec", "v", "sync", "m"], "pci_conf": ["pci_type", "pcixfi", "pcixaff", "pcul_config", "pki_Conf", "pki_ch", "pcixconfig", "pcul_type", "pci_ch", "pci_con", "pcixconf", "pki_fi", "pcul_conf", "pculJconf", "pki_cfg", "pki_state", "pciJaff", "pki_con", "pcixstate", "pculJconfig", "pcixch", "pki_conn", "pciJconfig", "pki_cal", "pci_config", "pci_state", "pci_conn", "pci_cal", "pki_config", "pci_Conf", "pculJaff", "pki_conf", "pciJconf", "pci_aff", "pki_aff", "pculJtype", "pciJtype", "pcul_aff", "pci_fi", "pci_cfg"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n", "idx": 19403, "substitutes": {"insn": ["INSne", "outsne", "insnot", "outsnc", "ainsnc", " insne", "outsnot", "ainsne", "tsn", "inssn", " insnot", "ainsn", "opensN", " inssn", "insnc", "insne", "tssn", " insN", " insz", "outsn", "outsz", "opensn", " insnc", "tsN", "insN", "ainsN", "INSz", "INSnot", "insz", "INSn", "outsN", "openssn"], "mask": ["gate", "cp", "skip", "flags", "scan", "shift", "map", "pattern", "match", "allow", "work", "mod", "pad", "mark", "reg", "add", "test", "tr", "config", "offset", "card", "max", "pack", "diff", "qq", "mac", "conf", "Mask", "black", "patch", "flag", "dist", "comment", "sign", "image", "lock", "shape", "cmp", "ask", "arr", "mm", "master", "random", "amp", "mode"], "dest": ["class", "trans", "dc", "map", "src", "route", "proc", "temp", "transform", "source", "buf", "orig", "wb", "test", " dst", "config", "dev", " Dest", "path", "ord", "img", "dir", "data", "usr", "target", "Dest", "params", "conf", "imag", "std", "store", "desc", "dist", "mem", "dat", "opt", "sub", "master", "ctr", "mode"], "tmp": ["proc", "wp", "jp", "test", "pb", "st", "app", "attr", "gb", "TB", "copy", "cm", "project", "temp", "buf", "source", "dd", "pad", "py", "np", "bb", "img", "data", "Dest", "sb", "fake", "vm", "nb", "mp", "cp", "kk", "src", "this", "tp", "obb", "stuff", "rm", "config", "db", "wx", "diff", "ctx", "target", "rb", "dist", "vt", "dat", "mm", "bg", "txt", "now", "result", "bt", "td", "wb", "obj", "boot", "tab", "cpp", "storage", "tt", "cro", "slice", "tc", "gz", "etc", "cmp", "start", "nm", "mk", "buff", "dust", "fb", "amp"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIONvidia3d0Quirk *data;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vdev->bars[1].region.size) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->data = data = g_malloc0(sizeof(*data));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    data->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,\n\n                          data, \"vfio-nvidia-3d4-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,\n\n                          data, \"vfio-nvidia-3d0-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 19408, "substitutes": {"vdev": ["ppack", "qda", "cdevice", "vda", "lprof", "gdevice", " vprof", "cdi", "Vdevice", " vde", "gga", "bdev", "vdie", " vdm", "vdiff", "fpu", "gdem", "vga", "vDev", "pdev", " vdef", " vconn", "vconn", "svdevice", "vdi", "ldev", "pdevice", "gDev", "Vprof", "gdm", "VDev", "fdevice", "hdevice", "Vdev", "mdiv", "wdef", "vvdem", " vDev", "elga", "svev", "vdef", "gdev", "fdev", "hdev", "wpack", "gdiv", "wde", "ldef", "qdev", "eldem", "ndevice", "pdef", "Vconn", "vvdev", "wda", "cdiff", "wdi", "vvprof", "eldevice", " vdevice", " vda", "vdm", "cdev", "bga", "wdie", "mdevice", "vprof", "cdiv", "vev", "svdev", "Vdem", "wdiff", "mdev", "mpu", " vpack", "wdiv", "vpack", "qdef", "gdie", "vdevice", "vpu", " vdiff", "gprof", "bdevice", " vdem", "wdev", "npu", "ndev", "vdiv", "pdiv", "vde", "eldev", "ldevice", "fdiv", "qdevice", "Vdm", "ndiv", "hdiv", "vdem", "svprof", "qdiv", "wdevice", " vdiv", "vvconn", "bdem", "gev", "pdi", " vdie", "qde", "hdef", "lev"], "quirk": ["QUirk", "qoise", "quark", "guirrel", "quisk", "aquird", "joirk", "affirt", "blbug", "queoise", "qack", "quoise", "affirk", "Quirk", "quiq", "quirrel", " quisk", "acquik", "squird", "aquoise", "squavour", "Quird", "guavour", "guack", " quirt", "requik", "blird", "quirt", "Quik", "Quirt", "quird", "aquirk", "aquark", "shirk", "squark", " quark", " quird", "Quiece", "quik", "queiq", "joirt", "squraud", "qirrel", "qirk", "qirt", "quiece", "qark", "blirt", "aquirt", "ghirt", "guirt", "shbug", "quavour", "Quirrel", "squirrel", "squirk", "ghraud", "queirt", " quiece", "QUird", "qird", "Quisk", "requirt", "qubug", "aquik", "acquird", "qik", "shirt", "squik", "ghird", "requirk", "qiq", "squirt", "guirk", " quik", "blirk", "aquiq", "qavour", "guark", " quirrel", "QUik", "aquirrel", "quraud", "affik", "shird", "queird", "queik", "requird", "shik", "acquirk", "queark", "affird", "acquirt", " quack", "aquisk", "joird", "joraud", "ghirk", "requark", " qubug", "guird", "aquiece", "QUirt", "quack", "queirk"], "data": ["batch", "di", "progress", "rec", "inner", "none", "session", "cache", "window", "api", "end", "connection", "valid", "record", "zip", "block", "content", "action", "update", "done", "image", "docker", "zero", "empty", "mode", "alpha", "name", "queue", "load", "reg", "no", "memory", "dev", "state", "draw", "p", "da", "missing", "current", "wait", "value", "ui", "model", "push", "bin", "this", "style", "array", "ad", "error", "buffer", "Data", "config", "module", "change", "input", "raw", "next", "area", "dat", "ata", "info", "resource", "and", "output", "result", "database", "new", "parent", "media", "DATA", "success", "d", "function", "slice", "gui", "mem", "start", "bad", "device", "size"]}}
{"project": "FFmpeg", "commit_id": "919d13d2383bd7318b80ed0c5b723323a79a8996", "target": 0, "func": "static int cookie_string(AVDictionary *dict, char **cookies)\n\n{\n\n    AVDictionaryEntry *e = NULL;\n\n    int len = 1;\n\n\n\n    // determine how much memory is needed for the cookies string\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n\n\n    // reallocate the cookies\n\n    e = NULL;\n\n    if (*cookies) av_free(*cookies);\n\n    *cookies = av_malloc(len);\n\n    if (!cookies) return AVERROR(ENOMEM);\n\n    *cookies[0] = '\\0';\n\n\n\n    // write out the cookies\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n\n\n    return 0;\n\n}\n", "idx": 19411, "substitutes": {"dict": ["self", "str", "df", "map", "coll", "f", "inc", "cache", "document", "d", "table", "config", "id", "db", "path", "ict", "code", "dom", "data", "dir", "entry", "doc", "w", "conf", "body", "c", "head", "object", "file", "inf", "da", "def", "lock", "die", "dat", "list", "arr", "host"], "cookies": ["cookys", "cookieis", "copy", "copries", "readys", "privys", " cooki", " cookis", "cookiees", "readies", "cookiey", " cooky", " cookries", "cooki", "cookieys", "privied", "csss", "cssy", "catis", "cooky", " cookys", "copes", "copies", "reads", "privies", "cookries", "cssies", " cooks", "readied", " cookied", "cssys", "caty", "cookieies", "Cooki", "copi", "cookes", " cookes", "cookieied", "cooks", "caties", "privy", "Cookries", "catys", "cookied", "Cookied", "cookis", "Cookys", "Cookies", "Cooky", "copys", "Cooks"], "e": ["ele", "g", "eu", "f", "x", "je", "eff", "me", "oe", "el", "end", "d", "ge", "i", "entity", "eng", "h", "E", "ae", "o", "es", "pse", "ue", "ee", "ec", "ze", "esi", "see", "ea", "c", "ce", "de", "ke", "line", "y", "he", "pe", "b", "ep", "ell", "be", "enter", "er", "ve", "ei", "edge", "le", "eve", "en", "err", "ede", "ne", "element", "ed", "ev", "l", "fe", "ie", "eg", "se", "m"]}}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "static int get_physical_address (CPUMIPSState *env, hwaddr *physical,\n\n                                int *prot, target_ulong real_address,\n\n                                int rw, int access_type)\n\n{\n\n    /* User mode can only access useg/xuseg */\n\n    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;\n\n    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;\n\n    int kernel_mode = !user_mode && !supervisor_mode;\n\n#if defined(TARGET_MIPS64)\n\n    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n#endif\n\n    int ret = TLBRET_MATCH;\n\n    /* effective address (modified for KVM T&E kernel segments) */\n\n    target_ulong address = real_address;\n\n\n\n#define USEG_LIMIT      0x7FFFFFFFUL\n\n#define KSEG0_BASE      0x80000000UL\n\n#define KSEG1_BASE      0xA0000000UL\n\n#define KSEG2_BASE      0xC0000000UL\n\n#define KSEG3_BASE      0xE0000000UL\n\n\n\n#define KVM_KSEG0_BASE  0x40000000UL\n\n#define KVM_KSEG2_BASE  0x60000000UL\n\n\n\n    if (kvm_enabled()) {\n\n        /* KVM T&E adds guest kernel segments in useg */\n\n        if (real_address >= KVM_KSEG0_BASE) {\n\n            if (real_address < KVM_KSEG2_BASE) {\n\n                /* kseg0 */\n\n                address += KSEG0_BASE - KVM_KSEG0_BASE;\n\n            } else if (real_address <= USEG_LIMIT) {\n\n                /* kseg2/3 */\n\n                address += KSEG2_BASE - KVM_KSEG2_BASE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (address <= USEG_LIMIT) {\n\n        /* useg */\n\n        if (env->CP0_Status & (1 << CP0St_ERL)) {\n\n            *physical = address & 0xFFFFFFFF;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        }\n\n#if defined(TARGET_MIPS64)\n\n    } else if (address < 0x4000000000000000ULL) {\n\n        /* xuseg */\n\n        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0x8000000000000000ULL) {\n\n        /* xsseg */\n\n        if ((supervisor_mode || kernel_mode) &&\n\n            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xC000000000000000ULL) {\n\n        /* xkphys */\n\n        if (kernel_mode && KX &&\n\n            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 19431, "substitutes": {"env": ["console", "core", "server", "cdn", "eu", "txt", "session", "cal", "lv", "nc", "net", "global", "et", "conn", "eni", "el", "exec", "np", "Environment", "site", "args", "enc", "config", "dev", "osc", "pg", "db", "dt", "eng", "code", "dict", "iss", "ef", "ctx", "ec", "engine", " environment", "exc", "qt", "esp", "ext", "conf", "cf", "ea", "profile", "ou", "her", "inv", "enter", "en", "context", "vm", "ne", "viron", "ev", "e", "dat", "environment", "serv", "que", "event", "v", "oa"], "physical": ["local", "console", "resource", "regular", "http", "intel", "hard", "secondary", "prefix", "linux", "relative", "primary", "ip", "Physical", "config", "memory", "address", "native", "phys", "virtual", "external", "protected", "digital", "host", "binary", "target", "al", "pixel", "pointer", "ipt", "network", "direct", "port", "reference", "remote", "serial", "smart", "present", "specified"], "prot": ["server", "inet", "istor", "txt", "Prot", "proc", "secondary", "prefix", "normal", "test", "primary", "config", "multi", "reset", "cl", "platform", "protected", "status", "phys", "mult", "binary", "typ", "stat", "ext", "att", "format", "pos", "selected", "def", "ptr", "ocol", "transfer", "en", "eth", "prop", "phy", "ret", "port", "pro", "opt", "rot"], "real_address": ["real_image", "real_addr", "realamadd", "true_location", "virtual_address", "true_addr", "virtual_addr", "virtual_add", "realxaddress", "realeraddress", "realipnumber", "realamaddress", "realerentry", "realipcondition", "realxentry", "virtual_image", "real67address", "trueerentry", "trueerlocation", "real67addr", "realamslave", "virtual_entry", "real_number", "physical_address", "real_message", "realmemslave", " real_name", "virtual_slave", "real_slave", "realamaddr", "realxaddr", "true_address", " real_number", "real_name", "realipmessage", "realeraddr", " real_addr", "physical_message", "realerlocation", "real_condition", "realmemaddr", "trueeraddress", "realmemadd", "realmemaddress", "real_entry", "real67image", "physical_number", "physical_condition", "trueeraddr", "realximage", "real_location", "true_entry", "real67entry", "real_add", "realipaddress"], "rw": ["ty", "pattern", "proc", "worker", "ro", "prefix", "wh", "sw", "nn", "slave", "r", "rx", "w", "rb", "ffff", "pn", "fp", "rf", "vt", "ww", "password", "RW", "rot"], "access_type": ["accessvaltype", "access_types", "accesstypetypes", "connectionvaltable", "connection_types", "accessvaltable", "connection_table", "connectionvaltypes", "accessvaltypes", "accessvalgroup", "connection_type", "connectionvaltype", "accesstypegroup", "access_table", "connection_group", "access_group", "accesstypetable", "accesstypetype", "connectionvalgroup"]}}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434, "substitutes": {"spapr": [" spapsrc", "Spacsr", "spagrar", "pseaprs", "splaprs", "pseappr", "scappr", "spacsr", "scapar", "spagar", "spaprc", "spagr", "scapprc", " spaprar", "sprapr", "ppaper", "pseapri", "Spacr", "spamprc", "spampnr", "spapear", " spaprc", "scapr", "pseagrs", " spapsar", "spajsr", "scaprar", "splapr", "spaxpr", "spappper", "ppapr", "Spaprs", "spappar", "spamper", " spapsr", "spluprs", "spAPr", "spapsnr", "ppapnr", "spampar", "Spaplr", "spagrc", "Spaclr", "spampr", "spapsar", "sprapri", "spAPsr", "scaprc", "scapprar", "spapprs", "spupr", "sprapnr", "spupnr", "ppapsr", " spapar", "spuprs", "Spacrs", "spamprar", "spupper", "spapprc", "spaxrs", "spagpr", "ppapri", "spaperar", "spraprs", "spapsrc", "spaperc", "spaxr", "spagri", "splupnr", "spapsrar", "spAPrs", "ppapsri", "pseagr", "spapnr", "spaprs", "spapar", "spaprar", "spappri", "spaper", "spaclr", "splapper", "spajlr", "Spapsr", "spaxri", "spajr", "pseapr", "spapprar", "spapser", "spappnr", "sprapper", "ppapsnr", "pseagri", "splapnr", "spacrs", "spraper", "spampri", "spajrs", " spapsrar", "splupr", "spapsri", "scappar", "spapper", "ppapser", "splupper", "spappr", "spaplr", "spapppr", "Spapr", "spapri", "spapsr", "spacr", "pseagpr", "spAPlr", "spagrs"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n", "idx": 19441, "substitutes": {"v": ["g", "self", "f", "uv", "ov", "vim", "x", "u", "t", "q", "vin", "n", "version", "i", "vid", "r", "iv", "vp", "vis", "k", "c", "p", "vol", "b", "value", "nv", "vt", "vm", "ev", "e", "l", "sv", "V", "tv", "j", "m"], "name": ["self", "str", "NAME", "none", "ame", "type", "x", "prefix", "new", "parent", "error", "d", "no", "n", "child", "i", "id", "word", "path", "label", "address", "code", "space", "data", "o", "call", "ext", "nam", "object", "key", "Name", "missing", "null", "search", "value", "comment", "named", "names", "start", "alias", "unknown", "a", "part"], "list": ["local", "batch", "set", "self", "str", "can", "and", "get", "map", "length", "result", "large", "allow", "type", "x", "queue", "parent", "array", "load", "source", "li", "global", "cache", "L", "end", "pool", "test", "listed", "view", "len", "base", "member", "stack", "i", "id", "chain", "cl", "card", "code", "tree", "data", "LIST", "lists", "full", "block", "lc", "call", "all", "join", "live", "p", "gl", "filter", "keep", "null", "la", "count", "like", "e", "List", "l", "out", "bl"], "size": ["g", "cs", "scale", "cm", "length", "sp", "large", "complete", "ix", "sized", "new", "ci", "six", "form", "Size", "len", "si", "args", "SIZE", "small", "ize", "capacity", "max", "code", "address", "null", "esc", "count", "num", "sec", "shape", "empty", "iz", "offset"], "errp": ["errpc", "errP", "rrfp", " errr", "irp", " errc", "derlp", "rrpc", "errpr", "erpc", " errpr", "irpc", "srP", "irc", "erap", " errlp", "derP", "rrap", "erp", "srlp", " errap", "derp", "erc", "erfp", "errap", "rrp", "derpr", "srp", " errpc", "err", " errfp", "errfp", " errP", "errr", "errlp", "srpr", "irr", "errc"], "qiv": ["guIV", "qriv", "sqadr", "quriv", "sqriv", "qiver", "qIV", "qou", "quadr", "Qiv", "qualiv", "Qiver", "qadr", "qualadr", " qIV", "QIV", "guiver", " qiver", " qou", "qualriv", "quoi", " qori", "Qoi", "guiv", "qoi", "sqiv", "guou", "quiver", "quio", "quori", "Qou", "Qori", "sqio", "qori", "quiv", "qio", " qoi", "qualio"], "qobj": ["qobject", "quobj", "pObj", "kobj", "viewobj", "quob", "Qob", "Qobj", "quobject", " qObj", "qob", "pobj", "Qobject", "pobject", "gobj", "qubr", "Qiv", "wob", "viewob", "Qbr", "kiv", "wobj", "giv", "wobject", "kbr", "wiv", "kout", "gob", "qObj", " qobject", "qbr", "qout", "kObj", "viewiv", "kobject", " qob", "pout", "viewobject", "quiv", "gobject", " qout"], "entry": ["server", "inner", "cat", "ry", "result", "match", "escape", "new", "array", "parent", "li", "q", "it", "add", "Entry", "connection", "feed", "member", "ge", "or", "obj", "si", "inter", "child", "counter", "id", "ner", "parse", "index", "r", "data", "reader", "lc", "ga", "import", "object", "p", "nt", "key", "her", "ent", "enter", "er", "insert", "la", "element", "row", "e", "term", "query", "ie", "se", "part", "info"]}}
{"project": "qemu", "commit_id": "0a982b1bf3953dc8640c4d6e619fb1132ebbebc3", "target": 0, "func": "static void test_qga_file_write_read(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    const unsigned char helloworld[] = \"Hello World!\\n\";\n\n    const char *b64;\n\n    gchar *cmd, *enc;\n\n    QDict *ret, *val;\n\n    int64_t id, eof;\n\n    gsize count;\n\n\n\n    /* open */\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-file-open',\"\n\n                 \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    id = qdict_get_int(ret, \"return\");\n\n    QDECREF(ret);\n\n\n\n    enc = g_base64_encode(helloworld, sizeof(helloworld));\n\n    /* write */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-write',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \",\"\n\n                          \" 'buf-b64': '%s' } }\", id, enc);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert_cmpint(eof, ==, 0);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read (check implicit flush) */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n", "idx": 19469, "substitutes": {"fix": [" format", "class", "fx", "pattern", "f", "new", "ix", "prefix", "q", "test", "make", "root", "config", " bug", "init", "diff", "data", "call", "fixes", "pre", "conf", "FIX", "format", "post", "patch", "setup", " prefix", "def", "update", " Fix", "Fix", "bf", "bug", "fe", "fc", "field", "mix"], "fixture": ["cuzzle", " flict", "citter", " fixtures", "foster", "nixture", "vitness", "factory", "destival", "hactory", "mixture", "hestival", "vestival", "dault", "Flict", "ditness", "duzzle", "hixture", "vactory", "hitness", "dactory", "fitness", "festival", "nitness", "Fixture", "goster", " fitness", "Fixtures", "nlict", "moster", " fuzzle", "flict", "formault", "fuzzle", "fixtures", "mault", "vixture", "cault", "formixture", "ditter", " fitter", "fault", " fault", "fitter", "cixture", "formoster", "Fitness", "gault", "nixtures", "dixture", "gixture"], "helloworld": [" hellowellow", "hellowedird", "hellewella", "hellewww", "helloyellow", "cloyworld", "hellowww", "hellowedella", "hellowingorld", "hellowedork", "hemowedellow", "hellowellow", "hellowingellow", "clowork", "clowworld", "helloyird", "hellowedworld", "hellowsworld", " hellowird", "helleworld", " hellowarden", "helloyork", "hellowingird", "hellowingarden", "hellowingww", "helloyworld", "hemoworld", "hellowedww", "hellowingork", "hellowsellow", "helloyorld", "hellowedarden", "hemowedella", "hellowarden", "cloyork", "hemowworld", "hellowird", "hellowsird", "hemowellow", "hemowedworld", "hellowork", "hellowedellow", " hellowingarden", "hellowworld", "hellowella", "hemowedird", " hellowingird", "hemowork", "hemowella", "hemowird", "cloyorld", "hellowingella", "hemowedww", "clowellow", "hemowedork", "cloyellow", "hellowsorld", "hellowingworld", " hellowingellow", " hellowingorld", "hemowww", "hellowsarden", "hemowedorld", "cloworld", "hellowedorld", "hellework"], "b64": ["base64", "p24", "coll", "p58", " b24", "base65", "boll", "base63", "baseoll", "f160", "b58", " b62", "b65", "B62", "zboll", "f24", "wb64", "Boll", "c256", " b160", "p160", "zb63", "f58", "zb65", "c62", "zb64", "f64", "B256", " boll", "wb65", "b256", " b256", "c64", "wb63", "p64", "b160", " b58", "b62", "b63", "B64", "b24", "wboll"], "cmd": ["g", "client", "grad", "command", "exec", "valid", "child", "fun", "kg", "auth", "code", "dict", "qq", "call", "cf", "gen", "cfg", "Cmd", "ctrl", "arg", "contin", "mode", "cd", "pt", "cli", "buf", "clean", "req", "force", "img", "dom", "mac", "wd", "std", "def", "pkg", "err", "msg", "url", "cookie", "bug", "method", "md", "cat", "ck", "crit", "config", "module", "init", "input", "dir", "win", "wx", "ctx", "help", "cc", "func", "cb", "custom", "cod", "cn", "ux", "ll", "prefix", "parent", "conn", "root", "gd", "bot", "gz", "seq", "rn", "anc"], "enc": ["vec", "acl", "inc", "ac", "nc", "feat", "uc", "conn", "el", "exec", "col", "ch", "lib", "auth", "eng", "code", "emb", "img", "wk", "win", "binary", "oder", "ec", "lang", "exc", "mac", "loc", "ext", "Enc", "iq", "c", "eval", "sl", "encrypted", "msg", "en", "alg", "rc", "seq", "sg", "env", "empty", "ver"], "ret": ["dr", "RET", "detail", "reply", "let", "f", "grad", "pt", "cat", "result", "alt", "buf", "del", "feat", "res", "flat", "success", "el", "repl", "reg", "vals", "valid", "rel", "back", "info", "base", "obj", "fun", "pet", "db", "fin", "fit", "des", "dict", "img", "data", "rev", "pass", "rets", "att", "ext", "ref", "det", "nt", "final", "response", "gt", "rl", "al", "eval", "def", "resp", "re", "en", "ft", "url", "Ret", "seq", "bf", "expr", "opt", "arr", "arg", "lit", "rt", "part", "art", "br"], "val": ["local", "bo", "VAL", "pt", "split", "aval", "x", "alt", "ol", "cel", "bc", "res", "el", "repl", "reg", "vals", "valid", "rel", "base", "len", "fun", "obj", "col", "lib", "elt", "il", "data", "rev", "stat", "loc", "fl", "Val", "pre", "ref", "all", "al", "var", "pos", "rl", "vol", "unit", "b", "eval", "sl", "ind", "cond", "value", "vert", "sel", "la", "bal", "url", "seq", "bel", "arg", "lit", "rt", "part", "v", "bl", "pr"], "id": ["bit", "ape", "cd", "f", "sid", "cat", "grad", "kind", "ension", "ids", "name", "type", "x", "parent", "in", "ac", "q", "ad", "end", "it", "valid", "d", "root", "ip", "base", "i", "Id", "ID", "oid", "one", "bid", "ident", "h", "code", "ify", "aid", "doc", "mid", "win", "iq", "ref", "file", "p", "nt", "post", "ind", "z", "uid", "url", "kid", "seq", "idy", "num", "start", "pid", "like", "ie", "md", "af", "ide", "info"], "eof": ["neOF", "neOf", " eov", "ieof", "peof", "zefor", "befor", "beof", " eol", "ieov", "Eef", "zeef", "eol", " eom", " eOf", "eeOf", "eef", "zeOf", " ef", "neov", "Eom", "ieOf", "geom", "eov", "zeof", "Eof", "peOf", " eos", "eeof", "peos", "ef", " eOF", "seof", "beol", "seef", "eos", "neof", "oneof", "sefor", "eOF", "eeOF", "eom", "seOf", "eop", "eeol", "beOf", "onef", " eop", "geof", "pef", "eOf", "beef", "Eop", "oneos", "beOF", "oneOf", "geop", "ieOF", " eef", "geef", "efor"], "count": ["coll", "check", "f", "cat", "length", "number", "type", "ac", "cache", "parent", "cast", "in", "name", "add", "child", "len", "col", "base", "n", "fail", "ch", "catch", "found", "label", "code", "max", "act", "sum", "stat", "call", "total", "time", "c", "part", "nt", "cc", "depth", "limit", "ind", "cond", "b", "keep", "p", "current", "err", "weight", "ct", "num", "seq", "l", "list", "Count", "size"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n", "idx": 19473, "substitutes": {"data": ["batch", "class", "none", "result", "style", "cache", "array", "media", "DATA", "parent", "window", "ad", "buffer", "valid", "test", "base", "Data", "args", "memory", "code", "index", "input", "draw", "used", "reader", "writer", "next", "xxx", "devices", "da", "missing", "null", "def", "value", "done", "image", "as", "dat", "options", "a", "device", "empty"], "unused": [" unus", "unusing", "umusing", "Unus", "Unavailable", "umus", " unavailable", "Unuse", "Unusing", "nonavailable", " unusing", "nonuse", "Unused", "unuse", "unavailable", "umused", "unus", "nonused", " unuse", "umuse"]}}
{"project": "qemu", "commit_id": "01cd90b641e1aed40cf13a577e6a737af94d55e7", "target": 0, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n", "idx": 19490, "substitutes": {"xendev": [" xendove", "xnddev", "wxendedov", "xendedove", "gendov", "xpendov", "exenderv", "xendsev", "xtentep", "xpenderv", "xedgeev", "zenddev", "xentown", "xndeva", "zendedev", "zendedee", "zendev", "xentev", "genderv", "xendeva", "xendsep", "xentove", "xenddiv", "exendev", "xtenterv", "xtenderv", " xenddev", "exendederv", "wxendedev", "xendedown", "xendedev", "xendove", "xendeddiv", "xEndep", "gendedov", "xtendev", "xenterv", "xndown", "xEndruction", "exendown", "xendown", "xendedep", "xEnderv", "wxendov", "zendee", "xendedruction", "wxenderv", "xtentev", "zendedov", "exendep", "xendedee", "xndev", "xendee", "exendruction", "zendeddev", "xstartdiv", "xentov", "gendedev", "xendruction", "exnddev", "xpendeva", "xedgediv", "xendserv", "xendedov", "xndee", " xendedov", " xendederv", " xendov", "zendov", "genddiv", "xEndev", "xendsruction", " xendown", "xendov", "xenddev", " xenderv", "gendederv", "xstarterv", "xedgeerv", "exendedev", "xtentov", "wxendederv", "xendederv", "xentep", "gendeddiv", "exndev", "xpendev", " xendeddev", "xedgeov", "xtendov", " xendedev", "exendedruction", "xenderv", "wxendev", "wxendedeva", "xentee", "wxendeva", "xstartev", "xndov", "xentdev", "xendedeva", "xendeddev", "exnderv", "gendev", "xnderv", "xstartov", "exndown", "exendedep", "xtendep", "exenddev", "xendep"], "i": ["g", "reply", "phi", "di", "inner", "ri", "xi", "hi", "qi", "ix", "idi", "x", "ci", "eni", "api", "I", "r", "c", "line", "b", "z", "gi", "adi", "a", "ini", "field", "mi", "m", "interface", "cli", "u", "source", "uri", "it", "si", "multi", "ai", "index", "iu", "p", "y", "ui", "yi", "fi", "l", "io", "isi", "\u0438", "ti", "j", "f", "isin", "abi", "ji", "n", "ip", "id", "init", "iv", "o", "lc", "ii", "ind", "ni", "zi", "info", "li", "t", "bi", "mu", "d", "pi", "ij", "slice", "gui", "count", "e", "ie", "v"], "xen_9pdev": ["xen_9fconf", "xen_ninepdevice", "xen_9pcd", "xen_9dadv", "xen_19pvalid", "xen_9pvalid", "xen_ninebadv", "xen_9bpvalid", "xen_9badv", "xen_9dconf", "xen_ninepdef", "xen_8ddevice", "xen_9cconf", "xen_10pdev", "xen_9bdiv", "xen_9pcde", "xen_109ddevice", "xen_8dconf", "xen_9pedef", "xen_9vdem", "xen_109ddev", "xen_975pcomment", "xen_09pdc", "xen_9cdebug", "xen_9puadv", "xen_09fadv", "xen_9pdef", "xen_9dhome", "xen_9cdevice", "xen_ninecdebug", "xen_9lpdevice", "xen_9drad", "xen_9fengine", "xen_9fev", "xen_9pivalid", "xen_09pcd", "xen_nineddevice", "xen_9padv", "xen_9fcd", "xen_9lpmode", "xen_9fpcomment", "xen_975pdev", "xen_9peadv", "xen_9fde", "xen_ninepcmode", "xen_9qdevice", "xen_9fdc", "xen_9ppfail", "xen_9fcomment", "xen_9ldev", "xen_9pdebug", "xen_9ppdev", "xen_9pconf", "xen_9psconf", "xen_9pengine", "xen_9prdev", "xen_9fmode", "xen_9dcd", "xen_9pfail", "xen_19bpdev", "xen_10pcdev", "xen_9psdev", "xen_9fpdev", "xen_09pdevice", "xen_9picomment", "xen_ninebdev", "xen_09fhome", "xen_9ldevice", "xen_ninepde", "xen_9pdevice", "xen_9cpdev", "xen_9pidevice", "xen_9pude", "xen_8pdevice", "xen_9pdiv", "xen_9pev", "xen_9bdev", "xen_9lpengine", "xen_9pde", "xen_9dapp", "xen_09fdevice", "xen_9ddevice", "xen_9pod", "xen_9fapp", "xen_9ddev", "xen_9ffail", "xen_9pcdevice", "xen_9qde", "xen_9qdev", "xen_9pdi", "xen_9pcmode", "xen_9fdef", "xen_nineprad", "xen_ninepconf", "xen_9lpdem", "xen_09phome", "xen_109pdevice", "xen_10papp", "xen_ninedrad", "xen_975fpdev", "xen_09fde", "xen_9fadv", "xen_ninefdef", "xen_9nprad", "xen_9bpdev", "xen_9lpdev", "xen_9pdem", "xen_8prad", "xen_9prcd", "xen_10pcapp", "xen_09fdc", "xen_19bpcd", "xen_109pdev", "xen_109dconf", "xen_9npdevice", "xen_9lconf", "xen_975pvalid", "xen_9pcomment", "xen_9qdi", "xen_09fev", "xen_19pdev", "xen_09pdef", "xen_975fpcomment", "xen_9fvalid", "xen_ninepdiv", "xen_9pidev", "xen_19bpvalid", "xen_9lpdc", "xen_9fdem", "xen_8pdev", "xen_10pcdevice", "xen_09pfail", "xen_ninepcdev", "xen_ninefdev", "xen_9ddebug", "xen_9bpcd", "xen_ninecdev", "xen_9cpdevice", "xen_9vdev", "xen_8dod", "xen_09padv", "xen_ninefdevice", "xen_9npdev", "xen_9psvalid", "xen_9psde", "xen_8drad", "xen_109prad", "xen_09fcd", "xen_9pscd", "xen_ninepdebug", "xen_8ddev", "xen_9pirad", "xen_9prad", "xen_09fdef", "xen_9fdevice", "xen_9pediv", "xen_9frad", "xen_9lrad", "xen_9pudev", "xen_9piconf", "xen_9phome", "xen_9qdef", "xen_9ddef", "xen_9lpdef", "xen_ninepdev", "xen_9papp", "xen_10pdevice", "xen_09pengine", "xen_9dod", "xen_9fdev", "xen_9vengine", "xen_9pehome", "xen_9ppdevice", "xen_09fengine", "xen_9fhome", "xen_109drad", "xen_ninebdiv", "xen_9puev", "xen_9psdebug", "xen_9ppod", "xen_ninecconf", "xen_9ppev", "xen_09fdev", "xen_9dde", "xen_9cdev", "xen_9cprad", "xen_09pdi", "xen_ninecde", "xen_9pedev", "xen_09pev", "xen_09fdi", "xen_9prdevice", "xen_9fdi", "xen_09pde", "xen_09pdem", "xen_9cpconf", "xen_nineddev", "xen_9ddem", "xen_9fdiv", "xen_09ffail", "xen_9pufail", "xen_109pconf", "xen_09pdev", "xen_9cdi", "xen_8pod", "xen_9pcdev", "xen_9ddc", "xen_9pcapp", "xen_9pmode", "xen_19pcd", "xen_ninepmode", "xen_9fod", "xen_ninepadv", "xen_9fpvalid", "xen_9pdc", "xen_975fpvalid", "xen_ninepcdevice", "xen_8pconf", "xen_9cde", "xen_09fdem"], "s": ["g", "server", "f", "session", "sa", "t", "d", "n", "r", "o", "w", "params", "c", "p", "service", "ssl", "b", "fs", "services", "stats", "S", "states", "e", "settings", "spec", "v", "sync", "m"], "fsdev": ["wsconf", "nsdev", "dsdef", "nsDev", "wsdef", "nsdef", "wsDev", "fsconf", "dsdev", "wsdev", "dsconf", "nsconf", "dsDev", "fsdef", "fsDev"], "str": ["dr", "inner", "txt", "f", "sp", "name", "temp", "rs", "style", "cur", "kr", "ss", "orig", "STR", "exec", "sr", "req", "wr", "tr", "obj", "enc", "stri", "cl", "h", "r", "code", "ocr", "dict", "fr", "doc", "input", "hr", "st", "pass", "iter", "read", "ext", "c", "Str", "var", "sl", "cr", "er", "z", "sta", "try", "err", "ct", "strike", "e", "expr", "text", "arr", "list", "sc", "ctr", "bl", "pr", "br"], "ring_order": ["ringpoffset", "ring__order", " ring_offset", "ring__info", "ringpinfo", "ringporder", "ring_offset", "ringparray", "ring__array", " ring_array", " ring_info", "ring__offset", "ring_info", "ring_array"]}}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n", "idx": 19492, "substitutes": {"s": ["g", "is", "cs", "self", "client", "f", "session", "ops", "sys", "http", "ps", "bs", "new", "u", "source", "js", "t", "sq", "scope", "d", "ns", "n", "site", "obj", "i", "h", "r", "space", "o", "us", "c", "p", "sb", "service", "ssl", "b", "xs", "sup", "services", "stats", "S", "sg", "ses", "e", "sv", "settings", "os", "sym", "spec", "sync", "m"], "op": ["ops", "operator", "option", "http", "sp", "operation", "jp", "wp", "cmd", "type", "node", "inst", "OP", "exec", "prev", "root", "ip", "obj", "or", "opus", "cop", "init", "pp", "ob", "oop", "o", "top", "oper", "block", "hop", "app", "oc", "p", "ic", "up", "Op", "vert", "pop", "prop", "num", "omp", "cmp", "opp", "opt", "mp", "open", "arg", "info"], "args": ["g", "ams", "changes", "Args", "cs", "pres", "flags", "ics", "ms", "ops", "acl", "sp", "ps", "ars", "extra", "ids", "js", "parts", "vals", "py", "ans", "ns", "obj", "config", "ips", "parse", "dict", "vs", "data", "ig", "params", "loc", "gs", "atts", "oc", "p", "uments", "pos", "points", "err", "stats", "objects", "ass", "states", "ants", "fields", "options", " arguments", "ins", "arr", "arg", "ds", "ras"], "dst": ["ndST", "ldrest", "frc", "datsts", " drc", "jost", "ddist", "bdost", "dsts", "datst", "jsrc", "indrest", "datST", "ldst", "Dsp", "dstr", "dost", "idsc", "bdst", "fsc", "dsp", "psp", "bdstr", "ldost", "ydst", "indst", "iddest", "adst", "idput", "hsp", " dsrc", "adset", "dput", " ddist", "Dsrc", " dsts", " dsth", "frest", "hST", "Dput", "idst", " dstr", "hdest", "fsts", "prc", "nsp", "dST", " ddest", "nrest", "ndsts", "bdsc", "hst", "ydsc", " drest", "nst", "DST", " dST", "addest", "jST", "idset", "disc", "ndst", "dbl", "pst", "fdest", "nsth", "dset", "jstr", "idsp", "ydset", "adST", "fST", "drest", "Dsts", "jsc", "datsth", "didist", " dsp", "diost", " dost", "prest", "idrc", "dist", "dsc", "adsc", "idsts", "fbl", "adost", "yddest", "dsth", " dsc", "Dst", "ndsth", "indsth", "indsp", "adsrc", "fst", "addist", "idbl", "drc", "ldsc", "jst", " dbl", "ddest", "datput", "fsrc", "dsrc", "fsp", "idST"], "src": ["core", "rec", "ruby", "proc", "bh", "scope", "sr", "low", "support", "r", "st", "stream", "RC", "rl", "ssl", "sl", "null", "dep", "attr", "sec", "sub", "usb", "origin", "rob", "server", "http", "inst", "source", "req", "site", "lib", "img", "usr", "params", "sb", "fp", "desc", "url", "obl", "filename", "fc", "host", "sync", "sn", "rest", "uc", "bc", "rs", "sq", "conv", "config", "ource", "iv", "ctx", "hr", "target", "rb", "sup", "impl", "dist", "sel", "rc", "cb", "share", "spec", "secure", "resource", "sys", "supp", "new", "cur", "front", "obj", "cpp", "loc", "tmp", "usc", "cv", "ptr", "hh", " dest", "gz", "dest", "cmp", "reverse", "sc"], "mask": ["bit", "skip", "flags", "scale", "scan", "copy", "map", "length", "result", "ck", "match", "allow", "type", "cache", "asm", "cast", "ban", "clean", "shadow", "pad", "mark", "reg", "tag", "info", "stack", "bits", "max", "qa", "index", "code", "pack", "block", "target", "sum", "cover", "cap", "conf", "iq", "sk", "cost", "Mask", "patch", "depth", "black", "key", "filter", "delay", "flag", "comment", "sign", "hack", "weight", "arch", "image", "lock", "count", "shape", "ask", "fix", "bug", "ack", "size", "field", "feature", "offset"]}}
{"project": "FFmpeg", "commit_id": "3594554a064d76e3514fab9781c0e63ea9e08ea9", "target": 0, "func": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n  /* VIS-specific optimizations */\n\n  int accel = vis_level ();\n\n  const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n  if (accel & ACCEL_SPARC_VIS) {\n\n      if (avctx->bits_per_raw_sample <= 8 &&\n\n          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {\n\n          c->idct_put = ff_simple_idct_put_vis;\n\n          c->idct_add = ff_simple_idct_add_vis;\n\n          c->idct     = ff_simple_idct_vis;\n\n          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n      }\n\n\n\n      if (!high_bit_depth) {\n\n      c->put_pixels_tab[0][0] = MC_put_o_16_vis;\n\n      c->put_pixels_tab[0][1] = MC_put_x_16_vis;\n\n      c->put_pixels_tab[0][2] = MC_put_y_16_vis;\n\n      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;\n\n\n\n      c->put_pixels_tab[1][0] = MC_put_o_8_vis;\n\n      c->put_pixels_tab[1][1] = MC_put_x_8_vis;\n\n      c->put_pixels_tab[1][2] = MC_put_y_8_vis;\n\n      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;\n\n\n\n      c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;\n\n      c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;\n\n      c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;\n\n      c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;\n\n\n\n      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;\n\n      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;\n\n      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;\n\n      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;\n\n\n\n      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;\n\n      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;\n\n      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;\n\n      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;\n\n      }\n\n  }\n\n}\n", "idx": 19494, "substitutes": {"c": ["g", "cs", "cd", "cp", "cm", "dc", "coll", "f", "pc", "com", "uc", "bc", "ac", "nc", "u", "ci", "cur", "cache", "t", "d", "n", "col", "ch", "enc", "config", "cl", "h", "co", "r", "con", "ctx", "ec", "lc", "w", "ca", "cf", "oc", "conf", "ce", "p", "s", "cc", "ic", "k", "vc", "b", "cr", "z", "tc", "cit", "ct", "cb", "rc", "mc", "e", "cmp", "l", "ctrl", "C", "cu", "xc", "sc", "fc"], "avctx": ["navcp", "afctx", " avloc", "avconn", "navxc", "abcontext", "abctx", " avxc", "navloc", "avcmp", "airctl", " avcontext", "avcontext", "afconn", "avloc", " avcmp", "abctl", "AVctx", "avctl", "avcp", "AVcmp", "AVcontext", "aircmp", "AVcp", "airctx", "avxc", " avconn", "navctx", "abcmp", "afctl", "aircontext", "afxc", "navconn", "navcontext", " avcp", "afcmp", "AVloc", "afloc", "afcontext"]}}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc(VP8Context *s, int luma,\n\n            uint8_t *dst, uint8_t *src, const VP56mv *mv,\n\n            int x_off, int y_off, int block_w, int block_h,\n\n            int width, int height, int linesize,\n\n            vp8_mc_func mc_func[3][3])\n\n{\n\n    if (AV_RN32A(mv)) {\n\n        static const uint8_t idx[3][8] = {\n\n            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,\n\n                                        // also function pointer index\n\n            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required\n\n            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels\n\n        };\n\n        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];\n\n        int my = (mv->y << luma)&7, my_idx = idx[0][my];\n\n\n\n        x_off += mv->x >> (3 - luma);\n\n        y_off += mv->y >> (3 - luma);\n\n\n\n        // edge emulation\n\n        src += y_off * linesize + x_off;\n\n        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {\n\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n\n                                block_w + idx[1][mx], block_h + idx[1][my],\n\n                                x_off - mx_idx, y_off - my_idx, width, height);\n\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n        }\n\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n\n    } else\n\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n}\n", "idx": 19538, "substitutes": {"s": ["g", "cs", "self", "server", "sf", "f", "session", "ops", "sys", "sp", "http", "secondary", "rs", "js", "south", "t", "ss", "sq", "d", "ns", "n", "site", "si", "private", "r", "space", "w", "gs", "conf", "c", "p", "sb", "service", "ssl", "b", "sl", "su", "fs", "services", "stats", "S", "sg", "ses", "e", "request", "a", "spec", "qs", "sync", "m"], "luma": ["duma", "lamin", " lama", "dumen", " lumo", "lcuma", "pluma", "Luca", "eluca", " lumen", " lta", "lumen", "plaea", "flasm", " lamin", "elta", "sluca", "fluma", " luna", "Luma", "elama", "muca", "mama", " lasm", " luca", "litama", "Lama", "lituma", "muna", "slaga", "laos", "lcasm", "lcamin", "duna", "lituna", "muma", "laea", "lcama", "flama", "Lta", "eluma", "lama", "plaos", "lta", "flamin", "litumen", "sluna", "litaos", "luca", "lasm", "lumo", "sluma", "maos", "laga", "plama", "maga", "litaea", "dumo", "maea", "luna", " laga", "litumo"], "dst": [" dsts", " dsc", "Dst", "bsts", "idost", "bst", "dbl", "idst", "Dsc", "wbl", "idft", "dsts", "fsts", "fost", "fst", "Dsts", "wsp", "nsp", "wst", "Dsp", " dsp", "bsp", "dost", "idsc", "fsc", "dsp", " dft", " dost", "nsts", "fft", "dft", "dsc", "nst", "wsts", "nsc", "fsp", "fbl", "bbl"], "src": ["sn", "cdn", "gin", "output", "sec", "ruby", "http", "rest", "inst", "uc", "rs", "source", "sq", "sr", "req", "rel", "border", "syn", "rib", "low", "lib", "config", "path", "irc", "img", "input", "wx", "replace", "rss", "ls", "ctx", "target", "stream", "loc", "rb", "sb", "channel", "sci", "gl", "tmp", "ssl", "origin", "sl", "sur", "slice", "dist", "sel", "send", "gz", "rc", "url", "cb", "dest", "attr", "gb", "filename", "zx", "seq", "href", "sub", "sc", "rob", "bg", "background", "sync", "use"], "mv": [" mw", "amq", "amf", "cmh", "Mself", "amj", "pq", " mov", "mrv", "mrvc", "cmx", "hvs", "vver", "mvc", "rv", "mx", "pv", "pf", "Mw", " mver", "hv", "pvs", "mf", " mh", "cmver", "Mv", "mq", "mh", "mrver", "hvc", " mc", "mrvs", "mself", "Mc", " mx", "Mb", "rb", "pj", "mvs", "Mf", " mself", "Mj", "vov", "mj", "vx", "hver", "mb", "pvc", "hvp", " mvc", "mw", "Mx", " mvs", "rc", "mvp", " mb", "mc", " mvp", "mver", "amv", "vv", "vself", "pvp", "cmv", "rw", "Mov", "vh", "mov", "Mq"], "x_off": ["xPmode", "x_online", "X_Off", "x__OFF", "x_on", "y_mode", "xPno", "x_offs", " x_offs", "x__ff", "x_Off", "y_no", " x_offset", "x_mode", "x_error", "tx_off", "x_fail", "X_on", "x67error", " x_online", "X_off", "tx67offs", "X_OFF", "tx67off", "x_offset", "tx67error", " x_OFF", " x_ff", "x__online", "x_OFF", "tx_error", "x_ff", " x_fail", "x_no", "x67offs", "x67off", "x__off", "tx_offs", "xPoff"], "y_off": ["y_obj", " y_left", "ry_off", "y_OFF", "yPoff", "my_off", "y_ON", "x_offs", "ry_over", " y_ON", "yPobj", "yPleft", "x_Off", "y67dead", "y_left", "yallleft", "my_on", "yalloff", "x_error", "yPOff", "y67ON", "x_left", "my_max", " y_down", " y_offs", "y_dead", "y_max", "yalloffs", "y_down", " y_obj", " y_OFF", "y67down", "y_on", "y_over", "ry_OFF", "ry_offs", "x_OFF", "y_error", "y_offs", "yallOFF", "y_Off", "y67off", "yPoffs", " y_dead"], "block_w": ["blockJh", "blocklexw", "block_b", "blockJw", "block_wall", " block_v", "block6w", "byte_we", "block67tw", " block_b", "block_v", "block6h", "blocklexb", "byte_h", " block_wall", "block6wall", "block_tw", "blocklextw", "blocklexh", "blockJwe", "block_we", "blockshwall", "block6v", "block67w", " block_tw", "block67we", "blockshh", "blockshv", "byte_w", "block_wt", "block67h", "blockshw", "byte_wt", "block67wt", "blockJwt", "block67b"], "block_h": ["block27h", "blockrictbh", "block1h", "block_n", "block17h", "block67w", "blockrictsh", " block_m", "block1w", "block_ht", "blockricth", "blocklexsh", "Block_h", "block27hs", "Block_n", "block_sh", "block27n", "block67hs", "block17bh", "block67n", "blocklexht", " block_bh", "blockrictheight", "Block_w", " block_ht", "block1m", "blocklexbh", "blocklexh", "block1bh", "block_hs", " block_height", "block17w", "blockrictht", "block17m", "block_height", "block27w", "block_m", " block_sh", "blockrictw", "block67h", "Block_hs", "block_bh"], "height": ["ty", "alpha", "layout", "length", "resolution", "holes", "style", "x", "Height", "window", "dim", "rh", "gap", "view", "bottom", "rank", "th", "h", "build", "padding", "block", "wrap", "upper", "volume", "w", "dy", "depth", "y", "han", "gh", "ths", "hh", "thin", "density", "pull", "shape", "row", "hold", "hang", "history", "rows", " heights", "crop", "size"], "linesize": ["linesIZE", " linesizing", " linesIZE", "inesIZE", "pagesization", "line8", "lins8", "timesizing", "linerssize", " linesization", "pagesized", "linerserial", "linesgment", "worksizer", "elinesize", "linksization", "elinesIZE", "linksized", "elineserial", "lins\n", "linesizes", "linersize", "pagesize", "pagesizing", "inesizing", "insize", "limitsIZE", " linesizer", "limitsizer", "linersized", "linkssize", "lines\n", "pagesIZE", "linksIZE", "worksize", "limitsizing", "lineserial", "linedgment", "insIZE", "worksizing", "linessize", "linksizer", " lines\n", "inesization", "linksizes", "lesiz", "timesize", "linersizes", "inesize", "linersizer", "linksize", "elinesizer", "linesiz", " lineserial", "linesization", "pagessize", "linersIZE", "insizing", "worksIZE", "timesIZE", "lesizer", "line\n", " lines8", "lesize", "linksiz", "limitsize", "linedizer", "insization", " linesiz", "linesizer", "lesization", "linesizing", "timesization", "linedizes", "linksgment", "lines8", "pagesizer", "linedize", "linersgment", "linesized"], "mc_func": ["mc_fn", "mcallfun", "mc5cc", "MC_func", "mc2function", "MC_unc", "mc5unc", "pc_fun", "mcallfunction", "mc_unc", "MC2function", "MC2cc", "mc5func", "mc5fn", "pc_callback", "mc2fun", "MC_fun", "pc_func", "mc2cc", "MC_cc", "mc_function", "mc_cc", "pc_function", "mcallfunc", "mc2func", "MC2func", "mc_fun", "mc_callback", "MC_function", "MC2fun", "MC_fn", "mcallcallback"], "idx": ["IDxc", "idns", " idxc", " idns", "namexes", " idf", "Idx", "sidy", "Idxs", "sidw", "IDX", "idsx", "Idf", "idsX", "aidz", "idsxc", "Idz", "idxs", "idsy", "aidX", "idf", "Idxc", "Idxes", "idex", "sidx", "IdX", " idxs", "Idy", "namexs", "IDw", "idey", "Idw", "IDx", "aidy", "idxc", "IDy", "namey", "sidns", "sidxc", " idz", "IDz", "namex", "idxes", "ideX", "idw", "idX", "idsxs", "sidX", "idy", "IDxs", "IDns", " idy", "sidxs", "idsf", " idX", "idexes", "idz", "idsxes", "aidx"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554, "substitutes": {"dev": ["self", "prom", "grad", "proc", "inst", "mod", "dd", "sh", "req", "d", "obj", "ch", "gd", "sd", "od", "dt", "private", "iv", "dom", "data", "Dev", "w", "gr", "wd", "conf", "de", "def", "dem", "err", "priv", "prof", "attr", "ev", "pro", "device", "rad", "debug", "comp", "md", "ver", "br"], "prop": ["val", "f", "pt", "proc", "type", "name", "op", "root", "property", "obj", "r", "pb", "data", "ctx", "ref", "p", "pos", "tmp", "prot", "def", "pointer", "properties", "priv", "dep", "phy", "Prop", "attr", "pred", "pro", "device", "lit", "rt", "part", "pr", "info"], "str": ["dr", "val", "pt", "sp", "name", "rs", "cur", "STR", "sr", "test", "tr", "obj", "enc", "stri", "r", "code", "fr", "data", "strings", "hr", "st", "ext", "Str", "cr", "err", "attr", "sec", "expr", "text", "arr", "spec", "part", "ctr", "pr", "br"], "ptr": ["dr", "val", "pt", "src", "sp", "pc", "length", "inst", "buf", "t", "pad", "py", "tr", "inter", "len", "fd", "spr", "r", "Ptr", "fr", "addr", "st", "loc", "ref", "nt", "p", "fp", "pos", "func", "prot", "pointer", "err", "vt", "tty", "rt", "pr", "offset"], "fmt": ["tfprintf", "sftr", "Fnt", "Fmt", "frrt", "sfrt", " fmbol", "frmt", "frt", "tfrt", "defnt", " frt", "sfmt", "Frt", "fnt", "sfMT", "fMT", "defmt", "ftr", "frMT", "tfmt", "tfMT", "Ftr", "frtr", "FMT", "Fprintf", "defMT", " fMT", " fnt", "defmbol", "Fmbol", "fmbol"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "DECLARE_LOOP_FILTER(mmxext)\n\nDECLARE_LOOP_FILTER(sse2)\n\nDECLARE_LOOP_FILTER(ssse3)\n\nDECLARE_LOOP_FILTER(sse4)\n\n\n\n#endif /* HAVE_YASM */\n\n\n\n#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT\n\n\n\n#define VP8_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \\\n\n    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)\n\n\n\n#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][1] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][2] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT\n\n\n\n\n\nav_cold void ff_vp8dsp_init_x86(VP8DSPContext* c)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        c->vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;\n\n        c->vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;\n\n#if ARCH_X86_32\n\n        c->vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;\n\n        c->vp8_idct_add       = ff_vp8_idct_add_mmx;\n\n        c->vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;\n\n#endif\n\n        c->put_vp8_epel_pixels_tab[1][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;\n\n\n\n#if ARCH_X86_32\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;\n\n#endif\n\n    }\n\n\n\n    /* note that 4-tap width=16 functions are missing because w=16\n\n     * is only used for luma, and luma is always a copy or sixtap. */\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        VP8_MC_FUNC(2, 4, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, mmxext);\n\n#if ARCH_X86_32\n\n        VP8_LUMA_MC_FUNC(0, 16, mmxext);\n\n        VP8_MC_FUNC(1, 8, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(1,  8, mmxext);\n\n\n\n        c->vp8_v_loop_filter_simple   = ff_vp8_v_loop_filter_simple_mmxext;\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;\n\n#endif\n\n    }\n\n\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        c->vp8_idct_add                         = ff_vp8_idct_add_sse;\n\n        c->vp8_luma_dc_wht                      = ff_vp8_luma_dc_wht_sse;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags) && (cpu_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, sse2);\n\n        VP8_MC_FUNC(1, 8, sse2);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, sse2);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, sse2);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_sse2;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        c->vp8_idct_dc_add4y          = ff_vp8_idct_dc_add4y_sse2;\n\n\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_sse2;\n\n\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_sse2;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse2;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, ssse3);\n\n        VP8_MC_FUNC(1, 8, ssse3);\n\n        VP8_MC_FUNC(2, 4, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, ssse3);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_ssse3;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;\n\n    }\n\n\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        c->vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;\n\n\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_sse4;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 19557, "substitutes": {}}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int get_bat (CPUState *env, mmu_ctx_t *ctx,\n\n                    target_ulong virtual, int rw, int type)\n\n{\n\n    target_ulong *BATlt, *BATut, *BATu, *BATl;\n\n    target_ulong base, BEPIl, BEPIu, bl;\n\n    int i;\n\n    int ret = -1;\n\n\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    switch (type) {\n\n    case ACCESS_CODE:\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n        break;\n\n    default:\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n        break;\n\n    }\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    base = virtual & 0xFFFC0000;\n\n    for (i = 0; i < 4; i++) {\n\n        BATu = &BATut[i];\n\n        BATl = &BATlt[i];\n\n        BEPIu = *BATu & 0xF0000000;\n\n        BEPIl = *BATu & 0x0FFE0000;\n\n        bl = (*BATu & 0x00001FFC) << 15;\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                    \" BATl 0x\" ADDRX \"\\n\",\n\n                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                    *BATu, *BATl);\n\n        }\n\n#endif\n\n        if ((virtual & 0xF0000000) == BEPIu &&\n\n            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||\n\n                (msr_pr == 1 && (*BATu & 0x00000001))) {\n\n                /* Get physical address */\n\n                ctx->raddr = (*BATl & 0xF0000000) |\n\n                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 19567, "substitutes": {"env": ["console", "chal", "server", "inet", "eu", "txt", "operator", "cal", "proc", "inst", "nc", "global", "et", "conn", "eni", "end", "scope", "exec", "np", "Environment", "enc", "config", "db", "dt", "code", "iv", "equ", "vs", "iss", "ec", "esp", "exc", "qt", "eur", "ext", "ea", "ou", "cv", "her", "inv", "current", "assets", "en", "context", "ne", "viron", "ev", "e", "network", "dat", "environment", "que", "event", "manager", "v", "oa"], "ctx": ["cp", "client", "grad", "src", "proc", "inst", "cmd", "bc", "nc", "conn", "sq", "scope", "exec", "connection", "conv", "obj", "hw", "cms", "config", "cl", "qa", "cas", "qq", "ec", "lc", "exc", "qt", "loc", "ca", "cf", "fp", "cc", "cv", "sci", "vc", "tx", "Context", "context", "ct", "rc", "cb", "fn", "ctrl", "environment", "sc"], "virtual": ["console", "server", "resource", "setting", "initial", "output", "component", "visible", "lv", "intel", "hard", "enabled", "actual", "global", "net", "physical", "Virtual", "NV", "uri", "front", "connection", "real", "valid", "view", "optional", "version", "hidden", "config", "vid", "bitcoin", "virt", "protected", "visual", "external", "iv", "binary", "volt", "target", "total", "variable", " Virtual", "format", "final", "mobile", "active", "public", "unit", "current", "mini", "vert", "fake", "context", "vm", "ne", "fi", "dirty", "text", "required", "environment", "remote", "lit", "special", "v", "complex", "plain"], "rw": ["self", "rec", "result", "nc", "res", "ive", "wire", "lr", "ip", "ib", "iv", "rt", "ig", "w", "rb", "ref", "nt", "fp", "rl", "vc", "ih", "weight", "vt", "rc", "ww", "fe", "io", "outer"], "type": ["bit", "val", "class", "ty", "resource", "rule", "f", "none", "kind", "name", "style", "op", "parent", "source", "Type", "level", "t", "error", "py", "test", "valid", "len", "version", "site", "config", "id", "types", "user", "state", "status", "code", "by", "full", "block", "target", "ping", "typ", "ype", "call", "pre", "loc", "format", "ref", "time", "file", "var", "y", "unit", "pe", "role", "function", "value", "action", "TYPE", "like", "port", "model", "open", "lit", "method", "event", "part", "size", "info"], "BATlt": ["MATl", "BATnat", "MATnat", "BTLT", "ATut", "MATLT", " BATli", "ATLT", "BGl", "NATlt", "BGLT", "NATl", "ATli", "ATelt", "BTlt", "NATLT", " BATnat", "NATelt", "BTli", "BGlt", "BTut", "BATLT", "BATelt", "BGnat", "MATut", "BATli", " BATLT", "BTl", "ATlt", "MATlt", "ATl", "BTelt"], "BATut": ["MATUT", "MATlet", "BGUT", "MATutil", "ATlit", "BTLT", "ATut", "MATuint", "MATu", "MATLT", "BATUT", "BATuint", "BATlett", "BATlit", "BGLT", "BITutt", "BITut", "BITlit", "MATlett", "BTlt", "BTuint", " BATutil", "BTlet", "ATu", "ATutil", "BGlt", "BATutil", "BTut", "BATLT", "BITlt", "MATut", "BGut", "BGlett", "ATlt", "BATutt", "BTutt", "BTlit", "BATlet", "MATlt", "BGlet", "BTUT", "BGuint", "BTlett", "ATutt"], "BATu": ["BATou", "MATl", "BTt", "BATU", "BITur", "ATui", "MATu", "CHATul", "BITu", "BATur", "BATus", "BATlu", "BTus", "MATlu", "CHATu", "BTur", " BATt", "ATur", "BITut", "CHATou", "BUSur", "BUSu", " BATou", "NATul", " BATui", "NATu", "BTlu", "ATu", "NATur", "CHATut", "BTut", "ATul", " BATul", "MATus", "BTu", " BATU", "BATt", "BTui", "MATut", "BTul", "BUSU", "BTl", " BATur", "MATou", "BITlu", "APPus", "APPui", "NATui", "BATul", "APPu", "MATur", "MATt", "BUSui", "BTU", "BATui", "APPul", "MATul", "MATui"], "BATl": ["g", "BITL", "MATl", "MATu", " BATn", "BITu", "ATL", "BATv", "MATn", " BATL", "_", "r", "ATu", "addr", " BATv", "ATul", " BATul", "BTn", "BTu", "MATL", "MATv", "BITl", "s", "BTl", "BITv", "BATn", "ATl", "BATL", "BATul", "MATul"], "base": ["local", "bit", "val", "core", "is", " unit", "scale", " bases", "name", "bc", "et", "physical", "soft", "bi", "Virtual", "it", "buffer", "end", "boot", "ip", "si", "config", "id", "protected", " bias", " baseline", "basic", "live", "file", "object", "bas", "al", " v", "unit", "b", "rc", "area", " mini", "v", " last", " fe", "Base", "bin", "BL"], "BEPIl": ["BEPUrl", "BepNL", "BMPEl", " BIPIns", "BTPIl", "BEMIns", "BEMNL", " BTPIl", "BEEPIl", " BIPIl", " BIPNL", "BEMIl", "BepUrl", " BEPNL", " BIPUrl", "BTPInc", "BepEl", " BEPLt", "BEPAlt", "BNPEl", "BepAlt", " BEPEl", " BEPExc", "BNPIl", " BEPUrl", "BepInc", "BTPLt", "BepEntity", " BEPEntity", "BEPEl", "BEMUrl", "BTPEntity", "BepLt", " BTPInc", " BTPEntity", "BEPLt", "BMPExc", " BEPIns", " BTPLt", "BEPExc", "BepIl", " BEPAlt", "BMPAlt", "BIPUrl", "BNPExc", " BMPIl", "BNPAlt", "BEPEntity", "BEPIns", "BEPNL", "BIPNL", "BEEPEntity", "BIPIl", "BepExc", "BIPIns", "BEEPLt", " BMPExc", "BEPInc", "BEEPInc", " BEPInc", " BMPEl", "BMPIl", "BepIns", " BMPAlt"], "BEPIu": ["BMPIIui", "BEPIul", "BEPIIu", "BEPUu", "BEPUui", "BEPSIu", "BEPIIul", "BEPSIq", "BEPIIut", "BECIul", "BEPIut", "BECIIul", "BMPIou", "BMPIui", "BAPIue", "BECIIu", "BMPIIcu", "BAPIo", "BEPIue", "BEPIcu", "BEPIDEu", "BAPIu", "BEPIq", "BMPIcu", "BEPKIu", "BEPITcu", "BAPSIq", "BEPIDEut", "BEPEu", "BEPEq", "BMPIIu", "BEPIui", "BEPIIui", "BEPSIo", "BEPNq", "BECIu", "BEPEo", "BEPIo", "BEPKIul", "BEPIIcu", "BEPITui", "BEPSIue", "BEPEue", "BEPIDEul", "BEPNo", "BAPSIu", "BEPITou", "BEPITu", "BEPIDEcu", "BEPIIou", "BAPIq", "BAPSIue", "BECIIcu", "BMPIu", "BAPSIo", "BECIut", "BMPIIou", "BECIcu", "BEPKIut", "BEPUou", "BEPNue", "BEPKIcu", "BEPIou", "BECIIut", "BEPNu", "BEPUcu"], "bl": ["ble", "val", " Bl", "yl", "pt", "ll", "iol", "ill", "li", "bh", "el", "ly", "isl", "rel", " BL", "Bl", "kl", "len", "ml", "lu", "cl", "pl", "label", "pb", "il", "ib", "eb", "block", "dl", "typ", "nl", "fl", "abl", "loc", "sil", "ld", "rl", "gl", "sl", "ali", "lock", "obl", "tl", "bel", "lit", "blast", "lb", "bg", "BL"], "i": ["is", "phi", "di", "uli", "f", "ri", "xi", "hi", "x", "u", "ix", "qi", "ci", "li", "in", "t", "ji", "end", "it", "mu", "eni", "mi", "n", "ip", "I", "si", "pi", "multi", "id", "h", "r", "index", "chi", "ai", "iu", "ii", "c", "p", "y", "gu", "b", "z", "mini", "m", "ui", "ni", "gi", "fi", "yi", "anti", "e", "adi", "l", "start", "io", "ini", "out", "v", "ti", "j", "info"]}}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "func": "static void *migration_thread(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    /* Used by the bandwidth calcs, updated later */\n\n    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    int64_t initial_bytes = 0;\n\n    int64_t max_size = 0;\n\n    int64_t start_time = initial_time;\n\n    int64_t end_time;\n\n    bool old_vm_running = false;\n\n    bool entered_postcopy = false;\n\n    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */\n\n    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_savevm_state_header(s->to_dst_file);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        /* Now tell the dest that it should open its end so it can reply */\n\n        qemu_savevm_send_open_return_path(s->to_dst_file);\n\n\n\n        /* And do a ping that will make stuff easier to debug */\n\n        qemu_savevm_send_ping(s->to_dst_file, 1);\n\n\n\n        /*\n\n         * Tell the destination that we *might* want to do postcopy later;\n\n         * if the other end can't do postcopy it should fail now, nice and\n\n         * early.\n\n         */\n\n        qemu_savevm_send_postcopy_advise(s->to_dst_file);\n\n    }\n\n\n\n    qemu_savevm_state_begin(s->to_dst_file, &s->params);\n\n\n\n    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;\n\n    current_active_state = MIGRATION_STATUS_ACTIVE;\n\n    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n\n\n    trace_migration_thread_setup_complete();\n\n\n\n    while (s->state == MIGRATION_STATUS_ACTIVE ||\n\n           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        int64_t current_time;\n\n        uint64_t pending_size;\n\n\n\n        if (!qemu_file_rate_limit(s->to_dst_file)) {\n\n            uint64_t pend_post, pend_nonpost;\n\n\n\n            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,\n\n                                      &pend_post);\n\n            pending_size = pend_nonpost + pend_post;\n\n            trace_migrate_pending(pending_size, max_size,\n\n                                  pend_post, pend_nonpost);\n\n            if (pending_size && pending_size >= max_size) {\n\n                /* Still a significant amount to transfer */\n\n\n\n                if (migrate_postcopy_ram() &&\n\n                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&\n\n                    pend_nonpost <= max_size &&\n\n                    atomic_read(&s->start_postcopy)) {\n\n\n\n                    if (!postcopy_start(s, &old_vm_running)) {\n\n                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;\n\n                        entered_postcopy = true;\n\n                    }\n\n\n\n                    continue;\n\n                }\n\n                /* Just another iteration step */\n\n                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);\n\n            } else {\n\n                trace_migration_thread_low_pending(pending_size);\n\n                migration_completion(s, current_active_state,\n\n                                     &old_vm_running, &start_time);\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (qemu_file_get_error(s->to_dst_file)) {\n\n            migrate_set_state(&s->state, current_active_state,\n\n                              MIGRATION_STATUS_FAILED);\n\n            trace_migration_thread_file_err();\n\n            break;\n\n        }\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        if (current_time >= initial_time + BUFFER_DELAY) {\n\n            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -\n\n                                         initial_bytes;\n\n            uint64_t time_spent = current_time - initial_time;\n\n            double bandwidth = (double)transferred_bytes / time_spent;\n\n            max_size = bandwidth * migrate_max_downtime() / 1000000;\n\n\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;\n\n\n\n            trace_migrate_transferred(transferred_bytes, time_spent,\n\n                                      bandwidth, max_size);\n\n            /* if we haven't sent anything, we don't want to recalculate\n\n               10000 is a small enough number for our purposes */\n\n            if (s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 19574, "substitutes": {"opaque": ["oppac", "ophole", "opque", "OPaque", "operec", "opaques", "opec", " opec", "paque", "operac", " opac", "OPhole", "OPacity", "oppque", "oppaque", "phole", "opacity", "pacity", " opque", " ophole", "OPaques", "operque", " opacity", "oppec", " opaques", "operaque", "opac", "paques"], "s": ["g", "is", "cs", "server", "sf", "f", "sys", "aws", "http", "ps", "secondary", "new", "ds", "rs", "source", "js", "south", "t", "ss", "sq", "scope", "d", "ns", "site", "si", "args", "i", "state", "storage", "submit", "h", "your", "ls", "es", "o", "w", "gs", "conf", "side", "c", "p", "sb", "ts", "service", "ks", "ssl", "b", "sl", "y", "sie", "su", "fs", "services", "stats", "S", "states", "sg", "ses", "settings", "os", "l", "sym", "e", "a", "sets", "serv", "hs", "spec", "qs", "sync", "m"], "end_time": ["end_offset", "start_money", "end_money", "end\u00b7money", "end\u00b7time", "end___time", "end___money", "end_size", "end___size", "start_time", "start_size", "end___offset", "start_offset", "end\u00b7size", "end\u00b7offset"], "current_time": ["current67mode", "current_times", "reported_mode", "reported_time", "current00time", "current_mode", "reported_speed", "reported_times", "current67speed", "current67time", "current_speed", "current00mode", "current67times", "current00speed", "current00times"], "pending_size": ["pended_time", "pending_bytes", "pended_size", "pending_time", "pended_page", "pending_page", "pended_bytes"], "pend_post": ["pend00post", "pend00pre", "end_post", "pend2posts", "end_posts", "pend_posts", "pend_type", "end_type", "pend2post", "pend00type", "pend_pre", "pend2pre", "end_pre", "pend2type", "pend00posts"], "pend_nonpost": ["pend_nonpadding", "pend_nonproc", "pend_prepost", "pend_prepadding", "pend_preproc", "pend_nonupload", "pend_unpost", "pend_unproc", "pend_unupload", "pend_unpadding", "pend_preupload"]}}
{"project": "qemu", "commit_id": "b6954712abea03afd686b724060f9873e2c61f2b", "target": 0, "func": "void replay_input_event(QemuConsole *src, InputEvent *evt)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        /* Nothing */\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_add_input_event(qapi_clone_InputEvent(evt));\n\n    } else {\n\n        qemu_input_event_send_impl(src, evt);\n\n    }\n\n}\n", "idx": 19576, "substitutes": {"src": ["sys", "proc", "http", "inst", "node", "bc", "rs", "source", "bh", "req", "hub", "lib", "support", "img", "ipl", "iv", "ctx", "target", "loc", "rb", "sync", "sb", "gl", "rl", "func", "vc", "socket", "sel", "rc", "url", "cb", "gb", "dest", "scenes", "scene", "sth", "sc", "rob", "bg", "comp", "host"], "evt": ["evl", "epl", "Evts", "evert", "epp", "ervp", "Evd", "ect", "Evv", "epts", "ervt", "evv", "ept", "epv", "ektt", "epc", "ekt", "ekp", "Evt", "Evc", "evp", "everc", "ervc", "Evl", "evd", "ecd", "eptt", "evc", "everl", "evts", "ervtt", "epd", "ecv", "evtt", "ekc", "ecc", "everts"]}}
{"project": "FFmpeg", "commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "target": 1, "func": "static inline unsigned int get_uint(ShortenContext *s, int k)\n\n{\n\n    if (s->version != 0)\n\n        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);\n\n    return get_ur_golomb_shorten(&s->gb, k);\n\n}\n", "idx": 19593, "substitutes": {"s": ["cs", "self", "sf", "f", "sys", "aws", "ops", "session", "ps", "u", "ds", "rs", "js", "in", "t", "ss", "sq", "sr", "ns", "si", "args", "storage", "ls", "es", "o", "ctx", "gs", "c", "p", "sb", "ts", "service", "ssl", "sup", "su", "fs", "services", "stats", "S", "ges", "sg", "ses", "e", "sv", "sets", "sym", "a", "spec", "sync", "settings"], "k": ["g", "kn", "kk", "f", "get", "length", "kind", "x", "u", "K", "q", "d", "ku", "dk", "n", "i", "id", "ik", "o", "w", "ak", "sk", "kick", "ke", "p", "key", "ks", "kw", "b", "ko", "kid", "uk", "ek", "ok", "spec", "size", "v", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "target": 1, "func": "static void scale_coefs (\n\n    int32_t *dst,\n\n    const int32_t *src,\n\n    int dynrng,\n\n    int len)\n\n{\n\n    int i, shift, round;\n\n    int16_t mul;\n\n    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;\n\n\n\n    mul = (dynrng & 0x1f) + 0x20;\n\n    shift = 4 - ((dynrng << 23) >> 28);\n\n    if (shift > 0 ) {\n\n      round = 1 << (shift-1);\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp = temp + round;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n", "idx": 19595, "substitutes": {"dst": ["frc", "pdst", "dsts", "dstd", "ldss", "adsts", "idss", "ldst", "dstr", "idsta", "lsts", "Drc", "idsc", " dste", "dests", "idrest", "sdst", "iddest", "adst", "nddest", "ldstd", "adset", "idsl", " dsts", "deste", "adstd", "frest", "sddest", " dsta", " dset", "idst", "dss", " dstr", "fsts", " ddest", "idstr", "ndsc", "sdsl", "Dstd", "pdsc", "addest", "lsc", "idset", " dsl", "ndst", "lst", "pdsts", "dset", "Dsl", "Dsc", "drest", "Dsts", "destd", " dstd", "pdset", "dste", "dsl", "lsta", "sdsts", "idrc", "dsc", "Dset", "adsc", "idsts", "Dstr", "ldsl", " dsc", "Dst", "Drest", "ldste", "fst", "ldest", "idest", "lddest", "ndsl", "drc", "ldsc", "ldsts", "ddest", " dest", "dsta", "dest", " dss"], "src": ["sn", "sites", "txt", "sys", "kk", "grad", "split", "supp", "proc", "inst", "rest", "uc", "feat", "source", "btn", "sit", "sq", "sr", "conv", "stack", "low", "lib", "config", "support", "irc", "img", "iv", "rss", "sort", "st", "ctx", "stat", "loc", "rb", "sb", "inf", "sci", "usc", "tmp", "gl", "ssl", "func", "sl", "sur", "sup", "dist", "desc", "www", "gn", "sel", "rc", "cb", "sec", "dest", "gb", "seq", "url", "attr", "start", "obl", "sub", "ins", "sth", "spec", "sc", "rob", "ser", "secure", "rect", "sync"], "dynrng": ["dynrgn", "dblrgen", "dynamrrface", "dynrrNG", "dynrangeng", "dynrangeface", "dynamicfrNG", "dynargen", "dynRreg", "dynarng", "dynamrrng", "dynsrNG", "dynrangereg", "dynsrgn", "dblRng", "dblRNG", "dynamicfrgen", "dynramp", "dynarNG", "dynsrgen", "dynrrreg", "dynamrreg", "dynRgen", "dyncrgn", "dynamrNG", "dynamicrNG", "dynamicrng", "dynsrng", "dynRng", "dblrgn", "dynRNG", "dynrrng", "dyncrNG", "dynframp", "dynrgen", "dynamicramp", "dynamrface", "dynamrrreg", "dblrNG", "dynamicfrng", "dynrNG", "dyncrgen", "dynamicframp", "dynRgn", "dynRamp", "dynamrng", "dynrface", "dynfrNG", "dyncrng", "dynRface", "dynamrrNG", "dblrng", "dblRgn", "dynaramp", "dblRgen", "dynrreg", "dynrangeNG", "dynfrgen", "dynamicrgen", "dynrrface", "dynfrng"], "len": ["lim", "val", "bl", "length", "split", "ll", "bin", "Len", "alt", "li", "dim", "el", "lf", "n", "lon", "dl", "lc", "loc", "fl", "all", "limit", "depth", "pos", "ld", "sl", "z", "en", "lock", "fn", "num", "l", "lvl", "list", "lit", "lin", "ln", "size", "offset"], "i": ["g", "phi", "di", "inner", "my", "xi", "hi", "x", "qi", "ix", "ci", "me", "api", "eni", "page", "I", "h", "r", "c", "line", "b", "z", "mini", "image", "gi", "oi", "ini", "mi", "m", "cli", "u", "source", "it", "uri", "site", "si", "multi", "index", "ai", "iu", "us", "p", "key", "y", "ki", "wait", "ui", "fi", "yi", "l", "io", "list", "isi", "ti", "j", "f", "isin", "q", "ji", "n", "ip", "id", "init", "iv", "o", "ii", "ind", "sup", "ni", "zi", "ani", "info", "is", "li", "bi", "mu", "d", "pi", "jit", "k", "ic", "try", "slice", "ei", "e", "start", "ie", "v"], "shift": ["set", "scale", "range", "ix", "sh", "off", "end", "zip", "power", "frac", "ice", "repeat", "depth", "limit", "keep", "vert", "transfer", "send", "shape", "fix", "order", "box", "field", "use", "hide", "escape", "load", "pad", "force", "ize", "late", "center", "gravity", "wind", "seed", "roll", "radius", "push", "mix", "offset", "sample", "throw", "length", "sq", "error", "ip", "version", "small", "sleep", "init", "select", "diff", "sort", "cap", "pos", "delay", "sup", "dist", "hift", "share", "adjust", "crop", "half", "lower", "transform", "flower", "drop", "back", "pick", "ff", "pack", "space", "align", "loop", "patch", "ress", "slice", "Shift", "pop", "pull", "count", "start", "reverse", "cart", "size"], "round": ["wave", "scale", "rol", "track", "length", "range", "type", "sound", "alt", "vel", "flower", "end", "form", "drop", "feed", "ort", "high", "low", "version", "col", "pair", "tab", "offset", "play", "ff", "order", "r", "build", "ound", "control", "diff", "sort", "shock", "call", "render", "cell", "loop", "grow", "rounded", "close", "patch", "key", "wind", "scroll", "keep", "slice", "sign", "run", "pull", "lock", "attr", "seed", "Round", "row", "shape", "port", "hold", "roll", "rect", "method", "push", "crop", "field", "mix", "half"], "mul": ["g", "dule", "mush", "smUL", " mush", "Mul", " mulation", "pmul", " mull", "lul", "eff", "mmula", "emull", "smul", " mun", "Mesh", "r", "muli", "emule", "frac", "Mil", "lule", " male", "mesh", "cmun", "null", "pil", "Muli", "cmull", " mpull", "luse", "Mpull", "jUL", "dul", "pUL", "dulation", "mmul", "lush", "pulus", "pmule", "add", "male", "pmuli", "Mull", "pmull", "amull", "mil", "tmul", "s", "dale", "mulus", "Mule", "amule", "amulus", "cmulus", "ampull", "amul", "mun", "mmold", "mmUL", "Mush", "duse", "smull", "pul", "dula", "tmull", "mold", "lula", "mulation", "pale", "mpull", "lull", "_", "emul", "emula", " mold", "nuli", "amUL", "mull", "mula", "cmul", " mule", "dUL", "amuli", "lale", "jul", "smulation", "jull", "nulus", "dush", "mule", "str", "mUL", " mula", "pmula", "lesh", " mUL", "Mulation", "mmull", "tmUL", "Male", "smush", "dull", "mmuli", " mulus", " muli", "dold", "nul", "jesh", "dil", "pull", "pun", "MUL", "mmule", "lUL", " muse", "muse", "ctr", " mil", "tmuli"], "temp": ["min", "dc", "get", "extra", "cache", "Temp", "api", "valid", "test", "comb", "magic", "mist", "c", "content", "keep", "null", "mini", "ctrl", "tw", "wa", "empty", "mi", "m", "wave", "copy", "pt", "timeout", "template", "cli", "source", "level", "clean", "flat", "toc", "emp", "data", "full", "perature", "p", "key", "current", "wait", "fake", "thin", "seed", "model", "cu", "pot", "stable", "mix", "white", "cp", "tp", "style", "cut", "orig", "buffer", "base", "small", "partial", "input", "wrap", "iter", "pure", "pre", "dat", "tem", "txt", "output", "cel", "form", "porary", "flow", "atom", "pack", "w", "loc", "time", "tmp", "unit", "tc", "sign", "count", "dest", "mag"], "temp1": ["tem5", "tem3", "Temp0", "tmp2", "tmp01", "tem0", "fake0", "tmp15", "fake4", " temp0", "temp15", "tmp1", "fake1", "Temp1", "Temp5", "Temp3", " temp01", "fake3", "tem2", "Temp15", "temp0", "Temp2", "temp01", "tem4", "tem1", " temp15", "Temp01"], "temp2": ["tempB", "tem5", "tem3", "Temp0", "tmp2", "pt2", "emp2", "temp02", "temp72", "tem0", " temp0", "tem02", " temp02", "tem6", "pt02", "temp8", "test3", " temp72", "emp72", " tempB", "test5", "Temp1", "Temp5", "tmp8", "test4", "Temp3", "empB", "tmpB", "tem2", "Temp4", "pt6", " temp8", "tem8", "temp0", "pt4", "tmp72", "Temp2", "tem4", "test2", "Temp8", "emp8", "tem1"], "temp3": ["tem30", "tem5", "tem3", "tem23", "fake2", "emp30", "tem7", "temp23", "fake4", "tempThree", "fake03", " temp23", "temp30", "test3", "fake1", "test5", "Temp1", "Temp5", "empThree", "Temp3", "fake3", " temp03", "emp3", " temp30", "temThree", "tem2", "fake5", "test03", "Temp7", "Temp4", " tempThree", "emp23", "Temp2", "tem4", "test2", "tem1", "temp03"], "temp4": ["emp4", "tem5", "temp40", "test6", " temp40", "fake6", "fake2", "iter4", "fake4", "emp400", "iter5", "tem6", "test1", "tmp40", "tmp5", "iter2", "fake1", " temp400", "Temp6", "Temp1", "emp5", "Temp5", "tmp400", "emp40", "test4", "tmp4", "tem2", "fake5", "Temp4", "Temp2", "tem4", "test2", "tem1", "temp400", "iter1"], "temp5": ["tem5", "tem3", "temp50", "fake6", "tmp50", "fake2", "fake4", " temp53", "iter5", " temp55", "tem6", "tem55", "tmp5", "tmp53", "temp55", "temp53", "tem50", "Temp6", "Temp1", "Temp5", "tem53", "tmp55", "Temp3", "iter6", "tem2", "fake5", "Temp4", "iter3", " temp50", "Temp2", "tem4", "tem1", "iter1"], "temp6": ["fake8", "tem5", "Temp66", "tmp06", "tmp66", "fake6", "test6", " temp06", "fake2", " temp68", "Temp68", "tem7", "tmp6", "fake4", "tem6", "tmp5", "temp8", "test5", "Temp6", "Temp5", "tmp8", "tem06", "test4", "temp06", "Temp7", "tmp68", "Temp4", " temp8", "test8", "tem8", "temp66", "Temp2", "tem4", "Temp8", " temp66", "temp68"], "temp7": [" temp87", "Temp13", "test6", "fake6", "temp13", "tmp47", " temp17", " temp47", "Temp47", "tem7", "tmp6", "fake4", "tmp17", "temp47", "test13", "tmp5", "test7", "temp8", "Temp17", " temp13", "Temp6", "tmp87", "Temp5", "tmp8", "tem67", "temp17", " temp67", "tmp67", "fake5", "tmp7", "Temp7", "fake7", "Temp4", " temp8", "test67", "tem8", "temp87", "tem87", "temp67", "Temp67"]}}
{"project": "qemu", "commit_id": "db3b3c7281ca82e2647e072a1f97db111313dd73", "target": 1, "func": "static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}", "idx": 19612, "substitutes": {"opts": ["preps", "obts", "pres", " opTs", "experts", "opls", "ops", "OPts", "opter", "experouts", "optTs", "opTs", " opouts", " oplets", "opty", "experTs", "otts", "OPty", " opls", " oppt", "otter", "experpt", "opps", "otpt", "opouts", "obs", "otlets", "OPs", "experlets", "obty", "oppt", " opter", "obps", "optls", "prets", "experls", "optts", "prety", "optouts", "experter", "oplets", "OPps"], "fse": ["fsle", "fze", "pze", "psle", " fpse", "fsu", "fme", "fSE", "rfse", "rfme", "pse", " fsle", "lfpse", "ppse", " fze", "rfsu", "Fse", " fsu", "fpse", "lfsle", "FSE", " fme", "Fme", "Fsu", "lfse", "lfze", " fSE", "rfSE"], "errp": ["erP", "errc", "ErP", "erp", " errP", "errr", "errP", " errr", "Erc", "Err", "erc", " errc", "Erp", "err"], "sec_model": ["sec_module", "sec_pattern", "Sec_model", "Sec_pattern", "Sec_mode", "Sec_models", "Sec_module", "sec_models", "sec_mode"], "path": ["str", "inner", "pattern", "ith", "route", "PATH", "name", "type", "node", "prefix", "parent", "source", "cmd", "po", "api", "error", "rh", "point", "root", "location", "args", "enc", "config", "id", "chain", "Path", "dir", "data", "mount", "target", "call", "ath", "loc", "wd", "file", "p", "patch", "key", "filter", "content", "pointer", "value", "image", "context", "prop", "url", "arc", "model", "port", "text", "alias", "password", "device", "method", "part"]}}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633, "substitutes": {"vs": ["ys", "cs", "verts", "eps", "css", "flags", "ves", "ils", "vas", "ms", "ops", "bs", "ov", "orts", "ps", "ports", "rs", "values", "js", "ss", "vals", "alls", "ns", "args", "cons", "vi", "vers", "state", "ues", "va", "versions", "vp", "iv", "ls", "iss", "es", "Vs", "als", "forces", "ii", "gs", "sk", "cf", "ums", "s", "ks", "ts", "obs", "xs", "oss", "ets", "fs", "services", "stats", "vt", "as", "sts", "ses", "os", "otes", "sv", "utils", "env", "ins", "words", "events", "VS", "ds", "qs", "v", "its"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int integratorcm_init(SysBusDevice *dev)\n\n{\n\n    IntegratorCMState *s = INTEGRATOR_CM(dev);\n\n\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n", "idx": 19643, "substitutes": {"dev": ["self", "di", "DEV", "prom", "temp", "mod", "dd", "link", "sh", "conn", "ad", "dm", "sw", "d", "tr", "sd", "hw", "gd", "av", "od", "dt", "pub", "dom", "Dev", "w", "devices", "nt", "de", "def", "ve", "dem", "ev", "bus", "die", "pro", "driver", "dn", "device", "rad", "serv", "ds", "serial", "md", "ver", "m"], "s": ["g", "set", "self", "ms", "none", "session", "bs", "uns", "x", "js", "h", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "stats", "states", "sets", "a", "qs", "m", "server", "http", "u", "ns", "si", "args", "i", "your", "data", "es", "us", "params", "p", "sb", "ts", "ks", "y", "services", "l", "sym", "serv", "se", "its", "sync", "f", "less", "rs", "south", "ss", "n", "o", "S", "sg", "ses", "spec", "is", "cs", "sys", "ps", "new", "t", "d", "status", "ls", "sum", "w", "xxx", "side", "service", "e", "os", "ds", "v", "settings"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650, "substitutes": {"obj": ["val", "str", "ops", "cat", "pt", "bs", "src", "node", "alt", "po", "js", "oa", "ns", "n", "args", "j", "lib", "od", "az", "ob", "code", "act", "data", "o", "ctx", "rb", "object", "adj", "nt", "pos", "tmp", "sb", "Object", "ass", "nb", "bj", "ab", "os", "arr", "Obj", "elt", "amp"]}}
{"project": "FFmpeg", "commit_id": "8f4020d8a4b2e6264f54accbcb881577316c3ca6", "target": 0, "func": "static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)\n\n{\n\n    int frame_size_code;\n\n\n\n    skip_bits(bitbuf, 8); /* temporal_reference */\n\n\n\n    /* frame type */\n\n    s->pict_type = get_bits(bitbuf, 2) + 1;\n\n    if (s->pict_type == 4)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        /* unknown fields */\n\n        if (s->f_code == 0x50 || s->f_code == 0x60) {\n\n            int csum = get_bits(bitbuf, 16);\n\n\n\n            csum = ff_svq1_packet_checksum(bitbuf->buffer,\n\n                                           bitbuf->size_in_bits >> 3,\n\n                                           csum);\n\n\n\n            av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",\n\n                    (csum == 0) ? \"correct\" : \"incorrect\", csum);\n\n        }\n\n\n\n        if ((s->f_code ^ 0x10) >= 0x50) {\n\n            uint8_t msg[256];\n\n\n\n            svq1_parse_string(bitbuf, msg);\n\n\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"embedded message: \\\"%s\\\"\\n\", (char *)msg);\n\n        }\n\n\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits1(bitbuf);\n\n\n\n        /* load frame size */\n\n        frame_size_code = get_bits(bitbuf, 3);\n\n\n\n        if (frame_size_code == 7) {\n\n            /* load width, height (12 bits each) */\n\n            s->width  = get_bits(bitbuf, 12);\n\n            s->height = get_bits(bitbuf, 12);\n\n\n\n            if (!s->width || !s->height)\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            /* get width, height from table */\n\n            s->width  = ff_svq1_frame_size_table[frame_size_code].width;\n\n            s->height = ff_svq1_frame_size_table[frame_size_code].height;\n\n        }\n\n    }\n\n\n\n    /* unknown fields */\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);    /* use packet checksum if (1) */\n\n        skip_bits1(bitbuf);    /* component checksums after image data if (1) */\n\n\n\n        if (get_bits(bitbuf, 2) != 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 4);\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 2);\n\n\n\n        while (get_bits1(bitbuf) == 1)\n\n            skip_bits(bitbuf, 8);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19654, "substitutes": {"bitbuf": ["bitbox", "loguf", "lockbuffer", "bootbuffer", "bugctx", "bitscb", "bitsbuf", "bitsbag", "Bitbuf", "bitbag", "banduf", "bootcb", "bugbuffer", "loadbuff", "logbuff", "bytebuf", " bitbuff", "bitbuff", "binuf", "bitsuf", "itbuf", "catbuff", "bonvec", "bitboard", "bonbox", "Bitbuff", "logbuf", "itbuffer", "bootbuff", "loadcb", "byteuf", "bugbuf", "loadbuffer", "lockbuf", "bandbuf", "bonboard", "bitsboard", "bonbag", "lockuf", "Bitcb", "bonuf", "catbuf", "bootvec", " bitbuffer", "bytecb", "buguf", "bytebuff", "bugbag", "lockbuff", "bytebuffer", "bootctx", "bitbatch", "Bitbuffer", "bituf", "bandbuff", "bincb", "bandbatch", "binbuffer", "loadbox", "catuf", "ituf", "bitsbuff", "bonbuf", "catcb", "bitvec", "bitsbuffer", "bugboard", "bitbuffer", "binbuff", "bitcb", "bugcb", "bonbatch", "itbuff", "bugbuff", "bootbuf", "bytevec", " bitcb", " bituf", "binbuf", "bonbuff", "logctx", "bootuf", "bootbatch", "bitctx", "bootbox", "loadbuf", "loaduf"], "s": ["g", "self", "session", "uns", "js", "h", "r", "gs", "conf", "c", "b", "ssl", "sl", "su", "fs", "stats", "states", "sets", "ins", "qs", "m", "sf", "http", "u", "ns", "si", "cons", "i", "your", "es", "p", "sb", "y", "ts", "ks", "services", "l", "sym", "words", "se", "manager", "its", "sync", "f", "rs", "ss", "sq", "n", "o", "xs", "sim", "S", "bis", "sg", "ses", "spec", "is", "cs", "sys", "aws", "ps", "new", "t", "d", "ls", "w", "details", "service", "comments", "e", "os", "sc", "ds"], "frame_size_code": ["frame_sizeingcode", "frame_sizexcount", "frame_genderfulllevel", "frame_size_const", "frame_sizexnumber", "frame_size_codes", "frame_shape_code", "frame_size_level", "frame_gender_code", "frame_gender_level", "frame_genderfullcode", "frame_scale_number", "frame_shape_count", "frame_scale_id", "frame_sizexcode", "frame_size_cycle", "frame_shape_length", "frame_size_id", "frame_size_value", "frame_scale_code", "frame_sizeingnumber", "frame_sizevalvalue", "frame_gender_coded", "frame_sizevallevel", "frame_sizeingstr", "frame_sizevalcode", "frame_genderfullcoded", "frame_size_number", "frame_scale_str", "frame_sizevalcoded", "frame_scale_count", "frame_size_32", "frame_size_coded", "frame_size_count", "frame_size_str", "frame_sizeingcount", "frame_genderfullvalue", "frame_sizefullcoded", "frame_sizefulllevel", "frame_scale_cycle", "frame_sizexstr", "frame_sizefullvalue", "frame_scale_codes", "frame_sizefullcode", "frame_scale_const", "frame_shape_32", "frame_gender_value", "frame_size_length"], "msg": ["g", "str", "header", "html", "ms", "essage", "cmd", "type", "bc", "frame", "node", "asm", "op", "orig", "error", "req", "message", "args", "mt", "enc", "i", "Msg", "code", "data", "doc", "byte", "raw", "mess", "comm", "loc", "gs", "gram", "gen", "ag", "b", "desc", "err", "bytes", "seq", "sg", "text", "sym", "og", "empty", "arg", "nm", "debug", "md", "alloc", "m"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n", "idx": 19665, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n", "idx": 19667, "substitutes": {"a": ["self", "f", "sa", "ac", "na", "ad", "d", "n", "i", "ra", "ar", "va", "ae", "aa", "asa", "ba", "ama", "ak", "ca", "c", "p", "s", "ada", "am", "A", "as", "la", "ab", "e", "an", "art"], "b": ["bd", "f", "B", "bs", "arb", "x", "xb", "d", "wb", "bb", "boot", "i", "ob", "ib", "emb", "eb", "ba", "bur", "rb", "c", "k", "sb", "p", "s", "abb", "y", "be", "mb", "as", "cb", "ab", "e", "ub", "lb", "v", "fb"], "da": ["ja", "bd", "sa", "pd", "ppa", "na", "aea", "dd", "ad", "ta", "d", "oda", "bb", "gd", "ra", "pa", "va", "data", "aa", "ma", "asa", "ba", "ga", "ca", "ea", "de", "lla", "ke", "aka", "ld", "ada", "fa", "sta", "lambda", "as", "la", "DA", "Da", "dat", "wa", "onda", "ds"], "db": ["Db", "bd", "bs", "ud", "database", "bc", "dd", "bh", "ad", "bi", "d", "bb", "base", "fd", "sd", "deb", "lib", "gd", "ob", "ib", "dir", "data", "ae", "eb", "aa", "doc", "ba", "dy", "loc", "rb", "sb", "ada", "ade", "cb", "vd", "ab", "gb", "bf", "ub", "lab", "DB", "ah", "ds", "fb"]}}
{"project": "qemu", "commit_id": "c3fecea50dc0f27198b8658a0c9c4fbfdd0f95db", "target": 1, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, int create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, NULL, s);\n\n    set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = do_write(s->fd, &hdr, sizeof(hdr));\n\n    if (ret) {\n\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -EIO;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = do_writev(s->fd, iov, wlen, aio_req->iov_offset);\n\n        if (ret) {\n\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -EIO;\n\n        }\n\n    }\n\n\n\n    set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, NULL, s);\n\n\n\n\n    return 0;\n\n}", "idx": 19684, "substitutes": {"s": ["g", "is", "set", "self", "server", "cs", "sys", "session", "sa", "f", "http", "this", "ps", "secondary", "new", "ds", "js", "south", "t", "ss", "sq", "scope", "ns", "n", "si", "sed", "i", "state", "storage", "submit", "r", "full", "iss", "ls", "o", "us", "w", "gs", "conf", "c", "p", "sb", "sci", "service", "sie", "ssl", "sis", "sl", "b", "current", "su", "sim", "services", "fs", "stats", "S", "so", "states", "sg", "ses", "e", "os", "l", "sym", "serv", "se", "spec", "v", "sync", "m"], "aio_req": ["aio__req", "aios_req", "aiosreq", "aiol__request", "aios_require", "aio_desc", "aiol__requ", "aiol_tar", "aio__tar", "aio5request", "acho_desc", "acho_required", "aio_required", "aiosocr", "aio_fr", "aio_request", "aIO_req", "aio67required", "aiol__req", "aio2req", "aio_rt", "aIO_rec", "aio_require", "aios_request", "acho_req", "aio_comp", "aio67request", "aio__requ", "aio67req", "aiosrequest", "aIO_err", "aios_rt", "aio_ocr", "aios_ref", "aIO_request", "aio_err", "aio67desc", "aio5req", "aios_rec", "aio2rec", "aiol_requ", "aio2err", "aiosrequire", "aio_requ", "aio__request", "aio_rec", "aio_ref", "aio5rt", "aio_tar", "aios_ocr", "aio2request", "aio5rec", "aiol_req", "aiol__tar", "aiol_request", "acho_request"], "iov": ["eu", "iop", "unc", "ro", "mx", "gc", "uncle", "ive", "org", "fee", "ir", " ov", "cons", "oci", "iv", "man", "uno", "uu", "ii", "iii", "ou", "roc", "ei", "eve", "rio", "wo", "io", "rob"], "niov": ["eiow", "naiv", "niiv", "eniove", "eiiv", "niow", "eniov", "niove", "naow", "eiov", "naov", "eiove", "eniiv", "naove", "eniow"], "create": ["Create", "set", "creat", "created", "copy", "check", "clear", "complete", "new", "parent", "enable", "raise", "activate", "construct", "drop", "add", "execute", "child", "make", "save", "init", "code", "change", "draw", "children", "write", "gen", "when", "wait", "desc", "update", "fake", "send", "delete", "shape", "password", "open", "custom", "destroy", "clone", "use"], "aiocb_type": ["aiocb_ype", "aiocbfype", "aiocbftype", "aiocb__type", "aiocsb_ype", "aiocbfrel", "aiocb__lock", "aiocsb_Type", "aiocsb_lock", "aiocb_Type", "aiocsb_type", "aiocsb_style", "aiocsb_rel", "aiocbfType", "aiocb_rel", "aiocb_style", "aiocb_lock", "aiocb__style"], "hdr": ["rhrc", "enhr", " htr", "rhder", "ehr", "handrid", "hydr", "handvar", "ehdr", "hrs", "hrid", "hlrc", "shDR", "hdi", "ihdr", "rhdc", "adhdr", "adhrr", "Hrid", "wtr", "adhrs", "enhdr", "hct", "uhdr", "hDr", "ehrid", " Hr", "Hmr", " Hdr", " hicit", "rhbr", "bhdr", "hiheader", "ihr", "ohder", "hmdr", "hhDR", " hmr", "hshr", "hric", "adhDR", "rhdr", "ihrid", "hder", "shDr", "Hrc", "bhhr", "ohheader", "ohDr", "rhDr", " hder", " hr", "shrr", "hrdc", "ohDR", "hhrt", "hrhr", "ohrs", "hrdr", "hvar", "hihr", "hmr", "hrder", "adhrid", "ghdr", "Hhr", "enhder", "adhhr", "handDR", "handdr", " hct", " Hicit", " hstr", " hrt", "handct", "shdr", " Hder", "hyvar", " hrs", "shrid", "ghder", "hmhr", " hrr", "ohhr", "Hdr", "whr", "rhDR", " hbr", " hdi", "hmheader", "hhdr", " hric", " hrid", "wder", "uhric", " hhr", "hheader", "hldr", "Hdi", "ihstr", "hr", "hider", "hdc", "hyrc", " hvar", "shtr", "rhrt", "ehstr", "hyrid", "rhdi", "hhhr", "rhhr", "phric", "phrc", "hbr", "hlDR", "hhr", "shhr", "wdr", "hmder", "hicit", "hidr", "hsdr", "bhder", "rhtr", "ohdr", "hstr", "hlmr", "htr", "ohtr", "HDR", "ghhr", "Hct", "hsder", "handrc", "phbr", "enhicit", "hrt", "rhr", "hDR", " hDR", "ghdc", "phdr", "hrc", "phr", " hrc", "adhtr", "hrr", "uhrc"], "wlen": ["swln", "ewlen", " wlf", "swlon", "walength", "wwln", " wlon", "owlen", "wlon", " wlength", "owen", "wlength", " wln", "rwlon", "rwln", "wwlon", "kwlen", "wordlength", "wen", "ewlength", "kwlon", "ewen", "wln", "wordlon", "owln", "rwlength", "wordlen", "owlon", "swen", "swlf", " wen", "wordln", "swlength", "walen", "rwlen", "ewlf", "wwlen", "wlf", "swlen", "walon", "waln", "kwln", "wwen", "kwlength"], "ret": ["RET", "val", "reply", "bit", "let", "cat", "result", "alt", "feat", "res", "success", "reg", "red", "fun", "len", "status", "code", "data", "addr", "rets", "att", "ref", "det", "nt", "resp", "re", " Ret", "count", "rc", "Ret", "num", "mem", "arr", "lit", "arg", "rt"]}}
{"project": "qemu", "commit_id": "2b3de6ada5d180130ba083d5b45ed51ce8e4def2", "target": 1, "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);", "idx": 19685, "substitutes": {"p": ["pc", "ps", "tp", "wp", "queue", "u", "op", "po", "lp", "t", "np", "n", "bp", "pm", "pi", "press", "i", "ip", "pg", "pp", "pa", "pb", "h", "o", "w", "qt", "pre", "c", "P", "patch", "post", "pe", "pkg", "e", "pid", "pr", "j", "m"], "q": ["local", "question", "g", "self", "check", "client", "f", "ck", "Q", "cmd", "queue", "u", "cache", "qi", "cur", "sh", "t", "sq", "form", "req", "view", "ch", "config", "pg", "cl", "quick", "h", "qa", "r", "qq", "ctx", "ue", "qt", "iq", "cf", "c", "k", "ce", "dq", "patch", "s", "qu", "pkg", "comment", "ct", "request", "e", "query", "que", "ack", "event", "qs", "v", "sync"], "state": ["is", "self", "resource", "rule", "f", "none", "length", "match", "type", "name", "new", "style", "parent", "instance", "t", "what", "STATE", "force", "back", "tag", "info", "State", "config", "id", "parse", "code", "ace", "call", "stat", "k", "part", "ate", "al", "key", "pe", "comment", "err", "use", "m", "run", "seed", "un", "e", "where", "start", "port", "ask", "event", "out", "an", "mode"]}}
{"project": "qemu", "commit_id": "36c6711bbe79642b0102416a9dd4243505e874a6", "target": 1, "func": "static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,\n\n                           int base, int16_t offset)\n\n{\n\n    const char *opn = \"ldst_pair\";\n\n    TCGv t0, t1;\n\n\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    t1 = tcg_temp_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n    case LWP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"lwp\";\n\n        break;\n\n    case SWP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sw(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sw(t1, t0, ctx);\n\n        opn = \"swp\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case LDP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"ldp\";\n\n        break;\n\n    case SDP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sd(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sd(t1, t0, ctx);\n\n        opn = \"sdp\";\n\n        break;\n\n#endif\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 19709, "substitutes": {"ctx": ["progress", "gru", "client", "grad", "jp", "na", "ci", "scope", "exec", "connection", "cl", "rx", "ga", "cf", "c", "vc", "Context", "context", "ctrl", "utils", "cm", "acl", "cli", "nc", "req", "hw", "lib", "qa", "cas", "kt", "mac", "fp", "cam", "pkg", "wcs", "cu", "kb", "sync", "cp", "scl", "src", "cmd", "bc", "sq", "crit", "conv", "stack", "cms", "config", "cgi", "wx", "lc", "cc", "sci", "la", "ct", "rc", "cb", "history", "cn", "cca", "cs", "txt", "parent", "conn", "loc", " cx", "ca", "cv", "tx", "tc", "gz", "cmp", "anc", "general", "xc", "sc"], "opc": ["OPc", "ospf", "OPC", "opf", "ospcs", "hopcn", "hopnc", "ipnc", "opnc", "opC", "opcs", "hopn", "OPf", "hopc", "OPcs", " opC", " opcn", "opcn", "ipcn", "ipn", " opnc", "ospC", " opf", "ipc", "ospc", " opcs"], "rd": ["dr", "ru", "val", "round", "cd", "rr", "RF", "ri", "dra", "src", "ud", "pt", "rest", "rw", "ro", "lt", "rs", "dd", "td", "dim", "rm", "lr", "d", "rid", "rod", "rh", "red", "fd", "rob", "od", "ra", "r", "ord", "index", "rt", "addr", "rx", "mid", "rss", "hr", "dir", "typ", "rb", "wn", "wd", "ld", "std", "rl", "ind", "nd", "xd", "rf", "cr", "raid", "rg", "ptr", "rc", "dig", "rn", "rect", "ds", "RD", "md"], "base": ["core", "val", "based", "scale", "server", "rest", "range", "x", "ite", "prefix", "name", "end", "old", "back", "root", "len", "site", "bp", "reset", "db", "address", "r", "index", "ra", "last", "fr", "addr", "loc", "rb", "ffff", "pre", "ref", "part", "bas", "b", "cr", "le", "rc", "zero", "bf", "area", "start", "Base", "ase"], "offset": ["set", "acl", "af", "route", "range", "type", "prefix", "array", "off", "api", "end", "position", "len", "reset", "address", "index", "padding", "addr", "data", "Offset", "align", "loc", "format", "ref", "slot", "part", "pos", "b", "ptr", "url", "seq", "area", "start", "adjust", "rot", "bound", "size"], "opn": ["hopN", "OPc", "ropN", "blockc", "ropc", "OPN", "opd", "blockn", "hopcn", "blockN", "blockd", "hopns", "ropnot", "OPn", "opercn", "opN", "hopc", " opd", " opN", "operc", "optn", " opns", "OPns", "opern", "ropn", "optd", "optN", " opcn", "opcn", "opns", " opnot", "optnot", "opnot", "optc", "hopn"], "t0": [" t4", "T0", "tt1", " t20", "f2", " t2", "at9", "p0", "tt20", " t9", "f1", " t3", "T20", "p4", "at0", "t20", "T9", "tt0", "ott20", "ott1", "T4", "tt2", "T1", "p1", "ta2", "ott0", "t9", "t01", "ott2", "p01", "T2", "T01", "ta0", "p2", "t4", "t3", "p3", "at01", "t2", "ta1", "at1", "ta20", "at2", "T3", "f4", "f3", "f0"], "t1": [" tone", "t6", "Tone", "t121", "tONE", " t2", "p8", "atOne", "p100", "at0", "it11", "TONE", "T81", "tt2", "T1", "te81", "tone", "ta2", "ta10", "pt1", "t11", "it81", "T6", "ta121", "it7", "T41", "t3", "itONE", "t2", "te0", "at2", "pt4", "itone", "f0", "it6", "T5", "tt591", "it0", "t100", "f2", "p0", "pone", "p1", "itOne", "t8", "it2", "T100", "t4", "ta1", "t81", "at1", "T3", "T121", "ta7", "T11", "t5", "at121", "T10", "t10", "ta100", "it3", "tOne", " t4", "t7", "T8", "p5", "p4", "at591", "at30", "p10", "f6", "T4", "ta61", "teOne", "T2", "at61", "p3", "it1", "f4", "p591", "tt100", "it100", "it8", "at41", "taone", "T0", "tt1", "at4", "TOne", "pt2", "t591", "t41", "f1", "ta81", "taOne", "ta30", "at100", "p41", "t61", "T30", "t30", "ptONE", "ta0", "atONE", "p2", "it5", "f11", "T61", "atone", "T7", "pONE", "te1"]}}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716, "substitutes": {"klass": ["klasses", "kcl", "klf", "sklasses", "ckcl", " kazz", "Klasses", "sklf", "sklass", " klf", "skazz", "Kclass", "Kazz", "kazz", "cklasses", "Klf", " klasses", " kcl", "kclass", "ckclass", "cklass", " kclass", "skcl", "skclass", "Klass"], "data": ["after", "result", "cache", "dd", "bc", "DATA", "load", "parent", "array", "buffer", "exec", "Data", "i", "config", "input", "loader", "da", "def", "ui", "cb", "dat", "ata", "ds", "info"], "dc": ["dr", "cca", "disc", "cd", "di", "cdn", "cm", "df", "pc", " DC", "uc", "nc", "bc", "ac", "cache", "gc", "ds", "conn", "d", "dk", "controller", "DC", "config", "db", "dt", "director", "doc", "deck", "ec", "lc", "design", "ga", "cf", "c", "jc", "cc", "da", "std", "vc", "abc", "enter", "tc", "cfg", "rc", "mc", "dp", "ctrl", "spec", "sc", "fc"], "diag288": ["diag28", "diig288", "adiag280", "diig280", "adiag128", "diagger28", "adiarg280", "Diig280", "diac288", "diang28", "Diig288", "adiarg288", "diag188", "diagger142", "diig142", "diagger280", "Diag142", "diag280", "diig188", "adiag288", "diag142", "Diig142", "diag128", "adiarg188", "diig128", "diarg288", "diang280", "adiag188", "diac128", "diagger288", "diac188", "Diag280", "adiarg128", "diarg280", "diac280", "Diig28", "diig28", "diarg128", "diarg188", "Diag28", "diang288", "diang142", "Diag288"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "int ff_estimate_motion_b(MpegEncContext * s,\n\n                       int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code)\n\n{\n\n    int mx, my, range, dmin;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    const int mot_stride = s->mb_width + 2;\n\n    const int mot_xy = (mb_y + 1)*mot_stride + mb_x + 1;\n\n    \n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = mv_table[mot_xy    ][0];\n\n            P[0][1] = mv_table[mot_xy    ][1];\n\n            P[1][0] = mv_table[mot_xy - 1][0];\n\n            P[1][1] = mv_table[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = mv_table[mot_xy - mot_stride             ][0];\n\n                P[2][1] = mv_table[mot_xy - mot_stride             ][1];\n\n                P[3][0] = mv_table[mot_xy - mot_stride + 1         ][0];\n\n                P[3][1] = mv_table[mot_xy - mot_stride + 1         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            pred_x= P[1][0];\n\n            pred_y= P[1][1];\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    /* intra / predictive decision */\n\n//    xx = mb_x * 16;\n\n//    yy = mb_y * 16;\n\n\n\n//    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n//    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    dmin= halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n\n\n//    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    mv_table[mot_xy][0]= mx;\n\n    mv_table[mot_xy][1]= my;\n\n    return dmin;\n\n}\n", "idx": 19721, "substitutes": {"s": ["g", "lines", "ms", "client", "session", "js", "gs", "conf", "c", "b", "ssl", "sl", "ches", "su", "fs", "stats", "states", "sets", "v", "qs", "m", "server", "sf", "http", "com", "u", "ions", "ns", "site", "si", "i", "tests", "es", "us", "p", "sb", "ks", "ts", "y", "sis", "services", "sv", "se", "its", "sync", "f", "ops", "sports", "rs", "south", "ss", "sq", "n", "phys", "o", "sci", "sim", "S", "bis", "sg", "ses", "spec", "cs", "groups", "sys", "t", "d", "storage", "stat", "details", "service", "e", "os", "ess", "sc", "ds", "an", "settings"], "mb_x": ["mp_xy", "MB_xy", "mm_xs", "mbacx", "MB_width", "MB_x", "mb5ux", "mm_x", "mb33xs", "mm_ey", "mb33x", "mb2y", "mb5y", "mb_ex", "mp_y", "mb33ey", "MB_y", "mb_xs", "mb_ey", "mb_width", "mb2ex", "mm_y", "mbacy", "mb2x", "mb_px", "MB_ux", "mb5x", "mb2width", "mb33y", "mbacxs", "mp_px", "mb_xy", "MB_ex", "mb_ux", "mb5xy", "mp_x", "mbacey"], "mb_y": ["mm_height", "mb_height", "mb__y", "mb_z", "mb5Y", "mb_hop", "mb0y", "mb25height", "mb_dy", "mm_x", "mb0x", "mb14height", "mm_ny", "mb67z", "mb_yo", "mb01hop", "mb__Y", "mb0hop", "mb01x", "mb01ny", "mm_dy", "mb0ny", "mb5y", "mb14y", "mp_y", "mb5vy", "mm_z", "mb14x", "mb_ny", "mp_Y", "mb25dy", "mm_y", "mb_Y", "mb_vy", "mb67yo", "mb01y", "mb5x", "mb__x", "mb25y", "mm_hop", "mp_vy", "mb67x", "mb25x", "mb14dy", "mb67y", "mb__vy", "mm_yo", "mp_x"], "mv_table": ["mf_machine", "mv__interface", "mf_tab", "mv__table", "mv7table", "mv_test", "mv5cache", "mf_list", "mv__cache", "mv_system", "mv5table", "mf_table", "mf_cache", "mf_test", "mv5system", "mf_file", "mv_cache", "mv_list", "mf_system", "mv7machine", "mv_tab", "mv7tab", "mv__source", "mf_interface", "mv1system", "mv1test", "mf_source", "mv__list", "mv7cache", "mv5test", "mv_machine", "mv_file", "mv_interface", "mv__file", "mv1table", "mv__machine", "mv1cache", "mv_source"], "ref_picture": ["refplepicture", "Ref_pic", "ref_video", "refspicture", "ref_statement", "refplepic", "ref_summary", "refacview", "ref_storage", "ref_memory", "refacvideo", "refvalpicture", "Ref_summary", " ref_statement", "ref_cache", "reference_storage", "reference_video", "refvalpic", "refaccache", "Ref_picture", "refacpicture", "refplestatement", "reference_view", "reference_cache", "reference_memory", "refspic", " ref_video", "reference_picture", "refvalimage", "ref_view", "ref_pic", "refssummary", "ref_image", "refvalsummary", "refplevideo", "refsimage", "Ref_image", " ref_pic"], "f_code": ["fp_error", "f_type", "famerror", "famclass", "f_call", "firmcode", "fc__codes", "fpamerror", "f2class", "firmcodes", "f2code", "f__map", "fc__code", "fp_class", "f__code", "fp_code", "fc_map", "f__type", "firmtype", "f_class", "fpamclass", "fp_call", "f__codes", "fc_code", "f_codes", "famcode", "f_error", "f2error", "fpamcall", "fc_type", "f_map", "fc__type", "fc_codes", "fc__map", "famcall", "f2call", "firmmap", "fpamcode"], "mx": ["lim", "sample", "cp", "min", "cm", "ms", "many", "xy", "x", "mod", "xml", "me", "wm", "mu", "dm", "fm", "ns", "mus", "pm", "bm", "module", "ml", "xp", "X", "max", "wx", "rx", "loc", "km", "lex", "p", "mes", "mouse", "y", "mr", "nr", "mos", "yx", "tx", "mn", "vm", "wy", "mc", "px", "zx", "mp", "dn", "im", "mm", "MX", "mag", "mi", "m"], "my": ["self", "mis", "min", "any", "ms", "x", "mod", "me", "mic", "bi", "py", "yo", "pm", "i", "mys", "max", "your", "oy", "rx", "sam", "ma", "dy", "mac", "body", "mine", "y", "cy", "mr", "mos", "MY", "dist", "mini", "mn", "am", "gy", "ng", "ya", "mc", "ym", "mem", "fy", "sym", "python", "nm", "mm", "My", "mon", "md", "mi", "m"], "range": ["sample", "lim", "ange", "scale", "resource", "scan", "mode", "route", "angle", "domain", "frame", "cache", "array", "grade", "distance", "error", "force", "gap", "broad", "no", "ge", "base", "low", "view", "multi", "offset", "chain", "max", "r", "year", "fr", "mid", "block", "target", "repeat", "loc", "conf", "ref", "line", "channel", "role", "slice", "edge", "use", "err", "run", "rage", "spread", "area", "row", "from", "query", "Range", "model", " Range", "remote", "size", "random", "theme", "feature", "m"], "dmin": ["ddpri", "Dmax", "dminimum", "Dmin", "nrupt", "yMIN", "dMIN", "smin", "fdmax", "dd0", "Dmid", "ldmine", " dminimum", " dmine", "dymin", "nmax", " dpri", "Drupt", "ymid", "ymins", "ldminimum", "dmins", " dpos", "dmine", "dyMIN", "ddmin", "D0", "yserv", " dMIN", "dmain", "Dpos", "nmin", "dmax", "fdrupt", "fdmain", "smins", "sMIN", "dserv", "drupt", " dmid", "ldMIN", " d0", "dyminimum", "nmain", "Dmain", "dpos", "dymine", "DMIN", "sserv", "Dmins", "dmid", "Dpri", "Dserv", "d0", "dpri", "fdmin", "ldmin", "ddpos"], "xmin": ["ixmin", "rxmax", "rxstart", " xMin", "xmins", "xmini", "ixmax", "ixmini", "xstart", " xpos", "ymins", "Xmini", "ymini", "ixmins", "ystart", "xMin", "XMin", "Xstart", "vmin", "vMin", "ypos", " xmini", "Xmin", "Xmins", "rxpos", "vmins", " xstart", "rxMin", "xpos", "rxmin", "Xmax", " xmins", "yMin", "vmax"], "ymin": ["yrange", "xmid", "eymin", "symax", "systat", "symini", "mymini", " yrange", "xstat", "xmins", "zmax", "skynext", "mystart", "mymins", "xmini", "mymax", "mymin", "xstart", "myonly", "syrange", "ymins", "ystat", "ymid", "ysum", "skymax", "sysum", " ystat", "zstart", "yymax", "ymini", "symid", "xrange", "eymax", "ynext", "ystart", "syonly", "eymid", " yonly", "xonly", "eymini", "yonly", "xsum", "znext", "yymin", "yymins", "yystart", "symin", "skystart", "zmin", "xnext", "skymin", " ysum"], "xmax": ["yrange", " xMax", "eyactive", "eymin", "ixmin", "xrand", "txmin", "xwrap", "ywrap", "eywrap", "eyrange", "mystart", "mymax", "mywrap", "ixmax", "mymin", "Xrand", "txax", "xstart", "yrand", "xax", "xactive", "exstart", "eymax", "xrange", "oxmin", "ystart", "ixax", "eyMax", "myactive", "xpress", "txstart", "eypress", "yactive", "oxmax", "exmin", "exax", "txmax", "oxrand", "xMax", "Xmin", "yax", "exmax", "eystart", "oxax", "mypress", "Xax", "ypress", "Xmax", "yMax", " xrange"], "ymax": ["ymak", "yanode", "ymaxy", "symax", "yrax", "ymmas", "ypac", "yraxy", "ymazon", "iemay", "mmazon", "ymmaxy", "ymac", "ypmax", "yrak", "pmin", "emin", "iemax", "ypin", "yras", "ymmak", "ypark", "ymode", "yanark", "symake", "symay", "mmaz", "ypake", "pmmax", "pmark", "yanmax", "ypay", "yanax", "ymaz", "ymase", "iemac", "ymoss", "pmase", "ymake", "ypax", "ypaz", "yoss", "ypate", "iemoss", "ypaxy", "ymmase", "symac", "ymay", "pmode", "ymmax", "mmax", "iemake", "yax", "emmax", "ymmaz", "ypak", "ymate", "ypas", "ypazon", "iemmax", "yate", "ymmazon", "pmax", "ypase", "iemate", "emase", "mmase", "yposs", "ymas", "ymark", "ypode", "emax"], "rel_xmin": ["rel_xypos", "rel_xmins", "rel_xymin", "rel_ypos", "rel_xyf", "rel_txmin", "rel_txf", "rel_axmax", "rel_axmin", "rel_Xmins", "rel_Xmin", "rel_xf", "rel_Xmax", "rel_xpos", "rel_axmins", "rel_ymins", "rel_txmax", "rel_txpos", "rel_xymax", "rel_yf"], "rel_ymin": ["rel_ymonly", "rel_ymmin", "rel_ymmax", "rel_xonly", "rel_xmid", "rel_tymax", "rel_yonly", "rel_yamax", "rel_yamin", "rel_ystat", "rel_yamid", "rel_ymid", "rel_xstat", "rel_tymin", "rel_yastat", "rel_yaonly", "rel_tymid", "rel_tystat"], "rel_xmax": ["rel_hmin", "rel_eyax", "rel_yfrom", "rel_Xmed", "rel_Xmin", "rel_eymin", "rel_xax", "rel_eymax", "rel_zmin", "rel_hax", "rel_Xmax", "rel_xmed", "rel_ymed", "rel_xfrom", "rel_zmed", "rel_hfrom", "rel_hmax", "rel_yax", "rel_eyfrom", "rel_zmax"], "rel_ymax": ["rel_ymmin", "rel_pmaz", "rel_pmap", "rel_ymmax", "rel_ypmax", "rel_mmmax", "rel_ymaz", "rel_mxmin", "rel_ypax", "rel_mxax", "rel_mmmin", "rel_yaz", "rel_mmin", "rel_pmax", "rel_ypap", "rel_mxin", "rel_pmmax", "rel_yax", "rel_ypaz", "rel_ymap", "rel_mxmax", "rel_yin", "rel_mmax", "rel_yap"], "P": ["Y", "D", "M", "B", "Q", "Ps", "K", "Port", "L", "R", "Picture", "H", " p", "PS", "X", "O", "API", "E", "PR", "BP", "N", "PRE", "U", "T", "F", "p", "PO", "PT", "G", "PUT", "PA", "S", "A", "Point", "J", " N", "C", "V", "PIN"]}}
{"project": "FFmpeg", "commit_id": "ecb14b8af73b92e5a1be47c119d2f528ff402ebd", "target": 0, "func": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n\n    MpegEncContext * const s = &h->s;\n\n    AVCodecContext * const avctx= s->avctx;\n\n    H264Context *hx; ///< thread context\n\n    int buf_index;\n\n    int context_count;\n\n    int next_avc;\n\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n\n    int nal_index;\n\n\n\n    h->nal_unit_type= 0;\n\n\n\n    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;\n\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n\n        h->current_slice = 0;\n\n        if (!s->first_field)\n\n            s->current_picture_ptr= NULL;\n\n        ff_h264_reset_sei(h);\n\n    }\n\n\n\n    for(;pass <= 1;pass++){\n\n        buf_index = 0;\n\n        context_count = 0;\n\n        next_avc = h->is_avc ? 0 : buf_size;\n\n        nal_index = 0;\n\n    for(;;){\n\n        int consumed;\n\n        int dst_length;\n\n        int bit_length;\n\n        uint8_t *ptr;\n\n        int i, nalsize = 0;\n\n        int err;\n\n\n\n        if(buf_index >= next_avc) {\n\n            if (buf_index >= buf_size - h->nal_length_size) break;\n\n            nalsize = 0;\n\n            for(i = 0; i < h->nal_length_size; i++)\n\n                nalsize = (nalsize << 8) | buf[buf_index++];\n\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n\n                break;\n\n            }\n\n            next_avc= buf_index + nalsize;\n\n        } else {\n\n            // start code prefix search\n\n            for(; buf_index + 3 < next_avc; buf_index++){\n\n                // This should always succeed in the first iteration.\n\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n\n                    break;\n\n            }\n\n\n\n            if(buf_index+3 >= buf_size) break;\n\n\n\n            buf_index+=3;\n\n            if(buf_index >= next_avc) continue;\n\n        }\n\n\n\n        hx = h->thread_context[context_count];\n\n\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n\n        if (ptr==NULL || dst_length < 0){\n\n            return -1;\n\n        }\n\n        i= buf_index + consumed;\n\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n\n        while(dst_length > 0 && ptr[dst_length - 1] == 0)\n\n            dst_length--;\n\n        }\n\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n        }\n\n\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n\n        }\n\n\n\n        buf_index += consumed;\n\n        nal_index++;\n\n\n\n        if(pass == 0) {\n\n            // packets can sometimes contain multiple PPS/SPS\n\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n\n            // if so, when frame threading we can't start the next thread until we've read all of them\n\n            switch (hx->nal_unit_type) {\n\n                case NAL_SPS:\n\n                case NAL_PPS:\n\n                    nals_needed = nal_index;\n\n                    break;\n\n                case NAL_IDR_SLICE:\n\n                case NAL_SLICE:\n\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n\n                    if (!get_ue_golomb(&hx->s.gb))\n\n                        nals_needed = nal_index;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        //FIXME do not discard SEI id\n\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n\n            continue;\n\n\n\n      again:\n\n        err = 0;\n\n        switch(hx->nal_unit_type){\n\n        case NAL_IDR_SLICE:\n\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n\n                return -1;\n\n            }\n\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n\n        case NAL_SLICE:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= &hx->s.gb;\n\n            hx->s.data_partitioning = 0;\n\n\n\n            if((err = decode_slice_header(hx, h)))\n\n               break;\n\n\n\n            if (   h->sei_recovery_frame_cnt >= 0\n\n                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {\n\n                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n\n                                    (1 << h->sps.log2_max_frame_num);\n\n            }\n\n\n\n            s->current_picture_ptr->f.key_frame |=\n\n                    (hx->nal_unit_type == NAL_IDR_SLICE);\n\n\n\n            if (h->recovery_frame == h->frame_num) {\n\n                h->sync |= 1;\n\n                h->recovery_frame = -1;\n\n            }\n\n\n\n            h->sync |= !!s->current_picture_ptr->f.key_frame;\n\n            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);\n\n            s->current_picture_ptr->sync = h->sync;\n\n\n\n            if (h->current_slice == 1) {\n\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n\n                    decode_postinit(h, nal_index >= nals_needed);\n\n                }\n\n\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n\n                    return -1;\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    ff_vdpau_h264_picture_start(s);\n\n            }\n\n\n\n            if(hx->redundant_pic_count==0\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL){\n\n                if(avctx->hwaccel) {\n\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n\n                        return -1;\n\n                }else\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n\n                }else\n\n                    context_count++;\n\n            }\n\n            break;\n\n        case NAL_DPA:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= NULL;\n\n\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n\n                break;\n\n\n\n            hx->s.data_partitioning = 1;\n\n\n\n            break;\n\n        case NAL_DPB:\n\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n\n            hx->intra_gb_ptr= &hx->intra_gb;\n\n            break;\n\n        case NAL_DPC:\n\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n\n               && s->context_initialized\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL)\n\n                context_count++;\n\n            break;\n\n        case NAL_SEI:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_sei(h);\n\n            break;\n\n        case NAL_SPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){\n\n                av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, trying alternative mode\\n\");\n\n                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);\n\n                init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));\n\n                ff_h264_decode_seq_parameter_set(h);\n\n            }\n\n\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n\n                s->low_delay=1;\n\n\n\n            if(avctx->has_b_frames < 2)\n\n                avctx->has_b_frames= !s->low_delay;\n\n            break;\n\n        case NAL_PPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n\n\n            break;\n\n        case NAL_AUD:\n\n        case NAL_END_SEQUENCE:\n\n        case NAL_END_STREAM:\n\n        case NAL_FILLER_DATA:\n\n        case NAL_SPS_EXT:\n\n        case NAL_AUXILIARY_SLICE:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n\n        }\n\n\n\n        if(context_count == h->max_contexts) {\n\n            execute_decode_slices(h, context_count);\n\n            context_count = 0;\n\n        }\n\n\n\n        if (err < 0)\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n\n        else if(err == 1) {\n\n            /* Slice could not be decoded in parallel mode, copy down\n\n             * NAL unit stuff to context 0 and restart. Note that\n\n             * rbsp_buffer is not transferred, but since we no longer\n\n             * run in parallel mode this should not be an issue. */\n\n            h->nal_unit_type = hx->nal_unit_type;\n\n            h->nal_ref_idc   = hx->nal_ref_idc;\n\n            hx = h;\n\n            goto again;\n\n        }\n\n    }\n\n    }\n\n    if(context_count)\n\n        execute_decode_slices(h, context_count);\n\n    return buf_index;\n\n}\n", "idx": 19724, "substitutes": {"h": ["g", "header", "f", "http", "hi", "u", "oh", "sh", "bh", "eh", "t", "q", "uh", "rh", "d", "H", "ch", "hw", "j", "th", "hl", "o", "ctx", "hr", "w", "c", "p", "ha", "han", "he", "gh", "b", "hp", "ih", "hh", "home", "hd", "handler", "e", "ph", "l", "hs", "history", "hist", "ah", "hm", "ht", "v", "host", "m"], "buf": ["batch", "header", "vec", "map", "output", "grad", "src", "uf", "cmd", "uc", "queue", "bc", "cur", "buffer", "Buffer", "pool", "wb", "conv", "config", "ff", "begin", "pb", "code", "img", "input", "data", "ctx", "grab", "cap", "rb", "cf", "bag", "cv", "b", "fb", "context", "rc", "cb", "bus", "seq", "cmp", "text", "port", "que", "box", "buff", "v", "Buff", "alloc", "br"], "buf_size": ["buf_length", "buf0number", "buf_SIZE", "queue_index", " buf_sync", "bufjnumber", " buf_offset", " buf_scale", "queue_size", "bufjindex", "buf_number", "queue_count", "buf_offset", "buf_loc", " buf_loc", "buf_source", "buf0index", "buf0offset", "buf_sync", " buf_source", "buf_scale", "buf_count", "bufjsize", " buf_number", "queue_length", "buf0size", "bufjoffset", " buf_SIZE"], "s": ["g", "client", "session", "js", "sh", "support", "r", "gs", "conf", "c", "b", "ssl", "sl", "su", "fs", "network", "qs", "setup", "m", "server", "sf", "http", "cli", "u", "op", "in", "ns", "site", "si", "sch", "es", "us", "p", "sb", "ts", "services", "sv", "l", "sync", "f", "rs", "ss", "sq", "n", "input", "o", "ctx", "sci", "xs", "sup", "S", "sg", "ses", "share", "hs", "spec", "is", "ys", "cs", "resource", "sys", "sa", "ps", "t", "d", "storage", "ls", "w", "service", "e", "sc", "ds", "v", "settings"], "avctx": ["avscl", "evctx", "afctx", "avecu", "AVconfig", "abcontext", "abctx", " avscl", "abcb", "avcci", "avcmp", "afconf", "broadcci", "avectx", " avcontext", "avcontext", "avcb", "avconfig", " avcmp", "AVctx", "afcb", "avecontext", " avcb", "evscl", " avconf", "AVcmp", "AVcontext", "afcci", "evcmp", "AVcci", "avcu", "abconfig", "afcu", "broadctx", "broadcmp", "afconfig", "abcu", "avconf", "evconf", "abcmp", " avconfig", "avecmp", "broadcontext", "AVconf", "afcmp", "afcontext", "AVscl"], "hx": ["rhxc", " hct", "phx", " hxc", "phxc", "phtx", "phct", "rhtx", "hxc", " htx", "rhct", "htx", "hct", "rhx"], "buf_index": ["vecPindex", "fp00prefix", "buf_length", "vecPcount", "uf_update", "bufssize", "bufallindex", "buf_default", "bufamcondition", "buf64diff", "bufPindex", "uf_size", "buflexcount", "buf_Index", "fp00index", "seq_prefix", "seqPprefix", "bufallprefix", "buflexbody", "buf_site", "buf_condition", "bufamprefix", "uf_body", "bufamIndex", "bufsupdate", "bufamind", "queue_index", "seq_ind", "fb_date", "buf_height", "bufPinc", "seqPind", "uf_prefix", "queue_type", "buflexheight", "buf00label", "fp_index", "buf00ind", "buf0inc", "buf_type", "cv_site", "buf_date", "bufsindex", "buf64count", "bufCdefault", "fb_default", "buf_label", "buflexsize", "buf_diff", "bufCindex", "buf_number", "queue_size", "buf00index", "fp_number", "bufallnumber", "vec_diff", "uf_condition", "vecPdiff", "bufPprefix", "fp_ind", "bufMindex", "bufPdiff", "buflexindex", "buf00size", "buf_handle", "bufCdate", "bufMsite", "buf1ind", "queue_inc", "bufPind", "fp_prefix", "buf1index", "buf00prefix", "fb_index", "buf_ini", "fb_ini", "seq_index", "bufamsite", "bufamnumber", "buf_body", "buffer_size", "cv_index", "seqPindex", "buf0index", "buf0type", "vec_count", "buf_prefix", "cv_handle", "buf1site", "buf_inc", "fp00number", "buf64inc", "bufamsize", "bufMhandle", "vec_inc", "buf_ind", "vec_index", "buffer_count", "queue_label", "bufamindex", "seq_site", "bufPsite", "buffer_index", "seqPsite", "bufCini", "buf_count", "uf_index", "uf_Index", "fp00ind", "cv_size", "bufPcount", "buflexupdate", "buf0size", "queue_length", "buf1prefix", "buf00site", "buf00number", "bufamhandle", "bufsbody", "bufMsize", "buffer_height", "buf00length", "bufallind", "buf64index", "buf_update", "vecPinc"], "context_count": ["contextfnumber", " contextslimit", " context_number", " contextsnum", " context_len", " context_size", "context__count", "context_limit", "context_size", "context__group", "context__number", " contextslen", "contextalllen", "contextallnum", "context_len", "contextfcount", "contextallcount", "context_number", "context0number", "context__size", " context0group", "context_num", " context_limit", " context0count", "context0group", "context_group", "context0count", "contextscount", " context0size", "contextfsize", "context0size", " context_num", "contextslimit", " contextscount", "contextalllimit", " context0number", "contextslen", "contextsnum", " context_group", "contextfgroup"], "next_avc": ["next_AVac", "next_avlc", "next_ajc", "next_avecs", "next_AVc", "next_afcs", "next_umarc", "next_avp", "next_awci", "next_avep", "next_afrc", "next_awcs", "next_umci", "next_alp", "next_afarc", "next_aff", "next_ajf", "next_calp", "next_awcu", "next_afcu", "next_avf", "next_avac", "next_afp", "next_avcs", "next_avci", "next_umcu", "next_ajrc", "next_avpc", "next_avepc", "next_avrc", "next_ajac", "next_ajpc", "next_aveci", "next_calc", "next_awp", "next_avec", "next_afci", "next_calci", "next_awc", "next_alc", "next_awarc", "next_alci", "next_AVlc", "next_avef", "next_avcu", "next_callc", "next_umc", "next_ajlc", "next_afc", "next_aflc", "next_AVrc", "next_afac", "next_allc", "next_averc", "next_afpc", "next_avarc"], "nal_index": ["nal_size", "nals_count", "naler_Index", "nal_count", "naler_i", "naler_size", "nal_type", "nal_i", "nals_index", "naler_index", "nals_type", "nal_Index", "nals_Index"], "pass": ["section", "skip", "PASS", "scan", "asses", "proc", "match", "result", "parent", "level", "access", "success", "fast", "flow", "sw", "test", "feed", "fail", "ride", "catch", "parse", "code", "act", "Pass", "call", "miss", "loop", "gen", "post", "pos", "stage", "thread", "cr", "process", "strip", "acc", "ass", "step", "run", "pull", "rupt", "row", "port", "password", "sc", "push", "j"], "consumed": [" unconsumption", "resensus", "resumed", " unconsensus", "cosumed", "conserved", "coserved", "cosumption", "resumption", " unconsumed", "reserved", "cosensus", "consumption", "consensus", " unconserved"], "dst_length": ["dst_long", "dst___length", "dst___address", "dst_len", "dst___long", "dbl_long", "dbl_address", "dbl_length", "dst___len", "dbl_len", "dst_address"], "bit_length": ["bit___width", "byte_len", "byte_width", "bit___len", "bit_width", "bit_len", "bit_limit", "byte_limit", "bit___length", "byte_length", "bit___limit"], "ptr": ["val", "str", "vec", "grad", "pt", "src", "proc", "pad", "dim", "buffer", "tr", "fd", "code", "addr", "data", "loc", "pos", "pointer", "desc", "slice", "rc", "attr", "seq", "cmp", "port", "buff", "alloc"], "i": ["phi", "di", "uli", "f", "ri", "xi", "x", "qi", "ci", "li", "eni", "bi", "ji", "uri", "d", "mi", "n", "len", "ip", "pi", "si", "I", "jit", "id", "multi", "index", "chi", "ai", "iu", "ii", "p", "ki", "z", "slice", "mini", "ui", "ni", "zi", "gi", "attr", "fi", "e", "l", "io", "ini", "ti", "j", "info"], "err": ["inner", "f", "result", " error", "in", "res", "success", "error", " rc", "found", "init", "code", "frac", "rx", " arr", "pack", "aa", "ea", "pos", "def", " res", "resp", " success", "e", " r", " errors", "comp"]}}
{"project": "FFmpeg", "commit_id": "611b35627488a8d0763e75c25ee0875c5b7987dd", "target": 1, "func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n\n                                const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext *pc = &dctx->pc;\n\n    uint64_t state = pc->state64;\n\n    int pic_found = pc->frame_start_found;\n\n    int i = 0;\n\n\n\n    if (!pic_found) {\n\n        for (i = 0; i < buf_size; i++) {\n\n            state = (state << 8) | buf[i];\n\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n\n                i++;\n\n                pic_found = 1;\n\n                dctx->cur_byte = 0;\n\n                dctx->remaining = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (pic_found && !dctx->remaining) {\n\n        if (!buf_size) /* EOF considered as end of frame */\n\n            return 0;\n\n        for (; i < buf_size; i++) {\n\n            dctx->cur_byte++;\n\n            state = (state << 8) | buf[i];\n\n\n\n            if (dctx->cur_byte == 24) {\n\n                dctx->h = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 26) {\n\n                dctx->w = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 42) {\n\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n\n\n                if (cid <= 0)\n\n                    continue;\n\n\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n\n                if (dctx->remaining <= 0) {\n\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n\n                    if (dctx->remaining <= 0)\n\n                        return dctx->remaining;\n\n                }\n\n                if (buf_size - i + 47 >= dctx->remaining) {\n\n                    int remaining = dctx->remaining;\n\n\n\n                    pc->frame_start_found = 0;\n\n                    pc->state64 = -1;\n\n                    dctx->cur_byte = 0;\n\n                    dctx->remaining = 0;\n\n                    return remaining;\n\n                } else {\n\n                    dctx->remaining -= buf_size;\n\n                }\n\n            }\n\n        }\n\n    } else if (pic_found) {\n\n        if (dctx->remaining > buf_size) {\n\n            dctx->remaining -= buf_size;\n\n        } else {\n\n            int remaining = dctx->remaining;\n\n\n\n            pc->frame_start_found = 0;\n\n            pc->state64 = -1;\n\n            dctx->cur_byte = 0;\n\n            dctx->remaining = 0;\n\n            return remaining;\n\n        }\n\n    }\n\n    pc->frame_start_found = pic_found;\n\n    pc->state64 = state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 19728, "substitutes": {"dctx": ["docam", "ldctx", "sdlc", "dhctx", " dlc", "dcp", " dgb", "dscp", "daycache", " dcontext", "dogb", "dhcam", "odqa", "dctrl", "dbc", "dotx", "pdctx", " dsci", "edcf", "r", "Dpkg", "dloc", "block", "dsbc", " dloc", "sdcontext", "dtx", "ndxc", " dqa", "dcam", " dcp", "daycontext", "Dcam", "odcp", "delctx", "docfg", "Dcmp", "edcontext", "dcache", "dsctx", "datcp", "dcfg", "ldlc", "datcfg", "nloc", "dlcam", "dchan", " dcfg", "sdcfg", "ndlc", "pdpkg", "sdpkg", "sdchan", "sdctx", "dhcfg", "vdcp", "datsci", "sdcp", "dscf", "ncontext", "dgb", "ncus", " dcas", "ldcas", "sdcf", "dhctrl", "addr", "sdgc", "datpkg", "dlctx", "datchan", "ldcf", "dsci", "dqa", "s", "vdcontext", "doctx", "vdpkg", "dslc", "dlloc", "dcli", "delcss", "edgb", "edcca", "ldcmp", "pdctrl", "nkb", "dxc", "bdctx", "comp", "ztx", "Dxc", "this", "dlcontext", "datcmp", "bdpkg", "pdcontext", "pdcli", "madkb", "delcontext", "odcontext", "_", "ndcontext", "dogc", "zcontext", "Dctx", "zgc", "sdsci", "pdcam", " dpkg", "madloc", "dkb", "dlcus", "dcss", " dcmp", "pdgc", "doctrl", "dgc", "pos", "func", "Dloc", "odctx", "sdcmp", "zctx", "vdctx", "datctx", "dpkg", "dscontext", "Dcli", "odcam", "odcca", "dayctx", " dcss", "Dqa", "zlc", "ndctx", "ndcf", "dlc", "pdsci", "sdbc", "bdcli", "dlcache", "dcas", "dcf", " dxc", "edcam", "Dcontext", "nlc", "dcus", "madcontext", " dtx", " dcus", "Dlc", "dcmp", "pdcfg", "Dcf", "sdcas", "dcca", " dkb", "Dcp", "bdcontext", "nctx", " dcf", "ldcontext", " dchan", " dgc", "daycam", "docf", "delcmp", "docontext", "edctx", "dcontext", "pdlc", " dbc", "Dcss", "Dcca", "zcf", "Dkb", "madctx", "Dcache", "ctr", " dcli"], "buf": ["batch", "wave", "header", "vec", "src", "uf", "proc", "cmd", "uc", "queue", "bc", "buffer", "wb", "pool", "Buffer", "conv", "fd", "config", "aux", "ff", "pb", "img", "data", "cas", "block", "grab", "cap", "rb", "cf", "sb", "bag", "cv", "pos", "func", "ptr", "context", "alloc", "cb", "rc", "fi", "seq", "num", "mem", "ab", "port", "que", "box", "buff", "fb", "br"], "buf_size": ["buf_length", "seq_number", "buflenlength", "buf_SIZE", "buf4end", "seq_size", "seq_handle", "buflensize", "buf_chain", "buf_width", "buf_found", "queue_found", " buf_chain", "buf_number", "queue_size", "cb_end", "buf4Size", "buf_Size", "buf_handle", "buf_loc", "cb_Size", "bufksize", " buf_length", "buf4size", "bufkloc", "buf_sized", "queue_scale", "queue_sized", "queue_time", "seq_loc", "buf_time", "buf4width", "buf_shape", "bufknumber", "bufkhandle", "queue_SIZE", "buf_scale", "cb_size", " buf_shape", "buflenchain", "buf_end", "cb_width", " buf_Size"], "pc": ["cca", "cp", "cs", "dc", "client", "sys", "pt", "proc", "sa", "pd", "uc", "bc", "nc", "inc", "ac", "ci", "lp", "conn", "py", "cz", "bp", "pm", "toc", "cms", "si", "enc", "pac", "plugin", "pa", "pb", "con", "ctx", "ec", "lc", "loc", "ca", "pre", "c", "jc", "p", "fp", "cc", "vc", "roc", "cr", "cus", "tc", "PC", "ct", "wcs", "arc", "mc", "gb", "px", "pid", "anc", "xc", "sc", "fc", "pin", "pr", "amp"], "i": ["g", "phi", "di", "my", "f", "ri", "xi", "hi", "qi", "ix", "u", "x", "ci", "li", "eni", "bi", "it", "ji", "uri", "mi", "n", "ip", "si", "pi", "I", "multi", "id", "state", "h", "ai", "index", "init", "r", "iu", "o", "esi", "ii", "c", "k", "p", "y", "b", "ki", "z", "slice", "m", "ui", "ni", "zi", "gi", "ami", "fi", "yi", "e", "l", "ori", "io", "oi", "ie", "ini", "v", "ti", "j", "info"], "cur_byte": ["char_binary", " cur_layer", "curJframe", "cur_large", "cur_binary", "curJword", "curIPword", "charJbyte", "cur__binary", " cur_channel", "char_byte", "charJframe", "cur_pixel", "cur__word", " cur_large", "curJbit", "cur_channel", "charJbinary", "cur__channel", "cur_word", "cur__bit", " cur_bit", " cur_hop", "cur_frame", "cur__byte", " cur_source", "curIPlarge", " cur_binary", "cur_hop", " cur_pixel", "cur__source", "cur_bit", " cur_bytes", "char_frame", "curJbinary", "charJbit", "cur_source", " cur_word", "curIPlayer", "cur__bytes", "char_bit", "curIPbyte", "cur_bytes", "cur_layer", "curJbyte"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext      *ctx = avctx->priv_data;\n\n    VAAPIEncodeH264Context *priv = ctx->priv_data;\n\n    int hrd_buffer_size;\n\n    int hrd_initial_buffer_fullness;\n\n\n\n    if (avctx->bit_rate > INT32_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Target bitrate of 2^31 bps or \"\n\n               \"higher is not supported.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size)\n\n        hrd_buffer_size = avctx->rc_buffer_size;\n\n    else\n\n        hrd_buffer_size = avctx->bit_rate;\n\n    if (avctx->rc_initial_buffer_occupancy)\n\n        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;\n\n    else\n\n        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;\n\n\n\n    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;\n\n    priv->rc_params.rc = (VAEncMiscParameterRateControl) {\n\n        .bits_per_second   = avctx->bit_rate,\n\n        .target_percentage = 66,\n\n        .window_size       = 1000,\n\n        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),\n\n        .min_qp            = (avctx->qmin >= 0 ? avctx->qmin : 18),\n\n        .basic_unit_size   = 0,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->rc_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->rc_params);\n\n\n\n    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;\n\n    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {\n\n        .initial_buffer_fullness = hrd_initial_buffer_fullness,\n\n        .buffer_size             = hrd_buffer_size,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->hrd_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->hrd_params);\n\n\n\n    // These still need to be  set for pic_init_qp/slice_qp_delta.\n\n    priv->fixed_qp_idr = 26;\n\n    priv->fixed_qp_p   = 26;\n\n    priv->fixed_qp_b   = 26;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\"PRId64\" bps.\\n\",\n\n           avctx->bit_rate);\n\n    return 0;\n\n}\n", "idx": 19759, "substitutes": {"avctx": ["ovqa", "varcmp", "ovcontext", "navcb", "avcrit", "avqa", "vercmp", "avkb", "navctl", "afctrl", "navctrl", "avcu", " avqa", "awctrl", "avalcdn", "avcdn", "AVloc", "evctx", "avecf", "AVcam", "aupkg", "avalcoll", "avconn", "evcf", "AVcdn", "varcam", "avalcomponent", "avcmp", "AVcrit", "awcontext", "Avloc", "avectx", "verkb", "avcontext", "afconn", "avcb", "avctrl", "verctx", "AVcoll", "AVctx", "avecontext", "avpkg", "varcontext", "avcomponent", "varcdn", "AVcontext", "varsc", "AVcf", " avconn", "AVctl", " avcli", "aucontext", "afcontext", "avcoll", "navcli", "Avcontext", " avctl", "Avconn", "evcontext", "avalcontext", "awctx", "afsc", "avcca", "evcu", "afpkg", "varctx", "ovcca", "avalcms", "avloc", "AVsc", "avctl", "varcomponent", "navcoll", "varctl", "AVcli", "avcas", "avalctx", "Avctx", "AVqa", "AVconn", "AVcomponent", "navcontext", "ovctx", "avcli", "AVkb", "AVpkg", "afctx", "avecu", "afcas", "awcas", "avalcrit", "afkb", " avcontext", "varconn", "auctx", "AVcca", "afcam", "navcas", "aucmp", "AVcmp", "AVcb", "avalcb", "avcf", "vercontext", "AVcu", "navctx", "AVcms", "avcms", "avcam", "avsc", " avcca", "afcmp", "afloc", "navcms", "verconn", "navcrit"], "ctx": ["client", "component", "jp", "ci", "exec", "r", "act", "cf", "c", "vc", "Context", "context", "voc", "ctrl", "utils", "cdn", "cm", "acl", "cli", "nc", "np", "hw", "lib", "qa", "cas", "fp", "s", "cam", "pkg", "wcs", "url", "cu", "kb", "sync", "cp", "src", "this", "ck", "cmd", "bc", "sq", "crit", "_", "config", " context", "lc", "cc", "sci", "func", "cus", "git", "cb", "rc", "cn", "cca", "cs", "sys", "conn", "loc", "ca", "all", "cv", "tx", "tc", "cmp", "anc", "xc", "sc"], "priv": ["cs", "cp", "rec", "txt", "sys", "Priv", "pc", "proc", "uc", "riv", "bc", "cache", "temp", "ci", "access", "conn", "api", "kr", "org", "req", "exec", "obj", "ch", "pi", "rib", "config", "dev", "auth", "pub", "storage", "private", "pb", "ocr", "data", "cap", "lc", "typ", "cert", "stat", "ca", "cf", "sk", "conf", "ce", "gr", "prem", "public", "kw", "cy", "vc", "tx", "pkg", "ptr", "auc", "neg", "cfg", "context", "soc", "prof", "git", "rc", "attr", "sec", "voc", "gb", "cmp", "utils", "pro", "anc", "spec", "pri", "info"], "hrd_buffer_size": ["hrd_queue_rate", "hrd_reference_width", "hrd_buffer__rate", "hrd_buffer_strength", "hrd_bufferamtype", "hrd_reference___size", "hrd_buffer_rate", "hrd_buffer_small", "hrd_buffer64width", "hrd_bufferactype", "hrd_buffer64exclusive", "hrd_bufferamstrength", "hrd_buffer__size", "hrd_buffer___width", "hrd_bufferacstrength", "hrd_queue_size", "hrd_bufferacsize", "hrd_queue_type", "hrd_buffer_exclusive", "hrd_bufferamcapacity", "hrd_reference_exclusive", "hrd_queue_capacity", "hrd_buffer__small", "hrd_buffer64fee", "hrd_buffer_capacity", "hrd_buffer___fee", "hrd_queue_length", "hrd_queue_ize", "hrd_bufferacize", "hrd_buffer_width", "hrd_reference_fee", "hrd_bufferamsize", "hrd_reference___width", "hrd_queue_strength", "hrd_buffer_fee", "hrd_buffer___exclusive", "hrd_reference___fee", "hrd_queue_scale", "hrd_buffer_type", "hrd_bufferaccapacity", "hrd_buffer64size", "hrd_queue_small", "hrd_buffer_scale", "hrd_reference___exclusive", "hrd_reference_size", "hrd_buffer_length", "hrd_buffer___size", "hrd_buffer_ize"], "hrd_initial_buffer_fullness": ["hrd_initial_buffer_shortness", "hrd_initial_buffer__fulness", "hrd_initial_buffer__fulment", "hrd_initial_buffer_fity", "hrd_initial_buffer_minlength", "hrd_initial_buffer_fulment", "hrd_initial_buffer_shortsize", "hrd_initial_buffer_widesize", "hrd_initial_buffer_fstrength", "hrd_initial_buffer_fuliness", "hrd_initial_buffer_fulsize", "hrd_initial_buffer_shortstrength", "hrd_initial_buffer__fullsize", "hrd_initial_buffer__fulsize", "hrd_initial_buffer_fullment", "hrd_initial_buffer_minsize", "hrd_initial_buffer_fullsize", "hrd_initial_buffer_fulness", "hrd_initial_buffer__fuliness", "hrd_initial_buffer_fsize", "hrd_initial_buffer_shortiness", "hrd_initial_buffer_longocity", "hrd_initial_buffer_fulllength", "hrd_initial_buffer__fullment", "hrd_initial_buffer_fness", "hrd_initial_buffer_shortment", "hrd_initial_buffer_halfness", "hrd_initial_buffer_freeity", "hrd_initial_buffer_longsize", "hrd_initial_buffer_minness", "hrd_initial_buffer_halflength", "hrd_initial_buffer_longness", "hrd_initial_buffer_fullity", "hrd_initial_buffer_widelength", "hrd_initial_buffer_longlength", "hrd_initial_buffer__fullness", "hrd_initial_buffer_wideness", "hrd_initial_buffer_shortlength", "hrd_initial_buffer_halfsize", "hrd_initial_buffer_minocity", "hrd_initial_buffer_fullstrength", "hrd_initial_buffer_freesize", "hrd_initial_buffer_wideocity", "hrd_initial_buffer_halfstrength", "hrd_initial_buffer__fulliness", "hrd_initial_buffer_freeness", "hrd_initial_buffer_fullocity", "hrd_initial_buffer_freestrength", "hrd_initial_buffer_fulliness"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)\n\n{\n\n\tlong x,y;\n\n\n\n\tdst[0]= src[0];\n\n\n\n\t// first line\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n\n\n        dst+= dstStride;\n\n\n\n\tfor(y=1; y<srcHeight; y++){\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\t\tconst long mmxSize= srcWidth&~15;\n\n\t\tasm volatile(\n\n\t\t\t\"mov %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_a\"), %%mm1\t\\n\\t\"\n\n\t\t\t\"movq 1(%0, %%\"REG_a\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"movq 1(%1, %%\"REG_a\"), %%mm3\t\\n\\t\"\n\n\t\t\t\"movq -1(%0, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movq -1(%1, %%\"REG_a\"), %%mm5\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm5, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm4, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm3, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm2, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\"\n\n#if 1\n\n\t\t\tMOVNTQ\" %%mm5, (%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm4, (%3, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#else\n\n\t\t\t\"movq %%mm5, (%2, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\t\"movq %%mm4, (%3, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#endif\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\t:: \"r\" (src + mmxSize  ), \"r\" (src + srcStride + mmxSize  ),\n\n\t\t\t   \"r\" (dst + mmxSize*2), \"r\" (dst + dstStride + mmxSize*2),\n\n\t\t\t   \"g\" (-mmxSize)\n\n\t\t\t: \"%\"REG_a\n\n\n\n\t\t);\n\n#else\n\n\t\tconst long mmxSize=1;\n\n#endif\n\n\t\tdst[0        ]= (3*src[0] +   src[srcStride])>>2;\n\n\t\tdst[dstStride]= (  src[0] + 3*src[srcStride])>>2;\n\n\n\n\t\tfor(x=mmxSize-1; x<srcWidth-1; x++){\n\n\t\t\tdst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;\n\n\t\t\tdst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;\n\n\t\t}\n\n\t\tdst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;\n\n\t\tdst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;\n\n\n\n\t\tdst+=dstStride*2;\n\n\t\tsrc+=srcStride;\n\n\t}\n\n\n\n\t// last line\n\n#if 1\n\n\tdst[0]= src[0];\n\n\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n#else\n\n\tfor(x=0; x<srcWidth; x++){\n\n\t\tdst[2*x+0]=\n\n\t\tdst[2*x+1]= src[x];\n\n\t}\n\n#endif\n\n\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 19782, "substitutes": {"src": ["uv", "bs", "ruby", "split", "proc", "sr", "lat", "support", "st", "stream", "RC", "ssl", "b", "sl", "image", "sec", "gb", "scenes", "sub", "rob", "http", "reflect", "inst", "source", "buf", "req", "asc", "lib", "img", "usr", "sb", "gl", "desc", "url", "filename", "expl", "fc", "ser", "comp", "sync", "scl", "uc", "rs", "sq", "conv", "rib", "config", "iv", "rss", "ctx", "rb", "sci", "sup", "impl", "dist", "sel", "rc", "rect", "spec", "secure", "sys", "supp", "chrom", "transform", "feat", "cur", "upload", "pack", "loc", "cv", "sur", "slice", "gz", "dest", "seq", "sth", "sc"], "dst": ["ndST", " dsts", "dssrc", "dsst", "ndst", "Dst", " dsc", "lsl", " dsl", "frc", " drc", "idost", "dbl", "ndconst", "lst", "pdsts", "idst", "dconst", " dconst", "pdst", "dsts", "fsts", "fconst", "drest", "adsts", "Dsts", "fst", "pdbl", "adsl", "lste", "adrest", "dST", " ddest", "idbl", "dste", "dost", "dsl", "ndsts", " dste", "dssc", "fsc", "drc", "adste", "dsconst", " dost", " drest", "dssts", " dbl", "idrest", "dsc", "ddest", "Dconst", "adsc", "adconst", "adst", "Dste", "fsrc", "dsrc", "DST", "adbl", "pddest", " dsrc", " dST", "adost", "addest", "lsc"], "srcWidth": ["destHeight", "rcwidth", " srcSize", "rcSize", "sourceLength", "srcwidth", "rcLen", "srcLen", "rcLength", "destWidth", "rcHeight", "sourceLen", " srcLen", "sourceHeight", "srcLength", "destLength", "srcSize", " srcLength", "destwidth", "sourceSize", " srcwidth", "rcWidth", "sourceWidth", "sourcewidth"], "srcHeight": [" srcLevel", "sourceLength", "stLevel", "rcLength", "srcTop", "rcHeight", "sourceTop", "sourceLevel", "srcLevel", "sourceHeight", "srcLength", " srcTop", "rcTop", "stHeight", " srcLength", "stLength", "rcWidth", "stWidth", "sourceWidth"], "srcStride": ["srcStair", "sourceRestr", "srcstrip", "rcstrict", "rcstrip", "srcEstrict", "srcstride", "srcShrict", "sourceRestair", "sourceRestrite", "srcWair", "srcStrict", "srcstrite", "srcWride", "srcEstride", "srcEstrip", "sourceStair", "rcStride", "srcRestr", "srcStide", "rcStrip", "rcStrict", "sourceStr", "srcShide", "rcStide", "srcStr", "srcStrite", "srcstide", "srcRestride", "srcEstide", "srcRestrite", "sourceStride", "srcStrip", "srcstrict", "sourceRestride", "rcstride", "srcWrite", "srcWr", "srcShride", "rcstide", "srcstair", "srcstr", "srcRestair", "srcShrip", "sourceStrite"], "dstStride": ["deststrip", "dststride", "deststrite", "dsrcStrip", "destStride", "dstEstrip", "dsrcTro", "dstEstride", "dsrcStr", "dsrcStro", "dsrcTr", "dstTr", "dsrcTride", "destStrite", "dstStrite", "dstStro", "dstSTide", "destStrip", "deststide", "dstRestride", "dstSTrite", "destStide", "dstStrip", "dstRestr", "dsrcStride", "dststrite", "dststrip", "dstSTride", "dstTro", "dstRestrip", "dstRestro", "dstTride", "dststide", "dstSTrip", "dstDestide", "dstStr", "dstDestrite", "dstStide", "dstTrip", "dstEstr", "dstDestrip", "dstEstro", "deststride", "dsrcTrip", "dstDestride"], "x": ["bit", "val", "fx", "ty", "min", "any", "my", "ux", "sex", "f", "xy", "xi", "name", "ix", "u", "t", "sw", "d", "n", "i", "ax", "id", "xp", "X", "on", "h", "index", "code", "wx", "rx", "host", "ctx", "xt", "w", "dx", "xxx", "c", "height", "lex", "p", "k", "key", "pe", "b", "xs", "tx", "yx", "z", "image", "step", "wy", "ct", "xx", "xes", "num", "cross", "xe", "e", "l", "px", "ww", "a", "xc", "plus", "v", "ex", "sync", "m"], "y": ["g", "Y", "ty", "ky", "vy", "yl", "f", "xy", "type", "yr", "t", "ny", "d", "py", "yo", "n", "yn", "col", "i", "id", "h", "ye", "year", "oy", "ady", "w", "dy", "c", "height", "p", "cy", "sy", "b", "ay", "z", "yt", "yd", "wy", "gy", "ya", "yi", "ym", "ey", "l", "yy", "j", "m"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 19808, "substitutes": {"ctx": ["progress", "gru", "client", "component", "jp", "na", "ci", "exec", "connection", "pai", "support", "cl", "qq", "ga", "cf", "c", "vc", "cr", "Context", "cfg", "context", "ctrl", "cm", "cli", "nc", "req", "np", "hw", "qa", "cas", "kt", "fp", "cam", "kw", "pkg", "msg", "wcs", "cu", "kb", "gpu", "fc", "sync", "console", "cp", "ck", "cmd", "bc", "crit", "cms", "config", "cgi", "wx", "concept", "lc", "lex", "cc", "sci", "cpu", "cus", "la", "git", "rc", "cb", "history", "cn", "cca", "cs", "txt", "conn", "ch", "cpp", "loc", "ca", "ce", "cv", "tx", "tc", "cmp", "anc", "xc", "sc"]}}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "substitutes": {"view": ["server", "client", "layout", "seen", "project", "route", "http", "template", "match", "style", "name", "node", "link", "source", "page", "form", "watch", "child", "face", "show", "index", "build", "entry", "block", "VIEW", "see", "object", "action", "comment", "update", "use", "package", "image", "url", "row", "model", "alias", "event", "feature", "View"]}}
{"project": "FFmpeg", "commit_id": "2162b862eba5aadb59c0cf7cc304c67f4a5fb946", "target": 1, "func": "static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}", "idx": 19827, "substitutes": {"vlc": ["svc", "llc", "lvci", "svch", "lvc", "llpc", "hlpc", "vrt", "vlch", "nlp", "nlci", "vrc", "vrci", "llp", "nlc", "hlc", "vlci", "svpc", "lvlc", "lvp", "vlpc", "svt", "nllc", "hlci", "vllc", "vlp", "llci", "lllc", "hlch", "vlt", "llch", "llt", "vrpc", "svci"], "len": ["lim", "val", "kn", "min", "length", "lan", "split", "ll", "bin", "cache", "Len", "den", "li", "dim", "el", "lf", "n", "base", "syn", "low", "lib", "enc", "lon", "lu", "lic", "fin", "label", "index", "con", "data", "block", "rev", "dl", "lc", "dy", "fl", "line", "limit", "pos", "sy", "z", "le", "en", "lif", "la", "lock", "fn", "num", "seq", "l", "ler", "sym", "norm", "list", "lit", "lin", "part", "ln", "size"], "he": ["the", "header", "rule", "hi", "work", "cache", "hel", "He", "rh", "here", "ale", "she", "ge", "hess", "we", "ense", "they", "hes", "one", "there", "h", "iche", "index", "che", "chi", "fen", "ae", "you", "HE", "ue", "ee", "see", "hu", "four", "ce", "his", "ache", "ke", "ha", "apache", "her", "pe", "han", "gh", "create", "be", "fore", "re", "ve", "cle", "en", "ne", "hea", "e", "ph", "hy", "hs", "fe", "wa", "se", "hen", "sche"], "codes": ["maps", "changes", "cs", "flags", "frames", "lines", "ports", "x", "values", "ci", "cells", "hops", "breaks", "coded", "rules", "ns", "ints", "keys", "cons", "config", "locks", "Code", "blocks", "opens", "ls", "items", "cards", "errors", "classes", "comm", "fixes", "cats", "modules", "objects", "bytes", "odes", "states", "names", "fields", "seq", "planes", "resses", "levels", "seconds", "ones", "ins", "cycles", "cod", "checks", "cases", "jobs", "comp", "rates"], "bits": ["bit", "cs", "flags", "frames", "lines", "ops", "bs", "limits", "ps", "gets", "ports", "x", "values", "pins", "cells", "parts", "alls", "plugins", "ints", "keys", "locks", "config", "ips", "blocks", "lins", "ls", "items", "classes", "bugs", "ries", "fixes", "details", "pos", "b", "pieces", "bands", "bytes", "odes", "planes", "ins", "outs", "cycles", "features", "rows", "cases", "words", "its", "settings"], "syms": ["cyms", "lymes", "syns", "cymes", " sym", "fymm", "fyml", "tymb", "syml", "syvs", "synps", "asyvs", "gyms", "symb", "tyns", " symm", "asyns", " symes", " syml", "fymn", "syps", "eyns", " symn", "symm", "gymm", "gyml", "asyms", "synns", "cyvs", "lymb", "fyms", "Sym", "symes", " syvs", "Symes", "tymes", "Symm", "asym", "asymes", "tyms", "symn", "Syms", "cym", "zyms", "asymm", "lyns", "lyms", "zyml", "eyps", "zyps", "sym", "synms", "eyml", "zyns", "asymb", "gymn", "synml", "eyms"], "code": ["core", "bit", "scale", "sequence", "copy", "cm", "length", "type", "name", "cache", "nc", "complete", "ci", "x", "cur", "bc", "error", "message", "ch", "id", "Code", "one", "zip", "order", "change", "co", "index", "address", "byte", "ec", "call", "ce", "c", "go", "cc", "p", "key", "create", "count", "cycle", "cb", "seq", "sec", "bug", "fe", "second", "cod", "size", "que", "sync"], "i": ["g", "phi", "di", "ri", "xi", "hi", "x", "qi", "ix", "ci", "eni", "api", "I", "r", "c", "b", "z", "gi", "a", "oi", "ini", "mi", "m", "cli", "inst", "u", "in", "uri", "it", "si", "multi", "ai", "index", "ik", "iu", "p", "y", "ki", "ui", "fi", "yi", "l", "io", "isi", "ti", "j", "f", "isin", "ji", "n", "ip", "module", "id", "vi", "init", "iv", "o", "ii", "ind", "ni", "zi", "info", "resource", "result", "li", "mu", "bi", "d", "pi", "chi", "k", "ei", "e", "start", "ie", "v"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n", "idx": 19834, "substitutes": {"task": ["resource", "project", "session", "kk", "result", "worker", "ck", "type", "complete", "work", "instance", "source", "trip", "clean", "t", "Task", "exec", "test", "job", "message", "pg", "pp", "act", "pack", "data", "block", "tf", "target", "call", "app", "object", "func", "tx", "thread", "tc", "process", "ass", "cb", "ask", "event", "sync"], "obj": ["self", "class", "coll", "inst", "instance", "obb", "source", "po", "parent", "js", "t", "api", "org", "exec", "test", "ns", "n", "boot", "j", "lib", "id", "od", "db", "ob", "init", "code", "act", "img", "data", "o", "ctx", "st", "fl", "rb", "ref", "object", "sb", "pos", "tmp", "func", "b", "pkg", "objects", "Object", "so", "ass", "nb", "bj", "cb", "fn", "url", "os", "arr", "Obj", "sync"], "src": ["sn", "resource", "class", "sys", "inst", "node", "instance", "source", "proxy", "super", "test", "record", "java", "config", "Source", "ources", "ource", "input", "img", "data", "ctx", "target", "stream", "loc", "rb", "callback", "ref", "object", "sb", "fp", "tmp", "std", "func", "sl", "null", "socket", "ptr", "dist", "sel", "rc", "cb", "url", "dest", "fn", "sc", "spec", "setup", "sync"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int64_t pos;\n\n    int inited_stream_count;\n\n\n\n    nut->avf= s;\n\n    \n\n    av_set_pts_info(s, 60, 1, AV_TIME_BASE);\n\n\n\n    /* main header */\n\n    pos=0;\n\n    for(;;){\n\n        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"no main startcode found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_main_header(nut) >= 0)\n\n            break;\n\n    }\n\n    \n\n    \n\n    s->bit_rate = 0;\n\n\n\n    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);\n\n\n\n    /* stream headers */\n\n    pos=0;\n\n    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){\n\n        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"not all stream headers found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_stream_header(nut) >= 0)\n\n            inited_stream_count++;\n\n    }\n\n\n\n    /* info headers */\n\n    pos=0;\n\n    for(;;){\n\n        uint64_t startcode= find_any_startcode(bc, pos);\n\n        pos= url_ftell(bc);\n\n\n\n        if(startcode==0){\n\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n\n            return -1;\n\n        }else if(startcode == KEYFRAME_STARTCODE){\n\n            url_fseek(bc, -8, SEEK_CUR); //FIXME\n\n            break;\n\n        }else if(startcode != INFO_STARTCODE){\n\n            continue;\n\n        }\n\n\n\n        decode_info_header(nut);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19886, "substitutes": {"s": ["g", "self", "ms", "session", "bs", "js", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "stats", "sec", "sets", "a", "qs", "m", "server", "http", "ns", "si", "i", "your", "es", "us", "p", "sb", "ts", "ks", "services", "sv", "sym", "se", "sync", "sn", "ats", "f", "ops", "this", "less", "south", "ss", "sq", "n", "small", "o", "sup", "S", "bis", "sts", "ses", "sg", "spec", "is", "cs", "sys", "sa", "aws", "ps", "t", "d", "storage", "ls", "stat", "service", "sign", "sac", "e", "os", "sc", "v", "ds", "an", "settings"], "ap": ["arp", "cp", "pc", "proc", "sp", "wp", "tp", "ac", "op", "api", "bp", "ip", "pi", "pac", "aps", "ar", "ai", "pa", "cap", "mac", "att", "hp", "am", "attr", "pro", "arr", "ams", "au", "amp"], "nut": ["not", "node", "orn", "or", "nit", "ocr", "ot", "done", "oren", "rob", "rt", "cdn", "np", "utt", "fit", "roy", "nt", "aft", "nah", "Nat", "pot", "art", "sn", "nas", "oven", "cut", "annot", "stone", "uts", "n", "config", "ott", "ore", "orb", "cot", "note", "nv", "fat", "nuts", "ct", "cb", "fn", "rot", "nat", "cn", "txt", "bd", "bt", "feat", "t", "aug", "conn", "ox", "tun", "boot", "obj", "ut", "dt", "gat", "qt", "cro", "ou", "gt", "tmp", "tube", "Nut", "ft", "cht", "cit", "nw", "rn", "anc", "cart", "ctr", "piece"], "bc": ["CBC", "cca", "bd", "dc", "cm", "acl", "bs", "pc", "bo", "uc", "com", "nc", "ac", "gc", "conn", "web", "BC", "bn", "org", "exec", "wb", "bi", "cms", "lib", "config", "ml", "db", "cl", "pb", "ib", "ocr", "con", "ctx", "ec", "lc", "mac", "comm", "loc", "ca", "exc", "oc", "c", "jc", "sb", "cc", "ic", "vc", "cus", "auc", "tc", "soc", "cb", "rc", "sec", "mc", "bf", "gb", "gg", "bos", "anc", "sc", "fc", "fb"], "pos": ["val", "skip", "min", "sp", "proc", "cache", "axis", "off", "end", "position", "POS", "block", "conf", "gen", "limit", "cond", "resp", "prop", "open", "pres", "pt", "op", "no", "fail", "col", "args", "state", "index", "lang", "aos", "slot", "p", "def", "port", "pid", "push", "offset", "length", "pc", "Pos", "style", "nos", "base", "config", "diff", "win", "pass", "post", "pointer", "neg", "spec", "is", "str", "ps", "type", "ac", "feat", "po", "tag", "len", "pi", "doc", "loc", "ref", "unit", "pose", "seq", "os", "start", "pro", "part", "size"], "inited_stream_count": ["inited_stream\u00b7sum", "inited_systemdcounter", "inited_stream_cache", "inited_thread_Count", "inited_thread_id", "inited_system_sum", "inited_stream_id", "inited_streamdsum", "inited_system_counter", "inited_thread_cache", "inited_systemdcount", "inited_streamsc", "inited_streamscount", "inited_stream_sum", "inited_stream_c", "inited_streamdcount", "inited_thread_base", "inited_systemdsum", "inited_streamscache", "inited_stream\u00b7counter", "inited_stream\u00b7count", "inited_stream_counter", "inited_stream_base", "inited_streamsid", "inited_streamdcounter", "inited_system_count", "inited_thread_count", "inited_stream_Count"]}}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)\n\n{\n\n    int ret;\n\n\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"reinit context\\n\");\n\n\n\n    /* 1. streamoff */\n\n    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);\n\n    if (ret)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"capture VIDIOC_STREAMOFF\\n\");\n\n\n\n    /* 2. unmap the capture buffers (v4l2 and ffmpeg):\n\n     *    we must wait for all references to be released before being allowed\n\n     *    to queue new buffers.\n\n     */\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"waiting for user to release AVBufferRefs\\n\");\n\n    if (atomic_load(&s->refcount))\n\n        while(sem_wait(&s->refsync) == -1 && errno == EINTR);\n\n\n\n    ff_v4l2_context_release(&s->capture);\n\n\n\n    /* 3. get the new capture format */\n\n    ret = ff_v4l2_context_get_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"query the new capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 4. set the capture format */\n\n    ret = ff_v4l2_context_set_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"setting capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 5. complete reinit */\n\n    sem_destroy(&s->refsync);\n\n    sem_init(&s->refsync, 0, 0);\n\n    s->draining = 0;\n\n    s->reinit = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 19889, "substitutes": {"s": ["is", "g", "cs", "self", "sf", "ms", "f", "ops", "sys", "session", "ps", "secondary", "new", "u", "rs", "js", "t", "ss", "sq", "parts", "d", "ns", "n", "site", "si", "args", "i", "h", "iss", "ls", "es", "o", "us", "gs", "conf", "side", "c", "p", "sb", "ts", "service", "ks", "ssl", "su", "fs", "services", "S", "states", "sg", "ses", "e", "sets", "l", "sym", "hs", "a", "options", "os", "spec", "se", "ds", "qs", "its", "settings"], "ret": ["reply", "val", "match", "valid", "fun", "pet", "pub", "code", "pat", "flag", "opt", "arg", "lit", "rt", "bit", "let", "res", "reg", "py", "red", "fail", "job", "reset", "fit", "full", "data", "usr", "rev", "nt", "sb", "key", "def", " Ret", "url", "bin", "art", "RET", "cat", "lt", "error", "base", "id", "pass", "att", "format", "en", "run", "Ret", "str", "bd", "result", "alt", "feat", "success", "back", "len", "mt", " RET", "rets", "ext", "ref", "det", "bot", "gt", "rf", "re", "ft", "bf", "bad", "debug", "part", "af"]}}
{"project": "FFmpeg", "commit_id": "e3123856c79c36507772ada1bcda6cfe36a1e297", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892, "substitutes": {"s": ["is", "g", "cs", "sn", "sf", "f", "sa", "src", "aws", "sys", "bs", "ds", "fts", "rs", "t", "ss", "sq", "sr", "ns", "ans", "si", "vs", "ls", "es", "us", "w", "gs", "c", "p", "sb", "sci", "ks", "ts", "service", "ssl", "sl", "xs", "su", "sim", "services", "fs", "S", "bis", "sec", "sets", "ses", "sg", "os", "sv", "sts", "ins", "sc", "se", "spec", "qs", "its"], "ap": ["arp", "cp", "AP", "pc", "sp", "tp", "wp", "ac", "capt", "api", "np", "pi", "aps", "pl", "ar", "pa", "pp", "cap", "att", "al", "amp", "am", "attr", "pro", "ast", "mp", "ams", "au", "pac"], "wsvqa": ["Wssvasa", "wsvasa", "wsvcqi", "wsvcaga", "wssvqa", "wsvrqa", "wsVqa", "wssvqi", "wordsvaga", "wsvrasa", "Wssvq", "wordsvcqa", "wslvaga", "wsvccca", "Wsvaga", "wsVaga", "Wsvqa", "wssvaga", "wsVcca", "Wsvq", "wordsvqa", "wsvraga", "wsvrq", "wsvcqa", "wssvq", "wsvqi", "Wsvasa", "wsvaga", "wslvq", "Wssvaga", "wordsvcqi", "wordsvccca", "wordsvqi", "wordsvcca", "wssvasa", "wssvcca", "wsvq", "Wssvqa", "wslvasa", "wsVqi", "wslvqa", "wsvcca", "wordsvcaga"], "pb": ["cp", "PB", "bs", "pc", "pt", "src", "tp", "wp", "ppa", "xb", "bc", "queue", "lp", "buf", "bh", "param", "wb", "bp", "pm", "hub", "aph", "bm", "fc", "cpp", "pg", "db", "pl", "platform", "pa", "summary", "vp", "afi", "bps", "ib", "eb", "typ", "rb", "orb", "sb", "p", "fp", "prot", "prop", "cb", "ab", "bf", "gb", "dp", "pit", "ub", "mp", "lb", "rob", "fb", "amp"], "st": ["set", "sp", "et", "sh", "end", "sw", "irst", "sr", "play", "cl", "ost", "nd", "sl", "cr", " est", "fe", "ste", "pt", "inst", "dd", "stress", "tta", "put", "fr", "kt", "stand", "nt", "sb", "std", "ts", "store", "ust", "sta", "sv", "l", "se", "bl", "art", "sn", "src", "rest", "lt", "ss", "ad", "stack", "sd", "est", "th", "ist", "ace", "post", "stage", "ct", "sts", "stop", "str", "sa", "cur", "td", "t", "back", "d", "St", "mt", "ut", "storage", "tt", "stat", "stim", "ld", "ST", "ft", "dest", "start", " St", "ast", "sth", "sc", "ess"], "header": ["detail", "handle", "match", "page", "description", "position", "metadata", "h", "code", "padding", "summary", "byte", "block", "head", "content", "comment", "layer", "player", "yer", "dr", "server", "name", "carry", "headers", "border", "message", "user", "column", "index", "data", "digit", "cover", "response", "hash", "protection", "num", "filename", "port", "date", "bin", "title", "ver", "host", "offset", "Header", "frame", "error", "buffer", "version", "input", "iter", "body", "channel", "gender", "pixel", "er", "feature", "section", "option", "result", "type", "parent", "document", "tag", "table", "status", "bridge", "her", "filter", "request", "driver", "event", "tail"], "scratch": ["encores", "ncores", " scores", "ncratch", "encratch", "scores"], "chunk_tag": ["chack_length", "chack2mode", "chunk_count", "chunk2mode", "chunk2tag", "chack2count", "chack_tag", "chack_mode", "chunk2count", "chack2tag", "chunk_mode", "chack2length", "chunk2length", "chunk_length", "chack_count"], "chunk_size": ["chunks_count", "chunk_count", "chunks_weight", "chunk2size", "chunks_SIZE", "chunks_size", "chunk2weight", "chunk2count", "chunk2SIZE", "chunk_SIZE", "chunk_weight"]}}
{"project": "FFmpeg", "commit_id": "984add64a41c3296a8a82051cc90bff2eb449609", "target": 1, "func": "int ff_wma_init(AVCodecContext *avctx, int flags2)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n    float bps1, high_freq;\n\n    volatile float bps;\n\n    int sample_rate1;\n\n    int coef_vlc_table;\n\n\n\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n\n        || avctx->channels    <= 0 || avctx->channels    > 2\n\n        || avctx->bit_rate    <= 0)\n\n        return -1;\n\n\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n\n        s->version = 1;\n\n    } else {\n\n        s->version = 2;\n\n\n\n\n    /* compute MDCT block size */\n\n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n\n                                                  s->version, 0);\n\n    s->next_block_len_bits = s->frame_len_bits;\n\n    s->prev_block_len_bits = s->frame_len_bits;\n\n    s->block_len_bits      = s->frame_len_bits;\n\n\n\n    s->frame_len = 1 << s->frame_len_bits;\n\n    if (s->use_variable_block_len) {\n\n        int nb_max, nb;\n\n        nb = ((flags2 >> 3) & 3) + 1;\n\n        if ((avctx->bit_rate / avctx->channels) >= 32000)\n\n            nb += 2;\n\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n\n        if (nb > nb_max)\n\n            nb = nb_max;\n\n        s->nb_block_sizes = nb + 1;\n\n    } else {\n\n        s->nb_block_sizes = 1;\n\n\n\n\n    /* init rate dependent parameters */\n\n    s->use_noise_coding = 1;\n\n    high_freq = avctx->sample_rate * 0.5;\n\n\n\n    /* if version 2, then the rates are normalized */\n\n    sample_rate1 = avctx->sample_rate;\n\n    if (s->version == 2) {\n\n        if (sample_rate1 >= 44100) {\n\n            sample_rate1 = 44100;\n\n        } else if (sample_rate1 >= 22050) {\n\n            sample_rate1 = 22050;\n\n        } else if (sample_rate1 >= 16000) {\n\n            sample_rate1 = 16000;\n\n        } else if (sample_rate1 >= 11025) {\n\n            sample_rate1 = 11025;\n\n        } else if (sample_rate1 >= 8000) {\n\n            sample_rate1 = 8000;\n\n\n\n\n\n    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);\n\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;\n\n\n\n\n\n\n\n    /* compute high frequency value and choose if noise coding should\n\n       be activated */\n\n    bps1 = bps;\n\n    if (avctx->channels == 2)\n\n        bps1 = bps * 1.6;\n\n    if (sample_rate1 == 44100) {\n\n        if (bps1 >= 0.61) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.4;\n\n\n    } else if (sample_rate1 == 22050) {\n\n        if (bps1 >= 1.16) {\n\n            s->use_noise_coding = 0;\n\n        } else if (bps1 >= 0.72) {\n\n            high_freq = high_freq * 0.7;\n\n        } else {\n\n            high_freq = high_freq * 0.6;\n\n\n    } else if (sample_rate1 == 16000) {\n\n        if (bps > 0.5) {\n\n            high_freq = high_freq * 0.5;\n\n        } else {\n\n            high_freq = high_freq * 0.3;\n\n\n    } else if (sample_rate1 == 11025) {\n\n        high_freq = high_freq * 0.7;\n\n    } else if (sample_rate1 == 8000) {\n\n        if (bps <= 0.625) {\n\n            high_freq = high_freq * 0.5;\n\n        } else if (bps > 0.75) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.65;\n\n\n    } else {\n\n        if (bps >= 0.8) {\n\n            high_freq = high_freq * 0.75;\n\n        } else if (bps >= 0.6) {\n\n            high_freq = high_freq * 0.6;\n\n        } else {\n\n            high_freq = high_freq * 0.5;\n\n\n\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n\n            avctx->block_align);\n\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n\n            bps, bps1, high_freq, s->byte_offset_bits);\n\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n\n\n\n    /* compute the scale factor band sizes for each MDCT block size */\n\n    {\n\n        int a, b, pos, lpos, k, block_len, i, j, n;\n\n        const uint8_t *table;\n\n\n\n        if (s->version == 1) {\n\n            s->coefs_start = 3;\n\n        } else {\n\n            s->coefs_start = 0;\n\n\n        for (k = 0; k < s->nb_block_sizes; k++) {\n\n            block_len = s->frame_len >> k;\n\n\n\n            if (s->version == 1) {\n\n                lpos = 0;\n\n                for (i = 0; i < 25; i++) {\n\n                    a = ff_wma_critical_freqs[i];\n\n                    b = avctx->sample_rate;\n\n                    pos = ((block_len * 2 * a) + (b >> 1)) / b;\n\n                    if (pos > block_len)\n\n                        pos = block_len;\n\n                    s->exponent_bands[0][i] = pos - lpos;\n\n                    if (pos >= block_len) {\n\n                        i++;\n\n                        break;\n\n\n                    lpos = pos;\n\n\n                s->exponent_sizes[0] = i;\n\n            } else {\n\n                /* hardcoded tables */\n\n                table = NULL;\n\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n\n                if (a < 3) {\n\n                    if (avctx->sample_rate >= 44100) {\n\n                        table = exponent_band_44100[a];\n\n                    } else if (avctx->sample_rate >= 32000) {\n\n                        table = exponent_band_32000[a];\n\n                    } else if (avctx->sample_rate >= 22050) {\n\n                        table = exponent_band_22050[a];\n\n\n\n                if (table) {\n\n                    n = *table++;\n\n                    for (i = 0; i < n; i++)\n\n                        s->exponent_bands[k][i] = table[i];\n\n                    s->exponent_sizes[k] = n;\n\n                } else {\n\n                    j = 0;\n\n                    lpos = 0;\n\n                    for (i = 0; i < 25; i++) {\n\n                        a = ff_wma_critical_freqs[i];\n\n                        b = avctx->sample_rate;\n\n                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);\n\n                        pos <<= 2;\n\n                        if (pos > block_len)\n\n                            pos = block_len;\n\n                        if (pos > lpos)\n\n                            s->exponent_bands[k][j++] = pos - lpos;\n\n                        if (pos >= block_len)\n\n                            break;\n\n                        lpos = pos;\n\n\n                    s->exponent_sizes[k] = j;\n\n\n\n\n\n            /* max number of coefs */\n\n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;\n\n            /* high freq computation */\n\n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /\n\n                                          avctx->sample_rate + 0.5);\n\n            n = s->exponent_sizes[k];\n\n            j = 0;\n\n            pos = 0;\n\n            for (i = 0; i < n; i++) {\n\n                int start, end;\n\n                start = pos;\n\n                pos += s->exponent_bands[k][i];\n\n                end = pos;\n\n                if (start < s->high_band_start[k])\n\n                    start = s->high_band_start[k];\n\n                if (end > s->coefs_end[k])\n\n                    end = s->coefs_end[k];\n\n                if (end > start)\n\n                    s->exponent_high_bands[k][j++] = end - start;\n\n\n            s->exponent_high_sizes[k] = j;\n\n#if 0\n\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n\n                    s->frame_len >> k,\n\n                    s->coefs_end[k],\n\n                    s->high_band_start[k],\n\n                    s->exponent_high_sizes[k]);\n\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n#endif\n\n\n\n\n\n#ifdef TRACE\n\n    {\n\n        int i, j;\n\n        for (i = 0; i < s->nb_block_sizes; i++) {\n\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n\n                    s->frame_len >> i,\n\n                    s->exponent_sizes[i]);\n\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n\n\n#endif\n\n\n\n    /* init MDCT windows : simple sinus window */\n\n    for (i = 0; i < s->nb_block_sizes; i++) {\n\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n", "idx": 19908, "substitutes": {"avctx": ["ajpkg", "AVtx", "abcontext", "avecn", "ovcontext", "avqa", " avcmp", "averbc", "navcf", "afctrl", "avcu", "ovcf", "ajcmp", "afqa", "aveloc", "ajcontext", "afcmd", "avertx", "avecf", "avconn", "avcmp", "AVmc", "devcf", "avectx", "avtx", "avcontext", "afconn", "avctrl", "verctx", "navcmd", "AVctx", "avpkg", "avecontext", "devcontext", "AVcontext", "afmc", "ajmc", "avlc", " avtx", "ajconn", "ajctrl", "AVctl", "avalcn", "afcontext", "avcmd", "aflc", "abctx", "avalcontext", "avercontext", "vercn", "afcca", "ajcf", "airctl", "avallc", "avcca", "avalqa", "afpkg", "avelc", "airconn", "avloc", "aftx", "vercf", "avctl", "devctrl", "ajcmd", "afcf", "ovcn", "afcu", "avecca", "ajcu", "avalctx", "avectl", "afctl", "AVconn", "ovctx", "navcontext", "abloc", "AVpkg", "avectrl", "afctx", "avecu", " avcontext", "ajctl", "avalcca", "avmc", "ajctx", "averctx", "devctx", "aveqa", "AVcmp", " avctrl", "avcf", "airctx", "vercontext", "AVcu", "navctx", "afbc", "aircontext", " avcf", "avecmp", " avbc", "abconn", "afcn", "afcmp", "avcn", "afloc", "aveconn", "avbc"], "flags2": ["flags1", "mask2", "Flags2", "bits1", "mask4", "Flags3", "bits2", "flag2", "bits3", "args4", "flags4", " flags1", "args2", " flags3", "flag4", "flags3", "Flags1"], "s": ["g", "self", "lines", "session", "secondary", "js", "r", "gs", "conf", "c", "ssl", "su", "fs", "stats", "states", "sets", "ins", "qs", "m", "server", "sf", "http", "times", "ions", "ns", "site", "si", "full", "es", "params", "p", "ts", "ks", "services", "l", "sym", "words", "its", "sync", "f", "ops", "this", "rs", "ss", "sq", "o", "ctx", "xs", "sup", "S", "sg", "ses", "spec", "rates", "is", "cs", "sys", "aws", "ps", "new", "t", "parts", "d", "storage", "ls", "w", "service", "e", "os", "features", "ds", "v", "settings"], "i": ["batch", "f", "cli", "ci", "li", "abi", "d", "ip", "I", "pi", "si", "multi", "uni", "ai", "iu", "ii", "c", "p", "slice", "ui", "ni", "io", "v", "ti", "m"], "bps1": ["bytes0", "bytes1", " pins0", "bps0", " pins1", " bytes0", " bytes1"], "high_freq": ["high_Frech", "high_funq", "high_Frecharge", "high_hardQ", "high_hardch", "high_condQ", "high_freg", "high_Freq", "high_FreQ", "high_frech", "high_freeg", "high_Freg", "high_freeq", "high_freeqs", "high_freix", "high_condch", "high_fung", "high_freecharge", "high_hardq", "high_hardix", "high_funcharge", "high_condq", "high_funqs", "high_Freqs", "high_freqs", "high_frecharge", "high_freQ", "high_condix", "high_Freix"], "bps": [" pins", "batch", "eps", " fps", "ps", "abytes", "SB", "ns", "bb", "bp", "base", "Mbps", "bits", "ips", "pb", "ls", "sb", "p", " bytes", " bits", "bytes", "bis", "fps", "cb", "seq"], "sample_rate1": ["sample_level6", "sample_slice001", "sample_slice10", "sample_rule4", "sample_rate4", "sampleacrate1", "sampleacrate10", "sample_rule6", "sample_rate6", "sample_num001", "sample_num1", "sample_rule1", "sample_scale1", "sample_time1", "sample_buffer6", "sample_level4", "sample_level1", "sampleacslice10", "sampleacslice1", "sample_buffer1", "sample_sum6", "sample_scale4", "sample_sum1", "sample_rate10", "sample_rate001", "sampleacslice001", "sampleacrate001", "sample_rates1", "sample_scale6", "sample_num10", "sample_slice1"], "coef_vlc_table": ["coef_vlf_count", "coef_vlc8type", "coef_vlc_db", "coef_vlc8db", "coef_vlf_table", "coef_vlc8table", "coef_vlc8count", "coef_vlf_type", "coef_vlc_count", "coef_vlf_db", "coef_vlc_type"], "nb_max": ["nbjonly", "nb49scale", "nb49max", "nb67ax", "nbIPrest", "nb_size", "nb67rest", "np_diff", "lb_rest", "nb49warm", "np_scale", "nb_warm", "nbIPmax", "nbIPonly", "nb_index", "lbIPmax", "np_warm", "nb49diff", "bb_sum", "nb_only", "lbIPrest", "nb_sum", "nb00sum", "bb00max", "lb_max", "nb00size", "nbjrest", "nb24max", "nb67only", "nb_count", "lib_cat", "np_max", "lb_Max", "lib_max", "nb24size", "nb00max", "nb_ax", "nb67Max", "nb24sum", "bb00index", "nb_rest", "nb_diff", "nbIPMax", "bb_size", "lbIPonly", "nb00index", "nb_scale", "bb00size", "bb_index", "lib_ax", "nb24index", "nbjMax", "nbjmax", "nb67cat", "lb_only", "nb_Max", "lib_count", "nb67count", "lbIPMax", "nb67max", "bb00sum", "nb_cat", "bb_max"], "nb": ["batch", "length", "split", "bc", "qi", "obb", "li", "spin", "bi", "bn", "nz", "ny", "wb", "api", "np", "bb", "bp", "ns", "len", "kl", "fee", "bm", "obj", "lib", "nn", "uni", "db", "bits", "zip", "pb", "ib", "NB", "eb", "dy", "nl", "rb", "nob", "quad", "nt", "sb", "adj", "abb", "sci", "nd", "note", "ni", "bis", "ne", "cb", "num", "count", "gb", "bf", "ab", "lab", "nm", "nu", "kb", "bin", "fb"]}}
{"project": "FFmpeg", "commit_id": "12dea8a5a15343e9c404376c40ca8a1cc9d1479e", "target": 1, "func": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}", "idx": 19912, "substitutes": {"avctx": ["avalcontext", " avchan", "avcmp", "avectx", "cvcu", "avcontext", "cvctx", "avloc", "avchan", "avalchan", " avcmp", "AVctx", "avecontext", "avechan", "AVcmp", "AVcontext", "avalloc", "avcu", "cvcmp", "cvchan", "avalctx", "AVcu", " avcu", "aveloc", "AVchan", "AVloc"], "ctx": ["cca", "cs", "cp", "cm", "coll", "component", "pc", "ck", "cmd", "nc", "bc", "instance", "ci", "conn", "connection", "conv", "hw", "cms", "config", "aux", "fc", "fw", "qa", "data", "cas", "lc", "cci", "loc", "ca", "cf", "conf", "c", "fp", "cam", "cc", "cv", "vc", "func", "coe", "tx", "pkg", "Context", "context", "ct", "wcs", "cb", "voc", "cmp", "ctrl", "anc", "cu", "xc", "kb", "sc", "buff", "comp", "cn"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n", "idx": 19916, "substitutes": {"nd": ["idd", "cd", "cdn", "bd", "ud", "ck", "pd", "inc", "nc", "cmd", "dd", "td", "und", "end", "d", "dk", "fd", "gd", "sd", "ond", "nn", "od", "dev", "ani", "dl", "wn", "wd", "rd", "nt", "inf", "ld", "std", "da", "ind", "xd", "zn", "hd", "gn", "nda", "nb", "ne", "ng", "vd", "nw", "rn", "dat", "ant", "ND", "dn", "nu", "inn", "ds", "md", "ln"], "models": ["links", "grid", "groups", "cm", "ms", "Model", "mode", "users", "ids", "flows", "x", "xml", "cells", "images", "mod", "media", "rules", "plugins", "chains", "view", "keys", "args", "agents", "cms", "module", "config", "id", "blocks", "index", "codes", "jobs", "forms", "ima", "data", "strings", "items", "mas", "members", "classes", "views", "files", "bugs", "params", "parents", "move", "apps", "gl", "sql", "modules", "xs", "women", "services", "objects", "dem", "image", "m", "gui", "names", "model", "bug", "features", "custom", "projects", "rooms", "cod", "faces", "im", "settings"], "default_model": [" default_service", "Default_module", "defaultusermodel", " default_models", "Default_models", "defaultusermodule", "defaultusermodels", "default_module", "Default_method", "defaultusermethod", "default_method", "default_service", "default_models", "defaultuserservice", "Default_model"], "i": ["phi", "val", "di", "inner", "ri", "xi", "hi", "qi", "ix", "x", "ci", "eni", "end", "api", "I", "h", "r", "code", "c", "gu", "b", "gi", "a", "oi", "ini", "mi", "m", "cli", "name", "u", "source", "in", "uri", "it", "si", "multi", "one", "index", "ai", "iu", "data", "p", "key", "y", "ui", "yi", "fi", "l", "io", "ti", "j", "f", "n", "ip", "id", "init", "diff", "o", "ii", "ind", "ni", "zi", "info", "type", "li", "bi", "mu", "d", "pi", "w", "ei", "count", "e", "start", "ie", "v"]}}
{"project": "qemu", "commit_id": "8103b4d161d7c00ea3ff89ffe66bb2bc2c67de5d", "target": 0, "func": "static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n", "idx": 19927, "substitutes": {"opaque": ["ophole", "opque", "OPaque", "opac", "operacity", "Opque", "oppacho", "operac", " opac", "Opacho", "OPhole", "OPacity", "oppque", "oppaque", "opacity", " opque", "OPac", " opacle", " opacity", "Opacle", " opacho", "Opaque", "opacle", "oppacle", "operaque", "operhole", "opacho", " ophole"], "vector": ["server", "vec", "sequence", "family", "token", "creator", "roller", "queue", "normal", "parent", "array", "buf", "buffer", "root", "version", "ensor", "writer", "reader", "service", "pointer", " token", "zero", "collection", "iterator", "driver", "io", "device", "serial", "Vector", "v"], "dev": ["di", "DEV", "prom", " device", "grad", "ov", "proc", "node", "conn", "ad", "api", "reg", "d", "valid", "auth", "pub", "iv", "data", "Dev", "block", "engine", "conf", "app", "de", "var", "def", "ve", "dem", "priv", "ev", "bus", " def", "driver", "env", "device", "rad", "serv", "serial", "ver", "info"]}}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 19962, "substitutes": {"cfg": ["g", "fine", "core", "gate", "cs", "cp", "css", "gm", "cm", "cli", "forge", "cmd", "ci", "gc", "org", "fm", "gd", "metadata", "config", "nova", "fg", "init", "cgi", "ctx", "lc", "ga", "conf", "cf", "gnu", "gov", "ext", "ea", "c", "cr", "gz", "gi", "alg", "cb", "nw", "gb", "mc", "sg", "gg", "ini", "ctr", "oga", "cn"], "errp": ["errpc", " erfp", " err", "ercp", "errorlp", "errP", " errr", "errorp", "itercp", "iterP", "errorfp", "errcp", "errper", "erpc", " errper", "nerper", " errlp", "erp", "nerfp", "errorper", "iterp", "erfp", "erpp", "errpp", " errfp", "err", " errpc", "errfp", "errorP", " errP", "iterlp", " errcp", " errpp", "nerp", "errr", "iterfp", " erpc", "iterpp", "errlp", " erp", "nerP"]}}
{"project": "FFmpeg", "commit_id": "101ef19ef4dc9f5c3d536aee8fcc10fff2af4d9e", "target": 1, "func": "static void decode_block(BinkAudioContext *s, short *out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = s->coeffs_ptr[ch];\n\n        if (s->version_b) {\n\n            coeffs[0] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n        } else {\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            /* constant is result of 0.066399999/log10(M_E) */\n\n            int value = get_bits(gb, 8);\n\n            quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root;\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else if (get_bits1(gb)) {\n\n                j = i + rle_length_tab[get_bits(gb, 4)] * 8;\n\n            } else {\n\n                j = i + 8;\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            width = get_bits(gb, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    coeff = get_bits(gb, width);\n\n                    if (coeff) {\n\n                        if (get_bits1(gb))\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n            s->dsp.vector_fmul_scalar(coeffs, coeffs, s->frame_len / 2, s->frame_len);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n\n                                          s->frame_len, s->channels);\n\n\n\n    if (!s->first) {\n\n        int count = s->overlap_len * s->channels;\n\n        int shift = av_log2(count);\n\n        for (i = 0; i < count; i++) {\n\n            out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n\n        }\n\n    }\n\n\n\n    memcpy(s->previous, out + s->block_size,\n\n           s->overlap_len * s->channels * sizeof(*out));\n\n\n\n    s->first = 0;\n\n}\n", "idx": 19965, "substitutes": {"s": ["g", "core", "self", "sites", "session", "js", "support", "h", "gs", "conf", "c", "b", "ssl", "sl", "su", "fs", "states", "sets", "a", "qs", "m", "server", "sf", "u", "in", "ns", "site", "si", "full", "es", "us", "p", "sb", "ks", "ts", "y", "services", "sv", "l", "sym", "se", "its", "sync", "f", "ops", "rs", "ss", "sq", "n", "native", "o", "xs", "sup", "sim", "S", "bis", "sg", "ses", "hs", "spec", "is", "cs", "sys", "sa", "ps", "t", "parts", "d", "ls", "side", "service", "e", "os", "features", "sc", "ds", "v", "settings"], "out": ["bl", "output", "cmd", "png", "op", "array", "in", "buffer", "obj", "OUT", "img", "input", "raw", "o", "w", "c", "p", "err", "image", "outs", "io", "arr", "buff", "bin", "Out", "m"], "use_dct": ["use_nct", "use_dkt", "use_pct", "use_bdct", "use_DCT", "use_Dkt", "use_ncc", "use_bdCT", "use_fCT", "use_pCT", "use_pont", "use_bdcc", "use_Dcc", "use_bdkt", "use_dCT", "use_nont", "use_fcc", "use_Dct", "use_pcc", "use_fkt", "use_Dont", "use_fct", "use_nCT", "use_dcc", "use_dont"], "ch": ["g", "batch", "core", "cp", "cs", "chip", "cm", "f", "zh", "chan", "chrom", "range", "x", "ci", "cur", "sh", "el", "conn", "chu", "cor", "child", "col", "th", "h", "code", "sch", "chi", "che", "fr", "mot", "ctx", "Ch", "CH", " chunk", "conf", "sk", "chn", "c", "p", "channel", "ach", "y", "cy", "vc", "b", "prot", "qu", "z", "ver", "cho", "cht", "count", "cb", "l", "ph", "och", "ie", "ich", "ht", "v"], "i": ["g", "phi", "di", "inner", "f", "ri", "xi", "hi", "cli", "x", "u", "qi", "ix", "ci", "li", "in", "me", "eni", "bi", "uri", "ji", "it", "d", "api", "info", "n", "ip", "ti", "I", "si", "pi", "multi", "vi", "id", "ij", "init", "ai", "index", "ik", "iu", "o", "ii", "c", "p", "line", "y", "ind", "b", "ki", "z", "slice", "mini", "ui", "ni", "zi", "gi", "yi", "fi", "e", "l", "ori", "io", "oi", "ie", "ini", "v", "mi", "m"], "j": ["g", "ja", "f", "jp", "x", "u", "qi", "ix", "je", "li", "js", "ji", "jo", "t", "d", "n", "jl", "job", "ij", "si", "dj", "kj", "h", "r", "index", "fr", "jet", "o", "aj", "w", "dy", "ii", "jc", "c", "p", "adj", "y", "uj", "b", "ki", "z", "ui", "ne", "e", "l", "J", "start", "ie", "size", "v", "jj", "m"], "k": ["g", "kn", "ky", "kk", "f", "ck", "work", "x", "u", "K", "qi", "kh", "d", "ku", "dk", "n", "ka", "_", "kg", "h", "ik", "o", "ijk", "w", "sk", "c", "p", "ke", "kick", "key", "y", "ks", "kw", "ki", "b", "gh", "z", "ko", "kid", "e", "uk", "l", "ek", "ok", "v", "m"], "q": ["g", "fx", "f", "Q", "x", "ix", "u", "qi", "t", "sq", "end", "req", "d", "quality", " p", " qual", "h", "qa", "r", "qq", "ig", " l", " query", "qt", "w", "iq", "c", "p", "y", " w", "b", "qu", "z", "charge", " Q", "l", "query", " quality", "qs", "v", "m"], "quant": ["qual", "scale", "progress", "check", "integer", "client", "component", "proc", "Q", "cur", "window", "pad", "req", "valid", "gap", "product", "util", "press", "rank", "quick", "parse", "pp", "private", "mult", "percent", "Quant", "frac", "quart", "qq", "draw", "select", "sum", "total", "pure", "iq", "quad", "final", "cost", "patch", "post", "p", "requ", "qu", "sim", "comment", "wait", "auc", "compl", "tax", "charge", "query", "spec", "sc", "buff", "quiet", "comp", "complex", "secure"], "coeff": ["goefficient", " coff", "koeff", "goaff", "Coff", "coneff", "koefficient", "noef", "goef", "coefficients", "canefficients", "caneff", "canefficient", " coefficient", "canef", "Coeff", "Coefficient", "noeff", " coaff", "noefficient", "coaff", "koef", "coff", "Coef", "koefficients", "coef", "conaff", "conefficient", "coefficient", " coef", "goeff", "noff", " coefficients", "conef"], "gb": ["g", "gm", "gru", "cm", "gin", "uv", "pc", "xy", "range", "bc", "gam", "gow", "wm", "py", "wb", "tm", "bb", "bp", "hub", "gd", "bm", "gom", "gal", "boot", "db", "storage", "cgi", "binary", "band", "eb", "ga", "gio", "gs", "rb", "gnu", "game", "gram", "sb", "abb", "channel", "cv", "gt", "hm", "gh", "b", "gl", "mb", "rg", "gp", "cfg", "ui", "gold", "gz", "nb", "gy", "phy", "cb", "gui", "bf", "gg", "general", "GB", "kb", "sc", "bands", "gpu", "bg", "usb", "lb", "bin", "go"], "coeffs": [" coeffis", "coefficientd", "coefficientls", " coeffsets", " coefs", "coeffices", "coffes", "coefficientsi", "coeffe", "coefi", "Coeffi", "coeffes", "coefes", "Coffp", "coefficienti", "Coffi", " coeffd", "coffp", "coEFFn", "coeffls", "coeffects", "coaccp", "coefe", "coefficientsd", " coefn", "coffs", "coefficientss", "coefficientsets", "coefsets", "Coeffes", "coeffics", "coffi", "coeffd", " coeffi", " coefsets", "coefficp", " coeffls", "coeffi", " coeffes", "coefficients", "coeffis", "coefficientsis", "coefficientsp", " coefe", "coefficientses", "coefp", "coefd", "coEFFi", "coeffn", "Coffes", "coeffsets", "coEFFp", "coeffecte", " coefp", "coeffectls", "coefs", "coeffici", "coefficis", "coaffs", " coefes", "coffn", "coefficientes", "Coeffs", "coefis", "coaccs", "coEFFs", " coefis", " coeffn", "coefficiente", "coeffp", "Coeffp", "Coffs", "coaffes", "coaffe", " coeffp", " coeffe", "coefn", "coeffectes", "coefls", " coefi", " coefd", "coefficientssets", " coefls"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n\n                                 const uint8_t *buf, int size, int64_t pts)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    AVStream *st = ctx->streams[stream_index];\n\n    StreamInfo *stream = st->priv_data;\n\n    int64_t dts;\n\n    int len;\n\n\n\n    /* XXX: system clock should be computed precisely, especially for\n\n       CBR case. The current mode gives at least something coherent */\n\n    if (stream_index == s->scr_stream_index)\n\n        s->last_scr = pts;\n\n    \n\n#if 0\n\n    printf(\"%d: pts=%0.3f scr=%0.3f\\n\", \n\n           stream_index, pts / 90000.0, s->last_scr / 90000.0);\n\n#endif\n\n    \n\n    /* XXX: currently no way to pass dts, will change soon */\n\n    dts = AV_NOPTS_VALUE;\n\n\n\n    /* we assume here that pts != AV_NOPTS_VALUE */\n\n    if (stream->start_pts == AV_NOPTS_VALUE) {\n\n        stream->start_pts = pts;\n\n        stream->start_dts = dts;\n\n    }\n\n    while (size > 0) {\n\n        len = s->packet_data_max_size - stream->buffer_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n\n        stream->buffer_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        while (stream->buffer_ptr >= s->packet_data_max_size) {\n\n            /* output the packet */\n\n            flush_packet(ctx, stream_index,\n\n                         stream->start_pts, stream->start_dts, s->last_scr);\n\n            /* Make sure only the FIRST pes packet for this frame has\n\n               a timestamp */\n\n            stream->start_pts = AV_NOPTS_VALUE;\n\n            stream->start_dts = AV_NOPTS_VALUE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 19976, "substitutes": {"ctx": ["cca", "cs", "cp", "cm", "client", "pc", "src", "ck", "jp", "cli", "cmd", "bc", "nc", "ci", "gc", "conn", "exec", "conv", "cms", "hw", "config", "cpp", "cas", "lc", "loc", "ca", "cf", "c", "fp", "p", "cam", "cv", "cc", "sci", "tx", "pkg", "cus", "tc", "Context", "context", "ct", "cb", "rc", "cmp", "anc", "cu", "xc", "kb", "sc", "cn"], "stream_index": ["channel_index", "streamdbindex", "thread_Index", "thread_index", "streamamerange", "stream_block", "stream_name", "thread_position", " stream_Index", " stream_range", "streamdbreference", "stream_Index", " stream_list", "stream_reference", "stream_list", "streamameIndex", "stream_slice", "stream_range", "channel_Index", "streamdbroute", "channel_level", "stream_ref", " stream_block", "channel_slice", "stream_route", " stream_name", "streamameindex", " stream_route", " stream_reference", "stream_position", "stream_level", "thread_ref", "streamamelist"], "buf": ["val", "vec", "src", "uf", "cmd", "uc", "queue", "bc", "cur", "buffer", "wb", "pool", "feed", "fd", "ff", "blocks", "pb", "data", "block", "raw", "cas", "cap", "loc", "rb", "cf", "bag", "cv", "b", "msg", "fb", "bytes", "context", "prop", "la", "cb", "rc", "count", "seq", "mem", "port", "box", "buff", "alloc"], "size": ["g", "cs", "scale", "min", "cm", "length", "timeout", "large", "mode", "name", "new", "cache", "sized", "page", "el", "Size", "n", "SIZE", "small", "ize", "capacity", "speed", "address", "max", "code", "data", "es", "cap", "lc", "sum", "grow", "loc", "fl", "body", "time", "c", "sync", " sizes", "limit", "line", "pos", "content", "function", "needed", "izes", "z", "en", "bytes", "send", "rc", "sec", "count", "shape", "term", "empty", "offset"], "pts": ["colts", "cold", "iptsize", "iptls", "ntsize", "pps", "ctsets", "ptsets", "PTd", "cts", "ptls", "putsize", "ointments", "ctments", "colsets", "ntsets", "iptts", "iptsets", "ointd", "ctsize", "PTsets", "putd", "ptments", "ctts", "ointsize", "ntd", "ctls", "nts", "ppsize", "putments", "ptsize", "PTs", "ptts", "ppls", "oints", "ctd", "iptd", "ppd", "cols", "ipts", "PTsize", "ptd"], "s": ["g", "is", "cs", "self", "sf", "client", "sys", "session", "sa", "src", "aws", "ps", "f", "this", "ds", "rs", "ss", "sq", "sw", "d", "ns", "ans", "si", "sd", "support", "h", "data", "ls", "sam", "es", "space", "gs", "c", "p", "sb", "sci", "ts", "service", "ks", "ssl", "sl", "xs", "su", "fs", "services", "sign", "S", "sg", "ses", "sts", "sv", "l", "hs", "sym", "serv", "se", "spec", "qs", "sync"], "st": ["stop", "str", "sn", "sf", "sa", "src", "sp", "inst", "t", "ss", "sw", "d", "St", "sd", "cl", "r", "sam", "sk", "sb", "p", "std", "ts", "service", "sl", "stage", "cr", "ST", "sta", "sts", "sv", "start", "sth", "sc", "ste", "steam"], "stream": ["progress", "rec", "coll", "client", "standard", "window", "sw", "pool", "child", "view", "record", "cl", "Stream", "cf", "head", "ssl", "content", "sl", "thread", "context", "wave", "can", "server", "prom", "source", "clean", "load", "own", "hw", "user", "forward", "full", "data", "draw", "public", "wrapper", "row", "model", "port", "host", "sync", "steam", "trans", "length", "uc", "draft", "buffer", "feed", "stack", "config", "control", "iv", "input", "raw", "file", "post", "channel", "stage", "ack", "header", "resource", "output", "result", "cur", "document", "form", "enc", "upload", "path", "sm", "ream", "reader", "loop", "time", "slice", "request", "sc", "event"], "dts": ["ddtes", "sdtt", " dTS", "dytes", "dcs", "ddtl", "dyts", " dds", " dtt", "Dts", "dtts", "dtl", "dycs", "sdds", "dds", "ddts", "ddcs", "dtds", " dtl", "dttt", "dytl", " dcs", " dtes", "dTS", "sdts", "DTS", "Dds", "dtt", "dtTS", "sdTS", "dtes"], "len": ["lim", "val", "str", " lang", "vec", "min", "coll", "f", "length", "lan", "bin", "lt", "ix", "Len", "li", "el", "lf", "n", "fun", "low", "lon", "fin", "il", " el", "data", "ls", "span", "dl", "rev", "hl", "lc", "late", "dy", "fl", "loc", "pre", "body", "line", "pos", "limit", "led", "sl", "z", "le", "err", "en", "ni", "zi", "la", "count", " length", "l", "ler", "lit", "lin", "ln", "elt"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n", "idx": 19987, "substitutes": {"cpu_model": ["cpu_Model", "cpu_path", " cpu_Model", "processor_Model", "cpu__Model", "cpu_block", "cpu__block", "processor_block", "cpu__path", "cpu_id", "cpu__model", " cpu_id", "processor_model", "processor_path"], "id": ["bit", "core", "sid", "cat", "proc", "worker", "name", "ids", "type", "parent", "proxy", "pad", "it", "uri", "rid", "root", "ip", "len", "fd", "base", "version", "i", "child", "Id", "ID", "oid", "vid", "path", "code", "index", "mid", "ctx", "kill", "ref", "c", "head", " fid", "uid", "rc", "num", "url", "seq", " ID", "kid", "start", "pid", "count", " pid", "info"], "prom_addr": ["promflen", "prom_align", "promemaddr", "promaladdress", "prompadd", "prom_address", "promaladdr", "promemaddress", "Prom_addr", "promfaddr", "prom_attr", "promfaddress", "prompaddr", "prom_data", "promaldata", "prom_len", "Prom_align", "prompaddress", "promemdata", "promfalign", "promemattr", "Prom_data", "Prom_add", "promalattr", "Prom_len", "Prom_attr", "prom_add", "prompalign", "Prom_address", "promplen"], "cpu_irqs": ["cpu__irqs", "cpu__ircs", "cpu_iperks", "cpu_arqs", "cpu_pirks", "cpu_iperqs", "cpu_arq", "cpu_iperfs", "cpu__irq", "cpu_rqu", "cpu_irfs", "cpu_pircs", "cpu_rcs", "cpu_iperq", "cpu_irq", "cpu_pirq", "cpu_pirqu", "cpu_ircs", "cpu__irqu", "cpu_rqs", "cpu_rq", "cpu_arks", "cpu_pirfs", "cpu_irqu", "cpu_arfs", "cpu_pirqs", "cpu_irks"], "cs": ["core", "cp", "css", "ils", "CS", "sys", "bs", "pc", "ps", "nc", "cache", "js", "conn", "ss", "ns", "cons", "co", "vs", "ls", "cas", "ctx", "ec", "lc", "ca", "sk", "cf", "c", "s", "cc", "ks", "cus", "fs", "rc", "utils", "spec", "sc", "ds", "Cs", "cn"], "cpu": ["console", "core", "cp", "css", "cm", "none", "pc", "proc", "clock", "CPU", "cli", "ck", "node", "nc", "cache", "instance", "net", "lp", "gc", "linux", "conn", "eni", "np", "obj", "hw", "config", "fc", "cpp", "pu", "pb", "computer", "ctx", "uci", "uno", "lc", "ec", "mac", "processor", "c", "fp", "loader", "colo", "hp", "ync", "null", "bench", "roc", "auc", "process", "cow", "vm", "ni", " CPU", "kernel", "cmp", "utils", "px", "pid", "python", "cu", "nu", "nic", "gpu", "cn"], "env": ["console", "shell", "core", "inet", "eu", "session", "proc", "skin", "cli", "export", "nc", "cache", "net", "global", "et", "enable", "conn", "el", "eni", "scope", "exec", "np", "Environment", "si", "args", "enc", "config", "agent", "db", "state", "init", "estate", "vs", "ef", "ctx", "ec", "exc", "conf", "ea", "profile", "c", "ext", "loader", "stage", "cfg", "priv", "en", "context", "vm", "ne", "gui", "viron", "ev", "kernel", "e", "environment", "que", "ds", "v", "oa"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "av_cold void avcodec_register(AVCodec *codec)\n\n{\n\n    AVCodec **p;\n\n    avcodec_init();\n\n    p = &first_avcodec;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p          = codec;\n\n    codec->next = NULL;\n\n\n\n    if (codec->init_static_data)\n\n        codec->init_static_data(codec);\n\n}\n", "idx": 19998, "substitutes": {"codec": ["codeec", "odenc", "capesc", "capec", " codEC", "pedenc", "Codoc", "cartec", "pedcode", "oderc", "codoc", "odac", "codac", "Codeca", " coderc", "odeca", "codeoc", "cartesc", "catec", "codef", " codcode", "copcc", "Coderc", "odoc", " codoc", "copoc", "capdc", "Codesc", "cateca", "codenc", "pedesc", "codesc", "Codef", "codeesc", "coderc", " coddc", "catef", " codesc", " codef", "codEC", "odec", "codecc", "Codec", "Codenc", "caperc", "cartdc", " codac", "CodEC", " codcc", "codcc", "copec", "pedec", "caterc", " codenc", "copesc", "Codcode", "odef", "codcode", "codeca", "carterc", "Codac", "coddc", "odEC"], "p": ["g", "cp", "f", "ap", "pc", "ps", "tp", "jp", "wp", "x", "op", "u", "parent", "lp", "po", "cache", "t", "q", "api", "point", "d", "np", "n", "ip", "bp", "pi", "i", "before", "pp", "pa", "r", "data", "o", "next", "pre", "c", "P", "k", "fp", "y", "pe", "b", "ep", "pointer", "up", "per", "e", "dp", "l", "a", "python", "v", "pr", "j", "m"]}}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 19999, "substitutes": {"p": ["g", "cp", "f", "ap", "pc", "proc", "ps", "tp", "sp", "x", "u", "op", "lp", "po", "t", "q", "param", "api", "pad", "d", "point", "np", "n", "ip", "bp", "pi", "pp", "pa", "r", "h", "code", "data", "o", "pre", "c", "P", "s", "patch", "post", "y", "k", "pe", "b", "pointer", "e", "l", "port", "a", "python", "part", "comp", "v", "pr", "j", "m"], "p_wwn": ["p_fwwn", "p_wbl", "p_wwgn", "p_whgn", "p_wgn", "p_WWN", "p_awclaim", "p_Wwn", "p_wwbl", "p_wsiw", "p_wawn", "p_fwwan", "p_Wkn", "p_whawn", "p_wwawn", "p_wdgn", "p_wwwan", "p_wkn", "p_wwwn", "p_fwbl", "p_Www", "p_wwd", "p_whww", "p_Wbl", "p_Wgn", "p_whwd", "p_awgn", "p_wdww", "p_www", "p_wskn", "p_wiw", "p_Wiw", "p_nwWN", "p_whWN", "p_nwgn", "p_wswn", "p_whwn", "p_wWN", "p_Wwan", "p_nwww", "p_awwn", "p_wwan", "p_wdclaim", "p_Wclaim", "p_wdwn", "p_wclaim", "p_nwwn", "p_fwgn", "p_wwwd", "p_awww", "p_wsgn"], "i": ["g", "phi", "di", "f", "ri", "xi", "hi", "type", "qi", "u", "x", "ci", "li", "t", "bi", "it", "mu", "d", "mi", "n", "ip", "base", "I", "pi", "si", "multi", "index", "ai", "chi", "iu", "o", "lc", "ii", "c", "y", "b", "z", "ui", "ni", "gi", "e", "l", "a", "io", "oi", "ie", "ini", "v", "ti", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_i_picture_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex, status = 0;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n#if HAS_ADVANCED_PROFILE\n\n    if (v->profile <= PROFILE_MAIN)\n\n#endif\n\n    {\n\n        if (v->extended_mv) v->mvrange = get_prefix(gb, 0, 3);\n\n        if (v->multires) v->respic = get_bits(gb, 2);\n\n    }\n\n#if HAS_ADVANCED_PROFILE\n\n    else\n\n    {\n\n        v->s.ac_pred = get_bits(gb, 1);\n\n        if (v->postprocflag) v->postproc = get_bits(gb, 1);\n\n        /* 7.1.1.34 + 8.5.2 */\n\n        if (v->overlap && v->pq<9)\n\n        {\n\n            v->condover = get_bits(gb, 1);\n\n            if (v->condover)\n\n            {\n\n                v->condover = 2+get_bits(gb, 1);\n\n                if (v->condover == 3)\n\n                {\n\n                    status = bitplane_decoding(&v->over_flags_plane, v);\n\n                    if (status < 0) return -1;\n\n#if TRACE\n\n                    av_log(v->s.avctx, AV_LOG_DEBUG, \"Overflags plane encoding: \"\n\n                           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n                }\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return status;\n\n}\n", "idx": 20000, "substitutes": {"v": ["g", "val", "f", "uv", "lv", "ov", "vim", "u", "qv", "t", "q", "api", "vin", "d", "video", "conv", "n", "view", "version", "i", "av", "vi", "dev", "h", "va", "vp", "iv", "vs", "rev", "volt", "o", "c", "k", "p", "s", "var", "gu", "vc", "vol", "b", "inv", "cv", "value", "ve", "ver", "vert", "nav", "nv", "vt", "vm", "en", "vr", "vd", "ev", "e", "sv", "l", "vv", "serv", "V", "tv", "j", "m"], "gb": ["g", "gm", "gru", "gin", "bo", "du", "pc", "bc", "gam", "gc", "gow", "bi", "bb", "hub", "gd", "gom", "bm", "lib", "mobi", "db", "storage", "cgi", "Gb", "eb", "ctx", "ged", "ga", "gio", "gs", "gnu", "rb", "bridge", "game", "sb", "abb", "vg", "gt", "vc", "gh", "b", "mb", "rg", "ko", "gp", "cfg", "hd", "agg", "gz", "gae", "nb", "git", "gy", "gui", "ogg", "cb", "sg", "bf", "gg", "phy", "GB", "kb", "lb", "usb", "gpu", "bg", "cod"], "pqindex": ["pdqind", "pqulen", "pqengine", "pdqweight", "pqqengine", "pquinfo", "cdqind", "prfxlen", "pqainfo", "pqlen", " pqIndex", "pqweight", "pqtind", "pqsite", "hquindex", "prfxindex", "pqlindex", " pdqweight", "pquweight", "pdqactive", "pqlactive", "cdqsize", "hqsite", "pqaIndex", " pqweight", "pdqindex", "pqunumber", "pqnumber", "pqqnumber", "pqaloc", "p_index", "pdqpath", "pqusite", " p_index", "pkgweight", "pfxindex", "pquengine", "pquindex", "cqind", "cqsize", "pqind", "pksize", "hqactive", "prqnumber", "prqindex", " pqloc", "p_info", "pdqsize", " pdqindex", "pqactive", "prqlen", "hqindex", "prfxnumber", "pkgindex", "pqloc", "pkgpath", "pkindex", "pqinfo", "pquIndex", "hqusite", "pdqsite", "pquactive", " p_loc", "pquloc", "hquactive", "pfxengine", "pqqlen", "prqengine", "pqtsize", "pkind", "cqindex", "p_Index", "pqlsite", "pfxlen", "pqsize", "pqaindex", "pqupath", " pqpath", "pqtindex", "pqqindex", "p_loc", " p_info", " pdqpath", "prfxengine", "cdqindex", "pqIndex", " pqinfo", " p_Index", "pfxnumber", "pqpath"]}}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    AVCodec *dec;\n\n    char val_str[128];\n\n    AVDictionaryEntry *tag = NULL;\n\n    AVRational display_aspect_ratio;\n\n\n\n    printf(\"[STREAM]\\n\");\n\n\n\n    printf(\"index=%d\\n\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        if ((dec = dec_ctx->codec)) {\n\n            printf(\"codec_name=%s\\n\", dec->name);\n\n            printf(\"codec_long_name=%s\\n\", dec->long_name);\n\n        } else {\n\n            printf(\"codec_name=unknown\\n\");\n\n        }\n\n\n\n        printf(\"codec_type=%s\\n\", media_type_string(dec_ctx->codec_type));\n\n        printf(\"codec_time_base=%d/%d\\n\",\n\n               dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        printf(\"codec_tag_string=%s\\n\", val_str);\n\n        printf(\"codec_tag=0x%04x\\n\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            printf(\"width=%d\\n\", dec_ctx->width);\n\n            printf(\"height=%d\\n\", dec_ctx->height);\n\n            printf(\"has_b_frames=%d\\n\", dec_ctx->has_b_frames);\n\n            if (dec_ctx->sample_aspect_ratio.num) {\n\n                printf(\"sample_aspect_ratio=%d:%d\\n\",\n\n                       dec_ctx->sample_aspect_ratio.num,\n\n                       dec_ctx->sample_aspect_ratio.den);\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n\n                          1024*1024);\n\n                printf(\"display_aspect_ratio=%d:%d\\n\",\n\n                       display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            printf(\"pix_fmt=%s\\n\",\n\n                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name\n\n                                                    : \"unknown\");\n\n            printf(\"level=%d\\n\", dec_ctx->level);\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            printf(\"sample_rate=%s\\n\", value_string(val_str, sizeof(val_str),\n\n                                                    dec_ctx->sample_rate,\n\n                                                    unit_hertz_str));\n\n            printf(\"channels=%d\\n\", dec_ctx->channels);\n\n            printf(\"bits_per_sample=%d\\n\",\n\n                   av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n        }\n\n    } else {\n\n        printf(\"codec_type=unknown\\n\");\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n\n        printf(\"id=0x%x\\n\", stream->id);\n\n    printf(\"r_frame_rate=%d/%d\\n\",\n\n           stream->r_frame_rate.num, stream->r_frame_rate.den);\n\n    printf(\"avg_frame_rate=%d/%d\\n\",\n\n           stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n\n    printf(\"time_base=%d/%d\\n\",\n\n           stream->time_base.num, stream->time_base.den);\n\n    printf(\"start_time=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->start_time, &stream->time_base));\n\n    printf(\"duration=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->duration, &stream->time_base));\n\n    if (stream->nb_frames)\n\n        printf(\"nb_frames=%\"PRId64\"\\n\", stream->nb_frames);\n\n\n\n    while ((tag = av_dict_get(stream->metadata, \"\", tag,\n\n                              AV_DICT_IGNORE_SUFFIX)))\n\n        printf(\"TAG:%s=%s\\n\", tag->key, tag->value);\n\n\n\n    printf(\"[/STREAM]\\n\");\n\n}\n", "idx": 20005, "substitutes": {"fmt_ctx": ["fmp_loc", "fmt2lc", "fmp2ctx", "fmt_lc", "fmt2ca", "fmp2hw", "fmp_hw", "fmp_ca", "fmp2ca", "fmt_ca", "fmp2lc", "fmt_context", "fmp_lc", "fmp_context", "fmt2hw", "fmt_loc", "fmp_ctx", "fmt2ctx", "fmt_hw"], "stream_idx": ["stream_Idy", "stream_idindex", "stream_Idxes", "stream_needxes", "stream_lenxes", "stream_idsy", "stream_lenx", "stream_partxes", "stream_needx", "stream_needy", "stream_needxs", "stream_idxs", "stream_idy", "stream_Idx", "stream_idsxes", "stream_lenindex", "stream_Idindex", "stream_partx", "stream_partindex", "stream_idsx", "stream_idsxs", "stream_party", "stream_leny", "stream_idxes"], "stream": ["wave", "round", "rec", "track", "client", "output", "length", "src", "uc", "transform", "source", "draft", "document", "form", "valid", "pool", "feed", "view", "down", "path", "input", "ream", "draw", "Stream", "reader", "writer", "hook", "loop", "time", "object", "channel", "filter", "func", "stage", "sign", "image", "context", "unk", "row", "model"], "dec_ctx": ["dev_anc", "ec_hw", "decaccontext", "decaccf", "decingcu", "dec1cca", "ec_canon", "decLcontext", " dec_voc", " dec_loc", "decallrec", "decalcas", "dev_loc", "decallfc", "devacsrc", "dec_sci", "delLcca", "dec_fact", "decalllc", "dev_cf", "decacsync", "decLsrc", " dec_tx", "decPcontext", "dec_cas", "decallcmp", "del_cn", "decingctx", "decpcontext", "del_cus", "decallcas", "dec1sys", "dec_lc", "Dec_rec", "dec__canon", "dec_cca", "decallctx", " dec_vc", "dec1cn", "decLcca", "Dec_cb", "loc_loc", "decpqa", " dec_conn", "decsctx", "Dec_scope", "decaccas", "devaccf", "decscontext", "loc_cu", "delLcn", "dec_context", "Dec_loc", "decallcf", "loc_ctx", "decLcn", "dec_hw", "delLctx", "dev_src", "ec_context", "dec_cf", "devacctx", "decaccu", "dev_lc", "decingloc", "dec__gal", " dec_cmp", "dec_cus", "del_ctx", " dec_qa", " dec_cu", "devallctx", "dec_ci", "ec_tx", "devalllc", "dev_ctx", "decLcf", "dec__loc", "decsloc", "ec_gal", "dec_scope", "decLctx", "dec_fc", "devalltx", "devallloc", "decalctx", "Dec_tx", "decallcontext", "dec_cu", "delLcus", "decstx", "decallloc", "dec_src", "decalsci", "decpproc", "loc_hw", "decjctx", "decPscope", "decjcb", "Dec_context", " dec_sync", "decalltx", "dec_anc", "decalloc", " dec_sci", "dec_cmp", "dec_sys", "dec_cn", "decLloc", "ec_loc", "decjcontext", " dec_fact", "dec_conn", "ec_cmp", "dec_vc", "decacfc", "dec_tx", "devacanc", "dec_canon", "dec__ctx", "decPcb", " dec_proc", "ec_lc", "dec_cb", "ec_ctx", "dev_tx", "dec1lc", "dec_voc", "decPctx", "decacloc", "dec_proc", "Dec_ctx", "decallanc", "decLcus", "decallsrc", "decLfact", "decLanc", "dec_gal", " dec_cas", "decacsrc", " dec_fc", " dec_ci", "ec_sys", "dec_sync", "dec_loc", "decjscope", "decingsync", "dec_rec", "decacanc", "dec1ctx", "dec1cus", "decjqa", " dec_context", "dec1loc", "decpctx", "decjproc", "decacctx", "dec_qa", "del_cca"], "val_str": ["val24set", "valxstr", "val2arr", "valingstr", "val64arr", "val_len", "val64STR", "val24str", "val24seq", "val_tr", " val_text", "str_set", "val_string", "valingtr", "str_str", "valxset", "val_name", "strxlen", "strxstr", "val_exec", " val_tr", "valxseq", "valingSTR", "strxexec", "val_STR", " val_Str", "val_seq", "val2str", "valxstring", "val_set", "val24name", "val_arr", "val2Str", " val_STR", "eval_str", "eval_seq", "val24string", "val64str", "valxexec", "val2text", "val_text", "eval_string", "eval_name", "valingarr", "valpStr", "str_exec", "valxlen", "valparr", "str_len", "strxset", "val_Str", "valxname", "val24len", " val_arr", "valptext", "val24exec", "valpstr", "val64tr"], "tag": ["val", "TAG", "cat", "length", "category", "match", "type", "cache", "mod", "reg", "col", "enc", "id", "code", "year", "doc", "block", "format", "ag", "pos", "key", "comment", "Tag", "count", "attr", "row", "date"], "display_aspect_ratio": ["display_aspect_basios", "display_aspect_ratlo", "display_aspect_tagio", "display_aspect_ratatio", "display_aspect_Ratio", "display_aspectingratios", "display_aspect_reportiod", "display_aspect_ratial", "display_aspect_rotogram", "display_aspect_radios", "display_aspect_latatio", "display_aspect_Rati", "display_aspectingbasiod", "display_aspect_basio", "display_aspect_basiod", "display_aspect_rateogram", "display_aspect_ratios", "display_aspect_atios", "display_aspect_rateio", "display_aspect_ratii", "display_aspect_bitric", "display_aspect_accio", "display_aspect_biti", "display_aspect_ratric", "display_aspect_rateios", "display_aspect_ratior", "display_aspect_statios", "display_aspect_latiod", "display_aspect_accii", "display_aspect_dimial", "display_aspectingratio", "display_aspect_ratelo", "display_aspect_reportios", "display_aspect_Ratios", "display_aspect_radio", "display_aspectingbasios", "display_aspectingratatio", "display_aspect_rotlo", "display_aspect_rati", "display_aspect_latios", "display_aspect_tagi", "display_aspect_Ratii", "display_aspect_reportatio", "display_aspect_rat0", "display_aspect_reportio", "display_aspect_ratogram", "display_aspect_basatio", "display_aspect_bitior", "display_aspect_Ratial", "display_aspect_dimios", "display_aspectingbasio", "display_aspect_radii", "display_aspect_latio", "display_aspect_Rat0", "display_aspect_accios", "display_aspectingratiod", "display_aspect_rotio", "display_aspect_Ratric", "display_aspect_atio", "display_aspect_statio", "display_aspect_dimio", "display_aspect_statogram", "display_aspect_Ratior", "display_aspect_rotios", "display_aspect_rad0", "display_aspect_acc0", "display_aspectingbasatio", "display_aspect_atial", "display_aspect_tagior", "display_aspect_statlo", "display_aspect_tagric", "display_aspect_ratiod", "display_aspect_bitio"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "static void encode_block(MpegEncContext *s, int16_t *block, int n)\n\n{\n\n    int i, j, table_id;\n\n    int component, dc, last_index, val, run;\n\n    MJpegContext *m = s->mjpeg_ctx;\n\n\n\n    /* DC coef */\n\n    component = (n <= 3 ? 0 : (n&1) + 1);\n\n    table_id = (n <= 3 ? 0 : 1);\n\n    dc = block[0]; /* overflow is impossible */\n\n    val = dc - s->last_dc[component];\n\n\n\n    ff_mjpeg_encode_coef(m, table_id, val, 0);\n\n\n\n    s->last_dc[component] = dc;\n\n\n\n    /* AC coefs */\n\n\n\n    run = 0;\n\n    last_index = s->block_last_index[n];\n\n    table_id |= 2;\n\n\n\n    for(i=1;i<=last_index;i++) {\n\n        j = s->intra_scantable.permutated[i];\n\n        val = block[j];\n\n\n\n        if (val == 0) {\n\n            run++;\n\n        } else {\n\n            while (run >= 16) {\n\n                ff_mjpeg_encode_code(m, table_id, 0xf0);\n\n                run -= 16;\n\n            }\n\n            ff_mjpeg_encode_coef(m, table_id, val, run);\n\n            run = 0;\n\n        }\n\n    }\n\n\n\n    /* output EOB only if not already 64 values */\n\n    if (last_index < 63 || run != 0)\n\n        ff_mjpeg_encode_code(m, table_id, 0);\n\n}\n", "idx": 20019, "substitutes": {"s": ["is", "g", "cs", "sf", "sys", "f", "sa", "session", "ps", "js", "south", "t", "ss", "sq", "ns", "si", "r", "sm", "ls", "es", "sam", "ctx", "o", "space", "w", "params", "comm", "gs", "conf", "c", "p", "sb", "ts", "service", "b", "ssl", "xs", "sl", "su", "sim", "services", "fs", "S", "sg", "ses", "e", "sv", "l", "settings", "os", "sets", "spec", "v", "ds", "an", "sync"], "block": ["batch", "check", "map", "Block", "session", "length", "rule", "number", "clock", "match", "type", "node", "cache", "frame", "work", "name", "load", "clean", "error", "buffer", "view", "ip", "record", "position", "config", "id", "blocks", "cl", "panel", "pack", "call", "pre", "join", "time", "object", "line", "patch", "unit", "value", "comment", "group", "image", "lock", "un", "row", "box", "event", "field", "sync"], "n": ["g", "sn", "cn", "f", "number", "node", "nc", "x", "net", "na", "name", "u", "t", "conn", "common", "d", "no", "ns", "nn", "r", "code", "span", "o", "nl", "N", "c", "k", "nt", "p", "pn", "y", "b", "z", "mn", "en", "nor", "nb", "ne", "num", "non", "e", "network", "l", " N", "a", "nu", "size", "v"], "i": ["di", "f", "ri", "xi", "x", "qi", "ix", "u", "ci", "li", "eni", "bi", "ji", "uri", "d", "info", "ip", "ti", "I", "pi", "si", "id", "index", "ai", "r", "iu", "ii", "c", "k", "p", "y", "ind", "b", "z", "mini", "ui", "ni", "zi", "gi", "fi", "e", "l", "ori", "io", "ie", "ini", "v", "mi"], "j": ["g", "ja", "f", "jp", "u", "jo", "ci", "li", "je", "js", "ji", "exec", "d", "jl", "job", "ij", "si", "jit", "r", "index", "jet", "o", "aj", "ii", "k", "c", "jc", "p", "sync", "adj", "uj", "unit", "ind", "b", "z", "ni", "un", "e", "l", "J", "ie", "v", "jj"], "table_id": ["tableappsid", "table_index", "table_ide", "tableingkid", "table_name", "tableCsize", "tableingtype", "machine_type", "cache_ID", " tableingkid", "table_base", "tableapptype", "tableapphead", "table_source", "table__type", " tableingid", "table_kid", "stable_uri", "table_ids", "cache_name", "table_uri", "cache_index", "tableingid", "stable_name", "machine_head", "tablebookform", "tableingID", "last_version", "tablebookids", "table_type", " tableingtype", " table_form", "table__sid", "table__head", "table_head", "tableingname", "tableCname", "stable_source", " table_kid", "machine_id", "table__id", "tableappid", "table_sid", "last_name", " table_base", "table_form", " tableingname", " table_ids", "stable_id", "machine_sid", "table_ID", "tableCversion", " table_type", "cache_id", " table_ide", "tablebookbase", "tablebookid", "table_version", "table_size", "tableingindex", "tableCid", " table_ID", "last_size", " table_name", "last_id"], "component": ["sample", "core", "section", "container", "coll", "rule", "du", "onents", "project", "category", "chrom", "com", "node", "name", "compatible", "production", "common", "connection", "member", "position", "method", "controller", "direction", "config", "module", "uni", "card", "division", "duration", "index", "code", "draw", "cell", "dimension", "circ", "processor", "ce", "c", "character", "patch", "channel", "conference", "unit", "service", "quarter", "function", "event", "comment", "package", "context", "element", "cycle", "shape", "cmp", "company", "Component", " components", "comp", "attribute", "host", "mode"], "dc": ["dr", "disc", "container", "cd", "di", "cdn", "cm", "coll", "cat", "du", "pc", "uc", "cmd", "nc", "inc", "ac", "bc", "dim", "dm", "exec", "d", "DC", "config", "id", "db", "index", "dom", "dir", "doc", "draw", "lc", "design", "ga", "loc", "cf", "c", "center", "de", "depth", "da", "cc", "dist", "desc", "mc", "anc", "sc", "fc", "comp"], "last_index": ["last__ind", "last__position", " last__position", "lastCid", " last_position", "one_index", "lastCposition", "lastCnumber", "last_position", "last_number", " last_id", "max_condition", "max_position", "last__search", "lastWorkposition", " lastCid", "last_weight", "max_index", " lastCnumber", "last__number", " lastCindex", " last__index", "one_id", "last_offset", "lastOweight", "lastFindex", " last_number", "lastFposition", "lastFsearch", " last_search", "one_weight", "last__id", "lastOoffset", "last_search", "max_length", "last__index", " last__search", "lastWorknumber", " last__ind", "lastWorkid", "last_condition", "lastOindex", "lastOid", " last_ind", "lastCindex", "one_offset", "lastWorkindex", "last_ind", "lastFind", "last_id", " lastCposition", "last_length"], "val": ["ann", "f", "VAL", "aval", "bc", "x", "ol", "po", "el", "reg", "vals", "valid", "rel", "exec", "d", "view", "len", "base", "col", "fee", "lib", "version", "vi", "dev", "db", "index", "r", "il", "doc", "win", "data", "trial", "lc", "ee", "pass", "loc", "Val", "slot", "ref", "live", "p", "al", "pos", "vol", "unit", "b", "eval", "sl", "def", "ind", "value", "update", "err", "sel", "fat", "seq", "ret", "arg", "comp", "v"], "run": ["ann", "ru", "round", "UN", "min", "length", "route", "work", "ro", "type", "runner", "mod", "running", "clean", "don", "end", "ran", "exec", "reg", "rate", "no", "old", "view", "fun", "len", "ride", "play", "r", "index", "year", "con", "win", "man", "pass", "call", "mor", "read", "loop", "pos", "unit", "thread", "update", "Run", "rown", "rc", "num", "un", "row", "day", "order", "mix", "go", "sync", "use"], "m": ["g", "gm", "cm", "ms", "f", "M", "machine", "om", "t", "dm", "wm", "d", "fm", "um", "pm", "message", "module", "bm", "mo", "sm", "man", "em", "mac", "c", "p", "y", "mr", "mos", "b", "mn", "am", "vm", "mc", "e", "ym", "l", "mm", "im", "v", "hm", "manager", "md", "mi"]}}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dstParam[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint16_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint16_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\tint srcStride[3];\n\n\tuint8_t *src[3];\n\n\tuint8_t *dst[3];\n\n\t\n\n\tif((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[2];\n\n\t\tsrc[2]= srcParam[1];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[2];\n\n\t\tsrcStride[2]= srcStrideParam[1];\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_YV12){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[1];\n\n\t\tsrc[2]= srcParam[2];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[1];\n\n\t\tsrcStride[2]= srcStrideParam[2];\n\n\t}\n\n\telse if(isPacked(c->srcFormat)){\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= srcParam[0];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStrideParam[0]<<1;\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_Y8){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= NULL;\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= 0;\n\n\t}\n\n\n\n\tif((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[2];\n\n\t\tdst[2]= dstParam[1];\n\n\t\t\n\n\t}else{\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[1];\n\n\t\tdst[2]= dstParam[2];\n\n\t}\n\n\t\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);\n\n\t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);\n\n*/\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we cant output a dstY line so lets try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\t\t\tRENAME(yuv2yuvX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2rgbX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstFormat,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n", "idx": 20022, "substitutes": {"c": ["g", "cs", "cp", "cn", "rec", "coll", "dc", "f", "cm", "client", "pc", "com", "uc", "nc", "u", "ac", "bc", "ci", "cur", "cache", "t", "d", "n", "col", "ch", "enc", "i", "config", "co", "con", "o", "ctx", "ec", "lc", "ca", "cf", "conf", "ce", "center", "p", "cont", "cc", "y", "vc", "ic", "cr", "tc", "ct", "cit", "rc", "cb", "mc", "e", "k", "l", "ctrl", "cu", "C", "xc", "sc", "spec", "v", "m"], "srcParam": ["rcMem", "srcPar", "selPar", "srcPart", "rcPart", " srcMem", "selMem", "rcPar", "srcMem", " srcPart", "selParam", "rcParam", "selPart", " srcPar"], "srcStrideParam": ["srcStriteNum", "srcRestripParam", "srcStriteMin", "srcRestrideParam", "srcStrMin", "srcStripPar", "srcStrParam", "srcRestripPar", "srcStrNum", "srcRestripNum", "srcStrideMin", "srcRestridePar", "srcStripMin", "srcStrideNum", "srcRestrideNum", "srcRestrideMin", "srcRestripMin", "srcStrPar", "srcStriteParam", "srcStritePar", "srcStridePar", "srcStripParam", "srcStripNum"], "srcSliceY": ["srcFliceY", "srcSliney", "srcSlicey", "srcSliceW", "srcSliceYY", "srcFlueYY", "srcSluey", "srcSlueY", "srcSlangeW", "srcFlicey", "srcFliceW", "srcFluey", "srcFliceYY", "srcSlineY", "srcSlangeYY", "srcSlueW", "srcSlangeY", "srcFlueY", "srcSlineYY", "srcSlineW", "srcSlueYY", "srcSlangey", "srcFlueW"], "srcSliceH": ["srcPlaceG", "srcSlaceY", "srcSlueH", "srcSliceW", "srcSlueG", "srcPlaceW", "srcSliceG", "srcPliceH", "srcSlueY", "srcSlaceH", "srcPlaceH", "srcPliceY", "srcSlashW", "srcSlaceW", "srcPlaceY", "srcSlueW", "srcPliceG", "srcSlashG", "srcSlaceG", "srcSlashH", "srcSlashY", "srcPliceW"], "dstParam": ["DndParameter", "dstMem", "dndParameter", "drdPar", "DstParam", "dSTParameter", "dSTPar", "DndPar", "DstPar", "DstMem", "drdMem", "dndParam", "DndMem", "dSTMem", "dndPar", "drdParameter", "DstParameter", "dSTParam", "dstPar", "drdParam", "DndParam", "dstParameter", "dndMem"], "dstStride": ["dststride", "dscStOverride", "dstStructure", "dscDestride", "dscDestOverride", "dstSTructure", "dststOverride", "dstSTide", "dstSTOverride", "dscStructure", "dscDestructure", "dstDestructure", "dstSTride", "dscStride", "dststide", "dstDestide", "dstStide", "dscStide", "dscDestide", "dstDestride", "dstDestOverride", "dstStOverride", "dststructure"], "vLumFilterPos": ["vLumMaskLen", "vLUMFilterPosition", "vLumNumberPosition", "vLUMFilterLoc", "vLUMNumberLoc", "vLumNumberLoc", "vLUMFilterMin", "vLUMNumberPos", "vLumMaskLoc", "vLumFilterPosition", "vLumControlPosition", "vLumLimitLoc", "vLumControlLoc", "vLUMNumberPOS", "vLumFilterLen", "vLumFilterMin", "vLUMNumberPosition", "vLumLimitLen", "vLUMFilterPos", "vLumLimitPos", "vLumFilterPOS", "vLumFeatureMin", "vLUMMaskLen", "vLumFilterLoc", "vLUMMaskMin", "vLumFPOS", "vLumFeatureLoc", "vLUMMaskPos", "vLUMFilterLen", "vLumNumberPos", "vLumControlPos", "vLumControlPOS", "vLumFeaturePos", "vLUMMaskLoc", "vLumFPos", "vLumMaskPos", "vLumMaskMin", "vLumLimitMin", "vLumNumberPOS", "vLumFLoc", "vLumFeatureLen", "vLumFPosition", "vLUMFilterPOS"], "vChrFilterPos": ["vChrUserPos", "vChrRuleDir", "vChrFilterRes", "vChrFPer", "vChrUserpos", "vChrNumberDir", "vChruFactorRes", "vChrListenerRes", "vChrRulePos", "vChrRulepos", "vChrFilterPOS", "vChruFactorPer", "vChrRulePOS", "vChrNumberPos", "vChruFilterPer", "vChrFactorPer", "vCharFilterpos", "vChrFactorRes", "vChrFPos", "vChrFPosition", "vChrNumberPOS", "vChrFilterDir", "vChruFactorPos", "vCharFilterPos", "vChruFactorPosition", "vCharFilterPOS", "vCharUserPOS", "vCharFilterDir", "vChruFilterPos", "vChruFilterRes", "vChrFRes", "vChrNumberpos", "vChrFilterPer", "vChrUserDir", "vChrListenerPer", "vChrFactorPosition", "vChrFilterPosition", "vChrListenerPos", "vChrFactorPos", "vChrUserPOS", "vCharUserPos", "vChrFilterpos", "vChrListenerPosition", "vChruFilterPosition", "vCharUserpos", "vCharUserDir"], "hLumFilterPos": ["hLumFilterpos", "hLumaHeaderPosition", "hLumerGroupStart", "hLumerGroupPos", "hLumFilterPosition", "hLumHeaderPosition", "hLumGroupPos", "hLumHeaderPos", "hLumFileTrans", "hLumGrouppos", "hLumerFilterpos", "hLumValuePosition", "hLumControlPos", "hLumerFilterPos", "hLumerGroupPosition", "hLumControlStart", "hLumFilterStart", "hLumerFilterStart", "hLumFilePosition", "hLumerFilterPosition", "hLumHeaderTrans", "hLumValuePos", "hLumaHeaderSize", "hLumaHeaderPos", "hLumFileStart", "hLumGroupPosition", "hLumControlpos", "hLumHeaderSize", "hLumFileSize", "hLumaFilterPosition", "hLumaFilterTrans", "hLumGroupStart", "hLumaFilterPos", "hLumFilterTrans", "hLumFilePos", "hLumFilterSize", "hLumaHeaderTrans", "hLumFilepos", "hLumControlPosition", "hLumValueTrans", "hLumaFilterSize", "hLumValueSize", "hLumerGrouppos"], "hChrFilterPos": ["hChrbSearchPos", "hChrSearchLoc", "hChmLimitEx", "hChrLimitOff", "hChrLimitPos", "hChrManagerPos", "hChrControlEx", "hChrFilterPo", "hChrMasterLoc", "hChrbFilterPos", "hChrSearchPos", "hChrbFilterPo", "hChrManagerEx", "hChrLimitEx", "hChrHandlerLoc", "hChmLimitPos", "hChrbFilterLoc", "hChrManagerPo", "hChmLimitOff", "hChrMasterNeg", "hChrFilterOff", "hChrSearchNeg", "hChrManagerOff", "hChmFilterEx", "hChrControlOff", "hChmFilterPos", "hChrLimitPo", "hChrHandlerPos", "hChmFilterPo", "hChrControlPos", "hChrFilterLoc", "hChrbSearchLoc", "hChrSearchPo", "hChrHandlerNeg", "hChmFilterOff", "hChrMasterPo", "hChrFilterNeg", "hChmLimitPo", "hChrFilterEx", "hChrHandlerPo", "hChrbFilterNeg", "hChrbSearchPo", "hChrControlPo", "hChrMasterPos", "hChrbSearchNeg"], "vLumFilter": ["vPlumbLevel", "vLumeLimit", "vLumLimit", "vLmpFilter", "vLumbGroup", "vPlumLevel", "vBlumLimit", "vBlumGroup", "vPlumbFilter", "vLumeFilter", "vBlumbLimit", "vLumbLevel", "vPlumSort", "vLumeGroup", "vLumerControl", "vBlumbFlow", "vLumSort", "vLmpSort", "vPlumControl", "vLumGroup", "vLrumFilter", "vLumbFilter", "vBlumbGroup", "vPlumFilter", "vLmpControl", "vLrumGroup", "vPlumbControl", "vLumFlow", "vLumbFlow", "vLumbLimit", "vPlumbSort", "vLumerFilter", "vLumerLevel", "vLumbControl", "vLumeFlow", "vLumerSort", "vBlumFilter", "vLumControl", "vBlumbFilter", "vLrumFlow", "vBlumFlow", "vLumLevel", "vLmpLevel", "vLrumLimit", "vLumbSort"], "vChrFilter": ["vChbLayer", "vCHrcLayer", "vChrControl", "vChlMask", "vChrcFile", "vchrcFilter", "vChrcMask", "vCHrcLimit", "vCHrFile", "vChrcControl", "vchrMask", "vCHrFilter", "vChrtControl", "vChlControl", "vChrLayer", "vCHrcFile", "vChrcLayer", "vChbLimit", "vCHrLimit", "vChbFilter", "vChlLimit", "vchrcControl", "vCHrcFilter", "vChrcLimit", "vChlFilter", "vChrLimit", "vChrtMask", "vCHrLayer", "vChrbLayer", "vChrtFilter", "vchrcMask", "vChbFile", "vChrbFilter", "vchrControl", "vChrbFile", "vChrMask", "vchrLimit", "vchrcLimit", "vChrFile", "vChrbLimit", "vChrcFilter", "vChrtLimit", "vchrFilter"], "hLumFilter": ["hSlulFlow", "hLummerSort", "hSlulFilter", "hElumbFilter", "hElumbSort", "hElumbPath", "hLummerControl", "hLmFilter", "hLuncRule", "hLulRule", "hLumaControl", "hLumbSort", "hLulSort", "hElumControl", "hSlumRule", "hLmSort", "hLumPath", "hLumbFilter", "hSlulSort", "hLuncSort", "hLuncFlow", "hLumaPath", "hElumSort", "hElumFilter", "hLmRule", "hSlulRule", "hSlumFilter", "hLulFilter", "hElumbControl", "hSlumFlow", "hLumFlow", "hLumbPath", "hLumaSort", "hElumPath", "hLumaFilter", "hLumRule", "hLumbControl", "hLummerFilter", "hSlumSort", "hLulFlow", "hLmFlow", "hLuncFilter", "hLumControl", "hLumSort", "hLummerPath"], "hChrFilter": ["hChmSort", "hPhrcLimit", "hColrgFilter", "hChmFactor", "hChrFactor", "hChpFilter", "hColrHandler", "hChrgRule", "hChrgFilter", "hChruSort", "hChrgHandler", "hPhrFilter", "hCharHandler", "hColrgHandler", "hChruHandler", "hColrRule", "hChrRule", "hChpSort", "hPhrSort", "hChmLimit", "hPhrFactor", "hChrcSort", "hChruFilter", "hPhrLimit", "hChrcFilter", "hChruRule", "hColrgRule", "hChrcLimit", "hChrHandler", "hColrFilter", "hColrSort", "hChrSort", "hPhrcFilter", "hCharFilter", "hChpFactor", "hColrgSort", "hChrgSort", "hChmFilter", "hPhrcFactor", "hChrLimit", "hChrcFactor", "hChpLimit", "hCharSort", "hPhrcSort", "hCharRule"], "lumMmxFilter": ["lumMuxMask", "lumMappingFilter", "lumMmxConfig", "lumMappingFile", "lumMappingLimit", "lumRaxFilter", "lumMxSort", "lumMmxLimit", "lumMpxSort", "lumRmxFilter", "lumMwmFile", "lumMappingMask", "lumRmxConfig", "lumMuxLimit", "lumMaxFilter", "lumRaxConfig", "lumRmxLimit", "lumRmxSort", "lumMwmMask", "lumMpxLimit", "lumMxLimit", "lumMpxConfig", "lumRaxLimit", "lumMaxConfig", "lumMpxFilter", "lumMaxLimit", "lumMuxFile", "lumRaxSort", "lumMmxSort", "lumMmxMask", "lumMmxFile", "lumMuxFilter", "lumMwmLimit", "lumMxFilter", "lumMwmFilter", "lumMaxSort", "lumMxConfig"], "chrMmxFilter": ["chrMexRule", "chrMMXFi", "chrMmxSort", "chrMmxLimit", "chrLmxFilter", "chrVmxFilter", "chrMpxLimit", "chrMiasFilter", "chrMappedControl", "chrMappedLimit", "chrMMXControl", "chrViasFilter", "chrLmxLimit", "chrMappedFilter", "chrMmxControl", "chrViasRule", "chrMmxRule", "chrMiasControl", "chrMuxFilter", "chrMiasSort", "chrLpxControl", "chrMappedFi", "chrMmxFi", "chrMpxFi", "chrViasSort", "chrVmxControl", "chrMuxSort", "chrMpxControl", "chrMMXLimit", "chrLmxControl", "chrLpxFilter", "chrMexSort", "chrMMXFilter", "chrVmxSort", "chrMuxRule", "chrMuxControl", "chrLpxFi", "chrLmxFi", "chrMexControl", "chrMexFilter", "chrViasControl", "chrMiasRule", "chrLpxLimit", "chrVmxRule", "chrMpxFilter"], "lumPixBuf": ["lumPexBmp", "lumPixFliff", "lumPixBiff", "lumPixCuff", "lumPixFluff", "lumPixCoff", "lumPixFuff", "lumPixAmp", "lumPixFaf", "lumPxBiff", "lumPixLmp", "lumPixAuff", "lumPixCiff", "lumPxCiff", "lumPexAaf", "lumPexAuff", "lumPixBmp", "lumPixLoff", "lumPixFloff", "lumPixBaf", "lumPixLuff", "lumPixAaf", "lumPexBuff", "lumPixLaf", "lumPexBaf", "lumPixLuf", "lumPxCoff", "lumPixCuf", "lumPexAuf", "lumPixAuf", "lumPxCuff", "lumPixBoff", "lumPexAmp", "lumPixBuff", "lumPxBuf", "lumPixFluf", "lumPixFmp", "lumPxBoff", "lumPxCuf", "lumPixLiff", "lumPexBuf", "lumPixFuf", "lumPxBuff"], "chrPixBuf": ["chrPixAoff", "chrPixAaf", "chrPixLuf", "chrPxBuff", "chrPxAuff", "chrPixFoff", "chrPixBundle", "chrPixAuf", "chrPiusMundle", "chrPxAaf", "chrPiusMump", "chrPixFaf", "chrPxAuf", "chrPixBaf", "chrPixFuf", "chrPixLump", "chrPixAuff", "chrPixCuf", "chrPiusMab", "chrPiusMuf", "chrPxBoff", "chrPxAoff", "chrPixBab", "chrPixBuff", "chrPixPundle", "chrPixPump", "chrPixBump", "chrPixCuff", "chrPixPab", "chrPixPuf", "chrPiusBuf", "chrPiusBab", "chrPixMab", "chrPixLab", "chrPxBaf", "chrPixFuff", "chrPixMump", "chrPxBuf", "chrPixMuf", "chrPixBoff", "chrPixMundle", "chrPixCaf", "chrPiusBundle", "chrPixLundle", "chrPiusBump", "chrPixCoff"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union srp_iu *srp = &req->iu.srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n", "idx": 20026, "substitutes": {"s": ["g", "is", "cs", "server", "self", "sf", "sys", "f", "session", "http", "ops", "ps", "secondary", "u", "rs", "js", "t", "q", "sq", "d", "ns", "i", "state", "r", "o", "es", "conf", "gs", "c", "p", "sb", "ts", "service", "ks", "ssl", "b", "fs", "services", "S", "states", "sg", "ses", "e", "os", "sym", "spec", "ds", "v", "sync", "m"], "req": ["progress", "min", "rec", "client", "get", "proc", "jp", "sem", "cache", "xml", "Request", "off", "org", "exec", "tr", "war", "low", "require", "r", "rx", "qq", "call", "conf", "iq", "app", "cf", "c", "dq", "mr", "resp", "sec", "required", "wa", "arg", "rt", "dr", "ry", "http", "ro", "load", "res", " request", "reg", "rh", "quest", "ir", "tar", "dev", "user", "qa", "fr", "def", "desc", "err", "serv", "comp", "pri", "ver", "j", "f", "cmd", "q", "sq", "crit", "config", "input", "hr", "ctx", "next", "gr", "requ", "er", "cb", "query", "spec", "rw", "str", "resource", "rr", "worker", "cur", "release", "ra", "need", "grab", "ec", "w", "qt", "ext", "ref", "rf", "request", "seq", "e", "cmp", "pro", "ctr"], "srp": ["rrpr", "vrpi", "rtp", "drpr", "vrper", "drP", "irp", "rrpt", "yrpt", "src", "srper", "lerpc", "yrp", "sprf", "vrpt", "trpe", "lerf", "srpatch", "drp", "vrps", "srpe", "drpt", "srpc", "vrc", "yrpi", "yrpatch", "vrp", "drpc", "hrP", "rrpc", "trpt", "krP", "hrf", "irpr", "srP", "srpi", "srpt", "sprps", "rtpatch", "krpe", "crp", "hrper", "srps", "yrpe", "vrf", "vrpc", "crc", "lerp", "trpi", "rrp", "rtpc", "trp", "hrp", "irpt", "irpe", "rrpe", "crps", "rrpatch", "drpe", "crf", "sprc", "krp", "srpr", "hrpe", "krpc", "lerper", "vrpe", "rtpe", "sprp", "srf", "yrpc", "hrpc"], "sdev": ["sdi", "nsdev", "tsconn", "psdev", "setsval", "lsconn", "csdevice", "Sdev", "Svalid", "sDEV", "dsDev", " sev", "sev", "pdev", "nsconn", " sconn", "esdev", "sconn", "pdevice", "cdebug", "lsdevice", " sdevice", "dsev", "ssvalid", "cgu", "dsvalid", "csdebug", "ssdiv", "psdiv", "sgu", "lsdev", "tsdebug", "setsdev", "gsdiv", "sdem", "servicesdev", "psprof", "fdev", " spub", "esconn", "sdevice", "ssdev", " svalid", "psDev", "fdebug", "setsdiv", "servicesev", "gsdev", "southdem", "southprof", "SDev", "dsdev", "sval", "esdevice", "dsdiv", "psdef", "setsprof", "tsdevice", " sdebug", "setsvalid", "lsdebug", "gsval", "cdev", "servicescomp", "setsdem", "sDev", "cdiv", "physdevice", "srad", "gsvalid", "physdev", "tsdev", "SDEV", "svalid", "sdef", " sDEV", "nsdi", "esdebug", " scomp", "sprof", " srad", "Sdebug", " sdiv", "southdiv", "esdi", "southdev", "csconn", "fgu", "Sev", "ssval", "fdiv", "sdebug", "scomp", "Sdevice", "physdebug", "sdiv", " sdef", "nsdevice", "psdem", " sDev", "csdev", "ppub", " sgu", "dsdef", "spub", "physDEV", "servicesrad", " sdi"], "n": ["g", "sn", "not", "cn", "none", "f", "number", "name", "nc", "net", "x", "na", "in", "anon", "t", " len", "d", "no", "ns", "len", "i", "nn", "on", "max", "r", "o", "w", "nl", "N", "c", "k", "nt", "p", "pn", "adj", "y", "b", "z", "nat", "en", "ni", "nb", "ne", "nor", "count", "num", "un", "e", "fn", "l", "nw", "non", "a", "dn", "nu", "v", "ng", "an", "ln", "j", "m"], "id": ["bit", "sid", "f", "length", "du", "type", "x", "name", "ids", "in", "q", "ad", "end", "it", "uri", "d", "rid", "ip", "len", "i", "Id", "ID", "oid", "bid", "ident", "vid", "max", "code", "aid", "db", "dev", "data", "mid", "ref", "head", "p", "active", "key", "uid", "num", "kid", "url", "seq", "start", "pid", "bug", "size", "did", "md", "ide", "info"], "lun": ["dlune", "lul", " lnum", "luno", "lbun", "LUN", "llul", "lcun", "lluc", "slun", "Lun", "lbuna", " luc", "plunt", "lbUN", "dlunt", "cluno", "Lon", " luna", "lund", "dluc", "flnum", "clund", "dlUN", "olun", " lUN", "sluna", "elen", " lon", " lune", "elunt", "llun", " lul", "luna", "rlUN", "slund", "Lunt", "elun", "dlban", "lcunt", "lunt", "lcUN", "flun", "plun", " len", "slune", "klune", "olund", "pluna", "rluc", "klnum", "lcune", "lban", "lbunt", "plUN", "klun", "clun", "llUN", "llunt", "clune", "llune", "dlun", "kluna", "luc", "olune", "len", "lon", "oluno", "fluna", "flune", "Luna", " lban", "elban", "sluno", "lune", "Lul", "Lune", "lnum", "lUN", "rlune", "Luc", "slon", "rlun", " lunt", "dlen"]}}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "static int do_sendv_recvv(int sockfd, struct iovec *iov, int len, int offset,\n\n                          int do_sendv)\n\n{\n\n    int ret, diff, iovlen;\n\n    struct iovec *last_iov;\n\n\n\n    /* last_iov is inclusive, so count from one.  */\n\n    iovlen = 1;\n\n    last_iov = iov;\n\n    len += offset;\n\n\n\n    while (last_iov->iov_len < len) {\n\n        len -= last_iov->iov_len;\n\n\n\n        last_iov++;\n\n        iovlen++;\n\n    }\n\n\n\n    diff = last_iov->iov_len - len;\n\n    last_iov->iov_len -= diff;\n\n\n\n    while (iov->iov_len <= offset) {\n\n        offset -= iov->iov_len;\n\n\n\n        iov++;\n\n        iovlen--;\n\n    }\n\n\n\n    iov->iov_base = (char *) iov->iov_base + offset;\n\n    iov->iov_len -= offset;\n\n\n\n    {\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n        struct msghdr msg;\n\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_iov = iov;\n\n        msg.msg_iovlen = iovlen;\n\n\n\n        do {\n\n            if (do_sendv) {\n\n                ret = sendmsg(sockfd, &msg, 0);\n\n            } else {\n\n                ret = recvmsg(sockfd, &msg, 0);\n\n            }\n\n        } while (ret == -1 && errno == EINTR);\n\n#else\n\n        struct iovec *p = iov;\n\n        ret = 0;\n\n        while (iovlen > 0) {\n\n            int rc;\n\n            if (do_sendv) {\n\n                rc = send(sockfd, p->iov_base, p->iov_len, 0);\n\n            } else {\n\n                rc = qemu_recv(sockfd, p->iov_base, p->iov_len, 0);\n\n            }\n\n            if (rc == -1) {\n\n                if (errno == EINTR) {\n\n                    continue;\n\n                }\n\n                if (ret == 0) {\n\n                    ret = -1;\n\n                }\n\n                break;\n\n            }\n\n            if (rc == 0) {\n\n                break;\n\n            }\n\n            ret += rc;\n\n            iovlen--, p++;\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Undo the changes above */\n\n    iov->iov_base = (char *) iov->iov_base - offset;\n\n    iov->iov_len += offset;\n\n    last_iov->iov_len += diff;\n\n    return ret;\n\n}\n", "idx": 20032, "substitutes": {"sockfd": ["sockstream", "sportfeed", "sockFD", "sesockfd", "socksfeed", "sesocksfd", "slockdc", "sessstream", "sighfx", "svcFD", "splaydc", "sockdc", "sinkfd", "sesocksFD", "sinkfa", "sportfat", "socksfd", "sockfun", "opensockfd", "slockflo", "splayfat", " sockfile", "sipstream", "opensighfat", "sipfd", "socksfile", "svcfd", "fsockfd", "sipfile", " socksfile", "slockfx", "opensighfd", "sckfd", "sOCKfun", "sesockFD", "sesockfun", " socksfat", "sportfd", "fslockflo", "sessfeed", "sockfeed", "sOCKfa", "slockfa", "splayfd", "opensighfx", "sipfat", "opensockdc", "sOCKfd", "sesockshandle", "sockfx", "socksFD", "sessfd", "sinkfun", "sighdc", "opensockfat", "sockfat", "slockfd", "slockfun", "svchandle", " sockfeed", "sportstream", "opensighdc", "slockfat", "fslockfun", "sockhandle", "fslockfa", "fslockfd", "opensockfx", "sighfat", "sighfd", "sinkflo", "fsockfun", "fsockfa", "sOCKflo", "splayfx", "sockfile", "sesockhandle", "socksfun", "socksfat", "sckhandle", "sckfun", " socksfd", "sockshandle", "sckFD", "sockflo", "fsockflo", "sessfat", " socksfeed", "sessfile", "svcfun", " sockfat", "sockfa", "sesocksfun", "sipfeed"], "iov": ["inet", "gru", "software", "drm", "oji", "pai", "syn", "obo", "uni", "photo", "oyer", "iq", "mos", "oren", "voc", "orman", "club", "gener", "oir", "iol", "yout", "anon", "ir", "hw", "respond", "lov", "four", "oc", "iris", "wav", "colo", "mn", "iro", "gmail", "dyl", "norm", "io", "mun", "username", "ilo", "iop", "mpeg", "\u00ef", "micro", "fm", "yo", "conv", "nox", "hub", "icho", "kov", "iv", "rss", "uno", "uu", "anim", "ibl", "voice", "vre", "omnia", "nov", "wikipedia", "mom", "userc", "imedia", "ov", "chrom", "ilib", "mx", "mu", "music", "mus", "ij", "iam", "liv", "loc", "vg", "rf", "ilan", "lore", "rolet", "soc", "inn", "anova"], "len": ["ann", "lim", "val", "vec", "min", "coll", "f", "length", "lan", "split", "ll", "lt", "net", "Len", "alt", "lp", "li", "den", "ol", "el", "lf", "syn", "base", "fun", "n", "low", "lon", "lib", "lu", "fin", "il", "dl", "lc", "fl", "pre", "loc", "line", "limit", "pos", "unit", "le", "en", "lif", "count", "num", "non", "seq", "l", "lin", "part", "ln", "size"], "offset": ["set", "split", "range", "et", "off", "end", "lf", "low", "online", "padding", "limit", "null", "attr", "origin", "layer", "alpha", "af", "enabled", "fee", "col", "location", "i", "reset", "index", "addr", "fp", "num", "l", "length", "aff", "error", "phase", "base", "ip", "o", "Offset", "format", "pos", "delay", "dist", "area", "adjust", "info", "initial", "shift", "alt", "prefix", "ol", "lon", "ff", "disabled", "align", "loc", "ref", "seq", "cmp", "start", "part", "bound", "size"], "do_sendv": ["do_sendiv", "do_sentiv", "do__setb", "do_recb", "do_recf", "do_recu", "do_reciv", "do_sentu", "do_endf", "do_sentf", "do_recp", "do_useev", "do_sentv", "do_useb", "do_sentev", "do_usev", "do_setf", "do__sendf", "do_sentb", "do_enp", "do_endv", "do_sendvs", "do_recv", "do_enf", "do_sendev", "do__sendb", "do_setvs", "do__setv", "do_sendp", "do_sentvs", "do_enu", "do_setv", "do_endvs", "do_useiv", "do_recev", "do_setb", "do_endb", "do__sendv", "do__setvs", "do__sendvs", "do_sendb", "do_sendf", "do_sentp", "do_sendu", "do_env", "do__setf"], "ret": ["reply", "val", "RET", "rr", "f", "cat", "pt", "get", "result", "match", "lt", "bc", "alt", "cur", "res", "success", "repl", "error", "reg", "valid", "rel", "req", "back", "fun", "mt", "rep", "id", "fin", "pet", "status", "code", "r", "data", "rev", "pat", "rets", "iter", "att", "gen", "ref", "det", "nt", "bot", "post", "gt", "rl", "rf", "def", "resp", "re", "err", "ft", "count", "num", "Ret", "mem", "bf", "cb", "opt", "fi", "lit", "arg", "rot", "rt", "art", "ver"], "diff": ["progress", "none", "f", "length", "result", "split", "extra", "changed", "range", "alt", "del", "eff", "error", "req", "rel", "lf", "d", "add", "fail", "fun", "low", "different", "col", "version", "dev", "ff", "found", "qa", "change", "dir", "iff", "rev", "frac", "lc", "conf", "ref", "pos", "unit", "missing", "Diff", "def", "dist", "comment", "done", "err", "update", " difference", "cmp", "fe", "part", "comp", "field", "info"], "iovlen": ["ilolan", "musicln", "lovln", "livln", "ilolin", "chromen", "ilolc", "mulen", "ilolimit", "ovcount", "iovbase", "novlan", "novlen", "musen", "roletlimit", "chromcount", "orenlan", "iliblc", "musln", "voiceln", "livbase", "voiceen", "ilofat", "chromlimit", "mulim", "musiclen", "ilibfat", "loven", "novline", "lovline", "muslen", "orenlen", "wavlen", "noven", "iovdata", "iovelt", "liven", "lovlen", "iovln", "iovfat", "lovcount", "voicelen", "muelt", "drmden", "drmlength", "ioven", "wavlength", "mudata", "iovline", "wavden", "iovlin", "iovlimit", "voicebase", "oven", "roletlin", "ilodata", "iovcount", "orenen", "iovlc", "ilolim", "ovln", "ilolen", "iovlength", "iovlim", "chromlc", "musiclength", "wavln", "iloelt", "chromlan", "chromlin", "iloln", "iovlan", "chromln", "chromlen", "ilibln", "musicden", "iovden", "roletlan", "ovlen", "drmlen", "lovlan", "iliblen", "orenline", "musbase", "drmln", "livlen", "chromfat", "roletlen"], "last_iov": [" last_imedia", "last_ilib", "last__iov", " last_iro", "lastPiov", "lastPkov", " last_soc", " last_nikov", "last_rolet", " last_rolet", " last_iol", "last_nox", "lastJiov", "lastWilib", "last__iop", " last_mus", " last_kov", "last_imedia", " last_voice", "last_mus", "last_soc", "last__iro", "lastPiop", "lastJsoc", " last_ilo", "lastWiop", "last__ilo", "lastWkov", " last_ilib", "last_nikov", "lastPilib", "last_ilo", "last_voice", " last_nox", "last_iop", "last_kov", "lastWiov", "last_iol", "last_iro", " last_iop", "lastJrolet", "lastJilo"], "msg": ["g", "reply", "client", "ms", "sent", "node", "mail", "pub", "mid", "block", "comm", "gs", "gen", "game", "live", "resp", "cfg", "send", "arg", "m", "wave", "dr", "gm", "cm", "op", "buf", "req", "ages", "message", "data", "gram", "irm", "def", "pkg", "mn", "num", "og", "mp", "mon", "cmd", "mit", "ge", "hub", "bm", "module", "db", "init", "input", "mess", "ag", "sim", "sg", "mom", "go", "info", "dm", "mu", "mt", "enc", "Msg", "mo", "pack", "doc", "stat", "mor", "loc", "seq", "mem", "text", "debug", "v"], "p": ["g", "cp", "f", "ap", "pt", "pc", "proc", "ps", "tp", "wp", "jp", "u", "op", "parent", "po", "lp", "t", "param", "api", "it", "py", "np", "pai", "n", "bp", "ip", "pi", "i", "pg", "pl", "pp", "pa", "pb", "h", "r", "pat", "pse", "par", "pre", "att", "c", "P", "pn", "post", "fp", "pos", "ref", "pe", "hp", "b", "prov", "pkg", "up", "re", "per", "gp", "e", "l", "port", "pro", "part", "comp", "pr", "j", "m"], "rc": ["reply", "ru", "rec", "ror", "dc", "rr", "src", "result", "pc", "ck", "ry", "uc", "inc", "bc", "nc", "ac", "cur", "error", "back", "rh", "cor", "bb", "reg", "sr", "fc", "irc", "code", "co", "r", "wx", "rx", "hl", "rev", "lc", "loc", "rb", "RC", "c", "cc", "rl", "roc", "abc", "cr", "rg", "auc", "err", "num", "cb", "cmp", "rn", "bug", "ok", "ack", "sc", "rt"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp9_decode_frame(AVCodecContext *ctx, void *frame,\n\n                            int *got_frame, AVPacket *pkt)\n\n{\n\n    const uint8_t *data = pkt->data;\n\n    int size = pkt->size;\n\n    VP9Context *s = ctx->priv_data;\n\n    int res, tile_row, tile_col, i, ref, row, col;\n\n    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&\n\n                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);\n\n    ptrdiff_t yoff, uvoff, ls_y, ls_uv;\n\n    AVFrame *f;\n\n    int bytesperpixel;\n\n\n\n    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {\n\n        return res;\n\n    } else if (res == 0) {\n\n        if (!s->s.refs[ref].f->buf[0]) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Requested reference %d not available\\n\", ref);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)\n\n            return res;\n\n        ((AVFrame *)frame)->pts = pkt->pts;\n\n#if FF_API_PKT_PTS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        ((AVFrame *)frame)->pkt_pts = pkt->pts;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n        ((AVFrame *)frame)->pkt_dts = pkt->dts;\n\n        for (i = 0; i < 8; i++) {\n\n            if (s->next_refs[i].f->buf[0])\n\n                ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n            if (s->s.refs[i].f->buf[0] &&\n\n                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)\n\n                return res;\n\n        }\n\n        *got_frame = 1;\n\n        return pkt->size;\n\n    }\n\n    data += res;\n\n    size -= res;\n\n\n\n    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {\n\n        if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0])\n\n            vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n            (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)\n\n            return res;\n\n    }\n\n    if (s->s.frames[REF_FRAME_MVPAIR].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR]);\n\n    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n        (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    if (s->s.frames[CUR_FRAME].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[CUR_FRAME]);\n\n    if ((res = vp9_alloc_frame(ctx, &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    f = s->s.frames[CUR_FRAME].tf.f;\n\n    f->key_frame = s->s.h.keyframe;\n\n    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    ls_y = f->linesize[0];\n\n    ls_uv =f->linesize[1];\n\n\n\n    if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0] &&\n\n        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||\n\n         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n    }\n\n\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->next_refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n        if (s->s.h.refreshrefmask & (1 << i)) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);\n\n        } else if (s->s.refs[i].f->buf[0]) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);\n\n        }\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (ctx->hwaccel) {\n\n        res = ctx->hwaccel->start_frame(ctx, NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->decode_slice(ctx, pkt->data, pkt->size);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->end_frame(ctx);\n\n        if (res < 0)\n\n            return res;\n\n        goto finish;\n\n    }\n\n\n\n    // main tile decode loop\n\n    bytesperpixel = s->bytesperpixel;\n\n    memset(s->above_partition_ctx, 0, s->cols);\n\n    memset(s->above_skip_ctx, 0, s->cols);\n\n    if (s->s.h.keyframe || s->s.h.intraonly) {\n\n        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n\n    } else {\n\n        memset(s->above_mode_ctx, NEARESTMV, s->cols);\n\n    }\n\n    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n\n    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_segpred_ctx, 0, s->cols);\n\n    s->pass = s->s.frames[CUR_FRAME].uses_2pass =\n\n        ctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;\n\n    if ((res = update_block_buffers(ctx)) < 0) {\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Failed to allocate block buffers\\n\");\n\n        return res;\n\n    }\n\n    if (s->s.h.refreshctx && s->s.h.parallelmode) {\n\n        int j, k, l, m;\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            for (j = 0; j < 2; j++)\n\n                for (k = 0; k < 2; k++)\n\n                    for (l = 0; l < 6; l++)\n\n                        for (m = 0; m < 6; m++)\n\n                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n\n                                   s->prob.coef[i][j][k][l][m], 3);\n\n            if (s->s.h.txfmmode == i)\n\n                break;\n\n        }\n\n        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;\n\n        ff_thread_finish_setup(ctx);\n\n    } else if (!s->s.h.refreshctx) {\n\n        ff_thread_finish_setup(ctx);\n\n    }\n\n\n\n    do {\n\n        yoff = uvoff = 0;\n\n        s->b = s->b_base;\n\n        s->block = s->block_base;\n\n        s->uvblock[0] = s->uvblock_base[0];\n\n        s->uvblock[1] = s->uvblock_base[1];\n\n        s->eob = s->eob_base;\n\n        s->uveob[0] = s->uveob_base[0];\n\n        s->uveob[1] = s->uveob_base[1];\n\n\n\n        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {\n\n            set_tile_offset(&s->tile_row_start, &s->tile_row_end,\n\n                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);\n\n            if (s->pass != 2) {\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    int64_t tile_size;\n\n\n\n                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&\n\n                        tile_row == s->s.h.tiling.tile_rows - 1) {\n\n                        tile_size = size;\n\n                    } else {\n\n                        tile_size = AV_RB32(data);\n\n                        data += 4;\n\n                        size -= 4;\n\n                    }\n\n                    if (tile_size > size) {\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n\n                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    data += tile_size;\n\n                    size -= tile_size;\n\n                }\n\n            }\n\n\n\n            for (row = s->tile_row_start; row < s->tile_row_end;\n\n                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {\n\n                struct VP9Filter *lflvl_ptr = s->lflvl;\n\n                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;\n\n\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,\n\n                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);\n\n\n\n                    if (s->pass != 2) {\n\n                        memset(s->left_partition_ctx, 0, 8);\n\n                        memset(s->left_skip_ctx, 0, 8);\n\n                        if (s->s.h.keyframe || s->s.h.intraonly) {\n\n                            memset(s->left_mode_ctx, DC_PRED, 16);\n\n                        } else {\n\n                            memset(s->left_mode_ctx, NEARESTMV, 8);\n\n                        }\n\n                        memset(s->left_y_nnz_ctx, 0, 16);\n\n                        memset(s->left_uv_nnz_ctx, 0, 32);\n\n                        memset(s->left_segpred_ctx, 0, 8);\n\n\n\n                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n\n                    }\n\n\n\n                    for (col = s->tile_col_start;\n\n                         col < s->tile_col_end;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        // FIXME integrate with lf code (i.e. zero after each\n\n                        // use, similar to invtxfm coefficients, or similar)\n\n                        if (s->pass != 1) {\n\n                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));\n\n                        }\n\n\n\n                        if (s->pass == 2) {\n\n                            decode_sb_mem(ctx, row, col, lflvl_ptr,\n\n                                          yoff2, uvoff2, BL_64X64);\n\n                        } else {\n\n                            decode_sb(ctx, row, col, lflvl_ptr,\n\n                                      yoff2, uvoff2, BL_64X64);\n\n                        }\n\n                    }\n\n                    if (s->pass != 2) {\n\n                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n\n                    }\n\n                }\n\n\n\n                if (s->pass == 1) {\n\n                    continue;\n\n                }\n\n\n\n                // backup pre-loopfilter reconstruction data for intra\n\n                // prediction of next row of sb64s\n\n                if (row + 8 < s->rows) {\n\n                    memcpy(s->intra_pred_data[0],\n\n                           f->data[0] + yoff + 63 * ls_y,\n\n                           8 * s->cols * bytesperpixel);\n\n                    memcpy(s->intra_pred_data[1],\n\n                           f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                    memcpy(s->intra_pred_data[2],\n\n                           f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                }\n\n\n\n                // loopfilter one row\n\n                if (s->s.h.filter.level) {\n\n                    yoff2 = yoff;\n\n                    uvoff2 = uvoff;\n\n                    lflvl_ptr = s->lflvl;\n\n                    for (col = 0; col < s->cols;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n\n                    }\n\n                }\n\n\n\n                // FIXME maybe we can make this more finegrained by running the\n\n                // loopfilter per-block instead of after each sbrow\n\n                // In fact that would also make intra pred left preparation easier?\n\n                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);\n\n            }\n\n        }\n\n\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n\n            adapt_probs(s);\n\n            ff_thread_finish_setup(ctx);\n\n        }\n\n    } while (s->pass++ == 1);\n\n    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n\n\nfinish:\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->s.refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->s.refs[i]);\n\n        if (s->next_refs[i].f->buf[0] &&\n\n            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)\n\n            return res;\n\n    }\n\n\n\n    if (!s->s.h.invisible) {\n\n        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n\n            return res;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    return pkt->size;\n\n}\n", "idx": 20035, "substitutes": {"ctx": ["cca", "cs", "cp", "cm", "client", "component", "pc", "ck", "cli", "jp", "cmd", "bc", "nc", "ci", "gc", "linux", "conn", "sq", "window", "scope", "connection", "conv", "cms", "hw", "config", "cpp", "cl", "cas", "kt", "lc", "mac", "loc", "ca", "cf", "c", "cam", "cv", "sci", "cc", "ks", "kw", "tx", "pkg", "Context", "cfg", "context", "wcs", "rc", "cb", "mc", "cmp", "anc", "cu", "xc", "kb", "sc", "ds", "sync"], "frame": ["frames", "pse", "figure", "hole", "range", "node", "Frame", "feat", "flower", "document", "window", "flow", "buffer", "point", "d", "framework", "video", "view", "position", "state", "za", "code", "dom", "fr", "draw", "fram", "block", "ze", "feature", "dy", "call", "ace", "kt", "body", "time", "c", "file", "p", "cf", "ce", "game", "object", "function", "b", "slice", "image", "element", "fi", "e", "fe", "fc", "part", "rame", "setup", "fb", "iframe"], "got_frame": ["got2frames", " got\n", "seenbuffer", "got_frames", "got_fram", "getbuffer", "get\n", "gotbuffer", "get_data", "gotjframe", "got2data", "get_frames", "got_data", "seen\n", "got2frame", "get_frame", "got\n", "got2fram", " gotbuffer", "gotjfram", "gotjframes", "get_fram", "gotjdata"], "pkt": ["pKT", "pwk", "packet", "bct", "biece", "bnt", "beth", "pki", " packet", " piece", "bet", "Pkt", "spki", "fct", "Pkg", "Pet", "cpct", "tacket", "pct", "bkt", "peth", "pet", "tkt", "fkt", "Packet", "fnt", "facket", "pnt", " pct", "bwk", "cpkt", "PKT", " pkg", "Peth", " pet", " pnt", "tki", "spacket", " peth", "pkg", "cpacket", " pki", "spkg", " pKT", "cpKT", "spkt", "Piece", "Pwk", "Pki", "tet", "Pct", "backet", " pwk", "piece"], "data": ["sample", "batch", "val", "results", "rec", "length", "result", "queue", "cache", "buf", "media", "DATA", "dd", "load", "window", "buffer", "d", "connection", "board", "feed", "info", "len", "Data", "message", "base", "record", "module", "memory", "input", "draw", "block", "raw", "reader", "binary", "next", "body", "object", "p", "response", "da", "content", "slice", "image", "bytes", "e", "dat", "start", "ata", "a", "empty", "device", "buff", "size"], "s": ["g", "self", "session", "bs", "secondary", "js", "sh", "auth", "h", "r", "comm", "gs", "conf", "c", "ssl", "b", "sl", "su", "z", "fs", "context", "states", "sets", "utils", "a", "ins", "qs", "http", "u", "ns", "site", "si", "args", "tests", "es", "us", "sk", "p", "sb", "ks", "ts", "y", "services", "sym", "hm", "sync", "ops", "this", "rs", "ss", "sq", "n", "vs", "o", "xs", "sup", "S", "bis", "sg", "ses", "hs", "spec", "info", "ssh", "is", "cs", "sys", "ps", "t", "parts", "d", "path", "ls", "w", "service", "e", "os", "sc", "ds", "v", "settings"], "res": ["val", "cs", "results", "pres", "vec", "changes", "css", "ms", "resolution", "bs", "result", "ps", "rest", "ids", "cache", "rs", "nos", "rus", "js", "values", "breaks", "req", "vals", "rel", "reg", "rh", "reed", "obj", "args", "RES", "has", "reset", "ros", "Res", "rem", "des", "rss", "rev", "errors", "runs", "gr", "details", "resh", "response", " results", "ris", "sol", "mr", "def", "resp", "re", "ress", "err", "msg", "rc", "fields", "ret", "os", "arr", "features", "ras", "rep", "ver", "rates"], "tile_row": ["tile32col", " tile32rows", "tile32row", "tile32rows", " tile32loc", " tile_rows", " tile32col", "tile32loc", "tile_loc", " tile32row", "tile_rows", " tile_loc"], "tile_col": ["ls2column", "ls2loc", "ls_pos", "tile1col", "tile1pos", "tile2column", "ls_col", "tile_loc", "ls_loc", "tile2loc", "tile1column", "ls2col", "tile_pos", "tile2pos", "ls2pos", "tile2col", "tile_column", "tile1loc", "ls_column"], "i": ["g", "phi", "di", "inner", "my", "ri", "xi", "hi", "range", "qi", "ix", "x", "ci", "eni", "I", "r", "block", "c", "b", "gi", "a", "oi", "ini", "field", "mi", "u", "in", "uri", "it", "si", "multi", "index", "ai", "full", "iu", "p", "key", "y", "ki", "ui", "fi", "yi", "io", "ti", "q", "ji", "ip", "id", "init", "iv", "o", "ii", "pos", "ni", "zi", "info", "type", "li", "mu", "bi", "d", "pi", "jit", "slice", "e", "start", "ori", "reference", "ie", "part", "v"], "ref": ["val", "rec", " reference", "aff", "range", "cache", "alt", "el", "req", "reg", "rel", "lf", "buffer", "len", "rib", "obj", "base", "id", "REF", "offset", "cl", "ob", "label", "index", "r", "img", "fr", "diff", "ef", "rev", "loc", "conf", "pre", "c", "inf", "pos", "p", "rf", "b", "def", "resp", "re", "pointer", "reb", "count", "rc", "url", "bf", "ab", "href", "reference", "remote", "part", "Ref", "rep", " Ref", "br"], "row": ["family", "coll", "ry", "src", "range", "ro", "mod", "rel", "feed", "pg", "Row", "r", "index", "entry", "raw", "block", "w", "pos", "key", "rc", "num", "port", "rows", "rw", "ver"], "col": ["val", "cp", "coll", "cat", "Col", "temp", "el", "rel", "len", "ch", "column", "cl", "index", "cell", "loc", "fl", "c", "p", "pos", "count", "num", "seq", "COL", "part", "offset"], "yoff": ["yoffset", "yoffs", "zoffset", "xoffs", "noffset", "noffs", "zoffs", "noff", "zoff", "xoffset", "xoff"], "uvoff": ["cvw", "svoff", "svoffs", "uvw", "cvoffs", "uzw", "uvoffs", "uzoff", "uzoffs", "svw", "cvoff"], "ls_y": ["ls_vy", "vs_y", "ls_py", "vs_py", "vs_vy", "vs_ii", "ls_ii"], "ls_uv": ["ls_vr", "vs_v", "vs_cv", "ls_v", "ls_cv", "vs_vr", "vs_uv"], "f": ["g", "fx", "sf", "df", "uf", "t", "q", "form", "d", "lf", "fo", "info", "fm", "fd", "fw", "ff", "h", "r", "fr", "fen", "o", "full", "w", "cf", "c", "F", "p", "fp", "inf", "rf", "b", "fa", "z", "fs", "elf", "fn", "e", "of", "fe", "fc", "v", "fb"], "bytesperpixel": ["bytesperbyte", "bytesPerrow", "bytesPerbyte", "bitsperbyte", "bytesbyrow", "bitsPerbyte", "bitsPerpixel", "bytesPERpixel", "bytesbypixel", "bytespercpu", "bytesPerpixel", "bytesPERbyte", "bytesbybyte", "bytesbycpu", "bytesPERrow", "bitsperrow", "bitspercpu", "bitsPercpu", "bitsPerrow", "bytesPercpu", "bytesperrow", "bytesPERcpu", "bitsperpixel"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t gt64120_readl (void *opaque,\n\n                               target_phys_addr_t addr, unsigned size)\n\n{\n\n    GT64120State *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    uint32_t val;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfff) >> 2;\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_MULTI:\n\n        /* Only one GT64xxx is present on the CPU bus, return\n\n           the initial value */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n        /* Reading those register should empty all FIFO on the PCI\n\n           bus, which are not emulated. The return value should be\n\n           a random value that should be ignored. */\n\n        val = 0xc000ffee;\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    case GT_CPU:\n\n    case GT_SCS10LD:\n\n    case GT_SCS10HD:\n\n    case GT_SCS32LD:\n\n    case GT_SCS32HD:\n\n    case GT_CS20LD:\n\n    case GT_CS20HD:\n\n    case GT_CS3BOOTLD:\n\n    case GT_CS3BOOTHD:\n\n    case GT_SCS10AR:\n\n    case GT_SCS32AR:\n\n    case GT_CS20R:\n\n    case GT_CS3BOOTR:\n\n    case GT_PCI0IOLD:\n\n    case GT_PCI0M0LD:\n\n    case GT_PCI0M1LD:\n\n    case GT_PCI1IOLD:\n\n    case GT_PCI1M0LD:\n\n    case GT_PCI1M1LD:\n\n    case GT_PCI0IOHD:\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n    case GT_ISD:\n\n        val = s->regs[saddr];\n\n        break;\n\n    case GT_PCI0_IACK:\n\n        /* Read the IRQ number */\n\n        val = pic_read_irq(isa_pic);\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Just return the last written value. */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CFGADDR:\n\n        val = phb->config_reg;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (!(phb->config_reg & (1 << 31))) {\n\n            val = 0xffffffff;\n\n        } else {\n\n            val = pci_data_read(phb->bus, phb->config_reg, 4);\n\n        }\n\n        if (!(s->regs[GT_PCI0_CMD] & 1) && (phb->config_reg & 0x00fff800)) {\n\n            val = bswap32(val);\n\n        }\n\n        break;\n\n\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_CMD:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    if (!(s->regs[GT_CPU] & 0x00001000))\n\n        val = bswap32(val);\n\n\n\n    return val;\n\n}\n", "idx": 20054, "substitutes": {"opaque": [" opchid", "OPace", "OPaque", "Opa", "opaques", "OPchid", "opace", "opchid", "ipac", "Opace", "Opac", "OPac", "OPaques", "opusaques", "opa", "Opaque", "ipace", "opuschid", " opaques", "opusaque", "ipaque", "OPa", "opac", "ipa"], "addr": ["dr", "str", "sid", "src", "node", "asm", "pad", "ad", "conn", "reg", "len", "base", "config", "db", "address", "index", "ord", "adr", "data", "byte", "ace", "ext", "side", "slot", "ref", "channel", "pos", "nr", "pointer", "ptr", "sta", "url", "seq", "alias", "arr", "rt", "part", "md", "oa", "host", "offset"], "size": ["length", " len", "Size", "len", "SIZE", "ize", "address", "data", " Size", " sizes", " bytes", "bytes", " length", " data"], "s": ["ssh", "is", "server", "sites", "sf", "f", "session", "sa", "sys", "aws", "ds", "south", "t", "single", "sq", "ss", "scope", "d", "ns", "n", "site", "si", "i", "storage", "o", "w", "gs", "side", "c", "p", "sb", "service", "sie", "ssl", "b", "sl", "socket", "fs", "services", "su", "stats", "S", "slice", "bis", "states", "sg", "e", "ses", "os", "sv", "sym", "sets", "serv", "spec", "v", "sync", "m"], "phb": ["phbs", "phB", " phB", "thB", "ppbs", " pha", "tha", "ppa", "ppB", "ppb", "thbs", "pha", "thb", " phbs"], "val": ["ann", "grad", "VAL", "pt", "cal", "split", "aval", "x", "alt", "ol", "el", "vals", "valid", "rel", "fail", "len", "base", "util", "col", "il", "data", " aval", "byte", "ival", "loc", "all", "Val", "slot", "ref", "al", "pos", "rl", "ind", "cond", "b", "eval", "sl", "def", "value", "sel", "ct", "num", "ret", "serv", "arg", "lit", "rot", "rol", "v", "bl"], "saddr": ["Srm", "Ssrc", " srm", "ssrc", "siteaddr", "sinaddress", "Sdr", "sadd", "sysaddr", "srm", "syshost", " sdr", "sinadr", "sysdr", "sitehost", "sysptr", "sdr", "taddr", "taddress", "sysrm", " sptr", "tdb", "sord", "sdb", "sysdb", "faddress", "siteaddress", "Sattr", "Sadd", " sord", "sitesrc", "secondarydr", "saddress", "syslayer", "slayer", "Sord", "secondaryaddress", "Saddr", "sysadr", " saddress", "sptr", "secondaryptr", " sadd", "Shost", " shost", "sindb", " ssrc", "sadr", " slayer", "sysaddress", "Slayer", "Saddress", "siteattr", "sysord", "faddr", "shost", "secondaryaddr", "sattr", "tadr", "fattr", "sinaddr", "siteadd", "fhost", " sattr"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    opt = qemu_opt_find(opts, name);\n\n    if (!opt) {\n\n        QemuOptDesc *desc = opts->list->desc;\n\n        int i;\n\n\n\n        for (i = 0; desc[i].name != NULL; i++) {\n\n            if (strcmp(desc[i].name, name) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc[i].name == NULL) {\n\n            if (i == 0) {\n\n                /* empty list -> allow any */;\n\n            } else {\n\n                fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\",\n\n                        name, opts->list->name);\n\n                return -1;\n\n            }\n\n        }\n\n        opt = qemu_mallocz(sizeof(*opt));\n\n        opt->name = qemu_strdup(name);\n\n        opt->opts = opts;\n\n        TAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n        if (desc[i].name != NULL) {\n\n            opt->desc = desc+i;\n\n        }\n\n    }\n\n    qemu_free((/* !const */ char*)opt->str);\n\n    opt->str = NULL;\n\n    if (value) {\n\n        opt->str = qemu_strdup(value);\n\n    }\n\n    if (qemu_opt_parse(opt) < 0) {\n\n        fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str,\n\n                opts->list->name, opt->name);\n\n        qemu_opt_del(opt);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20070, "substitutes": {"opts": ["obts", "optcs", " oputs", "optps", "OPts", "OPfs", "roplets", "omters", "operTS", "opcs", "opTS", "omps", "otjs", "hopds", "oputs", "catters", "operls", "okts", "optts", "depths", "operts", "depts", "otters", "catcs", "opters", "catks", " oplets", "obters", "ropments", "okments", "opds", "operments", "OPuts", "optd", "opjs", "obls", "okuts", "opttd", "oplets", " opps", "opths", " opks", " opfs", "operfs", "catts", "otts", "roputs", "opments", "opfs", "opks", "omts", "operuts", "dept", "operks", "hopts", "opps", "operds", "deputs", "OPths", " opTS", " opters", "otds", "omtd", "hopments", "otTS", " opments", "hopfs", "opls", " optd", "otments", "OPters", "otls", "ropts", "OPls", "hopjs", "hopks", "operters", "optters", "oklets", "OPt", "otks", "otcs", "optks", " opths", "operjs", "hopls", "otuts", "obfs"], "name": ["val", "min", "none", "ame", "sp", "extra", "x", "na", "end", "description", "label", "code", "block", "call", "null", "search", "comment", "image", "dot", "attr", "a", "arg", "field", "source", "no", "one", "full", "data", "var", "key", "missing", "group", "num", "filename", "alias", "list", "NAME", "old", "n", "base", "version", "id", "address", "nice", "named", "names", "custom", "spec", "info", "str", "resource", "initial", "option", "type", "new", "prefix", "parent", "conn", "common", "word", "path", "doc", "w", "all", "time", "nam", "Name", "e", "start", "nm", "part", "size"], "value": ["val", "set", "VALUE", "str", "json", "none", "option", "number", "range", "type", "new", "values", "alt", "source", "prefix", "parent", "end", "description", "valid", "property", "message", "version", "r", "change", "iv", "data", "w", "anything", "format", "object", "key", "unit", "content", "function", "comment", "field", "term", "other", "text", "list", "Value", "v", "size"], "opt": ["val", "skip", "proc", "xml", "eff", "off", "OP", "end", "ort", "tr", "comb", "or", "pl", "h", "oper", "call", "c", "close", "al", "sl", "z", "update", "vert", "prop", "cho", "oo", "attr", "ok", "open", "arg", "optim", "op", "temp", "it", "fo", "no", "py", "max", "usr", "oc", "nt", "p", "object", "inf", "def", "err", "num", "term", "serv", "pot", "out", "ver", "json", "f", "cat", "cmd", "lt", "orig", "error", "prev", "n", "id", "init", "ord", "o", "ott", "next", "iter", "post", "pos", "oss", "neg", "step", "fn", "ret", "options", "go", "info", "str", "txt", "option", "type", "alt", "parent", "conn", "root", "obj", "word", "aut", "path", "hop", "loc", "ext", "loop", "tmp", "tx", "dest", "expr", "text", "Opt", "v"], "desc": ["section", "disc", "str", "progress", "rec", "dc", "src", "uc", "contract", "conn", "req", "exec", "description", "asc", "prev", "toc", "enc", "config", "Desc", "id", "path", "des", "code", "dir", "doc", "data", "diff", "entry", "sort", "ec", "meta", "help", "next", "loc", "ext", "cont", "c", "decl", "sup", "resp", "def", "dist", "esc", "comment", "neg", "dep", "acc", "rc", "sec", "dest", "seq", "text", "sub", "anc", "sc", "pri", "info"], "i": ["val", "phi", "di", "f", "ri", "xi", "hi", "x", "qi", "u", "ix", "ci", "li", "in", "q", "ji", "bi", "eni", "uri", "mu", "d", "mi", "it", "n", "ip", "I", "pi", "si", "multi", "id", "h", "index", "code", "ai", "chi", "iu", "data", "o", "ii", "iq", "k", "c", "p", "s", "key", "y", "ind", "b", "z", "slice", "ui", "ni", "zi", "gi", "count", "fi", "e", "ori", "l", "start", "a", "io", "oi", "ie", "ini", "v", "ti", "j"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n", "idx": 20086, "substitutes": {"dev": ["development", "server", "di", "self", "debug", "DEV", "prom", "grad", "client", "dc", "mod", " Dev", "dd", "conn", "error", "req", "d", "ch", "hw", "config", "der", "dom", "data", "diff", "Dev", "block", "w", "conf", "sk", "app", "de", "var", "cam", "gu", "def", "ve", "dem", "comment", "dot", "ev", "driver", "bug", "device", "v", "spec", "serial", "md", "adv", "ver", "info"], "s": ["g", "self", "client", "session", "sp", "js", "sh", "h", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "stats", "sec", "sets", "a", "qs", "m", "server", "sf", "http", "u", "ns", "site", "si", "args", "i", "tests", "state", "your", "full", "params", "an", "sk", "p", "sb", "ts", "y", "ks", "current", "services", "l", "sym", "serv", "se", "sync", "j", "f", "ops", "less", "rs", "south", "ss", "sq", "n", "sd", "o", "xs", "sup", "sim", "S", "sg", "ses", "hs", "spec", "is", "cs", "sys", "aws", "ps", "new", "t", "d", "storage", "ls", "service", "request", "e", "os", "ds", "v"], "err": ["g", "dr", "str", "rr", "sys", "good", "better", "result", "inc", "Er", "yr", "cer", "rs", "res", "kr", "error", "req", "rh", "lr", "sr", "ir", "aster", "fee", "rar", "ch", "eor", "finder", "magic", "fg", "ar", "r", "rag", "der", "fr", "doc", "errors", "gr", "conf", "ref", "var", "mr", "ind", "nr", "cr", "resp", "er", "m", "msg", "Error", "cb", "rage", "rc", "e", "erer", "fy", "ler", "acer", "bug", "arr", "ah", "order", "ln", "pr", "br"]}}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20095, "substitutes": {"ehci": ["evdi", "herci", "ehlc", "khcu", "hca", "hlc", "khcit", "echsci", "ekcci", "ethci", "ohlc", "eccu", "hci", "ecco", "ehki", "hcu", "ohcu", "echco", "eksci", "ethlc", "evci", "ahcu", "hcci", "eclc", "ahcin", "ethcu", "echcin", "ahco", "ohc", "hercu", "eccci", "ahci", "eklc", "ehcu", "ethsci", "herdi", "khca", "ohci", "herco", "ohcci", "evcci", "khci", "hesscci", "ohdi", "ahc", "echci", "khcci", "ehca", "ahcci", "khc", "ehdi", "hesski", "evcu", "ehcin", "ohco", "ehsci", "ehcci", "ahsci", "ecsci", "ahcit", "eccin", "hc", "hessc", "ekci", "ohca", "khsci", "ahlc", "ehc", "ohcit", "ehco", "echcu", "khlc", "ecci", "hessci", "ehcit", "ahki", "khki", "echcci", "ahdi"], "frames": ["links", "lines", "interface", "tracks", "videos", "frame", "flows", "values", "cells", "images", "inches", "plugins", "blocks", "bits", "codes", "quarters", "classes", "files", "tones", "series", "stars", "pages", "points", "objects", "states", "fps", "steps", "planes", "seconds", "rows", "cycles", "features", "events", "Frames", "faces"], "i": ["phi", "di", "interface", "inner", "f", "ri", "xi", "cli", "hi", "qi", "u", "ci", "li", "abi", "eni", "bi", "uri", "ji", "mu", "n", "ip", "I", "si", "pi", "multi", "ai", "index", "diff", "iu", "o", "ii", "c", "k", "p", "z", "mini", "ui", "ni", "zi", "gi", "adi", "fi", "anti", "e", "yi", "l", "ori", "io", "oi", "ie", "ini", "v", "ti", "j", "m"]}}
{"project": "FFmpeg", "commit_id": "c9c55a56996836e7783fb27018834f230c553c98", "target": 0, "func": "static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n\n{\n\n    while (uls->id != CODEC_ID_NONE) {\n\n        if(mxf_match_uid(uls->uid, *uid, 16))\n\n            break;\n\n        uls++;\n\n    }\n\n    return uls;\n\n}\n", "idx": 20102, "substitutes": {"uls": ["lbs", "aunts", "cs", "ils", "phones", "nas", "ricks", "laus", "uli", "flags", " imports", "orts", "asses", "uns", "flies", "ports", " legions", "ul", "rs", " feats", "kids", "arers", "ools", "ups", "packs", "nox", "cons", "ols", "ushes", "ips", "clus", "lins", "uss", "los", "oos", "opens", "ls", "ruits", " supplies", "us", "ails", "lus", "rets", " los", "laws", "acs", "ums", "ulates", " settlers", "illes", " offspring", "ubs", "ets", "cus", "uses", "pull", "UL", "usher", " fees", "ults", "acks", "outs", "rows", "ins", "offs", "checks", "mods", "sels", " pulses", "its", "rates"], "uid": ["bit", "upid", "family", "sid", "UID", "du", "uv", "ud", "kind", "uc", "name", "ids", "users", "u", "parent", "type", "ticket", "ul", "uri", "ip", "base", "version", "id", "vid", "oid", "user", "bid", "card", "uin", "uni", "code", "auth", "nn", "umi", "data", "uu", "us", "ug", "mac", "wd", "null", "ui", "uds", "gi", "url", "num", "kid", "shape", "pid", "port", "alias", "username", "gpu", "mask", "udi", "bin", "ua"]}}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n", "idx": 20105, "substitutes": {"chr": ["shr", "Chr", "echar", " chri", "charlr", "schra", "chp", "echri", "chri", "echr", "charpr", "charr", "ichr", "Chrc", "Chri", "phlr", " chra", "charra", "Char", " chro", "ichpr", "charp", "ichp", "charri", " chp", "shro", "schr", "phra", " chpr", "phri", "shra", "chrc", "ichlr", "echrc", "chra", "schri", "schro", "ichra", "charar", "shri", "ichri", "phr", " chlr", "charrc", "chlr", "chpr", "chro"], "connected": ["container", "not", "colored", "started", "client", "visible", "dc", "loaded", "supported", "enabled", "less", "controlled", "handled", "linked", "bc", "rolled", "normal", "compatible", " closed", "running", "conn", "modified", "powered", "connection", "valid", " connection", "bound", "known", "config", "id", "wired", "online", "closed", "index", "built", "functional", " disconnected", "registered", "graph", "broken", "connect", "initialized", "established", "active", "close", "selected", "cond", "opened", "ended", "locked", "current", "thread", "encrypted", "responsive", "socket", "done", "ed", "updated", "checked", "unknown", "open", "finished", "empty", "called"], "s": ["g", "is", "cs", "self", "css", "sys", "session", "f", "ps", "secondary", "new", "u", "rs", "js", "t", "ss", "d", "ns", "n", "si", "args", "i", "h", "r", "opens", "ls", "o", "es", "gs", "c", "p", "sb", "ts", "sie", "b", "ssl", "sl", "fs", "services", "S", "sg", "e", "ses", "l", "sets", "hs", "sym", "os", "ins", "spec", "se", "ds", "sync", "m"]}}
{"project": "FFmpeg", "commit_id": "544286b3d39365b30298ae07e66a755200b0895c", "target": 1, "func": "int h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format, width, height;\n\n\n\n    /* picture header */\n\n    if (get_bits(&s->gb, 22) != 0x20)\n\n        return -1;\n\n    skip_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1)\n\n        return -1;\t/* marker */\n\n    if (get_bits1(&s->gb) != 0)\n\n        return -1;\t/* h263 id */\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n\n\n    if (format != 7) {\n\n        s->h263_plus = 0;\n\n        /* H.263v1 */\n\n        width = h263_format[format][0];\n\n        height = h263_format[format][1];\n\n        if (!width)\n\n            return -1;\n\n\n\n        s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n\n\n        s->unrestricted_mv = get_bits1(&s->gb); \n\n        s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* SAC: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* advanced prediction mode: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* not PB frame */\n\n\n\n        s->qscale = get_bits(&s->gb, 5);\n\n        skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n    } else {\n\n        s->h263_plus = 1;\n\n        /* H.263v2 */\n\n        /* OPPTYPE */\n\n     \n\n        if (get_bits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */\n\n            return -1;\n\n        format = get_bits(&s->gb, 3);\n\n                \n\n        skip_bits(&s->gb,1); /* Custom PCF */\n\n        umvplus_dec = get_bits(&s->gb, 1); /* Unrestricted Motion Vector */\n\n        skip_bits(&s->gb, 10);\n\n        skip_bits(&s->gb, 3); /* Reserved */\n\n        \n\n        /* MPPTYPE */\n\n        s->pict_type = get_bits(&s->gb, 3) + 1;\n\n        if (s->pict_type != I_TYPE &&\n\n            s->pict_type != P_TYPE)\n\n            return -1;\n\n        skip_bits(&s->gb, 7);\n\n        \n\n        /* Get the picture dimensions */\n\n        if (format == 6) {\n\n            /* Custom Picture Format (CPFMT) */\n\n            skip_bits(&s->gb, 4); /* aspect ratio */\n\n            width = (get_bits(&s->gb, 9) + 1) * 4;\n\n            skip_bits1(&s->gb);\n\n            height = get_bits(&s->gb, 9) * 4;\n\n#ifdef DEBUG \n\n            fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n\n#endif            \n\n        }\n\n        else {\n\n            width = h263_format[format][0];\n\n            height = h263_format[format][1];\n\n        }\n\n        \n\n        if ((width == 0) || (height == 0))\n\n            return -1;\n\n            \n\n        if (umvplus_dec) {\n\n            skip_bits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n\n        }\n\n            \n\n        s->qscale = get_bits(&s->gb, 5);\n\n    }\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n    s->width = width;\n\n    s->height = height;\n\n    return 0;\n\n}\n", "idx": 20109, "substitutes": {"s": ["g", "set", "self", "sites", "ms", "session", "uns", "x", "js", "plugins", "gs", "conf", "b", "ssl", "su", "fs", "stats", "as", "states", "sets", "a", "qs", "http", "u", "in", "ions", "res", "ns", "site", "si", "args", "i", "your", "full", "strings", "es", "us", "p", "sb", "ts", "ks", "y", "services", "l", "sym", "words", "its", "sync", "f", "ops", "this", "less", "rs", "ss", "sq", "n", "o", "xs", "sup", "S", "bis", "sg", "ses", "spec", "is", "cs", "css", "sys", "ps", "t", "parts", "d", "ls", "w", "side", "service", "comments", "e", "os", "features", "ds", "settings"], "format": ["scale", "pattern", "layout", "api", "quality", "position", "fd", "direction", "frequency", "lat", "act", "period", "package", "image", "attr", "theme", "attribute", "mode", "pretty", "template", "op", "temp", "source", "flat", "it", "gap", "Format", "language", "letter", "at", "url", "filename", "method", "date", "offset", "f", "cat", "length", "large", "style", "frame", "base", "version", "plot", "sort", "lc", "file", "stage", "fn", "spec", "feature", "section", "html", "option", "category", "type", "alt", "feat", "prefix", "transform", "dim", "form", "len", "status", "space", "band", "qt", "dimension", "unit", "function", "slice", "text", " fmt", "event", "size", "settings"], "height": ["arrow", "alpha", "layout", "length", "resolution", "Height", "dim", "window", "inches", "gap", "position", "bottom", "direction", "h", "max", "build", "padding", "img", "input", "index", "total", "above", "center", "join", "depth", "gravity", "stroke", "origin", "slice", "thin", "density", "image", "definition", "pull", "row", "gain", " heights", "crop", "size"]}}
{"project": "qemu", "commit_id": "f3d8b1eb105199a1d6bf063a8a574e782689909a", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           DisplayState *ds, stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    qemu_irq *gpio_in[5];\n\n    qemu_irq *gpio_out[5];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    i2c_bus *i2c;\n\n    int i;\n\n\n\n    flash_size = ((board->dc0 & 0xffff) + 1) << 1;\n\n    sram_size = (board->dc0 >> 18) + 1;\n\n    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        adc = stellaris_adc_init(0x40038000, pic[14]);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            stellaris_gptm_init(0x40030000 + i * 0x1000,\n\n                                pic[timer_irq[i]], adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],\n\n                                    &gpio_out[i]);\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        i2c = i2c_init_bus();\n\n        stellaris_i2c_init(0x40020000, pic[8], i2c);\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            ssd0303_init(ds, i2c, 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            pl011_init(0x4000c000 + i * 0x1000, pic[uart_irq[i]],\n\n                       serial_hds[i], PL011_LUMINARY);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void * oled;\n\n            void * sd;\n\n            void *ssi_bus;\n\n            int index;\n\n\n\n            oled = ssd0323_init(ds, &gpio_out[GPIO_C][7]);\n\n            index = drive_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n", "idx": 20110, "substitutes": {"kernel_filename": ["kernelPusername", "kernel_buf", "pixel_label", "kernelaclength", "pixel_filename", "cell_buf", "kernelPlabel", "pixel_username", "kernelacusername", "cell_path", "cell_filename", "kernelprobuf", "kernelprosurface", "kernel_surface", "pixel_length", "cell_surface", "kernelacfilename", "kernelPlength", "kernelpropath", "kernelPfilename", "kernel_label", "kernel_path", "kernel_username", "kernelaclabel", "kernel_length", "kernelprofilename"], "cpu_model": ["screen_memory", "cpualmemory", "cpu_image", "cpulogaddress", "cpualimage", "screen_address", "cpualmode", "screenlogmemory", "cpu64memory", "cpulogmemory", "cpulogmodel", "cpu64address", "processor_memory", "cpu_address", "cpulogimage", "cpualmodel", "processor_mode", "cpu_memory", "screen_image", "screen_model", "cpu_mode", "screenlogaddress", "screenlogmodel", "cpu64mode", "processor_model", "screenlogimage", "cpu64model", "cpu64image", "processor_image"], "ds": ["ys", "cs", "di", "cdn", "df", "ops", "ps", "pd", "rs", "dd", "ss", "dm", "dos", "gd", "ros", "dt", "db", "des", "der", "dds", "DS", "de", "da", "ks", "fs", "cb", "vd", "gb", "sync"], "board": ["core", "server", "room", "coll", "bo", "layout", "client", "pc", "database", "clock", "ck", "node", "bc", "frame", "bank", "boards", "flow", "buffer", "d", "feed", "view", "table", "controller", "hub", "config", "boarding", "state", "card", "control", "bro", "data", "o", "deck", "block", "phone", "reader", "cell", "hole", "stream", "design", "loop", "game", "bridge", "object", "line", "cam", "channel", "b", "stroke", "Board", "comment", "home", "image", "lane", "bus", "plate", "row", "pod", "model", "driver", "bug", "flo", "device", "ack", "que", "plugin", "builder", "player", "sync"], "uart_irq": ["timer_mirQ", "timer_mirqs", "timer_mirq", "timer_irqs", "timer_irQ", "timer_ireqq", "timer_ireqs", "timer_ireQ", "timer_iriq", "timer_iriQ", "timer_iriqs", "timer_irqq", "timer_mirqq", "timer_ireq", "timer_iriqq"], "timer_irq": ["timer_mirQ", "timer_IRqs", "timer_IRquest", "timer_IRq", "timer__rinq", "timer_mirq", "timer_mirqs", "timer_irqs", "timer_irQ", "timer_irequest", "timer__irqs", "timer_rinQ", "timer_ireqs", "timer__irQ", "timer_ireQ", "timer__irqq", "timer__rinQ", "timer_rinqq", "timer_iriq", "timer_iriQ", "timer_IRqq", "timer_mirquest", "timer_iriqs", "timer_irqq", "timer__rinqs", "timer_IRQ", "timer_irquest", "timer_ireq", "timer__irq", "timer_iriqq", "timer__rinqq", "timer_rinqs", "timer_rinq"], "gpio_addr": ["gpio_ix", "gpios_addr", "gpio_id", "gpio__address", "gpios_id", "gpios_inner", "gpios_address", "gpios_ix", "gpio__ix", "gpio__addr", "gpio_adder", "gpios_adder", "gpios_in", "gpio__id", "gpio_inner", "gpio_address"], "gpio_irq": ["gpio_mirv", "gpio_iraque", "gpio_srqt", "gpio_pirqq", "gpio_mirqu", "gpio_srv", "gpio_irqq", "gpio_irque", "gpio_irtqu", "gpio_irv", "gpio_irqu", "gpio_irqt", "gpio_iraqq", "gpio_irtqt", "gpio_mirqq", "gpio_srqu", "gpio_pirQ", "gpio_pirq", "gpio_irtv", "gpio_irtq", "gpio_iraq", "gpio_pirque", "gpio_mirque", "gpio_irQ", "gpio_mirQ", "gpio_mirq", "gpio_mirqt", "gpio_srq", "gpio_iraQ"], "pic": ["aci", "vec", "cat", "study", "pc", "proc", "xi", "ac", "cache", "pipe", "pins", "feat", "mic", "chat", "cube", "capt", "tick", "plug", "py", "pot", "icc", "plan", "pi", "lib", "config", "photo", "parse", "doc", "ig", "mot", "feature", "cap", "ping", "typ", "cci", "circ", "lc", "fig", "quad", "jc", "sync", "ic", "cam", "pixel", "cus", "mini", "pin", "image", "PC", "iac", "soc", "gui", "pict", "fi", "bus", "arc", "cycle", "fn", "pid", "Pic", "court", "nic", "plugin", "picture", "piece"], "gpio_in": ["gpio_inc", "gpIO_in", "gpio_input", "gpios_out", "gpios_inc", "gpios_ins", "gpIO_out", "gpIO_input", "gpio_ins", "gpios_in", "gpIO_inc"], "gpio_out": ["gpios_outs", "gpioPin", "gpio_not", "gpios_size", "gpioPout", "gpios_out", "gpio_outs", "gpios_init", "gpio_size", "gpioPnot", "gpios_in", "gpios_not", "gpioPsize", "gpio_init"], "adc": [" adcu", "ajc", "adct", "Adsc", "adp", "dc", "aidce", "madc", "adci", "agm", " adpc", "madct", "Adcr", "abce", "adpc", "adcr", "adce", "Adf", "aidcr", "agrc", "aidsc", "dpc", "ajm", "madci", "aidl", "absc", "aidcu", "abf", " adrc", "adf", "drc", "agpc", "aidf", "ajct", "agci", "adcu", "Adcu", "abc", "agct", "agp", " adcr", "adsc", "adm", " adp", "madm", "dp", "agc", "Adl", "ajci", " adl", "Adc", "Adce", "adl", "aidc", "adrc"], "sram_size": ["sgram_loc", "sramxterm", "sram1storage", "slam_shape", "slam_ize", "sray_term", "sram_core", "srayxname", "sgram_size", "sram_ize", "sram_length", "srayxterm", "srayxlength", "sray_size", "sram_sized", "sray_length", "slam_size", "sram1ize", "sramxname", "sgram_core", "sram_name", "slam_storage", "sram1shape", "sram_shape", "sgram_sized", "sram_storage", "srayxsize", "sram_loc", "sramxsize", "sram_term", "sram1size", "sramxlength", "sray_name"], "flash_size": ["flashkmax", " flash_strength", "flash\u00b7member", "flashksize", "flash\u00b7shape", "flashkshift", "flash_member", "flash67strength", "flash_strength", " flash_shape", " flash_area", "flash_max", "flash67size", "flash_area", "burst_shift", "flash_shape", " flash_member", "flash67area", "flash_shift", "burst_max", "burst_size", "flash\u00b7size"], "i2c": ["i1f", "i5cs", "pi5f", "pi5cs", "i8f", "i5c", "i2cs", "i5f", "pi2cs", "i1cc", "i8cs", "i2f", "i1c", "pi2c", "pi2f", "pi5c", "i2cc", "i5cc", "pi5cc", "i1cs", "i8cc", "pi2cc", "i8c"], "i": ["g", "phi", "di", "inner", "my", "ri", "xi", "hi", "qi", "x", "axis", "ix", "ci", "page", "eni", "I", "h", "r", "c", "b", "z", "mini", "image", "gi", "a", "oi", "ini", "mi", "m", "interface", "cli", "u", "in", "uri", "it", "si", "multi", "ai", "iu", "p", "y", "ui", "yi", "fi", "l", "io", "ti", "j", "uli", "f", "n", "ip", "id", "iv", "o", "ii", "pixel", "ni", "zi", "info", "li", "t", "bi", "d", "pi", "k", "slice", "e", "ori", "ie", "v"]}}
{"project": "FFmpeg", "commit_id": "47219e1c0c2f8a159e70b58e6293c169c7dd62cc", "target": 1, "func": "static void do_video_out(AVFormatContext *s,\n\n                         OutputStream *ost,\n\n                         InputStream *ist,\n\n                         AVFrame *in_picture,\n\n                         int *frame_size, float quality)\n\n{\n\n    int nb_frames, i, ret, av_unused resample_changed;\n\n    AVFrame *final_picture, *formatted_picture;\n\n    AVCodecContext *enc, *dec;\n\n    double sync_ipts;\n\n\n\n    enc = ost->st->codec;\n\n    dec = ist->st->codec;\n\n\n\n    sync_ipts = get_sync_ipts(ost) / av_q2d(enc->time_base);\n\n\n\n    /* by default, we output a single frame */\n\n    nb_frames = 1;\n\n\n\n    *frame_size = 0;\n\n\n\n    if(video_sync_method){\n\n        double vdelta = sync_ipts - ost->sync_opts;\n\n        //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c\n\n        if (vdelta < -1.1)\n\n            nb_frames = 0;\n\n        else if (video_sync_method == 2 || (video_sync_method<0 && (s->oformat->flags & AVFMT_VARIABLE_FPS))){\n\n            if(vdelta<=-0.6){\n\n                nb_frames=0;\n\n            }else if(vdelta>0.6)\n\n                ost->sync_opts= lrintf(sync_ipts);\n\n        }else if (vdelta > 1.1)\n\n            nb_frames = lrintf(vdelta);\n\n//fprintf(stderr, \"vdelta:%f, ost->sync_opts:%\"PRId64\", ost->sync_ipts:%f nb_frames:%d\\n\", vdelta, ost->sync_opts, get_sync_ipts(ost), nb_frames);\n\n        if (nb_frames == 0){\n\n            ++nb_frames_drop;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** drop!\\n\");\n\n        }else if (nb_frames > 1) {\n\n            nb_frames_dup += nb_frames - 1;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** %d dup!\\n\", nb_frames-1);\n\n        }\n\n    }else\n\n        ost->sync_opts= lrintf(sync_ipts);\n\n\n\n    nb_frames= FFMIN(nb_frames, max_frames[AVMEDIA_TYPE_VIDEO] - ost->frame_number);\n\n    if (nb_frames <= 0)\n\n        return;\n\n\n\n    formatted_picture = in_picture;\n\n    final_picture = formatted_picture;\n\n\n\n#if !CONFIG_AVFILTER\n\n    resample_changed = ost->resample_width   != dec->width  ||\n\n                       ost->resample_height  != dec->height ||\n\n                       ost->resample_pix_fmt != dec->pix_fmt;\n\n\n\n    if (resample_changed) {\n\n        av_log(NULL, AV_LOG_INFO,\n\n               \"Input stream #%d.%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               ist->file_index, ist->st->index,\n\n               ost->resample_width, ost->resample_height, av_get_pix_fmt_name(ost->resample_pix_fmt),\n\n               dec->width         , dec->height         , av_get_pix_fmt_name(dec->pix_fmt));\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    ost->video_resample = dec->width   != enc->width  ||\n\n                          dec->height  != enc->height ||\n\n                          dec->pix_fmt != enc->pix_fmt;\n\n\n\n    if (ost->video_resample) {\n\n        final_picture = &ost->resample_frame;\n\n        if (!ost->img_resample_ctx || resample_changed) {\n\n            /* initialize the destination picture */\n\n            if (!ost->resample_frame.data[0]) {\n\n                avcodec_get_frame_defaults(&ost->resample_frame);\n\n                if (avpicture_alloc((AVPicture *)&ost->resample_frame, enc->pix_fmt,\n\n                                    enc->width, enc->height)) {\n\n                    fprintf(stderr, \"Cannot allocate temp picture, check pix fmt\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n            /* initialize a new scaler context */\n\n            sws_freeContext(ost->img_resample_ctx);\n\n            ost->img_resample_ctx = sws_getContext(dec->width, dec->height, dec->pix_fmt,\n\n                                                   enc->width, enc->height, enc->pix_fmt,\n\n                                                   ost->sws_flags, NULL, NULL, NULL);\n\n            if (ost->img_resample_ctx == NULL) {\n\n                fprintf(stderr, \"Cannot get resampling context\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n        sws_scale(ost->img_resample_ctx, formatted_picture->data, formatted_picture->linesize,\n\n              0, ost->resample_height, final_picture->data, final_picture->linesize);\n\n    }\n\n#else\n\n    if (resample_changed) {\n\n        avfilter_graph_free(&ost->graph);\n\n        if (configure_video_filters(ist, ost)) {\n\n            fprintf(stderr, \"Error reinitialising filters!\\n\");\n\n            exit_program(1);\n\n        }\n\n    }\n\n#endif\n\n    if (resample_changed) {\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    /* duplicates frame if needed */\n\n    for(i=0;i<nb_frames;i++) {\n\n        AVPacket pkt;\n\n        av_init_packet(&pkt);\n\n        pkt.stream_index= ost->index;\n\n\n\n        if (s->oformat->flags & AVFMT_RAWPICTURE) {\n\n            /* raw pictures are written as AVPicture structure to\n\n               avoid any copies. We support temorarily the older\n\n               method. */\n\n            AVFrame* old_frame = enc->coded_frame;\n\n            enc->coded_frame = dec->coded_frame; //FIXME/XXX remove this hack\n\n            pkt.data= (uint8_t *)final_picture;\n\n            pkt.size=  sizeof(AVPicture);\n\n            pkt.pts= av_rescale_q(ost->sync_opts, enc->time_base, ost->st->time_base);\n\n            pkt.flags |= AV_PKT_FLAG_KEY;\n\n\n\n            write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n            enc->coded_frame = old_frame;\n\n        } else {\n\n            AVFrame big_picture;\n\n\n\n            big_picture= *final_picture;\n\n            /* better than nothing: use input picture interlaced\n\n               settings */\n\n            big_picture.interlaced_frame = in_picture->interlaced_frame;\n\n            if (ost->st->codec->flags & (CODEC_FLAG_INTERLACED_DCT|CODEC_FLAG_INTERLACED_ME)) {\n\n                if(top_field_first == -1)\n\n                    big_picture.top_field_first = in_picture->top_field_first;\n\n                else\n\n                    big_picture.top_field_first = top_field_first;\n\n            }\n\n\n\n            /* handles sameq here. This is not correct because it may\n\n               not be a global option */\n\n            big_picture.quality = quality;\n\n            if(!me_threshold)\n\n                big_picture.pict_type = 0;\n\n//            big_picture.pts = AV_NOPTS_VALUE;\n\n            big_picture.pts= ost->sync_opts;\n\n//            big_picture.pts= av_rescale(ost->sync_opts, AV_TIME_BASE*(int64_t)enc->time_base.num, enc->time_base.den);\n\n//av_log(NULL, AV_LOG_DEBUG, \"%\"PRId64\" -> encoder\\n\", ost->sync_opts);\n\n            if (ost->forced_kf_index < ost->forced_kf_count &&\n\n                big_picture.pts >= ost->forced_kf_pts[ost->forced_kf_index]) {\n\n                big_picture.pict_type = AV_PICTURE_TYPE_I;\n\n                ost->forced_kf_index++;\n\n            }\n\n            ret = avcodec_encode_video(enc,\n\n                                       bit_buffer, bit_buffer_size,\n\n                                       &big_picture);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Video encoding failed\\n\");\n\n                exit_program(1);\n\n            }\n\n\n\n            if(ret>0){\n\n                pkt.data= bit_buffer;\n\n                pkt.size= ret;\n\n                if(enc->coded_frame->pts != AV_NOPTS_VALUE)\n\n                    pkt.pts= av_rescale_q(enc->coded_frame->pts, enc->time_base, ost->st->time_base);\n\n/*av_log(NULL, AV_LOG_DEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\",\n\n   pkt.pts != AV_NOPTS_VALUE ? av_rescale(pkt.pts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1,\n\n   pkt.dts != AV_NOPTS_VALUE ? av_rescale(pkt.dts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1);*/\n\n\n\n                if(enc->coded_frame->key_frame)\n\n                    pkt.flags |= AV_PKT_FLAG_KEY;\n\n                write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n                *frame_size = ret;\n\n                video_size += ret;\n\n                //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\",\n\n                //        enc->frame_number-1, ret, enc->pict_type);\n\n                /* if two pass, output log */\n\n                if (ost->logfile && enc->stats_out) {\n\n                    fprintf(ost->logfile, \"%s\", enc->stats_out);\n\n                }\n\n            }\n\n        }\n\n        ost->sync_opts++;\n\n        ost->frame_number++;\n\n    }\n\n}\n", "idx": 20129, "substitutes": {"s": ["g", "cs", "ops", "sys", "sa", "op", "rs", "ds", "js", "sit", "sq", "ss", "si", "sed", "ls", "sam", "o", "ctx", "st", "es", "gs", "c", "acs", "sb", "sci", "service", "ssl", "oss", "sl", "fs", "so", "sec", "sts", "ses", "os", "sv", "ast", "serv", "ess", "spec"], "ost": ["sn", "ops", "ov", "ud", "http", "iol", "src", "inst", "om", "rest", "op", "osta", "omm", "oh", "obb", "oe", "ad", "ods", "org", "irst", "oster", "ort", "obj", "obo", "est", "lib", "oid", "od", "osc", "tto", "isc", "ob", "tt", "ocr", "co", "rss", "oop", "o", "ont", "oper", "st", "ott", "hop", "lov", "oc", "ot", "nt", "post", "object", "ld", "ust", "obs", "oss", "store", "odi", "roc", "ST", "sta", "OST", "ood", "so", "ct", "omp", "os", "opp", "ast", "osi", "sth", "rost", "host"], "ist": ["istor", "pt", "wp", "inst", "et", "iste", "ird", "ad", "dit", "irst", "isd", "edit", "od", "irc", "ict", "adr", "lda", "IST", "ists", "ace", "gest", "st", "esi", "isu", "asi", "wd", "ld", "dist", "sta", "ism", "rist", "alist", "pit", "ast", "osi", "imet", "isi", "sth", "aint", "ilst", "ess"], "in_picture": ["inLogimage", "inLogvideo", "current_image", "in_feature", "current_video", "orig_feature", "in_image", "orig_picture", "current_picture", "orig_fine", "in_memory", "inLogmemory", "orig_uri", "in_video", "inLogpicture", "in_fine", "current_memory", "in_uri"], "frame_size": ["cycle_capacity", "cycle_size", "frame\u00b7scale", "image_size", "frame\u00b7size", "frame_resolution", "cycle_number", "image_scale", "framesscale", "frame_scale", "framessize", "frame\u00b7resolution", "framesresolution", "image_count", "frame_sized", "frame_count", "framescount", "frame_capacity", "image_resolution", "frame\u00b7count", "cycle_sized"], "quality": [" crit", " refresh", " fidelity", " score", " calib", " depth", " frequency", " alpha", " gamma", " weight", " gain", " qual", " wa", " confidence", " aspect", " pause", " Quality", " progress", " pad", " perf", " resolution", "Quality", " Q", " filter", " FPS", " fraction", " compression", " accuracy"], "nb_frames": ["nbenframes", "nb_states", "nbJsteps", "nrJcycles", "nb48quarters", "nbJframes", "num_lines", "num_steps", "nb_views", "nbKmodules", "bn_views", "nbCdates", "nb_features", "nb48flows", "nn_videos", "nr_cycles", "nb67frames", "num_fps", "niXvideos", "nb_lines", "nb67cycles", "nb_hops", "nn67frames", "nb__plugins", "nb48frames", "nbxframes", "nbenfps", "nbJflows", "nb48effects", "nb00features", "nb33videos", "nb_quarters", "nb64flows", "num_planes", "nbXmodules", "nbJcycles", "num_cycles", "ni_tracks", "nbXvideos", "nb00frames", "nbJvideos", "num_pages", "bn67words", "num_states", "num_objects", "num_features", "bn67frames", "nbxvideos", "nb_modules", "nb48lines", "nbensteps", "nb33hops", "nb67lines", "nn_steps", "nb33steps", "nbXtracks", "nb64effects", "nblexframes", "nb64lines", "nb67pages", "nb33frames", "niXtracks", "nbxhops", "nn67videos", "bn_words", "ni_videos", "nb_plugins", "nb_pages", "nb67hops", "nblexplugins", "nb__flows", "nblexflows", "nbCflows", "nb68fps", "nbKvideos", "nbJtracks", "nr_steps", "nb67steps", "nbCobjects", "nb00steps", "num_frames", "nb_flows", "nrJframes", "bn67views", "nr_flows", "nn_hops", "nb68lines", "nb64frames", "num_effects", "nbxquarters", "nb_cycles", "num_flows", "num_quarters", "num_docs", "nb_tracks", "nr_frames", "nb68docs", "nblexquarters", "nrJsteps", "nbKframes", "nb_docs", "nb_fps", "nb_cells", "ni_frames", "nn67steps", "nb48features", "nbKtracks", "num_videos", "nb_effects", "nb_dates", "nb67flows", "bn67flows", "nb67docs", "nb67views", "nb48steps", "ni_modules", "nn67hops", "nb_objects", "nbxsteps", "bn_flows", "nbenstates", "nb67words", "num_cells", "nb67quarters", "nb__quarters", "niXframes", "nbJmodules", "num_dates", "nb_videos", "num_plugins", "nbxpages", "nb__frames", "nrJflows", "nb68frames", "nb67fps", "nb_words", "nb00quarters", "nb_steps", "niXmodules", "nbCframes", "nb_planes", "nn_frames", "bn_frames", "nb67videos", "nbXframes"], "i": ["inner", "f", "cli", "ci", "li", "it", "n", "ip", "ti", "I", "pi", "si", "id", "uni", "index", "ai", "iu", "ii", "c", "p", "b", "slice", "ui", "io", "ie", "mi", "j", "info"], "ret": ["reply", "val", "rec", "result", "gc", "res", "back", "mi", "len", "fd", "aux", "rem", "status", "rev", "ref", "def", "resp", "re", "rc", "fn", "fi", "cb", "mem", "wa", "arr", "rep"], "resample_changed": ["resplay_changed", "resamples_error", "resplay_change", "resplay_modified", "resample_change", "resample__change", "resample_changes", "resamples_changed", "resample_modified", "resample__changed", "resamples_change", "resplay_edited", "resample__edited", "resample_edited", "resample__modified", "resamples_changes", "resample_error"], "final_picture": ["original_photo", "finalisedmedia", "reported_pic", "finaledimages", "final_photo", "reported_picture", "final_images", "final__media", "final__pic", "finalOimages", "reporteditypic", "finalOphoto", "finaledphoto", "finaledmemory", "finalOmemory", "finalityframe", "reporteditypicture", "reporteditymedia", "finalitymedia", "finalitypic", "original_picture", "finalisedpicture", "finalitypicture", "finaledpicture", "finalisedframe", "reported_frame", "final_media", "final_frame", "finalOpicture", "reported_media", "reportedityframe", "final__picture", "final_pic", "final_memory", "final__frame", "original_memory", "original_images", "finalisedpic"], "formatted_picture": ["formated_frame", "formatted_profile", "formlied_image", "formatted_image", "formated_Picture", "formlied_picture", "formatted_Picture", "formured_Picture", "formured_picture", "formatted_frame", "formatted_piece", "formured_profile", "formlied_pic", "formatted_pic", "formattedOpiece", "formattedOpicture", "formated_picture", "formattedOpic", "formattedOimage", "formured_image", "formated_image", "formlied_piece"], "enc": ["eu", "rec", "dc", "sys", "cat", "pc", "unc", "inc", "cel", "nc", "ac", "conn", "exec", "obj", "ch", "osc", "od", "nec", "eng", "code", "emb", "iv", "con", "equ", "ctx", "oder", "ec", "lc", "loc", "Enc", "oc", "c", "ou", "de", "cc", "cv", "vc", "sl", "ent", "roc", "orc", "en", "sec", "ant", "env", "anc", "cod", "fc"], "sync_ipts": ["sync_emptls", "sync_ippn", "sync_ownn", "sync_ipsts", "sync_rtn", "sync_iptd", "sync_rts", "sync_cts", "sync_ipls", "sync_ptns", "sync_ippls", "sync_empts", "sync_iptn", "sync_rtts", "sync_ctsets", "sync_ips", "sync_ipn", "sync_ippns", "sync_rtns", "sync_iptts", "sync_ptls", "sync_emptd", "sync_ptsets", "sync_ippps", "sync_ipsets", "sync_ownns", "sync_owns", "sync_opn", "sync_iptls", "sync_iptsets", "sync_ippt", "sync_opns", "sync_ipd", "sync_ctn", "sync_ippts", "sync_pts", "sync_ptts", "sync_ptn", "sync_ivt", "sync_iptps", "sync_ipst", "sync_ownts", "sync_ippd", "sync_ops", "sync_ipps", "sync_iptt", "sync_ippsets", "sync_ivts", "sync_iptns", "sync_ipss", "sync_ivs", "sync_ipsps", "sync_ctns", "sync_emptsets", "sync_ivps"], "nb_frames_drop": ["nb_flows_add", "nb_frames_change", "nb_frames_add", "nb_flows_0", "nb_flows_change", "nb_flows_drop", "nb_frames_0"], "sync_opts": ["sync_ottt", "sync_ops", "sync_opers", "sync_efftt", "sync_opttt", "sync_optms", "sync_proms", "sync_OPms", "sync_prots", "sync_opercs", "sync_OPcs", "sync_effitions", "sync_optcs", "sync_procs", "sync_pros", "sync_opms", "sync_optts", "sync_optps", "sync_OPts", "sync_effts", "sync_OPps", "sync_operts", "sync_effs", "sync_optt", "sync_opps", "sync_opcs", "sync_operps", "sync_otts", "sync_OPs", "sync_ots", "sync_optitions", "sync_otitions", "sync_opitions"], "frame_number": ["video_position", "frame64no", "frame64number", "frame64index", "framealposition", "frame_index", "video_index", "video_number", "frame64position", "frame_no", "framealindex", "frame_position", "framealno", "framealnumber", "video_no"]}}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n", "idx": 20131, "substitutes": {"opaque": ["openacity", "ophole", "opque", "OPaque", "opaques", "octaques", "Opque", "octhole", "Ophole", "octifice", "openaque", "OPque", "OPacity", "opacity", "openque", " opque", "openaques", " ophole", "OPaques", " opifice", "octque", "octaque", "Opaque", "Opifice", "opifice", "octacity"], "dbs": ["Dbc", "ldbes", "dbBS", "Dba", "dcs", "Dbi", " dbi", "sdBS", "dsbi", " dbes", "Dbes", "dsba", "dba", "dbc", "dbps", "Dcs", "ldbs", " dps", "Dbs", "dbi", "dbes", " dcs", "idbs", "sdbis", "DBS", "idBS", "dbbs", "idbis", "dBS", "Dps", "dbcs", "idps", "sdps", "dsBS", "sdbs", "ldba", "dps", "ldbc", " dbc", " dba", " dBS", "dsbs", "dbis", " dbis"]}}
{"project": "qemu", "commit_id": "3a21532626bb5c3ecb0f916843f75ccce6501a9d", "target": 0, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n\n\n\n    /* Only aligned reads are allowed on OHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n        return;\n\n    }\n\n\n\n    if (addr < OPREGBASE) {\n\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n\n\n    /* Do any register specific pre-write processing here.  */\n\n    switch(addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n", "idx": 20148, "substitutes": {"ptr": ["dr", "str", "f", "dll", "pt", "src", "proc", "inst", "buf", "sh", "t", "scope", "buffer", "tr", "inter", "fd", "si", "address", "r", "Ptr", "ref", "p", "fp", "sb", "tmp", "ts", "sl", "pointer", "tc", "eth", "fi", "e", "port", "tty", "sth", "ctr"], "addr": ["dc", "grad", "node", "x", "eni", "point", "xp", "ar", "code", "r", "padding", "afi", "rx", "xd", "eth", "vr", "attr", "amd", "rt", "layer", "oa", "mode", "dr", "nc", "pad", "arm", "coord", "hw", "nn", "od", "index", "data", "kt", "mac", "ea", "slot", "p", "pkg", "sta", "ne", "url", "alias", "port", "md", "host", "offset", "src", "pc", "intel", "route", "cmd", "frame", "ad", "base", "config", "id", "db", "address", "ord", "ace", "ctx", "rd", "pos", "pointer", "rc", "arr", "size", "str", "rr", "anne", "alt", "asm", "aug", "conn", "inter", "len", "mt", "adr", "hl", "hop", "align", "loc", "ext", "ref", "ld", "nr", "adder", "edge", "slice", "seq", "start", "nm", "part", "amp"], "val": ["local", "VAL", "aval", "x", "valid", "test", "play", "pl", "Val", "live", "al", "cond", "b", "sl", "update", "prop", "arg", "Value", "bo", "pt", "pol", "values", "reg", "fail", "index", "data", "fl", "slot", "p", "var", "key", "vol", "store", "eval", "def", "value", "err", "ne", "num", "fi", "serv", "bl", "f", "cal", " old", "old", "base", "db", "pass", "pre", "pos", "ind", "pret", "ve", "sel", "bal", "ret", "arr", "new", "alt", "ol", "li", "el", "vals", "len", " value", "all", "ref", "ld", "unit", "count", "part", "v", "elt"], "s": ["g", "self", "ves", "session", "secondary", "x", "js", "scope", "h", "r", "gs", "conf", "c", "b", "ssl", "sl", "socket", "fs", "su", "stats", "states", "sets", "a", "ins", "qs", "m", "server", "sf", "http", "instance", "u", "ns", "site", "si", "slave", "state", "es", "p", "sb", "ts", "sie", "services", "sv", "sym", "serv", "se", "j", "sync", "f", "ops", "this", "rs", "ss", "sq", "n", "o", "S", "sg", "ses", "spec", "is", "cs", "sys", "ps", "new", "t", "d", "ls", "w", "details", "service", "request", "e", "os", "v", "ds", "an", "settings"], "mmio": ["mIO", "mbni", "mbori", "mio", "memni", "mmiao", "mmori", "mpiao", "mmri", "mpios", "mmni", "mbIO", " mmri", "mpio", "mo", "memio", "mmIO", "mmmios", "memios", "mmmio", "mios", "memori", "mmmni", "mbri", "mmno", "mbios", "mbio", " mmno", " mmo", "mmmiao", "mmmno", " mmIO", "memo", "memri", " mmios", "memIO", "mmios", "mmmori", " mmiao", "mpno", "mmo"], "i": ["is", "f", "x", "end", "d", "n", "I", "r", "c", "p", "b", "z", "err", "ed", "e", "l", "a", "io", "v", "j", "m"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n", "idx": 20151, "substitutes": {"index": ["NAME", "length", "number", "match", "inc", "Index", "ix", "prefix", "cache", "x", "level", "type", "instance", "point", "connection", "root", "position", "version", "i", "config", "id", "column", "path", "address", "addr", "data", "loc", "object", "pos", "key", "ind", "pointer", "value", "num", "url", "alias", "size", "offset"], "obj": ["val", "pt", "inst", "nc", "x", "prefix", "node", "po", "js", "eff", "conn", "wb", "ns", "n", "args", "id", "path", "ob", "init", "act", "code", "Obj", "data", "addr", "o", "ctx", "typ", "ext", "rb", "ref", "object", "nt", "adj", "pos", "tmp", "key", "elt", "Object", "err", "ass", "nb", "bj", "cb", "fn", "attr", "os", "arr", "buff", "oa", "art", "j", "cn"], "name": ["str", "resource", "NAME", "x", "instance", "prefix", "new", "type", "parent", "old", "connection", "n", "base", "root", "table", "id", "word", "path", "address", "data", "space", "block", "addr", "call", "ext", "ref", " parent", "object", "key", "Name", " prefix", "search", "desc", "comment", "package", "named", "dot", "names", "num", "attr", "e", "url", "filename", "alias", "out", "part", "size", " path"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20158, "substitutes": {"arg1": ["ax1", " arg01", "Argone", "argument2", "argone", "Arg01", "Arg1", "Arg2", "argument1", "ax01", "argument3", "axone", "arg01", "argument01", "ax2", "ax3", " argone"], "arg2": ["ax1", "argument2", "arm4", "ax4", "args02", " arg02", "arm2", "argument1", "argument4", "ax02", "arm3", " arg4", "args4", "arg4", "argument3", "arm1", "args2", "ax2", "args1", "arg02"], "arg3": ["ax1", "ax03", "arg53", "argument2", "Arg1", "Arg2", " arg53", "Arg3", "argument1", "Arg53", "argument3", " arg03", "ax53", "arg03", "ax3", "Arg03", "argument03"], "farg1": [" far1", "fgen11", " fargOne", "far3", "fgen3", "far4", "fArgone", "fparam61", "Farg3", "frarg1", "fax3", "fargs91", "fang3", "fArg1", "targ81", "fvar1", "afargumentone", "Farg01", " fark3", "fgen2", "targs1", "fax1", "fargument3", "frg3", "fark61", " farg4", " fargfirst", "fang1", "farg01", " fark81", "farc1", "fparam1", "faccess1", "fargs3", " farg01", "frg1", "afarg1", "farg6", " farkOne", "targs01", "fArg81", "targ1", "fArg3", "FArg01", "fvar0", "farkfirst", "targs81", "targN", " far6", "FArg81", "fvar3", "FArg1", "farc0", "fargsfirst", "farg81", "targsN", "frparam61", "faccessN", "faccess01", "fax4", "farg4", "afargument91", "fark1", " far3", "targ01", " farg0", "frparam1", "farc81", "fargsN", "frparamOne", " farkfirst", "fargN", "Farg81", "fargs4", "frarg61", "fark01", "frargOne", "fargs6", "fparam3", "fargument1", "fArgOne", "fark0", "fargfirst", "farc3", "fargs81", "fargone", "far1", "farg0", "fark3", "farg91", "fargsone", "fargs0", "fgen1", " fark01", "far6", "fArg91", "fargs2", "afarg3", "fvarOne", "farkN", "fargs11", "farg11", "frparam3", " far4", "frg61", "fax6", "fang01", "afargument3", "fargumentone", " farg6", "fArg01", "FArg3", " farg81", "fargument91", "frgOne", " farg11", "fparamOne", "fargOne", "Farg1", " fark0", "faccess81", "afargument1", "frarg3", "fark81", " fark1", "fang81", "fargs1", "fvar01", "fvarfirst", "fargs01", "afargone", "afarg91", "farg61", "farkOne"], "farg2": ["fplay4", "Farg0", "fark72", "fagsecond", "fArg2", "fitem0", "FangTwo", "fagentwo", "Farg3", "pArg182", "fplayTwo", "falle62", "fargtwo", "forarg2", "fargs62", "fitem3", "fang3", "fvar4", "frargtwo", "fcresult62", "fcarg02", "fplay22", "falle2", "fcresult2", "Fang2", "frarg72", "fordr22", "fark22", "Fang3", "afalletwo", "fcresult02", "Fang0", "fplay0", "FargTwo", "fcresultsecond", "falletwo", "parg2", "fordr2", "afargTwo", "fplay182", "fdrTwo", "fangTwo", "fralle2", "fArg3", "afallesecond", "fvar0", "fralle72", "fagTwo", "fresultsecond", "afalleTwo", "fallesecond", "fagen2", "fitemTwo", "fplay3", "farg02", "forarg3", "fArg0", "pArg0", "farg4", "farg22", "farn3", "fcarg62", "fagenTwo", "fArg4", "fralle3", "fresult62", "fagtwo", "fargTwo", "fdr3", "fvar2", "fordr3", "fargssecond", "fargs02", "fang0", "parg182", "parg0", "fvar182", "farg182", "fargsecond", "fcargsecond", "farktwo", "fang2", "farg0", "fark3", "Farg2", "farkTwo", "fargs2", "falle02", "fark2", "fcarg2", "frarg2", "parg4", "fArgTwo", "forarg22", "fresult02", "fagensecond", "fArg182", "fresult2", "pArg4", "fplay2", "falle72", "fdr22", "afargsecond", "fitem2", "afarg2", "fralletwo", "farg72", "afargtwo", "afalle2", "fdr2", "fordrTwo", "farntwo", "falleTwo", "pArg2", "farn72", "farn2", "falle3", "fag2", "frarg3", "forargTwo", "farg62"], "farg3": [" ferg23", "fArg2", "fark03", "fack3", " fArg3", "fvalid1", "fax3", "fcall3", " fargThree", "fang3", "fArg1", " farg23", "fall53", " fArgthird", "fcall53", " farg4", "ferg3", "fax9", " fargs2", "carg3", "fvalid40", "farc15", "frarg23", "fargs3", "fvalid3", " fArgThree", "fArgthird", "farkThree", "ferg23", "fax23", "fax15", " farg40", "carg9", "fArg3", "fack23", " ferg12", "cang3", "falle40", "fcall03", " ferg03", "cang53", "fack03", "farg4", "fark1", "frcall23", "fok03", "frcall3", "fArg4", "cang9", "farg40", "fcall23", "cang03", "farg12", "farg23", "fargs4", "fArgThree", "fang03", "ferg03", "fall03", "farc3", "ferg12", "farg15", " fArg1", "fark3", " fArg03", " fargs1", "fcall15", "fok3", "fax53", "fargs2", "fvalidthird", "frarg15", "fargThree", "fokThree", " farg03", "carg03", "frarg53", "falle1", "fcall12", "fargthird", "fArg03", "farg03", "fallethird", "farc53", "fang53", "fok1", "fArg40", "fall3", "carg53", "farg9", "farc23", " fargs4", "falle3", " farg12", "frarg3", "fall9", "frcall15", "fargs1", "fack12", "fax03", "frcall53", " ferg3", "fang9", " fArg40", " fargs3", "farg53", " fargthird"], "ft0_128": ["ft0j256", "ft80_1024", "ft0j128", "ft80_167", "ft1_257", "ft0_1024", "ft0_13", "ft0j58", "ft0_58", "ft0_048", "ft5_128", "ft0_188", "ft0_48", "ft2_048", "ft1_13", "ft1_512", "ft5_512", "ft2_48", "ft0_208", "ft80_256", "ft2_128", "ft80_128", "ft1_384", "ft1_048", "ft0_256", "ft1_256", "ft5_208", "ft1_58", "ft0_512", "ft5_256", "ft0j13", "ft0_167", "ft0_384", "ft2_188", "ft0_257"], "ft1_128": ["ft1_188", "ft1_48", "ft1_32", "ft0_32", "ft0_48", "ftone_128", "ftone_48", "ftone_188", "ft0_126", "ft1_126", "ft0_257", "ft1_257", "ft0_256", "ft1_256"]}}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n", "idx": 20189, "substitutes": {"buf": ["batch", "cp", "header", "f", "src", "uf", "result", "cmd", "queue", "cache", "array", "buffer", "Buffer", "pool", "obj", "fd", "config", "pb", "img", "data", "binary", "ctx", "writer", "rb", "cf", "file", "fp", "loader", "bag", "cv", "b", "ptr", "alloc", "cb", "rc", "fi", "seq", "bf", "buff", "Buff", "fb"], "buf_size": ["cb_sum", "buf2ize", "buf2offset", "bufroffset", "buf_ize", "cb_capacity", "bufrsize", " buf_offset", "cb_size", "buf_capacity", "buf_offset", "buf2size", "bufrize", "buf_sum", " buf_ize"], "filename": ["console", "tif", "dll", "src", "name", "png", "prefix", "window", "wb", "fd", "enc", "config", "path", "binary", "writer", "ctx", "w", "rb", "callback", "file", "loader", "func", "fs", "image", "fn", "tty", "username", "nm"], "cow_header": ["cow_buffer", "cca_header", "cca_version", "cow_magic", "ow_buffer", " cow_pair", "cow_cache", "cow_writer", "cow_head", "ow_magic", "ow_head", "cca_author", "cowingdefinition", "cowingversion", "cca_definition", "cow_version", "cow_pair", " cow_writer", "cow_author", "cowingpair", "cowingauthor", "cow_definition", "cowingcache", "cowingwriter", "ow_header", " cow_cache", "cowingheader"]}}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "uint64_t ram_bytes_remaining(void)\n\n{\n\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n\n}\n", "idx": 20197, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {\n\n    Pulse pulse;\n\n    TemporalNoiseShaping * tns = &sce->tns;\n\n    IndividualChannelStream * ics = &sce->ics;\n\n    float * out = sce->coeffs;\n\n    int global_gain, pulse_present = 0;\n\n\n\n    /* This assignment is to silence a GCC warning about the variable being used\n\n     * uninitialized when in fact it always is.\n\n     */\n\n    pulse.num_pulse = 0;\n\n\n\n    global_gain = get_bits(gb, 8);\n\n\n\n    if (!common_window && !scale_flag) {\n\n        if (decode_ics_info(ac, ics, gb, 0) < 0)\n\n            return -1;\n\n    }\n\n\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n\n        return -1;\n\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n\n        return -1;\n\n\n\n    pulse_present = 0;\n\n    if (!scale_flag) {\n\n        if ((pulse_present = get_bits1(gb))) {\n\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n\n                return -1;\n\n            }\n\n            decode_pulses(&pulse, gb, ics->swb_offset);\n\n        }\n\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n\n            return -1;\n\n        if (get_bits1(gb)) {\n\n            av_log_missing_feature(ac->avccontext, \"SSR\", 1);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 20199, "substitutes": {"ac": ["Ac", "cs", "AC", "dc", "acl", "cat", "pc", "ck", "com", "uc", "bc", "cache", "inc", "mic", "gc", "ad", "api", "aic", "kit", "ax", "config", "jac", "aut", "act", "app", "ae", "ace", "ec", "mac", "ga", "ca", "att", "acs", "oc", "c", "k", "ag", "cc", "ic", "ach", "vc", "fac", "abc", "auc", "tc", "am", "acc", "iac", "as", "ct", "sac", "mc", "acer", "anc", "cu", "a", "ack", "an", "af", "pac"], "sce": ["esces", "scast", "eske", "insse", "scca", "dske", "scel", "unske", "wsce", "esce", " scast", " scca", " scer", " sces", "gsced", "Ske", "gspose", "scer", "openske", "dsCE", "unsce", "opensces", "oscel", "gsste", "insce", " ske", "sesce", "vesce", " sste", "openscel", "unsCE", "inske", "iske", "gske", "wscel", "isject", "sescent", "iscca", "sse", "osced", "pske", "osce", "vesste", "gsce", "ysce", "SCE", "sste", "seske", "inscast", " sCE", "isce", "sesCE", "spose", " sject", " sse", "psce", "ske", "Scast", "unscent", "sces", " scel", "ospose", "scent", "sCE", "inscel", "gscel", "insCE", "veske", "wske", "insces", "inscent", "pscast", "escel", "yske", "sced", "yscer", "sject", "opensce", "Sce", "vescel", " scent", "dscent", "pscel", "opensse", "wsces", "dsce"], "gb": ["g", "cca", "gate", "cs", "gm", "gin", "pc", "generic", "range", "bc", "gam", "ci", "gc", "bb", "hub", "gd", "boot", "bm", "gal", "db", "bits", "cgi", "Gb", "eb", "ig", "ged", "ctx", "ga", "gio", "gs", "rb", "gram", "gnu", "sb", "gt", "kw", "vc", "gh", "b", "mb", "rg", "ko", "gp", "agg", "hd", "cfg", "gz", "nb", "gi", "gy", "cb", "yg", "bf", "sg", "gg", "ym", "ub", "og", "GB", "kb", "usb", "lb", "buff", "bg", "bin", "go"], "common_window": ["commonarygroup", " common_group", " common_depth", "common_group", "commoniangroup", "common_event", " commonitywindow", "common_depth", "commonitymode", "common_count", " commonitygroup", "commoniandepth", " commonitycount", "commonmevent", " common_event", "commonitydepth", "commonarydepth", "commonarycount", " common_count", "commonityevent", "commonitywindow", " common_mode", "commonianwindow", "commonmmode", "common_mode", "commonmwindow", "commoniancount", "commonarywindow", "commonitycount", " commonitydepth", "commonitygroup"], "scale_flag": ["cale_window", "cale_bit", "scalevalbit", "scalevalwin", "cale_win", " scale_info", "scale_bit", "scaleotype", " scale_window", "scaleallflag", "scale_file", "scale_info", "scaleoflag", "scalealltype", "scaleallinfo", "cale_flag", "scale_type", "scaleoinfo", " scale_type", "scale_window", " scale_file", "scalevalflag", "scalevalwindow", "scale_win"], "pulse": ["compurchase", " pair", " pulsion", " pilot", "pipe", "epuls", "Pilot", "compitch", " puls", "paramixels", "copitch", "Pulsion", "ppixels", "patulse", "patair", "vpitch", "ppixel", "pilot", "pair", "vpulsion", "epilot", "compulse", "patilot", "puls", "vpurchase", "pushulsion", "ppulse", "patulsion", "lpulse", "pixels", "pixel", "pulsion", " pipe", "ppitch", "Pair", "lpuls", "vpulse", "copixels", "epulse", "epipe", "compulsion", "paramitch", "paramixel", "copixel", "pushitch", "pitch", "pushulse", "paramulse", "copulse", "Pulse", "purchase", "pushurchase", "lpilot", "lpipe"], "tns": ["pls", "tnc", "atnc", "fns", "otns", " tnas", "tsicks", "tsn", "tna", "Tnas", "tcs", "dnc", "tls", "tsns", "Tcs", "dsn", "otsn", " touts", "atds", "touts", "dds", "pns", "pnas", " tbs", "atsn", "tnas", "dns", " tcs", "tcons", " tna", " ticks", "tticks", " tcons", "fls", "tsbs", "Tls", "ttns", "ttcons", "fna", "tscons", "Tna", "ticks", "otds", " tls", "otnc", "tds", "pouts", "atns", "fcs", "Touts", "tbs", "Tns", "ttbs"], "ics": ["g", "amples", "x", "ix", "xml", "ci", "mic", "magic", "icing", "aps", "codes", "ICS", "icons", "ga", "gs", "cf", "fs", "cfg", "stats", "xes", "icks", "ins", "outs", "qs", "omics", "ico", "cli", "gc", "ns", "aic", "args", "cons", "items", "acs", "inf", "ks", "ts", "abc", "wcs", "fps", "fi", "io", "isi", "events", "fc", "its", "nas", "ats", "ick", "ops", "bc", "cells", "inas", "ipes", "ips", "bits", "xs", "cus", "iac", "IC", "gy", "gg", "osi", "cases", "spec", "icc", "is", "cs", "css", "str", "sys", "wic", "fits", "igs", "isc", "status", "ls", "ig", "xxx", "rics", "details", "ic", "uses", "gz", "acks", "nic", "times", "rates"], "out": ["g", "bit", "copy", "output", "extra", "new", "temp", "ix", "cache", "prefix", "in", "gc", "op", "bc", "orig", "bb", "obj", "args", "i", "lib", "again", "init", "co", "img", "full", "input", "o", "raw", "ext", "Out", "gen", "c", "amp", "at", "err", "cfg", "image", "ui", "wcs", "cb", "outs", "io", "bin", "go", "sync"], "global_gain": ["global_wall", "Global_gen", "global67band", "global67growth", " global_gen", "global_band", " global_generation", "global_speed", "global_generation", "global67generation", "global_gen", "global5gain", "global5generation", "global67gen", " global_speed", "Global_gain", "Global_band", " global_wall", "Global_growth", "global67wall", "global67gain", "global_growth", "global5wall"]}}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n", "idx": 20200, "substitutes": {"s": ["g", "ms", "session", "secondary", "uns", "js", "h", "r", "gs", "conf", "c", "b", "ssl", "su", "fs", "as", "sets", "a", "ins", "qs", "m", "server", "sf", "u", "ns", "site", "si", "i", "your", "full", "es", "us", "sb", "p", "ts", "services", "l", "sym", "its", "sync", "the", "f", "ops", "this", "less", "rs", "ss", "sq", "n", "o", "xs", "S", "en", "sg", "ses", "spec", "is", "cs", "aws", "sys", "ps", "new", "t", "d", "ls", "side", "service", "comments", "e", "os", "ds", "v", "settings"]}}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void pci_qdev_register(PCIDeviceInfo *info)\n\n{\n\n    info->qdev.init = pci_qdev_init;\n\n    info->qdev.bus_type = BUS_TYPE_PCI;\n\n    qdev_register(&info->qdev);\n\n}\n", "idx": 20213, "substitutes": {"info": ["inner", "check", "f", "http", "this", "extra", "kind", "name", "type", "op", "link", "off", "api", "end", "it", "error", "INFO", "fo", "add", "feed", "py", "base", "ip", "si", "i", "config", "id", "fw", "parse", "init", "index", "build", "entry", "data", "ii", "conf", "app", "inf", "Info", "ignore", "def", "update", "comment", "image", "ui", "gi", "rc", "fi", "die", "options", "start", "opt", "a", "io", "rt", "manager", "af"]}}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n", "idx": 20233, "substitutes": {"net": ["set", "server", "not", "resource", "inet", "cat", "NET", "nc", "contract", "et", "mat", "conn", "web", "six", "connection", "Net", "np", "n", "fun", "boot", "tun", "plugin", "site", "ut", "config", "ner", "module", "user", "dt", "nec", "eng", "db", "nit", "act", "virtual", "jet", "mot", "iot", "ot", "nt", "channel", "key", "unit", "cot", "nets", "service", "fat", "en", "ni", "vm", "ne", "ct", "num", "un", "network", "dat", "text", "io", "nu", "nic", "pot", "nat", "art", "ver", "cn"], "dev": ["di", "DEV", "dc", "grad", " device", "client", "end", "der", "block", "engine", "call", "conf", "app", "devices", "gu", "package", "image", "disk", "unknown", "dn", "adv", "dr", "server", "nc", "temp", "mod", "dd", "req", "hw", "user", "dom", "data", "design", "def", "group", "bug", "env", "md", "ver", "ad", "error", "module", "db", "init", "dir", "diff", "Dev", "develop", "dist", "ve", "priv", "ev", "nov", "dat", "serial", "info", "development", "conn", "dim", "d", "gd", "ner", "dt", "private", "w", "de", "driver", "device", "rad", "debug"], "file": ["class", "resource", "check", "rule", "f", "http", "route", "worker", "name", "type", "cache", "queue", "link", "load", "parent", "folder", "uri", "d", "pool", "feed", "connection", "File", "base", "fun", "lib", "module", "id", "config", "zip", "db", "path", "play", "put", "il", "dir", "entry", "data", "block", "binary", "files", "w", "conf", "time", "object", "channel", "line", "key", "fp", "unit", "function", "ile", "comment", "image", "fi", "url", "un", " File", "port", "model", "bug", "out", "feature", "use"], "index": ["di", "length", "number", "inc", "name", "x", "type", "prefix", "level", "conn", "page", "end", "old", "connection", "point", "base", "position", "i", "config", "id", "db", "label", "address", "diff", "write", "loc", "body", "ref", "head", "key", "ind", "unit", "pointer", "action", "slice", "value", "update", "weight", "find", "count", "num", "degree", "shape", "open", "ini", "part", "offset"], "vhost_ops": ["vhost__ops", "vhostpapps", "vHost_opens", "vhost__flags", "vhost2op", "vhost2opens", "vhost_apps", "vhostpflags", "vhost2oper", "vhost_oper", "vhost_op", "vhostmloop", "vhostpops", "vHost_ops", "vhost__oper", "vhostmop", "vHost_oper", "vhost_opens", "vhostpoper", "vHost_op", "vhostmoper", "vhostmops", "vhost_flags", "vhost2ops", "vhost__apps", "vhost_loop"]}}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int rtsp_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char host[1024], path[1024], tcpname[1024], cmd[2048];\n\n    URLContext *rtsp_hd;\n\n    int port, i, ret, err;\n\n    RTSPHeader reply1, *reply = &reply1;\n\n    unsigned char *content = NULL;\n\n    AVStream *st;\n\n    RTSPStream *rtsp_st;\n\n    int protocol_mask;\n\n\n\n    rtsp_abort_req = 0;\n\n    \n\n    /* extract hostname and port */\n\n    url_split(NULL, 0,\n\n              host, sizeof(host), &port, path, sizeof(path), s->filename);\n\n    if (port < 0)\n\n        port = RTSP_DEFAULT_PORT;\n\n\n\n    /* open the tcp connexion */\n\n    snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port);\n\n    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)\n\n        return AVERROR_IO;\n\n    rt->rtsp_hd = rtsp_hd;\n\n    rt->seq = 0;\n\n    \n\n    /* describe the stream */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"DESCRIBE %s RTSP/1.0\\r\\n\"\n\n             \"Accept: application/sdp\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, &content);\n\n    if (!content) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n        \n\n    /* now we got the SDP description, we parse it */\n\n    ret = sdp_parse(s, (const char *)content);\n\n    av_freep(&content);\n\n    if (ret < 0) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    \n\n    protocol_mask = rtsp_default_protocols;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n       RTSP stream */\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        char transport[2048];\n\n        AVInputFormat *fmt;\n\n\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n\n\n        /* compute available transports */\n\n        transport[0] = '\\0';\n\n\n\n        /* RTP/UDP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) {\n\n            char buf[256];\n\n            int j;\n\n\n\n            /* first try in specified port range */\n\n            if (rtsp_rtp_port_min != 0) {\n\n                for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) {\n\n                    snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j);\n\n                    if (!av_open_input_file(&rtsp_st->ic, buf, \n\n                                            &rtp_demux, 0, NULL))\n\n                        goto rtp_opened;\n\n                }\n\n            }\n\n\n\n            /* then try on any port */\n\n            if (av_open_input_file(&rtsp_st->ic, \"rtp://\", \n\n                                       &rtp_demux, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n            }\n\n\n\n        rtp_opened:\n\n            port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;unicast;client_port=%d-%d\",\n\n                     port, port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/TCP\");\n\n        }\n\n\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), \n\n                     sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;multicast\");\n\n        }\n\n        snprintf(cmd, sizeof(cmd), \n\n                 \"SETUP %s RTSP/1.0\\r\\n\"\n\n                 \"Transport: %s\\r\\n\",\n\n                 rtsp_st->control_url, transport);\n\n        rtsp_send_cmd(s, cmd, reply, NULL);\n\n        if (reply->status_code != RTSP_STATUS_OK ||\n\n            reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].protocol != rt->protocol) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->protocol = reply->transports[0].protocol;\n\n        }\n\n\n\n        /* close RTP connection if not choosen */\n\n        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&\n\n            (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) {\n\n            av_close_input_file(rtsp_st->ic);\n\n            rtsp_st->ic = NULL;\n\n        }\n\n\n\n        switch(reply->transports[0].protocol) {\n\n        case RTSP_PROTOCOL_RTP_TCP:\n\n            fmt = &rtp_demux;\n\n            if (av_open_input_file(&rtsp_st->ic, \"null\", fmt, 0, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n            \n\n        case RTSP_PROTOCOL_RTP_UDP:\n\n            {\n\n                char url[1024];\n\n                \n\n                /* XXX: also use address if specified */\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d\", \n\n                         host, reply->transports[0].server_port_min);\n\n                if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n\n            {\n\n                char url[1024];\n\n                int ttl;\n\n\n\n                fmt = &rtp_demux;\n\n                ttl = reply->transports[0].ttl;\n\n                if (!ttl)\n\n                    ttl = 16;\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", \n\n                         host, \n\n                         reply->transports[0].server_port_min,\n\n                         ttl);\n\n                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* use callback if available to extend setup */\n\n    if (ff_rtsp_callback) {\n\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n\n                             NULL, 0, rt->last_reply) < 0) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n                         \n\n    /* start playing */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"PLAY %s RTSP/1.0\\r\\n\"\n\n             \"Range: npt=0-\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, NULL);\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n#if 0\n\n    /* open TCP with bufferized input */\n\n    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {\n\n        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {\n\n            err = AVERROR_NOMEM;\n\n            goto fail;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n fail:\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n        if (rtsp_st) {\n\n            if (rtsp_st->ic)\n\n                av_close_input_file(rtsp_st->ic);\n\n        }\n\n        av_free(rtsp_st);\n\n    }\n\n    av_freep(&content);\n\n    url_close(rt->rtsp_hd);\n\n    return err;\n\n}\n", "idx": 20237, "substitutes": {"s": ["g", "self", "client", "session", "js", "support", "r", "gs", "conf", "c", "ssl", "b", "sl", "su", "fs", "sets", "qs", "server", "ns", "site", "si", "args", "your", "es", "p", "sb", "ts", "y", "ks", "services", "l", "sym", "se", "sync", "f", "src", "this", "tp", "rs", "ss", "sq", "n", "o", "sci", "series", "xs", "S", "sg", "ses", "spec", "is", "shell", "cs", "sys", "aws", "sa", "ps", "new", "t", "parts", "d", "storage", "private", "space", "ls", "service", "e", "os", "ds", "v", "settings"], "ap": ["arp", "AP", "sa", "sp", "ars", "wp", "tp", "jp", "ac", "op", "api", "ad", "apt", "ax", "aps", "ar", "pa", "pp", "cap", "att", "al", "am", "as", "attr", "mp", "arr", "ams", "au", "pac"], "rt": ["dr", "rr", "sys", "pt", "rs", "bt", "NT", "t", "rm", "req", "sr", "rh", "tr", "boot", "mt", "ut", "dt", "tt", "r", "adr", "rx", "fr", "rss", "qt", "att", "rb", "rd", "nt", "ot", "gt", "rl", "vc", "irt", "rf", "cr", "vt", "ft", "ct", "vr", "rc", "rn", "RT", "ant", "rot", "ht", "art"], "host": ["container", "server", "header", "pattern", "client", "component", "http", "src", "route", "domain", "node", "type", "frame", "name", "Host", "source", "prefix", "proxy", "conn", "uri", "connection", "ip", "localhost", "config", "id", "h", "address", "dir", "addr", "full", "target", "hop", "stream", "loc", "format", "head", "file", "object", "key", "uid", "home", "context", "driver", "password", "method"], "path": ["core", "container", "resource", "pattern", "route", "cli", "PATH", "name", "node", "prefix", "parent", "temp", "source", "conn", "uri", "root", "config", "id", "auth", "address", "code", "Path", "dir", "data", "input", "ctx", "pass", "ath", "loc", "file", "key", "desc", "image", "prop", "request", "text", "password", "method"], "tcpname": ["tportName", "fmppath", "tmpname", "twpName", "tchurl", "tpnam", "tchname", " tportnam", "fcppath", "Tmpnames", "tcpnam", "tpName", " tcpnam", "Tmppath", "tfpname", "tpprefix", "Tmpname", "tportnam", "tcpnames", "twpnames", " tportname", "fmpurl", "tportname", "tpnames", "tfpName", "tcppath", " tportName", "Tcppath", "tppath", "fmpname", "tmppath", "tmpnames", "Tcpnames", "tchName", "tpname", " tcpName", "TcpName", "Tcpname", " tcpprefix", "twpname", "tchpath", "TmpName", "fmpName", "tpurl", "tportprefix", " tportprefix", "tcpprefix", "fcpName", "twppath", "tmpName", "fcpname", "fcpurl", "tcpName", "tmpprefix", "tfppath", "tcpurl", "tmpurl"], "cmd": ["shell", "cp", "cd", "header", "client", "cat", "src", "route", "cli", "command", "domain", "name", "pipe", "prefix", "conn", "req", "message", "config", "module", "auth", "cl", "code", "ctx", "target", "comm", "mac", "ext", "cf", "head", "file", "patch", "crypt", "pkg", "cfg", "msg", "Cmd", "cb", "cookie", "seq", "cmp", "text", "filename", "password", "method", "md", "setup", "mode"], "rtsp_hd": ["rtsp_rh", "rtsnp_xd", "rtsnp_ctx", "rtsnp_hd", "rtsnp_dh", "rtsnp_cd", "rtsc_vd", "rtsp_ld", "rtsp_cd", "rtsc_hd", "rtsp_hm", "rtsp_vd", "rtsnp_ld", "rtsp_conn", "rtsp_dh", "rtsnp_hm", "rtsp_xd", "rtsc_cd", "rtsnp_vd", "rtsnp_rh", "rtsp_ctx", "rtsc_conn"], "port": ["cp", "server", "priority", "length", "number", "timeout", "route", "PORT", "export", "ports", "name", "type", "parent", "source", "Port", "end", "connection", "test", "ort", "n", "ip", "message", "col", "len", "position", "direction", "config", "id", "version", "offset", "zip", "address", "index", "phone", "target", "hop", "stream", "time", "file", "p", "pos", "key", "limit", "line", "m", "count", "text", "size", "method", "part", "mode"], "i": ["phi", "di", "inner", "ri", "xi", "hi", "type", "idi", "qi", "ix", "x", "ci", "li", "u", "eni", "mu", "uri", "it", "n", "ip", "ti", "I", "pi", "si", "multi", "id", "jit", "h", "index", "ai", "chi", "iu", "ii", "iter", "c", "k", "p", "key", "gu", "y", "b", "m", "ui", "image", "ni", "gi", "ami", "fi", "yi", "e", "start", "ori", "l", "io", "ie", "ini", "v", "mi", "info"], "ret": ["val", "RET", "str", "bit", "result", "match", "alt", "feat", "res", "success", "reg", "sr", "no", "len", "fun", "ut", "status", "code", "r", "pat", "rev", "pass", "rets", "read", "att", "ref", "det", "nt", "def", "resp", "re", "flag", "msg", "en", "rc", "fi", "Ret", "count", "mem", "num", "arr", "arg", "lit", "rep", "info"], "err": ["dr", "str", "rr", "result", "cur", "raise", "kr", "orig", "error", "req", "rh", "lr", "ir", "ner", "fg", "ar", "code", "r", "der", "fr", "hr", "iter", "gr", "mr", "ind", "cr", "er", "msg", "Error", "cb", "fi", "rage", "e", "fy", "ler", "acer", "bug", "arr", "order", "fer", "pr", "ver", "br"], "reply1": ["reply2", "resp0", "Reply2", "request1", "reply0", "ReplyOne", " reply2", "Reply1", "requestOne", " replyOne", "Reply0", "request2", "resp1", "replyOne", "resp2", " reply0"], "reply": ["shell", "server", "resource", "rec", "rr", "sys", "f", "ry", "result", "sp", "report", "link", "proxy", "sq", "repl", "sr", "buffer", "Reply", "req", "prev", "message", "parse", "address", "status", "r", "fr", "entry", "replace", "rev", "respond", "data", "write", "call", "next", "answer", "response", "service", "b", "resp", "re", "comment", " replies", "transfer", "msg", "send", "rc", "request", "query", "serv", "rep", "sync", "info"], "content": ["accept", "server", "header", "resource", "cs", "rec", "results", "cm", "output", "result", "match", "command", "complete", "temp", "x", "xml", "media", "load", "script", "clean", "conn", "reg", "exec", "message", "ch", "cms", "enc", "config", "found", "address", "code", "status", "con", "data", "ctx", "read", "ext", "body", "cont", "c", "cf", "file", "connect", "resh", "response", "resp", "desc", "comment", "msg", "rc", "Content", "text", "size"], "st": ["dr", "str", "sn", "pt", "src", "sp", "sa", "inst", "rest", "td", "t", "ss", "d", "St", "sd", "mt", "est", "ut", "ist", "fr", "stream", "sb", "ld", "std", "ost", "nd", "sl", "stage", "se", "ptr", "ST", "sta", "ft", "ct", "sts", "start", "fe", "ast", "sth", "sc", "ste", "part"], "rtsp_st": ["rtsv_hd", "rtsf__ct", "rtsf__sth", "rtsv_st", "rtsf_ct", "rtsp_ct", "rtsp_stream", "rtsf__stream", "rtsp__stream", "rtsp__st", "rtsp_da", "rtsp__sth", "rtsv_da", "rtsf__st", "rtsp_sth", "rtsf_st", "rtsf_stream", "rtsv_sth", "rtsf_sth", "rtsp__ct"], "protocol_mask": ["protocol__mask", "protolution_mask", "protolution_Mask", "protocol_ask", "protolution_ask", "protchannel_count", "protchannel_delay", "protocol_delay", "protocol_pad", "protocol_Mask", "protocol__depth", "protocol_depth", "protocol_count", "protchannel_mask", "protocol__pad"], "transport": ["traports", "Transmission", "transocol", "transfercode", "ransport", "transpose", " transcode", "transferocol", "ranscode", "Transports", " transports", "ranspose", "Transpose", "transferpose", " transpose", "transcode", "transmission", "transferport", "Transport", " transmission", "transports", "traport", " transocol", "trapose", "tramission", "ransocol"], "fmt": ["cfkt", "cfmt", "cfm", "fm", " fkt", "fMT", " fm", "Fmt", " fMT", "fkt", "Fm", "Fkt", "FMT", "cfMT"], "buf": ["map", "uf", "cast", "off", "pad", "Buffer", "buffer", "pool", "bind", "feed", "method", "data", "block", "cap", "ba", "stream", "ref", "xff", "bag", "func", "seq", "box", "buff", "alloc", "br"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                                int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong phys;\n\n    int prot;\n\n\n\n    /* XXX: implement mmu */\n\n\n\n    phys = address;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n\n\n    return tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                        phys & TARGET_PAGE_MASK, prot,\n\n                        mmu_idx, is_softmmu);\n\n}\n", "idx": 20238, "substitutes": {"env": ["chal", "inet", "eu", "txt", "forge", "erv", "et", "enable", "conn", "eni", "np", "enc", "osc", "db", "eng", "dict", "equ", "iss", "ef", "ec", "ens", "qt", "esi", "exc", "ext", "ea", "profile", "conf", "det", "esm", "inv", "energy", "priv", "en", "viron", "ev", "fi", "e", "environment", "pect"], "address": ["resource", "interface", "output", "length", "number", "route", "mode", "type", "instance", "prefix", "array", "uri", "primary", "inter", "ip", "position", "base", "message", "localhost", "config", "memory", "pair", "state", "path", "index", "padding", "addr", "data", "ace", "target", "object", "pointer", "socket", "enter", "Address", "ptr", "attr", "area", "shape", "network", "port", "reference", "device", "master", "attribute", "host", "offset"], "rw": ["resource", "src", "proc", "worker", "wp", "work", "prefix", "conn", "wh", "sw", "lr", "hw", "nn", "slave", "padding", "rx", "w", "nr", "nw", "row", "ww", "wo", "password", "RW", "mode"], "mmu_idx": ["mmu_idsy", "mmu_idy", "mmu_idsc", "mmu_Idx", "mmu_idz", "mmu_indexx", "mmu_indexy", "mmu_pidx", "mmu_pidxs", "mmu_indexz", "mmu_idc", "mmu_idsz", "mmu_Idxs", "mmu_pidz", "mmu_idsx", "mmu_Idz", "mmu_idxs", "mmu_indexc", "mmu_pidc", "mmu_Idc"], "is_softmmu": ["is_softmmc", "is_hardmmu", "is_softMMcu", "is_softcmnu", "is_softmnu", "is_hardmmc", "is_hardmme", "is_softMMe", "is_softmmtu", "is_softmmnu", "is_hardmmcu", "is_softmemcu", "is_softmme", "is_softmmcu", "is_softmtu", "is_softMMc", "is_softcmcu", "is_softmemc", "is_softcmu", "is_hardmmtu", "is_softmu", "is_softMMu", "is_hardmmnu", "is_softmcu", "is_softmemu", "is_softcmtu", "is_softmeme"], "phys": ["class", "interface", "tech", "sys", "number", "proc", "intel", "tp", "type", "pty", "temp", "prefix", "proxy", "physical", "conn", "rel", "primary", "phase", "base", "config", "state", "path", "platform", "status", "padding", "addr", "data", "phone", "target", "params", "stat", "pre", "ref", "bridge", "sync", "p", "cpu", "pos", "pointer", "socket", "ptr", "eth", "prop", "phy", "attr", "port", "device", "Phys", "rot", "spec", "part", "host", "info"], "prot": ["server", "Prot", "pt", "mode", "secondary", "type", "prefix", "gap", "primary", "col", "len", "config", "reset", "path", "platform", "protected", "status", "padding", "mult", "addr", "data", "cert", "pre", "ext", "att", "cont", "ref", "format", "fp", "channel", "pos", "period", "pointer", "ptr", "nat", "transfer", "prop", "phy", "seq", "rot", "part", "sync", "offset"]}}
