{"project": "FFmpeg", "commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "target": 1, "func": "static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n\n{\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    while(buf + 48 <= buf_end) {\n\n        int dir_length, name_size, first_sector, depth;\n\n        uint64_t file_length;\n\n        const uint8_t *name;\n\n        if (ff_guidcmp(buf, dir_entry_guid)) {\n\n            av_log(s, AV_LOG_ERROR, \"unknown guid \"FF_PRI_GUID\", expected dir_entry_guid; \"\n\n                   \"remaining directory entries ignored\\n\", FF_ARG_GUID(buf));\n\n            break;\n\n        }\n\n        dir_length  = AV_RL16(buf + 16);\n\n        file_length = AV_RL64(buf + 24);\n\n        name_size   = 2 * AV_RL32(buf + 32);\n\n        if (buf + 48 + name_size > buf_end) {\n\n            av_log(s, AV_LOG_ERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\");\n\n            break;\n\n        }\n\n        first_sector = AV_RL32(buf + 40 + name_size);\n\n        depth        = AV_RL32(buf + 44 + name_size);\n\n\n\n        /* compare file name; test optional null terminator */\n\n        name = buf + 40;\n\n        if (name_size >= filename_size &&\n\n            !memcmp(name, filename, filename_size) &&\n\n            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))\n\n            return wtvfile_open_sector(first_sector, file_length, depth, s);\n\n\n\n        buf += dir_length;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12273, "substitutes": {"s": ["client", "storage", "o", "sv", "session", "options", "south", "v", "e", "u", "server", "ds", "sys", "si", "ss", "ssl", "service", "m", "an", "sq", "gs", "sf", "sn", "a", "g", "es", "self", "sup", "n", "os", "spec", "stats", "is", "c", "http", "sg", "ns", "p", "b", "aws", "sets", "sl", "f", "src", "sb", "ses", "js", "w", "parser", "settings", "r", "services", "socket", "t", "ops"], "buf": ["fp", "uno", "uf", "pkg", "bed", "cf", "cb", "fb", "uu", "seq", "rb", "cur", "utf", "box", "src", "sb", "uint", "auc", "len", "brace", "batch", "aka", "um", "tmp", "front", "uber", "tab", "loop", "cmd", "job", "path", "header", "queue", "offset", "fd", "pool", "num", "context", "cat", "mount", "fam", "buffer", "cas", "ru", "grab", "la", "count", "bc", "feat", "ff", "bu", "wb", "cap", "pg", "cmp", "runner", "bg", "rc", "usr", "buff", "home", "ph", "Buff", "chrom", "ha", "alloc", "br", "ffff", "length", "pad", "vec", "uc", "config", "proc", "ctx", "feed", "su", "cp", "coord", "begin", "bag", "prop", "ab", "port", "loader", "gb", "loc", "img", "pb", "cv"], "buf_size": ["buflexlarge", "bufaclength", "buflexsize", "buf_small", "path_end", "buffer_shape", "bufallend", "buflexend", "buf_length", "bufalllarge", "buf_shape", "pathallsize", "buffer_size", "bufallsmall", "bufacshape", "pathalllarge", "buflexsmall", "buf_large", "bufacsize", "path_small", "bufallsize", "buffer_length", "path_size", "path_large", "buffer_end", "bufacend", "pathallend", "pathallsmall"], "filename": ["fp", "binary", "prefix", "file", "ename", "Filename", "fn", "package", "length", "size", "wb", "uri", "username", "nil", "path", "directory", "fd", "sf", "sn", "url", "config", "un", "location", "rb", "ame", "NAME", "memory", "description", "b", "f", "buffer", "names", "nm", "text", "number"], "filename_size": ["file_size", "filename_end", "filename128width", "directory_width", "directory_size", "filename_sized", "username_term", "filename_term", "filename128size", "filename_Size", "file_sized", "name_Size", "name_length", "filename_length", "filename_day", "username_end", "file_day", "filename128end", "directory_end", "username_scale", "directory_name", "filename_width", "filename128name", "file_scale", "name_sized", "filename_scale", "filename_name", "name_scale", "username_size"], "buf_end": ["bufenoffset", "buf0size", "buf_enter", "buf_ent", "buf67ended", "room_size", "fd_enter", "room_end", "buf_offset", "bufenenter", "fd_offset", "buf67add", "buf_add", "bufenstart", "fd_end", "buf0ent", "buf_e", "buf_stop", "buf_ended", "bufenend", "buf_start", "room_ent", "rb_end", "rb_ended", "buf0end", "room_stop", "rb_e", "buf67end", "buf67e", "rb_add", "buf0stop", "fd_start"], "dir_length": ["dir_len", "dir__len", "dir_number", "dir___length", "dir54duration", "dir64len", "dir___depth", "dir_weight", "dir___time", "dir__size", "dir_scale", "dir_time", "dir_duration", "file_len", "diracweight", "dir___size", "dir__length", "dir__number", "diracduration", "diraclength", " dir_weight", "file_size", " dir_duration", "dir64length", "dir64number", "dir64size", "dir_depth", "diracscale", "file_time", "dir_size", "dir54length", "dir54weight", " dir_scale", "file_number", "dir54scale", "file_depth"], "name_size": ["nameploc", "uri_len", "namepscale", "name_small", "uri_fee", "file_size", "prefix_address", "name___size", "filename_member", "uri___name", "namepsize", "username_length", "username___length", "nameladdress", "name_number", "name_loc", "name___number", "prefix_offset", "name___fee", "uri___len", "filename_loc", "name___name", "nameloffset", "name_mode", "name_len", "name_offset", "uri_size", "name_length", "name___scale", "file_width", "username___scale", "name_type", "filename_length", "namellength", "uri___fee", "username___size", "namelsize", "username___sized", "name_fee", "name___length", "file_type", "username_scale", "prefix_size", "username_sized", "name___sized", "namepmember", "name_name", "name_member", "file_scale", "name___len", "name_sized", "filename_scale", "uri_name", "filename_number", "file_mode", "file_small", "prefix_length", "name_width", "name_scale", "name_address", "username_size", "uri___size"], "first_sector": ["first_context", "first_section", "firstSubsection", "firstallsection", "firstallsector", "first_part", "last_context", "last_location", "first_storage", "first_location", "last_sector", "last_part", "firstSubpart", "last_storage", "firstSubsector", "firstallpart", "firstalllocation", "last_section", "firstSubcontext"], "depth": ["debug", "d", "height", "dr", "der", "position", "deep", "distance", "dist", "count", "mode", "dir", "feature", "package", "length", "size", "path", "level", "dep", "padding", "slice", "time", "ptr", "dim", "scale", "parent", "progress", "details", "context", "weight", "side", "priority", "layer", "Depth", "type", "scope", "order", "rate", "rank", "len", "stack"], "file_length": ["file_capacity", "file\u00b7size", "filepstart", "file\u00b7length", "name_or", "file_len", "file_start", "file_offset", "file_or", "dir_offset", "file_size", "file\u00b7or", "name_depth", "name_capacity", "filepoffset", "filepsize", "dir_size", "name_len", "file_depth", "fileplength", "dir_start", "name_length", "file\u00b7depth"], "name": ["prefix", "part", "large", "session", "file", "connection", "data", "nam", "image", "package", "base", "size", "username", "alias", "path", "space", "Name", "vision", "with", "time", "comment", "url", "parent", "up", "channel", "word", "key", "block", "ame", "n", "id", "NAME", "mem", "node", "home", "no", "memory", "description", "ident", "info", "type", "common", "member", "names", "option", "nm", "number", "span"]}}
{"project": "FFmpeg", "commit_id": "527f89e05922e840083ac6d49eeb838b1e350dd4", "target": 1, "func": "static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)\n\n{\n\n    int e, b, k;\n\n\n\n    INTFLOAT (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;\n\n    INTFLOAT (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;\n\n    INTFLOAT (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;\n\n    INTFLOAT (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;\n\n    int8_t *opd_hist = ps->opd_hist;\n\n    int8_t *ipd_hist = ps->ipd_hist;\n\n    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;\n\n    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;\n\n    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;\n\n    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;\n\n    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;\n\n    TABLE_CONST INTFLOAT (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;\n\n\n\n    //Remapping\n\n    if (ps->num_env_old) {\n\n        memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n\n        memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n\n        memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n\n        memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n\n        memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n\n        memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n\n        memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n\n        memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n\n    }\n\n\n\n    if (is34) {\n\n        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (!ps->is34bands_old) {\n\n            map_val_20_to_34(H11[0][0]);\n\n            map_val_20_to_34(H11[1][0]);\n\n            map_val_20_to_34(H12[0][0]);\n\n            map_val_20_to_34(H12[1][0]);\n\n            map_val_20_to_34(H21[0][0]);\n\n            map_val_20_to_34(H21[1][0]);\n\n            map_val_20_to_34(H22[0][0]);\n\n            map_val_20_to_34(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    } else {\n\n        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (ps->is34bands_old) {\n\n            map_val_34_to_20(H11[0][0]);\n\n            map_val_34_to_20(H11[1][0]);\n\n            map_val_34_to_20(H12[0][0]);\n\n            map_val_34_to_20(H12[1][0]);\n\n            map_val_34_to_20(H21[0][0]);\n\n            map_val_34_to_20(H21[1][0]);\n\n            map_val_34_to_20(H22[0][0]);\n\n            map_val_34_to_20(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    }\n\n\n\n    //Mixing\n\n    for (e = 0; e < ps->num_env; e++) {\n\n        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {\n\n            INTFLOAT h11, h12, h21, h22;\n\n            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];\n\n            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];\n\n            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];\n\n            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];\n\n\n\n            if (!PS_BASELINE && ps->enable_ipdopd && b < NR_IPDOPD_BANDS[is34]) {\n\n                //The spec say says to only run this smoother when enable_ipdopd\n\n                //is set but the reference decoder appears to run it constantly\n\n                INTFLOAT h11i, h12i, h21i, h22i;\n\n                INTFLOAT ipd_adj_re, ipd_adj_im;\n\n                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];\n\n                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];\n\n                INTFLOAT opd_re = pd_re_smooth[opd_idx];\n\n                INTFLOAT opd_im = pd_im_smooth[opd_idx];\n\n                INTFLOAT ipd_re = pd_re_smooth[ipd_idx];\n\n                INTFLOAT ipd_im = pd_im_smooth[ipd_idx];\n\n                opd_hist[b] = opd_idx & 0x3F;\n\n                ipd_hist[b] = ipd_idx & 0x3F;\n\n\n\n                ipd_adj_re = AAC_MADD30(opd_re, ipd_re, opd_im, ipd_im);\n\n                ipd_adj_im = AAC_MSUB30(opd_im, ipd_re, opd_re, ipd_im);\n\n                h11i = AAC_MUL30(h11,  opd_im);\n\n                h11  = AAC_MUL30(h11,  opd_re);\n\n                h12i = AAC_MUL30(h12,  ipd_adj_im);\n\n                h12  = AAC_MUL30(h12,  ipd_adj_re);\n\n                h21i = AAC_MUL30(h21,  opd_im);\n\n                h21  = AAC_MUL30(h21,  opd_re);\n\n                h22i = AAC_MUL30(h22,  ipd_adj_im);\n\n                h22  = AAC_MUL30(h22,  ipd_adj_re);\n\n                H11[1][e+1][b] = h11i;\n\n                H12[1][e+1][b] = h12i;\n\n                H21[1][e+1][b] = h21i;\n\n                H22[1][e+1][b] = h22i;\n\n            }\n\n            H11[0][e+1][b] = h11;\n\n            H12[0][e+1][b] = h12;\n\n            H21[0][e+1][b] = h21;\n\n            H22[0][e+1][b] = h22;\n\n        }\n\n        for (k = 0; k < NR_BANDS[is34]; k++) {\n\n            LOCAL_ALIGNED_16(INTFLOAT, h, [2], [4]);\n\n            LOCAL_ALIGNED_16(INTFLOAT, h_step, [2], [4]);\n\n            int start = ps->border_position[e];\n\n            int stop  = ps->border_position[e+1];\n\n            INTFLOAT width = Q30(1.f) / ((stop - start) ? (stop - start) : 1);\n\n#if USE_FIXED\n\n            width <<= 1;\n\n#endif\n\n            b = k_to_i[k];\n\n            h[0][0] = H11[0][e][b];\n\n            h[0][1] = H12[0][e][b];\n\n            h[0][2] = H21[0][e][b];\n\n            h[0][3] = H22[0][e][b];\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n            //Is this necessary? ps_04_new seems unchanged\n\n            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {\n\n                h[1][0] = -H11[1][e][b];\n\n                h[1][1] = -H12[1][e][b];\n\n                h[1][2] = -H21[1][e][b];\n\n                h[1][3] = -H22[1][e][b];\n\n            } else {\n\n                h[1][0] = H11[1][e][b];\n\n                h[1][1] = H12[1][e][b];\n\n                h[1][2] = H21[1][e][b];\n\n                h[1][3] = H22[1][e][b];\n\n            }\n\n            }\n\n            //Interpolation\n\n            h_step[0][0] = AAC_MSUB31_V3(H11[0][e+1][b], h[0][0], width);\n\n            h_step[0][1] = AAC_MSUB31_V3(H12[0][e+1][b], h[0][1], width);\n\n            h_step[0][2] = AAC_MSUB31_V3(H21[0][e+1][b], h[0][2], width);\n\n            h_step[0][3] = AAC_MSUB31_V3(H22[0][e+1][b], h[0][3], width);\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n                h_step[1][0] = AAC_MSUB31_V3(H11[1][e+1][b], h[1][0], width);\n\n                h_step[1][1] = AAC_MSUB31_V3(H12[1][e+1][b], h[1][1], width);\n\n                h_step[1][2] = AAC_MSUB31_V3(H21[1][e+1][b], h[1][2], width);\n\n                h_step[1][3] = AAC_MSUB31_V3(H22[1][e+1][b], h[1][3], width);\n\n            }\n\n            ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd](\n\n                l[k] + start + 1, r[k] + start + 1,\n\n                h, h_step, stop - start);\n\n        }\n\n    }\n\n}\n", "idx": 12278, "substitutes": {"ps": ["hs", "mp", "files", "ports", "ins", "ples", "pe", "changes", "als", "PS", "phys", "per", "ras", "pt", "ups", "pos", "ts", "pc", "parts", "params", "pp", "docs", "ss", "wp", "pg", "sp", "pins", "posts", "times", "cases", "ep", "gs", "plugins", "clips", "pps", "bs", "pr", "amps", "pers", "ips", "ges", "details", "pa", "Ps", "ppa", "pres", "pse", "pes", "s", "p", "eps", "ph", "qs", "ns", "tests", "aps", "lines", "tx", "ms", "gp", "ls", "services", "hes", "powers", "points", "ops"], "l": ["o", "kl", "bl", "v", "li", "ol", "ll", "fl", "lt", "L", "lu", "m", "el", "lr", "lc", "lp", "ln", "c", "ul", "wl", "sl", "f", "pl", "rl", "ls", "j", "lo"], "r": ["ru", "rs", "ar", "R", "rh", "rt", "ro", "res", "m", "lr", "nr", "rc", "g", "rb", "rec", "q", "rx", "ri", "sr", "re", "ir", "cr", "err", "er", "rl", "rg", "j"], "is34": [" is94", " is35", "C533", "is533", "C94", "C35", "id533", " is533", "id35", " is12", "id12", "is12", "is94", "is35", "id94", "C12"], "e": ["en", "d", "o", "E", "pe", "v", "u", "fe", "end", "y", "m", "ae", "g", "z", "n", "c", "x", "h", "i", "p", "f", "w", "j", "t"], "b": ["d", "o", "v", "B", "y", "lb", "a", "bs", "g", "n", "bi", "c", "bp", "i", "h", "s", "bb", "p", "f", "sb", "ab", "w", "j", "aa"], "k": ["o", "v", "y", "m", "g", "ck", "z", "ks", "n", "ik", "K", "x", "q", "i", "h", "ki", "p", "s", "ak", "f", "w", "j", "t", "sk"], "opd_hist": ["opd_history", "opds_hist", "opds_path", "opds_history", "opds_master", "opd_orig", "opd_seq", "opds_seq", "opds_orig", "opd_path", "opd_master"], "ipd_hist": ["ipds_Hist", "ipd_Hist", "ipds_reg", "ipd_history", "ipds_conf", "ipd__conf", "ipd__hist", "ipd_conf", "ipd__history", "ipds_history", "ipds_dict", "ipd_dict", "ipds_hist", "ipd__dict", "ipd_reg"], "iid_mapped_buf": ["iid_mapping_buf", "iid_mapping_buff", "iid_mapped_buff", "iid_mapping_buffer", "iid_mappedallbuff", "iid_mapping_map", "iid_mappedallmap", "iid_mached_uf", "iid_mappedallbuffer", "iid_mapped_buffer", "iid_mached_buff", "iid_mappedallbuf", "iid_mached_conv", "iid_mached_buf", "iid_mapped_map", "iid_mapped_uf", "iid_mapped_conv"], "PS_MAX_NUM_ENV": ["PS_MAX_NUMIPenV", "PS_MAX_NUM_ENSF", "PS_MAX_NUM_EnH", "PS_MAX_NUM_EnCH", "PS_MAX_NUM_enV", "PS_MAX_NUM_INVICE", "PS_MAX_NUM_ENSV", "PS_MAX_NUM_enC", "PS_MAX_NUMIPENC", "PS_MAX_NUM_EnC", "PS_MAX_NUM_ENSU", "PS_MAX_NUM_ENP", "PS_MAX_NUM_ENCH", "PS_MAX_NUM_ENSVICE", "PS_MAX_NUM_INF", "PS_MAX_NUM_ENH", "PS_MAX_NUM_ETVs", "PS_MAX_NUM_PNVs", "PS_MAX_NUM_ETV", "PS_MAX_NUM_INQ", "PS_MAX_NUMIPenv", "PS_MAX_NUMIPENv", "PS_MAX_NUM_env", "PS_MAX_NUM_EnF", "PS_MAX_NUM_ENU", "PS_MAX_NUM_PNH", "PS_MAX_NUM_EnP", "PS_MAX_NUM_INC", "PS_MAX_NUM_ENQ", "PS_MAX_NUM_ENSC", "PS_MAX_NUM_ENVICE", "PS_MAX_NUM_Env", "PS_MAX_NUM_EnQ", "PS_MAX_NUM_ENC", "PS_MAX_NUM_EnV", "PS_MAX_NUM_ETv", "PS_MAX_NUM_ENSCH", "PS_MAX_NUMIPenC", "PS_MAX_NUM_PNV", "PS_MAX_NUM_ENVs", "PS_MAX_NUMIPENU", "PS_MAX_NUMIPENV", "PS_MAX_NUM_DENVICE", "PS_MAX_NUM_EnU", "PS_MAX_NUM_ENF", "PS_MAX_NUM_INV", "PS_MAX_NUM_ENSP", "PS_MAX_NUM_DENV", "PS_MAX_NUM_DENF", "PS_MAX_NUMIPenU", "PS_MAX_NUM_INv", "PS_MAX_NUM_EnVs", "PS_MAX_NUM_PNv", "PS_MAX_NUM_ENSv", "PS_MAX_NUM_enQ", "PS_MAX_NUM_ENSQ", "PS_MAX_NUM_INU", "PS_MAX_NUM_DENv", "PS_MAX_NUM_ENv", "PS_MAX_NUM_ETH", "PS_MAX_NUM_INP", "PS_MAX_NUM_enU"], "icc_mapped_buf": ["icc_mapping_cb", "icc_mached_buf", "icc_mapping_buf", "icc_mapped_cb", "icc_mapped_map", "icc_mached_cb", "icc_mapping_buff", "icc_mapped_buff", "icc_mapped_uf", "icc_mappedfbuf", "icc_mapping_uf", "icc_mached_map", "icc_mached_buff", "icc_mappedfmap", "icc_mappedfcb", "icc_mappedfbuff"], "ipd_mapped_buf": ["ipd_mached_buf", "ipd_mapped_buffer", "ipd_mapped_map", "ipd_mapped_uf", "ipd_mapping_uf", "ipd_mapped_cb", "ipd_mapped_buff", "ipd_mached_buff", "ipd_mapping_buffer", "ipd_mached_map", "ipd_mached_cb", "ipd_mapping_buff", "ipd_mapping_buf"], "opd_mapped_buf": ["opd_mapped_cap", "opd_mached_cap", "opd_mached_cb", "opd_mached_buff", "opd_mapped_cb", "opd_mapped_buff", "opd_mached_buf", "opd_mached_buffer", "opd_mapped_buffer"], "iid_mapped": ["iid_happing", "iid_smached", "iid_mraped", "iid_hached", "iid_mached", "iid_happed", "iid_smraped", "iid_smapping", "iid_hraped", "iid_Mapping", "iid_mapping", "iid_Mapped", "iid_Mraped", "iid_Mached", "iid_smapped"], "icc_mapped": ["icc__muted", "icc_waken", "icc_watted", "icc__cmatted", "icc_cmuted", "icc_cmaken", "icc_mduted", "icc_maken", "icc__cmuted", "icc__mapped", "icc_mdatted", "icc__cmaken", "icc__cmapped", "icc_muted", "icc_wuted", "icc_wapped", "icc_cmatted", "icc_mdapped", "icc_matted", "icc_cmapped", "icc__maken", "icc_mdaken", "icc__matted"], "ipd_mapped": ["ipd_movered", "ipd_bapped", "ipd_Mapped", "ipd_wovered", "ipd_bovered", "ipd_matched", "ipd_wached", "ipd_bached", "ipd_Movered", "ipd_batched", "ipd_Mached", "ipd_wapped", "ipd_watched", "ipd_mached", "ipd_Matched"], "opd_mapped": ["opd_amached", "opd_maped", "opd_amap", "opd_rmapped", "opd_amapped", "opd_Mached", "opd_amaped", "opd_Maped", "opd_rmached", "opd_map", "opd_mached", "opd_Map", "opd_Mapped", "opd_rmaped", "opd_rmap"], "INTFLOAT": ["INTFLPOATS", "INTALLoAT", "INTFLOREat", "INTFLTEAT", "INTFTOATING", "INTFLoAT", "INTFlEINT", "INTHLFOATS", "INTFLOOATS", "INTFLOATING", "INTFlEAT", "INTFLTATH", "INTFLEINT", "INTFROHat", "INTFlEATH", "INTFLMOATS", "INTFLOARD", "INTALLOATS", "INTALLOATER", "INTFLPOAR", "INTFROHARD", "INTFlEATS", "INTFLTEATS", "INTFLROATS", "INTHLFOAT", "INTFLoAR", "INTFLROat", "INTALLOAT", "INTFlOATH", "INTFROARD", "INTFTMOATS", "INTFLOOAR", "INTFLPOAT", "INTFTOAT", "INTFLTATS", "INTFTOat", "INTFLOREAT", "INTFLOOATH", "INTFlOINT", "INTFLROAT", "INTFLOOATER", "INTFLOOAT", "INTFTMOATING", "INTFLOATER", "INTHLOATS", "INTFLROATING", "INTFLFOAR", "INTFROHATING", "INTHLFOATER", "INTFLMOat", "INTFLFOATS", "INTFLFOATT", "INTALLoATS", "INTHLOATER", "INTFLEATH", "INTFLPOATER", "INTFROAT", "INTALLoAR", "INTFLROARD", "INTFTMOat", "INTFLFOAT", "INTALLoATER", "INTFLOATS", "INTFLOREARD", "INTFLOREATING", "INTFLoATER", "INTFLMOATING", "INTFLOATH", "INTFTOATS", "INTFLoATING", "INTFROATING", "INTFLOHAT", "INTFLTEATER", "INTFTMOAT", "INTFLTEAR", "INTFLOHARD", "INTFLTAT", "INTALLOAR", "INTFROHAT", "INTFLROAR", "INTHLFOAR", "INTFROat", "INTFLOINT", "INTFLFOATER", "INTFLOATT", "INTHLOAR", "INTFLOHATING", "INTFLoATS", "INTHLOAT", "INTFLOat", "INTFLOAR", "INTFLTINT", "INTFLoATT", "INTFLOOINT", "INTFLEATS", "INTFlOAT", "INTFLROATT", "INTFLMOAT", "INTFLOHat", "INTFLoat", "INTFLEAT", "INTFlOATS"]}}
{"project": "qemu", "commit_id": "04f8c053cca9c329eebb761f3a1ffef3d349b84c", "target": 1, "func": "static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    int err;\n\n    QObject *obj;\n\n    QDict *input, *args;\n\n    const mon_cmd_t *cmd;\n\n    Monitor *mon = cur_mon;\n\n    const char *cmd_name, *info_item;\n\n\n\n    args = NULL;\n\n\n\n    obj = json_parser_parse(tokens, NULL);\n\n    if (!obj) {\n\n        // FIXME: should be triggered in json_parser_parse()\n\n        qerror_report(QERR_JSON_PARSING);\n\n        goto err_out;\n\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        qobject_decref(obj);\n\n        goto err_out;\n\n    }\n\n\n\n    input = qobject_to_qdict(obj);\n\n\n\n    mon->mc->id = qdict_get(input, \"id\");\n\n    qobject_incref(mon->mc->id);\n\n\n\n    obj = qdict_get(input, \"execute\");\n\n    if (!obj) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n\n    } else if (qobject_type(obj) != QTYPE_QSTRING) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\");\n\n\n    }\n\n\n\n    cmd_name = qstring_get_str(qobject_to_qstring(obj));\n\n\n\n    if (invalid_qmp_mode(mon, cmd_name)) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    }\n\n\n\n    /*\n\n     * XXX: We need this special case until we get info handlers\n\n     * converted into 'query-' commands\n\n     */\n\n    if (compare_cmd(cmd_name, \"info\")) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    } else if (strstart(cmd_name, \"query-\", &info_item)) {\n\n        cmd = monitor_find_command(\"info\");\n\n        qdict_put_obj(input, \"arguments\",\n\n                      qobject_from_jsonf(\"{ 'item': %s }\", info_item));\n\n    } else {\n\n        cmd = monitor_find_command(cmd_name);\n\n        if (!cmd || !monitor_handler_ported(cmd)) {\n\n            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n        }\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n\n\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    QDECREF(input);\n\n\n\n    err = monitor_check_qmp_args(cmd, args);\n\n    if (err < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    if (monitor_handler_is_async(cmd)) {\n\n        qmp_async_cmd_handler(mon, cmd, args);\n\n    } else {\n\n        monitor_call_handler(mon, cmd, args);\n\n    }\n\n    goto out;\n\n\n\nerr_input:\n\n    QDECREF(input);\n\nerr_out:\n\n    monitor_protocol_emitter(mon, NULL);\n\nout:\n\n    QDECREF(args);\n\n}", "idx": 12281, "substitutes": {"parser": ["fp", "prot", "json", "Parser", "mp", "xml", "tp", "jack", "reader", "worker", "pc", "conn", "server", "processor", "writer", "monkey", "lex", "state", "pd", "pool", "parse", "php", "parent", "handler", "p", "loader", "er", "manager"], "tokens": ["tokenens", "pokkens", "poken", "targens", "takers", "targets", "targkens", "tokeners", "pokens", "pargents", "tokenkens", "targers", "tokenets", "token", "tokets", "pakets", "pokers", "pakens", "takets", "paken", "takens", "pargets", "targen", "pargkens", "takents", "tokkens", "taken", "tokenents", "pakers", "pargens", "tokenen", "takkens", "pokents", "targents", "pokets", "tokers", "tokents"], "err": ["ctr", " error", "all", "resp", "e", " Err", "result", "message", "inner", "lr", "ise", "nr", "str", "rr", "error", "proc", "handler", "c", "arr", "Er", "f", "out", "load", "call", "er", "Error", "r"], "obj": ["module", "fact", "pos", "act", "cb", "obb", "output", "Object", "objects", "api", "om", "rb", "nb", "init", "dict", "ind", "js", "bo", "ocr", "j", "conn", "part", "sync", "o", "tmp", "txt", "amp", "po", "nt", "inst", "str", "org", "ns", "arr", "bj", "oa", "json", "func", "yo", "data", "jp", "fn", "clone", "att", "ob", "object", "attr", "aos", "aj", "lock", "buff", "art", "active", "coll", "out", "ref", "bm", "body", "adj", "pot", "op", "nc", "pt", "orb", "os", "ctx", "so", "bot", "p", "Obj", "utils", "img"], "input": ["client", "binary", "json", "batch", "session", "img", "list", "xml", "data", "pull", "amp", "raw", "empty", "source", "command", "param", "image", "iq", "act", "inner", "local", "reader", "output", "model", "work", "head", "element", "bin", "qa", "in", "object", "Input", "form", "unit", "config", "parent", "method", "key", "block", "arg", "id", "init", "current", "dict", "i", "q", "active", "type", "inc", "instance", "out", "child", "request", "argument", "text", "ref", "inf", "array"], "args": ["enc", "actions", "options", "Args", "data", "amp", "cs", "params", "blocks", "doc", "conf", "gs", "items", "arms", "config", "arg", "comm", "init", "extra", "ns", "cli", "kw", "vals", "arr", "flags", "acl", "msg", "call", "lang", "argument", "fields", "conn", "help"], "cmd": ["pipe", "client", "module", "ct", "session", "func", "dom", "md", "command", "op", "act", "pkg", "cfg", "cd", "cb", "cf", "Cmd", "head", "bind", "def", "kind", "cc", "dc", "help", "unk", "num", "g", "method", "ck", "comm", "vc", "id", "ctx", "init", "node", "c", "dict", "clean", "cp", "bb", "cli", "req", "cat", "cod", "cl", "name", "msg", "child", "call", "cookie", "plugin", "conn", "gn", "code"], "mon": ["module", "mm", "session", "mp", "month", "dog", "atom", "mi", "yo", "don", "md", "cm", "mos", "mic", "po", "con", "pos", "mu", "message", "mun", "pm", "bin", "mat", "mag", "wm", "db", "m", "mo", "mn", "unit", "config", "mx", "man", "key", "block", "lock", "comm", "Mon", "admin", "monitor", "mot", "col", "mr", "dm", "mc", "msg", "master", "bo", "mor", "manager", "mand", "plugin", "MON", "conn", "mons", "bm"], "cmd_name": ["cmd_nam", "cm_name", "cmdkName", "cmdDname", "cmdkNAME", "cmd_search", "cmd_key", "comm_word", "cmdDnone", "comm2num", "comm_ref", "cmdsname", "cmdXcode", "cmdUName", "comm_def", "cmd_type", "cm_code", "md_name", "cmd2key", "cmd2ref", "md_Name", "cmd2code", "cmdXspan", "cmd_Name", "command_name", "cmdvname", " cmd_Name", "comm_name", "cmd_ref", "cmdDnames", "cm_span", "cmd_named", "cmdKname", "command_type", "cmd_none", "cmd2span", "comm2name", "cmd_def", "comm_num", "command_nam", "md_NAME", "cmdksearch", "cmdvnum", "cmdsnamed", "cmXspan", "cmd_num", "cmdKcode", "md_search", "cmXname", "cmXcode", "comm_key", "md_none", "cmdNname", "cmdUword", "comm2ref", "cmdKspan", "cmd2name", "cmdsName", "cmdKalias", "cmd2num", " cmd_names", "cmd_word", "cmdvkey", "cmdNtype", "cmdsnames", "cmd_names", "cmdUname", "cmdDNAME", "comm2key", "cmdUdef", "md_names", "cmdkname", "cmdvref", " cmd_named", "cmd_alias", "cmdXalias", "cmdknone", "cmd_id", "cm_alias", "cmdNnam", "cmd_code", "cmXalias", "comm_Name", " cmd_id", "cmdXname", "cmdNnames", "command_names", "cmd2alias", "cmd_span", "cmdknames", "cmd_NAME"], "info_item": ["infoWchannel", " info_value", "info_value", "info_Item", "info_page", "infoayname", "infoayItem", "infoWname", "infoaychannel", "info_name", "infoestinfo", "infoayitem", "infoWitem", " info_page", "infoayvalue", "info_channel", "info_info", " info_info", " info_name", "infoayinfo", " info_channel", "infoestvalue", "infoestitem", "infoaypage", "infoWpage", " info_Item"]}}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 12305, "substitutes": {"avctx": ["avcmp", "Avpc", " avpc", "AVcontext", "Avcontext", "avcmd", "afcontext", "ajcf", "avpc", "avecf", " avcf", " avcontext", "vercf", "avcca", "afconfig", "vercca", "Avctx", "AVcmp", "avconfig", "evctx", "avecu", " avcci", "avca", " avcca", " avcu", "avepkg", "avcf", "avectx", "evcu", "afcf", "ajcu", "abcmp", "abctx", "abcu", "abconfig", " avca", "avpkg", "avecci", "avcu", "verctx", "ajpkg", "AVpc", "Avca", "avcci", "afcmp", "afctx", "abcontext", "AVctx", "afcca", "ajcmd", "AVcf", "AVcu", "AVca", "AVconfig", "aveca", "evcf", "afcu", "AVcmd", "vercontext", "abpkg", "abcf", "ajcmp", "ajcontext", "avecontext", "afcmd", "avcontext", "evcci", "ajctx"], "s": ["session", "v", "ts", "states", "sys", "si", "se", "m", "sec", "xs", "self", "n", "spec", "qs", "src", "sb", "js", "services", "t", "ps", "sync", "fs", "o", "e", "cs", "parts", "ss", "ssl", "new", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "settings", "storage", "us", "sa", "ds", "service", "stats", "http", "ses", "sym", "S", "comments", "d", "sv", "rs", "south", "server", "space", "full", "g", "es", "ks", "os", "ctx", "su", "args", "p", "b", "aws", "sets", "f", "ls", "opens", "conf"], "i": ["adi", "it", "d", "ie", "di", "gi", "ini", "iu", "mi", "fi", "jp", "v", "multi", "li", "e", "xi", "u", "l", "pi", "uri", "si", "vi", "y", "ai", "ui", "m", "api", "a", "c", "k", "ix", "z", "n", "eni", "ci", "io", "id", "mini", "bi", "qi", "ip", "x", "ij", "oi", "info", "ji", "ki", "p", "index", "ri", "b", "ni", "f", "start", "zi", "ind", "ii", "I", "yi"], "j": ["adj", "ie", "o", "di", "dj", "J", "jp", "v", "li", "jl", "e", "xi", "obj", "u", "l", "job", "note", "si", "y", "m", "jo", "aj", "g", "pr", "k", "z", "jj", "ix", "n", "key", "ch", "kj", "qi", "q", "ij", "h", "ji", "p", "index", "b", "name", "ind", "js", "bj", "oj", "uj", "je", "ii", "jit", "ja", "jc"], "histograms": ["gregambers", "thograms", "historyrams", "rhures", " histographies", "histambers", "thobs", "historyures", "rhographies", "historyambers", "rhores", " histores", "historyographies", "gregograms", "thros", "histographies", " histambers", "gregrams", "historyros", "histrams", " histrams", "gregographies", " histures", "rhograms", "historyobs", "histores", "historyograms", " histros", "thambers", "histobs", "histures", "histros", " histobs", "historyores"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n\n{\n\n    int dx, dy, dw, dh;\n\n    int w_prev;\n\n    int w_best = 0, h_best = 0;\n\n\n\n    w_prev = w;\n\n\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n\n            break;\n\n        }\n\n\n\n        for (dx = x + dw; dx < x + w_prev;) {\n\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n\n                break;\n\n            }\n\n            dx += dw;\n\n        }\n\n\n\n        w_prev = dx - x;\n\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n\n            w_best = w_prev;\n\n            h_best = dy + dh - y;\n\n        }\n\n    }\n\n\n\n    *w_ptr = w_best;\n\n    *h_ptr = h_best;\n\n}\n", "idx": 12307, "substitutes": {"vs": ["ps", "hs", "fs", "sv", "ports", "rs", "verts", "styles", "v", "ys", "cs", "otes", "ov", "ds", "states", "ss", "vers", "state", "gs", "xs", "bs", "obs", "px", "fps", "ils", "sts", "iss", "ums", "stats", "acs", "forces", "ns", "s", "blogs", "vals", "views", "kins", "vg", "vas", "sb", "ms", "las", "VS", "vr", "ls", "services", "env", "vp", "lbs", "ops", "cv"], "x": ["d", "t", "v", "du", "e", "pos", "u", "xi", "l", "wd", "work", "yx", "wy", "m", "xy", "ady", "q", "vy", "xx", "xs", "xp", "px", "up", "z", "ix", "wx", "n", "ch", "xd", "id", "win", "xf", "ey", "c", "i", "ww", "hi", "rx", "p", "index", "ax", "ex", "b", "on", "dd", "fx", "hy", "f", "tx", "xxx", "xc", "X", "yi", "wa"], "y": ["ya", "d", "o", "ay", "ky", "ty", "yn", "yo", "v", "ys", "ry", "iy", "e", "yt", "l", "ny", "wy", "xy", "zy", "ym", "vy", "z", "n", "yd", "ch", "ey", "c", "i", "hi", "yah", "q", "p", "yu", "b", "cy", "hy", "Y", "j", "yy", "ye", "sy", "oy", "py", "t", "sky", "yi", "yl"], "w": ["d", "wh", "ew", "rw", "v", "u", "l", "wd", "wb", "iw", "ow", "W", "hw", "aw", "z", "n", "win", "ww", "weight", "i", "wt", "max", "p", "we", "b", "sw", "wn", "nw", "fw", "wa"], "h": ["hs", "d", "height", "hop", "v", "e", "u", "rh", "end", "l", "hd", "ht", "hm", "m", "gh", "bh", "g", "z", "k", "n", "sh", "H", "c", "hi", "q", "i", "p", "ph", "b", "hy", "f", "hor", "th", "j", "r", "t"], "color": ["normal", "cre", "lace", "gl", "colored", "ion", "opal", "cu", "ol", "source", "black", "size", "style", "bin", "resource", "border", "loc", "colour", "bg", "rc", "lc", "roy", "Color", "ac", "cor", "id", "win", "c", "col", "type", "roman", "ors", "pal", "blue", "gray", "name", "olor", "light", "gb", "white", "ori", "term", "COLOR", "alpha", "background", "cell", " colors", "number"], "w_ptr": ["w_dest", "wa_dest", "wPrt", "w_last", "w_pointer", "sw___ptr", "w_alloc", "wa_pointer", "w___rt", "wa_ptr", "w___last", "sw_ptr", "sw_best", "sw_last", "sw___best", "sw_rt", "w___best", "w_rt", "sw___last", "wPptr", "w_best", "w___ptr", "wPbest", "wPlast", "wa_alloc", "sw___rt"], "h_ptr": ["h_thread", "happptr", " h_best", "h_best", "happcur", "w_pointer", "happbest", "w_src", "h_src", " h_cur", " h_grad", "happgrad", "w_thread", "h_pointer", "h_cur", "h_grad"], "dx": ["wh", "d", "di", "ud", "zx", "dj", "dt", "ty", "xe", "dom", "quad", "du", "dist", " Dy", "xi", "wd", "ds", "wy", "dc", " dd", " d", "xy", " DX", "zy", "ady", "xx", "dim", "xp", "xs", "dl", "up", "px", "z", "ix", "wx", "sup", "xd", "ci", "ctx", "ww", "rx", "su", "hi", " dow", "ax", "dd", " delta", "ex", "fx", "tx", "dra", "dp", "zi", "diff", "dq", "eddy", "nw", "xc", "loc", "xa", " dim"], "dy": ["phy", "d", "di", "ud", "dj", "dt", "ty", "dom", "idy", "du", "md", "distance", "dist", "ld", "dir", "xi", " Dy", "li", "fy", "wd", "hd", "dat", "ds", "ny", "did", "wy", "db", "die", "lon", "xy", "ady", "zy", "vy", "dim", "dn", "dl", "ded", "z", "yd", "xd", "ey", "phi", "ww", "hi", "dd", "b", "ni", "hy", "dra", "dm", "zi", "dq", "eddy", "yy", "py", "j", "ye", "dad", "yi"], "dw": ["dsw", "adew", " dws", "fW", "ddx", "dr", "Dwd", "dW", "dwa", "cdw", "pew", "adwd", "adW", "dsr", "dsws", "adr", "sdwd", "dew", "Dwa", " dW", "fh", "ldw", "dsh", "pw", "ldew", "Dw", "adx", "px", "cdew", "ddw", "cdwd", "adh", "ldW", "sdws", "sdh", "cdwa", "ddws", "dws", " dr", "dwd", " dwa", "ddh", "sdw", "fx", "ddW", "ddew", "ldx", "pws", "ldh", " dwd", "Dew", " dew", "fw", "adws", "adw"], "dh": ["phy", "d", "bd", "di", "dt", "dr", "md", "dist", "wd", "hd", "wb", "ds", "den", "wm", "wy", "db", "hm", "hh", "dad", "dc", "pd", "fd", "deb", "dial", "dn", "dim", "dl", "DH", "bh", "dal", "adh", "vd", "dyl", "hi", "wt", "yah", "dd", "hy", "dm", "dp", "dra", "zh", "ohl", "dq", "sth", "nw", "conn", "wa"], "w_prev": ["wa_ref", "wa_orig", " w_next", "w_rev", " w_reverse", "w___final", "w_next", "w_orig", " w_final", "w_req", "w_adj", "w_pre", "w_vious", "wa_prev", "wa_best", "wa_next", "w_ref", "w___rev", "wa_adj", "wa_vious", "w_best", "w___pre", " w_orig", "wa_rev", " w_best", " w_rev", "wa_req", "w_reverse", "w_final", "w___prev", " w_pre"]}}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n", "idx": 12314, "substitutes": {"addr": ["prefix", "address", "hop", "dr", "amd", "ar", "hash", "data", "amp", "adr", "image", "array", "network", "base", "size", "area", "align", "access", "length", "resource", "pad", " address", "ress", "grad", "offset", "slice", "adder", "nr", "rr", "ptr", "url", "seq", "host", "config", "error", "byte", "point", "ac", "progress", "rss", "node", "ip", "args", "Address", "ext", "info", "layer", "art", "mac", "pointer", "docker", "ack", "src", "name", "inter", "port", "clock", "ace", "arp", "ref", "arm", "len", "number", "ad", "code"], "block": ["module", "orig", "address", "check", "list", "link", "work", "open", "val", "condition", "group", "map", "limit", "label", "parent", "box", "i", "value", "none", "prev", "sync", "part", "batch", "o", "flow", "raw", "record", "image", "pack", "new", "pool", "error", "num", "id", "node", "cache", "ip", "line", "off", "tx", "square", "buffer", "chain", "null", "update", " Block", "bl", "result", "bc", "bin", "blocks", "object", "valid", "unit", "byte", "pre", "key", "lock", "clean", "type", "run", "ack", "name", "out", "ref", "wall", "body", "base", "length", "page", "def", "full", "loc", "frame", "config", "inv", "point", "Block", "no", "range", "index", "row", "clock", "build", "plugin", "number", "function"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usbnet_can_receive(VLANClientState *nc)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n        return 1;\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 12320, "substitutes": {"nc": ["enc", "ne", "ct", "nn", "cn", "nd", "ng", "nt", "cm", "cs", "bc", "pc", "conn", "online", "anc", "nic", "ec", "cc", "dc", "uc", "cdn", "dn", "lc", "rc", "n", "np", "ci", "ctx", "fc", "c", "NC", "ns", "inc", "unc", "nm", "rn", "nw", "nec", "cv"], "s": ["ps", "hs", "fs", "sync", "o", "sv", "rs", "als", "south", "secondary", "cs", "e", "ts", "its", "parts", "ds", "states", "si", "ans", "ss", "ssl", "uns", "m", "acks", "state", "sq", "gs", "xs", "g", "es", "ks", "ads", "n", "comm", "is", "c", "su", "i", "sg", "p", "ns", "qs", "sl", "sets", "sb", "ses", "js", "settings", "r", "ls", "sym", "S", "services"]}}
{"project": "qemu", "commit_id": "333d50fe3d9a1ff0a6a1a44ef42a0d3a2a7f2abe", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int page, dbd, buflen, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = req->cmd.buf[1]  & 0x8;\n\n    page = req->cmd.buf[2] & 0x3f;\n\n    page_control = (req->cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, len %d, page_control %d)\\n\",\n\n        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);\n\n    memset(outbuf, 0, req->cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (bdrv_is_read_only(s->bs)) {\n\n        dev_specific_param = 0x80; /* Readonly.  */\n\n    } else {\n\n        dev_specific_param = 0x00;\n\n    }\n\n\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    if ((~dbd) & nb_sectors) {\n\n        if (req->cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= s->cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n", "idx": 12326, "substitutes": {"req": ["exec", "requ", "resp", "cb", "query", "rf", "tar", "ra", "seq", "reg", "spec", "cur", "sr", "src", "j", "conn", "client", "serv", "required", "rw", "rt", "cmd", "resource", "res", "sq", "str", "org", "cache", "input", "crit", "dq", "ru", "require", "jp", "data", "rh", "qt", "rr", "sem", "wx", "rec", "fr", "comm", "http", "q", "mr", "re", "ir", "call", "ref", "comp", "wa", "qq", "rs", "desc", "rob", "ro", "def", "grad", "config", "proc", "tr", "low", "ctx", "rx", "f", "row", "err", "request", "r", "gr", "conf", "pro"], "outbuf": [" outbuff", "newbuf", "bootbuff", "bootfb", "blockuf", "Outbuffer", "inbuffer", "OUTuf", "Outcb", "infb", "inbuf", "upfb", "outbuff", "inbuff", "outfp", "upfp", "blockbuffer", "outcb", "outfb", "OUTbuffer", "Outbuff", "incb", "blockbuf", " outbuffer", "upbuf", "newbuff", "OUTbuff", "Outbuf", "outbuffer", "OUTcb", "bootfp", "inuf", "Outuf", "outuf", "blockbuff", " outuf", "upbuff", "newbuffer", "bootbuf", "newuf", "OUTbuf", "infp"], "s": ["session", "v", "requ", "sys", "si", "m", "self", "n", "spec", "qs", "js", "j", "services", "t", "ps", "sync", "serv", "o", "e", "cs", "y", "ssl", "sq", "gs", "_", "c", "sg", "ns", "sis", "st", "sa", "l", "ds", "service", "http", "q", "ses", "sym", "S", "d", "sp", "g", "ks", "z", "os", "su", "b", "f", "w", "r", "ls"], "nb_sectors": ["nb_ensecs", "nb_secors", "nb_sections", "nb_traitors", "nb_ceors", "nb_spegments", "nb_vections", "nb_gerets", "nb_schelos", "nb_secctors", "nb_geeters", "nb_secrets", "nb_vecs", "nb_tractors", "nb_cectors", "nb_exxes", "nb_lectors", "nb_gectors", "nb_seats", "nb_segments", "nb_traors", "nb_vectors", "nb_geitors", "nb_veapters", "nb_sixeters", "nb_enseats", "nb_verets", "nb_secs", "nb_lections", "nb_cegments", "nb_ensegments", "nb_ensectors", "nb_seeters", "nb_seors", "nb_leivers", "nb_sexes", "nb_pegments", "nb_ceats", "nb_sixlos", "nb_gecs", "nb_spections", "nb_gexes", "nb_exgments", "nb_vector", "nb_scheeters", "nb_exctors", "nb_seivers", "nb_peivers", "nb_exctions", "nb_ceitors", "nb_tections", "nb_pections", "nb_secctions", "nb_peats", "nb_tegments", "nb_spector", "nb_vexes", "nb_gelos", "nb_serets", "nb_vegments", "nb_tragments", "nb_schectors", "nb_pecs", "nb_secgments", "nb_schegments", "nb_seapters", "nb_secapters", "nb_selos", "nb_geivers", "nb_sixctors", "nb_spectors", "nb_legments", "nb_seitors", "nb_gector", "nb_geapters", "nb_sixgments", "nb_seccs", "nb_teors", "nb_gegments", "nb_tectors", "nb_cecs", "nb_geors", "nb_gections", "nb_sector", "nb_pectors"], "page": ["en", "data", "per", "count", "pos", "result", "length", "server", "pp", "size", "Page", " Page", "pixel", "pg", "pid", "sp", "limit", "offset", "pri", "url", "next", "net", "rec", "age", "n", "block", "id", "pages", "cache", "ip", "c", "line", "type", "col", "order", "start", "row", "name", "min", "f", "pl", "aa", "loc", "len", "number"], "dbd": ["devd", "bdn", "bmd", " dbdn", "dbdn", "debdc", "devdl", "ddds", "bddc", " dbid", "devid", " dbcd", "bmid", "debd", "ddf", "dbdl", "devcd", "bdf", " dbf", "dbcd", "dbid", "dbf", "bdds", "ddd", "bdd", "dbdc", "dbds", "debn", "bmdl", "bmcd", "dbn", "dddc", " dbdc", " dbds", "bddn", " dbn", " dbdl", "debdn"], "buflen": ["bufline", "buveline", "bugllen", "auflens", "aufllen", "buglen", "bugline", "auflen", "buvelens", "auvelen", "buglens", "auveline", "buvellen", "buseline", "auvellen", "buselen", "buvelen", "aufline", "busellen", "buselens", "buflens", "auvelens", "bufllen"], "page_control": ["pagelexadjust", "page_con", "page_adjust", "page_controlled", "page__ctrl", "pagelexcontrol", " page_length", " page_controlled", "pagelexlock", "page__limit", "page_lock", " page_ctrl", " page_con", "page_ctrl", "page__control", "page_length", " page_adjust", "page__length", "page_limit", " page_lock", " page_limit"], "p": ["ps", "fp", "part", "it", "d", "o", "pe", "tp", "data", "jp", "v", "patch", "po", "param", "per", "e", "pos", "ap", "op", "after", "u", "pc", "result", "l", "pi", "P", "params", "pair", "pp", "post", "y", "wp", "m", "sp", "api", "a", "hp", "pre", "g", "up", "point", "lp", "k", "n", "z", "np", "pa", "cache", "c", "q", "i", "h", "x", "cp", "b", "f", "w", "port", "pin", "py", "r", "j", "br", "at", "t", "array", "prev"], "dev_specific_param": ["dev_special_param", "dev_special_ref", "dev_special_par", "dev_special_params", "dev_general_num", "dev_specificacnum", "dev_specific_ref", "dev_general_param", "dev_specific_par", "dev_general_item", "dev_specificacpar", "dev_special_channel", "dev_special_cm", "dev_specificaccm", "dev_specific_num", "dev_specific_params", "dev_special_num", "dev_specific_cm", "dev_specific_part", "dev_special_part", "dev_specificacparam", "dev_specific_item", "dev_general_params", "dev_specific_channel"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert((unsigned)op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < tcg_op_defs_max; op++) {\n\n        const TCGOpDef *def = &tcg_op_defs[op];\n\n        if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n            /* Wrong entry in op definitions? */\n\n            if (def->used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!def->used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 12329, "substitutes": {"tdefs": ["trefs", " tdefines", " trefs", "tdefe", "tDefe", "tdfs", "qtdefp", "tdefp", "tdescs", "tdivp", " tdefe", " tdfs", "dtdescs", "tfuns", "dtdescies", "tdefines", "tDEFies", "qtdefaultines", " tdefcs", "trefcs", "tdivcs", "tDEFp", "tdivs", "tdescb", "tdiverences", "tdecls", "tDEFerences", " tdfines", "tdefcs", "tDEFs", "dtdescks", "tdescies", "dtdefies", "tdefies", " trefcs", "tcondp", "tDEFcs", "tDEFb", "tdefaultp", "tdeclp", "tdefks", "treferences", "tDEFks", "qtdefines", "dtdefb", "tDefines", "tdefaults", "tfune", "tcomplb", "tcomplks", "dtdefks", "tdefaultines", "tDefs", "qtdefaults", "tdeclies", "tdefaulties", " trefp", "tdeclines", " tdeferences", "trefp", "tdefb", "tconds", "qtdefies", " treferences", "tdeferences", "tfunines", "tcompls", " tdefp", "dtdescb", "qtdefaulties", "tcondies", "tcondines", "qtdefs", " tdfe", "tdfines", "dtdefs", "tcomplies", "tdescks", "tdfe", "qtdefaultp"], "op": ["d", "Op", "o", "omp", "oper", "mp", "hop", "orig", "dr", "oc", "ok", "jp", "opp", "loop", "force", "pos", "oid", "act", "cop", " ip", "expr", "open", "pp", "OP", "post", "cmp", "sp", " opt", "ype", "mod", " cop", "error", "pre", "up", "operator", "key", "ant", " operation", "pop", "lock", "operation", "id", "opt", "init", "node", "ip", "x", "info", "top", "set", "p", " operator", "type", "cat", " Op", "ax", "off", "gen", "prop", "name", "pl", "ind", "option", "bit", "loc", "opus", "comp", "ops", "code"], "def": ["exec", "eval", "del", "pos", "obj", "pkg", "defined", "cf", "val", "ef", "ra", "sup", "spec", "init", "req", "gen", "diff", "prev", "du", "raw", "cmd", "die", "new", "error", "view", "block", "push", "off", "crit", "pred", "pass", "aux", "di", "nd", "data", "DEF", "md", "end", "definition", "dep", "gh", "valid", "rc", "df", "dev", "define", "lit", "adv", "call", "ref", "inf", "da", "d", "dr", "der", "decl", "dist", "desc", "dc", "el", "Def", "config", "proc", "de", "feed", "info", "cl", "f", "final", "old", "conf", "pro"], "ct_str": ["pt_str", "ct_exp", "ctFstr", "ct64cur", "ctwoct", "ctLstr", "att1path", "ct2path", "ctpstr", "cat_st", "att1exp", "dc_req", "ctwreq", "ectXres", "ct_br", "CT_str", "unctWstr", "ct_res", "ectXwr", "ct_req", "ct_STR", "apt\n", "ct_oct", "ectXstr", "att_path", "unct_cur", "ct1str", "satLstr", "sat_dr", "ctwstrip", "ect_rs", "ct64line", "ct\n", "satLstrip", "apt_enc", "ct_dr", "unctWline", "apt_dr", "ct1exp", "ct_st", "pt_Str", "CT_arr", "att1str", "unctWarr", "ct_sp", "ct_path", "ctXres", "unct_arr", "ctLdr", "CT_exp", "sat_str", "dc_strip", "unctWcur", "ct1STR", "ctwstr", "sat_strip", "ctFst", "ct_strip", "att_exp", "ct_stri", "cat_STR", "att_str", "ct2STR", "ct64oct", "ect_str", "ctWline", "ctWstr", "cat_str", "pt_arr", "CT_br", "ct2exp", "apt_str", "ctFenc", "dc_oct", "satLsp", "cat\n", "satLdr", "ct_Str", "ctpexp", "ct64strip", "ctXrs", "apt_string", "ctXwr", "pt_string", "ct_cur", "unct_str", "ct64str", "ct1path", "ct2str", "ctLstrip", "ct64arr", "ctWcur", "sat_sp", "ctLsp", "ectXrs", "ctppath", "ect_res", "att1STR", "ct_wr", "apt_st", "unct_line", "ctpSTR", "ctFstri", "ct_rs", "ct_string", "cat_string", "att_STR", "ect_wr", "apt_stri", "ctXstr", "dc_str", "ct64req", "ct_line", "ct_enc", "ctWarr", "ct_arr"], "i": ["adi", "module", "it", "d", "ie", "o", "di", "gi", "ij", "ini", "iu", "fi", "mi", "v", "multi", "li", "e", "xi", "u", "mu", "inner", "l", "pi", "abi", "uri", "si", "y", "in", "ai", "ui", "m", "lc", "ti", "g", "ix", "k", "z", "n", "eni", "ik", "io", "ci", "id", "iv", "bi", "qi", "ip", "x", "c", "h", "phi", "hi", "info", "p", "index", "ri", "s", "b", "ic", "ni", "f", "ind", "j", "r", "ii", "ori", "I", "yi"], "nb_args": ["nbOfpieces", "nb67pieces", "nb_cats", "wb67args", "nb__args", "nbwArgs", "nb__Args", "wb_objects", "nb67groups", "nbOfobjects", "nb_groups", "nbwcats", "wb67pieces", "nb_flags", "NB__args", "nb___flags", "nb___Args", "wb_args", "nb_pieces", "wb_pieces", "nb_cs", "nbwargs", "NB_args", "nb___args", "nb__cats", "nb2arms", "nbOfargs", "nb___cats", "nb2aux", "nb_objects", "bi_cs", "NB__cats", "nbwflags", "wb67objects", "nb_Args", "nb_arms", "bi_args", "nb2cs", "NB_flags", "nb2args", "nb67objects", "wb67groups", "NB_Args", "NB_cats", "NB__Args", "NB__flags", "wb_groups", "nbOfgroups", "nb67args", "nb__flags", "nb_aux", "bi_aux", "bi_arms"], "oarg": [" ocat", "Oargument", "osarg", "osargument", "oamp", "toarg", "osgen", "noamp", "oiargument", "oerg", "iocat", "oblank", "oaang", "oargs", "oaark", " oargs", " oinc", "floarr", " oar", "eArg", "nogen", "oaArg", "Oarr", "ioarr", "oargument", "ioargument", "floarg", "osArg", " ovar", "oark", "oiarg", "togen", "toamp", "iovar", "toargument", " oarm", "noarg", "woarr", "Ovar", "soArg", "toar", "oiar", "eerg", "ocat", "oar", " oang", " oamp", "oarr", "woarg", "oablank", "oainc", "ioark", "ioerg", "ioargs", " oark", "earg", " oerg", "osinc", "soarg", "oiarm", "osamp", "oinc", " oargument", " oblank", "ioArg", " oArg", "soargument", "ecat", "oaarg", "ovar", "oArg", "oaamp", "Oarg", "woang", "ioarg", "soarr", "flovar", "oarm", "oaargs", " oarr", "ogen", "oaarr", "floargument", "woblank", "noargument", "oavar", "toarm", "oang"]}}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n", "idx": 12347, "substitutes": {"cap": ["caps", "ha", "gap", "lan", "app", "mp", "span", "apy", "null", "com", "wal", "Cap", "op", "plug", "bc", "hab", "fab", "cb", "pac", " caps", "pad", "rap", "cmp", "map", "api", "pool", "capt", "san", "scale", "capacity", "ac", "ip", "c", "mac", "p", "cl", "ak", "aps", "except", "acl", "ca", "ab", "csv", "av", "pan", "ape", "ace", "snap", "xa", "CAP", "cas", "clip", "ping"], "fmt": ["iflt", "lprint", "llt", "Fprintf", "sfformat", "Flt", "Fmt", "sfmt", "Fprint", " flt", "ifformat", "fprint", "sfprintf", "sflt", "lformat", "lmt", "Fformat", "flt", "ifprintf", " fformat", "fformat", "ifmt", " fprint"], "ap": ["gap", "app", "AP", "apy", "af", "ar", "amp", "op", "pac", "ang", "db", "rap", "sp", " app", "el", "api", "ep", "al", "apt", "aper", "ac", "age", "am", "pa", "ip", "ats", "cp", "ast", "p", "tap", "ak", "b", "aps", "arp", "rep", "as", "ab", "or", "av", "ape", "snap", "ag", "array"]}}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,\n\n                                  OGGStreamContext *oggstream, int bitexact)\n\n{\n\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n\n    uint8_t *p;\n\n    if (extradata_size != 34)\n\n        return -1;\n\n    oggstream->header_len[0] = 51;\n\n    oggstream->header[0] = av_mallocz(51); // per ogg flac specs\n\n    p = oggstream->header[0];\n\n    bytestream_put_byte(&p, 0x7F);\n\n    bytestream_put_buffer(&p, \"FLAC\", 4);\n\n    bytestream_put_byte(&p, 1); // major version\n\n    bytestream_put_byte(&p, 0); // minor version\n\n    bytestream_put_be16(&p, 1); // headers packets without this one\n\n    bytestream_put_buffer(&p, \"fLaC\", 4);\n\n    bytestream_put_byte(&p, 0x00); // streaminfo\n\n    bytestream_put_be24(&p, 34);\n\n    bytestream_put_buffer(&p, extradata, 34);\n\n    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n\n    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n\n    p = oggstream->header[1];\n\n    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n\n    bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n\n    bytestream_put_le32(&p, strlen(vendor));\n\n    bytestream_put_buffer(&p, vendor, strlen(vendor));\n\n    bytestream_put_le32(&p, 0); // user comment list length\n\n    return 0;\n\n}\n", "idx": 12353, "substitutes": {"extradata": ["exrastatum", "extramata", "extadata", "extractata", "interramar", "exradana", "extradana", "extmandata", "extmandaton", "extractatum", "extradATA", "extramada", "exrastATA", "extredana", "exrastana", "extmandar", "interradada", "interramaton", "extadaton", "extradatum", "extrastatum", "extrastATA", "interramata", "exradata", "extrastana", "extredatum", "extramar", "extradada", "extadada", "extredATA", "extractATA", "extrastata", "exradATA", "extractana", "extradar", "interramada", "extramaton", "interradata", "extradaton", "exradatum", "extadar", "interradar", "exrastata", "extmandada", "extredata", "interradaton"], "extradata_size": ["extradATA_size", "extradata_address", "extradata_capacity", "extradada_size", "extradATA_len", "extradada_address", "extradATA_capacity", "extradada_capacity", "extradata_len"], "oggstream": ["awkfile", "ogahost", "oglstage", "ogghost", "ogamodel", "ogggraph", "oggedmodel", "awkserver", "ogstack", "ogcloud", "oggconfig", "oglserver", "ogaconsole", "oggrun", "oggedgraph", "gowstage", "awkcloud", "ogastring", "ggform", "oghost", "gowfile", "ogconfig", "ogconsole", "obbstream", "oggchannel", "ogcontext", "oggsw", "oglthread", "oglcontext", "ogchannel", "gggraph", "ottmodel", "ggcontext", "ottstream", "ogserver", "obbserver", "oggview", "ggstream", "ogacloud", "ogastream", "obbrun", "ogastack", "ogstring", "oggedcontext", "ogsystem", "oglfile", "ottsystem", "oggstack", "oggcontext", "oggthread", "ogagraph", "oggtable", "ogmodel", "oggsystem", "oglrun", "ottstring", "awkmodel", "ogview", "gowstream", "ogacontext", "awkchannel", "gowthread", "oggfile", "oglsw", "ottserver", "oglsystem", "ggsw", "awkthread", "oggmodel", "ogstream", "awkhost", "ottrun", "ggmodel", "oggserver", "obbmodel", "ottform", "awkview", "oggstage", "otttable", "ogtable", "oggconsole", "oggstring", "oglstream", "oglform", "oggcloud", "ogltable", "oggedstream", "ottchannel", "awkstage", "ogaview", "awkstream", "ogsw", "oggform", "awkconsole", "oglchannel", "awkstack", "ogachannel", "awkconfig", "obbconfig", "ogform", "obbchannel"], "bitexact": ["antineXacting", "biteXacting", "biteexacts", "bitextacting", "antinexact", "bitexacts", "biteXact", "bitexract", "biterexacts", "bitexACT", "biteexact", "ittexACT", "biteXacts", "bitexacting", "bitepexacting", "ittexacts", "itteXract", "ittexact", "ittexract", "bitepexact", "itteXACT", "biterexACT", "antinexacting", "biteexACT", "antineXract", "antineXact", "bitextract", "itteXact", "biteXACT", "bitepexract", "biteexract", "bitextact", "biterexract", "biterexact", "biteXract", "itteXacts", "antinexract"], "vendor": ["varn", "coid", "svavor", "envoice", "envoid", "svoy", " vender", "Vendor", "vsolution", " voice", "cector", "ivector", "ivoid", "svirgin", "volution", " vorer", "envolution", "ivendor", "vsendor", "volarn", "volendor", "svorer", "voloid", "voy", "Vavor", "volector", "svendor", "ivcore", "coy", "ivirgin", "vsoid", "virgin", "vavor", "ivender", "vector", "sender", "envendor", "voice", " voy", "soy", "cirgin", "score", " vcore", "carn", "vsoice", " vavor", "vender", " volution", "cendor", "Vorer", "ivoy", "ivarn", "svender", "cender", "vorer", "vcore", "sendor"], "p": ["fp", "ps", "part", "d", "o", "pe", "tp", "pn", "data", "jp", "v", "po", "patch", "param", "per", "e", "u", "ap", "op", "pc", "l", "pi", "P", "pp", "post", "y", "wp", "m", "sp", "api", "a", "php", "pre", "g", "up", "point", "lp", "parent", "n", "pr", "k", "np", "z", "pa", "cache", "ip", "bp", "c", "i", "pointer", "cp", "h", "x", "s", "q", "b", "f", "port", "parser", "j", "r", "at", "t"]}}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe(DCAEncContext *c, int subframe)\n\n{\n\n    int i, band, ss, ch;\n\n\n\n    /* Subsubframes count */\n\n    put_bits(&c->pb, 2, SUBSUBFRAMES -1);\n\n\n\n    /* Partial subsubframe sample count: dummy */\n\n    put_bits(&c->pb, 3, 0);\n\n\n\n    /* Prediction mode: no ADPCM, in each channel and subband */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 1, 0);\n\n\n\n    /* Prediction VQ address: not transmitted */\n\n    /* Bit allocation index */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 5, c->abits[band][ch]);\n\n\n\n    if (SUBSUBFRAMES > 1) {\n\n        /* Transition mode: none for each channel and subband */\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                put_bits(&c->pb, 1, 0); /* codebook A4 */\n\n    }\n\n\n\n    /* Scale factors */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 7, c->scale_factor[band][ch]);\n\n\n\n    /* Joint subband scale factor codebook select: not transmitted */\n\n    /* Scale factors for joint subband coding: not transmitted */\n\n    /* Stereo down-mix coefficients: not transmitted */\n\n    /* Dynamic range coefficient: not transmitted */\n\n    /* Stde information CRC check word: not transmitted */\n\n    /* VQ encoded high frequency subbands: not transmitted */\n\n\n\n    /* LFE data: 8 samples and scalefactor */\n\n    if (c->lfe_channel) {\n\n        for (i = 0; i < DCA_LFE_SAMPLES; i++)\n\n            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);\n\n        put_bits(&c->pb, 8, c->lfe_scale_factor);\n\n    }\n\n\n\n    /* Audio data (subsubframes) */\n\n    for (ss = 0; ss < SUBSUBFRAMES ; ss++)\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                    put_subframe_samples(c, ss, band, ch);\n\n\n\n    /* DSYNC */\n\n    put_bits(&c->pb, 16, 0xffff);\n\n}\n", "idx": 12357, "substitutes": {"c": ["enc", "d", "ct", "o", "cpp", "cu", "oc", "com", "cont", "v", "cm", "tc", "sc", "e", "cs", "con", "C", "nc", "bc", "cf", "pc", "l", "cb", "u", "core", "y", "ec", "cc", "dc", "m", "conf", "this", "uc", "rc", "lc", "config", "g", "k", "self", "z", "ac", "n", "vc", "ci", "ctx", "cur", "ce", "cache", "fc", "h", "cp", "s", "p", "cod", "cl", "col", "b", "cy", "coll", "co", "ctrl", "ic", "f", "cr", "mc", "w", "call", "abc", "xc", "cell", "t"], "subframe": ["subframes", "subsequence", "superframes", "subFrame", "supersequence", "ubframe", "ubFrame", "ubframes", " subframes", " subFrame", "superframe", "superFrame", " subsequence", "ubsequence"], "i": ["it", "d", "ie", "di", "gi", "chi", "ini", "iu", "fi", "v", "multi", "li", "e", "xi", "u", "l", "pi", "si", "y", "ai", "ui", "ti", "g", "k", "z", "ix", "key", "n", "ci", "id", "io", "bi", "qi", "is", "x", "ip", "oi", "ki", "p", "index", "type", "s", "b", "inc", "ri", "ni", "f", "zi", "j", "ii", "I", "yi"], "band": ["not", "field", "nn", "v", "patch", "sc", "pos", "wd", "work", "group", "channel", "boot", "uch", "h", "bb", "component", "ver", "cle", "pl", "brand", "back", "j", "part", "period", "ct", "batch", "arch", "flow", "front", "amp", "match", "kat", "Band", "cmd", "job", "path", "db", "tag", "word", "block", "x", "line", "off", "cat", "way", "th", "pass", "rule", "eb", "gap", "bug", "nd", "dom", "count", "plug", "st", "ff", "be", "head", "model", "pp", "bus", "gh", "key", "class", "fr", "dev", "stage", "type", "ph", "bit", "bands", "cell", "day", "ann", "code", "step", "ass", "connection", "ground", "cm", "br", "direction", "length", "broad", "sp", "url", "config", "g", "low", "version", "feed", "product", "layer", "p", "core", "device", "range", "b", "cl", "kk", "f", "kt", "child", "port", "gb", "plugin", "function"], "ss": ["ps", "ross", "us", "SS", "test", "ass", "nn", "rs", "ng", "patch", "sc", "cs", "st", "pos", "hess", "ff", "length", "ds", "pp", "style", "si", "se", "oss", "sp", "sq", "sf", "sn", "str", "sem", "bs", "seq", "es", "ks", "sch", "os", "spec", "iss", "ess", "rss", "feed", "vs", "su", "ns", "s", "sw", "sl", "tz", "series", "ses", "ls", "pass", "uss", "sk", "css"], "ch": ["chip", "hop", "chart", "v", "patch", "sc", "u", "work", "cher", "chn", "CH", "channel", "chan", "cur", "che", "uch", "sh", "h", "col", "ver", "j", "conn", "part", "wh", "batch", "arch", "ht", "y", "ech", "ich", "cor", "sw", "th", "bug", "com", "qu", "kick", "count", "och", "cho", "l", "gh", "tch", "inch", "dev", "q", "ph", "coll", "cht", "zh", "cell", "chrom", "sk", "code", "app", "chi", "ach", "cm", "br", "length", "el", "sub", "g", "z", "k", "sch", "ci", "vc", "Ch", "cp", "p", "cl", "core", "b", "co", "f", "child", "gr", "conf"]}}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n\n\n    count/=2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for(i=0; i<count; i++){\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n}\n", "idx": 12362, "substitutes": {"s": ["ps", "comments", "sync", "fs", "o", "session", "your", "sites", "rs", "temp", "south", "cs", "e", "u", "ts", "ds", "bis", "si", "ions", "ss", "y", "ssl", "service", "m", "conf", "this", "sq", "times", "gs", "sf", "a", "g", "es", "ks", "self", "k", "n", "ctx", "is", "context", "c", "side", "http", "ns", "p", "qs", "b", "sets", "lines", "f", "sb", "ses", "js", "gb", "settings", "r", "services", "ls", "S", "t", "ops"], "count": ["list", "Count", "all", "try", "li", "e", "force", "process", "sum", "l", "length", "size", "base", "page", "depth", "cc", "limit", "offset", "pool", "find", "num", "n", "low", "ch", "id", "second", "cache", "now", "current", "c", "weight", "max", "close", "p", "core", "index", "col", "b", "scroll", "coll", "f", "name", "found", "child", "ind", "call", "err", "allow", "cast", "len", "number", "code"], "i": ["it", "adi", "ie", "d", "di", "o", "gi", "ini", "iu", "mi", "fi", "v", "multi", "li", "e", "xi", "u", "mu", "inner", "l", "pi", "abi", "uri", "line", "si", "ai", "ui", "m", "hi", "slice", "api", "a", "lc", "ti", "ix", "n", "eni", "gu", "ci", "id", "io", "bi", "init", "is", "ip", "x", "qi", "c", "oi", "phi", "info", "p", "index", "ri", "cli", "b", "ji", "ni", "f", "zi", "ind", "diff", "j", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       vnc_read_when(vs, protocol_client_init, 1);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       return start_auth_vnc(vs);\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12365, "substitutes": {"vs": ["ps", "flows", "fs", "sv", "Vs", "ins", "rs", "verts", "vm", "v", "cs", "otes", "asts", "nets", "ov", "outs", "server", "ds", "ss", "pg", "vers", "ves", "state", "vt", "gs", "plugins", "xs", "bs", "obs", "pps", "es", "ks", "sts", "ils", "org", "vc", "os", "iv", "iss", "ums", "stats", "args", "ns", "s", "eps", "qs", "versions", "ver", "vals", "va", "lv", "lines", "vas", "ses", "js", "ms", "VS", "vp", "ls", "vr", "env", "opens", "alls", "css", "sk", "cv"], "err": ["ror", "orig", "ctr", "iter", "bug", " error", "dr", "eor", "fee", "fi", "exc", "data", "resp", "br", "e", "magic", "result", "message", "cb", "errors", "nil", "doc", "rr", "str", "error", "rage", "rb", "fr", "init", "hr", "rss", "extra", "status", "range", "req", "type", "ver", "mr", "order", "Er", "arr", "out", "msg", "ind", "diff", "or", "ner", "Error", "er", "r", "loc", "gr", "var", "code"]}}
{"project": "qemu", "commit_id": "1dde716ed6719c341c1bfa427781f0715af90cbc", "target": 0, "func": "iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 12367, "substitutes": {"iscsi": ["uscci", "uscsi", "fcci", "ircni", "ecsa", "ecsb", "ircsb", "ecsi", "ircci", "ircsi", "fcsa", "iscci", "licni", "iscsa", "iscdi", "ecci", "fcsi", "uscdi", "licsi", "licci", "licdi", "iscsb", "uscni", "fcsb", "ircsa", "iscni", "ircdi"], "acb": ["rcb", "ACb", "acbb", "accbb", "anca", "agbb", "acab", "ancb", "agb", "accsb", "ucb", "ucbb", "ACba", "ancsb", " acsb", "accbd", "ACa", "accba", "aca", "agsb", "acbd", "acsb", "rca", "ancbd", "ucba", "agab", "Acbb", "Acbd", "acba", "ucbd", "ACbd", " acbb", "accb", "ACab", " acab", " acbd", "ancbb", "Acsb", "Acb", "ACbb", "rcba", "ancba", "ACsb", "rcbb"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n", "idx": 12376, "substitutes": {"schid": ["SchID", "Schname", "Schid", "skids", "chid", "Schids", "skid", "chname", " schx", "chids", "schname", "schids", "skx", "appids", "chx", "chID", "appname", "schID", "schx", " schids", "appid", "skname", "appID", " schname"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n", "idx": 12377, "substitutes": {"env": ["enc", "en", "engine", "debug", "environment", "ev", "exc", "txt", "erv", "e", "cb", "eye", "skin", "server", "qt", "eng", "ec", "db", "conf", "gui", "esm", "dep", "ef", "rc", "config", "emb", "ea", "eu", "fen", "profile", "eni", "np", "init", "context", "ah", "args", "viron", "ext", "core", "scope", "him", "esi", "energy", "loader", "que", "console", "err", "buf", "forge", "conn", "enh", "Environment", "cv"], "paddr": ["tpaddr", "pamd", "lpaddress", "pcamd", "pager", "tpager", " pname", " ipamd", " pamd", "paddress", "tpaddress", "tpname", " pager", "pcaddr", "pcaddress", " ipaddress", "lpname", " paddress", "pname", "lpager", "lpaddr", " ipaddr"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lm32_evr_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    target_phys_addr_t flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    target_phys_addr_t timer0_base = 0x80002000;\n\n    target_phys_addr_t uart0_base  = 0x80006000;\n\n    target_phys_addr_t timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_evr.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 12378, "substitutes": {"args": ["enc", "module", "actions", "alloc", "ins", "ass", "Args", "cs", "ras", "sci", "cmd", "parts", "params", "ig", "api", "gs", "arms", "parse", "ae", "config", "g", "ks", "arg", "ands", "init", "Arg", "sg", "ext", "ns", "atts", "aws", "lines", "ams", "arr", "flags", "utils", "ms", "apps", "parser", "lang", "resources", "ants", "arm", "words"], "cpu_model": ["cpusmachine", "processor_base", "cpubookmodule", "processor_mode", "cpusserver", "cpu_string", "cpu_models", "cpu_base", "module_machine", "cpuallnetwork", "processor_model", "processor_models", "gpu_base", "cpubookdir", "module_server", "gpu_dir", "gpu_module", "cpubooknetwork", "module_models", "modulesserver", "cpuallmodel", "cpu_server", "cpu_location", "gpu_model", "gpu_string", "cpualldir", "cpu_module", "cpusmodels", "gpu_network", "cpu_machine", "cpusrange", "cpusmodel", "modulesmodel", "modulesmachine", "core_model", "cpu_network", "gpu_models", "core_range", "modulesmodels", "cpufmodel", "cpuallmodule", "cpufmodels", "cpufmachine", "core_location", "cpu_dir", "cpu_range", "cpufserver", "cpu_mode", "cpuslocation", "cpubookmodel", "module_model", "core_models"], "kernel_filename": ["kernel_uri", "cpu_definition", "kernelacimage", "process_image", "kernelanddirectory", "kernelandfile", "kernelfresource", "kernel_resource", "kernel_definition", "kernel_file", "kernelanddefinition", "kernelffilename", "kernelacfilename", "process_resource", "kernelfimage", "process_uri", "kernel_image", "cpu_filename", "cpu_directory", "kernelacresource", "cpu_file", "process_filename", "kernelandfilename", "kernelacuri", "kernel_directory", "kernelfuri"], "cpu": ["phy", "module", "prefix", "chip", "performance", "computer", "GPU", "cn", "vm", "jp", "CPU", "nc", "image", "consumer", "process", "pc", "gpu", "processor", "bench", "gc", "lu", "nic", "queue", "cmp", "hu", "uu", "prem", "hw", "pool", "hp", "unit", "program", "pu", "proc", "linux", "kernel", "net", "host", "lc", "eni", " CPU", "np", "boot", "ctx", "mem", "node", "cache", "home", "c", "memory", "cp", "p", "core", "cli", "component", "ram", "gru", "python", "utils", "gp", "loader", "clock", "platform", "conn"], "env": ["enc", "en", "engine", "ne", "session", "environment", "ev", "ini", "exec", "edge", "exc", "vm", "v", "e", "dir", "network", "skin", "conn", "style", "path", "ec", "db", "gui", "attr", "el", "state", "ef", "config", "profile", "ea", "eu", "exe", "eni", "np", " environment", "cache", "dev", "context", "extra", "shell", "viron", "info", "ext", "uv", "core", "scope", "energy", "loader", "console", "err", "enable", "equ", "conf", "Environment", "theme"], "dinfo": ["binf", "derror", "dderror", " dconfig", " dvalue", " daction", "dcconfig", "pconfig", "ddata", "ddinf", " ddata", " dinf", "binfo", " dni", "bni", "dninfo", "dninf", "ddinfo", "fdinfo", "pni", "dbdata", "fdaction", "fdinf", "dinf", "pinfo", "ddconfig", "dbinfo", "dbconfig", "ldconfig", "dni", "ldinfo", "ldinf", "lderror", "pinf", "daction", "bconfig", "dcinfo", "dcdata", "dnvalue", "dnaction", " derror", "dconfig", "dvalue", "fdvalue"], "address_space_mem": ["address_space_mm", "address_space_memory", "address_space__lim", "address_area_ram", "address_space__memory", "address_space__mem", "address_area_lim", "address_space__ram", "address_space2ram", "address_space2memory", "address_service_nm", "address_space_ram", "address_area_mem", "address_space_nm", "address_service_ram", "address_service_mem", "address_service_mm", "address_space2lim", "address_area_memory", "address_space_lim", "address_space2mem"], "phys_ram": ["physjram", "phys_flash", "physjflash", "phys_disk", "las_gram", "las_disk", "las_ram", "physical_channel", "las_array", "physibgram", "phys__flash", "physFgram", "phys_mode", "physical_flash", "physFmode", "physFram", "phys_gram", "phys__region", "physfdisk", "phys_region", "physibresource", "las_mode", "physibram", "physjregion", "phys_model", "physibmodel", "physfram", "phys_array", "phys__ram", "phys__channel", "physical_model", "las_region", "phys_channel", "physjchannel", "physical_ram", "physical_resource", "physfgram", "phys_resource", "physFarray", "physfregion", "physical_gram", "physical_region"], "cpu_irq": ["cpu_mirq", "cpu_irqu", "cpu_iperce", "cpu_irece", "cpu_irce", "cpu_iperqs", "cpu_iperq", "cpu_ireq", "cpu_mirqs", "cpu_irqs", "cpu_ireqs", "cpu_irequ", "cpu_iperqu", "cpu_mirqu", "cpu_mirce"], "irq": ["irqs", "irf", "iraq", "IRqs", "irch", "iraqs", " irqs", "irach", " irch", " irf", "IRq", "IRf", "IRch", "iraf"], "reset_info": ["reset_object", "reseterinfo", "config_info", "update_inner", "launch_id", "reset_Info", "updateerinfo", "resetjinfo", "reset_information", "reset\u00b7image", " reset_information", "resetallinformation", "reset\u00b7ori", "update_result", "config_object", "reseterid", "launch_ori", "config_Info", "reseterinner", "update_id", "reseterInfo", "config_information", "updateerresult", "reset_result", "configerInfo", "reseterresult", " reset_Info", "configerinfo", "resetallobject", "reset_inner", "resetallinfo", "resetjInfo", "update_info", "resetjinformation", "reset_internal", "reset_image", "launch_image", "updateerinner", "configerinformation", "resetallInfo", "resetjinternal", "configerobject", "reset\u00b7info", "reseterobject", "reset\u00b7id", " reset_internal", "updateerid", "reseterinformation", "reset_id", "reset_ori", "launch_info"], "i": ["d", "o", "ed", "v", "e", "u", "l", "pi", "in", "m", "a", "g", "z", "n", "io", "is", "c", "h", "s", "p", "b", "f", "or", "r", "j", "ii", "I"]}}
{"project": "qemu", "commit_id": "075a1fe788d36b271ec25507466c30b9a90b5d54", "target": 0, "func": "static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)\n\n{\n\n    uint8_t df = (ctx->opcode >> 21) & 0x3;\n\n    uint8_t wt = (ctx->opcode >> 16) & 0x1f;\n\n    int64_t s16 = (int16_t)ctx->opcode;\n\n\n\n    check_msa_access(ctx);\n\n\n\n    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    switch (op1) {\n\n    case OPC_BZ_V:\n\n    case OPC_BNZ_V:\n\n        {\n\n            TCGv_i64 t0 = tcg_temp_new_i64();\n\n            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);\n\n            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?\n\n                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);\n\n            tcg_gen_trunc_i64_tl(bcond, t0);\n\n            tcg_temp_free_i64(t0);\n\n        }\n\n        break;\n\n    case OPC_BZ_B:\n\n    case OPC_BZ_H:\n\n    case OPC_BZ_W:\n\n    case OPC_BZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        break;\n\n    case OPC_BNZ_B:\n\n    case OPC_BNZ_H:\n\n    case OPC_BNZ_W:\n\n    case OPC_BNZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);\n\n        break;\n\n    }\n\n\n\n    ctx->btarget = ctx->pc + (s16 << 2) + 4;\n\n\n\n    ctx->hflags |= MIPS_HFLAG_BC;\n\n    ctx->hflags |= MIPS_HFLAG_BDS32;\n\n}\n", "idx": 12383, "substitutes": {"env": ["enc", "en", "environment", "exec", "exc", "txt", "e", "obj", "cb", "def", "ec", "queue", "inst", "rc", "proc", "eu", "ch", "dev", "viron", "req", "scope", "cl", "que", "console", "err", "buf", "gr", "conf"], "ctx": ["fp", "client", "sync", "ct", "cpp", "cn", "cu", "exec", "git", "jp", "txt", "cm", "tc", "sc", "cs", "obj", "bc", "pkg", "sci", "cf", "pc", "cmd", "cb", "cfg", "kb", "qt", "qa", "anc", "wp", "Context", "cc", "cmp", "ga", "hw", "rc", "config", "cca", "wx", "ck", "lc", "vc", "ci", "fc", "node", "context", "c", "conv", "cp", "lib", "cli", "cpu", "req", "kw", "ctrl", "tx", "acl", "ca", "msg", "utils", "wcs", "std", "console", "xc", "loc", "fw", "conn", "cms", "cas", "cv"], "op1": ["opernum", " opnum", "OP3", "hop1", "oper0", "opOne", "optOne", "opt2", "op0", "oper2", "op2", "oper1", "opt1", "OP2", "OpOne", " op0", "oper3", "Op2", "op3", "Op1", "Op3", "hop2", "OP1", "hopOne", "opt0", "optnum", "opnum", " op2"]}}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 12384, "substitutes": {"ctxt": ["CText", "actxt", "CTbl", "qtbl", "qtxt", "CTtxt", "cext", "cttxt", "catxt", "qtext", "catbl", "qttxt", "cxt", "CTxt", "ctbl", "catext", "cattxt", "actext", "ctx", "ctext", "CTtx", "cttx", "acttx", "acttxt"], "tokens": ["tokentials", "tokenens", "Tokens", "torenos", "targentials", "pokenos", "toksings", "targens", "topicks", "targets", "tokenses", "tokenings", "targenos", "pargenos", "pokens", "Tokenses", "pargents", "Token", "torents", "tokenets", "Tokentials", "Targings", "tokets", "tokings", "Tokicks", "toksens", "Tokenos", "Targenses", "Targen", "torens", "pargets", "targen", "tocens", "Tokets", "tokenos", "topenos", "tensentials", "topens", "Targens", "Tokings", "tokenents", "tocenos", "targenses", "torets", "tocets", "pargens", "Targents", "targicks", "tokenen", "tokicks", "topets", "pokents", "Targenos", "Targentials", "targents", "Targets", "tensents", "tokenentials", "pokets", "toksen", "Targicks", "tensenses", "toksents", "targings", "tokenenses", "tokenicks", "Tokents", "tokenenos", "tocents", "tensens", "tokents"], "token": ["normal", "session", "atom", "column", "writer", "parent", "variable", "channel", "operator", "stop", "character", "date", "KEN", "start", "or", "value", "prefix", "sync", "o", "seed", "tool", "random", "element", "resource", "header", "tag", "method", "word", "node", "context", "option", "socket", "pass", "event", "rule", "span", "null", "iter", "ok", "data", "user", "result", "pattern", "bin", "service", "root", "valid", "key", "notice", "type", "name", "call", "argument", "cookie", "text", "oken", "document", "connection", "Token", "source", "tree", "note", "lex", "tick", "version", "current", "bot", "target", "p", "sign", "before", "parser", "request", "translation", "number", "function", "false"], "ret": ["auth", "gt", "ft", "success", "fi", "hash", "tmp", "data", "jp", "repl", "Return", "match", "obj", "result", "feat", "format", "rt", "base", "att", "true", "output", "val", "def", "job", "res", " RET", "det", "reply", "pret", "len", "reg", "rets", "arg", "id", "rev", "mem", "bot", "complete", "info", "active", "lit", "arr", "re", "RET", "flag", "python", "back", "value", "j", "ref", "alt", "Ret", "function"], "working": ["checking", "workers", "going", "session", "using", "locking", "writing", "Working", "moving", "breaking", "wrong", "ng", "same", "calling", "existing", "testing", "ordering", "worker", "inner", "network", "winning", "opening", "work", "conn", "wd", "starting", "reading", "conf", "broken", "thing", "hand", "channel", "ing", "leading", "worked", "between", "binding", "processing", "active", "missing", "won", "ending", "including", "picking", "works", "forcing", "found", "w", "loading", "ring", "setting", "containing", "running", "array", "ping"]}}
{"project": "FFmpeg", "commit_id": "892bbbcdc171ff0d08d69636a240ffb95f54243c", "target": 0, "func": "static av_cold int vaapi_encode_config_attributes(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAStatus vas;\n\n    int i, n, err;\n\n    VAProfile    *profiles    = NULL;\n\n    VAEntrypoint *entrypoints = NULL;\n\n    VAConfigAttrib attr[] = {\n\n        { VAConfigAttribRTFormat        },\n\n        { VAConfigAttribRateControl     },\n\n        { VAConfigAttribEncMaxRefFrames },\n\n    };\n\n\n\n    n = vaMaxNumProfiles(ctx->hwctx->display);\n\n    profiles = av_malloc_array(n, sizeof(VAProfile));\n\n    if (!profiles) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (profiles[i] == ctx->va_profile)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding profile not found (%d).\\n\",\n\n               ctx->va_profile);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    n = vaMaxNumEntrypoints(ctx->hwctx->display);\n\n    entrypoints = av_malloc_array(n, sizeof(VAEntrypoint));\n\n    if (!entrypoints) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigEntrypoints(ctx->hwctx->display, ctx->va_profile,\n\n                                   entrypoints, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query entrypoints for \"\n\n               \"profile %u: %d (%s).\\n\", ctx->va_profile,\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (entrypoints[i] == ctx->va_entrypoint)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding entrypoint not found \"\n\n               \"(%d / %d).\\n\", ctx->va_profile, ctx->va_entrypoint);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaGetConfigAttributes(ctx->hwctx->display,\n\n                                ctx->va_profile, ctx->va_entrypoint,\n\n                                attr, FF_ARRAY_ELEMS(attr));\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to fetch config \"\n\n               \"attributes: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(attr); i++) {\n\n        if (attr[i].value == VA_ATTRIB_NOT_SUPPORTED) {\n\n            // Unfortunately we have to treat this as \"don't know\" and hope\n\n            // for the best, because the Intel MJPEG encoder returns this\n\n            // for all the interesting attributes.\n\n            continue;\n\n        }\n\n        switch (attr[i].type) {\n\n        case VAConfigAttribRTFormat:\n\n            if (!(ctx->va_rt_format & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Surface RT format %#x \"\n\n                       \"is not supported (mask %#x).\\n\",\n\n                       ctx->va_rt_format, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRTFormat,\n\n                .value = ctx->va_rt_format,\n\n            };\n\n            break;\n\n        case VAConfigAttribRateControl:\n\n            if (!(ctx->va_rc_mode & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Rate control mode %#x \"\n\n                       \"is not supported (mask: %#x).\\n\",\n\n                       ctx->va_rc_mode, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRateControl,\n\n                .value = ctx->va_rc_mode,\n\n            };\n\n            break;\n\n        case VAConfigAttribEncMaxRefFrames:\n\n        {\n\n            unsigned int ref_l0 = attr[i].value & 0xffff;\n\n            unsigned int ref_l1 = (attr[i].value >> 16) & 0xffff;\n\n\n\n            if (avctx->gop_size > 1 && ref_l0 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"P frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (avctx->max_b_frames > 0 && ref_l1 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"B frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        break;\n\n        default:\n\n            av_assert0(0 && \"Unexpected config attribute.\");\n\n        }\n\n    }\n\n\n\n    err = 0;\n\nfail:\n\n    av_freep(&profiles);\n\n    av_freep(&entrypoints);\n\n    return err;\n\n}\n", "idx": 12395, "substitutes": {"avctx": ["afcontext", "AVcontext", " avcontext", "avectrl", "AVctrl", "afctrl", "aveconn", "navctx", "navtx", "avectx", "navxc", "afconn", " avxc", "AVxc", "afctx", "AVctx", "avctrl", "AVtx", "avxc", "avtx", "navcontext", "avconn", " avtx", "avecontext", "avcontext", "AVconn"], "ctx": ["cu", "cn", "exec", "git", "sc", "act", "pkg", "obj", "cf", "cb", "cc", "ga", "concept", "cv", "np", "component", "kw", "auc", "conn", "cms", "client", "sync", "prefix", "ct", "cs", "media", "pc", "cmd", "anon", "na", "gal", "sq", "hw", "lc", "cus", "context", "c", "cat", "cal", "tx", "ca", "wcs", "ja", "cas", "jp", "la", "bc", "fn", "feat", "voc", "iw", "qt", "qa", "anc", "wp", "Context", "cmp", "rc", "wx", "ck", " context", "mc", "ko", "las", "ku", "ha", "cam", "qq", "cm", "nc", "sci", "kb", "lex", "config", "cca", "px", "vc", "ci", "pa", "fc", "cp", "cli", "cl", "co", "ctrl", "kt", "xc", "loc", "fw", "ka", "css"], "vas": ["pic", "session", "ba", "nav", "draw", "ras", "cf", "true", "CS", " canvas", "BA", "ta", "aver", "scale", "cv", "pas", "avi", "virt", "ares", "auc", "facebook", "rus", "native", "var", "vis", "fs", "anus", "aka", "wordpress", "jas", "microsoft", "kit", "pc", "outs", "gpu", "na", "ss", "cus", "sts", "cache", "pse", "wt", "ns", "cat", "cal", "avin", "miss", "kes", "wcs", "buf", "nw", "pass", "ja", "span", "cas", "gly", "di", "fi", "jp", "wal", "Va", "feat", "ds", "usa", "inas", "qa", "wp", "bus", " cs", "mus", "valid", "vs", "stage", "complete", "status", "aba", "mas", "av", "las", "nec", "alls", "ops", "wa", " va", " dc", "document", "sv", "board", "goo", "Stage", "isi", "nas", "bridge", "px", "kas", "s", "p", "layout", "va", "port", "request", "fw", "opus", "css"], "i": ["adi", "d", "ie", "di", "o", "gi", "my", "chi", "ini", "iu", "mi", "fi", "v", "multi", "li", "e", "xi", "u", "mu", "inner", "l", "pi", "uri", "si", "y", "ai", "ui", "slice", "q", "ti", "ix", "key", "ani", "z", "eni", "ci", "io", "mini", "id", "bi", "iv", "qi", "ip", "x", "c", "oi", "info", "phi", "hi", "p", "index", "type", "ri", "ji", "uli", "b", "ni", "f", "name", "ind", "j", "ori", "ii", "I", "yi"], "n": ["en", "d", "adj", "o", "ne", "nn", "cn", "pn", "nd", "all", "v", "nt", "e", "u", "nc", "fn", "network", "l", "conn", "size", "na", "y", "in", "m", "el", "mn", "len", "sn", "dn", "num", "g", "un", "z", "net", "k", "np", "nb", "ln", "init", "node", "N", "c", "h", "x", "ns", "p", "no", "s", "b", "nu", "ni", "f", "name", "min", "w", "inn", "rn", "r", "j", "ii", "nw", "t", "none", "span", "nan"], "err": ["iter", "bug", "dr", "fee", "ini", "der", "fi", "ar", "resp", "br", "cr", "act", "result", "feat", "rh", "fy", "fg", "wr", "cb", " Err", "kr", "y", "doc", "erer", "str", "rr", "error", "rage", "usr", "pr", "go", "fr", "ler", "req", "esi", "mr", "arr", "Er", "ir", "late", "msg", "ind", "aster", "acer", "call", "er", "ner", "Error", "r", "aa", "rl", "gr", "aaa"], "profiles": ["memilies", " profilies", "attories", "Profils", "memiles", "suppilers", "protilers", "Profps", "Profories", "facilers", "servessions", "profilings", "protiles", "memps", "buffils", "Profilies", "profules", "compilies", "attilers", "metiles", "facilities", "protessions", "facilies", "serviles", " profories", "faciles", "compples", "buffessions", "facils", "Profiles", "simils", "suppories", "similes", " profps", "metils", "suppils", "metules", "attiles", "simories", "Profilities", "buffiles", "profilers", "protilies", "professions", "profilies", "similers", "metilities", "Profules", "suppiles", "profories", "memories", "profils", "facules", "buffilings", "facples", "protils", "servilings", "profps", "profples", "attils", "protilings", "compilers", "profilities", "protples", "servils", "compiles"], "entrypoints": ["EntryPoints", "gepoint", " entryPoints", "gePoints", "Entryports", "geports", " entrypoint", "entryPoints", "entryps", "enterpoint", "enterpoints", "Entrypoints", " entryps", "entpoints", "enterPoints", "gepoints", "Entrypoint", "enterps", "entPoints", "entps", "enterports", "entrypoint", "entryports", " entryports", "entports"], "attr": ["d", "options", "list", "rs", "data", "eval", "att", "params", "types", "map", "spec", "cache", "stats", "Attribute", "info", "lib", "type", "arr", "buf", "r", "Interface", "array"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *p, int *got_packet)\n\n{\n\n    int bpp, picsize, datasize = -1, ret;\n\n    uint8_t *out;\n\n\n\n    if(avctx->width > 0xffff || avctx->height > 0xffff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"image dimensions too large\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    picsize = av_image_get_buffer_size(avctx->pix_fmt,\n\n                                       avctx->width, avctx->height, 1);\n\n    if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* zero out the header and only set applicable fields */\n\n    memset(pkt->data, 0, 12);\n\n    AV_WL16(pkt->data+12, avctx->width);\n\n    AV_WL16(pkt->data+14, avctx->height);\n\n    /* image descriptor byte: origin is always top-left, bits 0-3 specify alpha */\n\n    pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0);\n\n\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_GRAY8:\n\n        pkt->data[2]  = TGA_BW;     /* uncompressed grayscale image */\n\n        pkt->data[16] = 8;          /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_RGB555LE:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompresses true-color image */\n\n        pkt->data[16] = 16;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGR24:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 24;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGRA:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 32;         /* bpp */\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Pixel format '%s' not supported.\\n\",\n\n               av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    bpp = pkt->data[16] >> 3;\n\n\n\n    out = pkt->data + 18;  /* skip past the header we just output */\n\n\n\n    /* try RLE compression */\n\n    if (avctx->coder_type != FF_CODER_TYPE_RAW)\n\n        datasize = targa_encode_rle(out, picsize, p, bpp, avctx->width, avctx->height);\n\n\n\n    /* if that worked well, mark the picture as RLE compressed */\n\n    if(datasize >= 0)\n\n        pkt->data[2] |= 8;\n\n\n\n    /* if RLE didn't make it smaller, go back to no compression */\n\n    else datasize = targa_encode_normal(out, p, bpp, avctx->width, avctx->height);\n\n\n\n    out += datasize;\n\n\n\n    /* The standard recommends including this section, even if we don't use\n\n     * any of the features it affords. TODO: take advantage of the pixel\n\n     * aspect ratio and encoder ID fields available? */\n\n    memcpy(out, \"\\0\\0\\0\\0\\0\\0\\0\\0TRUEVISION-XFILE.\", 26);\n\n\n\n    pkt->size   = out + 26 - pkt->data;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 12402, "substitutes": {"avctx": ["alcb", "ajcf", "afconfig", "aveconfig", "afctrl", "aircmd", "avci", "avepkg", "avcf", "verctx", "afctx", "affw", "avctrl", "avectl", "afcmd", "AVconn", "appkg", "ajctx", "apcontext", "akpkg", "afcontext", "vercf", "ajxc", "akctx", "avectrl", "akcontext", "AVcmp", "evctx", "afcv", " avpkg", "afpkg", "avctl", "avectx", "avpkg", "alctrl", "AVctx", "airctx", "ajfw", "AVcu", "AVcf", "evcontext", "avecmp", "avxc", "afxc", "ajcontext", "avecf", "apctx", " avcontext", "alctx", "ajci", "avcb", "afcf", "aircontext", "afci", "avcu", "afconn", "alcontext", "avfw", "afcmp", "aircmp", "aircf", "AVconfig", "evcmp", "afctl", "afcu", "airci", "avconn", "avcmp", "avcmd", "AVcontext", "airctl", "AVpkg", "avconfig", "aveconn", "avecu", "avexc", " avconn", "evcmd", "avecb", "akcv", "verfw", "airpkg", "aveci", "avcv", "apctl", "vercontext", "avecontext", "avecv", "afcb", "avcontext"], "pkt": ["preacket", " pct", "execacket", "wkt", "pwk", "cpct", "cpacket", "pkit", " pitting", "pitting", "pkg", "fkt", " pwk", "Pkg", "pdc", "pekit", "lnt", "ppkt", "execkt", "pnt", "Pnt", "fkg", " pnt", "pett", "tacket", "cpkt", "ppct", "Pitting", "fct", "pent", " pdc", "cpnt", " pkg", "telt", "spkt", "pet", "ipacket", " patten", "ipet", "ipkt", "pct", "Pdc", "pelt", "ppiece", " pett", "pratten", "Piece", "lkt", "wnt", "ipelt", "spett", "Pett", " piece", "Pwk", "preett", "Pkt", "prent", "Pelt", "patten", "spkg", "prekt", "spacket", "ppacket", " pelt", "wacket", "pekt", "prect", " packet", "lacket", "wct", "lkg", "Pct", "fnt", "tct", "execwk", " pet", "Patten", "packet", "prkg", "cpkit", "tkt", "tdc", "peacket", "fkit", "piece", "prkt", "Packet", "Pet", "facket", "pracket", "execitting"], "p": ["fp", "d", "o", "tp", "v", "e", "P", "pad", "wp", "m", "a", "pre", "g", "lp", "n", "np", "c", "q", "i", "pointer", "bp", "b", "f", "w", "parser", "j", "r", "at"], "got_packet": ["buf_compct", "buf_packct", "buf_octacket", "buf_paramct", "buf_packacket", "buf_octct", "buf2packets", "buf_packet", "buf_compet", "buf_compacket", "buf2packct", "buf_paramets", "buf_packets", "buf2octets", "buf_compets", "buf2octct", "buf_octet", "buf_paramet", "buf2octet", "buf2packacket", "buf_octets", "buf_paramacket", "buf2packet", "buf2octacket"], "bpp": ["bcp", "ppps", "pep", " bpps", "lbcp", " bep", "bpps", "lbpp", "lbmp", " bcp", "Bep", " bmp", "Bpps", "Bmp", "bep", "bmp", "Bcp", "pmp", "ppp", "lbep", "Bpp"], "picsize": ["picksizes", "apicksze", "pipssize", "picsization", "pitsization", "apicksize", "apicksizes", "pnicize", "apicsize", "apicksiz", "Picsize", "Picksiz", "picksizer", "Pickssize", "pixizer", "piciz", "picsizer", "pipsize", "picsiz", "pnicizes", "Picsization", "apicsizes", "pixze", "pnicze", "Picsiz", "picsze", "Picksize", "picssize", "Picssize", "pniciz", "apicksizer", "pnicizer", "pixize", "apicssize", "pnicsize", "picizes", "pipsiz", "pitssize", "pipsization", "apicsizer", "apickssize", "picsizes", "pickssize", "apicsiz", "picize", "apicsze", "pitsiz", "picksze", "picksiz", "pixiz", "picksization", "Picksization", "picksize", "pitsize"], "ret": ["fail", "en", "ft", "success", "data", "nt", "resp", "ben", "match", "result", "ut", "obj", "rt", "att", "val", "alt", "def", "res", "det", "reply", "valid", "al", "fun", "error", "rc", "reg", "rets", "arg", "mem", "mt", "info", "ext", "cat", "lit", "rep", "f", "re", "RET", "flag", "msg", "back", "bit", "r", "value", "ref", "len", "Ret", "code"], "out": ["img", "tmp", "Out", "result", "format", "output", "bin", "post", "val", "in", "res", "new", "reply", "num", "arg", "n", "opt", "arr", "err", "back", "nm", "bit", "len", "Ret"]}}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12409, "substitutes": {"cmd": ["client", "module", "ct", "send", "nd", "dom", "md", "nt", "command", "force", "pkg", "cd", "cfg", "head", "cb", "Cmd", "cf", "ht", "wd", "bind", "def", "cc", "dc", "cmp", "root", "grad", "hw", "config", "host", "parent", "ck", "add", "comm", "vc", "ctx", "cur", "init", "c", "input", "mac", "cp", "clean", "window", "target", "cli", "req", "cod", "device", "cat", "ctrl", "MD", "gen", "acl", "msg", "utils", "ind", "child", "call", "std", "cookie", "text", "plugin", "conn", "help", "code"], "dev": ["client", "debug", "serv", "engine", "d", "enc", "app", "ev", "cam", "der", "priv", "dom", "ve", "temp", "data", "user", "md", "DEV", "end", "pub", "prof", "desc", "server", "serial", "def", "pad", "conf", "dc", "mod", "valid", "comment", "error", "Dev", "proc", "reg", "de", "ch", "info", "dem", "off", "device", "dd", "unknown", "ver", "des", "diff", "adv", "err", "conn", "driver", "var"], "buf": ["enc", "bd", "batch", "alloc", "img", "func", "grab", "exc", "data", "uf", "v", "bf", "tab", "br", "bc", "result", "ff", "bu", "comb", "fab", "cb", "fb", "wb", "band", "pad", "db", "queue", "bus", "vec", "uc", "fd", "bg", "seq", "rc", "bh", "rb", "ctx", "usb", "cur", "buff", "nb", "context", "box", "home", "conv", "bytes", "window", "Buffer", "bb", "b", "bag", "src", "msg", "bo", "ab", "Buff", "uint", "buffer", "gb", "array", "cv"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void qdm2_init(QDM2Context *q) {\n\n    static int inited = 0;\n\n\n\n    if (inited != 0)\n\n        return;\n\n    inited = 1;\n\n\n\n    qdm2_init_vlc();\n\n    ff_mpa_synth_init(mpa_window);\n\n    softclip_table_init();\n\n    rnd_table_init();\n\n    init_noise_samples();\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"init done\\n\");\n\n}\n", "idx": 12412, "substitutes": {"q": ["qq", "Q", "qu", "v", "iq", "u", "query", "qt", "qa", "y", "m", "queue", "sq", "quad", "g", "k", "ch", "qi", "c", "h", "p", "req", "qs", "f", "w", "dq", "py", "r"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n", "idx": 12429, "substitutes": {"s": ["fs", "d", "o", "cpp", "rs", "south", "cs", "e", "ts", "ds", "sys", "si", "ions", "ss", "conf", "ssl", "m", "sq", "gs", "sf", "xs", "a", "g", "es", "ks", "self", "os", "ctx", "is", "ches", "c", "http", "i", "sg", "p", "ns", "qs", "b", "sets", "f", "sb", "ses", "js", "settings", "services", "sym", "S", "t", "ops"], "ch": ["enc", "app", "ach", "arch", "chi", "chart", "v", "patch", "ur", "e", "och", "cho", "cb", "ht", "length", "anch", "work", "cher", "y", "chn", "conf", "el", "CH", "ech", "cha", "ich", "bh", "channel", "chan", "k", "sch", "cor", "che", "Ch", "change", "sh", "c", "q", "i", "h", "cry", "cp", "dev", "p", "col", "mot", "b", "coll", "f", "th", "ind", "zh", "cht", "err", "oy", "conn", "sk", "code"], "count": ["body", "list", "Count", "try", "force", "e", "process", "l", "length", "size", "base", "depth", "cc", "offset", "comment", "error", "find", "num", "cond", "key", "n", "low", "id", "cur", "cache", "now", "current", "c", "weight", "max", "range", "index", "type", "col", "core", "p", "f", "name", "found", "ind", "child", "start", "call", "err", "build", "allow", "carry", "sum", "conf", "len", "catch", "code"]}}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos)\n\n{\n\n    PCIDevice *pdev = &vdev->pdev;\n\n    uint8_t cap_id, next, size;\n\n    int ret;\n\n\n\n    cap_id = pdev->config[pos];\n\n    next = pdev->config[pos + PCI_CAP_LIST_NEXT];\n\n\n\n    /*\n\n     * If it becomes important to configure capabilities to their actual\n\n     * size, use this as the default when it's something we don't recognize.\n\n     * Since QEMU doesn't actually handle many of the config accesses,\n\n     * exact size doesn't seem worthwhile.\n\n     */\n\n    size = vfio_std_cap_max_size(pdev, pos);\n\n\n\n    /*\n\n     * pci_add_capability always inserts the new capability at the head\n\n     * of the chain.  Therefore to end up with a chain that matches the\n\n     * physical device, we insert from the end by making this recursive.\n\n     * This is also why we pre-calculate size above as cached config space\n\n     * will be changed as we unwind the stack.\n\n     */\n\n    if (next) {\n\n        ret = vfio_add_std_cap(vdev, next);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* Begin the rebuild, use QEMU emulated list bits */\n\n        pdev->config[PCI_CAPABILITY_LIST] = 0;\n\n        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;\n\n        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    /* Use emulated next pointer to allow dropping caps */\n\n    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);\n\n\n\n    switch (cap_id) {\n\n    case PCI_CAP_ID_MSI:\n\n        ret = vfio_msi_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_EXP:\n\n        vfio_check_pcie_flr(vdev, pos);\n\n        ret = vfio_setup_pcie_cap(vdev, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_MSIX:\n\n        ret = vfio_msix_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_PM:\n\n        vfio_check_pm_reset(vdev, pos);\n\n        vdev->pm_cap = pos;\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_AF:\n\n        vfio_check_af_flr(vdev, pos);\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    default:\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"\n\n                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function,\n\n                     cap_id, size, pos, ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12434, "substitutes": {"vdev": [" vmod", " vver", "svdev", "gdev", "jdev", "wdev", "hdef", " vrad", "vdiv", "vpack", " vdevice", "jdi", "ldevelopment", "svev", "mde", "Vdev", "vdc", "papp", "fdc", "lprof", "fpriv", "ldata", "vmod", "vde", "fdiv", " vdiv", "hdevice", "lrad", "fver", "svdevice", " vde", "mdev", "gdevice", "svver", "vdevelopment", "hdev", "vapp", "pdiff", "vdef", "vDev", "crad", "pev", "vver", "hev", "svdef", "svdevelopment", "pserv", "pdef", "cdevice", "vdi", "pde", "cde", "Vdevice", "vprof", "pmod", " vpack", "gdi", "fdev", " vdevelopment", "fdi", " vapp", " vev", "vev", "cdiv", "svDev", "vd", "vpriv", " vserv", "vdiff", "vdata", "fde", "svrad", "pdevice", "gdc", "cdev", "vdevice", "svdiv", " vdef", "Vd", "svd", " vprof", "vrad", "svprof", "VDev", "pdiv", "fdevice", "ld", "ldevice", "jdc", " vpriv", "lDev", "ldev", "vserv", "wev", "jdevice", "fdata", "mapp", " vdata", "ldef", "wdef", "wpack", "svde", "svdiff", "mdiv", "prad", "ppack", " vdiff", "svserv", "fdef", "cpriv"], "pos": ["reset", "open", "val", "sec", "seq", "nos", "location", "spec", "i", "set", "col", "mon", "start", "min", "pl", "len", "part", "position", "all", "po", "kit", "pc", "present", "new", "offset", "str", "pri", "num", "block", "cache", "POS", "x", "push", "line", "off", "pass", "end", "pid", "state", "unit", "opt", "axis", "pres", "pointer", "type", "lit", "Pos", "name", "mid", "ref", "body", "pt", "length", "base", "style", "def", "slot", "post", "doc", "pose", "add", "os", "neg", "no", "args", "p", "index", "prop", "port", "loc", "conf", "pro"], "pdev": ["cconn", "ldi", "pdi", "cprof", "Pconf", "svdev", " pdc", " pserv", "ldiff", "pprof", "lprad", " pdiff", "svdevice", "cdef", "vprof", "vrad", " pdi", "pdiv", " pdiv", "pconf", "pcdev", "fdevice", "ldevice", "vconf", " pgu", "fdev", " prad", "pgu", "ldc", "lpdevice", "ldev", "pdiff", "pcdi", " pdef", "vdc", "crad", "pcdevice", "pdc", "lprof", "ldef", "lpdev", "cdiv", "Pdev", "vdiff", "svconn", "pdef", "pserv", "Pgu", "lserv", "svrad", "cdevice", " pconf", "pdevice", "prad", "Pdevice", "cdev", "pconn", "vdevice", "vgu", "pcserv", " pdevice", " pconn", "fprof"], "cap_id": ["cap2id", "cap_ID", "caperid", " cap_name", "capPbit", "capt_bit", " cap_path", "caperID", "caperi", "ap_type", "cp_name", "cap_bit", " cap_ids", " cap_num", "caperlit", "cap_name", "ap_id", "capt_type", "cp_type", "cap_lit", "captPids", "capPids", "capt_ids", "cap_num", "cap_ids", "captPtype", "cp_id", "capt_id", "cp_info", "capPid", "captPid", "cap_style", "cap_type", "capPtype", "ap_path", "captPbit", " cap_i", " cap_lit", "ap_ID", "cap2num", "cap_i", " cap_style", "cap2name", " cap_ID", "cap_info", "cap_path"], "next": ["done", "enc", "en", "client", "step", "first", "big", "append", "success", "front", "shift", "more", "result", "end", "length", "open", "style", "page", "job", "doc", "full", "loc", "new", "state", "valid", "frame", "reply", "len", "sec", "seq", "small", "config", "last", "skip", "sequence", "block", "second", "feed", "now", "current", "extra", "max", "line", "complete", "close", "range", "start", "gen", "min", "future", "mid", "entry", "Next", "prev"], "size": ["large", "en", "enc", "sync", "address", "big", "shift", "Size", "empty", "global", "cm", "count", "end", "use", "si", "shape", "cap", "sent", "fat", "full", "new", "sp", "el", "offset", "form", "sec", "time", "unit", "small", "scale", "fun", "ix", "last", "n", "z", "six", "g", "extra", "max", "set", "range", "cl", "name", "min", "SIZE", "esc", "loc", "sum", "ize", "len"], "ret": ["done", "part", "gt", "orig", "ft", "fin", "success", "bare", "data", "nt", "resp", "bf", "pat", "match", "result", "obj", "feat", "pt", "pub", "rt", "bc", "att", "lt", "val", "def", "res", "db", " RET", "det", "fit", "valid", "len", "reply", "str", "fun", "rc", "al", "url", "reg", "usr", "last", "rets", "arg", "flat", "rev", "opt", "mt", "art", "info", "status", "cat", "let", "lit", "f", "re", "out", "RET", "flag", "get", "back", "bit", "value", "pass", "ref", "alt", "Ret"]}}
{"project": "qemu", "commit_id": "fb9fb692312a84ebc6e9c10da6f374c5871ff7b0", "target": 0, "func": "int cpu_exec(CPUState *env1)\n\n{\n\n#define DECLARE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    unsigned long next_tb;\n\n\n\n    if (cpu_halted(env1) == EXCP_HALTED)\n\n        return EXCP_HALTED;\n\n\n\n    cpu_single_env = env1;\n\n\n\n    /* first we save global registers */\n\n#define SAVE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    env = env1;\n\n\n\n#if defined(TARGET_I386)\n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_M68K)\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->cc_dest = env->sr & 0xf;\n\n    env->cc_x = (env->sr >> 4) & 1;\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_ARM)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n    env->exception_index = -1;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (setjmp(env->jmp_env) == 0) {\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n            /* if an exception is pending, we execute it here */\n\n            if (env->exception_index >= 0) {\n\n                if (env->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = env->exception_index;\n\n                    if (ret == EXCP_DEBUG)\n\n                        cpu_handle_debug_exception(env);\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    do_interrupt_user(env->exception_index,\n\n                                      env->exception_is_int,\n\n                                      env->error_code,\n\n                                      env->exception_next_eip);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#endif\n\n                    ret = env->exception_index;\n\n                    break;\n\n#else\n\n#if defined(TARGET_I386)\n\n                    /* simulate a real cpu exception. On i386, it can\n\n                       trigger new exceptions, but we do not handle\n\n                       double or triple faults yet. */\n\n                    do_interrupt(env->exception_index,\n\n                                 env->exception_is_int,\n\n                                 env->error_code,\n\n                                 env->exception_next_eip, 0);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#elif defined(TARGET_PPC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MIPS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SPARC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_ARM)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SH4)\n\n\t\t    do_interrupt(env);\n\n#elif defined(TARGET_ALPHA)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_CRIS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_M68K)\n\n                    do_interrupt(0);\n\n#endif\n\n                    env->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            if (kvm_enabled()) {\n\n                kvm_cpu_exec(env);\n\n                longjmp(env->jmp_env, 1);\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = env->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~(CPU_INTERRUPT_HARD |\n\n                                               CPU_INTERRUPT_FIQ |\n\n                                               CPU_INTERRUPT_SMI |\n\n                                               CPU_INTERRUPT_NMI);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        env->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit();\n\n                    }\n\n#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \\\n\n    defined(TARGET_MICROBLAZE)\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        env->halted = 1;\n\n                        env->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit();\n\n                    }\n\n#endif\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                            svm_check_intercept(SVM_EXIT_INIT);\n\n                            do_cpu_init(env);\n\n                            env->exception_index = EXCP_HALTED;\n\n                            cpu_loop_exit();\n\n                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {\n\n                            do_cpu_sipi(env);\n\n                    } else if (env->hflags2 & HF2_GIF_MASK) {\n\n                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&\n\n                            !(env->hflags & HF_SMM_MASK)) {\n\n                            svm_check_intercept(SVM_EXIT_SMI);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;\n\n                            do_smm_enter();\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                                   !(env->hflags2 & HF2_NMI_MASK)) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n                            env->hflags2 |= HF2_NMI_MASK;\n\n                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);\n\n                            next_tb = 0;\n\n\t\t\t} else if (interrupt_request & CPU_INTERRUPT_MCE) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;\n\n                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                                   (((env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->hflags2 & HF2_HIF_MASK)) ||\n\n                                    (!(env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->eflags & IF_MASK && \n\n                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {\n\n                            int intno;\n\n                            svm_check_intercept(SVM_EXIT_INTR);\n\n                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);\n\n                            intno = cpu_get_pic_interrupt(env);\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing hardware INT=0x%02x\\n\", intno);\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            /* ensure that no TB jump will be modified as\n\n                               the program flow was changed */\n\n                            next_tb = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&\n\n                                   (env->eflags & IF_MASK) && \n\n                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {\n\n                            int intno;\n\n                            /* FIXME: this should respect TPR */\n\n                            svm_check_intercept(SVM_EXIT_VINTR);\n\n                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno);\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;\n\n                            next_tb = 0;\n\n#endif\n\n                        }\n\n                    }\n\n#elif defined(TARGET_PPC)\n\n#if 0\n\n                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {\n\n                        cpu_reset(env);\n\n                    }\n\n#endif\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        ppc_hw_interrupt(env);\n\n                        if (env->pending_interrupts == 0)\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD)\n\n                        && (env->sregs[SR_MSR] & MSR_IE)\n\n                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))\n\n                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MIPS)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&\n\n                        (env->CP0_Status & (1 << CP0St_IE)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n                        !(env->hflags & MIPS_HFLAG_DM)) {\n\n                        /* Raise it */\n\n                        env->exception_index = EXCP_EXT_INTERRUPT;\n\n                        env->error_code = 0;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SPARC)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        if (cpu_interrupts_enabled(env) &&\n\n                            env->interrupt_index > 0) {\n\n                            int pil = env->interrupt_index & 0xf;\n\n                            int type = env->interrupt_index & 0xf0;\n\n\n\n                            if (((type == TT_EXTINT) &&\n\n                                  cpu_pil_allowed(env, pil)) ||\n\n                                  type != TT_EXTINT) {\n\n                                env->exception_index = env->interrupt_index;\n\n                                do_interrupt(env);\n\n                                next_tb = 0;\n\n                            }\n\n                        }\n\n\t\t    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {\n\n\t\t\t//do_interrupt(0, 0, 0, 0, 0);\n\n\t\t\tenv->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n\t\t    }\n\n#elif defined(TARGET_ARM)\n\n                    if (interrupt_request & CPU_INTERRUPT_FIQ\n\n                        && !(env->uncached_cpsr & CPSR_F)) {\n\n                        env->exception_index = EXCP_FIQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    /* ARMv7-M interrupt return works by loading a magic value\n\n                       into the PC.  On real hardware the load causes the\n\n                       return to occur.  The qemu implementation performs the\n\n                       jump normally, then does the exception return when the\n\n                       CPU tries to execute code at the magic address.\n\n                       This will cause the magic PC value to be pushed to\n\n                       the stack if an interrupt occured at the wrong time.\n\n                       We avoid this by disabling interrupts when\n\n                       pc contains a magic address.  */\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)\n\n                            || !(env->uncached_cpsr & CPSR_I))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SH4)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_ALPHA)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_CRIS)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && (env->pregs[PR_CCS] & I_FLAG)) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_NMI\n\n                        && (env->pregs[PR_CCS] & M_FLAG)) {\n\n                        env->exception_index = EXCP_NMI;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_M68K)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((env->sr & SR_I) >> SR_I_SHIFT)\n\n                            < env->pending_level) {\n\n                        /* Real hardware gets the interrupt vector via an\n\n                           IACK cycle at this point.  Current emulated\n\n                           hardware doesn't rely on this, so we\n\n                           provide/save the vector when the interrupt is\n\n                           first signalled.  */\n\n                        env->exception_index = env->pending_vector;\n\n                        do_interrupt(1);\n\n                        next_tb = 0;\n\n                    }\n\n#endif\n\n                   /* Don't use the cached interupt_request value,\n\n                      do_interrupt may have updated the EXITTB flag. */\n\n                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(env->exit_request)) {\n\n                    env->exit_request = 0;\n\n                    env->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit();\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {\n\n                    /* restore flags in standard format */\n\n#if defined(TARGET_I386)\n\n                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n                    log_cpu_state(env, X86_DUMP_CCOP);\n\n                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_ARM)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SPARC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_PPC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_M68K)\n\n                    cpu_m68k_flush_flags(env, env->cc_op);\n\n                    env->cc_op = CC_OP_FLAGS;\n\n                    env->sr = (env->sr & 0xffe0)\n\n                              | env->cc_dest | (env->cc_x << 4);\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MIPS)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SH4)\n\n\t\t    log_cpu_state(env, 0);\n\n#elif defined(TARGET_ALPHA)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_CRIS)\n\n                    log_cpu_state(env, 0);\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n                }\n\n#endif\n\n                spin_lock(&tb_lock);\n\n                tb = tb_find_fast();\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tb_invalidated_flag = 0;\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                qemu_log_mask(CPU_LOG_EXEC, \"Trace 0x%08lx [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             (long)tb->tc_ptr, tb->pc,\n\n                             lookup_symbol(tb->pc));\n\n#endif\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);\n\n                }\n\n                spin_unlock(&tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                if (!unlikely (env->exit_request)) {\n\n                    env->current_tb = tb;\n\n                    tc_ptr = tb->tc_ptr;\n\n                /* execute the generated code */\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                    next_tb = tcg_qemu_tb_exec(tc_ptr);\n\n                    env->current_tb = NULL;\n\n                    if ((next_tb & 3) == 2) {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(long)(next_tb & ~3);\n\n                        /* Restore PC.  */\n\n                        cpu_pc_from_tb(env, tb);\n\n                        insns_left = env->icount_decr.u32;\n\n                        if (env->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            env->icount_extra += insns_left;\n\n                            if (env->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n", "idx": 12451, "substitutes": {"env1": ["environment0", "zone0", "env3", "env2", "enOne", "environmentOne", "environment3", "ecOne", "ec2", "ec3", "environment1", " env3", "en0", "envOne", " env0", "en1", "zone1", "en2", "ec0", "zone2", "environment01", " env01", "env0", "zone01", "en3", "ec1", "environment2", " envOne", "env01", " env2"], "ret": [" Ret", "data", "reset", "resp", "nt", "Return", "eval", "match", "result", "eth", "att", "alt", "val", "def", "res", " RET", "det", "reply", "fun", "capt", "proc", "net", "rets", "arg", "mem", "utf", "mt", "info", "status", "run", "f", "re", "ait", "RET", "red", "inter", "buffer", "bit", "len", "Ret"], "interrupt_request": ["intersect67request", "interrupt67window", "intersect_window", "intersect67req", "intersect67window", "intersect_progress", "interrupt_window", "interrupt_req", "interrupt_progress", "interrupt67progress", "intersect_request", "interrupt67req", "intersect67progress", "intersect_req", "interrupt67request"], "tb": ["tbh", "ttb", " tbb", " tbl", "ttbb", "ltbl", "ltbh", "tbl", "tbb", "ltbb", "ttbh", " tbh", "ttbl", "ltb"], "tc_ptr": ["tcfproc", "TC_tr", "tc2pointer", "tc2proc", "tc_proc", "tcfpointer", "tcftr", "TC_proc", "TC_pointer", "tc2tr", "tc2ptr", "tc_pointer", "tc_tr", "TC_ptr", "tcfptr"], "next_tb": ["next_intbb", "next_Tbb", "next_etbl", "next_tp", "next_tbl", "next_Tp", "next_etp", "next_intbl", "next_intb", "next_tbb", "next_Tb", "next_intp", "next_etb", "next_etbb", "next_Tbl"]}}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "substitutes": {"env": ["enc", "site", "exec", "exc", "v", "erv", "act", "obj", "skin", "output", "dat", "ec", "ef", "vel", "emb", "ea", "un", "np", "rev", "init", "scope", "esi", "here", "entry", "esc", "enable", "conn", "en", "ne", "qv", "esp", "edge", "txt", "po", "global", "e", "eng", "db", "queue", "eni", "org", "iv", "iss", "cache", "context", "c", "shell", "ah", "cal", "gear", "event", "oa", "et", "engine", "environment", "vm", "data", "end", "eye", "qt", "esm", "state", "ep", "lock", "dev", "vs", "stage", "viron", "que", "code", "app", "ev", "inet", "nc", "server", "style", "ou", "gui", "el", "export", "config", "eu", "net", "ctx", "args", "ext", "uv", "energy", "loader", "err", "er", "console", "equ", "Environment", "cv"], "maskreg": ["maskrec", "filterreg", " maskbar", "switchrun", "askblock", "switchReg", "flagreg", " maskREG", "maskReg", "switchreg", "askrun", "markREG", "maskREG", "filterregister", "askREG", "maskblock", " maskrec", "filterblock", "maskrun", "flagReg", "filterbar", "markreg", "maskregister", "askrec", "askregister", "askbar", "flagrun", "filterrec", "askreg", "markblock", "askReg", "flagrec", "filterREG", "maskbar", "markregister", "switchrec"], "val": ["it", "enc", "test", "v", "eval", "pos", "fe", "reg", "lib", "col", "fx", "pal", "pl", "ind", "entry", "value", "len", "alt", "ee", "var", "rot", "serv", "all", "local", "ol", "fl", "sil", "play", "aval", "arg", "item", "x", "cal", "vals", "arr", "tx", "Value", "buffer", "buf", "ret", "rule", "live", "update", "bl", "data", "count", "sol", "mask", "end", "sel", "bin", "pid", "valid", "pret", "al", "unit", "Val", "pre", "pr", "key", "cond", "dev", "lit", "sl", "text", "ref", "ann", "fail", "VAL", "pt", "ut", "base", "def", "slot", "el", "config", "pol", "mem", "p", "index", "vol", "b", "loc"]}}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 12470, "substitutes": {"cap_list": ["ape_list", "capslist", "caps_set", "capFedit", "ape_edit", "CAP_note", "cap_listed", "caps_list", "cap_set", "cap_lists", "cap_map", "CAP_set", "CAP_map", "cap_table", "apeFlist", "cl_list", "caps_table", "cap_def", "cp_type", "apeFlists", "cl_LIST", "cap_cache", "cp_cache", "cp_info", "apeFtable", "cap_edit", "cap_note", "ape_table", "capsmap", "cap_type", "cl_listed", "CAP_base", "capsset", "cl_set", "capFlist", "CAP_list", "CAP_lists", "cap_base", "capFtable", "capslists", "cp_list", "capFlists", "ape_lists", "cap_LIST", "apeFedit", "cap_info", "caps_def"], "params": ["ps", "caps", "json", "options", "rs", "changes", "tmp", "param", "cs", "array", "camp", "cas", "copy", "shape", "types", "cmp", "sp", "api", "plugins", "config", "proc", "pre", "ips", "par", "spec", "ctx", "opt", "ip", "args", "mac", "cli", "eps", "instance", "ams", "ram", "acl", "mc", "conf", "cms", "comp"], "errp": ["derpe", " errcp", "terr", "Erpre", "resultpr", " errfp", "errpe", "rrpre", " errpe", "errcp", "errpc", "derp", "resultps", "Ercp", "resultp", " errr", "terps", "errps", " errf", "Err", "errsp", " errpre", "errr", " errpr", "rrr", "terf", "erps", "cerp", "verpe", "cersp", "erf", "errpr", " errps", "errf", "resultsp", "verpc", " errpc", "errfp", "rrp", "erpr", "errpre", "derpc", "rrcp", "resultfp", "verfp", "erfp", "cerps", "verp", "terp", "err", "erp", "derfp", " errsp", "Erp", "resultr"], "cap": ["caps", "ct", "gap", "sv", "mp", "app", "card", "com", "exec", "jp", "tool", "cm", "Cap", "sc", "plug", "op", "ap", "bc", "act", "cop", "cf", "pc", "fab", "pac", "account", "pack", "an", "cmp", "lex", "sp", "rap", "ep", "capt", "config", "block", "ac", "ch", "can", "ce", "spec", "ip", "c", "mac", "cp", "p", "cl", "cod", "cat", "crop", "clip", "ctrl", "cr", "acl", "ca", "pl", "ab", "av", "crit", "call", "ape", "ace", "fac", "CAP", "span", "cut"], "old_postcopy_cap": ["old_postcopy_CAP", "old_postshare_cap", "old_postshare_caps", "old_postcopy_mac", "old_postshare_CAP", "old_postcopy__ap", "old_posttransfer_ap", "old_posttransfer_mac", "old_postcopy__cap", "old_postcopy__caps", "old_postcopy__CAP", "old_postshare__CAP", "old_postcopy_ap", "old_postshare__caps", "old_postcopy_cp", "old_posttransfer_CAP", "old_posttransfer_cap", "old_postcopy_caps", "old_postshare__cap", "old_postshare_ap", "old_posttransfer_cp", "old_postshare__ap"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(bdrv_get_stats(s->bs), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    bdrv_error_action(s->bs, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n", "idx": 12477, "substitutes": {"req": ["test", "exec", "patch", "requ", "resp", "obj", "query", "rf", "tar", "sec", "reg", "rb", "spec", "cur", "qs", "ver", "sr", "js", "client", "required", "temp", "e", "rt", "cmd", "resource", "res", "sq", "str", "arg", "org", "cache", "c", "input", "crit", "load", "dq", "require", "rh", "qt", "root", "rr", "sem", "rec", "fr", "ch", "quest", "dev", "http", "q", "mr", "call", "ref", "d", "app", "rs", "pull", "reader", "desc", "def", "grad", "config", "proc", "tr", "rx", "args", "info", "p", "f", "w", "err", "request", "er", "r", "gr", "pro"], "error": ["ror", "o", "address", "bug", "route", "action", "wrong", "data", "patch", "e", "base", "errors", "server", "query", "resource", "ERROR", "root", "danger", "comment", "rr", "rc", "rage", "parent", "block", "admin", "rss", "change", " exception", "no", "info", "active", "index", "type", "unknown", "ack", " Error", "row", " err", "name", "err", "Error", "er", "ace", "r", "event", "function", "code"], "is_read": ["is_valid", "as_read", "is_READ", "is_ok", " is_write", "is_reading", " is_READ", "is6read", "is6READ", "as_write", " is_ok", "as_reading", " is_valid", "is6readable", "is6write", "is_write", "is_readable", " is_readable"], "s": ["ps", "fs", "sync", "o", "app", "rs", "v", "requ", "e", "sa", "cs", "u", "server", "ds", "sys", "si", "ss", "y", "service", "se", "conf", "m", "sq", "gs", "sec", "bs", "g", "k", "self", "n", "os", "spec", "is", "c", "q", "su", "http", "sg", "input", "ns", "p", "qs", "info", "b", "scope", "f", "sr", "sb", "ses", "sis", "js", "w", "r", "ls", "sym", "S", "j", "t", "ops"]}}
{"project": "FFmpeg", "commit_id": "45198477de19ccb00729b7eec07d81494f0353e0", "target": 1, "func": "static inline void FUNC(idctRowCondDC_extrashift)(int16_t *row, int extra_shift)\n\n#else\n\nstatic inline void FUNC(idctRowCondDC)(int16_t *row, int extra_shift)\n\n#endif\n\n{\n\n    int a0, a1, a2, a3, b0, b1, b2, b3;\n\n\n\n#if HAVE_FAST_64BIT\n\n#define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN)\n\n    if (((AV_RN64A(row) & ~ROW0_MASK) | AV_RN64A(row+4)) == 0) {\n\n        uint64_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        temp += temp * ((uint64_t) 1 << 32);\n\n        AV_WN64A(row, temp);\n\n        AV_WN64A(row + 4, temp);\n\n        return;\n\n    }\n\n#else\n\n    if (!(AV_RN32A(row+2) |\n\n          AV_RN32A(row+4) |\n\n          AV_RN32A(row+6) |\n\n          row[1])) {\n\n        uint32_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        AV_WN32A(row, temp);\n\n        AV_WN32A(row+2, temp);\n\n        AV_WN32A(row+4, temp);\n\n        AV_WN32A(row+6, temp);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    a0 = (W4 * row[0]) + (1 << (ROW_SHIFT + extra_shift - 1));\n\n    a1 = a0;\n\n    a2 = a0;\n\n    a3 = a0;\n\n\n\n    a0 += W2 * row[2];\n\n    a1 += W6 * row[2];\n\n    a2 -= W6 * row[2];\n\n    a3 -= W2 * row[2];\n\n\n\n    b0 = MUL(W1, row[1]);\n\n    MAC(b0, W3, row[3]);\n\n    b1 = MUL(W3, row[1]);\n\n    MAC(b1, -W7, row[3]);\n\n    b2 = MUL(W5, row[1]);\n\n    MAC(b2, -W1, row[3]);\n\n    b3 = MUL(W7, row[1]);\n\n    MAC(b3, -W5, row[3]);\n\n\n\n    if (AV_RN64A(row + 4)) {\n\n        a0 +=   W4*row[4] + W6*row[6];\n\n        a1 += - W4*row[4] - W2*row[6];\n\n        a2 += - W4*row[4] + W2*row[6];\n\n        a3 +=   W4*row[4] - W6*row[6];\n\n\n\n        MAC(b0,  W5, row[5]);\n\n        MAC(b0,  W7, row[7]);\n\n\n\n        MAC(b1, -W1, row[5]);\n\n        MAC(b1, -W5, row[7]);\n\n\n\n        MAC(b2,  W7, row[5]);\n\n        MAC(b2,  W3, row[7]);\n\n\n\n        MAC(b3,  W3, row[5]);\n\n        MAC(b3, -W1, row[7]);\n\n    }\n\n\n\n    row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);\n\n    row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);\n\n    row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);\n\n    row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);\n\n    row[2] = (a2 + b2) >> (ROW_SHIFT + extra_shift);\n\n    row[5] = (a2 - b2) >> (ROW_SHIFT + extra_shift);\n\n    row[3] = (a3 + b3) >> (ROW_SHIFT + extra_shift);\n\n    row[4] = (a3 - b3) >> (ROW_SHIFT + extra_shift);\n\n}\n", "idx": 12493, "substitutes": {"row": ["month", "check", "column", "sc", "wheel", "group", "roll", "spec", "cur", "scan", "col", "ward", "entry", "value", "none", "array", "sync", "batch", "um", "flow", "raw", "record", "tab", "loop", "match", "pub", "element", "rows", "header", "slice", "mod", "error", "view", "word", "block", "item", "node", "now", "x", "input", "c", "line", "dd", "load", "update", "bug", "data", "user", "multi", "result", "end", "head", "model", "ow", "object", "comment", "key", "where", "order", "coll", "ack", "ko", "Row", "cell", "board", "pull", "reader", "container", "length", "server", "page", "post", "ro", "insert", "form", "config", "tr", "low", "feed", "p", "index", "device", "w", "port"], "extra_shift": ["extraJshift", "extraxoffset", "extraalshock", "final_weight", "relative_spin", "absoluteityfield", "extra_space", "extraveloffset", "extraityswitch", "secondary_shift", "extraitylow", "extreme_offset", "expecteditytransform", "extraityshift", "absolute_shift", "extra_secondary", "extra_check", "extralysecondary", "extraalshift", "extra_sync", "extraitycheck", "expectedityoffset", "extravelsup", "secondaryalshock", "extralyshift", "extra\u05bcspace", "extralysup", "expected_offset", "context_space", "context_shift", "extra_field", "extraityoffset", "extra_pop", "final_offset", "extraxfix", "extraityfield", "extravelfix", "extreme_pop", "uniqueitysup", "absoluteityshift", "special_shift", "extra_force", "extra_fix", "extreme_fix", "expected_shift", "special_offset", "extra_sq", "finalvelload", "unique_sup", "expected_check", "extra_weight", "absolute_sync", "extraxshift", "extraJslave", "extra67transform", "extra_sup", "expecteditycheck", "absoluteityswitch", "extra_square", "extra_shock", "uniqueitysecondary", "extra67set", "secondaryalshift", "extra_eight", "extraitysecondary", "extra_low", "final_shift", "extra_load", "extreme_shift", "extraveltransform", "finalveloffset", "uniqueityshift", "secondaryalset", "relative_force", "final_load", "extra\u05bcshift", "extra_slave", "external_shift", "extravellow", "extravelshift", "uniqueitylow", "extra67weight", "external_eight", "extraJfix", "secondary_set", "external_switch", "extraxslave", "extra_offset", "secondaryaltransform", "extravelsecondary", "absoluteitysync", "secondary_transform", "extra_spin", "extravelcheck", "extravelload", "extra\u05bcsquare", "extraJoffset", "special_fix", "unique_secondary", "context_square", "extra67shift", "finalvelshift", "extralylow", "extra_push", "extra_transform", "expected_transform", "extra_set", "unique_low", "extra67offset", "extravelpop", "extraitytransform", "extravelweight", "expectedityshift", "relative_sq", "extraitysup", "finalvelweight", "extra67load", "extraitysync", "external_push", "secondary_shock", "extraalset", "extra_switch", "relative_shift", "extra67shock", "absolute_field", "unique_shift", "special_slave", "extraaltransform", "absolute_switch"], "a0": ["a4", "A2", " a4", "A1", "A0", "A4", "b4"], "a1": [" a6", "b6", "A2", "A6", "A1", "a6", "A3"], "a2": ["alpha1", "a4", " a4", "alpha2", "bB", "aB", " aB", "b4", "alphaB", "alpha4"], "a3": ["a4", " a4", "alpha2", "alpha3", "b4", "alpha4"], "b0": ["B0", "a4", "B2", " b4", "B3", "B4", "b4"], "b1": ["B0", "B11", "B1", "B3", "a11", " b11", "b11"], "b2": ["B0", "B2", "B3", "B1"], "b3": ["B0", "B5", "B3", " b5", "a5", "b5", "B1"], "temp": ["orig", "atom", "test", "exec", "wr", "output", "dat", "porary", "level", "partial", "cook", "EMP", "cur", "i", "col", "wait", "cel", "diff", "t", "var", "tmp", "shift", "cont", "txt", "raw", "tc", "local", "magic", "format", "total", "new", "offset", "slice", "str", "lc", "num", "method", "flat", "item", "cache", "now", "c", "input", "memory", "off", "buffer", "option", "null", "iter", "data", "empty", "count", "sol", "result", "Temp", "size", "model", "zip", "valid", "unit", "pre", "key", "tt", "opt", "fake", "margin", "clean", "status", "ex", "unc", "name", "perature", "get", "white", "cookie", "cell", "code", "body", "adj", "tw", "content", "try", "source", "comb", "base", "cum", "style", "full", "form", "tem", "small", "tr", "mini", "read", "extra", "current", "stable", "p", "index", "inc", "ctrl", "f", "w", "err", "term", "loc", "emp", "wrap"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 12499, "substitutes": {"ta": ["ya", "asi", "ha", "ba", "aka", "tor", "ty", "fa", "nda", "oda", "sa", "oa", "area", "si", "qa", "ga", "ata", "dc", "eta", "tm", "meta", "a", "sta", "ti", "ea", "ada", "sha", "oma", "tk", "pa", "ppa", "ma", "oga", "va", "ka", "ca", "sea", "Ta", "te", "sth", "TA", "t", "da", "tta"], "bd": ["bm", "d", "isd", "dt", "bl", "zb", "nd", "md", "bf", "ld", "bc", "cd", "bda", "cb", "kb", "ds", "bind", "db", "dc", "bt", "pd", "fd", "cdn", "bg", "ded", "df", "rb", "vd", "nb", "dh", "sd", "bb", "BD", "dd", "b", "dm", "sb", "td", "gb", "gd", "da", "pb"], "irq": ["lrqs", "irk", "arqi", "ierqs", "IRq", "IRch", "nirq", "ierq", "irqs", "irke", "IRk", "lrq", "nirquest", "nirqs", "IRQ", "riqs", "lrk", "lrQ", "irch", "ierqi", "arke", "arqs", " irch", "igrke", "igrq", "irQ", "rik", "arq", "irquest", "riQ", "IRqs", "IRquest", "nirch", "riq", " irqs", "igrqs", "ierke", "igrqi", " irquest", "irqi"], "dma": ["dyfa", "lma", "dwa", "dywa", "adga", "dmas", "bpa", "bma", "bwa", "lwa", "datma", "dmma", "bfa", "datpa", " dpa", "dymma", "lmma", "bmc", " dga", "admc", "lfa", "bga", "dpa", " dmas", "datmas", "dmc", "dfa", " dmc", "adma", "datmma", "admas", "dyma", "dga", "bmma", "bmas", " dmma"], "fclk": ["rfplk", "fplb", "fmlq", "fClk", " fplk", " fplp", "fCLk", "fclq", "fclc", "fplk", "fplks", " fclp", "fClq", "fCLc", "rfplks", " fplc", "fclb", "faclk", "rfclks", "faclc", "fmlk", "rfclk", "rfclb", "fclp", "fmlp", " fclc", "rfplc", "fclks", "fClc", "fClp", "fmlc", "fCLb", "fplq", "fCLks", "rfclc", " fplq", "fplp", "fplc", " fclq", "rfplb", "faclb", "faclks"], "iclk": ["ccplsk", "icLk", "icilk", "cclk", "icplk", "icLsk", "icilq", "icLq", "icilsk", "iclsk", "ccplks", "ccplq", "icilks", "cclsk", "cclks", "icplq", "icplks", "iclks", "ccplk", "icplsk", "icLks", "cclq", "iclq"], "s": ["hs", "session", "v", "sc", "u", "ts", "its", "states", "sys", "si", "se", "m", "plugins", "self", "n", "spec", "sh", "i", "h", "qs", "sb", "js", "or", "services", "t", "ps", "fs", "sync", "o", "your", " is", "als", "cs", "e", "ss", "y", "ssl", "new", "gs", "a", "is", "c", "sg", "ns", "lines", "settings", "us", "sa", "l", "ds", "ans", "service", " parts", "vs", "sl", "ses", "ms", "sym", "S", "comments", "ows", "d", "rs", "south", "results", " values", "uns", "g", "es", "z", "k", "os", "su", "args", "p", "tests", "b", "aws", "sets", "f", "w", "ls", "r"]}}
{"project": "qemu", "commit_id": "dca6eeed8c2a1c131d161139428dd18a35e58b03", "target": 0, "func": "static void calxeda_init(MachineState *machine, enum cxmachines machine_id)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[128];\n\n    int n;\n\n    qemu_irq cpu_irq[4];\n\n    qemu_irq cpu_fiq[4];\n\n    MemoryRegion *sysram;\n\n    MemoryRegion *dram;\n\n    MemoryRegion *sysmem;\n\n    char *sysboot_filename;\n\n\n\n    if (!cpu_model) {\n\n        switch (machine_id) {\n\n        case CALXEDA_HIGHBANK:\n\n            cpu_model = \"cortex-a9\";\n\n            break;\n\n        case CALXEDA_MIDWAY:\n\n            cpu_model = \"cortex-a15\";\n\n            break;\n\n        }\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n        Object *cpuobj;\n\n        ARMCPU *cpu;\n\n        Error *err = NULL;\n\n\n\n        if (!oc) {\n\n            error_report(\"Unable to find CPU definition\");\n\n            exit(1);\n\n        }\n\n\n\n        cpuobj = object_new(object_class_get_name(oc));\n\n        cpu = ARM_CPU(cpuobj);\n\n\n\n        /* By default A9 and A15 CPUs have EL3 enabled.  This board does not\n\n         * currently support EL3 so the CPU EL3 property is disabled before\n\n         * realization.\n\n         */\n\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n\n            object_property_set_bool(cpuobj, false, \"has_el3\", &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        if (object_property_find(cpuobj, \"reset-cbar\", NULL)) {\n\n            object_property_set_int(cpuobj, MPCORE_PERIPHBASE,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ);\n\n        cpu_fiq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ);\n\n    }\n\n\n\n    sysmem = get_system_memory();\n\n    dram = g_new(MemoryRegion, 1);\n\n    memory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, dram);\n\n\n\n    sysram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0xfff88000, sysram);\n\n    if (bios_name != NULL) {\n\n        sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (sysboot_filename != NULL) {\n\n            if (load_image_targphys(sysboot_filename, 0xfff88000, 0x8000) < 0) {\n\n                hw_error(\"Unable to load %s\\n\", bios_name);\n\n            }\n\n            g_free(sysboot_filename);\n\n        } else {\n\n           hw_error(\"Unable to find %s\\n\", bios_name);\n\n        }\n\n    }\n\n\n\n    switch (machine_id) {\n\n    case CALXEDA_HIGHBANK:\n\n        dev = qdev_create(NULL, \"l2x0\");\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0xfff12000);\n\n\n\n        dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n        break;\n\n    case CALXEDA_MIDWAY:\n\n        dev = qdev_create(NULL, \"a15mpcore_priv\");\n\n        break;\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"num-irq\", NIRQ_GIC);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        sysbus_connect_irq(busdev, n + smp_cpus, cpu_fiq[n]);\n\n    }\n\n\n\n    for (n = 0; n < 128; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"sp804\");\n\n    qdev_prop_set_uint32(dev, \"freq0\", 150000000);\n\n    qdev_prop_set_uint32(dev, \"freq1\", 150000000);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff34000);\n\n    sysbus_connect_irq(busdev, 0, pic[18]);\n\n    sysbus_create_simple(\"pl011\", 0xfff36000, pic[20]);\n\n\n\n    dev = qdev_create(NULL, \"highbank-regs\");\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff3c000);\n\n\n\n    sysbus_create_simple(\"pl061\", 0xfff30000, pic[14]);\n\n    sysbus_create_simple(\"pl061\", 0xfff31000, pic[15]);\n\n    sysbus_create_simple(\"pl061\", 0xfff32000, pic[16]);\n\n    sysbus_create_simple(\"pl061\", 0xfff33000, pic[17]);\n\n    sysbus_create_simple(\"pl031\", 0xfff35000, pic[19]);\n\n    sysbus_create_simple(\"pl022\", 0xfff39000, pic[23]);\n\n\n\n    sysbus_create_simple(\"sysbus-ahci\", 0xffe08000, pic[83]);\n\n\n\n    if (nd_table[0].used) {\n\n        qemu_check_nic_model(&nd_table[0], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[0]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n", "idx": 12544, "substitutes": {"machine": ["module", "part", "engine", "computer", "bug", "address", "connection", "vm", "link", "mode", "project", "image", "process", "message", "base", "model", "server", "interface", "space", "object", "m", "service", "state", "mom", "comment", "config", "proc", "host", "linux", "kernel", "view", "class", "block", "handler", "boot", "node", "slave", "mac", "motion", "hard", "device", "instance", "table", "Machine", "controller", "template", "loader", "manager", "database"], "machine_id": ["vm_mode", "machine_name", " machine_type", " machine_ids", "vm_ids", "vm_id", "machine_mode", "machine_type", "machine_ids", " machine_name"], "cpu_model": ["cpu2resource", "cpuamsource", "currency_model", "cpu2language", "gpu_size", "vm_field", "gpu_source", "cpuLogstring", "cpu_string", "cpu_models", "vm_source", "cpu2model", "mem_language", "currency_loader", "currency_resource", "currencyjresource", "cpu67string", "gpu_mode", "cpujresource", "cpu_Model", " cpu_type", "gpu_class", "cpuLogmodels", "memLogmodels", "cpu2loader", "vm_language", "cpuamlanguage", " cpu_location", "mem_string", "cpujmodel", "mem_models", "cpu_location", "cpu_language", "vm_model", "cpu_channel", "gpu_model", "cpu_resource", "cpu67models", "gpu_channel", "cpu_type", "memLogmodel", "cpu67model", "cpu_source", "cpujfield", "memLogstring", "cpu_class", "cpujloader", "cpujsource", "currencyjlanguage", "cpujlanguage", "cpuammodel", "currencyjmodel", "cpuLoglanguage", "gpu_models", "cpu67language", " cpu_Model", "mem_model", "cpu_loader", "cpuamfield", "cpu_mode", "memLoglanguage", "currencyjloader", "cpu_size", "cpu_field", "currency_language", "cpuLogmodel"], "kernel_filename": ["kernel___filename", "kernel___license", "cpu_license", "kernel__file", "kernel_license", "kernel___files", "kernel_location", "system_location", "kernel__mode", "kernel__location", "kernel_files", "kernel_file", "system_file", "kernel___file", "kernel_mode", "cpu_filename", "system_filename", "cpu_file", "kernel__filename", "system_mode", "cpu_files"], "kernel_cmdline": ["kernel_cfglines", "kernel_hostlines", "kernel_commandlines", "kernel_cfgLine", "kernel_cmdli", "kernel_bootlines", "kernel_hostline", "kernel_bootline", "kernel_commandline", "kernel_bootLine", "kernel_cmdLine", "kernel_cfgline", "kernel_cmdlines", "kernel_commandLine", "kernel_bootli", "kernel_hostli", "kernel_hostLine", "kernel_cfgli"], "initrd_filename": ["initrd_path", "initrt_file", "initrd__uri", "initrt_name", "initrd__filename", "initrd_directory", "initrd_uri", "initrt_directory", "initrd__file", "initrt_filename", "initrt_path", "initrd_name", "initrd__path", "initrd_file", "initrt_uri"], "dev": ["debug", "serv", "app", "ev", "priv", "temp", "DEV", "pub", "prof", "conn", "serial", "def", "bus", "mod", "Dev", "pu", "rad", "block", "ch", "gu", "mem", "cache", "device", "ver", "w", "loader", "conf"], "busdev": ["BUSinfo", "busDev", "BUSdev", "BUSDev", "BUSdevice", "Busdevice", "BusDev", "bootDev", "busdevice", "bootdev", "bootinfo", "Busdev", "bootdevice", "businfo", "Businfo"], "pic": ["sync", "fs", "processor", "path", "nic", "cmp", "gui", "pins", "pid", "uu", "seq", "lc", "proc", "kernel", "eni", "mac", "rx", "lib", "itect", "cli", " pci", "vidia", "mc", "loader", "cci", "py", "conn", "img", "css"], "n": ["not", "en", "d", "o", "ne", "nn", "cn", "pn", "ng", " N", "nt", "v", "count", "e", "u", "nc", "fn", "network", "l", "m", "mn", "nr", "sn", "a", "num", "g", "un", "k", "z", "net", "np", "nb", "node", "N", "c", "i", "x", "h", "s", "ns", "p", "syn", "no", "b", "nu", "ni", "f", "name", "w", "nm", "r", "j", "t", "number"], "cpu_irq": ["cpu_mirq", "cpu_arq", "cpu_drq", "cpu_arp", "cpu_iiqq", "cpu_arqs", "cpu_pirq", "cpu_drqs", "cpu_irqq", "cpu_IRq", "cpu_iicl", "cpu_irce", "cpu_irp", "cpu_mirqq", "cpu_ircl", "cpu_iice", "cpu_drqa", "cpu_IRqa", "cpu_pirqq", "cpu_irqa", "cpu_mircl", "cpu_irqs", "cpu_drp", "cpu_pirce", "cpu_arqa", "cpu_iiq", "cpu_IRqs", "cpu_mirce", "cpu_pircl", "cpu_IRp"], "cpu_fiq": ["cpu_irqq", "cpu_irque", "cpu_rfQ", "cpu_fiqq", "cpu_iniqq", "cpu_irQ", "cpu_iniq", "cpu_fiQ", "cpu_rfq", "cpu_fique", "cpu_iniQ", "cpu_rfqq", "cpu_inique", "cpu_rfque"], "sysram": ["bootgram", "osram", "osmac", "bootram", "systemmac", "systemgram", "systemram", "sysmac", "osmem", "bootmac", "sysgram", "systemmem", "osgram", "bootmem"], "dram": ["xdmem", "fram", "farm", "darm", "fdram", "dmem", "fdgram", "fmem", "fdmem", "xdgram", "xdarm", "xdram", "fdarm", "dgram", "fgram"], "sysmem": ["syslim", "ysmem", " syslim", "ysMem", "yslim", "Syslim", "ysmb", " sysMem", " sysmb", "sysMem", "Sysmem", "sysmb", "SysMem", "Sysmb"], "sysboot_filename": ["syscpu_number", "sysboot_file", "sysboot__number", "sysboot__file", "syscpu_file", "syscpu_filename", "sysboot_number", "sysboot__filename", "sysboot__Filename", "syscpu_Filename", "sysboot_Filename"], "oc": ["enc", "o", "oca", "alloc", "soc", "oco", "oid", "bc", "nc", "obj", "oo", "pc", "voc", "ob", "toc", "ocol", "anc", "nic", "ec", "oci", "cc", "dc", "doc", "ow", "uc", "orc", "rc", "proc", "rec", "ac", "org", "os", "fc", "acs", "c", "OC", "mot", "isc", "co", "unc", "roc", "ocr", "loc"], "cpuobj": ["gpuo", "cpuact", "clockobject", "cacheo", "cachebj", "cpubj", "procobj", "cpObj", "processorobj", "pubj", "gpulab", "procob", "clockobj", "procct", "gpuct", "puct", "processorlab", "cpuo", "proccb", "puobj", "cpulab", "cpo", "cpuapi", "puObj", "gpucb", "processorobject", "clocklab", "cpobj", "gpuobject", "gpuob", "gpustr", "processorObj", "procobject", "gpuapi", "puobject", "cpuct", "gpubj", "cacheobj", "cpuObj", "bootstr", "bootobject", "cpuobject", "gpuact", "procObj", "gpuObj", "cpucb", "clockob", "clockObj", "clockapi", "cpuob", "cpustr", "pustr", "puact", "puapi", "puo", "procapi", "bootobj", "gpuobj", "pucb", "procact", "cpobject", "bootObj", "cacheObj"], "cpu": ["performance", "cn", "soc", "vm", "jp", "CPU", "nc", "bc", "pc", "gpu", "processor", "gc", "nic", "cow", "cmp", "dc", "uc", "runner", "lb", "rc", "pu", "proc", "mx", "fps", "net", "lp", "px", "np", "boot", "node", "cache", "fc", "mac", "cp", "core", "instance", "roc", "clock", "conn"], "err": ["orig", "eor", "nor", "exc", "rar", "resp", "cb", "later", "rb", "rev", "hr", "req", "rag", "ver", "sr", "here", "ait", "cr", "pl", "msg", "oller", "var", "magic", "fy", "rt", "res", "str", "error", "rage", "org", "ah", "ler", "oll", "arr", "gr", "ner", "rn", "aaa", "iter", "bug", "ry", "rh", "nil", "attr", "aer", "lr", "runner", "rr", "irm", "pr", "fr", "orr", "mr", "Er", "ir", "call", "ace", "ref", "norm", "dr", "ev", "der", "br", "yr", "kr", "doc", "erer", "ise", "yer", "rx", "inc", "f", "aster", "acer", "er", "loc", "orer", "conf"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "static int get_phys_addr_v5(CPUState *env, uint32_t address, int access_type,\n\n\t\t\t    int is_user, uint32_t *phys_ptr, int *prot)\n\n{\n\n    int code;\n\n    uint32_t table;\n\n    uint32_t desc;\n\n    int type;\n\n    int ap;\n\n    int domain;\n\n    uint32_t phys_addr;\n\n\n\n    /* Pagetable walk.  */\n\n    /* Lookup l1 descriptor.  */\n\n    table = get_level1_table_address(env, address);\n\n    desc = ldl_phys(table);\n\n    type = (desc & 3);\n\n    domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3;\n\n    if (type == 0) {\n\n        /* Section translation fault.  */\n\n        code = 5;\n\n        goto do_fault;\n\n    }\n\n    if (domain == 0 || domain == 2) {\n\n        if (type == 2)\n\n            code = 9; /* Section domain fault.  */\n\n        else\n\n            code = 11; /* Page domain fault.  */\n\n        goto do_fault;\n\n    }\n\n    if (type == 2) {\n\n        /* 1Mb section.  */\n\n        phys_addr = (desc & 0xfff00000) | (address & 0x000fffff);\n\n        ap = (desc >> 10) & 3;\n\n        code = 13;\n\n    } else {\n\n        /* Lookup l2 entry.  */\n\n\tif (type == 1) {\n\n\t    /* Coarse pagetable.  */\n\n\t    table = (desc & 0xfffffc00) | ((address >> 10) & 0x3fc);\n\n\t} else {\n\n\t    /* Fine pagetable.  */\n\n\t    table = (desc & 0xfffff000) | ((address >> 8) & 0xffc);\n\n\t}\n\n        desc = ldl_phys(table);\n\n        switch (desc & 3) {\n\n        case 0: /* Page translation fault.  */\n\n            code = 7;\n\n            goto do_fault;\n\n        case 1: /* 64k page.  */\n\n            phys_addr = (desc & 0xffff0000) | (address & 0xffff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 2: /* 4k page.  */\n\n            phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 3: /* 1k page.  */\n\n\t    if (type == 1) {\n\n\t\tif (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n\t\t    phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n\t\t} else {\n\n\t\t    /* Page translation fault.  */\n\n\t\t    code = 7;\n\n\t\t    goto do_fault;\n\n\t\t}\n\n\t    } else {\n\n\t\tphys_addr = (desc & 0xfffffc00) | (address & 0x3ff);\n\n\t    }\n\n            ap = (desc >> 4) & 3;\n\n            break;\n\n        default:\n\n            /* Never happens, but compiler isn't smart enough to tell.  */\n\n            abort();\n\n        }\n\n        code = 15;\n\n    }\n\n    *prot = check_ap(env, ap, domain, access_type, is_user);\n\n    if (!*prot) {\n\n        /* Access permission fault.  */\n\n        goto do_fault;\n\n    }\n\n    *phys_ptr = phys_addr;\n\n    return 0;\n\ndo_fault:\n\n    return code | (domain << 4);\n\n}\n", "idx": 12545, "substitutes": {"env": ["estate", "enc", "en", "engine", "serv", "environment", "ev", "dt", "fi", "exc", "vm", "txt", "v", "e", "nc", "obj", "enter", "eye", "server", "dat", "qt", "eng", "ec", "db", "queue", "esm", "conf", "dc", "vt", "header", "ef", "ep", "config", "profile", "ea", "eu", "eni", "np", "her", "ctx", "dh", "ey", "dev", "context", "viron", "dict", "ext", "cp", "esi", "energy", "que", "esc", "forge", "equ", "conn", "enh", "Environment"], "address": ["test", "ord", "abuse", "ge", "network", "output", "password", "account", "api", "channel", "location", "date", "description", "addr", "reference", "master", "array", "en", "ne", "position", "expression", "record", "adr", "image", "interface", "element", "hello", "resource", "offset", "error", "eni", "ip", "context", "event", "route", "attribute", "message", "end", "enter", "area", "average", "shape", "object", "ress", "state", "complete", "Address", "pointer", "ast", "email", "order", "name", "asm", "ace", "alpha", "ion", "length", "server", "pair", "uri", "alias", "grade", "url", "host", "config", "add", "feed", "archive", "layer", "target", "index", "device", "port", "loc", "number"], "access_type": ["access_level", "access2info", "ec_type", "access2level", "ec_level", "ec_port", "access_info", "ec_info", "access_port", "access2port", "access2type"], "is_user": ["is_pos", "id_uid", "is_server", "id_user", "id_server", "id_pos", "is_uid"], "phys_ptr": ["phys__addr", "phys__ptr", "phys__pointer", "phy_addr", "phys__struct", "phy_struct", "phy_pointer", "phy_ptr", "phys_pointer", "phys_struct"], "prot": ["client", "test", "pat", "mode", "pos", "eth", "pattern", "server", "ocol", "pri", "seq", "sec", "dim", "config", "nat", "channel", "np", "ip", "ext", "col", "prop", " protocol", "port", "platform", "chain", "conn", "len", "pro", "rot"], "code": ["fail", "charge", "step", "bug", "test", "catch", "check", "pe", "success", "data", "count", "result", "comb", "fe", "message", "length", "size", "ec", "cc", "Code", "state", "sec", "comment", "error", "rc", "go", "key", "create", "class", "ch", "id", "ce", "change", "cache", "c", "x", "line", "info", "close", "status", "ode", "cod", "cat", "order", "reason", "index", "co", "start", "name", "min", "call", "err", "loc", "comp", "codes"], "table": ["body", "trace", "module", "part", "session", "test", "file", "app", "bl", "tmp", "data", "chart", "tab", "record", "count", "mode", "tc", "result", "tree", "TABLE", "base", "model", "server", "interface", "query", "package", "round", "total", "level", "header", "account", "db", "conf", "object", "root", "state", "form", "error", "config", "cot", "key", "class", "block", "ac", "where", "flat", "cache", "stage", "pod", "description", "stable", "col", "order", "public", "row", "Table", "name", "th", "ca", "port", "td", "section", "conn", "database"], "desc": ["enc", "ord", "exec", "sc", "dir", "cd", "password", "summary", "ec", "meta", "sec", "seq", "parent", "asc", "spec", "cur", "phrase", "description", "req", "src", "des", "diff", "entry", "esc", "conn", "client", "en", "cont", "record", "adr", "path", "error", "org", "public", "done", "result", "end", "toc", "disc", "dep", "Desc", "comment", "dim", "rc", "rec", "progress", "complete", "stage", "name", "td", "text", "dest", "day", "d", "usc", "aug", "der", "decl", "acc", "dist", "comb", "server", "def", "doc", "dc", "contract", "uc", "form", "url", "config", "proc", "sub", "de", "feed", "info", "ext", "layer", "prop", "section", "loc", "conf"], "type": ["part", "test", "ty", "field", "pe", "count", "op", "pos", "year", "format", "pc", "length", "model", "size", "style", "page", "post", "day", "shape", "y", "types", "level", "ype", "group", "state", "form", "TYPE", "comment", "typ", "unit", "error", "parent", "role", "pre", "key", "class", "block", "like", "id", "version", "Type", "http", "no", "info", "p", "cat", "order", "ver", "prop", "name", "port", "call", "py", "rule", "t", "function", "ping"], "ap": ["gap", "apa", "app", "mp", "nav", "AP", "af", "tp", "ar", "ng", "amp", "acc", "op", "Ap", " cap", "pad", "cap", "rap", "ai", "sp", "map", "attr", "api", "hap", "ep", "apper", "apt", "aper", "aj", "ac", "ip", "apping", "ast", "tap", "aps", "apped", "rep", "arr", "ab", "or", "av", "ape", "snap", "arp", "array", "ad"], "domain": ["phy", "debug", "module", "part", "gap", "app", "lot", "site", "dom", "ng", "count", "dist", "nc", "dir", "command", "magic", "format", "year", "cmd", "feature", "model", "server", "page", "depth", "y", "root", "dc", "sp", "api", "sec", "error", "unit", "host", "role", "reg", "channel", "net", "country", "Domain", "cache", "node", "change", "rule", "description", "range", "index", "device", "cat", "core", "order", "rep", "name", "controller", "port", "ape", "asm", "sy", "ref"], "phys_addr": ["phys_grad", "las_addr", "phys2address", "phys_oa", "physical_adr", "phys64src", "physical_offset", "physical_ord", "phys__attr", "physPaddr", "phys__addr", "phys__ptr", "physPoffset", "phys_ord", "phys_add", "physical_attr", "phys64oa", "phys24addr", "physical_grad", "phys2add", "las_src", "phys67offset", "phys24src", "phys_wrapper", "physical_add", "physPwrapper", "physical_wrapper", "physical_ptr", "phys24oa", "physPaddress", "physical_address", "physical_addr", "las_oa", "phys__address", "phys67wrapper", "phys67address", "phys64addr", "phys_address", "phys67addr", "phys2ord", "phys_offset", "phys_adr", "phys2addr", "phys_attr", "phys_src"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n", "idx": 12548, "substitutes": {"s": ["session", "options", "u", "ts", "its", "states", "sys", "si", "in", "se", "m", "plugins", "xs", "self", "n", "spec", "qs", "sb", "js", "services", "t", "native", "ps", "sync", "serv", "fs", "o", "ins", "e", "cs", "parts", "ss", "ssl", "new", "sq", "gs", "sf", "is", "c", "sg", "ns", "sie", "settings", "stat", "socket", "storage", "us", "l", "ds", "service", "state", "stats", "http", "status", "ses", "ms", "sym", "S", "ops", "d", "sv", "rs", "strings", "south", "server", "full", "uns", "es", "ks", "os", "su", "args", "p", "aws", "sets", "f", "request", "ls", "devices"], "i": ["it", "ie", "di", "o", "gi", "chi", "ini", "iu", "fi", "multi", "li", "e", "u", "xi", "mu", "pi", "abi", "uri", "phi", "si", "in", "y", "ai", "ui", "a", "c", "ti", "z", "ix", "k", "eni", "n", "gu", "io", "id", "ci", "bi", "qi", "ip", "x", "ami", "oi", "info", "ji", "hi", "p", "index", "ri", "b", "ni", "f", "start", "zi", "child", "j", "ii", "I", "yi"]}}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "int ff_nvdec_decode_init(AVCodecContext *avctx, unsigned int dpb_size)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n\n\n    NVDECFramePool      *pool;\n\n    AVHWFramesContext   *frames_ctx;\n\n    const AVPixFmtDescriptor *sw_desc;\n\n\n\n    CUVIDDECODECREATEINFO params = { 0 };\n\n\n\n    int cuvid_codec_type, cuvid_chroma_format;\n\n    int ret = 0;\n\n\n\n    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!sw_desc)\n\n        return AVERROR_BUG;\n\n\n\n    cuvid_codec_type = map_avcodec_id(avctx->codec_id);\n\n    if (cuvid_codec_type < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec ID\\n\");\n\n        return AVERROR_BUG;\n\n    }\n\n\n\n    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);\n\n    if (cuvid_chroma_format < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported chroma format\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->thread_type & FF_THREAD_FRAME)\n\n        dpb_size += avctx->thread_count;\n\n\n\n    if (!avctx->hw_frames_ctx) {\n\n        AVHWFramesContext *frames_ctx;\n\n\n\n        if (!avctx->hw_device_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware device or frames context \"\n\n                   \"is required for CUVID decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n        if (!avctx->hw_frames_ctx)\n\n            return AVERROR(ENOMEM);\n\n        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n        frames_ctx->format            = AV_PIX_FMT_CUDA;\n\n        frames_ctx->width             = avctx->coded_width;\n\n        frames_ctx->height            = avctx->coded_height;\n\n        frames_ctx->sw_format         = AV_PIX_FMT_NV12;\n\n        frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?\n\n                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;\n\n        frames_ctx->initial_pool_size = dpb_size;\n\n\n\n        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error initializing internal frames context\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n    params.ulWidth             = avctx->coded_width;\n\n    params.ulHeight            = avctx->coded_height;\n\n    params.ulTargetWidth       = avctx->coded_width;\n\n    params.ulTargetHeight      = avctx->coded_height;\n\n    params.bitDepthMinus8      = sw_desc->comp[0].depth - 8;\n\n    params.OutputFormat        = params.bitDepthMinus8 ?\n\n                                 cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;\n\n    params.CodecType           = cuvid_codec_type;\n\n    params.ChromaFormat        = cuvid_chroma_format;\n\n    params.ulNumDecodeSurfaces = dpb_size;\n\n    params.ulNumOutputSurfaces = 1;\n\n\n\n    ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    pool = av_mallocz(sizeof(*pool));\n\n    if (!pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    pool->dpb_size = dpb_size;\n\n\n\n    ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,\n\n                                             nvdec_decoder_frame_alloc, av_free);\n\n    if (!ctx->decoder_pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    ff_nvdec_decode_uninit(avctx);\n\n    return ret;\n\n}\n", "idx": 12556, "substitutes": {"avctx": ["avelc", " avcmd", "averloc", "afconfig", "aveconfig", "evconnection", "avalloc", "vercca", " avcm", "avalcli", " avcu", "avkb", "verpkg", "avepkg", "avcf", "avbc", "navcf", "verctx", "ajctl", "avalcf", "afctx", "vercu", "avlc", "avctrl", "avercontext", "averctl", "Avconn", "avectl", "vercm", "abcf", "avqa", "AVloc", "avecca", "avalcomponent", "AVconn", "ajctx", "verqa", "avalkb", "vercmp", "afcontext", "vercf", "avcli", "AVlc", "avectrl", "avesync", "AVcmp", "evctx", "afpkg", "varctx", "navctx", "averconn", "avectx", "avctl", "avalwcs", "avpkg", "abcontext", "AVctx", "avsync", "AVcf", "AVcu", "avalqa", "AVcmd", "evcontext", "aflc", "ajconn", "avekb", "ajcontext", "varcontext", " avsync", "avercas", "Avcontext", "afkb", "avecf", "AVsync", " avcontext", "afcomponent", "afbc", "avcm", "AVctrl", "Avctx", "aveloc", "avewcs", "avcomponent", "avcu", "varpkg", "AVctl", "avecmd", "AVconfig", "verconnection", "afcu", "verconn", "navctrl", "navcontext", "avconn", " avcmp", "AVconnection", "avebc", "vercas", "Avcmp", "AVcas", "avcmp", "avalctx", "avcmd", "averctx", "AVcontext", "varbc", "avcca", "avconnection", "avalcontext", "AVpkg", "avconfig", "avecomponent", "aveconn", "avecu", "avecli", "abcmp", "avloc", " avconn", "navcmd", "abctx", "avwcs", "aveqa", "avalcca", "evcf", "vercontext", "afcm", "avcas", "avercli", "evconn", "avecontext", "avcontext", "averwcs"], "dpb_size": ["dpfb_channel", "dpfb_handle", "dpb8small", "dpb_capacity", "dpb8channel", "dpb_handle", "dpb8size", "dpfb_small", "dpfb_size", "dpb_channel", "dpfb_capacity", "dpb_small"], "ctx": ["client", "alloc", "cam", "cm", "tc", "nc", "bc", "obj", "cf", "pc", "cb", "anc", "cc", "cmp", "sq", "lc", "config", "cca", " context", "context", "c", "conv", "tx", "ca", "loc", "conn", "cas", "cv"], "pool": ["client", "prefix", "alloc", "thread", "image", "pkg", "container", "util", "val", "writer", "queue", "host", "config", "parent", "block", "Pool", "mem", "cache", "box", "conv", "lib", "cpu", "col", "coll", "port", "buffer", "buf", "conn"], "frames_ctx": ["finals_voc", " frames_lc", "framesplc", "framesingcontext", "frames___tx", "frames___ctx", "frames_cas", "framesingcmp", "finals_crit", "frames_cf", "images_coll", "hops_conn", " frames_wcs", "images_lc", "frames_cn", "frames_wcs", "framesalcf", "images_alloc", "framespcontext", "framespctx", "frames_context", "finals_ctx", "frames_lc", "images_cf", "frames___cas", "frames_cc", "hops_tx", "frames_alloc", "frames_tx", "finals_cv", "hops_cas", "images_context", "hops_ctx", "frames_conn", "images_tx", "frames___crit", "framesalctx", "frames___lc", "framesptx", "frames_cmp", "frames_coll", "frames___cc", "frames_crit", "framesingctx", "framesalcontext", "frames___cv", "images_cmp", "framesalalloc", "frames_voc", "frames___conn", "frames___wcs", "images_cn", "frames___voc", "images_ctx", "frames_cv", " frames_cc", "framesingtx"], "sw_desc": ["nw_sc", "nw_desc", "swaysec", "nw_decl", "sw2desc", " sw_description", " sw_entry", "sw_sec", "nw_rec", "swaydesc", "swpdecl", " sw_doc", " sw2esc", "swayentry", " sw_sec", "swpdesc", "sw_decl", "sw2description", "swprec", "sw_rec", "sw_entry", "sw_sc", "swpsc", "sw_esc", "sw_doc", "sw2esc", "sw2doc", " sw2desc", " sw2doc", " sw2description", " sw_rec", "swpentry", "swayrec", "sw_description", " sw_esc", "swpsec"], "cuvid_codec_type": ["cuvid_codec_name", "cuvid_codec_info", "cuvid_codac_count", "cuvid_codac_types", "cuvid_codac_info", "cuvid_codEC_name", "cuvid_codEC_id", "cuvid_codac_type", "cuvid_codec_types", "cuvid_codec_count", "cuvid_codEC_type", "cuvid_codEC_types", "cuvid_codac_id", "cuvid_codec_id"], "cuvid_chroma_format": ["cuvid_chromas_format", "cuvid_chroma___type", "cuvid_chromas_form", "cuvid_chroma_version", "cuvid_chromas_family", "cuvid_chromla_pattern", "cuvid_chroma___form", "cuvid_chroma___format", "cuvid_chromas_type", "cuvid_chroma_pattern", "cuvid_chroma___family", "cuvid_chroma_form", "cuvid_chromla_format", "cuvid_chroma_family", "cuvid_chroma_type", "cuvid_chromla_type", "cuvid_chromla_version", "cuvid_chromas_version", "cuvid_chroma_unit", "cuvid_chromas_unit"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n", "idx": 12558, "substitutes": {"mon": ["module", "month", "atom", "meter", "mol", "amon", "mail", "don", "mun", "token", "mat", "wm", "an", "m", "reg", "man", "un", "Mon", "boot", "date", "col", "pal", "bo", "mp", "my", "mu", "minute", "prem", "tom", "mt", "monitor", "on", "ran", "MON", "dom", "md", "con", "bean", "bin", "plan", "lon", "mag", "login", "mo", "fun", "wan", "comm", "lock", "mr", "member", "mc", "ms", "pin", "mor", "non", "mons", "day", "nan", "ann", "mm", "mi", "phys", "chron", "mos", "ml", "mer", "mn", "lin", "mx", "net", "mini", "rock", "vol", "platform"], "qdict": ["qudef", "dqdf", "qdat", "qdf", "dqdef", "dqdict", " qdef", "qudf", " qdat", "qudict", "dqdat", " qdf", "qudat", "qdef"], "bs": ["ps", "fs", "ba", "ins", "bl", "bas", "rs", "bn", "cs", "bc", "obj", "bu", "fb", "base", "ds", "bes", "ob", "sys", "bis", "ss", "db", "bos", "BS", "gs", "lb", "nas", "xs", "obs", "bh", "ubs", "os", "iss", "bi", "rss", "vs", "ns", "bps", "bb", "b", "src", "sb", "js", "ses", "eb", "gb", "banks", "ls", "conn", "less", "bid", "pb", "css"], "bs1": ["bisone", "ns81", "bisOne", "cs0", "bes2", "cs1", "res01", "ls2", "csone", "obsone", "ses3", "bing1", "ses2", "csOne", "bos1", "ns1", "ses11", "ps01", "psOne", "obs81", "bis1", "sespre", "bs3", "bosone", "bsOne", "lsone", "bbone", "resone", "psone", "fsone", "fsOne", "cs3", "fs3", "bes1", "bb0", "bspre", "ses0", "ses1", "obsOne", "resOne", "fs2", "bes0", "bis81", "ns2", "res1", "bs0", "ls1", "bos0", "bing11", "obs1", "ns0", "sesOne", "besone", "bsone", "bos81", "bb81", "bs01", "ps1", "bb1", "cs2", "bingpre", "bs81", "bbOne", "bs11", "bing0", "nsone", "cspre", "ls01", "fs1", "lsOne", "bs2", "cs11"], "sn_tab": ["fn_cell", "sn_stat", "sn2info", "sn1info", "SN_stat", "sn2bar", "sb_group", "sn_stack", "fn_state", "fn_info", "sb_range", "sn_lab", "snappstack", "SN_list", "sn_list", "sn8range", "sn__list", "sn_range", "snappinfo", "sn__info", "SN_tab", "SN_bar", "sn_group", "sn_bar", "sb8tab", "sb8group", "sb_info", "sn1tab", "sn_state", "SN_stack", "snapptab", "sn2tab", "SN_lab", "sb8range", "fn_tab", "sb8info", "sn8tab", "snappstat", "sn8info", "SN_info", "sn__tab", "sn8group", "sn_cell", "sn1stack", "sn1stat", "sb_tab", "sn2list", "sn__lab"], "sn": ["sync", "sv", "session", "nn", "cn", "pn", "nt", "li", "sc", "sa", "sm", "fn", "SN", "si", "kn", "ny", "na", "ssl", "ann", "sp", "attr", "sq", "sf", "dn", "n", "sch", "nb", "sd", "sh", "shell", "su", "ns", "syn", "p", "sw", "sl", "ni", "skill", "sb", "ski", "Sn", "ls", "ii", "conn", "span", "sk"], "s": ["ps", "sync", "d", "sv", "o", "session", "e", "sa", "sm", "server", "ds", "sys", "si", "ss", "space", "service", "m", "sp", "state", "sq", "gs", "sf", "g", "n", "spec", "stats", "is", "sg", "ns", "p", "b", "sl", "sb", "js", "settings", "ls", "services", "S", "t"], "sn_info": ["sn_fo", "sn_id", "SN_Info", "SN_fo", "SN_id", "sn2info", "SN_info", "sn2id", "SN_list", "sn_list", "sn2tab", "sn__tab", "sn__list", "sn__info", "SN_tab", "sn2fo", "sn__Info", "sn_Info"], "nb_sns": ["nb_sgs", "nb_pls", "nb_sls", "nb_pds", "nb_nults", "nb_pns", "nb_knas", "nb_ncs", "nb_snapns", "nb_nsts", "nbJexls", "nb_sesgs", "nb_shls", "nb_exvs", "nb_snapgs", "nb_ngs", "nb_Sds", "nb_sessions", "nbJexvs", "nb_ssns", "nb_samples", "nbJsnapns", "nb_shns", "nb_ssnas", "nbJsgs", "nb_sesls", "nb_pgs", "nb_ssls", "nb_sesds", "nb_snapessions", "nb_shults", "nb_snas", "nb_kls", "nb_pxs", "nbJsns", "nb_snapnas", "nb_nns", "nbJsnapessions", "nb_psts", "nb_sssts", "nb_exsts", "nb_sesns", "nb_nls", "nb_ssts", "nb_pults", "nb_csls", "nb_scs", "nb_csns", "nb_exls", "nb_snapls", "nbJsnapls", "nb_inns", "nb_Sns", "nbJexsts", "nb_svs", "nb_sscs", "nb_exns", "nb_shsts", "nb_pcs", "nb_sults", "nb_ssds", "nb_inds", "nbJsessions", "nb_csessions", "nbJsvs", "nb_sds", "nb_inamples", "nb_ssgs", "nb_Samples", "nbJssts", "nb_kvs", "nb_pamples", "nb_nvs", "nb_ssvs", "nb_inxs", "nbJsnapgs", "nbJexns", "nb_Sxs", "nb_snapvs", "nb_kns", "nb_nessions", "nbJsls", "nb_sxs", "nb_csgs"], "i": ["it", "ie", "di", "iter", "gi", "my", "o", "ini", "mi", "iu", "fi", "x", "multi", "li", "count", "e", "xi", "u", "mu", "inner", "end", "l", "pi", "ib", "abi", "size", "uri", "oi", "si", "y", "ai", "ui", "limit", "slice", "api", "ti", "k", "ix", "z", "eni", "n", "ci", "id", "io", "bi", "qi", "ip", "ami", "phi", "c", "info", "hi", "ki", "p", "index", "ri", "ni", "start", "f", "zi", "ind", "ski", "j", "ori", "ii", "I", "yi"], "ret": ["part", "failed", "mi", "success", "data", "nt", "match", "result", "rt", "desc", "att", "open", "sur", "val", "alt", "def", "job", "post", "full", "res", "det", "valid", "reply", "al", "error", "fun", "selected", "url", "reg", "usr", "rb", "rets", "arg", "mem", "trial", "complete", "art", "ext", "stable", "lit", "f", "sr", "re", "found", "RET", "rl", "option", "back", "bit", "r", "ref", "len", "Ret"], "available": ["expected", "limited", "empty", "external", "allowed", "volume", "existing", "supported", "length", "open", "able", "resource", "full", "ai", "ready", "protected", "usable", "valid", "availability", "api", "safe", "selected", "ac", "successful", "initialized", "installed", "current", "complete", "extra", "bound", "info", "stable", "active", "missing", "instance", "effective", "public", "used", "visible", "confirmed", "enabled", "disabled", "enough", "accessible", "Available", "published", "sum", "running", "shared"], "total": ["done", "not", "part", "limited", "list", "all", "temp", "multi", "nt", "private", "li", "count", "volume", "result", "e", "percent", "length", "base", "open", "pi", "size", "post", "qa", "Total", "partial", "full", "fat", "by", "valid", "html", "meta", "error", "scale", "parent", "last", "next", "key", "tax", "id", " Total", "current", "complete", "max", "no", "now", "info", "stable", "active", "index", "type", "cat", "we", "used", "final", "non", "sum", "t", "shared", "null"], "available_snapshots": ["available_Snapimages", "available_fourshot", "available_sshots", "available__captctions", "available2captshots", "available_gallipes", "available_captshots", "available_sppoints", "available_scs", "available_simages", "available_nshots", "available_nimages", "available_recordimages", "available_snapipes", "available2captuts", "available2captpoints", "available__captets", "available_sputs", "available_batchshots", "available_snapblems", "available_prections", "available_spments", "available2snaputs", "available_snapots", "available__snapctions", "available_spshots", "available_synshots", "available_nots", "available_sblems", "available__captots", "available__snapshots", "available_Snapblems", "available_gallimages", "available_gallots", "available__captshots", "available_captctions", "available2snapshots", "available_snapments", "available_preets", "available_preots", "available_captots", "available2snapments", "available_synctions", "available_snaputs", "available__snapets", "available_synets", "available_captuts", "available_batchpoints", "available_captpoints", "available_sshot", "available_recordshots", "available_fourshots", "available_captments", "available__snapots", "available2captments", "available_recordblems", "available_preshots", "available_snapimages", "available_snapcs", "available_captets", "available_snapshot", "available_gallshots", "available_snapets", "available_synots", "available_snapctions", "available_batchuts", "available_Snapshots", "available_batchments", "available2snappoints", "available_Snapshot", "available_recordshot", "available_fourcs", "available_Snapcs", "available_nipes", "available_snappoints"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n", "idx": 12585, "substitutes": {"c": ["enc", "d", "o", "cu", "oc", "cm", "cs", "e", "u", "C", "pc", "l", "icc", "ec", "cc", "dc", "m", "g", "k", "self", "ac", "n", "vc", "ch", "ce", "ctx", "ci", "cur", "cache", "h", "s", "p", "lib", "b", "cy", "ic", "f", "mc", "w", "r", "chain", "t", "comp", "code"], "block": ["batch", "panel", "bl", "position", "flow", "oc", "board", "output", "base", "length", "bin", "blocks", "token", "object", "root", "group", "contract", "label", "frame", "comment", "unit", "config", "pre", "parent", "channel", "inv", "Block", "lock", "cache", "node", "ip", "clean", "cl", "type", "coll", "row", "out", "buffer", "clock", "chain", "number", "code"], "probs": ["rovs", "procs", " provs", "rops", " procs", "Probs", "provs", "rob", "Prob", "prevs", "Procs", " prob", "robes", "robs", "Probes", "preps", "prebes", "probes", " props", " probes", "rocs", "preb", "prebs", "props", "prob"], "i": ["it", "d", "di", "gi", "ini", "iu", "t", "v", "li", "e", "u", "xi", "l", "pi", "token", "si", "y", "ai", "ui", "m", "k", "z", "ix", "n", "ci", "io", "id", "bi", "qi", "ip", "x", "p", "index", "b", "f", "start", "ind", "j", "ii", "I", "yi"], "zero_nhood": ["zero_lumbers", "zero_ldd", "zero_dumbers", "zero_lhood", "zero_dhood", "zero_nighth", "zero_dighth", "zero_numbers", "zero_anumbers", "zero_anmi", "zero_lighth", "zero_ddd", "zero_nmi", "zero_lmi", "zero_anighth", "zero_anhood", "zero_ndd"], "qmul": ["qdmul", " qbmUL", " qmUL", "iqcmult", "qbmUL", "qrmult", "qMuli", "iqmulator", "qcmul", "qmuli", "qmulator", "iqcmulator", "iqmult", "qdmulator", "qdmUL", "qrmul", "qmUL", " qbmul", "qrmulator", "qbmuli", "qrmUL", "qcmUL", "qMul", "qMUL", " qmuli", "qdmult", "qcmult", "qcmuli", "qbmul", "qcmulator", "iqmul", "qmult", " qbmuli", "iqcmUL", "iqmUL", "iqcmul"], "token_prob": ["token_perb", "token_probe", "token_rev", "token_funbe", "token_rebs", "token_perbs", "token_perbe", "token_prov", "token_perx", "token_funbs", "token_proc", "token_prombs", "token_probs", "token_prex", "token_promb", "token_prec", "token_prok", "token_promv", "token_preb", "token_promk", "token_funb", "token_prebe", "token_prebs", "token_perc", "token_prox", "token_reb", "token_func", "token_rek"]}}
{"project": "qemu", "commit_id": "913a87885f589d263e682c2eb6637c6e14538061", "target": 1, "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n", "idx": 12596, "substitutes": {"s": ["session", "site", "v", "u", "ts", "its", "states", "sys", "si", "m", "ims", "plugins", "xs", "self", "n", "spec", "i", "qs", "src", "sb", "as", "js", "services", "t", "native", "rates", "sync", "fs", "o", "sim", "e", "cs", "ss", "y", "ssl", "sq", "gs", "sf", "a", "sports", "is", "c", "sg", "ns", "sis", "settings", "storage", "us", "sites", "data", "l", "ds", "stats", "http", "status", "ses", "sym", "S", "d", "rs", "phys", "south", "secondary", "results", "params", "server", "full", "g", "es", "os", "su", "p", "b", "aws", "sets", "f", "w", "request", "r", "conf"], "blt_rop": ["blt__clip", "blt_clip", "blit_crop", "blit_clip", "blt_hop", "blt__rot", "blt2clip", "bls_rop", "blt2rop", "blit_rop", "blit_rot", "blt__crop", "blt2rot", "bls_crop", "blt_role", "blt__role", "bls_role", "blt2crop", "blt__rop", "blt__hop", "blt_crop", "blt_rot", "bls_hop"], "rop_func": ["rop_unc", "clip2func", "crop_unc", "clip_lambda", "rop2cb", "rop2func", "ropflambda", "clip2cb", "crop_function", "crop_func", "rop_fn", "rop_cb", "rop_function", "crop_fun", "crop_fn", "rop_fun", "rop_callback", "crop_callback", "clip_func", "ropffunc", "clip_cb", "ropfcb", "clip2lambda", "rop2lambda", "rop_lambda"]}}
{"project": "FFmpeg", "commit_id": "f5be84cfbc9c132a867ae8a8c0e0de26ed1a4e88", "target": 1, "func": "static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n\n    AVPacket *pkt) {\n\n\n\n    int chunk_type;\n\n\n\n    if (s->audio_chunk_offset) {\n\n\n\n\n\n\n\n\n        /* adjust for PCM audio by skipping chunk header */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) {\n\n            s->audio_chunk_offset += 6;\n\n            s->audio_chunk_size -= 6;\n\n\n\n\n        avio_seek(pb, s->audio_chunk_offset, SEEK_SET);\n\n        s->audio_chunk_offset = 0;\n\n\n\n        if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size))\n\n            return CHUNK_EOF;\n\n\n\n        pkt->stream_index = s->audio_stream_index;\n\n        pkt->pts = s->audio_frame_count;\n\n\n\n        /* audio frame maintenance */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM)\n\n            s->audio_frame_count +=\n\n            (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8));\n\n        else\n\n            s->audio_frame_count +=\n\n                (s->audio_chunk_size - 6) / s->audio_channels;\n\n\n\n        av_dlog(NULL, \"sending audio frame with pts %\"PRId64\" (%d audio frames)\\n\",\n\n                pkt->pts, s->audio_frame_count);\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else if (s->decode_map_chunk_offset) {\n\n\n\n        /* send both the decode map and the video data together */\n\n\n\n        if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n\n            return CHUNK_NOMEM;\n\n\n\n        if (s->has_palette) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (pal) {\n\n                memcpy(pal, s->palette, AVPALETTE_SIZE);\n\n                s->has_palette = 0;\n\n\n\n\n\n        pkt->pos= s->decode_map_chunk_offset;\n\n        avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET);\n\n        s->decode_map_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data, s->decode_map_chunk_size) !=\n\n            s->decode_map_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        avio_seek(pb, s->video_chunk_offset, SEEK_SET);\n\n        s->video_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data + s->decode_map_chunk_size,\n\n            s->video_chunk_size) != s->video_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        pkt->stream_index = s->video_stream_index;\n\n        pkt->pts = s->video_pts;\n\n\n\n        av_dlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts);\n\n\n\n        s->video_pts += s->frame_pts_inc;\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else {\n\n\n\n        avio_seek(pb, s->next_chunk_offset, SEEK_SET);\n\n        chunk_type = CHUNK_DONE;\n\n\n\n\n\n\n    return chunk_type;\n", "idx": 12607, "substitutes": {"s": ["hs", "session", "site", "ts", "its", "sys", "si", "m", "plugins", "xs", "self", "spec", "h", "qs", "sb", "as", "js", "services", "t", "ps", "sync", "fs", "o", "your", "ins", "als", "e", "cs", "parts", "scl", "ions", "ss", "ssl", "sq", "gs", "sf", "sports", "details", "is", "c", "sg", "ns", "settings", "less", "us", "sites", "multi", "l", "ds", "service", "ing", "sl", "ses", "sym", "S", "ops", "comments", "d", "sv", "rs", "secondary", "results", "features", "params", "full", "uns", "g", "es", "ks", "os", "ments", "ess", "su", "args", "p", "b", "aws", "sets", "f", "ls", "r", "conf"], "pb": ["fp", "prot", "bm", "mp", "apy", "cpp", "hub", "tp", "jp", "uf", "amp", "txt", "pkg", "bc", "pc", "pub", "pm", "fb", "cb", "pp", "wp", "pg", "db", "PB", "pd", "api", "lb", "hp", "typ", "proc", "bh", "aph", "rb", "lp", "np", "tk", "pa", "phrase", "fc", "bp", "ppa", "cp", "kk", "p", "bb", "bps", "b", "pit", "kt", "pl", "sb", "dp", "ab", "eb", "gb", "xb", "vp", "asm", "platform", "tta"], "pkt": ["tpkt", "mett", "pwk", "bwk", "pkg", "tpett", "hnt", "peth", "fkt", "pok", "psth", " pwk", "Pkg", "mkt", "opacket", "pnt", "lpeth", "fkg", "lpdt", "tpkg", "lpkt", "tpct", " pnt", "pett", "opkt", "fok", "tpwk", "opct", "opeth", " pkg", "lpacket", "spkt", "pet", "spki", "spsth", "met", " pck", "pct", "fwk", "tpacket", " pett", "bkt", "hok", " pki", "hwk", " ppt", " pdt", "pki", "Pett", "bkg", " psth", "Pck", "opck", "Pki", "Pkt", "spkg", "spacket", "ppt", "tpnt", "macket", " packet", "bok", "Pct", "Ppt", "pck", " pet", "hkt", "opdt", "packet", "sppt", "hett", "hkg", "Psth", "Packet", " peth", "pdt", "Pet", " pct"], "chunk_type": ["chunkerstate", "chkg_size", "chunker_type", "chunker_style", "chkg_num", "chunk_style", "chkg_Type", "chunk_Type", "chkg_type", "chunk_state", "chunk_size", "chunk_num", "chunkertype", "chunk_id", "chunker_state", "chunkerid", "chunker_id", "chunkerstyle"], "pal": ["ne", "panel", "app", "nav", "ass", "nn", "bl", "pe", "Pal", "chi", "opal", "real", "stal", "data", "wal", "li", "local", "ill", "plug", "ask", "sil", "raf", "skin", "sal", "dat", "pp", "val", "bin", "fal", "nil", "pid", "el", "label", "al", "wan", "ch", "pol", "apple", "ph", "cal", "pl", "cel", "pan", "py", "bat", "isal", "cell", "nl", "chal", "pel", "sk", "pod"]}}
{"project": "FFmpeg", "commit_id": "f21cf2b38365caaa8a130a32521c2648600c3f50", "target": 0, "func": "static int encode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    SliceArgs *slice_dat = arg;\n\n    VC2EncContext *s = slice_dat->ctx;\n\n    PutBitContext *pb = &slice_dat->pb;\n\n    const int slice_x = slice_dat->x;\n\n    const int slice_y = slice_dat->y;\n\n    const int quant_idx = slice_dat->quant_idx;\n\n    const int slice_bytes_max = slice_dat->bytes;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    int p, level, orientation;\n\n\n\n    avpriv_align_put_bits(pb);\n\n    skip_put_bytes(pb, s->prefix_bytes);\n\n    put_bits(pb, 8, quant_idx);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n\n        for (orientation = !!level; orientation < 4; orientation++)\n\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (p = 0; p < 3; p++) {\n\n        int bytes_start, bytes_len, pad_s, pad_c;\n\n        bytes_start = put_bits_count(pb) >> 3;\n\n        put_bits(pb, 8, 0);\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                encode_subband(s, pb, slice_x, slice_y,\n\n                               &s->plane[p].band[level][orientation],\n\n                               quants[level][orientation]);\n\n            }\n\n        }\n\n        avpriv_align_put_bits(pb);\n\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n\n        if (p == 2) {\n\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        } else {\n\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        }\n\n        pb->buf[bytes_start] = pad_s;\n\n        flush_put_bits(pb);\n\n        skip_put_bytes(pb, pad_c);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12616, "substitutes": {"avctx": ["evconv", "evctx", "avcontext", "evcontext", "avconv", "afpkg", "Avconv", "afcontext", "afctx", "Avcontext", "afconv", "evpkg", "avpkg", "Avpkg", "Avctx"], "arg": ["ad", "ay", "ar", "Args", "AR", "v", "amp", "param", "att", "val", "alias", "ang", "anc", "ai", "ig", "attr", "slice", "parse", "g", "par", "ac", "am", "ray", "Arg", " argument", "args", "mac", "arc", "arp", "arr", "load", "or", "call", "parser", "argument", "asm", "ace", "ag", "arm", "array", "var", "ann"], "slice_dat": ["slicealldata", "sliceOdef", "seed_ld", "pixelOld", "slice_dest", "slice_ld", "packageOvari", "slicealldest", "slice___dat", "sliceJgat", "sliceJdat", "volumeJtyp", "slice_not", "slice_grad", "sliceingdest", "sliceJtyp", "sliceacdan", "sliceOld", "slice_list", "sliceingdat", "sliceacinit", " slice_Dat", "sliceingdata", "slice_vari", " slice_list", " slice_def", " sliceacDat", " slice_att", "seed_dest", "package_bat", "slice_def", "volumeJgat", "sliceOdat", "slice___att", "slice_att", "seed_data", "pixel_not", "volume_batch", "slice___list", "package_dat", "sliceOdim", "volume_gat", "slice_Dat", "seed_dist", "slicealldist", "pixel_ld", "sliceingdist", "packageOdat", "package_dim", "sliceObat", "volume_typ", "seed_conn", " sliceacdat", "slice_bat", "sliceacdat", "sliceOgrad", "slice_dist", " slice_dan", "pixel_grad", "slicealldat", "slice_conn", "packageOdim", " sliceacdan", "sliceOatt", " slice_init", "volumeJdat", "sliceOvari", "slice_typ", "seed_dat", " sliceacinit", "slice_init", "slice_data", "sliceOlist", "slice_batch", "slice_dan", "package_vari", "sliceacDat", "pixelOnot", "pixelOdat", "pixel_dat", "packageObat", "sliceJbatch", "volume_dat", "slice___def", "slice_gat", "volumeJbatch", "slice_dim", "sliceOnot", "pixelOgrad"], "s": ["ps", "client", "sync", "fs", "sv", "session", "ins", "rs", "site", "south", "v", "secondary", "sc", "e", "sa", "cs", "u", "ts", "l", "ds", "sys", "si", "ss", "ssl", "service", "m", "sq", "slice", "gs", "sf", "g", "es", "self", "n", "os", "spec", "ctx", "is", "side", "c", "i", "su", "sg", "ns", "scope", "qs", "b", "core", "sl", "aws", "f", "sb", "ses", "js", "utils", "w", "groups", "settings", "ls", "services", "sym", "S", "j", "t", "r", "ops", "single"], "pb": ["fp", "prot", "bm", "mp", "cpp", "hub", "prototype", "alist", "tmp", "tp", "phys", "jp", "uf", "bf", "tc", "bc", "pkg", "plain", "pc", "pm", "cb", "fb", "wb", "pp", "rob", "wp", "pg", "summary", "db", "PB", "slice", "pd", "api", "lb", "dl", "proc", "bh", "rb", "lp", "ctx", "pa", "nb", "fc", "phrase", "bp", "ppa", "bot", "cp", "bps", "b", "esi", "lab", "sb", "dp", "pl", "ab", "bj", "python", "ub", "gp", "parser", "eb", "vp", "xb", "buf", "platform", "gb", "plugin", "buffer", "asm"], "quants": ["quans", "iquant", " quads", "operands", "quaints", "chant", "instants", "operant", "quANT", "aquants", "instaints", "instant", " quats", "quands", "aquands", "chANT", "operants", "quant", "aquaints", "iquants", "chads", " quaints", "operans", "aquats", " quant", "iquads", "quats", "aquans", " quands", "chants", "aquant", "instats", " quANT", "iquANT", "quads", " quans"], "MAX_DWT_LEVELS": ["MAX_DWT_LEVELV", "MAX_DWT_SLVELN", "MAX_DWT_LEENGTHV", "MAX_DWT_SLVELV", "MAX_DWT_LELLS", "MAX_DWT_LEVELING", "MAX_DWT_LEENGTHN", "MAX_DWT_LELLING", "MAX_DWT_SLVELS", "MAX_DWT_LELLN", "MAX_DWT_SLLLING", "MAX_DWT_SLLLV", "MAX_DWT_SLLLN", "MAX_DWT_LEVELN", "MAX_DWT_SLLLS", "MAX_DWT_LEENGTHS", "MAX_DWT_LELLV", "MAX_DWT_SLVELING", "MAX_DWT_LEENGTHING"], "p": ["fp", "ps", "part", "period", "d", " P", "o", "pe", "position", "tp", "jp", "patch", "v", "po", "per", "op", "pos", "e", "u", "pc", "l", "base", "pi", "P", "pp", "pair", "pad", "depth", "pg", "m", "pid", "a", "pre", "g", "pr", "point", "lp", "parent", "n", "np", "pa", "ip", "c", "bp", "i", "h", "cp", "q", "type", "b", "pressure", "f", "dp", "pl", "port", "j", "r", "at", "t", "ping", "code"], "level": ["sc", "condition", "limit", "vel", "scale", "parent", "variable", "col", "pl", "value", "any", "len", "sync", "Level", "o", "flow", "temp", "letter", "global", "local", "fl", "depth", "path", "pri", "time", "error", "lc", "id", "line", "lvl", "found", "levels", "pass", "rule", "lo", "update", "iter", "file", "count", "sol", "l", "rel", "model", "size", "round", "al", "unit", "pre", "key", "where", "lock", "stage", "wl", "clean", "status", "type", "coll", "name", "lf", "day", "rol", "wall", "code", "fail", "step", "ale", "ld", "length", "style", "full", "el", "url", "point", "like", "low", "version", "weight", "ul", "layer", "index", "cl", "inc", "f", "child", "w", "loc"], "orientation": ["orientator", "occupance", "orientmentation", "occupation", "rientature", "rientimation", "designations", " orientization", "rientrelation", "directionication", "occupication", "animation", "organimation", "organification", "orientimation", "organization", "rientator", "occupATION", "rientoration", "rotation", "animator", "animment", "variational", "directionated", "ortning", "directionization", "varioration", "organication", "occupator", "occupotation", "denation", "variation", "orientoration", "directionration", "orientate", "directionATION", "rientation", "rotator", "rientated", "animance", " orientmentation", "rientification", "animification", "orientrelation", "rientration", "orientance", " orientication", " orientate", "ortion", "variimation", "animmentation", "organational", "organation", "orientification", "animication", "directionation", "designration", "orientATION", "rientication", " orientration", "rotature", " orientotation", "riention", "rientization", "designATION", " orientations", "rientATION", "orientization", "designation", "animimation", " orientification", "directionment", "occupment", "pectning", "orientration", "organoration", "occupate", "organment", "organature", "orientment", "occupration", "pectation", "orientature", "rientational", " orientated", "rientotation", "orientations", "pection", "organator", "designrelation", "orientning", "orientated", "orientication", "rientment", "orientational", "rotization", "oriention", "directionrelation", "rientmentation", "ortation", "pectator", "orientotation", "denization", "ortator", "denated", "designate", " orientimation", "rientning", "rientance", "denotation", "animotation", "occupations"], "bytes_start": ["bytes_n", "bits_end", "bits_init", "bits_start", " bytes_n", "bytes_ad", "bytes_count", " bytes_end", " bytes_ad", " bytes_count", "bits_mean", "bytes_init", "bytes_mean", "bytes_end"], "bytes_len": ["bytes_max", "bytes_en", "bytes2", "bytes5len", " bytes\n", "seconds_len", "bytesxmax", "files_diff", "tes_dl", "tes\n", "bytes_dl", "tes_", "seconds_start", "tesxen", "files_start", "bytes_min", "tes_en", "tes_max", "bytesxlen", "bytes\n", " bytes_", "tes_len", "bytes5dl", "bytesxen", "tesxlen", "bits\n", "tes2", "seconds_min", "bits2", "files_l", " bytes2", "tesxdl", "seconds_base", "bytes_l", "bytes_diff", "bits_", "bytes5en", "files_len", "bytesxdl", "bytes_base", "bytes_", "tesxmax", "bytes5max"], "pad_s": [" pad_i", "padregs", "stripregy", "padXs", "pad_y", "pad_i", "strip_y", "strip_space", " pad_su", "stripregspace", "padregsum", "padregy", "pad_d", "pad_sum", "stripregsum", "padXsum", "stripregs", " pad_d", "strip_sum", "padXy", "padregspace", "pad_space", "pad_su", "padXspace", "strip_s"], "pad_c": ["pad___s", "padPcat", "pad_count", "pad67s", "pad67c", "pad___c", "pad___count", " pad_cn", "padding_s", "padding_sc", "pad_cn", "pad67count", "padding_c", "pad24c", "pad24s", "padPc", "pad___sc", "pad_cat", "pad24cat", "padPcn", "pad_sc", "padPs", "padding_count", "pad24cn", "pad67sc", " pad_cat"]}}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n", "idx": 12624, "substitutes": {"mon": ["module", "mm", "meter", "atom", "mi", "con", "mu", "mun", "pm", "bin", "mat", "mag", "mod", "om", "sam", "man", "Mon", "mem", "monitor", "met", " monitor", "min", "mc", "mid", "bo", "wat", "MON", "ann"], "ret_data": ["retacresult", "ret_body", "retacdi", "ret_result", " ret_result", " ret_obj", "ret_list", "ret_di", "retacdata", " ret_di", "ret_obj", " ret_body", " ret_list"], "cmd_list": ["cookie_head", "cmdxlist", "cfgxdel", "cookielback", "cmdipset", "cookie_back", "cmdllist", "cmd_record", "cookie_data", "cmd_set", "cmdxdel", "cmdenpre", "cmdiplist", "cmd_stack", "cmd_pre", "cmdenmain", "cmdenlist", "cmdldata", "cmdiptable", "cmdiprecord", "cmd_val", "cookieldata", "cmdxdata", "msg_main", "cmdxval", "cfg_data", "msg_table", "command_list", "cmd_del", "cmdsstack", "cmdlback", "cmdenval", "cmdxback", "cmdxhead", "cmd_head", "cfgxlist", "cmd_table", "cfgxdata", "command_set", "cookielhead", "cfg_del", "msg_list", "cmd_main", "msg_pre", "cfg_list", "cmdendata", "msg_record", "cmdendel", "cmdslist", "cmdsset", "msg_set", "cmd_List", "cfgxval", "cmd_back", "cmd_data", "cmdlhead", "cfg_val", "cmdenList", "cookiellist", "msg_List", "command_stack", "cookie_list"], "cmd": ["prefix", "module", "client", "auth", "ctr", "ct", "check", "cn", "dom", "content", "md", "cm", "command", "mode", "pt", "pkg", "obj", "nick", "cd", "cfg", "cb", "cf", "Cmd", "ht", "header", "cc", "dc", "cmp", "domain", "grad", "cook", "mod", "config", "host", "g", "method", "ck", "block", "comm", "vc", "id", "ctx", "opt", "c", "q", "cp", "clean", "cli", "req", "cat", "cl", "cod", "ctrl", "gen", "name", "crit", "msg", "child", "call", "kg", "cookie", "plugin", "conn", "custom", "code"], "buf": ["brace", "bd", "batch", "alloc", " buff", "bn", "data", "uf", "la", "raw", "br", " buffer", "bc", "ff", "base", "cb", "wb", "bin", "pad", "path", "cap", "doc", "queue", "map", "vec", "uc", "str", "seq", "fun", "rc", "pool", "num", "byte", "rb", "block", "ctx", "buff", "box", "bytes", "addr", "Buffer", "b", "lit", "coll", "bag", "src", "msg", "bo", "port", "buffer", "value", "text", "loc", "cas", "code"]}}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "func": "static void spapr_msi_write(void *opaque, hwaddr addr,\n\n                            uint64_t data, unsigned size)\n\n{\n\n    sPAPRPHBState *phb = opaque;\n\n    int ndev = addr >> 16;\n\n    int vec = ((addr & 0xFFFF) >> 2) | data;\n\n    uint32_t irq = phb->msi_table[ndev].irq + vec;\n\n\n\n    trace_spapr_pci_msi_write(addr, data, irq);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));\n\n}\n", "idx": 12635, "substitutes": {"opaque": ["opera", "openace", " opque", "iopque", "iopace", "iopatile", "operace", "opena", "opque", "operaque", " opace", "hopace", "iopaque", "opatile", "hopatile", "openaque", "opa", "hopque", " opatile", " opa", "opace", "hopaque"], "addr": ["enc", "address", "hop", "dr", "ord", "amd", "md", "mode", "adr", "pos", "cmd", "work", "align", "pad", "attr", "grad", "offset", "padding", "nr", "frame", "ptr", "sta", "config", "da", "host", "ea", "next", "add", "eni", "np", "node", "x", "ino", "pointer", "coord", "layer", "code", "mac", "device", "dd", "ast", "ext", "ack", "arr", "start", "src", "name", "advert", "asm", "ace", "ref", "len", "ad", "oa"], "data": ["batch", "address", "shift", "reader", "mode", "pos", "format", "length", "dat", "val", "def", "pad", "timeout", "uri", "res", "ata", "padding", "offset", "vec", "xy", "slice", "len", "seq", "a", "parent", "ada", "next", "feed", "cache", "memory", "pointer", "bytes", "window", "Data", "dd", "arr", "DATA", "buffer", "buf", "alpha", "da", "array"], "size": ["large", " len", " length", " payload", "Size", "raw", " ecc", " buffer", "format", "length", "val", "ec", "seq", "id", "ctx", "buffer", "SIZE", "ize", "len"], "phb": ["mphc", "PHbar", "mphb", "ophc", "mphsb", " phab", "PHa", "Phb", "mphab", "PHb", "phc", "PHsb", " phc", "Phsb", "phab", "Pha", "pha", "phbar", "ophb", " phsb", " phbar", "phsb", " pha", "ophab", "ophsb", "Phbar"]}}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n", "idx": 12642, "substitutes": {"opaque": ["ospaque", "opac", " opca", " opac", "opaques", "opaco", "ospca", " opaques", "ipaque", "optaques", "oppaques", "optca", "oppac", " opaco", "ospac", "ipaco", "optaque", "ospaques", "ipac", "ipaques", "oppaco", "oppaque", "opca", "optac"], "addr": ["enc", "address", "hop", "site", "ord", "ar", "hash", "butt", "pos", "wr", "cb", "work", "val", "nr", "seq", "sta", "reg", "location", "mac", "fx", "start", "src", "sb", "flags", "xxx", "conn", "driver", "alt", "len", "part", "en", "afi", "anne", "edge", "amp", "adr", "eth", "nick", "rt", "cmd", "offset", "str", "error", "id", "node", "ip", "x", "advert", "vr", "ad", "oa", "route", "amd", "data", "md", "area", "size", "access", "round", "cap", "cmp", "padding", "attr", "state", "ady", "xp", "rr", "byte", "art", "pointer", "od", "order", "ack", "name", "asm", "ace", "alpha", "ref", "code", "dr", "ld", "base", "align", "intel", "alias", "pad", "slot", "dc", "grad", "el", "adder", "ptr", "url", "host", "point", "east", "rx", "coord", "layer", "p", "index", "ext", "port", "loc"], "value": ["json", "address", "native", "fee", "flow", "content", "data", "v", "command", "image", "message", "format", "end", "output", "size", "server", "password", "VALUE", "val", "hello", "m", "padding", "valid", "comment", "values", "num", "reg", "key", "age", "iv", "id", "version", "current", "x", "memory", "max", "dollar", "set", "reference", "range", "p", "type", "index", "info", "none", "va", "name", "start", "w", "port", "Value", "buffer", "alt", "number", "function", "null"], "s": ["ps", "fs", "sync", "d", "o", "session", "site", "rs", "ssh", "south", "v", "e", "sa", "u", "cs", "ts", "l", "server", "ds", "states", "sys", "si", "ss", "space", "service", "ssl", "m", "new", "conf", "se", "sq", "gs", "sf", "a", "g", "es", "self", "n", "os", "spec", "is", "c", "http", "su", "i", "sg", "p", "ns", "scope", "b", "sl", "aws", "sets", "f", "sb", "sie", "w", "ses", "js", "settings", "r", "ls", "sym", "S", "services", "t", "socket"]}}
{"project": "qemu", "commit_id": "9c605cb13547a5faa5cb1092e3e44ac8b0d0b841", "target": 0, "func": "CPUX86State *cpu_x86_init(void)\n\n{\n\n    CPUX86State *env;\n\n    int i;\n\n    static int inited;\n\n\n\n    cpu_x86_tblocks_init();\n\n\n\n    env = malloc(sizeof(CPUX86State));\n\n    if (!env)\n\n        return NULL;\n\n    memset(env, 0, sizeof(CPUX86State));\n\n    /* basic FPU init */\n\n    for(i = 0;i < 8; i++)\n\n        env->fptags[i] = 1;\n\n    env->fpuc = 0x37f;\n\n    /* flags setup */\n\n    env->eflags = 0;\n\n\n\n    /* init various static tables */\n\n    if (!inited) {\n\n        inited = 1;\n\n        optimize_flags_init();\n\n    }\n\n    return env;\n\n}\n", "idx": 12645, "substitutes": {"env": ["enc", "en", "engine", "session", "app", "environment", "ev", "esp", "exec", "exc", "vm", "empty", "v", "global", "eval", "e", "nc", "obj", "erv", "cf", "fg", "oa", "output", "conn", "forest", "server", "password", "qt", "token", "eng", "ec", "db", "inst", "export", "config", "ea", "eu", "eni", "np", "her", "ctx", "ce", "init", "cache", "context", "vs", "ah", "args", "dict", "viron", "uv", "ext", "addr", "core", "scope", "f", "manager", "energy", "python", "loader", "err", "console", "enable", "event", "equ", "conf", "code"], "i": ["ie", "di", "gi", "chi", "ini", "iu", "fi", "t", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "abi", "uri", "si", "ai", "ui", "m", "slice", "ti", "z", "k", "eni", "n", "gu", "ci", "io", "id", "bi", "qi", "ip", "phi", "c", "oi", "hi", "ji", "x", "p", "cli", "index", "b", "uli", "ni", "f", "zi", "ind", "ski", "j", "ii", "I"], "inited": ["ninITED", "incitted", " INiting", "insited", "insitted", " initing", "incit", " inite", "inciting", " INITED", "insit", "inITED", " init", "inite", "ninite", " INited", "ninitted", " inended", "inended", "initing", "incite", "ninited", "initted", " initted", "init", "incited", " inITED", "incITED", " INitted", "insended", "incended"]}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n", "idx": 12663, "substitutes": {"rs": ["ps", "hs", "dr", "ins", "ars", "results", "ras", "airs", "cs", "rd", "ts", "pc", "rt", "ds", "ro", "ans", "ss", "rows", "res", "acks", "gs", "rr", "ra", "xs", "rc", "str", "rates", "ros", "pr", "RC", "rb", "ks", "bs", "spec", "rss", "hr", "acs", "stats", "rx", "arts", "ats", "args", "req", "sw", "RS", "rics", "mr", "ack", "sr", "src", "cr", "as", "ms", "Rs", "r", "rg", "ls", "ris", "rys"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int parallel_parse(const char *devname)\n\n{\n\n    static int index = 0;\n\n    char label[32];\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_PARALLEL_PORTS) {\n\n        fprintf(stderr, \"qemu: too many parallel ports\\n\");\n\n        exit(1);\n\n    }\n\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n\n    parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!parallel_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not connect parallel device\"\n\n                \" to character backend '%s'\\n\", devname);\n\n        return -1;\n\n    }\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 12667, "substitutes": {"devname": ["varnum", "Devnames", "evnum", "evName", "evno", "deviceno", "DevName", "Devno", "devicename", "devicenames", "Devname", " devno", "varName", "devName", "devno", "deviceName", "devnum", "evname", " devnum", "varname", "devnames", " devName", " devnames"], "label": ["binary", "prefix", "display", "address", "test", "hide", "field", "bl", "data", "li", "eval", "mask", "abel", "desc", "output", "base", "fb", "align", "val", "alias", "summary", "group", "el", "leaf", "valid", "comment", "unit", "error", "byte", "num", "variable", "key", "class", "block", "bad", "line", "col", "type", "unknown", "lab", "member", "Label", "name", "child", "ind", "msg", "call", "console", "value", "cell", "loc", "ref", "len", "bel", "span", "code"], "index": ["update", "prefix", "part", "module", "address", "append", "connection", "position", "action", "column", "localhost", "loop", "search", "Index", "match", "pos", "count", "end", "pattern", "length", "open", "element", "page", "condition", "path", "object", "offset", "slice", "valid", "len", "insert", "comment", "xx", "error", "find", "num", "key", "point", "id", "version", "axis", "x", "weight", "i", "pointer", "current", "ticket", "date", "active", "type", "input", "inc", "instance", "row", "ind", "diff", "option", "section", "j", "socket", "old", "number"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "START_TEST(qfloat_destroy_test)\n\n{\n\n    QFloat *qf = qfloat_from_double(0.0);\n\n    QDECREF(qf);\n\n}\n", "idx": 12668, "substitutes": {"qf": ["Qc", " qfs", " qdf", "qp", " qp", "iqfp", "qfs", "qF", "qc", "qudf", " qfp", "quf", "iqf", "eqfp", "eqF", "Qf", "quc", "eqfs", "iqF", "qfp", "Qp", "eqf", "iqfs", "qdf", "qup", "Qdf", " qF", " qc"]}}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 12672, "substitutes": {"fs_ctx": ["fsjlc", "fb_lc", "fb_ctx", "fs_connection", "fsJcf", "fs_sem", "fsprectx", "fs_rc", "fs___voc", "raf_cn", "fs___ctx", "ws_path", "fsgsem", "fs_lc", "fsgcn", "fs_src", "fs_cn", "fs_crit", "fsJcrit", "fs_xc", "fs_voc", "fs_context", "fs_cf", "fs_exc", "fs___path", "FS_src", "fb_src", "FS_context", "fsprecf", "aws_xc", "ws_conn", "vs_c", "vs_lc", "vs_connection", "vs_ctx", "FS_rc", "raf_ctx", "fsjconnection", "fsgcrit", "raf_sem", "ws_voc", "fs_c", "fs_conn", "fs___conn", "fsJctx", "fs_course", "fsgctx", "aws_course", "aws_ctx", "ws_ctx", "fsxsrc", "aws_exc", "fs_anc", "FS_ctx", "aws_exec", "fsjctx", "aws_crit", "fsprexc", "fsxrc", "fb_anc", "fsxcontext", "aws_cf", "fsxctx", "raf_crit", "fsprecrit", "fsJxc", "fsjc", "fs_exec"], "fs_path": ["fs___context", " fs___context", "fs___batch", " fs___batch", " fs_context", " fs_config", "fs_config", "fs_anc", " fs___path", "fs_batch", " fs___anc", "fs_context", "fs___anc", "fs___path", " fs_anc", "fs_tx", " fs_tx", " fs_batch"], "stbuf": ["lbuf", "STbuf", "STcb", "constbuffer", "stcb", "luf", "putfb", "STgb", "lbuff", "putbuf", "ostbuff", "constbuff", " stbuffer", "putgb", "STbuff", " stcb", "constbuf", "constuf", "putport", "puttext", " stbuff", "ctblock", "stfb", "ftcb", "stbuff", "putcb", " stbh", "ostbuf", "ctbuf", "STblock", "ctbh", "stport", "STport", "STuf", "stgb", "stbuffer", "ftbuffer", "restcb", "stblock", "resttext", "stuf", "ostbuffer", "ctbuff", "ftbuf", "ctbuffer", "restfb", " stgb", "stbh", "ostbh", "lbuffer", "restbuf", " sttext", "putbuff", "sttext", " stport", "STbuffer", " stblock", " stfb", "ftgb"], "err": ["it", "orig", "test", "nor", "ar", "resp", "act", "fe", "cb", "later", "self", "init", "req", "ver", "here", "ind", "msg", "or", "Error", "len", "ee", "all", " Err", "e", "magic", "fy", "y", "die", "str", "error", "rage", "id", "ah", "ler", "arr", "found", "ner", "dy", "aaa", "eb", "ctr", "bug", "ok", "more", "count", "result", "rh", "nil", "attr", "lr", "rr", "rc", "pr", "go", "type", "order", "mr", "Er", "out", "ref", "dr", "der", "fee", "fer", "try", "br", "ise", "range", "f", "aster", "er", "r", "loc", "gr"], "buffer": ["binary", " buf", "document", "batch", "iter", "file", "FFER", "position", "flow", "seed", "data", "uf", "raw", "reader", "texture", "source", "loop", " buffers", "message", "holder", "length", "fb", "base", "server", "size", "bin", "pad", "shape", "writer", "header", "counter", "queue", "uffer", "map", "limit", "bar", "slice", " Buffer", "str", "url", "byte", "channel", "block", "handler", "feed", "buff", "cache", "seek", "slave", "memory", "phrase", "pointer", "context", "reference", "Buffer", "device", "b", "table", "loader", "transfer", "buf", "filename", "array"], "path": ["prefix", "part", "sync", "file", "route", "connection", "content", "temp", "data", "Path", "source", "mode", "image", "dir", "fn", "inner", "end", "pattern", "area", "base", "alias", "transform", "full", "root", "uc", "url", "config", "parent", "host", "location", "view", "block", "id", "ctx", "PATH", "node", "cache", "context", "c", "home", "pointer", "current", "p", "ath", "cat", "col", "thin", "prop", "name", "mount", "child", "port", "loader", "text", "ref", "conn", "folder"], "tmp_uid": ["tmp_u", "tmp___dev", "tmp___uu", "tmp_user", "mp_user", "tmp00mode", "mp_pid", " tmp_uu", "tmp_pid", "tmp00uid", "tmp_uu", "mp_machine", "mp_uu", "tmp___u", "tmp___uid", "tmp_machine", " tmp_u", "mp_mode", "mp_uid", "tmp00uu", "tmp00user"], "tmp_gid": ["tmp_gone", "tmp_gamax", "tmp_rid", "tmp_gamid", "tmp_rad", "tmp_gax", "tmp_gident", "tmp_appid", "tmp_appids", "tmp_gamiden", "tmp_cip", "tmp_cids", "tmp_guiden", "tmp_cid", "tmp_egid", "tmp_rids", "tmp_gad", "tmp_guid", "tmp_uone", "tmp_uids", "tmp_cone", "tmp_uip", "tmp_appax", "tmp_guad", "tmp_gamids", "tmp_guax", "tmp_egident", "tmp_giden", "tmp_egids", "tmp_appiden", "tmp_rident", "tmp_egad", "tmp_guone", "tmp_gip", "tmp_guip", "tmp_guids", "tmp_gids", "tmp_guident"], "tmp_mode": ["tmp5option", "tmp67user", "mp_option", "vt_mode", "tmp_user", "mp_user", "temp_mac", "tmp67mode", "vt_mod", "tmp_dim", "tmp67mod", "vt_dim", "temp_dev", "tmp_mod", "tmp_option", "tmp_raid", "temp_mode", "temp_mod", "mp_mode", "tmp5user", "vt_raid", "tmp5mode", "tmp67option", "mp_mod", "tmp_mac", "tmp5mod"], "tmp_dev": [" tmp_de", "tmp__device", "tmp_diff", " tmp_device", "tmp_device", "tmp__push", "mp_debug", "tmp_de", "mp_dev", "mp_push", " tmp_home", "tmp_debug", "mp_device", "tmp__diff", "tmp__dev", "tmp_home", "tmp_push", "mp_mode", "mp_diff"]}}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n", "idx": 12686, "substitutes": {"env": ["enc", "en", "engine", "ne", "eve", "et", "environment", "ass", "ev", "dt", "site", "cn", "exec", "exc", "vm", "txt", "v", "inet", "global", "e", "nc", "obj", "bc", "cf", "oa", "cb", "server", "dat", "eng", "ec", "db", "conf", "el", "export", "config", "fen", "ea", "eu", "net", "kernel", "eni", "her", "np", "ctx", " environment", "init", "ce", "dev", "context", "vs", "c", "args", "viron", "dict", "ext", "code", "ah", "core", "cache", "here", "manager", "energy", "utils", "que", "err", "settings", "console", "forge", "agent", "conn", "Environment", "cv"], "excp": ["extcm", "Expc", "Excp", "execcp", "axpc", "excm", "extcp", "nexpp", "ExCP", "execcpp", "expp", "axCP", "nacs", "axcs", "nacp", "excpp", "Excs", "expc", "naCP", "execcm", "execpp", "exCP", "nexcpp", "extcpp", "extpp", "nexcm", "axcp", "napc", "nexcp", "excs"], "retaddr": [" retace", "RETaddr", "retwork", "RETace", " retwork", "RETwork", "RETnode", "retnode", "Retaddress", "retace", "Retnode", " retnode", "Retwork", "Retace", "retaddress", "RETaddress", " retaddress", "Retaddr"], "cs": ["ps", "fs", "sync", "cons", "Cs", "ars", "rs", "cn", "sc", "ras", "bc", "ts", "cf", "pc", "ds", "CS", "ss", "ec", "cc", "gs", "ces", "lc", "bs", "ck", "cus", "ks", "ci", "spec", "ctx", "os", "acs", "c", "vs", "args", "cp", "ns", "s", "cks", "ca", "js", "wcs", "ls", "conn", "cas", "sk", "css"], "t": ["it", "et", "d", "o", "test", "T", "ty", "dt", "tp", "temp", "v", "tc", "e", "pt", "u", "ts", "rt", "l", "token", "total", "y", "m", "tm", "ta", "tf", "a", "ti", "g", " p", "z", "ant", "tt", "n", "mt", "c", "x", "i", "h", "wt", "s", "off", "p", "type", "target", "b", "f", "tz", "out", "w", "port", "j", "at", " T", "null"]}}
{"project": "qemu", "commit_id": "a277c3e094d5e9f653ccc861f59e07c94c7fe6c7", "target": 0, "func": "static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n", "idx": 12701, "substitutes": {"poll": ["fp", "list", "oc", "exec", "patch", "draft", "cb", "work", "query", "ga", "reg", "ac", "lib", "bb", "col", "wait", "pick", "sync", "batch", "friend", "loop", "pc", "download", "ctl", "delay", "play", "job", "timeout", "db", "queue", "pool", "lc", "vote", "block", "oll", "load", "select", "event", "live", "lot", "bl", "data", "ll", "quit", "zip", "comment", "rec", "progress", "lock", "io", "run", "Poll", "call", "sleep", "pipe", "fail", "board", "pull", "thread", "search", "ock", "server", "irc", "lex", "wave", "config", "ctx", "feed", "p", "cl", "index", "child", "install", "loc"], "i": ["it", "adi", "d", "ie", "di", "o", "gi", "ini", "iu", "fi", "multi", "v", "li", "e", "xi", "u", "mu", "l", "pi", "abi", "ei", "uri", "si", "in", "ai", "ui", "m", "iii", "api", "lc", "ti", "ix", "z", "ci", "io", "id", "iv", "init", "bi", "qi", "ip", "c", "x", "phi", "info", "ji", "oi", "p", "index", "ri", "cli", "b", "uli", "f", "j", "ii", "I", "yi"], "rc": ["sync", "oc", "tc", "sc", "ry", "nc", "result", "bc", "rh", "pc", "cb", "qa", "gc", "anc", "ec", "cc", "irc", "dc", "uc", "reply", "rr", "error", "lc", "ck", "RC", "rb", "rec", "ac", "iv", "cur", "init", "fc", "c", "rx", "ri", "inc", "ic", "ack", "src", "cr", "roc", "err", "rl", "rn", "r", "xc", "loc", "ref", "conn", "ann", "cv"]}}
{"project": "qemu", "commit_id": "2dfb4c033f2f8fbad252bed1ba3e0fed112cbb7c", "target": 0, "func": "SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n\n                                                         bool has_id,\n\n                                                         const char *id,\n\n                                                         bool has_name,\n\n                                                         const char *name,\n\n                                                         Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockBackend *blk;\n\n    AioContext *aio_context;\n\n    QEMUSnapshotInfo sn;\n\n    Error *local_err = NULL;\n\n    SnapshotInfo *info = NULL;\n\n    int ret;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!has_id) {\n\n        id = NULL;\n\n    }\n\n\n\n    if (!has_name) {\n\n        name = NULL;\n\n    }\n\n\n\n    if (!id && !name) {\n\n        error_setg(errp, \"Name or id must be provided\");\n\n        goto out_aio_context;\n\n    }\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out_aio_context;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n\n        goto out_aio_context;\n\n    }\n\n\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n    if (!ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n\n                   \"device '%s'\",\n\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n\n\n    info = g_new0(SnapshotInfo, 1);\n\n    info->id = g_strdup(sn.id_str);\n\n    info->name = g_strdup(sn.name);\n\n    info->date_nsec = sn.date_nsec;\n\n    info->date_sec = sn.date_sec;\n\n    info->vm_state_size = sn.vm_state_size;\n\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n\n\n    return info;\n\n\n\nout_aio_context:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 12704, "substitutes": {"device": ["phy", "module", "d", "display", "di", "address", "task", "connection", "sid", "data", "attribute", "mobile", "md", "mode", "project", "feature", "disk", "direction", "package", "cmd", "model", "server", "gpu", "serial", "password", "path", "directory", "dc", "service", "tag", "uid", "dn", "Device", "unit", "host", "error", "block", "de", "node", "dev", "product", "ip", "mac", "description", "target", "component", "type", "scope", "direct", "dp", "port", "platform", "conn", "driver", "devices"], "has_id": [" has_vid", "has64ids", "has64vid", "hasWname", "hasCid", "hasCversion", "has64id", "hasOdevice", "hasCsource", "has64device", "hasWid", " has_device", "has_vid", "has_source", " has_version", "has_device", "has_version", " has_source", "hasOid", "hasOvid", "hasWsource", "has_ids", "hasWversion", "hasOids", "hasCname", " has_ids"], "id": ["it", "ids", "d", "address", "vid", "ID", "rid", "sid", "data", "user", "md", "search", "image", "oid", "hid", "act", "end", " fid", "head", "length", "size", " ID", "def", "pad", "in", "root", "ui", "pid", "uid", "kid", "error", "url", "key", "like", "block", "Id", "version", "dev", "ip", "ide", "input", "i", "ident", "aid", "index", "type", "start", "mid", "value", "number", "bid", "ad", "code"], "has_name": ["has_description", "hasJlong", "main_name", "hasSdescription", "hasJid", "nasJname", "mainSdescription", "has__name", "nas_long", "nasJid", "nasJtime", "nas_name", "has_long", "main_resource", "hasSname", "hasJtime", "mainSname", "has__resource", "mainSresource", "hasJname", "main_description", "nasJlong", "hasSresource", "has_resource", "has_time", "nas_id", "nas_time", "has__description"], "name": ["prefix", "part", "engine", "office", "data", "named", "user", "nam", "search", "image", "end", "package", "base", "size", "style", "resource", "alias", "path", "na", "space", "new", "Name", "label", "time", "error", "comment", "create", "key", "word", "block", "n", "mini", "NAME", "version", "dev", "x", "no", "description", "ident", "type", "ni", "min", "nice", "names", "nm", "non", "term", "pass", "filename", "none", "number", "custom", "wa"], "errp": ["orderpoint", "rrr", "errorb", "erps", "errorr", " errb", "errfp", " errP", "arrr", "errc", "ierpatch", "oderr", "erfp", "errorp", "armps", "oderps", "erp", "errpatch", "orderp", " erc", "arrp", " erp", "armpc", "erpi", "rrfp", " errps", "erpc", "rrp", "codep", "codeps", "errpre", " errpatch", "ierpoint", "rrb", "rrf", " erP", "rrpre", "orderpatch", "errps", " errf", "errb", "errr", "erc", "arrpi", "errpi", "finderp", "erf", "errf", "yrpa", " errpa", "errorP", "armr", " errc", "errpa", "rrP", " err", "finderps", " errpoint", "finderr", "codef", "oderp", " errfp", "finderpc", "errpc", "oderpi", " errr", "errpoint", " errpre", "yrf", "yrp", "ierp", "erpre", "errorf", "armp", "codepa", "yrps", "erP", "errP", "arrps", "err"], "bs": ["ps", "sync", "ops", "fs", "android", "us", "ins", "bl", "bas", "rs", "br", "cs", "kit", "bc", "pos", "cb", "fb", "base", "kb", "ds", "bes", "bis", "bin", "ss", "res", "db", "bos", "state", "BS", "gs", "lb", "bg", "obs", "bh", "ros", "ks", "org", "os", "iss", "bi", "bits", "vs", "bytes", "ns", "bb", "lib", "bps", "b", "src", "sb", "js", "las", "banks", "gb", "ls", "socket", "platform", "conn", "bid", "pb", "css"], "blk": ["belk", "belc", "plke", "pld", "blck", "plc", "plck", " bluk", "blc", "clks", "selc", "plkt", "BlK", "plk", "plK", " blkt", "BLok", "brK", "bld", " blc", "Blkt", "brk", "blb", "sld", "clc", "blK", "BLk", "brck", " blK", "blkt", "slk", " bld", "selke", "BLkt", "Blk", "BLks", " blb", " blck", "blok", "belK", "dlk", "slck", "dlks", "selk", "BLb", "bluk", "dlok", " blok", "selks", "plks", "dluk", "Blks", "Blb", "clke", "blke", "slkt", " blks", "blks", "clk", "belck", "brb", "Blck", "BLuk"], "aio_context": ["aio_control", "aios_ctx", "aio_stream", "aioaccontext", "aio_connection", "aioacchannel", "aioacctx", "aioacconnection", "aio_channel", "aio_ctx", "aios_stream", "aios_config", "aios_context", "aios_connection", "aio_config", "aios_control"], "sn": [" syn", "sync", "auth", " resp", "session", " disp", " ob", "sid", "nt", " ex", " obj", "fn", "Syn", "SN", " rc", "server", " detail", "si", " li", " conf", "service", " cs", " ac", "attr", "detail", "uid", " stats", "dn", " Sn", " el", "rec", " SN", "os", "spec", "opt", "details", "cache", "dev", "ip", " si", "i", " sys", "addr", " sr", "s", " rec", " sc", " res", "Sn", "settings", "handle", "loc", "conn", "sk"], "local_err": ["standardenerr", "foreignapperror", "local5ler", "foreign_err", "local_var", "internal_exp", "locallyerr", "error_err", " local_error", "local_cor", "global_user", "standardencor", "locallykey", "standardendata", "locallyvar", "foreignapperr", "localappsys", " local_ler", "local5err", "global_var", "error_rr", "local_rr", "localalerr", "local_er", "local_bug", "locallyinit", "global_err", "local_req", "standard_err", "internal_error", "foreign_sys", "localingerr", "localapperror", "local_exp", "local_user", "erroringerr", "local_sys", "foreignappsys", "local5req", "localayerr", "locallyrr", "localenbug", "locallyuser", "localalvar", "internal_err", "localinginit", "local_error", "localaybug", "error_key", "error_init", "local_ler", "localaydata", "localencor", "foreign_error", "local_key", "localalerror", "standardenbug", "localaycor", " local_er", "localendata", "localaluser", "standard_cor", "local_data", "localappmsg", "erroringinit", "localenerr", "internal_msg", "erroringrr", "localapperr", "localingrr", "erroringkey", "standard_bug", "global_error", "localingkey", "standard_data", " local_req", "local_msg", "localappexp", "locallyerror", "local_init"], "info": ["part", "data", "source", "op", "obj", "inner", "att", "sys", "def", "detail", "state", "api", "error", "os", "details", "Info", "cache", "ip", "extra", "i", "fo", "f", "INFO", "diff", "stat", "inf"], "ret": ["fin", "success", " Ret", "hash", "data", "resp", "nt", "count", "match", "result", "feat", "obj", "rt", "att", "val", "def", "alt", "res", "full", " RET", "det", "reply", "fun", "rc", "num", "reg", "rets", "arg", "rec", "rev", "mt", "no", "lit", "arr", "re", "RET", "red", "flag", "bit", "ref", "len", "Ret", "code"]}}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 12710, "substitutes": {"req": ["exec", "war", "requ", "resp", "pkg", "query", "rf", "tar", "sec", "seq", "spec", "cur", "init", "hr", "ver", "conn", "required", "iq", "worker", "rt", "cmd", "resource", "res", "sq", "str", "pri", "org", "push", "crit", "load", "dq", "ru", "ctr", "require", "data", "user", "rh", "qt", "cmp", "dep", "this", "rr", "sem", "wx", "rec", "progress", "fr", "http", "q", "mr", "call", "ref", "wa", "app", "ev", "qq", "pull", "desc", "def", "grad", "config", "proc", "tr", "low", "ctx", "rx", "ext", "p", "f", "row", "err", "request", "r", "conf", "pro"], "s": ["client", "fs", "d", "o", "session", "v", "e", "server", "ds", "sys", "si", "ss", "ssl", "service", "m", "sq", "gs", "sf", "g", "es", "n", "os", "spec", "dev", "c", "su", "p", "ns", "b", "f", "sb", "ses", "w", "js", "r", "services", "sym", "S", "t", "sk"], "vq": ["fp", "vqu", "jw", "vrqa", "hqt", "evq", "ng", "tvque", "vw", " vw", "fdev", "evp", "vqs", "fque", "evqs", "jq", "nqt", "vqt", "vrq", "hque", " vqt", " vque", "fq", "hg", "vrdev", " vg", "vrw", "jqu", "evque", "nqu", "fqa", "vqa", "tvp", "tvq", "fqu", "hq", "nque", "vg", "vque", "tvqs", "nq", "vp", "nw", "fqs", "fw", " vqa", "jque"], "vdev": ["wdev", "vdiv", " vdevice", "wdiv", "ldevice", " vev", "vev", "ldev", "wconn", "wdevice", "Vdev", "lconn", "Vrc", " vrc", "vmrc", "vrc", "vmev", " vconn", "vconn", "vdevice", " vdiv", "Vdiv", "vmdev", "Vev", "vmdiv"]}}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "bool timer_pending(QEMUTimer *ts)\n\n{\n\n    QEMUTimer *t;\n\n    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {\n\n        if (t == ts) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 12724, "substitutes": {"ts": ["ps", "TS", "fs", "test", "dt", "options", "rs", "tp", "ter", "als", "tc", "e", "cs", "its", "outs", "ss", "types", "m", "this", "ta", "times", "tm", "tf", "xs", "es", "tr", "tt", "os", "tk", "ted", "acs", "ats", "s", "tests", "Ts", "tips", "qs", "ns", "tl", "tx", "tz", "uts", "tg", "er", "td", "te", "las", "ls", "tes", "ops"], "t": ["it", "d", "ct", "o", "test", "T", "dt", "tw", "tp", "temp", "the", "v", "tc", "tree", "e", "pt", "u", "rt", "l", "unt", "token", "qt", "you", "y", "m", "ta", "tim", "tf", "time", "ti", "tr", "ant", "tt", "n", "ot", "x", "c", "h", "timer", "wt", "s", "p", "target", "type", "b", "tz", "f", "tg", "template", "that", "er", "te", "at", "null"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int av_cold libopus_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibopusEncContext *opus = avctx->priv_data;\n\n    const uint8_t *channel_mapping;\n\n    OpusMSEncoder *enc;\n\n    int ret = OPUS_OK;\n\n    int coupled_stream_count, header_size, frame_size;\n\n\n\n    coupled_stream_count = opus_coupled_streams[avctx->channels - 1];\n\n    opus->stream_count   = avctx->channels - coupled_stream_count;\n\n    channel_mapping      = libav_libopus_channel_map[avctx->channels - 1];\n\n\n\n    /* FIXME: Opus can handle up to 255 channels. However, the mapping for\n\n     * anything greater than 8 is undefined. */\n\n    if (avctx->channels > 8)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Channel layout undefined for %d channels.\\n\", avctx->channels);\n\n\n\n    if (!avctx->bit_rate) {\n\n        /* Sane default copied from opusenc */\n\n        avctx->bit_rate = 64000 * opus->stream_count +\n\n                          32000 * coupled_stream_count;\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"No bit rate set. Defaulting to %d bps.\\n\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->bit_rate < 500 || avctx->bit_rate > 256000 * avctx->channels) {\n\n        av_log(avctx, AV_LOG_ERROR, \"The bit rate %d bps is unsupported. \"\n\n               \"Please choose a value between 500 and %d.\\n\", avctx->bit_rate,\n\n               256000 * avctx->channels);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    frame_size = opus->opts.frame_duration * 48000 / 1000;\n\n    switch (frame_size) {\n\n    case 120:\n\n    case 240:\n\n        if (opus->opts.application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"LPC mode cannot be used with a frame duration of less \"\n\n                   \"than 10ms. Enabling restricted low-delay mode.\\n\"\n\n                   \"Use a longer frame duration if this is not what you want.\\n\");\n\n        /* Frame sizes less than 10 ms can only use MDCT mode, so switching to\n\n         * RESTRICTED_LOWDELAY avoids an unnecessary extra 2.5ms lookahead. */\n\n        opus->opts.application = OPUS_APPLICATION_RESTRICTED_LOWDELAY;\n\n    case 480:\n\n    case 960:\n\n    case 1920:\n\n    case 2880:\n\n        opus->opts.packet_size =\n\n        avctx->frame_size      = frame_size * avctx->sample_rate / 48000;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame duration: %g.\\n\"\n\n               \"Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\\n\",\n\n               opus->opts.frame_duration);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->compression_level < 0 || avctx->compression_level > 10) {\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Compression level must be in the range 0 to 10. \"\n\n               \"Defaulting to 10.\\n\");\n\n        opus->opts.complexity = 10;\n\n    } else {\n\n        opus->opts.complexity = avctx->compression_level;\n\n    }\n\n\n\n    if (avctx->cutoff) {\n\n        switch (avctx->cutoff) {\n\n        case  4000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_NARROWBAND;\n\n            break;\n\n        case  6000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;\n\n            break;\n\n        case  8000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_WIDEBAND;\n\n            break;\n\n        case 12000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND;\n\n            break;\n\n        case 20000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_FULLBAND;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Invalid frequency cutoff: %d. Using default maximum bandwidth.\\n\"\n\n                   \"Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\\n\",\n\n                   avctx->cutoff);\n\n            avctx->cutoff = 0;\n\n        }\n\n    }\n\n\n\n    enc = opus_multistream_encoder_create(avctx->sample_rate, avctx->channels,\n\n                                          opus->stream_count,\n\n                                          coupled_stream_count,\n\n                                          channel_mapping,\n\n                                          opus->opts.application, &ret);\n\n    if (ret != OPUS_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to create encoder: %s\\n\", opus_strerror(ret));\n\n        return ff_opus_error_to_averror(ret);\n\n    }\n\n\n\n    ret = libopus_configure_encoder(avctx, enc, &opus->opts);\n\n    if (ret != OPUS_OK) {\n\n        ret = ff_opus_error_to_averror(ret);\n\n        goto fail;\n\n    }\n\n\n\n    header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0);\n\n    avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!avctx->extradata) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate extradata.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    avctx->extradata_size = header_size;\n\n\n\n    opus->samples = av_mallocz(frame_size * avctx->channels *\n\n                               av_get_bytes_per_sample(avctx->sample_fmt));\n\n    if (!opus->samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate samples buffer.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay));\n\n    if (ret != OPUS_OK)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Unable to get number of lookahead samples: %s\\n\",\n\n               opus_strerror(ret));\n\n\n\n    libopus_write_header(avctx, opus->stream_count, coupled_stream_count,\n\n                         opus_vorbis_channel_map[avctx->channels - 1]);\n\n\n\n    ff_af_queue_init(avctx, &opus->afq);\n\n\n\n    opus->enc = enc;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opus_multistream_encoder_destroy(enc);\n\n    av_freep(&avctx->extradata);\n\n    return ret;\n\n}\n", "idx": 12730, "substitutes": {"avctx": ["avelc", "avecn", "ajctrl", "avvoc", "umcmp", "avcp", "afconfig", "aveconfig", "afsci", "afctrl", "auctx", "afloc", "avsci", "avkb", "navvoc", "avci", "avepkg", "avcf", "afcoll", " avci", "ajcci", "verctx", "aucontext", "apconn", "avcci", "afctx", "avekw", "avlc", "avctrl", "averc", "Avconn", "apcca", "plugcontext", "avtx", "avrc", "AVloc", "avecca", "avcn", "navconfig", "ajctx", "AVconn", "apcontext", "afcontext", "ajconfig", "vercf", "avevoc", "akctx", "AVlc", "akcontext", "AVcmp", "afpkg", "avecus", "navctx", "avectx", "avecp", "avecci", "avpkg", "alctrl", "Avloc", " avkw", "avetx", "abcontext", "ajcdn", "AVctx", " avloc", "AVcu", "AVcf", "auconn", "avalcus", "aflc", "avecmp", "avcdn", "avekb", "ajcontext", "afnas", "auconfig", "abconn", "akloc", "Avcontext", "afkb", "avecf", "apctx", " avcontext", "alctx", "afcdn", "avecoll", "Avctx", "afvoc", " avcci", "aveloc", "AVkb", "avkw", "afcf", "ausci", " avconfig", "awctx", "afci", "avcu", "afconn", "alcontext", "awnas", "plugctx", "afcmp", "aftx", "AVconfig", "navsci", "avesci", "umtx", "AVcca", "vercoll", "navcontext", "avconn", "plugcn", " avcmp", "avcus", " avvoc", "avalctx", "avcmp", "afcus", "AVcontext", " avcoll", "avcca", "AVnas", "aucu", "avnas", "akconfig", "afcn", "avalcontext", "avconfig", "aveconn", "avecu", "avcoll", "avloc", "awcontext", " avconn", "abctx", "AVci", "awlc", "abcp", "navrc", "afkw", "plugconfig", "afrc", "AVsci", "umctx", "afcci", "umcontext", "vercontext", "alcdn", "apkb", "avalpkg", "apcf", "afcp", "avecontext", "avcontext"], "opus": ["append", "oc", "office", "obj", "iop", "join", "fb", "osa", "api", "edit", "operator", "ahi", "np", "avi", "esi", "oph", "opa", "ave", "ocr", "abo", "auc", "anus", "o", "apa", "mp", "iti", "afi", "opp", "split", "author", "image", "cop", "wiki", "abi", "opers", "opl", "bos", "slice", "audio", "osi", "org", "ip", "voice", "gmail", "avin", "apache", "creator", "oper", "original", "umi", "data", "jp", "voc", "wp", "object", "root", "php", "lp", "oga", "effect", "av", "roc", "wikipedia", "ops", "opter", "op", "orb", "alias", "oss", "asu", "capt", "archive", "wav", "opted", "ogg", "eff", "pb"], "channel_mapping": ["channel_matching", "channel_Mappings", "channel_smapping", "channel_smasing", "channel_mapper", "channel_lmap", "channel_dimappings", "channel_lapping", "channel_mmap", "channel_lappings", "channel_Mapper", "channel_lasing", "channel_Matching", "channel_Masing", "channel_latching", "channel_dimmap", "channel_Mmap", "channel_mappings", "channel_lapper", "channel_smapper", "channel_dimapping", "channel_masing", "channel_smappings", "channel_Mapping", "channel_dimatching"], "enc": ["auth", "alloc", "alg", "acc", "nc", "obj", "util", "voc", "conn", "sys", "eng", "ec", "transform", "ant", "rec", "ac", "iv", "acs", "conv", "mac", "cat", "inc", "sl", "ack", "Enc", "nec", "cv"], "coupled_stream_count": ["coupled_streamslength", "coupled_channel_path", "coupled_channel_sum", "coupled_stream_sum", "coupled_stream_type", "coupled_stream_size", "coupled_channel_count", "coupled_stream_length", "coupled_channel_size", "coupled_channel_type", "coupled_channel_length", "coupled_streamscount", "coupled_stream_path", "coupled_streamssize"], "header_size": ["header64number", "header64size", "header_number", "header_count", " header_bytes", "header64bytes", " header64count", " header_number", " header64number", "header64count", " header64bytes", " header_count", "header_bytes", " header64size"], "frame_size": ["window_size", "file_size", "fram_Size", "iframe___duration", "frame_Size", "frame_offset", "file_length", "window_offset", "frame_rate", "iframe_size", "iframe___count", "frame___count", "frame64size", "frame_length", "frame_duration", "window_count", "iframe_count", "iframe_duration", "frame_mode", "frame_count", "file_speed", "image_type", "fram_size", "fram_speed", "image_start", "frame64start", "window_rate", "frame64scale", "image_size", "image_scale", "iframe___size", "fram_rate", "frame_scale", "frame_speed", "frame_start", "frame___size", "file_mode", "frame_type", "frame___duration", "frame64type"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int sig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t    \t   && current->exec_domain->signal_invmap\n\n\t\t    \t   && sig < 32\n\n\t\t    \t   ? current->exec_domain->signal_invmap[sig]\n\n\t\t\t   : */sig),\n\n\t\t\t  &frame->sig);\n\n\terr |= __put_user((target_ulong)&frame->info, &frame->pinfo);\n\n\terr |= __put_user((target_ulong)&frame->uc, &frame->puc);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Create the ucontext.  */\n\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\n\terr |= __put_user(0, &frame->uc.uc_link);\n\n\terr |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);\n\n\terr |= __put_user(/* sas_ss_flags(regs->esp) */ 0,\n\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\n\terr |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 12741, "substitutes": {"sig": ["sesigma", "psig", "nsIG", "sesigs", "pock", " sIG", "gsigma", "SIG", "setsigma", "pigs", "setsIG", " sigma", "sigma", "nsigs", "pig", "setsigh", "dsig", "sesIG", "sigs", "Sig", "nsig", "sock", "dsigma", "setsig", "Sigma", "Sigs", "sigh", "pigma", "ssock", "ssigs", "sesigh", "psigs", " sigs", "ssigma", "gsIG", "dsIG", "dsigh", "psock", "sIG", "gsig", "gsigs", "psigma", "sesig", "nsigma", "ssig"], "ka": ["ya", "ha", "aka", "ba", "qua", "ua", "asa", "la", "sc", "sa", "za", "oa", "area", "kb", "KA", "na", "qa", "ga", "ai", "ta", "ema", "ra", "sta", "cha", "ae", "cca", "ea", "LA", "eka", "ia", "ctx", "ker", "ama", "ma", "ki", "va", "kt", "wa", "ca", "au", "ko", "ku", "da", "ja", "ket"], "info": ["update", "afi", "ini", "mi", "fi", "source", "image", " inf", "util", "abi", "job", "si", "path", "in", "summary", "ai", "ui", "zip", "hel", "uc", "api", "meta", "config", "up", "hand", "iso", "ci", "id", "init", "Info", "home", "context", "ami", "buff", "i", "hi", "index", "isu", "inc", "about", "fo", "f", "name", "INFO", "diff", "py", "stat", "setup", "ii", "loc", "information", "conf", "inf", "help", "code"], "set": ["SET", "update", "enc", "en", "clear", "et", "ne", "send", "site", "exec", "reset", "sc", "kit", "e", "ut", "Set", "store", "end", "sel", "base", "dat", "si", "se", "loc", "state", "ise", "export", "parse", "config", "pre", "vert", "net", "block", "spec", "iss", "init", "context", "sh", "ze", "status", "ex", "cal", "sets", "gen", "start", "ind", "msg", "get", " en", "que", "ner", "section", "stat", "setting", "sche", "setup", "eq", "from"], "env": ["estate", "enc", "en", "et", "ne", "environment", "ev", "ini", "exc", "data", "v", "e", "dat", "qt", "si", "eng", "ec", "db", "el", "ise", "ef", "ep", "config", "ea", "eu", "net", "ette", "eni", "np", "ctx", "init", "dev", "context", "vs", "stage", "dict", "viron", "ext", "ind", " en", "eq", "loc", "conf"], "frame": ["module", "session", "hop", "pe", "shot", "draw", "fe", "cf", "fb", "Frame", "seq", "role", "boot", "window", "component", "scope", "frames", "setup", "none", "part", "ne", "iframe", "flow", "position", "e", "image", "element", "processor", "slice", "view", "figure", "block", "node", "c", "line", "cpu", "load", "sche", "raise", "event", "update", "file", "plane", "fi", "data", "jp", "user", "flower", "result", "feat", "fram", "cfg", "message", "cycle", "model", "nil", "object", "zip", "state", "parse", "profile", "scene", "class", "fr", "ch", "lock", "fake", "stage", "call", "que", "ace", "framework", "game", "design", "code", "body", "step", "dr", "connection", "thread", "source", "rame", "feature", "za", "base", "style", "note", "def", "el", "cha", "config", "point", "tick", "ctx", "version", "fc", "ze", "motion", "layer", "target", "layout", "range", "b", "plate", "f", "row", "section", "build", "next", "function"]}}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n", "idx": 12777, "substitutes": {"ioc": ["atioci", " iog", "liocation", " ioci", "diocation", "ialloc", "inioo", "tioc", "aoo", "dioc", "ioo", "sioc", "atialloc", "iniocl", "iuocl", "aocl", " ialloc", "diocol", "iocl", "aiow", "yioc", "yiocol", "iuoc", "siog", "atioo", "inioc", "yiuc", "atiuc", "iuocation", "tialloc", "tiocl", "iuc", "atiocl", " iroc", "aioc", "siroc", "iocation", "atiocol", "siow", "iniocol", " iocl", "liocl", "aiog", "iroc", "airoc", "ioci", "lioci", "iog", "diuc", "yiocation", "tioci", "aoc", "atioc", "aocol", "iuoci", " iow", "atiocation", "iocol", "iow", "lioc"], "buf": ["fp", "aux", "ru", "batch", "pkg", "alloc", "func", "fi", "uf", "la", "bf", "br", "bc", "comb", "ff", "bu", "cf", "fab", "cb", "fb", "output", "wb", "cmd", "cap", "queue", "cmp", "uu", "vec", "uc", "fd", "pool", "seq", "ptr", "rc", "config", "usr", "bh", "proc", "lc", "rb", "block", "ctx", "buff", "home", "context", "c", "feat", "conv", "Buffer", "bb", "req", "cat", "b", "begin", "bag", "coll", "src", "ab", "port", "av", "buffer", "auc", "font", "text", "loc", "cas", "null", "cv"]}}
{"project": "qemu", "commit_id": "1606e4cf8a976513ecac70ad6642a7ec45744cf5", "target": 1, "func": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n", "idx": 12780, "substitutes": {"blk": ["blku", "belku", "belk", "brkt", " blke", "plke", "belks", "blck", "belb", "plck", "elok", "clkt", "belok", "elk", "flke", "brku", "plkt", "belkt", "plk", " blkt", "Blck", "brke", "brk", "blb", "flck", "brck", "clku", "blkt", "blsk", "Blke", "Blk", "blok", " blck", " blb", "elke", "flk", "plok", "belke", "brsk", " blok", " blsk", "plks", "plb", "brok", "Blks", "clke", "elck", "blke", " blks", "elsk", "blks", "clk", "plsk", "belck", "brks", "elkt", "flsk"]}}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 12785, "substitutes": {"port": ["address", "file", "ports", "route", "proxy", "v", "Port", "count", "pt", "PORT", "pos", "end", "length", "server", "path", "db", "pid", "host", "nat", "method", "config", "point", "proc", "ort", "ip", "cp", "p", "type", "name", "value", "socket", "loc", "ref"], "sockaddr": ["Sockwork", "sipattr", "sigaddr", "sworkaddr", "insockadr", "statesocketptr", "Sockaddr", "sOCKaddress", "dsockptr", "sOCKadr", "sinkaddr", "ingsockhost", "statesockethost", "insockaddr", "dsockaddress", "insvcaddr", "sinkattr", " sockaddress", "sigattr", "statesockaddr", "socketserver", "sipaddress", "svcattr", "sworkopt", "socksadr", "Sockadr", "statesocketaddr", "sockswork", "statesocketserver", "sockaddress", "sinkopt", "Socksadr", "statesockserver", "socketdriver", "insigadr", "swinlayer", "insvcopt", "dsipaddr", "socksaddress", "songaddr", "sinkserver", "sipadr", "sinkadr", "dsockattr", "synserver", "swinopt", "socketaddress", "sigopt", "sockhost", "sockwork", "sipopt", "sockshost", "songattr", "socketptr", "sockoa", "siphost", " sipaddr", "sipaddr", "sigptr", "dsipattr", "ingsockaddress", "insockaddress", "socketaddr", "swinaddr", "ingsockdriver", "sOCKoa", "sipdriver", "svclayer", "Sockswork", "socklayer", "insigaddress", "songaddress", "insocklayer", "sockserver", "sockdriver", "sworkadr", "sigoa", "songptr", "sinkhost", "dsipaddress", "ingsocketaddress", " sipoa", "ingsocketdriver", "synaddr", "sigadr", "sipptr", "sinkptr", " sockadr", "Sockhost", "insockattr", "sockopt", "svcopt", " sockoa", "insigaddr", "svcaddr", "dsockaddr", "synhost", "sighost", "statesockptr", "socksaddr", "insvcattr", "sworkaddress", "dsipptr", "synptr", "sipoa", "swinattr", " sipaddress", "insockopt", "sockattr", "sinkwork", " sipadr", "insvclayer", "sockadr", "statesockhost", "Socksaddr", "sockethost", "ingsockethost", "Sockshost", "ingsocketaddr", "sinklayer", "socksdriver", "insigopt", "sigaddress", "sigwork", "ingsockaddr", "sOCKaddr", "sockptr"], "fd": ["fp", "pipe", "fs", "d", "bd", "ct", "eth", "file", "dt", "fin", "func", "fi", "nd", "exec", "v", "bf", "md", "ld", "dir", "fl", "fn", "ff", "cf", "fe", "cd", "fb", "wd", "hd", "ds", "dat", "l", "def", "cb", "fat", "db", "dc", "pd", "sf", "frame", "dn", "fun", "dl", "fen", "df", "vd", "handler", "xd", "ln", "feed", "fc", "sd", "c", "fed", "dd", "sl", "fx", "f", "lf", "red", "ind", "FD", "td", "buf", "dy", "socket", "conn", "da", "ad", " fid"], "val": ["fail", "serv", "VAL", "test", "v", "resp", "ol", "eval", "pt", "fl", "rt", "sel", "rel", "base", "alt", "slot", "timeout", "res", "pet", "loc", "pid", "el", "grad", "valid", "al", "pret", "sec", "unit", "Val", "byte", "reg", "cond", "arg", "opt", "x", "rx", "addr", "index", "lit", "sl", "vals", "lv", "RET", "ind", "bit", "value", "buf", "ref", "len", "rot"], "ret": ["part", "ft", "fin", "success", "hash", "v", "resp", "bf", "nt", "eval", "count", "pt", "result", "obj", "eth", "ben", "del", "rt", "cb", "sel", "att", "res", "db", "pet", "el", "det", "valid", "len", "al", "fun", "num", "reg", "rb", "rets", "arg", "mt", "rx", "art", "lit", "arr", "re", "RET", "flag", "rl", "py", "bit", "j", "r", "pass", "ref", "alt", "Ret", "ann"]}}
{"project": "qemu", "commit_id": "280503ee9d7833a793770d732dda5358659825e9", "target": 1, "func": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}", "idx": 12786, "substitutes": {"klass": [" klasses", "Kclass", "Klf", "kclass", " kcl", " kclass", "sklf", " klf", "klf", "Klass", "klasses", "sklass", "skcl", "kcl", "Kcl", "sklasses", "skclass", "Klasses"], "data": ["d", "di", "o", "reader", "result", "dat", "ds", "def", "db", "m", " d", "config", "parent", "df", "context", "input", "i", "info", "device", "Data", "dd", "f", "DATA", "da"], "dc": ["d", "deck", "di", "dt", "driver", "director", "acc", "tc", "sc", "nc", "bc", "cd", "cf", "enter", "desc", "dat", "ds", "gc", "doc", "ec", "ga", "dk", "cc", "db", "disc", "cdn", "lc", "config", "cca", "rc", "df", "ac", "DC", "tk", "fc", "center", "c", "dd", "coll", "f", "mc", "design", "da"], "k": ["d", "o", "ad", "ok", "kick", "kin", "e", "u", "wk", "work", "kn", "kr", "cc", "dk", "kid", "ke", "g", "ck", "ks", "key", "self", "n", "ik", "tk", "K", "c", "q", "uk", "ki", "kk", "p", "ak", "kw", "f", "ijk", "kt", "ko", "ku", "mk", "t", "ka", "sk", "kind"]}}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        ioreq_t copy = *req;\n\n\n\n        xen_rmb();\n\n        handle_ioreq(state, &copy);\n\n        req->data = copy.data;\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xenevtchn_notify(state->xce_handle,\n\n                         state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n", "idx": 12787, "substitutes": {"opaque": ["opusaques", "opaques", "opaco", "catacity", "oaques", "popaco", "ompacity", "opusaque", "opque", "oque", "cataques", "opusque", "OPque", "cataque", "opacity", "oaque", "ompaque", "ompaques", "OPaque", "opusaco", "popque", "popaque", "ompque", "catque", "OPaques", "oaco", "OPacity", "popaques"], "state": ["estate", "session", "address", "patch", "pos", "work", "states", "se", "parent", "scale", "role", "reg", "self", "un", "cur", "addr", "set", "scope", "instance", "start", "msg", "j", "driver", "part", "o", "seed", "ate", "e", "media", "use", "State", "resource", "job", "tag", "offset", "slice", "str", "error", "id", "power", "cache", "is", "node", "stat", "socket", "rule", "manager", "update", "powered", "data", "kill", "count", "message", "head", "area", "size", "pid", "this", "parse", "are", "key", "ch", "q", "art", "stage", "status", "type", "name", "call", "ace", "handle", "sy", "code", "action", "private", "source", "mode", "store", "length", "style", "grade", "ptr", "config", "STATE", "g", "trigger", "version", "info", "range", "p", "core", "index", "port", "err", "er", "request", "loc"], "req": ["orig", "hop", "exec", "patch", "requ", "resp", "repl", "cb", "quire", "rf", "seq", "parent", "reg", "spec", "cur", "diff", "conn", "client", "prefix", "required", "flow", "worker", "download", "rt", "cmd", "copy", "State", "resource", "queue", "sq", "mod", "pri", "error", "org", "id", "cache", "push", "load", "dq", "stat", "ctr", "require", "task", "grab", "data", "ry", "rel", "access", "write", "qa", "cmp", "rr", "sem", "release", "key", "rec", "progress", "http", "q", "art", "type", "ir", "name", "call", "ref", "comp", "fail", "pull", "op", "desc", "ro", "grad", "ptr", "config", "proc", "ctx", "read", "rx", "cp", "info", "core", "child", "loader", "err", "request", "er", "transfer", "r", "conf", "next", "pro"]}}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 12789, "substitutes": {"r": ["d", "ru", "o", "rw", "dr", "rs", "ar", "R", "rar", "ur", "br", "e", "u", "result", "rh", "wr", "rt", "l", "kr", "res", "rf", "m", "this", "lr", "nr", "rr", "str", "ra", "rc", "usr", "pr", "g", "tr", "rb", "k", "rec", "self", "fr", "cur", "hr", "x", "i", "rx", "h", "c", "s", "p", "req", "range", "b", "run", "mr", "arr", "sr", "f", "ir", "re", "cr", "or", "err", "er", "request", "rg", "gr", "t"], "pages": ["comments", "seconds", "cats", "cycles", "workers", "days", "files", "breaks", "ins", "books", "sites", "words", "per", "count", "packages", "packs", "events", "Pages", "users", "planes", "features", "length", " page", "docs", "page", "blocks", "qa", "total", "rows", "types", "links", "objects", "posts", "limit", "pid", "images", "items", "plugins", "ages", "num", "ks", "ips", "n", "heads", "c", "bytes", "s", "cells", "lines", "views", "frames", "sections", "classes", "groups", "apps", "members", "fields", "points", "devices", "steps", "codes"]}}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL;\n\n    uint64_t nb_clusters;\n\n    uint8_t *expanded_clusters;\n\n    int ret;\n\n    int i, j;\n\n\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n\n                                   BDRV_SECTOR_SIZE);\n\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 12799, "substitutes": {"bs": ["ps", "fs", "sync", "us", "bl", "bas", "bing", "cs", "sa", "bc", "outs", "fb", "abi", "ds", "bes", "ob", "blocks", "ss", "ec", "db", "oss", "bos", "state", "BS", "gs", "lb", "plugins", "obs", "bh", "es", "ks", "ros", "fps", "ubs", "os", "iss", "bi", "bits", "is", "vs", "http", "ns", "bb", "qs", "b", "aws", "src", "sb", "ab", "ses", "js", "gb", "las", "ls", "lbs", "bis", "pb", "css"], "s": ["ps", "storage", "fs", "sync", "us", "sv", "session", "o", "sites", "ins", "site", "rs", "sc", "cs", "sa", "e", "ts", "its", "l", "parts", "server", "ds", "states", "sys", "si", "ss", "service", "ssl", "uns", "state", "sq", "gs", "xs", "obs", "g", "ks", "self", "os", "spec", "iss", "rss", "stats", "is", "c", "su", "sg", "p", "ns", "qs", "b", "sl", "sets", "aws", "f", "src", "sb", "ses", "js", "settings", "ls", "services", "sym", "S", "r", "t", "ops"], "l1_table": ["l1_body", "l11pentry", "l11_slice", "lOne_table", "l1_shape", "l1_course", "lart_file", "l1stable", "lartJtable", "l167binary", "lOne_shape", "l1__file", "l2_size", "l3_table", "l1__table", "l1Jtable", "lart_table", "lOne_binary", "l167body", "l1ptable", "l1pslice", "lart_private", "l11_module", "lart_column", "l11ptable", "l1smodule", "l167shape", "l3_cache", "l1stree", "l1_time", "l1_size", "l11_key", "l1_TABLE", "l1Jfile", "l11_table", "l1_slice", "l1_cache", "l1_key", "l1__column", "l1_tree", "l3_db", "l1_session", "l11_entry", "lartJprivate", "l1skey", "l11_session", "l11_tree", "l11pslice", "l1Jprivate", "l1psession", "l167table", "l1_entry", "l1_file", "l1_module", "l1Jcolumn", "lartJcolumn", "l3_TABLE", "l2_table", "l1pentry", "l1_column", "l1_private", "l11psession", "l1_binary", "l2_cache", "l2_db", "l1__private", "l1_db", "lartJfile", "lOne_body"], "nb_clusters": ["nb_bcairs", "nb_clones", "nb_slunks", "nb67declapses", "nb_CLuster", "nb_scodes", "nb_llards", "nb_CLards", "nb_Clashes", "nb_Clords", "nb_flroups", "nb_clappers", "nb67declusters", "nb_colluster", "nb_clashes", "nb_flairs", "nb_bcroups", "nb_clodes", "nb_collappers", "nb\u00b7llodes", "nb67cluster", "nb_decluster", "nb_collusters", "nb_spluster", "nb_scashes", "nb_Clodes", "nb_slairs", "nb67clapses", "nb_declusters", "nb_splords", "nb_scones", "nb_slapses", "nb_flusters", "nb_clards", "nb_bcunks", "nb_Clapses", "nb_slusters", "nb_clunks", "nb67decluster", "nb\u00b7llones", "nb\u00b7clashes", "nb_declapses", "nb_CLappers", "nb_clairs", "nb_flunks", "nb_CLusters", "nb67clords", "nb67clusters", "nb_Cluster", "nb_coluster", "nb\u00b7clones", "nb_colusters", "nb\u00b7llusters", "nb\u00b7llashes", "nb_slroups", "nb_clapses", "nb_Clones", "nb_splusters", "nb67declords", "nb_collards", "nb_declords", "nb\u00b7clusters", "nb_splapses", "nb_lluster", "nb_llashes", "nb_Clusters", "nb_colapses", "nb_llodes", "nb_cluster", "nb_bcusters", "nb_llusters", "nb_colodes", "nb_clords", "nb_clroups", "nb\u00b7clodes", "nb_sluster", "nb_llappers", "nb_llones", "nb_slodes", "nb_scusters"], "expanded_clusters": ["expanded_chosures", "expanded_lresses", "expanded2sclust", "expanded_chions", "expanded_buster", "expanded_busters", "expandedsclures", "escanded\n", "expanded_cluster", "expanded_lusters", "expanded2sclusters", "expandedscliffs", "escanding\n", "expanded2scliffs", "expanded_clust", "expandedsslusters", "expanded2scluster", "expanded_colliffs", "expanded_blores", "expanded_clures", "expanded_clresses", "expanded_sclust", "expandedsclusters", "expended\n", "expand\n", "expanded_losures", "expanded_bluster", "expanded2clust", "expanded_clayers", "expanded_Cliffs", "expanded_sliffs", "expandedsclayers", "expanded2cluster", "expanded_Cluster", "expanding\n", "expanded_collusters", "expanded_slusters", "expanded2clusters", "expanded\n", "expanded_Clust", "expanded_slosures", "expanded_clions", "expanded_collures", "expanded_sclusters", "expanded_slayers", "expanded_Clusters", "expanded_clores", "expanded_blusters", "expanded_slures", "expanded_chores", "expanded2cliffs", "expanded_scliffs", "expanded_scluster", "expanded_chuster", "expanded_cliffs", "expanded_sclayers", "expanded_chusters", "expanded_biffs", "expandedssliffs", "expanded_Clores", "expanded_chresses", "expanded_lions", "expanded_slions", "expanded_Clodes", "expanded_sclures", "expanded_clodes", "expandedsslayers", "expanded_collayers", "expanded_blodes", "expanded_bust", "expanded_slresses", "expandedsslures", "expanded_closures", "expanded_chodes"], "ret": ["part", "en", "gt", "ct", "ft", "success", " Ret", "hash", "nt", "bf", "resp", "match", "result", "obj", "ut", "pt", "feat", "rt", "att", "lt", "true", "val", "job", "def", "res", "db", "group", "grad", "det", "fit", "reply", "len", "fun", "rc", "error", "usr", "reg", "g", "url", "rb", "rets", "arg", "rev", "opt", "mem", "mt", "art", "info", "let", "lit", "cat", "re", "out", "RET", "flag", "rl", "err", "bit", "pass", "ref", "alt", "Ret"], "i": ["part", "ie", "di", "gi", "ij", "ini", "iu", "mi", "fi", "v", "multi", "li", "e", "u", "xi", "inner", "l", "pi", "uri", "si", "y", "in", "ai", "ui", "m", "ti", "ix", "n", "eni", "ik", "ci", "id", "io", "iv", "bi", "init", "qi", "ip", "x", "c", "phi", "info", "q", "ki", "p", "index", "ri", "b", "ni", "ind", "r", "ii", "jit", "I", "yi"], "j": ["it", "not", "adj", "d", "o", "dj", "jam", "J", "jp", "v", "li", "jl", "br", "e", "u", "l", "job", "y", "m", "el", "jo", "jen", "aj", "g", "pr", "k", "z", "jet", "jj", "n", "key", "kj", "x", "ij", "q", "h", "ji", "c", "p", "other", "b", "ni", "f", "out", "js", "oj", "uj", "r", "ii", "jit", "t", "ja", "jc"]}}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 12805, "substitutes": {"fs_ctx": ["feed_lc", "fs__ctx", "fsprectx", "fs_cos", "fsdefgb", "fs_gb", "FS_tx", "fsdefloc", "feeddefctx", "fs6bc", "FS_conn", "fsdeflc", "fs_lc", "fits_loc", "fsdefcrit", "fskbc", "fs_cm", "fsprebc", "feed_ctx", "fs_crit", "FS_bc", "vs_bc", "feeddefcos", "fs__cu", "fs_cmp", "fs_context", "fitsdefloc", "ns_ci", "fits_cca", "fs_tx", "FS_cm", "fs_cu", "FS_cu", "fs6ctx", "FS_context", "fs6gb", "fs_bc", "ns_ctx", "fs7crit", "feed_gb", "feeddeflc", "fsdefcos", "feed_cos", "fs7cca", "fs7ctx", "vs_ctx", "fs_ctrl", "fskctx", "vs_ctrl", "fs__context", "fs6cos", "fs_cas", "fsdefctx", "FS_cmp", "fs6context", "fs_conn", "fits_crit", "feeddefgb", "fs7loc", "fs_cca", "fsdefcca", "fsprecontext", "fskcontext", "ns_context", "fsprectrl", "fs6lc", "vs_context", "fs_loc", "fs_ci", "fs6ctrl", "FS_ctx", "fskcu", "FS_cas", "fitsdefcrit", "fitsdefcca", "fitsdefctx", "fs__bc", "fits_ctx", "ns_loc"], "path": ["prefix", "enc", "part", "sync", "file", "route", "ion", "content", "Path", "user", "txt", "patch", "mode", "image", "dir", "inner", "pattern", "uri", "alias", "resource", "anc", "full", "transform", "root", "str", "url", "host", "parent", "config", "location", "method", "key", "id", "ctx", "PATH", "node", "cache", "context", "version", "c", "pointer", "p", "ath", "col", "type", "prop", "name", "mount", "child", "loader", "text", "loc", "ref", "filename"], "flags": ["FLAG", "prot", "fs", "files", "options", "af", "fee", "locks", "Flags", "cs", "mask", "missions", "reads", "fl", "features", "parts", "ds", "xff", "types", "links", "fd", "items", "faces", "linux", "fps", "ips", "ils", "feed", "bits", "stats", "args", "ats", "bytes", "s", "status", "lines", "vals", "f", "lf", "flag", "settings", "opens", "alls", "len", "lag", "ops"], "credp": [" credP", "creds", "cribP", " crsp", "cramu", "cronc", " cribc", "crecpc", "crampc", " creedpa", "decredp", "credm", "cronpc", "creda", "crds", "corsc", "cldP", "decwdp", "clds", "cribs", " crsc", " crsm", "credc", "lcredpa", "credpe", " crspc", "creditpa", "crspc", "decredpc", "crdpc", " credpa", "cribp", "decwdpc", " creedp", "cachedp", "crede", "cdefp", "crdp", "crdP", "crecu", "lcredc", "cachedc", "cachedpa", "crdpa", "corspa", "creedp", "credpc", "corsp", "lcribc", "decredph", " cribp", " cribP", "cwdph", "cribpe", "decwdph", "crdm", " cdefpa", "cdefpc", "cwdpc", "cramph", "creedpa", " creds", "cdefc", " cdefp", "credpa", "cwdp", "lcredpe", "cribc", "credP", "credita", "cldc", "crecp", "creede", "crsp", " credm", "creditp", " cdefc", " credpc", "credite", "decredu", "cramp", "decwdu", "cronp", "crda", " credc", "crdc", " creda", "crde", "cdefpa", "lcribpa", "cachedpc", " creeda", "cldp", "cronm", "corspe", " creede", "lcredp", "cdefpe", "cwdu", " cdefpc", " cribs", "crsc", " crede", "credph", "credu", "cribpa", "creeda", "lcribpe", "lcribp", "crsm", "crecph"]}}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n", "idx": 12809, "substitutes": {"c": ["enc", "ct", "d", "cam", "cpp", "cu", "cm", "tc", "cs", "con", "e", "C", "u", "pc", "cit", "cd", "cf", "l", "icc", "ec", "cc", "dc", "m", "uc", "lc", "k", "ac", "vc", "ci", "ch", "ce", "cp", "p", "b", "cy", "cr", "mc", "ca", "t", "cv"], "lumFilter": ["lumiF", "lumifilter", "lumiListener", "lumiFilter", "lumbF", "lumbListener", "lumF", " lrumListener", "lrumfilter", "lumListener", " lrumfilter", "lumbFilter", "lumfilter", "lrumFilter", "lrumF", " lrumFilter", " lrumF", " lumListener", " lumfilter", "lrumListener", " lumF", "lumbfilter"], "lumSrc": ["lumbAsource", "lumOsRC", "lumSuc", "lumbSrc", "lumAsuc", "lumbAsRC", "lumbSource", "lumbAsuc", "lumOsuc", "lumOsrc", "lumAsource", "lumbSuc", "lumAsrc", "lumbAsrc", "lumOsource", "lumSource", "lumSRC", "lumbSRC", "lumAsRC"], "lumFilterSize": ["lumBufferSize", "lumFilterC", "lumsFilterSize", "lumFC", "lumFiltersize", "lumsFiltersize", "lumBuffersize", "lumBufferC", "lumsFilterC", "lumFsize", "lumFSize"], "chrFilter": ["chrbFilter", "chrbFil", "echrFilter", "echrfilter", "echrbfilter", "chrfilter", "echrbFormat", "chrumFilter", "echrbFil", "chrumFil", "chmFormat", "chmfilter", "echrFormat", "chrFil", "chrFormat", "echrbFilter", "chmFil", "chrbfilter", "echrFil", "chrumfilter", "chrbFormat", "chmFilter", "chrumFormat"], "chrSrc": ["chrSubrc", "chrfSources", "chrAsRC", "chrSubource", "chrAsources", "chrfSource", "chrSRC", "chrSource", "chrSources", "chrfSRC", "chrAsrc", "chrAsource", "chrfSrc", "chrSubources", "chrSubRC"], "chrFilterSize": ["chrFilterLen", "chreFilterSize", "chrControlSIZE", "chrControlLen", "chreFilterLen", "chrControlsize", "chrfilterLen", "chrfilterSize", "chreControlSIZE", "chreControlSize", "chrFilterSIZE", "chreControlsize", "chrControlSize", "chrfilterSIZE", "chrFileSIZE", "chrFileLen", "chrFileSize", "chrFilesize", "chrfiltersize", "chrFiltersize", "chreFiltersize", "chreFilterSIZE", "chreControlLen"], "dest": ["orig", "includes", "test", "ord", "draw", "wd", "gest", "sup", "ident", "gen", "src", "ward", "Dest", "trans", "esc", "sum", "move", "wh", "shift", "cont", "du", "txt", "match", "path", "transform", "destroy", "sort", "num", "flat", "walk", "done", "iter", "route", " Dest", "data", "result", "feat", "rest", "end", "wb", "shape", "this", "origin", "dim", "usr", "class", "replace", "opt", "home", "d", " destination", "south", "source", "dist", "mode", "comb", "store", "desc", "dc", "uc", "config", "coord", "uv", "target", "sign", "prop", "err", "transfer", "loc", "img"], "dstW": [" dSTH", "dostH", "ddestW", " dSTW", " dstH", " dstw", "dSTVW", "dostw", "dostVW", "ddestw", "dSTw", "dostW", " dSTw", "dstw", "dstH", "dSTW", "ddestH", " dSTVW", "dSTH", "ddestVW", " dstVW", "dstVW"], "y": ["d", "ay", "ty", "ys", "e", "iy", "ny", "vy", "z", "ch", "ey", "x", "h", "p", "type", "b", "w", "Y", "yy", "dy", "py", "oy", "t", "yi"], "i": ["d", "iu", "v", "li", "count", "e", "end", "l", "pi", "ui", "k", "n", "ci", "h", "p", "type", "b", "f", "start", "w", "j", "ii", "t", "I", "code"]}}
{"project": "FFmpeg", "commit_id": "2fc9a3eb7a8c606bd403dc9fbdb8463144b243cf", "target": 1, "func": "static int write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, did_split;\n    if (s->output_ts_offset) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n    }\n    if (s->avoid_negative_ts > 0) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = st->mux_ts_offset;\n        int64_t ts = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts;\n        if (s->internal->offset == AV_NOPTS_VALUE && ts != AV_NOPTS_VALUE &&\n            (ts < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) {\n            s->internal->offset = -ts;\n            s->internal->offset_timebase = st->time_base;\n        }\n        if (s->internal->offset != AV_NOPTS_VALUE && !offset) {\n            offset = st->mux_ts_offset =\n                av_rescale_q_rnd(s->internal->offset,\n                                 s->internal->offset_timebase,\n                                 st->time_base,\n                                 AV_ROUND_UP);\n        }\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n        if (s->internal->avoid_negative_ts_use_pts) {\n            if (pkt->pts != AV_NOPTS_VALUE && pkt->pts < 0) {\n                av_log(s, AV_LOG_WARNING, \"failed to avoid negative \"\n                    \"pts %s in stream %d.\\n\"\n                    \"Try -avoid_negative_ts 1 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        } else {\n            av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0);\n            if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) {\n                av_log(s, AV_LOG_WARNING,\n                    \"Packets poorly interleaved, failed to avoid negative \"\n                    \"timestamp %s in stream %d.\\n\"\n                    \"Try -max_interleave_delta 0 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        }\n    }\n    did_split = av_packet_split_side_data(pkt);\n    if (!s->internal->header_written) {\n        ret = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s);\n        if (ret < 0)\n            goto fail;\n    }\n    if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) {\n        AVFrame *frame = (AVFrame *)pkt->data;\n        av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE);\n        ret = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0);\n        av_frame_free(&frame);\n    } else {\n        ret = s->oformat->write_packet(s, pkt);\n    }\n    if (s->pb && ret >= 0) {\n        if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS)\n            avio_flush(s->pb);\n        if (s->pb->error < 0)\n            ret = s->pb->error;\n    }\nfail:\n    if (did_split)\n        av_packet_merge_side_data(pkt);\n    if (ret < 0) {\n        pkt->pts = pts_backup;\n        pkt->dts = dts_backup;\n    }\n    return ret;\n}", "idx": 12810, "substitutes": {"s": ["hs", "session", "site", "v", "sc", "u", "ts", "its", "sys", "si", "se", "m", "sec", "xs", "self", "n", "spec", "h", "i", "set", "qs", "sb", "js", "services", "t", "ps", "client", "sync", "fs", "o", "your", "ins", "txt", "cs", "e", "ss", "ssl", "sq", "gs", "sf", "sts", "is", "c", "sg", "ns", "less", "storage", "us", "sa", "l", "ds", "ans", "service", "vs", "sl", "ses", "sym", "S", "ops", "single", "d", "sv", "rs", "south", "params", "server", "g", "es", "ks", "os", "su", "args", "p", "b", "aws", "sets", "f", "request", "ls", "r", "conf", "support"], "pkt": [" pct", "tpkt", "pwk", "cpct", "pert", "mct", "Pcht", "pkg", "apkt", "hnt", "fkt", "psert", " pcht", " pwk", "Pkg", "feter", "spdt", "mkt", "ppkt", "opacket", "ipft", "pnt", "Pnt", "pswk", " pnt", "opkt", "Peter", "cpkt", "ppnt", "fct", "ipct", "opct", "apck", "fet", "cpnt", " pkg", "wpacket", "cpert", "ptp", "spelt", "spkt", "pet", "wpft", "ipacket", "apacket", "ppeter", "ipkt", "pct", "fwk", "tpacket", " pert", "pelt", "apkg", "ppwk", "pskt", "ipwk", "ipelt", "pft", "peter", "opwk", "ppet", "psacket", "pcht", "mtp", "Pck", "apnt", "opet", "spcht", "Ptp", "Pkt", "helt", "Pelt", "wpelt", "psct", "spkg", "cpet", "spacket", "pscht", "ipnt", "opkg", " pelt", "ppacket", "tpnt", "macket", "spnt", "Pdt", "cpwk", " packet", "ipcht", "pskg", "tpelt", "wpkt", "Pct", "tpck", "opcht", "pck", " pet", "hkt", "apet", "apelt", "packet", "wpet", "cpkg", "Pert", " ptp", "Packet", "Pft", "pset", "ppdt", "pdt", "Pet", "facket", "hacket"], "ret": ["TS", " resp", " error", " rs", "ets", "nt", " rc", " alt", "val", " RET", " fut", "len", "sec", "seq", "num", " status", "id", "mt", " result", " temp", "RET", " res", " sa", " reply", "alt", "Ret", " success"], "did_split": ["ip_split", "did__sync", "did__send", "did_send", "ip_sync", "did__sec", "ip__send", "did_sec", "did__split", "ip__sync", "ip_send", "ip__split", "ip__sec", "did_sync", "ip_sec"], "st": ["client", "storage", "d", "ct", "ST", "step", "ft", "dt", "stress", "sc", "St", "sa", "ut", "rest", "ts", "ld", "sm", "pt", "ste", "post", "ss", "service", "se", "sp", "inst", "sn", "sta", "str", "sts", "fr", "est", "iss", "ess", "sd", "stop", "sh", "stage", "ast", "stable", "cl", "sw", "sl", "station", "sr", "src", "sb", "cr", "start", "ist", "td", "ost", "sth", "std", "t", "stack", "sk"]}}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}", "idx": 12814, "substitutes": {"f": ["fp", "fm", "fs", "file", "af", "fa", "fac", "fi", "exec", "fore", "data", "uf", "bf", "e", "u", "fe", "ff", "cf", "l", "fb", "rf", "conf", "m", "of", "fd", "sf", "form", "tf", "fen", "fr", "xf", "feed", "fc", "buff", "c", "i", "fed", "p", "b", "fx", "fo", "lf", "r", "F", "fw", "t", "inf"], "info": ["it", "check", "options", "obj", "work", "si", "ui", "api", "tf", "hand", "self", "init", "Info", "i", "start", "diff", "j", "ii", "part", "ie", "xml", "txt", "image", "of", "error", "num", "id", "now", "is", "hi", "off", "fo", "INFO", "help", "update", "aux", "di", "gi", "bug", "fi", "data", "same", "result", "end", "parse", "key", "iso", "io", "opt", "buff", "home", "http", "type", "name", "py", "information", "inf", "comp", "app", "op", "inner", "base", "def", "note", "full", "config", "add", "extra", "index", "fw", "conf", "from"]}}
{"project": "qemu", "commit_id": "e9ebead2b5c70890454e698d9ff174e3020ea861", "target": 1, "func": "static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     int pci_enabled, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    int ret, linux_boot, i;\n\n    ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;\n\n    int bios_size, isa_bios_size, vga_bios_size;\n\n    PCIBus *pci_bus;\n\n    int piix3_devfn = -1;\n\n    CPUState *env;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        cpu_model = \"qemu64\";\n\n#else\n\n        cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n    \n\n    for(i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find x86 CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (i != 0)\n\n            env->halted = 1;\n\n        if (smp_cpus > 1) {\n\n            /* XXX: enable it in all cases */\n\n            env->cpuid_features |= CPUID_APIC;\n\n        }\n\n        qemu_register_reset(main_cpu_reset, env);\n\n        if (pci_enabled) {\n\n            apic_init(env);\n\n        }\n\n    }\n\n\n\n    vmport_init();\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(0xa0000);\n\n    cpu_register_physical_memory(0, 0xa0000, ram_addr);\n\n\n\n    /* Allocate, even though we won't register, so we don't break the\n\n     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),\n\n     * and some bios areas, which will be registered later\n\n     */\n\n    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);\n\n    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);\n\n    cpu_register_physical_memory(0x100000,\n\n                 below_4g_mem_size - 0x100000,\n\n                 ram_addr);\n\n\n\n    /* above 4giga memory allocation */\n\n    if (above_4g_mem_size > 0) {\n\n        ram_addr = qemu_ram_alloc(above_4g_mem_size);\n\n        cpu_register_physical_memory(0x100000000ULL,\n\n                                     above_4g_mem_size,\n\n                                     ram_addr);\n\n    }\n\n\n\n\n\n    /* allocate VGA RAM */\n\n    vga_ram_addr = qemu_ram_alloc(vga_ram_size);\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = get_image_size(buf);\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios_offset = qemu_ram_alloc(bios_size);\n\n    ret = load_image(buf, phys_ram_base + bios_offset);\n\n    if (ret != bios_size) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n\n\n    if (cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled) {\n\n        /* VGA BIOS load */\n\n        if (cirrus_vga_enabled) {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_CIRRUS_FILENAME);\n\n        } else {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_FILENAME);\n\n        }\n\n        vga_bios_size = get_image_size(buf);\n\n        if (vga_bios_size <= 0 || vga_bios_size > 65536)\n\n            goto vga_bios_error;\n\n        vga_bios_offset = qemu_ram_alloc(65536);\n\n\n\n        ret = load_image(buf, phys_ram_base + vga_bios_offset);\n\n        if (ret != vga_bios_size) {\n\nvga_bios_error:\n\n            fprintf(stderr, \"qemu: could not load VGA BIOS '%s'\\n\", buf);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* setup basic memory access */\n\n    cpu_register_physical_memory(0xc0000, 0x10000,\n\n                                 vga_bios_offset | IO_MEM_ROM);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024))\n\n        isa_bios_size = 128 * 1024;\n\n    cpu_register_physical_memory(0x100000 - isa_bios_size,\n\n                                 isa_bios_size,\n\n                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);\n\n\n\n    {\n\n        ram_addr_t option_rom_offset;\n\n        int size, offset;\n\n\n\n        offset = 0;\n\n        if (linux_boot) {\n\n            option_rom_offset = qemu_ram_alloc(TARGET_PAGE_SIZE);\n\n            load_linux(phys_ram_base + option_rom_offset,\n\n                       kernel_filename, initrd_filename, kernel_cmdline);\n\n            cpu_register_physical_memory(0xd0000, TARGET_PAGE_SIZE,\n\n                                         option_rom_offset | IO_MEM_ROM);\n\n            offset = TARGET_PAGE_SIZE;\n\n        }\n\n\n\n        for (i = 0; i < nb_option_roms; i++) {\n\n            size = get_image_size(option_rom[i]);\n\n            if (size < 0) {\n\n                fprintf(stderr, \"Could not load option rom '%s'\\n\",\n\n                        option_rom[i]);\n\n                exit(1);\n\n            }\n\n            if (size > (0x10000 - offset))\n\n                goto option_rom_error;\n\n            option_rom_offset = qemu_ram_alloc(size);\n\n            ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n\n            if (ret != size) {\n\n            option_rom_error:\n\n                fprintf(stderr, \"Too many option ROMS\\n\");\n\n                exit(1);\n\n            }\n\n            size = (size + 4095) & ~4095;\n\n            cpu_register_physical_memory(0xd0000 + offset,\n\n                                         size, option_rom_offset | IO_MEM_ROM);\n\n            offset += size;\n\n        }\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    bochs_bios_init();\n\n\n\n    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    ferr_irq = i8259[13];\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, i8259);\n\n        piix3_devfn = piix3_init(pci_bus, -1);\n\n    } else {\n\n        pci_bus = NULL;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);\n\n\n\n    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);\n\n\n\n    if (cirrus_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_cirrus_vga_init(pci_bus,\n\n                                ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        } else {\n\n            isa_cirrus_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        }\n\n    } else if (vmsvga_enabled) {\n\n        if (pci_enabled)\n\n            pci_vmsvga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                            vga_ram_addr, vga_ram_size);\n\n        else\n\n            fprintf(stderr, \"%s: vmware_vga: no PCI bus\\n\", __FUNCTION__);\n\n    } else if (std_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size, 0, 0);\n\n        } else {\n\n            isa_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size);\n\n        }\n\n    }\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    qemu_register_boot_set(pc_boot_set, rtc_state);\n\n\n\n    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);\n\n    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);\n\n\n\n    if (pci_enabled) {\n\n        ioapic = ioapic_init();\n\n    }\n\n    pit = pit_init(0x40, i8259[0]);\n\n    pcspk_init(pit);\n\n    if (!no_hpet) {\n\n        hpet_init(i8259);\n\n    }\n\n    if (pci_enabled) {\n\n        pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic);\n\n    }\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], i8259[parallel_irq[i]],\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd, i8259);\n\n        else\n\n            pci_nic_init(pci_bus, nd, -1, \"ne2k_pci\");\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n\tif (index != -1)\n\n\t    hd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    hd[i] = NULL;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259);\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n\t                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n        }\n\n    }\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(0);\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_enabled ? pci_bus : NULL, i8259);\n\n#endif\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        index = drive_get_index(IF_FLOPPY, 0, i);\n\n\tif (index != -1)\n\n\t    fd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);\n\n\n\n    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);\n\n        for (i = 0; i < 8; i++) {\n\n            smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus, unit;\n\n        void *scsi;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            scsi = lsi_scsi_init(pci_bus, -1);\n\n            for (unit = 0; unit < LSI_MAX_DEVS; unit++) {\n\n\t        index = drive_get_index(IF_SCSI, bus, unit);\n\n\t\tif (index == -1)\n\n\t\t    continue;\n\n\t\tlsi_scsi_attach(scsi, drives_table[index].bdrv, unit);\n\n\t    }\n\n        }\n\n    }\n\n\n\n    /* Add virtio block devices */\n\n    if (pci_enabled) {\n\n        int index;\n\n        int unit_id = 0;\n\n\n\n        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {\n\n            virtio_blk_init(pci_bus, drives_table[index].bdrv);\n\n            unit_id++;\n\n        }\n\n    }\n\n\n\n    /* Add virtio balloon device */\n\n    if (pci_enabled)\n\n        virtio_balloon_init(pci_bus);\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i])\n\n                virtio_console_init(pci_bus, virtcon_hds[i]);\n\n        }\n\n    }\n\n}\n", "idx": 12828, "substitutes": {"ram_size": ["ramingaddr", "ramingnum", "cam_type", "ram00num", "ram_cap", "vm_term", "ram_offset", "ram\u00b7size", "ramingsize", "ram_type", "simingsize", "gram_size", "ram00offset", "sim_addr", "ram_shape", "ram_scale", "gram_loc", "vm_scale", "ram_loc", "ram\u00b7cap", "sim_num", "ram00size", "simingaddr", "ramingoffset", "cam_len", "simingoffset", "cam_shape", "simingnum", "ram\u00b7scale", "sim_offset", "vm_size", "cam_size", "ram_term", "ram_num", "sim_size", "ram\u00b7term", "ram00addr", "gram_scale", "ram_len", "vm_cap"], "vga_ram_size": ["vga_gram_length", "vga_ram_length", "vga_ram_width", "vga_gram_size", "vga_gram_width"], "boot_device": ["kernel_device", "bootmingdevice", "boot_devices", "kernel_engine", "bootmingmode", "bootingdevices", "bootmingdevices", "boot_mode", "bootingmode", "bootmingengine", "kernel_mode", "bootingdevice", "boot_engine", "bootingengine", "kernel_devices"], "ds": ["ps", "fs", "dds", "irs", "dt", "rs", "ys", "cs", "DS", "ss", "db", "pd", "xs", "bs", "df", "ks", "ils", "dh", "vs", "ns", "dd", "tx", "dm", "des", "Ds", "ls", "gd", "da", "ops"], "kernel_filename": ["kernel___filename", "kernellogfile", "kerneldbfile", "kernel___sequence", "kerneldbfilename", "config_sequence", "config_file", "kernel_files", "config_name", "kernel_name", "kernel_file", "configlogfile", "kernel_sequence", "kerneldbsoftware", "kernel___file", "config_filename", "kerneldbfiles", "configlogfilename", "configlogsequence", " kernel_files", " kernel_file", "kernellogsequence", "kernel___name", "configlogname", "kernellogfilename", "kernel_software", " kernel_software", "kernellogname"], "kernel_cmdline": ["kernel_hostlines", "kernel_commandlines", "kernel_hostline", "kernel_hostse", "kernel_commandse", "kernel_commandline", "kernel_cmdend", "kernel_argse", "kernel_arglines", "kernel_cmdlines", "kernel_cmdse", "kernel_commandend", "kernel_argend", "kernel_hostend", "kernel_argline"], "initrd_filename": ["initrd_path", "initrf_source", "initrddlocation", "initrdmatlocation", "initrfmatfilename", "initrddfilename", "initrd_location", "initrdmatsource", "initrf_filename", "initrd_source", "initrddsource", "initrdmatfilename", "initrfmatlocation", "initrfmatsource", "initrfmatpath", "initrddpath", "initrf_path", "initrdmatpath", "initrf_location"], "pci_enabled": ["pki_supported", "pci__required", "pci_enable", "pci_mode", "pci__enable", "pci__enabled", "pci_disabled", "pci2disabled", "pili_required", "pili_enabled", "pki_enabled", "pci2supported", "pci2enabled", "pili_enable", "pci_supported", "pki_mode", "pci2mode", "pili_disabled", "pci_required", "pki_disabled", "pci__disabled"], "cpu_model": [" cpu_mode", "processor_mode", " cpu_module", "CPU_device", "cpu67command", "cpu___models", "cpu_models", "cpu_view", "cpu_base", "pc_handler", "cpu___model", "cpu_Model", " cpu_models", "processor_model", "processor_view", "cpu_scale", "cpu67models", "cpu67model", "CPU_models", "cpu_module", "processor_Model", "CPU_model", "cpu_handler", "cpu_command", "cpu__model", "CPU_command", "pc_model", " cpu_base", "pc_module", "pc_models", "cpu___device", "cpu__mode", "cpu_device", "cpu67device", " cpu_scale", "cpu__base", "cpu_mode", "cpu___command"], "buf": ["ba", "alloc", "func", "fi", "data", "uf", "br", " buffer", "cb", "bin", "blocks", "pad", "cap", "map", "seq", "ptr", "proc", "rb", "block", "ctx", "mem", "buff", "box", "Buffer", "b", "bag", "buffer"], "ret": ["test", "ports", "all", "exec", "v", "result", "script", " rc", "val", "def", "res", " RET", "rc", "reg", "info", "status", "out", "RET", "stat", "conn", "len", "Ret", "code"], "linux_boot": ["linux_Boot", "kernel_Boot", "kernel_setup", "linux_setup", "linux_lock", " linux_config", "linux_config", "kernel_bit", " linux_bit", " linux_lock", "kernel_boot", "linux_bit"], "i": ["it", "ie", "di", "gi", "uni", "chi", "ini", "iu", "mi", "fi", "x", "t", "multi", "v", "li", "count", "image", "xi", "u", "mu", "pi", "uri", "si", "y", "ai", "ui", "limit", "slice", "udi", "ti", "ix", "n", "eni", "gu", "io", "id", "ci", "mini", "init", "qi", "ip", "c", "phi", "h", "info", "ami", "hi", "p", "cli", "b", "ni", "f", "start", "ski", "j", "ii", "I", "yi"], "ram_addr": ["ream_device", "ramMaddr", "ram_address", "mem_addr", "ramdaddr", "ramMoffset", "ream_size", "ramMptr", "ramdaddress", "ream_address", "mem_ptr", "ram_ptr", "ram_offset", "ramMaddress", "mem_offset", "ramdsize", "ram_device", "ream_addr", "ramddevice", "mem_address"], "vga_ram_addr": ["vga_ram_address", "vga_mem_src", "vga_ram_src", "vga_mem_address", "vga_ram_offset", "vga_ramingaddr", "vga_mem_offset", "vga_ramingoffset", "vga_mem_addr", "vga_ramingaddress", "vga_ramingsrc"], "bios_offset": ["biosacdata", "bios_data", "bio_data", "bio_offset", "bio_size", "biosacsize", "biosacoffset", "bios_position", "biosacposition", "bio_position"], "vga_bios_offset": ["vga_bio_offset", "vga_bio_size", "vga_bio_len", "vga_bios_pos", "vga_bio_pos", "vga_bios_len"], "below_4g_mem_size": ["below_4g_mem_speed", "below_4g_memory_size", "below_4g_memssmall", "below_4g_memsspeed", "below_4g_memacspeed", "below_4g_memacsize", "below_4g_memory_stream", "below_4g_memacstream", "below_4g_memssize", "below_4g_memory_small", "below_4g_ram_address", "below_4g_mem_small", "below_4g_memory_speed", "below_4g_ram_small", "below_4g_mem_address", "below_4g_ram_size", "below_4g_mem_stream"], "bios_size": ["bio_ize", "bio_size", "bios_len", "bios_ize", "bio_len", "bio_address", "bios_address"], "isa_bios_size": ["isa_bio_len", "isa_bios_ize", "isa_bio_size", "isa_bio_ize", "isa_bios_len"], "vga_bios_size": ["vga_bias_scale", "vga_bios_capacity", "vga_bias_size", "vga_bios_scale", "vga_bias_capacity"], "pci_bus": ["pci2boot", "pki_bus", "pki_BUS", "pki_boot", "pci_BUS", "pci_boot", "pci2bus", "pci2device", "pci2BUS", "pki_device", "pci_device"], "env": ["enc", "en", "ne", "et", "engine", "session", "app", "environment", "ass", "ev", "site", "exec", "exc", "vm", "txt", "inet", "v", "global", "e", "nc", "dir", "obj", "bc", "act", "end", "output", "dat", "style", "qt", "eng", "ec", "db", "dc", "ven", "conf", "el", "state", "ig", "ef", "export", "config", "ea", "eu", "net", "inv", "eni", "np", "her", " environment", "ctx", "cache", "dev", "context", "vs", "c", "args", "viron", "dict", "ext", "h", "ah", "scope", "virt", "cal", "here", "console", "err", "py", "enable", "chal", "conn", "Environment", "eb", "oa"], "cpu_irq": ["cpu_mirq", "cpu_mirp", "cpu_crq", "cpu_IRq", "cpu_crch", "cpu_irp", "cpu_irck", "cpu_crp", "cpu_crck", "cpu_IRck", "cpu_mirck", "cpu_mirch", "cpu_irch", "cpu_IRch", "cpu_IRp"], "i8259": ["int8257", "i8257", "int8259", "i8266", "i18257", "i6257", "i6266", "i6259", "int8258", "int8266", "i6258", "i8258", "i18258", "i18259", "i18266"], "index": ["sync", "engine", "position", "action", "data", "thread", "loop", "Index", "pos", "output", "error", "config", "num", "version", "x", "weight", "info", "addr", "type", "run", "name", "ind", "diff", "value", "conn", "len"], "hd": ["hs", "ha", "bd", "di", "dt", "hub", "amd", "du", "md", "hid", "rh", "cd", "ht", "wd", "cow", "hm", "dc", "pd", "hw", "hp", "ck", "df", "vd", "xd", "dd", "gd", "da", "ad"], "MAX_IDE_BUS": ["MAX_IDE__USE", "MAX_IDEADUSE", "MAX_IDEADBus", "MAX_DE_USE", "MAX_IDE__BUS", "MAX_IDE_DIR", "MAX_IDEADDIR", "MAX_DE_BUS", "MAX_DE_Bus", "MAX_IDE_Bus", "MAX_DE_DIR", "MAX_IDE__Bus", "MAX_IDE_USE", "MAX_IDEADBUS", "MAX_IDE__DIR"], "MAX_IDE_DEVS": ["MAX_IDE_DVICE", "MAX_IDE_DPS", "MAX_IDE_DEPS", "MAX_IDE_DRFS", "MAX_IDE_DFS", "MAX_IDE_DRVS", "MAX_IDE_DIVS", "MAX_IDE_DEVICE", "MAX_IDE_DRVICE", "MAX_IDE_DIVICE", "MAX_IDE_DRPS", "MAX_IDE_DEFS", "MAX_IDE_DIFS", "MAX_IDE_DVS", "MAX_IDE_DIPS"], "fd": ["fs", "d", "bd", "flow", "du", "md", "fl", "dir", "ff", "cf", "cb", "fb", "wd", "fat", "db", "dc", "ef", "dl", "df", "cond", "fr", "fc", "dev", "sd", "fx", "f", "lf", "FD", "fw"], "MAX_FD": ["MAX_MODE", "Max_FD", "MAX_DEF", "MAX_HD", "Max_DEF", "MAX__FD", "MAX__DEF", "MAX__HD", "Max_HD", "MAX__MODE", "Max_MODE"]}}
{"project": "qemu", "commit_id": "0bed71edbc323de12ed1e5390a85a013f6a143f4", "target": 0, "func": "static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n\n                         int legacy_format)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    struct in_addr guest_addr = { .s_addr = 0 };\n\n    int host_port, guest_port;\n\n    const char *p;\n\n    char buf[256];\n\n    int is_udp;\n\n    char *end;\n\n\n\n    p = redir_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        error_report(\"could not set up host forwarding rule '%s'\",\n\n                     redir_str);\n\n        return -1;\n\n    }\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid host forwarding rule '%s'\", redir_str);\n\n    return -1;\n\n}\n", "idx": 12846, "substitutes": {"s": ["fs", "sv", "session", "o", "v", "e", "sa", "server", "ss", "ssl", "m", "sq", "sf", "g", "n", "spec", "c", "h", "su", "sg", "b", "sl", "f", "ses", "r", "services", "S", "t"], "redir_str": ["redir_format", "redir_Str", "redirect_format", "redir2Str", "redir2format", "redIR_tr", "redir2arr", "redir_tr", "redirect_str", "redir_arr", "redIR_str", "redIR_string", "redir_string", "redirect_arr", "redirect_Str", "redIR_Str", "redir2str"], "legacy_format": ["legacy_form", "legcore__mode", "legcore_form", "legcore__prefix", "legcore_mode", "legacy__format", "legcore_prefix", "legacy_magic", "legACY_format", "legcore__form", "legacy__prefix", "legACY_magic", "legcore__format", "legacy__form", "legcore_format", "legacy_prefix", "legacy_style", "legACY_style", "legacy__mode", "legacy_mode", "legacy_str"], "host_port": [" host_direction", "host7width", "host67port", " host_width", "host\u00b7limit", "hostableport", "hostingdirection", "host_path", "master_port", "host_pool", " host_pool", " host_ip", "hostingexp", " host_exp", "host_hop", "hostingport", "master_path", " hostswidth", "host_limit", "host7hop", "host_ip", "host\u00b7position", "hostablepath", "master_limit", "host7port", "host\u00b7direction", "hostsport", "hostallength", " host_position", "host_exp", "hostalpool", " hostspool", "hostswidth", "hostaldirection", " host_hop", "hostinglength", "host67direction", "host67ip", "hostspool", "host\u00b7path", " hostsport", "host_width", "master_direction", " host_length", "host67position", "hostablelimit", "host_length", " hostshop", "hostabledirection", "hostalport", "hostalwidth", "host7pool", "hostalexp", "host\u00b7port", "hostalhop", "hostshop", "host\u00b7ip", "host_direction", "host_position"], "guest_port": ["guility\u00b7address", "guest__ports", "guess_port", "guility_address", "guest_limit", "guess_length", "guest_ports", "guest\u00b7Port", "guest6port", "gugest__ports", "guess_end", "guest_end", "guestDport", "gugest_port", "guest_Port", "guility_Port", "guess_name", "guest_address", "guility\u00b7port", "guest__port", "guest\u00b7address", "guess_number", "guess_ports", "guest6number", "guest_depth", "gugest__port", "guest\u00b7port", "guest_length", "guest6ports", "guest6end", "gugest__limit", "guest_name", "guility_port", "guility_depth", "guestDlimit", "guest\u00b7depth", "guility\u00b7Port", "gugest_limit", "guestDports", "gugest_ports", "guility\u00b7depth", "guest_number", "guest__limit"], "p": ["fp", "prefix", "part", "en", "d", "o", "pe", "tp", "pn", "jp", "v", "po", "pat", "param", "after", "e", "pt", "ap", "u", "op", "pos", "pc", "l", "pi", "pkg", "P", "pp", "pair", "pad", "path", "y", "wp", "m", "sp", "padding", "api", "ep", "a", "pre", "g", "pr", "pen", "lp", "point", "n", "np", "pa", "ip", "c", "bp", "h", "i", "cp", "b", "start", "f", "prop", "dp", "python", "port", "vp", "py", "r", "j", "at", "t", "pro", "pb"], "buf": ["fp", "exc", "uf", "u", "pkg", "cb", "fb", "val", "map", "bt", "lb", "seq", "rb", "cur", "box", "h", "bytes", "Buffer", "bb", "src", "sb", "msg", "bo", "font", "prot", "brace", "aka", "front", "cmd", "path", "queue", "fd", "pool", "str", "a", "block", "cache", "context", "c", "input", "cat", "buffer", "binary", "func", "grab", "data", "la", "plug", "bc", "result", "bu", "ff", "wb", "cap", "bus", "padding", "bh", "buff", "home", "conv", "ph", "hal", "text", "bd", "br", "pt", "desc", "pad", "vec", "uc", "bridge", "config", "proc", "ctx", "mem", "feed", "b", "bag", "f", "prop", "ab", "port", "err", "gb", "r", "loc", "img", "pb", "cv"], "is_udp": ["is__udsb", "is_audpa", "is_audpe", "is_adm", "is_adp", "is_dupa", "is__udm", "is__udp", "is_udspa", "is_audp", "is_udsb", "is_urpe", "is_urm", "is_udspe", "is_audpp", "is__udspe", "is__udsm", "is_udpe", "is_dup", "is_urp", "is_webpa", "is__udspa", "is_udm", "is__udsp", "is_udpa", "is_udspp", "is_adb", "is_dupe", "is__udb", "is_udsm", "is__udpe", "is_webb", "is_dupp", "is_udsp", "is_udpp", "is_urb", "is_urpa", "is_adpe", "is_webpe", "is__udpa", "is_webp", "is_udb"], "end": ["enc", "en", "d", "append", "send", "nd", "all", "after", "e", "pos", "eval", "until", "rest", "enter", "desc", "open", "End", "post", "path", "in", "ended", "ent", "api", "last", "z", "k", "est", "id", "win", "stop", "dev", "ip", "c", "max", "h", "line", "set", "ast", "pend", "index", "close", "ending", "begin", "start", "f", "w", "port", "END", "entry", "r", "text", "pass", "len", "ad"]}}
{"project": "qemu", "commit_id": "e6eef7c221634c942e9f586df84aae623aa06cd5", "target": 0, "func": "int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    struct kvm_fpu fpu;\n\n    int r;\n\n    int i;\n\n\n\n    /* always save the PSW  and the GPRS*/\n\n    cs->kvm_run->psw_addr = env->psw.addr;\n\n    cs->kvm_run->psw_mask = env->psw.mask;\n\n\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.gprs[i] = env->regs[i];\n\n            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;\n\n        }\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            regs.gprs[i] = env->regs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Floating point */\n\n    for (i = 0; i < 16; i++) {\n\n        fpu.fprs[i] = env->fregs[i].ll;\n\n    }\n\n    fpu.fpc = env->fpc;\n\n\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    /* Do we need to save more than that? */\n\n    if (level == KVM_PUT_RUNTIME_STATE) {\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * These ONE_REGS are not protected by a capability. As they are only\n\n     * necessary for migration we just trace a possible error, but don't\n\n     * return with an error return code.\n\n     */\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);\n\n\n\n    if (cap_async_pf) {\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Finally the prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        /* prefix is only supported via sync regs */\n\n    }\n\n    return 0;\n\n}\n", "idx": 12853, "substitutes": {"cs": ["ps", "fs", "sync", "ops", "ct", "cons", "Cs", "cing", "ins", "cn", "tc", "ys", "sc", "nc", "bc", "ras", "ts", "cf", "cb", "ds", "sys", "CS", "ec", "cc", "acks", "gs", "ces", "lc", "rc", "bs", "ck", "ks", "cus", "ix", "ac", "vc", "ch", "spec", "ctx", "ce", "ci", "cache", "acs", "c", "vs", "args", "cp", "ns", "s", "core", "qs", "cks", "cells", "cal", "co", "ca", "js", "wcs", "utils", "ics", "ocr", "ls", "ace", "conn", "cms", "cas", "sk", "css"], "level": ["Level", "enc", "d", "loop", "mode", "sc", "l", "style", "depth", "path", "limit", "state", "vel", "scale", "role", "method", "parent", "key", "where", "lock", "id", "c", "stage", "rol", "line", "clean", "layer", "status", "cl", "lvl", "type", "inc", "scope", "col", "name", "lf", "levels", "len", "code"], "cpu": ["cn", "vm", "cm", "CPU", "sc", "nc", "bc", "pc", "gpu", "bench", "processor", "sys", "cmp", "uc", "hw", "lc", "rc", "pu", "kernel", "net", "uci", "np", "spec", "ctx", "fc", "node", "cache", "c", "cp", "core", "cli", "instance", "mc", "ca", "clock", "platform", "conn", "cv"], "env": ["estate", "enc", "dt", "site", "exec", "exc", "v", "cf", "dat", "ec", "ef", "vel", "fen", "ea", "np", "her", "req", "scope", "csv", "conn", "en", "ne", "edge", "e", "den", "eng", "header", "db", "eni", "osc", "iss", "cache", "context", "c", "shell", "cal", "gear", "oa", "visor", "et", "engine", "environment", "cfg", "end", "anc", "esm", "cdn", "ce", "stage", "viron", "que", "code", "eve", "ass", "ev", "nc", "server", "gui", "el", "export", "config", "eu", "exe", "ctx", "args", "ext", "zone", "uv", "core", "cli", "energy", "console", "conf", "Environment", "cv"], "sregs": ["sregn", "sconfigs", "gsarchn", "gsarchb", "gsregb", "sconfigos", "gsregs", "gsarchs", "sarchb", "sconfigb", "sarchs", "gsregn", "srecs", "gsregos", "sconfign", "sarchos", "sregb", "sarchn", "srecos", "gsarchos", "sregos", "srecb", "srecn"], "regs": ["REGh", "orgs", "regcs", "funsets", "rcgs", "egds", "rolls", "REGds", "memcs", "stath", "statcs", "REGp", "rollsets", "rcns", "eggs", "gregds", "regh", "egns", "regns", "egs", "regsets", "memp", "reggs", "gregb", "orges", "Regs", " regp", "recd", "Regp", "REGd", "gregs", "regps", "systemd", "rcs", "orgb", "rcds", " regps", " regb", "mems", "greggs", "regd", "Regd", "recps", "stats", "rolld", " regds", " reges", "recs", "REGps", "systems", "REGcs", "regb", "reges", "orgds", "recp", "systemp", "funs", "recsets", "recds", "regds", "regp", "statp", "memh", "gregns", "REGs", "fund", "greges"], "fpu": [" fcpu", "sfpu", " fcp", "lpac", "frpu", "lpc", "vcp", " fpac", "fpl", "ppac", "frcpu", "ppr", "ppu", "Fpc", " fpl", "sfpc", "vpl", " fpc", "Fpl", "vpu", "Fcpu", "vpac", "fcpu", "Fpac", "frproc", " fproc", "fpr", "fproc", " fpr", "lpu", "fpc", "Fcp", "fpac", "frpc", "vcpu", "Fpu", "fcp", "vpc", "lpr", "sfproc", "ppc", "sfcpu"], "r": ["it", "d", "ru", "o", "dr", "rs", "ar", "R", "rar", "v", "ur", "br", "e", "u", "result", "rh", "rt", "l", "res", "rf", "m", "attr", "lr", "nr", "rr", "error", "rc", "pr", "k", "rb", "rec", "n", "fr", "hr", "c", "q", "h", "p", "b", "run", "mr", "sr", "f", "ir", "cr", "re", "w", "or", "err", "er", "vr", "rg"], "i": ["it", "field", "ini", "v", "u", "pi", "si", "vi", "in", "m", "ui", "ix", "n", "ni", "j", "ii", "t", "none", "I", "adi", "ie", "o", "my", "li", "e", "mu", "abi", "resource", "y", "slice", "a", "ti", "block", "eni", "id", "bi", "qi", "ip", "c", "x", "phi", "hi", "ri", "ori", "yi", "di", "gi", "fi", "data", "multi", "l", "ai", "key", "io", "zi", "anti", "d", "iu", "mi", "source", "xi", "inner", "uri", "g", "k", "z", "ci", "mini", "current", "oi", "info", "ji", "p", "index", "cli", "b", "uli", "f", "w"]}}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,\n\n                                    sPAPRDRConnectorType drc_type,\n\n                                    uint32_t drc)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n    hp->hotplug_identifier = hp_id;\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {\n\n            spapr_hotplug_set_signalled(drc);\n\n        }\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {\n\n        hp->drc.count = cpu_to_be32(drc);\n\n    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {\n\n        hp->drc.index = cpu_to_be32(drc);\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));\n\n}\n", "idx": 12887, "substitutes": {"hp_id": ["cp_id", "cp_name", "hp_name", "hp_image", "hp_type", "cp_type", "cp_image"], "hp_action": ["gp_name", "hp_uri", "hp_name", "hp_type", "gp_uri", "gp_action", "gp_type"], "drc_type": ["drc_id", "ddc_name", "drc_types", "drc_name", "ddc_id", "ddc_types", "ddc_type"], "drc": ["dri", " dri", " drd", " drt", "pdrc", "drd", "Drt", "pdri", "pdrd", "pdrt", "Drc", "Dri", "drt", "Drd"], "spapr": ["spapyr", "paprator", "pAPr", "spamprm", "spapR", "pAPrator", "spAPR", "pAPR", "spAPr", "spAPrator", "spampR", "spapyrator", "spapyrm", "spampr", "pAPrm", "spAPrm", "papr", "papR", "paprm", "spaprm", "spapyR", "spaprator", "spamprator"], "new_hp": ["new_hw", "new67fp", "newjtp", "newlexgp", "remote67hop", "newplehai", "newjhp", "new_cpp", "new___hm", "new_http", "newplehp", "private_xml", "private_hp", "newJgp", " new_http", "new___gp", "new_hop", "remote67hp", "New_phy", "new___hp", "remote_hop", "newplexml", "new___ht", "newThehp", "new_ht", "new_dh", "new_gp", "new_hap", "new_tp", " new_dh", "new_pai", "remote_hp", "newjcp", "new_fp", "newlexcpp", "newlexmph", "remote67hy", "newJht", "new_phy", " new_ht", "newjgp", "New_hp", "newThemph", "New_hap", "remote_fp", "new67hop", "new_mph", "newplepai", " new_cp", " new_tp", "new_cp", "new67hp", "newJhp", " new_cpp", "private_hai", "new_hm", "new_hai", " new_mph", "newJhm", "new67hy", "New_gp", "newThecpp", "new_xml", " new_hm", "remote67fp", " new_gp", "new_hy", "newThehw", " new_hw", "newlexhp", "remote_hy", "private_pai"], "hdr": ["ihdr", "Hdr", "dhdr", "ohvr", "Hride", "hvar", "hmdr", "ihDR", " hstr", "hmirt", "rhrid", "ohdr", "ihder", "dhDR", "hmstr", "shder", "shride", "ohmt", "shrid", "ehmt", "dhint", "hmrid", "thdr", "ehrid", "ohDR", "hrDR", "khrt", "khvar", "thrid", "hint", " hirt", "Hmt", "shirt", "enhdr", "HDr", "hDR", "ehdr", "hbr", "shstr", "Hint", "Hirt", "hmt", "ehDR", " hvar", "rhdr", "hstr", "Hrid", " hDr", " hDR", "enhrid", "hmDR", "rhint", "hrder", "shdr", "thendor", "HDR", " hrt", "hmint", "dhride", "ihstr", "hder", "hmvr", "shint", "enhbr", " hrid", "ohirt", "khdr", "thrt", "enhDr", "hirt", "shDR", "thint", "thvar", "hvr", " hvr", "rhendor", " hder", " hint", "khder", "hrid", "Hbr", "enhint", "ohrid", "hrdr", "hrstr", "hride", "shbr", "hendor", "hDr", "Hstr", "shendor", "enhirt", "hrt", "thder"], "v6hdr": ["v4hhint", "v6bhdr", "v9hint", "v3bhride", "v4hr", "v6hhdr", "v6HDR", "v6ehint", "v6phint", "v3hrid", "v3bhrt", "v6hride", "v6bhDR", "v6ehdr", "v6hlrid", "v4hint", "v6Hdr", "v6ghDR", "v6hint", "v9ehrt", "v0hdr", "v6ghint", "v4hhr", "v6ehDR", "v9ehint", "v6hr", "v6mrid", "v0ehrid", "v0hDR", "v6hlrt", "v6bhint", "v3bhrid", "v6phr", "v0hrid", "v0ehdr", "v6hldr", "v6hrt", "v6hhint", "v9hDR", "v6hhrt", "v6ghdr", "v6ghrid", "v0ehDR", "v0hint", "v6hhr", "v4hhDR", "v9hdr", "v3hdr", "v6hDR", "v6ehrt", "v9ehdr", "v6phdr", "v6Hr", "v4hhdr", "v6hlride", "v0ehint", "v6phrid", "v6bhride", "v6hrid", "v3hrt", "v6bhrid", "v4hDR", "v6mdr", "v3bhdr", "v6mride", "v9hrt", "v6bhrt", "v6Hint", "v3hride", "v6mrt", "v4hdr", "v9ehDR", "v6hhDR", "v6ehrid", "v6phDR"], "maina": [" mainA", "minan", "Maina", "westA", "Mainc", "masterc", "Mainan", "masteran", "mainan", " mainaa", "MainA", "centralan", "minc", "masterab", "mainas", " mainan", "centrala", "minaa", "mainab", "westa", "centralc", "minA", "masteraa", "minas", " mainc", "Mainas", "mainaa", "minb", "mainc", "mina", "Mainb", "westab", "centralb", "mainA", "westb", "masterb", "masterA", "mastera", " mainas", "minab"], "mainb": ["Maine", "defaultbar", "westbreak", "centralf", "nightbase", "mainbody", " mainf", "Mainab", "centralbar", "Maina", "nightf", " mainba", "Mainc", "masterB", " mainbase", "centralbody", "centralba", "masterab", "daybreak", "minc", "mine", "markb", " maine", "mainbar", "mainab", "centrala", "Mainf", " mainbreak", "maine", "defaulta", "centralc", "nightb", "minf", "mainbreak", "mainbase", "defaultb", " mainbar", " mainc", "centralab", " mainab", "minB", "minb", " mainbody", "mainc", "mina", "markba", "Mainb", "mainba", "centrale", "defaultc", "markf", "dayab", "westab", "mastere", "centralb", "nighta", "markbody", "mainB", "westb", "masterb", "Mainbar", "mastera", " mainB", "minbase", "dayb", "mainf"], "hp": ["fp", "phy", "prot", "hs", "ha", "hop", "imp", "cpp", "tp", "ssh", "phys", "jp", "pkg", "rh", "eth", "igh", "ht", "hd", "pp", "ih", "wp", "pg", "wm", "hm", "hh", "hap", "hw", "xp", "php", "config", "hl", "helm", "lp", "hai", "np", "drm", "dh", "ip", "bp", "rpm", "h", "cp", "p", "cli", "ph", "him", "pai", "hy", "dp", "gp", "vp"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n", "idx": 12894, "substitutes": {"s": ["ps", "fs", "sv", "o", "south", "private", "cs", "u", "parts", "ds", "states", "sys", "si", "ss", "ssl", "service", "state", "sq", "sports", "n", "os", "spec", "stats", "is", "side", "http", "c", "su", "sg", "ns", "sl", "f", "sie", "ses", "js", "share", "ls", "services", "sym", "S", "t"], "p": ["ps", "fp", "d", "o", "tp", "data", "jp", "v", "e", "pt", "ap", "pc", "pi", "P", "pp", "m", "sp", "api", "a", "g", "point", "n", "np", "pa", "c", "h", "cp", "b", "f", "pl", "w", "gp", "j", "r", "t", "pb"], "port": ["pipe", "part", "address", "test", "hop", "ports", "connection", "proxy", "v", "Port", "source", "op", "pt", "PORT", "match", "band", "end", "pi", "interface", "server", "pair", "service", "object", "m", "tag", "group", "state", "machine", "api", "export", "pool", "bridge", "host", "parent", "config", "point", "ort", "slave", "ip", "cp", "target", "device", "type", "component", "prop", "f", "mount", "child", "transfer", "j", "plugin", "t", "driver", "pod"], "dev": ["debug", "d", "bd", "di", "part", "app", "bug", "ev", "der", "priv", " device", "data", "user", "raw", "md", "dist", "mode", "plug", "DEV", "obj", "pt", "pub", "end", "cmd", "wd", "serial", "def", "pad", "conf", "bus", "prom", "mod", "api", "valid", "comment", "error", "Dev", "pu", "rad", "de", "block", "gu", "ch", "boot", "home", "development", "dem", "info", "off", "device", "dd", "od", "ver", "sk", "prop", "name", "ind", "w", "diff", "adv", "gd", "conn", "driver", "var", "ad", "kind"], "i": ["adi", "d", "ie", "di", "o", "gi", "ini", "mi", "iu", "fi", "t", "v", "multi", "li", "e", "u", "xi", "mu", "inner", "l", "pi", "oi", "uri", "si", "in", "ai", "ui", "m", "slice", "udi", "a", "ti", "k", "ix", "n", "eni", "ci", "id", "io", "bi", "qi", "ip", "x", "c", "ami", "phi", "hi", "index", "ki", "h", "b", "ni", "f", "zi", "j", "r", "ii", "ori", "I", "var"], "ret": ["en", "gt", "orig", "success", "fi", "data", "nt", "pat", "match", "result", "obj", "pub", "rt", "val", "res", "pet", "db", "det", "reply", "len", "fun", "error", "num", "reg", "rb", "rets", "id", "rev", "secret", "ext", "status", "cat", "lit", "rep", "re", "RET", "flag", "red", "std", "rl", "py", "bit", "pass", "ref", "alt", "Ret", "code"]}}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12916, "substitutes": {"bs": ["ps", "fs", "sync", "us", "ins", "bl", "bas", "bing", "cs", "ras", "obj", "bc", "bu", "ts", "base", "fb", "outs", "ds", "bes", "abi", "sys", "blocks", "ob", "ss", "ec", "db", "bos", "BS", "gs", "lb", "plugins", "nas", "obs", "lc", "es", "ubs", "ks", "org", "os", "iss", "bi", "bits", "is", "vs", "http", "bytes", "ns", "s", "bb", "bps", "b", "sb", "ab", "js", "ses", "eb", "las", "gb", "banks", "ls", "bis", "bid", "pb", "css"], "sector_num": ["sector__ident", "section_um", "section_number", "sector__num", "sector_nr", "section_ident", "sector_loc", "section_num", "sector__nr", "sector_number", "sector_um", "sector_name", "sector__number", "sector_ident", "section_name", "section_nr", "sector__name", "section_loc"], "qiov": ["qqiov", "ixicho", "xiov", "ixliv", "qiev", "ixiov", " qicho", "qicho", " qovi", "qqiev", "quiban", " qiban", "qovi", "qiban", "ixiev", "questovi", "quiov", "questiban", "quovi", "xliv", "qqicho", "xiev", "xicho", "questicho", "quicho", "qliv", "questiov", "qqliv"], "nb_sectors": ["nb_gearers", "nb_seccs", "nb_negments", "nb_serctor", "nb_seors", "nb_searers", "nb_serctions", "nb_vegments", "nb_ceors", "nb_spegments", "nb_sections", "nb_gegments", "nb_serctors", "nb_pecs", "nb_secgments", "nb_pegments", "nb_sercs", "nb_vections", "nb_spections", "nb_vefs", "nb_secctors", "nb_sergments", "nb_specs", "nb_spearers", "nb_vector", "nb_vecs", "nb_peors", "nb_secivers", "nb_serivers", "nb_cectors", "nb_seivers", "nb_nefs", "nb_pefs", "nb_sefs", "nb_cecs", "nb_nectors", "nb_peivers", "nb_spectors", "nb_geors", "nb_gectors", "nb_segments", "nb_neors", "nb_vectors", "nb_veors", "nb_speors", "nb_spector", "nb_secs", "nb_vearers", "nb_cegments", "nb_sector", "nb_pectors"], "cb": ["fp", "zb", "func", "bf", "CB", "bc", "fn", "cf", "pc", "orb", "fb", "obb", "cmd", "wb", "ob", "gc", "callback", "db", "lb", "fun", "lc", "rb", "ctx", "fc", "c", "pb", "bb", "b", "unc", "f", "sb", "abb", "abc", "xb", "nob", "function", "eb", "cv"], "opaque": ["ospaque", "oppatile", "uppaques", "opaques", " opaques", "uppatile", "oppaques", " opacity", " opacre", "uppacity", "opacity", "uppaque", "ospacity", "opatile", " copacre", "ospaques", " copacity", " copaques", "oppaque", " opatile", "oppacity", "ospacre", "opacre", " copaque"], "drv": ["DRw", "Drp", "rrv", "DRf", " drw", " drp", " drV", "hrf", "hrc", "hrv", "DRc", "hrb", "Drf", "rrver", " drver", "Drv", "drV", "srv", "rdw", "drp", "DRb", "rdv", " drb", "DrV", "Drb", "rrp", " drf", "srV", "srf", "drver", "drc", "rdf", "Drver", "src", "drw", "drb", "drf", "DRv", "rrf", "rdb", "srb"], "ret": ["gt", "bd", "ft", "fin", "real", " Ret", "success", "tmp", "bare", "data", "resp", "nt", "bf", "br", "ben", "match", "ut", "result", "obj", "rt", "att", "base", "val", "def", "gc", "job", "sys", "res", "db", "full", "det", "reply", "len", "valid", "str", "fun", "rc", "url", "reg", "rets", "arg", "id", "rev", "mem", "ext", "cat", "lit", "f", "re", "out", "RET", "flag", "back", "bit", "ref", "alt", "Ret", "code"], "wr_ops": ["rw_bytes", "rw_cycles", "wr_cycles", "wr_bytes", "rw_bits", "rw_ops", "wr_bits"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dct_init_x86(DCTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_SSE(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse;\n\n    if (EXTERNAL_SSE2(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse2;\n\n    if (EXTERNAL_AVX(cpu_flags))\n\n        s->dct32 = ff_dct32_float_avx;\n\n}\n", "idx": 12927, "substitutes": {"s": ["ps", "hs", "fs", "sync", "us", "rs", "uses", "cs", "e", "ts", "its", "features", "l", "parts", "states", "sys", "ans", "ss", "ssl", "an", "m", "gs", "sf", "g", "es", "ips", "os", "stats", "c", "h", "ats", "ns", "p", "qs", "aws", "sets", "f", "ses", "js", "settings", "ls", "services", "r", "t", "ops"]}}
{"project": "FFmpeg", "commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "target": 1, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n\n                             GetByteContext *gb)\n\n{\n\n    unsigned char rle_code;\n\n    unsigned char extra_byte, odd_pixel;\n\n    unsigned char stream_byte;\n\n    unsigned int pixel_ptr = 0;\n\n    int row_dec = pic->linesize[0];\n\n    int row_ptr = (avctx->height - 1) * row_dec;\n\n    int frame_size = row_dec * avctx->height;\n\n    int i;\n\n\n\n    while (row_ptr >= 0) {\n\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n\n                   row_ptr);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n\n        if (rle_code == 0) {\n\n            /* fetch the next byte to see how to handle escape code */\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            if (stream_byte == 0) {\n\n                /* line is done, goto the next one */\n\n                row_ptr -= row_dec;\n\n                pixel_ptr = 0;\n\n            } else if (stream_byte == 1) {\n\n                /* decode is done */\n\n                return 0;\n\n            } else if (stream_byte == 2) {\n\n                /* reposition frame decode coordinates */\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                pixel_ptr += stream_byte;\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                row_ptr -= stream_byte * row_dec;\n\n            } else {\n\n                // copy pixels from encoded stream\n\n                odd_pixel =  stream_byte & 1;\n\n                rle_code = (stream_byte + 1) / 2;\n\n                extra_byte = rle_code & 0x01;\n\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12940, "substitutes": {"avctx": ["abpc", "avcmp", " avcf", "afcontext", "AVcontext", "ajpc", "avecf", "ablc", "avpc", " avcontext", "AVlc", "AVscope", " avscope", "afconfig", "avconfig", "AVcmp", "evctx", " avcci", "avcf", "avectx", "abcmp", "ajcit", " avconfig", "abctx", "evlc", "afconn", "AVcci", "AVpc", "avcci", "afcmp", "afctx", "abcontext", "AVctx", "avlc", "AVcf", "avescope", "AVconfig", "afcci", "evcontext", "aflc", "AVcit", " avcit", "ajcmp", "evconn", "avconn", "AVconn", "avscope", "ajcontext", " avcmp", "avecontext", "avcit", "avcontext", "ajctx"], "pic": ["sync", "cam", "Pic", "oc", "fi", "image", "bc", "xi", "sci", "pc", "cycle", "pi", "gc", "mag", "doc", "bus", "gui", "pins", "quad", "cdn", "sec", "parse", "typ", "rc", "lc", "proc", "inch", "cus", "ac", "vc", "spec", "ctx", "bi", "fc", "picture", "mac", "lib", "cli", "pict", "coll", "ic", "ctrl", "mc", "pin", "cci", "conn", "img", "jc"], "gb": ["storage", "gy", "cam", "hub", "cgi", "jpg", "bf", "gm", "bc", "pc", "cfg", "cb", "kb", "gc", "GB", "db", "ga", "gui", "ui", "gio", "gal", "agi", "gs", "bg", "bridge", "gin", "g", "rb", "gam", "nb", "usb", "greg", "gz", "gram", "bb", "gnu", "gg", "mb", "vg", "sb", "abb", "gru", "src", "ub", "gp", "eb", "rg", "gd", "bm"], "rle_code": ["rle__Code", "rle8number", "rle64code", "rle_name", "rle64number", "rLE_byte", "rle__cod", "rlembyte", "rLE_call", "rle9count", "rLE_cod", "rle9number", "rle64Code", "rLE_name", "rle9name", "rlemconst", "rLE_number", "rle__const", "rle_codes", "rle8code", "rLE_count", "rle_number", "rlemcode", "rseOpcode", "rse_code", "rle_Code", "rle_value", "rle_const", "rle_call", "rleOpvalue", "rle__code", "rleOpbyte", "rLE_Code", "rseOpvalue", "rle_module", "rse_value", "rLE_module", "rleOpcode", "rle_cod", "rle_byte", "rle_count", "rle9code", "rle__codes", "rLE_code", "rle64call", "rLE_const", "rle__byte", "rseOpbyte", "rse_byte", "rle8count", "rle8name"], "extra_byte": ["stream_bit", "extra___bit", "stream_layer", "extra67byte", "extra67bit", "extra___message", "extra67value", "stream_character", "random_value", "extra_value", "extra_layer", "extra___layer", "random___bit", "extra67message", "random___byte", "random_bit", "extra_message", "extra_bit", "random_message", "extra___byte", "extra___value", "extra___character", "random___message", "random___value", "random_byte", "extra_character"], "odd_pixel": [" odd_byte", "oddvelcharacter", "odd_color", "odd\u00b7byte", "odd\u00b7pixel", "odd\u00b7pin", "odd_hole", " oddxpin", "odd_character", "odd_pin", " odd_pin", "oddencharacter", " oddxbyte", " oddxcolor", "oddenpixel", "auto_pixel", "oddvelhole", " odd_color", "odd_byte", "oddxpin", "oddenhole", "oddxcolor", "oddvelbyte", " oddxpixel", "oddxpixel", "odd\u00b7color", "oddvelpixel", "oddenbyte", "auto_character", "auto_byte", "oddxbyte", "auto_hole"], "stream_byte": ["header_token", "ssl_connection", "model_route", "streamPbyte", "stream67job", "stream_second", "video_byte", " stream_bytes", "streamdbytes", "streamobyte", "sslflowbyte", "console_outine", "roll_token", "model_function", "rollMbyte", "streamablebyte", "streamacfee", "streamflowoutine", "roll_rule", "filterSbyte", "console_byte", "stream_reference", "streammcode", "ssl_byte", "draw_code", "streamMtoken", "streamJcode", "filterStoken", "streamobin", "stream_block", "filter_code", "stream_route", "video_source", "streammByte", "streammsize", "streamablejob", "streamflowconnection", "filter_second", "stream_type", "streamdbyte", "readerJbyte", "streamMrule", "feed_byte", "streamJval", " stream_size", "streamMreference", "stream_page", "roll_byte", "stream67token", "reader_page", "streamJjob", "streamMsource", "stream67val", "streamSbyte", "reader_reference", "stream67position", "streamosecond", " stream_code", " stream_block", "streamedoutine", "streamMchannel", "header_value", "drawdunit", "streamalltype", "stream_code", "streamScode", "ssl_outine", "roll_channel", "stream_channel", "streamdcode", "feed___byte", "streamedlevel", "streamedbyte", "stream_level", "streamflowbyte", "filterobyte", "stream_full", "streamMphase", "streamCphase", "feed___val", " stream_binary", "stream_unit", "readerJblock", "streamJfull", "streamPcode", "streamCbyte", "streamPvalue", "stream_bin", "stream_position", " stream_job", "reader_note", "filterSfee", "feed_val", "streamMblock", "stream67byte", "sslflowchannel", "streamedByte", "stream_phase", "streamCblock", "feed___full", "filterobin", "console_Byte", "filter_token", " stream_channel", "stream_token", "streamallnode", "draw_byte", "stream_Byte", "stream_binary", "streamingbytes", "stream67full", "filter_bin", "reader_code", "reader_phase", "stream_size", "stream_fee", "header_position", "streamingchannel", "stream_rule", "streamJfee", "streamJbyte", "stream_value", " stream_Byte", "sslflowoutine", "streamingblock", "stream___bytes", "sslflowconnection", "feed___job", "header_byte", "stream_layer", "streamCreference", "stream_val", "stream_source", "stream_node", "streamaccode", "stream_connection", "model_node", "streamMnode", "draw_unit", "filterolayer", "streamJreference", "streammbyte", "drawdbyte", "filter_byte", "filter_layer", "feed_full", "rollMchannel", "streamSfee", "stream_note", "streamactoken", "streamStoken", "stream___channel", "streamallsource", "streamMtype", "stream___byte", "streamablebinary", "drawdcode", "readerJreference", "readerJphase", "streamflowchannel", "video_type", "model_byte", "streamolayer", "filter_fee", "filterScode", "streamPtoken", "streamJblock", "console_level", "stream_bytes", "streamdunit", "draw_bytes", "streamPpage", "filterosecond", "streamablechannel", "stream67value", "video_node", "rollMrule", "stream_job", "streamJtoken", "stream___job", "streamMbyte", "ssl_channel", "rollMtoken", "streamacbyte", "stream_function", "stream_outine", "stream___block", "streamingbyte", "stream___val", "drawdbytes", "streamJphase", "stream___full", "feed_job", "streamPposition", "streamallbyte", "reader_block", "reader_byte", "streamPnote"], "i": ["it", "ie", "d", "di", "gi", "chi", "ini", "iu", "fi", "split", "multi", "v", "li", "t", "count", "e", "xi", "u", "l", "pi", "uri", "page", "si", "in", "ai", "ui", "ti", "k", "ix", "eni", "n", "ci", "id", "mini", "io", "bi", "qi", "ip", "phi", "x", "c", "hi", "ji", "ki", "p", "index", "cli", "ri", "b", "ni", "start", "f", "zi", "ind", "ski", "j", "ii", "I", "yi", "code"], "pixel_ptr": ["row_addr", "row_wr", "pixelityptr", "pixelIddegree", "cpuIdpair", "pixelxpointer", "pixel_wr", "pixelPopointer", "cpu_ptr", "pixelPdim", "pixelacpair", "pixelityaddr", "cpuIdptr", "pixelaldim", "row_pointer", "pixel_pair", "pixel_addr", "pixelityref", "pixelIdptr", "cpuIdref", " pixel_cro", "pixelxpointers", "row_ptr", " pixel_pointer", "pixel_ref", "pixelitypointer", "row_inter", " pixel_degree", "pixel_dim", "pixelxptr", "pixelalinter", "pixelacptr", "pixel_inter", "pixelalptr", "pixelalpointer", "pixel_cro", "cpu_degree", "pixelPinter", "cpu_pair", "pixel_proc", "pixelPowr", "pixel_pointers", "pixelitypair", "cpu_ref", "pixelxdegree", "pixelacdegree", "pixelPptr", "row_proc", "row_dim", "pixel_slice", " pixel_slice", "pixelitycro", "pixel_degree", "pixelacref", "pixelPpointer", " pixel_pointers", "row_pos", "pixelIdref", "cpuIddegree", "pixelitydegree", "pixelIdpair", "pixelPoptr", "pixel_pos", "pixel_pointer", " pixel_addr", "pixelPoaddr"]}}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "substitutes": {"env": ["stack", "enc", "en", "engine", "atten", "environment", "ev", "esp", "dt", "priv", "exec", "exc", "vm", "v", "e", "hess", "ench", "server", "style", "qt", "kn", "qa", "eng", "ec", "db", "dep", "queue", "esm", "el", "cdn", "export", "assets", "vel", "config", "proc", "ea", "eu", "net", "fen", "eni", "iv", "np", "ctx", "opt", "init", "her", "context", "ah", "shell", "viron", "info", "tern", "esi", "here", "energy", "gear", "que", "console", "loader", "er", "buf", "forge", "equ", "chal", "conn", "enh", "Environment"], "l": ["d", "o", "kl", "v", "la", "li", "ol", "ll", "source", "u", "fl", "e", "length", "L", "lu", "level", "m", "el", "lr", "lb", "al", "lin", "url", "lc", "dl", "g", "z", "k", "lp", "n", "ell", "ln", "c", "shell", "h", "ul", "line", "layer", "p", "x", "b", "lit", "s", "sl", "il", "f", "w", "rl", "lang", "j", "ls", "nl", "loc", "t", "len"], "dest": ["delete", "session", "priv", "v", "dir", "wd", "output", "dat", "later", "sup", "ident", "gen", "start", "pl", "master", "diff", "Dest", "trans", "tmp", "shift", "front", "cont", "temp", "seed", "du", "txt", "resource", "path", "destroy", "transform", "ssl", "slice", "inst", "lc", "lower", "null", "done", "di", "route", "data", "st", "feat", "rest", "end", "head", "wb", "dep", "attr", "cdn", "origin", "usr", "class", "opt", "dev", "home", "other", "lit", "name", "future", "again", "text", "bound", "norm", "d", "gl", " destination", "south", "source", "dist", "comb", "store", "desc", "dc", "vision", "grad", "uc", "url", "config", "proc", "de", "gz", "coord", "target", "secure", "uv", "b", "sign", "prop", "loc", "img"], "src": ["sc", "cb", "sur", "SOURCE", "sys", "sec", "RC", "rb", "sup", "cur", "sh", "req", "start", "sb", "sr", "back", "connect", "sync", "front", "image", "fl", "download", "resource", "ssl", "slice", "inst", "lc", "gin", "view", "rib", "iv", "remote", "filename", "null", "bl", "st", "bc", "feat", "rest", "sel", "username", "nil", "sn", "rc", "lit", "sl", "ource", "stream", "sth", "gl", "source", "dist", "project", "ruby", "desc", "length", "uri", "rob", "vision", "uc", "url", "config", "proc", "sub", "hl", "low", "ul", "gz", "s", "target", "b", "rl", "gb", "r", "loc", "img", "gn", "support"], "i": ["it", "d", "ie", "di", "o", "gi", "my", "ini", "mi", "fi", "iu", "t", "v", "li", "e", "u", "xi", "mu", "pi", "L", "uri", "si", "y", "ai", "m", "ui", "ti", "ix", "z", "n", "ci", "id", "io", "bi", "qi", "ip", "c", "x", "phi", "hi", "ji", "p", "index", "ri", "b", "ni", "f", "zi", "j", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "0d2cd785ef1282b14687f9f7f4b63ae4a2430be3", "target": 1, "func": "static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 12949, "substitutes": {"path": ["prefix", "enc", "sync", "step", "test", "route", "xml", "success", "temp", "Path", "raw", "pat", "patch", "param", "mode", "match", "image", "format", "inner", "desc", "pattern", "model", "uri", "resource", "transform", "full", "ith", "api", "str", "url", "error", "config", "parent", "location", "method", "key", "view", "handler", "id", "PATH", "node", "axis", "pointer", "clean", "p", "index", "col", "ath", "type", "row", "name", "child", "call", "request", "value", "text", "pass", "loc", "ref", "dest", "code"], "recurse": ["Recieve", "rurse", "Recurse", "curse", "cursed", " recursive", "Recursed", "cursive", " recieve", "recursed", " recursed", "cieve", "rursed", "Recursive", "Recursion", "rursive", "recieve", "recursion", "recursive", " recursion", "rursion"], "child_path": ["parent_ath", "child___pointer", "child_prop", "child_row", " childspointer", "child_name", " childsrow", "child___path", "parent_name", "childfulpointer", " child_child", "childspath", " child_ath", "childfulrow", "childspointer", " child_row", "parent_path", "child_ath", "parent_full", "child___request", "child_pointer", "child_request", " child_pointer", "parent_request", "child_child", " childspath", " childsath", "childsath", "childsrow", "child___name", "child_full", "childfulath", " child_prop", "childfulpath", "parent_pointer"], "response": ["body", "document", "json", "o", "route", "connection", "success", "xml", "received", "given", "site", "data", "react", "resp", "onse", "tree", "e", "image", "result", "message", "output", "model", "server", "uri", "property", "resource", "def", "answer", "service", "queue", "object", "respond", "api", "reply", "graph", "error", "host", "parent", "view", "os", "successful", "version", "feed", "relation", "complete", "collection", "application", "dict", "su", "status", "reason", "example", "f", "child", "Response", "request", "err", "value", "respons", "r", "array", "sequence"], "tuple": ["Tachment", "pticket", "tyrie", "Turtle", "protple", "mictionary", "tuesday", "tauple", "tachment", "protutor", " tuesday", "tenple", "typle", "turtle", "taoutine", "artple", "artuple", "Taken", "tickle", "taque", "protoutine", " tictionary", "muesday", "ptutable", "Ticket", "tque", " tachment", "ytque", "protuple", "artrie", "tutor", "proticle", "taictionary", "trie", "tenoutine", "taple", "protque", "ptuple", "pturtle", "muple", "torickle", " tickle", "tple", "toutine", "Tictionary", "taicle", "artutable", "tyutable", "tyuple", " ticket", "ytictionary", "taken", "protictionary", "tenuple", "ticket", "ptple", "torachment", "ytuple", "ptrie", "ptickle", "ytutor", "toruple", "Tickle", "mickle", "ticle", "Tuesday", "tenicle", "Tuple", "tictionary", " taken", " turtle", "tutable", "tautor", "toraken"], "list": ["client", "part", "LIST", "batch", "session", "test", "all", "data", "la", "lists", "listed", "li", "ll", "tree", "result", "l", "base", "server", "ml", "val", "queue", "el", "pool", "List", "lc", "parse", "parent", "g", "self", "cache", "ul", "collection", "p", "range", "type", "cl", "coll", "table", "name", "out", "child", "call", "chain", "array", "sequence"], "entry": ["ries", "part", "ie", "address", "card", "connection", "data", "reader", "Entry", "record", "search", "ry", "e", "nt", "obj", "result", "ge", "enter", "server", "element", "query", "object", "se", "insert", "comment", "error", "parse", "key", "item", "id", "feed", "archive", "line", "info", "range", "index", "member", "row", "child", "term", "r", "cell", "event", "array"], "prop": ["ps", "part", "field", "priv", "data", "param", "op", "pos", "pt", "feat", "property", "val", "attr", "vec", "xy", "rop", "lc", "config", "proc", "num", "pr", "key", "arg", "id", "opt", "properties", "line", "info", "cp", "ref", "p", "col", "type", "lit", "name", "pred", "option", "value", "loc", "Prop", "comp", "pro", "pb"]}}
{"project": "FFmpeg", "commit_id": "482ee63641f4fa50f017538af384aadbceee7a18", "target": 1, "func": "static int thp_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    ThpDemuxContext *thp = s->priv_data;\n\n    AVStream *st;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n\n\n    /* Read the file header.  */\n\n                           avio_rb32(pb); /* Skip Magic.  */\n\n    thp->version         = avio_rb32(pb);\n\n\n\n                           avio_rb32(pb); /* Max buf size.  */\n\n                           avio_rb32(pb); /* Max samples.  */\n\n\n\n    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);\n\n    thp->framecnt        = avio_rb32(pb);\n\n    thp->first_framesz   = avio_rb32(pb);\n\n                           avio_rb32(pb); /* Data size.  */\n\n\n\n    thp->compoff         = avio_rb32(pb);\n\n                           avio_rb32(pb); /* offsetDataOffset.  */\n\n    thp->first_frame     = avio_rb32(pb);\n\n    thp->last_frame      = avio_rb32(pb);\n\n\n\n    thp->next_framesz    = thp->first_framesz;\n\n    thp->next_frame      = thp->first_frame;\n\n\n\n    /* Read the component structure.  */\n\n    avio_seek (pb, thp->compoff, SEEK_SET);\n\n    thp->compcount       = avio_rb32(pb);\n\n\n\n    /* Read the list of component types.  */\n\n    avio_read(pb, thp->components, 16);\n\n\n\n    for (i = 0; i < thp->compcount; i++) {\n\n        if (thp->components[i] == 0) {\n\n            if (thp->vst != 0)\n\n                break;\n\n\n\n            /* Video component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* The denominator and numerator are switched because 1/fps\n\n               is required.  */\n\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_id = CODEC_ID_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->width = avio_rb32(pb);\n\n            st->codec->height = avio_rb32(pb);\n\n            st->codec->sample_rate = av_q2d(thp->fps);\n\n            thp->vst = st;\n\n            thp->video_stream_index = st->index;\n\n\n\n            if (thp->version == 0x11000)\n\n                avio_rb32(pb); /* Unknown.  */\n\n        } else if (thp->components[i] == 1) {\n\n            if (thp->has_audio != 0)\n\n                break;\n\n\n\n            /* Audio component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_ADPCM_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->channels    = avio_rb32(pb); /* numChannels.  */\n\n            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */\n\n\n\n            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n            thp->audio_stream_index = st->index;\n\n            thp->has_audio = 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12951, "substitutes": {"s": ["ps", "us", "sv", "ins", "sc", "cs", "e", "sa", "sci", "ts", "ds", "sys", "si", "ss", "ssl", "service", "se", "sp", "sq", "gs", "sf", "sn", "sam", "g", "ks", "n", "os", "spec", "c", "su", "sg", "p", "ns", "b", "aps", "sl", "f", "sr", "sb", "src", "sis", "ses", "ls", "services", "r", "S", "sym", "t"], "ap": ["mp", "AP", "ar", "amp", "aram", "pm", "att", "pac", "pp", "cap", "ai", "attr", "sp", "map", "api", "al", "ac", "am", "pa", "cp", "ast", "aps", "ams", "as", "av", "au", "arp", "array"], "thp": ["sthps", "ethps", "thk", "whl", "thpo", "ethw", "thtp", "uthf", "ithip", "thinm", "ftp", "ethop", "whlp", "uthp", "stht", "athpc", "thip", "sthf", "phn", "althpo", "thpi", " thfp", "whpc", "etht", "ntn", "othf", "ithpe", "ethk", "rahk", "thinop", "ntpe", " thcp", "tht", "htpe", "thf", "sthpe", "Thps", " thbp", "rahl", "thpc", "ethpi", "thg", "harp", "ithop", "athl", "thinpe", "rahp", "uthpc", "thps", "pathps", "htp", "othp", "rahpc", "thl", "rahip", "thfp", "whf", "uthpe", " thlp", "Thpc", "akwp", "ethp", " thw", "hell", "whpe", "thper", "othpc", "whp", "Thp", " thps", "patht", "thop", " thl", "ntp", "thwp", " thwp", "thw", "ethm", "ethpc", "htjp", "thbp", "sthn", "thn", "help", "rahpi", "pathp", "ntlp", "ftf", "ithm", " thn", "htm", " tht", "the", "thjp", "athcp", "thlp", "othlp", " thf", " thip", "php", "ethn", "ithpo", "harpe", "helt", "ethcp", "sthtp", "sthlp", "ithtp", "sthop", "phfp", "thpe", "ethl", " thg", "sthpc", "athp", "ethg", " thm", " thv", "ithfp", "thinp", "ethlp", "hellp", "sthp", " the", " thk", "ithl", "althp", "phl", "ithn", "thv", " thpe", "althn", "sthper", "itht", "helpe", "ethbp", " thpi", "sthv", "ethper", "hart", "helwp", "ethv", "akp", "ftw", "ethjp", "ithpc", "thcp", "Thbp", "thm", "ethe", " thjp", "ithp", "sthpo", " thper", "whg", "ithlp", "aklp", "ithf", "ithe", "harl", "althtp", "ethf", " thpc", "pathop", "ftpe", "akpe", "ethpe"], "st": ["part", "et", "ct", "ST", "sv", "ft", "bl", "pe", "stress", "nd", "amp", "nt", "ust", "sc", "St", "pt", "ut", "rest", "ts", "pc", "ld", "sa", "rt", "obj", "l", "pp", "ste", "stim", "ss", "sp", "rd", "bt", "inst", "sf", "sty", "sn", "sta", "str", "sec", "sts", "fr", "est", "sd", "stop", "sh", "art", "put", "ast", "cl", "sw", "sl", "ist", "src", "sb", "sr", "kt", "start", "td", "ost", "sth", "std", "t", "irst"], "pb": ["fp", "prot", "mp", "um", "apy", "cpp", "hub", "tmp", "tp", "phys", "jp", "uf", "txt", "bf", "plug", "bc", "pkg", "pc", "pm", "cb", "fb", "wb", "rob", "wp", "pg", "summary", "db", "pid", "PB", "uc", "pd", "api", "lb", "typ", "bh", "rb", "lp", "pa", "fc", "phrase", "bp", "ppa", "rpm", "cp", "http", "bot", "bps", "p", "bb", "b", "lab", "pit", "prop", "sb", "pl", "dp", "ab", "src", "ub", "eb", "gb", "xb", "vp", "abc", "platform", "wikipedia", "plugin", "bm", "cv"], "i": ["d", "ie", "di", "gi", "chi", "ini", "iu", "fi", "mi", "t", "v", "multi", "li", "loop", "e", "pos", "xi", "u", "inner", "l", "pi", "abi", "si", "y", "counter", "ai", "ui", "a", "ti", "num", "ix", "key", "sup", "k", "n", "eni", "gu", "ci", "id", "mini", "bi", "is", "ip", "qi", "c", "phi", "hi", "x", "p", "index", "ri", "b", "uli", "ni", "f", "zi", "diff", "j", "ii", "yi", "I", "clip", "code"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968, "substitutes": {"rdma": ["ldma", "rdmma", "ridmma", "rtta", "rtda", "rdmad", "rtea", "ndmas", "rxmma", "rgda", "ldda", "vrda", "rdmas", "raftma", "ndda", "rtmas", "ldqa", "rtsta", "raftsta", "rdea", "rtama", "rlda", "raftda", "rnmas", "ridqa", "rnma", "vrma", "raftmma", "rdmar", "rnmad", "rdqa", "rdda", "rrta", "ldta", "rtmma", "ldmar", "rxma", "vrmar", "vrmas", "rgea", "rgmas", "rrama", "rlsta", "rgma", "ridma", "rtmar", "rlma", "rnda", "ndmad", "rtmad", "ridmas", "rxqa", "rrma", "rnea", "rrda", "ndma", "rtma", "ldmma", "rdama", "ldmas", "rdsta", "ldama", "rlmma", "rxmas", "rdta"], "block_name": [" block_number", "byte_names", "block_class", "byte_name", "plugin_description", "blockingdef", "blockfullspec", "blockingspec", "blockfulldescription", "byte_def", " block_size", "block_names", "plugin_spec", "block___class", "byte_spec", "block___description", "block_def", "block__name", "block_spec", "block__number", "blockingnames", "plugin_class", "blockingname", "block_description", "plugin_name", "block_number", "block___name", "block__size", "block___spec", "blockfullclass", "blockfullname", "block_size"], "host_addr": ["hostingoffset", "server_off", "block_size", "hostalslot", "hostingnr", "host6address", "host_off", " host_ad", "server_addr", "block_address", "hostingaddress", "hostaladdr", "hostacindex", "server_address", "host6index", "host_ad", "hostacsize", "hostingname", "block_addr", "hostipaddress", "hostingad", "host_nr", "hostipaddr", "hostaladdress", "hostacaddress", "block_index", "host_address", "host6addr", " host_offset", " host_nr", "hostalindex", "host_size", "host_name", "host_offset", "hostacaddr", "hostingoff", "host6size", "host_index", "hostipslot", "block_slot", "host_slot", "hostipindex", "hostingaddr", "server_name"], "block_offset": ["block_padding", "block_length", "block___size", "block___offset", " block_size", "block_addr", " block_prefix", "block_prefix", "byte_size", "byte_padding", "byte_offset", " block_length", "byte_addr", "block___addr", "block___padding", "block_size"], "length": ["body", "part", "address", "height", "position", "pull", "split", "count", "Length", "end", "l", "duration", "size", "base", "style", "depth", "path", "shape", "padding", "zip", "limit", "offset", "slice", "form", "time", "seq", "url", "key", "capacity", "lock", "ch", "weight", "ength", "line", "h", "range", "index", "type", "p", "name", "th", "load", "lang", "section", "angle", "build", "len", "number", "live", "sequence", "code"], "local": ["update", "client", "wall", "session", "joined", "list", "all", "temp", "same", "initial", "global", "private", "link", "user", "external", "util", "container", "inner", "join", "l", "base", "model", "server", "package", "post", "partial", "full", "new", "group", "el", "state", "valid", "standard", "pool", "parse", "small", "parent", "self", "lock", "event", "node", "home", "current", "http", "clean", "missing", "instance", "plugin", "public", "tx", "child", "get", "Local", "lang", "remote", "build", "foreign", "final", "loc", "pass", "back", "shared", "pack", "custom", "single"], "block": ["session", "address", "check", "exec", "link", "patch", "join", "work", "open", "condition", "group", "map", "label", "parent", "channel", "un", "init", "instance", "none", "prev", "sync", "part", "flow", "global", "raw", "record", "image", "match", "random", "copy", "builder", "header", "new", "tag", "pool", "BL", "error", "num", "view", "node", "cache", "ip", "line", "close", "off", "outer", "load", "buffer", "option", "chain", "event", "null", "update", "bl", "user", "script", "model", "bin", "blocks", "object", "comment", "unit", "byte", "pre", "key", "lock", "http", "clean", "ban", "other", "type", "name", "out", "call", "bit", "wall", "panel", "container", "base", "style", "def", "post", "full", "loc", "frame", "config", "point", "Block", "info", "index", "cl", "row", "child", "before", "request", "clock", "section", "build", "plugin", "number", "pack"], "old": ["update", "part", "orig", "o", "original", "ore", "ld", "existing", "obj", "e", "inner", "l", "base", "att", "model", "val", "post", "Old", "and", "full", "object", "an", "new", "el", "state", "slice", "prev", "small", "pre", "OLD", "last", "where", "arg", "low", "buff", "now", "current", "older", "clean", "p", "other", "gen", "row", "f", "ind", "or", "diff", "before", "ard", "build", "handle", "array", "from"], "x": ["ux", "xe", "pe", "t", "v", "e", "xi", "u", "base", "work", "val", "y", "lex", "m", "dx", "xy", "ady", "xx", "xs", "xp", "num", "wx", "ww", "ix", "k", "z", "id", "c", "i", "h", "max", "rx", "ext", "p", "index", "ax", "ex", "b", "sw", "sex", "fx", "tx", "f", "wa", "name", "w", "xxx", "xb", "r", "j", "xc", "xt", "xa", "X", "code"], "nb_blocks": ["nn54blocks", "nr__images", "nb_maps", "nr__blocks", "num_images", "num_frames", "nbJblocks", "nb__chains", "nn54heads", "nb_frames", "nbJbars", "nbJlocks", "nb__maps", "nb_ins", "nbJrooms", "nr_blocks", "nb_images", "nb___quarters", "num_blocks", "nb54works", "b_blocks", "nb_boxes", "b_classes", "nb_bars", "nr_images", "nn54works", "nb__frames", "nn_heads", "num_rooms", "nr_maps", "nb64blocks", "nb_rooms", "nbJboxes", "nb__images", "nn_chains", "nb54heads", "nb64works", "nb_locks", "nb__locks", "num_chains", "nb64heads", "nn_works", "nb___blocks", "nb_heads", "nb_classes", "nbJclasses", "nr__frames", "nb54blocks", "b_ins", "nb_chains", "nn54chains", "nr_frames", "nn_blocks", "num_locks", "num_boxes", "nb54chains", "nbJins", "b_bars", "nr__maps", "nb64chains", "nb___images", "nb_works", "nb___locks", "nb__blocks", "nb_quarters", "num_quarters"]}}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 12984, "substitutes": {"bytes": ["ps", "seconds", "days", "files", "fee", "data", "outs", "hops", "ds", "blocks", "gs", "items", "seq", "byte", "ips", "os", "bits", "ns", "bps", "eps", "frames", "flags", "ls", "units", "ops"], "sz": [" sce", " size", "lsce", "size", "scl", "sce", "Sce", "lsz", "Sz", "Size", "lscl", " scl", "Scl", "lsize"], "op": ["update", "Op", "o", "omp", "oper", "app", "hop", "dr", "route", "oc", "opp", "mode", "oid", "pos", "ap", "cop", "iop", "cmd", "orb", "open", "pp", "copy", "ob", "google", "OP", "post", "wp", "cmp", "root", "sp", "dot", "prev", "ep", "om", "error", "num", "up", "proc", "operator", "ips", "OPER", "opy", "pop", "operation", "opt", "init", "ip", "http", "cp", "top", "set", "p", "off", "type", "cat", "oop", "gen", "or", "ocr", "option", "bit", "loc", "opus", "comp", "ops"], "addr": ["address", "route", "data", "nc", "rt", " ip", "wp", "sp", "map", "apper", "ptr", "mx", "ctx", "opt", "ip", "extra", "args", "mac", "tx", "src", "dp", "port", "gp", "parser", "transfer", "arp", "pack"], "xp": ["fp", "fm", "pipe", "adj", "omp", "dj", "imp", "esp", "xe", "cpp", "hop", "xml", "exec", "jp", "txt", "project", "nc", "pkg", "expr", "qt", "qa", "wp", "pg", "isp", "esm", "zip", "xy", "sf", "hw", "xs", "php", "hp", "wx", "opy", "ix", "lp", "osi", "org", "ctx", "axe", "yp", "ppa", "bp", "ppo", "rpm", "cp", "p", "eps", "lvl", "cli", "Pg", "fx", "tx", "XP", "dm", "dp", "python", "gp", "vp", "asm", "xc", "xt"], "tp": ["fp", "gt", "dt", "pkg", "sys", "ta", "api", "tf", "hp", "np", "tg", "tif", "t", "prot", "prefix", "mp", "tmp", "all", "txt", "tc", "ht", "TP", "ssl", "_", "typ", "id", "mt", "ip", "bps", "gp", "ctr", "jp", "end", "qt", "wp", "cmp", "vt", "php", "byte", "lp", "bp", "http", "tap", "plugin", "py", "sth", "d", "sv", "pt", "sp", "tm", "g", "tk", "cp", "p", "cli", "s", "dp", "utils", "port", "parser", "transfer", "vp", "arp", "pack", "pb"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 13001, "substitutes": {"vpci_dev": ["vpcivdist", "vpci_debug", "vpci_engine", "vpci1dev", "vpci2device", "vpci_conf", "vpci5rc", "vpci5dev", "vpdi_dev", "vpci1ver", "vpci1development", "vpci_rc", "vpci_priv", "vpcifdevice", "vpix_dev", "vpix_development", "vpix_ver", "vpc_dev", "vpci_development", "vpccifpub", "vpci2conf", "vpcisdevice", "vpcci_pub", "vpci_ver", "vpcci_device", "vpci2dev", "vpcivdevice", "vpc_rc", "vpci_device", "vpcisengine", "vpdi_priv", "vpccifdevice", "vpdi_device", "vpcci_dev", "vpci_dist", "vpc_device", "vpcisrc", "vpcifdev", "vpdi_conf", "vpci2priv", "vpci5device", "vpci_driver", "vpc_engine", "vpi_dist", "vpcisdev", "vpci1debug", "vpcifpub", "vpccifdev", "vpi_dev", "vpcivdev", "vpi_device", "vpcivdriver", "vpi_driver", "vpci_pub", "vpci5engine", "vpix_debug"], "errp": [" errcp", " errfp", "ercp", "errcp", "Ercp", " errf", "ErP", "Erf", "Erop", "erf", "errf", "errfp", " errP", "errop", " errop", "erP", "erfp", "erop", "errP", "Erfp", "erp", "Erp"], "vinput": ["construct", "vanPUT", "vinPUT", "vinsec", "vanconst", "vinconst", "kinstruct", "vansec", "vanper", "vidsec", "conPUT", "evinput", "vidcut", "kinPUT", "vinstruct", "vanput", "vancut", "evinper", "vincut", "vidper", "evincut", "kinconst", "vanstruct", "evinsec", "kinput", "vidput", "vinper", "conput", "conconst"], "vdev": ["lvdev", "qdevice", "rdev", "qconf", " vprop", "lvdiv", "qdev", "lvprop", "pdiv", "evdiv", "vdiv", "rconf", "pconf", " vdevice", "evdevice", "vconf", " vdevelopment", "qev", " vev", "vdevelopment", "evdevelopment", "vev", "rbus", "vdef", "qdef", "lvdevice", "pbus", "pev", "pdev", "pprop", "pdef", "vprop", "pdevelopment", "evdev", "qbus", "pdevice", "vbus", "rdevice", "vdevice", " vdiv", " vdef"]}}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n", "idx": 13002, "substitutes": {"data": ["done", "fail", "module", "d", "batch", "o", "session", "test", "dt", "connection", "exec", "draw", "reader", "record", "results", "result", "inner", "script", "base", "model", "dat", "ds", "style", "def", "database", "writer", "object", "db", "new", "ui", "this", "str", "config", "parent", "input", "stage", "i", "info", "window", "p", "missing", "Data", "dd", "DATA", "parser", "da", "ad", "code"], "unused": [" unusing", "UNused", "Unchecked", "Unusing", "UNusing", "UNuse", "unuse", " unchecked", "unusing", "UNchecked", " unuse", "unchecked", "Unuse", "Unused"], "err": ["iter", "dr", "der", "ar", "fi", "fer", "exc", "resp", "e", "result", "rh", "fy", "cb", "finder", "ise", "nr", "str", "rr", "error", "rage", "pr", "fr", "spec", "cur", "init", "ler", "req", "inc", "order", "mr", "Er", "arr", "ir", "cr", "msg", "ind", "aster", "found", "er", "Error", "rn", "r", "raise", "ref", "var"], "obj": ["adj", "ie", "o", "tmp", "fi", "jp", "amp", "po", "nt", "opp", "br", "act", "fn", "pt", "rt", "orb", "cb", "ob", "val", "object", "db", "el", "api", "inst", "elt", "str", "aj", "eff", "parent", "rb", "n", "os", "io", "ctx", "nb", "node", "so", "id", "x", "oi", "art", "args", "bot", "p", "lib", "od", "ex", "b", "coll", "Obj", "arr", "src", "name", "sb", "bo", "bj", "js", "j", "ref", "t", "alt", "img", "oa"]}}
{"project": "qemu", "commit_id": "d1048bef9df0aacde9a54bf9b5b97a6e10950d8c", "target": 0, "func": "static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n", "idx": 13012, "substitutes": {"obj": ["module", "o", "func", "tmp", "office", "po", "act", "pt", "pos", "orb", "cb", "base", "ob", "object", "objects", "attr", "api", "inst", "emb", "bh", "org", "os", "boot", "opt", "ctx", "nb", "node", "so", "args", "code", "p", "core", "od", "b", "instance", "Obj", "src", "pl", "j", "ref", "img", "oa"], "value": ["done", "update", "test", "pause", "action", "down", "v", "allowed", "primary", "mode", "result", "message", "size", "VALUE", "property", "val", "service", "state", "valid", "values", "selected", "create", "age", "change", "current", "complete", "slave", "status", "active", "off", "type", "b", "valued", "name", "accept", "enabled", "bo", "Value", "w", "paid", "function", "null"], "errp": ["erfp", "rrfp", "erpc", "errr", " errpc", "rrp", "errfp", " errfp", "rrr", "err", "erp", "errpc", "rrpc", " errr"], "pcms": ["PCfs", "pcws", "mcps", "pcMs", "ucms", "fcws", "fcfs", "PCws", "PCms", "fcms", "fcMS", "mcMs", " pcMS", " pcfs", "cps", "pcfs", "ucMs", "pcMS", "pcps", "cMs", "cMS", "ucps", "PCMS", "ucMS", "mcMS", "mcms", " pcws", "cms"]}}
{"project": "FFmpeg", "commit_id": "5763f675024765df8f256d8b5b01926a5fbd997d", "target": 1, "func": "static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = avformat_new_stream(c->fc, NULL);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    st->id = c->fc->nb_streams;\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n\n    sc->ffindex = st->index;\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n\n                            (!sc->sample_size && !sc->sample_count))) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        return 0;\n\n    }\n\n\n\n    fix_timescale(c, sc);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n\n        if (mov_open_dref(&sc->pb, c->fc->filename, dref, &c->fc->interrupt_callback,\n\n            c->use_absolute_path, c->fc) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR,\n\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n\n                   st->index, dref->path, dref->dir, dref->filename,\n\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n\n    } else {\n\n        sc->pb = c->fc->pb;\n\n        sc->pb_is_copied = 1;\n\n    }\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (!st->sample_aspect_ratio.num &&\n\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}\n", "idx": 13024, "substitutes": {"c": ["enc", "ct", "cu", "com", "cn", "t", "v", "cm", "tc", "cs", "con", "bc", "nc", "C", "e", "cf", "cit", "pc", "cd", "l", "icc", "u", "anc", "ec", "cc", "dc", "m", "this", "uc", "lc", "rc", "config", "g", "cus", "k", "self", "ac", "vc", "ci", "ce", "ctx", "ch", "cur", "fc", "cache", "cp", "p", "cod", "cl", "cat", "b", "cy", "arc", "coll", "ic", "co", "f", "cr", "ca", "mc", "abc", "xc", "conf", "jc"], "pb": ["fp", "prot", "bm", "mp", "cpp", "tmp", "uf", "primary", "cm", "tc", "bf", "nc", "bc", "con", "pkg", "pc", "fab", "cb", "fb", "pm", "wb", "icc", "ib", "ob", "anc", "wp", "pg", "db", "dc", "summary", "PB", "uc", "pd", "api", "lb", "typ", "lc", "dl", "bh", "rb", "lp", "np", "ctx", "pa", "fc", "ppa", "bp", "cp", "p", "bps", "bb", "b", "lab", "metadata", "prop", "sb", "pl", "dp", "ab", "utils", "lf", "auc", "xb", "gb", "py", "platform", "abc", "ref"], "atom": ["app", "arch", "com", "xml", "ar", "amp", "cm", "tc", "param", "op", "obj", "bc", "ap", "pc", "orb", "att", " parent", "mat", "an", "m", "attr", "tm", " om", "mom", "om", "typ", "config", "num", "atomic", "tom", "ac", "spec", "am", "node", "bb", "ab", "oms", "abc", "asm", "xb", "sym", "at"], "st": ["storage", "ct", "ST", "step", "ft", "nd", "ust", "St", "sa", "ld", "rest", "ts", "pc", "ut", "cs", "fe", "nc", "l", "ste", "post", "ss", "se", "dc", "sp", "uc", "inst", "sf", "sn", "str", "sta", "Sc", "lc", "sec", "typ", "rc", "config", "sts", "spect", "est", "osc", "cur", "sd", "sh", "stage", "ast", "s", "set", "cl", "sw", "sk", "sl", "co", "ist", "src", "sb", "cr", "sr", "start", "stream", "td", "back", "ost", "sth", "std", "t", "stack"], "sc": ["enc", "oc", "exec", "cf", "icc", "si", "ec", "cc", "se", "ga", "sec", "sup", "spec", "asc", "cur", "sd", "sh", "scan", "scope", "isc", "src", "cr", "sb", "esc", "sync", "imp", "cont", "tc", "cs", "match", "pc", "scl", "ss", "sq", "inst", "lc", "cus", "osc", "SC", "sw", "ca", "sche", "soc", "com", "sa", "bc", "con", "access", "anc", "pg", "sem", "rc", "ch", "mc", "cer", "usc", "acc", "nc", "sci", "desc", "dc", "sp", "uc", "Sc", "capt", "config", "sub", "ctx", "fc", "ul", "cl", "inc", "loc", "cv"], "ret": ["en", "success", " Ret", "data", "reset", "nt", "resp", "bf", "match", "result", "ut", "rt", "desc", "att", "val", "alt", "gc", "job", "def", "res", " RET", "offset", "det", "reply", "valid", "al", "fun", "rc", "reg", "rb", "rets", "cur", "mt", "no", "ext", "status", "lit", "run", "rep", "arr", "re", "out", "RET", "red", "ner", "back", "value", "pass", "ref", "len", "Ret", "code"], "dref": ["pdrel", " dreference", "amdrel", "dference", "amdref", "bRef", "breference", "dreference", "pdror", " dference", "prol", "dre", "DRef", " dror", "sdreference", "sdre", "bdref", " drev", "pdRef", "pference", "amdrol", "Dref", "bdreference", "fdrec", "drel", "pdref", " drel", "brel", "amdreference", "drol", "bref", "bdrev", "sdrec", " dRef", "fdref", "Dror", "preference", " drol", "Dre", "pdreference", "Drev", "fdre", "Dreference", "fdreference", "Drec", "drev", "dRef", "prel", "Drel", "drec", "pdference", "pref", "dror", "pRef", "sdref"]}}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n", "idx": 13031, "substitutes": {"buffer": ["fp", "document", "iter", "data", "reader", "source", "command", "image", "result", "container", "interface", "fb", "timeout", "pad", "builder", "writer", "header", "border", "object", "uffer", "queue", "comment", "ptr", "url", "bridge", "buff", "cache", "context", "timer", "reference", "window", "Buffer", "b", "table", "port", "loader", "transfer", "buf"]}}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n", "idx": 13035, "substitutes": {"opaque": ["oppatile", "ipacity", "opac", "opercode", " opac", "opaques", " opque", " opaques", "ipaque", "hopac", "oppaques", "opque", "ipcode", " opacity", "operaque", "OPac", "OPque", "opcode", "opacity", "opatile", "operque", "hopacity", "ipaques", "hopque", "oppaque", " opatile", "oppacity", "operacity", "ipatile", "ipque", " opcode", "OPaque", "OPacity", "hopaque"], "chr": ["Chr", "CHrb", "ichrb", "echsr", "Chrb", "corr", "CHr", "chrb", "chrf", "CHra", "ichr", "cherb", "chra", "chers", "cher", "Chra", "corlr", "schlr", "chsr", "ichrs", "schsr", "echr", "schrf", "corrf", "echlr", "CHrs", "corsr", "chrs", "chlr", " chra", "chelr", "ichlr", "schr", "Chrs", "Chlr", "echrf", " chrs", " chrb"], "s": ["ps", "comments", "sync", "o", "session", "secondary", "e", "sa", "cs", "u", "ts", "ds", "sys", "si", "ss", "in", "ssl", "m", "new", "sq", "gs", "sf", "g", "self", "n", "os", "spec", "stats", "submit", "c", "http", "args", "sg", "p", "ns", "b", "f", "sie", "out", "ses", "w", "js", "r", "services", "sym", "S", "t", "ops"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_encode_init(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_uni_dc_tab();\n\n\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        \n\n        init_uni_mpeg4_rl_tab(&rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);\n\n        init_uni_mpeg4_rl_tab(&rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);\n\n\n\n        init_uni_h263_rl_tab(&rl_intra_aic, NULL, uni_h263_intra_aic_rl_len);\n\n        init_uni_h263_rl_tab(&rl_inter    , NULL, uni_h263_inter_rl_len);\n\n\n\n        init_mv_penalty_and_fcode(s);\n\n    }\n\n    s->me.mv_penalty= mv_penalty; //FIXME exact table for msmpeg4 & h263p\n\n    \n\n    s->intra_ac_vlc_length     =s->inter_ac_vlc_length     = uni_h263_inter_rl_len;\n\n    s->intra_ac_vlc_last_length=s->inter_ac_vlc_last_length= uni_h263_inter_rl_len + 128*64;\n\n    if(s->h263_aic){\n\n        s->intra_ac_vlc_length     = uni_h263_intra_aic_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_h263_intra_aic_rl_len + 128*64;\n\n    }\n\n    s->ac_esc_length= 7+1+6+8;\n\n\n\n    // use fcodes >1 only for mpeg4 & h263 & h263p FIXME\n\n    switch(s->codec_id){\n\n    case CODEC_ID_MPEG4:\n\n        s->fcode_tab= fcode_tab;\n\n        s->min_qcoeff= -2048;\n\n        s->max_qcoeff=  2047;\n\n        s->intra_ac_vlc_length     = uni_mpeg4_intra_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_mpeg4_intra_rl_len + 128*64;\n\n        s->inter_ac_vlc_length     = uni_mpeg4_inter_rl_len;\n\n        s->inter_ac_vlc_last_length= uni_mpeg4_inter_rl_len + 128*64;\n\n        s->luma_dc_vlc_length= uni_DCtab_lum_len;\n\n        s->chroma_dc_vlc_length= uni_DCtab_chrom_len;\n\n        s->ac_esc_length= 7+2+1+6+1+12+1;\n\n        s->y_dc_scale_table= ff_mpeg4_y_dc_scale_table;\n\n        s->c_dc_scale_table= ff_mpeg4_c_dc_scale_table;\n\n\n\n        if(s->flags & CODEC_FLAG_GLOBAL_HEADER){\n\n\n\n            s->avctx->extradata= av_malloc(1024);\n\n            init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n            \n\n            mpeg4_encode_visual_object_header(s);\n\n            mpeg4_encode_vol_header(s, 0, 0);\n\n\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n\n            flush_put_bits(&s->pb);\n\n            s->avctx->extradata_size= (put_bits_count(&s->pb)+7)>>3;\n\n        }\n\n        \n\n        break;\n\n    case CODEC_ID_H263P:\n\n        if(s->umvplus)\n\n            s->fcode_tab= umv_fcode_tab;\n\n        if(s->modified_quant){\n\n            s->min_qcoeff= -2047;\n\n            s->max_qcoeff=  2047;\n\n        }else{\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        break;\n\n        //Note for mpeg4 & h263 the dc-scale table will be set per frame as needed later \n\n    case CODEC_ID_FLV1:\n\n        if (s->h263_flv > 1) {\n\n            s->min_qcoeff= -1023;\n\n            s->max_qcoeff=  1023;\n\n        } else {\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n        break;\n\n    default: //nothing needed default table allready set in mpegvideo.c\n\n        s->min_qcoeff= -127;\n\n        s->max_qcoeff=  127;\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n    }\n\n}\n", "idx": 13040, "substitutes": {"s": ["ps", "comments", "fs", "d", "o", "session", "rs", "sim", "secondary", "cs", "e", "sa", "ts", "its", "l", "features", "server", "ds", "states", "sys", "si", "ions", "ss", "y", "ssl", "service", "m", "uns", "conf", "sq", "gs", "sf", "xs", "g", "es", "ks", "self", "sup", "n", "os", "spec", "stats", "is", "c", "args", "su", "sg", "i", "ns", "p", "qs", "b", "sets", "f", "sb", "ses", "js", "w", "settings", "request", "ls", "services", "sym", "S", "r", "t", "ops"]}}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n\n                              BdrvCheckMode fix)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);\n\n    int ret;\n\n    uint64_t refcount;\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->l1_size; i++) {\n\n        uint64_t l1_entry = s->l1_table[i];\n\n        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;\n\n        bool l2_dirty = false;\n\n\n\n        if (!l2_offset) {\n\n            continue;\n\n        }\n\n\n\n        ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,\n\n                                 &refcount);\n\n        if (ret < 0) {\n\n            /* don't print message nor increment check_errors */\n\n            continue;\n\n        }\n\n        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n            fprintf(stderr, \"%s OFLAG_COPIED L2 cluster: l1_index=%d \"\n\n                    \"l1_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                            \"ERROR\",\n\n                    i, l1_entry, refcount);\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                s->l1_table[i] = refcount == 1\n\n                               ? l1_entry |  QCOW_OFLAG_COPIED\n\n                               : l1_entry & ~QCOW_OFLAG_COPIED;\n\n                ret = qcow2_write_l1_entry(bs, i);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    goto fail;\n\n                }\n\n                res->corruptions_fixed++;\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n        }\n\n\n\n        ret = bdrv_pread(bs->file, l2_offset, l2_table,\n\n                         s->l2_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\",\n\n                    strerror(-ret));\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->l2_size; j++) {\n\n            uint64_t l2_entry = be64_to_cpu(l2_table[j]);\n\n            uint64_t data_offset = l2_entry & L2E_OFFSET_MASK;\n\n            QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n            if ((cluster_type == QCOW2_CLUSTER_NORMAL) ||\n\n                ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) {\n\n                ret = qcow2_get_refcount(bs,\n\n                                         data_offset >> s->cluster_bits,\n\n                                         &refcount);\n\n                if (ret < 0) {\n\n                    /* don't print message nor increment check_errors */\n\n                    continue;\n\n                }\n\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n\n                            \"l2_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                                    \"ERROR\",\n\n                            l2_entry, refcount);\n\n                    if (fix & BDRV_FIX_ERRORS) {\n\n                        l2_table[j] = cpu_to_be64(refcount == 1\n\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n\n                        l2_dirty = true;\n\n                        res->corruptions_fixed++;\n\n                    } else {\n\n                        res->corruptions++;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (l2_dirty) {\n\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n\n                                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n\n\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table,\n\n                              s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n\n                        strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_vfree(l2_table);\n\n    return ret;\n\n}\n", "idx": 13050, "substitutes": {"bs": ["ps", "fs", "sync", "us", "ins", "bl", "bas", "rs", "bing", "cs", "sa", "bc", "ts", "its", "outs", "base", "fb", "ds", "bes", "ss", "db", "ec", "bos", "BS", "gs", "lb", "obs", "bh", "ros", "ubs", "rb", "ks", "os", "iss", "ctx", "bi", "bits", "is", "vs", "bb", "ns", "qs", "bps", "b", "aws", "sb", "ab", "ses", "js", "gb", "banks", "ls", "lbs", "bis", "bid", "pb", "css"], "res": ["ps", "fs", "rs", "changes", "Res", "reset", "resp", "results", "ras", "cs", "result", "obj", "rh", "sys", "def", "val", "ss", "rows", "ress", "reply", " Res", "rr", "response", "rc", "resolution", "proc", "reg", "ros", "es", "pers", "self", "pre", "os", "details", "rev", "spec", "pres", "args", "ns", "p", "req", "scope", "qs", "RS", "mr", "vals", "report", "rep", "arr", "re", "des", "sr", "RES", "ms", "rez", "js", "err", "r", "gr", "rem", "conf", "rus", "css"], "fix": ["update", "prefix", "bug", "test", "append", "check", " prefix", "reset", "pull", " fixes", "patch", "apply", "mode", "op", "force", "result", "magic", "delay", "commit", "FIX", "def", "fixes", "Fix", "pad", "post", "valid", "xx", "comment", "config", "edit", "method", "ix", "hack", "add", "replace", "init", "cache", "correct", "cod", " Fix", " FIX", "tx", "call", "err", "conf", "next", "pack", "prev"], "s": ["ps", "hs", "sync", "sv", "session", "ins", "site", "cs", "sa", "e", "ts", "parts", "params", "ds", "states", "sys", "si", "ss", "y", "service", "ssl", "m", "conf", "state", "sq", "gs", "xs", "obs", "g", "es", "ks", "ubs", "n", "spec", "iss", "details", "stats", "is", "c", "su", "args", "p", "ns", "qs", "b", "sl", "sets", "f", "sie", "sb", "ses", "js", "utils", "settings", "ls", "sym", "services", "S", "bis", "ops"], "l2_table": ["l2_offset", "l2stable", "l4_entry", "l1_block", "l2sentry", "l4_size", "l2fblock", "l1_table", "l2_entry", "l2_size", "l2ftable", "l2foffset", "l2_block", "l4_offset", "l1_offset", "l4_table", "l2fentry", "l2ssize", "l1_entry", "l2soffset"], "ret": ["fail", "en", "gt", "ft", "success", "hash", "nt", "count", "match", "result", "pt", "obj", "feat", "end", "rt", "att", "rel", "val", "alt", "def", "db", "det", "reply", "html", "al", "fun", "rc", "error", "url", "reg", "num", "rets", "arg", "id", "rev", "mem", "mt", "no", "art", "hard", "ext", "status", "cat", "lit", "let", "rep", "re", "out", "RET", "flag", "err", "back", "bit", "pass", "ref", "conn", "len", "Ret", "code"], "refcount": ["Refsize", "relref", "referenceount", "bflimit", "arcsize", " refCount", "referencecount", "referencec", "relcount", "relsize", "refc", "arccount", "Refcount", "reflimit", " reflimit", "relcode", " refc", "refCount", "arcCount", "bfc", "bfcount", " refref", "refcode", " refount", "refref", "RefCount", "refsize", "arcref", "referencelimit", "relCount", "refount", " refsize", "relount", "referenceCount", " refcode", "Refcode", "referencesize"], "i": ["it", "anti", "d", "ie", "di", "gi", "ini", "iu", "mi", "fi", "t", "v", "multi", "li", "e", "u", "xi", "l", "pi", "uri", "si", "in", "y", "ai", "ui", "a", "ti", "k", "ix", "key", "n", "eni", "ik", "ci", "io", "id", "bi", "qi", "ip", "x", "c", "info", "ji", "ki", "p", "index", "ri", "b", "ni", "f", "start", "zi", "ind", "r", "ii", "ori", "I", "yi"], "j": ["adj", "d", "o", "dj", "jam", "J", "jp", "v", "li", "jl", "e", "pos", "obj", "pt", "l", "rel", "job", "y", "m", "jit", "aj", "num", "g", "k", "z", "key", "jj", "n", "ix", "fr", "c", "q", "ij", "x", "ji", "p", "index", "syn", "b", "f", "ind", "js", "err", "oj", "uj", "r", "ii", "ref", "t", "next", "ja", "jc"], "check_errors": ["fix_success", "check___errors", "check_success", " check_results", "check___issues", "fix_issues", "check__rors", "checkMrors", "checkMerrors", "check_rors", "checkMsuccess", "check__results", "fix_rors", "check__errors", "fix_errors", "checkMissues", "check__issues", "check_issues", "check___success", "check___rors", "check_results", " check_rors", " check_issues"], "corruptions_fixed": ["corruptions_fix", "corruption_failed", "corruptions_failed", "corruption_handled", "corruptions_handled", "corruption_fixed", "corruption_fix"], "corruptions": ["corruption", "corruptedion", "corritures", "corruptures", "morruptions", "corruptedions", "corrition", "morruptedion", "morruptures", "corritIONS", "morruptIONS", "morruption", "corritions", "morruptedions", "corruptIONS", "morruptedIONS", "corruptedures", "corruptedIONS", "morruptedures"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 13051, "substitutes": {"address_space_mem": ["address_space_mm", "address_space_cpu", "address_space_memory", "address_stack_ram", "address_space2mm", "address_pace_mem", "address_space67cpu", "address_space2ram", "address_space2memory", "address_service_model", "address_space_ram", "address_pace_ram", "address_service_lim", "address_service_ram", "address_stack_cpu", "address_pace_memory", "address_service_mem", "address_space_model", "address_space2model", "address_stack_mem", "address_space67mem", "address_stack_memory", "address_space2lim", "address_space67ram", "address_space67memory", "address_pace_mm", "address_space_lim", "address_space2mem"], "machine": ["storage", "session", "computer", "connection", "vm", "link", "param", "mode", "image", "process", "resource", "service", "m", "object", "state", "mo", "mom", "config", "host", "managed", "boot", "mem", "node", "cache", "memory", "slave", "mac", "cpu", "device", "Machine", "ram", "mount", "loader", "manager", "comp"], "model": ["module", "zero", "address", "data", "global", "cm", "mode", "base", "serial", "gment", "lu", "vision", "mod", "config", "man", "view", "class", "block", "de", "gu", "complete", "Model", "core", "type", "scope", "array", "code"], "arm_id": [" app_id", "armOids", " app_ids", "armOtype", " app_type", "armOid", "armOroot", "arm_ids", "arm_type", "arm_root", " app_root"], "mainstone_flash_base": ["mainstone_boot_bas", "mainstone_boot_area", "mainstone_flash_area", "mainstone_boot_base", "mainstone_flash_server", "mainstone_system_bas", "mainstone_system_Base", "mainstone_booterbase", "mainstone_flashalbas", "mainstone_system_base", "mainstone_flashalsupport", "mainstone_flash_support", "mainstone_booterbas", "mainstone_booterarea", "mainstone_boot_support", "mainstone_flash_bas", "mainstone_bootersupport", "mainstone_flashalarea", "mainstone_system_server", "mainstone_flashersupport", "mainstone_flasherbas", "mainstone_flasherbase", "mainstone_flash_Base", "mainstone_flasherarea", "mainstone_flashalbase"], "mpu": ["mmg", "mpi", "spu", "ppus", "ampo", " mpg", "ppiu", "mpa", "mmc", "mpg", "mpo", " mpa", "ppu", "spus", "ampi", "mpus", "ppcu", "spui", "mpui", " mpo", "mbus", "mpiu", "mpc", "mmu", "ppi", "ampa", "mbui", "mpcu", "mbu", "ampcu", "spiu", "ppo", "ampc", "ampu", " mpc", "ampg", " mpcu", "ppui", "mma", " mpi", "mbiu"], "mst_irq": ["mst_irqq", "mst_arch", "mst_rinp", "mst_mirce", "mst_arce", "mst_lrq", "mst_irce", "mst_mirp", "mst_irw", "mst_arp", "mst_lrqq", "mst_mirw", "mst_rinch", "mst_lrp", "mst_brw", "mst_mirqq", "mst_brqq", "mst_mirch", "mst_rince", "mst_arq", "mst_irch", "mst_irp", "mst_mirq", "mst_rinq", "mst_brq", "mst_lrw", "mst_brp"], "dinfo": ["binf", "kcheck", " dconfig", "ldInfo", "kInfo", "kinf", " dinf", "binfo", "dedinfo", "ddfi", "ddfo", "dedfi", "linf", "ddinfo", " dcheck", "dinf", "pinfo", "ddconfig", "dInfo", " dtype", "dfi", "ldfo", "ptype", " dfo", "dcheck", "dfo", "btype", "kinfo", "lcheck", "ldinfo", "lInfo", " dfi", "ldinf", "dedinf", "linfo", "pfi", "pinf", "dedfo", " dInfo", "dtype", "dedconfig", "dedInfo", "bfi", "dconfig"], "i": ["it", "adi", "ie", "d", "di", "uni", "gi", "chi", "ini", "iu", "mi", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "ai", "ui", "slice", "udi", "ti", "z", "n", "eni", "gu", "ci", "id", "mini", "bi", "init", "qi", "ip", "c", "x", "phi", "info", "hi", "ji", "p", "index", "ri", "type", "b", "cli", "ni", "zi", "j", "ori", "ii", "r", "I", "yi", "input"], "be": ["ble", " b", "debug", "ne", "oe", "ache", "trace", "le", "bl", "pe", "ve", " BE", "fore", "ore", "e", "fe", " e", "use", "bes", "ste", "ro", "see", "pose", "se", "Be", "he", "bee", "ignore", "ke", "ae", "are", "scale", " ne", "byte", "me", "de", "boot", "ce", " probe", "bi", " Be", "BE", "ze", "is", "ome", " je", "ine", "range", "we", "component", "b", "ere", "abe", "ape", "console", "te", "obe", "enable", "bis", "none", "ee", "eb"], "rom": ["ru", "rs", "com", "vm", "cm", "rome", "param", "aram", "mode", "sm", "camp", "cmd", "rum", "rob", "ro", "resource", "prom", "m", "gra", "prem", "iam", "ra", "dim", "lim", "irm", "ros", "roy", "rb", "region", "ream", "drm", "mem", "ray", "rm", "roma", "gram", "dem", "rock", "cp", "core", "cpu", "ROM", "coll", "ram", "REM", "cr", "mc", "mor", "rim", "roc", "r", "rg", "chrom", "ran", "rem", "arm", "pro", "norm"], "cpu_model": [" cpu_mode", "core_type", "cache_address", "gpu_size", "cpu_models", "cpu_view", "cpufimage", "gpu_mode", "core_image", " cpu_contract", "cpuromodels", "cpuermodel", "cache_location", " cpu_layout", "cpu_location", "cpu_channel", "gpu_model", "cpu_resource", "cpuercontract", "cpu_type", "cpuermode", "cpu_address", "cache_model", "cache_channel", "cpuromodel", "cpu_contract", "core_model", "cpuerlayout", "cpu_layout", " cpu_view", "gpu_models", "cpurotype", "cpufmodel", "cpuftype", "cpu_image", "cpufmodels", "cpuroimage", "cpu_mode", "cpu_size", " cpu_resource", "core_models"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,\n\n\t\t\tuint8_t *dst1, uint8_t *dst2,\n\n\t\t\tlong width, long height,\n\n\t\t\tlong srcStride1, long srcStride2,\n\n\t\t\tlong dstStride1, long dstStride2)\n\n{\n\n    long y,x,w,h;\n\n    w=width/2; h=height/2;\n\n#ifdef HAVE_MMX\n\n    asm volatile(\n\n\tPREFETCH\" %0\\n\\t\"\n\n\tPREFETCH\" %1\\n\\t\"\n\n\t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\");\n\n#endif\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s1=src1+srcStride1*(y>>1);\n\n\tuint8_t* d=dst1+dstStride1*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s1[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];\n\n    }\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s2=src2+srcStride2*(y>>1);\n\n\tuint8_t* d=dst2+dstStride2*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n", "idx": 13068, "substitutes": {"src1": [" srcFirst", "rcFirst", "supp2", "source1", "rc2", " srcOne", " src3", "rc1", "source2", "suppFirst", "srcFirst", "rcOne", "srcOne", "supp1", "src0", "source3", "sourceOne", "source0", " src0", "suppOne", "rc3", "rc0", "src3"], "src2": ["sb2", "rc4", "source1", "rc2", "source4", "src8", " srcB", "src4", "rc1", "source2", "sur20", "sur1", " src4", "srcB", "sb0", "rcB", "source8", "sb20", "sb1", " src8", "src20", "rc8", "src0", "sourceB", "source0", "rc20", " src0", "rc0", "sur2", "sur0"], "dst1": ["drest2", "dst001", "dstsOne", "Dsc001", "drc1", "dst3", "drest001", "drc001", "drest01", "adst1", "adsts2", "adstsOne", "drest1", "dsp1", "drc01", "dstOne", "dspOne", "dsc3", "adstOne", "Dst001", "Dst01", "Dst1", "dsts3", "dsc1", "Dst2", "adsts1", "Dsc01", "dsc001", "Dsc1", "adsts3", "drc2", "dsp2", "dscOne", "dsc2", "dst01", "adst2", "dsp3", "Dsc2", "dsts2", "dsc01", "adst3", "dsts1"], "dst2": ["dscTwo", "sst1", "sst62", "drcTwo", " dstTwo", "dst62", "drc1", "ddest2", "dsc0", "dst0", " dsp1", "ddest02", "ddest1", "sdest2", "dsp1", "sdest1", "dstTwo", "sdest02", "dsp0", "dste1", "dste2", "sst02", " dsp2", "dsc1", "dste62", " dsp0", "drc2", "sst2", "dsp2", "sdest62", "dsc02", "ddest62", "dsc2", "drc0", " dst0", " dspTwo", "dspTwo", "dsc62", "dst02", "dste02"], "height": ["ty", "gravity", "image", "direction", "head", "length", "size", "hd", "ht", "style", "depth", "Height", "shape", "pad", "padding", "dim", "hold", "resolution", "density", "sh", "window", "crop", "layout", "ph", "thin", "th", "angle", "build", "inches", "img", "wa"], "srcStride1": ["srcStride01", "srcStide0", "srcStrip1", "srcStrite2", "srcStide3", "srcstride01", "srcStrite1", "srcstideOne", "srcStrite3", "srcStrueOne", "srcScrite1", "srcStrue3", "srcStriteOne", "srcScride2", "srcStri01", "srcStrip0", "srcStrue2", "srcScride1", "srcStide2", "srcScrideOne", "srcstide2", "srcstide0", "srcStrub11", "srcStrub2", "srcStideOne", "srcStrip01", "srcScrite2", "srcScriteOne", "srcStri0", "srcStri1", "srcstride0", "srcStrue1", "srcstide3", "srcStrip2", "srcStide01", "srcStrite11", "srcstide1", "srcstride1", "srcstride2", "srcStrue11", "srcStri2", "srcstide01", "srcStrubOne", "srcScrite11", "srcStide1", "srcStrub1", "srcStride0", "srcstrideOne", "srcScride11", "srcStrideOne", "srcStride11", "srcStride3", "srcstride3"], "srcStride2": ["srcStride8", "srcStrite2", "srcStide3", "srcShide3", "srcStrip1", "srcStrite1", "srcStrb2", "srcStrite3", "srcScride4", "srcStride4", "srcScrite1", "srcScrite4", "srcStrue3", "srcSterve8", "srcScride2", "srcStrue2", "srcStrite8", "srcStide4", "srcStide2", "srcShide1", "srcSterve4", "srcScrite0", "srcStrb4", "srcStrb0", "srcScride1", "srcStide8", "srcShide4", "srcScrite2", "srcStrue1", "srcStrip2", "srcStrue4", "srcStrb1", "srcStrip0", "srcShide2", "srcShride2", "srcSterve2", "srcShride4", "srcStide1", "srcStrip4", "srcStride0", "srcScride0", "srcShride1", "srcStrite4", "srcStrite0", "srcShride3", "srcStride3", "srcSterve1"], "dstStride1": ["dstStriteX", "dstScrite4", "dstStro4", "dstStro01", "dstStride4", "dstStrip1", "dstScrideX", "dstStride8", "dstScride1", "dstStrideX", "dstStride3", "dstStrite1", "dstScrite01", "dstStgradeX", "dstStrip8", "dstStro2", "dstStgrade1", "dstStgrade01", "dstStgrade4", "dstStrite01", "dstStrite3", "dstScride4", "dstScrite1", "dstScriteX", "dstStro3", "dstStroX", "dstStrite2", "dstStride01", "dstStrip3", "dstStrite8", "dstStrite4", "dstStrip2", "dstScride01", "dstStro1", "dstStro8"], "dstStride2": ["dstStride52", "dstStrTwo", "dststr4", "dstStriteTwo", "dstStrid4", "dststride2", "dstStride4", "dstStridTwo", "dstStrid2", "dstStrid52", "dstRestride\n", "dststride52", "dststr52", "dststride4", "dstStrite52", "dststrTwo", "dstStride\n", "dststr2", "dstSterve\n", "dstStr2", "dstStgrade\n", "dstResterve\n", "dstStrite2", "dstStrideTwo", "dstStrite4", "dststrideTwo", "dstStr52", "dstStrip\n", "dstStr4"], "y": ["ya", "o", "ay", "ty", "ky", "yn", "yo", "v", "ys", "ry", "e", "yt", "yr", "year", "iy", "u", "l", "ny", "lon", "wy", "m", "by", "zy", "xy", "ady", "ym", "vy", "uy", "a", "z", "key", "n", "yd", "io", "id", "ey", "c", "i", "p", "type", "b", "cy", "hy", "f", "name", "Y", "yy", "dy", "ye", "oy", "sy", "py", "j", "t", "sky", "yi", "gy", "yl"], "x": ["ct", "my", "pe", "X", "v", "e", "u", "pos", "xi", "code", "image", "l", "work", "xes", "yx", "full", "lex", "m", "dx", "xy", "ady", "q", "xx", "xp", "xs", "php", "time", "host", "g", "wx", "z", "px", "ix", "key", "n", "cross", "event", "id", "win", "ww", "i", "c", "rx", "s", "p", "index", "ax", "ex", "b", "sw", "on", "sex", "fx", "tx", "f", "name", "wait", "view", "r", "xc", "j", "any", "xt", "t", "wa"], "w": ["wall", "wh", "ew", "tw", "v", "e", "l", "wd", "wb", "iw", "wy", "wp", "ow", "m", "W", "hw", "aw", "g", "wx", "z", "n", "win", "ww", "c", "weight", "wt", "i", "p", "s", "we", "window", "sw", "b", "r", "wn", "max", "fw", "t", "wa"], "h": ["hs", "en", "high", "v", "uh", "rh", "l", "ht", "hm", "m", "W", "gh", "g", "z", "k", "n", "ch", "sh", "H", "c", "hi", "i", "s", "p", "q", "ph", "ww", "b", "f", "th", "j", "t", "wa"], "s1": [" sX", "ds1", "sOne", "ns1", "ses1", "s91", "ps8", "nsOne", "dsone", "ps1", "ps2", " s5", "sa91", "cs2", "sesX", "saone", "ses5", "ns91", "csX", "cs1", "dsOne", "nsone", "ses8", "sesone", "ds91", "sX", "sa1", " s8", "psone", "cs5", "s5", "saOne", " sone", "ses2", "s8", "sone"], "d": ["done", "bd", "di", "o", "ct", "dt", "dr", "dos", "data", "md", "v", "du", "ld", "e", "del", "cd", "l", "dat", "ds", "did", "db", "dc", "m", "fd", "dim", "dl", "ded", "g", "z", "n", "id", "dh", "sd", "c", "q", "i", "s", "p", "dd", "b", "f", "D", "dy", "r", "j", "t", "da", "ad"], "s2": ["p8", "p92", " s8", "sync8", "sync92", "sync1", " s92", "sync2", "s92", "p2", "p1", "s8"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 13077, "substitutes": {"machine": ["module", "part", "computer", "address", "environment", "app", "vm", "data", "sim", "mode", "project", "image", "process", "message", "base", "model", "server", "space", "object", "m", "service", "state", "mom", "comment", "parse", "host", "config", "proc", "linux", "class", "boot", "node", "cache", "slave", "mac", "hard", "instance", "Machine", "controller", "template", "loader", "game", "agent", "rule", "manager", "database"], "cpu_model": [" cpu_mode", "cpuidmode", "kerneljmanager", "cpuamsize", "cpu_models", "kerneljmode", " cpu_size", "cpu_base", "gpu_resource", "gpu_mode", " cpu_models", "cpuidimage", "gpu_layout", "kerneljservice", "gpu_loader", "cpulexresource", "cpujservice", "cpu_server", "cpuleximage", "cpu_manager", "cpujmodel", "core_server", "cpulexmode", "cpuamserver", "kernel_service", "gpu_model", "cpu_resource", "cpuidresource", "gpu_image", "kernel_model", "core_base", "cpulexmodel", "cpuambase", "cpujmode", "core_model", "kernel_manager", "cpuammodel", "cpu_layout", "cpu_loader", "cpuidmodel", "cpu_image", "kernel_mode", "cpu_service", "core_size", "cpu_mode", "cpu_size", "cpujmanager", "kerneljmodel"], "kernel_filename": ["kernel2label", "kernel_label", "kernel1filename", "ernel_title", "kernel2size", " kernelpfilename", " kernelpsize", "kernelpfile", "kernelblockfunction", "erneldblabel", "kernel2filename", " kernelpfile", "nn_function", " kernelplabel", "kernelblockfile", "kernelFtitle", "kerneldbfilename", "kernelblockfilename", "kernelpfilename", "kernel1title", "ernel_download", "nn_file", "kernelFdownload", "kerneldbdownload", "kernel_file", "nn_size", "kerneldbtitle", " kernel_label", "kernelFlabel", "erneldbtitle", "kerneldblabel", "erneldbdownload", "kernel_title", "kernel2file", "kernelblocksize", " kernel_size", "kernel_size", "erneldbfilename", " kernel_file", "ernel_filename", "kernel1label", "kernelpsize", "ernel_label", "kernel_download", "kernel_function", "kernel1download", "nn_filename", "kernelFfilename", "kernelplabel"], "initrd_filename": ["initrt_file", "initrd___fn", "initrs_Filename", "initrt_module", "initrd_Filename", "initr_Filename", "initr_maximum", "initrd_maximum", "initrs_file", "initrd_module", "initrs_filename", "initr_filename", "initrd___filename", "initrs_name", "initr_fn", "initrd_fn", "initrt_filename", "initrd_selection", "initrd___maximum", "initrt_selection", "initrd___Filename", "initrd_name", "initrd_file"], "env": ["estate", "enc", "en", "engine", "environment", "ev", "pe", "exec", "edge", "exc", "vm", "v", "global", "e", "network", "cfg", "skin", "oa", "size", "work", "eye", "style", "end", "qt", "path", "eng", "ec", "db", "conf", "queue", "attr", "state", "gui", "doc", "config", "ea", "eu", "net", "exe", "eni", "cv", "np", "her", "osc", " environment", "ctx", "cache", "context", "ah", "shell", "args", "viron", "egg", "ext", "core", "scope", "here", "energy", "loader", "que", "console", "err", "agent", "equ", "conn", "img", "Environment", "code"], "cpu": ["fp", "uno", "performance", "computer", "environment", "uca", "GPU", "cn", "vm", "currency", "po", "CPU", "nc", "process", "pc", "gpu", "processor", "bench", "gc", "cow", "lb", "prem", "hw", "lc", "config", "pu", "proc", "linux", "px", "kernel", "net", "eni", " CPU", "np", "boot", "ctx", "node", "cp", "core", "gnu", "nu", "ni", "instance", "python", "roc", "loader", "console", "clock", "conn", "css"]}}
{"project": "FFmpeg", "commit_id": "caa845851d790f894a2ccbe12580934f75545f92", "target": 0, "func": "static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n\n                                uint8_t *data, unsigned int *data_size, int is32)\n\n{\n\n    SubStream *s = &m->substream[substr];\n\n    unsigned int i, out_ch = 0;\n\n    int32_t *data_32 = (int32_t*) data;\n\n    int16_t *data_16 = (int16_t*) data;\n\n\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n\n        return -1;\n\n\n\n    for (i = 0; i < s->blockpos; i++) {\n\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n\n            int mat_ch = s->ch_assign[out_ch];\n\n            int32_t sample = m->sample_buffer[i][mat_ch]\n\n                          << s->output_shift[mat_ch];\n\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n\n            if (is32) *data_32++ = sample << 8;\n\n            else      *data_16++ = sample >> 8;\n\n        }\n\n    }\n\n\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n\n\n    return 0;\n\n}\n", "idx": 13081, "substitutes": {"m": ["fm", "module", "mm", "d", "o", "mp", "sim", "im", "md", "cm", "mos", "gm", "e", "u", "v", "sm", "mu", "media", "pm", "l", "y", "wm", "hm", "machine", "tm", "mn", "this", "mod", "M", "em", "ym", "g", "man", "n", "mt", "c", "mac", "p", "b", "mr", "f", "dm", "mc", "manager", "ms", "t", "bm"], "substr": ["ubr", "thchar", "subStr", "substring", "ubStr", "Subr", " substring", "ubstr", " substrings", "ubstring", "subr", "subchar", "SubStr", " subStr", " subchar", "Substring", "substrings", " subr", "constr", "thstrings", "Substr", "conchar", "constring", "thstr", "thstring", "constrings"], "data": ["body", "d", "batch", "di", "shift", "draw", "multi", "results", "source", "image", "result", "mu", "base", "size", "dat", "open", "output", "slice", "frame", "a", "scale", "da", "block", "cache", "change", "input", "memory", "window", "p", "missing", "Data", "index", "one", "start", "DATA", "sample", "buffer", "value", "alpha", "none", "array", "code"], "data_size": ["sample_size", "data_depth", "sample_scale", "data_time", " data_time", "sample_speed", " data_speed", "data_scale", "data_speed", " data_depth", " data_scale"], "is32": ["iss64", "mis31", "bis33", " is33", "mis64", "isi64", "lis32", "iss33", "Is34", "bis32", "Is32", "Is16", "is64", "Is128", "lis64", "is16", "is128", "isa32", " is72", "IS32", "iss32", "mis34", "lis33", "bis31", "is72", " is64", " is128", "IS128", "isi32", " is31", "isi31", "isa33", "iss72", "isi34", "is31", "bis16", "mis32", "lis72", "isa31", "is34", "is33", " is16", "IS16", "isa16", "Is64", "Is31"], "s": ["ps", "hs", "sync", "fs", "d", "client", "o", "session", "ins", "site", "rs", "sim", "v", "e", "sa", "cs", "sm", "u", "ts", "l", "ds", "si", "ss", "space", "y", "ssl", "hm", "service", "ims", "sq", "gs", "sf", "xs", "g", "es", "n", "comm", "os", "spec", "is", "c", "su", "sg", "p", "ns", "qs", "b", "sl", "f", "sb", "ses", "w", "js", "ms", "r", "services", "ls", "S", "t", "rates"], "i": ["it", "d", "ie", "di", "gi", "chi", "ini", "iu", "mi", "fi", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "ei", "uri", "si", "y", "ai", "ui", "ti", "ix", "k", "n", "eni", "ch", "ci", "id", "io", "mini", "bi", "qi", "phi", "c", "ip", "h", "x", "oi", "info", "p", "index", "ri", "b", "ni", "f", "start", "zi", "j", "ii", "I", "yi"], "data_32": [" data_8", "data_62", "data___16", "data___62", "data_64", " data_64", " data_62", "data___32", "data_8", "data___8"], "data_16": [" data_8", " data_18", "data_64", "data_18", "data_36", " data_64", "data_8", " data_36"], "out_ch": ["outxchi", "win_ch", "out_ach", "outJcher", "out_coll", "out_chy", "outJchar", "out_conn", " out_chan", "outJach", "outLCh", " outRCH", "win_coll", "mat_chan", " outRch", "data_chy", "data_Ch", "outJCH", "data_cha", " out_cher", "mat_ch", " out_char", "mat_chi", "mat_zh", "out_Ch", "at_size", "out_CH", "out_char", " outRconn", "outJconn", "out_cher", "outLcha", "outxch", "win_ach", "out_cha", " outRcher", "out_zh", "outCzh", "outxzh", "outCch", " out_conn", "out_size", "at_char", "outRch", "at_chan", "outJch", "data_ch", "outxchan", "out_chi", "outRconn", "outRcher", "outCchi", "outLch", "outLchy", "out_chan", "win_char", "outJcoll", " out_CH", "outCchan", "at_ch", "outRCH"]}}
{"project": "qemu", "commit_id": "2ebafc854d109ff09b66fb4dd62c2c53fc29754a", "target": 1, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13097, "substitutes": {"bs": ["ps", "fs", "sync", "bm", "ins", "bl", "bas", "rs", "bn", "bing", "cs", "sa", "bc", "obj", "ras", "boxes", "its", "outs", "base", "fb", "abi", "ds", "cb", "bes", "blocks", "blog", "ss", "db", "bos", "bt", "BS", "gs", "lb", "plugins", "obs", "bh", "ros", "ubs", "org", "iss", "bi", "bits", "vs", "bytes", "ns", "bb", "bps", "qs", "b", "aws", "vals", "sb", "ab", "ses", "js", "utils", "gb", "las", "abc", "ls", "lbs", "bis", "cms", "pb", "css"], "start_offset": ["start__offset", "start_start", "begin_start", "start67position", "start___align", "start_size", "start00area", "start_align", "start67slot", "begin_offset", "start_index", "begin_size", " start_size", "start67offset", "start___size", "start67size", "begin___align", "start__position", "start_position", "start__size", "start_area", " start_area", "begin___start", "start00offset", "start__slot", "begin___size", "end_slot", "begin_align", "start00index", "end_size", "start_slot", "start00size", "begin___offset", " start_index", "end_position", "start___start", "start___offset"], "end_offset": ["start_start", "end_Offset", "end_area", "stop00format", "start_size", "end00offset", "end00format", "start_off", "stop_Offset", "end_start", "start_end", "end_format", "end_addr", "end_off", "start_area", "stop_offset", "stop00offset", "end_end", "end00Offset", "stop00Offset", "end_size", "start_addr", "stop_format"], "p_feature_table": ["p_features_table", "p_feature_file", "p_\n", "p_featurelogfile", "p_featurelogtable", "p_features_details", "p_feature_details", "p_featureingdetails", "p_features_file", "p_featurelogdetails", "p_feature_list", "p_features_list", "P_\n", "p_featureingfile", "p_str", "p_featureloglist", "P_str", "p_featureinglist", "p_featureingtable"], "errp": [" erpre", "Erpre", "errpc", "erjp", "derp", "ierr", " errr", " erp", "Err", "acerp", "errb", "errpoint", " erpatch", "errr", "errjp", "ErP", "dert", "iterp", "errorb", "nerpc", "errpatch", " errt", "errorr", "nerb", "nerP", "ierp", "iterb", " errpc", "errfp", "erpre", "ierP", "errorP", "errorpc", " errP", "errpre", "derpc", "Erpoint", "Erpatch", "acerpc", "erP", "acerP", "iterpc", "erfp", "ierpoint", " erfp", "errorp", "errP", "derP", "errt", " errjp", "err", "erp", "acert", "Erfp", "iterP", "nerp", "erpoint", "Erp", "erpatch", "errorjp"], "s": ["ps", "storage", "fs", "sv", "rs", "cs", "sa", "e", "ts", "ds", "states", "sys", "si", "ss", "ssl", "state", "sq", "gs", "sf", "xs", "os", "spec", "stats", "is", "c", "ns", "p", "qs", "b", "sl", "sb", "ses", "js", "settings", "stat", "ls", "S", "t", "ops"], "ext": ["fp", "append", "test", " orig", "ord", "exec", " extended", "Ext", "obj", "cf", " parent", "cb", "later", "ec", "ef", "tf", "sec", "seq", "ix", "init", " instr", "lib", "req", "EXT", "fx", "ind", "inter", "diff", "abc", "temp", "txt", "e", " aux", "eng", "str", "lc", "vert", "word", "org", "x", "off", "aux", "ft", " intr", "external", "feat", "zip", "fit", "xp", "fr", "ch", " EXT", "art", " extent", "ex", "text", "code", "cut", "app", "dist", "br", " aug", "desc", " fmt", "def", "full", "config", "z", " extend", " ep", "extra", "info", "p", "f", "section", "xt", "eff", "next", "img", " cont"], "offset": ["fp", "address", "append", "hop", "reset", "pos", "offer", "output", "online", "ui", "limit", "api", "seq", "location", "stop", "addr", "set", "start", "adjusted", "entry", "alt", "len", "prefix", "part", "o", "optional", "afi", "position", "nt", "format", "abi", "timeout", "slice", "error", "num", "id", "off", "scroll", "outer", "Offset", "null", "et", "af", "initial", "attribute", "count", "end", "size", "exclusive", "padding", "origin", "operation", "pointer", "type", "order", "adjust", "ref", "bound", "fee", "ut", "length", "base", "align", "alias", "slot", "ptr", "url", "skip", "layout", "index", "f", "absolute", "section", "loc", "next"], "ret": ["part", "et", "en", "gt", "ft", "af", " Ret", "success", "nt", "bf", "pat", "count", "match", "result", "obj", "rt", "desc", "att", "val", "alt", "job", "def", "res", " RET", "det", "reply", "str", "fun", "url", "num", "reg", "usr", "key", "rets", "arg", "id", "opt", "rev", "mem", "mt", "no", "art", "info", "cat", "lit", "let", "arr", "f", "re", "out", "RET", "flag", "back", "bit", "ref", "conn", "len", "Ret"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n\n\n    src1 += c->chrSrcOffset;\n\n    src2 += c->chrSrcOffset;\n\n\n\n    if (c->chrToYV12) {\n\n        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst, dstWidth);\n\n}\n", "idx": 13100, "substitutes": {"c": ["enc", "d", "ct", "cpp", "cu", "oc", "cn", "com", "v", "cm", "tc", "sc", "cs", "con", "e", "u", "C", "nc", "cf", "cit", "l", "pc", "bc", "ec", "cc", "dc", "m", "conf", "cmp", "this", "uc", "lc", "config", "rc", "g", "self", "ac", "n", "vc", "ci", "ce", "ch", "ctx", "cur", "cache", "context", "h", "cp", "s", "p", "core", "cl", "b", "cy", "co", "ctrl", "f", "cr", "ca", "mc", "call", "r", "xc", "t", "cv"], "dst": ["Dsrc", "adST", "gdST", "mdrest", "dsts", "madsta", "ddst", "ddstr", "ddsts", "dstr", "madstr", "Dst", "dsrc", " dstr", "gdst", "idST", " drc", "mdsth", "sdsts", " dsta", "Dsts", "gdsth", "mdsts", " dST", "DST", "idrest", "idst", "drest", "adst", "mdst", "adsth", " dsth", "idsth", "sdst", " dsrc", "adrc", "sdsth", "gdrc", "drc", " drest", "dsth", "ddsta", "sdST", "dST", "adsts", "dsta", "idsrc", "idsts", "madst", " dsts", "madsts"], "dstWidth": [" dscWidth", "drcwidth", "dstW", "DstWidth", "DstHeight", "dstsWidth", "dStWidth", "DSTwidth", "drcWill", "dscWidth", " dstHeight", " dSTHeight", " drcWill", "dscwidth", "dstwidth", "drcHeight", "drcW", "dscHeight", "dSTWill", "dSTHeight", "ddestwidth", "ddestHeight", " drcWidth", " drcwidth", "dSTwidth", "dStW", " dstwidth", "ddestWill", "DSTW", "DstW", "dStwidth", "destwidth", "DSTWidth", " dstswidth", " dstsWidth", "drcWidth", " dscwidth", " dSTwidth", "destWidth", " drcHeight", "dStHeight", "dSTW", " dstWill", "dstswidth", "DSTHeight", " dstsHeight", "Dstwidth", "dstWill", " dSTWidth", "dSTWidth", " dscHeight", "destHeight", "ddestWidth", "dstHeight", "dstsHeight"], "src1": [" srcFirst", "imgOne", " srcN", "imgFirst", "source1", "rc2", " srcOne", "uc1", "struct2", "uc2", " src01", " src3", "rc1", "ucOne", "source2", "const2", "srcone", "attr01", "img01", "structN", "rcN", "srcFirst", "rc01", "rcOne", "srcOne", "rcone", "src0", "source3", "srcN", "source0", "sourceOne", "source01", "img1", " src0", "const1", "const01", " srcone", "src01", "attrFirst", "const0", "ucW", "attrOne", "rc3", "rcW", "rc0", "structone", "src3", "attr1", "struct1"], "src2": ["rc4", "source1", "rc2", "sc02", " src02", "source4", " srcB", "rc1", "reflectTwo", "src4", "dest2", "sc2", "source2", " src4", "src02", "dist002", "reflect02", "dest1", "srcB", "loc0", "destTwo", "rcB", "distTwo", "dist02", "loc2", "st2", "src0", "dist2", "st1", " src002", " src0", "rc02", "reflect2", "dest4", "sc1", "src002", "reflect002", " srcTwo", "loc4", "st02", "scTwo", "srcTwo", "rcTwo", "rc0", "loc1", "stB"], "srcW": [" srcN", "locW", " srcw", "rc2", "instN", "srcL", "locN", "rc1", "source2", " srcL", "locCW", "rcN", "inst2", "rcL", "imgW", "sourceN", "imgw", "loc2", "img2", "srcN", "instL", "srcw", "sourcew", "sourceW", "instW", "imgCW", "instw", "inst1", "rcw", "rcW", "srcCW", " srcCW", "locw"], "xInc": ["wIncrease", "txINC", "wINC", "Xinc", "dxInc", "yxIncre", "dxExec", "nexinc", "XIncre", "txExec", "XInc", "txInc", "nexIncrease", "XEnc", "xinc", "XINC", " xSec", "xExc", "aIncrease", "nexInc", "sexINC", "dxIncre", "sexInc", "yxExec", " xinc", "xIncrease", "xExec", "xxIncre", "txIncre", "nexINC", "xIncre", "ySec", "xINC", "winc", "xEnc", " xEnc", "yinc", "wInc", "xxInc", "XExc", "xxINC", "xSec", "yEnc", "ainc", "xxExc", "sexIncre", "yxInc", "yxINC", "XSec", "aInc", "sexExc", "aINC", "dxINC", "yInc"], "hChrFilter": ["hQurlFactor", "hChlFormat", "hChrlFormat", "hChrbFilter", "hChrsFl", "hChrsLimit", "hChoFilter", "hchlFactor", "hchrLimit", "hQrFi", "hQurFilter", "hQurFactor", "hChlFactor", "hChrlFl", "hQrbFilter", "hQurlFl", "hQrFl", "hChlLimit", "hChrLimit", "hchrFilter", "hCharHandler", "hChrbFl", "hChrFormat", "hQurFl", "hChlrFilter", "hchrHandler", "hChlFl", "hChlrFi", "hchlHandler", "hChoFormat", "hChrFactor", "hChrFl", "hQrFilter", "hChlHandler", "hChrsHandler", "hChrbFormat", "hChoFl", "hChrHandler", "hQurlFilter", "hChrlFilter", "hCharFilter", "hCharFactor", "hQrbFormat", "hQurFormat", "hQurlFormat", "hChoFi", "hQrbFl", "hChrFi", "hChlrFormat", "hchlFilter", "hchrFactor", "hChrsFilter", "hChlrFl", "hChrsFactor", "hCharLimit", "hQrbFi", "hChrlFactor", "hQrFormat", "hchlLimit", "hChrsFormat", "hChlFilter", "hChrbFi"], "hChrFilterPos": ["hChrFilterMin", "hChrFormatTop", "hChrcLimitPos", "hChrBufferPos", "hChrBufferLen", "hChrListenerPos", "hChuFilterMin", "hChrcFilterSlot", "hChrFilterpos", "hChrtFilterpos", "hChrtRulePos", "hChrcFilterPos", "hChrLayerMin", "hChrFilterSlot", "hChrLayerPos", "hChrtFilterTop", "hChrBufferOffset", "hChrFactorOffset", "hChuFactorPos", "hChuFilterOffset", "hChrLimitPos", "hChrtRuleTop", "hChrLayerLen", "hChrFilterOffset", "hChrLimitpos", "hChrRuleTop", "hChrFactorMin", "hChuFilterPos", "hChrcLimitpos", "hChrtRuleMin", "hChrcFilterLen", "hChrBufferMin", "hChrcLimitLen", "hChrListenerSlot", "hChrMaskpos", "hChrtFilterMin", "hChrLimitSlot", "hChrcLimitSlot", "hChrcFilterpos", "hChrFactorLen", "hChrRuleSlot", "hChrFilterTop", "hChrtFilterPos", "hChrListenerpos", "hChrMaskPos", "hChuFilterLen", "hChrLimitLen", "hChuFactorMin", "hChuFactorLen", "hChrFilterLen", "hChrListenerLen", "hChrRulePos", "hChrRuleLen", "hChrFormatpos", "hChrFactorPos", "hChrFormatMin", "hChrMaskMin", "hChrtRulepos", "hChrMaskTop", "hChrFormatPos", "hChrRuleMin", "hChrRulepos", "hChuFactorOffset", "hChrLayerOffset"], "hChrFilterSize": ["hChrLimitSize", "hChrlFactorSource", "hChrLimitStyle", "hChrFileLen", "hChrFactorSize", "hChrUserSize", "hChrFilter2", "hChrBufferInfo", "hChrlFilter2", "hChrFilterConf", "hChrFilterStyle", "hChrBufferStyle", "hChrRefConf", "hChrBufferLen", "hCherFilterStyle", "hChrtLimitSize", "hChrtLimitInfo", "hCherFilterLen", "hCherFilterSize", "hChrChannel2", "hChrRefStyle", "hChrlFilterSource", "hChrRefSize", "hChrBufferOffset", "hChrtFilterStyle", "hChrFactorOffset", "hChrFileStyle", "hChrRefLen", "hChrLimitOffset", "hChrtLimitOffset", "hChrUser2", "hCherFilterConf", "hChrFilterOffset", "hChrlFactorNumber", "hCherBufferSize", "hChrFileConf", "hChrBufferSize", "hCherBufferStyle", "hChrtFilterOffset", "hChrFilterSource", "hChrLimitInfo", "hChrUserNumber", "hChrChannelNumber", "hChrFactorSource", "hChrFactorInfo", "hChrChannelSize", "hChrtFilterInfo", "hChrUserSource", "hChrBufferConf", "hChrFilterNumber", "hChrtFilterSize", "hChrlFilterSize", "hCherBufferConf", "hChrFilterLen", "hChrtLimitStyle", "hChrlFactorSize", "hCherBufferLen", "hChrFactor2", "hChrChannelSource", "hChrFactorNumber", "hChrFilterInfo", "hChrFileSize", "hChrlFilterNumber", "hChrFactorStyle", "hChrlFactor2"], "formatConvBuffer": ["formatEnvBegin", "formatRefFile", "formatEnvEnd", "formatConviBuffer", "formatAnvBuffer", "formatConfBuffer", "formatConcFile", "formatRefBuff", "formatConvibuffer", "formatConfBuff", "formatEnVBegin", "formatRefBuffer", "formatConverFile", "formatConVBuffer", "formatConvLimit", "formatConviFile", "formatConcbuffer", "formatAnfBuff", "formatConVBegin", "formatConvbuffer", "formatEnVEnd", "formatEnvBuffer", "formatConvtBuffer", "formatConvtBegin", "formatConfBegin", "formatRevFile", "formatConvEnd", "formatAnvBuff", "formatConfFile", "formatConviBuff", "formatRevbuffer", "formatAncBuff", "formatEnVBuff", "formatAncbuffer", "formatConVFile", "formatConVEnd", "formatConvBegin", "formatEnVFile", "formatConcBuffer", "formatAncFile", "formatConfFormat", "formatConverBuff", "formatAnvBegin", "formatRefbuffer", "formatConvcBuffer", "formatEnvBuff", "formatConvcLimit", "formatAnvFile", "formatConvcBegin", "formatConvFile", "formatConVbuffer", "formatAnvbuffer", "formatAnvLimit", "formatRevBuff", "formatConcBuff", "formatConvtBuff", "formatEnvFormat", "formatAnfLimit", "formatEnVFormat", "formatConvFormat", "formatConvtFormat", "formatConvBuff", "formatConverbuffer", "formatEnvFile", "formatConvtEnd", "formatAnfBegin", "formatRevBuffer", "formatConvtFile", "formatConfbuffer", "formatConfEnd", "formatAnfBuffer", "formatConverBuffer", "formatConVFormat", "formatConfLimit", "formatConVBuff", "formatEnVBuffer", "formatAncBuffer", "formatConvcBuff", "formatConVLimit"], "pal": ["ascal", "phil", "abl", "app", "nav", "Pal", "real", "ar", "opal", "paren", "stal", "local", "raf", "sal", "area", "rel", "align", "val", "fal", "pad", "alias", "pixel", "padding", "gal", "al", "scale", " Pal", "par", "gam", "pol", "color", "cal", "pl", "isal", "alpha", "fac", "chal", "conf", "pel"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 13114, "substitutes": {"base": ["prefix", "fs", "et", "zero", "address", "file", "ases", "bas", "proxy", "source", "e", "u", "l", "area", "server", "size", "bin", "resource", "total", "y", "root", "m", "padding", "state", "offset", "frame", "ite", "a", "origin", "ase", "scale", "byte", "ada", "ix", "channel", "parent", "n", "os", "id", "bi", "cache", "x", "c", "i", "http", "ode", "core", "type", "p", "b", "scope", "index", "f", "start", "name", "as", "ca", "buffer", "Base", "gb", "bit", "ace", "native", "code"], "irq": ["irtc", "ircqs", "iperp", "mirc", "mirq", "ircp", "iperqa", "earqi", "ircqi", "irqs", "earq", "irqu", "iperqs", "irtq", "irc", "yrf", "irtx", "earqu", "irep", "irp", "iraq", "mirx", "yrq", "iraqi", "irx", "ircq", "ireqa", "yrc", "yrx", "iraqs", "iraqu", "earqs", "irf", "ircqu", "mirf", "irtf", "irqa", "iperq", "ireq", "ireqs", "ircqa", "irqi"], "chr": ["chnr", "CHro", "Chr", "CHran", "corc", "Chsr", "CHrb", "chro", "thr", "echrs", "corrt", "chc", "chnrn", "chran", "corr", "CHr", "chrf", "chrb", "chnar", "schc", "CHrt", "thrf", "chanr", "chnrar", "CHsr", "Chrn", "thrs", "chsr", "chrn", "corrs", "echrt", "chanar", " chrb", "schrs", " chran", "chanrn", "Char", "echr", " chc", "schrb", " chlr", " chro", " chru", "Chrar", "corrf", "corru", "chanrar", "chrs", "thrt", "chlr", "schrt", "chrt", "schr", "CHlr", "Chro", " chrt", "schran", " chsr", "Chlr", "echrf", " chrs", "chrar", "chru", "schru"], "iomemtype": ["iomomcat", "homademstate", "iomademsize", "oriemtype", "iomomstate", "iomademType", "iomembror", "iomemcat", "oriemping", "ionicemtype", "iomemerType", "iomomtype", "iomemror", "iominemtype", "ionicemror", "iominemype", "homademtypes", "iomelstate", "iomemerping", "iomemeType", "iomemtypes", "iomomtypes", "iomemersize", "iomemertype", "iomembtype", "iomemping", "iomademping", "iomamformat", "homademcat", "oriemsize", "iomemsize", "ionicembror", "iomemype", "ionicembype", "iomamror", "ionicembtype", "ionicemformat", "oriademType", "homademtype", "oriemType", "iomademtype", "iomemetype", "iomamtype", "iominemformat", "homemcat", "iomemType", "iomembformat", "iomembype", "iomademtypes", "iomeltype", "iomademcat", "iomeltypes", "iomemeping", "iomemesize", "homemtypes", "homemtype", "oriademsize", "iomemformat", "ionicemype", "iominemror", "iomemstate", "oriademtype", "homemstate", "ionicembformat", "iomamype", "iomelcat", "oriademping", "iomademstate"], "s": ["ps", "sync", "fs", "d", "o", "session", "rs", "site", "south", "v", "e", "u", "cs", "ts", "its", "l", "server", "ds", "states", "sys", "si", "ss", "y", "ssl", "se", "m", "new", "service", "state", "sq", "conf", "gs", "a", "g", "es", "n", "os", "spec", "is", "full", "c", "http", "i", "su", "sg", "p", "status", "ns", "b", "sl", "f", "sb", "ses", "w", "js", "settings", "r", "socket", "services", "S", "ls", "t", "support"]}}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "substitutes": {"ctx": ["cam", "cpp", "txt", "cm", "pkg", "bc", "pc", "cb", "conn", "anc", "Context", "cc", "cmp", "grad", "lc", "rc", "cca", "context", "c", "conv", "cp", "ctrl", "tx", "ca", "abc", "xc", " cx", "cas", "cv"], "gprn": ["rgprns", " gprN", "gPrns", "gPRr", "rgPRns", "gprne", " gPrne", "gprN", "rgprn", " gPrns", "gPrr", "rgprN", "gprns", "gprr", "gPrne", "rgPRr", "rgPRn", " gprne", "gPRn", "gPrN", "gPRne", " gPrN", " gPrn", "gPRN", "rgPRN", "gPRns", " gprns", "rgprr", "gPrn"], "sprn": ["prr", " sprb", "Sprb", "prN", "Sprn", "Sprr", "prn", "sprr", " sprr", "prb", "sprN", " sprN", "sprb", "SprN"]}}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int i, j;\n\n    target_ulong sdr1;\n\n    uint32_t fpscr;\n\n    target_ulong xer;\n\n\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gpr[i]);\n\n#if !defined(TARGET_PPC64)\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gprh[i]);\n\n#endif\n\n    qemu_get_betls(f, &env->lr);\n\n    qemu_get_betls(f, &env->ctr);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be32s(f, &env->crf[i]);\n\n    qemu_get_betls(f, &xer);\n\n    cpu_write_xer(env, xer);\n\n    qemu_get_betls(f, &env->reserve_addr);\n\n    qemu_get_betls(f, &env->msr);\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->tgpr[i]);\n\n    for (i = 0; i < 32; i++) {\n\n        union {\n\n            float64 d;\n\n            uint64_t l;\n\n        } u;\n\n        u.l = qemu_get_be64(f);\n\n        env->fpr[i] = u.d;\n\n    }\n\n    qemu_get_be32s(f, &fpscr);\n\n    env->fpscr = fpscr;\n\n    qemu_get_sbe32s(f, &env->access_type);\n\n#if defined(TARGET_PPC64)\n\n    qemu_get_betls(f, &env->spr[SPR_ASR]);\n\n    qemu_get_sbe32s(f, &env->slb_nr);\n\n#endif\n\n    qemu_get_betls(f, &sdr1);\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->sr[i]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->DBAT[i][j]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->IBAT[i][j]);\n\n    qemu_get_sbe32s(f, &env->nb_tlb);\n\n    qemu_get_sbe32s(f, &env->tlb_per_way);\n\n    qemu_get_sbe32s(f, &env->nb_ways);\n\n    qemu_get_sbe32s(f, &env->last_way);\n\n    qemu_get_sbe32s(f, &env->id_tlbs);\n\n    qemu_get_sbe32s(f, &env->nb_pids);\n\n    if (env->tlb.tlb6) {\n\n        // XXX assumes 6xx\n\n        for (i = 0; i < env->nb_tlb; i++) {\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->pb[i]);\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_get_betls(f, &env->spr[i]);\n\n    ppc_store_sdr1(env, sdr1);\n\n    qemu_get_be32s(f, &env->vscr);\n\n    qemu_get_be64s(f, &env->spe_acc);\n\n    qemu_get_be32s(f, &env->spe_fscr);\n\n    qemu_get_betls(f, &env->msr_mask);\n\n    qemu_get_be32s(f, &env->flags);\n\n    qemu_get_sbe32s(f, &env->error_code);\n\n    qemu_get_be32s(f, &env->pending_interrupts);\n\n    qemu_get_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_get_betls(f, &env->excp_vectors[i]);\n\n    qemu_get_betls(f, &env->excp_prefix);\n\n    qemu_get_betls(f, &env->ivor_mask);\n\n    qemu_get_betls(f, &env->ivpr_mask);\n\n    qemu_get_betls(f, &env->hreset_vector);\n\n    qemu_get_betls(f, &env->nip);\n\n    qemu_get_betls(f, &env->hflags);\n\n    qemu_get_betls(f, &env->hflags_nmsr);\n\n    qemu_get_sbe32s(f, &env->mmu_idx);\n\n    qemu_get_sbe32(f); /* Discard unused power_mode */\n\n\n\n    return 0;\n\n}\n", "idx": 13130, "substitutes": {"f": ["fp", "fm", "fs", "d", "o", "file", "af", "fa", "func", "fi", "fore", "uf", "v", "bf", "elf", "e", "fe", "fn", "ff", "cf", "l", "fb", "def", "full", "rf", "conf", "m", "this", "of", "fd", "sf", "form", "tf", "fun", "fen", "g", "df", "k", "self", "fr", "feed", "buff", "fc", "c", "h", "info", "fed", "p", "b", "fo", "fx", "F", "fw", "t", "inf", "function"], "opaque": ["oplcoe", "Opaque", "opaques", "opaco", "operaco", " opque", " opacs", " opaques", "oplaque", "Opec", "plaques", "opque", "oplaques", "Opque", "operaque", "Opaco", "opacs", " opaco", "opec", " opcoe", "operque", "plcoe", "opcoe", "placs", "oplacs", "plaque", " opec", "operec"], "version_id": [" version_hash", " version0id", " version0sid", " versionidid", " version_ids", " version0ids", " versionidsid", "version_sid", " version_sid", " versionidhash", "version_hash", " versionidids", " version0hash", "version_ids"], "cpu": ["fp", "uno", "fi", "vm", "CPU", " gcc", "pc", "prof", "gpu", "processor", "bench", "sys", "ec", "cow", "hu", "uu", "hw", "pool", "lc", "pu", "proc", "linux", "kernel", "net", " CPU", "uci", "boot", " cp", "cache", "node", "c", "cp", "p", "cli", "core", "cal", "loader", "clock", "platform", "conn"], "env": ["estate", "enc", "site", "priv", "exec", "exc", "v", "erv", "pos", "dir", "fe", "obj", "fb", "output", "dat", "equ", "ec", "ef", "assets", "vel", "ern", "fen", "ea", "emb", "np", "her", "dict", "scope", "esi", "here", "enable", "conn", "len", "en", "ne", "qv", "e", "den", "eng", "limits", "eni", "org", "cache", "context", "cal", "gear", "chal", "oa", "engine", "environment", "fi", "vm", "ff", "cfg", "fg", "end", "esm", "fun", "vs", "enos", "viron", "que", "inf", "enh", "ass", "ev", "inet", "server", "style", "gui", "el", "export", "config", "eu", "inv", "exe", "net", "extra", "args", "info", "ext", "cli", "energy", "loader", "console", "err", "forge", "fw", "conf", "Environment", "cv"], "i": ["d", "ie", "di", "o", "gi", "my", "chi", "ini", "iu", "fi", "mi", "data", "jp", "v", "multi", "li", "e", "xi", "image", "mu", "l", "pi", "uri", "ei", "si", "vi", "in", "y", "ai", "ui", "m", "slice", "ti", "k", "z", "ix", "me", "n", "eni", "ci", "id", "io", "bi", "init", "qi", "ip", "c", "x", "phi", "hi", "info", "ji", "p", "index", "ri", "cli", "b", "type", "uli", "ni", "name", "zi", "r", "ii", "I", "yi"], "j": ["it", "sync", "o", "uni", "J", "jp", "v", "xi", "obj", "job", "aj", "g", "z", "k", "jet", "n", "ij", "ji", "b", "jump", "js", "bj", "je", "jit", "ja", "jc"], "sdr1": ["srs1", "sDRone", "scr3", "scr1", "sDR2", "ssdr1", "ssrone", "srsone", "ssr2", "sscr1", "sdr3", "ssDRone", "sscr3", "ssdr2", "sscrone", "srs2", "ssr1", "ssDR1", "scrone", "sdrone", "ssr3", "ssDR2", "sdr2", "ssdrone", "ssdr3", "sDR1"], "fpscr": ["bpsCr", "bpsrc", "framescr", "fsCr", " fpscre", "tailscr", "fsctr", "fpsCr", " fpsrc", "bitskr", " fpsCr", "fsrr", "fpspr", "bpscre", "fpsrr", "bpsCR", " fpspr", "tailscre", " fpsctr", "msCr", "flagscr", "fpsCR", "fskr", "mspr", "bpscr", "flagscre", "flagskr", "bitscr", "mscr", "fscr", "bitscre", "fpsctr", "fscre", "framesrc", "fspr", "framesCR", "flagsrr", " fpsCR", "tailsCR", "fpscre", "msctr", "bitsrr", "fpsrc", "tailsrc", "framesCr", "fpskr"], "xer": ["wers", "txe", "xe", "txel", "war", " xeri", "xeser", " xar", "txer", "xers", " xe", " xers", "xel", " Xer", "xester", "exe", "wer", "exers", "xesar", "we", "txester", "xar", "xeseri", " xel", "xeri", "exeri", "xesers", " Xel", " xester", " Xe", " Xester", "exar", "exer"], "u": ["d", "us", "o", "ru", "um", "cu", "iu", "user", "v", "du", "ur", "fu", "e", "ut", "util", "mu", "l", "lu", "ou", "y", "ui", "uid", "uu", "hu", "uc", "ue", "pu", "up", "un", "x", "ul", "c", "h", "uv", "p", "su", "nu", "w", "tu", "back", "U"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 13136, "substitutes": {"str": ["enc", "ctr", "iter", "frac", "dr", "rs", "temp", "txt", "br", "cs", "st", "obj", "inner", "STR", "kr", "in", "res", "sp", "rr", "ptr", "lc", "seq", "pr", "tr", "stri", "fr", "id", "spec", "hr", "ext", "Str", "arr", "sr", "start", "cr", "f", "er", "r", "text", "old", "code"], "endptr": [" endproc", "startPtr", "endedPtr", "endedptr", " endpointer", "startptr", "adPtr", "adtr", "endpointer", "adptr", "endedtr", "startpointer", "endedpointer", "endaddr", "adpointer", " endPtr", "endtr", "adproc", " endaddr", "endproc", "adaddr", "startproc", " endtr", "endPtr", "startaddr"], "err": ["ctr", "iter", "test", "dr", "der", "ar", "try", "resp", "e", "result", "rh", "inner", "res", "lr", "ise", "nr", "rr", "error", "rc", "pr", "z", "fr", "i", "ler", "p", "req", "order", "ver", "Er", "arr", "cr", "ind", "msg", "acer", "ner", "er", "Error", "r", "gr", "var", "code"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,\n\n                                     uint8_t *dst, int32_t dst_stride,\n\n                                     int32_t height, uint8_t ver_offset)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                          mask0, mask1, mask2);\n\n\n\n    PCKOD_D2_SH(hz_out0, hz_out0, hz_out2, hz_out2, hz_out1, hz_out3);\n\n\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n\n\n        hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n        hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n\n\n        PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8);\n\n\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (ver_offset) {\n\n            dst1 = __msa_srari_h(hz_out3, 5);\n\n            dst3 = __msa_srari_h(hz_out4, 5);\n\n            dst5 = __msa_srari_h(hz_out5, 5);\n\n            dst7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            dst1 = __msa_srari_h(hz_out2, 5);\n\n            dst3 = __msa_srari_h(hz_out3, 5);\n\n            dst5 = __msa_srari_h(hz_out4, 5);\n\n            dst7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);\n\n\n\n        dst0 = __msa_aver_s_h(dst0, dst1);\n\n        dst1 = __msa_aver_s_h(dst2, dst3);\n\n        dst2 = __msa_aver_s_h(dst4, dst5);\n\n        dst3 = __msa_aver_s_h(dst6, dst7);\n\n\n\n        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);\n\n        XORI_B2_128_SB(src0, src1);\n\n\n\n        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n", "idx": 13137, "substitutes": {"src": ["sync", "ctr", "gl", "rs", "tmp", "chrom", "source", "dist", "sc", "st", "sci", "sil", "desc", "cb", "sel", "scl", "rob", "ssl", "cmp", "sq", "uc", "inst", "bg", "sec", "url", "rc", "config", "sub", "RC", "rb", "sup", "low", "dest", "ctx", "cur", "fc", "gz", "comp", "lib", "sl", "sr", "sb", "pl", "gru", "stream", "gb", "loc", "filename", "img", "gn"], "src_stride": ["src_Stride", "src_trides", "src_STRride", "src_Strided", "src_STRider", "src_strided", "src_strides", "src_trided", "src_STRides", "src_strIDE", "src_brride", "src_dride", "src_tride", "src_STRIDE", "src_drides", "src_STRided", "src_brided", "src_striride", "src_striided", "src_bride", "src_strride", "src_striide", "src_brIDE", "src_StrIDE", "src_Strides", "src_trride", "src_brider", "src_STRide", "src_brides", "src_strider", "src_striides", "src_drride", "src_drider", "src_Strride"], "dst": ["Dst", "best", "fst", "frc", "Dsp", "fsp", "fest", "brc", "bsp", "bst", "Dest", "Drc", "dsp", "drc", "dest"], "dst_stride": ["dst_arride", "dst_trides", "dst_divride", "dst_divide", "dst_trride", "dst_strided", "dst_arrides", "dst_tride", "dst_trided", "dst_arrride", "dst_divides", "dst_strides", "dst_strride", "dst_arrided", "dst_divided"], "height": ["gap", "headers", "high", "data", "op", "length", "hd", "size", "timeout", "Height", "depth", "shape", "header", "def", "level", "y", "padding", "slice", "boost", "windows", "dim", "resolution", "block", "ch", "id", "input", "h", "bottom", "i", "window", "top", "layout", "index", "thin", "kw", "row", "th", "diff", "build", "img", "prev"], "ver_offset": ["ver_mask", "block_padding", "ver_no", "verprepadding", "blocklenpadding", "verpreoffset", "verpreno", "blocklenno", "blocklenmask", "verpremask", "block_offset", "verlenno", "block_no", "block_mask", "verlenmask", "ver_padding", "verlenpadding", "verlenoffset", "blocklenoffset"], "loop_cnt": ["loop_ncant", "loop_cnc", "loop_dcct", "loop_countNT", "loop_Cant", "loop_acnd", "loop_secount", "loop_ncnt", "loop_counttrl", "loop_cant", "loop_cnd", "loop_acNT", "loop_secNT", "loop_countnt", "loop_cno", "loop_secnd", "loop_lcnc", "loop_ncNT", "loop_lcnt", "loop_Cnt", "loop_Ctrl", "loop_secnt", "loop_CNT", "loop_dcno", "loop_Cnd", "loop_dcnc", "loop_cct", "loop_dcnt", "loop_lcct", "loop_acount", "loop_ctrl", "loop_lcno", "loop_acnc", "loop_Count", "loop_count", "loop_cNT", "loop_nctrl", "loop_acno", "loop_acnt", "loop_countant", "loop_acct"], "src0": ["rc4", "seq0", "src00", "seq60", " src00", "source1", "rc2", "source4", "rc1", "source2", " src60", "rc00", "loc00", "loc0", "seq2", "loc2", "source0", "loc3", "src60", "rc3", "rc60", "seq1", "rc0", "loc1"], "src1": ["rc4", "source1", "rc2", "source4", "src8", "inst0", "rc1", "loc8", "inst8", "loc0", "inst2", "loc2", "rc8", "source3", "source0", "loc3", "loc4", "rc3", "inst1", "rc0", "loc1"], "src2": ["rc4", "source1", "rc2", " src02", "source4", "src8", "rc1", "source2", "src02", "loc0", "source8", "loc2", " src8", "rc8", "loc3", "rc02", "loc4", "rc3", "rc0", "loc1", "source02"], "src3": ["rc4", "dist23", "source5", "source1", "rc2", "source4", "sur1", "rc1", " src5", "source2", "sur3", "dist03", "src03", "sur4", "loc2", "rc23", "sur5", "rc03", "rc5", "source3", "dist2", "g", "src5", "src23", "loc3", "s", "source03", "dist3", "loc03", "rc3", "loc1", "source23", "dist1"], "src4": ["dist4", "rc4", "source5", "dist44", "src40", "rc2", "rc40", "source4", "src8", " src5", "source2", "dest2", "dest3", " src40", "source8", " src8", "rc8", "rc44", "src44", "rc5", "source3", "dist2", "src5", "dest4", "source44", "rc3", "dest8", "dist8", "source40"], "mask0": ["shape2", "mask5", "weight50", "ph1", "sum1", "shape5", "shape1", "ask50", "ask0", "miss00", "mask00", "sum0", "ph5", "fix5", "ask1", " mask00", "miss1", "sum2", " mask5", "mask50", "weight0", "weight1", "fix0", "ph2", "ask5", "miss0", "fix2", "weight00", "ask00", "ph0", "shape0", "ask2", " mask50", "miss2", "fix1"], "mask1": ["mark0", "ask3", "miss4", "ask0", "miss8", " mask8", "ask1", "ask4", "mask4", "miss1", "weight4", "weight0", "weight1", "miss2", "mask3", " mask4", "miss0", "mark3", "mark4", " mask3", "weight2", "mask8", "ask2", "mark2", "mark1", "ask8"], "mask2": ["mask5", "ask3", "sum1", "miss4", "sum5", "sum3", "mask6", "sum4", "miss3", "pack6", " mask6", "ask1", "ask4", "mask4", "miss1", "sum2", "ask6", " mask5", "mask3", " mask4", "pack2", "pack4", " mask3", "pack3", "ask2", "miss2", "ask5"], "hz_out0": ["hz_OUT3", "hz_OUT1", "hz_no3", "hz_in10", "hz_mask0", "hz_mask2", "hz_out10", "hz_in3", "hz_in1", "hz_no1", "hz_OUT2", "hz_mask12", "hz_again3", "hz_OUT19", "hz_again0", "hz_option3", "hz_no8", "hz_again1", "hz_exp0", "hz_OUT0", "hz_exp10", "hz_out12", "hz_sum8", "hz_OUT12", "hz_exp8", "hz_in2", "hz_option1", "hz_exp1", "hz_in12", "hz_no0", "hz_sum10", "hz_option0", "hz_in19", "hz_option8", "hz_sum0", "hz_again19", "hz_mask1", "hz_out19", "hz_sum1", "hz_in8", "hz_in0"], "hz_out1": ["hz_nin7", "hz_OUT1", "hz_in11", "hz_nin8", "hz_OUTOne", "hz_OUT2", "hz_nin2", "hz_option2", "hz_out11", "hz_outOne", "hz_inOne", "hz_in7", "hz_exp8", "hz_in2", "hz_option1", "hz_nin1", "hz_exp7", "hz_exp1", "hz_optionOne", "hz_OUT11", "hz_option11", "hz_in8", "hz_exp2", "hz_in1"], "hz_out2": ["hz_OUTTwo", "hz_nin82", "hz_in4", "hz_nin5", "hz_OutTwo", "hz_Out3", "hz_option1", "hz_Out1", "hz_name02", "hz_OUT5", "hz_out02", "hz_in3", "hz_in02", "hz_option2", "hz_off1", "hz_outTwo", "hz_inTwo", "hz_nin4", "hz_out82", "hz_OUT1", "hz_copy5", "hz_copy2", "hz_Out0", "hz_in2", "hz_off0", "hz_name2", "hz_off3", "hz_OUT4", "hz_Out4", "hz_off2", "hz_in0", "hz_in1", "hz_OUT82", "hz_name1", "hz_option02", "hz_nin2", "hz_OUT2", "hz_in7", "hz_copy4", "hz_Out2", "hz_copy82", "hz_name7", "hz_option7"], "hz_out3": ["hz_again5", "hz_in03", "hz_index6", "hz_in3", "hz_out03", "hz_index5", "hz_update6", "hz_Out03", "hz_again3", "hz_index3", "hz_again6", "hz_Out3", "hz_index305", "hz_in2", "hz_again305", "hz_update305", "hz_update5", "hz_Out2", "hz_Out1", "hz_num1", "hz_update3", "hz_num03", "hz_num2", "hz_out305", "hz_num3", "hz_in1"], "hz_out4": ["hz_sum2", "hz_again32", "hz_sum12", "hz_in3", "hz_sum4", "hz_again3", "hz_in32", "hz_sum3", "hz_again2", "hz_sum32", "hz_in4", "hz_out32", "hz_out12", "hz_sum8", "hz_again12", "hz_in2", "hz_again8", "hz_in12", "hz_again4", "hz_in8"], "hz_out5": ["hz_again5", "hz_outer5", "hz_outerL", "hz_again2", "hz_again1", "hz_in2", "hz_outL", "hz_outer2", "hz_in5", "hz_againL", "hz_inL", "hz_outer1", "hz_in1"], "hz_out6": ["hz_over6", "hz_index12", "hz_index6", "hz_over12", "hz_over2", "hz_in6", "hz_index7", "hz_out12", "hz_index2", "hz_in7", "hz_in2", "hz_in12", "hz_over7"], "hz_out7": ["hz_nin7", "hz_in57", "hz_out27", "hz_exp57", "hz_exp17", "hz_in7", "hz_exp7", "hz_in17", "hz_out17", "hz_out57", "hz_in27", "hz_nin57", "hz_exp27", "hz_nin17", "hz_nin27"], "hz_out8": ["hz_OUT1", "hz_again5", "hz_OUT2", "hz_again2", "hz_again1", "hz_in2", "hz_in5", "hz_OUT8", "hz_again8", "hz_OUT5", "hz_in8", "hz_in1"], "dst0": ["dost0", "lest4", "dsc0", "dest0", "dost2", "dest2", "lst0", "dest1", "dost1", "lst4", "dost4", "dsc1", "lest2", "lst2", "dest4", "dsc2", "lst1", "lest0", "dsc4", "lest1"], "dst1": [" dsc01", "dsp01", " dst01", "dsc0", "dest0", " dsc2", "dest2", "dest01", "dsp1", "dest1", "dsp0", " dsc1", "dsc1", " dsc0", "dsp2", "dsc2", "dst01", "dsc01"], "dst2": ["ddest2", " dest4", "dconst5", "dconst4", "dest2", "dest5", "ddest1", "dest1", " dest2", "ddest4", "dest4", "dconst1", "dconst2", " dest1", "ddest5", " dest5"], "dst3": ["dgest1", "dgest3", "ddest2", " dest4", "dest2", "ddest1", " dest3", "dest3", "dest1", "dgest2", " dest2", "ddest4", "ddest3", "dest4", " dest1", "dgest4"], "dst4": ["dgest54", " dst54", " dest4", "dest2", "dST2", "dest54", "dest5", "dgest2", " dest2", "dST4", " dest54", "dest4", "dST54", "dgest5", "dst54", "dST5", "dgest4", " dest5"], "dst5": [" dest4", "dgest55", "dest2", "dest55", "dest5", "dsts5", "dgest2", "dsts55", "dst55", " dest2", " dest55", "dest4", "dgest5", " dst55", "dgest4", "dsts2", " dest5", "dsts4"], "dst6": ["dst8", "dstage6", "ddest7", " dest8", " dest7", " dstSix", "destSix", " dest6", "dstage7", "dest6", "dstageSix", "ddest8", "dest7", " destSix", "ddest6", "dstSix", "dstage8", "ddestSix", "dest8", " dst8"], "dst7": ["dst8", "ddest7", "dst77", " ddest8", "ddest77", "dST7", "dest6", " dst77", "dST77", " ddest77", "ddest8", " ddest7", "dST6", " ddest6", "dST8", "dest77", "dest7", "ddest6", "dest8", " dst8"]}}
{"project": "qemu", "commit_id": "afcf905cff7971324c2706600ead35a1f41f417a", "target": 1, "func": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}", "idx": 13140, "substitutes": {"data": ["module", "d", "func", "reader", "media", "image", "result", "message", "script", "base", "dat", "style", "def", "pad", "resource", "writer", "db", "root", "map", "attr", "this", "api", "ra", "a", "error", "config", "parent", "cache", "input", "memory", "args", "window", "missing", "Data", "arr", "DATA", "buffer", "parser", "entry", "buf", "alpha", "array", "ad"], "user_data": ["user_Data", "user_ad", " user_Data", " user_ad"], "var": ["app", "dr", "ars", "func", "ar", "AR", "reader", "param", "adr", "val", "Var", "pack", "attr", "tag", "car", "bar", "mod", "comment", "parse", "aver", "par", "arg", "vari", "rec", "spec", "cur", "dev", "type", "cat", "ver", "arr", "name", "as", "av", "err", "er", "ref"]}}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    /* use non-QOM casts in the data path */\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n    VirtIOSCSICommon *vs = &s->parent_obj;\n\n\n\n    VirtIOSCSIReq *req;\n\n    int n;\n\n\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        SCSIDevice *d;\n\n        int out_size, in_size;\n\n        if (req->elem.out_num < 1 || req->elem.in_num < 1) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        out_size = req->elem.out_sg[0].iov_len;\n\n        in_size = req->elem.in_sg[0].iov_len;\n\n        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||\n\n            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        if (req->elem.out_num > 1 && req->elem.in_num > 1) {\n\n            virtio_scsi_fail_cmd_req(req);\n\n            continue;\n\n        }\n\n\n\n        d = virtio_scsi_device_find(s, req->req.cmd->lun);\n\n        if (!d) {\n\n            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET;\n\n            virtio_scsi_complete_req(req);\n\n            continue;\n\n        }\n\n        req->sreq = scsi_req_new(d, req->req.cmd->tag,\n\n                                 virtio_scsi_get_lun(req->req.cmd->lun),\n\n                                 req->req.cmd->cdb, req);\n\n\n\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n            int req_mode =\n\n                (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n            if (req->sreq->cmd.mode != req_mode ||\n\n                req->sreq->cmd.xfer > req->qsgl.size) {\n\n                req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN;\n\n                virtio_scsi_complete_req(req);\n\n                continue;\n\n            }\n\n        }\n\n\n\n        n = scsi_req_enqueue(req->sreq);\n\n        if (n) {\n\n            scsi_req_continue(req->sreq);\n\n        }\n\n    }\n\n}\n", "idx": 13149, "substitutes": {"vdev": ["wconf", "Vdevice", "wdev", " vdevice", "ldevice", " vconf", "vconf", "ldev", "vdef", "wdevice", "Vdev", "ldef", "wdef", "Vconf", "vnd", "Vnd", "Vdef", " vnd", "vdevice", "lnd", " vdef"], "vq": [" vqueue", " vdq", "Vq", "vmdq", "vue", "vw", " vw", "vmqueue", "vsq", "Vdq", "pw", "Vue", "vmq", "vmsq", " vue", " vsq", "pqueue", "Vsq", "Vqueue", "vqueue", "pq", "vdq", "pue", "Vw"], "s": ["ps", "sv", "session", "o", "rs", "sid", "v", "cs", "sa", "e", "server", "ds", "sys", "si", "ss", "service", "ssl", "m", "sp", "gs", "sec", "a", "g", "self", "os", "spec", "c", "i", "q", "sg", "su", "p", "ns", "b", "f", "sb", "ses", "sis", "w", "js", "r", "services", "j", "S", "t", "sk"], "vs": ["ps", "fs", "ops", "sv", "nav", "rs", "vm", "v", "cs", "ov", "outs", "params", "ds", "vers", "ves", "vt", "ims", "grad", "gs", "xs", "bs", "values", "obs", "g", "ks", "vc", "os", "vd", "ums", "dev", "http", "args", "forces", "ns", "eps", "qs", "vals", "va", "views", "vg", "flags", "utils", "VS", "vr", "vp", "ls", "env", "alls", "sk"], "req": ["exec", "requ", "resp", "cb", "query", "ec", "rf", "cook", "sec", "seq", "ae", "reg", "rb", "spec", "rev", "cur", "hr", "ver", "src", "ind", "msg", "j", "conn", "client", "serv", "required", "iq", "rt", "cmd", "resource", "res", "respond", "sq", "mod", "str", "arg", "org", "id", "cache", "qi", "input", "crit", "load", "dq", "ru", "ctr", "require", "task", "jp", "data", "md", "result", "rh", "rel", "qt", "qa", "dep", "cmp", "this", "rr", "sem", "release", "pr", "wx", "rec", "progress", "fr", "ch", "quest", "http", "q", "art", "urg", "rep", "ir", "get", "call", "ref", "comp", "wa", "dr", "qq", "ev", "pull", "desc", "def", "grad", "form", "url", "config", "proc", "tr", "z", "low", "ctx", "rx", "ext", "p", "range", "cl", "inc", "f", "row", "Request", "loader", "err", "request", "r", "gr", "conf", "pro"], "n": ["o", "nn", "nd", "ng", "v", "nt", "e", "nc", "l", "conn", "in", "m", "nr", "num", "g", "k", "z", "nb", "N", "c", "i", "ns", "p", "b", "f", "w", "r", "t"], "d": ["bd", "di", "dt", "dr", "nd", "dos", "data", "v", "md", "e", "ld", "rd", "u", "cd", "l", "dB", "dat", "ds", "dc", "m", "dx", "pd", "fd", "dn", "dl", "da", "ded", "z", "de", "xd", "id", "dh", "dev", "c", "i", "p", "dd", "b", "f", "ind", "dq", "D", "dy", "j", "r", "gd", "t", "driver", "ad"], "out_size": ["out64stream", "out_scale", " out_set", "out64sized", "out_capacity", "out_set", "out_sized", " out64stream", "point_bytes", " out64size", " out_capacity", "out_bytes", "outCvalue", "point_ize", " out_stream", "out_value", "outlexstream", "out64size", "point_size", "out64set", "out_count", " out_count", "outCbytes", "point_value", " out64set", "outCize", "out_ize", "outlexsize", "outlexsized", " out64sized", "outCsize", " out_sized", "outlexset", "out_stream", " out_scale"], "in_size": ["inxwidth", "in67size", "in\u00b7size", "inc_length", "inAClength", "inACsize", "inc_width", " in_speed", "in\u00b7loc", "inxsize", " in_align", "in_length", "inxweight", "in_width", "inACwidth", "in\u00b7speed", "in_sym", "in_ize", "in\u00b7align", "inxize", "In_weight", "in67loc", " in_loc", "in_weight", "in67speed", "In_size", "In_width", "In_ize", "in_speed", "in_loc", "in_align", "inACsym", "inc_size", "inc_sym", "in67align"]}}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n", "idx": 13154, "substitutes": {"opts": ["operls", "operTS", "operments", "opfs", "optted", " optics", "OPments", "OPfs", "optouts", "optt", "hopsts", "lintics", "opops", "okted", "optfs", "optTS", "linls", "opttics", "OPts", " opsts", "optionfs", "optws", "opers", "operops", "opments", "optts", "optics", "opws", "linments", "OPt", "optops", "optiont", "optionouts", "optsts", " opws", "operted", "optments", "opt", "opsts", "okts", "opouts", "hoptics", "optls", "lints", "okops", "optionts", "OPouts", "opTS", "okTS", "opertics", "operts", "hopts", "opted", "hopws", "opert", "opls", "ops", "OPs"], "chr": ["cyr", "Chcr", "chrw", "corr", "corro", "cyrf", "charru", " chcr", "cher", "cherc", "charp", " chrf", "chrc", " chp", "hr", " chlr", "clr", "chrl", "colrf", "qr", "charrf", "clnr", "ctran", "achr", "chru", " chrb", "Chr", "Chrl", "hlr", "chrb", "charr", "ichr", "charrc", "achre", " chran", "Chrw", "chcr", "Chp", "cylr", "colrl", "ichro", "colru", "Chpr", "schrt", " chrl", " chrt", "cordr", "charpr", "schran", "ctrt", "ichdr", "ctr", "chro", "shdr", "clru", "hrf", "hrb", "shr", "clrl", "colre", "charre", "charcr", "charar", "chsr", "qrw", "cyrb", "chpr", "corsr", "ichlr", "schr", "chrt", "chelr", "chre", "colnr", "achru", "chnr", "ichrb", "Chrb", "ichsr", "qrl", " chrw", "chrf", "shsr", "ichrf", "shro", "chear", "charlr", "chp", " chpr", "chdr", " chnr", " chru", "schrf", "colr", "ctrf", "chlr", " chrc", "achrf", "qrb", "chran"], "s": ["ps", "hs", "sync", "storage", "fs", "client", "sv", "session", "o", "d", "rs", "sid", "south", "v", "cs", "e", "u", "ts", "its", "l", "server", "ds", "better", "params", "sys", "si", "ss", "rows", "service", "ssl", "m", "sq", "gs", "sf", "str", "g", "es", "n", "os", "spec", "stats", "is", "side", "c", "shell", "http", "su", "sg", "h", "ns", "p", "scope", "i", "b", "sign", "secure", "sl", "lines", "f", "sb", "ses", "w", "js", "settings", "share", "r", "services", "socket", "S", "ls", "t", "sym", "ops"], "height": ["how", "gap", "ty", "hip", "deep", "pull", "gravity", "gain", "volume", "rh", "direction", "head", "length", "size", "work", "above", "style", "Height", "depth", "shape", "y", "level", "arrow", "padding", "gh", "ady", "shadow", "slice", "hold", "resolution", "view", "tight", "density", "east", "id", "han", "huge", "weight", "h", "bottom", "window", "crop", "layout", "upper", "missing", "index", "ths", "thin", "stroke", "row", "th", "square", "grow", "build", "rank", "angle", "pass", "inches", "hang"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 13155, "substitutes": {"opaque": ["oppatile", "Opaque", "OPacity", "operatile", "opaques", "opctx", "ipopaque", "Opec", "operaques", "oppaques", "ipopaques", " opacity", "operaque", "ipopatile", "opec", " opec", "Opacity", "opacity", "opatile", "OPec", "ipopacity", "oppaque", "oppacity", "operacity", "OPctx", "Opctx", "OPaque", " opctx"], "addr": ["part", "address", "dr", "null", "ord", "amd", "edge", "data", "mode", "adr", "pos", "e", "image", "cmd", "base", "server", "align", "pad", "padding", "grad", "offset", "adder", "nr", "ptr", "seq", "a", "host", "config", "byte", "error", "point", "np", "node", "ip", "x", "args", "pointer", "rx", "p", "layer", "type", "i", "index", "device", "start", "src", "port", "xxx", "ace", "r", "socket", "ref", "len", "ad", "oa"], "size": ["enc", "en", "sync", "address", "fee", "Size", "empty", "mode", "e", "length", "align", "timeout", "shape", "offset", "sec", "sn", "small", "scale", "g", "z", "sized", "capacity", "n", "x", "c", "args", "bytes", "type", "or", "SIZE", "loc", "ize", "len", "from", "code"], "s": ["sync", "fs", "d", "us", "o", "session", "address", "south", "secondary", "e", "u", "server", "si", "ss", "service", "ssl", "m", "an", "sq", "slice", "sf", "a", "g", "es", "n", "os", "spec", "is", "side", "c", "http", "p", "status", "ns", "scope", "b", "sl", "aws", "instance", "f", "sb", "sie", "ses", "settings", "request", "stat", "r", "sym", "socket", "S", "t"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n", "idx": 13156, "substitutes": {"vdev": ["vapi", "svgen", "nvdiv", "svdev", "nvgen", "vcprof", "verdev", " vprof", "svdevice", "fgen", "vprof", "svprof", "verring", "ivdev", "vcapi", "evdi", "vdiv", "fdevice", "vmid", " vdevice", "svring", "lmid", "ldevice", "fdev", "ivconn", "ldev", "vcring", " vdi", "nvdev", " vgen", "svapi", "lconn", "ivdevice", "svdb", " vapi", "vding", "vcgen", " vding", "ivmid", "svmid", "vcdb", "vergen", "svconn", "vdb", "evdev", "svding", "evring", "vdi", "verdi", " vdb", "vcding", "vconn", "fdiv", "vgen", "vdevice", " vdiv", "evgen", "vcdev", "nvdevice"], "vring": ["blic", "vsdev", "svdev", "pray", "voltring", " vridge", "vsring", "vsetting", "vvray", "nvlic", "vlic", "ivcalling", " vray", "lvsing", "nvrig", " vgen", " vng", "varray", " vding", " vtesting", "evping", "varbinding", "evding", "vvtesting", "svsetting", " vlic", "pding", "lvbinding", "vping", "vbinding", "vridge", "svending", "svdi", "pring", "lvray", "rdata", "rring", "pending", "vsridge", "vding", "voltding", "vvstring", "vsing", " vending", "ivding", "svding", "svsing", "vdi", "brig", "vsding", "ivray", "avdi", "rgen", "svridge", "nvray", "avring", "lvring", "vvring", "rstring", " vdi", "ivring", "evsetting", " vping", "vdata", " vrig", "avding", "nvring", "rtesting", "evring", "voltray", "svray", "bray", "svng", "svgen", "svdata", "avng", "vng", "vstring", "varsing", "svring", "svbinding", "voltcalling", "varring", "bring", "vtesting", "varding", " vdata", "vending", "vray", "svping", "vrig", "rray", " vstring", " vsetting", "varcalling", "vgen", "vcalling"], "old": ["update", "normal", "d", "orig", "o", "original", "null", "md", "after", "und", "ld", "end", "l", "val", "Old", "valid", "num", "pre", "OLD", "last", "low", "id", "now", "current", "older", "x", "i", "p", " Old", "other", "range", "f", "lv", "ind", "or", "diff", "before", "j", "from", "event", "live", "prev"], "new": ["update", "normal", "d", "o", "ew", "good", "NEW", "raw", "result", "end", "l", "el", "with", "valid", "small", "g", "view", "self", "add", "n", "low", "where", "version", "now", "current", "c", "other", "missing", "inc", "f", "gen", "name", "again", "false", "or", "diff", "w", "New", "final", "r", "j", "value", "next", "var", "from"], "v": ["d", "o", "sv", "ev", "ve", "var", "e", "u", "V", "l", "val", "m", "valid", "g", "k", "n", "iv", "nv", "rev", "change", "c", "x", "i", "conv", "h", "uv", "p", "s", "vs", "b", "f", "lv", "w", "vp", "j", "r", "event", "vv", "t", "function"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                               const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n    int written, ret;\n\n    int16_t *flush_buf = NULL;\n\n    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;\n\n\n\n    if (s->enc_bitrate != avctx->bit_rate) {\n\n        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n        s->enc_bitrate = avctx->bit_rate;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, 32))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n\n\n    if (frame) {\n\n        if (frame->nb_samples < avctx->frame_size) {\n\n            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n            if (!flush_buf)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n\n            samples = flush_buf;\n\n            if (frame->nb_samples < avctx->frame_size - avctx->delay)\n\n                s->enc_last_frame = -1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {\n\n            av_freep(&flush_buf);\n\n            return ret;\n\n        }\n\n    } else {\n\n        if (s->enc_last_frame < 0)\n\n            return 0;\n\n        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n        if (!flush_buf)\n\n            return AVERROR(ENOMEM);\n\n        samples = flush_buf;\n\n        s->enc_last_frame = -1;\n\n    }\n\n\n\n    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,\n\n                                       avpkt->data, 0);\n\n    av_dlog(avctx, \"amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\\n\",\n\n            written, s->enc_mode, frame[0]);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    avpkt->size = written;\n\n    *got_packet_ptr = 1;\n\n    av_freep(&flush_buf);\n\n    return 0;\n\n}\n", "idx": 13163, "substitutes": {"avctx": [" avcmd", "ajcf", "avalloc", "afctrl", "avalcmd", "afloc", "avepkg", "avcf", "verctx", "apconn", "avalcf", "afctx", "avekw", "avlc", "avctrl", "akxc", "ajcmp", "afcmd", "ajctx", "afcli", "appkg", "apcontext", "afcontext", "vercf", "avcli", "raftpkg", "ajxc", "akctx", "avectrl", "akcontext", "afcit", "evctx", " avpkg", "afpkg", "avctl", "avectx", "aplc", "avpkg", "ajloc", "abcontext", " avloc", "evcontext", "aflc", "avecmp", "avxc", "afxc", "ajcontext", "akcmp", "abcmd", "awpkg", "abconn", "awcli", " avcf", "avecf", "apctx", "akctrl", " avcontext", " avcca", "ajcca", "avkw", "afcf", "ajcit", "avalctl", "awctx", "avcu", "afconn", "afcmp", "avalconn", "ajcmd", "afctl", "evcmp", "afcu", " avcit", "avconn", "avcit", "verxc", "aploc", "avalctx", "avcmp", "raftctx", "avcmd", "apcu", "avcca", "avalcontext", "raftcontext", "avecu", "ajkw", "avloc", "awcontext", "abcmp", "abctx", "avallc", "raftcli", "avalcca", " avxc", "afcca", "afkw", "apctl", "vercontext", "akcf", "evconn", "avalpkg", "avecontext", "avcontext"], "avpkt": ["apjpwk", "avjpki", " avpacket", "avtpkt", "avfqt", "avjpnt", "avjpkt", "avpki", " avpki", "avipqt", "avjpqt", "avfck", "apjpkg", " avpkg", "avfki", "avipnt", "avtpkg", "avjpacket", "avspki", " avipck", "apjpkt", "avpkg", "avspkg", "avspkt", " avspki", " avspacket", "avpacket", " avspkt", "avfacket", "avipck", "avspacket", "appacket", " avspkg", "avpnt", "appkt", " avpqt", "avjpck", " avipqt", "apjpacket", "avfwk", "avipkt", "appwk", "avpqt", " avpnt", " avpck", "avfkt", " avipkt", "avjpkg", "avfkg", " avipnt", "avfnt", "avpwk", "avjpwk", "avpck", "avtpacket", "appkg", "avtpwk"], "frame": ["module", "orig", "session", "fe", "cf", "cb", "fb", "m", "Frame", "seq", "up", "channel", "window", "set", "component", "scope", "frames", "j", "setup", "none", "sequence", "ne", "iframe", "flow", "position", "e", "image", "fl", "format", "element", "header", "slice", "time", "view", "block", "flat", "node", "c", "line", "pse", "cpu", "series", "buffer", "dy", "raise", "event", "forward", "file", "fi", "dom", "data", "fram", "message", "cycle", "model", "object", "zip", "state", "byte", "fps", "progress", "fr", "fake", "call", "que", "sample", "game", "ace", "code", "document", "fee", "board", "thread", "feature", "rame", "process", "za", "length", "slot", "el", "config", "point", "tick", "feed", "ze", "target", "range", "vol", "f", " Frame", "request", "video", "next", "function"], "got_packet_ptr": ["got_packet6desc", "got_packacket_ptr", "got_packacket2pointer", "got_packacket2desc", "got_packacket2data", "got_packet2pointer", "got_packet2ptr", "got_packacket_desc", "got_packacket2ptr", "got_packacket_data", "got_packacket_pointer", "got_packet2desc", "got_packet6pointer", "got_packet_pointer", "got_packet_data", "got_packet_desc", "got_packet6data", "got_packet6ptr", "got_packet2data"], "s": ["ps", "storage", "sync", "fs", "d", "us", "o", "session", "ins", "rs", "site", "data", "v", "sc", "e", "cs", "ts", "l", "parts", "ds", "states", "sys", "si", "ss", "ssl", "se", "m", "service", "conf", "sp", "sq", "state", "gs", "uns", "a", "xs", "g", "es", "ks", "os", "spec", "stats", "is", "side", "c", "vs", "i", "args", "sg", "h", "p", "ns", "qs", "set", "b", "scope", "aws", "sl", "sets", "f", "sb", "ses", "js", "ms", "ls", "sym", "j", "S", "services", "t", "r", "ops"], "written": ["done", "en", "writers", "checked", "started", "writing", "ed", "temp", "data", "reset", "updated", "WR", " rewritten", "output", "locked", "write", "wrote", "writer", "sent", "ended", "protected", "rawn", "generated", "finished", "fd", "seq", "unit", "loaded", "byte", "writ", "printed", "mem", "read", "weight", "changed", "bytes", "won", "ritten", "wait", "run", "created", "used", "w", "Written", "edited", "called", "len", "wa"], "ret": ["en", "failed", "ft", "fin", "real", "success", "temp", "reset", "nt", "resp", "repl", "match", "result", "obj", "format", "sat", "rt", "att", "val", "job", "def", "res", "det", "reply", "len", "valid", "pret", "fun", "reg", "rets", "arg", "bad", "rev", "mem", "art", "hard", "code", "status", "active", "let", "lit", "run", "cat", "arr", "used", "re", "RET", "red", "flag", "err", "back", "r", "value", "ref", "alt", "Ret", "rot"], "flush_buf": ["flush67uf", "clean_buffer", "push_block", "push_vec", "fl_buf", "flush_home", "clean_uf", "flush2vec", "flusherqueue", "fl_box", "flushetabs", "flush67loc", "cleaningbuf", "ushingbuf", "reset_fun", "flushacloc", "ush_buf", "reset64cur", "flush67cas", "flusheruf", "flush64cur", "flushetff", "flush_box", "flush2loc", "push_buf", "fl_seq", "flush67wb", "flushinguf", "flush2callback", "push_wb", "flush2buf", "filteretbuf", "flushingloc", "flushPuf", "flushingbox", "flush67br", "flush67brace", "cleaningbrace", "flushPbuf", "flush2brace", "push_cap", "flush2bag", "flush_seq", "flushacbuf", "flush67vec", "clean_br", "flush_block", "flush64pool", "flush_brace", "push_home", "filter_ff", "flush_uf", "flusherbuf", "flush_callback", "copy_vec", "push_loc", "flush_abs", "flush67bag", "flush_cap", "flush64buf", "copy_buf", "filteretff", "push_uf", "flush_buffer", "flushacbox", "flush_bag", "flush64fun", "flush67buffer", "flush_func", "clean_brace", "flush67buf", "flushetexc", "flushingbuffer", "flushingbuf", "push_buff", "filter_buf", "flushingbrace", "update_uf", "flush_vec", "copy_callback", "flush_wb", "cleaninguf", "filter_abs", "flush_pos", "reset64fun", "flushingfunc", "flush67callback", "ushingfunc", "flushPbox", "reset_buf", "flush_loc", "filteretabs", "update_buf", "flush_ff", "reset_cur", "push_bag", "flush2uf", "fl_uf", "copy_brace", "update_pos", "clean_buf", "flush_pool", "push_box", "push_buffer", "flush_cas", "flushPseq", "flush_exc", "flushacfunc", "flush_queue", "ush_box", "cleaningbuffer", "ushingbox", "ush_loc", "flushetbuf", "flusherpos", "update_queue", "clean_cas", "reset_pool", "flush_fun", "flush_buff", "flush_cur", "filteretexc", "reset64buf", "ush_func", "flush_br", "filter_exc", "ushingloc", "flush67home", "reset64pool"], "samples": ["Sessions", "nmodels", " sessions", "Smodels", " sockets", "sesamps", "Samples", "Samps", "nipes", " samps", "Sipes", "damples", "sockets", "samps", " smodels", "sipes", "sesamples", "sesessions", "dample", " sipes", " sample", "splays", "namps", "sesample", "dplays", "sessions", " splays", "namples", "sample", "Splays", "Sample", "smodels", "Sockets"]}}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n", "idx": 13172, "substitutes": {"addr": ["address", "dr", "ord", "amd", "data", "amp", "md", "br", "rd", "adr", "mode", "pc", "rt", "network", "wd", "alias", "slot", "resource", " address", "attr", "offset", "nr", "ptr", "rc", "host", "mx", "node", "mt", "ip", "mac", "pointer", "Address", "cp", "args", "target", "type", "device", "kt", "name", "port", "asm", "ace", "arp", "filename", "ad"], "is_write": ["isPubwriter", "isPuball", "is1read", "name_exec", " is_all", "is_read", "namegexec", "namegread", "isgread", "isPubread", "namegwrite", " is_read", "is_writer", "namegexecute", "is1write", "name_read", "isgexecute", "isgexec", "name_execute", "is_all", "isPubwrite", "is1writer", "is_execute", "is1all", "isgwrite", "name_write", " is_writer"], "is_exec": ["IS_exec", " is_sync", "isPwrite", "IS__read", "is__eval", "IS_eval", "isPclose", "is_read", " is_close", "isPec", "IS__write", "IS__eval", "isPexec", "is__exec", "is_ec", "is_eval", "is_sec", "is__write", "is_sync", " is_sec", "is_close", " is_ec", "IS_read", "IS__exec", "is__read", "IS_write"], "is_asi": [" is_sync", " is_open", "is_open", " is_data", "is_data", " is_fail", "is_fail", "is_sync"], "size": ["enc", "address", "Size", "empty", "count", "mode", "align", "timeout", "offset", "form", "sec", "unit", "scale", "capacity", "extra", "args", "name", "SIZE", "loc", "ize", "len", "security"], "saved_env": ["save__environment", "saved__environment", "saved___dat", "save__env", "saved_dat", "saved___environment", "saved_environment", "saved__env", "save__dat", "saved_exc", "save_dat", "saved___env", "saved_v", "save_environment", "saved__dat", "save_v", "save_exc", "save_env"]}}
{"project": "FFmpeg", "commit_id": "9340a99588c2bf6209b5c396df15b893c4b576b5", "target": 1, "func": "static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int chrSrcW= c->chrSrcW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int srcFormat= c->srcFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint32_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint32_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\tconst int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;\n\n\tconst int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);\n\n\tint lastDstY;\n\n        uint8_t *pal=NULL;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\t\n\n\tif(isPacked(c->srcFormat)){\n\n                pal= src[1];\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= src[0];\n\n\t\tsrcStride[0]=\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStride[0];\n\n\t}\n\n\tsrcStride[1]<<= c->vChrDrop;\n\n\tsrcStride[2]<<= c->vChrDrop;\n\n\n\n//\tprintf(\"swscale %X %X %X -> %X %X %X\\n\", (int)src[0], (int)src[1], (int)src[2],\n\n//\t\t(int)dst[0], (int)dst[1], (int)dst[2]);\n\n\n\n#if 0 //self test FIXME move to a vfilter or something\n\n{\n\nstatic volatile int i=0;\n\ni++;\n\nif(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)\n\n\tselfTest(src, srcStride, c->srcW, c->srcH);\n\ni--;\n\n}\n\n#endif\n\n\n\n//printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2],\n\n//dstStride[0],dstStride[1],dstStride[2]);\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tav_log(c, AV_LOG_WARNING, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tlastDstY= dstY;\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tconst int chrDstY= dstY>>c->chrDstVSubSample;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*chrDstY;\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*chrDstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n//printf(\"dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\\n\",\n\n// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);*/\n\n\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we can't output a dstY line so let's try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n#ifdef HAVE_MMX\n\n\t\tint i;\n\n            if(flags & SWS_ACCURATE_RND){\n\n                        for(i=0; i<vLumFilterSize; i+=2){\n\n                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];\n\n                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];\n\n                                lumMmxFilter[2*i+2]=\n\n                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]\n\n                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n                        for(i=0; i<vChrFilterSize; i+=2){\n\n                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];\n\n                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];\n\n                                chrMmxFilter[2*i+2]=\n\n                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]\n\n                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n            }else{\n\n\t\tfor(i=0; i<vLumFilterSize; i++)\n\n\t\t{\n\n\t\t\tlumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];\n\n\t\t\tlumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;\n\n\t\t\tlumMmxFilter[4*i+2]= \n\n\t\t\tlumMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;\n\n\t\t}\n\n\t\tfor(i=0; i<vChrFilterSize; i++)\n\n\t\t{\n\n\t\t\tchrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];\n\n\n\t\t\tchrMmxFilter[4*i+2]= \n\n\t\t\tchrMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;\n\n\t\t}\n\n            }\n\n#endif\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tRENAME(yuv2nv12X)(c,\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2yuvX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\t\t\t\tRENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags, dstY);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n                                lumMmxFilter[2]=\n\n                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;\n\n                                chrMmxFilter[2]=\n\n                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;\n\n\t\t\t\tRENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstY);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2packedX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstY);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we can't use MMX here without overwriting this array's tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2nv12XinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2packedXinC(c, \n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstY);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n\n\n\treturn dstY - lastDstY;\n\n}", "idx": 13204, "substitutes": {"c": ["client", "enc", "ct", "d", "cu", "cn", "com", "cont", "cm", "tc", "sc", "e", "con", "cs", "u", "nc", "C", "cf", "bc", "cit", "l", "cb", "pc", "in", "y", "ec", "cc", "dc", "m", "conf", "uc", "lc", "rc", "config", "g", "rec", "ac", "n", "vc", "ci", "ce", "ctx", "cur", "ch", "spec", "cache", "cp", "p", "cl", "col", "b", "coll", "co", "ic", "f", "cr", "mc", "ca", "xc", "t"], "src": ["sync", "source", "sc", "sel", "scl", "sur", "sys", "transform", "ssl", "sq", "inst", "rc", "host", "sub", "rb", "scene", "rec", "ctx", "cur", "conv", "req", "sl", "sr", "sb", "share", "loc", "cv"], "srcStride": ["srcShause", "rcShause", "srcShrip", "srcEstride", "rcShride", "srcShride", "rcStause", "srcStrip", "srcEstrip", "srcEstause", "srcStause", "srcSTerve", "srcSTride", "rcStrip", "rcStride", "rcSherve", "srcSterve", "srcSTause", "srcSherve", "rcSterve", "srcSTrip", "srcEsterve", "rcShrip"], "srcSliceY": ["srcSlashD", "srcSlueD", "srcPliceY", "srcSlideY", "srcSliceW", "srcSliceI", "srcSlueY", "srcSlueW", "srcPlueD", "srcPlueW", "srcPliceD", "srcSlideD", "srcSlashY", "srcPliceI", "srcSlideI", "srcSlueI", "srcPlueI", "srcSlashI", "srcSliceD", "srcPlueY", "srcPliceW", "srcSlashW", "srcSlideW"], "srcSliceH": ["srcFliceW", "srcSlaseW", "srcSlashRH", "srcFliceRH", "srcSliceRH", "srcSliceW", "srcSlaceH", "srcFlashH", "srcFliceH", "srcFlashW", "srcFlashRH", "srcFliceY", "srcSlashY", "srcFlashY", "srcSlashH", "srcSlaceY", "srcSlaceW", "srcSlaceRH", "srcSlashW", "srcSlaseH", "srcSlaseRH", "srcSlaseY"], "dst": ["Dsc", "Dsrc", "idst", "Dst", "dsrc", "idrc", "idsrc", " drc", "dsc", " dsc", "Drc", "idsc", " dsrc", "drc"], "dstStride": ["dstShride", "dstDestide", "dstStrite", "dscStride", "dscDestride", "dstStide", "dstStause", "dstDestrite", "dstShause", "dscDestide", "dstScause", "dstScride", "dscStause", "dstShrite", "dscStrite", "dstScrite", "dstDestride", "dscStide", "dscDestrite", "dstDestause", "dscDestause", "dstShide", "dstScide"], "vLumFilterPos": ["vLumbFilterPos", "vLumbFilePos", "vLumeFilterRef", "vLumHeaderEx", "vLumbFilterEx", "vLumListenerLen", "vLumFeatureEx", "vLumMaskEx", "vLumListenerEx", "vLumbFileEx", "vLumFileEx", "vLumHeaderOff", "vLumeHeaderPos", "vLumLayerOff", "vLumFeaturePosition", "vLumFilterRef", "vLumbFilterPosition", "vLumFilePos", "vLumMaskPos", "vLumFeatureLen", "vLumeHeaderOff", "vLumLayerRef", "vLumbFilePosition", "vLumeFilterOff", "vLumbFileLen", "vLumFilterOff", "vLumListenerPos", "vLumeFilterPos", "vLumLayerPos", "vLumbFilterLen", "vLumMaskOff", "vLumHeaderPos", "vLumMaskRef", "vLumFileLen", "vLumFilterEx", "vLumeHeaderEx", "vLumeFilterEx", "vLumFilterLen", "vLumHeaderRef", "vLumListenerPosition", "vLumeHeaderRef", "vLumFilePosition", "vLumLayerEx", "vLumFilterPosition", "vLumFeaturePos"], "vChrFilterPos": ["vChrFPosition", "vChmFilterOffset", "vChrLimitPosition", "vChrFlowOffset", "vChmFilterpos", "vChrFilterPref", "vChmFilterPosition", "vChrFilterOffset", "vChrtFeaturePosition", "vChmFPos", "vChrFilPosition", "vChrFeaturePref", "vChrLimitPos", "vChmFpos", "vChmFPosition", "vChrtFeaturePos", "vChrLimitOffset", "vChrFOffset", "vChrtFilterPref", "vChrFlowPos", "vChrFilpos", "vChrFeaturepos", "vChrtFilterPos", "vChrFilterPosition", "vChrFeaturePosition", "vChrFpos", "vChrFlowPosition", "vChmFOffset", "vChrtFeaturepos", "vChrFlowpos", "vChrtFeaturePref", "vChrFeaturePos", "vChrFPos", "vChrFilPos", "vChrFPref", "vChrFilterpos", "vChmFilterPos", "vChrLimitpos", "vChrtFilterpos", "vChrtFilterPosition", "vChrFilPref"], "hLumFilterPos": ["hLumFilterSe", "hLumFilterpos", "hLmFilterPos", "hLumFileSe", "hLmFileP", "hLumReaderPos", "hLumContentpos", "hLumFilterMin", "hLumFileP", "hLmFilterSe", "hLumManagerPosition", "hLumContentP", "hLumReaderP", "hLumFilePosition", "hLumReaderPosition", "hLumManagerPos", "hLumFilterP", "hLmFilterpos", "hLumFilepos", "hLumLimitMin", "hLumFilterPosition", "hLmFilePosition", "hLumReaderpos", "hLmFilePos", "hLumLimitSe", "hLumContentPosition", "hLmFilterP", "hLmFilterPosition", "hLumContentPos", "hLumManagerMin", "hLmFileSe", "hLmFilterMin", "hLmFileMin", "hLumFilePos", "hLumLimitPos", "hLumLimitPosition", "hLumFileMin", "hLumManagerSe", "hLmFilepos"], "hChrFilterPos": ["hChrControlpos", "hChrControlStart", "hChrSelectPos", "hChrFilterLoc", "hChrtHandlerpos", "hChlMaskScan", "hChlMaskPo", "hChrFilterScan", "hChrFilterpos", "hChrtFilterpos", "hChlFilterLoc", "hChrHandlerPos", "hChrFilterStart", "hChrFlowEx", "hChrControlPos", "hChrFactorLoc", "hChrFilterPo", "hChrSelectScan", "hChrHandlerStart", "hChrSelectLoc", "hChrMaskPo", "hChrFlowStart", "hChlMaskLoc", "hChrtHandlerPos", "hChrFactorPo", "hChrFactorScan", "hChrtFilterPos", "hChrtHandlerEx", "hChlFilterPo", "hChrMaskLoc", "hChrMaskScan", "hChrSelectPo", "hChrtHandlerStart", "hChrMaskPos", "hChrtFilterStart", "hChlFilterScan", "hChrFilterEx", "hChlMaskPos", "hChrControlEx", "hChlFilterPos", "hChrFactorPos", "hChrFlowPos", "hChrHandlerpos", "hChrtFilterEx", "hChrFlowpos", "hChrHandlerEx"], "vLumFilter": ["vLumerFilter", "vBlumbFilter", "vLumbName", "vLumbHandler", "vLumHandler", "vLawHandler", "vPlumbLayer", "vPlumbName", "vBlumbHandler", "vPlumbLimit", "vLUMLimit", "vBlumFilter", "vLawFil", "vLUMFilter", "vBlumLimit", "vPlumLimit", "vLumbFil", "vPlumLayer", "vPlumFilter", "vLumerName", "vLumName", "vLumbLimit", "vLumLimit", "vLamLimit", "vBlumbLimit", "vPlumbFilter", "vLumLayer", "vLumbFilter", "vBlumbFil", "vPlumName", "vLamName", "vLamFilter", "vLUMFil", "vLumerLayer", "vLumerLimit", "vLawLimit", "vLUMHandler", "vBlumHandler", "vLumbLayer", "vLamLayer", "vLumFil", "vLawFilter", "vBlumFil"], "vChrFilter": ["vPhrcSort", "vChrFill", "vSchrSort", "vSchrbResult", "vSchrbSort", "vChrcMask", "vSchrFilter", "vChrcRule", "vChrtRule", "vChrcFill", "vChrbSort", "vPhrSort", "vChrtMask", "vSchrbFilter", "vPhrcMask", "vChrcFilter", "vChnrFilter", "vSchrResult", "vChrbFill", "vChtRule", "vPhrFilter", "vChrbFilter", "vChrtFilter", "vChrResult", "vChnrResult", "vSchrbFill", "vPhrRule", "vChrRule", "vChrMask", "vSchrFill", "vChrbResult", "vPhrMask", "vPhrcFilter", "vPhrcRule", "vChrSort", "vChrcSort", "vChrcResult", "vChnrSort", "vChtMask", "vChtSort", "vChnrFill", "vChtFilter", "vChrtSort"], "hLumFilter": ["hClumFilter", "hClumfilter", "hLrumFilter", "hLmUrl", "hLemFilter", "hLumSelect", "hMumaUrl", "hLumifilter", "hLmSelect", "hClumifilter", "hLumaFilter", "hLumFl", "hClumiFilter", "hLumiFl", "hLumiFilter", "hLUMfilter", "hLrumSort", "hLmFilter", "hClumiFl", "hLmSort", "hLumUrl", "hLUMFl", "hLumaUrl", "hLrumSelect", "hMumaSort", "hLumSort", "hLumaSelect", "hClumFl", "hMumSort", "hLumaSort", "hLUMFilter", "hLemFl", "hLumfilter", "hLemfilter", "hMumFilter", "hLrumUrl", "hMumSelect", "hMumaFilter", "hMumUrl", "hMumaSelect"], "hChrFilter": ["hChrbFilter", "hChrcFilter", "hChrbHandler", "hchrcFilter", "hHrbFilter", "hChrcFactor", "hHrControl", "hChsrRequest", "hchrcFactor", "hChrbFactor", "hChrbControl", "hHrHandler", "hchrFilter", "hChrUser", "hChrbSort", "hChrControl", "hchrcUser", "hChdSort", "hChsrControl", "hChdFactor", "hChrbUser", "hChrRequest", "hChruControl", "hChruRequest", "hChsrHandler", "hChrFactor", "hChrcUser", "hHrbControl", "hChdUser", "hChruFilter", "hChrHandler", "hChsrFilter", "hchrUser", "hchrSort", "hHrFilter", "hChruHandler", "hHrbRequest", "hHrRequest", "hchrcSort", "hchrFactor", "hChrcSort", "hHrbHandler", "hChrbRequest", "hChrSort", "hChdFilter"], "lumMmxFilter": ["lumMxFilter", "lumMexHeader", "lumMaxFilter", "lumMappingFilter", "lumMgrSort", "lumPmxHeader", "lumMaxFile", "lumMxF", "lumLgrLimit", "lumLmxLimit", "lumMappingLimit", "lumPuxFile", "lumPuxFilter", "lumMmxLimit", "lumMmxF", "lumPmxFile", "lumLgrF", "lumMaxHeader", "lumPmxFilter", "lumMgrLimit", "lumMmxSort", "lumMmxHeader", "lumMexFilter", "lumMuxFile", "lumPuxHeader", "lumLgrSort", "lumMappingSort", "lumMappingF", "lumMmxFile", "lumMexFile", "lumLmxSort", "lumMxLimit", "lumMgrF", "lumLmxF", "lumMuxFilter", "lumMuxHeader", "lumMxSort", "lumLmxFilter", "lumLgrFilter", "lumMgrFilter"], "chrMmxFilter": ["chrMoverLayer", "chrLexProfile", "chrMaxFilter", "chrMaxConfig", "chrMexLayer", "chrMmxF", "chrLexF", "chrMoverFilter", "chrMexProfile", "chrRmxF", "chrMmxProfile", "chrRexLayer", "chrRmxLayer", "chrLexConfig", "chrMixConfig", "chrMappingConfig", "chrMexConfig", "chrMappingF", "chrLmxF", "chrMappingFilter", "chrRexF", "chrMappingProfile", "chrMixF", "chrLmxFilter", "chrMixProfile", "chrMmxConfig", "chrMixFilter", "chrMoverConfig", "chrMmxLayer", "chrRexFilter", "chrLmxConfig", "chrRmxFilter", "chrLmxProfile", "chrLexFilter", "chrMexFilter", "chrRexConfig", "chrMexF", "chrMaxLayer", "chrMaxF", "chrRmxConfig", "chrMoverF"], "lumPixBuf": ["lumPixBuffmp", "lumPixDuff", "lumPixAuf", "lumPngBuff", "lumPixAum", "lumPexCuff", "lumPngBum", "lumPixBuffof", "lumPixDmp", "lumPixLuff", "lumPixDuf", "lumPexCuf", "lumPexBuf", "lumPixLum", "lumPexCmp", "lumPexBmp", "lumPixAuff", "lumPixCuf", "lumPixBum", "lumPixBlu", "lumPixLuf", "lumPixCmp", "lumPngBuf", "lumPixAlu", "lumPixBof", "lumPexBuff", "lumPixCof", "lumPexCof", "lumPixDof", "lumPixBuffuf", "lumPixBmp", "lumPixBuff", "lumPixLlu", "lumPixCuff", "lumPixBuffuff", "lumPexBof", "lumPngBlu"], "chrPixBuf": ["chrPixBomp", "chrPxBust", "chrPixBouf", "chrPixelsMob", "chrPixelsMuf", "chrPixAust", "chrPixelsBuf", "chrPixBundle", "chrPixBouff", "chrPixelsBump", "chrPixBuff", "chrPixBump", "chrPixBuffump", "chrPixBob", "chrPixelsMundle", "chrPixLuff", "chrPixLust", "chrPixBuffob", "chrPxAust", "chrPixAuff", "chrPxBuff", "chrPixMuf", "chrPixelsBob", "chrPixelsMump", "chrPixLuf", "chrPixelsBundle", "chrPixBmp", "chrPixLmp", "chrPixBust", "chrPixMundle", "chrPxAuf", "chrPxBmp", "chrPixAmp", "chrPixMob", "chrPxAuff", "chrPxAmp", "chrPixBuffuf", "chrPixBuffundle", "chrPixAuf", "chrPixBoust", "chrPixMump", "chrPxBuf"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n", "idx": 13205, "substitutes": {"dst": ["Dsrc", "dsts", "lst", "cdsts", "Dst", "dsrc", " drc", "Dsts", "ssts", "bsc", "lsts", "Dconst", " dconst", "lrc", "bsrc", "sconst", "cdst", "bst", "cdsc", "dconst", " dsrc", "sst", "drc", "lconst", "bsts", "cdsrc", "dsc", " dsc", " dsts"], "src": ["stack", "storage", "sync", "enc", "ctr", "gl", "tmp", "impl", "cont", "reflect", "source", "sc", "st", "dist", "fl", "rest", "cb", "sel", "scl", "rob", "sur", "SOURCE", "flash", "transform", "pack", "ssl", "sq", "inst", "sn", "seq", "url", "rc", "config", "supp", "sub", "proc", "rb", "rib", "sup", "iv", "ctx", "cur", "rect", "http", "conv", "secure", "lib", "sl", "sr", "sb", "gb", "buf", "sth", "text", "loc", "img", "dest", "support", "cv"], "unused": ["unferred", "Unchecked", "nonuse", "nonferred", "Unferred", "unuse", " unchecked", "nonchecked", " unferred", " unuse", "unchecked", "Unuse", "Unused", "nonused"], "i": ["adi", "anti", "it", "d", "ie", "di", "o", "gi", "ini", "iu", "fi", "t", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "hei", "ai", "ui", "m", "iii", "api", "ti", "g", "k", "ix", "z", "n", "ci", "id", "io", "bi", "qi", "ip", "phi", "x", "c", "info", "oi", "hi", "p", "index", "ri", "cli", "b", "s", "ni", "f", "start", "zi", "j", "r", "ii", "is", "at", "ami", "I"]}}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n", "idx": 13230, "substitutes": {"block": ["batch", "address", "check", "filter", "data", "image", "end", "length", "base", "bin", "blocks", "condition", "header", "object", "group", "limit", "label", "frame", "BL", "unit", "error", "Block", "lock", "id", "node", "ip", "box", "x", "clean", "set", "off", "cl", "type", "col", "index", "one", "table", "tx", "row", "name", "start", "buffer", "clock", "chain", "none", "number", "pack", "null"], "i": ["it", "d", "di", "gi", "my", "ini", "mi", "iu", "fi", "data", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "oi", "uri", "si", "vi", "in", "ai", "ui", "iii", "api", "a", "ti", "ix", "eni", "io", "id", "ci", "bi", "qi", "ip", "x", "phi", "h", "hi", "info", "c", "p", "index", "ri", "b", "ni", "f", "start", "zi", "j", "r", "ii", "ami", "I"]}}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n", "idx": 13236, "substitutes": {"ohci": [" ohpi", "ihcci", "ehc", "ahpi", "ehlc", "ehcm", "ehsc", "ovc", "ahdi", "ehpi", "ehcci", "ohc", "odci", "ovco", "odcci", "ahcm", "ahsc", "ohco", "ihco", "odcu", "ohlc", " ohdi", " ohco", "ahci", "ohcu", "ahcci", "odco", " ohcm", "ovci", "ehci", "ahsi", "ihci", "ohcm", "ahc", "ehco", "ahco", "ihcu", "ovlc", " ohcci", "ohdi", "ahlc", " ohsi", "ehsi", "ohcci", "ohsi", "ohpi", " ohsc", "ehdi", " ohcu", "ohsc"], "dev": ["orig", "d", "di", "app", "ev", "der", "priv", " device", " priv", "data", "user", "reader", "md", "v", "private", "dist", "DEV", "pub", "desc", "ov", "wd", "conn", "def", "develop", "ow", "die", "group", "inst", "valid", "hw", "error", "Dev", "rad", "block", "gu", "iv", "home", "development", "dem", "device", "dd", "od", "ver", "prop", "name", "brand", "diff", "adv", "av", "loader", "gd", "conf", "var", "ad", "kind"]}}
{"project": "FFmpeg", "commit_id": "fd0f45e58b010c0d7049914a392c3e96a2223107", "target": 1, "func": "static int av_encode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     AVFormatContext **input_files,\n\n                     int nb_input_files,\n\n                     AVStreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    AVOutputStream *ost, **ost_table = NULL;\n\n    AVInputStream *ist, **ist_table = NULL;\n\n    AVInputFile *file_table;\n\n    AVFormatContext *stream_no_data;\n\n    int key;\n\n\n\n    file_table= (AVInputFile*) av_mallocz(nb_input_files * sizeof(AVInputFile));\n\n    if (!file_table)\n\n        goto fail;\n\n\n\n    /* input stream init */\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        file_table[i].ist_index = j;\n\n        file_table[i].nb_streams = is->nb_streams;\n\n        j += is->nb_streams;\n\n    }\n\n    nb_istreams = j;\n\n\n\n    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));\n\n    if (!ist_table)\n\n        goto fail;\n\n    \n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = av_mallocz(sizeof(AVInputStream));\n\n        if (!ist)\n\n            goto fail;\n\n        ist_table[i] = ist;\n\n    }\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        for(k=0;k<is->nb_streams;k++) {\n\n            ist = ist_table[j++];\n\n            ist->st = is->streams[k];\n\n            ist->file_index = i;\n\n            ist->index = k;\n\n            ist->discard = 1; /* the stream is discarded by default\n\n                                 (changed later) */\n\n\n\n            if (ist->st->codec.rate_emu) {\n\n                ist->start = av_gettime();\n\n                ist->frame = 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n        \n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > file_table[fi].nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            exit(1);\n\n        }\n\n    }\n\n    \n\n    ost_table = av_mallocz(sizeof(AVOutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = av_mallocz(sizeof(AVOutputStream));\n\n        if (!ost)\n\n            goto fail;\n\n        ost_table[i] = ost;\n\n    }\n\n    \n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++) {\n\n            int found;\n\n            ost = ost_table[n++];\n\n            ost->file_index = k;\n\n            ost->index = i;\n\n            ost->st = os->streams[i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = file_table[stream_maps[n-1].file_index].ist_index + \n\n                    stream_maps[n-1].stream_index;\n\n                    \n\n                /* Sanity check that the stream types match */\n\n                if (ist_table[ost->source_index]->st->codec.codec_type != ost->st->codec.codec_type) {\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n-1].file_index, stream_maps[n-1].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    exit(1);\n\n                }\n\n                \n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for(j=0;j<nb_istreams;j++) {\n\n                    ist = ist_table[j];\n\n                    if (ist->discard && \n\n                        ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                        ost->source_index = j;\n\n                        found = 1;\n\n                    }\n\n                }\n\n                \n\n                if (!found) {\n\n                    /* try again and reuse existing stream */\n\n                    for(j=0;j<nb_istreams;j++) {\n\n                        ist = ist_table[j];\n\n                        if (ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = ist_table[ost->source_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        ist = ist_table[ost->source_index];\n\n\n\n        codec = &ost->st->codec;\n\n        icodec = &ist->st->codec;\n\n\n\n        if (ost->st->stream_copy) {\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n            codec->codec_tag = icodec->codec_tag;\n\n            codec->bit_rate = icodec->bit_rate;\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                codec->frame_rate = icodec->frame_rate;\n\n                codec->frame_rate_base = icodec->frame_rate_base;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n        } else {\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                if (fifo_init(&ost->fifo, 2 * MAX_AUDIO_PACKET_SIZE))\n\n                    goto fail;\n\n                \n\n                if (codec->channels == icodec->channels &&\n\n                    codec->sample_rate == icodec->sample_rate) {\n\n                    ost->audio_resample = 0;\n\n                } else {\n\n                    if (codec->channels != icodec->channels &&\n\n                        icodec->codec_id == CODEC_ID_AC3) {\n\n                        /* Special case for 5:1 AC3 input */\n\n                        /* and mono or stereo output      */\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                        if (codec->sample_rate == icodec->sample_rate)\n\n                            ost->audio_resample = 0;\n\n                        else {\n\n                            ost->audio_resample = 1;\n\n                            ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\t    if(!ost->resample)\n\n\t\t\t      {\n\n\t\t\t\tprintf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t\tav_abort();\n\n\t\t\t      }\n\n                        }\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                    } else {\n\n                        ost->audio_resample = 1; \n\n                        ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\tif(!ost->resample)\n\n\t\t\t  {\n\n\t\t\t    printf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t    av_abort();\n\n\t\t\t  }\n\n                    }\n\n                }\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                if (codec->width == icodec->width &&\n\n                    codec->height == icodec->height &&\n\n                    frame_topBand == 0 &&\n\n                    frame_bottomBand == 0 &&\n\n                    frame_leftBand == 0 &&\n\n                    frame_rightBand == 0)\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 0;\n\n                } else if ((codec->width == icodec->width -\n\n                                (frame_leftBand + frame_rightBand)) &&\n\n                        (codec->height == icodec->height -\n\n                                (frame_topBand  + frame_bottomBand)))\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 1;\n\n                    ost->topBand = frame_topBand;\n\n                    ost->leftBand = frame_leftBand;\n\n                } else {\n\n                    uint8_t *buf;\n\n                    ost->video_resample = 1;\n\n                    ost->video_crop = 0; // cropping is handled as part of resample\n\n                    buf = av_malloc((codec->width * codec->height * 3) / 2);\n\n                    if (!buf)\n\n                        goto fail;\n\n                    ost->pict_tmp.data[0] = buf;\n\n                    ost->pict_tmp.data[1] = ost->pict_tmp.data[0] + (codec->width * codec->height);\n\n                    ost->pict_tmp.data[2] = ost->pict_tmp.data[1] + (codec->width * codec->height) / 4;\n\n                    ost->pict_tmp.linesize[0] = codec->width;\n\n                    ost->pict_tmp.linesize[1] = codec->width / 2;\n\n                    ost->pict_tmp.linesize[2] = codec->width / 2;\n\n\n\n                    ost->img_resample_ctx = img_resample_full_init( \n\n                                      ost->st->codec.width, ost->st->codec.height,\n\n                                      ist->st->codec.width, ist->st->codec.height,\n\n                                      frame_topBand, frame_bottomBand,\n\n                                      frame_leftBand, frame_rightBand);\n\n                }\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && \n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n                int size;\n\n                char *logbuffer;\n\n                \n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\", \n\n                         pass_logfilename ? \n\n                         pass_logfilename : DEFAULT_PASS_LOGFILENAME, i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"w\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    /* read the log file */\n\n                    f = fopen(logfilename, \"r\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    fseek(f, 0, SEEK_END);\n\n                    size = ftell(f);\n\n                    fseek(f, 0, SEEK_SET);\n\n                    logbuffer = av_malloc(size + 1);\n\n                    if (!logbuffer) {\n\n                        fprintf(stderr, \"Could not allocate log buffer\\n\");\n\n                        exit(1);\n\n                    }\n\n                    fread(logbuffer, 1, size, f);\n\n                    fclose(f);\n\n                    logbuffer[size] = '\\0';\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    fprintf(stderr, \"Stream mapping:\\n\");\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\\n\",\n\n                ist_table[ost->source_index]->file_index,\n\n                ist_table[ost->source_index]->index,\n\n                ost->file_index, \n\n                ost->index);\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_encoder(ost->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec for output stream #%d.%d\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ost->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_decoder(ist->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec (id=%d) for input stream #%d.%d\\n\", \n\n                        ist->st->codec.codec_id, ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ist->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for input stream #%d.%d\\n\", \n\n                        ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            //if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO)\n\n            //    ist->st->codec.flags |= CODEC_FLAG_REPEAT_FIELD;\n\n            ist->frame_decoded = 1;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n\tis = input_files[ist->file_index];\n\n        ist->pts = 0;\n\n        if (ist->decoding_needed) {\n\n            switch (ist->st->codec.codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.sample_rate);\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.frame_rate);\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    \n\n    /* compute buffer size max (should use a complete heuristic) */\n\n    for(i=0;i<nb_input_files;i++) {\n\n        file_table[i].buffer_size_max = 2048;\n\n    }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (av_write_header(os) < 0) {\n\n            fprintf(stderr, \"Could not write header for output file #%d (incorrect codec paramters ?)\\n\", i);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#ifndef CONFIG_WIN32\n\n    if ( !using_stdin )\n\n        fprintf(stderr, \"Press [q] to stop encoding\\n\");\n\n#endif\n\n    term_init();\n\n\n\n    stream_no_data = 0;\n\n    key = -1;\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        uint8_t *ptr;\n\n        int len;\n\n        uint8_t *data_buf;\n\n        int data_size, got_picture;\n\n        AVPicture picture;\n\n        short samples[AVCODEC_MAX_AUDIO_FRAME_SIZE / 2];\n\n        void *buffer_to_free;\n\n        double pts_min;\n\n        \n\n    redo:\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        pts_min = 1e10;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double pts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = ist_table[ost->source_index];\n\n            pts = (double)ost->st->pts.val * os->pts_num / os->pts_den;\n\n            if (!file_table[ist->file_index].eof_reached && \n\n                pts < pts_min) {\n\n                pts_min = pts;\n\n                file_index = ist->file_index;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            break;\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time > 0 && pts_min >= (recording_time / 1000000.0))\n\n            break;\n\n\n\n        /* read a packet from it and output it in the fifo */\n\n        is = input_files[file_index];\n\n        if (av_read_packet(is, &pkt) < 0) {\n\n            file_table[file_index].eof_reached = 1;\n\n            continue;\n\n        }\n\n        if (!pkt.size) {\n\n            stream_no_data = is;\n\n        } else {\n\n            stream_no_data = 0;\n\n        }\n\n        if (do_hex_dump) {\n\n            printf(\"stream #%d, size=%d:\\n\", pkt.stream_index, pkt.size);\n\n            av_hex_dump(pkt.data, pkt.size);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= file_table[file_index].nb_streams)\n\n            goto discard_packet;\n\n        ist_index = file_table[file_index].ist_index + pkt.stream_index;\n\n        ist = ist_table[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        // printf(\"read #%d.%d size=%d\\n\", ist->file_index, ist->index, pkt.size);\n\n\n\n        len = pkt.size;\n\n        ptr = pkt.data;\n\n        while (len > 0) {\n\n            /* decode the packet if needed */\n\n            data_buf = NULL; /* fail safe */\n\n            data_size = 0;\n\n            if (ist->decoding_needed) {\n\n                /* NOTE1: we only take into account the PTS if a new\n\n                   frame has begun (MPEG semantics) */\n\n                /* NOTE2: even if the fraction is not initialized,\n\n                   av_frac_set can be used to set the integer part */\n\n                if (ist->frame_decoded) { \n\n                    /* If pts is unavailable -- we have to use synthetic one */\n\n                    if( pkt.pts != AV_NOPTS_VALUE )\n\n                    {\n\n                        ist->pts = ist->next_pts.val = pkt.pts;\n\n                    }\n\n                    else\n\n                    {\n\n                        ist->pts = ist->next_pts.val;\n\n                    }\n\n                    ist->frame_decoded = 0;\n\n                }\n\n\n\n                switch(ist->st->codec.codec_type) {\n\n                case CODEC_TYPE_AUDIO:\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                    ret = avcodec_decode_audio(&ist->st->codec, samples, &data_size,\n\n                                               ptr, len);\n\n                    if (ret < 0)\n\n                        goto fail_decode;\n\n                    /* Some bug in mpeg audio decoder gives */\n\n                    /* data_size < 0, it seems they are overflows */\n\n                    if (data_size <= 0) {\n\n                        /* no audio frame */\n\n                        ptr += ret;\n\n                        len -= ret;\n\n                        continue;\n\n                    }\n\n                    data_buf = (uint8_t *)samples;\n\n\t\t    av_frac_add(&ist->next_pts, \n\n\t\t\t        is->pts_den * data_size / (2 * ist->st->codec.channels));\n\n                    break;\n\n                case CODEC_TYPE_VIDEO:\n\n                    {\n\n                        AVFrame big_picture;\n\n\n\n                        data_size = (ist->st->codec.width * ist->st->codec.height * 3) / 2;\n\n                        ret = avcodec_decode_video(&ist->st->codec, \n\n                                                   &big_picture, &got_picture, ptr, len);\n\n                        picture= *(AVPicture*)&big_picture;\n\n                        ist->st->quality= big_picture.quality;\n\n                        if (ret < 0) {\n\n                        fail_decode:\n\n                            fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                                    ist->file_index, ist->index);\n\n                            av_free_packet(&pkt);\n\n                            goto redo;\n\n                        }\n\n                        if (!got_picture) {\n\n                            /* no picture yet */\n\n                            ptr += ret;\n\n                            len -= ret;\n\n                            continue;\n\n                        }\n\n                        av_frac_add(&ist->next_pts, \n\n\t\t\t            is->pts_den * ist->st->codec.frame_rate_base);          \n\n                    }\n\n                    break;\n\n                default:\n\n                    goto fail_decode;\n\n                }\n\n            } else {\n\n                data_buf = ptr;\n\n                data_size = len;\n\n                ret = len;\n\n            }\n\n            ptr += ret;\n\n            len -= ret;\n\n\n\n            buffer_to_free = 0;\n\n            if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n                pre_process_video_frame(ist, &picture, &buffer_to_free);\n\n            }\n\n\n\n            ist->frame_decoded = 1;\n\n\n\n            /* frame rate emulation */\n\n            if (ist->st->codec.rate_emu) {\n\n                int64_t pts = av_rescale((int64_t) ist->frame * ist->st->codec.frame_rate_base, 1000000, ist->st->codec.frame_rate);\n\n                int64_t now = av_gettime() - ist->start;\n\n                if (pts > now)\n\n                    usleep(pts - now);\n\n\n\n                ist->frame++;\n\n            }\n\n\n\n#if 0\n\n            /* mpeg PTS deordering : if it is a P or I frame, the PTS\n\n               is the one of the next displayed one */\n\n            /* XXX: add mpeg4 too ? */\n\n            if (ist->st->codec.codec_id == CODEC_ID_MPEG1VIDEO) {\n\n                if (ist->st->codec.pict_type != B_TYPE) {\n\n                    int64_t tmp;\n\n                    tmp = ist->last_ip_pts;\n\n                    ist->last_ip_pts  = ist->frac_pts.val;\n\n                    ist->frac_pts.val = tmp;\n\n                }\n\n            }\n\n#endif\n\n            /* transcode raw format, encode packets and output them */\n\n\n\n            for(i=0;i<nb_ostreams;i++) {\n\n                int frame_size;\n\n\n\n                ost = ost_table[i];\n\n                if (ost->source_index == ist_index) {\n\n                    os = output_files[ost->file_index];\n\n\n\n#if 0\n\n                    printf(\"%d: got pts=%f %f\\n\", i, pkt.pts / 90000.0, \n\n                           (ist->pts - ost->st->pts.val) / 90000.0);\n\n#endif\n\n                    /* set the input output pts pairs */\n\n                    ost->sync_ipts = (double)ist->pts * is->pts_num / \n\n                        is->pts_den;\n\n                    /* XXX: take into account the various fifos,\n\n                       in particular for audio */\n\n                    ost->sync_opts = ost->st->pts.val;\n\n                    //printf(\"ipts=%lld sync_ipts=%f sync_opts=%lld pts.val=%lld pkt.pts=%lld\\n\", ist->pts, ost->sync_ipts, ost->sync_opts, ost->st->pts.val, pkt.pts); \n\n\n\n                    if (ost->encoding_needed) {\n\n                        switch(ost->st->codec.codec_type) {\n\n                        case CODEC_TYPE_AUDIO:\n\n                            do_audio_out(os, ost, ist, data_buf, data_size);\n\n                            break;\n\n                        case CODEC_TYPE_VIDEO:\n\n                            /* find an audio stream for synchro */\n\n                            {\n\n                                int i;\n\n                                AVOutputStream *audio_sync, *ost1;\n\n                                audio_sync = NULL;\n\n                                for(i=0;i<nb_ostreams;i++) {\n\n                                    ost1 = ost_table[i];\n\n                                    if (ost1->file_index == ost->file_index &&\n\n                                        ost1->st->codec.codec_type == CODEC_TYPE_AUDIO) {\n\n                                        audio_sync = ost1;\n\n                                        break;\n\n                                    }\n\n                                }\n\n\n\n                                do_video_out(os, ost, ist, &picture, &frame_size, audio_sync);\n\n                                if (do_vstats && frame_size)\n\n                                    do_video_stats(os, ost, frame_size);\n\n                            }\n\n                            break;\n\n                        default:\n\n                            av_abort();\n\n                        }\n\n                    } else {\n\n                        AVFrame avframe;\n\n                                                \n\n                        /* no reencoding needed : output the packet directly */\n\n                        /* force the input stream PTS */\n\n                        \n\n                        memset(&avframe, 0, sizeof(AVFrame));\n\n                        ost->st->codec.coded_frame= &avframe;\n\n\t\t\tavframe.key_frame = pkt.flags & PKT_FLAG_KEY; \n\n                        \n\n                        av_write_frame(os, ost->index, data_buf, data_size);\n\n\t\t\tost->st->codec.frame_number++;\n\n\t\t\tost->frame_number++;\n\n                    }\n\n                }\n\n            }\n\n            av_free(buffer_to_free);\n\n        }\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n        \n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n    term_exit();\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec.stats_in);\n\n            avcodec_close(&ost->st->codec);\n\n        }\n\n    }\n\n    \n\n    /* close each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(&ist->st->codec);\n\n        }\n\n    }\n\n    \n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n    /* finished ! */\n\n    \n\n    ret = 0;\n\n fail1:\n\n    av_free(file_table);\n\n\n\n    if (ist_table) {\n\n        for(i=0;i<nb_istreams;i++) {\n\n            ist = ist_table[i];\n\n            av_free(ist);\n\n        }\n\n        av_free(ist_table);\n\n    }\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                fifo_free(&ost->fifo); /* works even if fifo is not\n\n                                          initialized but set to zero */\n\n                av_free(ost->pict_tmp.data[0]);\n\n                if (ost->video_resample)\n\n                    img_resample_close(ost->img_resample_ctx);\n\n                if (ost->audio_resample)\n\n                    audio_resample_close(ost->resample);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n fail:\n\n    ret = -ENOMEM;\n\n    goto fail1;\n\n}\n", "idx": 13268, "substitutes": {"output_files": ["output___images", "input_maps", "output___maps", "output_maps", "output_images", "input_images", "output___files", "output___file", "input_file", "output_file"], "nb_output_files": ["nb_outputvfiles", "nb_input_file", "nb_output_file", "nb_outputvfile", "nb_output_groups", "nb_outputvgroups", "nb_output_maps", "nb_outputvmaps", "nb_input_maps", "nb_input_groups"], "input_files": ["fileingfiles", "inputsuploads", "output_models", "input_lines", "inputsgroups", "output_items", "file_images", "inputingmodels", "current_images", "inputinguploads", "file_uploads", "inputingimages", "input_items", "current_files", "input_models", "input_flows", "fileingimages", "inputingitems", "inputinggroups", "file_files", "fileinggroups", "current_lines", "inputingfile", "fileinguploads", "input_images", "file_groups", "inputsfiles", "input_uploads", "input_groups", "current_flows", "inputsimages", "input_file", "inputingfiles", "output_file"], "nb_input_files": ["nb_input_images", "nb_outputsiles", "nb_inputablefile", "nb_inputityfiles", "nb_inputschildren", "nb_output_objects", "nb_outputsfiles", "nb_input_file", "nb_inputsfiles", "nb_input_steps", "nb_output_file", "nb_output_thumbnails", "nb_inputityfile", "nb_inputablemodels", "nb_inputsfile", "nb_input2models", "nb_input_thumbnails", "nb_inputableiles", "nb_outputsfile", "nb_input2objects", "nb_input_objects", "nb_inputingfile", "nb_inputingfiles", "nb_inputingmodels", "nb_output_models", "nb_input_models", "nb_output_children", "nb_inputsiles", "nb_inputablefiles", "nb_inputitychildren", "nb_output_iles", "nb_input2file", "nb_input_children", "nb_input_iles", "nb_inputablechildren", "nb_input2thumbnails", "nb_input2images", "nb_output_images", "nb_inputingthumbnails", "nb_outputschildren", "nb_output_steps", "nb_inputablesteps", "nb_input2files", "nb_inputityiles"], "stream_maps": [" stream_devices", "stream_devices", "stream_map", " stream_map"], "nb_stream_maps": ["nb_streamsfiles", "nb_streamsmap", "nb_stream_map", "nb_channel_map", "nb_channel_maps", "nb_stream_files", "nb_streamsmaps", "nb_channel_files"], "ret": ["en", "ru", "bl", "J", "all", "du", "resp", "match", "result", "feat", "val", "res", " RET", "fun", "rc", "num", "reg", "rec", "mem", "N", "status", "RET", "Ret", " success"], "i": ["it", "anti", "d", "ie", "di", "o", "my", "gi", "ini", "iu", "mi", "fi", "t", "v", "im", "li", "e", "u", "xi", "inner", "l", "pi", "uri", "si", "y", "in", "ai", "m", "ui", "api", "a", "lc", "ti", "z", "ix", "eni", "ik", "ci", "id", "io", "bi", "init", "qi", "x", "ip", "phi", "info", "c", "ki", "p", "index", "ri", "ji", "b", "s", "ni", "zi", "ori", "ii", "I", "yi"], "j": ["it", "adj", "d", "ie", "o", "json", "dj", "jam", "J", "jp", "v", "li", "jl", "br", "e", "obj", "l", "job", "note", "y", "m", "jo", "jen", "aj", "g", "z", "jj", "jet", "eni", "ch", "ci", "kj", "x", "q", "h", "ij", "ji", "p", "index", "syn", "b", "start", "name", "ind", "w", "oj", "uj", "je", "ii", "r", "jit", "t", "ja", "jc"], "k": ["o", "ky", "ok", "v", "kick", "u", "ask", "l", "work", "kn", "y", "in", "dk", "m", "ek", "unk", "ke", "g", "ck", "ks", "z", "ik", "ch", "id", "tk", "K", "x", "q", "h", "c", "uk", "kk", "ki", "p", "ak", "km", "b", "kw", "th", "kh", "w", "ko", "ku", "mk", "ka", "sk"], "n": ["d", "o", "nn", "pn", "nt", "e", "nc", "u", "l", "y", "m", "nr", "sn", "num", "g", "z", "np", "nb", "N", "c", "ns", "p", "b", "ni", "w", "nl", "t"], "is": ["ps", "it", "ie", "us", "app", "ins", "list", "x", "ar", "im", "kit", "cs", "image", "ois", "its", "l", "ib", "pi", "uri", "isi", "Is", "so", "in", "isl", "ai", "se", "lis", "api", "isa", "a", "bs", "are", "es", "ils", "iso", "ch", "id", "iss", "iv", "ci", "init", "ip", "vs", "ish", "ists", "info", "iris", "s", "p", "core", "ri", "isc", "ic", "il", "has", "ir", "as", "or", "ics", "js", "ais", "inn", "las", "IS", "ii", "ris", "bis"], "os": ["enc", "o", "oper", "oc", "ol", "op", "pos", "ois", "pc", "sys", "ocol", "oss", "osi", "io", "ot", "so", "ast", "od", "co", "OS", "as", "ms", "or", "ops", "oa"], "codec": ["codenc", "codeef", "codef", "Coderer", "pedec", "genenc", "codeenc", "oderer", "coderer", "cdef", "pedEC", "cdpc", "codeec", "cdec", "cdenc", "odec", "codEC", "Codef", "Codec", "CodEC", "genec", "genef", "codpc", "pederer", "odef", "odEC", "pedef", "genpc", "codepc"], "icodec": ["icODesc", "acodEC", "acODec", "acodel", "icODEC", "icodeesc", "acodec", "icodeec", "icodEC", "acodesc", "icodedEC", "icodeel", "icodedel", "icodedesc", "acODesc", "acODEC", "icODec", "acODel", "icodesc", "icodeEC", "icodel", "icODel", "icodedec"], "ost": ["et", "ct", "dr", "alist", "oc", "nt", "dist", "op", "pt", "rest", "oss", "inst", "host", "tt", "est", "ess", "ot", "art", "ast", "od", "ont", "src", "ind", "ace", "irst", "ad"], "ost_table": ["ost_tab", "ist_tab", "ist_cache", "ist__table", "ost_cache", "ist__map", "ost_map", "ist__tab", "ist_map", "ist__cache"], "ist": ["it", "part", "et", "artist", "ft", "test", "hop", "dr", "xt", "alist", "list", "iste", "data", "jp", "ust", "dist", "pt", "ism", "feat", "rest", "act", "ld", "force", "ht", "att", "isi", "pect", "ans", "gest", "wp", "IST", "state", "adder", "inst", "edit", "ert", "point", "osi", "ict", "tt", "ant", "lp", "est", "id", "dit", "ess", "rss", "ists", "ort", "istance", "art", "pse", "tta", "ast", "exist", "p", "set", "mot", "kt", "ind", "er", "back", "ace", "std", "at", "pick", "irst", "ad", "asi"], "ist_table": ["istendict", "pick_table", "ism_table", "ist_list", "ist_TABLE", "dist_tab", "ist_family", "ism_TABLE", "picksdict", "port_family", "iststable", "dist_index", "pickstable", "ism_count", "dist_list", "istentree", "ist_count", "iststree", "ist_rule", "ist_code", "dist_header", "istscache", "pick_cache", "ist_header", "ist_dict", "pick_tree", "port_tab", "port_table", "pickscache", "istsdict", "istencache", "istentable", "dist_code", "ist_tab", "ist_cache", "ism_tree", "port_rule", "pickstree", "dist_cache", "pick_dict", "dist_table", "ist_tree"], "file_table": ["input_buffer", "progress_template", "fileingbuffer", "fileingindex", "fileingtable", "progressertab", "fileptable", "progress_table", "file_list", "fileingtab", "filepmodule", "progressertree", "fileertable", "fileingsession", "file_template", "fileingcache", "file_buffer", "filepfile", "wordingtree", "progressertemplate", "word_session", "progress_tree", "progressertable", "filepcache", "wordingsession", "file_tree", " file_list", "progress_tab", "fileertemplate", " file_file", "input_table", "fileertree", "wordingtable", "fileertab", "file_tab", "input_file", "input_tab", "file_module", "input_cache", "input_module", "fileingtree", "file_cache", "word_index", "wordingindex", "file_session", "word_table", "file_file", " file_cache", "word_tree"], "stream_no_data": ["stream_meta_media", "stream_meta_data", "stream_no_cache", "stream_meta_cache", "stream_no_length", "stream_no_media", "stream_meta_length"], "key": ["keys", "J", "jp", "loop", "count", "base", "val", "res", "m", "sec", "seq", "num", "Key", "jj", "id", "ip", "x", "max", "q", "ak", "order", "ver", "start", "row", "ek"], "file_index": ["file_position", "line__position", "file__offset", "file_offset", "filevindex", "file__type", "line__type", "file__position", "filevtype", "line_index", "file_type", "line__offset", "file__index", "line_offset", "filevposition", "line_position", "filevoffset", "line_type", "line__index"], "ist_index": ["ast_name", "ist_name", "ist_id", "ast_id", "ast_index"], "st": ["ct", "ST", "bl", "stress", "St", "ld", "fe", "rest", "be", "end", "ste", "stim", "stand", "play", "gest", "ss", "service", "inst", "stem", "str", "sta", "sts", "fr", "est", "sd", "stop", "stage", "ast", "cl", "sw", "sl", "start", "cr", "leg", "sth", "std", "irst"], "frame": ["period", "trace", "position", "seed", "reset", "thread", "speed", "cycle", "base", "delay", "play", "offset", "unit", "error", "scale", "roll", "fps", "block", "version", "weight", "stage", "cpu", "frames", "load", "sample", "transfer", "clock", "rot"]}}
{"project": "FFmpeg", "commit_id": "f37b2d5a6884c7bea87a6c7454239381449bd637", "target": 1, "func": "int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,\n                                 int bit_size, int sync_extension)\n{\n    GetBitContext gb;\n    int specific_config_bitindex;\n    init_get_bits(&gb, buf, bit_size);\n    c->object_type = get_object_type(&gb);\n    c->sample_rate = get_sample_rate(&gb, &c->sampling_index);\n    c->chan_config = get_bits(&gb, 4);\n    if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels))\n        c->channels = ff_mpeg4audio_channels[c->chan_config];\n    c->sbr = -1;\n    c->ps  = -1;\n    if (c->object_type == AOT_SBR || (c->object_type == AOT_PS &&\n        // check for W6132 Annex YYYY draft MP3onMP4\n        !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F)))) {\n        if (c->object_type == AOT_PS)\n            c->ps = 1;\n        c->ext_object_type = AOT_SBR;\n        c->sbr = 1;\n        c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n        c->object_type = get_object_type(&gb);\n        if (c->object_type == AOT_ER_BSAC)\n            c->ext_chan_config = get_bits(&gb, 4);\n    } else {\n        c->ext_object_type = AOT_NULL;\n        c->ext_sample_rate = 0;\n    }\n    specific_config_bitindex = get_bits_count(&gb);\n    if (c->object_type == AOT_ALS) {\n        skip_bits(&gb, 5);\n        if (show_bits_long(&gb, 24) != MKBETAG('\\0','A','L','S'))\n            skip_bits_long(&gb, 24);\n        specific_config_bitindex = get_bits_count(&gb);\n        if (parse_config_ALS(&gb, c))\n            return -1;\n    }\n    if (c->ext_object_type != AOT_SBR && sync_extension) {\n        while (get_bits_left(&gb) > 15) {\n            if (show_bits(&gb, 11) == 0x2b7) { // sync extension\n                get_bits(&gb, 11);\n                c->ext_object_type = get_object_type(&gb);\n                if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&gb)) == 1)\n                    c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n                if (get_bits_left(&gb) > 11 && get_bits(&gb, 11) == 0x548)\n                    c->ps = get_bits1(&gb);\n                break;\n            } else\n                get_bits1(&gb); // skip 1 bit\n        }\n    }\n    //PS requires SBR\n    if (!c->sbr)\n        c->ps = 0;\n    //Limit implicit PS to the HE-AACv2 Profile\n    if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01)\n        c->ps = 0;\n    return specific_config_bitindex;\n}", "idx": 13273, "substitutes": {"c": ["enc", "ct", "d", "cu", "cn", "oc", "t", "v", "cm", "tc", "sc", "cs", "con", "bc", "C", "e", "nc", "cd", "cit", "cf", "l", "pc", "icc", "u", "cb", "ec", "cc", "dc", "m", "uc", "lc", "config", "cca", "g", "rc", "k", "z", "ac", "vc", "ci", "ch", "ce", "cur", "ctx", "cache", "x", "h", "cp", "s", "p", "cl", "b", "cy", "coll", "co", "ic", "ctrl", "f", "arc", "cr", "mc", "ca", "w", "r", "xc", "conf"], "buf": ["fp", "bm", "batch", "alloc", "fi", "uf", "v", "loop", "br", "bc", " buffer", "ff", "cf", "cb", "fb", "queue", "vec", "fd", "seq", "rc", "config", "rb", "ctx", "nb", "mem", "buff", "box", "Buffer", "b", "f", "src", "sb", "port", "Buff", "buffer", "len", "pb", "cv"], "bit_size": ["batch_size", "bit_length", "bit_number", "bitqsize", "bit_rate", "batchqweight", "batch_number", "batch_weight", "bitCrate", "batchqnumber", "bitqrate", " bit_count", "bitCnumber", " bit_length", "batchqsize", "bitCweight", "bitNnumber", "bit_weight", "bitqweight", "batchqrate", "batch_rate", " bit_number", "bitqnumber", "bit_count", "bitNcount", "bitNsize", "bitNlength", "bitCsize"], "sync_extension": [" sync_EXTraction", " sync_extraction", " sync_xtend", " sync_descraction", " sync_descend", " sync_descensions", " sync_xtension", " sync_EXTend", " sync_xtensions", " sync_descension", " sync_extensions", " sync_extend", " sync_xtraction", " sync_EXTension", " sync_EXTensions"], "gb": ["gt", "hub", "git", "cb", " eg", "yg", "GB", "ga", "ui", "rb", "gam", "nb", " rg", " rgb", "bb", "gg", " cc", "sb", "tg", "bo", "Gb", "all", "bf", " gcc", "gm", "pc", "gpu", "db", "gal", "gs", "_", " g", "gin", "usb", "node", "gom", "cod", "gru", "gp", "xb", "eb", "gow", "bc", "cfg", " rc", "gae", "pg", "gio", "vt", "gh", "bg", "rc", "byte", "oga", "abb", "game", "gy", "bm", " db", "gl", "cgi", "bn", "cm", "kb", " kb", "bridge", "g", "gu", "ci", "gz", "s", "b", "mb", "rg", "gd", "gn"], "specific_config_bitindex": ["specific_config_bitnum", "specific_config_bitpointer", "specific_config_bootindex", "specific_config_bitpos", "specific_config_bitnumber", "specific_config_byteIndex", "specific_config_blockindex", "specific_config_blockIndex", "specific_config_bytenumber", "specific_config_longdepth", "specific_config_backsize", "specific_config_bitIndex", "specific_config_microsection", "specific_config_micronumber", "specific_config_bitsize", "specific_config_bootpos", "specific_config_blocksection", "specific_config_backindex", "specific_config_bitssize", "specific_config_longsize", "specific_config_longindex", "specific_config_lockpos", "specific_config_lockpointer", "specific_config_backnum", "specific_config_bitdepth", "specific_config_byteindex", "specific_config_lockindex", "specific_config_longnum", "specific_config_bitsindex", "specific_config_bytesection", "specific_config_bitsection", "specific_config_bitsdepth", "specific_config_bitsnum", "specific_config_microIndex", "specific_config_blocknumber", "specific_config_bootpointer", "specific_config_microindex", "specific_config_backdepth"]}}
{"project": "FFmpeg", "commit_id": "a52f443714b5c2a40ed272d8445f4c39220a4b69", "target": 1, "func": "static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int block_num)\n\n{\n\n    MpegEncContext *s  = &v->s;\n\n    int mb_cbp         = v->cbp[s->mb_x - 1 - s->mb_stride],\n\n        block_cbp      = mb_cbp      >> (block_num * 4), right_cbp,\n\n        mb_is_intra    = v->is_intra[s->mb_x - 1 - s->mb_stride],\n\n        block_is_intra = mb_is_intra >> (block_num * 4), right_is_intra;\n\n    int idx, linesize  = block_num > 3 ? s->uvlinesize : s->linesize, ttblk;\n\n    uint8_t *dst;\n\n\n\n    if (block_num > 3) {\n\n        dst = s->dest[block_num - 3] - 8 * linesize;\n\n    } else {\n\n        dst = s->dest[0] + (block_num & 1) * 8 + ((block_num & 2) * 4 - 16) * linesize - 8;\n\n    }\n\n\n\n    if (s->mb_x != s->mb_width || !(block_num & 5)) {\n\n        int16_t (*mv)[2];\n\n\n\n        if (block_num > 3) {\n\n            right_cbp      = v->cbp[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            mv             = &v->luma_mv[s->mb_x - s->mb_stride - 1];\n\n        } else {\n\n            right_cbp      = (block_num & 1) ? (v->cbp[s->mb_x - s->mb_stride]      >> ((block_num - 1) * 4))\n\n                                             : (mb_cbp                              >> ((block_num + 1) * 4));\n\n            right_is_intra = (block_num & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> ((block_num - 1) * 4))\n\n                                             : (mb_is_intra                         >> ((block_num + 1) * 4));\n\n            mv             = &s->current_picture.motion_val[0][s->block_index[block_num] - s->b8_stride * 2 - 2];\n\n        }\n\n        if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else {\n\n            idx = ((right_cbp >> 1) | block_cbp) & 5; // FIXME check\n\n            if (idx == 5) {\n\n                v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n            } else if (idx) {\n\n                if (idx == 1)\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq);\n\n                else\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n            }\n\n        }\n\n    }\n\n\n\n    dst -= 4;\n\n    ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> (block_num * 4)) & 0xf;\n\n    if (ttblk == TT_4X4 || ttblk == TT_4X8) {\n\n        idx = (block_cbp | (block_cbp >> 1)) & 5;\n\n        if (idx == 5) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else if (idx) {\n\n            if (idx == 1)\n\n                v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq);\n\n            else\n\n                v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n        }\n\n    }\n\n}\n", "idx": 13311, "substitutes": {"v": ["d", "sv", "o", "nav", "video", "ev", "ve", "vm", "e", "u", "V", "l", "ov", "server", "vi", "y", "tv", "vic", "m", "vt", "q", "volt", "g", "vert", "k", "z", "view", "n", "vc", "vd", "iv", "nv", "version", "vs", "c", "h", "i", "vu", "uv", "p", "conv", "http", "vol", "b", "ver", "va", "f", "lv", "vim", "w", "av", "vp", "j", "r", "vv", "t", "var"], "block_num": [" block_NUM", "blockingmn", " block2num", "blockerno", "blockqnum", " block_param", "blockernumber", "block00sum", "blockqnone", " block_div", " block_two", "objecternone", "block33sum", "block_dim", "block5number", "block_common", "block2number", "block64nam", "block2num", "Block_number", "blockallabel", "block_Num", "blockPdiv", "block_sem", "block1number", "block67common", "Block_num", "block_NUM", "block_nam", " block_length", "block_begin", "block67sum", " block_note", "block_tun", "block_net", "bytes", "block_four", "blockalNUM", "src", "blocksnumber", "label_sum", "blockvalcommon", "block_two", "label33sum", " block_common", "block00sem", "block_param", "block_none", "label_sem", "objecternum", "objectertun", "blockingnum", "blockPnote", "image", "block33san", "blockerum", " block2number", "label33sem", "block_sum", "object_none", "_", "block64none", "block25nom", "block64num", "block33sem", "blockacnumber", "blockernum", "blockingnet", "block_length", "blockaccommon", " block_un", "block_mn", "Block_sem", "blockernam", "block_san", " block_com", "blockqnumber", "blockslength", "blockedmn", "blockvalnum", "block_div", "blockednum", "line_number", " block_Num", "blockertun", "lock_number", " block_no", "blockPnum", "block2begin", " block_nam", "block1no", "block_set", "block_nom", "block00san", "block_um", "blockslabel", "bc", "block5sem", "end", "label33num", "blockjlength", "block5num", "blockednet", "block33num", "Block_four", "all", "block00num", "block67un", "blockalnum", " block2dim", "blockvalun", "label33san", "blockernone", "block25number", "blockalnumber", "objecternam", "lock_um", " block_dim", "blocksnum", "blockednumber", "block_number", "line_net", " block_four", "Block_set", " block_number", "blockjlabel", "block5four", " block2begin", "blockvalsum", "Block_nom", "block1num", "block64tun", "object_tun", "blockjnum", "block67num", " block_label", "block_note", "block2dim", "block_un", "blockqtwo", "block25num", "blockingnumber", "object_num", "block_no", "block_label", "g", " block_none", " block_begin", "lock_num", "lock_no", "label_num", "blockacnam", "blockPnumber", "block1four", "line_mn", "object_nam", "blockacnum", "block_com", "block25set", " block_sum", "line_num", "r", "blockjnumber", "label_san"], "s": ["session", "site", "ed", "u", "ts", "states", "sys", "si", "se", "m", "xs", "sup", "self", "n", "spec", "sh", "h", "i", "qs", "sb", "js", "j", "services", "setup", "t", "native", "ps", "fs", "sync", "serv", "en", "o", "e", "cs", "ss", "y", "ssl", "sq", "gs", "sf", "time", "a", "is", "x", "c", "input", "sg", "ns", "series", "settings", "share", "bis", "less", "us", "sites", "styles", "l", "ds", "service", "this", "ing", "vs", "http", "conv", "sl", "ses", "sy", "sym", "S", "comments", "d", "sv", "rs", "south", "secondary", "features", "server", "style", "full", "g", "es", "k", "z", "ks", "os", "ish", "side", "su", "p", "b", "f", "w", "port", "request", "r", "conf"], "right_cbp": ["right_rbp", "right_crop", "right_rbr", "right_cbps", "right_rblp", "right_cbP", "right_cueP", "right_rbpo", "right_cbc", "right_cror", "right_cbpo", "right_cuepa", "right_bbpa", "right_CBps", "right_rbpa", "right_cuer", "right_cblp", "right_obbc", "right_cuep", "right_bbp", "right_rbps", "right_crops", "right_bbP", "right_CBp", "right_CBr", "right_ncpo", "right_crolp", "right_CBlp", "right_ncp", "right_rbc", "right_cbr", "right_ncP", "right_obbP", "right_bbr", "right_ncc", "right_cbpa", "right_obbpo", "right_obbp", "right_rbP"], "right_is_intra": ["right_is_outran", "right_is_ntara", "right_is_outRA", "right_is_ntro", "right_is_outra", "right_is_intara", "right_is_integra", "right_is_indra", "right_is_distro", "right_is_intran", "right_is_pitara", "right_is_integara", "right_is_distras", "right_is_ntRA", "right_is_intRA", "right_is_pitra", "right_is_distla", "right_is_intro", "right_is_distra", "right_is_outras", "right_is_ntra", "right_is_ntras", "right_is_pitRA", "right_is_integras", "right_is_ntran", "right_is_intras", "right_is_indras", "right_is_pitras", "right_is_indla", "right_is_integran", "right_is_intla", "right_is_indro", "right_is_pitran", "right_is_ntla"], "idx": ["idey", "idxs", "endy", "idexs", "idv", "endv", " idv", "idex", "idy", " idxs", " idy", "idev", "endxs", "endx"], "ttblk": ["ttplks", "ttflck", "mmplck", "mmblks", "mmplks", "ttblck", "ttblw", "ttplck", "ttflks", "ttflk", "ttplk", "ttflw", "mmblw", "mmplw", "ttblks", "ttplw", "mmblck", "mmblk", "mmplk"], "dst": [" ddest", " dbl", " dft", "dsts", "nft", "Dft", "ddest", "lST", "fdest", "lst", "Dst", "dedsts", "Dsts", "lbl", " dST", "DST", "lsts", "dft", "fst", "fsts", "fST", "dedST", "nst", "nbl", "dST", "dedst", "deddest", "Dbl", "dbl", "nsts", " dsts"], "mv": ["mvs", "Mvp", "Mvs", " mvp", "fv", "dmw", "dmv", " mvt", "dmh", " mvs", " mh", "fh", "Mvt", "mw", "Mv", "fvp", "mh", "Mh", "fvt", "dmvs", "mvp", "Mw", "mvt", " mw"]}}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int len;\n\n\n\n    for(;;) {\n\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n\n        if (len != TS_PACKET_SIZE)\n\n            return len < 0 ? len : AVERROR_EOF;\n\n        /* check packet sync byte */\n\n        if ((*data)[0] != 0x47) {\n\n            /* find a new packet start */\n\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n\n            if (mpegts_resync(s) < 0)\n\n                return AVERROR(EAGAIN);\n\n            else\n\n                continue;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13316, "substitutes": {"s": ["ps", "fs", "sv", "o", "session", "rs", "tp", "south", "sc", "cs", "e", "sa", "sci", "ts", "server", "ds", "si", "ss", "space", "ssl", "service", "sq", "gs", "sf", "xs", "a", "bs", "g", "es", "ks", "self", "os", "spec", "ctx", "c", "su", "sg", "ns", "p", "qs", "b", "sl", "f", "src", "sb", "sie", "ses", "utils", "parser", "settings", "ls", "services", "t"], "buf": ["fp", "tmp", "uf", "txt", "bf", "tc", "br", "bc", "raf", "cb", "fb", "pad", "db", "queue", "uc", "fd", "ptr", "seq", "rc", "config", "bh", "rb", "ctx", "buff", "context", "bp", "window", "Buffer", "b", "src", "sb", "ab", "buffer", "cv"], "raw_packet_size": ["raw_packkt_timeout", "raw_packet_id", "raw_packet___length", "raw_packet___size", "raw_packet_length", "raw_packet_timeout", "raw_packkt_length", "raw_packkt_id", "raw_packet___timeout", "raw_packet___id", "raw_packkt_size"], "data": ["body", "d", "batch", "options", "empty", "raw", "la", "reader", "pos", "result", "format", "message", "package", "cb", "length", "size", "dat", "abi", "blocks", "pad", "ata", "new", "map", "slice", "api", "response", "a", "config", "parent", "next", "cache", "input", "args", "i", "bytes", "window", "p", "Data", "arr", "DATA", "buffer", "text", "alpha", "array", "pack", "ad"], "pb": ["fp", "prot", "bm", "mp", "cpp", "hub", "tmp", "tp", "jp", "uf", "bf", "tc", "bc", "pc", "pm", "cb", "fb", "wb", "pp", "wp", "pg", "db", "PB", "pd", "api", "lb", "typ", "bh", "rb", "lp", "np", "ctx", "pa", "buff", "bp", "ppa", "cp", "p", "bb", "bps", "sb", "dp", "pl", "ab", "abb", "ub", "eb", "parser", "buffer", "vp", "gb", "xb"], "len": ["body", "part", "en", "le", "fin", " length", "nt", "li", "count", "ll", "Len", "pos", "fl", "e", "fn", "l", "length", "base", "size", "L", "val", "in", "full", "el", "offset", "elt", "fd", "_", "lin", "str", "lc", "dl", "num", "z", "n", "id", "rev", "ln", "c", "no", "line", "i", "h", "f", "name", "lf", "ind", "err", "lang", "dy", "j", "span", "code"]}}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)\n\n{\n\n    char *tail;\n\n    double srate = av_strtod(arg, &tail);\n\n    if (*tail || srate < 1 || (int)srate != srate) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Invalid sample rate '%s'\\n\", arg);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    *ret = srate;\n\n    return 0;\n\n}\n", "idx": 13339, "substitutes": {"ret": ["gt", "ft", "test", "rs", "success", "fi", "result", "feat", "rt", "att", "val", "res", "vt", "det", "fit", "reply", "len", "seq", "reg", "rets", "rev", "mem", "rx", "ext", "status", "lit", "arr", "sr", "rep", "sb", "re", "RET", "alt", "Ret", "ann"], "arg": ["enc", "orig", "ar", "exec", "amp", "param", "match", "result", "pc", "end", "val", "loc", "ig", "tag", "ary", "str", "parse", "g", "reg", "word", "ac", "tick", "item", "phrase", "Arg", "input", "args", "addr", "ext", "target", "ax", "p", "mac", "inc", "arc", "arr", "name", "inter", "call", "err", "argument", "bit", "ace", "ag", "ref", "arm", "len", "var", "ad"], "log_ctx": ["log_context", " log_scope", "logwlc", " log_config", "log_config", "logrscope", " log_tx", "log_scope", "log_tx", "logrcontext", "logrctx", " log_cmp", "log_lc", "logFcontext", "logFscope", " log_lc", "log_cmp", " log_context", "logwconfig", "logFtx", "logrtx", "logwctx", "logFctx", "logwcmp"], "tail": ["prefix", "body", "gt", "iter", "test", "temp", "lead", "letter", "pull", "thread", "tc", "ll", "head", "length", "lt", "size", "align", "nil", "timeout", "fat", "tag", "limit", "offset", "stem", "tip", "lc", "unit", "word", "lp", "tt", "lock", "tick", "weight", "wl", "ail", "ext", "target", "index", "col", "tails", "term", "beta", "nw", "t", "len", "ad", "code"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n", "idx": 13347, "substitutes": {"env": ["enc", "en", "environment", "ev", "exec", "exc", "obj", "cb", "conn", "def", "ec", "db", "queue", "inst", "ep", "rc", "config", "proc", "eu", "ch", "dev", "viron", "info", "req", "loader", "err", "gr", "conf"], "ctx": ["client", "sync", "cam", "cz", "connection", "cn", "cu", "exec", "exc", "jp", "cm", "tc", "sc", "cs", "nc", "obj", "pkg", "bc", "sci", "cf", "pc", "cmd", "cfg", "kb", "voc", "kn", "anc", "qa", "Context", "cc", "cmp", "grad", "rc", "config", "cca", "lc", "ck", "cus", "progress", "vc", "ch", "ci", "cor", " context", "context", "c", "conv", "cp", "history", "lib", "cli", "scope", "cpu", "coll", "kw", "ctrl", "tx", "crit", "acl", "mc", "ca", "utils", "wcs", "que", "console", "loc", "conn", "cas", "sk", "cv"], "op2": ["oper4", " op3", "OP3", "hop1", "OP4", "OP02", "oper2", "OP2", "oper1", "op1", "oper3", " op02", " op1", "hop3", "op3", "hop2", "OP1", " op4", "op4", "op02", "hop4", "oper02"], "r1": ["rlone", "rpart", "yr7", "yrone", "R5", "rone", "err1", " r2", "rgip", "rname", "rgpart", " rone", "rrname", "range1", "prup", "R3", "errOne", "R1", "sr7", "rg1", "R2", " r5", "r61", " r4", " r0", "rl1", "pr15", "rangename", "rup", "ROne", "r5", "tr1", " rname", "rg3", "br0", "pr61", "sr1", "str0", "sr3", "R0", "r0", " rOne", "rip", "dr1", "pr1", "str1", " r3", "rr15", "rOne", "tr15", "trname", "tr61", "r2", "rgone", "rr61", "err0", "rr1", "dr0", "rgup", " rpart", "r3", "err4", "yrpart", "drOne", "rlip", "brOne", "br2", "yr3", " r7", "yr1", "sr5", "prip", "r15", "r4", "range0", "prname", "r7", "dr4", "strname", "rlup", "sr2", "prone", "br1"], "address": ["prefix", "trace", "route", "position", "attribute", "mode", "array", "message", "holder", "format", "output", "interface", "length", "element", "uri", "pair", "alias", "path", "account", "shape", "padding", "offset", "ptr", "host", "parent", "location", "channel", "point", "key", "capacity", "add", "cache", "context", "ip", "memory", "Address", "pointer", "addr", "reference", "index", "type", "order", "instance", "ash", "tx", "name", "port", "buffer", "ace", "socket", "value", "number", "code"], "temp": ["test", "cu", "exec", "draw", "v", "output", "porary", "level", "circ", "cel", "font", "stack", "tmp", "cont", "tc", "local", "format", "holder", "timeout", "slice", "fd", "str", "lc", "keep", "cache", "context", "input", "memory", "tx", "mount", "load", "buffer", "null", "storage", "iter", "data", "result", "Temp", "model", "write", "zip", "this", "valid", "mix", "fake", "buff", "pointer", "clean", "ex", "out", "perature", "get", "ace", "handle", "make", "cut", "private", "cm", "thread", "base", "length", "form", "ptr", "tem", "config", "current", "cp", "stable", "layout", "index", "cli", "p", "ctrl", "w", "loc", "emp", "wrap", "pack"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readdir(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsFidState *fidp;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    uint64_t initial_offset;\n\n    int32_t count;\n\n    uint32_t max_count;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &initial_offset, &max_count);\n\n\n\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (!fidp->fs.dir) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (initial_offset == 0) {\n\n        v9fs_co_rewinddir(pdu, fidp);\n\n    } else {\n\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n\n    }\n\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n\n    if (count < 0) {\n\n        retval = count;\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"d\", count);\n\n    retval += count;\n\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 13357, "substitutes": {"opaque": ["OPaco", "iponymous", "ipacity", "opac", " opac", "opaques", "opaco", " opque", "ipaque", "oponymous", "ovacity", "ovonymous", "oppaques", "opque", "ovaques", "OPac", " opaco", "OPque", "opponymous", "opacity", "ipaco", "ipac", "ipaques", "oppaque", "oppacity", "ipque", "ovaque", "OPaque"], "fid": ["fpoid", " fbid", "fbid", "affid", " fname", "fade", "fcident", "affids", " fident", "fident", "fpID", "sfite", " fids", "rfoid", "cfida", "fcid", "eid", "cfid", "fpida", "tfbid", "fpid", "sfids", "fID", "tfida", "eite", "cfname", " foid", "fcname", "rfID", "fids", "tfids", " fida", "cade", "sfade", "fname", "foid", "rfid", "fcida", "affida", " fID", "cids", "eade", "cfident", "tfid", "rfida", "cite", "eids", "affbid", "fite", "sfid", "cid", "fida"], "fidp": ["wIDp", "filpe", "wIDpr", " fidech", "fixpe", "pidp", "fidpi", "feidpi", "fidsp", "fidev", "filper", "fidpe", "fandper", "fiddl", "piddu", "fsidpi", " fidping", "fideping", "fiddp", "fidapi", "fidping", "fiddu", "faidc", "fuidch", "fidaP", "fuidping", "fidv", "piddp", "fide", "fsidp", "fixp", "pidc", "tfidepe", "tfidpe", "wIDpa", "fbidpi", "fidu", "fandpi", "fIDpa", "fIDpr", " fidse", "fIde", "tfidp", "fidap", "faxp", "feidv", "fidse", " fidsp", "wIDr", " fideping", "fidper", "fidach", "fidep", "fideper", "fidsl", "tfidper", "fbitc", "fIdl", "fidel", "faidp", "fbitp", "fIDp", "filpa", "fidsc", "fridp", "fbitpi", "fIdp", "tfidep", "fuidp", "feridper", "fiddc", "feridpa", "filp", "fIDr", "fidl", " fideP", "fbidper", " fide", "fideP", " fidch", "fkeyr", "fkeyp", "fandpa", "widp", "fidenv", " fidep", "fkeypa", "fbidpa", "fidenper", "tfidepa", "fidec", "feidp", "fsidc", "fidenpa", "fidenp", "fIdc", "fidP", "fsidapi", "feridpi", "feidper", " fidP", "tfideper", "fidpa", "widpa", "fidech", "piddl", "fridpa", "fuidP", "fridper", "fkeypr", "widpr", "fandp", "fbitapi", "fidee", "fridv", "fidr", " fidsl", "fidepe", " fidapi", "fidpr", "feidpa", "fidaping", "pidl", "feridp", "fixpa", " fidsc", "faxl", "fixper", "faxc", " fidl", "pidu", "piddc", "feridv", "faidl", "fridpi", "tfidpa", "fbidp", "fidepa", "fidch", "faxu", "faidu", " fidc", "fidc", "widr", " fidpi"], "initial_offset": [" initial_pos", " initial_connection", " initial_part", "minimum_index", "initial_connection", "initial_address", " initial_size", "initial_pos", "minimum_address", " initial_order", "minimum_offset", "initialityconnection", "initial_count", "minimum_size", " initial_ptr", "initial_order", "initial_part", " initial_index", "initial_size", " initial_count", "initial_ptr", "initialityoffset", " initial_entry", "initialityindex", "initial_index", "initial_entry"], "count": ["part", "file", "list", "Count", "all", "content", "match", "process", "end", "use", "length", "size", "base", "write", "val", "depth", "total", "cc", "limit", "offset", "label", "time", "seq", "error", "parent", "num", "key", "cond", "skip", "n", "ch", "id", "cache", "read", "current", "c", "weight", "complete", "max", "close", "now", "core", "type", "index", "cat", "col", "start", "name", "found", "child", "ind", "old", "call", "err", "allow", "text", "cast", "sum", "len", "number", "code"], "max_count": [" max_size", " max_depth", "max24offset", "max_limit", " max_limit", " max_name", " max_length", "max_name", "max54offset", "max64length", "max64name", "max54count", "max_size", "max_max", " max_max", "max24limit", "max54limit", "max_length", " max_offset", "max_offset", "max64size", "max_depth", "max64count", "max24count"], "pdu": ["psdu", "ppdu", "aptu", "pssu", "fuu", "opdi", "vtu", "vde", "pluu", "Pdu", "pdi", "opcu", "fdu", "cuu", "psu", " pcu", " puna", " puu", "cpde", "vdu", " psu", "vuu", "arpdu", "ptu", " ptu", "opde", "cpdu", "fcu", "opdu", "pde", "cde", "arpuu", " pru", "Pcu", "plsu", "funa", " pdi", "pcu", "fru", "fdi", "duc", "apru", "ctu", "ppcu", "dsu", "psuna", "fsu", "pluc", "fde", "duu", "puu", "psru", "cpcu", "pru", "optu", "apdu", "ppru", "opsu", "ddu", "apcu", "csu", "arptu", "puc", "ccu", "cptu", "puna", "arpde", "pptu", "Ptu", "Pdi", "pldu", " pde", "cdu", "ftu", "Pde", "cpdi", " puc"], "s": ["storage", "sync", "d", "us", "o", "session", "south", "v", "secondary", "e", "u", "server", "states", "sys", "si", "in", "summary", "ssl", "service", "m", "state", "gs", "a", "g", "uploads", "n", "os", "spec", "stats", "is", "submit", "c", "http", "i", "h", "sg", "p", "status", "scope", "ns", "b", "aws", "sets", "instance", "f", "sb", "js", "w", "ses", "settings", "r", "services", "sym", "S", "t", "ops"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint32_t cc = 0;\n\n    int old_exc = cs->exception_index;\n\n    uint64_t asc = env->psw.mask & PSW_MASK_ASC;\n\n    uint64_t ret;\n\n    int flags;\n\n\n\n    /* XXX incomplete - has more corner cases */\n\n    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {\n\n        program_interrupt(env, PGM_SPECIAL_OP, 2);\n\n    }\n\n\n\n    cs->exception_index = old_exc;\n\n    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {\n\n        cc = 3;\n\n    }\n\n    if (cs->exception_index == EXCP_PGM) {\n\n        ret = env->int_pgm_code | 0x80000000;\n\n    } else {\n\n        ret |= addr & ~TARGET_PAGE_MASK;\n\n    }\n\n    cs->exception_index = old_exc;\n\n\n\n    env->cc_op = cc;\n\n    return ret;\n\n}\n", "idx": 13363, "substitutes": {"env": ["enc", "en", "engine", "eve", "ne", "et", "environment", "ass", "ev", "esp", "dt", "site", "exec", "icer", "exc", "txt", "v", "e", "nc", "bc", "obj", "conn", "server", "qt", "eng", "ec", "db", "pec", "el", "ep", "export", "config", "proc", "ea", "eu", "net", "exe", "kernel", "eni", "cv", "np", "her", "ctx", "osc", "init", "cache", "context", "vs", "shell", "args", "viron", "code", "ext", "c", "ah", "core", "req", "scope", "esi", "cal", "enos", "energy", "utils", "loader", "que", "console", "er", "forge", "chal", "conf", "Environment", "oa"], "addr": ["address", "dr", "route", "arch", "func", "ord", "amd", "ar", "exec", "rs", "data", "amp", "adr", "nc", "result", "eth", "oa", "cmd", "rt", "size", "alt", "alias", "pad", "dc", "cmp", "loc", "offset", "xp", "ptr", "seq", "rc", "host", "proc", "sta", "arg", "ac", "id", "ip", "mac", "pointer", "coord", "layer", "dd", "src", "asm", "ace", "arp", "ref", "conn", "len", "lag", "ad", "code"], "cs": ["ps", "fs", "sync", "ops", "Cs", "cn", "ys", "sc", "bc", "pc", "cf", "ds", "sys", "CS", "ec", "cc", "gs", "ces", "lc", "rc", "bs", "ck", "ks", "ix", "cus", "ils", "vc", "ci", "spec", "ctx", "acs", "c", "vs", "args", "cp", "ns", "cks", "qs", "co", "ca", "js", "wcs", "ics", "utils", "ls", "ace", "conn", "cms", "cas", "sk", "css"], "ret": ["expected", "part", "ft", "func", "rs", "fi", "data", "nt", "match", "result", "feat", "bc", "rt", "att", "val", "def", "res", "pet", "offset", "det", "reply", "len", "seq", "fun", "rc", "reg", "rets", "arg", "rev", "cur", "mem", "ext", "status", "cat", "lit", "arr", "re", "RET", "flag", "get", "bit", "value", "pass", "lag", "ref", "alt", "Ret", "code"], "flags": ["ops", "fs", "rs", "Flags", "rules", "mask", "bc", "fts", "cc", "mods", "seq", "fun", "rc", "reg", "fps", "ips", "rets", "bits", "args", "s", "status", "inc", "CC", "vals", "f", "lf", "flag", "ls", "ags", "pass", "nl", "alls", "len", "lag", "codes"]}}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,\n\n                                  uint64_t new_shared_perm,\n\n                                  BdrvChild *ignore_child, Error **errp)\n\n{\n\n    BdrvChild *c;\n\n    uint64_t cumulative_perms = new_used_perm;\n\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c == ignore_child) {\n\n            continue;\n\n        }\n\n\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n\n                             \"allow '%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n\n                             \"'%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        cumulative_perms |= c->perm;\n\n        cumulative_shared_perms &= c->shared_perm;\n\n    }\n\n\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);\n\n}\n", "idx": 13365, "substitutes": {"bs": ["ps", "fs", "sync", "ba", "ins", "bl", "bas", "rs", "null", "loop", "cs", "bc", "obj", "cb", "fb", "base", "ds", "bes", "sys", "blocks", "bin", "ss", "res", "db", "root", "bos", "BS", "gs", "lb", "url", "fps", "cus", "ac", "os", "iss", "ctx", "bi", "bits", "is", "vs", "pb", "bp", "bot", "bytes", "ns", "bb", "s", "lib", "bps", "b", "sb", "as", "ab", "ms", "js", "ses", "gb", "banks", "ls", "bis", "bid", "eb", "css"], "new_used_perm": ["new_needed_mod", "new_usedalper", "new_used27spec", "new_used__mode", "new_used_ptr", "new_used27perm", "new_needed_per", "new_use_ptr", "new_usedlyper", "new_usedlymode", "new_use_admin", "new_use_req", "new_used_req", "new_usedalperm", "new_usedlyperm", "new_use_spec", "new_use_mode", "new_usedamper", "new_used_priv", "new_shared_mission", "new_usedamperm", "new_use_perm", "new_used__per", "new_shared_per", "new_used_mod", "new_needed_priv", "new_used_spec", "new_usedlyadmin", "new_use_per", "new_used__admin", "new_usedalreq", "new_used27per", "new_used_mission", "new_used__perm", "new_usedammission", "new_used_mode", "new_used_admin", "new_needed_perm", "new_used_per", "new_usedalptr"], "new_shared_perm": ["new_shared1priv", "new_share_priv", "new_sharedtheper", "new_shared_mask", "new_share_perm", "new_shared_acl", "new_shared1mission", "new_exclusive_perm", "new_shared1perm", "new_shared1per", "new_sharedthemask", "new_owned_perm", "new_used_priv", "new_shared_mission", "new_owned_per", "new_shared_per", "new_ared_per", "new_ared_priv", "new_sharedtheperm", "new_shared_attr", "new_ared_perm", "new_used_mission", "new_exclusive_per", "new_owned_mask", "new_share_per", "new_exclusive_attr", "new_used_per", "new_ared_acl", "new_shared_priv"], "ignore_child": ["ignore_children", "ignore_parent", "ignore_group", " ignore_group", " ignore_children", " ignore_parent"], "errp": ["errvp", "Erpre", " errfp", "rrpre", "errpc", " errvp", " errpre", "erc", "errorfp", "nerP", "rrfp", "erpc", " errpc", "ervp", "errfp", "Erpc", "erpre", "rrp", "errorpc", " errP", "errpre", "errc", "nervp", "rrpc", " errc", "erP", "erfp", "errorp", "errP", "Erfp", "erp", "errorc", "nerfp", "nerp", "Erp"], "c": ["enc", "cn", "cu", "exec", "oc", "v", "sc", "u", "cf", "cd", "icc", "in", "ec", "cc", "m", "parent", "self", "n", "ac", "h", "i", "col", "cy", "ic", "cr", "or", "t", "client", "ct", "o", "tc", "cs", "e", "pc", "lc", "cache", "ca", "chain", "con", "C", "l", "anc", "cmp", "rc", "rec", "ch", "ce", "coll", "mc", "call", "code", "d", "content", "cm", "nc", "dc", "uc", "config", "g", "k", "vc", "ci", "ctx", "fc", "current", "cp", "s", "p", "b", "co", "ctrl", "f", "child", "w", "r", "xc"], "user": ["client", "module", "person", "bug", "um", "field", "USER", "author", "project", "u", "match", "users", "sum", "use", "base", "post", "username", "resource", "usa", "path", "job", "full", "object", "group", "uid", "uu", "by", "root", "valid", "time", "url", "usr", "up", "role", "parent", "key", "word", "me", "lock", "id", "home", "User", "date", "line", "type", "device", "ver", "public", "used", "member", "name", "manager", "custom", "pass", "plugin", "rule", "creator", "ee", "human", "from"], "perm_names": ["fil_ames", "perm_locks", "perm_name", "permPns", "fp_objects", "perm9name", "permSops", "fil_names", "filfnames", "filfkeys", "perm9roots", "permSsettings", "fpNparams", "fil_des", "permfames", "permfnames", "mission_names", "permfdes", "per_name", "perm_als", "fp_name", "permFobjects", "perm_objects", "missionPns", "permFnames", "permNnames", "filfames", "perm_params", "fpNnames", "permFname", "filfdes", "fp_names", "fp_params", "mission_parents", "perm_options", "perm_ns", "perm_settings", "missionPparents", "permxobjects", "mission_ns", "permFsettings", "permNparams", "permFparams", "perm_values", "permxname", "per_ops", "fp_values", "perm_keys", "perm9names", "perm_roots", "permGns", "missionPnames", "fp_als", "fpNname", "perm9objects", "fil_keys", "permNobjects", "fp_locks", "permSnames", "permPnames", "missionPoptions", "permSname", "per_objects", "permGoptions", "permxnames", "permxroots", "perm_parents", "perm_des", "per_settings", "permGnames", "fpNobjects", "permFops", "permPoptions", "mission_options", "permPparents", "perm_ops", "permNname", "perm_ames", "permGparents", "per_roots", "per_names", "permfkeys"]}}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n", "idx": 13366, "substitutes": {"mon": ["module", "part", "mm", "atom", "meter", "dog", "month", "connection", "com", "mi", "dom", "mail", "user", "don", "po", "kin", "chron", "con", "mu", "message", "mun", "pm", "bean", "den", "mer", "plan", "mag", "wm", "an", "m", "pid", "mo", "mn", "unit", "num", "wan", "man", "method", "un", "block", "tom", "demon", "channel", "Mon", "key", "lock", "mem", "http", "date", "monitor", "col", "met", "on", "run", "member", "nan", "mc", "manager", "master", "bo", "mor", "pin", "wat", "mand", "stat", "plugin", "MON", "conn", "ann"], "data": ["done", "body", "module", "part", "d", "json", "o", "options", "xml", "empty", "raw", "results", "record", "media", "result", "obj", "array", "message", "package", "base", "model", "dat", "params", "val", "resource", "partial", "object", "map", "api", "valid", "meta", "response", "a", "config", "parent", "da", "ada", "cache", "dev", "change", "complete", "input", "money", "dict", "info", "none", "monitor", "Data", "p", "missing", "dd", "type", "metadata", "python", "DATA", "value", "database", "number", "ad"], "qmp": ["qusup", "sqph", "chep", "quemb", "qpp", "qmb", "qcp", "quefp", "quesup", "sqmp", "qpac", "workap", "qupac", "qucp", "aypar", "qamm", "sqpac", "ayph", "Qcomp", "queomp", "quap", "qph", " qproc", " qcomp", "aymt", "Qmp", "sqomp", "workep", "chomp", "qucmp", "qap", " qcp", "qumt", "aymp", "qaMP", "qproc", "QMP", " qmb", "qamp", "qucop", "workmb", "qep", " qcmp", " qomp", " qsup", "chmp", " qpp", "chmm", "quep", " qmm", "quph", "workmp", "workcp", "qsup", "qacomp", "workpp", "Qmm", "quomp", "quproc", "workmm", "qufp", "qpar", "qMP", "workproc", "qumm", "sqmt", "sqcop", "qmm", "qcop", "qupar", "workomp", "quemp", "sqpar", "qumb", " qfp", "workcmp", "qupp", "quecop", "qmt", "qcomp", "qcmp", " qap", "qfp", "qomp", "qump", "quepac", "quemm", " qMP"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static inline int decode_vui_parameters(H264Context *h, SPS *sps)\n\n{\n\n    int aspect_ratio_info_present_flag;\n\n    unsigned int aspect_ratio_idc;\n\n\n\n    aspect_ratio_info_present_flag = get_bits1(&h->gb);\n\n\n\n    if (aspect_ratio_info_present_flag) {\n\n        aspect_ratio_idc = get_bits(&h->gb, 8);\n\n        if (aspect_ratio_idc == EXTENDED_SAR) {\n\n            sps->sar.num = get_bits(&h->gb, 16);\n\n            sps->sar.den = get_bits(&h->gb, 16);\n\n        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {\n\n            sps->sar = pixel_aspect[aspect_ratio_idc];\n\n        } else {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"illegal aspect ratio\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        sps->sar.num =\n\n        sps->sar.den = 0;\n\n    }\n\n\n\n    if (get_bits1(&h->gb))      /* overscan_info_present_flag */\n\n        get_bits1(&h->gb);      /* overscan_appropriate_flag */\n\n\n\n    sps->video_signal_type_present_flag = get_bits1(&h->gb);\n\n    if (sps->video_signal_type_present_flag) {\n\n        get_bits(&h->gb, 3);                 /* video_format */\n\n        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */\n\n\n\n        sps->colour_description_present_flag = get_bits1(&h->gb);\n\n        if (sps->colour_description_present_flag) {\n\n            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */\n\n            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */\n\n            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */\n\n            if (sps->color_primaries >= AVCOL_PRI_NB)\n\n                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;\n\n            if (sps->color_trc >= AVCOL_TRC_NB)\n\n                sps->color_trc = AVCOL_TRC_UNSPECIFIED;\n\n            if (sps->colorspace >= AVCOL_SPC_NB)\n\n                sps->colorspace = AVCOL_SPC_UNSPECIFIED;\n\n        }\n\n    }\n\n\n\n    /* chroma_location_info_present_flag */\n\n    if (get_bits1(&h->gb)) {\n\n        /* chroma_sample_location_type_top_field */\n\n        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;\n\n        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */\n\n    }\n\n\n\n    sps->timing_info_present_flag = get_bits1(&h->gb);\n\n    if (sps->timing_info_present_flag) {\n\n        sps->num_units_in_tick = get_bits_long(&h->gb, 32);\n\n        sps->time_scale        = get_bits_long(&h->gb, 32);\n\n        if (!sps->num_units_in_tick || !sps->time_scale) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"time_scale/num_units_in_tick invalid or unsupported (%\"PRIu32\"/%\"PRIu32\")\\n\",\n\n                   sps->time_scale, sps->num_units_in_tick);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sps->fixed_frame_rate_flag = get_bits1(&h->gb);\n\n    }\n\n\n\n    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->nal_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->vcl_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    if (sps->nal_hrd_parameters_present_flag ||\n\n        sps->vcl_hrd_parameters_present_flag)\n\n        get_bits1(&h->gb);     /* low_delay_hrd_flag */\n\n    sps->pic_struct_present_flag = get_bits1(&h->gb);\n\n\n\n    sps->bitstream_restriction_flag = get_bits1(&h->gb);\n\n    if (sps->bitstream_restriction_flag) {\n\n        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */\n\n        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */\n\n        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */\n\n        sps->num_reorder_frames = get_ue_golomb(&h->gb);\n\n        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/\n\n\n\n        if (get_bits_left(&h->gb) < 0) {\n\n            sps->num_reorder_frames         = 0;\n\n            sps->bitstream_restriction_flag = 0;\n\n        }\n\n\n\n        if (sps->num_reorder_frames > 16U\n\n            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Clipping illegal num_reorder_frames %d\\n\",\n\n                   sps->num_reorder_frames);\n\n            sps->num_reorder_frames = 16;\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if (get_bits_left(&h->gb) < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Overread VUI by %d bits\\n\", -get_bits_left(&h->gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13388, "substitutes": {"h": ["hs", "d", "ha", "o", "x", "hash", "v", "e", "uh", "oh", "u", "rh", "head", "hd", "l", "ht", "hist", "header", "hm", "m", "hh", "gh", "q", "beh", "he", "hw", "esh", "ul", "hp", "host", "hl", "g", "hand", "k", "bh", "ch", "ctx", "hr", "sh", "c", "H", "FH", "http", "hi", "s", "p", "ah", "him", "ph", "b", "history", "f", "th", "kh", "w", "zh", "r", "i", "t", "enh"], "sps": ["tspps", "dsps", "sapes", "jsports", "srs", "fseps", "spt", "sPS", "sples", "scheps", "wspe", " sports", " seps", "spe", "hops", "spp", "spos", "sbs", "lports", "psops", "osports", "msts", "setsps", "sols", "osips", "sgs", "pops", "setspp", "ospps", "asrs", " spp", "esips", "tsps", "anseps", "anspps", "ksips", "lseps", "eseps", "unspe", "kspps", "eops", "tseps", "aspos", "unsps", "fsps", "ispp", "SPS", "aspps", "ppps", "pspos", "tsops", "setsples", "dsms", "spps", "isps", "msps", " sks", "sinps", "gports", "ests", "mseps", "ispt", "lpe", "asips", " scs", "sports", "sts", "unseps", "psps", "psips", "ksps", "sops", "asbs", "sinpp", "scheples", "eps", "scheols", "Spt", "sls", "hps", "unsips", "dsops", " sapes", "seps", "gps", "epps", "anscs", "asps", "ansips", "pspps", "wseps", " sbs", " sips", "sms", "lspe", "lips", "psgs", "lsps", "peps", "lspps", "gips", "lsips", "gpps", "osss", "Spp", "ansrs", "wsps", "ansps", "osps", "msips", "tsports", "ksports", "hpps", " sls", "hgs", " sPS", "fsls", " spps", "jsps", "setsols", "psks", "dspps", "esps", "jsips", "sips", "wsips", "Sps", " sss", "aseps", "psports", "asops", "asports", "tspos", "schepp", "psls", " sops", "egs", "scs", "ansops", "lscs", "osapes", "jspe", "pps", "sks", "pseps", "lps", "sinples", "isPS", " sms", "sinols", " srs", " spt", "fsks", "sss", " spe"], "aspect_ratio_info_present_flag": ["aspect_ratio_info_presentingflags", "aspect_ratio_info_presentingflag", "aspect_ratio_info_present_bit", "aspect_ratio_info_present_flags", "aspect_ratio_info_presentingcount", "aspect_ratio_info_show_flags", "aspect_ratio_info_present_band", "aspect_ratio_info_valid_flag", "aspect_ratio_info_show_count", "aspect_ratio_info_valid_count", "aspect_ratio_info_show_flag", "aspect_ratio_info_valid_band", "aspect_ratio_info_valid_bit", "aspect_ratio_info_present_count"], "aspect_ratio_idc": ["aspect_ratio_idr", "aspect_ratio_idsc", "aspect_ratio_bidx", "aspect_ratio_idsf", "aspect_ratio_idec", "aspect_ratio_ider", "aspect_ratio_idef", "aspect_ratio_idscs", "aspect_ratio_Ide", "aspect_ratio_idcs", "aspect_ratio_Idci", "aspect_ratio_ideci", "aspect_ratio_Idc", "aspect_ratio_idee", "aspect_ratio_ide", "aspect_ratio_bidr", "aspect_ratio_idsci", "aspect_ratio__idci", "aspect_ratio_cdx", "aspect_ratio_bidc", "aspect_ratio_idx", "aspect_ratio_idsx", "aspect_ratio_cdf", "aspect_ratio__idc", "aspect_ratio_idex", "aspect_ratio_idsn", "aspect_ratio__ideci", "aspect_ratio_deff", "aspect_ratio_Idx", "aspect_ratio_cdc", "aspect_ratio_bidci", "aspect_ratio_cdcs", "aspect_ratio__idee", "aspect_ratio_defn", "aspect_ratio__idef", "aspect_ratio_idn", "aspect_ratio_idf", "aspect_ratio__idec", "aspect_ratio__idf", "aspect_ratio_idse", "aspect_ratio_Idn", "aspect_ratio_idci", "aspect_ratio_defci", "aspect_ratio__ide", "aspect_ratio_Idf", "aspect_ratio_defc"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 13415, "substitutes": {"bs": ["ps", "fs", "sync", "ins", "bl", "bas", "rs", "bing", "cs", "ras", "bc", "obj", "bu", "cb", "fb", "base", "abi", "ds", "bes", "blocks", "ss", "db", "bus", "bos", "bt", "BS", "gs", "lb", "nas", "obs", "bh", "ks", "ubs", "fps", "os", "iss", "bits", "cache", "vs", "bytes", "ns", "bb", "b", "sb", "ab", "ses", "js", "las", "banks", "ls", "lbs", "bis", "bid", "pb", "css"], "sector_num": [" sector_count", " sector_id", " sector_name", "sector__num", "sector_Num", "sector_number", "sector_name", "sector__number", "sector_count", "sector_id", " sector_Num", "sector__count", " sector_number"], "buf": ["batch", "alloc", "data", "uf", "br", "bc", "fab", "cb", "base", "cas", "fb", "bin", "bus", "queue", "offset", "vec", "fd", "uc", "seq", "config", "num", "rb", "block", "ctx", "buff", "Buffer", "b", "bag", "src", "ab", "port", "que", "buffer", "ref", "len", "array", "pb", "cv"], "nb_sectors": ["nb_seccs", "nb_teapters", "nb_telements", "nb_begments", "nb_vegments", "nb_becs", "nb_serctors", "nb_serkers", "nb_secgments", "nb_seclements", "nb_tekers", "nb_sekers", "nb_seapters", "nb_secctors", "nb_tectors", "nb_sergments", "nb_secapters", "nb_vecs", "nb_tegments", "nb_selements", "nb_vekers", "nb_bectors", "nb_belements", "nb_segments", "nb_serlements", "nb_vectors", "nb_veapters", "nb_secs", "nb_velements"], "drv": ["dric", "Drp", "rrv", "DRf", " drw", " drp", " drV", "hrf", "hrc", "hrv", "DRc", "prp", "Drf", "hrb", "rrw", " drver", "Drv", "drV", " drc", "hrw", "drif", "drp", "driV", "hrV", "DrV", " drb", "DRV", "Drb", " drf", "drver", "drc", "prf", "prv", "Drver", "drw", "rrb", "drf", "drb", "DRv", "rrf", "driv", "prver", "Drc"], "ret": ["fail", "en", "ft", "fin", "success", " Ret", "reset", "nt", "pat", "bf", "ry", "result", "obj", "rt", "base", "att", "val", "alt", "def", "res", "pet", "det", "fit", "reply", "valid", "al", "fun", "rc", "error", "reg", "tr", "rb", "next", "rets", "arg", "mt", "art", "req", "let", "lit", "cat", "rep", "sr", "re", "RET", "flag", "err", "back", "bit", "value", "ref", "len", "Ret", "code"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret;\n\n\n\n    /*\n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n\n\n    /* Note request is (bRequestType << 8) | bRequest */\n\n    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 13426, "substitutes": {"dev": ["debug", "d", "engine", "di", "app", "bug", "ev", "ve", "priv", "temp", " device", "pro", "v", "md", "user", "dom", "dist", "plug", "DEV", "pub", "cmd", "ds", "serial", "def", "bus", "die", "new", "mod", "valid", "hw", "comment", "dn", "error", "Dev", "pu", "proc", "g", "self", "block", "de", "ch", "sd", "home", "h", "info", "dem", "req", "device", "dd", "f", "dm", "w", "diff", "av", "gd", "conf", "driver", "devices", "pack"], "p": ["fp", "d", "o", "tp", "v", "e", "u", "pc", "P", "pp", "m", "sp", "pd", "proc", "g", "pre", "np", "ip", "c", "q", "i", "h", "cp", "b", "f", "dp", "w", "gp", "py", "vp", "r", "j", "plugin", "t", "pb"], "request": ["address", "first", "received", "initial", "pull", "attribute", "author", "param", "mode", "command", "result", "rest", "message", "use", "head", "access", "query", "pair", "hello", "resource", "path", "header", "object", "rf", "insert", "frame", "response", "time", " Request", "config", "method", "id", "version", "current", "complete", "input", "rx", "push", "art", "q", "info", "ext", "req", "type", "device", "instance", "f", "name", "effect", "Request", "buffer", "r", "event", "forward"], "value": ["update", "json", "address", "fee", "position", "flow", "content", "initial", "v", "localhost", "search", "command", "store", "message", "end", "size", "server", "element", "write", "val", "property", "total", "valid", "response", "time", "values", "config", "view", "key", "id", "version", "change", "current", "x", "max", "input", "info", "set", "off", "type", "range", "device", "description", "start", "name", "port", "Value", "buffer", "section", "number", "function", "null"], "index": ["address", "field", "position", "initial", "localhost", "Index", "pos", "match", "end", "base", "access", "size", "query", "val", "level", "offset", "slice", "len", "error", "config", "view", "point", "key", "id", "read", "x", "input", "i", "weight", "info", "active", "type", "inc", "start", "name", "ind", "diff", "tail", "loc", "connect"], "length": ["body", "failed", "position", "empty", "count", "Length", "end", "l", "size", "duration", "style", "delay", "val", "total", "level", "shape", "path", "full", "padding", "limit", "offset", "zip", "slice", "time", "block", "lock", "weight", "max", "info", "off", "type", "ph", "thin", "f", "name", "load", "buffer", "section", "angle", "tail", "loc", "text", "len", "number", "sequence"], "data": ["d", "send", "fee", "du", "raw", "command", "result", "message", "base", "def", "new", "frame", "response", "config", "block", "feed", "read", "buff", "input", "push", "info", "Data", "load", "DATA", "transfer", "array", "pack"], "s": ["hs", "session", "v", "sc", "u", "ts", "its", "states", "sys", "si", "an", "se", "m", "self", "n", "spec", "sd", "sh", "h", "qs", "sb", "as", "js", "j", "services", "t", "ps", "sync", "serv", "o", "ins", "sim", "cs", "e", "ions", "ss", "ssl", "new", "sq", "gs", "details", "is", "c", "sg", "ns", "bis", "storage", "us", "l", "ds", "service", "http", "sl", "ses", "sym", "S", "d", "sv", "rs", "south", "server", "sp", "g", "es", "ks", "os", "su", "device", "b", "sets", "f", "w", "r", "ls", "conf"], "urb": ["address", "atom", "hub", "abuse", "uf", "erg", "force", "cb", "obb", "fb", "account", "api", "emb", "rb", "nb", "bb", "cr", "ocr", "rub", "editor", "arb", "aim", "um", "eur", "flow", "uber", "ur", "adr", "utter", "interface", "element", "ulp", "udi", "lc", "rib", "usb", "qi", "buffer", "buf", "eb", "abl", "aur", "fab", "ob", "urban", "attr", "deb", "irm", "ch", "buff", "urt", "report", "abb", "verb", "ub", "uff", "ann", "aud", "aff", "br", "air", "raf", "orb", "rob", "uri", "url", "config", "feed", "ell", "uv", "b", "f", "ab", "gb", "transfer", "plugin", "img", "pb"], "aurb": ["rard", "URB", "ura", "rarb", "rumB", "igrB", "eurp", "eura", "urp", "rumab", "ervp", "erva", "urc", "turbs", "igrb", "turab", "hrB", "urB", "auc", "aurc", "turp", "acerr", "igrib", "acerb", "iarp", "turB", "urd", "rarib", "aura", "aup", "igra", "aub", "eurc", "iarr", "aurr", "acerB", "URbs", "ervc", "turb", "ervr", "ervB", "rara", "eurr", "aurp", "aur", "rumb", "iarb", "hrb", "eurab", "igrd", "aurB", "hrab", "urchab", "eurb", "urib", "eurB", "urr", "iarab", "iarB", "urchB", "ervb", "aurib", "turf", "aurbs", "aua", "rumr", "igrab", "aurf", "iarbs", "urchr", "aurd", "urchb", "iarf", "urab", "aurab", "URf", "URb", "acerab", "hra", "turr"], "ret": ["orig", "fin", "success", "hash", "resp", "nt", "pat", "count", "match", "result", "obj", "eth", "sat", "rt", "att", "val", "alt", "res", "full", " RET", "det", "valid", "reply", "fun", "url", "rc", "num", "reg", "rets", "arg", "id", "rev", "opt", "no", "let", "lit", "arr", "re", "RET", "red", "back", "bit", "pass", "ref", "len", "Ret", "code"]}}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int dshow_read_header(AVFormatContext *avctx)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IGraphBuilder *graph = NULL;\n\n    ICreateDevEnum *devenum = NULL;\n\n    IMediaControl *control = NULL;\n\n    IMediaEvent *media_event = NULL;\n\n    HANDLE media_event_handle;\n\n    HANDLE proc;\n\n    int ret = AVERROR(EIO);\n\n    int r;\n\n\n\n    CoInitialize(0);\n\n\n\n    if (!ctx->list_devices && !parse_device_name(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Malformed dshow input string.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id\n\n                                                : AV_CODEC_ID_RAWVIDEO;\n\n    if (ctx->pixel_format != AV_PIX_FMT_NONE) {\n\n        if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Pixel format may only be set when \"\n\n                              \"video codec is not set or set to rawvideo\\n\");\n\n            ret = AVERROR(EINVAL);\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->framerate) {\n\n        r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);\n\n        if (r < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not parse framerate '%s'.\\n\", ctx->framerate);\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_IGraphBuilder, (void **) &graph);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create capture graph.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->graph = graph;\n\n\n\n    r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_ICreateDevEnum, (void **) &devenum);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate system devices.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->list_devices) {\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow video devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, VideoDevice, NULL);\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow audio devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, AudioDevice, NULL);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n    if (ctx->list_options) {\n\n        if (ctx->device_name[VideoDevice])\n\n            dshow_list_device_options(avctx, devenum, VideoDevice);\n\n        if (ctx->device_name[AudioDevice])\n\n            dshow_list_device_options(avctx, devenum, AudioDevice);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->device_name[VideoDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, VideoDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, VideoDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->device_name[AudioDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, AudioDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, AudioDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    ctx->mutex = CreateMutex(NULL, 0, NULL);\n\n    if (!ctx->mutex) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Mutex\\n\");\n\n        goto error;\n\n    }\n\n    ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);\n\n    if (!ctx->event[1]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Event\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media control.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->control = control;\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->media_event = media_event;\n\n\n\n    r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event handle.\\n\");\n\n        goto error;\n\n    }\n\n    proc = GetCurrentProcess();\n\n    r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0],\n\n                        0, 0, DUPLICATE_SAME_ACCESS);\n\n    if (!r) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not duplicate media event handle.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IMediaControl_Run(control);\n\n    if (r == S_FALSE) {\n\n        OAFilterState pfs;\n\n        r = IMediaControl_GetState(control, 0, &pfs);\n\n    }\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not run filter\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nerror:\n\n\n\n    if (devenum)\n\n        ICreateDevEnum_Release(devenum);\n\n\n\n    if (ret < 0)\n\n        dshow_read_close(avctx);\n\n\n\n    return ret;\n\n}\n", "idx": 13429, "substitutes": {"avctx": ["avelc", "avvoc", "apcb", "avcfg", "avsci", "avci", "avepkg", "avcf", "Avcu", "avecfg", "Avcb", "afctx", "avlc", "avectl", "AVcb", "avecca", "aircomponent", "AVcomponent", "AVconn", "appkg", "airsci", "apcontext", "afcontext", "avevoc", "akctx", "AVlc", "akcontext", "navcomponent", "navctx", "avctl", "avectx", "apsci", "avpkg", "aircfg", "AVctx", "airctx", "Avcf", "AVcf", "AVcu", "AVcfg", "aflc", "navcu", "Avctl", "Avcontext", "avecf", "apctx", " avcontext", "avecoll", "Avctx", "avcb", "aircontext", "aircu", "avcomponent", "avcu", "afci", "afconn", "AVctl", "avesci", "airci", "AVcca", "navcontext", "AVcoll", "avconn", " avvoc", "AVcontext", " avcoll", "akcu", "avcca", "airctl", "AVpkg", "aveconn", "avcoll", "AVvoc", "avecb", "akctl", "AVci", "aveci", "afcca", "AVsci", "apcf", "avecontext", "avcontext"], "ctx": ["client", "sync", "cam", "hub", "connection", "cu", "cn", "exec", "cm", "tc", "sc", "cs", "nc", "bc", "pkg", "sci", "cf", "cfg", "cmd", "cb", "kb", "qa", "anc", "gc", "wp", "Context", "cc", "cmp", "dc", "concept", "ga", "conf", "hw", "rc", "config", "cca", "lc", "ck", "cus", "chan", "wx", "vc", "ci", "np", "fc", "context", "c", "conv", "cp", "cli", "component", "scope", "cl", "cal", "coll", "kw", "ctrl", "tx", "css", "crit", "acl", "ca", "utils", "wcs", "xc", "loc", "fw", "conn", "cms", "cas", "cv"], "graph": ["client", "module", "document", "connection", "proxy", "flow", "edge", "data", "draw", "subject", "tree", "media", "image", "result", "container", "format", "network", "model", "gpu", "query", "path", "shape", "root", "group", "m", "comment", "raph", "config", "host", "g", "method", "chan", "view", "block", "id", "growth", "feed", "node", "context", "h", "plot", "Graph", "layout", "index", "scope", "p", "ctrl", "gen", "f", "handle", "j", "gd", "connect", "conn", "driver", "function"], "devenum": ["devinnum", "DEvinum", "devernnum", "devennum", "deVENum", "devenUM", "devernum", "DEzenum", "devinum", "devasUM", "DEvennum", "devenums", "dezennum", "DEvenum", "deuxenum", "dezenam", "deVENums", "deuxum", "DEvenam", "devinenum", "deuxums", "devenenum", "devernUM", "DEvinnum", "DEvenums", "devasum", "deVENenum", "dezenUM", "devernam", "dezenum", "DEzennum", "deuxnum", "devasam", "devinums", "DEvenenum", "devenam", "DEzenUM", "DEzenam", "DEvenUM", "devasnum", "DEvinenum", "DEvinums", "deVENnum"], "control": ["card", " controls", "flow", "exec", "trl", "command", "media", "model", "attr", "form", "comment", "config", "edit", "roll", "channel", "method", "Control", "feed", "change", "layout", "ctrl", "ack", "crit", "controller", "connect", "support", "rol"], "media_event": ["video_event", "video_events", "video_image", "media_events", "media_image", "video_object", "media_object"], "media_event_handle": ["media_image_object", "media_image_handle", "media_event_Handle", "media_event_event", "media_image_Handle", "media_image_event", "media_event_object"], "proc": [" PROC", "func", "PC", "exec", " processor", " exec", "loop", "PR", " process", "process", "pc", "script", "cb", "Process", "processor", "callback", " prod", " prog", "frame", "config", " procedure", " PE", "p", "lib", "ctrl", "src", "console", "handle"], "r": ["d", "o", "dr", "rs", "ar", "R", "rar", "v", "ur", "br", "e", "result", "rh", "rt", " rc", "l", "kr", "res", "rf", "m", "lr", "nr", " ret", "rr", "str", "error", "rc", " re", "pr", " p", "k", "rb", "self", "g", "n", "fr", "hr", "c", "q", "i", "h", "x", " sr", "p", " R", "s", "b", "run", "mr", "arr", "sr", "f", "re", "cr", " res", "or", "ner", "err", "er", "rn", "rg", "j", "ret", "t", "var"]}}
{"project": "qemu", "commit_id": "274250c30158f60aefb46088a7bb0d711061226c", "target": 1, "func": "static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}", "idx": 13437, "substitutes": {"obj": ["module", "sync", "ct", "fail", "o", "ad", "ass", "dr", "tmp", "cn", "jp", "empty", "po", "oid", "fn", "act", "op", "result", "oa", "cb", "att", "Object", "ob", "alt", "y", "object", "objects", "m", "el", "az", "api", "str", "eff", "parent", "g", "ck", "bh", "self", "class", "rb", "n", "os", "boot", "nb", "ctx", "id", "node", "bot", "x", "args", "cp", "p", "lib", "od", "cat", "b", "ex", "kw", "Obj", "false", "sb", "bo", "js", "xxx", "stat", "j", "old", "t", "none", "bm", "code"]}}
{"project": "FFmpeg", "commit_id": "d86d7b2486cd5c31db8e820d8a89554abf19567e", "target": 0, "func": "static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform)\n\n{\n\n    int i, mb_x, mb_y;\n\n    uint16_t (*buffer)[4];\n\n    int left[4], top[4], topleft[4];\n\n    const int linesize = s->linesize[0];\n\n    const int mask     = ((1 << s->bits) - 1) << point_transform;\n\n    int resync_mb_y = 0;\n\n    int resync_mb_x = 0;\n\n\n\n    if (s->nb_components != 3 && s->nb_components != 4)\n\n        return AVERROR_INVALIDDATA;\n\n    if (s->v_max != 1 || s->h_max != 1 || !s->lossless)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n\n    s->restart_count = s->restart_interval;\n\n\n\n    av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,\n\n                   (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));\n\n    buffer = s->ljpeg_buffer;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        buffer[0][i] = 1 << (s->bits - 1);\n\n\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n\n        uint8_t *ptr = s->picture_ptr->data[0] + (linesize * mb_y);\n\n\n\n        if (s->interlaced && s->bottom_field)\n\n            ptr += linesize >> 1;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            top[i] = left[i] = topleft[i] = buffer[0][i];\n\n\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int modified_predictor = predictor;\n\n\n\n            if (s->restart_interval && !s->restart_count){\n\n                s->restart_count = s->restart_interval;\n\n                resync_mb_x = mb_x;\n\n                resync_mb_y = mb_y;\n\n                for(i=0; i<4; i++)\n\n                    top[i] = left[i]= topleft[i]= 1 << (s->bits - 1);\n\n            }\n\n            if (mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || !mb_x)\n\n                modified_predictor = 1;\n\n\n\n            for (i=0;i<nb_components;i++) {\n\n                int pred, dc;\n\n\n\n                topleft[i] = top[i];\n\n                top[i]     = buffer[mb_x][i];\n\n\n\n                PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                dc = mjpeg_decode_dc(s, s->dc_index[i]);\n\n                if(dc == 0xFFFFF)\n\n                    return -1;\n\n\n\n                left[i] = buffer[mb_x][i] =\n\n                    mask & (pred + (dc << point_transform));\n\n            }\n\n\n\n            if (s->restart_interval && !--s->restart_count) {\n\n                align_get_bits(&s->gb);\n\n                skip_bits(&s->gb, 16); /* skip RSTn */\n\n            }\n\n        }\n\n        if (s->rct && s->nb_components == 4) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[4*mb_x + 2] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[4*mb_x + 1] = buffer[mb_x][1] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 3] = buffer[mb_x][2] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 0] = buffer[mb_x][3];\n\n            }\n\n        } else if (s->nb_components == 4) {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[4*mb_x+3-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[4*mb_x+c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        } else if (s->rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else if (s->pegasus_rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13442, "substitutes": {"s": ["hs", "session", "site", "v", "u", "ts", "its", "states", "sys", "si", "se", "m", "ims", "plugins", "xs", "self", "n", "spec", "h", "qs", "sb", "js", "services", "t", "rates", "ps", "fs", "sync", "your", "ins", "e", "cs", "parts", "ss", "y", "ssl", "new", "sq", "gs", "sf", "a", "is", "c", "x", "sg", "ns", "series", "settings", "bis", "us", "changes", "styles", "l", "ds", "service", "this", "stats", "ses", "ms", "sym", "S", "ops", "comments", "d", "sv", "rs", "strings", "secondary", "features", "params", "space", "full", "g", "es", "ks", "os", "su", "p", "b", "sets", "f", "w", "ls", "conf", "support"], "nb_components": ["nb_chonents", "nb_compators", "nb_compords", "nb_distonents", "nbofcomponentonent", "nb_Components", "nb_distounds", "nbofcomponentonents", "nb_distators", "nb_complements", "nbofcomponentixels", "nbofcompixels", "nb_component", "nb_Component", "nb_conent", "nb_chonent", "nb_componentonents", "nb_sconents", "nb_sconent", "nb_componentixels", "nb_scords", "nb_comords", "nb_comonents", "nb_compixels", "nb_Complements", "nb_distonent", "nb_comounds", "nbofcomponent", "nb_comixels", "nbofcomponents", "nb_compounds", "nb_conents", "nb_sclements", "nb_Compords", "nb_cators", "nb_counds", "nb_comonent", "nb_componentonent", "nb_comlements", "nb_chixels", "nb_comators"], "predictor": ["ppriitor", "priptator", "predictator", "pprior", "compveyutor", "priptor", "pcessions", "pcessator", "pacheror", "compredictator", "pcredictor", "compveyator", "pcriptitor", "pacheritor", "pcessor", "ppriator", "pcriptator", "pcriptistor", "compveyions", "predictutor", "presentator", "pveyor", "predictitor", "priptistor", "predictions", "presentutor", "compredictor", "pcessutor", "pcredictistor", "presentor", "pveyions", "pcredictitor", "compredictutor", "ppriistor", "predictistor", "pcredictator", "pveyator", "compredictions", "presentions", "pveyutor", "pacherator", "pcriptor", "priptitor", "pacheristor", "compveyor"], "point_transform": ["int_shape", "int_size", " point_scale", "point2scale", "point_scale", "point_shape", "point_size", "point2mask", "point_mask", " point_trans", "int_transform", "int_scale", "point_trans", " point_mask", "point2trans", "point2transform"], "i": ["it", "ini", "v", "u", "pi", "si", "in", "ui", "m", "ix", "n", "init", "h", "ni", "start", "ind", "j", "ii", "I", "ie", "o", "my", "li", "e", "image", "y", "slice", "ti", "eni", "id", "bi", "qi", "phi", "ip", "c", "x", "hi", "ri", "yi", "di", "gi", "fi", "data", "multi", "count", "l", "size", "ai", "io", "q", "type", "name", "zi", "d", "chi", "iu", "mi", "xi", "base", "uri", "g", "k", "z", "ci", "mini", "info", "ki", "p", "index", "b", "f"], "mb_x": ["mbPwidth", "mbUt", "mbFt", "amb_sex", "mbUex", "mp_wy", "mb_z", "embPwidth", "mb_t", "mbFx", "mb67x", "amb_z", "mbPx", "mb_cross", "mb67name", "emb_width", "mb_width", "emb_y", "mbUx", "ambIdz", "mp_ex", "mp_xs", "mbIdrx", "mbPy", "ambIdrx", "mbFex", "mbFcross", "mb_rx", "mp_z", "mbIdz", "mb_wy", "embPw", "mbIdx", "embPy", "mp_y", "mp_name", "mb_w", "mb_xs", "mb_name", "embPx", "ambIdx", "mbPw", "mbIdsex", "emb_x", "mb_sex", "emb_w", "mbUcross", "amb_x", "mp_t", "mp_cross", "mb67y", "mp_x", "mb_ex", "mb67z", "amb_rx", "ambIdsex"], "mb_y": ["bg_ady", "emb_cy", "mbPcy", "mp_ny", "mb_zy", "em_ery", "mbPx", "mbPyl", "emb_y", "mbUny", "mbUx", "mbPya", "mb_vy", "embPcy", "bg_y", "mbPy", "bg_ym", "mb_i", "mb_cy", "em_zy", "mp_ey", "mbPvy", "mb_ya", "mbPi", "em_ey", "embPy", "mb_ym", "mp_y", "mb33yl", "mb33y", "mbUy", "embPvy", "mb_ey", "mb_yl", "mb_ery", "mb_ady", "mbUey", "em_y", "mp_i", "emb_vy", "embPyl", "emb_yl", "mp_ya", "mb_ny", "mp_x", "bg_x", "mb33cy", "mb33vy"], "buffer": ["cube", "document", "iter", "file", "plane", "material", "pause", "position", "data", "texture", "source", "command", "image", "bc", "message", "length", "base", "server", "flash", "bin", "resource", "writer", "header", "border", "uffer", "queue", "offset", "surface", "slice", "comment", "byte", "channel", "block", "feed", "buff", "cache", "context", "memory", "input", "shell", "reference", "layer", "Buffer", "window", "b", "scroll", "table", "port", "que", "transfer", "console", "buf", "clip"], "top": ["ops", "first", "all", "front", "high", "tops", "per", "op", "pos", "output", "above", "Top", "TOP", "below", "path", "space", "limit", "super", "tip", "best", "parent", "up", "last", "maximum", "pop", "stop", "bot", "bottom", "target", "upper", "tips", "p", "min", "master", "platform", "tail", "stack", "support"], "topleft": ["trouplet", " tourgent", "tyleplet", "toplefts", "toplekt", "tourft", "strouvel", "toulft", "stoplekt", "topleaft", "strouplet", "touraft", "topleplet", "stoplevel", "stroukt", "toulvel", " tourfts", " tourft", "tourfts", "tourgent", "tOPLEgent", "toplevel", "toulkt", "trieft", "toplegent", "toulplet", "tyleft", "tylevel", "tOPLEfts", "stopleplet", "trouvel", "stopleft", "tylekt", " toplefts", " touraft", " topleaft", "tOPLEaft", "triegent", "trieaft", " toplegent", "strouft", "triefts", "trouft", "troukt", "tOPLEft"], "ptr": ["fp", "prot", "ctr", "address", "dr", "butt", "br", "Ptr", "obj", "fe", "pt", "pos", "nil", "pad", "tile", "attr", "map", "offset", "slice", "inst", "pri", "xp", "rc", "tr", "fr", "iv", "ctx", "peer", "pointer", "addr", "ext", "scope", "arr", "src", "inter", "buf", "j", "loc", "ref", "stack", "code"], "restart_count": ["restardPoolpart", "restartFmultiple", "restart_part", "restart_index", "restort_count", "restarmFcache", "restarm_count", "restardPoolindex", "restartFcache", "restard_index", "restartClength", "restartCcount", "restardPoolcount", "restartCtype", "restard_part", "restart64part", "restort_code", "restort_length", "restart64index", "restard_count", "restort_type", "restarm_multiple", "restartCcode", "restarmFcount", "restart_cache", "restart64count", "restartPoolcount", "restart_length", "restarm_cache", "restartFcount", "restarmFmultiple", "restartPoolindex", "restartPoolpart", "restart_multiple", "restart_type", "restart_code"]}}
{"project": "qemu", "commit_id": "b5e751b51f14cffada6be647aa576b79f1755d7e", "target": 1, "func": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n", "idx": 13448, "substitutes": {"con": ["client", "gate", "en", "cons", "ain", "aff", "func", "cn", "connection", "exec", "fac", "acon", "bc", "container", "fn", "cf", "pc", "conn", "ec", "dc", "contract", "hel", "uc", "pool", "rc", "sub", "un", "ac", "can", "win", "ln", "fc", "cur", "cache", "c", "conv", "core", "cat", "ran", "run", "co", "Con", "ca", "mc", "pin", "inter", " uncon", "lang", "CON", "ocon", "cell", "connect", "conf"], "ssd": [" ssda", "rssdl", "esssd", "hesssd", "amsd", "rssdk", "pssd", "essd", "ksdl", "essdd", "ssda", "csssd", "essda", "SSdc", "assds", " ssds", "cssD", "vsdk", "hessD", "essdc", "yshd", "ssdc", " ssdl", "essl", "ssl", "vssd", "ysds", "amsdd", "sssd", "ssdl", "dsd", "SSD", "cosdl", "sshd", "cssdd", "yssd", "ssdd", "hessd", "ysd", "asssd", "ssds", "ssdk", "dsds", "hessdc", "rssdc", "vsds", "amsds", "dssd", " ssdc", "hessl", "cosds", "ssD", "cssds", "cossd", "SSd", "vsd", "ksds", "cssl", "amsdc", "assdk", "psd", "ysda", "kssd", "cssd", "psdc", "cssdk", "essdl", "cosd", " sshd", "assd", "SSsd", "esshd", "essds", "rssds", "rsssd", "dsdk", "cssdc", "ysdk", "psds", "rssd", "psl", "hessds", "ksd"]}}
{"project": "FFmpeg", "commit_id": "fe7547d69e6721d064c8604d0a6375a2d24b35ca", "target": 0, "func": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n", "idx": 13462, "substitutes": {"entries": ["integrows", "endessions", "tables", "tences", "gentrants", "entrie", "ntries", "Entrys", "Entributes", "estries", "endries", "enties", "centrows", "ientrie", "trants", "entences", "estessions", "contrys", "entessions", "integuries", "ntributes", "endences", "incrows", "gentables", "genturies", "metables", "conties", "enturies", "integries", "metries", "entributes", "ntrys", "tries", "entions", "endions", "ientries", "tions", "ienturies", "entlements", "Enturies", "metrants", "settries", "settrows", "settlements", "ientrows", "entables", "tories", "gentries", "incries", "estences", "entories", "incences", "Entrie", "contrants", "ties", "entrows", "contributes", "contries", "Entries", "turies", "entrants", "ENTories", "tessions", "integrie", "ENTries", "centries", "ENTies", "centlements", "Entrows", "ENTrants", "contories", "estions", "settences", "meturies", "entrys", "inclements", "centences"], "nb_entries": ["nb_ntrs", "nb_entry", "nb_endues", "nb_endes", "nb_intues", "nb_ntry", "nb_ENTies", "nb_extents", "nbofenties", "nb_entes", "nbofentries", "nb_intrs", "nb_ntles", "nb_counties", "nbofentrys", "nb_entrys", "nb_intrants", "nb_enties", "nb_centrs", "nb_centries", "nb_centrys", "nb_entents", "nb_intles", "nb_extes", "nb_extrants", "nb_entues", "nbofentry", "nb_ENTents", "nb_ENTries", "nb_entles", "nb_entrs", "nb_ntrys", "nb_exties", "nb_entrants", "nb_endries", "nb_ntries", "nbofcentries", "nb_countries", "nb_extues", "nb_nties", "nb_ENTrs", "nb_country", "nb_extrs", "nbofcentrys", "nb_countrys", "nb_endrants", "nbofcenties", "nb_centry", "nb_centies", "nb_intes", "nbofcentry", "nb_extries", "nb_intries", "nb_centents", "nb_intry", "nb_centles"], "wanted_timestamp": ["wanted_timency", "wanted_wateremark", "wanted_Timeter", "wanted_timeestamp", "wanted_marketetime", "wanted_timest", "wanted_Timest", "wanted_timeemark", "wanted_timeeter", "wanted_shortest", "wanted_waterest", "wanted_Timeline", "wanted_semency", "wanted_timeetime", "wanted_timeline", "wanted_semest", "wanted_Timency", "wanted_timeest", "wanted_waterestamp", "wanted_tmeline", "wanted_tmest", "wanted_timeeline", "wanted_marketeter", "wanted_semestamp", "wanted_marketest", "wanted_tmency", "wanted_semetime", "wanted_timeter", "wanted_tmetime", "wanted_timemark", "wanted_Timestamp", "wanted_Timetime", "wanted_shortestamp", "wanted_timetime", "wanted_marketestamp", "wanted_shortetime", "wanted_Timemark", "wanted_tmestamp", "wanted_shorteter", "wanted_wateretime"], "flags": ["FLAG", "ids", "fs", "codes", "prot", "files", "ports", "afi", "ins", "options", "fee", "locks", "strings", "Flags", "styles", "rules", "lists", "mask", "fl", "requires", "fts", "checks", "planes", "features", "ds", "states", "types", "links", "pins", "cards", "limits", "fd", "sf", "mods", "plugins", "faces", "fun", "dates", "ages", "rets", "allows", "details", "stats", "bits", "heads", "args", "ats", "bytes", "tests", "atts", "pieces", "vals", "fo", "frames", "lines", "lf", "flag", "utils", "settings", "fields", "ags", "ants", "nl", "alls", "lag", "ops"], "a": ["d", "ba", "o", "af", "fa", "ar", "la", "e", "sa", "ap", "u", "l", "area", "na", "y", "an", "ai", "ga", "api", "ae", "aj", "n", "ac", "am", "pa", "c", "x", "i", "s", "p", "ma", "ak", "A", "f", "wa", "as", "ca", "ab", "w", "va", "r", "aa", "alpha", "j", "aaa", "da", "ad", "aw"], "b": ["binary", "body", "d", "bd", "ba", "o", "ad", "big", "bm", "bas", "ok", "v", "bf", "br", "e", "u", "bc", "be", "l", "fb", "base", "wb", "ib", "B", "ob", "cb", "job", "y", "db", "an", "machine", "bar", "reb", "lb", "ae", "bs", "emb", "bh", "z", "rb", "k", "n", "bad", "boot", "nb", "pa", "bi", "am", "c", "bp", "i", "bot", "pb", "x", "s", "bb", "p", "h", "f", "mb", "sb", "abb", "ca", "ab", "w", "r", "j", "aa", "bis", "eb"], "m": ["fm", "module", "d", "mm", "o", "month", "um", "mi", "v", "md", "cm", "im", "gm", "e", "u", "sm", "mu", "pm", "l", "model", "y", "mA", "wm", "an", "machine", "hm", "tm", "mn", "mod", "mo", "M", "ym", "om", "em", "dim", "g", "man", "z", "me", "n", "mini", "am", "pa", "c", "x", "i", "h", "s", "p", "ma", "mr", "f", "dm", "mc", "mid", "w", "ms", "j", "r", "t", "bm"], "timestamp": ["timpoint", "contineline", "timplay", "ampedoffset", "contineport", "simette", "homestamp", "temetime", "metest", "imment", "teneport", "timeetime", "metoffset", "timest", "timeta", "tmeter", "timoffset", "timeeline", "metency", "Timestamp", "tmeline", "tuneline", "Timity", "ampedemark", "meteta", "tmeta", "hometime", "metity", "tenestamp", "scheestamp", "timeline", "homeline", "mintestamp", "metemark", "Timment", "timetime", "simestamp", "imemark", "tmetime", "impoint", "monthment", "tmette", "scheetime", "templay", "tenpoint", "Timency", "imestamp", "continpoint", "hometa", "monthest", "minteline", "timeport", "simeline", "scheeline", "scheplay", "integency", "integestamp", "teneline", "timemark", "imoffset", "imest", "metetime", "tmestamp", "ampedestamp", "minteport", "simeter", "monthpoint", "Timest", "timette", "metestamp", "timity", "timeplay", "temestamp", "ampedest", "integity", "Timpoint", "timment", "timeestamp", "tuneter", "tunette", "meteline", "tunestamp", "continestamp", "mintpoint", "timeter", "monthestamp", "timency", "temeline", "integest"]}}
{"project": "FFmpeg", "commit_id": "668494acd8b20f974c7722895d4a6a14c1005f1e", "target": 1, "func": "static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)\n{\n    InputStream *ist = s->opaque;\n    FrameBuffer *buf;\n    int ret, i;\n    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)\n        return ret;\n    buf              = ist->buffer_pool;\n    ist->buffer_pool = buf->next;\n    buf->next        = NULL;\n    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {\n        av_freep(&buf->base[0]);\n        av_free(buf);\n        ist->dr1 = 0;\n        if ((ret = alloc_buffer(s, ist, &buf)) < 0)\n            return ret;\n    }\n    buf->refcount++;\n    frame->opaque        = buf;\n    frame->type          = FF_BUFFER_TYPE_USER;\n    frame->extended_data = frame->data;\n    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;\n    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {\n        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't\n        frame->data[i]     = buf->data[i];\n        frame->linesize[i] = buf->linesize[i];\n    }\n    return 0;\n}", "idx": 13468, "substitutes": {"s": ["v", "sc", "u", "ts", "sys", "si", "in", "an", "se", "m", "xs", "self", "sup", "n", "spec", "h", "qs", "frames", "src", "sb", "as", "js", "services", "t", "ps", "fs", "sync", "ins", "sim", "e", "cs", "ss", "ssl", "sq", "gs", "sf", "a", "sts", "is", "c", "sg", "ns", "sie", "sis", "us", "com", "ds", "ans", "service", "this", "vs", "sl", "ses", "sym", "S", "d", "sv", "source", "op", "sci", "bs", "g", "es", "ks", "os", "ctx", "su", "p", "b", "sets", "f", "w", "ls", "r", "conf"], "frame": ["fp", "module", "session", "uf", "draw", "fe", "cf", "cb", "fb", "ov", "m", "Frame", "seq", "component", "fx", "frames", "setup", "driver", "part", "iframe", "flow", "position", "face", "e", "image", "fl", "element", "play", "builder", "header", "slice", "sf", "block", "c", "line", "pse", "fo", "load", "buffer", "cast", "file", "plane", "fi", "flower", "data", "fram", "cfg", "object", "state", "html", "fr", "buff", "coll", "game", "framework", "ace", "code", "document", "dr", "board", "source", "rame", "feature", "za", "base", "style", "full", "player", "config", "host", "ctx", "fc", "ze", "info", "layer", "p", "layout", "f", "kt", "w", "fw"], "ist": ["it", "fp", "part", "et", "ie", "isd", "obj", "ft", "xt", "aunt", "dr", "aim", "alist", "iste", "oc", "nt", "dist", "op", "pt", "ism", "feat", "st", "ld", "act", "rt", "store", "wd", "att", "ht", "ds", "isi", "pect", "sys", "ans", "asp", "wp", "ss", "se", "oss", "IST", "adder", "inst", "edit", "ix", "osi", "ant", "ac", "est", "iss", "ctx", "ess", "dit", "ists", "is", "ide", "art", "ast", "p", "mot", "ic", "kt", "as", "ait", "ind", "ard", "ais", "er", "ace", "ost", "at", "irst", "ad"], "buf": ["fp", "uno", "uf", "obj", "cf", "cb", "fb", "ov", "lb", "seq", "rb", "box", "h", "Buffer", "fx", "gen", "src", "uber", "bf", "anim", "cmd", "builder", "header", "queue", "fd", "pool", "block", "fam", "buffer", "fac", "cast", "cas", "aux", "af", "func", "fi", "grab", "data", "bc", "bu", "ff", "fg", "fab", "wb", "runner", "buff", "home", "coll", "Buff", "que", "sov", "ref", "bd", "alloc", "board", "br", "raf", "base", "vec", "uc", "bridge", "config", "proc", "ctx", "feed", "b", "bag", "f", "loader", "fw", "img", "pb", "cv"], "ret": ["it", "fail", "part", "bd", "fin", "af", "success", "fi", "reset", "nt", "resp", "pat", "bf", "match", "result", "feat", "rt", "ib", "att", "val", "alt", "job", "def", "res", "pet", "det", "reply", "valid", "pret", "str", "fun", "rc", "error", "reg", "rets", "arg", "bad", "art", " def", "active", "let", "lit", "run", "arr", "f", "re", "RET", "flag", "red", "get", "disabled", "back", "bit", "pass", "ref", "len", "Ret", "code"], "i": ["it", "adi", "ie", "di", "o", "gi", "ini", "iu", "mi", "fi", "x", "multi", "v", "li", "e", "xi", "u", "mu", "inner", "l", "pi", "abi", "uri", "si", "vi", "in", "y", "ai", "ui", "api", "a", "c", "ti", "ix", "k", "eni", "n", "ci", "id", "io", "bi", "qi", "ip", "phi", "ami", "oi", "info", "ji", "hi", "p", "cli", "ri", "index", "type", "ni", "f", "ir", "zi", "ind", "j", "ori", "ii", "I", "yi", "code"], "refcount": ["poscount", "memCount", "rowlen", "poslow", "reflen", "reflow", "memlen", "posCount", "poslen", "rowcount", "refCount", "memlow", "rowlow", "memcount", "rowCount"]}}
{"project": "FFmpeg", "commit_id": "b8edf91657ad9fa2f0c5175c9ca8fbe3c8b0c624", "target": 0, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)\n\n{\n\n    AVFilterContext   *ctx     = inlink->dst;\n\n    HisteqContext     *histeq  = ctx->priv;\n\n    AVFilterLink      *outlink = ctx->outputs[0];\n\n    int strength  = histeq->strength  * 1000;\n\n    int intensity = histeq->intensity * 1000;\n\n    int x, y, i, luthi, lutlo, lut, luma, oluma, m;\n\n    AVFrame *outpic;\n\n    unsigned int r, g, b, jran;\n\n    uint8_t *src, *dst;\n\n\n\n    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n\n    if (!outpic) {\n\n        av_frame_free(&inpic);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    av_frame_copy_props(outpic, inpic);\n\n\n\n    /* Seed random generator for antibanding. */\n\n    jran = LCG_SEED;\n\n\n\n    /* Calculate and store the luminance and calculate the global histogram\n\n       based on the luminance. */\n\n    memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n            luma = (55 * r + 182 * g + 19 * b) >> 8;\n\n            dst[x + histeq->rgba_map[A]] = luma;\n\n            histeq->in_histogram[luma]++;\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"in[%d]: %u\\n\", x, histeq->in_histogram[x]);\n\n#endif\n\n\n\n    /* Calculate the lookup table. */\n\n    histeq->LUT[0] = histeq->in_histogram[0];\n\n    /* Accumulate */\n\n    for (x = 1; x < 256; x++)\n\n        histeq->LUT[x] = histeq->LUT[x-1] + histeq->in_histogram[x];\n\n\n\n    /* Normalize */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w);\n\n\n\n    /* Adjust the LUT based on the selected strength. This is an alpha\n\n       mix of the calculated LUT and a linear LUT with gain 1. */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 +\n\n                         ((255 - strength) * x)      / 255;\n\n\n\n    /* Output the equalized frame. */\n\n    memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram));\n\n\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            luma = dst[x + histeq->rgba_map[A]];\n\n            if (luma == 0) {\n\n                for (i = 0; i < histeq->bpp; ++i)\n\n                    dst[x + i] = 0;\n\n                histeq->out_histogram[0]++;\n\n            } else {\n\n                lut = histeq->LUT[luma];\n\n                if (histeq->antibanding != HISTEQ_ANTIBANDING_NONE) {\n\n                    if (luma > 0) {\n\n                        lutlo = histeq->antibanding == HISTEQ_ANTIBANDING_WEAK ?\n\n                                (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 :\n\n                                 histeq->LUT[luma - 1];\n\n                    } else\n\n                        lutlo = lut;\n\n\n\n                    if (luma < 255) {\n\n                        luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ?\n\n                            (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 :\n\n                             histeq->LUT[luma + 1];\n\n                    } else\n\n                        luthi = lut;\n\n\n\n                    if (lutlo != luthi) {\n\n                        jran = LCG(jran);\n\n                        lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M;\n\n                    }\n\n                }\n\n\n\n                GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n                if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) {\n\n                    r = (r * 255) / m;\n\n                    g = (g * 255) / m;\n\n                    b = (b * 255) / m;\n\n                } else {\n\n                    r = (r * lut) / luma;\n\n                    g = (g * lut) / luma;\n\n                    b = (b * lut) / luma;\n\n                }\n\n                dst[x + histeq->rgba_map[R]] = r;\n\n                dst[x + histeq->rgba_map[G]] = g;\n\n                dst[x + histeq->rgba_map[B]] = b;\n\n                oluma = (55 * r + 182 * g + 19 * b) >> 8;\n\n                histeq->out_histogram[oluma]++;\n\n            }\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"out[%d]: %u\\n\", x, histeq->out_histogram[x]);\n\n#endif\n\n\n\n    av_frame_free(&inpic);\n\n    return ff_filter_frame(outlink, outpic);\n\n}\n", "idx": 13488, "substitutes": {"inlink": ["inslock", "insline", " inplug", "inLink", "outLink", "inink", "inbug", " inlock", "outline", "inclink", "inlock", "incLink", "outink", " inink", "incink", "outfile", " inframe", " inLink", " infile", "infile", "incline", "outbug", "insLink", "inslink", "incfile", "inplug", "outframe", "incbug", "inframe", "outlock", "incplug", "incframe", " inbug", "outplug"], "inpic": ["outPic", "inpixel", "outpixel", "INpin", "npic", " outpict", "INlink", " inpixel", "INpixel", " inpin", "idpic", "outpict", " outpin", "INPic", "inpict", "outpins", " inpins", "idpin", "insPic", " inpict", "INpict", "INpins", "inpin", "idpict", "inspic", "npixel", "npict", "inspixel", " inPic", "outpin", "idframe", "outframe", "inframe", "inPic", "inspict", " outframe", "npin", "INpic", "inpins"], "ctx": ["client", "sync", "cam", "cpp", "hub", "cn", "cm", "tc", "sc", "cs", "nc", "pkg", "bc", "sci", "util", "cf", "obj", "cmd", "cb", "voc", "kb", "anc", "Context", "cc", "cmp", "concept", "sq", "hw", "rc", "config", "cca", "parent", "ck", "cus", "vc", "ci", "init", "fc", "context", "c", "conv", "mac", "cp", "lib", "cli", "kw", "ctrl", "tx", "ca", "utils", "xc", "loc", "fw", "conn", "cas", "cv"], "histeq": ["histqq", "Histue", "historyequ", "regcoe", "historycomment", " historyctx", "hyeq", "histec", "hesseq", "histcoe", "regsys", " histite", "hexcoe", "histite", "batcheq", " histne", "histq", "historycomp", "regequ", " historycoe", "Histeq", " historych", "combcoe", "hessnec", "historyq", "combeq", " historyite", "batchqq", "hapq", " histch", "historyexp", "historyqq", "historycoe", "comboise", "hapeq", "hessequ", " histcomp", "historynec", "thequ", " historyue", " histctx", "histsys", "ploteq", "theq", "regeq", "Histq", "hessoise", "plotiq", "hesscoe", "thcomp", "histue", "combequ", " historyeq", "hapne", " histq", " histexp", "hessne", "gitequ", "thne", "histiq", "histcomp", "humsys", "gitiq", " historyexp", "regcomp", "hexcomment", "historysys", "hyne", "historyne", "batchiq", "hyquant", "humiq", " histue", " historycomp", "Histquant", "histquant", "hapequ", "histcomment", "historyiq", " histec", "historych", "historyec", "histnec", "gitsys", "humeq", "batchsys", "histexp", "hexeq", "hexequ", "historyctx", " histsys", "histctx", " historysys", "hesscomment", "hyq", "Histne", " histcoe", " historyec", " historyq", "humqq", "giteq", "historyoise", "plotsys", " histequ", "historyeq", "histequ", "historyquant", "histoise", "histne", " histnec", "plotequ", "histch", "historyite", "historyue"], "outlink": ["uppic", "OutLink", "Outlink", "uplink", "downchat", " outlock", "inLink", "outLink", "offlink", "inchat", "offlock", "offlc", "outline", "inlock", " outLink", "downlink", "offpic", "outload", "downline", "upline", " outline", "outchat", "Outline", "Outload", "downlock", "offline", "outframe", "inload", "inlc", "upframe", " outlc", "offchat", "inframe", " outload", " outframe", "outlock", "outlc"], "x": ["xe", "pe", "v", "u", "work", "yx", "xs", "ix", "n", "h", "col", "sex", "fx", "pl", "xxx", "j", "any", "t", "X", "ct", "o", "my", "e", "xes", "xy", "time", "id", "c", "ww", "ax", "sw", "on", "tx", "event", "xa", "l", "XX", "dx", "ady", "xx", "xp", "wx", "axis", "q", "ph", "ex", "name", "code", "wa", "d", "xi", "full", "el", "px", "z", "k", "rx", "p", "index", "cl", "f", "w", "xc", "xt"], "y": ["ya", "d", "o", "ay", "ky", "yn", "ys", "ry", "e", "u", "yr", "yt", "l", "ny", "zy", "xy", "ym", "vy", "xx", "a", "z", "n", "ch", "id", "ey", "c", "h", "s", "p", "type", "cy", "f", "w", "Y", "yy", "j", "oy", "dy", "ye", "py", "t", "sy", "yi", "yl"], "i": ["it", "d", "e", "u", "l", "pi", "ai", "z", "k", "n", "phi", "c", "h", "hi", "ip", "s", "p", "f", "w", "j", "ii", "t", "I"], "luthi": ["luthl", "lustai", "lustli", "elustli", "eluthai", "luhli", "luthai", "eluthi", "lushli", "elusti", "lushai", "lushi", "elustai", "lustl", "luhi", "eluthli", "luhai", "lusti", "eluthl", "lushl", "luthli", "elustl", "luhl"], "lutlo": ["lstlo", "lustli", "lustlo", " lutli", "lutli", "lUTlo", "lustco", "lutco", "lutla", " lutco", "lUTla", " lstli", "lstla", " lstla", "lustla", " lstlo", "lstli", " lutla", "lstco", " lstco", "lUTli", "lUTco"], "lut": [" luti", "slut", "oldu", " ldu", " luv", "oluv", "luti", "ldu", "sluv", "sldu", "luv", "olut", "sluti", "oluti"], "luma": ["eluma", "Lma", "lma", "fluna", " lma", "eluca", "oluto", "loca", "luna", "eluc", "luto", " luv", "Luna", "kloma", "eluna", "flappa", " luc", "fluma", "eluto", "eluv", "elamin", " lamin", "floca", "oluv", "kluna", "oloca", " lappa", "luv", "olappa", "oluca", "oluc", " loca", "Luma", " luca", "luc", "kluma", "lamin", "olamin", " luna", "Loma", "lappa", "oluna", " luto", "klma", " loma", "luca", "loma"], "oluma": ["moluna", "ioluma", "ioloca", "ioluna", "oluna", "oloca", "olut", "luna", "loca", "molut", "moloca", "moluma", "iolut"], "m": ["mm", "d", "o", "mi", "v", "cm", "im", "gm", "e", "volume", "mode", "u", "mu", "mass", "l", "hm", "M", "meta", "n", "c", "h", "p", "f", "dm", "mc", "mean"], "outpic": [" outpicture", "outPic", "againpicture", "OUTproc", " outpict", " outproc", "againpict", "outpict", " outpin", " outnic", "Outpin", "OutPic", "inpict", "outpins", "mainnic", "inpicture", " outPic", "OUTpic", "againpin", "offpicture", "outpicture", "offpic", "Outpict", "netpic", "offpict", "outproc", "mainproc", "inpin", "OUTpin", "offPic", "OUTnic", "againPic", " outpins", "outpin", "againpic", "mainpic", "netpin", "netpins", "outnic", "Outpic", "inPic", "netpict", "mainpin", "inpins"], "r": ["d", "ru", "rw", "rs", "ar", "R", "v", "ur", "br", "e", "u", "l", "rf", "nr", "rr", "a", "rc", "pr", "k", "rb", "z", "n", "c", "h", "rx", "p", "mr", "sr", "f", "cr", "w", "rl", "er", "vr", "rg", "var"], "g": ["d", "gt", "gi", "v", "e", "u", "l", "pg", "group", "gh", "bg", "a", "G", "k", "reg", "n", "c", "h", "sg", "gz", "s", "p", "gg", "f", "gen", "w", "gb", "rg", "t", "gn"], "b": ["d", "o", "v", "e", "u", "l", "fb", "wb", "B", "ob", "bin", "lb", "a", "bs", "bh", "z", "rb", "k", "n", "c", "h", "s", "p", "f", "mb", "sb", "ab", "w", "j", "t"], "jran": ["jsrn", "jrn", "jra", "jrg", "jron", "jprun", "Jlan", "Jron", "Jrg", " jrun", "jrun", " jron", " jrn", "Jran", " jra", "jslan", "jpran", "Jrun", "Jrn", "jsrg", " jlan", "jsran", "jpra", "Jra", "jlan", "jpron", " jrg"], "src": ["gl", "rs", "func", "ur", "source", "sc", "dist", "image", "cb", "sel", "rob", "uri", "sys", "RGB", "ssl", "attr", "sq", "uc", "inst", "bg", "url", "rc", "config", "hl", "sub", "RC", "rb", "sup", "rin", "iv", "spec", "href", "rss", "hr", "rx", "gz", "uv", "s", "ug", "sl", "ource", "sr", "sb", "stream", "rl", "gb", "rg", "loc", "filename", "img", "dest"], "dst": ["Dsrc", "sdput", "dsts", "rste", " dest", "rsts", "Dsth", "rst", "nsrc", "Dost", "Dst", "Dste", "dsrc", " dste", "sest", "hconst", "sdsts", "dste", "Dsts", "Dput", " dput", "fost", "ssts", " dST", "DST", "sost", " dost", "Dconst", "fst", "dost", "fsts", "dest", "fsrc", " dsth", "sdst", "nST", "hST", "nconst", "dconst", "sdsth", " dsrc", "sst", "rST", "nst", "dsth", "dST", "hsrc", "hst", "Dest", " dsts", "dput"], "in_histogram": ["in_histor", "in_imageograms", "in_blograms", "in_Histograms", "in_thrice", "in_Histogue", "in_Histog", "in_Histrice", "in_historyrice", "in_pastometry", "in_historyograms", "in_logrogram", "in_historyor", "in_glory", "in_historical", "in_logograms", "in_plog", "in_histog", "in_memometry", "in_Histogram", "in_memograms", "in_historyorical", "in_Historical", "in_Histicle", "in_imageogram", "in_blorical", "in_logor", "in_plograms", "in_pastograms", "in_imageory", "in_histrice", "in_logogram", "in_glogram", "in_thogram", "in_histometry", "in_Histrogram", "in_historyogram", "in_blor", "in_Histometry", "in_history", "in_History", "in_plrogram", "in_histrogram", "in_pastogram", "in_histicle", "in_blogram", "in_histograms", "in_imageogue", "in_historyrogram", "in_glogue", "in_throgram", "in_Histor", "in_glograms", "in_historyog", "in_memogram", "in_pasticle", "in_plogram", "in_memicle", "in_thograms", "in_histogue"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n", "idx": 13494, "substitutes": {"data": ["done", "batch", "test", "options", "empty", "reader", "media", "image", "result", "inner", "dat", "style", "writer", "iterator", "object", "api", "valid", "devices", "a", "parent", "next", "class", "cache", "input", "window", "missing", "Data", "index", "used", "DATA", "loader", "xxx", "buffer", "buf", "value", "entry", "alpha", "rule", "da", "array", "function", "ad"], "unused": ["unavailable", "unaavailable", " Unuse", "Unsigned", " unavailable", " unuse", "Unused", " Unused", "unaused", "unause", "unuse", "unasigned", "Unuse", " Unavailable"]}}
{"project": "qemu", "commit_id": "353ab969730742b7392414d62f4ba9632e8cf22c", "target": 0, "func": "static void nbd_trip(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n    NBDExport *exp = client->exp;\n\n    NBDRequest *req;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n    uint32_t command;\n\n\n\n    TRACE(\"Reading request.\");\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    req = nbd_request_get(client);\n\n    ret = nbd_co_receive_request(req, &request);\n\n    if (ret == -EAGAIN) {\n\n        goto done;\n\n    }\n\n    if (ret == -EIO) {\n\n        goto out;\n\n    }\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n        goto error_reply;\n\n    }\n\n    command = request.type & NBD_CMD_MASK_COMMAND;\n\n    if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len,\n\n                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        goto invalid_request;\n\n    }\n\n\n\n    if (client->closing) {\n\n        /*\n\n         * The client may be closed when we are blocked in\n\n         * nbd_co_receive_request()\n\n         */\n\n        goto done;\n\n    }\n\n\n\n    switch (command) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        ret = blk_pread(exp->blk, request.from + exp->dev_offset,\n\n                        req->data, request.len);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_co_send_reply(req, &reply, request.len) < 0)\n\n            goto out;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = EROFS;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Writing to device\");\n\n\n\n        ret = blk_pwrite(exp->blk, request.from + exp->dev_offset,\n\n                         req->data, request.len, 0);\n\n        if (ret < 0) {\n\n            LOG(\"writing to file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        goto out;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = blk_co_flush(exp->blk);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = blk_co_discard(exp->blk, (request.from + exp->dev_offset)\n\n                                       / BDRV_SECTOR_SIZE,\n\n                             request.len / BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n    invalid_request:\n\n        reply.error = EINVAL;\n\n    error_reply:\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\ndone:\n\n    nbd_request_put(req);\n\n    return;\n\n\n\nout:\n\n    nbd_request_put(req);\n\n    client_close(client);\n\n}\n", "idx": 13504, "substitutes": {"opaque": ["ospaque", "Opaque", "opac", "opaques", "OPasso", "Opasso", "oppaques", "oppac", "OPac", "opasso", "ospac", "Opacity", "opacity", "ospacity", "ospaques", "Opac", "ospasso", "oppaque", "oppacity", "OPaques", "OPaque", "OPacity"], "client": ["prefix", "session", "address", "connection", "patch", "cm", "local", "project", "con", "image", "util", "pc", "Client", "cmd", "conn", "server", "open", "pattern", "resource", "service", "queue", "contract", "gui", "api", "cdn", "export", "host", "parent", "config", "net", "ac", "ce", "ctx", "cache", "c", "http", "bird", "input", "window", "cl", "cli", "cod", "core", "co", "public", "port", "call", "remote", "socket", "cell", "plugin", "connect", "manager", "contact"], "req": ["app", "require", "qq", "dr", "exec", "grab", "jp", "user", "reader", "requ", "resp", "ur", "patch", "ry", "data", "download", "rt", "cb", "cmd", "query", "qt", "resource", "def", "res", "conf", "queue", "tar", "respond", "sq", "form", "rr", "seq", "fun", "config", "proc", "reg", "rb", "rec", "progress", "fr", "quest", "spec", "cur", "ctx", "cache", "http", "q", "rx", "art", "info", "ext", "Request", "msg", "get", "dq", "call", "err", "load", "transfer", "r", "er", "ref", "conn", "pro"], "request": ["session", "test", "received", "requ", "resp", "query", "writer", "callback", "response", "parent", "create", "reference", "instance", "subject", "xml", "record", "worker", "consumer", "demand", "job", "hello", "resource", "header", "queue", "method", "view", "item", "input", "press", "buffer", "remote", "event", "rule", "require", "route", "task", "data", "user", "result", "message", "enter", "model", "lease", "QUEST", "object", "parse", "rec", "quest", "complete", "q", "type", "order", "report", "re", "name", "call", "reader", "search", "project", "server", "post", "frame", "config", "change", "current", "peer", "Request", "child", "transfer", "er", "r", "claim", "next"], "reply": ["prefix", "sync", "module", "part", "delete", "address", "route", "send", "connection", "proxy", "link", "resp", "apply", "repl", " replies", "force", "record", "result", "store", "match", "message", "ry", "base", "server", "query", "write", "post", "answer", "maybe", "service", "respond", "frame", "rr", "response", "comment", "parse", "rec", "replace", "rev", "cache", "bot", "shell", "notice", "info", "status", "order", "reason", "report", "child", "msg", "call", "buffer", "transfer", "remote", "entry", "back", "err", "next", "Reply"], "ret": ["gt", "success", "resp", "pat", "obj", "val", "rf", "det", "response", "reg", "rb", "rev", "flag", "back", "conn", "len", "alt", "prot", "part", "en", "fin", "tmp", "nt", "bf", "match", "format", "rt", "lt", "res", "pet", "db", "str", "error", "arg", "id", "mt", "cat", "arr", "pass", "Ret", "ft", "data", "result", "feat", "att", "valid", "fun", "key", "rets", "opt", "dev", "art", "status", "lit", "rep", "re", "out", "bit", "let", "ref", "code", "aud", "fail", "pt", "ut", "def", "url", "mem", "bot", "no", "info", "RET", "err", "rl", "old"], "command": ["communication", "module", "clear", "automatic", "bug", "route", "send", "connection", "action", "git", "sudo", "attribute", "md", "resp", "mode", "magic", "project", "three", "format", "message", "direction", "cmd", "pattern", "script", "length", "model", "delay", "query", "style", "timeout", "password", "commit", "resource", "sent", "callback", "service", "directory", "comment", "response", "method", "comm", "operation", "handler", "power", "version", "target", "type", "component", "reason", "name", "msg", "template", "buffer", "event", "which", "Command", "function", "sequence", "code"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "substitutes": {"func": ["fp", "aux", "amd", "lambda", "exec", "data", "apply", "pkg", "fn", "obj", "pc", "package", "cb", "cmd", "work", "conn", "cf", "val", "job", "callback", "attr", "super", "fun", "proc", "go", "rb", "handler", "wrapper", "ctx", "args", "rx", "addr", "ack", "unc", "f", "name", "src", "parser", "rl", "entry", "buf", "r", "rule", "wrap", "function", "code"], "opaque": ["ipesc", "oace", "ipacity", "opaques", "opaco", "operaco", " opque", "oaques", "opicit", " opaques", "ipaque", "operesc", "oicit", "oacity", "oque", "oppesc", "opque", " opacity", "operaque", "opericit", " opicit", " opace", "hopaques", "hopace", "opacity", "oaque", "ipaco", "operque", "hopacity", "oppaco", "opesc", "oppaque", "oppacity", "operacity", "opace", "hopaque"], "re": ["cre", "ru", "dr", "ren", "rs", "real", "ar", "reset", "resp", "record", "per", "ry", "e", "rt", "rel", "ro", "resource", "res", "reb", "reply", "rew", "response", "RE", "parse", "ae", "reg", "g", "pre", "Rec", "rec", "fr", "replace", "rev", "bre", "cache", "change", "rm", "rule", " rec", "arr", "gre", "entry", "r", "rg", "ret", "Re", "ref", "array", "rem", "ere"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 13517, "substitutes": {"addr": ["part", "module", "ha", "address", "alloc", "route", "dr", "ord", "amd", "ar", "data", "v", "amp", "md", "adr", "pos", "pkg", "ld", "pc", "rt", "work", "align", "pair", "uri", "alias", "attr", "offset", "filename", "nr", "rr", "seq", "rc", "config", "url", "usr", "str", "host", "rage", "id", "node", "rm", "x", "rx", "pointer", "info", "Address", "art", "layer", "index", "dd", "coord", "mr", "arr", "src", "name", "acl", "err", "vr", "rn", "r", "ace", "loc", "ref", "arm", "len", "ad", "oa"], "val": ["VAL", " value", "ay", "alloc", "all", "data", "v", "ault", "ol", "eval", "pt", "pos", "pc", "sel", "base", "def", "slot", "ival", "loc", "el", "grad", "valid", "al", "seq", "unit", "Val", "byte", "reg", "x", "rx", "ext", "index", "vol", "vals", "tx", "arr", "ind", "inter", "buffer", "buf", "value", "ret", "ref", "len"], "ptr": ["address", "dr", "alloc", "data", "br", "adr", "pt", "Ptr", "pos", "eth", "pc", "length", "pair", "pad", "attr", "offset", "slice", "fd", "inst", "xp", "rc", "proc", "pr", "tr", "point", "id", "code", "pointer", "p", "index", "pend", "src", "ind", "port", "inter", "buf", "ace", "r", "loc", "ref", "rot"], "section": ["large", "module", "address", "session", "site", "patch", "sc", "account", "se", "group", "sec", "parent", "location", "channel", "region", "character", "component", "instance", "ment", "sections", "entry", "esc", "array", "part", "position", "image", "element", "job", "fat", "tag", "offset", "slice", "shadow", "lc", "Section", "option", "socket", "storage", "environment", "route", "data", "script", "area", "sel", "size", "definition", "service", "root", "comment", "member", "division", "sector", "connection", "ion", "sect", "search", "container", "package", "server", "pair", "loc", "vision", "small", "config", "sub", "version", "layout", "core", "child", "port", "plugin", "function"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static void compute_antialias_float(MPADecodeContext *s,\n\n                              GranuleDef *g)\n\n{\n\n    float *ptr;\n\n    int n, i;\n\n\n\n    /* we antialias only \"long\" bands */\n\n    if (g->block_type == 2) {\n\n        if (!g->switch_point)\n\n            return;\n\n        /* XXX: check this for 8000Hz case */\n\n        n = 1;\n\n    } else {\n\n        n = SBLIMIT - 1;\n\n    }\n\n\n\n    ptr = g->sb_hybrid + 18;\n\n    for(i = n;i > 0;i--) {\n\n        float tmp0, tmp1;\n\n        float *csa = &csa_table_float[0][0];\n\n#define FLOAT_AA(j)\\\n\n        tmp0= ptr[-1-j];\\\n\n        tmp1= ptr[   j];\\\n\n        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\\\n\n        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];\n\n\n\n        FLOAT_AA(0)\n\n        FLOAT_AA(1)\n\n        FLOAT_AA(2)\n\n        FLOAT_AA(3)\n\n        FLOAT_AA(4)\n\n        FLOAT_AA(5)\n\n        FLOAT_AA(6)\n\n        FLOAT_AA(7)\n\n\n\n        ptr += 18;\n\n    }\n\n}\n", "idx": 13524, "substitutes": {"s": ["ps", "sync", "fs", "rs", "sc", "cs", "e", "ds", "sys", "si", "ss", "ssl", "service", "m", "sq", "gs", "sec", "c", "sg", "ns", "p", "ses", "parser", "r", "services", "S", "css"], "g": ["d", "gl", "v", "ge", "gm", "e", "u", "bc", "cfg", "gas", "l", "eg", "ga", "m", "ig", "group", "gh", "gs", "G", "k", "self", "gu", "gam", "c", "q", "h", "sg", "p", "b", "gg", "f", "gen", "w", "gp", "j", "t"], "ptr": ["fp", "trace", "ne", "ctr", "rw", "alloc", "dr", "tmp", "tp", "shift", "jp", "nt", "e", "Ptr", "pt", "pos", "ff", "fe", "length", "size", "pair", "xff", "sp", "attr", "offset", "fd", "inst", "xp", "aj", "tr", "z", "np", "buff", "eger", "pointer", "addr", "ext", "p", "index", "arr", "f", "src", "start", "ind", "dy", "r", "j", "ii", "loc", "xt", "t", "len", "code"], "n": ["en", "d", "adj", "o", "ne", "nn", "pn", "nt", "e", "u", "nc", "network", "l", "size", "in", "an", "m", "nr", "a", "num", "un", "k", "z", "nb", "N", "x", "c", "p", "ns", "index", "b", "nu", "ni", "f", "min", "w", "j", "r", "t", "len", "span", "Ns"], "i": ["it", "d", "ie", "di", "o", "gi", "ini", "mi", "iu", "t", "v", "multi", "li", "e", "u", "xi", "l", "pi", "si", "y", "ai", "m", "ui", "api", "ti", "z", "k", "eni", "ci", "io", "bi", "qi", "x", "c", "oi", "ji", "p", "b", "ni", "f", "zi", "ind", "j", "ori", "ii", "I", "yi"], "tmp0": ["temp50", "tmp2", "cp2", "temp2", "ptr50", "mp2", "mp4", "ptr2", "cp1", "temp0", "cp0", " tmp50", "tmp00", "temp4", " tmp4", "mp00", "tmp4", "cp00", "mp1", "mp0", "ptr0", " tmp2", "tmp50", "ptr1", "temp1", "temp00"], "tmp1": ["tmp2", "temp2", "ptrone", "txt2", "mp2", "txt1", "tmpone", "testone", "ptr2", "temp0", " tmpone", "test1", "test0", "txt0", "mpone", "txtone", "mp1", "mp0", "ptr0", " tmp2", "temp1", "ptr1", "tempone", "test2"], "csa": ["dss", "casas", "casa", "csva", "csas", "cass", "dsas", " csva", "dsva", "casva", " css", " csas", "css", "dsa"]}}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n", "idx": 13548, "substitutes": {"pi440fx_state": ["pi440fx_states", "pi440fx_stat", "pi440fx_config", "pi440fx_size", "pi440f_stat", "pi440fy_size", "pi440fy_state", "pi440fx__state", "pi440f_states", "pi440FX_err", "pi440fx_err", "pi440fx_style", "pi440fx_driver", "pi440FX_parent", "pi440fx__err", "pi440fx__config", "pi440fxtstyle", "pi440fy_config", "pi440fxtdriver", "pi440fx__parent", "pi440f_state", "pi440FX_config", "pi440fxtstate", "pi440fw_driver", "pi440f_config", "pi440fxtstat", "pi440fw_stat", "pi440fx_parent", "pi440fw_state", "pi440FX_state", "pi440fw_style"], "piix3_devfn": ["piix3_devicefs", "piix3_devpath", "piix3_pubfn", "piix3_devicepath", "piix3__devicef", "piix3_divpath", "piix3__divfn", "piix3__devf", "piix3__devfs", "piix3__divpath", "piix3_evfs", "piix3_evf", "piix3_divfn", "piix3__divf", "piix3_devicefn", "piix3__devpath", "piix3_devicef", "piix3__devicefs", "piix3_pubpath", "piix3_devfs", "piix3_devf", "piix3_pubf", "piix3_diskfs", "piix3_diskf", "piix3_diskfn", "piix3_divf", "piix3__devicefn", "piix3_evfn", "piix3__devfn"], "pic": ["sync", "di", "fin", "cam", "Pic", "fi", "du", "xi", "bc", "fn", "feature", "image", "pc", "feat", "pi", "sys", "bin", "nic", "doc", "bus", "lic", "ig", "pins", "pid", "dot", "quad", "sec", "dim", "lc", "config", "iv", "biz", "mini", "bi", "fc", "cache", "picture", "mac", "lib", "wire", "pict", "misc", "ic", "miss", "prop", "pin", "ku", "pick", "img"], "ram_size": ["ramenrate", "RAM_size", "gram_shape", "pool_data", "mem_ize", "ram64data", "ramensize", "pool_sized", "gram_weight", "pool_size", "ramingsize", "ram_width", "memoryensize", "ram_type", "ram64sized", "ram1width", "gram_size", "poolensize", "ram_SIZE", "ram_data", "pool_ize", "mem_size", "ram_shape", "memory_type", "ram_scale", "ramenstrength", "ram_ize", "ram64num", "ram_strength", "ramentype", "memoryentype", "gram_ize", "ram_weight", "ramenize", "mem_num", "ram1SIZE", "mem_scale", "ramingweight", "poolensized", "memory_strength", "ram1size", "ram64size", "memory_size", "ramingscale", "ram64ize", "poolendata", "ramingize", "gram_type", "ram1ize", "ram64scale", "ram_num", "poolenize", "ram_sized", "ramendata", "ramensized", "RAM_SIZE", "ram_rate", "gram_scale", "memoryenrate", "memory_rate", "RAM_ize", "memoryenstrength", "RAM_width"], "dev": ["priv", "v", "u", "m", "Dev", "reg", "rad", "spec", "cur", "init", "sd", "development", "i", "ver", "diff", "conn", "driver", "var", "debug", "serv", "du", "pub", "serial", "db", "die", "mod", "error", "block", "c", "dd", "ad", "di", "bug", "ve", "data", "user", "plug", "DEV", "ds", "bus", "comment", "ch", "dem", "av", "game", "da", "app", "ev", "cam", "der", "def", "dc", "dot", "g", "de", "gu", "mem", "info", "p", "device", "f", "prop", "w", "err", "r", "gd", "conf", "img"], "b": ["bd", "o", "ad", "bug", "hub", "bl", "v", "bf", "br", "e", "u", "bc", "obj", "be", "l", "base", "fb", "wb", "cb", "B", "bin", "val", "y", "bus", "db", "m", "lb", "bg", "a", "bs", "g", "bh", "k", "rb", "n", "boot", "nb", "c", "x", "i", "h", "p", "bb", "f", "sb", "ab", "w", "gb", "r", "t", "pb"], "d": ["o", "dt", "v", "md", "e", "u", "l", "ds", "db", "dc", "m", "g", "k", "z", "n", "id", "dh", "sd", "c", "i", "dict", "p", "dd", "f", "w", "D", "dy", "j", "t", "driver", "ad"], "s": ["ps", "fs", "sv", "o", "v", "sc", "e", "sa", "cs", "u", "l", "ds", "sys", "si", "ss", "ssl", "se", "m", "state", "sq", "gs", "a", "bs", "g", "self", "n", "os", "sd", "is", "c", "i", "su", "p", "ns", "sl", "f", "sb", "js", "w", "r", "S", "t"], "piix3": ["piisk03", "pox3", "pifixthird", "xiox2", "paixdiv", "pox2", "pox15", "pox1", "apiox03", "apiox3", "piix03", "piixed3", "piIX1", "pifixdiv", "piox3", "piius15", "piox2", "xiix03", "apiix03", "paius3", "apiix3", "xiix2", "piius3", "pix1", "paixthird", "paius03", "piiskdiv", "piix23", "piIX03", "px3", "piIX31", "piius6", "px03", "piisk3", "piican2", "piican1", "piIX2", "piiskthird", "piox6", "pix15", "piica3", "piixed03", "pix31", "pix2", "pifix3", "pifix03", "piisk6", "xiox03", "pix3", "apiox15", "piixdiv", "pox03", "piixed31", "paiusthird", "piix15", "piox31", "piox1", "pIX23", "piica23", "piox15", "apiix15", "piiusdiv", "piix2", "pifix15", "piq03", "piq3", "piixthird", "piixed23", "piica15", "piius03", "xiox3", "piq2", "pix03", "pifix23", "piix6", "piox03", "piq1", "piican3", "paix03", "piica03", "pix23", "xiix3", "piican03", "apiox23", "pIX3", "px2", "piIX23", "pIX31", "xiox1", "piIX3", "pix6", "paix3", "apiix23", "xiix1", "piix1", "pox6", "piox23", "paiusdiv", "piiusthird", "pIX03", "piix31", "piisk15"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n", "idx": 13554, "substitutes": {"env": ["estate", "enc", "en", "et", "environment", "ev", "esp", "priv", "exc", "v", "e", "end", "eng", "ec", "db", "state", "ef", "ep", "config", "emb", "ea", "eu", "cv", "iv", "np", "context", "ah", "stage", "args", "viron", "window", "scope", "here", "loader", "err", "buf", "esc", "conn", "next", "enh", "code"], "a": ["aux", "ha", "ba", "address", "ua", "ar", "data", "e", "sa", "area", "an", "ata", "ga", "ta", "api", "sta", "ae", "ea", "ada", "ac", "ia", "pa", "asha", "c", "i", "ama", "ma", "p", "b", "va", "A", "f", "as", "ca", "aa", "alpha", "da", "oa"]}}
{"project": "FFmpeg", "commit_id": "73789b85a759f3874112618120194e1712d7adcd", "target": 0, "func": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n\n{\n\n    int ret;\n\n\n\n    s->ext_audio_mask = 0;\n\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n\n        return ret;\n\n    s->gb_in = s->gb;\n\n\n\n    if ((ret = parse_frame_header(s)) < 0)\n\n        return ret;\n\n    if ((ret = alloc_sample_buffer(s)) < 0)\n\n        return ret;\n\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n\n        return ret;\n\n    if ((ret = parse_optional_info(s)) < 0)\n\n        return ret;\n\n\n\n    // Workaround for DTS in WAV\n\n    if (s->frame_size > size && s->frame_size < size + 4)\n\n        s->frame_size = size;\n\n\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13555, "substitutes": {"s": ["hs", "session", "u", "ts", "its", "sys", "si", "se", "m", "ims", "xs", "self", "spec", "i", "h", "qs", "sb", "as", "js", "or", "services", "t", "ps", "fs", "sync", "o", "ins", "cs", "e", "parts", "ions", "ss", "ssl", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "settings", "bis", "us", "l", "ds", "service", "stats", "vs", "http", "ses", "ms", "sym", "S", "ops", "comments", "d", "rs", "features", "server", "uns", "g", "es", "ks", "os", "args", "su", "p", "b", "sets", "f", "w", "parser", "er", "ls", "conf"], "data": ["body", "binary", "d", "o", "address", "draw", "raw", "source", "mode", "image", "base", "dat", "bin", "in", "ui", "slice", "a", "da", "scale", "cache", "x", "input", "memory", "i", "window", "p", "device", "Data", "start", "f", "as", "DATA", "buffer", "sample", "buf", "len"], "size": ["en", "address", "fee", "Size", "empty", "cm", "mode", "use", "length", "shape", "ui", "offset", "form", "sec", "unit", "small", "scale", "iz", "time", "six", "n", "sized", "capacity", "name", "SIZE", "general", "loc", "sum", "ize", "len", "number", "from", "code"], "ret": ["gt", "success", "reset", "resp", "obj", "cb", "val", "det", "reg", "rb", "bad", "rev", "flag", "back", "value", "conn", "len", "alt", "part", "debug", "bf", "nt", "match", "format", "rt", "job", "gc", "res", "error", "arg", "id", "over", "mt", "off", "cat", "arr", "red", "pass", "Ret", "ft", "af", "result", "att", "fit", "valid", "pret", "fun", "rc", "usr", "key", "rets", "replace", "opt", "art", "status", "active", "lit", "run", "rep", "re", "out", "get", "let", "ref", "fail", "op", "base", "def", "reply", "url", "f", "RET"]}}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 13556, "substitutes": {"dc": ["d", "dt", "cam", "director", "cm", "tc", "sc", "nc", "bc", "cd", "pc", "cf", "icc", "doc", "ec", "cc", "cow", "db", "uc", "fd", "cdn", "rc", "lc", "cca", "cot", "config", "df", "ac", "DC", "vc", "fc", "context", "c", " DC", "CC", "dm", "cr", "ca", "mc", "cci", "design", "conn", "da", "jc"], "dest": ["orig", "d", "di", "ctr", "route", " Dest", "decl", "txt", "du", "source", "dist", "sc", "dir", "comb", "rest", "desc", "cb", "wd", "wb", "nom", "path", "destroy", "dep", "loc", "cdn", "config", "usr", "de", "home", "dev", "coord", "target", "core", "src", "Dest", "nw", "gd"], "srca": ["destb", "sourceb", "srcA", "desta", "sourcea", "destA", "sourceA", " srcA"], "srcb": ["srcv", "rcb", "destB", "destb", "desta", " srcB", "scB", "srcB", "rcB", "rca", "scv", "rcv", " srcv", "scb", "sca"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static int decode_init_mp3on4(AVCodecContext * avctx)\n\n{\n\n    MP3On4DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Codec extradata missing or too short.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;\n\n    s->frames = mp3Frames[s->chan_cfg];\n\n    if(!s->frames) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid channel config number.\\n\");\n\n        return -1;\n\n    }\n\n    avctx->channels = mp3Channels[s->chan_cfg];\n\n\n\n    /* Init the first mp3 decoder in standard way, so that all tables get builded\n\n     * We replace avctx->priv_data with the context of the first decoder so that\n\n     * decode_init() does not have to be changed.\n\n     * Other decoders will be inited here copying data from the first context\n\n     */\n\n    // Allocate zeroed memory for the first decoder context\n\n    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));\n\n    // Put decoder context in place to make init_decode() happy\n\n    avctx->priv_data = s->mp3decctx[0];\n\n    decode_init(avctx);\n\n    // Restore mp3on4 context pointer\n\n    avctx->priv_data = s;\n\n    s->mp3decctx[0]->adu_mode = 1; // Set adu mode\n\n\n\n    /* Create a separate codec/context for each frame (first is already ok).\n\n     * Each frame is 1 or 2 channels - up to 5 frames allowed\n\n     */\n\n    for (i = 1; i < s->frames; i++) {\n\n        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));\n\n        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;\n\n        s->mp3decctx[i]->adu_mode = 1;\n\n        s->mp3decctx[i]->avctx = avctx;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13571, "substitutes": {"avctx": ["ajsci", "avenc", "afsci", "afconfig", "aveconfig", "avsci", "avci", "avcf", "avbc", "ajcu", "avcms", "afcoll", "afcms", "mpctx", "abcb", "afctx", "Avkw", "afcas", "Avconn", "avtx", "amcas", "absci", "amcontext", "ajctx", "apcontext", "akpkg", "afcontext", "akctx", "akcontext", "AVcmp", "afpkg", "navctx", "avectx", "avpkg", "afnc", " avkw", "avetx", "abcontext", "AVctx", "airctx", "AVcu", "amctx", "avnc", "ajcoll", "ajcontext", "akci", "mpconn", "akcmp", "abpkg", "ajbc", "Avcontext", "avecf", "apctx", " avcontext", "amcms", "afbc", "aircas", "ajci", "Avctx", "avecoll", "aircms", "aktx", "avcb", "avkw", "afcf", "aircontext", "abcu", "awctx", "afci", "avcu", "afconn", "afcmp", "apcmp", "mpcu", "aftx", "afcu", "navsci", "avesci", "awcu", "navcontext", "avconn", "avebc", "avcmp", "ajnc", "AVcontext", "apcu", "awconfig", "avconfig", "aveconn", "avecu", "avcoll", "abcmp", "awcontext", " avconn", "abctx", "avecb", "mpcontext", "aveci", "navcmp", "afkw", "AVsci", "akcf", "avcas", "avecontext", "afcb", "avcontext"], "s": ["session", "u", "ts", "its", "states", "sys", "si", "m", "ims", "xs", "sup", "self", "n", "spec", "h", "qs", "sb", "as", "js", "services", "t", "ps", "fs", "sync", "o", "your", "ins", "cs", "e", "parts", "ss", "ssl", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "us", "l", "ds", "ans", "service", "this", "stats", "vs", "ses", "ms", "members", "sym", "S", "ops", "comments", "rs", "strings", "params", "full", "uns", "g", "es", "ks", "os", "ctx", "su", "args", "p", "b", "aws", "sets", "f", "w", "ls", "r", "conf"], "i": ["adi", "anti", "it", "d", "ie", "di", "o", "gi", "chi", "ini", "iu", "fi", "mi", "v", "im", "li", "multi", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "y", "ai", "ui", "api", "a", "ti", "k", "ix", "n", "ci", "io", "id", "mini", "bi", "iv", "qi", "ip", "c", "phi", "x", "hi", "oi", "ji", "p", "cli", "index", "ri", "b", "info", "ni", "f", "manager", "ind", "j", "ori", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "substitutes": {}}
{"project": "qemu", "commit_id": "8dc7a7725bd6db2aa7e3c09b49bc21a1a25f40cb", "target": 1, "func": "static void curl_readv_bh_cb(void *p)\n\n{\n\n    CURLState *state;\n\n    int running;\n\n\n\n    CURLAIOCB *acb = p;\n\n    BDRVCURLState *s = acb->common.bs->opaque;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n\n\n    size_t start = acb->sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n    state = curl_init_state(s);\n\n    if (!state) {\n\n        acb->common.cb(acb->common.opaque, -EIO);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->start = 0;\n\n    acb->end = (acb->nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    g_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + s->readahead_size;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = g_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%zd-%zd\", start, end);\n\n    DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\",\n\n            (acb->nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n\n\n    /* Tell curl it needs to kick things off */\n\n    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n}\n", "idx": 13604, "substitutes": {"p": ["ps", "fp", "o", "pe", "tp", "ar", "jp", "patch", "per", "param", "op", "ap", "pkg", "pc", "pi", "P", "pp", "wp", "m", "pid", "pre", "n", "np", "pa", "bp", "c", "i", "h", "cp", "pointer", "b", "f", "pl", "pin", "r", "t", "pb"], "state": ["session", "address", "check", "pe", "list", "pos", "output", "work", "open", "states", "se", "parent", "self", "date", "set", "scope", "start", "back", "j", "conn", "t", "part", "sync", "o", "seed", "e", "match", "use", "State", "resource", "ss", "new", "tag", "slice", "str", "error", "view", "last", "cache", "is", "close", "cal", "rate", "settings", "stat", "event", "rule", "manager", "update", "bug", "the", "user", "st", "message", "l", "area", "service", "root", "al", "comment", "parse", "key", "ce", "art", "status", "type", "sl", "name", "ace", "body", "ass", "private", "source", "style", "ose", "post", "grade", "sp", "config", "STATE", "k", "os", "change", "no", "args", "info", "core", "range", "port", "err", "old"], "running": ["done", "live", "using", "available", "tmp", "thread", "loop", "mode", "result", "testing", "Running", "base", "working", " starting", "starting", "playing", "reading", "standing", "padding", " performing", "finished", "runner", "valid", " Running", "unit", " remaining", "id", "cur", "current", "runs", "stable", "active", "type", "ending", "blocking", "run", " sleeping", "name", "connected", " continuing", " blocking", "loading", "bound"], "acb": ["axmb", "icbb", "acf", "ecbb", "ancf", "ancb", "icsb", "accl", "acbe", "AcB", "ecbs", "icl", " acl", "ackmb", "ancbe", "ackb", "ecn", "ecB", "ecb", "ecab", "ocbb", "acurl", "icv", "ancbb", " acf", "accjob", "ACbb", "ocbr", "icgb", "ACb", "acbb", "aka", "Acl", "ocfb", "ACl", "ecl", "ACf", "icp", "arcsb", "ecf", "acca", " acsb", "icB", "icbs", "ackfb", " acB", " acp", "akb", "aclb", "acbas", "aclf", "acsbas", "ecp", "Acp", "accbe", "icf", "acsbb", "accn", "acgb", "icb", "ocsb", "ocbs", " acbs", "ocp", "arcb", " acurl", "ancl", "ackbb", "acll", "acv", "Acf", "accbb", "arcbb", "ocmb", "ocbas", "acfb", "acab", "accsb", "ecsb", "acssb", "aclurl", "axbb", "ACp", "accbr", "accp", "acp", "acljob", "acbr", "ocB", "acsb", "akbb", "acjob", "ACurl", "acmb", "ACsb", "aclgb", "axfb", "akf", "accbas", "icbr", "acB", "ocl", "aclp", " acjob", " aca", "akbs", "acn", "aca", "akbe", "ACbe", "ocf", "Acbb", "arcab", "ecv", "aclbb", "axb", "ocv", " acbb", "accb", "acl", "ocb", "accf", "accab", "Acb", "ancbs", " acgb", " acbe", "acbs", "ACn"], "s": ["ps", "fs", "sync", "d", "us", "o", "session", "site", "rs", "south", "t", "secondary", "e", "sa", "cs", "ts", "its", "params", "ds", "server", "states", "sys", "si", "ss", "service", "ssl", "new", "conf", "sq", "gs", "sf", "a", "bs", "g", "es", "ks", "self", "n", "os", "spec", "stats", "is", "c", "http", "args", "sg", "secure", "ns", "scope", "b", "sl", "f", "sb", "ses", "js", "settings", "stat", "ls", "services", "sym", "S", "r", "bis"], "end": ["update", "en", "address", "append", "nd", "all", "edge", "v", "after", "e", "pos", "until", "ff", "inner", "use", "head", "length", "size", "open", "End", "rest", "post", "ended", "el", "offset", "limit", "last", "z", "add", "est", "id", "then", "stop", "change", "max", "line", "set", "ail", "range", "index", "close", "off", "ending", "one", "begin", "ension", "b", "run", "start", "row", "ind", "w", "mid", "END", "entry", "enable", "event", "old", "len", "ad"]}}
{"project": "FFmpeg", "commit_id": "3a83b2461e4ce9d48ad6ab037eb14569d0e53506", "target": 1, "func": "static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)\n\n{\n\n    int lambda, up_step, down_step;\n\n    int last_lower = INT_MAX, last_higher = 0;\n\n    int x, y, q;\n\n\n\n    for (q = 1; q < avctx->qmax; q++) {\n\n        ctx->qscale = q;\n\n        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);\n\n    }\n\n    up_step = down_step = 2<<LAMBDA_FRAC_BITS;\n\n    lambda = ctx->lambda;\n\n\n\n    for (;;) {\n\n        int bits = 0;\n\n        int end = 0;\n\n        if (lambda == last_higher) {\n\n            lambda++;\n\n            end = 1; // need to set final qscales/bits\n\n        }\n\n        for (y = 0; y < ctx->m.mb_height; y++) {\n\n            for (x = 0; x < ctx->m.mb_width; x++) {\n\n                unsigned min = UINT_MAX;\n\n                int qscale = 1;\n\n                int mb = y*ctx->m.mb_width+x;\n\n                for (q = 1; q < avctx->qmax; q++) {\n\n                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);\n\n                    if (score < min) {\n\n                        min = score;\n\n                        qscale = q;\n\n                    }\n\n                }\n\n                bits += ctx->mb_rc[qscale][mb].bits;\n\n                ctx->mb_qscale[mb] = qscale;\n\n                ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits;\n\n            }\n\n            bits = (bits+31)&~31; // padding\n\n            if (bits > ctx->frame_bits)\n\n                break;\n\n        }\n\n        //av_dlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\",\n\n        //        lambda, last_higher, last_lower, bits, ctx->frame_bits);\n\n        if (end) {\n\n            if (bits > ctx->frame_bits)\n\n                return -1;\n\n            break;\n\n        }\n\n        if (bits < ctx->frame_bits) {\n\n            last_lower = FFMIN(lambda, last_lower);\n\n            if (last_higher != 0)\n\n                lambda = (lambda+last_higher)>>1;\n\n            else\n\n                lambda -= down_step;\n\n            down_step *= 5; // XXX tune ?\n\n            up_step = 1<<LAMBDA_FRAC_BITS;\n\n            lambda = FFMAX(1, lambda);\n\n            if (lambda == last_lower)\n\n                break;\n\n        } else {\n\n            last_higher = FFMAX(lambda, last_higher);\n\n            if (last_lower != INT_MAX)\n\n                lambda = (lambda+last_lower)>>1;\n\n            else if ((int64_t)lambda + up_step > INT_MAX)\n\n                return -1;\n\n            else\n\n                lambda += up_step;\n\n            up_step = FFMIN((int64_t)up_step*5, INT_MAX);\n\n            down_step = 1<<LAMBDA_FRAC_BITS;\n\n        }\n\n    }\n\n    //av_dlog(ctx->m.avctx, \"out lambda %d\\n\", lambda);\n\n    ctx->lambda = lambda;\n\n    return 0;\n\n}\n", "idx": 13635, "substitutes": {"avctx": ["Avcmp", "avcmp", "afcontext", "AVcontext", "Avcontext", "averctx", "afkb", "avcli", "AVcli", "akctrl", "akctx", "Avkb", "akcontext", "AVctrl", "Avctx", "AVcmp", "afctrl", "evctx", "akcas", "avkb", "navctx", "ahcontext", "evcu", "aircontext", "avercas", "avcu", "navconn", "ahcas", "aircli", "ahctx", "afctx", "AVctx", "avctrl", "aircmp", "avercontext", "airctx", "AVcu", "afcas", "Avcli", "evctrl", "Avcas", "averctrl", "navctrl", "evcontext", "avcas", "ahkb", "evconn", "navcontext", "avconn", "navcu", "avcontext", "AVconn"], "ctx": ["cu", "cn", "exec", "git", "sc", "act", "pkg", "cf", "cb", "cc", "concept", "cv", "mac", "component", "scope", "qs", "instance", "kw", "auc", "conn", "cms", "client", "prefix", "sync", "cs", "cmd", "scl", "gc", "sq", "hw", "lc", "cus", "context", "c", "tx", "crit", "ca", "wcs", "cas", "bc", "qt", "qa", "anc", "wp", "Context", "cmp", "cdn", "rc", "wx", "ck", "ce", "conv", "cam", "qq", "connection", "cm", "nc", "sci", "kb", "config", "cca", "vc", "ci", "cp", "history", "cli", "co", "ctrl", "kt", "acl", "utils", "console", "xc", "loc", "support", "css"], "lambda": ["ba", "pi", "partial", "ga", "ta", "api", "pha", "lam", "scale", "variable", "sha", "i", " la", "xxx", "abc", "beta", "elta", "aka", "mu", "abi", "delay", "slice", "xy", "a", "lc", "lim", "LA", "handler", "phi", "hi", "ma", "xb", "lo", "ja", "aw", "binary", "aux", "appa", "kl", "func", "data", "la", "expr", "always", "area", "dB", "l", "wb", "qa", "lu", "phase", "boost", "closure", " beta", " delta", "mas", "alpha", "da", "wa", "mega", "base", "length", "params", "quad", "ema", "layout", "cli", "p", " lam", "acl", "python", " omega", "aa", "loc", "xa", "function"], "up_step": ["up_scale", "up_sync", "up_phase", "up67steps", "down_steps", "down_phase", "down_sync", "up67step", "up_steps", "up67scale", "down_scale", "up67sync", "down_diff", "up_diff"], "down_step": ["downxsteps", "downfstep", "down_size", "up_walk", "downxstep", "downerstep", "downerslice", "down_walk", "down_slice", "downersample", "up_scale", "up_size", "down_sample", "down_weight", "up_slice", "down_STEP", "downfsteps", "down_steps", "downfSTEP", "up_steps", "downxslice", "downxsample", "down_scale", "downfscale", "downersteps", "up_sample", "up_STEP", "up_weight"], "x": ["en", "d", "o", "pe", "t", "v", "e", "u", "xi", "l", "qa", "yx", "wy", "m", "dx", "xy", "ady", "xx", "px", "ix", "z", "k", "n", "ci", "id", "i", "h", "c", "rx", "max", "p", "index", "ax", "ex", "one", "b", "ph", "fx", "tx", "f", "w", "xxx", "r", "j", "xc", "X", "code"], "y": ["ya", "d", "o", "ay", "ky", "ty", "yo", "ys", "ry", "e", "yt", "yr", "qa", "ny", "wy", "m", "xy", "zy", "ady", "ym", "vy", "g", "z", "k", "n", "ch", "id", "ey", "yp", "i", "h", "c", "p", "b", "cy", "f", "min", "w", "Y", "yy", "dy", "ye", "oy", "sy", "j", "py", "t", "sky", "yi", "gy"], "q": ["quality", "d", "ct", "mm", "bug", "qq", "check", "pe", "com", "Q", "qu", "v", "requ", "iq", "count", "u", "end", "query", "qt", "qa", "depth", "pg", "m", "queue", "quant", "sq", "quad", "gh", "ue", "time", "g", "ck", "z", "ix", "k", "view", "n", "ch", "quest", "id", "qi", "sh", "max", "h", "c", "i", "p", "req", "qs", "cl", "type", "ph", "cy", "quick", "core", "f", "mb", "row", "w", "dq", "que", "eq", "j", "r", "question", "t"]}}
{"project": "FFmpeg", "commit_id": "5a2645cafeca1c2207ac55cc831c3349572a82ed", "target": 1, "func": "static int find_and_decode_index(NUTContext *nut)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    uint64_t tmp, end;\n\n    int i, j, syncpoint_count;\n\n    int64_t filesize = avio_size(bc);\n\n    int64_t *syncpoints;\n\n    int8_t *has_keyframe;\n\n    int ret = AVERROR_INVALIDDATA;\n\n\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n\n        return ret;\n\n    }\n\n\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n\n    end += avio_tell(bc);\n\n\n\n    ffio_read_varlen(bc); // max_pts\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n\n    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);\n\n    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));\n\n    if (!syncpoints || !has_keyframe)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < syncpoint_count; i++) {\n\n        syncpoints[i] = ffio_read_varlen(bc);\n\n        if (syncpoints[i] <= 0)\n\n            goto fail;\n\n        if (i)\n\n            syncpoints[i] += syncpoints[i - 1];\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        int64_t last_pts = -1;\n\n        for (j = 0; j < syncpoint_count;) {\n\n            uint64_t x = ffio_read_varlen(bc);\n\n            int type   = x & 1;\n\n            int n      = j;\n\n            x >>= 1;\n\n            if (type) {\n\n                int flag = x & 1;\n\n                x >>= 1;\n\n                if (n + x >= syncpoint_count + 1) {\n\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n\n                    goto fail;\n\n                }\n\n                while (x--)\n\n                    has_keyframe[n++] = flag;\n\n                has_keyframe[n++] = !flag;\n\n            } else {\n\n                while (x != 1) {\n\n                    if (n >= syncpoint_count + 1) {\n\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n\n                        goto fail;\n\n                    }\n\n                    has_keyframe[n++] = x & 1;\n\n                    x >>= 1;\n\n                }\n\n            }\n\n            if (has_keyframe[0]) {\n\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n\n                goto fail;\n\n            }\n\n            assert(n <= syncpoint_count + 1);\n\n            for (; j < n && j < syncpoint_count; j++) {\n\n                if (has_keyframe[j]) {\n\n                    uint64_t B, A = ffio_read_varlen(bc);\n\n                    if (!A) {\n\n                        A = ffio_read_varlen(bc);\n\n                        B = ffio_read_varlen(bc);\n\n                        // eor_pts[j][i] = last_pts + A + B\n\n                    } else\n\n                        B = 0;\n\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n\n                    last_pts += A + B;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    av_free(syncpoints);\n\n    av_free(has_keyframe);\n\n    return ret;\n\n}\n", "idx": 13636, "substitutes": {"nut": ["orn", "ct", "ctr", "gat", "ft", "bd", "dt", "cn", "cont", "txt", "cm", "nt", "oven", "adr", "ut", "feat", "rt", "orb", "cit", "nit", "annot", "cb", "qt", "anc", "UT", "ou", "bt", "cdn", "config", "nat", "cot", "ctor", "rb", "n", "org", "cue", "boot", "nv", "ctx", "art", "core", "uts", "unc", "kt", "cr", "ocr", "t", "cart", "nuts", "rot"], "s": ["storage", "d", "o", "sv", "session", "soc", "sc", "cs", "sa", "e", "ts", "sat", "server", "ds", "sys", "si", "ss", "space", "service", "ssl", "conf", "sq", "gs", "sf", "sn", "bs", "g", "sub", "n", "os", "spec", "ctx", "sac", "stats", "is", "sh", "c", "su", "sg", "ns", "p", "b", "sl", "f", "sb", "ses", "utils", "settings", "ls", "services", "r", "t", "ops"], "bc": ["bd", "ct", "bitcoin", "CBC", "soc", "oc", "exec", "bn", "cm", "bf", "tc", "sc", "nc", "pc", "cf", "cb", "fb", "ib", "wb", "gc", "anc", "ec", "cc", "dc", "db", "lic", "bt", "uc", "bus", "BC", "bs", "rc", "lc", "cot", "cca", "config", "cus", "rb", "org", "ctx", "fc", "c", "bb", "cl", "lib", "gg", "sb", "acl", "mc", "ca", "cr", "clus", "gb", "auc", "cms", "jc", "pb"], "tmp": ["fp", "client", "batch", "mp", "test", "dt", "stuff", "front", "temp", "data", "v", "nt", "dist", "st", "pos", "obj", "ff", "cb", "output", "duration", "fb", "pad", "zip", "offset", "vt", "elt", "api", "len", "config", "proc", "rb", "np", "cache", "stop", "buff", "max", "uv", "start", "diff", "buffer", "py", "buf", "t", "next", "array", "pack"], "end": ["enc", "en", "d", "append", "send", "all", "edge", "v", "after", "e", "pos", "result", "rest", "size", "open", "End", "page", "post", "ended", "offset", "fd", "num", "last", "z", "id", "stop", "max", "h", "set", "close", "index", "ending", "run", "begin", "start", "f", "w", "END", "r", "tail", "event", "t", "len", "ad"], "i": ["it", "d", "ie", "di", "o", "gi", "my", "ini", "iu", "mi", "fi", "h", "v", "multi", "li", "im", "e", "xi", "u", "inner", "l", "pi", "abi", "uri", "si", "y", "ai", "ui", "m", "api", "c", "lc", "ti", "g", "ix", "z", "key", "n", "eni", "ik", "ci", "id", "io", "mini", "bi", "init", "is", "ip", "qi", "phi", "hi", "ji", "ki", "p", "index", "type", "ri", "b", "info", "ni", "f", "start", "ind", "ami", "ii", "I", "yi"], "j": ["sync", "adj", "d", "o", "dj", "J", "jp", "v", "li", "e", "pos", "u", "l", "y", "m", "offset", "aj", "num", "g", "k", "z", "jj", "n", "ch", "ij", "h", "c", "ji", "q", "p", "index", "syn", "b", "start", "f", "ind", "w", "js", "uj", "r", "ii", "t", "ja"], "syncpoint_count": ["syncPoint_count", "syncpoint_sum", "syncpoints2sum", "syncpoint_base", "syncpointer_list", "syncPoint_length", "syncblock_all", "syncPoint_cache", "syncpoints2count", "syncpoint2size", "syncpoint_Count", "syncpoints2size", "syncPoint_code", "syncpoint2sum", "syncpoint_cache", "syncpoint_max", "syncpoints_count", "syncpoint_code", "syncpointer_size", "syncpoint2cache", "syncblock_size", "syncpointer_length", "syncpoints_size", "syncblock_count", "syncPoint_size", "syncPoint_max", "syncblock_Count", "syncpointer_count", "syncpoints_sum", "syncpoints_cache", "syncPoint_Count", "syncpoint_size", "syncpoint2count", "syncpointer_max", "syncpoint_list", "syncpoint_length", "syncpoint_all", "syncpoints2cache", "syncpointer_base"], "syncpoints": ["synframes", "lockpoints", "sharepoints", "syncpoint", "syncPoints", "yncports", "ynclines", "lockframes", "fillobjects", "Syncpoint", " syncpoint", "syncframes", "yncobjects", " synclines", "yncpoints", "synPoints", "synports", "lockports", " syncports", "synclines", "yncpoint", "lockpoint", "synitems", " syncpointers", "synpoints", " syncobjects", "synpoint", "Syncpoints", "synlines", "fillpoints", "Syncitems", "lockPoints", "syncitems", " syncitems", "sharePoints", "yncpointers", "SyncPoints", "syncports", " syncPoints", "fillports", "shareframes", "locklines", "syncobjects", " syncframes", "fillpointers", "syncpointers", "yncPoints", "sharepoint"], "has_keyframe": ["has_skyframes", "has_anypoint", "has_keyframes", "has_myframes", "has_Keyframes", "has_keyfram", "has_myframe", "has_anyfram", "has_keypoint", "has_Keyframe", "has_Keyfram", "has_anyframe", "has_skyframe", "has_anyframes", "has_mypoint", "has_skyfram"], "x": ["sync", "d", "batch", "xml", "data", "t", "v", "xi", "u", "work", "xes", "y", "lex", "m", "dx", "xy", "xp", "xs", "xx", "wx", "ix", "z", "n", "cross", "rax", "ctx", "id", "c", "rx", "h", "ww", "p", "ax", "type", "ex", "index", "b", "sex", "fx", "tx", "f", "w", "xxx", "bit", "xc", "xa", "X"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 13667, "substitutes": {"s": ["ps", "comments", "fs", "sync", "session", "rs", "south", "e", "cs", "ts", "its", "params", "ds", "states", "sys", "si", "ss", "ssl", "service", "m", "sq", "gs", "g", "es", "ks", "self", "os", "stats", "is", "c", "i", "h", "sg", "tests", "p", "qs", "ns", "b", "aws", "sets", "f", "sie", "sb", "ses", "w", "js", "settings", "ls", "services", "sym", "S", "conf", "ops"]}}
{"project": "qemu", "commit_id": "8cf07dcbe7691dbe4f47563058659dba6ef66b05", "target": 1, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 13672, "substitutes": {"arg": ["enc", "ar", "exec", "oc", "amp", "param", "op", "match", "pc", "val", "ang", "slot", "doc", "pg", "ig", "tag", "parse", "proc", "g", "reg", "par", "ac", "Arg", "input", "args", "mac", "inc", "arc", "arr", "gen", "flag", "mor", "call", "argument", "ace", "rg", "ag", "ref", "ad"], "snapshot": ["captshot", "capvision", "captvision", "picvision", "capshot", "picshot", "captformat", "snapimage", "picformat", "captimage", "picimage", "capformat", "capimage", "snapvision", "snapformat"], "opaque": ["opac", "mpbc", " opac", "opbc", "mpac", " oponymous", "oponymous", "operonymous", "optonymous", "mpacity", " opacity", "operaque", "operac", " opbc", "operbc", "opacity", "optaque", "mpaque", "optacity", "operacity", "optac"], "buf": ["exc", "uf", "pkg", "cf", "cb", "fb", "seq", "rb", "cur", "box", "src", "msg", "uint", "array", "batch", "holder", "cmd", "path", "header", "queue", "car", "fd", "pool", "num", "block", "context", "arr", "buffer", "filename", "null", "ru", "ctr", "func", "fi", "grab", "data", "la", "bc", "result", "wb", "cap", "bus", "cmp", "runner", "rc", "bh", "buff", "home", "stage", "conv", "lit", "text", "ref", "code", "br", "desc", "doc", "vec", "uc", "bridge", "config", "proc", "ctx", "b", "begin", "bag", "prop", "loc", "fw", "img", "cv"], "file": ["body", "binary", "files", "source", "mode", "image", "dir", "base", "model", "uri", "path", "bus", "object", "book", "db", "queue", "pool", "unit", "profile", "byte", "channel", "parent", "block", "id", "File", "input", "line", "info", "family", "cpu", "f", "name", "port", "buffer", "filename", "array"], "devname": ["evName", "defnum", "busname", "devid", "defName", "defno", "evpath", "diskname", "camname", "devicenum", "evno", "deviceno", "diskno", "devkey", "evid", "diskName", "devicename", "deviceid", "evkey", "divName", "diskline", "divname", " devno", "devicepath", "busno", "divnum", "devName", "divno", "devno", "camName", "camkey", "defname", "deviceName", "buspath", " devid", "defline", "devnum", "evline", " devkey", "evname", "devline", "devpath", " devName", "camno"], "serial": ["prefix", "command", "mode", "mask", "util", "model", "uri", "toc", "cmp", "tag", " bus", "comment", "proc", "parent", "spec", "dev", "extra", "status", "device", "lit", "mount", "controller", "master", "lang", "pass", "loc", "pack"], "mediastr": ["medietre", "mediestr", "mediastrs", "mediustl", "datestrs", "datestl", "medietl", "mediustre", "mediastre", "datestre", "mediestl", "datestr", "mediestre", "medietr", "mediastl", "datastre", "mediestrs", "datastr", "medietrs", "mediustr", "mediustrs", "datastl", "datastrs"], "type": ["part", "o", "ty", "pe", "position", " TYPE", "data", "link", "user", "source", "image", "format", "rel", "model", "style", "size", "resource", "y", "types", "full", "ype", "tag", "state", "TYPE", "comment", "time", "typ", "unit", "config", "parent", "error", "method", "like", "class", "block", "role", "view", "key", "id", "Type", "info", "family", "p", "off", "instance", "name", "port", "rule", "t", "pb", "code"], "media": ["storage", "document", "Media", "medium", "library", "connection", "language", "medi", "music", "vm", "data", "record", "source", "mode", "image", "command", "volume", "format", "package", "script", "pi", "model", "interface", "style", "resource", "java", "m", "ype", "mod", "audio", "method", "memory", "i", "ma", "device", "port", "manager"], "bus_id": [" bus_ids", "unit_ids", "bus_like", "buspreID", "busEID", "bus_Id", " bus_ID", " bus_sid", "unit_name", "bus_ip", "busEname", "unit_Id", "unit_kid", "bus_name", "bus_sid", "buspreid", " bus_name", "bus_kid", "busElike", "bus_ID", "bus_ids", "busprename", "busEid", "unit_ip", "busprelike", " bus_like"], "unit_id": ["unit_Id", "unitPname", " unit_key", "unit_name", "bus_name", " unit_ids", "unitPid", "unitPinfo", "unit_ids", "unit_key", " unit_ident", " unit_name", "unit_info", "unitPkey", "unit_ident", "bus_Id", " unit_info"], "cyls": ["cyll", "tyls", " cyles", "cyols", "cfols", "ryls", "cedles", "crles", "cyles", "tyles", "cfll", " cyll", "cylas", "tyl", "cedls", "ryl", "cedll", "crlas", "ryles", "cedols", "crls", "cfles", "tylas", "cyl", " cyols", "crl", "rylas", "cfls"], "heads": ["comments", "ids", "workers", "files", "HEAD", "headers", "drivers", "hook", "locks", "checks", "head", "outs", "docs", "blocks", "stars", "types", "rows", "links", "plugins", "shots", "pages", "tests", "jobs", "tails", "views", "sets", "frames", "offs", "lines", "flags", "sections", "sticks", "opens", "shows", "loads", "runs", "boards", "devices"], "secs": ["licS", "licb", "secb", "execi", "SECS", "secments", " Secs", " Secsym", "secS", "secsym", "licls", "execs", "lics", "SECb", "SECs", "reqi", "seci", " secls", "execments", "SECls", "execsym", "reqsym", " secS", "secls", " secb", "reqs", "reqments", " Seci", " Secments"], "translation": ["comments", "prefix", "options", "language", "position", "la", "pos", "message", "length", "base", " translations", "val", "resource", "alias", "qa", "border", "offset", "config", "version", "info", "description", "layout", "lit", "late", "name", "utils", "Translation", "port", "settings", "lang", "option", "trans", "text", "loc", "conf", "ping", "rot"], "bdrv": ["bdrp", "Bdrf", "BDrf", "bDrvs", "bstrvs", "bstrv", "bDrp", "BDrv", "Bdrp", "bstrp", "bDrv", "Bdrv", "Bdrvs", "BDrvs", "bdrvs", "bDrf", "BDrp", "bstrf", "bdrf"], "drv": ["Drva", "rdv", "Drp", "srv", "srva", "Drb", "rdp", "srp", "drb", "drva", "rdva", "drp", "rdb", "srb", "Drv"], "machine": ["storage", "engine", "computer", "connection", "vm", "mode", "image", "container", "process", "interface", "model", "bus", "m", "service", "meta", "unit", "bridge", "config", "proc", "man", "mem", "node", "slave", "memory", "mac", "info", "ma", "target", "device", "instance", "Machine", "mount", "mc", "controller", "template", "manager", "driver"], "max_devs": ["max_devicei", "max_memn", "max_evits", "max_compins", "max_compns", "max_comps", "max_evins", "max_avins", "max_devops", "max_compds", "max_reqgroups", "max_disops", "max_avds", "max_evgroups", "max_evds", "max_devi", "max_diss", "max_devins", "max_memds", "max_devgroups", "max_mems", "max_deviceits", "max_disits", "max_devds", "max_devns", "max_evn", "max_devits", "max_reqs", "max_evi", "max_deviceops", "max_reqds", "max_evops", "max_avns", "max_reqn", "max_disi", "max_devn", "max_evs", "max_devices", "max_avs", "max_evns", "max_memgroups"], "index": ["prefix", "connection", "proxy", "position", "action", "Index", "loop", "image", "pos", "fix", "head", "length", "flash", "toc", "condition", "level", "offset", "slice", "len", "unit", "bridge", "config", "num", "error", "view", "id", "version", "axis", "weight", "input", "ticket", "pointer", "info", "priority", "scan", "active", "inc", "miss", "buffer", "alpha", "loc"], "cache": ["prefix", "ache", "sync", "batch", "session", "frac", "temp", "global", "count", "image", "Cache", "base", "delay", "timeout", "race", "toc", "slot", "cmp", "tag", "comment", "pool", "ignore", "rc", "config", "parent", "pre", "time", "capacity", "ac", "lock", "block", "read", "c", "pointer", "scan", "cat", "acl", "child", "master", "buffer", "ref", "conf", "pack", "code"], "bdrv_flags": ["bdrv_count", "bdrva_bits", "bdrv_bits", "bdrva_flag", "bdrva_flags", "bdrv2bits", "bdrv2count", "bdrv_flag", "bdrv2flag", "bdrv2flags", "bdrva_count"], "onerror": ["emerror", "onerlock", "errror", "irlock", "irror", "errerror", "onererror", "emerlock", "irerror", "irrr", "emerrr", "errlock", "onerrr", "emererror", "errrr"], "drives_table_idx": ["drives_table_Idx", "drives_table_sidxc", "drives_table_sidxs", "drives_table_Idxs", "drives_table_sidz", "drives_table_idxs", "drives_table_idxc", "drives_table_Idz", "drives_table_idz", "drives_table_Idxc", "drives_table_sidx"], "str": ["enc", "part", "ctr", "iter", "dr", "rs", "strings", "exec", "data", "empty", "br", "st", "obj", "bc", "format", "cf", "wr", "expr", "STR", "strip", "doc", "String", "sp", "vec", "car", "url", "lc", "config", "proc", "usr", "tr", "word", "par", "fr", "spec", "dict", "Str", "cl", "cat", "lit", "sl", "arr", "sr", "cr", "name", "msg", "ocr", "err", "r", "text", "pass", "none", "var"], "params": ["ps", "body", "json", "afi", "options", "rs", "data", "param", "pos", "obj", "desc", "base", "parts", "blocks", "Parameters", "types", "attr", "url", "config", "proc", "parent", "rb", "par", "block", "opt", "ctx", "extra", "vs", "args", "info", "description", "req", "ams", "prop", "acl", "names", "settings", "conf", "array", "ops", "css"]}}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n", "idx": 13706, "substitutes": {"s": ["session", "site", "v", "u", "its", "states", "sys", "si", "se", "m", "plugins", "xs", "self", "spec", "i", "qs", "sb", "js", "services", "t", "ps", "fs", "sync", "o", "cs", "e", "parts", "ss", "ssl", "new", "sq", "gs", "sf", "is", "c", "sg", "ns", "lines", "sie", "settings", "stat", "sites", "changes", "l", "ds", "service", "state", "this", "times", "stats", "http", "vs", "sl", "ses", "sym", "S", "ops", "comments", "sv", "rs", "secondary", "uns", "g", "es", "ks", "su", "p", "tests", "b", "sets", "f", "groups", "request", "ls", "r"], "cpu": ["fp", "module", "screen", "chip", "site", "cn", "cu", "network", "uu", "ilo", "lb", "pu", "np", "boot", "mac", "component", "col", "conn", "len", "performance", "uca", "cpp", "tmp", "loop", "consumer", "worker", "pc", "gpu", "processor", "bench", "gc", "queue", "lc", "num", " CPU", "cache", "node", "c", "rpm", "pai", "gru", "gp", "computer", "PC", "vm", "CPU", "count", "username", "lu", "nic", "cap", "login", "cmp", "pid", "unit", "cale", "uci", "name", "mc", "lag", "connection", "GPU", "cm", "thread", "nc", "process", "server", "course", "pixel", "uc", "config", "proc", "px", "net", "capacity", "ci", "campus", "ctx", "piece", "current", "cp", "cli", "core", "loader", "clock", "xc", "platform", "css"], "irq": ["irinq", "irce", "srq", "irqual", "hrque", "iriqu", "iraqual", "irirc", "urqi", "ierQ", "airq", " irue", "iraqa", "irtqa", "iriq", "IRQ", "irtqual", "ircle", "iraq", "srque", "IRche", "rrq", "irQ", " irqu", "airqu", "hrq", "yrche", "irinQ", "yrque", "irinque", "iriche", "arinqu", "ierq", "irreq", "irinqu", " irqa", "earq", " irque", "iriqa", "ierqu", "arique", "urq", "irequal", "iriQ", "ireche", "ierqi", "irtche", "irtqi", "srue", "srqu", "irtquest", "irique", "ariQ", "rrque", "irtque", "irue", " irQ", " irquest", "irqi", "earQ", "arinq", "irtqu", "IRq", " irrc", "irtQ", "earque", "irqu", "irache", "yrQ", "irtq", "iracle", "hrqu", "irach", "arinqa", "yrq", "iraqi", "earqa", "irch", "yrquest", "irque", "ireQ", "iraqu", "ariq", "irtcle", "irtce", "irquest", "irqa", "irche", "IRquest", "earquest", "ireq", "irerc", "ierreq", "ironque", "airreq", "irace", "rrqa", "urqu", "IRqi", "airqa", "ironch", "hrue", "IRque", "ireque", "rrcle", "irtch", "irrc", "urqa", "iraque", "irireq", "earqu", "ierqa", "irece", "ironqu", "arinquest", "iriquest", "ironq", "ariqu", "ierquest"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "static void init_dequant8_coeff_table(H264Context *h){\n\n    int i,q,x;\n\n    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly\n\n    h->dequant8_coeff[0] = h->dequant8_buffer[0];\n\n    h->dequant8_coeff[1] = h->dequant8_buffer[1];\n\n\n\n    for(i=0; i<2; i++ ){\n\n        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n\n            h->dequant8_coeff[1] = h->dequant8_buffer[0];\n\n            break;\n\n        }\n\n\n\n        for(q=0; q<52; q++){\n\n            int shift = div6[q];\n\n            int idx = rem6[q];\n\n            for(x=0; x<64; x++)\n\n                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =\n\n                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *\n\n                    h->pps.scaling_matrix8[i][x]) << shift;\n\n        }\n\n    }\n\n}\n", "idx": 13712, "substitutes": {"h": ["hs", "eh", "d", "ha", "hash", "ssh", "home", "uh", "oh", "u", "hhh", "rh", "end", "l", "ht", "work", "ih", "hm", "m", "hh", "hu", "this", "gh", "he", "hw", "hp", "hl", "host", "g", "bh", "self", "ch", "ctx", "hr", "cache", "plus", "sh", "c", "H", "ah", "hi", "http", "p", "him", "ph", "b", "history", "f", "th", "kh", "context", "t", "help"], "i": ["ie", "d", "o", "di", "gi", "chi", "ini", "iu", "fi", "mi", "t", "v", "multi", "li", "count", "e", "u", "xi", "l", "pi", "uri", "si", "qa", "y", "ai", "ui", "api", "a", "ti", "g", "ix", "k", "z", "n", "ci", "id", "io", "bi", "qi", "ip", "c", "oi", "phi", "p", "index", "ri", "b", "ni", "f", "zi", "ind", "j", "ii", "I", "yi"], "q": ["d", "ct", "charge", "qq", "check", "shift", "Q", "qu", "v", "patch", "iq", "e", "u", "force", "l", "query", "qt", "qa", "y", "m", "quant", "sq", "g", "ck", "k", "ix", "z", "ch", "id", "qi", "ip", "c", "sh", "p", "req", "qs", "type", "b", "ph", "f", "w", "dq", "j", "r", "ii", "eq", "question", "t"], "x": ["xe", "pe", "v", "u", "work", "yx", "m", "xs", "ix", "n", "cross", "sex", "fx", "xxx", "j", "any", "t", "X", "o", "Q", "e", "image", "xes", "na", "y", "xy", "a", "id", "ww", "c", "ax", "sw", "tx", "ya", "data", "qu", "l", "qa", "dx", "xx", "php", "xp", "wx", "ph", "ex", "name", "code", "wa", "d", "zx", "qq", "xi", "lex", "g", "px", "z", "k", "plus", "rx", "s", "p", "index", "b", "f", "w", "python", "r", "xc"]}}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}", "idx": 13726, "substitutes": {"id": ["ids", "d", "address", "vid", "ID", "rid", "sid", "data", "image", "end", "path", "pid", "kid", "key", "Id", "ip", "q", "i", "addr", "ident", "aid", "index", "type", "p", "start", "name", "mid", "ref", "bid", "ad", "code"], "vs": ["ps", "fs", "sv", "Vs", "vid", "rs", "als", "verts", "vm", "v", "cs", "ds", "ss", "vers", "ves", "gs", "bs", "values", "obs", "es", "ks", "ils", "os", "ums", "forces", "ns", "qs", "views", "plays", "vals", "va", "lines", "ms", "VS", "vp", "ls", "env", "alls", "vis", "sk"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 13728, "substitutes": {}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "idx": 13734, "substitutes": {"data": ["d", "o", "test", "empty", "reader", "record", "u", "result", "message", "format", "base", "dat", "style", "def", "post", "writer", "object", "m", "api", "valid", "form", "a", "error", "config", "parent", "da", "rec", "c", "input", "i", "p", "Data", "f", "DATA", "stream", "parser", "xxx", "database", "array"], "unused": ["unavailable", " unavailable", "Unchecked", " unbchecked", " unbavailable", " unbused", "unuse", " unchecked", " unuse", "Unavailable", "unchecked", "Unuse", "Unused", " unbuse"], "udp": ["adpi", "ugport", "sdps", "sdpi", "udsps", "adp", "udport", "ugps", "odps", "ugP", "urps", "urpi", "azpi", "audps", "udsp", "ugp", "ubport", "udsP", "udP", "urp", "sdb", "audp", "audpi", "odp", "audpc", "udb", "udsport", "azpc", "urpc", "adps", "adb", "udpc", "azps", "ubp", "ubps", "azp", "udps", "udpi", "odpi", "sdp", "odb", "ubP"], "err": ["iter", "bug", "dr", "ev", "der", "rs", "ar", "fi", "exc", "resp", "br", "e", "rh", "l", "cb", "ise", "lr", "rr", "error", "rage", "pr", "g", "n", "fr", "spec", "rev", "c", "i", "ler", "p", "req", "inc", "order", "mr", "ver", "arr", "Er", "tx", "ir", "f", "acer", "cr", "ind", "aster", "er", "Error", "r", "conf", "var", "cer"], "v": ["d", "o", "sv", "test", "ve", "temp", "e", "u", "V", "l", "val", "vi", "m", "vt", "api", "g", "k", "inv", "z", "n", "vd", "iv", "c", "q", "i", "vs", "h", "uv", "s", "p", "conv", "b", "f", "lv", "w", "vp", "j", "r", "vv", "t"]}}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "substitutes": {"opaque": ["oopaque", "oopaques", " opca", "opaques", " opque", "iopque", "opicit", "iopace", " opaques", "oopity", "iopicit", "oppity", "phpaque", " opity", "oppaques", "opque", "oppca", " opicit", " opace", "iopaque", "oopca", "phpicit", "opity", "oppaque", "phpace", "opca", "phpque", "opace"], "buf": ["fp", "batch", "alloc", "data", "uf", "bc", "fl", "cb", "fb", "length", "base", "wb", "blocks", "cap", "db", "queue", "vec", "fd", "pool", "seq", "lim", "config", "rb", "ctx", "buff", "cache", "context", "box", "c", "bytes", "Buffer", "b", "bag", "f", "src", "ab", "port", "que", "buffer", "loc", "bound", "pb", "cv"], "pos": ["address", "position", "end", "base", "val", "limit", "offset", " start", "str", "seq", "block", "os", "no", "pointer", "addr", "set", "off", "p", "Pos", "start", " positions", " offset", "port", " position", "loc", " index", "from"], "size": ["enc", "en", "address", "position", "Size", "data", "empty", "count", "e", "end", "length", "timeout", "offset", "limit", "sn", "small", "z", "n", "id", "cache", "c", "args", "bytes", "p", "start", "name", "SIZE", "loc", "ize", "code"], "s": ["fs", "sync", "o", "session", "e", "sa", "ts", "server", "ds", "sys", "si", "ssl", "service", "m", "sq", "gs", "sec", "es", "ips", "os", "spec", "is", "c", "http", "p", "ns", "syn", "sl", "f", "sb", "sie", "ses", "js", "ls", "socket", "sym", "S", "ops"], "len": ["body", "en", "ie", "le", "fin", " length", "all", "data", "nt", "li", "ll", "Len", "count", "fl", "e", "fn", "l", "length", "lt", "val", "db", "el", "vec", "limit", "elt", "_", "str", "url", "lc", "fun", "num", "pre", "hl", "z", " el", "rc", "n", "rev", "ln", "no", "i", "ler", "line", "h", "lib", "bytes", "sl", " l", " err", "f", "lf", " lib", "js", " lang", "El", "err", "dy", "ls", "code"]}}
{"project": "qemu", "commit_id": "b71706d122838d9656e1a6dae80e22401babdf37", "target": 1, "func": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n", "idx": 13739, "substitutes": {"c": ["ct", "d", "com", "cu", "exec", "t", "cm", "sc", "cs", "e", "bc", "C", "con", "container", "cd", "l", "cb", "ec", "cc", "dc", "m", "uc", "lc", "config", "channel", "k", "ac", "vc", "ci", "ch", "ctx", "ce", "cur", "fc", "cache", "h", "i", "cp", "p", "cl", "b", "coll", "ctrl", "f", "cr", "mc", "ca", "xc", "conn"], "buf": ["fp", "batch", "file", "alloc", "data", "uf", "bc", "fl", "cf", "cb", "base", "fb", "path", "cap", "db", "queue", "fd", "pool", "seq", "rc", "rb", "ctx", "feed", "buff", "cache", "bytes", "Buffer", "b", "f", "src", "port", "buffer", "handle", "array", "cv"], "size": ["done", "sync", "en", "enc", "storage", "address", "fee", "Size", "empty", "e", "length", "write", "sent", "offset", "sec", "sn", "time", "small", "scale", "ize", " sizes", "weight", "max", "bytes", "gz", "used", "name", "w", "SIZE", "esc", "sum", "len", "code"], "count": ["part", "sync", "batch", "file", "list", "connection", "Count", "all", "content", "data", "force", "process", "base", "length", "work", "write", "depth", "total", "counter", "state", "time", "seq", "error", "last", "cond", "id", "read", "cache", "current", "weight", "max", "p", "col", "order", "start", "used", "name", "found", "child", "flag", "call", "stat", "old", "len", "number", "code"], "status": ["site", "success", "resp", "act", "output", "si", "response", "seq", "spec", "date", "wait", "score", "sb", "flags", "msg", "flag", "security", "debug", "sync", "temp", "STAT", "use", "job", "gc", "ss", "Status", "standard", "str", "error", "id", "successful", "stat", "null", "update", "data", "result", "bc", "speed", "message", "service", "this", "state", "comment", "unit", "class", "progress", "stats", "complete", "stage", "active", "type", "code", "fail", "step", "content", "results", "base", "server", "style", "grade", "wrapper", "version", "current", "su", "stable", "sign", "err", "console", "final"], "ret": ["fail", "part", "gt", "ft", "fin", " Ret", "success", "nt", "resp", "Return", "ry", "match", "result", "ut", "obj", "pub", "rt", "conn", "val", "alt", "def", "res", "pet", " RET", "det", "valid", "reply", "fun", "rc", "reg", "rets", "rec", "replace", "rev", "stop", "art", "ext", "req", " result", "run", "lit", "RT", "re", "RET", "flag", "rl", "back", "bit", "ref", "wrap", "len", "Ret", " success", "ann"], "written": ["done", " write", "checked", "failed", "led", "started", "writing", "flow", "temp", "data", "updated", "played", "WR", "added", "ENDED", "output", " output", "write", "wrote", "writer", " wrote", "sent", "ended", "protected", "rawn", "owned", "finished", "broken", "generated", "seen", "loaded", "sized", "writ", "printed", "initialized", "lost", "worked", "weight", "changed", " created", "won", "ritten", "created", "run", "used", "rendered", "connected", "found", "made", "w", "Written", "paid", "filled", "called", "len"]}}
{"project": "FFmpeg", "commit_id": "8d0a2180582005e91d9f14ae3dd219a882277c23", "target": 1, "func": "int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n\n\n    AVBPrint bp;\n\n\n\n    char *name = NULL;\n\n    char *message = NULL;\n\n\n\n    jclass class_class = NULL;\n\n    jmethodID get_name_id = NULL;\n\n\n\n    jclass exception_class = NULL;\n\n    jmethodID get_message_id = NULL;\n\n\n\n    jstring string;\n\n\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    exception_class = (*env)->GetObjectClass(env, exception);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    class_class = (*env)->GetObjectClass(env, exception_class);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class's class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    get_name_id = (*env)->GetMethodID(env, class_class, \"getName\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method Class.getName()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Class.getName() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    if (name && message) {\n\n        av_bprintf(&bp, \"%s: %s\", name, message);\n\n    } else if (name && !message) {\n\n        av_bprintf(&bp, \"%s occurred\", name);\n\n    } else if (!name && message) {\n\n        av_bprintf(&bp, \"Exception: %s\", message);\n\n    } else {\n\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n\n        av_bprintf(&bp, \"Exception occurred\");\n\n    }\n\n\n\n    ret = av_bprint_finalize(&bp, error);\n\ndone:\n\n\n\n    av_free(name);\n\n    av_free(message);\n\n\n\n    if (class_class) {\n\n        (*env)->DeleteLocalRef(env, class_class);\n\n    }\n\n\n\n    if (exception_class) {\n\n        (*env)->DeleteLocalRef(env, exception_class);\n\n    }\n\n\n\n    if (string) {\n\n        (*env)->DeleteLocalRef(env, string);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13740, "substitutes": {"env": ["enc", "dt", "site", "exec", "exc", "ng", "v", "erv", "dir", "ov", "dat", "pec", "ec", "chn", "api", "vel", "ern", "fen", "ea", "essential", "np", "her", "init", "h", "window", "esi", "here", "enable", "conn", "en", "ne", "atten", "impl", "txt", "global", "e", "eng", "inst", "hell", "het", "eni", "org", "iv", "osc", "context", "ah", "shell", "gear", "rn", "nw", "event", "chal", "gov", "done", "et", "engine", "environment", "vm", "ench", "eye", "qt", "pect", "kn", "vt", "cdn", "dev", "vs", "stage", "viron", "que", "ku", "eh", "eve", "app", "ev", "icer", "inet", "nc", "server", "style", "forge", "gui", "export", "config", "eu", "inv", "net", "ctx", "dh", "args", "uv", "ext", "cli", "console", "loc", "equ", "img", "Environment", "cv"], "exception": ["excException", "comcess", "xException", "xpect", "comception", "execcess", "xceptions", "Exceptions", "excceptions", "execpect", "xception", "excess", "compect", "exption", "exException", "Exception", "ExException", "expect", "exceptions", "comption", "xption", "execception", "execption", "excception", "xcess"], "error": ["ror", "address", "ception", "attribute", "patch", "param", "command", "result", "errors", "resource", "ERROR", "comment", "parent", "channel", "status", "type", "reason", "warning", "row", "msg", "call", "err", "Error", "parser", "event", "array", "function"], "log_ctx": ["configencor", "configencit", "logplespec", "write_loc", "config_cor", "log_console", "lex_lc", "logCtx", "call_context", "loplespec", "logCspec", "lex_tx", "lo_scope", "logplecmp", "resource_scope", "resourcepleloc", "lex_context", "logPpkg", "resourceplescope", "log_loc", "log_cor", "log_spec", "lo_ctx", "config_cit", "lex_ctx", "logvalctx", "config_ctx", "log_scope", "logPctx", "resource_ctx", "logCcontext", "logpleloc", "resourceplepkg", "loplecmp", "writevalconsole", "lo_spec", "writevalctx", "call_stack", "log_btn", "logvalconsole", "logurecit", "logwctx", "log_context", "logplectx", "logwcor", "writevalloc", "resource_pkg", "logCstack", "log_tx", "logwconsole", "call_tx", "writevalbtn", "logencit", "configenctx", "logPscope", "log_cmp", "logvalbtn", "log_cit", "resourceplectx", "resource_loc", "write_console", "loplectx", "logureconsole", "log_pkg", "logurecor", "logplescope", "log_stack", "config_console", "logPloc", "lo_cmp", "logvalloc", "logenctx", "logwcit", "configenconsole", "logenconsole", "log_lc", "logCctx", "write_btn", "call_ctx", "logCscope", "write_ctx", "logCcmp", "logurectx", "loplescope", "logplepkg", "logencor"], "bp": ["fp", " gp", "cpp", "tp", "jp", "bf", "bc", " xp", "pc", " ip", "cb", "fb", "kb", "pp", " pc", " bar", "wp", "sp", "PB", "lb", " eb", "bg", "hp", " lb", " p", "rb", "lp", "BP", "nb", " cp", " pp", " np", "cp", "bps", "p", "bb", " hp", "mb", "sb", "dp", "gp", " PB", " ap", "gb", "sth", " BP", "pb"], "name": ["part", "file", "action", "temp", "data", "letter", "package", "desc", "base", "size", "alias", "resource", "path", "object", "new", "Name", "time", "comment", "str", "channel", "key", "word", "block", "class", "id", "NAME", "version", "description", "info", "ident", "type", "call", "names", "text", "old", "filename", "function", "code"], "message": ["body", "document", "language", "content", "mail", "command", "result", "summary", "object", "m", "Message", "comment", "response", "method", "mess", "version", "description", "email", "reference", "reason", "msg", "value", "filename", "number", "function", "code"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                   uint32_t arg)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);\n\n    vscsi_req *req = vscsi_find_req(s, tag);\n\n    SCSIDevice *sdev;\n\n    uint8_t *buf;\n\n    int32_t res_in = 0, res_out = 0;\n\n    int len, rc = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\",\n\n            reason, tag, arg, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag);\n\n        return;\n\n    }\n\n    sdev = req->sdev;\n\n\n\n    if (req->sensing) {\n\n        if (reason == SCSI_REASON_DONE) {\n\n            dprintf(\"VSCSI: Sense done !\\n\");\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n            vscsi_put_req(s, req);\n\n        } else {\n\n            uint8_t *buf = sdev->info->get_buf(sdev, tag);\n\n\n\n            len = MIN(arg, SCSI_SENSE_BUF_SIZE);\n\n            dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[0], buf[1], buf[2], buf[3],\n\n                    buf[4], buf[5], buf[6], buf[7]);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[8], buf[9], buf[10], buf[11],\n\n                    buf[12], buf[13], buf[14], buf[15]);\n\n            memcpy(req->sense, buf, len);\n\n            req->senselen = len;\n\n            sdev->info->read_data(sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n", "idx": 13748, "substitutes": {"bus": ["sync", "serv", "ux", "us", "session", "hub", "USB", "board", "plug", "bc", "util", "base", "serial", "def", "service", "bridge", "config", "proc", "bs", "BUS", "Bus", "lock", "io", "boot", "os", "usb", "feed", "cache", "dev", "http", "lib", "cat", "gen", "mount", "port", "conf", "driver"], "reason": [" Reason", "session", "Reason", "exc", "resp", "author", "param", "source", "record", "match", "message", "desc", "head", "condition", "doc", "summary", "cmp", "group", "valid", "response", "comment", "error", "sec", "reg", "method", "g", "un", "why", "rec", "bad", "ASON", "ticket", "issue", "description", "status", "component", "type", "unknown", "warning", "report", "crit", "re", "name", "msg", "cause", "err", "request", "category", "value", "argument", "loc", "comp", "subject", "code"], "tag": ["prefix", "module", "bug", "test", "ar", "attribute", "patch", "param", "br", "match", "pos", "year", "nick", "feat", "length", "loc", "attr", "mod", "comment", "rr", "error", "config", "Tag", "reg", "tr", "key", "block", "bad", "event", "par", "TAG", "id", "date", "target", "type", "cat", "col", "prop", "name", "pl", "msg", "port", "category", "option", "bit", "rg", "ag", "tags", "ref", "var", "code"], "arg": ["enc", "bug", "dr", "ar", "exc", "param", "count", "op", "match", "nick", "use", "cmd", "val", "ang", "slot", "mag", "doc", "in", "loc", "ig", "attr", "rc", "num", "reg", "g", "par", "tick", "item", "neg", "id", "Arg", "date", "args", "mac", "addr", "ext", "ret", "target", "ax", "cat", "inc", "ack", "arr", "prop", "gen", "msg", "flag", "issue", "ind", "call", "err", "option", "argument", "bit", "rg", "ag", "ref"], "s": ["ps", "storage", "sync", "serv", "d", "us", "o", "sv", "session", "fs", "south", "v", "e", "cs", "ts", "server", "ds", "sys", "si", "spot", "ssl", "service", "m", "an", "conf", "state", "sq", "gs", "sf", "g", "ks", "z", "os", "spec", "stats", "is", "c", "http", "su", "i", "sg", "h", "p", "ns", "scope", "b", "sl", "aws", "f", "sb", "ses", "js", "r", "services", "sym", "S", "socket", "t", "ops"], "req": ["ar", "exec", "war", "requ", "resp", "per", "pkg", "cf", "cb", "query", "rf", "tar", "sec", "seq", "reg", "rb", "spec", "rev", "cur", "ver", "j", "client", "required", "param", "cmd", "resource", "res", "queue", "sq", "str", "org", "id", "cache", "input", "crit", "dq", "ru", "require", "jp", "data", "plug", "feat", "qt", "qa", " requ", "cmp", "sem", "rr", "release", "rec", "fr", "comm", "http", "q", "urg", "mr", "ir", "call", "ref", "comp", "wa", "app", "pull", "op", "desc", "def", " request", "config", "proc", "ctx", "rx", "ext", "p", "f", "loader", "err", "request", "er", "r", "conf", "next"], "sdev": ["pserror", " svc", "gdev", "skydes", "wdev", "skylim", " sconn", "serror", " sdiv", "lsgd", " sserv", " sprof", "fdd", "sde", "spriv", "sdiv", "verror", "Sdd", "Sdev", "psmod", "csdevice", "vmod", "fdiv", "lsdes", "lsdiv", "wprof", "cserv", "skydev", "gdef", "wdiv", "gdevice", " sDev", "cserror", "smod", "vdef", "vDev", "sserv", " sdevice", "gpriv", "cdevice", "skygd", "lslim", "cde", " sde", "sgd", "vvc", " sgd", "fdev", "sconn", " sdd", "psdevice", "fconn", "csmod", "vpriv", "Sconn", "lsprof", "wgd", "vdev", "psdev", "cdev", "vdevice", "sdes", "sprof", " spriv", "sDev", "svc", "Sdiv", "slim", " sdef", "sdevice", "lsdev", "sdd", "sdef", "vconn", "csdev"], "buf": ["fp", "bd", "batch", "ba", "ha", "alloc", "func", "tmp", "grab", "exc", "data", "uf", "agg", "br", "result", "bc", "feat", "comb", "cf", "ff", "cmd", "fb", "cb", "wb", "cas", "page", "val", "pad", "path", "header", "cap", "queue", "map", "vec", "uc", "fd", "pool", "seq", "config", "num", "bh", "rb", "block", "ctx", "cur", "mem", "buff", "cache", "box", "bp", "conv", "off", "cat", "b", "bag", "gen", "src", "prop", "msg", "ab", "port", "av", "que", "buffer", "text", "loc", "img", "dest", "pb", "cv"], "len": ["en", "ie", "fin", "bl", "data", "la", "resp", "li", "ll", "Len", "pos", "fl", "count", "bc", "l", "length", "lt", "size", "bin", "val", "lon", "alt", "cap", "el", "vec", "lin", "seq", "fun", "lc", "lim", "num", "rc", "n", "win", "ln", "rev", "ler", "line", "lit", "sl", "il", "gen", "min", "lf", "pl", "err", "lang", "loc", "conn", "span", "ann"]}}
{"project": "qemu", "commit_id": "7d6250e3d1a145e5427f21f5664995e0056b34a6", "target": 0, "func": "void helper_store_sdr1(CPUPPCState *env, target_ulong val)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n\n\n    if (!env->external_htab) {\n\n        if (env->spr[SPR_SDR1] != val) {\n\n            ppc_store_sdr1(env, val);\n\n            tlb_flush(CPU(cpu));\n\n        }\n\n    }\n\n}\n", "idx": 13754, "substitutes": {"env": ["enc", "en", "engine", "et", "eve", "environment", "ev", "site", "exc", "v", "erv", "e", "obj", "end", "ench", "server", "style", "dat", "qt", "eng", "ec", "db", "conf", "gui", "el", "state", "ep", "em", "export", "config", "fen", "ea", "eu", "profile", "exe", "eni", "np", "her", "ctx", "cache", "context", "extra", "ah", "args", "viron", "dict", "ext", "core", "f", "here", "energy", "gear", "loader", "que", "settings", "er", "nw", "conn", "enh", "Environment", "code"], "val": ["fail", "serv", "VAL", "test", "bl", "data", "v", "local", "eval", "count", "pos", "pt", "base", "write", "slot", "db", "pid", "el", "state", "valid", "al", "volt", "unit", "Val", "num", "pre", "config", "reg", "arg", "ctx", "mem", "cache", "dev", "x", "addr", "p", "index", "vol", "cal", "lib", "sl", "vals", "tx", "buffer", "stat", "value", "ref", "len", "ee"], "cpu": ["cn", "vm", "pot", "CPU", "nc", "bc", "process", "pc", "gpu", "processor", "bench", "cmp", "pid", "lb", "prem", "hw", "pool", "unit", "lc", "config", "pu", "px", "proc", "ea", "net", "fps", "boot", "ctx", "foo", "mem", "node", "cache", "cp", "component", "core", "cal", "instance", "pit", "gp", "loader", "platform", "conn", "comp"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 2);\n\n}\n", "idx": 13768, "substitutes": {"opaque": ["openque", "ospaque", "OPque", "ospac", "opacity", "opac", "opque", "ospacity", "ospque", "openac", "OPaque", "OPacity", "OPac", "openaque", "openacity"], "addr": ["address", "ord", "data", "md", "pos", "eth", "base", "arity", "val", "cap", "oint", "ptr", "config", "byte", "block", "x", "args", "pointer", "Address", "mac", "cp", "type", "name", "ace", "ost", "ad", "oa"], "size": ["en", "address", "izes", "send", "fee", "content", "Size", "empty", "external", "e", "speed", "length", "timeout", "si", "shape", "sec", "small", "iz", "scale", "g", "es", "parent", "sized", "six", "capacity", "z", "needed", " sizes", "args", "bytes", "member", "or", "SIZE", "esc", "any", "value", "loc", "ize", "len", "number", "code"], "is_write": ["isNewwritten", " is_lex", "isNewwriting", "is_lex", "is_exclusive", "isNewwrite", " is_written", "is_writer", " is_writing", "is_written", "is_writing", "isNewexclusive", " is_exclusive", " is_writer"]}}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n", "idx": 13772, "substitutes": {"owner": ["oe", "address", "own", "OWN", "office", "reader", "private", "mode", "e", "oid", "head", "ock", "property", "alias", "owned", "cow", "root", "state", "host", "proc", "parent", "org", "node", "slave", "addr", "target", "device", "component", "Owner", "instance", "owners", "prop", "name", "manager", "ace", "staff", "creator", "driver"], "liobn": ["liObN", "Liobn", "libn", "liocdn", "luobnt", "liOBna", "lobni", "liobbnt", "ciobnr", "liodynr", "liObr", "liodx", "liabr", "Liobbn", "ciobbn", "luObn", "iloobbno", "libnt", "liabn", "luObl", "luabnt", "liobnr", "liodno", "ciobbnr", "liibni", "lobnw", "lobn", "iloobbx", "luabdn", "liobnt", "luobN", "liadowdn", "liocx", "Liobna", "Liobl", "liabornr", "liabdn", "liObn", "luobr", "liodyn", "ciobbnan", "ciobdn", "liadown", "libni", "luobl", "liobbna", "luObN", "liobbdn", "liabni", "liadowni", "liibnt", "liOBl", "luabni", "ciobn", "liobbnr", "Liobbl", "iloobno", "ciobnan", "liabornan", "libnw", "ciobbdn", "liobna", "iloobbn", "liabN", "Liobr", "liOBn", "liibn", "luObr", "iloobn", "liubni", "liobbni", "liObl", "lioddn", "liibnw", "liobbN", "liobbl", "liOBr", "liolognw", "liobbx", "liodynan", "liobnan", "liubn", "liadownt", "liObna", "liocno", "liodn", "Liobbr", "liolognt", "liabnt", "liocn", "liobN", "liobno", "liobni", "liobdn", "luabn", "liabl", "lobnt", "liodydn", "liobbr", "iloobx", "liobr", "liobbno", "liobx", "liubnt", "liaborn", "luobdn", "liologn", "liubnw", "liobl", "luobni", "iloobdn", "iloobbdn", "Liobbna", "liobnw", "liologni", "liobbn", "liabordn", "luobn", "liobbnan"], "bus_offset": ["controller_size", "busamshift", "BUS_size", "BUS_sort", "busaloffset", "BUS_shift", "bus_shift", "busaltranslation", "BUS_field", "bus_align", "bus_sort", "BUS_offset", "bus_field", "bus_location", "busamfield", "BUS_location", "bus_size", "busamoffset", "controller_align", "controller_shift", "controller_offset", "BUS_translation", "bus_translation", "busalsize", "busamlocation", "busalsort"], "page_shift": ["pagealgap", "page_shape", "pagealsize", " page_space", " page_gap", " page_shape", "page_direction", "pagealshift", " page_size", "page_space", "page_size", "page\u00b7direction", " page_direction", "pagealshape", " page_center", "page_gap", "page_distance", "page\u00b7shift", " page_distance", "page\u00b7size", "page_center", "page\u00b7space"], "nb_table": ["np_block", "api_address", "nbjtab", "sbaccache", "nbactree", "apiblocktable", "sb_tree", "nbjtable", "nbjblock", "api_cache", "sbactable", "sb_cache", "nbxtype", "nbactable", "nbfcache", "nbxtree", "nbactype", "nb_address", "sb_table", "apiblockcache", "nbblockcache", "sbactype", "nb_module", "nbxtable", "api_module", "nb_tab", "nbfaddress", "nb2table", "nbfmodule", "nbaccache", "nb_cache", "nbjsection", "sb_type", "np_cache", "nb2address", "np_table", "api_table", "nbftable", "sbactree", "np_section", "nb_type", "nbblocktable", "nbxcache", "nb2module", "nbblockaddress", "apiblockmodule", "nb2cache", "nbblockmodule", "nb_tree", "nb_block", "np_tab", "nb_section", "apiblockaddress"], "vfio_accel": ["vfio_acsquire", "vfio_acce", "vfio_acccel", "vfio_maccel", "vfio_maccer", "vfio_faccl", "vfio_excl", "vfio_maccl", "vfio_maccent", "vfio_macce", "vfio_accce", "vfio_facceler", "vfio_acccer", "vfio_excel", "vfio_acscl", "vfio_acceler", "vfio_faccent", "vfio_accer", "vfio_accent", "vfio_exceler", "vfio_accl", "vfio_acccent", "vfio_acquire", "vfio_accceler", "vfio_acscel", "vfio_acccl", "vfio_faccel", "vfio_macceler", "vfio_acsceler", "vfio_exquire", "vfio_accquire"], "tcet": ["scet", "fc\u00e9t", "tg\u00e9t", "ucot", " TCset", "fcat", " tcets", "tkset", " tcpet", "bcit", "lcot", "pcset", "tgset", "TCpet", "tempset", "tcets", "cfset", "tgpet", " tc\u00e9t", "dcound", " TCpet", "tgoint", "ucset", "tcant", "lcset", "lcat", "temponet", "ctrlpet", "scit", "bcett", "fcet", "ucit", "tgat", "tkinet", "tcound", "bcet", " tcset", "TCound", "TCset", "ctrlet", "tcat", "tcpet", "lcET", "scset", "pcet", "tcot", "mcet", "tket", "cfonet", "tcET", "tcinet", "dcpet", "lcant", "dcet", "pcpet", "lcet", "wbant", "dcET", "TCet", "tgets", "tgant", "tkET", "tc\u00e9t", "fcets", "ctrlset", "temppet", "lcinet", "tkpet", "tkonet", "tcit", "TCET", "wbat", "tempet", "tcset", " tcET", "ucett", "tconet", "fcset", "tempoint", "tget", " TCet", "wbset", "cfpet", "mcET", "tcoint", " tcound", "mcset", " tcat", "scett", "pcets", "TCant", "ucet", "TCat", "tcett", "TCot", " TCets", "wbet", "fcant", "bcset", "cfet", "ucET", "ctrloint", "mcinet"], "tmp": ["fp", "storage", "binary", "done", "address", "mp", "append", "stuff", "cpp", "tp", "temp", "data", "txt", "tab", "tc", "obj", "result", "desc", "cb", "fb", "wb", "copy", "ob", "db", "cmp", "zip", "bt", "vt", "elt", "slice", "tf", "ptr", "proc", "rb", "sup", "tt", "np", "nb", "ucc", "appy", "buff", "cache", "rm", "ppa", "ctx", "properties", "cp", "pty", "ext", "bb", "table", "bag", "metadata", "prop", "sb", "msg", "buffer", "buf", "loc", "img", "dest", "pb"]}}
{"project": "qemu", "commit_id": "192cf55cc02dc0838bbfa5ac17feb7f6c1651441", "target": 1, "func": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n", "idx": 13784, "substitutes": {"fis": ["alfils", "Fils", "Fi", "fi", " fids", "vids", "vi", " fi", "Fris", "alfris", "fids", "fils", "alfi", " fris", "Fids", " fils", "Fis", "vils", "alfis", "fris", "vis"], "cmd_len": [" cmd_length", "cmd_body", " cmd_Len", "cmd4len", " cmd_count", "cmd_length", " cmd_body", "cmd_count", "cmd4length", "cmd4count", "cmd_Len"], "i": ["it", "part", "d", "di", "o", "gi", "uni", "iu", "fi", "temp", "t", "multi", "v", "li", "split", "count", "e", "xi", "u", "mu", "l", "pi", "length", "uri", "si", "in", "ai", "ui", "m", "slice", "api", "a", "ti", "k", "key", "ix", "n", "eni", "ci", "id", "io", "bi", "qi", "phi", "c", "x", "oi", "hi", "ji", "ip", "p", "index", "ri", "b", "ni", "f", "start", "zi", "j", "r", "ii", "len", "I"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static av_cold int svc_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVCContext *s = avctx->priv_data;\n\n    SEncParamExt param = { 0 };\n\n    int err = AVERROR_UNKNOWN;\n\n    int log_level;\n\n    WelsTraceCallback callback_function;\n\n    AVCPBProperties *props;\n\n\n\n    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion\n\n    // function (for functions returning larger structs), thus skip the check in those\n\n    // configurations.\n\n#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)\n\n    OpenH264Version libver = WelsGetCodecVersion();\n\n    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect library version loaded\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n#endif\n\n\n\n    if (WelsCreateSVCEncoder(&s->encoder)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to create encoder\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    // Pass all libopenh264 messages to our callback, to allow ourselves to filter them.\n\n    log_level = WELS_LOG_DETAIL;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level);\n\n\n\n    // Set the logging callback function to one that uses av_log() (see implementation above).\n\n    callback_function = (WelsTraceCallback) libopenh264_trace_callback;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);\n\n\n\n    // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to av_log().\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);\n\n\n\n    (*s->encoder)->GetDefaultParams(s->encoder, &param);\n\n\n\n    param.fMaxFrameRate              = avctx->time_base.den / avctx->time_base.num;\n\n    param.iPicWidth                  = avctx->width;\n\n    param.iPicHeight                 = avctx->height;\n\n    param.iTargetBitrate             = avctx->bit_rate;\n\n    param.iMaxBitrate                = FFMAX(avctx->rc_max_rate, avctx->bit_rate);\n\n    param.iRCMode                    = RC_QUALITY_MODE;\n\n    param.iTemporalLayerNum          = 1;\n\n    param.iSpatialLayerNum           = 1;\n\n    param.bEnableDenoise             = 0;\n\n    param.bEnableBackgroundDetection = 1;\n\n    param.bEnableAdaptiveQuant       = 1;\n\n    param.bEnableFrameSkip           = s->skip_frames;\n\n    param.bEnableLongTermReference   = 0;\n\n    param.iLtrMarkPeriod             = 30;\n\n    param.uiIntraPeriod              = avctx->gop_size;\n\n#if OPENH264_VER_AT_LEAST(1, 4)\n\n    param.eSpsPpsIdStrategy          = CONSTANT_ID;\n\n#else\n\n    param.bEnableSpsPpsIdAddition    = 0;\n\n#endif\n\n    param.bPrefixNalAddingCtrl       = 0;\n\n    param.iLoopFilterDisableIdc      = !s->loopfilter;\n\n    param.iEntropyCodingModeFlag     = 0;\n\n    param.iMultipleThreadIdc         = avctx->thread_count;\n\n    if (s->profile && !strcmp(s->profile, \"main\"))\n\n        param.iEntropyCodingModeFlag = 1;\n\n    else if (!s->profile && avctx->coder_type == FF_CODER_TYPE_AC)\n\n        param.iEntropyCodingModeFlag = 1;\n\n\n\n    param.sSpatialLayers[0].iVideoWidth         = param.iPicWidth;\n\n    param.sSpatialLayers[0].iVideoHeight        = param.iPicHeight;\n\n    param.sSpatialLayers[0].fFrameRate          = param.fMaxFrameRate;\n\n    param.sSpatialLayers[0].iSpatialBitrate     = param.iTargetBitrate;\n\n    param.sSpatialLayers[0].iMaxSpatialBitrate  = param.iMaxBitrate;\n\n\n\n    if ((avctx->slices > 1) && (s->max_nal_size)){\n\n        av_log(avctx,AV_LOG_ERROR,\"Invalid combination -slices %d and -max_nal_size %d.\\n\",avctx->slices,s->max_nal_size);\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->slices > 1)\n\n        s->slice_mode = SM_FIXEDSLCNUM_SLICE;\n\n\n\n    if (s->max_nal_size)\n\n        s->slice_mode = SM_DYN_SLICE;\n\n\n\n    param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;\n\n    param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;\n\n\n\n    if (s->slice_mode == SM_DYN_SLICE) {\n\n        if (s->max_nal_size){\n\n            param.uiMaxNalSize = s->max_nal_size;\n\n            param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;\n\n        } else {\n\n            if (avctx->rtp_payload_size) {\n\n                av_log(avctx,AV_LOG_DEBUG,\"Using RTP Payload size for uiMaxNalSize\");\n\n                param.uiMaxNalSize = avctx->rtp_payload_size;\n\n                param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = avctx->rtp_payload_size;\n\n            } else {\n\n                av_log(avctx,AV_LOG_ERROR,\"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\\n\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Initialize failed\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n\n        SFrameBSInfo fbi = { 0 };\n\n        int i, size = 0;\n\n        (*s->encoder)->EncodeParameterSets(s->encoder, &fbi);\n\n        for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++)\n\n            size += fbi.sLayerInfo[0].pNalLengthInByte[i];\n\n        avctx->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        avctx->extradata_size = size;\n\n        memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size);\n\n    }\n\n\n\n    props = ff_add_cpb_side_data(avctx);\n\n    if (!props) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    props->max_bitrate = param.iMaxBitrate;\n\n    props->avg_bitrate = param.iTargetBitrate;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    svc_encode_close(avctx);\n\n    return err;\n\n}\n", "idx": 13809, "substitutes": {"avctx": ["avelc", "afconfig", "avalloc", "afloc", "avalcli", " avcu", "avkb", "avci", "avcf", "ajcu", " avci", "verctx", "avalcf", "avcci", "afctx", "vercu", "avlc", "afwcs", "avtx", "AVloc", "ajctx", "afcli", "abtx", "AVconn", "afcontext", "ajcomponent", "avcli", "AVconv", "avectx", "avalwcs", "avecci", "avconv", "avetx", "abcontext", "AVctx", "airctx", "ajcas", " avcas", "AVcu", " avloc", "aflc", "ajcontext", " avkb", "afkb", "avecf", " avcontext", "afcomponent", "ajci", "ovconv", "aveloc", "AVkb", "avewcs", "afcf", "vercomponent", "aircontext", "abcu", "avcomponent", "avcu", "afconn", "avalconf", "ovctx", "aircci", "AVconfig", "afcu", "AVtx", "avconn", "airconn", "AVcas", "avalctx", "AVcontext", "aveconf", "avalcontext", "avconfig", "abloc", "aveconn", "avecu", "avecli", "avloc", " avconn", "abctx", "abconfig", "avwcs", "avallc", "AVci", "ovconn", "AVconf", "ovcontext", "afcci", " avconv", "vercontext", "avcas", "avconf", "avecontext", "avcontext"], "s": ["sync", "fs", "d", "us", "o", "session", "rs", "site", "v", "param", "cs", "e", "u", "ts", "l", "params", "ds", "sys", "y", "ss", "ssl", "service", "m", "se", "sq", "gs", "sec", "a", "g", "es", "ks", "k", "os", "spec", "ctx", "is", "c", "http", "args", "su", "p", "ns", "qs", "b", "aws", "f", "sb", "as", "js", "ses", "r", "services", "sym", "S", "ls", "t", "native"], "log_level": ["loglenclass", "pathvallevel", "logvallevel", "logloglog", "log_message", "log_class", "path_mode", "pathvalvel", "error_vel", "pathvallvl", "loglenlevel", "error_message", "log_lvl", "logloglevel", " log_location", "error_level", "path_lvl", "logvalvel", "logloglocation", "loglogvel", "log_vel", "loglenvel", " log_vel", "pathvalmode", "log_log", " log_log", "path_level", "log_mode", "loglenmessage", "error_class", "path_vel", "logvalmode", "log_location", "logvallvl"], "callback_function": ["callback_Function", "back_callback", "callbackalcallback", "callback2Function", "callbackalfunction", " callback_Function", " callback_resource", "callback2callback", "callback_func", " callback_func", "callback_callback", "callback2command", "callbackalfun", "back_error", "callback_resource", "log_fn", "log_command", "callback2function", "back_function", "callback2error", "callback2fun", "callback_error", "callback_fn", "callback_fun", "back_fun", "log_function", "callback_command", "log_Function", "callback2fn", "callbackalerror"], "props": [" progs", "pregs", "Prors", " prors", "Progs", "preps", "probs", "Props", "prebs", "progs", " probs", "prers", "Probs", "prors"]}}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    SM501State *s = (SM501State *)opaque;\n\n    SM501_DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\",\n\n                  (unsigned)addr, (unsigned)value);\n\n\n\n    switch (addr) {\n\n    case SM501_DC_PANEL_CONTROL:\n\n        s->dc_panel_control = value & 0x0FFF73FF;\n\n        break;\n\n    case SM501_DC_PANEL_PANNING_CONTROL:\n\n        s->dc_panel_panning_control = value & 0xFF3FFF3F;\n\n        break;\n\n    case SM501_DC_PANEL_FB_ADDR:\n\n        s->dc_panel_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_OFFSET:\n\n        s->dc_panel_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_WIDTH:\n\n        s->dc_panel_fb_width = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_FB_HEIGHT:\n\n        s->dc_panel_fb_height = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_TL_LOC:\n\n        s->dc_panel_tl_location = value & 0x07FF07FF;\n\n        break;\n\n    case SM501_DC_PANEL_BR_LOC:\n\n        s->dc_panel_br_location = value & 0x07FF07FF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_H_TOT:\n\n        s->dc_panel_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_H_SYNC:\n\n        s->dc_panel_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_TOT:\n\n        s->dc_panel_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_SYNC:\n\n        s->dc_panel_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_HWC_ADDR:\n\n        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_LOC:\n\n        s->dc_panel_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_1_2:\n\n        s->dc_panel_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_3:\n\n        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_CONTROL:\n\n        s->dc_crt_control = value & 0x0003FFFF;\n\n        break;\n\n    case SM501_DC_CRT_FB_ADDR:\n\n        s->dc_crt_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n", "idx": 13829, "substitutes": {"opaque": ["ipacity", "operatile", "opac", " opque", "ipula", "transacity", "opula", "operula", "ipaque", "opque", " opacity", "operaque", "transaque", "operac", "opacity", "opatile", "operque", "ipac", "transula", " opatile", "transac", "operacity", "ipatile", "ipque"], "addr": ["prefix", "address", "func", "ord", "data", "v", "mode", "eth", "message", "direction", "enter", "cmd", "cb", "align", "pair", "val", "alt", "pad", "callback", " address", "cmp", "attr", "padding", "offset", "ptr", "rc", "host", "config", "block", "add", "node", "ip", "x", "mac", "pointer", "Address", "ext", "off", "p", "device", "type", "src", "name", "port", "buffer", "buf", "r", "ref", "len", "number", "ad"], "value": ["large", "address", "v", "command", "join", "val", "values", "scale", "create", "slave", "description", "reference", "component", "start", "sum", "native", "alt", "flow", "media", "image", "format", "element", "hello", "resource", "total", "new", "offset", "num", "node", "max", "memory", "Value", "buffer", "option", "buf", "null", "done", "json", "ve", "data", "attribute", "multi", "message", "end", "VALUE", "bin", "service", "padding", "valid", "comment", "unit", "selected", "key", "home", "complete", "type", "name", "get", "sample", "handle", "single", "document", "fee", "content", "source", "mode", "feature", "store", "length", "server", "style", "uri", "current", "archive", "info", "index", "device", "termin", "begin", "w", "number", "function"], "size": ["address", " length", "data", "v", "mode", " buffer", " values", "length", "val", "state", " bytes", "ptr", "bytes", "type", "name", "buffer", "SIZE", " mode", "buf"], "s": ["ps", "hs", "fs", "storage", "d", "client", "o", "session", "us", "rs", "site", "south", "v", "e", "sa", "u", "ts", "l", "ds", "states", "sys", "si", "ss", "y", "service", "an", "m", "ssl", "conf", "state", "new", "gs", "sf", "g", "es", "self", "n", "os", "spec", "is", "side", "c", "http", "i", "sg", "p", "ns", "qs", "status", "b", "sl", "aws", "sets", "f", "sb", "manager", "w", "ses", "js", "stat", "r", "sym", "ls", "S", "t", "native", "single"]}}
{"project": "FFmpeg", "commit_id": "9b2c28e6edbb43e00e0b2d99b95567189cd46e91", "target": 0, "func": "void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)\n\n{\n\n#ifdef HAVE_MMX\n\n  register const char* s=src+src_size;\n\n  register char* d=dst+src_size;\n\n  register int offs=-src_size;\n\n  __asm __volatile(PREFETCH\"\t%0\"::\"m\"(*(s+offs)):\"memory\");\n\n  __asm __volatile(\n\n\t\"movq\t%0, %%mm4\\n\\t\"\n\n\t\"movq\t%1, %%mm5\"\n\n\t::\"m\"(mask15b), \"m\"(mask15rg):\"memory\");\n\n  while(offs<0)\n\n  {\n\n\t__asm __volatile(\n\n\t\tPREFETCH\"\t32%1\\n\\t\"\n\n\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm1\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*(d+offs))\n\n\t\t:\"m\"(*(s+offs))\n\n\t\t:\"memory\");\n\n\toffs+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#else\n\n   const uint16_t *s1=( uint16_t * )src;\n\n   uint16_t *d1=( uint16_t * )dst;\n\n   uint16_t *e=((uint8_t *)s1)+src_size;\n\n   while( s1<e ){\n\n     register int x=*( s1++ );\n\n     /* rrrrrggggggbbbbb\n\n        0rrrrrgggggbbbbb\n\n        0111 1111 1110 0000=0x7FE0\n\n        00000000000001 1111=0x001F */\n\n     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );\n\n   }\n\n#endif\n\n}\n", "idx": 13855, "substitutes": {"src": ["sync", "ins", "rs", "impl", "ur", "source", "sc", "reflect", "image", "cb", "scl", "rob", "sur", "ssl", "attr", "sq", "uc", "inst", "seq", "url", "rc", "config", "proc", "sub", "RC", "rb", "rib", "sup", "cur", "c", "gz", "secure", "req", "core", "b", "sr", "sb", "pl", "stream", "loc", "filename", "img", "dest", "support"], "dst": ["rdconst", "dsts", "lst", "pdst", "Dst", "rdst", " drc", "rdct", "Dsts", " dsp", "lsts", "Dconst", " dconst", "lrc", "adst", "adconst", "Dsp", " dct", "lsc", "dconst", "pdct", "pdsts", "adrc", "drc", "adsts", "pdconst", "adsp", "dsc", " dsc", "dct", "rdsts", "dsp", " dsts", "adsc"], "src_size": ["srclogscale", " src_scale", "rc_scale", " src_address", "src_scale", "src_address", "srclogshape", "src_ize", "src_dim", "rc_ize", "srcblockscale", "rc_size", "rc_address", "srcblocksize", "srcblockize", "rc_shape", "rc_dim", "srclogsize", "src_shape"], "s": ["ps", "o", "sv", "ins", "v", "u", "ts", "l", "ds", "si", "ss", "sp", "gs", "a", "g", "z", "ks", "n", "os", "sh", "c", "su", "h", "i", "p", "ns", "b", "f", "sb", "w", "ses", "r", "j", "S", "t"], "d": ["di", "o", "dt", "v", "u", "l", "dat", "ds", "dc", "dn", "a", "g", "z", "n", "dh", "sd", "c", "x", "h", "i", "p", "b", "f", "dp", "w", "D", "r", "j", "t", "da", "ad"], "m": ["fm", "mm", "o", "mi", "v", "multi", "cm", "gm", "u", "sm", "pm", "l", "y", "hm", "tm", "M", "a", "g", "n", "c", "h", "i", "x", "p", "b", "f", "mc", "ms", "w", "r", "t"], "memory": ["large", "module", "performance", "mm", "medium", "address", "session", "material", "all", "data", "vm", "texture", "cm", "record", "global", "mode", "media", "image", "mask", "message", "use", "complex", "size", "model", "gpu", "server", "write", "resource", "shape", "java", "map", "program", "Memory", "byte", "block", "mem", "cache", "h", "application", "reference", "p", "metadata", "math", "name", "mount", "master", "buffer", "asm", "function"], "s1": ["done", "ds1", "tsone", "S1", "c8", "sOne", "ns1", "S81", "y1", "SOne", "nOne", "ts3", "yOne", " s3", "n1", "dsOne", "nsone", "s81", "s3", "c81", "ds8", "c1", "yone", "s8", "dOne", "cOne", "ds81", "d3", "ts1", "S8", " sone", "none", "sone"], "d1": ["done", "mOne", "t81", "d81", "f1", "tone", "m1", "e1", "tOne", "t1", "f81", "s81", "e81", "m81", "mone", "eone", "dOne", "eOne"], "e": ["ie", "o", "ne", "E", "ev", "xe", "pe", "ed", "nd", "edge", "dos", "ve", "v", "fe", "be", "l", "element", "ei", "y", "ec", "equal", "se", "el", "ue", "ef", "ae", "ea", "es", "z", "me", "n", "de", "ce", "c", "x", "eed", "p", "esi", "f", "ffe", "ee"]}}
{"project": "FFmpeg", "commit_id": "4749e074987d45cb98935a683a7ee8e1ee376d86", "target": 1, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n    int src_len, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    pd = dest;\n\n    if (src_len & 1)\n\n        *pd++ = *ps++;\n\n\n\n    src_len >>= 1;\n\n    i = 0;\n\n    do {\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_len);\n\n\n\n    return ps - src;\n\n}\n", "idx": 13859, "substitutes": {"src": ["sync", "upp", "send", "rs", "func", "front", "tmp", "raw", "source", "sc", "repl", "dist", "st", "rest", "desc", "cb", "sel", "size", "rt", "sur", "pack", "ssl", "sort", "cmp", "attr", "sq", "slice", "uc", "super", "bg", "ptr", "url", "rc", "config", "proc", "sub", "view", "supp", "rb", "lc", "rec", "sup", "iv", "lower", "cur", "fc", "rx", "comp", "req", "reverse", "b", "lit", "sl", "sr", "sb", "start", "pl", "load", "stream", "gb", "remote", "r", "loc", "inf", "img"], "dest": ["done", "delete", "d", "orig", "iter", " destination", "route", "tmp", "both", "temp", "cont", "txt", "source", "dist", "del", "dir", "comb", "pos", "end", "desc", "head", "wd", "size", "wb", "later", "destroy", "dc", "dep", "uc", "slice", "standard", "ptr", "config", "proc", "sub", "rib", "sup", "de", "buff", "home", "target", "start", "prop", "master", "remote", "Dest", "text", "trans", "loc"], "src_len": ["sr__line", "src_l", "src64start", "httpMln", "httpMline", " src_l", "src64limit", "dest_en", "src64len", " src_Len", "src_line", "src_ln", "sr_limit", "sr_start", "srcMlen", "src2len", "dest_length", "httpMlen", "src_en", "src2length", "sr__limit", " src_en", "http_line", "src_length", "src64line", "src2en", "dest_l", "src__start", "sr_line", "sr__start", "src_start", "sr__len", "http_ln", "sr_len", "src__len", "src__limit", "src_Len", "src_limit", "src__line", "srcMline", "src2l", "http_len", "srcMln"], "dest_len": ["destModlen", "dest_fail", "destModurl", "rc_url", "rcParurl", "destParfail", "rc_len", "destParlen", "destParurl", "dest_name", "rcParfail", "dest_l", "dest_line", " dest_name", "rc_fail", "dest_url", "rc_end", "rcParend", "destModend", " dest_line", "destModfail", "destParend", "rcParlen", " dest_l"], "ps": ["hs", "pe", "list", "PS", "pos", "ts", "its", "pi", "ims", "amps", " pops", "qs", "pl", "as", "js", "ins", "ports", "als", "po", "ys", "li", "cs", "parts", "ss", "pins", "gs", "lc", "pers", "ppa", "pse", "ns", "bps", "eps", "lines", "pass", "points", "gi", "ars", "changes", "pp", "ds", "ans", "pg", "cases", "pre", "pr", "ips", "lp", "les", "vs", "ph", "aps", "ms", "py", "powers", "ops", "comments", "d", "files", "rs", "proxy", "rules", "pt", "ups", "params", "posts", "pps", "bs", "es", "ks", "os", "pa", "Ps", "cp", " props", "s", "p", "ls", "pb", "css"], "pd": ["sync", "d", "pard", "kl", "pe", "tp", "ped", "la", "po", "li", "ll", "ld", "pt", "pos", "u", "xi", "pkg", "pc", "pm", "pi", "hd", "raf", "ds", "pp", "cd", "wd", "ctl", "wp", "pg", "dc", "pid", "fd", "lb", "api", "php", "PD", "dl", "lc", "pr", "pu", "lp", "vd", "xd", "pa", "ln", "sd", "dL", "phi", "ppa", "pex", "pse", "cp", "ppo", "p", "ph", "dd", "od", "lv", "dp", "pl", "lf", "python", "rl", "td", "py", "parser", "ls", "sth", "plugin", "da", "pb"], "i": ["it", "d", "o", "di", "gi", "ini", "iu", "mi", "t", "v", "im", "li", "e", "u", "xi", "pi", "L", "uri", "si", "in", "y", "ai", "ui", "m", "pid", "api", "a", "lc", "dl", "ix", "lp", "n", "ci", "id", "io", "bi", "qi", "ip", "x", "c", "phi", "is", "ami", "hi", "p", "index", "ri", "ji", "b", "ni", "f", "ir", "pl", "j", "ori", "ii", "I", "yi"], "l": ["d", "o", "kl", "le", "v", "la", "li", "ol", "ll", "e", "u", "fl", "length", "L", "lu", "loc", "m", "el", "lb", "lin", "lc", "dl", "z", "lp", "n", "ln", "c", "ul", "p", "s", "b", "sl", "il", "f", "lv", "pl", "lf", "ls", "j", "nl", "r", "t", "len"], "dest_end": ["dest_last", "destacEND", "destacend", "src_limit", "destacstart", "destResend", " dest_start", "src_end", " dest_range", "src_END", "destaclen", "destReslast", "destResrange", "dest_END", " dest_last", "src_start", "destResstart", "dest_range", "dest_limit", "dest_start"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,\n\n                                           src - (stride * 2) +\n\n                                           sizeof(uint8_t), stride,\n\n                                           dst, stride);\n\n}\n", "idx": 13867, "substitutes": {"dst": ["Dsrc", "ddsrc", "dsts", "ddst", "cdconst", "ddsts", "cdsts", "Dst", "dsrc", " drc", "Dsts", "dedsts", "dedconst", " dconst", "cdrc", "cdst", "ddrc", "dconst", " dsrc", "drc", "dedst", "dedrc", "Drc", " dsts"], "src": ["sync", "ctr", "source", "sc", "st", "dist", "cb", "sel", "size", "sur", "cmp", "grad", "sq", "uc", "inst", "sec", "url", "rc", "config", "supp", "sub", "rb", "sup", "cur", "gz", "comp", "lib", "sl", "sr", "sb", "stream", "gb", "buf", "img", "dest", "cv"], "stride": ["bride", "gestince", " strride", "erride", "stringide", "intided", "gestiden", "stringided", "striride", " strIDE", "striided", "errince", "striden", "stringipe", "intider", "drand", "intiden", "dride", "strince", "striiding", "gestider", "striide", "Stride", "stringider", " strand", "strIDE", "drIDE", "Strince", " strider", "striding", "Stripe", "Striding", "incand", "errided", "errider", "strided", "gestided", "strand", "Strided", "Strride", "incide", "brided", "incided", "Strider", "brider", " strided", "incIDE", "briden", " striding", "strride", "drided", "strider", "gestide", "intide", "stripe", " stripe"]}}
{"project": "FFmpeg", "commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "target": 1, "func": "static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                        const uint8_t **poutbuf, int *poutbuf_size,\n\n                        const uint8_t *buf, int buf_size)\n\n{\n\n    VorbisParseContext *s = s1->priv_data;\n\n    int duration;\n\n\n\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n\n        if (!s->vp)\n\n            goto end;\n\n    }\n\n\n\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n\n        s1->duration = duration;\n\n\n\nend:\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only packet analysis */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 13888, "substitutes": {"s1": [" s0", "sOne", "c01", "s4", "sp1", "qsone", "p4", "pone", "p0", " s4", "s2", "c3", "qs1", "c4", " s2", " s3", "s3", "c1", "sp2", "qs2", "cone", "c2", "p01", "sp0", "s01", "qs01", "spOne", "p3", "s0", "pOne", " sOne", "p2", "p1", "sone"], "avctx": ["Avcmp", "avcmp", "akpkg", "vercmp", "AVcrit", "afcontext", "Avcontext", "AVcontext", " avcf", "avecf", "avconnection", "akctx", " avcontext", "akcontext", "afcn", "varcb", "akcn", "varcmp", "Avctx", "AVcmp", "avcrit", "afcrit", "aveconnection", "afpkg", "avcb", "varctx", "afcf", "avectx", "ajcn", "avcf", "avpkg", "verctx", "afconn", "ajpkg", "afcmp", "afctx", "Avcrit", "AVctx", " avconnection", "vercn", "afconnection", "verconn", "vercontext", "ajconn", "avconn", "ajcontext", "avcn", "avecontext", "varcontext", "afcb", "avcontext", "ajctx", "vercb"], "poutbuf": [" pOutlog", "pagainbuffer", " pOutbuf", " pOutbuffer", "Poutbuffer", "Poutqueue", "pagainbuf", "poutbuffer", "pinbuf", "pOutlog", "poutlog", "pinlog", "poutqueue", "Poutbuf", "Pinbuf", "Pinbuffer", "pOutqueue", "pOutbuffer", "pinbuffer", "pagainlog", " poutlog", "Pinqueue", " poutbuffer", "pinqueue", "pOutbuf"], "poutbuf_size": ["poutbufssize", "poutbuffer_capacity", "poutbuf_small", "poutbag_number", "poutbag_small", "poutbufscapacity", "poutbuf_number", "poutbuf_capacity", "poutbuffer_size", "poutbufslength", "poutbuffer_length", "poutbag_size", "poutbuf_length"], "buf": ["fp", "binary", "aux", "prefix", "alloc", "data", "uf", "v", "bf", "br", "bc", "ff", "cf", "cb", "cmd", "fb", "wb", "pad", "queue", "padding", "vec", "uc", "fd", "offset", "seq", "rc", "rb", "ctx", "foo", "buff", "conv", "window", "Buffer", "b", "bag", "f", "src", "ab", "port", "buffer", "auc", "ref", "cas", "pb", "cv"], "buf_size": ["buf1ize", "batch_size", "buf_ize", "buffer_len", "bufssized", "bufslen", "buf32sized", "queue_len", "bufssize", "buf_len", "buffer_size", "buf_sized", "buffer_name", "queue_size", "queue_sized", " buf_ize", "buffer_sized", " buf_len", "buf32size", "batch_ize", "buf_name", "buf1size", "batch_sized", "buf32len", "bufsname", "buf1len"], "s": ["ps", "hs", "fs", "sync", "d", "us", "session", "rs", "v", "sc", "cs", "e", "sa", "u", "ts", "ds", "sys", "ss", "y", "an", "ssl", "m", "uns", "sq", "gs", "a", "xs", "g", "es", "ks", "self", "ads", "n", "ctx", "stats", "is", "context", "c", "vs", "i", "su", "sg", "p", "ns", "qs", "aws", "f", "sb", "as", "ses", "js", "ms", "vp", "ls", "services", "S"], "duration": ["period", "seconds", "d", "gap", "vid", "library", "address", "driver", "dt", "pause", "fee", "vm", "count", "until", "result", "end", " dur", "desc", "length", "runtime", "delay", "uri", "property", "timeout", "pad", "Duration", "later", "depth", "doc", "grade", "dep", "uu", "during", "nr", "frame", "episode", "time", "cost", "id", "version", "videos", "date", "timer", "description", "uv", "window", "interrupted", "type", "sleep", "start", "repeat", "dp", "series", " Duration", "port", "that", "vr", "ace", "event", "lag", "video", "len", "number", "span"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void xen_ram_init(PCMachineState *pcms,\n\n                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)\n\n{\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    ram_addr_t block_len;\n\n    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),\n\n                                                   PC_MACHINE_MAX_RAM_BELOW_4G,\n\n                                                   &error_abort);\n\n\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n\n     * min(xen limit, user limit).\n\n     */\n\n    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {\n\n        user_lowmem = HVM_BELOW_4G_RAM_END;\n\n    }\n\n\n\n    if (ram_size >= user_lowmem) {\n\n        pcms->above_4g_mem_size = ram_size - user_lowmem;\n\n        pcms->below_4g_mem_size = user_lowmem;\n\n    } else {\n\n        pcms->above_4g_mem_size = 0;\n\n        pcms->below_4g_mem_size = ram_size;\n\n    }\n\n    if (!pcms->above_4g_mem_size) {\n\n        block_len = ram_size;\n\n    } else {\n\n        /*\n\n         * Xen does not allocate the memory continuously, it keeps a\n\n         * hole of the size computed above or passed in.\n\n         */\n\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n\n    }\n\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n\n                           &error_abort);\n\n    *ram_memory_p = &ram_memory;\n\n    vmstate_register_ram_global(&ram_memory);\n\n\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n\n                             &ram_memory, 0, 0xa0000);\n\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n\n     * emulated device.\n\n     *\n\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n\n     * the Options ROM, so it is registered here as RAM.\n\n     */\n\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n\n                             &ram_memory, 0xc0000,\n\n                             pcms->below_4g_mem_size - 0xc0000);\n\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n\n                                 &ram_memory, 0x100000000ULL,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n\n    }\n\n}\n", "idx": 13890, "substitutes": {"pcms": ["pcros", " pcmb", "acms", "bcms", "mcml", "pcma", "pcs", "arcmes", "fcMS", "lcml", "aucmd", "pcmd", "bcmm", "ncents", "PCmb", "PCks", "PCps", "pacms", "pacws", "lcks", "aucma", "arcns", "pdma", "pcmm", "ancme", "pcps", "pacents", "acarms", "mcms", "mcks", "arccs", "bcma", "pdmm", "bcs", "arcps", "pacmb", "pcmb", "arcmaps", "PCms", "PCm", "discids", "PCws", "fcms", "arcml", "pacmn", "pcmn", "bcme", "arcmm", "locms", "ancks", "pcm", "encme", "ancMS", "discents", "ncids", "PCents", "acme", "locmn", "aucmes", "loccs", "aucms", "PCMS", "pcents", "tcmes", "arcents", "fcks", "encarms", "mcps", "bcns", "discps", "pcws", "arcmd", "arcks", "pcml", "pcmaps", "pdms", "PCros", "encs", "pcarms", "pdns", "tcma", "arcmn", "locmaps", "lcps", "mcme", "bcarms", "fcme", "pacmaps", "mcMS", "arcids", "mcm", "tcms", "arcros", "pacands", "paccs", "arcands", " pcents", "PCands", "encms", "tcmd", "pcmes", "ncps", "discms", "arcms", "pccs", "lcms", "ncms", "pacps", "pcks", "pcme", "acs", "pcands", "pcMS", "ancms", "pcns", "fcm", "pacros", " pcws", "pcids", "arcma"], "ram_size": ["ram_grow", "pool_grow", "ramlgrow", "ram_capacity", "poollsum", "sam_size", "sam_align", "ramfscale", "sam_capacity", "ram\u00b7size", "ramlsum", "block_address", "ramfend", "ram_engine", "pool_size", "ramllen", "ram_address", "gram_len", "gram_size", "block_mini", "ram_end", "ramfhandle", "pool_len", "ram_scale", "gram_handle", "ramlsize", "ram\u00b7sum", "ram\u00b7grow", "ram_sum", "poollgrow", "poolllen", "ram_min", "gram_min", "block_name", "ram_mini", "gram_end", "ram_align", "pool_sum", "poollsize", "ram_name", "ramfsize", "gram_scale", "ram_len", "ram\u00b7len", "ram_handle", "sam_engine", "block_size"], "ram_memory_p": ["ram_region_p", "ram_memory___P", "ram_memory_P", "ram_mem_t", "ram_region_r", "ram_memory_t", "ram_mem_P", "ram_memory_pair", "ram_memory___pair", "ram_memory___r", "ram_mem_p", "ram_memory_r", "ram_region_P", "ram_memory___p", "ram_region_pair"], "sysmem": ["sysema", "systemlim", "osema", " sysmm", "Sysmm", "ysaccess", "Sysmem", " sysmemory", "Sysaccess", "Sysmemory", "osram", " sysvm", "ysmem", " syslim", "ysmemory", "rammem", "rammemory", "sysram", "Sysvm", "sysvm", "sysmemory", "ramema", "osmemory", "systemmm", "sysmm", "Sysram", " sysdem", "osmem", "systemmem", "sysdem", "syslim", "osaccess", "sysaccess", "systemvm", " sysema", "ysram", "osdem", "Syslim", "ramdem"], "block_len": ["block\u00b7val", "block_lock", "blockinglen", "block__long", "recordetlen", "block67len", "block_val", "block___val", "block_dim", "record_dim", "block_loc", "row_length", "blocketlen", "recordetsize", "block_ln", "recordetlong", "block\u00b7len", "record_long", "block\u00b7lock", "block_length", " block_val", "block___len", "record_size", "blockingno", "row_len", "block67ln", "block___size", "blocketdim", "block__len", "block__dim", "row_line", "block67lock", "block_line", "blocketsize", "block_long", "record_len", "row_no", " block_size", "block___loc", "blockinglength", "block_no", " block_ln", "blockingline", "recordetdim", "block67val", "block__size", "blocketlong", " block_lock", " block_loc", "block_size", "block\u00b7ln"]}}
{"project": "qemu", "commit_id": "caae58cba07efec5f0616f568531c9dfaf1e9179", "target": 1, "func": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n", "idx": 13897, "substitutes": {"opaque": [" ophole", "litacity", "opsaque", "opsac", "opac", "ophole", "oplhole", "litec", "oplaque", "obac", "obacity", "obec", "opshole", "opsacle", "litaque", " opacity", "obaque", "litac", "opec", "oplacle", "opacity", "opsacity", "oplacity", " opacle", "opacle", "opsec"], "irq_num": ["irc_off", "irq_name", "irc_number", "irq_off", "irp_number", "irq_number", "irp_begin", "irp_nu", "irq_unit", "irc_num", "irc_nom", "irq_begin", "irq_nom", "irq_nu", "irp_num", "irp_nom", "irp_unit", "irp_name"], "level": ["Level", "file", "letter", "loop", "mode", "sol", "local", "lo", "message", "length", "style", "depth", "path", "full", "limit", "valid", "vel", "url", "unit", "method", "location", "point", "key", "where", "stage", "line", "wl", "clean", "layer", "index", "type", "lvl", "scope", "inc", "levels", "value", "loc", "len", "rol"], "phb": ["shab", "handbu", "aphb", " phab", "handc", "handbb", " phbb", "Phb", "phc", " phc", "Phsb", " Phb", "phab", " Phsb", "aphbb", "Pha", " phbu", "shsb", "aphc", "aphab", "pha", "phcb", "Phbd", "Phcb", " Pha", "sha", "phbu", "phbb", "Phbb", "handb", "aphsb", " phsb", "aphbu", "shcb", " phbd", " Phbd", "shb", "phsb", " pha", "phbd", "shbb", " phcb"]}}
{"project": "FFmpeg", "commit_id": "2f6ec9fdd7808c8ed045ae0ca4134ab21fb785e6", "target": 1, "func": "static int alloc_sequence_buffers(DiracContext *s)\n\n{\n\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n\n    int sbheight = DIVRNDUP(s->source.height, 4);\n\n    int i, w, h, top_padding;\n\n\n\n    /* todo: think more about this / use or set Plane here */\n\n    for (i = 0; i < 3; i++) {\n\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n\n\n        /* we allocate the max we support here since num decompositions can\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n", "idx": 13899, "substitutes": {"s": ["session", "site", "sc", "u", "ts", "its", "states", "sys", "si", "se", "m", "xs", "sup", "self", "n", "spec", "qs", "src", "sb", "js", "services", "t", "native", "ps", "sync", "fs", "o", "ins", "e", "cs", "parts", "ss", "y", "ssl", "sq", "gs", "sf", "a", "is", "c", "x", "sg", "ns", "settings", "us", "uses", "l", "ds", "ans", "service", "vs", "ses", "sym", "S", "ops", "d", "sv", "rs", "secondary", "features", "params", "uns", "g", "es", "ks", "os", "su", "args", "p", "b", "aws", "sets", "f", "ls", "r", "conf"], "i": ["it", "ini", "v", "u", "pi", "si", "in", "ui", "m", "iii", "ix", "n", "init", "esi", "ic", "ni", "start", "j", "ii", "I", "part", "ie", "o", "li", "e", "image", "mu", "y", "inst", "ti", "eni", "iv", "id", "bi", "qi", "ip", "phi", "x", "input", "is", "hi", "ri", "yi", "di", "gi", "fi", "multi", "l", "ai", "io", "zi", "d", "chi", "iu", "mi", "xi", "inner", "uri", "ei", "ik", "ci", "mini", "ish", "oi", "ij", "info", "ji", "p", "index", "cli", "f", "ski"], "w": ["wall", "how", "d", "wh", "ew", "rw", "tw", "wen", "v", "wal", "u", "l", "wd", "work", "wb", "iw", "y", "wp", "ow", "m", "W", "q", "wave", "hw", "c", "wo", "aw", "g", "wan", "z", "wx", " W", "n", "win", "x", "ww", "wl", "wt", "p", "weight", "we", "max", "b", "sw", "wrap", "kw", "f", "r", "nw", "wn", "fw", "t", "wa"], "h": ["hs", "en", "d", "wh", "o", "ha", "height", "v", "e", "oh", "uh", "u", "rh", "l", "ht", "y", "hm", "padding", "m", "gh", "he", "hw", "ul", "g", "bh", "z", "n", "hr", "sh", "x", "H", "hi", "c", "p", "ah", "ph", "q", "b", "sw", "f", "r", "max", "t", "wa"], "top_padding": [" top_margin", "bottom_adding", "Top_padding", "top__adding", "TOP_pad", "bottom_padding", "top_adding", "top__padding", "Top_pad", "bottom_margin", "top_margin", "top__pad", "Top_margin", "TOP_adding", "top_pad", "TOP__adding", "TOP_padding", "TOP__padding", " top_pad", "TOP__pad", "Top_inning", "bottom_pad", "top_inning", "TOP_margin", " top_adding", "top__margin", "TOP__margin"]}}
{"project": "FFmpeg", "commit_id": "bfeb83a8b7d3fcf09a54d8dbc9c521e10bb17530", "target": 1, "func": "static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    const uint8_t *rtp_pl = buf;\n\n    int tid, lid, nal_type;\n\n    int first_fragment, last_fragment, fu_type;\n\n    uint8_t new_nal_header[2];\n\n    int res = 0;\n\n\n\n    /* sanity check for size of input packet: 1 byte payload at least */\n\n    if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short RTP/HEVC packet, got %d bytes\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n     * decode the HEVC payload header according to section 4 of draft version 6:\n\n     *\n\n     *    0                   1\n\n     *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\n     *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n     *   |F|   Type    |  LayerId  | TID |\n\n     *   +-------------+-----------------+\n\n     *\n\n     *      Forbidden zero (F): 1 bit\n\n     *      NAL unit type (Type): 6 bits\n\n     *      NUH layer ID (LayerId): 6 bits\n\n     *      NUH temporal ID plus 1 (TID): 3 bits\n\n     */\n\n    nal_type =  (buf[0] >> 1) & 0x3f;\n\n    lid  = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f);\n\n    tid  =   buf[1] & 0x07;\n\n\n\n    /* sanity check for correct layer ID */\n\n    if (lid) {\n\n        /* future scalable or 3D video coding extensions */\n\n        avpriv_report_missing_feature(ctx, \"Multi-layer HEVC coding\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* sanity check for correct temporal ID */\n\n    if (!tid) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Illegal temporal ID in RTP/HEVC packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* sanity check for correct NAL unit type */\n\n    if (nal_type > 50) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported (HEVC) NAL type (%d)\\n\", nal_type);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (nal_type) {\n\n    /* video parameter set (VPS) */\n\n    case 32:\n\n    /* sequence parameter set (SPS) */\n\n    case 33:\n\n    /* picture parameter set (PPS) */\n\n    case 34:\n\n    /*  supplemental enhancement information (SEI) */\n\n    case 39:\n\n    /* single NAL unit packet */\n\n    default:\n\n        /* sanity check for size of input packet: 1 byte payload at least */\n\n        if (len < 1) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* create A/V packet */\n\n        if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0)\n\n            return res;\n\n        /* A/V packet: copy start sequence */\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        /* A/V packet: copy NAL unit data */\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n\n\n        break;\n\n    /* aggregated packet (AP) - with two or more NAL units */\n\n    case 48:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        res = ff_h264_handle_aggregated_packet(ctx, pkt, buf, len,\n\n                                               rtp_hevc_ctx->using_donl_field ?\n\n                                               RTP_HEVC_DOND_FIELD_SIZE : 0,\n\n                                               NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        break;\n\n    /* fragmentation unit (FU) */\n\n    case 49:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /*\n\n         *    decode the FU header\n\n         *\n\n         *     0 1 2 3 4 5 6 7\n\n         *    +-+-+-+-+-+-+-+-+\n\n         *    |S|E|  FuType   |\n\n         *    +---------------+\n\n         *\n\n         *       Start fragment (S): 1 bit\n\n         *       End fragment (E): 1 bit\n\n         *       FuType: 6 bits\n\n         */\n\n        first_fragment = buf[0] & 0x80;\n\n        last_fragment  = buf[0] & 0x40;\n\n        fu_type        = buf[0] & 0x3f;\n\n\n\n        /* pass the HEVC FU header */\n\n        buf += RTP_HEVC_FU_HEADER_SIZE;\n\n        len -= RTP_HEVC_FU_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        av_dlog(ctx, \" FU type %d with %d bytes\\n\", fu_type, len);\n\n\n\n        if (len <= 0) {\n\n            /* sanity check for size of input packet: 1 byte payload at least */\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (first_fragment && last_fragment) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Illegal combination of S and E bit in RTP/HEVC packet\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1);\n\n        new_nal_header[1] = rtp_pl[1];\n\n\n\n        res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment,\n\n                                         new_nal_header, sizeof(new_nal_header));\n\n\n\n        break;\n\n    /* PACI packet */\n\n    case 50:\n\n        /* Temporal scalability control information (TSCI) */\n\n        avpriv_report_missing_feature(ctx, \"PACI packets for RTP/HEVC\\n\");\n\n        res = AVERROR_PATCHWELCOME;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return res;\n\n}\n", "idx": 13905, "substitutes": {"ctx": ["fp", "client", "sync", "ct", "ux", "ha", "cam", "connection", "cn", "exec", "jp", "txt", "nt", "cm", "la", "sc", "nc", "pkg", "bc", "sci", "util", "cf", "cb", "cmd", "kb", "qa", "anc", "Context", "cc", "cmp", "lex", "grad", "uc", "hw", "rc", "config", "lc", "cca", "ck", "progress", "vc", "ci", "cor", "context", "c", "conv", "mac", "cl", "cli", "coll", "kw", "ack", "tx", "ctrl", "kt", "crit", "utils", "wcs", "ocr", "cci", "auc", "xc", "loc", "conn", "cas", "cv"], "rtp_hevc_ctx": ["rtp_hevc__ctx", "rtp_hevc_context", "rtp_heic_cas", "rtp_heic_context", "rtp_hevc__context", "rtp_heic_tx", "rtp_heic_ctx", "rtp_hevc__tx", "rtp_hevc__cas", "rtp_hevc_tx", "rtp_hevc_cas"], "st": ["ct", "ST", "nd", "nt", "sc", "St", "sa", "ut", "rest", "ste", "ss", "se", "sp", "inst", "str", "sta", "sts", "cur", "mt", "stage", "art", "ast", "sw", "src", "sb", "ace", "sth", "std"], "pkt": ["belt", "bck", "hke", "fct", "cpmt", "fet", " packet", "pke", "Pct", " pk", "fnt", "fkt", "pqt", "pck", "Pk", "pelt", " pet", "pet", "hkt", "nke", "Pck", "fk", "packet", "backet", "net", "nmt", "Pkt", "nkt", "het", "pmt", "Pelt", "pnt", "Pnt", "bkt", "cpet", " pck", "pct", "Packet", "fqt", "hmt", " pqt", " pnt", "pk", "cpke", "Pet", " pelt", "cpkt", "Pqt", "facket", " pct"], "timestamp": ["temest", "tmestamp", "tmeline", "timeline", "temetime", "tmest", "timest", "tmetime", "rameline", "ramest", "ramestamp", "rametime", "timetime", "temestamp", "temeline"], "buf": ["fp", "brace", "ru", "batch", "aux", "img", "func", "bn", "fi", "exc", "data", "uf", "txt", "bf", "br", "bc", "feat", "ff", "fn", "cf", "cb", "fb", "cmd", "cas", "wb", "pad", "header", "cap", "bus", "queue", "vec", "uc", "fd", "bg", "pool", "rc", "config", "proc", "bh", "num", "rb", "cur", "mem", "buff", "context", "bp", "conv", "bytes", "window", "uv", "bb", "req", "b", "bag", "src", "msg", "port", "Buff", "buffer", "auc", "gb", "text", "loc", "ref", "array", "pb", "cv"], "len": ["body", "enc", "en", "part", "lan", "fin", "bl", "list", "data", "split", "la", "nt", "li", "count", "ll", "Len", "pos", "fn", "fl", "ld", "end", "l", "length", "lt", "size", "val", "lon", "lu", "el", "limit", "offset", "fd", "elt", "lin", "fun", "lc", "lim", "dl", "hl", "num", "lp", "n", "lock", "rev", "ln", "line", "bytes", "layer", "lib", "lvl", "lit", "gen", "lf", "pl", "lang", "loc", "span"], "seq": ["ux", " resp", "count", "pos", "format", "cb", "val", "res", "queue", "vec", "frame", "sec", "num", "version", "q", "cl", " sequence", "ver", "vals", "gen", " count", "flag", "ret", "sequence", "code"], "flags": ["fs", "files", "options", "Flags", "mask", "fn", "ff", "ts", "ffff", "features", "rows", "offset", "fd", "frame", "bits", "bytes", "vals", "rep", "frames", "flag", "fields", "ents", "ants", "ret", "lag"], "rtp_pl": ["rtpo__ctx", "rtp_prot", "rtpo__lang", "rtpo__pl", "rtp__pl", "rtp__ctx", "rtp_lang", "rtpo__prot", "rtp__lang", "rtpo_prot", "rtpo_ctx", "rtp_ctx", "rtpo_pl", "rtp__prot", "rtpo_lang"], "tid": ["tname", "tiide", "nide", "tids", "nids", " tID", " tok", "pid", "lname", "tiip", "pID", "tID", "tfID", "pip", "tip", "tkid", "tfkid", "nip", "fip", "nok", "tok", "fids", "fname", "tiid", "lids", "nkid", "nname", "tfok", "tiID", "tfid", "fid", "lip", "tide", " tkid", "nID", "nid", "pide"], "lid": ["tids", "lend", "llaid", "tend", " laid", "pids", " lbid", " lkid", "lq", "pid", " lq", "llkid", " lend", "llid", "tkid", "elkid", "lbid", "tq", "elid", "lids", "pend", "lkid", "elbid", "taid", "tbid", "paid", "llq", "laid", " lids", "elaid"], "nal_type": ["naling_level", "nal___types", "nmal_type", "nal_style", "nalpkey", "nal_key", "naler_id", "naler_name", "nal_id", "naler_type", "nmal_ype", "nmal_key", "nal_Type", "nstal_list", "nal67ype", "nstal_id", "naler_Type", "nal___list", "nal_level", "nal___type", "nalpType", "nmal_Type", "nstal_type", "nstal_style", "nbal_style", "nstal_types", "nal_list", "nal67key", "nal_types", "nstal_name", "naling_type", "nalpype", "nal67type", "nalptype", "nal_ype", "nal_set", "nal_name", "nbal_type", "nal67Type", "nal___style", "naling_style", "nbal_set", "nbal_types"], "first_fragment": ["first_frangment", "first_drigment", "first_dragment", "first_drigments", "first_drigement", "first_frainments", "first_frigment", "first_fragments", "first_frangement", "first_frangments", "first_fraggment", "first_friggment", "first_fragement", "first_draggment", "first_dragement", "first_fraingment", "first_franggment", "first_dragments", "first_frainement", "first_frigement", "first_driggment", "first_frainment", "first_frigments"], "last_fragment": ["last_friggment", "last_frangments", "last_frigement", "last_fagments", "last_frangment", "last_faggment", "last_figment", "last_fraggment", "last_frangement", "last_frigment", "last_figments", "last_figement", "last_fragement", "last_fragments", "last_franggment", "last_fagment", "last_fraggement", "last_figgment", "last_fragggment", "last_fraggments", "last_fagement", "last_frigments"], "fu_type": ["fuenoffset", "fu_key", "uniqueclkey", "unique_offset", "fu_state", "fu_offset", "uniquecltype", "fuentype", "fucloffset", "fucltype", "uniqueclstate", "unique_type", "fuenkey", "fuenstate", "unique_key", "unique_state", "uniquecloffset", "fuclkey", "fuclstate"], "new_nal_header": ["new_nal_entry", "new_nul_entry", "new_nul_num", "new_nal1entry", "new_nal_num", "new_nalenentry", "new_nalenlayer", "new_nal_layer", "new_nul_header", "new_nalennum", "new_nal1layer", "new_nal1num", "new_nal1header", "new_nalenheader", "new_nul_layer"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13906, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int libschroedinger_encode_close(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    /* Close the encoder. */\n\n    schro_encoder_free(p_schro_params->encoder);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->enc_frame_queue,\n\n                        libschroedinger_free_frame);\n\n\n\n\n\n    /* Free the encoder buffer. */\n\n    if (p_schro_params->enc_buf_size)\n\n        av_freep(&p_schro_params->enc_buf);\n\n\n\n    /* Free the video format structure. */\n\n    av_freep(&p_schro_params->format);\n\n\n\n    return 0;\n\n}\n", "idx": 13915, "substitutes": {"avctx": ["avcmp", "apcontext", "avcmd", "apconfig", "afcontext", "AVcontext", "apctx", "akctx", "afconfig", "akcontext", "avconfig", "AVcmp", "avcb", "afcmp", "afctx", "akcmd", "AVctx", "apcmp", "AVconfig", "AVcmd", "AVcb", "afcb", "afcmd", "avcontext", "akcb"], "p_schro_params": ["p_schlo_manager", "p_schro__params", "p_schros_manager", "p_schro_processor", "p_schro_parser", "p_schros_params", "p_schroedprocessor", "p_schro__manager", "p_schlo_params", "p_schrob_param", "p_schro_data", "p_schrob_data", "p_schrob_channel", "p_schroedparams", "p_schro__param", "p_schro_ams", "p_schro__parser", "p_schro_manager", "p_schros_param", "p_schrosmanager", "p_schro_channel", "p_schro_param", "p_schrob_processor", "p_schrob_params", "p_schrob_parser", "p_schrosparams", "p_schrosparam", "p_schroedmanager", "p_schros_master", "p_schrob_manager", "p_schlo_param", "p_schro_master", "p_schro__channel", "p_schrosams", "p_schlo_ams", "p_schroedparam"]}}
{"project": "FFmpeg", "commit_id": "121be310607879841d19a34d9f16d4fe9ba7f18c", "target": 0, "func": "static int cinepak_decode_frame(AVCodecContext *avctx,\n\n                                void *data, int *got_frame,\n\n                                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int ret = 0, buf_size = avpkt->size;\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->data = buf;\n\n    s->size = buf_size;\n\n\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->palette_video) {\n\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n\n            s->frame->palette_has_changed = 1;\n\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n\n        }\n\n    }\n\n\n\n    if ((ret = cinepak_decode(s)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"cinepak_decode failed\\n\");\n\n    }\n\n\n\n    if (s->palette_video)\n\n        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);\n\n\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n\n        return ret;\n\n\n\n    *got_frame = 1;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 13943, "substitutes": {"avctx": ["akpkg", "avcmp", "apcontext", "afcontext", "AVcontext", "apcu", "apctx", "akctx", "akcontext", "ajcv", "AVpkg", "AVcmp", "afcv", "afpkg", "abcv", "avctl", "avectx", "abcmp", "ajcu", "aircontext", "abctx", "avpkg", "avcu", "ajctl", "afcmp", "afctx", "avnp", "AVctx", "abcontext", "aircmp", "airctx", "avcv", "aircv", "ajnp", "afctl", "afcu", "avectl", "afnp", "ajcontext", "avecv", "avecontext", "akcmp", "avcontext", "apnp", "ajctx"], "data": ["module", "pos", "dat", "open", "val", "map", "response", "parent", "channel", "window", "req", "Data", "start", "DATA", "value", "o", "flow", "raw", "media", "image", "delay", "resource", "res", "queue", "new", "slice", "a", "block", "id", "cache", "input", "memory", "family", "load", "buffer", "ad", "file", "func", "empty", "la", "after", "result", "message", "size", "bin", "ata", "rec", "buff", "name", "call", "alpha", "da", "code", "body", "d", "actions", "connection", "content", "board", "reader", "results", "package", "base", "length", "frame", "ada", "feed", "args", "info", "p", "device", "f", "video", "next"], "got_frame": ["got_frames", "gotacFrame", "got_Frame", "got_size", "get_thread", "get_fram", "get_frames", "get_size", "get_Frame", "got_thread", "gotacthread", "got_fram", "gotacfram", "gotacframe", "get_frame"], "avpkt": ["AVcpkt", "avckt", "AVpacket", "avpct", "avnpett", "afpelt", "avwpwk", " avpcht", " avwpacket", "avppwk", "avfpcht", "AVcpet", "avplelt", "avpcht", "awpct", "awpkt", "avpakt", "avcett", "avpkh", "afpkh", "avnpkt", "avwpacket", "avpaacket", "avwpcht", "avfwk", "avwpkt", "avfcht", "avplkh", "avcpqt", "avcpacket", "afpacket", "avfpkt", "AVpkt", "affkh", "avcct", "avpacket", "avfpacket", "avplkt", "avfkh", "avcpett", "affacket", "avfkt", "avfpet", "avppkt", "avpakh", " avpwk", "avppacket", "awnpct", "awpett", "awpqt", "avnpqt", "avfelt", "avpqt", "avcqt", "avpet", "avcpkt", " avwpkt", "affkt", "AVpet", "avpwk", " avpacket", "avpett", "AVcpacket", "avcpct", "avpelt", "avcpcht", "AVcpcht", "afpkt", "avnpct", "affelt", " avwpcht", "avfacket", "avppcht", "avcpet", "AVpcht", "awnpqt", " avwpwk", "awnpkt", "awnpett", "avpaelt", "avfet", "avplacket"], "buf": ["fp", "bd", "alloc", "tmp", "fi", "uf", "v", "raw", "bc", "obj", "ff", "raf", "cb", "fb", "base", "val", "pad", "queue", "vec", "uc", "fd", "pool", "config", "rb", "block", "ctx", "buff", "cache", "box", "p", "Buffer", "b", "bag", "f", "port", "Buff", "buffer", "ref", "array", "pack", "pb", "cv"], "s": ["hs", "session", "site", "sc", "obj", "ts", "its", "sys", "si", "m", "xs", "self", "n", "spec", "i", "h", "qs", "sb", "as", "js", "services", "t", "ps", "sync", "fs", "o", "ins", "cs", "e", "parts", "ss", "y", "ssl", "new", "sq", "gs", "a", "sports", "is", "c", "sg", "ns", "bis", "us", "l", "ds", "ans", "service", "vs", "ses", "ms", "sym", "S", "ops", "comments", "d", "rs", "server", "full", "uns", "bs", "g", "es", "ks", "os", "ctx", "su", "p", "b", "aws", "f", "ls"], "pal": ["ascal", "phil", "ne", "lan", "nav", "panel", "app", "le", "ale", "bl", "pe", "Pal", "opal", "stal", "wal", "v", "li", "ill", "local", "plug", "skin", "sal", "area", "rel", "pp", "align", "bin", "bil", "plan", "fal", "alias", "pixel", "pack", "pocket", "pid", "gal", "el", "label", "al", "ali", "scale", "channel", "pill", "wan", "par", "pol", "pa", "ell", "vale", "p", "ph", "cal", "il", "pl", "cel", "theme", "py", "nl", "isal", "cell", "chal", "bel", "pel", "sk", "pod"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void taihu_405ep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    qemu_irq *pic;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *bios;\n\n    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));\n\n    MemoryRegion *ram = g_malloc0(sizeof(*ram));\n\n    hwaddr ram_bases[2], ram_sizes[2];\n\n    long bios_size;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors;\n\n    DriveInfo *dinfo;\n\n\n\n    /* RAM is soldered to the board so the size cannot be changed */\n\n    ram_size = 0x08000000;\n\n    memory_region_allocate_system_memory(ram, NULL, \"taihu_405ep.ram\",\n\n                                         ram_size);\n\n\n\n    ram_bases[0] = 0;\n\n    ram_sizes[0] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[0], NULL,\n\n                             \"taihu_405ep.ram-0\", ram, ram_bases[0],\n\n                             ram_sizes[0]);\n\n    ram_bases[1] = 0x04000000;\n\n    ram_sizes[1] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[1], NULL,\n\n                             \"taihu_405ep.ram-1\", ram, ram_bases[1],\n\n                             ram_sizes[1]);\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes,\n\n                  33333333, &pic, kernel_filename == NULL ? 0 : 1);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#if defined(USE_FLASH_BIOS)\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 2MB */\n\n        //        bios_size = 2 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, -bios_size,\n\n               bdrv_get_device_name(bs), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size),\n\n                              NULL, \"taihu_405ep.bios\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, NULL, \"taihu_405ep.bios\", BIOS_SIZE,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(bios);\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, memory_region_get_ram_ptr(bios));\n\n            g_free(filename);\n\n            if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n                error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n                exit(1);\n\n            }\n\n            bios_size = (bios_size + 0xfff) & ~0xfff;\n\n            memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios);\n\n        } else if (!qtest_enabled()) {\n\n            error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    /* Register Linux flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 32MB */\n\n        bios_size = 32 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr \" TARGET_FMT_lx \" '%s'\\n\",\n\n               fl_idx, bios_size, (target_ulong)0xfc000000,\n\n               bdrv_get_device_name(bs));\n\n#endif\n\n        pflash_cfi02_register(0xfc000000, NULL, \"taihu_405ep.flash\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(sysmem, 0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n", "idx": 13951, "substitutes": {"machine": ["storage", "module", "part", "computer", "session", "address", "connection", "vm", "data", "mobile", "mode", "image", "sm", "process", "message", "base", "model", "space", "db", "m", "service", "object", "state", "M", "program", "config", "linux", "boot", "mini", "mem", "node", "cache", "memory", "mac", "hard", "motion", "cpu", "device", "instance", "Machine", "mc", "mount", "template", "controller", "loader", "manager", "database"], "kernel_filename": ["kernelboardfilename", "kernel_label", "kernelpubfilename", "kernel_theme", "loader_information", "kernelboarddirectory", "kernelpubFilename", " kernel_Filename", "kernel_name", "kernel_file", "ernel_name", "kernel_information", "kernelpubtheme", "kernelboardinformation", "kernel_Filename", " kernel_file", "loader_size", "ernel_filename", "loader_directory", " kernel_theme", "ernel_label", "loader_filename", "kernelboardsize", "kernel_directory", "kernelpubfile"], "initrd_filename": ["initrt_username", "initrd67filename", "initrd__filename", "initrt_description", "initrd___width", "initrd_binary", "initrd__username", "initrd__memory", "initrt_memory", "initrd__binary", "initrd67username", "initrd67binary", "initrd___filename", "initrd_description", "initrt_filename", "initrd_memory", "initrd___description", "initrd67memory", "initrt_binary", "initrd_username", "initrd___username", "initrt_width", "initrd_width"], "filename": ["fp", "prefix", "binary", "document", "kl", "files", "file", "original", "Filename", "image", "fn", "processor", "uri", "password", "username", "path", "writer", "pixel", "login", "url", "File", "picture", "fil", "name", "acl", "tty"], "pic": ["sync", "fs", "file", "cam", "Pic", "fi", "temp", "mic", "xi", "image", "fn", "sci", "pc", "script", "pi", "sys", "bin", "writer", "nic", "pixel", "bus", "ig", "gui", "pins", "lc", "ac", "mini", "fc", "cache", "picture", "mac", "lib", "pict", "misc", "ic", "pin"], "sysmem": ["systemlim", " sysmemory", "svm", "osram", "ysmem", " syslim", "ysmemory", "sysram", "systemram", "sysvm", "sysmemory", "smemory", "osmemory", "smem", "yslim", " sysram", "osmem", "systemmem", "osvm", "syslim", "sram", "systemvm", "ysram", "systemmemory"], "bios": ["bii", "rbios", "nbias", "bias", "Bii", "rbias", "Bias", "Bio", "rbio", "bio", "Bios", "nbio", "nbios", "nbii", "rbii"], "ram_memories": ["ram_memorers", "ram_processors", "ram_processories", "ram_memipes", "ram_regeters", "ram_factories", "ram_temrollers", "ram_processives", "ram_comborers", "ram_processrices", "ram_accessrollers", "ram_temories", "ram_accessory", "ram_memoryory", "ram_regories", "ram_tomories", "ram_temores", "ram_combives", "ram_regipes", "ram_memeters", "ram_processores", "ram_accessories", "ram_tomrices", "ram_memors", "ram_memives", "ram_combrices", "ram_regory", "ram_temors", "ram_regores", "ram_temeters", "ram_combories", "ram_factory", "ram_memrices", "ram_processory", "ram_accessors", "ram_processipes", "ram_tomives", "ram_accesseters", "ram_temory", "ram_memory", "ram_tomorers", "ram_accessores", "ram_memoryors", "ram_memoryipes", "ram_memrollers", "ram_regors", "ram_memoryories", "ram_memores", "ram_processorers", "ram_factores", "ram_factrollers"], "ram": ["module", "mm", "rw", "cam", "micro", "jam", "amd", "vm", "sim", "user", "cm", "nam", "sc", "mode", "image", "container", "grain", "disk", "process", "pc", "ruby", "access", "password", "resource", "space", "pixel", "Ram", "hw", "iam", "dim", "sam", "program", "rage", "kernel", "ra", "man", "channel", "region", "gam", "win", "am", "mem", "memory", "mac", "gram", "cpu", "device", "dam", "row", "RAM", "mc", "mount", "mor", "loader", "gb", "array", "pack", "folder"], "ram_bases": ["ram_Bases", "ram_bubashes", "ram_Basing", "ram_backases", "ram_susters", "ram_buffasing", "ram_matches", "ram_Boots", "ram_lasing", "ram_wbases", "ram_brasing", "ram_buffase", "ram_dasing", "ram_soots", "ram_ambabilities", "ram_base", "ram_buffases", "ram_masing", "ram_bubuses", "ram_wbamps", "ram_Bizes", "ram_backasing", "ram_wbizes", "ram_bubasing", "ram_ambases", "ram_boots", "ram_bubases", "ram_backusters", "ram_basing", "ram_abases", "ram_sasing", "ram_lashes", "ram_abores", "ram_mase", "ram_backoots", "ram_bores", "ram_buffores", "ram_busters", "ram_brices", "ram_labilities", "ram_latches", "ram_lases", "ram_bruses", "ram_batches", "ram_bubabilities", "ram_bubices", "ram_abase", "ram_mases", "ram_dases", "ram_Batches", "ram_brases", "ram_bamps", "ram_Busters", "ram_ambashes", "ram_lase", "ram_babilities", "ram_duses", "ram_buses", "ram_ambizes", "ram_sases", "ram_Base", "ram_bices", "ram_bashes", "ram_Bamps", "ram_ambamps", "ram_bizes", "ram_abasing", "ram_wbasing", "ram_ambasing", "ram_dices", "ram_lores"], "ram_sizes": ["ram_sizers", "ram_pizations", "ram_setsiques", "ram_sizing", "ram_syiques", "ram_size", "ram_setsamples", "ram_asises", "ram_esizing", "ram_syizes", "ram_insases", "ram_insixels", "ram_esensing", "ram_cizes", "ram_setsixels", "ram_ensizes", "ram_ensessions", "ram_esases", "ram_sesessions", "ram_sesizes", "ram_somes", "ram_sizations", "ram_statesizing", "ram_syenses", "ram_statesizes", "ram_cases", "ram_cizable", "ram_statizers", "ram_setsensing", "ram_setsomes", "ram_cize", "ram_censing", "ram_senses", "ram_camples", "ram_esizes", "ram_pizes", "ram_asizations", "ram_statesises", "ram_sizable", "ram_comes", "ram_isizable", "ram_asizes", "ram_isizes", "ram_setsizes", "ram_statizes", "ram_statizing", "ram_sesize", "ram_insizing", "ram_insamples", "ram_asizing", "ram_isizers", "ram_sixels", "ram_ciques", "ram_siques", "ram_cizers", "ram_cixels", "ram_pizing", "ram_syomes", "ram_sensing", "ram_sises", "ram_insensing", "ram_pises", "ram_statesizations", "ram_ensizing", "ram_censes", "ram_samples", "ram_sessions", "ram_isizing", "ram_statizable", "ram_sases", "ram_sesizing", "ram_setsenses", "ram_insizes", "ram_cessions", "ram_ensize", "ram_cizing"], "bios_size": ["bios_capacity", "bits_capacity", "bios_width", "bits_width", "bits_size"], "kernel_base": ["kernel_scale", "ram_size", "kernel_area", "ram_scale", "ram_base", "ram_area"], "initrd_base": ["initrs_base", "initrs_width", "initrs_buffer", "initrs_size", "initrd_buffer", "initrd_width"], "kernel_size": ["ernel_base", "kernel_width", "ernel_capacity", "ernel_width", "ernel_size", "kernel_capacity"], "initrd_size": ["initrs_base", "initrs_capacity", "initrs_size", "initrd_capacity"], "linux_boot": ["sys_size", "linux86setup", "sys_boot", "linux_mount", "linux86size", "linux_setup", "linux86mount", "sys_mount", "linux86boot", "linux_size", "sys_setup"], "fl_idx": ["fl_Idy", "fl_Idz", "fl_idy", "fl__Idxs", "fl_ideX", "fl_pidx", "fl_idf", "fl__idx", "fl_pidb", "fl_pidxes", "fl__Idxes", "fl_idxes", "fl_Idxs", "fl__Idb", "fl_idey", "fl_idxs", "fl_sidx", "fl_idxe", "fl__idxes", "fl_Idx", "fl_pidxs", "fl_sidf", "fl_Idxe", "fl_sidxe", "fl_idef", "fl_idexe", "fl_sidX", "fl_Idb", "fl_idex", "fl__idxs", "fl_idb", "fl_Idxes", "fl__idb", "fl_idX", "fl_IdX", "fl__Idx", "fl_idez", "fl_Idf", "fl_idz"], "fl_sectors": ["fl_idctors", "fl_vegment", "fl_clegment", "fl_selic", "fl_idlic", "fl_vex", "fl_idgment", "fl_velic", "fl_clectors", "fl_clex", "fl_sex", "fl_clelic", "fl_vectors", "fl_segment"], "dinfo": ["dltype", "dbInfo", "lstate", "dmINFO", "bstate", " daction", " dstate", "dINFO", "binfo", "DInfo", "dmInfo", "dlInfo", "Dinfo", "dninfo", "dindex", "dmaction", "dbaction", "dbtype", " dindex", "dInfo", "bindex", "dbinfo", " dtype", "bInfo", "dstate", "Daction", "lInfo", "dnINFO", "linfo", "dnInfo", "daction", " dInfo", "dlinfo", "dlaction", "dtype", "lindex", "dnaction", "dminfo", "DINFO"], "bs": ["ps", "fs", "bd", "ba", "ins", "bl", "bas", "rs", "sa", "bc", "ts", "ds", "ss", "BS", "gs", "fps", "ils", "iss", "bi", "ns", "bps", "ses", "gb", "ls", "bis", "bid", "pb", "BT"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n", "idx": 13969, "substitutes": {"obj": ["sync", "o", "cpp", "tmp", "jp", "nt", "op", "pkg", "cb", "att", "open", "object", "objects", "attr", "api", "inst", "rb", "self", "os", "ctx", "opt", "init", "node", "i", "ns", "lib", "p", "scope", "b", "coll", "Obj", "src", "sb", "js", "ref", "inf", "img", "ops"], "prev": ["prefix", "orig", "iter", "first", "original", "initial", "after", "op", "result", "winner", "desc", "rel", "above", "post", "wp", "counter", "root", "pper", "super", "ep", "pre", "parent", "proc", "self", "skip", "rec", "rev", "cur", "node", "vious", "pres", "info", "upper", "reverse", "p", "inc", "pred", "inter", "before", "back", "request", "Prev", "next", "var"], "s": ["storage", "fs", "sv", "o", "south", "external", "v", "private", "inner", "ds", "sys", "ss", "object", "ssl", "sq", "api", "sf", "sn", "a", "g", "self", "n", "os", "c", "h", "sg", "ns", "p", "sl", "f", "sr", "sb", "ses", "r", "S", "native", "ops", "single"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n", "idx": 13988, "substitutes": {"ioport": ["iporter", "ioorn", "imetorted", "ioporn", "imetorn", "ioorted", "ipore", "oport", "iprt", "ioore", "iported", "coport", "coporter", "imetorter", "ioorter", "opore", "ioprt", "imetort", "coported", "oporn", "ioort", "coprt", "oporter", "oported", "iopore", "imetrt", "iport", "ioporter", "ioported"], "addr": ["prefix", "aud", "enc", "address", "dr", "route", "proxy", "ord", "amd", "amp", "inet", "mode", "adr", "pos", "eth", "rt", "cmd", "cb", "align", "delay", "pad", "header", "attr", "grad", "offset", "state", "frame", "arm", "ptr", "url", "rc", "host", "config", "seq", "proc", "xp", "id", "ip", "context", "x", "rx", "pointer", "ext", "mac", "layer", "index", "device", "ack", "arr", "start", "src", "kt", "ace", "socket", "ref", "conn", "len", "ad"], "data": ["update", "body", "d", "di", "address", "fee", "action", "v", "la", "result", "size", "dat", "align", "write", "def", "ata", "new", "attr", "state", "valid", "al", "response", "config", "parent", "da", "block", "feed", "cache", "input", "i", "status", "p", "index", "Data", "arr", "DATA", "buffer", "buf", "value", "aa", "alpha", "len", "array", "wa"], "s": ["ps", "sync", "fs", "d", "us", "o", "session", "your", "rs", "south", "e", "cs", "ts", "ds", "states", "sys", "si", "ss", "an", "service", "m", "ssl", "uns", "conf", "sq", "gs", "a", "g", "es", "self", "n", "os", "is", "c", "su", "i", "ns", "p", "qs", "b", "sl", "aws", "f", "sb", "as", "ses", "js", "ls", "r", "services", "S", "sym", "t"], "val": ["exec", "v", "eval", "pos", "fe", "min", "ind", "value", "alt", "len", "ee", "part", "serv", "all", "split", "ol", "local", "db", "aval", "error", "x", "cal", "vals", "arr", "stat", "pass", "ret", "live", "update", "bl", "result", "bc", "sel", "rel", "pid", "valid", "al", "unit", "Val", "pre", "cond", "key", "dev", "status", "sl", "il", "call", "ref", "ann", "fail", "VAL", "fee", "pt", "base", "def", "slot", "doc", "el", "grad", "mem", "p", "index", "vol", "b", "err", "rl"]}}
{"project": "FFmpeg", "commit_id": "4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816", "target": 1, "func": "static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14014, "substitutes": {"s": ["hs", "session", "site", "u", "ts", "its", "states", "sys", "si", "m", "xs", "self", "n", "spec", "h", "i", "qs", "ic", "sb", "as", "js", "ics", "services", "t", "ps", "fs", "sync", "o", "your", "ins", "ys", "cs", "e", "parts", "ss", "y", "ssl", "new", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "sis", "less", "us", "cons", "sites", "l", "ds", "service", "stats", "http", "ses", "ms", "sym", "S", "ops", "d", "rs", "params", "full", "uns", "g", "es", "ks", "os", "ments", "su", "args", "p", "b", "aws", "sets", "f", "has", "w", "ls", "r", "conf"], "height": ["gap", "ty", "hub", "high", "deep", "volume", "image", "container", "rh", "direction", "length", "size", "above", "gpu", "style", "gallery", "Height", "depth", "y", "rows", "lat", "level", "shape", "padding", "gh", "api", "dim", "hold", "resolution", "view", "tight", "density", "id", "huge", "read", "input", "bottom", "h", "window", "crop", "layout", "device", "missing", "thin", "stroke", "row", "th", "w", "buffer", "rank", "alpha", "fw", "inches", "max", "driver", "img"]}}
{"project": "qemu", "commit_id": "01b05c66a3616d5a4adc39fc90962e9efaf791d1", "target": 1, "func": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)\n\n{\n\n    int ret;\n\n    const char *type;\n\n\n\n    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);\n\n    if (ret <= 0) {\n\n        return ret;\n\n    }\n\n\n\n    be32_to_cpus(&reply->magic);\n\n\n\n    switch (reply->magic) {\n\n    case NBD_SIMPLE_REPLY_MAGIC:\n\n        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        trace_nbd_receive_simple_reply(reply->simple.error,\n\n                                       nbd_err_lookup(reply->simple.error),\n\n                                       reply->handle);\n\n        if (reply->simple.error == NBD_ESHUTDOWN) {\n\n            /* This works even on mingw which lacks a native ESHUTDOWN */\n\n            error_setg(errp, \"server shutting down\");\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    case NBD_STRUCTURED_REPLY_MAGIC:\n\n        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        type = nbd_reply_type_lookup(reply->structured.type);\n\n        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,\n\n                                                 reply->structured.type, type,\n\n                                                 reply->structured.handle,\n\n                                                 reply->structured.length);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);\n\n        return -EINVAL;\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 14022, "substitutes": {"ioc": [" iocy", "iiocon", "iocon", "uoc", " ioci", "tioc", "pioc", "iooc", "uioc", "piocl", "uocl", "aioci", "ioocon", "piocy", "iooci", "tiocy", "uocon", "iocent", "ioocent", "iocl", "aiocl", "uiocl", "iioc", "ioroc", "uOC", "ioOC", "xiocl", "xioci", "tiocl", "xioc", "aioc", "iiocent", "iOC", "iocy", " iocl", "ioocl", "pioci", "iroc", "airoc", "ioci", "xiroc", "tioci", "uoci", "uocent", "uioci", "iiocl", "uiOC"], "reply": ["update", "prefix", "sync", "module", "address", "bug", "route", "send", "related", "connection", "proxy", "jp", "same", "link", "resp", "record", "repl", "ry", "command", "image", "patch", "feature", "match", "message", "join", "model", "server", "query", "write", "job", "post", "resource", "database", "answer", "service", "queue", "respond", "frame", "comment", "response", "rr", "error", "parse", "replace", "http", "bot", "notice", "info", "reference", "reason", "order", "report", "repair", "re", "flag", "template", "diff", "call", "buffer", "request", "entry", "remote", "back", "transfer", "plugin", "py", "next", "ping", "Reply"], "errp": [" erc", "inerp", " errcp", "errpy", " errfp", "acefp", "irfp", "ercp", "errorcp", "errcp", " erp", " errf", "erlp", " erping", "errlp", "asterp", "erc", "irlp", "erping", " erlp", "acec", " errpy", "irp", "erf", "erpo", "errf", "irpp", "acepo", "errfp", "acep", "asterlp", "errorf", " errping", "inerc", "errc", "errpo", "inerf", " errc", "errpp", " errpo", "erfp", " erfp", "errorp", "erpp", "errping", "inerpy", " errlp", "errorpy", "erp", "errorc", "errorfp", " erpp", "asterfp", "asterf"], "ret": ["gt", "success", "reset", "resp", "pat", "repl", "obj", "val", "rf", "det", "reg", "rb", "rev", "flag", "back", "len", "alt", "part", "en", "nt", "bf", "match", "format", "rt", "res", "pet", "db", " RET", "str", "error", "last", "arg", "id", "mt", "off", "cat", "arr", "pass", "Ret", "ft", "data", "result", "feat", "att", "fit", "valid", "pret", "al", "fun", "rc", "rets", "opt", "art", "active", "lit", "run", "order", "rep", "re", "out", "bit", "let", "ref", "code", "try", "pt", "base", "url", "mem", "bot", "ext", "RET"], "type": ["part", "address", "ty", "field", "null", "patch", "mode", "op", "match", "image", "year", "count", "format", "length", "rel", "size", "style", "copy", "val", "y", "level", "types", "loc", "group", "ype", "tag", "attr", "offset", "state", "TYPE", "comment", "error", "unit", "url", "pre", "parent", "time", "key", "class", "block", "where", "like", "lock", "method", "id", "version", "owner", "Type", "rule", "code", "weight", "info", "status", "target", "p", "col", "index", "order", "name", "port", "lang", "py", "value", "handle", "ref", "alt", "var", "ping", "kind"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    NE2000State *s = opaque;\n\n    uint8_t *p;\n\n    int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] = \n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n    \n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (!ne2000_can_receive(s))\n\n        return;\n\n    \n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n", "idx": 14023, "substitutes": {"opaque": ["copacity", "ospaque", "coac", "ospaco", "opac", "iopacity", "opaco", "coaco", "operaco", "iopace", "iopatile", "obacity", "obatile", "copatile", "copace", "operaque", "obaque", "operac", "ospac", "opacity", "iopaque", "opatile", "coaque", "copaque", "obace", "opace"], "buf": ["fp", "uf", "v", "cf", "cb", "fb", "map", "seq", "rb", "cur", "box", "window", "Buffer", "src", "msg", "bo", "aka", "tmp", "uber", "cmd", "header", "queue", "fd", "pool", "lim", "num", "block", "cache", "context", "c", "cat", "buffer", "cas", "aux", "func", "fi", "grab", "data", "bc", "bu", "ff", "result", "fab", "wb", "bin", "cap", "rc", "bh", "buff", "home", "conv", "ph", "av", "Buff", "que", "text", "dest", "code", "bd", "ha", "alloc", "br", "comb", "page", "vec", "uc", "ptr", "config", "proc", "ctx", "mem", "coord", "uv", "b", "bag", "f", "prop", "ab", "port", "gb", "loc", "img", "pb", "cv"], "size": ["large", "enc", "address", "pos", "si", "sec", "scale", "n", "sh", "i", "bytes", "sum", "en", "li", "e", "timeout", "offset", "time", "num", "cache", "now", "c", "max", "storage", "Size", "data", "empty", "count", "speed", "end", "shape", "unit", "six", "name", "code", "zero", "fee", "length", "export", "small", "g", "z", "sized", "capacity", "mini", "weight", "args", "core", "SIZE", "loc", "ize"], "s": ["hs", "session", "site", "u", "ts", "its", "states", "sys", "si", "se", "m", "sec", "self", "n", "spec", "i", "qs", "sb", "js", "services", "t", "ps", "sync", "serv", "fs", "o", "your", "e", "cs", "ions", "ss", "y", "ssl", "new", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "sie", "settings", "socket", "bis", "us", "l", "ds", "service", "state", "this", "stats", "http", "sl", "ses", "sym", "S", "d", "south", "private", "secondary", "server", "g", "es", "ks", "os", "su", "b", "aws", "sets", "f", "w", "ls", "r", "conf"], "p": ["ps", "fp", "d", "o", "tp", "jp", "po", "e", "op", "pos", "pc", "P", "pad", "m", "sp", "a", "pre", "g", "z", "proc", "n", "np", "bp", "c", "i", "pointer", "cp", "q", "h", "b", "press", "f", "w", "port", "r", "j", "t", "span", "ping"], "total_len": ["total_rev", " total_rev", "total_mem", "sum_fin", "total_Len", "Total_mem", "Total_lon", "Total_Len", "sum_pos", "total_pos", " total_pos", "Total_len", "sum_en", "sum_len", "total_lon", " total_Len", "total_fin", "total_en"], "next": ["done", "prefix", "adj", "step", "first", "big", "front", "data", "link", "li", "count", "pos", "result", "end", "head", "length", "open", "bis", "later", "doc", "new", "zip", "state", "offset", "this", "prev", "reply", "frame", "response", "seq", "error", "valid", "sec", "bridge", "last", "skip", "latest", "eni", "second", "now", "current", "priority", "max", "pointer", "close", "start", "future", "min", "j", "forward", "conn", "Next", "sequence", "code"], "avail": ["averail", "avari", "abari", "averal", "ovil", "ovail", "averil", "abil", "oval", "aval", "ovari", "abal", "abail", "averari", "avil"], "len": ["en", "iter", "fin", "data", "li", "count", "pos", "l", "length", "val", "el", "offset", "slice", "seq", "n", "low", "ln", "mem", "weight", "line", "min", "ind", "tail", "loc"], "index": ["update", "iter", "address", "append", "ini", "shift", "position", "action", "initial", "Index", "count", "loop", "pos", "match", "end", "length", "open", "online", "page", "si", "val", "path", "new", "offset", "slice", "error", "num", "key", "block", "skip", "id", "version", "current", "x", "weight", "i", "inc", "start", "xxxx", "ind", "value", "alpha", "loc", "forward"], "mcast_idx": ["mcast_Idv", "mcast_midxs", "mcast_Idx", "mcast_sidn", "mcast__idxe", "mcast_ridct", "mcast__idct", "mcast_argc", "mcast2idec", "mcast_idz", "mcast_idb", "mcast_namex", "mcast__ridxe", "mcast_idsz", "mcast_idxe", "mcast_idv", "mcast2idb", "mcast__idz", "mcast_idex", "mcast_idsxe", "mcast_sidz", "mcast_argle", "mcast_idsct", "mcast_midy", "mcast2ideb", "mcast_sidv", "mcast_midct", "mcast_midx", "mcast_namec", "mcast_Idn", "mcast2idc", "mcast_idec", "mcast_sidx", "mcast_ridv", "mcast_idy", "mcast_idc", "mcast_idele", "mcast2idex", "mcast_ridxe", "mcast__ridx", "mcast_idle", "mcast__idx", "mcast_pidxs", "mcast2idx", "mcast_pidy", "mcast_idn", "mcast_Idz", "mcast_idxs", "mcast__ridct", "mcast2idle", "mcast_pidx", "mcast_ridxs", "mcast_ridn", "mcast_argx", "mcast_idct", "mcast_ridz", "mcast_pidct", "mcast_argb", "mcast_ideb", "mcast2idele", "mcast_ridy", "mcast__ridz", "mcast_namele", "mcast_idsx", "mcast_nameb", "mcast_ridx"], "buf1": ["queueone", "queue1", "uf0", "bufferone", "buf2", "uf2", "buffer2", "ufone", "buff1", "buff0", "buf0", "buff2", "bufone", "buffer1", "buffer0", "buffone", "queue0", "uf1", "queue2"], "broadcast_macaddr": ["broadcast2macaddr", "broadcast_acaddr", "broadcast_micaddr", "broadcast2acaddr", "broadcast_acptr", "broadcast_compaddr", "broadcast_micr", "broadcast_Macptr", "broadcast_acaddress", "broadcast2acaddress", "broadcast_micaddress", "broadcast_compaddress", "broadcast2macaddress", "broadcast_macr", "broadcast_macdr", "broadcast_macaddress", "broadcast_acdr", "broadcast_macptr", "broadcast_Macr", "broadcast_micdr", "broadcast2acptr", "broadcast2macdr", "broadcast_Macdr", "broadcast_compr", "broadcast_Macaddress", "broadcast2macptr", "broadcast_micptr", "broadcast2acdr", "broadcast_Macaddr", "broadcast_compptr"]}}
{"project": "FFmpeg", "commit_id": "f264d336fe61c12ce9607c3060aa5d3dca947c61", "target": 1, "func": "static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n\n{\n\n    int16_t tmp[146 + 60], *ptr0, *ptr1;\n\n    const int16_t *filter;\n\n    int i, t, off;\n\n\n\n    t = dec->offset2[quart];\n\n    if(t == 127){\n\n        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));\n\n        return;\n\n    }\n\n    for(i = 0; i < 146; i++)\n\n        tmp[i] = dec->filtbuf[i];\n\n    off = (t / 25) + dec->offset1[quart >> 1] + 18;\n\n\n    ptr0 = tmp + 145 - off;\n\n    ptr1 = tmp + 146;\n\n    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;\n\n    for(i = 0; i < 60; i++){\n\n        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;\n\n        ptr0++;\n\n        dec->newvec[i] = t;\n\n        ptr1[i] = t;\n\n    }\n\n}", "idx": 14024, "substitutes": {"quart": [" Quart", "part", "ct", "period", "gap", "ft", "mint", "temp", "qu", "letter", "amp", "pot", "nt", "pt", "minute", "cit", "bass", "qt", "upt", "qa", "fat", "pet", "quant", "quad", "sq", "pound", "cot", "ant", "jet", "boot", "piece", "iot", "art", "cup", "component", "cat", "quick", "quarter", " quint", "question", "tube", "rot"], "tmp": ["fp", "mp", "tp", "front", "temp", "seed", "data", "tw", "amp", "txt", "nt", "obj", "cb", "output", "base", "params", "fb", "wb", "MP", "page", "pad", "db", "cmp", "dc", "bt", "offset", "meta", "tf", "proc", "rb", "sup", "tt", "np", "boot", "appy", "buff", "cache", "fake", "now", "pointer", "cp", "p", "bb", "kk", "arr", "src", "sb", "buffer", "buf", "vv", "img", "dest", "pb", "code"], "ptr0": ["Ptr2", "ptr6", "pointer1", "pt2", "ptr2", "pointer00", "tr2", "Ptr6", "p0", "pt0", "pt19", "pt6", "tip19", "tip0", "tr00", "pointer0", "pointer2", "ptr19", "tip1", "Ptr00", "pointer6", "ptr00", "Ptr8", "pt1", "ptr8", "pt8", "pointer19", "tr1", "tip2", "Ptr1", "pointer8", "tr0", "p2", "p1", "Ptr0"], "ptr1": ["Ptr2", "pointer1", "ptrone", "ptr2", "tr2", "offsetone", "pointersone", "pointers2", "Ptr0", "offset1", "offset2", "dr1", "Ptrone", "pointer0", "pointer2", "dr2", "pointers1", "pointers0", "offset0", "trone", "tr1", "Ptr1", "tr0", "dr0", "pointerone"], "filter": ["fp", "part", "ft", "test", "shift", "attribute", "amp", "v", "search", "count", "force", "match", "fl", "mask", "format", "Filter", "page", "transform", "fat", "sort", "limit", "offset", "tf", "ilt", "url", "config", "g", "block", "ac", "flat", "opt", "version", "stop", "q", "control", "ext", "fil", "p", "type", "il", "f", "th", "w", "select", "buffer", "call", "term", "tail", "ref", "alt", "number", "support", "cover"], "i": ["it", "d", "ie", "o", "di", "gi", "ini", "iu", "mi", "fi", "v", "multi", "li", "e", "u", "xi", "mu", "l", "pi", "uri", "phi", "si", "in", "y", "ai", "ui", "m", "slice", "ti", "g", "k", "ix", "z", "n", "eni", "ci", "id", "io", "mini", "qi", "ip", "x", "c", "q", "oi", "info", "s", "p", "index", "b", "ni", "f", "start", "ind", "w", "j", "ii", "at", "I"], "t": ["it", "part", "d", "ct", "o", "test", "T", "dt", "tp", "temp", "v", "nt", "tool", "e", "u", "pt", "st", "ut", "ts", "l", "unt", "qt", "token", "y", "m", "offset", "ta", "tm", "tf", "tip", "ti", "a", "g", "z", "ant", "n", "tt", "to", "ot", "c", "x", "art", "bot", "wt", "p", "type", "b", "f", "tz", "w", "j", "at"], "off": ["orig", "o", "Off", "own", "af", "shift", "flow", "front", "down", "amp", "after", "pos", "pt", "ff", "end", "length", "alt", "new", "offset", "oat", "block", "opt", "foo", "dev", "ip", "now", "no", "art", "at", "set", "ext", "type", "on", "order", "offs", "old", "out", "start", "load", "w", "diff", "non", "j", "OFF", "ref", "len"]}}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 14025, "substitutes": {"s": ["ps", "sync", "fs", "d", "session", "rs", "v", "e", "cs", "ts", "ds", "states", "sys", "si", "ss", "y", "ssl", "se", "m", "conf", "service", "state", "sq", "gs", "sf", "a", "es", "self", "n", "spec", "c", "h", "su", "sg", "ns", "p", "b", "aws", "f", "sb", "ses", "w", "js", "j", "services", "S", "sym", "t"], "r": ["ru", "d", "dr", "rs", "ar", "R", "requ", "ur", "br", "rd", "e", "result", "rh", "rt", "l", "kr", "res", "rf", "lr", "nr", "rr", "str", "rc", "usr", "pr", "g", "tr", "rb", "fr", "hr", "c", "q", "rx", "p", "req", "b", "mr", "arr", "sr", "f", "re", "ir", "cr", "err", "er", "request", "rg", "j", "gr"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n", "idx": 14031, "substitutes": {"vlan": ["vlas", "Vara", "vda", "jda", "virtuallan", "virtualnic", "llan", "qda", "jnic", "vla", "vnic", "jla", "qla", " vara", "Vlan", "lnic", " vlas", "Vnic", "qnic", "virtualara", "vara", "qlan", "lla", "lda", "Vlas", "jlan", " vnic", "virtuallas"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){\n\n    char buf1[32], tuple_type[32];\n\n    int h, w, depth, maxval;;\n\n\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    if (!strcmp(buf1, \"P4\")) {\n\n        avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n    } else if (!strcmp(buf1, \"P5\")) {\n\n        if (avctx->codec_id == CODEC_ID_PGMYUV) \n\n            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        else\n\n            avctx->pix_fmt = PIX_FMT_GRAY8;\n\n    } else if (!strcmp(buf1, \"P6\")) {\n\n        avctx->pix_fmt = PIX_FMT_RGB24;\n\n    } else if (!strcmp(buf1, \"P7\")) {\n\n        w = -1;\n\n        h = -1;\n\n        maxval = -1;\n\n        depth = -1;\n\n        tuple_type[0] = '\\0';\n\n        for(;;) {\n\n            pnm_get(s, buf1, sizeof(buf1));\n\n            if (!strcmp(buf1, \"WIDTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                w = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"HEIGHT\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                h = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"DEPTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                depth = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"MAXVAL\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                maxval = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"TUPLETYPE\")) {\n\n                pnm_get(s, tuple_type, sizeof(tuple_type));\n\n            } else if (!strcmp(buf1, \"ENDHDR\")) {\n\n                break;\n\n            } else {\n\n                return -1;\n\n            }\n\n        }\n\n        /* check that all tags are present */\n\n        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0')\n\n            return -1;\n\n        avctx->width = w;\n\n        avctx->height = h;\n\n        if (depth == 1) {\n\n            if (maxval == 1)\n\n                avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n            else \n\n                avctx->pix_fmt = PIX_FMT_GRAY8;\n\n        } else if (depth == 3) {\n\n            avctx->pix_fmt = PIX_FMT_RGB24;\n\n        } else if (depth == 4) {\n\n            avctx->pix_fmt = PIX_FMT_RGBA32;\n\n        } else {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->width = atoi(buf1);\n\n    if (avctx->width <= 0)\n\n        return -1;\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->height = atoi(buf1);\n\n    if (avctx->height <= 0)\n\n        return -1;\n\n    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {\n\n        pnm_get(s, buf1, sizeof(buf1));\n\n    }\n\n\n\n    /* more check if YUV420 */\n\n    if (avctx->pix_fmt == PIX_FMT_YUV420P) {\n\n        if ((avctx->width & 1) != 0)\n\n            return -1;\n\n        h = (avctx->height * 2);\n\n        if ((h % 3) != 0)\n\n            return -1;\n\n        h /= 3;\n\n        avctx->height = h;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14056, "substitutes": {"avctx": ["avalctx", "avcmp", "afcontext", "AVcontext", "Avcontext", "avcca", " avcontext", "AVlc", "avalcontext", "afcdn", "Avctx", "afctrl", "AVcmp", "aucdn", "auctx", " avpkg", "afpkg", "appctx", "navctx", "appcu", " avconn", "Avconf", "cvctx", "appcca", "navpkg", "avpkg", "verctx", "appcontext", "avcu", "afconn", "navconn", "cvcmp", "aucontext", "navcca", "avalconf", "cvlc", " avxc", "AVxc", "afcmp", "afctx", "AVctx", "avlc", "avctrl", "afcca", "Avctrl", "afconf", "afcu", "auconn", "verconn", "vercontext", "aflc", "avcdn", "vercdn", "avconf", "avalctrl", "avxc", "navcontext", "avconn", "afxc", " avcmp", "cvcontext", "navcu", "avcontext"], "s": ["comments", "fs", "sync", "d", "serv", "o", "session", "native", "site", "rs", "south", "t", "sc", "e", "cs", "params", "ds", "scl", "bis", "sys", "server", "ions", "path", "ss", "in", "ssl", "service", "m", "sq", "gs", "sf", "a", "g", "es", "self", "sup", "n", "details", "spec", "stats", "is", "current", "c", "http", "args", "sg", "i", "ns", "p", "scope", "secure", "b", "info", "sets", "support", "f", "sb", "js", "ses", "gb", "settings", "stat", "r", "sym", "services", "conf", "cms", "ops"], "buf1": ["bu9", "bagone", "cmdONE", "bufpre", "vecone", "buff61", "ufull", "bufull", "buf91", "BuffOnce", "nob2", "bu0", " buffer2", "bgone", "bg1", "ufpre", "buf9", "buff51", "cmd0", "buffer2", "bufn", "ufOne", "cmd64", "buffer81", "buff1", "buff0", "buf0", "buL", "buff2", "ufback", "buffOne", "bag2", "buffL", "raf2", "bufONE", "buf31", "buffONE", "uf51", "buffn", "bc1", "buffpre", "raf1", "buff91", "BuffOne", "nob31", "raf0", " bufone", "cmd2", "buf64", "uber1", "ufnum", "uf0", "bcONE", "cfone", "buf2", "rafOne", "Buff0", "bgull", "uber0", " buf2", "buf01", "buf100", "bufback", "buffer1", "vec61", "vecn", " buf0", "uber9", "uf61", "bag81", "buf81", "uf64", "rub1", "cmdpre", "rub100", "cvback", "bufOnce", "uf01", "cvn", "uf100", "vec0", "bufferull", "bag1", "bu1", "buf61", "bu91", "bufferone", "bu51", "cmdone", "buff64", "ufOnce", "bus", "vec2", "vec100", "Buff1", "uber91", "ufone", "ufL", "vec1", "bufs", "buffs", "bu2", "ufn", "cmd1", "bc2", "bufone", "cf1", "cv1", "buffone", "vecpre", "vec01", "bufnum", " buffernum", " buffer1", "cfOne", "bufOne", " bufnum", "vecback", "bufL", "nob1", " bufOnce", "buf51", "uf2", "uf91", "bu31", "cvone", "uf31", " buf81", "ufs", "buff01", "uf9", "bg2", "cf2", "cv2", " bufOne", "rub2", "ufONE", "uf1"], "tuple_type": ["tple_unit", "tuple2type", "tuple_t", "tune2length", "tune_length", "tple_type", "tune2type", "tune_type", "tuple_size", "tple_block", "all", "image", "format", "_", "c", "tuple_block", "tune2size", "end", "tple_t", "tuple2size", "tuple_length", "tune_size", "text", "tuple2length", "d", "tuple_key", "tple_key", "tuple_unit", "g", "r"], "h": ["hs", "en", "d", " H", "o", "height", "v", "count", "u", "rh", "l", "length", "ht", "ih", "y", "m", "hh", "padding", "gh", "hw", "hl", "g", "bh", "z", "n", "hr", "sh", "x", "H", "c", "q", "i", "p", "hi", "ph", "b", "sl", "f", "th", "t"], "w": ["how", "d", "wh", "height", "v", "u", "l", "wd", "work", "y", "ow", "m", "W", "wave", "wl", " W", "g", "wx", "z", "n", "win", "sh", "x", "max", "weight", "q", "c", "p", "wt", "we", "window", "sw", "kw", "f", "row", "r", "fw", "t", "wa"], "depth": ["quality", "debug", "d", "height", "dr", "der", "deep", "dist", "count", "fl", "rh", "length", "style", "path", "level", "y", "root", "m", "padding", "time", "dim", "sn", "scale", "parent", "pr", "z", "progress", "n", "id", "cache", "dev", "phi", "x", "q", "max", "weight", "push", "layer", "p", "Depth", "reverse", "color", "order", "sl", "th", "dq", "lang", "r", "len", "stack"], "maxval": ["maxvalue", "Maxvals", "MAXVAL", "axVal", "maxvals", "Maxval", "minvals", "minvalue", "MAXval", "MaxVAL", "maxVal", "axval", "maxVAL", "MAXVal", "Maxvalue", "MaxVal", "MAXvals", " maxVal", "axvalue", "axvals", " maxvalue", "minVal", "minval", " maxVAL", " maxvals"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n", "idx": 14076, "substitutes": {"addr": ["address", "alloc", "func", "ar", "data", "pos", "pkg", "eth", "cb", "base", "align", "pad", " address", "attr", "offset", "nr", "ptr", "host", "config", "proc", "eni", "ctx", "node", "ip", "mac", "pointer", "Address", "target", "p", "device", "src", "kt", "port", "inter", "ace", "loc", "ref", "conn", "ad"], "buf": ["fp", "bd", "batch", "alloc", "fi", "data", "uf", "cmd", "length", "fb", "base", "cb", "cap", "queue", "fd", "lb", "pool", "seq", "ptr", "lim", "byte", "bh", "ctx", "mem", "buff", "bytes", "b", "src", "ab", "buffer", "loc", "ref", "pb", "cv"], "len": ["enc", "en", "part", "lan", " length", "bl", "data", "la", "li", "count", "Len", "pos", "fl", "l", "length", "base", "size", "val", "bin", "alt", "lon", "cap", "el", "limit", "offset", "lin", "seq", "lim", "ln", "mem", "line", "lit", "lf", "lang", "loc", "ref", "ann"], "is_write": ["is_read", " is_written", " is_read", "is_writer", "is_written", " is_writer"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 14090, "substitutes": {"opaque": ["opsaque", "apacity", "opac", "opaques", "opaqu", "oaques", "copac", "copaques", "operaques", "opque", "oque", "operaque", "opsaqu", "apaque", "OPac", "OPque", "operaqu", "oac", "opacity", "oaque", "apaqu", "opsacity", "copaque", "copque", "operacity", "opsaques", "OPaques", "apaques", "OPaque"], "pdu": ["psdu", "ppdu", "ppud", "opuu", "pssu", "fuu", "hdu", "bdu", "btu", " pud", "cuts", "Pdu", "opcu", "fdu", "psu", " pcu", "hcu", " puu", "cpde", "pdf", "lpdf", " psu", "opci", "peruu", "htu", "ptu", " ptu", "bcu", "cpdu", "fcu", "opdu", "pde", "cpci", " pru", "Pcu", "fud", "persu", "Pdf", "pcu", "ppsu", " pda", "vpdu", "huu", "lpde", "pscu", "percu", "fsu", "perdu", "vpuu", "puu", "lpcu", "cpcu", "pru", "opda", "optu", "pda", "ppru", "opsu", "csu", "Pci", "ccu", "cptu", "Pud", "ppuu", "perci", "lpdu", "pud", "cpuu", "vpud", "fda", "pptu", "Ptu", "buu", " pci", "perru", "psuts", "cdu", "ftu", "Pde", "pci", "vptu", "cpdf"], "s": ["storage", "sync", "d", "save", "o", "session", "south", "private", "secondary", "e", "u", "ts", "server", "states", "sys", "si", "ss", "ssl", "conf", "m", "state", "gs", "g", "location", "n", "os", "spec", "stats", "side", "c", "http", "h", "slave", "description", "ns", "status", "p", "scope", "b", "instance", "sets", "f", "sb", "w", "ses", "settings", "r", "services", "setup", "S", "sym", "t", "ops"], "dfid": ["DFiden", "tfide", "ufID", "dfident", "dfend", "fpaid", "xfid", " dfaid", "dfID", "fpID", "fdkid", "dfq", "xfkid", "DFID", " dfident", " dfmid", "dfide", "lfend", "lfid", "fdid", "sfID", "dfaid", "dfmid", "lfide", "lfID", "sfids", "tfID", "fpid", "ufq", "fpq", " dfq", "ufiden", "fdident", " dfID", " dfide", "DFids", " dfkid", "DFid", "fdmid", "ufids", "xfmid", "xfident", "dfkid", "tfid", " dfend", "ufaid", "sfiden", "dfiden", "sfid", "dfids", "ufid", "tfend"], "oldfid": ["oldcfip", "newcid", "oldfit", "oldfkid", "newcids", "oldfaid", "olderfaid", "longfId", "olddfip", " oldlaid", "oldfacid", "olderdfid", "oldlaid", "olderdfids", "oldFit", "newckid", "oldcfids", "olderfid", "oldcip", "olddfId", "newcrid", " oldfaid", "olderfids", "oldtfid", "olddfit", " oldfip", "longfaid", "oldfacrid", "longtfip", "longtfid", "oldfsip", "oldcfaid", "oldfId", "olddfid", "oldcaid", "olderdfit", "olddfaid", "oldtfId", "longtfId", "oldcid", "oldFids", "oldlid", " oldfids", "longfid", "oldfsid", "newfrid", "oldFid", "newfid", "longtfaid", "oldfsId", "oldlids", "oldFaid", "oldfsaid", "oldfip", "oldcids", " oldlip", "oldfackid", " oldlid", "oldcfid", "oldcit", "oldfrid", "olderdfaid", "newfkid", "oldlip", "olddfids", "olderfit", "oldfacids", "oldtfip", "oldfids", "newfids", "olddfkid", " oldlids", "oldckid", "longfip", "oldcrid", "olddfrid", "oldtfaid"], "dfidp": ["dfIdP", "dfIdc", "dfkeyper", "dfstrpr", " dfbitpoint", "fIdi", "dfIdpi", "dfbitp", "dfodpc", "fdidp", "dfIDp", "dfiddlp", "cmdidlp", "dfidpi", " dfidm", "fdidpi", "dfIdi", "cmdiddp", "dfidper", "dfodP", "fdidpr", "fdmidpr", "dfmidp", "cmdidp", "dfmidpr", "dfstrc", " dfidpoint", "dfdp", "dfmidpc", "fdmidc", "dfdm", "dfidi", "dfidpoint", "dfidentper", "dfkeylp", "dfitm", "fIdP", "dfitp", "cmdiddpc", "dfidpc", "fIdr", "fdidpc", "dfIdr", " dfbitm", "fIdp", "dfidP", "dfidentp", "dfidentpc", "fdmidpc", " dfidc", "dfmidc", "dfmidP", "fdmidP", "dfkeypc", "fdmidpi", "fdidP", "cmdidper", "dfbitpoint", "dfidlp", "cmdiddper", "fidP", "dfstrpi", "cmdiddlp", "fdmidp", "dfIdpc", "dfstrp", "dfiddper", "fidi", "dfidm", " dfbitp", "dfIDr", "dfodpr", "dfdpoint", "dfmidpi", "dfkeyp", "dfIdpr", "dfidpr", "fidr", "fidp", "dfitc", "dfidc", "dfbitc", "dfbitm", "dfIDi", "dfiddp", "fdidc", "dfidr", "cmdidpc", "dfdc", " dfbitc", "dfiddpc", "dfitpoint", "dfidentlp", "dfIDP", "dfodp", "dfIdp"], "oldfidp": ["oldfbiti", "oldfIdu", "oldfsidsp", "oldfidsb", "oldfaidr", "oldfarkpi", "oldfoidpe", "oldfidsr", "oldfoidb", "oldfIdp", "oldfIdl", "oldfaidl", "oldfidsg", "oldfidsl", "oldtfidp", "oldfbitv", "oldfaidg", "oldfidc", "oldfidsc", "oldfoidc", "oldfbitp", "oldfadv", "oldfiddpe", "oldfidv", "oldfsidsg", "oldtfidi", "oldfarku", "oldfidpi", "oldfitedl", "oldfIdpi", "oldfidu", "oldfiddp", "oldfadp", "oldfidpe", "oldfitedp", "oldtfiddi", "oldfidl", "oldfidi", "oldfiddb", "oldfiddr", "oldfiddm", "oldfiddc", "oldfoidp", "oldtfidm", "oldtfidv", "oldfarkl", "oldfidb", "oldfiddv", "oldfidsp", "oldfadi", "oldtfiddm", "oldfadm", "oldfiddl", "oldfsidl", "oldfsidsr", "oldfsidg", "oldfitedu", "oldfbitm", "oldfidm", "oldfarkp", "oldfitedpi", "oldtfiddp", "oldfiddg", "oldfaidp", "oldfiddi", "oldfsidr", "oldfsidp", "oldfidg", "oldfidspe", "oldfsidsl", "oldtfiddv", "oldfidr"], "name": ["prefix", "part", " prefix", "connection", "data", "named", "nam", "obj", "desc", "base", "size", " Name", "resource", "path", "in", "anc", "object", "alias", "new", "attr", "Name", "label", "comment", "str", "error", "time", "parent", "self", "word", "block", "ame", "key", "n", "def", "id", "NAME", "mem", "version", "x", "no", "memory", "info", "ext", "missing", "type", "member", "f", "out", "child", "w", "call", "buffer", "names", "filename", "none"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "int dxva2_init(AVCodecContext *s)\n\n{\n\n    InputStream *ist = s->opaque;\n\n    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    DXVA2Context *ctx;\n\n    int ret;\n\n\n\n    if (!ist->hwaccel_ctx) {\n\n        ret = dxva2_alloc(s);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    ctx = ist->hwaccel_ctx;\n\n\n\n    if (s->codec_id == AV_CODEC_ID_H264 &&\n\n        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {\n\n        av_log(NULL, loglevel, \"Unsupported H.264 profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->codec_id == AV_CODEC_ID_HEVC &&\n\n        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {\n\n        av_log(NULL, loglevel, \"Unsupported HEVC profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    av_buffer_unref(&ctx->hw_frames_ctx);\n\n\n\n    ret = dxva2_create_decoder(s);\n\n    if (ret < 0) {\n\n        av_log(NULL, loglevel, \"Error creating the DXVA2 decoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14108, "substitutes": {"s": ["session", "site", "sc", "ts", "its", "sys", "si", "an", "se", "plugins", "xs", "self", "spec", "i", "qs", "sb", "as", "des", "js", "services", "t", "sync", "fs", "your", "ins", "e", "cs", "ions", "ss", "ssl", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "sis", "settings", "bis", "less", "storage", "us", "sa", "l", "ds", "service", "this", "http", "sl", "ses", "ms", "sym", "S", "comments", "d", "sv", "sci", "features", "params", "g", "es", "ks", "os", "ess", "su", "args", "p", "b", "aws", "sets", "f", "w", "ls", "r", "conf", "support", "css"], "ist": ["et", "ati", "dr", "alist", "ista", "iste", "nt", "dist", "st", "pt", "ism", "ld", "sa", "feat", "ird", "wd", "ht", "ift", "att", "isi", "pect", "asp", "irc", "IST", "inst", "osi", "ict", "ant", "tt", "est", "iss", "dit", "ess", "sd", "ists", "art", "ast", "ont", "isu", "isc", "kt", "ind", "ais", "ost", "ace", "xt", "irst", "ad", "asi"], "ctx": ["sync", "ct", "ctr", "cn", "cu", "fi", "exec", "cm", "cs", "bc", "pkg", "sci", "obj", "cf", "pc", "cb", "cmd", "anc", "ec", "cc", "cmp", "sq", "hw", "rc", "lc", "config", "ck", "cv", "vc", "ci", "acs", "context", "c", "cp", "cy", "kw", "ctrl", "tx", "mc", "ca", "wcs", "xc", "loc", "conn", "cas", "css"], "ret": ["gt", "success", "resp", "pat", "repl", "obj", "val", "rf", "det", "reg", "rb", "rev", "lib", "req", "sr", "flag", "disabled", "back", "len", "alt", "fin", "nt", "bf", "rt", "res", "pet", "str", "error", "arg", "id", "cat", "pass", "Ret", "ft", "data", "result", "feat", "fab", "att", "pret", "fun", "rc", "usr", "rets", "art", "active", "lit", "run", "rep", "re", "py", "bit", "let", "ref", "code", "fail", "desc", "base", "def", "reply", "url", "mem", "no", "info", "ext", "f", "RET", "err"]}}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,\n\n                                         XenPTRegInfo *reg)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    XenPTRegion *region = NULL;\n\n    PCIIORegion *r;\n\n    int index = 0;\n\n\n\n    /* check 64bit BAR */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if ((0 < index) && (index < PCI_ROM_SLOT)) {\n\n        int type = s->real_device.io_regions[index - 1].type;\n\n\n\n        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)\n\n            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {\n\n            region = &s->bases[index - 1];\n\n            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {\n\n                return XEN_PT_BAR_FLAG_UPPER;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check unused BAR */\n\n    r = &d->io_regions[index];\n\n    if (!xen_pt_get_bar_size(r)) {\n\n        return XEN_PT_BAR_FLAG_UNUSED;\n\n    }\n\n\n\n    /* for ExpROM BAR */\n\n    if (index == PCI_ROM_SLOT) {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n\n\n    /* check BAR I/O indicator */\n\n    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {\n\n        return XEN_PT_BAR_FLAG_IO;\n\n    } else {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n}\n", "idx": 14126, "substitutes": {"s": ["sync", "fs", "sv", "o", "session", "rs", "data", "sim", "v", "south", "sc", "cs", "sa", "ts", "server", "ds", "states", "sys", "si", "ss", "ssl", "se", "m", "service", "sed", "sq", "state", "gs", "sf", "this", "a", "g", "es", "ks", "self", "n", "os", "spec", "sd", "dev", "side", "c", "su", "args", "ns", "p", "status", "device", "b", "sl", "f", "sb", "ses", "w", "js", "settings", "stat", "services", "S", "t", "devices"], "reg": ["acc", "record", "param", "REG", "cmd", "conn", "ro", "eng", "eg", "res", "db", "ann", "tag", "mod", "sec", "rc", "config", "rec", "arg", "rad", "spec", "mem", "ray", "scan", "Reg", "arr", "ram", "re", "red", "ab", "stat", "rg", "loc", "gr", "ref", "arm", "rem", "arb"], "d": ["di", "dt", "dr", "driver", "md", "dist", "dir", "cd", "dat", "ds", "def", "db", "dc", "m", "grad", "dn", "dim", "de", "dh", "sd", "dev", "c", "p", "device", "dd", "f", "dm", "ind", "w", "D", "dy", "gd", "t", "da", "ad"], "region": ["module", "gap", "native", "route", "connection", "ion", "texture", "record", "dist", "feature", "REG", "area", "resource", "account", "contract", "tag", "vision", "state", "slice", "dim", "rc", "config", "role", "location", "g", "progress", "country", "memory", "Region", "description", "zone", "p", "range", "component", "scope", "instance", "re", "division", "parser", "option", "section", "remote", "rg", "loc", "dimension", "radius", "array"], "r": ["ru", "o", "rw", "dr", "rus", "rs", "ar", "R", "v", "br", "rd", "adr", "e", "result", "rh", "u", "rt", "pair", "resource", "res", "rf", "m", "attr", "lr", "nr", "rr", "str", "rc", "role", "pr", "g", "rb", "rec", "fr", "n", "c", "h", "range", "p", "ri", "b", "sr", "re", "cr", "rl", "er", "err", "rn", "rg", "j", "radius", "arb"]}}
{"project": "FFmpeg", "commit_id": "50c466d609ec60a324a7a776dfdb57c8d38faa11", "target": 1, "func": "static av_cold int g726_encode_init(AVCodecContext *avctx)\n\n{\n\n    G726Context* c = avctx->priv_data;\n\n\n\n    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&\n\n        avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Sample rates other than 8kHz are not \"\n\n               \"allowed when the compliance level is higher than unofficial. \"\n\n               \"Resample or reduce the compliance level.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (avctx->sample_rate <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Samplerate is invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (avctx->bit_rate % avctx->sample_rate) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitrate - Samplerate combination is invalid\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;\n\n    if (c->code_size < 2 || c->code_size > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of bits %d\\n\", c->code_size);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    avctx->bits_per_coded_sample = c->code_size;\n\n\n\n    g726_reset(c, c->code_size - 2);\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    /* select a frame size that will end on a byte boundary and have a size of\n\n       approximately 1024 bytes */\n\n    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];\n\n\n\n    return 0;\n\n}\n", "idx": 14141, "substitutes": {"avctx": ["avelc", "ajsci", "ajcf", "avcp", "afsci", "afconfig", "aveconfig", "vercca", " avcm", "afctrl", "auctx", "afloc", "avsci", " avcu", "avcf", "verloc", "afcoll", "avercca", "verctx", "aucontext", "afscope", "afctx", "avlc", "avctrl", "avercontext", "aupkg", "aklc", "ajcmp", "avscope", "AVconn", "afcli", "ajctx", "auctr", "afcontext", "vercf", "avcli", "akctx", "AVlc", "avectrl", " avscope", "akcontext", "AVcmp", "afcit", " avpkg", "afpkg", "averconn", "avectx", "avpkg", "ajloc", "AVctx", "AVcu", "avctr", "ajcp", "avecmp", "aflc", "ajcontext", " avcli", "afctr", "avecf", " avcontext", "avcm", "avecoll", "vercp", "aveloc", "afcf", "avecm", "ajcli", "ajcit", " avconfig", "avcu", "afconn", "verlc", "afcmp", "avescope", "afcu", "verconn", "avconn", "AVcoll", "avcit", "avcmp", "averctx", "AVcontext", "vercli", "avcca", "vercit", "avconfig", "avecit", "aveconn", "avecu", "avcoll", "avecli", "avloc", " avconn", " avctr", " avsci", "afcca", "avercit", "averctrl", "vercontext", "akcf", "afcm", "afcp", "avecontext", "avcontext"], "c": ["enc", "ct", "d", "cu", "oc", "exec", "t", "v", "cm", "tc", "sc", "cs", "e", "nc", "C", "u", "con", "cf", "pc", "l", "gc", "anc", "ec", "cc", "cmp", "dc", "m", "uc", "sec", "a", "lc", "config", "g", "k", "ac", "n", "vc", "ch", "ce", "ctx", "ci", "cur", "fc", "cache", "context", "h", "i", "cp", "s", "p", "cl", "col", "b", "cy", "coll", "arc", "ctrl", "co", "f", "unc", "cr", "ic", "mc", "ca", "w", "xc", "conn", "code"]}}
{"project": "FFmpeg", "commit_id": "8332321c5737cf24ebad504bf10a03818424718d", "target": 1, "func": "static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n", "idx": 14144, "substitutes": {"s": ["ps", "storage", "sync", "fs", "d", "us", "sv", "rs", "sc", "e", "cs", "sa", "u", "ts", "server", "ds", "sys", "si", "ss", "ssl", "se", "service", "sq", "gs", "sf", "sec", "xs", "es", "ks", "self", "n", "os", "spec", "is", "context", "su", "sg", "p", "ns", "qs", "b", "sets", "f", "src", "sb", "sr", "ses", "settings", "services", "ls", "S"], "stream_index": ["Stream_index", "Stream_ind", "stream_ind", "Stream_alias", "stream_alias", "streamnameconnection", "streamnameindex", "streamnameind", "stream_connection", "Stream_connection", "streamnamealias"], "timestamp": ["longed", "nametz", "typestamp", "Timency", "Timetz", "namestamp", "timeline", "parameline", "paramency", "parametz", "namency", "paramestamp", "timetime", "Timed", "timed", "timetz", "longetime", "typetime", "longestamp", "Timeline", "Timestamp", "nameline", "Timetime", "typed", "timency"], "flags": ["FLAG", "fs", "seconds", "ints", "files", "options", "fee", "Flags", "data", "mask", "reads", "ts", "features", "errors", "fd", "sf", "faces", "windows", "linux", "fps", "ips", "properties", "bits", "stats", "args", "forces", "bytes", "vals", "frames", "offs", "lf", "flag", "orts", "settings", "fields", "lag", "ops"], "r": ["d", "ru", "dr", "rs", "ar", "R", "rar", "e", "u", "rh", "rt", "kr", "res", "rf", "m", "rr", "ra", "rc", "g", "rb", "rec", "fr", "rss", "p", "b", "mr", "sr", "re", "ir", "cr", "as", "w", "or", "err", "er", "rg", "t", "rus"], "c": ["enc", "d", "ct", "o", "cu", "v", "cm", "tc", "sc", "cs", "e", "bc", "C", "nc", "u", "pc", "cf", "l", "ec", "cc", "dc", "m", "uc", "lc", "rc", "config", "k", "self", "n", "ac", "vc", "ci", "ce", "ctx", "cur", "i", "p", "b", "cy", "f", "unc", "cr", "mc", "ca", "xc", "t"]}}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n", "idx": 14162, "substitutes": {"plug_handler": ["plug_handle", "plug_controller", "pluginghand", "plugin_handler", "pluginghandler", "plugfinfo", "plugfhandle", "plugin_hand", " plug_config", "plugfhandler", "pluginghandle", "plug_hand", " plug_handle", "plugingcontroller", "plugalhandler", "plug_config", "plug_info", "plugalhandle", "plugfconfig", " plug_info", "plugin_controller", "plugin_handle", "plugalconfig", "plugalinfo"], "plugged_dev": ["plugded_Dev", "plugging__ev", "pluggedPev", "pluggedPdi", "plugged__di", "plugded_dev", "plugged_di", "plugged_Dev", "plugled_di", "plugging_def", "plugged__def", "plugged_ev", "plugged__dev", "plugged__device", "plugger_dev", "plugged_tag", "plugged_priv", "plugging_dev", "plugged_def", "plugging_ev", "plugged_device", "plugging__def", "plugger_device", "pluggedPdevice", "plugded_tag", "plugded_priv", "plugged__ev", "plugging__dev", "pluggedPdev", "plugger_di", "plugled_ev", "plugled_device", "plugled_dev"], "errp": ["errpe", "rrpre", " errpe", "erpe", " errr", "errl", " errpre", "errr", "riskr", "rrr", " errl", "strr", "erl", "riskp", "erpre", "rrp", "strp", "strl", "strP", "riskpe", " errP", "errpre", "erP", "rrP", "errP", "err", "erp"], "phb": ["phba", "Phba", "PHba", "herp", "ophbs", "phlb", "phB", " phbb", "PHa", "Phb", "hB", "PHb", "phc", " phB", "PHsb", " phc", "Phsb", "thp", "Pha", "herb", "phd", "phbs", "chbs", "pha", "phw", "Php", "herc", "php", "hyp", "hp", " phbs", "chp", "chb", "Phw", " phba", "phbb", "chB", "Phbb", "hyc", " phlb", "hyb", "Phbs", " phw", "ophb", " phsb", "thbb", "opha", "hb", " php", "thw", "hbs", "ophd", "phsb", " pha", "herlb", "thb", " phd", "hylb", "Phd"], "pdev": ["tname", "tdevice", "spdc", " pdc", "pprof", "pdiv", " pdiv", "spdev", "ddevice", "fdevice", " pname", "dod", "fdev", "tdev", "spdiv", " pprof", "Pod", "Pdiv", "pdc", "spprof", "tdc", "Pdev", "fname", "tdiv", "ddev", "pdevice", " pod", "ddiv", "Pdevice", "fdiv", "tprof", " pdevice", "pname", "pod"], "drc": ["ddsrc", "ddrec", "fRC", "mdisc", "dru", "ndru", "mdsrc", "ddisc", "dRC", "fsc", "dsrc", "dci", " drec", "frc", "disc", "ndrc", "trec", "bsrc", "cdrc", "frec", "ddrc", "fsrc", "cdru", " dRC", "ndci", " dsrc", "tRC", " dru", "mdrec", "bRC", "ndsrc", " disc", "cdsrc", "dsc", "drec", "brc", " dsc", " dci", "tsc", "cdci", "mdrc", "trc"], "local_err": ["Local_rage", "Local_err", "local_orr", "local_finder", "local_rr", "local_rage", "localxerr", "local_er", " local_er", "local_order", "localxfinder", "Local_rr", "Local_orr", " local_order", "local_error", " local_error", " local_finder", "localxerror"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "av_cold int ff_dvvideo_init(AVCodecContext *avctx)\n\n{\n\n    DVVideoContext *s = avctx->priv_data;\n\n    DSPContext dsp;\n\n    static int done = 0;\n\n    int i, j;\n\n\n\n    if (!done) {\n\n        VLC dv_vlc;\n\n        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];\n\n        int16_t  new_dv_vlc_level[NB_DV_VLC*2];\n\n\n\n        done = 1;\n\n\n\n        /* it's faster to include sign bit in a generic VLC parsing scheme */\n\n        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {\n\n            new_dv_vlc_bits[j]  = dv_vlc_bits[i];\n\n            new_dv_vlc_len[j]   = dv_vlc_len[i];\n\n            new_dv_vlc_run[j]   = dv_vlc_run[i];\n\n            new_dv_vlc_level[j] = dv_vlc_level[i];\n\n\n\n            if (dv_vlc_level[i]) {\n\n                new_dv_vlc_bits[j] <<= 1;\n\n                new_dv_vlc_len[j]++;\n\n\n\n                j++;\n\n                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;\n\n                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;\n\n                new_dv_vlc_run[j]   =  dv_vlc_run[i];\n\n                new_dv_vlc_level[j] = -dv_vlc_level[i];\n\n            }\n\n        }\n\n\n\n        /* NOTE: as a trick, we use the fact the no codes are unused\n\n           to accelerate the parsing of partial codes */\n\n        init_vlc(&dv_vlc, TEX_VLC_BITS, j,\n\n                 new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0);\n\n        assert(dv_vlc.table_size == 1184);\n\n\n\n        for (i = 0; i < dv_vlc.table_size; i++){\n\n            int code = dv_vlc.table[i][0];\n\n            int len  = dv_vlc.table[i][1];\n\n            int level, run;\n\n\n\n            if (len < 0){ //more bits needed\n\n                run   = 0;\n\n                level = code;\n\n            } else {\n\n                run   = new_dv_vlc_run  [code] + 1;\n\n                level = new_dv_vlc_level[code];\n\n            }\n\n            ff_dv_rl_vlc[i].len   = len;\n\n            ff_dv_rl_vlc[i].level = level;\n\n            ff_dv_rl_vlc[i].run   = run;\n\n        }\n\n        ff_free_vlc(&dv_vlc);\n\n    }\n\n\n\n    /* Generic DSP setup */\n\n    ff_dsputil_init(&dsp, avctx);\n\n    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);\n\n    s->get_pixels = dsp.get_pixels;\n\n    s->ildct_cmp = dsp.ildct_cmp[5];\n\n\n\n    /* 88DCT setup */\n\n    s->fdct[0]     = dsp.fdct;\n\n    s->idct_put[0] = dsp.idct_put;\n\n    for (i = 0; i < 64; i++)\n\n       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];\n\n\n\n    /* 248DCT setup */\n\n    s->fdct[1]     = dsp.fdct248;\n\n    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP\n\n    memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);\n\n\n\n    avctx->coded_frame = &s->picture;\n\n    s->avctx = avctx;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;\n\n\n\n    return 0;\n\n}\n", "idx": 14168, "substitutes": {"avctx": ["Avcmp", "avalctx", "avcmp", "AVcontext", "Avcontext", "avconnection", " avcontext", "avalcontext", "Avctx", "AVcmp", "avca", "avalconnection", " avca", "Avca", "AVctx", " avconnection", "AVca", "avalca", "AVconnection", " avcmp", "avcontext"], "s": ["sync", "d", "o", "session", "v", "sc", "cs", "e", "space", "ssl", "service", "m", "sq", "sec", "a", "g", "n", "c", "args", "p", "b", "f", "w", "ses", "js", "services", "S", "t"], "dsp": ["vdpp", " cdpp", " dpp", " cdspe", "udtp", " cdsp", "udsp", "vdtp", " dspe", "vdspe", "udspe", " dtp", "udpp", "vdsp", " cdtp"], "i": ["it", "d", "ie", "di", "gi", "chi", "ij", "ini", "iu", "mi", "fi", "jp", "v", "li", "jl", "e", "u", "xi", "l", "pi", "uri", "ei", "si", "vi", "y", "ai", "ui", "api", "ti", "k", "ix", "z", "n", "eni", "ik", "ci", "io", "id", "bi", "qi", "ip", "x", "c", "phi", "oi", "ji", "ki", "p", "cli", "ri", "info", "b", "current", "ni", "f", "zi", "ind", "r", "ii", "ori", "I", "yi"], "j": ["it", "adj", "d", "ie", "o", "dj", "J", "jp", "v", "li", "jl", "br", "e", "u", "obj", "pos", "end", "l", "size", "job", "y", "m", "ui", "el", "jo", "jen", "aj", "g", "k", "z", "jj", "jet", "n", "fr", "io", "kj", "bi", "qi", "x", "ij", "q", "jon", "ji", "info", "p", "index", "b", "ni", "f", "ind", "js", "bj", "uj", "je", "ii", "jit", "ja", "jc"], "dv_vlc": ["dv_svcs", "dv_llc", "dv_wlc", "dv_wlt", "dv_elcs", "dv_tllc", "dv_tlb", "dv_elc", "dv_vlk", "dv_wlb", "dv_llci", "dv_llt", "dv_tlc", "dv_vlb", "dv_wlcs", "dv_ellc", "dv_svc", "dv_dlci", "dv_llcs", "dv_dlcs", "dv_vlci", "dv_vlt", "dv_svt", "dv_dlc", "dv_vlcs", "dv_llk", "dv_vllc", "dv_svci", "dv_tlcs", "dv_wlci", "dv_wllc", "dv_elb", "dv_wlk", "dv_dlk"], "new_dv_vlc_bits": ["new_dv_vllc_bit", "new_dv_vlc__bytes", "new_dv_vlc_bit", "new_dv_vlc4bit", "new_dv_vlc4len", "new_dv_vllc_bits", "new_dv_vlci_bit", "new_dv_vlc4bits", "new_dv_vlc__bit", "new_dv_vlci_bits", "new_dv_vlci_level", "new_dv_vlc__runs", "new_dv_vlc__bits", "new_dv_vlci_len", "new_dv_vllc_bytes", "new_dv_vlc_vals", "new_dv_vlci_bytes", "new_dv_vlc64vals", "new_dv_vlc4level", "new_dv_vlc_bytes", "new_dv_vlc64bytes", "new_dv_vllc_vals", "new_dv_vlci_runs", "new_dv_vlc_runs", "new_dv_vlc64bit", "new_dv_vlc64bits"], "new_dv_vlc_len": ["new_dv_vlc_pos", "new_dv_vlcs_pos", "new_dv_vlcs_log", "new_dv_vlci_run", "new_dv_vlc__len", "new_dv_vlc_line", "new_dv_vlc__run", "new_dv_vlc_la", "new_dv_vlcs_line", "new_dv_vlci_layer", "new_dv_vlc_length", "new_dv_vlc__length", "new_dv_vlci_line", "new_dv_vlci_len", "new_dv_vlc_log", "new_dv_vlcs_run", "new_dv_vlci_pos", "new_dv_vlci_log", "new_dv_vlc__log", "new_dv_vlc__pos", "new_dv_vlcs_la", "new_dv_vlcs_len", "new_dv_vlc_layer", "new_dv_vlci_length", "new_dv_vlc__line"], "new_dv_vlc_run": ["new_dv_vlcs_reg", "new_dv_vlc_reg", "new_dv_vlci_run", "new_dv_vlc_name", "new_dv_vlci_len", "new_dv_vlc_use", "new_dv_vlcs_run", "new_dv_vlci_runs", "new_dv_vlc_runs", "new_dv_vlci_name", "new_dv_vlcs_len", "new_dv_vlcs_runs", "new_dv_vlci_use"], "new_dv_vlc_level": ["new_dv_vlcs__log", "new_dv_vlc___run", "new_dv_vlcs_level", "new_dv_vlcs__vel", "new_dv_vlcs__run", "new_dv_vlcs_log", "new_dv_vlci_run", "new_dv_vlcs_vel", "new_dv_vlc___level", "new_dv_vlc__line", "new_dv_vlc_line", "new_dv_vlc__len", "new_dv_vlc_lock", "new_dv_vlc_vel", "new_dv_vlci_level", "new_dv_vlc___log", "new_dv_vlci_line", "new_dv_vlc__vel", "new_dv_vlc__level", "new_dv_vlc_log", "new_dv_vlci_len", "new_dv_vlcs_run", "new_dv_vlc___vel", "new_dv_vlc__log", "new_dv_vlcs__level", "new_dv_vlcs_lock", "new_dv_vlcs_len", "new_dv_vlc__run"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int libquvi_read_header(AVFormatContext *s)\n\n{\n\n    int i, ret;\n\n    quvi_t q;\n\n    quvi_media_t m;\n\n    QUVIcode rc;\n\n    LibQuviContext *qc = s->priv_data;\n\n    char *media_url, *pagetitle;\n\n\n\n    rc = quvi_init(&q);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);\n\n\n\n    rc = quvi_parse(q, s->filename, &m);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);\n\n    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);\n\n    if (rc == QUVI_OK)\n\n        av_dict_set(&s->metadata, \"title\", pagetitle, 0);\n\n\n\n    for (i = 0; i < qc->fmtctx->nb_streams; i++) {\n\n        AVStream *st = avformat_new_stream(s, NULL);\n\n        AVStream *ist = qc->fmtctx->streams[i];\n\n        if (!st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);\n\n    }\n\n\n\n    return 0;\n\n\n\nquvi_fail:\n\n    av_log(s, AV_LOG_ERROR, \"%s\\n\", quvi_strerror(q, rc));\n\n    ret = AVERROR_EXTERNAL;\n\n\n\nend:\n\n    quvi_parse_close(&m);\n\n    quvi_close(&q);\n\n    return ret;\n\n}\n", "idx": 14199, "substitutes": {"s": ["comments", "storage", "sync", "d", "o", "session", "your", "rs", "h", "v", "sc", "e", "cs", "sa", "u", "ts", "l", "parts", "params", "ds", "server", "sys", "si", "ss", "in", "ssl", "service", "conf", "sq", "gs", "sec", "a", "xs", "sn", "g", "es", "ks", "self", "n", "os", "spec", "ctx", "is", "c", "su", "sg", "args", "p", "ns", "qs", "scope", "b", "sl", "f", "sr", "sb", "ses", "js", "w", "settings", "r", "services", "ls", "S", "sym", "t", "ops"], "i": ["it", "adi", "ie", "d", "di", "gi", "ini", "mi", "iu", "fi", "v", "multi", "li", "count", "xi", "u", "mu", "end", "l", "pi", "ib", "uri", "si", "y", "ai", "ui", "a", "c", "ti", "k", "ix", "n", "eni", "ik", "io", "id", "ci", "gu", "bi", "is", "ip", "x", "oi", "phi", "info", "qi", "ki", "p", "index", "ri", "hi", "b", "ji", "ni", "f", "start", "zi", "j", "r", "ii", "jit", "I", "yi"], "ret": ["ru", "ft", "fin", "rs", "success", "nt", "ur", "ry", "match", "result", "feat", "ut", "rt", "att", "sur", "val", "def", "res", "det", "reply", "len", "fun", "usr", "reg", "RC", "rets", "arg", "rev", "cur", "rx", "ext", "status", "cat", "lit", "let", "arr", "re", "RET", "flag", "rl", "back", "bit", "ref", "alt", "Ret", "ann", "code"], "q": ["client", "ct", "d", "o", "qq", "Q", "qu", "v", "requ", "iq", "e", "u", "l", "query", "play", "qt", "qa", "queue", "sq", "ue", "config", "g", "ck", "z", "k", "self", "ac", "n", "ch", "quest", "cache", "qi", "c", "h", "input", "x", "p", "cl", "qs", "req", "f", "ca", "w", "dq", "que", "question", "r", "ract", "t"], "m": ["fm", "module", "mm", "d", "o", "mi", "v", "cm", "md", "source", "gm", "e", "media", "sm", "u", "mu", "param", "pc", "mode", "l", "y", "hm", "tm", "mod", "M", "meta", "g", "k", "n", "mt", "x", "c", "h", "ma", "p", "b", "metadata", "f", "dm", "mc", "w", "ms", "nm", "r", "t", "bm"], "rc": ["ror", "ru", "dr", "rs", "success", "ok", " RC", "nt", "ur", "sc", "ry", "ras", "result", "bc", "rh", "feat", "pc", "rt", "cb", "sur", "ro", "usr", "anc", "ec", "irc", "cc", "loc", "dc", "rd", "uc", "rr", "ra", "error", "irm", "hl", "reg", "ck", "RC", "rb", "lc", "rec", "ac", "rin", "wx", "cur", "fc", "c", "rx", "inc", "arc", "co", "ack", "ctrl", "src", " r", "roc", "err", "rl", "auc", "rn", "r", "rg", "lang", "ref", "Ret", "ann"], "qc": ["sqsc", " qsc", "sqc", " qf", "ckcs", " qr", "qci", "ipc", " qd", " qdc", "qr", "sqf", "calf", "reqcu", " qv", " qpc", "qv", " qcu", "reqr", "Qdc", "qupc", " qp", "ipd", "qxc", "ckpc", "qud", "ckcu", "calp", "Qxc", "qudc", "quxc", "quc", "qucu", "quv", "sqdc", "qf", "ippc", " qlc", "qsc", "sqd", "qucs", "qlc", "sqr", "iplc", " qmc", " qxc", "qdc", "sqcu", "qur", "calc", "quci", "qulc", "reqc", "qd", "qup", "qcs", "sqlc", "sqv", "Qc", "sqcs", "sqpc", "qusc", "qmc", "qp", "ckc", "sqp", " qci", "sqmc", "qumc", "caldc", "reqp", "Qci", "qcu", " qcs", "qpc"], "media_url": ["media_path", "image_url", "media_address", "image_uri", "mediaadURL", "image_URL", "mediaadname", "mediaadurl", "image_address", "media_URL", "image_string", "image_path", "mediaadaddress", "media_name", "media_uri", "image_name", "media_string"], "pagetitle": ["paguETitle", "pagatotal", "pagetyitle", "pagETime", "pagentotal", "pagettitles", "pagotype", "pagedetyail", "pagETitles", "pagedetrue", "pagedentrue", "pagedetyitle", "pagatail", "paguetype", "pagentrue", "pagestitle", "paguetitle", "pagetotal", "pagettitle", "pagentitles", "pagettail", "pagetype", "pagentitle", "pagedetyime", "paguetyle", "pagetime", "pagatitle", "paguETyle", "pagotyle", "pagestrue", "paguETitles", "pagedetitles", "pagedetail", "pagedentotal", "pagotitles", "pagotitle", "paguEType", "pagedetyitles", "pagedentail", "paguetitles", "pagedetime", "pagetail", "pagedetotal", "pagetyail", "pagedentitle", "pagatrue", "pagetyitles", "pagETail", "pagETitle", "pagedetitle", "pagestail", "pagentyle", "pagetyle", "pagetitles", "pagetyime", "pagettime", "pagestotal", "pagentype", "pagentail", "pagETyle", "pagEType", "pagetrue"], "st": ["et", "d", "ST", "dr", "stress", "bl", "tmp", "nd", "ust", "sc", "St", "sa", "pt", "rest", "store", "obj", "dist", "ds", "ste", "se", "sp", "inst", "sty", "str", "sn", "sta", "sts", "spect", "fr", "est", "ess", "sd", "stop", "sh", "stage", "ast", "p", "sw", "sl", "src", "sb", "start", "kt", "stream", "td", "ost", "sth", "std", "t"], "ist": ["it", "part", "et", "asi", "isd", "ft", "dr", "alist", "ista", "iste", "nd", "dist", "ld", "pt", "ism", "feat", "rest", "gd", "wd", "ift", "isi", "pect", "IST", "inst", "sta", "edit", "lp", "ict", "pop", "est", "id", "aint", "iss", "ess", "sd", "is", "ists", "ia", "art", "ast", "dd", "ic", "ind", "ost", "std", "xt", "irst", "ad", "tta"]}}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14220, "substitutes": {"fmt": ["Fnt", "bformat", "fm", "blt", "sfformat", "sfMT", "tfm", "tftt", "fwt", " fm", "Fmt", "tflt", "fnt", "sfmt", "tfwt", " fwt", " fnt", " flt", "FMT", "tfnt", "Ftt", "tfformat", "sftt", "tfMT", "fMT", "bmt", "Fformat", "flt", " fformat", "tfmt", "Fm", "fformat", "bwt", "ftt"], "opts": ["OPps", "precs", "optt", "optches", "OPTS", "optTS", "iopt", "OPts", "iopches", "otts", "otps", "otcs", "alpt", "iopTS", "opcs", "prets", "optts", "otters", "OPpt", "OPches", "OPt", "preps", "optcs", "iopts", "opt", "operpt", "preters", "alts", "opters", "operps", "opps", "opTS", "optters", "opches", "operts", "alps", "optps", "oppt", "opert", "alt"], "base_filename": ["base_string", "base_files", "baseinglanguage", "baseingfilename", "baseingfile", "basefullfilename", "basefullfiles", "base_layer", "build_filename", " base_file", " base_files", " base_txt", "baseingfamily", "base_txt", "build_layer", "base_language", "baseingtxt", "baseinglayer", "build_file", "build_language", "basefullfile", "base_file", "base_family", " base_string", " base_family", "basefullstring"], "base_fmt": ["base_flass", "base_bformat", "base_frameworktml", "base_frlt", "base_tflt", "base_formatter", "base_frameworkformat", "base__ftml", "base2formlt", "base_bmt", "base_fileformat", "base_fatter", "base_frameworkmt", "base_frameworkwd", "base__fmt", "base_formformat", "base2fmt", "base_filelass", "base_frformat", "base_filemt", "base_btml", "base_tfwd", "base_fmatter", "base_frmt", "base_filelt", "base__fformat", "base_blt", "base_fmformat", "base2formatter", "base__bwd", "base_bwd", "base2formformat", "base_fformat", "base_batter", "base2fatter", "base_formlt", "base__bmt", "base_ftml", "base__fwd", "base__bformat", "base_flt", "base2fformat", "base_formmt", "base2flt", "base_tftml", "base_tflass", "base_tfformat", "base2formmt", "base_frlass", "base_fmlt", "base_fwd", "base_tfmt", "base_fmmt", "base__btml"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_flush_queued_packets(VLANClientState *vc)\n\n{\n\n    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {\n\n        VLANPacket *packet;\n\n        int ret;\n\n\n\n        packet = TAILQ_FIRST(&vc->vlan->send_queue);\n\n        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n\n\n        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);\n\n        if (ret == 0 && packet->sent_cb != NULL) {\n\n            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);\n\n            break;\n\n        }\n\n\n\n        if (packet->sent_cb)\n\n            packet->sent_cb(packet->sender, ret);\n\n\n\n        qemu_free(packet);\n\n    }\n\n}\n", "idx": 14228, "substitutes": {"vc": ["VC", "client", "ct", "cu", "vm", "data", "v", "ll", "cs", "nc", "bc", "cf", "rt", "cb", "wd", "conn", "server", "iw", "qt", "sys", "gc", "cc", "dc", "service", "db", "vt", "sq", "asu", "this", "cdn", "api", "lc", "config", "ant", "ac", "ci", "vd", "ctx", "fc", "acs", "c", "q", "input", "wl", "req", "qs", "cli", "cy", "ic", "ctrl", "vine", "lv", "entry", "xc", "ku", "vv", "nec", "cv"], "packet": ["formET", "compat", "plugat", "Packinet", " packetter", "packageeter", " packkt", "plugset", " packec", "octetter", " packacket", "plugET", "compon", "packeter", "hookacket", "Packette", "octacket", "packon", "packset", "hooken", "formel", " packett", "packsinet", "plugacket", "compen", "packagekt", "packageET", "pacen", "packetter", "octet", "Packel", "paceter", "pacet", "packkt", "packette", "packett", "compet", " packon", "packageetting", "pacacket", "packsetter", "packsen", "ppET", "PackET", "packageette", "packat", "compkt", "packageacket", "packinet", "packsacket", "pluget", "hooketer", "Packect", "pacset", "compel", "packseter", "ppet", "plugen", "packageel", " packect", "ppel", "Packeto", "packen", "compacket", " packeto", " packette", "compec", "packetting", "packET", "packect", "compett", " packinet", "packageet", "formeto", "packeto", "packec", "packageec", " packeter", "packageon", "ppeto", "hooket", " packel", "packacket", "packageett", " packET", " packetting", "packageect", "Packat", "packel", "formet", "Packacket", "Packet", "compset", "compET", "competting", "packseto", "packageetter", "octetting", "packageeto"], "ret": ["ct", " resp", "ft", "fin", "success", "data", "nt", "resp", "bf", "ry", "pat", "pt", "result", "match", "repl", "rt", "cb", "att", "val", "job", "res", "pet", "db", " RET", "rf", "det", "reply", "len", "_", "seq", "fun", "rc", "num", "reg", "rb", "rets", "id", "rev", " fun", "mt", "no", "art", "req", "cat", "lit", "ver", "f", "re", "sr", "RET", "flag", "ref", "alt", "Ret"]}}
{"project": "FFmpeg", "commit_id": "c0bc8b9afb7e4f39d84080870b9feedcd23ab5c9", "target": 1, "func": "LF_FUNC (h,  luma,         sse2)\n\nLF_IFUNC(h,  luma_intra,   sse2)\n\nLF_FUNC (v,  luma,         sse2)\n\nLF_IFUNC(v,  luma_intra,   sse2)\n\n\n\n/***********************************/\n\n/* weighted prediction */\n\n\n\n#define H264_WEIGHT(W, H, OPT) \\\n\nvoid ff_h264_weight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    int stride, int log2_denom, int weight, int offset);\n\n\n\n#define H264_BIWEIGHT(W, H, OPT) \\\n\nvoid ff_h264_biweight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    uint8_t *src, int stride, int log2_denom, int weightd, \\\n\n    int weights, int offset);\n\n\n\n#define H264_BIWEIGHT_MMX(W,H) \\\n\nH264_WEIGHT  (W, H, mmx2) \\\n\nH264_BIWEIGHT(W, H, mmx2)\n\n\n\n#define H264_BIWEIGHT_MMX_SSE(W,H) \\\n\nH264_BIWEIGHT_MMX(W, H) \\\n\nH264_WEIGHT      (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, ssse3)\n\n\n\nH264_BIWEIGHT_MMX_SSE(16, 16)\n\nH264_BIWEIGHT_MMX_SSE(16,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8, 16)\n\nH264_BIWEIGHT_MMX_SSE( 8,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  8)\n\nH264_BIWEIGHT_MMX    ( 4,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  2)\n\n\n\nvoid ff_h264dsp_init_x86(H264DSPContext *c)\n\n{\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n        c->h264_loop_filter_strength= h264_loop_filter_strength_mmx2;\n\n    }\n\n#if HAVE_YASM\n\n    if (mm_flags & AV_CPU_FLAG_MMX) {\n\n        c->h264_idct_dc_add=\n\n        c->h264_idct_add= ff_h264_idct_add_mmx;\n\n        c->h264_idct8_dc_add=\n\n        c->h264_idct8_add= ff_h264_idct8_add_mmx;\n\n\n\n        c->h264_idct_add16     = ff_h264_idct_add16_mmx;\n\n        c->h264_idct8_add4     = ff_h264_idct8_add4_mmx;\n\n        c->h264_idct_add8      = ff_h264_idct_add8_mmx;\n\n        c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx;\n\n\n\n        if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n            c->h264_idct_dc_add= ff_h264_idct_dc_add_mmx2;\n\n            c->h264_idct8_dc_add= ff_h264_idct8_dc_add_mmx2;\n\n            c->h264_idct_add16     = ff_h264_idct_add16_mmx2;\n\n            c->h264_idct8_add4     = ff_h264_idct8_add4_mmx2;\n\n            c->h264_idct_add8      = ff_h264_idct_add8_mmx2;\n\n            c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx2;\n\n\n\n            c->h264_v_loop_filter_chroma= ff_x264_deblock_v_chroma_mmxext;\n\n            c->h264_h_loop_filter_chroma= ff_x264_deblock_h_chroma_mmxext;\n\n            c->h264_v_loop_filter_chroma_intra= ff_x264_deblock_v_chroma_intra_mmxext;\n\n            c->h264_h_loop_filter_chroma_intra= ff_x264_deblock_h_chroma_intra_mmxext;\n\n#if ARCH_X86_32\n\n            c->h264_v_loop_filter_luma= ff_x264_deblock_v_luma_mmxext;\n\n            c->h264_h_loop_filter_luma= ff_x264_deblock_h_luma_mmxext;\n\n            c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_mmxext;\n\n            c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_mmxext;\n\n\n            c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_mmx2;\n\n            c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_mmx2;\n\n            c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_mmx2;\n\n            c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_mmx2;\n\n            c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_mmx2;\n\n            c->weight_h264_pixels_tab[5]= ff_h264_weight_4x8_mmx2;\n\n            c->weight_h264_pixels_tab[6]= ff_h264_weight_4x4_mmx2;\n\n            c->weight_h264_pixels_tab[7]= ff_h264_weight_4x2_mmx2;\n\n\n\n            c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_mmx2;\n\n            c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_mmx2;\n\n            c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_mmx2;\n\n            c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_mmx2;\n\n            c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_mmx2;\n\n            c->biweight_h264_pixels_tab[5]= ff_h264_biweight_4x8_mmx2;\n\n            c->biweight_h264_pixels_tab[6]= ff_h264_biweight_4x4_mmx2;\n\n            c->biweight_h264_pixels_tab[7]= ff_h264_biweight_4x2_mmx2;\n\n\n\n            if (mm_flags&AV_CPU_FLAG_SSE2) {\n\n                c->h264_idct8_add = ff_h264_idct8_add_sse2;\n\n                c->h264_idct8_add4= ff_h264_idct8_add4_sse2;\n\n\n\n                c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_sse2;\n\n                c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_sse2;\n\n                c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_sse2;\n\n                c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_sse2;\n\n                c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_sse2;\n\n\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_sse2;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_sse2;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_sse2;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_sse2;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_sse2;\n\n\n\n\n                c->h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2;\n\n                c->h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2;\n\n                c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2;\n\n                c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2;\n\n\n\n\n                c->h264_idct_add16 = ff_h264_idct_add16_sse2;\n\n                c->h264_idct_add8  = ff_h264_idct_add8_sse2;\n\n                c->h264_idct_add16intra = ff_h264_idct_add16intra_sse2;\n\n            }\n\n            if (mm_flags&AV_CPU_FLAG_SSSE3) {\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_ssse3;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_ssse3;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_ssse3;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_ssse3;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_ssse3;\n\n            }\n\n        }\n\n    }\n\n\n}", "idx": 14248, "substitutes": {"c": ["v", "cm", "cs", "e", "bc", "C", "l", "icc", "gc", "ec", "cc", "dc", "m", "lc", "config", "g", "ac", "vc", "ch", "fc", "cache", "p", "b", "f", "mc", "ca", "xc", "cv"]}}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *band,\n\n                           AVCodecContext *avctx)\n\n{\n\n    int plane, band_num, indx, transform_id, scan_indx;\n\n    int i;\n\n\n\n    plane    = get_bits(&ctx->gb, 2);\n\n    band_num = get_bits(&ctx->gb, 4);\n\n    if (band->plane != plane || band->band_num != band_num) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid band header sequence!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->is_empty = get_bits1(&ctx->gb);\n\n    if (!band->is_empty) {\n\n        int old_blk_size = band->blk_size;\n\n        /* skip header size\n\n         * If header size is not given, header size is 4 bytes. */\n\n        if (get_bits1(&ctx->gb))\n\n            skip_bits(&ctx->gb, 16);\n\n\n\n        band->is_halfpel = get_bits(&ctx->gb, 2);\n\n        if (band->is_halfpel >= 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid/unsupported mv resolution: %d!\\n\",\n\n                   band->is_halfpel);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n#if IVI4_STREAM_ANALYSER\n\n        if (!band->is_halfpel)\n\n            ctx->uses_fullpel = 1;\n\n#endif\n\n\n\n        band->checksum_present = get_bits1(&ctx->gb);\n\n        if (band->checksum_present)\n\n            band->checksum = get_bits(&ctx->gb, 16);\n\n\n\n        indx = get_bits(&ctx->gb, 2);\n\n        if (indx == 3) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid block size!\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        band->mb_size  = 16 >> indx;\n\n        band->blk_size = 8 >> (indx >> 1);\n\n\n\n        band->inherit_mv     = get_bits1(&ctx->gb);\n\n        band->inherit_qdelta = get_bits1(&ctx->gb);\n\n\n\n        band->glob_quant = get_bits(&ctx->gb, 5);\n\n\n\n        if (!get_bits1(&ctx->gb) || ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n\n            transform_id = get_bits(&ctx->gb, 5);\n\n            if (transform_id >= FF_ARRAY_ELEMS(transforms) ||\n\n                !transforms[transform_id].inv_trans) {\n\n                avpriv_request_sample(avctx, \"Transform %d\", transform_id);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((transform_id >= 7 && transform_id <= 9) ||\n\n                 transform_id == 17) {\n\n                avpriv_request_sample(avctx, \"DCT transform\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n            if ((transform_id >= 0 && transform_id <= 2) || transform_id == 10)\n\n                ctx->uses_haar = 1;\n\n#endif\n\n\n\n            band->inv_transform = transforms[transform_id].inv_trans;\n\n            band->dc_transform  = transforms[transform_id].dc_trans;\n\n            band->is_2d_trans   = transforms[transform_id].is_2d_trans;\n\n            if (transform_id < 10)\n\n                band->transform_size = 8;\n\n            else\n\n                band->transform_size = 4;\n\n\n\n            if (band->blk_size != band->transform_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            scan_indx = get_bits(&ctx->gb, 4);\n\n            if (scan_indx == 15) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Custom scan pattern encountered!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (scan_indx > 4 && scan_indx < 10) {\n\n                if (band->blk_size != 4)\n\n                    return AVERROR_INVALIDDATA;\n\n            } else if (band->blk_size != 8)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            band->scan = scan_index_to_tab[scan_indx];\n\n\n\n            band->quant_mat = get_bits(&ctx->gb, 5);\n\n            if (band->quant_mat >= FF_ARRAY_ELEMS(quant_index_to_tab)) {\n\n\n\n                if (band->quant_mat == 31)\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"Custom quant matrix encountered!\\n\");\n\n                else\n\n                    avpriv_request_sample(avctx, \"Quantization matrix %d\",\n\n                                          band->quant_mat);\n\n                band->quant_mat = -1;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            if (old_blk_size != band->blk_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"The band block size does not match the configuration \"\n\n                       \"inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (band->quant_mat < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid quant_mat inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n        /* decode block huffman codebook */\n\n        if (!get_bits1(&ctx->gb))\n\n            band->blk_vlc.tab = ctx->blk_vlc.tab;\n\n        else\n\n            if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF,\n\n                                     &band->blk_vlc, avctx))\n\n                return AVERROR_INVALIDDATA;\n\n\n\n        /* select appropriate rvmap table for this band */\n\n        band->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8;\n\n\n\n        /* decode rvmap probability corrections if any */\n\n        band->num_corr = 0; /* there is no corrections */\n\n        if (get_bits1(&ctx->gb)) {\n\n            band->num_corr = get_bits(&ctx->gb, 8); /* get number of correction pairs */\n\n            if (band->num_corr > 61) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Too many corrections: %d\\n\",\n\n                       band->num_corr);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* read correction pairs */\n\n            for (i = 0; i < band->num_corr * 2; i++)\n\n                band->corr[i] = get_bits(&ctx->gb, 8);\n\n        }\n\n    }\n\n\n\n    if (band->blk_size == 8) {\n\n        band->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    } else {\n\n        band->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    }\n\n\n\n    /* Indeo 4 doesn't use scale tables */\n\n    band->intra_scale = NULL;\n\n    band->inter_scale = NULL;\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n", "idx": 14263, "substitutes": {"ctx": ["client", "sync", "library", "cam", "cpp", "hub", "connection", "cu", "cn", "git", "la", "cm", "sc", "cs", "nc", "bc", "pkg", "sci", "cf", "act", "cmd", "voc", "cb", "kb", "sys", "gc", "anc", "qa", "na", "Context", "cc", "cmp", "ga", "dc", "bus", "conf", "hw", "lc", "rc", "cca", "config", "kernel", "cus", "vc", "np", "ci", "fc", "context", "c", "conv", "mac", "cp", "cli", "req", "scope", "component", "qs", "coll", "plugin", "ctrl", "tx", "crit", "ca", "utils", "wcs", "cci", "gb", "xc", "loc", "fw", "conn", "cas", "support", "cv"], "band": ["session", "field", "card", "hub", "list", "filter", "patch", "output", "work", "group", "boot", "bb", "lib", "component", "gen", "bolt", "brand", "flag", "bo", "back", "client", "part", "library", "batch", "flow", "amp", "tool", "match", "Band", "cmd", "header", "db", "tag", "slice", "unk", "audio", "word", "block", "usb", "now", "line", "off", "load", "cast", "bug", "bank", "dB", "bass", "model", "and", "service", "bus", "book", "byte", "class", "stage", "but", "station", "bit", "cell", "bound", "bd", "d", "app", "connection", "board", "ground", "project", "feature", "base", "length", "BB", "broad", "bridge", "bart", "kernel", "host", "point", "low", "feed", "product", "layer", "range", "device", "b", "port", "gb", "plugin", "support"], "avctx": ["airsci", "afcontext", "awsci", "AVcontext", "abcrit", "afconv", "versync", " avcontext", "afsci", "avecrit", "airloc", "avesync", "avcrit", "aveconn", "afloc", "avsci", "AVconv", "AVchan", "airconv", "avectx", "awcontext", "avloc", "awchan", "aircontext", "awctx", "abctx", "aircu", "verctx", "avcu", " avsci", "avconv", "afctx", "AVctx", "vercu", "avsync", "avchan", "airctx", "absync", "AVsci", "afcu", "vercrit", "verconn", "vercontext", "versci", "avconn", "AVloc", " avchan", "avcontext", "abconn"], "plane": ["gate", "charge", "engine", "route", "card", "pe", "position", "flow", "board", "ge", "mode", "force", "mask", "fl", "flight", "source", "planes", "direction", "ane", "base", "cop", "den", "plan", "qa", "space", "pose", "fle", "se", "group", "phase", "slice", "frame", "unit", "lane", "scale", "nat", "age", "flat", "drop", "axis", "weight", "plot", "zone", "flo", "core", "component", "type", "plate", "fly", "sea", "port", "category", "orient", "clip", "rot"], "band_num": ["band__nr", "bug___range", " band_sum", "band6type", "bug_num", "band___range", "flowactype", "band_label", "band__size", "band_number", "band0offset", "band6label", "band0nr", "band_nor", "bug___size", "Band_uni", "bug___num", "flowacoffset", "band0range", "bug_nr", "flowaclabel", "band__range", "bandactype", "band1nor", "band_nr", "bug_size", "band_offset", "flow_label", "band_size", "flowacnum", "band_sum", "band1sum", "band6num", "band6offset", "Band_number", "flow_type", "Band_num", "band_na", "band___nr", "band0size", "bandacnum", "flow_num", "flow_offset", "bandacoffset", "bug_range", "band0num", "band___size", "band___num", "band1num", "band0type", "bandaclabel", "band_uni", "Band_na", "band_type", "band__num", "band_range", " band_nor", "bug___nr", "band0label"], "indx": ["idX", " indy", "indw", " idX", "indxp", "INDw", "Indz", "incxp", "idy", "INDy", "Index", "incy", "idxp", "pidX", "idice", " idx", " indX", "pidx", "INDex", "indj", "incz", "indice", " idj", "Indy", " indice", " indm", " indj", "idw", "idex", "pidm", "Indw", "indm", " idm", "INDx", "index", "indX", "IndX", "incx", "Indx", "pidj", "INDice", "Indxp", "idx", "INDX", "idz", "indy", "indz"], "transform_id": ["trans_id", "transformblockkey", "trans_ids", "transformOrid", "transform_ids", "trans_key", "transformOid", "transformblockrid", "transform_key", "transformOkey", "transform_rid", "trans_rid", "transformblockid", "transformblockids", "transformOids"], "scan_indx": ["scan2idy", "scan2indx", "scan_ridx", "scan_sidxe", "scan2idxe", "scan_idx", "scan2idb", "scan_sidy", "scan_sidb", "scan2indb", "scan_idy", "scan_sidx", "scan_indy", "scan_idb", "scan2idx", "scan2indy", "scan_ridb", "scan_indxe", "scan_ridxe", "scan_indb", "scan2indxe", "scan_idxe", "scan_ridy"], "i": ["d", "iu", "fi", "split", "li", "e", "u", "xi", "pi", "pixel", "ai", "ui", "slice", "a", "n", "ci", "bi", "qi", "ip", "c", "axis", "phi", "p", "b", "f", "j", "ii", "I"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, \n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct kernel_statfs *stfs;\n\n    \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\\n\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        ret = get_errno(read(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_write:\n\n        ret = get_errno(write(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_open:\n\n        ret = get_errno(open((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk((char *)arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(fork());\n\n        break;\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int *status = (int *)arg2;\n\n            ret = get_errno(waitpid(arg1, status, arg3));\n\n            if (!is_error(ret) && status)\n\n                tswapls((long *)&status);\n\n        }\n\n        break;\n\n    case TARGET_NR_creat:\n\n        ret = get_errno(creat((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_link:\n\n        ret = get_errno(link((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        ret = get_errno(unlink((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_execve:\n\n        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        ret = get_errno(chdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_time:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            ret = get_errno(time((time_t *)time_ptr));\n\n            if (!is_error(ret) && time_ptr)\n\n                tswap32s(time_ptr);\n\n        }\n\n        break;\n\n    case TARGET_NR_mknod:\n\n        ret = get_errno(mknod((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        ret = get_errno(chmod((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lchown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n        /* need to look at the data field */\n\n        goto unimplemented;\n\n    case TARGET_NR_umount:\n\n        ret = get_errno(umount((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(getuid());\n\n        break;\n\n    case TARGET_NR_stime:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            if (time_ptr)\n\n                tswap32s(time_ptr);\n\n            ret = get_errno(stime((time_t *)time_ptr));\n\n        }\n\n        break;\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n    case TARGET_NR_utime:\n\n        goto unimplemented;\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n    case TARGET_NR_access:\n\n        ret = get_errno(access((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n    case TARGET_NR_sync:\n\n        ret = get_errno(sync());\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        ret = get_errno(rename((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        ret = get_errno(mkdir((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        ret = get_errno(rmdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int *pipe_ptr = (int *)arg1;\n\n            ret = get_errno(pipe(pipe_ptr));\n\n            if (!is_error(ret)) {\n\n                tswap32s(&pipe_ptr[0]);\n\n                tswap32s(&pipe_ptr[1]);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        goto unimplemented;\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(getgid());\n\n        break;\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(getegid());\n\n        break;\n\n    case TARGET_NR_acct:\n\n        goto unimplemented;\n\n    case TARGET_NR_umount2:\n\n        ret = get_errno(umount2((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        switch(arg2) {\n\n        case F_GETLK:\n\n        case F_SETLK:\n\n        case F_SETLKW:\n\n            goto unimplemented;\n\n        default:\n\n            ret = get_errno(fcntl(arg1, arg2, arg3));\n\n            break;\n\n        }\n\n        break;\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        ret = get_errno(chroot((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n    case TARGET_NR_sigaction:\n\n#if 0\n\n        {\n\n            int signum = arg1;\n\n            struct target_old_sigaction *tact = arg2, *toldact = arg3;\n\n            ret = get_errno(setsid());\n\n            \n\n\n\n        }\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sgetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_ssetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_sigsuspend:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigpending:\n\n        goto unimplemented;\n\n    case TARGET_NR_sethostname:\n\n        ret = get_errno(sethostname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrusage:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                target_tv->tv_sec = tswapl(tv.tv_sec);\n\n                target_tv->tv_usec = tswapl(tv.tv_usec);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            tv.tv_sec = tswapl(target_tv->tv_sec);\n\n            tv.tv_usec = tswapl(target_tv->tv_usec);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_select:\n\n        goto unimplemented;\n\n    case TARGET_NR_symlink:\n\n        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_readlink:\n\n        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n    case TARGET_NR_swapon:\n\n        ret = get_errno(swapon((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap:\n\n        {\n\n            uint32_t v1, v2, v3, v4, v5, v6, *vptr;\n\n            vptr = (uint32_t *)arg1;\n\n            v1 = tswap32(vptr[0]);\n\n            v2 = tswap32(vptr[1]);\n\n            v3 = tswap32(vptr[2]);\n\n            v4 = tswap32(vptr[3]);\n\n            v5 = tswap32(vptr[4]);\n\n            v6 = tswap32(vptr[5]);\n\n            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap2:\n\n#else\n\n    case TARGET_NR_mmap:\n\n#endif\n\n        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));\n\n        break;\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(munmap((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_truncate:\n\n        ret = get_errno(truncate((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n    case TARGET_NR_statfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_statfs((const char *)arg1, stfs));\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            tswap32s(&stfs->f_type);\n\n            tswap32s(&stfs->f_bsize);\n\n            tswap32s(&stfs->f_blocks);\n\n            tswap32s(&stfs->f_bfree);\n\n            tswap32s(&stfs->f_bavail);\n\n            tswap32s(&stfs->f_files);\n\n            tswap32s(&stfs->f_ffree);\n\n            tswap32s(&stfs->f_fsid.val[0]);\n\n            tswap32s(&stfs->f_fsid.val[1]);\n\n            tswap32s(&stfs->f_namelen);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_fstatfs(arg1, stfs));\n\n        goto convert_statfs;\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, (long *)arg2);\n\n        break;\n\n    case TARGET_NR_syslog:\n\n        goto unimplemented;\n\n    case TARGET_NR_setitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_getitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_stat:\n\n        ret = get_errno(stat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        ret = get_errno(lstat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st = (void *)arg2;\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->st_atime = tswapl(st.st_atime);\n\n                target_st->st_mtime = tswapl(st.st_mtime);\n\n                target_st->st_ctime = tswapl(st.st_ctime);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long *status_ptr = (void *)arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            struct target_rusage *target_rusage = (void *)arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    *status_ptr = tswap32(status);\n\n                if (target_rusage) {\n\n                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);\n\n                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);\n\n                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);\n\n                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);\n\n                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);\n\n                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);\n\n                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);\n\n                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);\n\n                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);\n\n                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);\n\n                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);\n\n                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);\n\n                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);\n\n                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);\n\n                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);\n\n                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);\n\n                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);\n\n                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_swapoff:\n\n        ret = get_errno(swapoff((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_sysinfo:\n\n        goto unimplemented;\n\n    case TARGET_NR_ipc:\n\n        goto unimplemented;\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_sigreturn:\n\n        goto unimplemented;\n\n    case TARGET_NR_clone:\n\n        goto unimplemented;\n\n    case TARGET_NR_setdomainname:\n\n        ret = get_errno(setdomainname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        ret = get_errno(sys_uname((struct new_utsname *)arg1));\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));\n\n        break;\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;\n\n            \n\n            switch(how) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -EINVAL;\n\n                goto fail;\n\n            }\n\n            \n\n            if (pset) {\n\n                target_to_host_old_sigset(&set, pset);\n\n                set_ptr = &set;\n\n            } else {\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && poldset) {\n\n                host_to_target_old_sigset(poldset, &oldset);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_create_module:\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n    case TARGET_NR_get_kernel_syms:\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsuid:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsgid:\n\n        goto unimplemented;\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            *(int64_t *)arg4 = tswap64(res);\n\n        }\n\n        break;\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n#error not supported\n\n#endif\n\n        {\n\n            struct dirent *dirp = (void *)arg2;\n\n            long count = arg3;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = tswap16(de->d_reclen);\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = reclen;\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, \n\n                        (void *)arg5);\n\n        break;\n\n    case TARGET_NR_flock:\n\n        goto unimplemented;\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(readv(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(writev(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n    case TARGET_NR_fdatasync:\n\n        goto unimplemented;\n\n    case TARGET_NR__sysctl:\n\n        goto unimplemented;\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_setscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n    case TARGET_NR_sched_get_priority_min:\n\n    case TARGET_NR_sched_rr_get_interval:\n\n    case TARGET_NR_nanosleep:\n\n    case TARGET_NR_mremap:\n\n    case TARGET_NR_setresuid:\n\n    case TARGET_NR_getresuid:\n\n    case TARGET_NR_vm86:\n\n    case TARGET_NR_query_module:\n\n    case TARGET_NR_poll:\n\n    case TARGET_NR_nfsservctl:\n\n    case TARGET_NR_setresgid:\n\n    case TARGET_NR_getresgid:\n\n    case TARGET_NR_prctl:\n\n    case TARGET_NR_rt_sigreturn:\n\n    case TARGET_NR_rt_sigaction:\n\n    case TARGET_NR_rt_sigprocmask:\n\n    case TARGET_NR_rt_sigpending:\n\n    case TARGET_NR_rt_sigtimedwait:\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n    case TARGET_NR_rt_sigsuspend:\n\n    case TARGET_NR_pread:\n\n    case TARGET_NR_pwrite:\n\n        goto unimplemented;\n\n    case TARGET_NR_chown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getcwd:\n\n        ret = get_errno(sys_getcwd1((char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_capget:\n\n    case TARGET_NR_capset:\n\n    case TARGET_NR_sigaltstack:\n\n    case TARGET_NR_sendfile:\n\n    case TARGET_NR_getpmsg:\n\n    case TARGET_NR_putpmsg:\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(vfork());\n\n        break;\n\n    case TARGET_NR_ugetrlimit:\n\n    case TARGET_NR_truncate64:\n\n    case TARGET_NR_ftruncate64:\n\n    case TARGET_NR_stat64:\n\n    case TARGET_NR_lstat64:\n\n    case TARGET_NR_fstat64:\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n", "idx": 14289, "substitutes": {"cpu_env": ["pu_path", "cpu_ext", "cpu2path", "pu_info", "cpu2ext", "cpu2env", "cpu_info", "pu_env", "cpu2info", "cpu_path", "pu_ext"], "num": ["sync", "um", "test", "temp", "multi", "thread", "nam", "param", "loop", "count", "con", "command", "fn", "cmd", "integ", "timeout", "counter", "Num", "NUM", "valid", "dim", "unit", "fun", "proc", "method", "reg", "block", "n", "np", "nb", "init", "node", "current", "no", "off", "type", "gnu", "begin", "nu", "gen", "name", "out", "msg", "nm", "loc", "sum", "len", "number", "code"], "arg1": [" argn", "args1", " arg0", "Arg10", "arg10", "erg31", "args0", " arg31", "args3", " arg01", "argument01", "axone", "ag2", "ar4", "argument2", "Arg5", "args6", "ag0", "erg2", "inc3", "inc4", "ax6", " arg10", "Argn", "arg91", "argn", "argumentn", "argument6", "inc1", "ig2", "args2", "ag6", "Arg91", "mag1", "mag2", " arg91", "ig10", "arg01", "argument3", "Arg0", "ar2", "ig3", "ag1", "Arg1", "arg0", "ar3", "ig1", "argumentone", "Arg2", "inc2", "argone", "Arg3", "Arg4", "arg31", "ar0", "args4", "ax5", "Arg31", "mag91", "ax1", "ax2", " argone", "erg1", "argument1", "ar1", "Arg01"], "arg2": ["argument52", "Arg6", "ax6", "Arg02", "item4", "ar2", "arg42", "ax1", "ax4", "Arg1", "ar3", "argument42", "ax2", "item2", "argument5", "Arg2", "item42", "argument1", "ark02", "ark2", "Arg42", "item5", " arg02", "ark4", "ark1", "Arg3", "ar1", "arg52", "ar4", "Arg4", "argument2", " arg52", "Arg5", "arg02", "argument4", "Arg52"], "arg3": ["Arg6", "argument3", "ar2", "ar6", "Arg1", "ar3", "argument5", "Arg2", "argument1", "argument6", "Arg3", "ar1", "ar4", "Arg4", "argument2", "Arg5", "argument4"], "arg4": ["argument3", "argument2", "args4", "args2", "args5", "args3", "argument4", "argument5"], "arg5": ["ar4", "args4", "args2", "args5", "ar3", "args3", "ar5", "ar2"], "arg6": ["arg7", "args8", "ax7", "args7", "doc8", "doc7", "args5", "ax5", "arg8", "doc5", "args6", "doc6", "ax8", "ax6"], "ret": ["en", "gt", "ft", "success", "data", "nt", "resp", "repl", "ll", "match", "result", "obj", "ut", "format", "rt", "expr", "att", "val", "alt", "def", "job", "db", "det", "reply", "str", "fun", "error", "rc", "url", "reg", "rets", "arg", "id", "rev", "mem", "mt", "sg", "ext", " result", "cat", "lit", "let", "lv", "re", "RET", "flag", "red", "get", "std", "rl", "err", "back", "bit", "value", "rg", "pass", "r", "ref", "conn", "len", "Ret"], "st": ["ST", "bl", "vm", "ust", "istic", "nt", "sc", "St", "store", "rest", "ss", "inst", "sf", "sn", "sts", "est", "mt", "x", "ast", "sl", "ist", "sb", "ost", "std", "t", "stack"], "stfs": ["snfn", "sthfd", "sthfn", "ostfn", "stfn", "ostfs", "sthfs", "ostFS", "stFS", "ostfd", "sthFS", "snfs", "stfd", "snFS", "snfd"], "status": ["update", "serv", "d", "step", "success", "temp", "data", "uses", "source", "STAT", "speed", "result", "size", "job", "si", "y", "Status", "service", "sp", "state", "str", "sec", "error", "comment", "fps", "class", "progress", "id", "spec", "version", "stats", "complete", "stage", "date", "info", "active", "s", "type", "ex", "index", "wait", "warning", "start", "name", "flags", "msg", "flag", "stat", "security", "code"]}}
{"project": "qemu", "commit_id": "f80ac75d0e6e6e7481d61cdb86e5a741a442f100", "target": 1, "func": "static int rebuild_refcount_structure(BlockDriverState *bs,\n\n                                      BdrvCheckResult *res,\n\n                                      void **refcount_table,\n\n                                      int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;\n\n    int64_t refblock_offset, refblock_start, refblock_index;\n\n    uint32_t reftable_size = 0;\n\n    uint64_t *on_disk_reftable = NULL;\n\n    void *on_disk_refblock;\n\n    int ret = 0;\n\n    struct {\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED reftable_offset_and_clusters;\n\n\n\n    qcow2_cache_empty(bs, s->refcount_block_cache);\n\n\n\nwrite_refblocks:\n\n    for (; cluster < *nb_clusters; cluster++) {\n\n        if (!s->get_refcount(*refcount_table, cluster)) {\n\n            continue;\n\n        }\n\n\n\n        refblock_index = cluster >> s->refcount_block_bits;\n\n        refblock_start = refblock_index << s->refcount_block_bits;\n\n\n\n        /* Don't allocate a cluster in a refblock already written to disk */\n\n        if (first_free_cluster < refblock_start) {\n\n            first_free_cluster = refblock_start;\n\n        }\n\n        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,\n\n                                              nb_clusters, &first_free_cluster);\n\n        if (refblock_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating refblock: %s\\n\",\n\n                    strerror(-refblock_offset));\n\n            res->check_errors++;\n\n            ret = refblock_offset;\n\n            goto fail;\n\n        }\n\n\n\n        if (reftable_size <= refblock_index) {\n\n            uint32_t old_reftable_size = reftable_size;\n\n            uint64_t *new_on_disk_reftable;\n\n\n\n            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),\n\n                                     s->cluster_size) / sizeof(uint64_t);\n\n            new_on_disk_reftable = g_try_realloc(on_disk_reftable,\n\n                                                 reftable_size *\n\n                                                 sizeof(uint64_t));\n\n            if (!new_on_disk_reftable) {\n\n                res->check_errors++;\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n            on_disk_reftable = new_on_disk_reftable;\n\n\n\n            memset(on_disk_reftable + old_reftable_size, 0,\n\n                   (reftable_size - old_reftable_size) * sizeof(uint64_t));\n\n\n\n            /* The offset we have for the reftable is now no longer valid;\n\n             * this will leak that range, but we can easily fix that by running\n\n             * a leak-fixing check after this rebuild operation */\n\n            reftable_offset = -1;\n\n        }\n\n        on_disk_reftable[refblock_index] = refblock_offset;\n\n\n\n        /* If this is apparently the last refblock (for now), try to squeeze the\n\n         * reftable in */\n\n        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&\n\n            reftable_offset < 0)\n\n        {\n\n            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *\n\n                                                          sizeof(uint64_t));\n\n            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                                  refcount_table, nb_clusters,\n\n                                                  &first_free_cluster);\n\n            if (reftable_offset < 0) {\n\n                fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                        strerror(-reftable_offset));\n\n                res->check_errors++;\n\n                ret = reftable_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,\n\n                                            s->cluster_size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* The size of *refcount_table is always cluster-aligned, therefore the\n\n         * write operation will not overflow */\n\n        on_disk_refblock = (void *)((char *) *refcount_table +\n\n                                    refblock_index * s->cluster_size);\n\n\n\n        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,\n\n                         on_disk_refblock, s->cluster_sectors);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* Go to the end of this refblock */\n\n        cluster = refblock_start + s->refcount_block_size - 1;\n\n    }\n\n\n\n    if (reftable_offset < 0) {\n\n        uint64_t post_refblock_start, reftable_clusters;\n\n\n\n        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);\n\n        reftable_clusters = size_to_clusters(s,\n\n                                             reftable_size * sizeof(uint64_t));\n\n        /* Not pretty but simple */\n\n        if (first_free_cluster < post_refblock_start) {\n\n            first_free_cluster = post_refblock_start;\n\n        }\n\n        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                              refcount_table, nb_clusters,\n\n                                              &first_free_cluster);\n\n        if (reftable_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                    strerror(-reftable_offset));\n\n            res->check_errors++;\n\n            ret = reftable_offset;\n\n            goto fail;\n\n        }\n\n\n\n        goto write_refblocks;\n\n    }\n\n\n\n    assert(on_disk_reftable);\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        cpu_to_be64s(&on_disk_reftable[refblock_index]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n", "idx": 14300, "substitutes": {"bs": ["ps", "fs", "ins", "bl", "bas", "cs", "sa", "bc", "ts", "base", "abi", "ds", "bes", "ob", "ss", "db", "bos", "BS", "gs", "lb", "plugins", "obs", "bh", "ubs", "rb", "ks", "fps", "os", "iss", "bi", "bits", "vs", "bytes", "ns", "bb", "bps", "b", "src", "sb", "ses", "js", "gb", "banks", "ls", "lbs", "bis", "bid", "pb", "css"], "res": ["ps", "fs", "rs", "Res", "resp", "results", "ras", "cs", "result", "sys", "ons", "rows", "ress", "response", "resolution", "proc", "reg", "ros", "pers", "os", "rev", "ray", "rss", "pres", "req", "ex", "mr", "vals", "re", "des", "RES", "js", "rez", "err", "r", "ret", "gr", "rem", "rus"], "refcount_table": ["refcountttree", "refcountercache", "refcountscache", "refallPtree", "refcount2session", "refallPwindow", "refcount_session", "refcountPtree", "refcount_window", "refallPtable", "refall_tree", "refcount_tree", "refcount2table", "refCount2table", "refcount__total", "refcount__session", "refCount_table", "refcounttwindow", "refall_table", "refcountPsequence", "refall_window", "refall_sequence", "refCount2total", "refcountPwindow", "refcount__table", "refcountsTABLE", "refCount_session", "refallPsequence", "refCount2session", "refcount_cache", "refcount2total", "refcounttsequence", "refcountstable", "refcount_total", "refcountPtable", "refcount_TABLE", "refcountttable", "refcounterheader", "refCount_total", "refcount_sequence", "refcountertable", "refcountsheader", "refcount_header", "refcounterTABLE"], "nb_clusters": ["nb_bluster", "nb_players", "nb_blonents", "nb_clayers", "nb_blusters", "nb_custers", "nb_clicas", "nb_plients", "nb_Clusters", "nb_plicas", "nb_pluster", "nb_cluster", "nb_lients", "nb_Clayers", "nb_plashes", "nb_layers", "nb_codes", "nb_blients", "nb_licas", "nb_Clients", "nb_custer", "nb_sclusters", "nb_sclonents", "nb_plusters", "nb_cashes", "nb_lusters", "nb_pliques", "nb_plodes", "nb_scliques", "nb_clients", "nb_Clicas", "nb_cliques", "nb_clashes", "nb_plonents", "nb_sclients", "nb_clonents", "nb_blodes", "nb_clodes", "nb_blashes", "nb_bliques"], "s": ["ps", "hs", "fs", "sync", "sv", "session", "ins", "sites", "rs", "site", "secondary", "cs", "sa", "ts", "outs", "features", "parts", "server", "ds", "states", "sys", "si", "ss", "service", "ssl", "space", "state", "ims", "gs", "xs", "es", "self", "os", "spec", "details", "iss", "ess", "stats", "is", "c", "http", "args", "sg", "p", "ns", "qs", "tests", "b", "sl", "sets", "lines", "aws", "sie", "ses", "js", "settings", "ls", "services", "sym", "S", "r", "bis", "words", "ops"], "refblock_offset": ["refblock8offset", "refoff_error", "refblock0error", "refblock_padding", "refblock_alpha", "refrow_start", "refblock2offset", "refcol8alpha", "refoff0size", "refblocks_offset", "refblocks_index", "refblock_Offset", "refoff_size", "refblock8location", "refblock0index", "refoff0error", "refblock0offset", "refcol8location", "refblock_location", "refoff_index", "refblocks_set", "refblock0size", "refcol8offset", "refoff_offset", "refblock_error", "refblock00padding", "refblock8alpha", "refcol_offset", "refblock2index", "refcol_location", "refblock00location", "refblock00alpha", "refblock2addr", "refblock2set", "refblock_addr", "refblock8padding", "refcol8padding", "refblock_set", "refblock00offset", "refoff0index", "refcol_alpha", "refrow_offset", "refblocks_addr", "refrow_Offset", "refcol_padding", "refoff0offset", "refblock_size"], "refblock_start": ["refblock__start", "refblock__get", "refblock67address", "refblock_pad", "refblock_id", "refBlock_origin", "refblock__align", "refblock__offset", "refBlock_start", "refblock__id", "refBlock_address", "refblock_address", "refblock00align", "refBlock_offset", "refblockingstart", "refblockCindex", "refBlock_end", "refblockCid", "refblock67origin", "refblock00origin", "refblock67index", "refBlock_pad", "refblockCget", "refBlock_index", "refblockAoffset", "refblockCstart", "refblock67start", "refblockingaddress", "refblock__index", "refblock_origin", "refblock00offset", "refblockingorigin", "refblock_end", "refblockApad", "refblock__origin", "refblockAend", "refblock_align", "refblock00start", "refblockAstart", "refblock_get", "refblockingindex"], "refblock_index": ["refsectionerend", "refblock__start", "refblock2offset", "reflock_range", "reflock0index", "refblockerstart", "refoff__end", "refblock2size", "refblockCrange", "refblock0index", "refblockCoffset", "reflock_offset", "refsection_inc", "refblock__end", "refoff_index", "refblockerend", "reflock_index", "refoff__ind", "refblock_inc", "refsectionerinc", "refblockCindex", "refblock0size", "reflock0size", "refoff_end", "refsectionerstart", "reflock_number", "refblock__ind", "refblock2index", "reflock_size", "refsection_end", "refblock_ind", "refblock2ind", "refblock__index", "refblockCnumber", "refblockerindex", "refblock0start", "refblock_end", "refoff__index", "reflock_start", "refblockerinc", "refsectionerindex", "reflock0start", "refsection_start", "refoff__start", "refblock_range", "refoff_start", "refblock_size", "refblock_number", "refoff_ind", "refsection_index"], "on_disk_reftable": ["on_disk_reftible", "on_disk_reveror", "on_disk_recoveree", "on_disk_rectable", "on_disk_breftor", "on_disk_breftable", "on_disk_reftor", "on_disk_rector", "on_disk_breverable", "on_disk_reftee", "on_disk_recoverable", "on_disk_breverible", "on_disk_recoveror", "on_disk_reveree", "on_disk_reverible", "on_disk_rectible", "on_disk_breveree", "on_disk_rectee", "on_disk_recoverible", "on_disk_reverable", "on_disk_breftee", "on_disk_breftible", "on_disk_breveror"], "on_disk_refblock": ["on_disk_relcount", "on_disk_refcache", "on_disk_referencecount", "on_disk_refcount", "on_disk_referenceblock", "on_disk_relblock", "on_disk_relcache", "on_disk_referencecache"], "QEMU_PACKED": ["QEMU_PADDed", "QEMU_POWERED", "QEMU_PADDES", "QEMU_Packeded", "QEMU_PACK32", "QEMU_POWERed", "QEMU_Packed32", "QEMU_PUACKES", "QEMU_PUACKED", "QEMU_PADDED", "QEMU_POWERES", "QEMU_PACKed", "QEMU_PUACKed", "QEMU_PUADDES", "QEMU_PUADDED", "QEMU_PADD32", "QEMU_PUACK32", "QEMU_PackedES", "QEMU_PUADDed", "QEMU_PUADD32", "QEMU_POWER32", "QEMU_PACKES", "QEMU_PackedED"], "cluster": ["scluster", " clust", "CLuster", "compuster", "cluration", " clard", "slore", " clause", "clard", "blause", "blore", "compust", "chause", "sluration", "blaco", "blard", "chuster", "blocate", "CLocate", "sclause", "clust", "blust", "claco", "slust", "composer", "clocate", "cancer", "bluster", "choser", "slancer", " clore", "coser", "bluration", "slaco", "scloser", "clusters", "sluster", " claco", "compause", "bloser", "sclust", "CLusters", "blusters", "slocate", "sloser", "slard", "cause", "slause", "clause", "clancer", "CLause", "closer", "custer", " cluration", "slusters", "clore", "chancer"], "check_errors": ["block_runs", "checkingfailed", "checkingerrors", "checkallfailed", "block_error", "check_failed", "checkallerror", "block_failed", "block_errors", "checkingerror", "check_runs", "checkingruns", "checkallerrors", "check_error", "checkallruns"], "new_on_disk_reftable": ["new_on_disk_reaftabe", "new_on_disk_precoverable", "new_on_disk_breffor", "new_on_disk_refttable", "new_on_disk_rectible", "new_on_disk_reffible", "new_on_disk_recovering", "new_on_disk_breffable", "new_on_disk_brefting", "new_on_disk_reftible", "new_on_disk_prefttable", "new_on_disk_precoverabe", "new_on_disk_rectable", "new_on_disk_reverable", "new_on_disk_reftor", "new_on_disk_reverible", "new_on_disk_breffing", "new_on_disk_reftabe", "new_on_disk_reffable", "new_on_disk_reffing", "new_on_disk_revering", "new_on_disk_precovering", "new_on_disk_reverabe", "new_on_disk_breftor", "new_on_disk_preftable", "new_on_disk_breftable", "new_on_disk_reafting", "new_on_disk_recoverable", "new_on_disk_breffible", "new_on_disk_reffor", "new_on_disk_recovertable", "new_on_disk_recoverabe", "new_on_disk_reaftable", "new_on_disk_precovertable", "new_on_disk_preftabe", "new_on_disk_reveror", "new_on_disk_rector", "new_on_disk_refting", "new_on_disk_prefting", "new_on_disk_breftible", "new_on_disk_reafttable", "new_on_disk_revertable", "new_on_disk_recting"], "reftable_clusters": ["reftable_clicas", "reftable_lusters", "reftable_sclores", "reftable_los", "reftable_plicas", "reftable_plusters", "reftable_sclicas", "reftable_sclusters", "reftable_licas", "reftable_plos", "reftable_sclos", "reftable_clores", "reftable_clos", "reftable_lores", "reftable_plores"]}}
{"project": "FFmpeg", "commit_id": "f1ffb01ee9fd3a15c395c3cf6ff362ac5cd668d0", "target": 0, "func": "static int synchronize_audio(VideoState *is, short *samples,\n\n                             int samples_size1, double pts)\n\n{\n\n    int n, samples_size;\n\n    double ref_clock;\n\n\n\n    n = 2 * is->audio_st->codec->channels;\n\n    samples_size = samples_size1;\n\n\n\n    /* if not master, then we try to remove or add samples to correct the clock */\n\n    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||\n\n         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {\n\n        double diff, avg_diff;\n\n        int wanted_size, min_size, max_size, nb_samples;\n\n\n\n        ref_clock = get_master_clock(is);\n\n        diff = get_audio_clock(is) - ref_clock;\n\n\n\n        if (diff < AV_NOSYNC_THRESHOLD) {\n\n            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;\n\n            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {\n\n                /* not enough measures to have a correct estimate */\n\n                is->audio_diff_avg_count++;\n\n            } else {\n\n                /* estimate the A-V difference */\n\n                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);\n\n\n\n                if (fabs(avg_diff) >= is->audio_diff_threshold) {\n\n                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);\n\n                    nb_samples = samples_size / n;\n\n\n\n                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    if (wanted_size < min_size)\n\n                        wanted_size = min_size;\n\n                    else if (wanted_size > max_size)\n\n                        wanted_size = max_size;\n\n\n\n                    /* add or remove samples to correction the synchro */\n\n                    if (wanted_size < samples_size) {\n\n                        /* remove samples */\n\n                        samples_size = wanted_size;\n\n                    } else if (wanted_size > samples_size) {\n\n                        uint8_t *samples_end, *q;\n\n                        int nb;\n\n\n\n                        /* add samples */\n\n                        nb = (samples_size - wanted_size);\n\n                        samples_end = (uint8_t *)samples + samples_size - n;\n\n                        q = samples_end + n;\n\n                        while (nb > 0) {\n\n                            memcpy(q, samples_end, n);\n\n                            q += n;\n\n                            nb -= n;\n\n                        }\n\n                        samples_size = wanted_size;\n\n                    }\n\n                }\n\n                av_dlog(NULL, \"diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\\n\",\n\n                        diff, avg_diff, samples_size - samples_size1,\n\n                        is->audio_clock, is->video_clock, is->audio_diff_threshold);\n\n            }\n\n        } else {\n\n            /* too big difference : may be initial PTS errors, so\n\n               reset A-V filter */\n\n            is->audio_diff_avg_count = 0;\n\n            is->audio_diff_cum       = 0;\n\n        }\n\n    }\n\n\n\n    return samples_size;\n\n}\n", "idx": 14306, "substitutes": {"is": ["it", "ois", "its", "si", "in", "ui", "init", "bits", "i", "esi", "isc", "ic", "as", "js", "ics", "or", "ais", "IS", "ii", "cms", "serv", "fs", "ie", "kit", "sil", "parts", "play", "Is", "lis", "inst", "osi", "iv", "id", "iss", "ip", "ists", "iris", "ri", "ist", "series", "sie", "sis", "ori", "bis", "us", "im", "nis", "isin", "does", "isl", "ai", "mis", "state", "obs", "are", "ils", "iso", "isu", "ses", "ms", "get", "ris", "ops", "op", "isi", "irc", "oss", "isa", "bs", "es", "os", "ci", "ish", "info", "s", "has", "ls", "css"], "samples": ["sesannels", "Sips", "Samps", "sesips", "sips", "Sannels", " sannels", " sips", "sesamps", "Samples", "samps", " samps", "sesamples", "sannels"], "samples_size1": ["samples_form1", "samples_size01", "samples_form2", "samples_mode01", "samples_size2", "samples_form01", "samples_scale1", "samples_mode1", "samples_scale01", "samples_scale2", "samples_mode2", "samples_unit1"], "pts": ["ptsi", "mindsi", "minds", "ptsf", "indsf", "inds", "putsi", "mindS", "ptS", "indsi", "mindsf", "putS", "indS", "putsf"], "n": ["adj", "d", "ne", "o", "en", "nn", "cn", "pn", " N", "v", "count", "e", "nc", "u", "fn", "network", "l", "conn", "size", "y", "an", "m", "sn", "dn", "num", "g", "un", "z", "net", "k", "np", "N", "c", "i", "x", "ns", "p", "s", "b", "nu", "ni", "f", "name", "min", "w", "j", "nw", "nl", "t", "len", "span", "norm"], "samples_size": ["samples_count", "summies_edge", "sourses0type", "sourses_sized", "samples__size", "samples___weight", "samples___sum", "samples__width", "sourses_size", "samples_ize", "samples0type", "samples0center", "sample_ize", "samplesallcount", "summiesalledge", "sourses_center", "summies_size", "samples_width", "sourses0center", "samplesetsize", "samples128type", "samplesetize", "samples0size", "samples_member", "samplesetarea", "sample_size", "samples_center", "sourses0size", "samplesallscale", "sampleetsize", "samples_weight", "summiesallsize", "samples__ize", "samples___scale", "sourses0sized", "samples___capacity", "samples_capacity", "samplesetsized", "samplesallsize", "summiesallcount", "summies_scale", "samples___size", "samples0sized", "samples_edge", "sampleetsized", "sourses_type", "summies_count", "samples_sum", "samples128size", "sampleslexmember", "sampleetarea", "sampleslexwidth", "samples_length", "sampleetize", "samples_type", "samples_area", "samples__member", "samples128center", "samples_sized", "samples128sized", "sampleslexsize", "sampleslexize", "sample_area", "samples_scale", "sample_sized", "summiesallscale", "samplesalledge", "samples___sized"], "ref_clock": ["ref01Clock", "refxround", "ref_lock", "ref67Clock", "ref_round", " reference_balance", " referencexclock", "ref_balance", "ref67lock", "ref01error", " ref_Clock", "refurebalance", " ref_lock", " referencexround", " ref_charge", "refxbalance", "ref01lock", "ref01clock", "ref_error", "ref67charge", " reference_round", "ref_charge", "refureclock", " ref_error", "ref_Clock", "refureround", " referencexbalance", "ref67clock", "refxclock", " reference_clock"], "diff": ["update", "fail", "part", "d", "bug", "test", "frac", "shift", "flow", "iff", "data", "distance", " difference", "md", "dist", "count", "dir", "fe", "message", "sum", "desc", "l", "Diff", "length", "dust", "cd", "def", "cmp", "mix", "different", "comment", "error", "scale", "df", "progress", "low", " differences", "change", "dev", "version", "between", "i", "changed", "info", "range", " delta", "f", "min", "err", "transfer", "alpha", "ref", "conf", "none", "comp"], "avg_diff": ["avrg_cmp", "avgen_dist", "avgin67diff", "avgin67length", "avg_cmp", "avgin67scale", "avg67comp", "avgin_scale", "avg_different", "avrg_diff", "avg67diff", "avrg_comp", "avrg_different", "avg_dist", "avg_message", "avgin_diff", "avg_comp", "avgen_comp", "avgin_message", "avg_length", "avg_field", "avg67message", "avg67field", "avgen_field", "avg67scale", "avgin67message", "avg67dist", "avgin_length", "avgen_diff", "avg_scale", "avg67length"], "wanted_size": ["wanting_ize", "want_speed", "wanting_code", "watched_size", "wanted64size", "wanted_code", "wanted67mode", "wanted67size", "want_name", "wanted_num", "wanted_speed", "watched_capacity", "want_Size", "wanted_name", "wanted64scale", "watched_ize", "want_sized", "woded_length", "wanted_Size", "want_size", "wanting_scale", "wanted67scale", "wanted_length", "wanted_mode", "wanted64speed", "woded_size", "wanted_lane", "wanted_capacity", "wanted64sized", "wanted_ize", "woded_scale", "wanting_size", "want_lane", "wanting_capacity", "wanted64length", "wanted64num", "wanted_sized", "wanted67ize", "wanted_time", "want_scale", "want_time", "wanted64ize", "wanted_left", "woded_num", "want_ize", "watched_speed", "wanting_left", "wanted_scale", "want_mode"], "min_size": ["min_grow", "int_core", "minfcore", "min_mini", "int_size", "minflarge", "min_speed", " min_speed", "int_large", "min64source", " min_mini", "minimum_rate", "min_large", "minqarea", " min_course", "min64size", "min_core", "min_length", "min_source", "minallsize", "minfsize", "minimum_size", "min64mini", "min\u00b7rate", "min48speed", "minallarea", "min_small", "minqsize", "min48length", "min_course", "minqgrow", "minimum_grow", "minallrate", "minimum\u00b7area", "min64speed", "minallgrow", "minimum_area", "minqrate", "min\u00b7grow", "minimum\u00b7rate", "min48course", "min\u00b7area", "min_area", "minimum\u00b7grow", "min\u00b7size", "int_small", "min_rate", "minfsmall", "min48size", " min_source", "minimum\u00b7size", " min_length"], "max_size": ["az_uri", "max00scale", "max_source", " max_large", "max\u00b7strength", "maxacsource", "max_strength", " max_cache", "max_cache", "maxmscale", "maxacsize", "maxfullshape", "max_large", "max00large", "maxfullhandle", "maxenshape", "az_size", "maxacuri", "breakfullsize", "max00cache", " max_handle", "maxmhandle", "maxingscale", "maxingsize", "max\u00b7size", "max_depth", "max_scale", "max_score", "break_strength", "breakfullstrength", " max_depth", "maxfullscale", "maxensize", "break_shape", "maxfullstrength", "break_size", "max00size", "maxingcache", "maxmsize", "maxfullsize", "breakfullshape", "maxfullscore", "break_score", "max\u00b7shape", "max\u00b7score", "max_uri", "maxinglarge", "max_shape", "maxfulldepth", "maxenstrength", " max_scale", "breakfullscore", "az_source", "maxmdepth", "maxenscore", "max_handle"], "nb_samples": ["nb_siments", "nb_namples", "nb_sesanguages", "nb_sanguages", "nb_tamples", "nb_gamps", "nb_namps", "nb67tesiments", "nb_filesamples", "nb_filesimens", "nb_bources", "nb67tesacters", "nb_sviments", "nb_sources", "nb_simens", "nb_sidores", "nb_sesamples", "nb_bamples", "nb_filesannels", "nb_sidample", "nb_bides", "nb_filesamps", "nb_servicesamples", "nb67tesplings", "nb_tesamples", "nb_tample", "nb_tamps", "nb_tesplings", "nb67siments", "nb67sacters", "nb_sesources", "nb_tesacters", "nb_testsimens", "nb_svamples", "nb_samps", "nb_stides", "nb_gamples", "nb67tesamples", "nb_testsamples", "nb_sores", "nb_sample", "nb67splings", "nb_svplings", "nb_testsamps", "nb_nannels", "nb_tores", "nb_testsannels", "nb_sesides", "nb_stources", "nb_stanguages", "nb_sannels", "nb_servicesiments", "nb_sacters", "nb67samples", "nb_gample", "nb_sidamples", "nb_sides", "nb_svacters", "nb_sidamps", "nb_splings", "nb_servicesplings", "nb_gores", "nb_tesiments", "nb_servicesacters", "nb_nimens", "nb_banguages", "nb_stamples"], "audio_diff_avg_count": ["audio_diff_avg_diff", "audio_diff_avG_c", "audio_diff_avG_count", "audio_diff_avG_sum", "audio_diff_avg_cache", "audio_diff_avg_sum", "audio_diff_avG_cache", "audio_diff_avG_diff", "audio_diff_avg_c"]}}
{"project": "FFmpeg", "commit_id": "a82468514048fb87d9bf38689866bc3b9aaccd02", "target": 1, "func": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n\n                               int is_indeo4)\n\n{\n\n    int p, b;\n\n    uint32_t b_width, b_height, align_fac, width_aligned,\n\n             height_aligned, buf_size;\n\n    IVIBandDesc *band;\n\n\n\n    ivi_free_buffers(planes);\n\n\n\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* fill in the descriptor of the luminance plane */\n\n    planes[0].width     = cfg->pic_width;\n\n    planes[0].height    = cfg->pic_height;\n\n    planes[0].num_bands = cfg->luma_bands;\n\n\n\n    /* fill in the descriptors of the chrominance planes */\n\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n\n        if (!planes[p].bands)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* select band dimensions: if there is only one band then it\n\n         *  has the full size, if there are several bands each of them\n\n         *  has only half size */\n\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n\n                                            : (planes[p].width  + 1) >> 1;\n\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n\n                                            : (planes[p].height + 1) >> 1;\n\n\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n\n        align_fac       = p ? 8 : 16;\n\n        width_aligned   = FFALIGN(b_width , align_fac);\n\n        height_aligned  = FFALIGN(b_height, align_fac);\n\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n\n            band->plane    = p;\n\n            band->band_num = b;\n\n            band->width    = b_width;\n\n            band->height   = b_height;\n\n            band->pitch    = width_aligned;\n\n            band->aheight  = height_aligned;\n\n            band->bufs[0]  = av_mallocz(buf_size);\n\n            band->bufs[1]  = av_mallocz(buf_size);\n\n            band->bufsize  = buf_size/2;\n\n            if (!band->bufs[0] || !band->bufs[1])\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* allocate the 3rd band buffer for scalability mode */\n\n            if (cfg->luma_bands > 1) {\n\n                band->bufs[2] = av_mallocz(buf_size);\n\n                if (!band->bufs[2])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            if (is_indeo4) {\n\n                band->bufs[3]  = av_mallocz(buf_size);\n\n                if (!band->bufs[3])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            /* reset custom vlc */\n\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14308, "substitutes": {"planes": ["ps", "flows", "codes", "cats", "cycles", "workers", "players", "files", "plane", "ports", "lights", "drivers", "scenes", "rules", "lists", "photos", "users", "thumbnails", "features", "parts", "liners", "docs", "states", "weights", "models", "rows", "types", "balls", "links", "pins", "cards", "limits", "cases", "images", "devices", "plugins", "config", "birds", "plates", "flat", "reports", "pages", "stats", "bits", "tests", "cells", "qs", "pieces", "bags", "lines", "views", "frames", "works", "flags", "classes", "cuts", "groups", "forms", "settings", "banks", "levels", "bands", "services", "maps", "powers", "rates", "words", "ops"], "cfg": ["gate", "storage", "cons", "gi", "plane", "img", "ini", "cgi", "alg", "fi", "umi", "iana", "ng", "ugi", "git", "cm", "sc", "nc", "bc", "sci", "fg", "cmd", "cf", "conn", "fab", "cb", "gc", "mag", "eng", "fle", "ga", "gui", "ig", "dc", "gov", "gs", "cdn", "lc", "config", "cca", "g", "gin", "ea", "org", "comm", "ci", "np", "ctx", "init", "sg", "ext", "cli", "core", "oga", "cy", "gg", "ni", "gen", "mc", "msg", "ca", "gp", "loader", "settings", "gb", "fine", "rg", "ii", "gd", "conf", "lag", "gn", "css"], "is_indeo4": ["is_indie256", "is_indie0", "is_indee4", "is_inded4", "is_indeo256", "is_indeos0", "is_indee256", "is_indio256", "is_indio4", "is_indeos4", "is_indee0", "is_indeos256", "is_indio0", "is_inded256", "is_inded0", "is_indie4", "is_indeo0"], "p": ["fp", "pe", "tp", "v", "patch", "per", "pos", "u", "ap", "pi", "m", "api", "pu", "up", "n", "np", "i", "h", "pl", "or", "back", "j", "t", "ps", "part", "o", "pn", "po", "e", "pc", "y", "a", "power", "ip", "x", "c", "jp", "l", "P", "pp", "wp", "pid", "pre", "pr", "lp", "bp", "q", "ph", "py", "d", "br", "op", "pt", "pm", "base", "length", "page", "post", "pad", "g", "z", "point", "k", "pa", "cp", "s", "f", "w", "port", "er", "r"], "b": ["body", "part", "d", "bd", "ba", "o", "bl", "v", "bf", "br", "e", "u", "bc", "be", "l", "base", "ib", "wb", "fb", "B", "ob", "bin", "y", "db", "bar", "lb", "a", "bs", "emb", "g", "k", "rb", "n", "boot", "nb", "bi", "c", "bp", "i", "bot", "h", "x", "s", "bb", "lib", "f", "mb", "sb", "ab", "w", "gb", "r", "j", "eb"], "b_width": ["bacweight", "b_w", "bvwm", "b_filename", "bvheight", "b_weight", "boot_weight", "nb_width", "b_strength", "bf_width", "bacdirection", "boot_width", "b_wm", "nb_wm", "nb_w", "bvwidth", "boot_shape", "bf_strength", "b_gender", "bf_gender", "nb_height", "bvw", "boot_direction", "bacshape", "bf_filename", "b_direction", "bacwidth", "b_shape"], "b_height": ["l_width", " b_shape", "b___rank", "b___height", "b_rank", "b___dash", "lb_alpha", "b_volume", "l_height", " b_volume", "l_dash", "lb_pass", "b__shape", "b_pass", "b_depth", "b__depth", " b_depth", "b_alpha", "b___width", "l_rank", "b__height", "lb_height", "b_dash", "b_shape", "b__volume"], "align_fac": ["align2fi", "alignityeff", "alignerfrac", "align67fac", "alignederfam", "align2vol", "alignkFac", "align_format", "align___frac", "qualityityeff", "align_eff", "qualityityfac", "quality_Fac", " align_factor", "quality_fac", "aligned_frac", "align_fi", "align2frac", "align_lat", "align67frac", "align___fam", "aligned_fam", "quality_eff", "qualityityFac", "alignkfac", "quality_format", "align_factor", "align_frac", "align_rac", " alignment_frac", "aligned_lat", "alignerfac", " alignment_vol", "align___rac", " alignment_fi", "align___factor", "aligned_fac", "alignityformat", "align2fac", "align_fam", "align___lat", "align67lat", "align___fac", "align_vol", "qualityityformat", " alignment_fac", "alignkformat", "alignederlat", "alignerlat", "alignederfac", "alignerfam", "alignederfrac", " align_rac", "align67fam", "align_Fac", "alignityFac", "alignityfac", "alignkeff"], "width_aligned": ["h_centered", "width67centered", "width67signed", "url_aligned", "width_centered", "width___centered", "width_signed", "h_signed", "width_identified", "width___aligned", "widthingaligned", "widthingidentified", "h_aligned", "width___signed", "width67aligned", "width___filled", "width_filled", "widthingjoined", "url_available", "h___centered", "h_filled", "width67filled", "url_joined", "width_available", " width_ranged", "h___aligned", " width_signed", "h___signed", "h___filled", "url_identified", "width_joined", "widthingavailable", " width_joined", "width_ranged"], "height_aligned": [" height_ranged", "height64sat", "heightallrequired", "height_igned", "height_adjusted", "height_centered", "gapallaligned", "height_ranged", "gap_sat", " height_igned", "gap_required", "height64aligned", "gap_aligned", "heightallcentered", "heightallsat", "gapallcentered", "heightallaligned", "gapallrequired", "height_sat", "height_joined", "gapallsat", "height_required", " height_adjusted", "height64centered", "height64required", "gap_centered", " height_joined"], "buf_size": [" buf_count", "buf_ize", "buflexsize", "img_ize", "img_size", "buflexmember", "img_member", "buf_length", "buf64count", "buflexize", "buf64scale", "buflexlength", "buf64size", "buf_member", "buf_scale", " buf_range", " buf_scale", "img_length", "buf_count", "buf64range", "buf_range"], "band": ["part", "bd", "batch", "d", "plane", "dr", "card", "connection", "flow", "filter", "board", "letter", "v", "ground", "mode", "force", "match", "Band", "disk", "direction", "output", "bass", "work", "style", "bind", "bin", "page", "header", "cap", "object", "bus", "group", "tag", "service", "book", "unit", "bridge", "config", "channel", "word", "block", "io", "boot", "piece", "product", "weight", "character", "line", "layer", "device", "component", "co", "prop", "brand", "flag", "child", "port", "gb", "back", "bit", "bands", "cell", "plugin", "ann"]}}
{"project": "FFmpeg", "commit_id": "ce551a3925a1cf9c7824e26a246b99b6773bda4b", "target": 1, "func": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n{\n    SeqVideoContext *seq = avctx->priv_data;\n    seq->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    seq->frame = av_frame_alloc();\n    if (!seq->frame)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "idx": 14309, "substitutes": {"avctx": ["akpkg", "afcontext", " avcontext", "akctx", "afconfig", "aveconfig", "akconfig", "akcontext", "ajcc", "avconfig", "afcv", "avecu", "afpkg", " avcu", "avepkg", "avectx", "afsrc", " avcv", "avpkg", "avsrc", "avcu", "avcc", " avsrc", "afctx", " avcc", "avcv", "ajcas", " avcas", "afcas", "ajconf", "afconf", "afcc", "afcu", "avconf", "avcas", "ajcontext", "avecv", "avecontext", "ajsrc", " avconf", "avcontext", "ajctx"], "seq": ["aux", "iter", "cam", "fi", "data", "txt", "acc", "Sequ", "iq", "pkg", "feat", "sci", "pub", "desc", "cas", "sel", "qa", "shape", "ec", "cc", "queue", "cmp", "zip", "uu", "vec", "sq", "slice", "uc", "frame", "wave", "sequ", "sem", "sec", "lc", "config", "parent", "sub", "sup", "ctx", "feed", "cache", "context", "q", "pse", "req", "coll", "ctrl", "fam", "que", "xxx", "comp", "sequence", "code"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 14324, "substitutes": {"child": ["client", "children", "bl", "fee", "connection", "exec", "local", "count", "baby", "fe", "inner", "pc", "anch", "server", "job", "round", "Child", "path", "in", "cow", "root", "queue", "hel", "leaf", "kid", "pool", "parent", "sub", "create", "self", "block", "add", "lock", "ch", "id", "cur", "boy", "node", "cache", "current", "c", "q", "ell", "h", "lib", "cl", "row", "ca", "entry", "build", "oy", "cell", "bit", "code"], "sector_num": ["sectoringnum", "section_number", "sector_span", "sector___name", "sector_coord", "sector___num", "sector___number", "sectoringspan", "section_num", "section_info", "sector_number", "sector___coord", "section_coord", "sector_name", "section_name", "sectoringnumber", "sectoringinfo", "section_span", "sector_info"], "qiov": ["eqiw", "sqiov", " qnom", "qnom", "qoyer", "eqiov", " qicho", "qrolet", "qicho", "eqrolet", "Qiov", " qiw", " qwy", "sqrolet", "Qnom", "sqiw", "quantoyer", "sqoyer", "Qicho", "quiov", "qiw", " qliv", "quantliv", " qrolet", "quantiov", "qunom", "Qwy", "quantimeters", " qoyer", "qwy", "quimeters", "quwy", "eqoyer", "quicho", "quliv", "qliv", "qimeters", "quoyer", " qimeters"], "nb_sectors": ["nb_sixgments", "nb_cegment", "nb_vegment", "nb_vegments", "nb_sections", "nb_spegments", "nb_serctors", "nb_sixvers", "nb_pegments", "nb_vections", "nb_veivers", "nb_spections", "nb_sergments", "nb_sixivers", "nb_vevers", "nb_serivers", "nb_severs", "nb_speivers", "nb_cectors", "nb_segment", "nb_seivers", "nb_sixctors", "nb_cections", "nb_peivers", "nb_spectors", "nb_segments", "nb_servers", "nb_vectors", "nb_pegment", "nb_pections", "nb_cegments", "nb_pectors"], "flags": ["FLAG", "fs", "caps", "ints", "files", "options", "fee", "relations", "locks", "Flags", "rules", "mask", "fe", "feat", "grades", "features", "errors", "weights", "def", "fixes", "types", "limits", "fd", "sf", "plugins", "mods", "fun", "fps", "ils", "details", "reports", "properties", "stats", "bits", "fc", "weight", "args", " Flags", "forces", "bytes", "status", "iffs", "fx", "vals", "f", "flag", "utils", "interest", "groups", "bugs", "settings", "fields", "ags", "ants", "lag", "ops"], "cb": ["fp", "zb", "cgi", "func", "bf", "CB", "bc", "fn", "cf", "cd", "obb", "fb", "wb", "orb", "rob", "ob", "pc", "callback", "cmp", "rb", "ctx", "fc", "c", "pb", "cp", "bb", "cod", "b", "ctrl", "sb", "abb", "gb", "xb", "abc", "function", "eb", "cv"], "opaque": [" ophole", "Opaque", "opsaque", "opac", " opac", "ophole", "opusacent", " opque", "opusaque", "Opacent", "opque", "opsque", " opacity", "opacity", " opacent", "opsacity", "opatile", "hopatile", "hopacity", "Opac", "Ophole", "opushole", "hopque", " opatile", "opsatile", "opacent", "opusac", "hopaque"], "is_write": ["as_sync", "isableflush", "isPcreate", "isPwrite", "is_create", "as_read", "is_read", "isPwritten", "isPflow", "isablewrite", " is_flow", "is__read", "isableread", " is_written", " is_create", "is_writer", "is_lock", "as_write", "is_flush", "is__flush", " is_dirty", "as_flush", "is_flow", "is_written", "is__sync", "is__write", "is_dirty", " is_lock", "isablesync", "is_sync", " is_writer"], "co": ["client", "Co", "CO", "oe", "o", "aco", "po", "con", "isco", "oo", "pc", "ob", "cc", "cmp", "mo", "lc", "cca", "go", "cost", "cus", "coe", "ci", "ce", "can", "ico", "che", "cache", "so", "c", "flo", "company", "coll", "ctrl", "fo", "ca", "mc", "bo", "call", "ko", "xc", "cell", "loc", "lo", "code"], "acb": ["rcb", "macp", "acf", "ecbb", "accl", "acbe", "aitf", "accba", "AcB", " acl", "ackmb", "ackb", "ecd", "ecb", "achbe", "accu", "ecbase", "accc", "ocbb", "accB", " acf", "ACbb", "acku", "ocbr", "ACb", "macd", "acd", "acbb", "ecbr", "aitbase", "macb", "macfb", "ACl", "ecl", "ACf", "ecf", " acba", " acB", "achb", " acp", "aitfb", "ecp", "Acp", "accbe", "rcsb", "rcf", "accn", "ACd", "ocsb", "ocp", " acn", "ackbb", "rcbb", "Acf", "acu", "accbb", "accfb", "acfb", "ecsb", "accsb", "ackbe", "ecc", "accbr", "accp", "acp", "acksb", "acbr", "acsb", "acba", "macmb", " acd", "accbase", "achba", "acmb", "ecfb", "accmb", "macn", " acfb", "aitb", "accd", "acc", "ecu", "acB", "ocl", "ackn", "macbb", "acn", "ACbe", "ocf", "ackl", " acc", "achn", " acbb", "accb", "ecbe", "acbase", "accf", "ocb", "acl", "Acb", " acbe", "ACn"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0, index;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case P_TYPE: status = decode_p_picture_secondary_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_secondary_header(v); break;\n\n    case BI_TYPE:\n\n    case I_TYPE: break; //Nothing needed as it's done in the epilog\n\n    }\n\n    if (status < 0) return FRAME_SKIPED;\n\n\n\n    /* AC Syntax */\n\n    v->ac_table_level = decode012(gb);\n\n    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)\n\n    {\n\n        v->ac2_table_level = decode012(gb);\n\n    }\n\n    /* DC Syntax */\n\n    index = decode012(gb);\n\n    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];\n\n    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];\n\n   \n\n    return 0;\n\n}\n", "idx": 14350, "substitutes": {"v": ["serv", "sv", "ev", "ve", "vm", "var", "e", "u", "V", "l", "ov", "server", "vin", "vi", "tv", "m", "vers", "vt", "volt", "g", "vert", "k", "n", "vd", "iv", "vc", "nv", "gu", "rev", "dev", "c", "vs", "i", "conv", "uv", "s", "p", "vol", "b", "ver", "va", "lv", "f", "vg", "w", "vim", "av", "vp", "j", "value", "vv", "t", "video"], "gb": ["phy", "storage", "gy", "gt", "hub", "git", "bf", "gm", "bc", "cfg", "pc", "cb", "pm", "kb", "gpu", "gc", "GB", "pg", "db", "ga", "gui", "ui", "gal", "tm", "gs", "bg", "gin", "g", "rb", "vd", "gu", "gam", "ctx", "usb", "vc", "buff", "ci", "nb", "gz", "bb", "cod", "lib", "range", "b", "gom", "gg", "mb", "vg", "sb", "gp", "eb", "buffer", "Gb", "beta", "rg", "gd", "bm"], "index": ["update", "sync", "part", "document", "address", "ini", "connection", "position", "action", "office", "column", "Index", "count", "match", "pos", "output", "length", "size", "element", "si", "condition", "level", "offset", "slice", "len", "unit", "url", "config", "num", "edit", "ix", "point", "key", "item", "version", "axis", "x", "input", "i", "weight", "info", "status", "active", "type", "inc", "f", "row", "xxxx", "ind", "xxx", "section", "value", "j", "loc", "bis", "number"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356, "substitutes": {"oc": ["o", "oca", "alloc", "soc", "ok", "aco", "oco", "mic", "bc", "oid", "oo", "pc", "og", "voc", "ob", "toc", "anc", "ec", "oci", "dc", "cc", "object", "uc", "rc", "config", "cus", "ac", "org", "os", "ucc", "fc", "c", "mac", "OC", "mot", "isc", "co", "coll", "roc", "ocr", "loc", "cms"], "data": ["module", " dc", "d", "di", "o", "func", "raw", "record", "obj", "desc", "output", "ds", "def", "doc", "object", "meta", "config", "parent", "os", "cache", "mac", "Data", "dd", "co", "load", "DATA", "da"], "mc": ["VC", "module", "MC", "mm", "di", "mp", "mi", "PC", "aco", "cm", "tc", "mic", "md", "bc", "container", "pc", "cfg", "cycle", "cf", "model", "ml", "gc", "doc", "ec", "cc", "dc", "m", "disc", "mn", "uc", "meta", "rc", "lc", "cca", "config", "mx", "cus", "ac", "DC", "spec", "fc", "c", "NC", "mac", "Mc", "ma", "core", "mot", "col", "inc", "WC", "coll", "mr", "co", "cli", "acl", "ca", "ms", "roc", "cci", "chain", "loc", "mk", "conn", "cms"], "nc": ["enc", "nn", "cn", "nt", "tc", "bc", "pc", "cb", "gc", "anc", "nic", "ec", "cc", "dc", "disc", "mn", "uc", "cdn", "rc", "lc", "cca", "ac", "ci", "nec", "nv", "ucc", "fc", "c", "NC", "inc", "unc", "roc", "cci", "xc", "conn", "jc"], "hc": ["herpc", "shc", "phpc", "Hc", "hrc", " hcs", "hmci", "hvc", "hmpc", "hci", " hrc", "Hci", " hk", "shpc", "phc", " hpc", "hk", "phvc", "hcs", "hercs", "Hpc", "hmc", "herc", "shk", "hmrc", "hac", "phac", "phk", "hervc", "Hrc", " hci", " hac", " hvc", "hpc", "phcs", "shac"], "s390mc": ["S390pc", "s090cc", "s40MC", "S370mc", " s390mot", "s170cc", "s90MC", "s090mac", "S90cc", " s390mac", " s40mc", "s40c", "S390cm", "s620mot", "s620mc", "S390nc", " s390cc", "s390mot", "s390pc", "S90mc", "s40cc", "s40tc", "s490cm", " s390cm", " s390MC", " s90pc", " s90mc", " s170mc", " s90cm", "s390c", "s490pc", "s40mac", "s490mc", "s380mc", "S370nc", "safercm", "s390tc", "s390cm", "s370c", "saferpc", " s390c", "S90tc", "S370pc", "S370cm", "S390tc", "s40pc", "s90mc", " s170c", " s40mot", "S390mc", "s90tc", "s170c", "s090mc", "s390nc", "s380c", "s370pc", " s40mac", "s170MC", "s90mac", "s390cc", "s90pc", " s90c", "safermc", "s90c", " s170MC", "safernc", "s620mac", "s490nc", " s170cc", "s170mc", "S390cc", "s370cm", " s40pc", "s380pc", "s370mc", "s90cc", "s090tc", " s390pc", "s90cm", "S390mac", "s380cm", "s40mot", "S90mac", "s370nc", "s370mot", "s390mac", "s390MC", "s620pc", "s40mc", "s370mac"]}}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n", "idx": 14359, "substitutes": {"s": ["client", "fs", "caps", "serv", "sync", "sv", "session", "south", "data", "v", "cs", "sa", "events", "u", "server", "si", "ss", "space", "ssl", "service", "m", "sq", "gs", "a", "g", "sports", "self", "sup", "spec", "ctx", "cur", "stats", "c", "h", "i", "sg", "p", "ns", "b", "aws", "sets", "sl", "f", "src", "sb", "ses", "js", "w", "gb", "opens", "services", "S", "t", "ops"], "buf": ["aux", "bd", "batch", "brace", "func", "fi", "data", "uf", "agg", "br", "result", "bc", "array", "ff", "cf", "fab", "cb", "fb", "cmd", "wb", "output", "cap", "db", "queue", "vec", "uc", "fd", "comb", "pool", "seq", "emb", "usr", "rb", "opt", "cur", "feed", "buff", "ctx", "context", "conv", "h", "uv", "Buffer", "b", "begin", "bag", "ver", "f", "src", "ab", "av", "Buff", "port", "buffer", "font", "loc", "fac", "img", "pb", "cv"], "num_strips": ["num_trippers", "num_traples", "num_stripped", "num_wrappers", "num_strappings", "num_wraples", "num_trippings", "num_triips", "num_strappers", "num_trips", "num_strippers", "num_trapped", "num_stripips", "num_traips", "num_stripples", "num_wraps", "num_wrappings", "num_striips", "num_traps", "num_straples", "num_strippings", "num_stripps", "num_tripped", "num_straps", "num_striples", "num_triples", "num_strippped"], "data_size": ["dataacspeed", "data1sized", "window_size", "window_num", "data_num", " data_SIZE", "data_capacity", "data1size", "data_sized", "data1speed", "data_SIZE", "window_capacity", "dataacSIZE", " data_speed", " data_sized", "dataacsize", "data1SIZE", "window_SIZE", "data_speed", "dataacsized"]}}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362, "substitutes": {"s": ["ps", "hs", "fs", "sv", "rs", "soc", "v", "sc", "e", "sa", "cs", "ds", "sys", "si", "ss", "m", "sq", "gs", "sf", "xs", "ks", "self", "sac", "c", "sg", "p", "sb", "as", "ses", "ms", "js", "parser", "ls", "services"], "pc": ["enc", "pic", "cam", "cz", "PC", "cu", "oc", "amp", "tc", "sc", "cs", "nc", "bc", "sa", "pm", "pac", "anc", "ec", "cc", "dc", "uc", "pd", "lc", "FC", "cca", "px", "ck", "cus", "rc", "lp", "ac", "vc", "ctx", "pa", "fc", "c", "cp", "p", "arc", "co", "cr", "mc", "ca", "gb", "auc", "xc", "cms", "pb"]}}
{"project": "FFmpeg", "commit_id": "a6d6b8a20072a5919d38258dd48cc612e2372f81", "target": 1, "func": "const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n", "idx": 14366, "substitutes": {"obj": ["o", "ass", "ord", "tmp", "data", "jp", "po", "nt", "op", "act", "pos", "clone", "lt", "ob", "val", "object", "inst", "parent", "rb", "self", "next", "os", "opt", "nb", "init", "node", "bot", "art", "ext", "lib", "cl", "b", "instance", "Obj", "src", "pl", "j", "alt", "aut"], "last": ["sync", "first", "list", "nd", "empty", "private", "worst", "li", "after", "eval", "global", "count", "end", "cycle", "always", "size", "style", "later", "full", "object", "str", "best", "parent", "self", "cost", "latest", "pop", "est", "id", "Last", "closure", "node", "cache", "max", "bottom", "close", "cl", "scope", "one", "cle", "child", "or", "option", "final", "j", "build", "value", "old", "next", "prev", "code"], "class": ["first", "ass", "pe", "user", "private", "op", "style", "ss", "object", "service", "book", "new", "Class", "super", "str", "config", "parent", "self", "latest", "CLASS", "opt", "cache", "c", "current", "line", "s", "lib", "cl", "scope", "cat", "b", "instance", "lass", "name", "future", "out", "classes", "or", "option", "section", "final", "rule", "css", "function", "prev", "code"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void do_audio_out(AVFormatContext *s, OutputStream *ost,\n\n                         InputStream *ist, AVFrame *decoded_frame)\n\n{\n\n    uint8_t *buftmp;\n\n\n\n    int size_out, frame_bytes, resample_changed, ret;\n\n    AVCodecContext *enc = ost->st->codec;\n\n    AVCodecContext *dec = ist->st->codec;\n\n    int osize = av_get_bytes_per_sample(enc->sample_fmt);\n\n    int isize = av_get_bytes_per_sample(dec->sample_fmt);\n\n    uint8_t *buf = decoded_frame->data[0];\n\n    int size     = decoded_frame->nb_samples * dec->channels * isize;\n\n    int out_linesize = 0;\n\n    int buf_linesize = decoded_frame->linesize[0];\n\n\n\n    get_default_channel_layouts(ost, ist);\n\n\n\n    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (audio_sync_method > 1                      ||\n\n        enc->channels       != dec->channels       ||\n\n        enc->channel_layout != dec->channel_layout ||\n\n        enc->sample_rate    != dec->sample_rate    ||\n\n        dec->sample_fmt     != enc->sample_fmt)\n\n        ost->audio_resample = 1;\n\n\n\n    resample_changed = ost->resample_sample_fmt  != dec->sample_fmt ||\n\n                       ost->resample_channels    != dec->channels   ||\n\n                       ost->resample_channel_layout != dec->channel_layout ||\n\n                       ost->resample_sample_rate != dec->sample_rate;\n\n\n\n    if ((ost->audio_resample && !ost->avr) || resample_changed) {\n\n        if (resample_changed) {\n\n            av_log(NULL, AV_LOG_INFO, \"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\" to rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\"\\n\",\n\n                   ist->file_index, ist->st->index,\n\n                   ost->resample_sample_rate, av_get_sample_fmt_name(ost->resample_sample_fmt),\n\n                   ost->resample_channels, ost->resample_channel_layout,\n\n                   dec->sample_rate, av_get_sample_fmt_name(dec->sample_fmt),\n\n                   dec->channels, dec->channel_layout);\n\n            ost->resample_sample_fmt  = dec->sample_fmt;\n\n            ost->resample_channels    = dec->channels;\n\n            ost->resample_channel_layout = dec->channel_layout;\n\n            ost->resample_sample_rate = dec->sample_rate;\n\n            if (ost->avr)\n\n                avresample_close(ost->avr);\n\n        }\n\n        /* if audio_sync_method is >1 the resampler is needed for audio drift compensation */\n\n        if (audio_sync_method <= 1 &&\n\n            ost->resample_sample_fmt  == enc->sample_fmt &&\n\n            ost->resample_channels    == enc->channels   &&\n\n            ost->resample_channel_layout == enc->channel_layout &&\n\n            ost->resample_sample_rate == enc->sample_rate) {\n\n            ost->audio_resample = 0;\n\n        } else if (ost->audio_resample) {\n\n            if (!ost->avr) {\n\n                ost->avr = avresample_alloc_context();\n\n                if (!ost->avr) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Error allocating context for libavresample\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n\n\n            av_opt_set_int(ost->avr, \"in_channel_layout\",  dec->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"in_sample_fmt\",      dec->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"in_sample_rate\",     dec->sample_rate,    0);\n\n            av_opt_set_int(ost->avr, \"out_channel_layout\", enc->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"out_sample_fmt\",     enc->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"out_sample_rate\",    enc->sample_rate,    0);\n\n            if (audio_sync_method > 1)\n\n                av_opt_set_int(ost->avr, \"force_resampling\", 1, 0);\n\n\n\n            /* if both the input and output formats are s16 or u8, use s16 as\n\n               the internal sample format */\n\n            if (av_get_bytes_per_sample(dec->sample_fmt) <= 2 &&\n\n                av_get_bytes_per_sample(enc->sample_fmt) <= 2) {\n\n                av_opt_set_int(ost->avr, \"internal_sample_fmt\", AV_SAMPLE_FMT_S16P, 0);\n\n            }\n\n\n\n            ret = avresample_open(ost->avr);\n\n            if (ret < 0) {\n\n                av_log(NULL, AV_LOG_FATAL, \"Error opening libavresample\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (audio_sync_method > 0) {\n\n        double delta = get_sync_ipts(ost, ist->last_dts) * enc->sample_rate - ost->sync_opts -\n\n                       av_fifo_size(ost->fifo) / (enc->channels * osize);\n\n        int idelta = delta * dec->sample_rate / enc->sample_rate;\n\n        int byte_delta = idelta * isize * dec->channels;\n\n\n\n        // FIXME resample delay\n\n        if (fabs(delta) > 50) {\n\n            if (ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate) {\n\n                if (byte_delta < 0) {\n\n                    byte_delta = FFMAX(byte_delta, -size);\n\n                    size += byte_delta;\n\n                    buf  -= byte_delta;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\",\n\n                           -byte_delta / (isize * dec->channels));\n\n                    if (!size)\n\n                        return;\n\n                    ist->is_start = 0;\n\n                } else {\n\n                    av_fast_malloc(&async_buf, &allocated_async_buf_size,\n\n                                   byte_delta + size);\n\n                    if (!async_buf) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Out of memory in do_audio_out\\n\");\n\n                        exit_program(1);\n\n                    }\n\n\n\n                    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples + idelta, &out_linesize) < 0) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                    ist->is_start = 0;\n\n\n\n                    generate_silence(async_buf, dec->sample_fmt, byte_delta);\n\n                    memcpy(async_buf + byte_delta, buf, size);\n\n                    buf = async_buf;\n\n                    size += byte_delta;\n\n                    buf_linesize = allocated_async_buf_size;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", idelta);\n\n                }\n\n            } else if (audio_sync_method > 1) {\n\n                int comp = av_clip(delta, -audio_sync_method, audio_sync_method);\n\n                av_log(NULL, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\",\n\n                       delta, comp, enc->sample_rate);\n\n//                fprintf(stderr, \"drift:%f len:%d opts:%\"PRId64\" ipts:%\"PRId64\" fifo:%d\\n\", delta, -1, ost->sync_opts, (int64_t)(get_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));\n\n                avresample_set_compensation(ost->avr, comp, enc->sample_rate);\n\n            }\n\n        }\n\n    } else if (audio_sync_method == 0)\n\n        ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) -\n\n                                av_fifo_size(ost->fifo) / (enc->channels * osize); // FIXME wrong\n\n\n\n    if (ost->audio_resample) {\n\n        buftmp = audio_buf;\n\n        size_out = avresample_convert(ost->avr, (void **)&buftmp,\n\n                                      allocated_audio_buf_size, out_linesize,\n\n                                      (void **)&buf, buf_linesize,\n\n                                      size / (dec->channels * isize));\n\n        size_out = size_out * enc->channels * osize;\n\n    } else {\n\n        buftmp = buf;\n\n        size_out = size;\n\n    }\n\n\n\n    /* now encode as many frames as possible */\n\n    if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) {\n\n        /* output resampled raw samples */\n\n        if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"av_fifo_realloc2() failed\\n\");\n\n            exit_program(1);\n\n        }\n\n        av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL);\n\n\n\n        frame_bytes = enc->frame_size * osize * enc->channels;\n\n\n\n        while (av_fifo_size(ost->fifo) >= frame_bytes) {\n\n            av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL);\n\n            encode_audio_frame(s, ost, audio_buf, frame_bytes);\n\n        }\n\n    } else {\n\n        encode_audio_frame(s, ost, buftmp, size_out);\n\n    }\n\n}\n", "idx": 14372, "substitutes": {"s": ["d", "sv", "o", "soc", "oc", "sc", "e", "cs", "sys", "ss", "lex", "sq", "sf", "sec", "a", "g", "ac", "os", "spec", "sac", "acs", "c", "h", "f", "sb", "w", "ses"], "ost": ["not", "\u00f3", "oe", "ud", "omp", "ST", "hop", "ord", "oc", "pos", "obj", "om", "sta", "omm", "oster", "isc", "src", "ocr", "odi", "o", "opp", "nt", "ods", "inst", "wo", "word", "osi", "org", "osc", "rod", "OST", "ad", "et", "ott", "oper", "nd", "ober", "st", "oid", "rest", "ob", "oint", "osta", "obs", "tt", "est", "opt", "oder", "http", "art", "ast", "od", "tto", "roc", "rost", "sth", "oy", "irst", "ood", "\u0435", "ust", "op", "oh", "ld", "og", "rob", "post", "oss", "host", "os", "ot", "rss", "so", "ont", "mot", "iol", "kt", "orest", "loc", "old"], "ist": ["et", "isd", "ft", "dr", "alist", "ista", "iste", "nd", "nt", "dist", "st", "ld", "ism", "pt", "rest", "wd", "ht", "ds", "isi", "pect", "ilst", "post", "wp", "irc", "IST", "adder", "inst", "sta", "edit", "ette", "osi", "ict", "est", "dit", "aint", "ess", "ctx", "ists", "is", "ia", "art", "ast", "set", "erd", "isu", "ont", "dd", "od", "mot", "pit", "kt", "src", "ind", "idd", "std", "sth", "imet", "ace", "xt", "irst", "ad", "asi"], "decoded_frame": ["decoded_frames", "decodedadelement", "decanced_coll", "decoded_sample", "decaned_sample", "decoded_scene", "decodedingFrame", "decaded_game", "decoded_fr", "decrypted_image", "decadedingframe", "decrypted_source", "decaned_step", "decodedadcoll", "decodedJsource", "decodedingframe", "decoded_coll", "decrypted_fr", "decodedinggame", "decoded_image", "decrypted_frames", "decodedingdef", "decaned_Frame", "decodedingsource", "decoded_stream", "decadedinggame", "decaded_scene", "decrypted_Frame", "decoded_def", "decodedingscene", "decadedingscene", "decodedJfr", "decodedingfr", "decrypted_stream", "decodedJframe", "decanced_frame", "decodedadframes", "decoded_element", "decodedJFrame", "decaded_def", "decoded_Frame", "decodedadframe", "decoded_source", "decaded_frame", "decrypted_frame", "decanced_element", "decaned_frame", "decanced_frames", "decoded_step", "decoded_game", "decadedingdef"], "buftmp": ["puffmp", "buktip", "buffmp", "buffok", "puftok", "buffamp", "buktmp", "bufdmp", "bufdip", "buktok", "puffip", "buftok", "buktamp", "bufdamp", "puftmp", "buffip", "puftamp", "bufdok", "buftip", "puffok", "puftip", "puffamp", "buftamp"], "size_out": [" size_output", " size_diff", "size_output", " size_in", "size_in", "size_diff"], "frame_bytes": ["frame6bytes", "frame_base", "frame_seq", "frames_seq", "frame6base", "frame_bits", "frames_bits", "frames_base", "frame6bits", "frames_bytes", "frame6seq"], "resample_changed": ["resampleJchange", "resanceJchange", "resampleJchanged", "resamp_edited", "resample_error", "resamp_change", "resample_change", "rescale_changes", "resanceJchanged", "resample_changing", "resampleJchanging", "resplay_changed", "rescale_modified", "resplay_change", "resance_changing", "resampleJadded", "resamp_changed", "resample_modified", "resanceJadded", "resample__changed", "resplay_error", "resamp_updated", "resample_edited", "resance_added", "resance_changed", "resanceJchanging", "resample_changes", "resample__change", "resample_added", "resample__added", "resplay_changes", "resample__changing", "rescale_changed", "rescale_updated", "resample_updated", "resance_change"], "ret": ["orig", "success", "temp", "empty", "resp", "nt", "result", "val", "def", "res", "seq", "fun", "capt", "rc", "reg", "mem", "no", "info", "status", "flags", "RET", "msg", "flag", "alt", "Ret"], "enc": ["en", "et", "ew", "ens", "oc", "decl", "ENC", "bn", "exec", "nt", "adr", "nc", "con", "bc", "rh", "desc", "cb", "oa", "conn", "sel", "sys", "anon", "ang", "anc", "eng", "ec", "ou", "dc", "ent", "vec", "uc", "sec", "lc", "rc", "emb", "eu", "ant", "rec", "ac", "vc", "iv", "de", "ch", "cur", "oder", "fc", "dev", "c", "code", "ext", "cod", "od", "cat", "inc", "cy", "sl", "unc", "cel", "Enc", "oy", "env", "loc", "equ", "nec", "img", "cv"], "buf": ["fp", "aux", "orig", "alloc", "tmp", "data", "uf", "br", "bc", "cf", "cb", "cmd", "pad", "queue", "vec", "uc", "wave", "seq", "rc", "num", "rb", "block", "ctx", "buff", "box", "src", "buffer", "img", "cv"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n", "idx": 14376, "substitutes": {"var": ["orig", "card", "ar", "rar", "war", "v", "endor", "cf", "parent", "variable", "man", "self", "gar", "spec", "cur", "mac", "bb", "col", "ver", "sr", "start", "as", "array", "prev", "stack", "arch", "tmp", "raw", "adr", "ser", "rt", "y", "car", "mod", "slice", "str", "error", "vert", "star", "keep", "c", "x", "cat", "arr", "buffer", "vr", "null", "cover", "oper", "ars", "func", "data", "Var", "shape", "this", "bar", "valid", "rr", "parse", "rc", "usr", "par", "fr", "opt", "dev", "vs", "type", "ph", "name", "av", "comp", "sk", "sv", "dr", "reader", "br", "op", "feature", "base", "pair", "mir", "pad", "vard", "wave", "host", "vari", "vc", "cp", "p", "err", "er", "r", "rank", "loc", "gr", "pack"], "shiftop": ["shiftOp", "pullOP", " shiftOp", "hiftbit", "sizeOP", "pullbit", "shiftOP", " shiftOP", "hiftop", "sizeop", "sizeOp", "sizeops", "pullOp", "hiftOP", "hiftops", "hiftOp", "shiftops", " shiftops", "pullop", "shiftbit", " shiftbit"], "shift": ["save", "address", "append", "field", "send", "patch", "force", "pos", "scale", "ix", "sup", "center", "drop", "sh", "slave", "set", "start", "pick", "stack", "move", "shock", "front", "seed", "use", "copy", "transform", "sort", "offset", "slice", "sq", "tip", "keep", "power", "lower", "ip", "push", "close", "off", "reverse", "half", "hift", "square", "carry", "ctr", "gap", "hide", " shifts", "kick", "count", "shr", "end", "size", "shape", "cap", "Shift", "ress", "mix", "parse", "cost", "hack", "pop", "ice", "margin", "order", "effect", "sample", "adjust", "sleep", "cart", "pull", "dist", "length", "just", "align", "pair", "pad", "space", "small", "skip", "crop", "range", "p", "sign", "rank", "pack"], "flags": ["FLAG", "comments", "fs", "caps", "yrs", "includes", "files", " shifts", "options", "books", "locks", "fi", "strings", "Flags", "rules", "styles", "lists", "results", "mask", "reads", "feat", "fts", "requires", "fl", "features", "states", "weights", "ss", "needs", "types", "links", "limits", "ifts", "fd", "sf", "wave", "lins", "mods", "plugins", "fun", "linux", "cost", "ips", "ils", "allows", "rets", "bits", "stats", "weight", "vs", "args", " flag", "atts", "lines", "vals", "f", "lf", "flag", "utils", "groups", "bugs", "orts", "settings", "fields", "opens", "ants", "ags", "nl", "alls", "len", "lag", "ops", "kind"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 14379, "substitutes": {"s": ["ps", "sync", "us", "o", "session", "your", "ins", "sites", "rs", "strings", "south", "data", "e", "cs", "u", "ts", "its", "features", "parts", "params", "ds", "states", "sys", "si", "ss", "in", "ssl", "service", "new", "m", "state", "sq", "gs", "plugins", "a", "xs", "bs", "es", "ks", "sports", "details", "stats", "is", "c", "http", "args", "status", "p", "ns", "qs", "tests", "sets", "ses", "js", "settings", "ls", "services", "sym", "S", "t", "less", "ops"], "i": ["d", "ie", "o", "di", "gi", "ini", "iu", "fi", "mi", "data", "v", "multi", "li", "e", "u", "xi", "mu", "l", "pi", "length", "abi", "uri", "si", "in", "y", "ai", "ui", "m", "api", "a", "lc", "ti", "k", "z", "ix", "eni", "n", "io", "ci", "id", "bi", "init", "qi", "ip", "c", "oi", "h", "info", "x", "phi", "p", "index", "ri", "hi", "b", "ni", "f", "zi", "j", "ii", "t", "I", "yi"]}}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n", "idx": 14387, "substitutes": {"s": ["ps", "serv", "sync", "fs", "o", "session", "options", "rs", "cs", "e", "ts", "l", "ds", "sys", "si", "ss", "ssl", "service", "new", "conf", "state", "gs", "sf", "plugins", "a", "xs", "es", "self", "os", "spec", "stats", "is", "side", "c", "http", "i", "input", "sg", "info", "status", "p", "scope", "su", "ns", "qs", "sl", "sets", "aws", "f", "sb", "sie", "ses", "js", "w", "settings", "request", "stat", "ls", "services", "sym", "S", "t"], "reload": ["REloader", "refload", "recharge", "Reloader", "brefill", "Refill", "Reload", "breloads", "REcharge", "refplay", "reloader", "refloader", "foreloader", "rowcharge", "rowload", "rowplay", "REload", "refill", "breload", "foreloads", "foreload", "Reloads", "reloads", "breloader", "REplay", "replay", "refcharge", "rowloader", "forefill"], "limit": ["large", "it", "iter", "limited", "route", "position", "filter", "source", "count", "force", "match", "pos", "mode", "use", "l", "base", "length", "size", "model", "page", "timeout", "ure", "level", "limits", "offset", "ite", "ignore", "unit", "lim", "config", "url", "view", "inf", "location", "release", "block", "skip", "lock", "capacity", "io", "version", "cache", "ip", "priority", "line", "Limit", "info", "i", "target", "index", "status", "control", "start", "repeat", "pin", "buffer", "len"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf),\n\n                term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 14388, "substitutes": {"term_hist_entry": ["term_histxenter", "term_hist_ry", "term_history_enter", "term_hist23entry", "term_histprepart", "term_hist_enter", "term_histpreEntry", "term_history_index", "term_histprelast", "term_hist_Entry", "term_histpcount", "term_history_Entry", "term_hist_last", "term_hist_count", "term_hist_index", "term_histpreentry", "term_hist23ry", "term_history_last", "term_history_part", "term_hist23index", "term_histpindex", "term_histxpart", "term_histpentry", "term_hist23element", "term_history_count", "term_history_element", "term_hist_element", "term_history_ry", "term_hist_part", "term_histxentry", "term_history_entry"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n", "idx": 14393, "substitutes": {"phys_addr": ["phys__addr", "phys_ord", "phys_address", "mem_addr", " phys_loc", "physxloc", "phys__ord", "physxaddress", "phys_loc", "phys__coord", "physxaddr", "phys_ace", " phys_address", "phys__address", "phys_coord", "physxace", "mem_coord", " phys_ace", "mem_ord", "mem_address"], "size": ["storage", "address", "alloc", "send", "fee", "Size", "empty", "count", "speed", "use", "base", "length", "password", "si", "timeout", "shape", "eng", "offset", "sec", "unit", "small", "iz", "scale", "g", "sized", "six", "capacity", "block", " sizes", "args", "bytes", "name", "SIZE", "esc", "sum", "ize", "len", "security"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "substitutes": {"argc": ["Arglc", "argxc", " arglc", "iglc", "tagc", "Argrc", " argxc", "agsc", "arglc", "argpc", "Argsc", "tagfc", "Argc", "Argfc", "agc", " argrc", "igxc", "tagpc", "agfc", "tagsc", "Argxc", "argrc", "argfc", "igrc", "Argpc", "igc", "argsc", "agpc"], "argv": ["opsv", "tagc", "argsf", "opv", "opp", "opc", " argf", "arf", "arv", "Argc", "argval", " argsv", "Argp", "tagv", "argsval", "argsv", "arval", "argssv", "Argf", " argval", "Argv", " argp", "argsc", "argf", "argsp", "argp", "tagp", "arp", "tagsv"], "mask": ["mark", "bug", "check", "filter", "data", "patch", "count", "iq", "ask", "match", "black", "image", "fix", "result", "work", "style", "delay", "Mask", "strip", "qa", "cloud", "pixel", "broad", "group", "map", "zip", "offset", "unk", "comment", "scale", "parent", "ck", "cost", "key", "hack", "like", "block", "lock", "id", "cache", "weight", "code", "clean", "info", "ban", "scan", "sign", "ack", "flag", "bit", "allow", "ace", "sum", "array", "sk", "cover"]}}
{"project": "FFmpeg", "commit_id": "1a3ed056c523b4670e192301be15dbc521ec8353", "target": 0, "func": "static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)\n\n{\n\n    HEVCContext *s  = avctxt->priv_data;\n\n    int ctb_size    = 1 << s->sps->log2_ctb_size;\n\n    int more_data   = 1;\n\n    int x_ctb       = 0;\n\n    int y_ctb       = 0;\n\n    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];\n\n\n\n    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Impossible initial tile.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->sh.dependent_slice_segment_flag) {\n\n        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];\n\n        if (s->tab_slice_address[prev_rs] == -1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Previous slice segment missing\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    while (more_data && ctb_addr_ts < s->sps->ctb_size) {\n\n        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];\n\n\n\n        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);\n\n\n\n        ff_hevc_cabac_init(s, ctb_addr_ts);\n\n\n\n        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);\n\n\n\n        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;\n\n        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;\n\n        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;\n\n\n\n        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);\n\n        if (more_data < 0) {\n\n            s->tab_slice_address[ctb_addr_rs] = -1;\n\n            return more_data;\n\n        }\n\n\n\n\n\n        ctb_addr_ts++;\n\n        ff_hevc_save_states(s, ctb_addr_ts);\n\n        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);\n\n    }\n\n\n\n    if (x_ctb + ctb_size >= s->sps->width &&\n\n        y_ctb + ctb_size >= s->sps->height)\n\n        ff_hevc_hls_filter(s, x_ctb, y_ctb);\n\n\n\n    return ctb_addr_ts;\n\n}\n", "idx": 14442, "substitutes": {"avctxt": ["avctXT", "avptkt", " avctXT", " avftXT", "avntxt", "AVctert", "AVctext", "AVntert", "AVctxt", "avCTXT", "avntext", "AVntext", "AVcttxt", "avcert", "avCTxt", "AVntxt", " avfttxt", "avpttxt", "avptXT", "avftxt", " avftkt", "avptxt", "avcttxt", " avctkt", " avcttxt", "avCTkt", "avcext", "avsectxt", "avCTtxt", "avcxt", "avsecxt", "avctert", "avctext", " avftxt", "avfttxt", "avftXT", "avsecert", "avctkt", "avnttxt", "avntert", "AVnttxt", "avsecext", "avftkt"], "isFilterThread": ["asFilterPool", "isMainPool", "asFilterThread", "asMainLock", "asMainThread", "isMainThread", "asFilterLock", "isCallThread", "isFilterPool", "isCallthread", "isCallLock", "isCatLock", "isMainthread", "asMainPool", "isFilterLock", "isCatThread", "asFilterthread", "isMainLock", "isCatPool", "isCatthread", "isFilterthread", "isCallPool", "asMainthread"], "s": ["session", "site", "sc", "ts", "states", "sys", "si", "an", "se", "m", "plugins", "sec", "xs", "sup", "self", "n", "spec", "i", "qs", "sb", "as", "js", "services", "t", "ps", "fs", "sync", "o", "cs", "e", "parts", "ss", "ssl", "sq", "gs", "sf", "a", "details", "is", "c", "sg", "ns", "lines", "settings", "bis", "less", "storage", "us", "sites", "data", "l", "ds", "service", "ing", "stats", "http", "sl", "ses", "sym", "S", "ops", "comments", "d", "sv", "south", "secondary", "server", "full", "uns", "g", "es", "ks", "k", "os", "ctx", "ches", "su", "p", "tests", "b", "aws", "sets", "f", "w", "groups", "request", "ls", "r", "opens", "conf", "words"], "ctb_addr_ts": ["ctb_addr_TS", "ctb_addrPts", "ctb_addr2ts", "ctb_vr6ts", "ctb_vr6ss", "ctb_addrMrs", "ctb_addr__ts", "ctb_addr_tt", "ctb_vr_tt", "ctb_dr_tt", "ctb_ord_ents", "ctb_ord_fs", "ctb_addrPrs", "ctb_addr_ns", "ctb_vr_ts", "ctb_addr2TS", "ctb_addr6ts", "ctb_addr35TS", "ctb_addr_ps", "ctb_addr_ss", "ctb_addr35ps", "ctb_dr_ts", "ctb_addr__TS", "ctb_addr_Ts", "ctb_addr_fs", "ctb_addr_ms", "ctb_addr__tt", "ctb_ord_rs", "ctb_addr_ents", "ctb_addr_rs", "ctb_addrPcs", "ctb_addrJms", "ctb_vr_ss", "ctb_dr_ns", "ctb_dr_TS", "ctb_addrMTS", "ctb_ord_ps", "ctb_addrPms", "ctb_ord_ms", "ctb_dr_rs", "ctb_ord_ts", "ctb_ord_TS", "ctb_addr6rs", "ctb_addrMns", "ctb_addr2tt", "ctb_addr_cs", "ctb_addrJts", "ctb_dr_Ts", "ctb_ord_cs", "ctb_addr__rs", "ctb_addr6ss", "ctb_addr2rs", "ctb_addrJcs", "ctb_vr6rs", "ctb_addr35ts", "ctb_addr6tt", "ctb_vr6tt", "ctb_addrMts", "ctb_dr_ats", "ctb_addr_ats", "ctb_addrJrs", "ctb_addr35ents", "ctb_vr_rs"]}}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int decode_header(MPADecodeContext *s, UINT32 header)\n\n{\n\n    int sample_rate, frame_size, mpeg25, padding;\n\n    int sample_rate_index, bitrate_index;\n\n    if (header & (1<<20)) {\n\n        s->lsf = (header & (1<<19)) ? 0 : 1;\n\n        mpeg25 = 0;\n\n    } else {\n\n        s->lsf = 1;\n\n        mpeg25 = 1;\n\n    }\n\n    \n\n    s->layer = 4 - ((header >> 17) & 3);\n\n    /* extract frequency */\n\n    sample_rate_index = (header >> 10) & 3;\n\n    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);\n\n    if (sample_rate == 0)\n\n        return 1;\n\n    sample_rate_index += 3 * (s->lsf + mpeg25);\n\n    s->sample_rate_index = sample_rate_index;\n\n    s->error_protection = ((header >> 16) & 1) ^ 1;\n\n\n\n    bitrate_index = (header >> 12) & 0xf;\n\n    padding = (header >> 9) & 1;\n\n    //extension = (header >> 8) & 1;\n\n    s->mode = (header >> 6) & 3;\n\n    s->mode_ext = (header >> 4) & 3;\n\n    //copyright = (header >> 3) & 1;\n\n    //original = (header >> 2) & 1;\n\n    //emphasis = header & 3;\n\n\n\n    if (s->mode == MPA_MONO)\n\n        s->nb_channels = 1;\n\n    else\n\n        s->nb_channels = 2;\n\n    \n\n    if (bitrate_index != 0) {\n\n        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];\n\n        s->bit_rate = frame_size * 1000;\n\n        switch(s->layer) {\n\n        case 1:\n\n            frame_size = (frame_size * 12000) / sample_rate;\n\n            frame_size = (frame_size + padding) * 4;\n\n            break;\n\n        case 2:\n\n            frame_size = (frame_size * 144000) / sample_rate;\n\n            frame_size += padding;\n\n            break;\n\n        default:\n\n        case 3:\n\n            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);\n\n            frame_size += padding;\n\n            break;\n\n        }\n\n        s->frame_size = frame_size;\n\n    } else {\n\n        /* if no frame size computed, signal it */\n\n        if (!s->free_format_frame_size)\n\n            return 1;\n\n        /* free format: compute bitrate and real frame size from the\n\n           frame size we extracted by reading the bitstream */\n\n        s->frame_size = s->free_format_frame_size;\n\n        switch(s->layer) {\n\n        case 1:\n\n            s->frame_size += padding  * 4;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 48000;\n\n            break;\n\n        case 2:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 144000;\n\n            break;\n\n        default:\n\n        case 3:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;\n\n            break;\n\n        }\n\n    }\n\n    s->sample_rate = sample_rate;\n\n    \n\n#if defined(DEBUG)\n\n    printf(\"layer%d, %d Hz, %d kbits/s, \",\n\n           s->layer, s->sample_rate, s->bit_rate);\n\n    if (s->nb_channels == 2) {\n\n        if (s->layer == 3) {\n\n            if (s->mode_ext & MODE_EXT_MS_STEREO)\n\n                printf(\"ms-\");\n\n            if (s->mode_ext & MODE_EXT_I_STEREO)\n\n                printf(\"i-\");\n\n        }\n\n        printf(\"stereo\");\n\n    } else {\n\n        printf(\"mono\");\n\n    }\n\n    printf(\"\\n\");\n\n#endif\n\n    return 0;\n\n}\n", "idx": 14459, "substitutes": {"s": ["hs", "session", "site", "v", "ts", "its", "states", "sys", "si", "m", "plugins", "xs", "self", "n", "spec", "h", "i", "qs", "sb", "js", "services", "t", "native", "rates", "ps", "client", "sync", "fs", "o", "ins", "cs", "e", "parts", "ss", "ssl", "new", "sq", "gs", "sports", "details", "is", "c", "sg", "ns", "settings", "bis", "us", "sites", "l", "ds", "service", "this", "obs", "stats", "http", "status", "ses", "sym", "S", "ops", "comments", "d", "rs", "features", "server", "full", "bs", "g", "es", "ks", "os", "p", "b", "aws", "sets", "f", "ings", "ls", "r", "conf"], "header": ["headers", "hash", "filter", "v", "gender", "later", "border", "writer", "meta", "response", "channel", "her", "date", "h", "ver", "master", "driver", "prev", "prot", "e", "image", "magic", "counter", "ssl", "queue", "offset", "num", "block", "handler", "c", "input", "line", "hidden", "metadata", "outer", "buffer", "event", "forward", "null", "cover", "iter", "first", "data", "message", "head", "size", "definition", "pper", "Header", "key", "status", "liner", "stream", "cookie", "text", "code", "body", "document", "dr", "numbered", "content", "reader", "source", "feature", "inner", "server", "page", "frame", "player", "bridge", "config", "version", "layer", "er", "request", "number"], "sample_rate": ["sampleAcrate", "samplealrated", "sample_grade", " sample_rates", "sample_rating", "samplealprice", "sample64rating", "sample64grade", "Sample_term", "sample_number", "sample_rates", "Sample_charge", "sample_price", "samplealrate", "sampleAcprice", "sample64number", " sample_price", "sample_size", "sample_charge", "sample64name", "sampleacspeed", "sample64size", "Sampleacspeed", " sample_size", "Sample_rate", "Sampleacrate", "sample64width", "scale_grade", "sample2rating", "sampleaccharge", " sample2rating", "sampleacrate", "Sampleacprice", "sample_score", "samplealrates", " sample_number", "sample_term", "sample64score", "sample2rate", " sample_name", " sample_rating", " sample_width", "scale_score", " sample2rate", "sampleAcspeed", "sample_rated", "sampleAccharge", " sample2number", " sample_rated", "Sample_size", "sampleacprice", "Sample_speed", "scale_rate", "sample64rate", "sample_name", "sample2number", "sample_width", "sample_speed", "scale_size", "Sample_price", "sample2width", " sample2width", "Sampleaccharge"], "frame_size": ["module64content", " frame_use", "slice_size", "frame_member", "module64source", "frame_term", " frame_scale", "frameacsize", "view_sized", "game_function", " frame_content", "byte_size", "frame64source", "frame64style", "frameacshape", "sample_ize", "byte64memory", "fram_body", "frame_sized", "frame_Size", "game_term", "sequence_length", "frame_offset", "slice_storage", "frame67function", "frame_address", "frameaccost", "frame_rate", " frame_gap", "sample_size", "byte64size", "framealsize", "frame_fee", "frameingsize", "frame_ize", "frame64size", " frame_shape", "frame_length", "frame_color", "frame_strength", "module_size", "sample_strength", "game_size", "sequence_size", "game_sized", "frame64ize", "module64size", "frame_storage", "frameacfunction", "frame64offset", "frame_cost", "game_scale", "frame_use", "module_style", "view_size", "framealoffset", "framexscale", "byte64offset", "frameingsized", "fram_size", " frame_member", "module64style", "frame_body", "frameacoffset", "frame64sized", "byte_sized", "frame64memory", "frame_style", "game_color", "byte_memory", "frame67sized", "frame_source", " frame_strength", "byte_offset", "frame_memory", "frameacscale", "frame64scale", "framexsized", "framexsize", "slice_source", " frame_offset", " frame_address", "frameingmemory", "fram_rate", "frameacsized", "view_Size", "module_content", "frameacrate", "frame_function", "module_source", "frame_scale", "frame64content", " frame_cost", " frame_sized", "frame67size", "framealmember", "frameacmemory", "frame67scale", "framexgap", "frame_content", "frame_shape", "view_strength", " frame_rate", "sequence_fee", "frameingoffset", " frame_ize", "frame_gap", "byte64sized"], "mpeg25": ["mpeg75", "gg75", "peg125", "mp75", "mp25", "ogg125", "camera35", "video25", "ogg15", "wav25", "mpeg24", "mpeg15", "wav125", "camera50", "mp24", "peg15", "gg25", "mpeg23", "mpeg20", "peg20", "peg25", "wav23", "mpeg125", "camera20", "peg50", "video75", "gg125", "video50", "wav24", "mp23", "peg24", "peg75", "mpeg50", "mp35", "ogg25", "ogg75", "mp20", "mpeg35", "camera25", "peg35", "wav75", "gg15", "peg23", "mp125", "mp50", "video125"], "padding": ["prefix", "trace", "performance", "large", "gap", "packing", "height", "position", "temp", "length", "protection", "duration", "size", "password", "tracking", "align", "timeout", "pad", "space", "border", "pixel", "offset", "scale", "skip", "np", "wrapper", "power", "adding", "ip", "ppa", "margin", "pointer", "binding", "layer", "p", "crop", "pressure", "parser", "buffer", "value", "alpha", "radius", "ping"], "sample_rate_index": ["sample_size_size", "sample_status_index", "sample_rate_ini", "sample_rate2position", "sample_size_position", "sample_status_number", "sample_rate_size", "sample_rate_position", "sample_rate_pointer", "sample_size_ini", "sample_size_pointer", "sample_rate_ind", "sample_size_index", "sample_wave_index", "sample_rate2pointer", "sample_rate_point", "sample_scale_length", "sample_status_position", "sample_rate_inc", "sample_scale_position", "sample_rate_slice", "sample_rate2index", "sample_rate2ini", "sample_rate_number", "sample_wave_ini", "sample_scale_index", "sample_rate_offset", "sample_rate2size", "sample_size_point", "sample_wave_length", "sample_rate2slice", "sample_status_offset", "sample_wave_ind", "sample_scale_point", "sample_rate_x", "sample_rate2point", "sample_rate_length", "sample_size_slice"], "bitrate_index": ["bitrate_field", "bitrate_address", "bitrate__index", "bitration_number", "bitrate_Index", "bitrating_Index", "bitration_index", "bitrate__field", "bitration_ind", "bitrate_size", "bitrating_field", "bitrating_index", "bitrate__Index", "bitrate__left", "bitration_size", "bitrate_ind", "bitrating_left", "bitrate_number", "bitrate_left"]}}
{"project": "FFmpeg", "commit_id": "2d66fc543b01995d6146fc132a778d3e722ca665", "target": 1, "func": "static av_cold int init(AVFilterContext *ctx, const char *args)\n\n{\n\n    GradFunContext *gf = ctx->priv;\n\n    float thresh = 1.2;\n\n    int radius = 16;\n\n\n\n    if (args)\n\n        sscanf(args, \"%f:%d\", &thresh, &radius);\n\n\n\n    thresh = av_clipf(thresh, 0.51, 255);\n\n    gf->thresh = (1 << 15) / thresh;\n\n    gf->radius = av_clip((radius + 1) & ~1, 4, 32);\n\n\n\n    gf->blur_line = ff_gradfun_blur_line_c;\n\n    gf->filter_line = ff_gradfun_filter_line_c;\n\n\n\n    if (ARCH_X86)\n\n        ff_gradfun_init_x86(gf);\n\n\n\n    av_log(ctx, AV_LOG_VERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius);\n\n\n\n    return 0;\n\n}\n", "idx": 14469, "substitutes": {"ctx": ["cam", "exec", "jp", "cm", "tc", "sc", "cs", "nc", "bc", "pkg", "sci", "obj", "cf", "cmd", "cb", "kb", "qa", "anc", "Context", "cc", "cmp", "uc", "rc", "config", "cca", "lc", "ck", "linux", "vc", "ci", "init", "context", "c", "conv", "cp", "core", "component", "cli", "kw", "ctrl", "tx", "crit", "ca", "mc", "xc", "loc", "conn", "cms", "cas", "cv"], "args": ["includes", "actions", "alloc", "afi", "ars", "Args", "ar", "all", "data", "empty", "cs", "ras", "obj", "magic", "cb", "parts", "params", "size", "objects", "limits", "api", "gs", "arms", "a", "icks", "config", "g", "friends", "ks", "arg", "np", "spec", "init", "context", "extra", "axis", "c", "s", "p", "range", "inc", "atts", "arc", "aws", "arr", "series", "flags", "call", "err", "argument", "fields", "arm", "array"], "gf": [" gdf", "gfe", "kf", "gasfs", "gfac", "gbc", "Gcf", "ogfe", "gif", "arginf", "graff", "kfc", "guc", " gfo", "qfo", "graf", "egf", " gfac", "genfs", "gbfac", "gc", "Gfe", "ginf", "gbfs", " gfs", "genfe", "ogdf", "genf", "sgf", "ogcf", "gdf", "kif", "grafs", "qf", " gb", "gufs", "argff", "gnf", "agff", "gasfo", "Gdf", "Gc", "gufac", " gc", "guf", "grainf", "gencf", "argf", " gfe", "aginf", "gnfs", "egif", "sgc", "sgfs", "gfs", "gbf", "Gf", "gendf", "gasf", "qfs", "egfc", " gfc", "gndf", "gfc", "gfo", "gasb", "ogf", "gnfe", " gif", "argfs", "agfs", "qb", "agf", "gff", "Gfs", "gb", "gcf"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n", "idx": 14476, "substitutes": {"client": ["prefix", "connection", "global", "local", "command", "project", "image", "con", "pc", "Client", "server", "path", "conf", "config", "parent", "man", "cache", "node", "http", "clean", "cli", "public", "child", "port", "remote", "cell", "conn", "custom"], "enable": ["execute", "update", "debug", "en", "address", "hide", "send", "pire", "apply", "mode", "force", "use", "end", "activate", "open", "online", "style", "write", "ure", "valid", "disable", "ignore", "like", "add", "Enable", "line", "active", "core", "run", "start", "enabled", "pin", "allow", "enh", "show"]}}
{"project": "FFmpeg", "commit_id": "fc8fa007fb6099643a1f742a162e5e5eda760fd6", "target": 0, "func": "static int64_t rtmp_read_seek(URLContext *s, int stream_index,\n\n                              int64_t timestamp, int flags)\n\n{\n\n    RTMP *r = s->priv_data;\n\n\n\n    if (flags & AVSEEK_FLAG_BYTE)\n\n        return AVERROR(ENOSYS);\n\n\n\n    /* seeks are in milliseconds */\n\n    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);\n\n    if (!RTMP_SendSeek(r, timestamp))\n\n        return -1;\n\n    return timestamp;\n\n}\n", "idx": 14499, "substitutes": {"s": ["client", "fs", "https", "sv", "rs", "sc", "cs", "e", "server", "ds", "si", "ss", "ssl", "service", "m", "sq", "gs", "sf", "sec", "es", "os", "ctx", "c", "secure", "ns", "p", "b", "sl", "f", "src", "sb", "ses", "js", "w", "ls", "socket", "S", "services", "t", "support"], "stream_index": ["ream_position", "ream_index", "stream_offset", "stream_position", "ream_offset"], "timestamp": ["lifest", "threadetz", "timpoint", "mintest", "tenempt", "imestamp", "lifemark", "imempt", "stimpoint", "tenestamp", "Timemark", "timeest", "Timetz", "nullestamp", "timempt", "timeline", "stimestamp", "Timera", "stimetz", "lifestamp", "mintera", "Timpoint", "tmempt", "stimera", "mintestamp", "stimeline", "timera", "stimest", "timeestamp", "timeetime", "teneline", "imetime", "timest", "timemark", "imest", "timetime", "tenetime", "timeemark", "timetz", "threadest", "lifetime", "mintetz", "Timeline", "Timestamp", "Timetime", "tmeline", "tmestamp", "tmetime", "nullest", "nulletz", "impoint", "imeline", "Timest", "threadestamp"], "flags": ["FLAG", "prot", "seconds", "fs", "ints", "files", "options", "fee", "relations", "Flags", "data", "reads", "mask", "fl", "ts", "format", "planes", "features", "parts", "types", "links", "times", "plugins", "fps", "properties", "bits", "stats", "args", "forces", "bytes", "status", "vals", "frames", "f", "flag", "bugs", "settings", "fields", "ags", "ants", "lag", "ops"], "r": ["d", "ru", "o", "dr", "rs", "ar", "R", "rar", "reader", "v", "e", "u", "rh", "l", "m", "lr", "nr", "rr", "ra", "rc", "g", "rb", "fr", "hr", "c", "p", "req", "b", "mr", "sr", "f", "re", "w", "rl", "er", "rg", "t"]}}
{"project": "FFmpeg", "commit_id": "6df1cfa7e4d488051d7b5033c0c69df970db9f82", "target": 0, "func": "static av_cold int mace_decode_init(AVCodecContext * avctx)\n\n{\n\n    MACEContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&ctx->frame);\n\n    avctx->coded_frame = &ctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 14508, "substitutes": {"avctx": ["avelc", "avcmp", "afcontext", "aucmp", "AVcontext", "auctrl", "afca", "avcca", "AVctrl", "AVcmp", "afctrl", "auctx", "avca", "afpkg", "avepkg", "avectx", "awcontext", "awctx", "avpkg", "aucontext", "awlc", "afcmp", "afctx", "AVctx", "avlc", "avctrl", "afcca", "AVca", "aveca", "aflc", "avecmp", "AVcca", "avecca", "avecontext", "avcontext", "awpkg"], "ctx": ["aux", "cam", "alloc", "cu", "cn", "soc", "cm", "tc", "sc", "cs", "obj", "pkg", "cf", "cfg", "cb", "cmd", "voc", "qa", "cc", "cmp", "conf", "dc", "lc", "config", "cca", "vc", "ci", "pa", "fc", "context", "c", "cp", "cli", "component", "coll", "kw", "ctrl", "tx", "ca", "wcs", "cci", "xc", "loc", "fw", "conn", "cms", "cas", "cv"]}}
{"project": "qemu", "commit_id": "1bf6beec8a012cae4bb6fbc89c465127e9650c92", "target": 1, "func": "float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM)\n\n{\n\n    flag aSign;\n\n    int_fast16_t aExp;\n\n    uint32_t aSig;\n\n    uint32_t mask;\n\n    uint32_t increment;\n\n    int8 roundingMode;\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n    if ( aExp == 0xFF ) {\n\n        if (aSig) {\n\n            /* Input is a NaN */\n\n            float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR );\n\n            if (!ieee) {\n\n                return packFloat16(aSign, 0, 0);\n\n            }\n\n            return r;\n\n        }\n\n        /* Infinity */\n\n        if (!ieee) {\n\n            float_raise(float_flag_invalid STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n        return packFloat16(aSign, 0x1f, 0);\n\n    }\n\n    if (aExp == 0 && aSig == 0) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    /* Decimal point between bits 22 and 23.  */\n\n    aSig |= 0x00800000;\n\n    aExp -= 0x7f;\n\n    if (aExp < -14) {\n\n        mask = 0x00ffffff;\n\n        if (aExp >= -24) {\n\n            mask >>= 25 + aExp;\n\n        }\n\n    } else {\n\n        mask = 0x00001fff;\n\n    }\n\n    if (aSig & mask) {\n\n        float_raise( float_flag_underflow STATUS_VAR );\n\n        roundingMode = STATUS(float_rounding_mode);\n\n        switch (roundingMode) {\n\n        case float_round_nearest_even:\n\n            increment = (mask + 1) >> 1;\n\n            if ((aSig & mask) == increment) {\n\n                increment = aSig & (increment << 1);\n\n            }\n\n            break;\n\n        case float_round_up:\n\n            increment = aSign ? 0 : mask;\n\n            break;\n\n        case float_round_down:\n\n            increment = aSign ? mask : 0;\n\n            break;\n\n        default: /* round_to_zero */\n\n            increment = 0;\n\n            break;\n\n        }\n\n        aSig += increment;\n\n        if (aSig >= 0x01000000) {\n\n            aSig >>= 1;\n\n            aExp++;\n\n        }\n\n    } else if (aExp < -14\n\n          && STATUS(float_detect_tininess) == float_tininess_before_rounding) {\n\n        float_raise( float_flag_underflow STATUS_VAR);\n\n    }\n\n\n\n    if (ieee) {\n\n        if (aExp > 15) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0);\n\n        }\n\n    } else {\n\n        if (aExp > 16) {\n\n            float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n    }\n\n    if (aExp < -24) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    if (aExp < -14) {\n\n        aSig >>= -14 - aExp;\n\n        aExp = -14;\n\n    }\n\n    return packFloat16(aSign, aExp + 14, aSig >> 13);\n\n}\n", "idx": 14521, "substitutes": {"a": ["aux", "d", "ba", "o", "address", "img", "ar", "la", "aaaa", "source", "e", "sa", "image", "u", "l", "access", "password", "in", "y", "an", "ata", "m", "ga", "ai", "new", "parse", "ae", "sta", "ea", "g", "z", "audio", "ac", "am", "c", "input", "i", "args", "mac", "window", "s", "p", "active", "ama", "missing", "b", "A", "va", "wa", "f", "as", "ca", "ab", "ao", "au", "abc", "any", "aa", "alpha", "aaa", "da", "array", "ad", "aw"], "STATUS_PARAM": ["STATUS_VAM", "STATUS_PARA", "STATUS_ARAR", "STATUS_VA", "STATUS_STRAMS", "STATUS_ARAM", "STATUS_PARAR", "STATUS_ARAMS", "STATUS_ARA", "STATUS_STRAR", "STATUS_VAR", "STATUS_STRAM", "STATUS_STRA", "STATUS_VAMS", "STATUS_PARAMS"], "aSign": ["areaSign", "eaPay", "iSign", " aPen", "iPull", "anPass", "aSize", " aNeg", "bSc", "saExp", "anSign", "saNeg", "saClose", "saSign", " aPay", "anExp", "saDig", "bSign", "aPay", "anSc", "anaExp", "aSc", "aPull", "alphaExp", " aClose", "anaSc", "anaSign", "iSc", "eaExp", "alphaDig", " aShift", "eaSign", "anaPen", "aNeg", "ASize", " aPull", "saShift", "bSize", "alphaShift", "anShift", "aClose", " aDig", "anClose", " aSc", "aPen", "iClose", "saSc", "aDig", "areaNeg", "eaClose", "saPay", " aPass", "bDig", "alphaSign", " aSize", "anPay", "areaPay", "areaDig", "aShift", "saPass", "anPull", "aPass", "bExp", "ASign", "saPen", "AExp"], "aExp": ["alphaComp", "aaImp", "aEx", " aSec", "eCl", "saExp", "anSign", "saEx", "anEx", " aEnc", "anExt", "anEXP", "saSec", "anexp", "saSign", "anExp", "anOp", "aComp", "aImp", "anComp", "alphaExp", "saExt", "anSec", "pEx", "aEnc", "maSign", "aaCl", "aaExp", "anCl", "maEx", "aexp", " aComp", "pExp", "alphaEXP", "maExt", " aEx", "aEXP", "saEXP", " aCl", "eImp", "pEXP", "aaSec", "maExp", "AEx", " aEXP", "saOp", "eSec", " aImp", "pEnc", "aCl", " aExt", "aOp", "AExt", "AEnc", "alphaExt", "aExt", "alphaexp", "AEXP", "aSec", "eExp", "saCl", "ASign", "alphaEx", " aOp", "AExp", " aexp"], "aSig": ["aUsock", "aEsign", " aAsess", "aPsess", "aSuigma", " aAsIG", " aSick", "aSuign", "aAsign", "aSock", " aSigm", " aAsig", "aSeIG", "aSigma", "aSess", "aPsIG", "aSigs", "aAsigs", "aAsick", " aAsiz", "aSiz", "aSeig", "aIsig", " aAsigm", " aSigned", " aSigs", "aEsig", " aSuign", "AUsIG", "aPsig", " aAsign", "aDesig", "aAsigma", "aAsIG", " aSuIG", "aSligs", "aUsigs", "aDesIG", "aAsess", "AUsig", "aEsIG", "aEsiz", "aPsigs", " aSiz", "ASIG", "aAsigh", "aSeigs", " aSuigma", "aSignig", "aIsIG", "aSlig", "aSignigm", "aInsick", "aEsigm", "aAsiz", "aDesigma", " aSigh", "AUsock", "aSuig", "aSlIG", "aInsig", "aUsess", " aAsigh", " aAsigned", "aUsig", " aSess", "aSuIG", "aSligh", "aSignigs", "aUsIG", " aAsigs", "aSigm", "ASig", "aSick", " aSuig", "aSigniz", "aEsigh", "aDesock", "aEsigs", "aSigned", "aIsigned", "aSeign", "aInsigs", "aSuigs", " aSIG", "aInsIG", "aAsig", "aAsigned", " aSuigs", " aSigma", "aSIG", "aSigh", "aUsigma", "aEsigned", "aAsigm", " aAsick", "aIsigs", "AUsigma", "ASock", "aSuigh", "ASigma", "aSlign"], "mask": ["mark", "mm", "batch", "bug", "hide", "qq", "shift", "hash", "filter", "pull", "gain", "patch", "cm", "count", "iq", "match", "ask", "feature", "result", "fix", "pattern", "black", "image", "delay", "Mask", "strip", "qa", "depth", "shape", "pixel", "group", "map", "offset", "shadow", "comment", "error", "scale", "ix", "key", "skip", "keep", "lock", "ch", "block", "weight", "q", "max", "scan", "ban", "inc", "sign", "reason", "ack", "miss", "flag", "bit", "allow", "carry", "pass", "sum", "conf", "pack", "sk", "cover"], "increment": ["generments", "operments", "incrementation", "fillmented", "generension", "Decreement", "generment", "incement", "intmentation", "increament", "Increments", "improvements", "improvement", "improveement", " increasemented", "incation", "crementation", "Incrementation", "crement", "Decrement", "ironmentation", "improvemented", "incremented", "ironment", "Increation", "incmentation", "incMENT", "penement", "Incremental", "incmented", "intmental", "incmental", "improveament", "ironmented", "Incremented", "increement", "intmented", "Decreament", "Decrementation", "Increement", "incremental", "increension", "Increral", "increral", "fillmentation", "IncreMENT", " increaseral", "fillment", "operment", "incment", "intment", "increation", "crements", "penament", "incral", "penment", "penmentation", "Increment", "creMENT", "generement", "ironement", "genermented", "operement", "fillation", "Increension", "improveension", "increMENT", " increasementation", "opermentation", "improvementation", "genermentation", "increments", "incments", " increasement"], "roundingMode": ["hardningKind", "rounddingSetting", "roundeningmode", "roundisingMODE", "roundingKind", "roundeningKind", "roundingOrder", "roundisingMode", "Roundgingmode", "roundeningMod", "roundningSetting", "hardingKind", "rollinggingMODE", "roundtingmode", "RoundgingOrder", "rounddingKind", "roundINGMode", "Roundingmode", "roundeningMODE", "hardningSetting", "roundingmode", "roundingMod", "roundINGOrder", "rollingingMODE", "roundgingMod", "roundgingmode", "RoundgingMode", "rounddingMODE", "hardingMODE", "RoundingOrder", "hardningMODE", "roundgingMODE", "roundisingMod", "roundeningSetting", "roundgingMode", "RoundingMode", "roundingSetting", "roundgingOrder", "roundtingOrder", "hardingMode", "roundisingmode", "hardingSetting", "roundINGmode", "rollingingMode", "roundingMODE", "rollinggingMod", "roundningMODE", "rollinggingmode", "rounddingMode", "rollingingMod", "hardningMode", "roundeningMode", "rollinggingMode", "roundtingMode", "roundningKind", "rollingingmode", "roundningMode"]}}
{"project": "qemu", "commit_id": "0d8d7690850eb0cf2b2b60933cf47669a6b6f18f", "target": 0, "func": "int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes)\n\n{\n\n    unsigned int idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n\n\n    idx = vq->last_avail_idx;\n\n\n\n    total_bufs = in_total = out_total = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        target_phys_addr_t desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                if (in_bytes > 0 &&\n\n                    (in_total += vring_desc_len(desc_pa, i)) >= in_bytes)\n\n                    return 1;\n\n            } else {\n\n                if (out_bytes > 0 &&\n\n                    (out_total += vring_desc_len(desc_pa, i)) >= out_bytes)\n\n                    return 1;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14531, "substitutes": {"vq": ["svque", "vqu", " vf", " vqueue", "vb", "kqu", " vp", "svdq", " vdq", "vquery", "svf", "vck", "wque", "svck", "flquery", "bf", "svqa", "dque", " vc", " vquery", "svqq", "svc", "wck", "dqu", "lq", "wq", "kque", " vque", "wdq", "lqa", "svk", "dk", "svquery", "bq", "lc", "svb", "lp", "vk", "vf", "vc", "nqueue", "svqu", "vqa", "flf", " vck", " vqq", "vqq", "flq", "kk", "bb", " vb", "nque", "bque", "nqq", "svp", "vque", "kq", "flque", "dq", "nq", "vqueue", "vp", "svq", "svqueue", "vdq", " vqa"], "in_bytes": ["inxbytes", "inxlines", "in00bytes", "in24bytes", " in_windows", "in24lines", "in24loads", " in__total", "in_net", "in_pages", "in00lines", "out_net", "in_windows", "in_loads", "out_pages", "out_loads", "in__bytes", " in__lines", "in00windows", " in__bytes", " in_lines", "in_lines", "in__windows", "in00total", "inxpages", " in__windows", "inxnet", "in__lines", "in24total", "in__total", "out_lines"], "out_bytes": ["out_events", "outingdes", "outxgroups", "out67events", "outxbytes", "outMblocks", "inc_groups", "outxsteps", "out67groups", "out_des", "inc_steps", "outMbytes", " out_events", "in_blocks", "inc_des", " out_groups", "out_steps", "outxdes", "out_pieces", "out67bytes", "in_pieces", "inc_bytes", "outMpieces", "in_lines", " out_lines", "out67lines", "outingsteps", "out_blocks", "outinggroups", "outingbytes", "outMlines", "out_lines", "out_groups"], "idx": ["adz", "idxes", "idX", " idX", "midxc", "kidz", "idexc", "Idxs", " idz", "adxc", "idy", " idy", "indx", "Idy", "indxc", " idf", "Idx", "kidxc", "idf", "idez", "idxc", "kidx", "IdX", "adx", "indxs", "idef", "idexs", " idxc", "idex", " idxs", "Idxc", "midf", "idxs", "ideX", "midx", "adxes", " idxes", "kidxes", "midz", "idz", "indy"], "total_bufs": ["total_ufd", "total_bufn", "total_buffn", "total_ufses", "total_reqls", "total_ufis", "total_buffd", "total_ufs", "total_ufn", "total_reqes", "total_bufals", "total_pathses", "total_caps", "total_seqn", "total_bufds", "total_reqi", "total_buffs", "total_pooln", "total_ufi", "total_bufls", "total_bufi", "total_pooles", "total_seqis", "total_ufls", "total_pooli", "total_paths", "total_seqds", "total_seqals", "total_capds", "total_bufits", "total_pools", "total_ufds", "total_poolls", "total_ufals", "total_bufses", "total_reqn", "total_buffals", "total_bufes", "total_ufes", "total_pathd", "total_bufd", "total_poold", "total_pathits", "total_seqs", "total_capis", "total_capd", "total_reqd", "total_ufits", "total_reqs", "total_bufis", "total_seqd"], "in_total": ["in_base", "in__gross", "inPbytes", "inPtotal", "in67bytes", "in_meta", " in_stable", "in67meta", "in_gross", "out_normal", "in__total", "in67base", "inc_meta", "in67total", "in_stable", "inLtotal", "inPstable", "inPsum", "inc_bytes", "in__normal", " in_sum", "inc_total", "out_gross", "inLnormal", "inLgross", "inc_base", "in_normal", "in_sum"], "out_total": ["num_total", "out67token", "out67total", "out_token", "out_size", "outalltotal", "totalallsize", "outallgross", "total_gross", "output_total", "outallglobal", "totalallgross", "outallsize", "num_available", "out_available", "output_full", "output_errors", "total_total", "totalalltotal", "output_token", "out_max", "out67full", "num_max", "totalallglobal", "out_errors", "out_gross", "out_full", "out67errors", "total_size", "out_global", "total_global"], "max": ["orig", "cu", "ng", "act", "Max", "in", "limit", "scale", "parent", "self", "n", "init", "huge", "wrap", "start", "min", "cr", "diff", "none", "client", "height", "all", "temp", "total", "mod", "error", "num", "last", "can", "id", "cache", "ip", "x", "c", "ax", "cat", "MAX", "ca", "load", "chain", "count", "rest", "end", "cycle", "size", "parse", "key", "rec", "active", "name", "out", "step", "k", "ci", "current", "no", "cp", "info", "index", "cl", "inc", "co", "w", "final", "conf"], "num_bufs": ["num_bufses", "num_buffd", "num_refs", "num_brd", "num_ufp", "num_bufd", "num_bufts", "num_bufsets", "num_ucds", "num_ufses", "num_poolp", "num_outputd", "num__bufs", "num_pools", "num_ucts", "num_ufs", "num_poold", "num_poolps", "num_lims", "num_bufm", "num_brds", "num_ucd", "num_bufp", "num_bufps", "num_limses", "num__bufd", "num_outputs", "num_ucns", "num_poolds", "num__ucts", "num_bufds", "num_outputps", "num_ufns", "num_buffm", "num_buffs", "num_ucs", "num_outputm", "num_ucm", "num_brc", "num__ucd", "num_ufds", "num_poolsets", "num__ucds", "num_ufsets", "num_refsets", "num_limns", "num_refp", "num_ufps", "num_limd", "num_ufd", "num_poolts", "num_refd", "num_bufns", "num_ufc", "num_brs", "num__bufts", "num_ucc", "num_buffses", "num_ufm", "num__ucs", "num__bufds", "num_bufc", "num_poolm", "num_ufts", "num_buffns"], "desc_pa": ["desckpe", " desc_ca", "ascPpai", "asc_ba", "descKpas", "descriptionLp", "sec_pe", "des_ba", "descalpar", "desc__p", "descriptionkpa", "des_pa", "descPpar", "compCpa", "comp_pa", "descalpa", "descOpa", "desCpa", "desCp", "desc_pb", "descJapa", "descdpas", "desc_pse", "desckba", "descCca", "sec_pa", "desc_lia", "desKbase", "desc_pas", "description_ppa", "descriptionkpse", "desc_par", "descCba", "descpbase", "descdsea", "spec_lia", "desc_p", "desc__apa", "desc_pe", "desckopa", "desc_apa", "descCpi", "des_p", "descLPA", "recPapa", "description_opa", "description_p", " desc_apa", "descriptionLpas", "descJpb", "comp_pb", "specLPA", "desc_ca", "descCpai", "spec_PA", "description_sea", "comp_pai", "descalpai", "descPapa", "rec_pa", "descOpai", "descriptionkba", "compCpai", "asc_pa", "descLsea", "sec_opa", "descppa", "descppas", "desKpi", "ascPpar", "desc_sea", "compCpb", "descKpi", "desc_opa", "descPba", "descClia", "descPca", "description_pse", "rec_apa", "descCbase", "descppi", "descKpa", "spec_pa", "desClia", "description_pai", "des_pi", "descriptionLsea", "comp_apa", "description_ba", "descPpai", "recPpa", "compCapa", "des_lia", "description_pas", "descLpas", "descCapa", "desckpa", "desc_ppa", "recPppa", "ascPpa", "recPca", "descLp", "descdpa", "descJpai", "asc_par", "rec_ca", "descalba", "descCpas", "asc_pai", "descCpa", "ascPba", "descCppa", "descCpb", "descOba", "descdp", "desckpai", "sec_ppa", "descriptionLpa", "descCp", "desc_base", "desc_PA", " desc_p", "descriptionkpai", "descKbase", "specLlia", "spec_pas", "desKpas", "descLlia", "descOpse", "descPpse", "descLpa", "descPpa", "desckppa", "desckpse", "desc_pi", "desKpa", "desc__pa", "description_pe", "des_base", "specLpas", "des_pas", "descPppa", "rec_ppa", "desc__ca", "desCba", "specLpa", "descJpa", "desc_ba", "description_pa", "desc_pai"], "i": ["it", "part", "d", "ie", "di", "gi", "chi", "ini", "iu", "fi", "t", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "y", "ai", "ui", "m", "api", "ti", "z", "ix", "key", "eni", "n", "ci", "id", "mini", "io", "qi", "ip", "c", "phi", "x", "hi", "info", "p", "index", "b", "ni", "f", "start", "zi", "ind", "j", "ii", "is", "I", "yi"]}}
{"project": "qemu", "commit_id": "bd5c51ee6c4f1c79cae5ad2516d711a27b4ea8ec", "target": 0, "func": "static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 14557, "substitutes": {"fd_in": ["FD_slice", "fd_IN", "fd_ini", "fd___ini", "fdalldown", "FD_out", "fdallin", "fdPdown", "fdallout", "fd_inner", "FD_IN", "dir___in", "fd_down", "fdPout", "fd___out", "dir_down", "dir___ini", "fdallslice", "dir_out", "dir_in", "fd___slice", "fd___down", "fd___in", "dir___out", "dir_ini", "fdPin", "dir___down", "FD_in", "fdPini", "FD_down", "FD_inner", "fd_slice"], "fd_out": ["fd_output", " fid_write", "fd_p", " fid_for", "fd___out", "fd___write", "fdxout", "fd_for", "fdxwrite", "fd_off", "cond_out", "FD_out", "fdxsource", "fd___source", "fd_write", "fdxfor", "cond_in", " fid_out", "cond_outs", "cond_output", "draft_off", "draft_inner", " fid_source", "fd_outs", "fd_again", "fd___for", "fd_inner", "fd_source", "FD_p", "FD_in", "draft_again", "draft_out"], "chr": [" chrn", "cyr", "CHrr", "echrr", "hrc", "CHr", "ichrc", "cherre", "shre", "macrt", "macr", "cher", "cherc", " chrf", "charnr", "macrb", "gyrt", "chrc", "kyrr", "hr", "cherr", " chlr", "qr", "gyrb", "qrar", "kyrer", "achr", "chrar", "macrr", "chru", " chrb", "colrt", "corerb", "chrb", "kyrb", "charr", "gyrer", "ichr", "cherb", "chra", "chesr", "collr", "ichrar", "CHnr", "cherrb", "CHrar", "gyr", "echr", "whru", "gyrf", "hrar", "countru", "echlr", "colrr", "chere", "cyre", "ichnr", " chrt", "shrb", "achrn", "qnr", "countra", " chsr", "qar", "whrb", "chenr", "shr", "gyrr", "whr", "cherru", "chsr", "chrn", "echrt", "cyrb", "corerer", " chrer", "chrt", "chre", "qrc", "cherf", "chert", "countrb", "qrt", "achrer", "chnr", "ichsr", "chrf", "gyrn", "shsr", "ichrf", "chear", "cyru", "charrr", "chera", "chrr", " chnr", "countr", "chrer", "ichra", "corerr", "charrar", "qrr", "qra", "colr", "chlr", "cheru", " chre", " chrc", "corer", "achrf", "cherer", "whra", "kyr", " chrr", "hra"], "s": ["ps", "storage", "fs", "sync", "d", "o", "session", "sv", "rs", "south", "t", "v", "e", "u", "cs", "l", "server", "ds", "sys", "si", "resource", "ss", "in", "ssl", "service", "m", "sq", "gs", "sf", "a", "g", "self", "n", "os", "spec", "rss", "is", "c", "http", "i", "su", "sg", "h", "p", "ns", "scope", "status", "b", "sl", "f", "sr", "sb", "w", "ses", "js", "share", "settings", "stat", "r", "ls", "sym", "S", "socket", "conf"]}}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    const int16_t *samples = (const int16_t *)frame->data[0];\n\n    int nb_samples, out_size, ret;\n\n\n\n    out_size = (frame->nb_samples + 1) / 2;\n\n    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))\n\n        return ret;\n\n\n\n    nb_samples = frame->nb_samples - (frame->nb_samples & 1);\n\n\n\n    if (avctx->trellis)\n\n        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);\n\n    else\n\n        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);\n\n\n\n    /* handle last frame with odd frame_size */\n\n    if (nb_samples < frame->nb_samples) {\n\n        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };\n\n        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 14566, "substitutes": {"avctx": ["akpkg", "avcmp", "akkb", "afcontext", "AVcontext", "afkb", "airxc", "avcca", "akctx", " avcontext", "afconfig", "aveconfig", "akconfig", "akcontext", "AVpkg", "avconfig", "AVcmp", "evctx", "auctx", "aveconn", "afpkg", "avkb", " avqa", "aucca", "avepkg", "avectx", "aircontext", " avconn", "avpkg", "aveqa", "aucontext", "afconn", "AVxc", "afcmp", "afctx", "AVctx", "aircmp", "afcca", "airctx", "AVconfig", "evcmp", "evcontext", "avecmp", "afqa", "avxc", "avqa", "evconn", "afxc", "akcca", "avconn", "avekb", "avecontext", "akcmp", "avcontext", "auconfig"], "avpkt": ["AVcpkt", "avckt", "AVpacket", "AVpett", "avpct", "afpelt", "AVcpqt", "avfkit", "avmkt", "AVbpett", "AVcpet", "avtkt", " avtpkt", "avbpacket", "affett", "avPkt", "apppdc", " avpilot", "AVpqt", "AVbpacket", "avpbke", "avPkit", "avnpkt", "avtct", "avcilot", "appnpdc", "avcpqt", "avpyth", "avcpacket", "avpreacket", "AVpyth", "avPke", "afpacket", "avcpelt", "AVpkt", "avprekit", "avnpke", "avmqt", "avpacket", "avnpdc", "avbpyth", "avtacket", "appnpkt", "AVbpkt", "avfct", "avcpett", "affacket", "avfkt", "avpbkt", " avpet", "affct", "avcpilot", "avtpilot", " avtpqt", "avpkit", "avcpyth", "avPett", " avtpilot", "avpilot", "avPelt", "avtpqt", "avmet", "avmyth", "avmacket", "apppelt", "avfett", "avfelt", "avbpett", "avpqt", "avcqt", "avpet", "avpke", "avcpkt", "avcet", "affkt", "AVpet", "appnpelt", "afpett", "avtpkt", "avfqt", "avpreett", "avbpkt", "avpett", "AVcpacket", "avpelt", "avcpct", "apppke", "afpkit", "appnpke", "afpkt", "avtpet", "avtelt", "avPacket", "avpbelt", "affelt", "avfacket", "avprekt", "avpbdc", "avcpet", "AVbpyth", "avnpelt", "avPdc", "apppkt", " avpqt", "afpct", "affkit", "avpdc", " avtpet", "avfet", "avmett"], "frame": ["module", "document", "iframe", "file", "plane", "flow", "fi", "position", "za", "data", "thread", "e", "image", "feature", "fram", "cf", "process", "message", "package", "model", "fb", "element", "cycle", "play", "style", "def", "note", "header", "object", "zip", "Frame", "state", "slice", "time", "parse", "host", "scale", "word", "point", "block", "fr", "ce", "cast", "fake", "ze", "line", "date", "zone", "range", "core", "component", "cfg", "f", "frames", "name", "game", "setup", "framework", "event", "ace", "video", "function", "sequence", "code"], "got_packet_ptr": ["got_packetallpty", "got_packet__pointer", "got_packacket_ptr", "got_packacket_offset", "got_packacket_ctr", "got_packetalltr", "got_packet__offset", "got_packet__ptr", "got_packacket_pty", "got_packacket_pointer", "got_packacket_tr", "got_packet_offset", "got_packet_ctr", "got_packet_pty", "got_packet_pointer", "got_packetallptr", "got_packetallpointer", "got_packet_tr", "got_packet__ctr"], "c": ["d", "ct", "o", "cu", "oc", "v", "cm", "tc", "e", "cs", "bc", "C", "u", "nc", "cf", "cit", "l", "pc", "cd", "anc", "ec", "cc", "dc", "m", "uc", "a", "lc", "config", "g", "k", "self", "ac", "cv", "ch", "ci", "vc", "ctx", "ce", "cache", "context", "h", "s", "p", "core", "b", "cy", "arc", "coll", "co", "f", "cr", "mc", "r", "xc", "t", "code"], "samples": ["passample", "ssample", "scizes", "passamples", "schanges", "assims", "bisages", "asources", "lales", " sages", "sesamps", " sims", "sales", "sizes", " samps", "pamps", "scample", "sources", "lamples", " sonents", "psamps", "passizes", "samps", "nample", "psample", " sample", "ssamples", "asales", "ponents", "bisims", "sesizes", "psamples", "scamps", "lources", "assages", "sesample", "psonents", "namps", "ssamps", " schanges", "lamps", "passamps", "assamples", "asschanges", "namples", "sages", "asamples", "sims", "sample", "asamps", "pample", "bisamples", "sonents", "scamples", "pamples", "sesamples", "bischanges"], "nb_samples": ["nb_servicesessions", "nb_esamples", "nb64psamples", "nb_Samps", "nb_namples", "nb_siffs", "nb_sidites", "nb_suffamples", "nb_timesessions", "nb_testsourses", "nb_offsamps", "nb_tamples", "nb___samples", "nb64psipes", "nb_namps", "nb___timesizes", "nb_lessills", "nb_bores", "nb_seeds", "nb_testsonents", "nb_inseeds", "nb_spaces", "nb_ssims", "nb_timesourses", "nb64samples", "nb_ssources", "nb_timesizes", "nb_testsites", "nb___timesonents", "nb_sources", "nb_simens", "nb_sessions", "nb_testsizes", "nb_timesamps", "nb_insizes", "nb_offsamples", "nb_sesamples", "nb_sills", "nb_lessamples", "nb_bamples", "nb_Sizes", "nb_tites", "nb_sites", "nb_tannels", "nb_testsessions", "nb_testsiffs", "nb_servicesamples", "nb_psipes", "nb_tonents", "nb64sims", "nb_sesongs", "nb_esills", "nb_tamps", "nb_testsounds", "nb_timesonents", "nb_sesources", "nb_aseeds", "nb_asamps", "nb_samps", "nb_testsipes", "nb_psamples", "nb_Songs", "nb_insiffs", "nb_insounds", "nb_sizes", "nb_sesourses", "nb_testsources", "nb_lessapes", "nb_sores", "nb_testsamples", "nb_devicesizes", "nb_esamps", "nb_lessamps", "nb_testseeds", "nb_timesources", "nb_testsamps", "nb_bims", "nb_nannels", "nb_sounds", "nb_ssamps", "nb_asiffs", "nb_suffizes", "nb_servicesimens", "nb_insamps", "nb_sourses", "nb_sespaces", "nb_testsannels", "nb_psources", "nb_statesonents", "nb_sonents", "nb_Sonents", "nb_sipes", "nb_servicesamps", "nb_asamples", "nb_psims", "nb_sims", "nb_sesamps", "nb_Sapes", "nb_psores", "nb_Sills", "nb___sizes", "nb_sannels", "nb_timesimens", "nb64sipes", "nb_sidonents", "nb_offsims", "nb_ssimens", "nb_devicesounds", "nb_esapes", "nb_insamples", "nb64sores", "nb_Spaces", "nb64psores", "nb_Samples", "nb_psamps", "nb_testsims", "nb___timesamples", "nb_statesamps", "nb_songs", "nb___sonents", "nb_bipes", "nb_devicesamps", "nb_sidamples", "nb_pspaces", "nb_testsores", "nb_sidamps", "nb_speconents", "nb64psims", "nb_timesamples", "nb_psongs", "nb_ssamples", "nb_offsources", "nb_devicesamples", "nb_specamples", "nb_nessions", "nb_sapes", "nb_specamps", "nb_suffonents", "nb_tessions", "nb_statesamples", "nb_ssessions"], "out_size": ["outlexlength", "out_length", "bytelexform", "out_scale", "byte_length", " out_ize", "Out__time", "Out_Size", "out__Size", "bytelexsize", "bytelexscale", "outlexscale", "out_Size", "byte_scale", "out__size", "bytelexlength", "byte_form", "byte_size", "out2size", "out_form", "Out_size", " out_Size", "out2ize", "Out_time", "out2Size", "out__time", "out2scale", "outlexsize", "out_ize", "Out__size", "Out__Size", "outlexform", " out_scale", "out_time"], "ret": ["ft", "fin", "success", " Ret", "reset", "nt", "bf", "repl", "ry", "match", "result", "obj", "rt", "desc", "att", "val", "def", "res", "det", "valid", "reply", "len", "al", "fun", "rc", "reg", "rb", "rets", "arg", "mem", "mt", "no", "run", "rep", "re", "out", "RET", "flag", "ner", "bit", "r", "value", "ref", "t", "alt", "Ret"], "last_samples": ["last_ussample", "last_sores", "last_Sizes", "last_shores", "last_nsample", "last_ssample", "last_usamples", "last_namps", "last_shims", "last_Samps", "last_sims", "last_Sores", "last_nizes", "last_Samples", "last_shamples", "last_usamps", "last_psamples", "last_psores", "last_psims", "last_namples", "last_shamps", "last_samps", "last_Ssample", "last_Sims", "last_psamps", "last_sizes", "last_usizes"]}}
{"project": "FFmpeg", "commit_id": "03d83ba34b2070878909eae18dfac0f519503777", "target": 0, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint32_t *palette,\n\n                                 const uint8_t *buf, const int linesize,\n\n                                 AVPacket *pkt)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len = 0, height = avctx->height, width = avctx->width, x, y;\n\n    int x_start = 0, y_start = 0, trans = s->transparent_index;\n\n    int honor_transparency = (s->flags & GF_TRANSDIFF) && s->last_frame;\n\n    const uint8_t *ptr;\n\n\n\n    /* Crop image */\n\n    if ((s->flags & GF_OFFSETTING) && s->last_frame && !palette) {\n\n        const uint8_t *ref = s->last_frame->data[0];\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        int x_end = avctx->width  - 1,\n\n            y_end = avctx->height - 1;\n\n\n\n        /* skip common lines */\n\n        while (y_start < y_end) {\n\n            if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width))\n\n                break;\n\n            y_start++;\n\n        }\n\n        while (y_end > y_start) {\n\n            if (memcmp(ref + y_end*ref_linesize, buf + y_end*linesize, width))\n\n                break;\n\n            y_end--;\n\n        }\n\n        height = y_end + 1 - y_start;\n\n\n\n        /* skip common columns */\n\n        while (x_start < x_end) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_start] != buf[y*linesize + x_start]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_start++;\n\n        }\n\n        while (x_end > x_start) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_end] != buf[y*linesize + x_end]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_end--;\n\n        }\n\n        width = x_end + 1 - x_start;\n\n\n\n        av_log(avctx, AV_LOG_DEBUG,\"%dx%d image at pos (%d;%d) [area:%dx%d]\\n\",\n\n               width, height, x_start, y_start, avctx->width, avctx->height);\n\n    }\n\n\n\n    /* image block */\n\n    bytestream_put_byte(bytestream, GIF_IMAGE_SEPARATOR);\n\n    bytestream_put_le16(bytestream, x_start);\n\n    bytestream_put_le16(bytestream, y_start);\n\n    bytestream_put_le16(bytestream, width);\n\n    bytestream_put_le16(bytestream, height);\n\n\n\n    if (!palette) {\n\n        bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    } else {\n\n        unsigned i;\n\n        bytestream_put_byte(bytestream, 1<<7 | 0x7); /* flags */\n\n        for (i = 0; i < AVPALETTE_COUNT; i++) {\n\n            const uint32_t v = palette[i];\n\n            bytestream_put_be24(bytestream, v);\n\n        }\n\n    }\n\n\n\n    if (honor_transparency && trans < 0) {\n\n        trans = pick_palette_entry(buf + y_start*linesize + x_start,\n\n                                   linesize, width, height);\n\n        if (trans < 0) { // TODO, patch welcome\n\n            av_log(avctx, AV_LOG_DEBUG, \"No available color, can not use transparency\\n\");\n\n        } else {\n\n            uint8_t *pal_exdata = s->pal_exdata;\n\n            if (!pal_exdata)\n\n                pal_exdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n\n            if (!pal_exdata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pal_exdata, s->palette, AVPALETTE_SIZE);\n\n            pal_exdata[trans*4 + 3*!HAVE_BIGENDIAN] = 0x00;\n\n        }\n\n    }\n\n    if (trans < 0)\n\n        honor_transparency = 0;\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf + y_start*linesize + x_start;\n\n    if (honor_transparency) {\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        const uint8_t *ref = s->last_frame->data[0] + y_start*ref_linesize + x_start;\n\n\n\n        for (y = 0; y < height; y++) {\n\n            memcpy(s->tmpl, ptr, width);\n\n            for (x = 0; x < width; x++)\n\n                if (ref[x] == ptr[x])\n\n                    s->tmpl[x] = trans;\n\n            len += ff_lzw_encode(s->lzw, s->tmpl, width);\n\n            ptr += linesize;\n\n            ref += ref_linesize;\n\n        }\n\n    } else {\n\n        for (y = 0; y < height; y++) {\n\n            len += ff_lzw_encode(s->lzw, ptr, width);\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    return 0;\n\n}\n", "idx": 14588, "substitutes": {"avctx": ["avcmp", "AVcms", "afcontext", "AVcontext", "apsconnection", "afkb", "avcca", "avconnection", " avcontext", "akctx", "afconfig", "akcontext", "afcdn", "apscontext", "avconfig", "AVcmp", "aircms", "aveconn", "avkb", "avcb", "navctx", "antctx", "avctl", "abcmp", "avectx", " avconfig", "aircontext", "abcu", "abctx", "avcms", "afcms", " avcb", "avcu", "afconn", "antcontext", "navctl", "akcdn", "afcmp", "afctx", "abcontext", "AVctx", "airconfig", "afcca", "airctx", "navkb", "AVcu", "AVconfig", "afctl", "apsctx", "navcb", "afcu", "antkb", "akconnection", "afconnection", "antctl", "avcdn", "apscdn", "AVcca", "navcontext", "avconn", "avecca", "avecontext", "navconfig", "afcb", "avcontext", "AVconn"], "bytestream": ["bytvream", "bytrib", "bytore", "byderore", "bytestrib", "astestore", "bytram", "astvore", "astvram", "bytvrib", "bytestore", "byderrib", "byderream", "astestram", "byderram", "astestrib", "astvream", "bytestram", "bytvram", "bytvore", "astvrib", "bytream", "astestream"], "end": ["client", "enc", "en", "append", "nd", "edge", "e", "pos", "length", "open", "post", "ended", "id", "feed", "stop", "max", "index", "device", "ending", "begin", "start", "mid", "port", "END", "text", "event", "code"], "palette": ["Palette", " palignment", "glignment", "glette", "Palettes", " pallette", "malotation", "palignment", " palettes", "Palignment", "malette", "gllette", "pallette", "palotation", "Palotation", "Pallette", "isalettes", "isallette", "isalotation", "palettes", "glettes", "isalette", "malettes", "mallette"], "buf": ["aux", "alloc", "img", "func", "grab", "uf", "br", "bc", "cf", "fab", "cb", "fb", "cmd", "wb", "pub", "border", "cap", "queue", "map", "vec", "uc", "pool", "seq", "rc", "config", "proc", "rb", "ctx", "cur", "buff", "home", "context", "box", "conv", "cp", "coord", "uv", "bag", "prop", "src", "ab", "fam", "port", "Buff", "que", "buffer", "console", "gb", "text", "filename", "cas", "pb", "cv"], "linesize": [" linesiz", "inesiz", "vertsize", "inesIZE", "linesization", "linersenge", "facesiz", "linksize", "codesize", "linesizable", "linsize", "inesization", "lightssize", "linesenge", "linessize", "linersiz", "linersize", "codesizes", " linessize", " linesIZE", "lightsization", " linesizable", "lightsIZE", "pinsenge", "codesizable", "vertsiz", "linsization", "linesizer", " linesization", "linksization", " linesizer", " linesizes", "imagesize", "imagessize", "pinsize", "lightsiz", "linersization", "lightsize", "lightsizer", "linesizes", "codesiz", "imagesizable", "facesization", "linesIZE", "pinsization", "inesize", "inesizes", "pinsiz", "inessize", "facesizing", " linesenge", "linesizing", "linksizer", "linsizing", "codessize", "linksiz", "linsiz", "vertsizing", "vertsization", "linesiz", "facesize", "imagesiz"], "pkt": ["plkt", "plunt", "Packet", "pct", "Punt", "Pkt", "placket", "plct", " packet", " punt", "punt", "packet", " pct", "Pct"], "s": ["ps", "storage", "sync", "ops", "d", "fs", "sv", "session", "rs", "data", "v", "cs", "e", "sa", "events", "ts", "parts", "server", "ds", "bis", "sys", "si", "ss", "ssl", "service", "conf", "sq", "gs", "sf", "a", "xs", "g", "ks", "n", "comm", "spec", "ctx", "is", "c", "h", "sg", "su", "p", "ns", "qs", "b", "sl", "aws", "f", "sb", "ses", "js", "stat", "ls", "services", "sym", "S", "t", "sk"], "x": ["d", "height", "data", "v", "e", "image", "l", "size", "m", "dx", "xy", "px", "g", "z", "n", "c", "h", "rx", "p", "index", "ex", "b", "f", "w", "X"], "y": ["ya", "d", "o", "height", "ay", "ky", "yn", "yo", "ys", "ry", "e", "yt", "iy", "year", "yr", "yan", "l", "ny", "lon", "m", "ady", "zy", "ym", "vy", "z", "key", "n", "ch", "id", "ey", "ish", "yer", "c", "h", "hi", "q", "p", "type", "b", "cy", "hy", "start", "f", "w", "Y", "dy", "yy", "ye", "sky", "oy", "sy", "py", "t", "j", "yi", "gy", "yl"], "ptr": ["trace", "ctr", "alloc", "bl", "tmp", "pt", "obj", "fe", "cb", "pad", "attr", "slice", "fd", "dim", "rc", "tr", "buff", "pointer", "addr", "src", "port", "buffer", "trans", "loc", "img", "dest", "rot"], "ref": ["part", "ha", "af", "aff", "REF", "data", "uf", "bf", "source", "count", "br", "pos", "Ref", "ff", "fab", "cb", "rel", "ob", "val", "def", "fat", "db", "cmp", "offset", "el", "ef", "comment", "url", "rc", "config", "pre", "reg", "parent", "rb", "rib", "block", "rec", "fr", "cache", "buff", "c", "pointer", "info", "reference", "p", "lib", "col", "req", "bb", "cal", "b", "f", "re", "lf", "ab", "diff", "buffer", "back", "loc", "conf", "alt", "pb"], "y_start": ["yamend", "yacend", "yacbegin", "y_source", "y0end", "x_started", "y001mid", "ey_start", "y00start", "y1count", "oy_first", "y__end", " y_min", "ny_range", "x_count", "y200center", "ny00mid", "y001address", "y67max", "y__begin", "x_center", "y00max", "ny_address", "y00source", "y_range", "ey_end", "yy_start", "y0center", "y___middle", "y67stop", "y200id", "y00mid", "x_range", "y_middle", "x_space", "y67first", "x_begin", "yy_max", "oy_start", "y_min", "y__start", "y001start", "y200start", "y_center", "y_max", "oy_stop", "yy_source", "y0id", "yamrange", "y_mid", "yacstart", "ny00address", "oy_max", "yy_end", "y___end", " y_started", "y__space", "y___start", "y001range", "x_middle", "yamstart", "y_id", "y_space", "ny_start", "y1range", "y_count", "y1end", "ny00range", "y_address", "y_started", "ny00start", "y_first", "y_Start", "y0start", "x_id", "y_add", "y_stop", "y1start", "y00address", "yamcount", "ey_add", "y67start", "ey_Start", "y200end", "y_begin", "y00range", "yacspace", "y___started", "ny_mid", "y00end"], "y_end": ["yacend", "sy_end", "y0stop", "dyallend", "ey0ension", "y0end", "ey0end", "y_ending", "ey_start", "y00start", "y_est", "dy_ends", "y25clean", "y0size", "yacsend", "ey0start", "y00send", "y0ended", "y_ended", "y_END", "dy_start", "y25open", "y0ension", "y___est", " y_nd", "y64end", "dyallending", " y_ends", "yalllast", "y25end", "sy_send", "ey_size", "ey_end", "y25ends", "yacending", "ry_stop", "dy_nd", "y_edge", "ry_est", "yallend", "y_ension", "yallending", "sy_ending", "x_END", "sy00ending", "y_clean", "y64open", "ey_open", "y_ends", "y00open", "yacstart", "ey00end", "dy_end", "ry_start", "dyalllast", "y64clean", "y___end", "y00clean", "dy_last", "ey00clean", "y___start", " y_ension", "ry_edge", "y___begin", "ey_ension", "y0start", "ry_begin", "sy00send", "y00ending", "dyallstart", "y_stop", "ey00open", "ry___est", "ry_ended", "y_send", "ey_ends", "y0edge", "dy_ending", "ry_end", "y_last", "sy_start", "sy00end", "yallstart", "ey_clean", "ey0size", "ry___end", "ry___begin", "y_size", "sy00start", "y_begin", "x_ended", "y00ends", "ry___start", "ey00ends", "y_open", "y64ends", "y_nd", "y00end"], "x_start": ["by_begin", "x_pos", "xFadd", "x00add", "xMsize", " x_middle", "xFbegin", "xMstarting", "by00mean", "lex_size", "by_add", "x00set", "x_count", "lex_start", "lex_set", "by00start", "x00count", "by_start", "x_add", "x00starting", "x00pos", "x_begin", " x_starting", "x00begin", "x_size", "x00mean", "x_starting", "xFstart", "x_set", "x_middle", "xMStart", "xMmiddle", "x_Start", "y_count", "by00add", "lex00starting", "x_stop", "xFmean", "y_pos", "by_mean", "lex00size", "by00begin", "xMend", "y_stop", "xMset", " x_Start", "x00start", "lex00set", "x00Start", "x_mean", "x00size", "xMstart", "lex_starting", "lex00start", "x00end"], "x_end": ["x67end", "wx_END", "y_enter", "x0end", "x00stop", "y_est", "x0start", "y_ended", "x67start", "x64enter", "x67stop", "y_edge", "x64stop", "x0ended", "x_END", "x64start", "x_est", "x_ending", "y_id", "x64end", "x67ended", "x_stop", "x0stop", "wx_ending", "x00enter", "wx_start", "x_id", "y_stop", "x_index", "x_enter", "x00start", "wx_end", "x_ended", "y_index", "x_edge", "x00end"]}}
{"project": "qemu", "commit_id": "9c4bab2668e6b5a9b69f77e3533380b6fd79034e", "target": 0, "func": "static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n", "idx": 14589, "substitutes": {"name": ["prefix", "part", "o", "file", "temp", "data", "image", "base", "size", "path", "fat", "cap", "new", "Name", "fd", "time", "a", "url", "parent", "ix", "word", "self", "key", "ame", "n", "id", "NAME", "am", "version", "home", "x", "c", "no", "ext", "type", "b", "f", "names", "old", "filename", "code"], "flags": ["FLAG", "fs", "ints", "files", "ports", "options", "ins", "fee", "locks", "Flags", "count", "cs", "mask", "ffff", "ff", "features", "types", "faces", "fun", "fps", "bits", "stats", " Flags", "args", "vals", "fx", "lf", "flag", "orts", "settings", "fields", "ents", "opens", "ants", "alls", "lag", "ops", "kind"]}}
{"project": "qemu", "commit_id": "67113c03423a23e60915574275aed7d60e9f85e1", "target": 0, "func": "static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n", "idx": 14591, "substitutes": {"d": ["done", "bd", "o", "di", "dt", "dr", "dom", "dos", "data", "md", "ld", "e", "u", "cd", "l", "dB", "dat", "ds", "db", "dc", "m", "die", "this", "fd", "pd", "dn", "dl", "config", "ded", "g", "z", "self", "de", "n", "id", "dh", "c", "x", "i", "p", "dd", "f", "dm", "dp", "ind", "D", "gb", "dy", "r", "gd", "t", "da", "ad"], "errp": ["ererror", "errerror", "errP", " errerror", "rP", " errP", "rerror", "erp", "rp", "erP"], "b": ["bd", "ba", "v", "e", "l", "fb", "orb", "dB", "ib", "B", "ob", "y", "db", "m", "lb", "bg", "a", "bs", "emb", "g", "rb", "n", "nb", "usb", "c", "pb", "i", "p", "bb", "f", "mb", "sb", "abb", "ab", "w", "eb", "gb", "xb", "j", "r", "t", "ad"], "ccsr": ["ctr", "rcrf", "rctr", "cnr", "ccrg", "ccnr", "cfradius", "cfrf", "accrg", "cftr", "cfsr", "ucnr", "cfr", "scsr", " ccnr", "crf", "ucsr", "scnr", "ccr", "scrf", "scmr", "cfmr", "cfnr", "ccarg", "ccradius", "cfrg", "ucr", "accnr", " ccrf", " ccmr", "ccanr", "accsr", "ccaradius", "cr", "rcsr", "csr", "ccmr", "ccasr", "rcnr", "cctr", "accradius", "ccrf", "uctr"]}}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}", "idx": 14599, "substitutes": {"out": ["prefix", "IN", "sync", "OUT", "o", "exec", "v", "Out", "obj", "outs", "output", "base", "work", "copy", "bin", "dot", "new", "In", "parent", "up", "point", "io", "init", "extra", "line", "ext", "window", "p", "inc", "co", "arr", "again", "err", "at", "conn", "array", "null"], "in": ["update", "IN", "ins", "ini", "connection", "exec", "data", "reader", "source", "con", "image", "inner", "isin", "vin", "query", "bin", "nin", "token", "inas", "login", "new", "In", "this", "slice", "lin", "a", "str", "gin", "rin", "rec", "ci", "id", "win", "init", "x", "input", "inc", "ic", "again", "inn", "diff", "or", "err", "pass", "old", "conn", "tin"], "size": ["en", "address", "shift", "Size", "empty", "cm", "e", "length", "si", "shape", "form", "time", "small", "scale", "g", "iz", "z", "ix", "six", "sized", "n", "capacity", "io", "c", "ice", "name", "grow", "SIZE", "white", "ii", "loc", "ize", "len", "number", "code"], "i": ["d", "di", "o", "gi", "ini", "mi", "iu", "t", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "y", "ai", "ui", "m", "a", "ti", "ix", "z", "k", "n", "ci", "id", "io", "bi", "is", "ip", "x", "c", "h", "qi", "hi", "p", "index", "b", "ni", "f", "start", "min", "zi", "ind", "w", "j", "r", "ii", "I", "yi"]}}
{"project": "FFmpeg", "commit_id": "c58d45e00489e07fd4606b64ad4095660494185b", "target": 1, "func": "static int film_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char scratch[256];\n\n    int i;\n\n    unsigned int data_offset;\n\n    unsigned int audio_frame_counter;\n\n\n\n    film->sample_table = NULL;\n\n    film->stereo_buffer = NULL;\n\n    film->stereo_buffer_size = 0;\n\n\n\n    /* load the main FILM header */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    data_offset = AV_RB32(&scratch[4]);\n\n    film->version = AV_RB32(&scratch[8]);\n\n\n\n    /* load the FDSC chunk */\n\n    if (film->version == 0) {\n\n        /* special case for Lemmings .film files; 20-byte header */\n\n        if (avio_read(pb, scratch, 20) != 20)\n\n            return AVERROR(EIO);\n\n        /* make some assumptions about the audio parameters */\n\n        film->audio_type = CODEC_ID_PCM_S8;\n\n        film->audio_samplerate = 22050;\n\n        film->audio_channels = 1;\n\n        film->audio_bits = 8;\n\n    } else {\n\n        /* normal Saturn .cpk files; 32-byte header */\n\n        if (avio_read(pb, scratch, 32) != 32)\n\n            return AVERROR(EIO);\n\n        film->audio_samplerate = AV_RB16(&scratch[24]);\n\n        film->audio_channels = scratch[21];\n\n        film->audio_bits = scratch[22];\n\n        if (scratch[23] == 2)\n\n            film->audio_type = CODEC_ID_ADPCM_ADX;\n\n        else if (film->audio_bits == 8)\n\n            film->audio_type = CODEC_ID_PCM_S8;\n\n        else if (film->audio_bits == 16)\n\n            film->audio_type = CODEC_ID_PCM_S16BE;\n\n        else\n\n            film->audio_type = CODEC_ID_NONE;\n\n    }\n\n\n\n    if (AV_RB32(&scratch[0]) != FDSC_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (AV_RB32(&scratch[8]) == CVID_TAG) {\n\n        film->video_type = CODEC_ID_CINEPAK;\n\n    } else\n\n        film->video_type = CODEC_ID_NONE;\n\n\n\n    /* initialize the decoder streams */\n\n    if (film->video_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->video_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id = film->video_type;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->width = AV_RB32(&scratch[16]);\n\n        st->codec->height = AV_RB32(&scratch[12]);\n\n    }\n\n\n\n    if (film->audio_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->audio_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = film->audio_type;\n\n        st->codec->codec_tag = 1;\n\n        st->codec->channels = film->audio_channels;\n\n        st->codec->sample_rate = film->audio_samplerate;\n\n\n\n        if (film->audio_type == CODEC_ID_ADPCM_ADX) {\n\n            st->codec->bits_per_coded_sample = 18 * 8 / 32;\n\n            st->codec->block_align = st->codec->channels * 18;\n\n        } else {\n\n            st->codec->bits_per_coded_sample = film->audio_bits;\n\n            st->codec->block_align = st->codec->channels *\n\n                st->codec->bits_per_coded_sample / 8;\n\n        }\n\n\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample;\n\n    }\n\n\n\n    /* load the sample table */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    if (AV_RB32(&scratch[0]) != STAB_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n    film->base_clock = AV_RB32(&scratch[8]);\n\n    film->sample_count = AV_RB32(&scratch[12]);\n\n    if(film->sample_count >= UINT_MAX / sizeof(film_sample))\n\n        return -1;\n\n    film->sample_table = av_malloc(film->sample_count * sizeof(film_sample));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        /* load the next sample record and transfer it to an internal struct */\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts /= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 /\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size /\n\n                    (film->audio_channels * film->audio_bits / 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 14612, "substitutes": {"s": ["fs", "sv", "ins", "sit", "sim", "v", "sc", "e", "cs", "sa", "sci", "ts", "l", "ds", "sys", "si", "ss", "service", "se", "m", "sed", "sq", "sf", "a", "g", "sports", "os", "spec", "c", "http", "su", "sg", "p", "sl", "f", "sb", "sie", "sav", "series", "ses", "sis", "js", "ls", "services", "setup", "S", "t", "support"], "ap": ["app", "ar", "tp", "amp", "aram", "pak", "att", "pac", "pi", "cap", "wp", "ai", "attr", "sp", "api", "al", "hp", " p", "ac", "am", "pa", "bp", "ppa", "aps", "ams", "ab", "au", "arp"], "film": ["fp", "list", "v", "fact", "fb", "icc", "flash", "inyl", "fen", "edit", "redd", "spec", "avi", "sell", "lib", "Film", "lv", "pl", "cel", "diff", "web", "front", "temp", "music", "director", "fuel", "kel", "media", "image", "fl", "liv", "crew", "sil", "starter", "play", "die", "izzle", "food", "lc", "audio", "iv", "videos", "voice", "drive", "load", "cover", "kl", "ideo", "oper", "bug", "material", "fi", "movie", "ll", "plug", "l", "tv", "international", "league", "lamm", "tt", "http", "coll", "iva", "conference", "design", "cell", "inf", "rol", "document", "coat", "internet", "feature", "technology", "sci", "length", "production", "vic", "fiction", "el", "player", "azine", "config", "life", "vc", "ell", "control", "iol", "f", "software", "ogg", "video"], "pb": ["fp", "prot", "mp", "afi", "cpp", "hub", "tp", "jp", "amp", "txt", "sc", "pt", "bc", "pc", "pm", "cb", "fb", "wb", "params", "rob", "summary", "pg", "db", "PB", "pd", "api", "lb", "lc", "bh", "audio", "rb", "lp", "np", "ctx", "pa", "fc", "bp", "ppa", "cp", "kk", "bb", "p", "bps", "prop", "sb", "pl", "dp", "ab", "abb", "verb", "ub", "eb", "buffer", "gb", "vp", "asm", "xb", "platform", "plugin"], "st": ["ct", "ST", "bl", "amp", "sc", "St", "sa", "pt", "rest", "ste", "stim", "ss", "sp", "inst", "sn", "sta", "sts", "est", "put", "ast", "sw", "sl", "src", "sb", "cr", "ost", "sth", "std"], "scratch": ["oscraw", " scrratch", "cleratch", "descrub", "clash", "scresh", "ucrub", " Scratch", "schematic", "shraped", " scraped", " scattered", "straper", "screenshot", "scattering", "crratch", "oscresh", "scenge", "oscratch", "cradle", "SCraped", " Scresh", "clrub", "scheatter", "stratch", "eschematic", "shratch", "SCrub", "clreenshot", "scopeenario", "stresh", "shraper", "SCratch", "descratch", "escrub", "cleraper", " screenshot", "scraper", " scrraper", "scenario", "scopeattering", "escresh", "bcratch", " scatter", "cleraped", "scadle", "clratch", "ucratch", "oscraper", "escadle", "shattered", "ucraped", "clresh", "scattered", " schematic", "bcreenshot", " scenge", "SCash", "scheash", "stattered", "schereenshot", "straped", "scoperatch", "escratch", "oscattered", "bcash", "scraped", "chresh", " scrraw", "scraw", "deschematic", " scraper", " Scenge", "oscraped", " unscenario", " scenario", " scresh", "shash", "scheratch", "chhematic", " scrresh", " unscratch", "escreenshot", "escatter", " Schematic", "straw", "chenge", "escattered", "chratch", "cratter", "cleattered", "scrub", "shrub", " scash", "escash", "descreenshot", " scrub", "bcatter", "scatter", "scash", "crreenshot", " unscattering", " scadle", " scattering", "ucash"], "i": ["d", "batch", "iu", "v", "li", "e", "pi", "abi", "ai", "ui", "m", "a", "ti", "z", "n", "ci", "id", "is", "ip", "c", "info", "p", "index", "b", "f", "j", "ii", "I"], "data_offset": ["sample_pos", "sample_size", "data_length", "data_count", "data_position", " data_length", " data_address", "sample_count", "data_pos", "data_address", " data_position", "sample_offset", "data_size"], "audio_frame_counter": ["audio_frame_num", "audio_frame_count", "audio_frames_counter", "audio_frames_num", "audio_frames_offset", "audio_frames_count", "audio_frame_offset"]}}
{"project": "FFmpeg", "commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "target": 1, "func": "static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14639, "substitutes": {"ctx": ["fp", "client", "prefix", "sync", "ct", "cam", "cpp", "connection", "cu", "cn", "exec", "cm", "tc", "sc", "cs", "nc", "bc", "pkg", "sci", "cf", "pc", "cmd", "cb", "cfg", "kb", "qa", "anc", "Context", "cc", "cmp", "concept", "conf", "sq", "hw", "lc", "config", "cca", "kernel", "ck", "cus", "ci", " context", "fc", "cache", "context", "c", "rx", "conv", "cp", "cli", "kw", "ctrl", "tx", "css", "crit", "ca", "utils", "wcs", "que", "gb", "xc", "loc", "conn", "cms", "cas", "support", "cv"], "num_coeffs": ["num_coefficientsi", "num_coefs", "num_coefi", "num_coefficientses", "num_coeffi", "num_COeffs", "num_coffi", "num_COeffd", "num_coefficientsd", "num_COffd", "num_COeffes", "num_coffs", "num_coefficientes", "num_coefficientss", "num_coffes", "num_coffd", "num_coefficientd", "num_coefp", "num_COffp", "num_coefficientp", "num_coefficients", "num_coeffd", "num_coeffp", "num_COffes", "num_coefficientsp", "num_coefes", "num_coffp", "num_COffs", "num_coeffes", "num_COeffp"], "qscale": [" qdata", "qnorm", "QScale", "qucale", "qunorm", "qudata", "bitnorm", "kcale", "kscale", "bitcale", " qScale", "Qcale", "qdata", "Qscale", "qcale", "kScale", "bitscale", " qnorm", "quscale", " qcale", "bitdata", "qScale"], "block": ["batch", "session", "address", "panel", "bl", "list", "position", "flow", "board", "record", "bc", "image", "length", "work", "base", "bin", "blocks", "job", "object", "group", "map", "label", "bar", "frame", "slice", "pool", "comment", "unit", "error", "byte", "pre", "channel", "point", "lock", "Block", "cache", "node", "box", "line", "dict", "clean", "layout", "range", "type", "bb", "b", "table", "tx", "row", "bo", "buffer", "section", "buf", "bit", "chain", "ref", "number", "pack"], "pos": ["part", "ass", "position", "opp", "po", "pt", "obj", "pc", "base", "size", "length", "style", "rel", "val", "post", "slot", "def", "pose", "padding", "sp", "pid", "offset", "limit", "slice", "unit", "num", "nos", "cond", "n", "os", "neg", "spec", "POS", "x", "no", "pres", "pointer", "axis", "i", "p", "index", "type", "col", "Pos", "start", "prop", "min", "f", "port", "diff", " position", "j", "pass", "loc", "ref", "conf", "len", "comp", "pro", "rot"], "vlc": ["velcs", "lvcu", "lvp", "nlct", "lvlc", "lipcu", "svcs", "lipcs", "vlrc", "velc", "llrc", "lvac", "llci", "lvc", "vlp", "kllc", "vlcs", "vlce", "liplc", "llp", "lllc", "klcs", "svc", "wlac", "lvcs", "wlcs", "vllc", "lvci", "llct", "velf", "klct", "klf", "llce", "klc", "llf", "llcs", "vlcu", "nlcs", "velp", "vlct", "wlc", "vlci", "svci", "nlce", "vlf", "svrc", "klce", "wlci", "llc", "lvrc", "nlc", "llcu", "lvf", "wlf", "wllc", "llac", "wlp", "lipc", "vlac", "velci"], "num_bits": ["numloglocks", "num_flags", " num_bit", "numlogbits", "num__locks", "num__bit", "num_points", "max_bits", "numLflags", " num_bytes", "numLbits", "num_bs", "num_locks", "numlogbit", " num_bs", " num_points", "num__points", "max_parts", "numlogpoints", "max_details", "num_parts", "num__bits", "num_bytes", "num_hours", "num_bit", " num_locks", "numLhours", "max_bit", " num_hours", "numLbit", "num_details", " num_flags"], "value": ["address", "field", "position", "flow", "data", "v", "image", "message", "length", "size", "VALUE", "val", "total", "object", "offset", "limit", "valid", "wave", "comment", "sec", "unit", "values", "scale", "num", "cost", "key", "version", "dev", "current", "weight", "max", "range", "index", "type", "start", "name", "child", "port", "Value", "len", "number", "function", "null"], "coeff": ["noefficient", " coeffect", "COef", "COff", "collef", "Coefficient", "coreff", "opefficient", " coff", "microeff", "colleff", "cefficient", "coef", " coef", "opeff", "Coeffect", "colleffect", "ceff", "coff", "coref", "COeff", "noef", "noeff", "opef", "Coff", " coort", "microef", "opeffect", "collefficient", "coort", "coeffect", "Coort", "Coeff", "microeffect", "noff", "Coef", "coefficient", "coreffect", "cef", "COefficient", "microefficient", " coefficient", "cff", "corort"]}}
{"project": "FFmpeg", "commit_id": "87e302bfd8ffbc6cdb20920029013956b10ace63", "target": 0, "func": "static int svq3_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MpegEncContext *const s = avctx->priv_data;\n\n    H264Context *const h = avctx->priv_data;\n\n    int m, mb_type;\n\n\n\n    /* special case for last picture */\n\n    if (buf_size == 0) {\n\n        if (s->next_picture_ptr && !s->low_delay) {\n\n            *(AVFrame *) data = *(AVFrame *) &s->next_picture;\n\n            s->next_picture_ptr = NULL;\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    init_get_bits (&s->gb, buf, 8*buf_size);\n\n\n\n    s->mb_x = s->mb_y = h->mb_xy = 0;\n\n\n\n    if (svq3_decode_slice_header(h))\n\n        return -1;\n\n\n\n    s->pict_type = h->slice_type;\n\n    s->picture_number = h->slice_num;\n\n\n\n    if (avctx->debug&FF_DEBUG_PICT_INFO){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\\n\",\n\n               av_get_pict_type_char(s->pict_type), h->halfpel_flag, h->thirdpel_flag,\n\n               s->adaptive_quant, s->qscale, h->slice_num);\n\n    }\n\n\n\n    /* for hurry_up == 5 */\n\n    s->current_picture.pict_type = s->pict_type;\n\n    s->current_picture.key_frame = (s->pict_type == FF_I_TYPE);\n\n\n\n    /* Skip B-frames if we do not have reference frames. */\n\n    if (s->last_picture_ptr == NULL && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip B-frames if we are in a hurry. */\n\n    if (avctx->hurry_up && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip everything if we are in a hurry >= 5. */\n\n    if (avctx->hurry_up >= 5)\n\n        return 0;\n\n    if (  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == FF_B_TYPE)\n\n        ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != FF_I_TYPE)\n\n        || avctx->skip_frame >= AVDISCARD_ALL)\n\n        return 0;\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == FF_B_TYPE)\n\n            return 0;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (frame_start(h) < 0)\n\n        return -1;\n\n\n\n    if (s->pict_type == FF_B_TYPE) {\n\n        h->frame_num_offset = (h->slice_num - h->prev_frame_num);\n\n\n\n        if (h->frame_num_offset < 0) {\n\n            h->frame_num_offset += 256;\n\n        }\n\n        if (h->frame_num_offset == 0 || h->frame_num_offset >= h->prev_frame_num_offset) {\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"error in B-frame picture id\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        h->prev_frame_num = h->frame_num;\n\n        h->frame_num = h->slice_num;\n\n        h->prev_frame_num_offset = (h->frame_num - h->prev_frame_num);\n\n\n\n        if (h->prev_frame_num_offset < 0) {\n\n            h->prev_frame_num_offset += 256;\n\n        }\n\n    }\n\n\n\n    for (m = 0; m < 2; m++){\n\n        int i;\n\n        for (i = 0; i < 4; i++){\n\n            int j;\n\n            for (j = -1; j < 4; j++)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= 1;\n\n            if (i < 3)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= PART_NOT_AVAILABLE;\n\n        }\n\n    }\n\n\n\n    for (s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) {\n\n        for (s->mb_x = 0; s->mb_x < s->mb_width; s->mb_x++) {\n\n            h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;\n\n\n\n            if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits &&\n\n                ((get_bits_count(&s->gb) & 7) == 0 || show_bits(&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) {\n\n\n\n                skip_bits(&s->gb, h->next_slice_index - get_bits_count(&s->gb));\n\n                s->gb.size_in_bits = 8*buf_size;\n\n\n\n                if (svq3_decode_slice_header(h))\n\n                    return -1;\n\n\n\n                /* TODO: support s->mb_skip_run */\n\n            }\n\n\n\n            mb_type = svq3_get_ue_golomb(&s->gb);\n\n\n\n            if (s->pict_type == FF_I_TYPE) {\n\n                mb_type += 8;\n\n            } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) {\n\n                mb_type += 4;\n\n            }\n\n            if (mb_type > 33 || svq3_decode_mb(h, mb_type)) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n\n\n            if (mb_type != 0) {\n\n                hl_decode_mb (h);\n\n            }\n\n\n\n            if (s->pict_type != FF_B_TYPE && !s->low_delay) {\n\n                s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =\n\n                    (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;\n\n            }\n\n        }\n\n\n\n        ff_draw_horiz_band(s, 16*s->mb_y, 16);\n\n    }\n\n\n\n    MPV_frame_end(s);\n\n\n\n    if (s->pict_type == FF_B_TYPE || s->low_delay) {\n\n        *(AVFrame *) data = *(AVFrame *) &s->current_picture;\n\n    } else {\n\n        *(AVFrame *) data = *(AVFrame *) &s->last_picture;\n\n    }\n\n\n\n    avctx->frame_number = s->picture_number - 1;\n\n\n\n    /* Do not output the last pic after seeking. */\n\n    if (s->last_picture_ptr || s->low_delay) {\n\n        *data_size = sizeof(AVFrame);\n\n    }\n\n\n\n    return buf_size;\n\n}\n", "idx": 14654, "substitutes": {"avctx": ["avecn", "afconfig", "aveconfig", "auctx", "afloc", "avcf", "navcf", "ajcu", "afcoll", "verctx", "aucontext", "afctx", "aphlc", "avlc", "AVsc", "avcn", "ajctx", "AVconn", "apcontext", "AVlib", "afcontext", "aphctl", "aflib", "avesync", "afcv", "navctx", "avctl", "avectx", "aplc", "ajcam", "AVhw", "AVctx", "avsync", "AVcf", "auloc", "avcam", "aflc", "ajcontext", "afsc", "avhw", "avecf", "apctx", "ausync", "avecoll", "aveloc", "afcf", "afhw", "avcu", "afconn", "aucv", "navconn", "AVconfig", "afctl", "afcu", "verconn", "aphctx", "avsc", "vercoll", "navcontext", "avconn", "afcam", "avlib", "AVcontext", "navcoll", "avecam", "afcn", "aucn", "avconfig", "navhw", "aveconn", "avecu", "avcoll", "aphcontext", "avloc", "afsync", "avcv", "apctl", "avelib", "vercontext", "avesc", "avecv", "avecontext", "avcontext"], "data": ["body", "d", "batch", "content", "uf", "v", "reader", "la", "media", "image", "result", "base", "size", "dat", "length", "val", "pad", "queue", "slice", "frame", "meta", "rc", "config", "audio", "next", "block", "feed", "buff", "cache", "read", "input", "memory", "picture", "bytes", "window", "info", "p", "Data", "f", "start", "frames", "w", "DATA", "buffer", "value", "video", "da", "img", "code"], "data_size": ["buf_capacity", "data__speed", "buffer_time", "data_capacity", "buffer_speed", "data_time", "buffer_size", "data__time", "data_name", "data__scale", "data__size", "data_scale", "buf_size", "buf_name", "data_speed", "buffer_scale"], "avpkt": ["avckt", "avpk", "affkg", "avvpKT", "avpct", "avcpacket", "avprfx", "afpkl", "avvpkg", "avckg", "avlpkl", "avcpct", " avvpKT", "avcKT", "afpacket", "afcpacket", "avcpfx", "avcpk", " avpkg", "afpkg", "afpkt", " avvpk", "afcpfx", "avPacket", "avffx", "avprct", "avPkl", "avcpKT", "avpkg", "afpfx", "avPkt", "avpacket", "avfacket", "avvpk", " avvpkg", "afcpkt", "avlpacket", "avlpkt", "affkl", " avpk", "avck", "avfkl", "avpfx", "avpkl", "avvpkt", "avlpkg", "afpct", "avfct", "avpracket", "avpKT", "affacket", "avfkt", " avpKT", "avfkg", "avcpkt", "affkt", "avPkg", "avprkt", " avvpkt", "avcpkg", "afcpct"], "buf": ["aux", "batch", "alloc", "img", "tmp", "fi", "uf", "v", "br", " buffer", "bc", "ff", "cb", "fb", "cas", "pad", "cap", "queue", "map", "vec", "uc", "fd", "seq", "config", "num", "rb", "block", "ctx", "buff", "cache", "p", "b", "bag", "f", "src", "prop", "port", "buffer", "len", "array", "cv"], "s": ["hs", "session", "options", "v", "u", "ts", "its", "sys", "si", "xs", "self", "n", "spec", "sh", "qs", "sb", "as", "js", "services", "sum", "t", "ps", "fs", "sync", "o", "ins", "ys", "cs", "e", "parts", "ss", "y", "ssl", "new", "sq", "gs", "a", "is", "c", "sg", "ns", "share", "settings", "us", "uses", "sa", "l", "ds", "ans", "service", "this", "vs", "sl", "ms", "ses", "sym", "S", "ops", "comments", "d", "sv", "rs", "features", "full", "g", "es", "ks", "os", "ctx", "su", "args", "p", "b", "aws", "sets", "f", "has", "w", "request", "ls", "r", "hes", "conf", "words", "css"], "h": ["hs", "eh", "d", "ha", "o", "hash", "v", "e", "oh", "u", "uh", "rh", "his", "l", "hd", "ht", "ih", "hist", "y", "header", "hm", "hh", "gh", "he", "hw", "hp", "hl", "host", "bh", "g", "z", "k", "n", "ch", "han", "dh", "hr", "home", "sh", "c", "H", "q", "hi", "ah", "p", "http", "ph", "history", "b", "him", "f", "th", "kh", "w", "zh", "r"], "m": [" w", "d", " chunk", " bi", " c", "mode", "slot", " d", "g", " p", "n", "id", "c", " f", " cm", " u", "p", "type", "b", "f", "src", " mode", "r", " dim", "img", "code"], "mb_type": ["mb_types", "photo_type", "mb_name", "photo_size", "photo_name", "mb_size", "photo_types"], "mb_y": ["MB_ye", "mbJy", "MB_ya", "mbJya", "mbJx", "MB_x", "mbJye", "mb_ye", "mb_ya", "MB_y"], "mb_x": ["mbIdx", "emb_x", "mbIdy", "mbIdsize", "emb_xy", "mb_xy", "emb_y", "mbIdxy", "emb_size", "mb_size"]}}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int rl2_decode_init(AVCodecContext *avctx)\n\n{\n\n    Rl2Context *s = avctx->priv_data;\n\n    int back_size;\n\n    int i;\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n\n\n    /** parse extra data */\n\n    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid extradata size\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** get frame_offset */\n\n    s->video_base = AV_RL16(&avctx->extradata[0]);\n\n    s->clr_count = AV_RL32(&avctx->extradata[2]);\n\n\n\n    if(s->video_base >= avctx->width * avctx->height){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid video_base\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** initialize palette */\n\n    for(i=0;i<AVPALETTE_COUNT;i++)\n\n        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);\n\n\n\n    /** decode background frame if present */\n\n    back_size = avctx->extradata_size - EXTRADATA1_SIZE;\n\n\n\n    if(back_size > 0){\n\n        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);\n\n        if(!back_frame)\n\n            return -1;\n\n        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,\n\n                           back_frame,avctx->width,0);\n\n        s->back_frame = back_frame;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14658, "substitutes": {"avctx": ["avelc", "ajctrl", "ajcf", "AVcam", "afconfig", "aveconfig", "afctrl", "ajqa", "afloc", " avcu", "avci", "avecup", "avcf", "ajcu", "verctx", "ajclient", "avecas", "ajtx", "avcci", "vertx", "afctx", "avekw", "avlc", "avctrl", "afcas", "avectl", "avqa", "ajcmp", " avhw", "avtx", "avscope", "avcn", "navconfig", "ajctx", "AVconn", "afcontext", "vercf", "afca", "aflib", "avesync", "AVcmp", "navctx", "avctl", "avectx", "ajcn", "avclient", "alpkg", "ajcam", "avpkg", "avecci", "afclient", "AVhw", "AVctx", "avsync", "avcup", "avalqa", "AVcu", " avcas", "avcam", "AVcf", "verscope", "avalcup", "aflc", "avecmp", "ajconn", "ajcontext", "avhw", "avecf", " avcontext", "alctx", "AVscope", "ajscope", "ajlib", " avcci", "avalcu", "aveloc", "avkw", "afcf", " avconfig", "avalctl", "avcu", "afci", "alcontext", "afconn", "navloc", "afcmp", "avalconn", "afctl", "vercn", "afcu", "verconn", "AVtx", "navcontext", "avconn", "ajsync", "avlib", "verca", "avalctx", "avcmp", "AVcontext", "AVkw", "alcam", "avalci", "afcn", "avalcontext", "AVpkg", "avconfig", "aveconn", "avecu", "ajkw", "avca", "avloc", "aveclient", " avconn", "afcup", "avehw", "ajpkg", "afsync", "aveci", " avlc", "aveca", "avelib", "afcci", "vercontext", "afqa", "avalctrl", "avcas", "avecontext", "avcontext"], "s": ["ps", "client", "sync", "fs", "d", "us", "o", "session", "sv", "ops", "hs", "rs", "v", "cs", "e", "sa", "u", "ts", "l", "server", "ds", "sys", "si", "ss", "ssl", "service", "m", "conf", "se", "sq", "gs", "nas", "sec", "xs", "a", "g", "es", "ks", "self", "n", "os", "spec", "ctx", "stats", "is", "c", "su", "sg", "h", "p", "ns", "qs", "b", "sl", "aws", "sets", "f", "sb", "ses", "js", "w", "ls", "services", "sym", "S", "r", "t", "sk"], "back_size": ["back_storage", "right_small", "back__name", " back__size", "back__address", " back_key", "back_scale", " back__address", " back_storage", " back_address", "backFcode", "back_use", "right_size", " back_code", "back_small", " back_scale", "right_fee", " back__name", "backFsize", " back__code", "back_key", "back_address", "right_capacity", "back__code", "back_capacity", "back__size", " back_ize", "back_ize", "back_fee", "back_name", "back_code", "backFaddress", "backFname", " back_use", " back_name"], "i": ["it", "d", "di", "gi", "ini", "iu", "fi", "t", "v", "multi", "li", "h", "count", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "y", "ai", "ui", "m", "ti", "k", "ix", "z", "n", "ci", "io", "id", "bi", "qi", "ip", "x", "phi", "c", "oi", "ji", "hi", "p", "index", "cli", "ri", "b", "ni", "zi", "j", "ii", "I", "yi"], "back_frame": ["back__zip", "backboarddata", "backboardsector", "back_scale", "front_size", "back_element", " back_slice", " back__zip", "backlogsector", " back_element", " back_hole", "forwardlogframe", "backboardsequence", "back__slice", "forwardlogsector", "back_hole", "back_line", "forward_sequence", " back__slice", "back_slice", "backlogframe", " back_scale", "forward_data", "backboardframe", "back_data", "backingsector", " back__scale", "backxhole", "backingframe", "backingsequence", "back_sequence", " back__frame", "backacframe", "back__frame", "backacsize", "backxsize", "backxscale", "forward_frame", "forwardlogdata", "backingdata", "front_frame", "back__scale", "forwardlogsequence", "backlogsequence", "backacelement", "front_line", "backlogdata", "back_zip", " back_zip", "backxframe", "forward_sector", "back_sector"]}}
{"project": "FFmpeg", "commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 14665, "substitutes": {"s": ["ps", "sync", "fs", "sv", "your", "ins", "cpp", "rs", "site", "t", "sim", "sc", "cs", "e", "u", "ts", "l", "parts", "ds", "sys", "si", "ss", "space", "service", "conf", "se", "m", "ssl", "sq", "gs", "g", "es", "self", "os", "spec", "is", "c", "vs", "i", "sg", "ns", "p", "qs", "cli", "scope", "sets", "frames", "f", "series", "ses", "js", "settings", "gb", "share", "ls", "services", "setup", "S", "sym", "bis", "sche", "ops"], "frame": ["document", "iframe", "o", "panel", "file", "flow", "fi", "data", "draw", "flower", "e", "image", "feature", "fl", "fe", "fram", "cf", "rame", "ov", "element", "object", "m", "Frame", "state", "slice", "scale", "figure", "scene", "motion", "line", "pse", "window", "p", "coll", "frames", "f", "series", "dy", "framework", "game", "setup", "sequence"], "value": ["update", "shift", "position", "flow", "action", "data", "v", "after", "media", "image", "mask", "feature", "result", "message", "end", "size", "VALUE", "write", "val", "depth", "total", "object", "m", "offset", "limit", "wave", "values", "scale", "num", "view", "cost", "z", "parent", "age", "version", "change", "weight", "window", "range", "p", "one", "b", "start", "rate", "w", "Value", "number", "function"], "run": ["running", "sync", "orig", "step", "Run", "thread", "loop", "image", "con", "use", "cycle", "head", "write", "race", "depth", "round", "limit", "ride", "unit", "config", "num", "scale", "un", "man", "k", "spin", "block", "n", "lock", "keep", "id", "win", "version", "trial", "c", "q", "max", "plot", "index", "f", "row", "rate", "repeat", "min", "bit", "r", "pass", "runs", "len", "day"], "x": ["data", "t", "v", "e", "image", "pos", "u", "l", "size", "page", "pixel", "m", "dx", "xy", "time", "xx", "a", "px", "z", "ix", "n", "axis", "c", "i", "h", "q", "line", "p", "index", "ax", "ex", "b", "f", "w", "bit", "xc", "dy", "X"], "y": ["ya", "o", "ay", "ky", "ty", "yo", "v", "e", "u", "xi", "iy", "l", "pi", "ny", "m", "xy", "zy", "vy", "g", "z", "k", "n", "ey", "c", "i", "h", "p", "type", "col", "b", "cy", "f", "w", "Y", "yy", "dy", "sky", "py", "sy", "oy", "t", "ye", "yi", "gy"], "plane": ["module", "charge", "o", "pe", "flow", "position", "board", "mode", "e", "image", "mask", "fl", "u", "xi", "planes", "direction", "ane", "force", "size", "den", "page", "plan", "day", "level", "se", "group", "m", "limit", "slice", "unit", "lane", "scale", "pen", "g", "z", "key", "k", "age", "flat", "drop", "axis", "weight", "q", "line", "plot", "zone", "p", "core", "fly", "order", "f", "rate", "row", "pin", "port", "orient", "clip", "rot"], "bits_per_plane": ["bits_per_plate", "bits_per\u00b7line", "bits_per\u00b7flight", "bits_pervlane", "bits_PER_plate", "bits_pervplane", "bits_per_month", "bits_PER_lane", "bits_per_fly", "bits_pervspace", "bits_per_band", "bits_per\u00b7month", "bits_PER_line", "bits_per_lane", "bits_pervfly", "bits_per_plan", "bits_per_line", "bits_PER_plane", "bits_per_planes", "bits_per_space", "bits_per_flight", "bits_per\u00b7plane"], "d": ["di", "o", "dt", "data", "v", "md", "e", "u", "l", "dat", "ds", "dc", "m", "dx", "fd", "dn", "dim", "dl", "g", "z", "df", "k", "n", "dh", "sd", "c", "i", "dict", "h", "q", "p", "dd", "b", "f", "dp", "w", "diff", "D", "dy", "t", "ad"], "j": ["part", "adj", "ie", "o", "ne", "dj", "J", "jp", "t", "v", "li", "jl", "e", "xi", "u", "obj", "l", "job", "m", "el", "jo", "xy", "dim", "aj", "g", "k", "z", "jj", "jet", "n", "lock", "fr", "io", "ch", "ip", "ij", "i", "h", "q", "ji", "p", "b", "ni", "f", "start", "ind", "js", "section", "uj", "dy", "jit", " i", "ja"]}}
{"project": "FFmpeg", "commit_id": "f61d44b74aaae1d306d8a0d38b7b3d4292c89ced", "target": 0, "func": "static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_t min_delta[17])\n\n{\n\n    int pass, i;\n\n    for (pass = 0; pass < 20; pass++) {\n\n        int k, min_diff = 0;\n\n        for (i = 0; i < order+1; i++) {\n\n            int low  = i != 0     ? nlsf[i-1] : 0;\n\n            int high = i != order ? nlsf[i]   : 32768;\n\n            int diff = (high - low) - (min_delta[i]);\n\n\n\n            if (diff < min_diff) {\n\n                min_diff = diff;\n\n                k = i;\n\n\n\n                if (pass == 20)\n\n                    break;\n\n            }\n\n        }\n\n        if (min_diff == 0) /* no issues; stabilized */\n\n            return;\n\n\n\n        /* wiggle one or two LSFs */\n\n        if (k == 0) {\n\n            /* repel away from lower bound */\n\n            nlsf[0] = min_delta[0];\n\n        } else if (k == order) {\n\n            /* repel away from higher bound */\n\n            nlsf[order-1] = 32768 - min_delta[order];\n\n        } else {\n\n            /* repel away from current position */\n\n            int min_center = 0, max_center = 32768, center_val;\n\n\n\n            /* lower extent */\n\n            for (i = 0; i < k; i++)\n\n                min_center += min_delta[i];\n\n            min_center += min_delta[k] >> 1;\n\n\n\n            /* upper extent */\n\n            for (i = order; i > k; i--)\n\n                max_center -= min_delta[k];\n\n            max_center -= min_delta[k] >> 1;\n\n\n\n            /* move apart */\n\n            center_val = nlsf[k - 1] + nlsf[k];\n\n            center_val = (center_val >> 1) + (center_val & 1); // rounded divide by 2\n\n            center_val = FFMIN(max_center, FFMAX(min_center, center_val));\n\n\n\n            nlsf[k - 1] = center_val - (min_delta[k] >> 1);\n\n            nlsf[k]     = nlsf[k - 1] + min_delta[k];\n\n        }\n\n    }\n\n\n\n    /* resort to the fall-back method, the standard method for LSF stabilization */\n\n\n\n    /* sort; as the LSFs should be nearly sorted, use insertion sort */\n\n    for (i = 1; i < order; i++) {\n\n        int j, value = nlsf[i];\n\n        for (j = i - 1; j >= 0 && nlsf[j] > value; j--)\n\n            nlsf[j + 1] = nlsf[j];\n\n        nlsf[j + 1] = value;\n\n    }\n\n\n\n    /* push forwards to increase distance */\n\n    if (nlsf[0] < min_delta[0])\n\n        nlsf[0] = min_delta[0];\n\n    for (i = 1; i < order; i++)\n\n        if (nlsf[i] < nlsf[i - 1] + min_delta[i])\n\n            nlsf[i] = nlsf[i - 1] + min_delta[i];\n\n\n\n    /* push backwards to increase distance */\n\n    if (nlsf[order-1] > 32768 - min_delta[order])\n\n        nlsf[order-1] = 32768 - min_delta[order];\n\n    for (i = order-2; i >= 0; i--)\n\n        if (nlsf[i] > nlsf[i + 1] - min_delta[i+1])\n\n            nlsf[i] = nlsf[i + 1] - min_delta[i+1];\n\n\n\n    return;\n\n}\n", "idx": 14673, "substitutes": {"nlsf": ["Nlsfo", "nailsc", "nLSfe", "nlsfa", "nlesc", "nailsf", "nLSform", " nnsb", "NLSfs", "nlesv", "nfsp", "NLSc", "npsf", "numsv", "nnsfs", "nfsfs", "nfsb", "ynlesv", "nnsb", "nnsc", "nlasfe", "solsfs", "ncsfs", "nlsc", "nolsf", "nbsf", "Nlsform", "nlesif", "nlasb", "nfsf", "nrsb", "nLSfo", "Nlsfs", "nmesfc", "nolsfx", "ngsf", " ncsv", "ynlsc", " nlsfc", "nLSf", " nailsfx", "solsf", " nnsf", "nmesb", "nlasf", " nailsc", "nlasfs", "nmesv", "unlesb", " ncsfc", "nolsb", "lnsc", "nfsfb", "nlsb", "Nlsv", " nlsfb", "nailsfx", "nrsv", "llsp", "lnsv", "Nlsc", "nLSconf", "unlesif", "slsfa", "nfsfa", "nlesf", "ynlesc", "nlsfx", "nlasconf", "nlsfs", " nlsfs", " ncsfe", "nlsfb", "nailsfs", "nlsconf", "llsc", "solsp", "unlsc", "Nlsf", "nLSif", "nnsfa", "nlsfe", "nrsf", "nnsv", " ncsb", "ynlsv", "ynlsf", "numsfe", "nbsb", "nLSfx", "nolsfs", " ncsp", "nnsp", "nolsfa", "NLSb", "nlsv", "solsfa", "nLSb", "ncsform", "NLSv", "nailsfo", " nlsc", "nrsfs", "npsfb", "llsf", " nnsfe", "nailsform", "nLSfc", "nnsf", " nfsf", " ncsf", "slsf", "ynlsb", "nlesb", "ncsfe", "NLSform", "lnsf", "ncsv", "unlsb", " nlsv", "nLSv", "unlsif", "nolsp", "ncsc", " nlsp", "unlsf", "unlesf", "nlsfo", "numsp", "llsv", "nailsv", "nrsc", "nlsp", "nLSp", "nbsfs", " nfsb", "Nlsb", " nnsc", "slsfs", "ncsf", " nlsb", " nailsf", "nbsconf", "ncsp", "ngsb", "nlsfc", "nLSfs", "Nlsconf", "NLSconf", "ncsb", "ngsfo", "NLSfo", "ncsif", " nfsfb", "nlasc", "ncsfc", "slsp", " nlsfe", "nolsc", "npsb", "unlesc", "lnsfs", "nnsfe", " nfsfs", "ynlesb", " nlsfx", "npsfs", "NLSf", "nlsif", "llsfs", "nLSfb", "nailsp", "lnsp", "nailsb", " nailsb", "nLSc", "nmesf", "ynlesf", "numsf", "nlsform"], "order": ["orig", "hop", "ord", "ordered", "dir", "work", "level", "m", "limit", "scale", "n", "asc", "spec", "here", "o", "position", "all", "xml", "seed", "record", "e", "use", "random", "element", "sort", "offset", "error", "last", "block", "keep", "id", "now", "x", "max", "rule", "ordering", "iter", "ok", "user", "after", "end", "Order", "round", "shape", "root", "ai", "pre", "key", "axis", "name", "ko", "sk", "code", "step", "acc", "inner", "direction", "length", "page", "grade", "tr", "info", "layer", "index", "row", "err", "er", "orders", "rank", "r"], "min_delta": ["min2dDelta", "min_melt", "min2sdDelta", "min_doiesta", "min_tiff", "min_datota", "min_dynamic", "min_dlux", "min_diata", "min_data", "min\u00b7tta", "min_diff", "min_Diesta", "min_telta", "min_Detime", "min_ddiff", "min_dslux", "min_mynamic", "min_diesta", "min_tota", "min2delt", "min_indelta", "min_sdelta", "min_datelt", "min_sdota", "min_dica", "min_diota", "min_dielt", "min_ddelta", "min_adDelta", "min_doota", "min_delt", "min_mesh", "min\u00b7dota", "min_sdynamic", "min_adetime", "min_adota", "min_diica", "min_indynamic", "min\u00b7telta", "min_desh", "min2sdelta", "min_sdelt", "min_datDelta", "min_datetime", "min_dsetime", "min\u00b7dta", "min_Dica", "min_doelta", "min_indelt", "min_ddota", "min_sdica", "min_tta", "min_adelta", "min_doetime", "min_ddta", "min\u00b7delta", "min_Delta", "min_sdDelta", "min_dsota", "min_dta", "min_adelt", "min\u00b7tota", "min_sdesh", "min_dota", "min_adiesta", "min_DDelta", "min2sdelt", "min_indesh", "min_detime", "min_dselta", "min_melta", "min2delta", "min_datiff", "min_Delt", "min_sdata", "min_dielta", "min_dDelta", "min_datelta", "min\u00b7tiff", "min_Dota", "min_datlux", "min_datta", "min\u00b7diff", "min_datata"], "pass": ["fail", "sync", "batch", "step", "test", "check", "flow", "ok", "all", "acc", "loop", "sc", "mode", "pos", "ask", "act", "use", "password", "strip", "round", "post", "path", "level", "ss", "grade", "slice", "ride", "Pass", "parse", "lc", "ck", "key", "skip", "cross", "keep", "id", "feed", "x", "stage", "c", "push", "scan", "PASS", "layer", "p", "index", "inc", "run", "ack", "row", "w", "r", "rank", "code"], "i": ["it", "ini", "v", "u", "pi", "si", "m", "ui", "api", "ix", "init", "ni", "start", "diff", "ii", "I", "adi", "ie", "o", "my", "li", "e", "mu", "y", "slice", "a", "lc", "ti", "ani", "eni", "id", "bi", "qi", "ip", "c", "phi", "is", "x", "hi", "ri", "ori", "di", "gi", "fi", "multi", "l", "ai", "me", "key", "io", "ami", "q", "d", "mi", "iu", "xi", "inner", "uri", "g", "z", "ik", "ci", "mini", "oi", "ij", "info", "ji", "ki", "p", "index", "cli", "b", "f", "jit"], "k": ["v", "u", "work", "level", "in", "m", "cook", "ke", "self", "n", "spec", "h", "scan", "kw", "kh", "kind", "o", "e", "kat", "element", "y", "block", "id", "x", "c", "max", "ek", "km", "ok", "kick", "ask", "end", "l", "kn", "dk", "gh", "ck", "key", "q", "ak", "ph", "ack", "ijk", "ko", "ku", "sk", "code", "d", "g", "ks", "z", "ik", "K", "uk", "ki", "p", "kk", "s", "b", "f", "w", "r", "mk"], "center_val": ["centerenVal", " center_base", "center___val", "centerPval", "center_rot", "center___valid", "center_VAL", "center_valid", " center_buf", "center__val", "contextPlen", "centerenval", " center_vals", "center___rot", " center_aval", "centerjreal", "center2val", "center___real", "core_val", "center_value", "center_bal", "center_vals", "context_val", "center_real", " center_real", "context_rot", " center_valid", "core_valid", "center2aval", "centerjVal", " center_v", "center___Val", "centerjval", "contextProt", " center_bal", "center___bal", "enter_value", " center_VAL", "context_len", "centerenbase", "center2valid", "context_Val", "center_buf", "center_v", "centerProt", "center__eval", "center_base", "enter_val", "center_len", "centerenvals", "center_Val", "center2bal", "centerjVAL", "center___len", " center_Val", "centerPVal", "center___value", " center_value", "center_eval", "center_aval", "centerPlen", "center___aval", " center_eval", "contextPVal", "enter_vals", "core_bal", "center__value", "contextPval", "enter_eval", "center___VAL", "core_value", "center__valid"], "j": ["it", "body", "part", "adj", "ie", "d", "o", "dj", "J", "jan", "jp", "v", "li", "jl", "br", "e", "pos", "obj", "u", "l", "size", "val", "si", "job", "note", "y", "m", "jo", "jen", "a", "aj", "num", "g", "z", "key", "jj", "jet", "fr", "n", "item", "ix", "rev", "x", "ij", "h", "q", "ji", "syn", "index", "p", "other", "b", "f", "child", "js", "ind", "uj", "value", "ii", "r", "jit", "next", "ja", "jc"]}}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n", "idx": 14679, "substitutes": {"opaque": ["copacity", " ophole", "obhole", "operatile", "ophole", "opaques", " opaques", "obacity", "obatile", "copaques", "operaques", "copatile", " opacity", "operaque", "obaque", "opacity", "OPatile", "opatile", "OPhole", "copaque", " opatile", "operacity", "OPaque", "OPacity"], "addr": ["prot", "prefix", "address", "hop", "ord", "amd", "sid", "data", "mode", "adr", "pos", "ld", "rt", "base", "align", "def", "pad", "alias", "slot", "attr", "grad", "offset", "fd", "adder", "xp", "ptr", "config", "host", "point", "arg", "ctx", "mt", "x", "mac", "pointer", "dd", "tx", "src", "port", "ace", "loc", "ref", "ad"], "val": ["enc", "VAL", "d", "test", "bl", "all", "fi", "data", "v", "eval", "count", "pt", "end", "l", "sel", "base", "def", "bin", "ival", "aval", "pid", "el", "grad", "valid", "al", "a", "unit", "Val", "config", "reg", " Val", "byte", "key", "num", "vl", "arg", "ctx", "x", "ret", "p", "type", "vol", "b", "sl", "vals", "tx", "arr", "f", "py", "buf", "value", "r", "loc", "ref", "len", "null"], "s": ["ps", "fs", "o", "session", "ins", "rs", "e", "sa", "cs", "ts", "l", "states", "si", "ss", "an", "ssl", "m", "sq", "gs", "a", "g", "es", "ips", "n", "os", "c", "args", "p", "ns", "b", "sl", "sb", "flags", "ses", "r", "sym", "services", "S", "ls", "ops"]}}
{"project": "qemu", "commit_id": "523b018dde3b7650fe5401d0499b30cf2f117515", "target": 1, "func": "vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;", "idx": 14680, "substitutes": {"vra": ["frera", "vira", " vru", "svra", "vcran", "libra", "Vara", "vrera", "Vtra", " vaga", "Vta", "lvca", "vras", "varran", "wara", "fma", "lvara", "fras", "baga", "wran", "upru", "lara", "wra", "Vran", "upra", "hara", "vma", "Vra", " vma", "vru", "svras", "ivran", "bha", "farea", "lran", "lru", "bra", "Vca", "nvara", " vrera", "vtra", "vcra", "wta", "varea", "fra", "vRA", " vira", "bara", "nvra", "vca", "libru", "haga", "Vma", " vras", "nvtra", "libran", "ftra", "vcru", "vha", "fru", "varra", " vca", "vartra", " vRA", "ivarea", "hra", "svira", " vara", "varha", "lvru", "varara", "lvra", "fran", "nvran", "ivra", "lvRA", "svrera", "vaga", "svran", "lvran", "lira", "vcRA", "svara", "fara", "vta", "varaga", "libara", "hran", "lra", "upran", " vha", "ivtra", " vran", "vara", "vararea", "vran", " vta"], "vq": [" vance", "volance", "invque", "verquest", "fiq", "volql", "Vq", "ovcc", "avque", "convance", "vcc", "svQ", "vvqs", "encc", " vQ", " vqu", "fq", "viq", "ovix", "convq", "VQ", "fqa", "vqa", "vql", "avqa", "ovqu", "verque", "Viq", " vqa", "svql", "varq", "svdq", "convw", " vdq", "varquest", " viq", "convql", "vqs", "alQ", "fque", "vix", " vque", "invQ", "uvQ", "volqu", "jqu", "viewance", "vvquest", "verq", "svqu", "fra", "uvq", "varqu", "verqs", "invix", "invqu", "enq", "vdq", "vvque", "vardq", "varql", "verqu", "valque", " vix", "enqu", "svqa", "frc", "vquest", " vquest", "Vqu", "varcc", "viewq", "volw", "ovQ", "enquest", "valw", "alq", "sviq", "varqa", "vance", "avQ", "valq", "ovq", "vQ", "vque", "avql", "vqu", "jra", "vvq", " vql", " vqs", "avq", "aviq", "vw", " vw", "volq", "viewqu", "jq", "valqu", "viewql", "invquest", "invq", "verance", " vrc", "fqu", "vrc", "aliq", "alqu", "invw", "svq", "uvque", "jrc", "verql", "ovquest", "uvql"]}}
{"project": "FFmpeg", "commit_id": "e7843db3df0224cafcc1af9da103a3a7286ae2ba", "target": 1, "func": "void ff_get_unscaled_swscale(SwsContext *c)\n\n{\n\n    const enum PixelFormat srcFormat = c->srcFormat;\n\n    const enum PixelFormat dstFormat = c->dstFormat;\n\n    const int flags = c->flags;\n\n    const int dstH = c->dstH;\n\n    int needsDither;\n\n\n\n    needsDither = isAnyRGB(dstFormat) &&\n\n            c->dstFormatBpp < 24 &&\n\n           (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));\n\n\n\n    /* yv12_to_nv12 */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) &&\n\n        (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {\n\n        c->swScale = planarToNv12Wrapper;\n\n    }\n\n    /* yuv2bgr */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUV422P ||\n\n         srcFormat == PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) &&\n\n        !(flags & SWS_ACCURATE_RND) && !(dstH & 1)) {\n\n        c->swScale = ff_yuv2rgb_get_func_ptr(c);\n\n    }\n\n\n\n    if (srcFormat == PIX_FMT_YUV410P &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_BITEXACT)) {\n\n        c->swScale = yvu9ToYv12Wrapper;\n\n    }\n\n\n\n    /* bgr24toYV12 */\n\n    if (srcFormat == PIX_FMT_BGR24 &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_ACCURATE_RND))\n\n        c->swScale = bgr24ToYv12Wrapper;\n\n\n\n    /* RGB/BGR -> RGB/BGR (no dither needed forms) */\n\n    if (   isAnyRGB(srcFormat)\n\n        && isAnyRGB(dstFormat)\n\n        && srcFormat != PIX_FMT_BGR8      && dstFormat != PIX_FMT_BGR8\n\n        && srcFormat != PIX_FMT_RGB8      && dstFormat != PIX_FMT_RGB8\n\n        && srcFormat != PIX_FMT_BGR4      && dstFormat != PIX_FMT_BGR4\n\n        && srcFormat != PIX_FMT_RGB4      && dstFormat != PIX_FMT_RGB4\n\n        && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE\n\n        && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE\n\n        && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK\n\n        && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE\n\n        && srcFormat != PIX_FMT_RGB48LE   && dstFormat != PIX_FMT_RGB48LE\n\n        && srcFormat != PIX_FMT_RGB48BE   && dstFormat != PIX_FMT_RGB48BE\n\n        && srcFormat != PIX_FMT_BGR48LE   && dstFormat != PIX_FMT_BGR48LE\n\n        && srcFormat != PIX_FMT_BGR48BE   && dstFormat != PIX_FMT_BGR48BE\n\n        && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n\n        c->swScale= rgbToRgbWrapper;\n\n\n\n    /* bswap 16 bits per pixel/component packed formats */\n\n    if (IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR565) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_GRAY16) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB565))\n\n        c->swScale = packed_16bpc_bswap;\n\n\n\n    if ((usePal(srcFormat) && (\n\n        dstFormat == PIX_FMT_RGB32   ||\n\n        dstFormat == PIX_FMT_RGB32_1 ||\n\n        dstFormat == PIX_FMT_RGB24   ||\n\n        dstFormat == PIX_FMT_BGR32   ||\n\n        dstFormat == PIX_FMT_BGR32_1 ||\n\n        dstFormat == PIX_FMT_BGR24)))\n\n        c->swScale = palToRgbWrapper;\n\n\n\n    if (srcFormat == PIX_FMT_YUV422P) {\n\n        if (dstFormat == PIX_FMT_YUYV422)\n\n            c->swScale = yuv422pToYuy2Wrapper;\n\n        else if (dstFormat == PIX_FMT_UYVY422)\n\n            c->swScale = yuv422pToUyvyWrapper;\n\n    }\n\n\n\n    /* LQ converters if -sws 0 or -sws 4*/\n\n    if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) {\n\n        /* yv12_to_yuy2 */\n\n        if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) {\n\n            if (dstFormat == PIX_FMT_YUYV422)\n\n                c->swScale = planarToYuy2Wrapper;\n\n            else if (dstFormat == PIX_FMT_UYVY422)\n\n                c->swScale = planarToUyvyWrapper;\n\n        }\n\n    }\n\n    if (srcFormat == PIX_FMT_YUYV422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = yuyvToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = uyvyToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = yuyvToYuv422Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = uyvyToYuv422Wrapper;\n\n\n\n    /* simple copy */\n\n    if ( srcFormat == dstFormat ||\n\n        (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P) ||\n\n        (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P) ||\n\n        (isPlanarYUV(srcFormat) && isGray(dstFormat)) ||\n\n        (isPlanarYUV(dstFormat) && isGray(srcFormat)) ||\n\n        (isGray(dstFormat) && isGray(srcFormat)) ||\n\n        (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) &&\n\n         c->chrDstHSubSample == c->chrSrcHSubSample &&\n\n         c->chrDstVSubSample == c->chrSrcVSubSample &&\n\n         dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21 &&\n\n         srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n\n    {\n\n        if (isPacked(c->srcFormat))\n\n            c->swScale = packedCopyWrapper;\n\n        else /* Planar YUV or gray */\n\n            c->swScale = planarCopyWrapper;\n\n    }\n\n\n\n    if (ARCH_BFIN)\n\n        ff_bfin_get_unscaled_swscale(c);\n\n    if (HAVE_ALTIVEC)\n\n        ff_swscale_get_unscaled_altivec(c);\n\n}\n", "idx": 14694, "substitutes": {"c": ["enc", "ct", "d", "cpp", "cu", "oc", "cont", "v", "cm", "tc", "sc", "e", "cs", "con", "C", "nc", "u", "cf", "cit", "pc", "l", "cb", "ec", "cc", "dc", "cmp", "m", "conf", "this", "uc", "lc", "rc", "config", "g", "k", "self", "n", "ac", "ch", "ci", "ce", "vc", "cur", "ctx", "cache", "i", "cp", "s", "p", "cl", "b", "cy", "coll", "co", "ctrl", "ic", "f", "cr", "mc", "ca", "call", "r", "xc", "t", "cv"], "needsDither": [" needsduth", "needsDsuth", "needsDalth", " needsdiring", " needsDiring", "needsDsither", "needsLither", "needsdither", "needsduth", "needsDsiring", "forcesLith", "needsDithering", "needsDiring", "needsDDithering", "needsdithering", " needsDuth", "forcesDither", "needsDDuth", " needsdithering", "needsIither", "needsDuith", " needsdither", "needsDsithering", "forcesDalth", "needsDuth", "forcesLithering", "needsDuithering", " needsDithering", "forcesDithering", "forcesDith", "needsIalth", "needsLalth", "needsDith", "needsLithering", "forcesLalth", "needsdiring", "needsDuither", "needsDualth", "needsLith", "needsDDiring", "needsDDither", "needsIith", "forcesLither", "needsIithering"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);\n\n    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &w->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n\n\n    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);\n\n\n\n    return w;\n\n}\n", "idx": 14716, "substitutes": {"br": ["module", "bd", "ctr", "dr", "bl", "fore", "jp", "bf", "bal", "plug", "adr", "bc", "obj", "ber", "wr", "base", "fb", "kr", "db", "el", "bar", "lr", "str", "bridge", "bh", "pr", "tr", "brid", "rb", "block", "fr", "org", "ch", "Br", "hr", "bre", "current", "bp", "pb", "ler", "ref", "p", "b", "sw", "ver", "mr", "coll", "arr", "BR", "ger", "gr", "cr", "pl", "sr", "or", "ab", "bo", "err", "er", "buf", "r", "j", "browser", "bro", "driver", "img", "var", "bm"], "pd": ["client", "d", "bd", "ad", "dt", "tp", "md", "po", "ld", "pc", "pm", "cd", "pi", "wd", "hd", "ds", "pp", "raf", "pad", "pg", "db", "dc", "pid", "fd", "cdn", "PD", "dl", "df", "lp", "vd", "xd", "ctx", "pa", "dh", "sd", "fc", "ppa", "cp", "p", "od", "dd", "dp", "td", "py", "gd", "da", "pb"], "parent": ["large", "client", "part", "global", "author", "known", "source", "Parent", "image", "pos", "pt", "bc", "inner", "pc", "base", "server", "parents", "resource", "post", "path", "writer", "full", "root", "new", "pid", "m", "father", "uc", "prev", "pool", "unit", "bridge", "host", "g", "wan", "self", "block", "ctx", "pa", "cache", "home", "c", "node", "current", "p", "other", "ph", "instance", "public", "f", "row", "child", "port", "master", "parser", "remote", "r", "any", "null"], "w": ["wall", "wh", "d", "ew", "rw", "tw", "wig", "war", "wal", "v", "e", "u", "l", "wd", "work", "wb", "wu", "iw", "writer", "wp", "wm", "ow", "W", "hw", "wo", "aw", "g", "wan", "wx", "word", " W", "wer", "win", "wi", "c", "widget", "x", "ww", "wl", "window", "wt", "p", "h", "we", "sw", "b", "way", "kw", "f", "web", "r", "fw", "t", "wk", "wa"]}}
{"project": "FFmpeg", "commit_id": "e22ebd04bcab7f86548794556c28ecca46d9c2ac", "target": 0, "func": "static void hls_transform_tree(HEVCContext *s, int x0, int y0,\n\n                               int xBase, int yBase, int cb_xBase, int cb_yBase,\n\n                               int log2_cb_size, int log2_trafo_size,\n\n                               int trafo_depth, int blk_idx)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    uint8_t split_transform_flag;\n\n\n\n    if (trafo_depth > 0 && log2_trafo_size == 2) {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);\n\n    } else {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;\n\n    }\n\n\n\n    if (lc->cu.intra_split_flag) {\n\n        if (trafo_depth == 1)\n\n            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];\n\n    } else {\n\n        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];\n\n    }\n\n\n\n    lc->tt.cbf_luma = 1;\n\n\n\n    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&\n\n                              lc->cu.pred_mode == MODE_INTER &&\n\n                              lc->cu.part_mode != PART_2Nx2N &&\n\n                              trafo_depth == 0;\n\n\n\n    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&\n\n        log2_trafo_size >  s->sps->log2_min_tb_size    &&\n\n        trafo_depth     < lc->cu.max_trafo_depth       &&\n\n        !(lc->cu.intra_split_flag && trafo_depth == 0)) {\n\n        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);\n\n    } else {\n\n        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||\n\n                               (lc->cu.intra_split_flag && trafo_depth == 0) ||\n\n                               lc->tt.inter_split_flag;\n\n    }\n\n\n\n    if (log2_trafo_size > 2) {\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n    }\n\n\n\n    if (split_transform_flag) {\n\n        int x1 = x0 + ((1 << log2_trafo_size) >> 1);\n\n        int y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n\n\n        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 0);\n\n        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 1);\n\n        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 2);\n\n        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 3);\n\n    } else {\n\n        int min_tu_size      = 1 << s->sps->log2_min_tb_size;\n\n        int log2_min_tu_size = s->sps->log2_min_tb_size;\n\n        int min_tu_width     = s->sps->min_tb_width;\n\n\n\n        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {\n\n            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);\n\n        }\n\n\n\n        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,\n\n                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);\n\n\n\n        // TODO: store cbf_luma somewhere else\n\n        if (lc->tt.cbf_luma) {\n\n            int i, j;\n\n            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)\n\n                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {\n\n                    int x_tu = (x0 + j) >> log2_min_tu_size;\n\n                    int y_tu = (y0 + i) >> log2_min_tu_size;\n\n                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;\n\n                }\n\n        }\n\n        if (!s->sh.disable_deblocking_filter_flag) {\n\n            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,\n\n                                                  lc->slice_or_tiles_up_boundary,\n\n                                                  lc->slice_or_tiles_left_boundary);\n\n            if (s->pps->transquant_bypass_enable_flag &&\n\n                lc->cu.cu_transquant_bypass_flag)\n\n                set_deblocking_bypass(s, x0, y0, log2_trafo_size);\n\n        }\n\n    }\n\n}\n", "idx": 14723, "substitutes": {"s": ["ps", "storage", "sync", "us", "o", "session", "sv", "rs", "site", "sc", "cs", "e", "sa", "u", "ts", "l", "ds", "sys", "si", "ss", "space", "ssl", "service", "sq", "gs", "sf", "sec", "xs", "g", "self", "os", "spec", "ctx", "acs", "context", "c", "h", "sg", "su", "ns", "p", "qs", "sl", "f", "sie", "sb", "ses", "js", "settings", "ls", "r", "services", "S", "t", "sk"], "x0": ["xxee", "xyBase", "x4", "rx1", "xxNo", " xStart", "xZero", "xx0", " xNo", "y4", "xp4", " x250", "x1", "y10", "XBase", " x10", "xy0", "y250", "y1", "axZero", "rxStart", " xSource", "XStart", "rx0", "yNo", "ySource", "ax1", "xSource", " x4", "xp1", "xNo", " xee", " x1", "x250", "xp0", "ax10", "xStart", "xx1", "x10", "yee", "X0", "rxBase", "yZero", "ax0", " xZero", "xySource", "xy1", "xp250", "xee", "X1"], "y0": ["eyElement", "yItem", "y00", " y1", "y3", " y3", "yEl", " y50", "ry1", "Y00", "asyItem", "yElement", "asy1", "vy1", "YOrigin", "Y50", "y1", "ryEl", "ey1", "vyBase", " yEl", "Y0", "ySource", "ry50", " ySource", "yOrigin", "YItem", "ey0", "yy1", "ry0", " yOrigin", "asy0", "YElement", "Y1", "ryBase", "rySource", "yy0", " y00", "yyOrigin", "YSource", "Y3", "vy3", "YEl", "asyElement", "yy00", "vy0", "y50", "eyItem", "YBase"], "xBase": ["xSize", "xZero", "Xbase", "ySize", "XBase", "xMax", "yMax", "ix0", "XMax", " xMax", " xSize", " xbase", "ixBase", "X0", "ixbase", "yZero", " xZero", "ixZero", "ybase", "xbase", "XSize"], "yBase": [" yByte", "Ybase", "YBuffer", "yBased", "eyBack", "yaSource", "yByte", " yBack", "yaByte", "vybase", "vyBase", "eyBase", "xBased", "ySource", "yBack", " yBased", " yBuffer", " ySource", "YByte", "YBack", " ybase", "eybase", "YSource", "yBuffer", "eyBuffer", "ybase", "yaBased", "vy0", "vyBased", "xbase", "YBased", "yaBase", "YBase"], "cb_xBase": ["cb_wEnd", "cb_ey0", "cb_eyBase", "cb_yUnit", "cb_yEnd", "cb_wBase", "cb_xEnd", "cb_x0", "cb_y0", "cb_xUnit", "cb_eyEnd", "cb_eyUnit", "cb_wUnit", "cb_w0"], "cb_yBase": ["cb_cyScale", "cb_cyRest", "cb_yRest", "cb_cy0", "cb_zyRest", "cb_zy0", "cb_zyScale", "cb_yScale", "cb_y0", "cb_x0", "cb_xScale", "cb_zyBase", "cb_xRest", "cb_cyBase"], "log2_cb_size": ["log2_cb2size", "log2_cb2capacity", "log2_cb2small", "log2_cb_small", "log2_bb_capacity", "log2_bb_small", "log2_cb_count", "log2_cb2count", "log2_cb_capacity", "log2_bb_count", "log2_bb_size"], "log2_trafo_size": ["log2_traco_depth", "log2_traf_size", "log2_traco_size", "log2_trafi_go", "log2_traf_scale", "log2_trafo_weight", "log2_trafo_len", "log2_trafo_go", "log2_trafi_size", "log2_trafo_scale", "log2_traf_weight", "log2_traco_width", "log2_trafi_depth", "log2_traf_depth", "log2_traf_len", "log2_trafo_width", "log2_trafo_depth"], "trafo_depth": ["traf_root", "trafo_weight", "trafo_rank", "tre\n", "traverse_height", "trafi_count", "trafo_uri", "trafi_size", "traph_root", "trafo_distance", "trafo_root", "traverse_level", "trafo_scale", "traph_size", "trafo_color", "tra\n", "tratto_rank", "traf_weight", "trafo_strength", "tratto_size", "tratto_scale", "trafo_level", "traf_length", "tratto_depth", "traf_deep", "tratto_level", "traph_color", "traf_mode", "tratto_deep", "traf_distance", "trafo_deep", "trafi_depth", "trafi_root", "trafo_count", "trafo_size", "trafi_deep", "trafo_mode", "traf_size", "trafo_length", "ra\n", " tra\n", "traph_deep", "traph_depth", "traph_uri", "traf_depth", "trafo_height", "traverse_depth", "traverse_strength"], "blk_idx": ["blk_Idxs", "blk_idew", "blk1idew", "blk_idv", "blk_Idw", "blk_catw", "blk_pidc", "blk_idec", "blk_catv", "blk_idxs", "blk1idw", "blk_idw", "blk_idsxs", "blk_idev", "blk_Idc", "blk_Idv", "blk1idc", "blk_pidw", "blk1idx", "blk_idsw", "blk_catx", "blk_idsx", "blk_catxs", "blk_idc", "blk1idec", "blk_pidx", "blk1idv", "blk1idex", "blk_idex", "blk_pidv", "blk_idsv", "blk1idev", "blk_Idx"], "lc": ["kl", "cu", "cn", "la", "cm", "tc", "li", "ll", "cs", "nc", "bc", "ld", "sci", "sc", "pc", "cf", "l", "lt", "icc", "ml", "si", "lu", "cc", "dc", "lex", "ga", "lic", "uc", "lr", "lb", "lin", "hl", "dl", "rc", "cus", "lp", "LC", "vc", "ci", "spec", "ctx", "CI", "ln", "fc", "ku", "cache", "c", "wl", "lib", "cli", "cl", "coll", "ic", "ctrl", "lv", "uci", "sb", "lf", "mc", "acl", "cci", "rl", "gb", "lang", "ls", "cell", "loc", "ii", "conn", "cas", "jc"], "split_transform_flag": ["split_transform_count", "split_transform\u00b7flag", "split_transform\u00b7only", "split_transfer_only", "split_transform\u00b7count", "split_transfer_flag", "split_transfer_bit", "split_transform\u00b7bit", "split_transfer_count", "split_transform_only", "split_transform_bit"]}}
{"project": "FFmpeg", "commit_id": "ba3f07d0611d9a6c10eaa90b3c058ecdffe76676", "target": 1, "func": "static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,\n\n                          int block_idx, AMRFixed *fcb)\n\n{\n\n    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding\n\n    uint16_t *use_mask = use_mask_mem + 2;\n\n    /* in this function, idx is the index in the 80-bit (+ padding) use_mask\n\n     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits\n\n     * of idx are the position of the bit within a particular item in the\n\n     * array (0 being the most significant bit, and 15 being the least\n\n     * significant bit), and the remainder (>> 4) is the index in the\n\n     * use_mask[]-array. This is faster and uses less memory than using a\n\n     * 80-byte/80-int array. */\n\n    int pulse_off = s->aw_first_pulse_off[block_idx],\n\n        pulse_start, n, idx, range, aidx, start_off = 0;\n\n\n\n    /* set offset of first pulse to within this block */\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        while (pulse_off + s->aw_pulse_range < 1)\n\n            pulse_off += fcb->pitch_lag;\n\n\n\n    /* find range per pulse */\n\n    if (s->aw_n_pulses[0] > 0) {\n\n        if (block_idx == 0) {\n\n            range = 32;\n\n        } else /* block_idx = 1 */ {\n\n            range = 8;\n\n            if (s->aw_n_pulses[block_idx] > 0)\n\n                pulse_off = s->aw_next_pulse_off_cache;\n\n        }\n\n    } else\n\n        range = 16;\n\n    pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;\n\n\n\n    /* aw_pulse_set1() already applies pulses around pulse_off (to be exactly,\n\n     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus\n\n     * we exclude that range from being pulsed again in this function. */\n\n    memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));\n\n    memset( use_mask,   -1, 5 * sizeof(use_mask[0]));\n\n    memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) {\n\n            int excl_range         = s->aw_pulse_range; // always 16 or 24\n\n            uint16_t *use_mask_ptr = &use_mask[idx >> 4];\n\n            int first_sh           = 16 - (idx & 15);\n\n            *use_mask_ptr++       &= 0xFFFF << first_sh;\n\n            excl_range            -= first_sh;\n\n            if (excl_range >= 16) {\n\n                *use_mask_ptr++    = 0;\n\n                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);\n\n            } else\n\n                *use_mask_ptr     &= 0xFFFF >> excl_range;\n\n        }\n\n\n\n    /* find the 'aidx'th offset that is not excluded */\n\n    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);\n\n    for (n = 0; n <= aidx; pulse_start++) {\n\n        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;\n\n        if (idx >= MAX_FRAMESIZE / 2) { // find from zero\n\n            if (use_mask[0])      idx = 0x0F;\n\n            else if (use_mask[1]) idx = 0x1F;\n\n            else if (use_mask[2]) idx = 0x2F;\n\n            else if (use_mask[3]) idx = 0x3F;\n\n            else if (use_mask[4]) idx = 0x4F;\n\n            else                  return;\n\n            idx -= av_log2_16bit(use_mask[idx >> 4]);\n\n        }\n\n        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n\n            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));\n\n            n++;\n\n            start_off = idx;\n\n        }\n\n    }\n\n\n\n    fcb->x[fcb->n] = start_off;\n\n    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;\n\n    fcb->n++;\n\n\n\n    /* set offset for next block, relative to start of that block */\n\n    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;\n\n    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;\n\n}\n", "idx": 14741, "substitutes": {"s": ["storage", "sync", "us", "sv", "session", "o", "your", "rs", "site", "south", "sim", "sc", "cs", "e", "u", "ts", "l", "ds", "states", "sys", "si", "ss", "space", "service", "se", "m", "ssl", "conf", "this", "sq", "gs", "sf", "g", "es", "ks", "self", "os", "spec", "ctx", "stats", "is", "c", "su", "sg", "p", "ns", "qs", "b", "sl", "sets", "f", "sb", "sie", "ses", "w", "js", "utils", "settings", "ls", "sym", "services", "S", "r", "t", "less", "support"], "gb": ["gate", "gm", "bc", "cfg", "cmd", "cb", "gc", "wm", "ga", "ui", " bc", "gs", "bg", "bridge", "g", "rb", "gam", "usb", "buff", "mac", "sg", "gg", "src", "sb", "mc", "gp", "gd", "conf", "bm"], "block_idx": ["block_Idxx", "block__itex", "block_indz", "block_itew", "block_itex", "block_modecent", "blockOindexxs", "block_defx", "block_idxs", "block_iteX", "blockOidxx", "block00idents", "block_Idx", "blockEidng", "block_Idz", "block_itxes", "block_iddng", "block_iteng", "blockEidentx", "block_indxes", "block_idst", "blockOindexw", "blockOindexxes", "block__idX", "block__idx", "block00idcent", "block_beginxx", "block_idsx", "block_ridx", "block_itest", "block__idw", "block_iddx", "block_ridy", "block_modeom", "block_itexx", "block_namex", "block_iddxx", "block_idsxes", "block_lengthx", "block_modes", "blockEidentng", "block_nameng", "blockObeginng", "block_endxs", "block_idc", "block_endw", "block_defng", "block_lengthcent", "block_indexx", "block_ridc", "block_namest", "blockEidxx", "block_idw", "block_itz", "blockObeginxes", "block_indng", "block__itexx", "blockObeginx", "block_endxes", "blockOidw", "block_idom", "block00identom", "block_namexx", "block_indexxs", "block_lengthom", "block_idng", "block_endxx", "block_identx", "block_endX", "block__itew", "block_idxx", "blockOidxes", "block_indx", "block_identxx", "block_lengths", "block_Idy", "block_endx", "block_itx", "blockOidxs", "blockOidng", "block_idents", "block_beginng", "block_idX", "blockEidentst", "block_idz", "block_indexxes", "blockObeginxx", "block_modex", "block_idy", "blockOidx", "block_iddxes", "block_beginz", "blockEidst", "block_Idc", "block_ridz", "block_beginx", "block_Idw", "block__iteX", "block_ids", "block_identst", "block_IdX", "block_defxx", "block00ids", "block_identcent", "block00identcent", "block_itng", "block_identom", "block00identx", "blockEidx", "block_indexw", "block00idx", "block_idsxs", "blockEidentxx", "block_beginxes", "blockOindexx", "block_idsw", "block_defxes", "block_identng", "block__idxx", "block00idom", "block_idcent", "block_idxes"], "fcb": ["rcb", "FCsb", "FCd", "feb", "fcd", "lcl", "FCbs", "FCm", "fxb", "fxsb", "fcbs", "fnc", "fb", "fxbs", "fcc", "fem", "fec", "lcm", "dcl", "fxB", "fbs", "fen", "lcd", "dcm", "fsb", "lcb", "fnm", "FCB", "dcd", "fnn", "rcm", "fB", "fnb", "fcn", "rcc", "fcB", "fcl", "fcm", "rcn", "dcb", "fcsb", "FCb", "FCl"], "use_mask_mem": ["use_map_Mem", "use_ask_ram", "use_ask_memory", "use_mask_Mem", "use_mask_ram", "use_map_ram", "use_mask_memory", "use_map_all", "use_mask_all", "use_map_mem", "use_ask_mem"], "use_mask": [" use2map", "ride_ask", "uselogshape", "use_black", "usePcost", "use_sign", "use\u00b7miss", "use_cost", "usealcloud", "seePmargin", " use_map", "see_mask", "usePmask", "matchlogmask", "seePcost", "ride_mask", "apply_mask", "ride_sign", "see_cost", "usealshape", "use_count", "see_miss", "usexmask", "apply_ask", "uselymask", "use\u00b7cost", "use__cache", "use_sum", "rule_black", "rulelymask", "rule_mask", "usage_cache", "ridealsign", "usage_mask", "use_cache", "apply_lock", "usealcount", "use_ask", "use2lock", "see_margin", "match_filter", "uselygap", "ride_cloud", "apply_window", "match_mask", "usePmiss", "usePmargin", "usealfilter", "uselyask", "uselogmask", "use_filter", "use__cost", "use_gap", " use2group", "use2mask", "uselogcount", "matchlogfilter", "usexcost", "matchlogshape", "rulelyblack", "usage_sum", "rulelycache", "seePmask", "use_cloud", "use2map", "use2group", " use_sum", "match_count", " use2sum", "use_margin", "use2sum", " use_lock", "usealmask", "match_shape", "usealsign", "use_lock", "usage_cost", "use__sum", "uselylock", "usexmargin", "uselywindow", " use_group", "use_group", "use2filter", " use_filter", "use_shape", "ridealask", "rule_gap", "uselogfilter", "use_map", "seePmiss", "rulelygap", "matchlogcount", "uselycache", "use\u00b7margin", "ridealcloud", "use__mask", "usexmiss", "use\u00b7mask", "ridealmask", "use_miss", " use2mask", "uselyblack", "usealask", "use_window", "rule_cache"], "pulse_start": ["pitch_len", "pitch_end", "pulse_len", "pulse_set", "pulse_off", "pitch_start", "pitch_set", "pitch_stop", "pulse_stop", "pulse_end", "pitch_off"], "n": ["d", "o", "e", "nc", "u", "network", "l", "y", "m", "sn", "num", "g", "z", "np", "nb", "node", "N", "c", "i", "ns", "p", "b", "ni", "f", "w", "r", "len"], "idx": ["idxes", "idX", " idX", " idix", "Idxs", " idz", "idy", "sidX", "indx", "indix", "aidy", "idey", "ridxs", "ridw", " idw", "Idx", "sidx", "aidxc", "indxes", "idxc", "idc", "sidxc", "IdX", "ridX", "idec", "aidz", "indxs", "aidX", "midX", "idw", " idxc", "ridx", "idex", "partix", " idxs", "idexes", "Idxc", "partxs", "indy", "idix", "indX", "partx", "idxs", "partX", "sidxs", "midx", "aidxs", "midxs", " idxes", "aidxes", "aidc", "indc", "idz", "midw", "indz"], "range": ["binary", "ne", "gap", "route", "nor", "ge", "mode", "e", "feature", "use", "end", "random", "length", "size", "l", "area", "ange", "resource", "Range", "grade", "domain", "offset", "slice", "limit", "state", "nr", "frame", "ranged", "error", "spread", "lim", "scale", "role", "view", "num", "channel", "last", "block", "fr", "low", "version", "cache", "max", "line", "ver", "start", "row", "repeat", "rate", "f", "err", "r", "ace", "chain", "loc", "lag", "rule", "none", "array", "span", "from"], "aidx": ["aidy", "adx", " idy", " idr", " idc", "adc", "ady", "idy", "aidc", "idc", "aidr", "adr", "idr"], "use_mask_ptr": ["use_ask_pointer", "use_ask_tr", "use_ask_addr", "use_mask_tr", "use_ask_ctr", "use_ask_ptr", "use_mask_addr", "use_mask__addr", "use_mask_pos", "use_mask_pointer", "use_mask__tr", "use_mask__ptr", "use_mask__ctr", "use_mask_ctr"]}}
{"project": "FFmpeg", "commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "target": 1, "func": "static void asf_build_simple_index(AVFormatContext *s, int stream_index)\n\n{\n\n    ff_asf_guid g;\n\n    ASFContext *asf     = s->priv_data;\n\n    int64_t current_pos = avio_tell(s->pb);\n\n    int i;\n\n\n\n    avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);\n\n    ff_get_guid(s->pb, &g);\n\n\n\n    /* the data object can be followed by other top-level objects,\n\n     * skip them until the simple index object is reached */\n\n    while (ff_guidcmp(&g, &index_guid)) {\n\n        int64_t gsize = avio_rl64(s->pb);\n\n        if (gsize < 24 || s->pb->eof_reached) {\n\n            avio_seek(s->pb, current_pos, SEEK_SET);\n\n            return;\n\n        }\n\n        avio_skip(s->pb, gsize - 24);\n\n        ff_get_guid(s->pb, &g);\n\n    }\n\n\n\n    {\n\n        int64_t itime, last_pos = -1;\n\n        int pct, ict;\n\n        int64_t av_unused gsize = avio_rl64(s->pb);\n\n        ff_get_guid(s->pb, &g);\n\n        itime = avio_rl64(s->pb);\n\n        pct   = avio_rl32(s->pb);\n\n        ict   = avio_rl32(s->pb);\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n\n\n        for (i = 0; i < ict; i++) {\n\n            int pktnum        = avio_rl32(s->pb);\n\n            int pktct         = avio_rl16(s->pb);\n\n            int64_t pos       = s->data_offset + s->packet_size * (int64_t)pktnum;\n\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n\n\n            if (pos != last_pos) {\n\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n\n                       pktnum, pktct, index_pts);\n\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n\n                last_pos = pos;\n\n            }\n\n        }\n\n        asf->index_read = ict > 0;\n\n    }\n\n    avio_seek(s->pb, current_pos, SEEK_SET);\n\n}\n", "idx": 14745, "substitutes": {"s": ["session", "site", "sc", "u", "ts", "its", "states", "sys", "in", "se", "plugins", "xs", "self", "sup", "n", "spec", "qs", "sb", "js", "services", "t", "native", "ps", "sync", "fs", "your", "ins", "e", "cs", "ions", "ss", "ssl", "new", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "settings", "less", "storage", "us", "sites", "data", "l", "ds", "service", "stats", "http", "ses", "ms", "sym", "S", "ops", "single", "comments", "d", "sv", "rs", "south", "secondary", "features", "server", "full", "uns", "bs", "es", "ks", "os", "su", "p", "tests", "b", "sets", "f", "ls", "r", "conf"], "stream_index": [" stream_ctx", " stream_ref", " stream_input"], "g": ["debug", "d", "gl", "gi", "guide", "ge", "gm", "e", "u", "erg", "cfg", "l", " eg", "gc", "pg", "ga", "eg", "group", "ig", "m", "gh", "gs", "bg", " G", "general", "num", "G", "go", "reg", "n", "arg", "gu", "gar", "gam", "greg", "x", "c", "h", "sg", "p", "b", "f", "gen", "vg", "msg", "w", "gp", "gb", "game", "rg", "j", "gd", "mg"], "asf": ["rasv", "Asfo", "arsl", "asfo", "atsc", "arsfo", " asl", "atsf", "assf", " asfc", "Asfc", "asfs", "asv", "rasf", "arsfp", "Asp", "ASfs", "asp", "rasc", "masc", " asfo", "Asc", " asc", "assl", "asl", "asfc", "assfp", " asv", "masv", "masf", "masfs", "asc", "assfo", "atsfo", "ASc", "rasp", "Asfs", "asfp", "atsfc", "Asf", "rasfs", "arsf", "ASf", " asfs", " asfp", "ASp"], "i": ["adi", "anti", "it", "d", "ati", "di", "gl", "gi", "chi", "ini", "iu", "fi", "t", "multi", "li", "ge", "gm", "u", "xi", "inner", "l", "pi", "oi", "uri", "si", "in", "ai", "m", "gui", "group", "ui", "api", "aci", "bg", "udi", "ti", "G", "z", "ani", "ix", "n", "eni", "gu", "ik", "id", "ci", "mini", "bi", "qi", "ip", "c", "x", "h", "hi", "ami", "ji", "p", "cli", "ki", "info", "index", "uli", "idi", "ic", "ni", "start", "zi", "ski", "j", "ii", "I", "yi"], "itime": ["riage", "imei", "uture", "ie", "isd", "phil", "ne", "uni", "iti", "qq", "mi", "umi", "industrial", "txt", "inet", "iman", "ige", "duty", "mine", "cit", "ib", "nit", "ih", "uri", "nil", "loc", "ele", "mis", "quad", "udi", "lane", "agency", "ahi", "eni", "rice", "iv", "ime", "ide", "ship", "igure", "ngth", "imi", "pir", "ine", "cli", "groupon", "metadata", "ila", "ski", "interest", "xxx", "oni", "nir", "imet", "ii", "mie", "uti", "asi"], "pct": ["tpkt", "vpcent", " pdc", "pcent", "PCT", "jpnt", "jpCT", "gct", "pcy", " pcr", "tpcr", "Pct", "tpcent", "Pcr", "vpct", "gnt", "jpcr", "lpnt", "pdc", "lpcy", "vpcr", "lpct", "pCT", "vpkt", "pnt", "Pnt", "pcr", "lpdc", " pcent", "tpct", " pcy", "gdc", "gcy", " pnt", "jpct", " pCT", "pkt", " pkt"], "ict": ["gt", "FFFF", "unch", "cc", "limit", "ac", "icit", "dict", "omm", "atts", "ic", "anta", "ct", "txt", "nt", "ht", "oci", "ich", "icts", "ant", "ect", "iot", "max", "sg", "dd", "ants", "et", "di", "voc", "iw", "qt", "qa", "pg", "vag", "gh", "tt", "oga", "ICT", "catch", "aud", "dr", "pt", "ffff", "cit", "irc", "dc", "uc", "ci", "uct", "ot", "cli", "mot", "ont", "acl", "cci", "ogg", "xc", "gd"]}}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n", "idx": 14750, "substitutes": {"bs": ["ps", "fs", "ba", "ins", "bas", "rs", "cs", "sa", "bc", "fb", "base", "ds", "bes", "blocks", "ss", "bos", "state", "BS", "gs", "lb", "obs", "bh", "es", "ks", "rb", "ubs", "os", "iss", "bi", "bits", "vs", "bytes", "ns", "bb", "bps", "b", "aps", "aws", "sb", "ab", "ses", "gb", "ls", "lbs", "bis", "bid", "pb"], "s": ["ps", "sync", "o", "session", "rs", "south", "e", "sa", "cs", "ts", "server", "ds", "states", "sys", "si", "ss", "ssl", "service", "state", "sq", "gs", "a", "g", "es", "n", "os", "spec", "rss", "stats", "is", "submit", "c", "http", "i", "args", "p", "status", "ns", "b", "sl", "aws", "f", "sie", "sb", "ses", "js", "ls", "services", "sym", "S", "socket", "t"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 14774, "substitutes": {"str": ["enc", "orig", "ctr", "iter", "frac", "dr", "rs", "func", "exec", "temp", "txt", "br", "cs", "st", "obj", "inner", "STR", "kr", "in", "res", "sp", "vec", "rr", "ptr", "lc", "pr", "tr", "stri", "fr", "spec", "cur", "hr", "c", "Str", "ext", "s", "arr", "sr", "start", "cr", "f", "old", "er", "r", "text", "std", "gr"], "endptr": [" endproc", "startPtr", "endedPtr", "EndPtr", "endedptr", " endpointer", "startptr", "endedprot", "Endpointer", "adPtr", "Endptr", "endedaddr", "endedproc", "endpointer", "adptr", "endprot", "endedpointer", " endprot", " endPtr", "adpointer", "endaddr", "Endproc", "adprot", "endedctr", "adctr", " endaddr", "adproc", "endctr", "endproc", " endctr", "startproc", "endPtr", "startaddr"], "err": ["ctr", "iter", "bug", "test", "dr", "der", "ar", "fer", "try", "resp", "count", "br", "result", "rh", "cb", "kr", "res", "ise", "lr", "rr", "error", "pr", "fr", "cor", "i", "ler", "range", "req", "ver", "Er", "arr", "cr", "ind", "msg", "ner", "er", "Error", "r", "gr", "var", "code"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 14775, "substitutes": {"hostname": ["portpath", "addresscode", "ipname", "Hostname", "portnames", "Hostnames", " hostName", "portcode", " hostpath", "portName", " hostnames", "ipnum", "hostpath", "ipcode", "Hostpath", "hostnames", "hostnum", "portnum", "addressname", "HostName", "hostName", "hostcode", "portname", "addressnum"], "has_proto": ["has_pocol", "has_perto", "has_Proocol", "has_pego", "has_probe", "has_Probe", "has_progo", "has_protgo", "has_perpo", "has_protdo", "has_propco", "has_protbe", "has_perbe", "has_Proco", "has_Prodo", "has_pto", "has_protf", "has_protpo", "has_Prof", "has_pbe", "has_pf", "has_protto", "has_Proto", "has_prob", "has_preocol", "has_prepo", "has_pedo", "has_protocol", "has_peocol", "has_propbe", "has_propb", "has_protb", "has_Prob", "has_propto", "has_prebe", "has_Progo", "has_proocol", "has_protco", "has_perocol", "has_peto", "has_prof", "has_propo", "has_prodo", "has_preto", "has_proco"], "ai": ["adi", "aud", "ru", "ha", "ati", "address", " mi", "ay", " api", "afi", "af", "fa", "ini", "mi", "ar", "aii", "aur", "sa", "air", "AI", "abi", "uri", "si", "qa", "na", " li", "oci", "an", " ac", " info", "attr", "agi", "api", "iri", "ui", " ja", "ra", "a", "ae", "config", " acc", "ani", "rec", "ac", "hai", "eni", "ci", "ia", "pa", " ar", "bi", "qi", "ami", "i", "info", "pai", "iat", "ni", " ca", "ir", "ca", "ait", "apache", "au", "ais", "AU", "aa", "aaa", "conn", "ee", "ann", "wa"], "res": ["ru", "vre", "ass", "rs", "real", "Res", "func", "rar", "reset", "resp", "results", "ras", "result", "obj", "rest", "rh", "rt", "sys", "resource", "rows", "rap", "ress", "respond", "reply", "ra", "response", "rr", "resolution", "reg", "pre", "self", "rec", "os", "rev", "ray", "rss", "cache", "rm", "complete", "rx", "pres", "args", "req", "core", "ex", "run", "arr", "rep", "sr", "re", "gr", "des", "RES", "cr", "rez", "err", "remote", "r", "resources", "ret", "ris", "rem", "rus"], "rc": ["ror", "sync", "ct", "success", " src", "sc", "rd", "nc", "bc", "result", "rh", "pc", "rt", "cb", "round", "anc", "cc", "dc", "irc", "loc", "cmp", "uc", "rr", "fun", "irm", "error", "lc", "ck", "RC", "rb", "rec", "ac", "rin", "id", "rev", "cur", "fc", "c", "rx", "req", "core", "inc", "co", "ack", "src", "cr", "err", "rl", "auc", "rn", "r", "rg", "rank", "ret", "ref", "conn", "len", "ann", "code"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n", "idx": 14777, "substitutes": {"ctx": ["ct", "ctr", "cam", "cn", "cgi", "exec", "git", "cu", "jp", "cm", "tc", "sc", "cs", "nc", "bc", "pkg", "sci", "cf", "pc", "cmd", "cb", "cfg", "qa", "anc", "gc", "Context", "cc", "cmp", "ga", "queue", "grad", "hw", "lc", "config", "cca", "cot", "ck", "cus", "vc", "ci", "ce", "ch", "cache", "context", "c", "conv", "cp", "cli", "component", "ctrl", "tx", "cr", "crit", "ca", "kt", "gru", "ocr", "que", "xc", "nw", "loc", "fw", "conn", "css", "cas", "cv"], "max_ns": [" max_size", "max_nc", "max__ns", "max0000ns", "end_ns", "max_lines", " max_nc", "end_ms", "end_names", "max0000nc", "max_names", "max_ms", "max_size", "max_sync", "max0000seconds", "maxacrs", "maxacsync", " max_seconds", " max_rs", "maxacns", "max0000sync", "end_lines", "max__lines", "max__names", "maxacsize", "max__ms", "max_seconds", "max_rs", " max_sync"], "end_time": ["end_value", "end_times", "endencall", "end_clock", "endmcost", "end_timer", "max_timer", "beginmcost", "beginmvalue", "endentime", "end_weight", "max_weight", "endentimes", "end_call", "endmtime", "endenclock", "endxvalue", "endxcost", "max_call", "endmvalue", "endxtime", "begin_length", "end_length", "begin_time", "begin_cost", "endmlength", "beginmtime", "begin_value", "endiantimer", "endianweight", "endiantimes", "endiantime", "max_times", "end_cost", "max_time", "max_clock", "endxlength", "beginmlength"], "node": ["client", "document", "hop", "route", "nn", "null", "connection", "edge", "content", "raw", "global", "source", "tree", "op", "fn", "worker", "consumer", "holder", "package", "server", "query", "post", "resource", "path", "object", "root", "ready", "leaf", "cdn", "graph", "parse", "config", "parent", "host", "num", "view", "key", "self", "n", "handler", "id", "dest", "context", "slave", "peer", "stage", "none", "core", "index", "ode", "od", "component", "instance", "name", "child", "master", "load", "remote", "ridge", "nw", "event", "ref", "native", "live", "Node"]}}
{"project": "FFmpeg", "commit_id": "3c5cf2a31b4b29a8e4282cbe6a3f0617c14698b8", "target": 0, "func": "static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,\n\n                                     int *got_frame, AVPacket *avpkt)\n\n{\n\n    ScreenpressoContext *ctx = avctx->priv_data;\n\n    AVFrame *frame = data;\n\n    int keyframe;\n\n    int ret;\n\n\n\n    /* Size check */\n\n    if (avpkt->size < 3) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small (%d)\\n\", avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Basic sanity check, but not really harmful */\n\n    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||\n\n        avpkt->data[1] != 8) { // bpp probably\n\n        av_log(avctx, AV_LOG_WARNING, \"Unknown header 0x%02X%02X\\n\",\n\n               avpkt->data[0], avpkt->data[1]);\n\n    }\n\n    keyframe = (avpkt->data[0] == 0x73);\n\n\n\n    /* Resize deflate buffer and frame on resolution change */\n\n    if (ctx->inflated_size != avctx->width * avctx->height * 3) {\n\n        av_frame_unref(ctx->current);\n\n        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        /* If malloc fails, reset len to avoid preserving an invalid value */\n\n        ctx->inflated_size = avctx->width * avctx->height * 3;\n\n        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);\n\n        if (ret < 0) {\n\n            ctx->inflated_size = 0;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Inflate the frame after the 2 byte header */\n\n    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,\n\n                     avpkt->data + 2, avpkt->size - 2);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Deflate error %d.\\n\", ret);\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    /* When a keyframe is found, copy it (flipped) */\n\n    if (keyframe)\n\n        av_image_copy_plane(ctx->current->data[0] +\n\n                            ctx->current->linesize[0] * (avctx->height - 1),\n\n                            -1 * ctx->current->linesize[0],\n\n                            ctx->inflated_buf, avctx->width * 3,\n\n                            avctx->width * 3, avctx->height);\n\n    /* Otherwise sum the delta on top of the current frame */\n\n    else\n\n        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],\n\n                          ctx->inflated_buf, avctx->width * 3,\n\n                          avctx->width * 3, avctx->height);\n\n\n\n    /* Frame is ready to be output */\n\n    ret = av_frame_ref(frame, ctx->current);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Usual properties */\n\n    if (keyframe) {\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n    } else {\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n    }\n\n    *got_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14813, "substitutes": {"avctx": ["avelc", "avcp", "afconfig", "aveconfig", "afsci", "afctrl", "avsci", " avcu", "avkb", "avepkg", "avcf", "navcf", "Avcu", "AVcp", "verctx", "afctx", "Avconfig", "avlc", "avctrl", "AVnp", "versci", "abxc", "avenp", "AVconn", "apcontext", "vercmp", "afcontext", "vercf", "versync", "akctx", "AVlc", "avectrl", "akcontext", "avesync", "AVcmp", "afpkg", "navctx", "avctl", "avectx", "avecp", "avpkg", "abcontext", "AVctx", "avsync", "AVcf", "AVcu", "aflc", "avecmp", "avxc", "afxc", "avekb", "akcmp", "verctrl", "abconn", "Avcontext", "afkb", "avecf", "apctx", "AVsync", " avcontext", "AVctrl", "Avctx", "afcf", " avconfig", "abcu", "navpkg", "avcu", "afconn", "verkb", "afcmp", "apcmp", "AVconfig", "afctl", "afcu", "avesci", "afnp", "navcontext", "avconn", "avcmp", "AVcontext", "AVpkg", "avconfig", "aveconn", "avexc", "abcmp", "navsync", "abctx", "akctl", "afsync", "avnp", "apctl", "vercontext", "afcp", "avecontext", "avcontext"], "data": ["it", "draw", "pos", "dat", "val", "in", "ui", "api", "response", "parent", "scale", "channel", "i", "addr", "window", "bytes", "Data", "instance", "start", "as", "DATA", "value", "client", "part", "batch", "shift", "split", "raw", "record", "media", "image", "delay", "present", "depth", "header", "new", "offset", "slice", "a", "last", "block", "id", "cache", "x", "input", "memory", "missing", "lines", "load", "buffer", "buf", "ad", "gap", "first", "file", "empty", "count", "result", "message", "script", "end", "head", "area", "size", "bin", "shape", "valid", "byte", "key", "to", "complete", "ack", "name", "get", "call", "sample", "alpha", "code", "pipe", "body", "fail", "d", "actions", "connection", "content", "reader", "results", "base", "length", "style", "align", "pad", "wave", "capacity", "feed", "read", "weight", "ul", "p", "index", "device", "video", "next", "number"], "got_frame": ["get_image", "got_frames", "got_image", "got2frames", "got2frame", "get_frames", "got2buffer", "get2image", "get2frame", "get_buffer", "gotoutimage", "got_buffer", "gotoutframes", "gotoutbuffer", "gotoutframe", "get2frames", "get2buffer", "got2image", "get_frame"], "avpkt": ["AVpacket", "afputh", "avppft", "avebeter", "akputh", "afpelt", " avpcht", " avbpelt", "avbpelt", "avpdat", "afpdt", "avmkt", "avmfx", "avepaga", " avbpkt", "afpnt", "avbacket", "avfpcht", "avPdr", "avbcht", "avpolaga", "avpreter", "avcpft", " avbpka", "avpolwd", "avpacker", "avpcht", "avprck", "avPkt", "avfdt", "akpkt", "avpdt", "avfdr", "avpakt", "avpsth", "AVPkt", "affft", "avPcht", "avnpkt", "avdacket", "avbpka", "affcht", "avwpacket", "avpfx", " avbpce", "avspcht", "AVPck", "avwpdat", "avwpkt", "avpeelt", "avpka", "avfcht", "avkelt", "akpruth", " avdacket", "avepwd", "avvnt", "avcpacket", "avepkt", "afpacket", "avvacket", "avkuth", "avpud", "afpft", "avpaka", "avfpkt", "AVpkt", "avkacket", "afffx", "akprud", "avebwd", "afpet", " avfpkt", "avdud", "avspkt", "avcpdat", "avpdr", "afpfx", "avpacket", "avfpacket", "avvpck", "avbkt", "avperacket", " avfpsth", "avfdat", "akprkt", "avspacket", "avfuth", " avfpcht", "avprud", "avkkt", "avnpce", "avbnt", "avpft", " avpelt", "avvcht", "affacket", "avfkt", "avcpud", "avprkt", "affuth", "avprwd", "avbpce", "avpck", "avppkt", "avdnt", "avpruth", "avcpdt", "avpekt", "affacker", "avbwd", "avfud", "avvpdr", "avppacket", "avwpdt", "affdat", "afpacker", "avpraga", "avpwd", " avfpacket", "avffx", "akprck", "avperfx", "avppacker", "avepeter", "avebkt", "avmet", "avmacket", " avdnt", "avspsth", "avfelt", "avcputh", "avbaga", "affdt", "avpeuth", "avpce", "avpracket", " avpnt", "avfacker", "avpet", "avPuth", "avpeacket", "avPsth", "AVpdr", "avcpkt", "affet", "affkt", "avnpka", "avfft", "avvkt", "avPck", "avperkt", " avdkt", " avpacket", "avfpsth", "afpcht", " avpka", "avpoleter", "avbpkt", "avpelt", "avpace", " avpsth", "AVPacket", "avfck", "avperet", "afpkt", " avpce", " avpud", "avPud", "avPacket", " avdud", "akpck", "affelt", "avfacket", "affnt", "AVPdr", "avvpacket", "akpud", "avprnt", "avpaga", "avnpelt", "avdkt", "AVpck", "avcpck", "avputh", "avpnt", "avcpacker", "avpolkt", "avvpkt", "avebaga", "avpaelt", "afpdat", "avfet", "avfnt", "avpeter", "avbeter"], "ctx": ["client", "sync", "cam", "qq", "cu", "cn", "exec", "cm", "tc", "cs", "act", "pkg", "bc", "sci", "nc", "cf", "pc", "cmd", "cb", "cas", "cfg", "kb", "sys", "qa", "anc", "Context", "cc", "cmp", "sq", "uc", "cdn", "hw", "lc", "config", "cca", "wx", "ck", "cus", "vc", "ci", "np", " context", "context", "c", "conv", "cp", "cli", "component", "coll", "co", "ctrl", "tx", " cx", "css", "crit", "acl", "ca", "kw", "utils", "wcs", "xc", "loc", "fw", "conn", "cms", "comp", "support", "cv"], "frame": ["part", "document", "iframe", "session", "shot", "flow", "board", "image", "result", "element", "object", "Frame", "slice", "seq", "parent", "view", "block", "node", "context", "window", "component", "instance", "row", "buffer", "value", "event", "code"], "keyframe": ["KEYblock", "linkframe", "KEYfram", "keyhole", " keyblock", "linkfram", "keyword", "KeyFrame", " keyflow", "KEYframe", "KEYword", "linksequence", " keyFrame", " keyword", " keyhole", " keyline", "keyline", "keyblock", "keyflow", "linkblock", "keysequence", "switchframe", "KEYflow", "Keyword", " keysequence", "keyFrame", "Keyframe", "matchline", "matchframe", " keyfram", "KEYsequence", "keyfram", "matchhole", "switchhole", "switchFrame", "Keyflow", "KEYFrame", "switchline", "matchFrame"], "ret": ["gt", "success", "hash", "reset", "resp", "obj", "val", "rf", "detail", "det", "reg", "rb", "bad", "rev", "sr", "flag", "back", "len", "alt", "debug", "en", "ct", "nt", "bf", "match", "format", "rt", "res", "db", "error", "num", "arg", "mt", "cat", "pass", "Ret", "done", "ft", "result", "feat", "att", "al", "fun", "rc", "usr", "rets", "replace", "art", "status", "active", "lit", "run", "rep", "re", "bit", "let", "ref", "code", "fail", "try", "def", "post", "reply", "url", "no", "info", "ext", "RET", "rl", "err"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814, "substitutes": {"reg": ["aug", "registered", "param", "feat", "REG", " REG", "rel", "ang", "eng", "eg", "res", " Reg", "tag", "mod", "sec", "proc", "num", "un", "region", "rec", "arg", "bad", "win", "mem", "addr", "Reg", "index", "req", "re", "name", "min", "pred", "port", "stat", "loc", "conn", "rol"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n", "idx": 14816, "substitutes": {"env": ["enc", "en", "ie", "environment", "ev", "anne", "ini", "priv", "v", "inet", "erv", "e", "obj", "ov", "eye", "conn", "server", "si", "ec", "state", "inst", "config", "ea", "eu", "eni", "iv", "iss", "init", "scope", "ni", "sr", "ind", "err", "ridge", "equ", "conf"], "rip": ["serv", "ru", "oper", "rw", "rid", "route", "rou", "rs", "trip", "jp", "op", "rh", "raf", "rt", "uri", "strip", "ro", "tri", "cap", "rap", "iri", "ra", "raped", "stri", "rin", "iv", "riv", "ip", "rx", "ick", "rio", "sr", "pin", "rn", "RI", "rub", "ris"], "value": ["prefix", "sv", "data", "v", "image", "result", "format", "end", "server", "VALUE", "uri", "val", "property", "write", "si", "resource", "vi", "object", "service", "VI", "valid", "response", "values", "reg", "key", "iv", "ip", "i", "vector", "set", "index", "name", "child", "port", "Value", "entry", "RI", "rule", "null"], "ri": ["di", "gi", "rid", "ini", "mi", "li", "ry", "xi", "rt", "pi", "abi", "uri", "ro", "si", "vi", "tri", "nic", "ai", "iri", "ra", "pri", "ti", "stri", "ani", "rin", "ci", "io", "iv", "rm", "ip", "i", "rx", "ki", "ni", "rio", "sr", "pin", "ori", "RI", "ris"]}}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822, "substitutes": {"s": ["ps", "storage", "sync", "serv", "d", "fs", "o", "session", "us", "rs", "south", "v", "e", "cs", "u", "ts", "server", "ds", "params", "sys", "ss", "ssl", "service", "m", "new", "conf", "sq", "gs", "sf", "a", "g", "es", "self", "ks", "os", "spec", "is", "c", "i", "su", "sg", "secure", "p", "ns", "tests", "args", "b", "aws", "instance", "f", "sb", "ses", "js", "settings", "r", "services", "sym", "S", "ls", "t", "less"], "vdev": ["vrhost", "vpub", "svdev", " vserial", "qdevice", "qdi", " vde", "svdevice", " vbus", "qdev", "svbus", "vdiv", "fdevice", " vdevice", " vdist", "fdev", "ftech", " vtech", "svdi", "svserial", "qdist", " vdi", "vserial", "vrdev", "tvdev", " vhost", "svde", "fpub", "vdist", "fde", "tvtech", "qserial", "vhost", "vrdist", "vrdevice", "vdi", "vbus", "qhost", "vde", "fdiv", "vdevice", " vdiv", " vpub", "svdiv", "tvdevice", "vtech", "tvpub"], "qbus": ["sqbuild", "pboot", "qubs", "qubuild", " qb", "Qproc", "qbuild", "Qcase", "quickbus", "qucase", "quickhub", "qda", "qub", "pbus", "sqbus", "qcase", " qboot", "quboot", "pbs", "qb", "pproc", "qboot", " qcase", "quickbuild", "Qb", "qbs", "sqhub", "Qbs", "Qbus", "quproc", "qubus", "sqda", "qhub", "quhub", "qproc", "Qboot", "quickda", "quda"], "k": [" K", "o", "ky", "ok", "kick", "kin", "wk", "work", "kb", "dk", "unk", "kid", "ke", "kernel", "g", "ck", "ks", "key", "ik", "tk", "spec", "K", "c", "q", "uk", "ki", "p", "ak", "kw", "ack", "ijk", "get", "ko", "ku", "mk", "sk", "kind"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 14823, "substitutes": {"d": ["done", "bd", "di", "dr", "dt", "nd", "dom", "data", "draw", "md", "e", "ld", "l", "dat", "ds", "db", "dc", "m", "dad", "grad", "fd", "pd", "dn", "dl", "g", "df", "z", "n", "xd", "id", "dh", "sd", "dev", "c", "dict", "p", "od", "dd", "b", "plugin", "f", "ind", "D", "gd", "t", "da", "ad"], "val": ["VAL", "ay", "all", "fi", "data", "split", "v", "bal", "ol", "eval", "count", "pt", "fl", "sel", "base", "alt", "slot", "aval", "el", "elt", "valid", "_", "al", "unit", "Val", "pre", "pr", "key", "pol", "ot", "dev", "x", "max", "put", "p", "index", "vol", "b", "cal", "sl", "vals", "il", "f", "ind", "py", "value", "loc", "len", "ee", "ann", "rot"]}}
{"project": "qemu", "commit_id": "1931076077254a2886daa7c830c7838ebd1f81ef", "target": 0, "func": "void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n", "idx": 14840, "substitutes": {}}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 14842, "substitutes": {"mountfd": ["devd", "procfd", "devor", "_fd", "devdb", "procdb", "devfd", "mountd", "procor", "_d", "_db", "_or", "mountor", "mountdb", "procd"], "fh": ["fH", "fdH", "fdhs", "fdhh", " fH", " fhs", "fhh", "fhs", " fhh", "sfhs", "sfH", "fdh", "sfh", "sfhh"], "flags": ["FLAG", "fs", "files", "options", "Flags", "data", "mode", "mask", "magic", "features", "types", "offset", "windows", "ptr", "bits", "stats", "args", "s", "vals", "name", "flag", "settings", "ents", "ants", "ags", "len", "ops"]}}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "static void cmd_get_event_status_notification(IDEState *s,\n\n                                              uint8_t *buf)\n\n{\n\n    const uint8_t *packet = buf;\n\n\n\n    struct {\n\n        uint8_t opcode;\n\n        uint8_t polled;        /* lsb bit is polled; others are reserved */\n\n        uint8_t reserved2[2];\n\n        uint8_t class;\n\n        uint8_t reserved3[2];\n\n        uint16_t len;\n\n        uint8_t control;\n\n    } __attribute__((packed)) *gesn_cdb;\n\n\n\n    struct {\n\n        uint16_t len;\n\n        uint8_t notification_class;\n\n        uint8_t supported_events;\n\n    } __attribute((packed)) *gesn_event_header;\n\n\n\n    enum notification_class_request_type {\n\n        NCR_RESERVED1 = 1 << 0,\n\n        NCR_OPERATIONAL_CHANGE = 1 << 1,\n\n        NCR_POWER_MANAGEMENT = 1 << 2,\n\n        NCR_EXTERNAL_REQUEST = 1 << 3,\n\n        NCR_MEDIA = 1 << 4,\n\n        NCR_MULTI_HOST = 1 << 5,\n\n        NCR_DEVICE_BUSY = 1 << 6,\n\n        NCR_RESERVED2 = 1 << 7,\n\n    };\n\n    enum event_notification_class_field {\n\n        ENC_NO_EVENTS = 0,\n\n        ENC_OPERATIONAL_CHANGE,\n\n        ENC_POWER_MANAGEMENT,\n\n        ENC_EXTERNAL_REQUEST,\n\n        ENC_MEDIA,\n\n        ENC_MULTIPLE_HOSTS,\n\n        ENC_DEVICE_BUSY,\n\n        ENC_RESERVED,\n\n    };\n\n    unsigned int max_len, used_len;\n\n\n\n    gesn_cdb = (void *)packet;\n\n    gesn_event_header = (void *)buf;\n\n\n\n    max_len = be16_to_cpu(gesn_cdb->len);\n\n\n\n    /* It is fine by the MMC spec to not support async mode operations */\n\n    if (!(gesn_cdb->polled & 0x01)) { /* asynchronous mode */\n\n        /* Only polling is supported, asynchronous mode is not. */\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n        return;\n\n    }\n\n\n\n    /* polling mode operation */\n\n\n\n    /*\n\n     * These are the supported events.\n\n     *\n\n     * We currently only support requests of the 'media' type.\n\n     */\n\n    gesn_event_header->supported_events = NCR_MEDIA;\n\n\n\n    /*\n\n     * We use |= below to set the class field; other bits in this byte\n\n     * are reserved now but this is useful to do if we have to use the\n\n     * reserved fields later.\n\n     */\n\n    gesn_event_header->notification_class = 0;\n\n\n\n    /*\n\n     * Responses to requests are to be based on request priority.  The\n\n     * notification_class_request_type enum above specifies the\n\n     * priority: upper elements are higher prio than lower ones.\n\n     */\n\n    if (gesn_cdb->class & NCR_MEDIA) {\n\n        gesn_event_header->notification_class |= ENC_MEDIA;\n\n        used_len = event_status_media(s, buf);\n\n    } else {\n\n        gesn_event_header->notification_class = 0x80; /* No event available */\n\n        used_len = sizeof(*gesn_event_header);\n\n    }\n\n    gesn_event_header->len = cpu_to_be16(used_len\n\n                                         - sizeof(*gesn_event_header));\n\n    ide_atapi_cmd_reply(s, used_len, max_len);\n\n}\n", "idx": 14846, "substitutes": {"s": ["fs", "sync", "d", "o", "session", "south", "private", "secondary", "e", "server", "ds", "states", "sys", "resource", "ss", "ssl", "se", "m", "service", "sed", "sf", "sec", "es", "spec", "stats", "is", "side", "c", "submit", "status", "b", "sl", "sets", "f", "sb", "ses", "stat", "r", "services", "sym", "S", "t"], "buf": ["fp", "batch", "append", "alloc", "tmp", "data", "uf", "v", "result", "bc", "fab", "cb", "fb", "cmd", "wb", "output", "pad", "callback", "queue", "map", "vec", "uc", "fd", "runner", "seq", "ptr", "bridge", "config", "rb", "buff", "context", "Buffer", "b", "bag", "f", "src", "mount", "msg", "port", "que", "buffer", "ref", "array", "pb", "cv"], "packet": ["packetter", "paramant", "passen", "parameter", "passet", " packetter", "compet", "bucketer", "packant", " packant", "packets", " packeter", "packsen", "packeter", "passets", "packacket", "passacket", "compets", "buckant", "packset", "bucketter", "bucket", "packsacket", "paramet", "packen", "parametter", "compen", "compacket", "packsets"], "reserved2": ["respired2", "resumed0", "reserved4", "reserved0", "reserve0", "reserve2", "resumed4", "preserved2", "reserve4", "resumed2", "presumed2", "presumed4", "preserved4", "preserved0", "respired0", "presumed0", "respired4"], "reserved3": ["reserve03", "reservation4", "reserved4", "resigned3", "reserve5", "reserve4", "reservation03", "preserved03", "preserve4", "reservation3", "preserved4", "resigned5", "resigned03", "reserve3", "reservation5", "preserve03", "preserve5", "preserved5", "preserve3", "reserved03", "preserved3", "resigned4", "reserved5"], "gesn_cdb": ["gesn_gonda", "gesn_econda", "gesn_ncdoc", "gesn_mcdb", "gesn_collde", "gesn_cbm", "gesn_cpy", "gesn_gpy", "gesn_csdata", "gesn_cde", "gesn_cds", "gesn_xcbal", "gesn_tds", "gesn_tdata", "gesn_gDb", "gesn_cmdb", "gesn_mcDb", "gesn_mcdoc", "gesn_foder", "gesn_cmdoc", "gesnLogcmDb", "gesn_conn", "gesn_cmpy", "gesn_gdoc", "gesn_cmDb", "gesnLogcmdoc", "gesn_ecde", "gesn_cobal", "gesn_fdata", "gesn_gdb", "gesnLogcmpy", "gesn_codoc", "gesnLogcmdb", "gesn_gbm", "gesn_collnn", "gesn_xcdoc", "gesn_recde", "gesn_cdata", "gesn_cdoc", "gesn_cmb", "gesn_ecmb", "gesn_mcpy", "gesn_cnn", "gesn_csdb", "gesn_ncbal", "gesn_cDb", "gesn_xcnn", "gesn_codb", "gesn_xcdb", "gesn_cbal", "gesn_tdb", "gesn_ecnn", "gesn_csonda", "gesn_ecbm", "gesn_collmb", "gesn_coder", "gesn_csde", "gesn_toder", "gesn_recdb", "gesnLogcpy", "gesn_fdb", "gesn_ncdb", "gesn_ecdb", "gesn_fds", "gesn_ncnn", "gesn_recmb", "gesnLogcdb", "gesnLogcdoc", "gesnLogcDb", "gesn_csoder", "gesn_colldb", "gesn_recnn", "gesn_csds", "gesn_csbm", "gesn_gde", "gesn_conda"], "max_len": ["maxxLen", " max_pos", " max2fen", "max2len", "max\u00b7en", "max2en", "max_fen", " max_length", " max_fen", "max_en", "max_pos", "maxxlength", "maxxlen", " max2len", "max_bin", "max_Len", "max2fen", "maxxbin", "max\u00b7len", "max\u00b7fen", " max2en", " max_Len", "max_length", " max_en", "max\u00b7pos", "max2pos", " max_bin", " max2pos"], "used_len": ["next_lim", "used2val", "used7val", "used67val", "used2lim", "used2len", "used7cache", "next_len", "used7len", "next_val", "next67val", "used67len", "used2cache", "next67lim", "used67lim", "used_cache", "next67len", "used_val", "used67cache", "next_cache", "next67cache", "used7lim", "used_lim"]}}
{"project": "FFmpeg", "commit_id": "850c6db97d1f78e7607952ab8b854a93a185319e", "target": 0, "func": "static int decode_plane(UtvideoContext *c, int plane_no,\n\n                        uint8_t *dst, int step, ptrdiff_t stride,\n\n                        int width, int height,\n\n                        const uint8_t *src, int use_pred)\n\n{\n\n    int i, j, slice, pix;\n\n    int sstart, send;\n\n    VLC vlc;\n\n    GetBitContext gb;\n\n    int prev, fsym;\n\n    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P)) : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n\n\n    if (build_huff(src, &vlc, &fsym)) {\n\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n\n        send = 0;\n\n        for (slice = 0; slice < c->slices; slice++) {\n\n            uint8_t *dest;\n\n\n\n            sstart = send;\n\n            send   = (height * (slice + 1) / c->slices) & cmask;\n\n            dest   = dst + sstart * stride;\n\n\n\n            prev = 0x80;\n\n            for (j = sstart; j < send; j++) {\n\n                for (i = 0; i < width * step; i += step) {\n\n                    pix = fsym;\n\n                    if (use_pred) {\n\n                        prev += pix;\n\n                        pix   = prev;\n\n                    }\n\n                    dest[i] = pix;\n\n                }\n\n                dest += stride;\n\n            }\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    src      += 256;\n\n\n\n    send = 0;\n\n    for (slice = 0; slice < c->slices; slice++) {\n\n        uint8_t *dest;\n\n        int slice_data_start, slice_data_end, slice_size;\n\n\n\n        sstart = send;\n\n        send   = (height * (slice + 1) / c->slices) & cmask;\n\n        dest   = dst + sstart * stride;\n\n\n\n        // slice offset and size validation was done earlier\n\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n\n        slice_data_end   = AV_RL32(src + slice * 4);\n\n        slice_size       = slice_data_end - slice_data_start;\n\n\n\n        if (!slice_size) {\n\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n\n                   \"yet a slice has a length of zero.\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n\n                          (uint32_t *)(src + slice_data_start + c->slices * 4),\n\n                          (slice_data_end - slice_data_start + 3) >> 2);\n\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n\n\n        prev = 0x80;\n\n        for (j = sstart; j < send; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);\n\n                if (pix < 0) {\n\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n\n                    goto fail;\n\n                }\n\n                if (use_pred) {\n\n                    prev += pix;\n\n                    pix   = prev;\n\n                }\n\n                dest[i] = pix;\n\n            }\n\n            if (get_bits_left(&gb) < 0) {\n\n                av_log(c->avctx, AV_LOG_ERROR,\n\n                        \"Slice decoding ran out of bits\\n\");\n\n                goto fail;\n\n            }\n\n            dest += stride;\n\n        }\n\n        if (get_bits_left(&gb) > 32)\n\n            av_log(c->avctx, AV_LOG_WARNING,\n\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n\n    }\n\n\n\n    ff_free_vlc(&vlc);\n\n\n\n    return 0;\n\nfail:\n\n    ff_free_vlc(&vlc);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 14848, "substitutes": {"c": ["client", "d", "ct", "cn", "cu", "com", "v", "cm", "tc", "sc", "cs", "e", "con", "C", "u", "bc", "cd", "pc", "l", "nc", "cf", "cb", "ec", "conf", "dc", "cc", "cmp", "m", "uc", "rc", "lc", "config", "g", "k", "self", "ac", "n", "vc", "ch", "ce", "ctx", "cur", "ci", "cache", "center", "h", "cp", "s", "p", "cl", "cat", "b", "cy", "coll", "co", "ctrl", "f", "cr", "ca", "mc", "xc", "t", "cv"], "plane_no": ["plane_spec", "sourceqNO", "card__no", "plane_NO", "plane_na", " plane_none", "plane_pos", "plane_wa", "source_NO", "card__wa", "plane_none", "plane__wa", "planeqnumber", "card_na", " plane_number", "sourceqno", "source_spec", "source_no", "card_info", "source_pos", "sourceqpos", "plane__no", "plane_number", "planeqnone", "planeqno", "card__na", "planeqNO", "card__info", "sourceqspec", "planeqpos", "planeqspec", "plane__info", "plane__na", "card_no", "plane_info", "card_wa"], "dst": ["dsts", "adnd", "datst", "adost", "datsts", "ssc", "datsc", "Dsc", "Dst", "Dost", "dedsc", "Dsts", "dedsts", "dsl", "snd", "sost", " dost", "Dsl", "dedost", "datsl", "dost", "adst", " dnd", " dsl", "sst", "dedst", "dsc", " dsc", "dnd", " dsts", "adsc"], "step": ["d", "batch", "hop", "shift", "flow", "seed", "draw", "patch", "loop", "st", "speed", "cycle", "length", "size", "STEP", "ste", "depth", "pad", "shape", "transform", "strike", "grade", "grad", "mix", "Step", "ride", "sec", "dim", "unit", "scale", "z", "skip", "version", "stop", "change", "weight", "stage", "max", "set", "wait", "sl", "start", "min", "sample", "move", "pass", "steps"], "stride": ["tride", "iterided", "trip", "divipe", "spriden", "colline", "striden", " stripe", "Strade", "tridi", "Stride", "strip", "strade", "iteride", "lenider", "strine", "collip", " strider", "trade", "strime", "divider", "lenide", "trime", "strided", "collide", "Strime", "divance", "lenipe", "Strided", " strance", "sprider", "trided", "sprance", "divide", "Stridi", "lenance", "Strine", "Strance", "collade", "Strider", "stridi", "Striden", "trine", "Strip", "strider", "iterime", "strance", "iteridi", " striden", "stripe", "spride"], "height": ["gap", "hop", "shift", "flow", "seed", "deep", "count", "volume", "dist", "three", "rh", "direction", "head", "length", "duration", "size", "style", "timeout", "Height", "depth", "shape", "y", "gh", "hold", "resolution", "tight", "density", "id", "power", "feed", "input", "h", "bottom", "history", "window", "crop", "layout", "inc", "scroll", "thin", "row", "th", "square", "grow", "build", "rank", "alpha", "hang"], "src": ["sync", "img", "sid", "shift", "sit", "seed", "split", "source", "sc", "st", "dist", "image", "rest", "sci", "cb", "sel", "desc", "shape", "transform", "pack", "ssl", "uc", "inst", "sq", "sec", "sn", "url", "rc", "config", "rb", "sup", "scene", "rec", "spec", "ctx", "fc", "input", "conv", "code", "secure", "crop", "target", "req", "sl", "sr", "sb", "start", "stream", "loc", "filename", "stack", "cv"], "use_pred": ["use__reg", "use_prev", " use_Pred", "USE_Pred", "USE__Pred", "USE_pred", "USE__pred", "use__pred", "use_cod", "use_reg", "use__prev", "USE_cod", " use_reg", "use_Pred", "USE__cod", "use__Pred", "use__cod", " use_prev"], "i": ["it", "d", "ie", "di", "o", "gi", "ini", "mi", "fi", "v", "im", "li", "e", "xi", "u", "inner", "end", "l", "pi", "uri", "si", "y", "ai", "m", "ui", "ti", "ix", "z", "ani", "n", "eni", "ci", "io", "bi", "qi", "ip", "x", "ice", "ami", "ji", "info", "p", "index", "ij", "b", "ni", "start", "f", "zi", "r", "ii", "ori", "I"], "j": ["it", "adj", "d", "ne", "o", "di", "ie", "J", "shift", "jp", "v", "im", "li", "jl", "e", "pos", "u", "obj", "fl", "end", "l", "y", "m", "sp", "jo", "num", "g", "z", "k", "jet", "n", "ij", "ice", "x", "ji", "p", "index", "syn", "b", "ni", "start", "f", "jump", "ind", "w", "r", "je", "ii", "jit", "jc"], "slice": ["module", "hop", "pe", "v", "sc", "si", "tile", "se", "scale", "channel", "region", "spec", "sh", "slave", "diff", "ii", "pick", "sequence", "part", "ie", "batch", "shift", "edge", "seed", "split", "li", "image", "match", "minute", "sort", "sq", "trial", "scroll", "hole", "series", "live", "plane", "route", "blade", "script", "sel", "size", "shape", "service", "pocket", "zip", "fit", "episode", "dim", "unit", "ice", "sl", "zi", "pie", "call", "sample", "cell", "multiple", "single", "pod", "source", "volume", "sci", "uri", "slot", "pad", "pose", "pixel", "grade", "sp", "vision", "player", "config", "sub", "second", "knife", "layer", "p", "crop", "index", "range", "ski", "section", "loc", "video"], "pix": ["pipe", " pixel", "pike", "vpius", " pixels", "dpix", "ipixels", "spicks", "apixel", " pike", "ipx", " px", "dpike", "vpixel", "spixel", "pius", "PIX", "Pipe", " pIX", "ipixel", "dpx", "pixel", "vpip", "pip", "apicks", " pipe", "picks", "ipike", "pIX", "px", "dpipe", "ipIX", "apix", "apius", "Pix", "spix", " pip", " picks", "spip", "ipix", "spius", "Pike", "Pixel", "ipipe", "Pixels", " pius", "pixels", "vpix"], "sstart": ["lsstop", " spart", "lsend", "imscall", "lsstart", " sstop", "sstop", "setsstop", "statesstop", "sesstop", "ssstart", "sinfo", "esinfo", "sstep", "setsskip", "esfrom", "slike", " sfind", "statespart", "sesskip", "lsmin", "scall", "ssstop", "nsstep", "dsmax", "sesstart", "sfind", "Send", "csinfo", "imsstart", "statesfind", "asstop", "Sstop", "gslike", "setscall", "smax", "asstart", "setsstart", "gsstart", "imsskip", "Sstart", "dsstart", "esmax", "aspart", "entslike", "sfrom", "csstart", " slike", "nsfind", "dsinfo", "smin", "gsstarting", "esstart", "gsstep", "entsstop", " sstarting", "statesstart", "Smin", "nsstop", "imsstop", "sskip", "gsstop", "asfind", "ssmin", "dsfrom", "spart", "ssend", "sescall", "gsfind", "csfrom", "sstarting", "entsstarting", "nsstart", "entsstart", "csmax"], "send": ["update", "sync", "enc", "en", "append", "check", "shift", "nd", "seed", "draw", "Send", "source", "sc", "force", "dist", "speed", "end", "use", "desc", "size", "give", "write", "nil", "see", "sent", "eng", "destroy", "service", "sort", "se", "transform", "mit", "sec", "parse", "export", "find", "scale", "last", "sup", "add", "init", "read", "feed", "push", "set", "status", "pend", "missing", "start", "ind", "msg", "get", "call", "err", "transfer", "share", "carry", "text", "pack"], "vlc": ["vlu", "llcli", "lvac", "lvct", "lvc", "llci", "vcc", "vlcs", "vrcli", "wlcs", "llu", "llct", "vcci", "llcs", "vrac", "vccs", "vcu", "vlct", "wlc", "vlci", "vlcli", "vrct", "wlu", "vrc", "wlci", "llc", "lvcli", "llac", "vlac"], "gb": ["VC", " config", " comp", " cmd", " conv", " cf", " enc", " scr", " gcc", "bc", " parent", " conf", " bc", " ac", " gl", "rc", " cu", " acc", " co", "vc", "ci", " cal", " ic", "CC", " alloc", " lib", " img", " cis", " cd"], "prev": ["enc", "orig", "gap", "nav", "append", "original", "img", "trip", "shift", "seed", "jp", "v", "op", "rest", "fix", "rel", "above", "val", "post", "wp", "cmp", "root", "loc", "vec", "inst", "seq", "best", "pre", "vert", "parent", "last", "sup", "par", "rec", "skip", "block", "ch", "iv", "rev", "pop", "init", "cache", "ip", "vious", "pres", "history", "pend", "req", "reverse", "p", "gen", "jump", "pred", "sav", "before", "back", "Prev", "pass", "old", "ref", "next", "comp", "var", "code"], "fsym": ["fsid", "hsid", "fsm", " fsid", "hsm", " fnm", "tfsm", " fym", "tSym", "hsym", " fsm", "tfsym", "hscope", "tsym", "fSym", "tfym", "psm", "hcm", "hsy", "tcm", "fsy", "psid", " fscope", " fsy", "fnm", "fym", "bsid", "bsym", "tsy", "pnm", " fSym", " fcm", "psym", "fscope", "bsm", "pSym", "tnm", "pym", "fcm", "bsy", "tsid", "tscope", "tfSym"], "dest": ["orig", "delete", "append", "ord", "draw", "sc", "output", "true", "later", "parent", "sup", "scan", "ident", "Dest", "trans", "sum", "stack", "move", "sync", "shift", "cont", "seed", "global", "path", "destroy", "transform", "sort", "die", "keep", "flat", "push", "reverse", "miss", "outer", "option", "pass", "done", "route", "trip", "data", "feat", "rest", "end", "write", "dim", "usr", "opt", "stage", "text", "decl", "source", "dist", "comb", "desc", "dc", "uc", "ignore", "config", "coord", "target", "prop", "transfer", "loc", "img"], "slice_data_start": ["slice_data_pad", "slice_data_part", "slice_data_min", "slice_data_id"], "slice_data_end": ["ctr", "img", "slice_data_ending", "pos", "slice_data___start", "_", "slice_data__end", "slice_data___end", "slice_data___set", "slice_data__start", "slice_data___offset", "slice_data_offset", "slice_data_set", "slice_data__ending", "slice_data__ends", "slice_data_ends", "r"], "slice_size": ["image_count", "slice_num", "slice_offset", "ice_index", "slice2count", "ice_size", "slice2size", "image_len", "slice2len", "slice_count", "slice_index", "ice_offset", "image_size", "ice_num", "slice_len"]}}
{"project": "FFmpeg", "commit_id": "81a8701eb52d2b6469ae16ef442ce425388141b7", "target": 0, "func": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,\n\n                           uint8_t *data, unsigned size, int64_t granule,\n\n                           int header)\n\n{\n\n    OGGStreamContext *oggstream = st->priv_data;\n\n    OGGContext *ogg = s->priv_data;\n\n    int total_segments = size / 255 + 1;\n\n    uint8_t *p = data;\n\n    int i, segments, len, flush = 0;\n\n\n\n    // Handles VFR by flushing page because this frame needs to have a timestamp\n\n    // For theora, keyframes also need to have a timestamp to correctly mark\n\n    // them as such, otherwise seeking will not work correctly at the very\n\n    // least with old libogg versions.\n\n    // Do not try to flush header packets though, that will create broken files.\n\n    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&\n\n        (ogg_granule_to_timestamp(oggstream, granule) >\n\n         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||\n\n         ogg_key_granule(oggstream, granule))) {\n\n        if (oggstream->page.granule != -1)\n\n            ogg_buffer_page(s, oggstream);\n\n        flush = 1;\n\n    }\n\n\n\n    // avoid a continued page\n\n    if (!header && oggstream->page.size > 0 &&\n\n        MAX_PAGE_SIZE - oggstream->page.size < size) {\n\n        ogg_buffer_page(s, oggstream);\n\n    }\n\n\n\n    for (i = 0; i < total_segments; ) {\n\n        OGGPage *page = &oggstream->page;\n\n\n\n        segments = FFMIN(total_segments - i, 255 - page->segments_count);\n\n\n\n        if (i && !page->segments_count)\n\n            page->flags |= 1; // continued packet\n\n\n\n        memset(page->segments+page->segments_count, 255, segments - 1);\n\n        page->segments_count += segments - 1;\n\n\n\n        len = FFMIN(size, segments*255);\n\n        page->segments[page->segments_count++] = len - (segments-1)*255;\n\n        memcpy(page->data+page->size, p, len);\n\n        p += len;\n\n        size -= len;\n\n        i += segments;\n\n        page->size += len;\n\n\n\n        if (i == total_segments)\n\n            page->granule = granule;\n\n\n\n        if (!header) {\n\n            AVStream *st = s->streams[page->stream_index];\n\n\n\n            int64_t start = av_rescale_q(page->start_granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n            int64_t next  = av_rescale_q(page->granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n\n\n            if (page->segments_count == 255 ||\n\n                (ogg->pref_size     > 0 && page->size   >= ogg->pref_size) ||\n\n                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {\n\n                ogg_buffer_page(s, oggstream);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (flush && oggstream->page.granule != -1)\n\n        ogg_buffer_page(s, oggstream);\n\n\n\n    return 0;\n\n}\n", "idx": 14865, "substitutes": {"s": ["ps", "storage", "fs", "sync", "d", "us", "sv", "o", "session", "serv", "rs", "soc", "com", "site", "v", "sc", "cs", "e", "sm", "sa", "ts", "events", "server", "ds", "sys", "si", "ss", "rows", "ssl", "se", "service", "an", "m", "sed", "sq", "sp", "sf", "plugins", "sam", "g", "uploads", "es", "self", "os", "spec", "stats", "is", "c", "http", "su", "sg", "ns", "b", "sl", "f", "src", "sb", "ses", "js", "settings", "stat", "ls", "services", "r", "S", "t", "ops"], "st": ["client", "ct", "d", "ST", "sv", "bl", "pe", "sc", "sa", "sm", "e", "fe", "ts", "St", "rest", "ld", "pt", "ds", "ste", "ss", "se", "sp", "sed", "inst", "sf", "sn", "sta", "sam", "sec", "config", "str", "sts", "tt", "fr", "est", "osc", "rss", "sd", "stop", "sh", "c", "stage", "ast", "sw", "sl", "ist", "src", "sb", "cr", "start", "stream", "td", "ost", "sth", "std", "t", "stack"], "data": ["done", "body", "d", "batch", "address", "shift", "content", "draw", "empty", "results", "after", "media", "image", "download", "length", "dat", "area", "write", "timeout", "delay", "padding", "offset", "api", "response", "a", "config", "da", "parent", "scale", "last", "next", "block", "capacity", "cache", "init", "extra", "input", "memory", "info", "window", "missing", "Data", "start", "name", "load", "DATA", "buffer", "sample", "buf", "value", "alpha", "video", "number"], "size": ["large", "screen", "address", "send", "si", "ui", "group", "limit", "sec", "scale", "channel", "n", "sh", "bytes", "start", "value", "sum", "en", "e", "timeout", "offset", "slice", "time", "last", "cache", "c", "max", "memory", "x", "buffer", "event", "storage", "engine", "Size", "empty", "count", "speed", "message", "write", "shape", "unit", "six", "type", "member", "name", "sea", "stream", "code", "body", "zero", "fee", "connection", "content", "mode", "length", "style", "small", "g", "z", "sized", "capacity", "mini", "feed", "second", " sizes", "weight", "w", "SIZE", "loc", "video", "ize", "number"], "granule": ["gnulus", "generules", "ranule", " granue", "generul", " granulation", "ranulus", "generume", "gnularity", "gnume", "ranul", "granulation", "ranularity", " granularity", "ranules", "generulation", "gorulus", "granules", "gorules", " granules", "gorul", "gnue", "gnule", "gorularity", " granume", "granue", "granulus", "generularity", "gorule", "gnules", "gorue", "granularity", "granume", "gnulation", " granul", " granulus", "gorulation", "generule", "gnul", "granul"], "header": ["body", "debug", "client", "document", "required", "height", "dr", "numbered", "headers", "director", "title", "reader", "author", "loop", "source", "plain", "download", "head", "server", "commit", "timeout", "writer", "border", "ssl", "summary", "padding", "leader", "offset", "Header", "comment", "player", "error", "kernel", "parent", "channel", "middle", "over", "version", "date", "h", "hard", "layer", "table", "name", "aster", "master", "buffer", "back", "final", "request", "tail", "event", "forward", "number", "cover"], "oggstream": ["oodstream", "grossStream", "oground", "aggpath", "ogfeed", "ogghost", "otthost", "ogamodel", "ogcoll", "aggengine", "ogchild", "bbserver", "aggstream", "ogaconsole", "ogainput", "oodstring", "aggrow", "oghost", "ggform", "ogconsole", "agground", "obbstream", "oggmessage", "oggchannel", "oodround", "ogacoll", "grossstream", "ogchannel", "gghost", "ogmessage", "oggenc", "ogpath", "obbserver", "ottstream", "ogserver", "bbenc", "ggserver", "ogStream", "ggstream", "ggStream", "ogastream", "aggsystem", "aggstring", "ogenc", "ogstring", "grossserver", "ogsystem", "aggserver", "oggpath", "ogapath", "ggfeed", "aggcoll", "oodengine", "ogaform", "ogmodel", "aggchild", "bbstream", "oggsystem", "ogasystem", "oggchild", "ogaserver", "ogachild", "oginput", "bbform", "ogginput", "aggconsole", "ogengine", "ogarow", "aggenc", "oggfeed", "oggmodel", "ogground", "oggrow", "ogstream", "aggchannel", "agginput", "oggcoll", "oggserver", "ogrow", "grossloop", "ottform", "ggloop", "ogamessage", "oggconsole", "aggmessage", "oggstring", "ogloop", "obbsystem", "oggStream", "obbengine", "aggform", "oggform", "ottfeed", "oggengine", "aggmodel", "oggloop", "ogachannel", "ogaengine", "ogform"], "ogg": ["gow", "aud", "mm", "ott", "oc", "acc", "ogo", "og", "pp", "ob", "gc", "eg", "ow", "ga", "pg", "cc", "mpeg", "audio", "ogs", "ogle", "org", "omm", "gram", "bb", "od", "oga", "gg", "ocr", "gd"], "p": ["fp", "ps", "d", "o", "pe", "tp", "jp", "v", "po", "per", "e", "pt", "pc", "l", "pi", "P", "pp", "pad", "wp", "m", "sp", "padding", "api", "pool", "a", "pre", "g", "up", "z", "lp", "n", "np", "ip", "bp", "c", "h", "cp", "pointer", "q", "b", "f", "dp", "port", "j", "r", "t"], "i": ["it", "ie", "di", "o", "gi", "ini", "iu", "mi", "fi", "multi", "li", "count", "e", "pos", "xi", "u", "image", "l", "pi", "uri", "si", "vi", "y", "ai", "ui", "slice", "ti", "inf", "ix", "z", "n", "eni", "ci", "io", "mini", "id", "qi", "phi", "ip", "x", "c", "ji", "ki", "index", "cli", "none", "ri", "esi", "ni", "start", "f", "zi", "ind", "ski", "j", "ii", "I"], "segments": ["SEgments", "pegements", "seges", "selements", "seegs", "sements", "tegments", "sugs", "seegements", "seegments", "perseles", "susections", "seasons", "segement", "SEments", "gegments", " Segment", "pesections", "persegment", " segement", "pseabytes", " seges", "gements", "sugments", "megements", "teasons", " sements", "geabytes", "gegements", "parsesections", "schegements", "pegs", "scalegs", "scalegment", "seabytes", "secgments", "pements", "parsegements", "gegment", "gectors", "schegments", "scalegments", "schegment", "pegments", "segment", "sectors", "parsegments", "mectors", "SEgements", "secges", "tegements", "segs", "psegements", "sesections", "seeabytes", "megment", "gegs", "SEgment", " Segements", "megments", "pelements", "secgements", "seles", "peasons", " segment", " segements", "scalegements", " sectors", " segs", "geles", "persegments", " Segments", "pseasons", "persegements", "secgement", " Sements", "teges", "psegs", "telements", "segements", "schements", "tegement", "pegment", "sugements", "pselements", "parsegs", "psegments", "peles"], "len": ["en", "le", "fin", "led", "bl", "all", "split", "la", "li", "ll", "Len", "count", "fl", "pos", "fn", "l", "length", "lt", "den", "val", "lon", "loc", "sp", "el", "limit", "offset", "elt", "lin", "seq", "url", "lc", "lim", "dl", "pre", "num", "lp", "n", "low", "rev", "ln", "mem", "ler", "syn", "lib", "lit", "sl", "f", "min", "lf", "zi", "err", "lang", "dy", "ls", "loss", "conn", "span"], "page": ["large", "enc", "module", "display", "session", "menu", "pe", "site", "v", "per", "ge", "Page", " Page", "account", "group", "article", "meta", "response", "ae", "parent", "channel", "n", "stall", "asc", "phrase", "stop", "date", "instance", "pl", "entry", "web", "theme", "position", "edge", "record", "e", "image", "match", "pc", "wiki", "element", "gc", "eng", "queue", "view", "word", "age", "item", "cache", "node", "c", "line", "load", "option", "rule", "update", "gap", "route", "user", "result", "message", "end", "sel", "area", "average", "pp", "write", "wp", "pg", "object", "root", "chapter", "html", "comment", "pre", "me", "pages", "stage", "pointer", "ph", "www", "order", "sl", "stream", "document", "content", "search", "desc", "pm", "server", "post", "blog", "full", "sp", "frame", "url", "config", "g", "skip", "button", "change", "index", "inc", "f", "row", "child", "request", "section", "aa", "plugin", "video", "next"]}}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n\n        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if(!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n\n\n    assert(s->time>=0);\n\n    time_div= s->time/s->avctx->time_base.den;\n\n    time_mod= s->time%s->avctx->time_base.den;\n\n    time_incr= time_div - s->last_time_base;\n\n    assert(time_incr >= 0);\n\n    while(time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n\n    if (    s->pict_type == AV_PICTURE_TYPE_P\n\n        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n\n    }\n\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n\n    if(!s->progressive_sequence){\n\n         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);\n\n         put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    //FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code); /* fcode_for */\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code); /* fcode_back */\n\n}\n", "idx": 14872, "substitutes": {"s": ["hs", "session", "site", "u", "ts", "its", "states", "sys", "si", "se", "m", "plugins", "xs", "self", "n", "spec", "i", "h", "set", "qs", "scope", "sb", "as", "js", "services", "t", "native", "ps", "sync", "fs", "o", "your", "cs", "e", "parts", "ions", "ss", "y", "ssl", "new", "sq", "gs", "sf", "a", "sports", "details", "is", "c", "sg", "ns", "share", "bis", "storage", "us", "l", "ds", "service", "obs", "comm", "http", "status", "ses", "ms", "sym", "S", "ops", "comments", "d", "rs", "results", "source", "server", "full", "uns", "g", "es", "ks", "os", "admin", "ches", "side", "args", "su", "p", "b", "sets", "f", "w", "request", "er", "ls", "r", "conf"], "picture_number": ["pictureIddata", " picture_index", "image_data", "pictureitylength", "pictureityindex", "picture_index", "pictureIdnum", "pictureIdnumbered", "picture_num", " picture_length", "picture_length", "picture_numbered", " picture_num", "image_num", "picture_data", "pictureitynumber", "image_numbered", "pictureIdnumber", "pictureitynum", "image_number"], "time_incr": ["time_integrx", "time_winrar", "time_Inccr", "time_winr", "time_decr", "time_dectr", "time_integcr", "time_increrar", "time_incrr", "time_decru", "time_deccr", "time_incru", "time_corcr", "time_increcr", "time_increrr", "time_incrar", "time_integtr", "time_integr", "time_integrb", "time_increerc", "time_winrc", "time_inccr", "time_corru", "time_decerc", "time_decrc", "time_decrb", "time_Incr", "time_increrc", "time_cortr", "time_inctr", "time_integru", "time_decrar", "time_integerc", "time_integrr", "time_wincr", "time_increr", "time_Incrb", "time_decrr", "time_corr", "time_incrb", "time_integrc", "time_decrx", "time_incrc", "time_incerc", "time_incrx", "time_Incrx"], "time_div": ["weight00div", "time_dev", "timeCdev", "weight_def", "weight_val", "weight00def", "time00div", " time_dev", "time\u00b7base", " time_base", "time00def", "weight00mod", "time_def", "time_base", "time\u00b7dev", " time_division", "time_val", "weight00val", "time\u00b7div", "weight_mod", "time\u00b7mod", "time_division", "timeCdivision", "weight_div", "timeCinit", "time00val", " time_init", "timeCdiv", "time00mod", "time_init"], "time_mod": ["timeallmod", "time54mod", "timeallmult", " time_mult", " time_inc", "time___mod", " time_dig", "time___div", " time_sign", "timealldiv", "time54dig", " time_dim", "timeallsign", "time54dim", "timeallinc", "time_dig", "time_inc", "time___mult", "timeallmodule", " time_module", "time_dim", "time___sign", "time_mult", "time_module", "time54div", "time_sign"]}}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, \n\n                      int nb_codes)\n\n{\n\n    uint8_t huff_size[256];\n\n    uint16_t huff_code[256];\n\n\n\n    memset(huff_size, 0, sizeof(huff_size));\n\n    build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    \n\n    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);\n\n}\n", "idx": 14884, "substitutes": {"vlc": ["svcs", "lvv", "svf", "lvc", "llci", "vlcs", "llv", "svc", "lvcs", "lvci", "vlv", "llf", "vrci", "llcs", "vrf", "svv", "vlci", "svci", "vlf", "lll", "vrc", "llc", "vll", "vrl", "svl"], "bits_table": ["bits_test", "bits_entry", "bits_tab", "bitssbuffer", "bits_cache", "bitsstab", " bits_cache", " bits_test", " bits_entry", "bitsstable", "bitssentry", " bits_buffer", " bits_tab", "bits_buffer"], "val_table": ["eval_array", "valetcode", "valettab", "valuestable", "valuesrange", "val_tab", "valmatsys", "value_table", "value_tab", "valettable", "valmatcode", "valuestab", "eval_table", "value_code", "valmatarray", "valmattable", "val_range", "valstab", "valstable", "val_code", "eval_code", "val_array", "valuescode", "val_sys", "valsrange", "value_range", "valscode", "eval_sys", "valetrange"], "nb_codes": ["nb2cod", "num_states", "num_cells", "nb_code", "num_cod", "nb2states", "nb_cod", "num_codes", "num_code", "nb2cells", "nb_cells", "nb2codes", "nb_states"], "huff_size": ["huff64loc", "huffploc", "huff_length", "huffy_size", "huff_name", "huffkcode", "huffsweight", "huffplength", "huff_data", "huf_data", "huf_code", "huffksize", "huffacshape", "huff_count", "huffpcode", "huffssize", "huffy_weight", "huffacname", "huff64length", "huff64size", "huffsaddress", "huffy_code", "huffpsize", "huff_weight", "huff_loc", "huf_length", "huf_loc", "huff_shape", "huf_size", "huff64code", "huffy_address", "huffy_count", "huffaccode", "huffkname", "huff_address", "huffy_name", "huffacsize", "huffy_shape", "huffkshape"], "huff_code": ["huffdnumber", "huffacnumber", "huffy_codes", "huf_size", "huff_desc", "huff_cache", "huffdcode", "huffpcod", "huff_codes", "huffy_count", "huffy_number", "huffy_code", "huffaccode", "huffpsize", "huffddesc", "huff_number", "huffy_cod", "huffy_desc", "huffpcodes", "huf_code", "huffpcache", "huffaccount", "huff_cod", "huffy_size", "huf_codes", "huff_count", "huf_cache", "huffacdesc", "huffpcode", "huffdcount"]}}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n", "idx": 14904, "substitutes": {"n": ["en", "d", "ne", "o", "nn", "cn", "count", "e", "nc", "u", "fn", "l", "an", "m", "sn", "a", "num", "nat", "k", "z", "nb", "ln", "init", "N", "c", "i", "x", "ns", "p", "s", "b", "f", "min", "j", "nl", "t", "len", "number", "nan"], "pool_size": ["queue_limit", "queue_capacity", "poolFsized", "queue_max", "queue_address", "pool_max", "pool__sized", "pool_capacity", "poolFlimit", "queue_size", "queue_sized", "pool_address", "pool_sized", "pool__capacity", "poolFcapacity", "poolFsize", "pool__size", "pool_limit", "pool__limit"], "co": ["Co", "CO", "o", "pe", "cu", "aco", "la", "po", "con", "bc", "nc", "fe", "oo", "pc", "cf", "ro", "cc", "mo", "ra", "rc", "lc", "wo", "ck", "go", "coe", "ci", "ce", "ico", "c", "cl", "coll", "fo", "ca", "mc", "bo", "ko", "loc", "lo"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n", "idx": 14911, "substitutes": {"s": ["ps", "storage", "fs", "sync", "sv", "o", "rs", "south", "secondary", "e", "ts", "server", "ds", "states", "sys", "si", "ss", "service", "ssl", "m", "new", "sq", "gs", "sf", "g", "es", "os", "spec", "stats", "side", "c", "http", "su", "args", "sg", "ns", "p", "b", "f", "sb", "ses", "js", "ls", "services", "sym", "S", "t", "ops"], "r": ["d", "ru", "o", "dr", "rs", "ar", "R", "rar", "v", "reader", "resp", "br", "e", "rd", "result", "u", "rh", "l", "kr", "res", "rf", "m", "lr", "nr", "rr", "response", "rc", "g", "rb", "n", "fr", "hr", "c", "q", "i", "h", "p", "b", "mr", "sr", "f", "re", "cr", "rl", "er", "err", "entry", "rg", "j", "gr"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)\n\n{\n\n#if HAVE_YASM\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {\n\n#if ARCH_X86_32\n\n        if (mm_flags & AV_CPU_FLAG_MMX) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;\n\n        }\n\n#endif\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE2) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 14913, "substitutes": {"c": ["ct", "oc", "v", "cm", "sc", "cs", "e", "con", "C", "u", "cf", "l", "gc", "cc", "dc", "m", "uc", "lc", "rc", "g", "ac", "vc", "ch", "ce", "ctx", "center", "acs", "cache", "h", "cp", "s", "p", "cl", "b", "coll", "co", "ctrl", "f", "cr", "ca", "mc", "xc", "t", "cv"], "codec": ["codenc", "odac", "Codac", "pedec", " codac", "pedac", "pedEC", " codenc", " codEC", "pedenc", "odec", "codEC", "CodEC", "odenc", "Codec", "odEC", "codac", "Codenc"]}}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    uint32_t physical;\n\n    int prot;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n//    printf(\"%s 0\\n\", __func__);\n\n    access_type = env->access_type;\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        ret = -2;\n\n        goto do_fault;\n\n    }\n\n    /* NASTY BUG workaround */\n\n    if (access_type == ACCESS_CODE && rw) {\n\n\tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", __func__);\n\n\taccess_type = ACCESS_INT;\n\n    }\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    if (ret == 0) {\n\n\tret = tlb_set_page(env, address & ~0xFFF, physical, prot,\n\n\t\t\t   is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n    do_fault:\n\n#if defined (DEBUG_MMU)\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_ISI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14936, "substitutes": {"env": ["enc", "en", "et", "engine", "ne", "environment", "ev", "dt", "site", "exec", "exc", "txt", "inet", "v", "erv", "e", "obj", "worker", "network", "enter", "server", "dat", "style", "qt", "kn", "eng", "ec", "db", "conf", "ef", "export", "config", "proc", "ea", "eu", "net", "profile", "eni", "org", "np", "her", "init", "cache", "context", "shell", "viron", "dict", "ext", "scope", "here", "manager", "energy", "loader", "que", "console", "settings", "err", "forge", "equ", "conn", "Environment", "code"], "address": ["prefix", "route", "number", "connection", "position", "office", "attribute", "external", "inet", "localhost", "primary", "mode", "image", "uration", "message", "network", "enter", "interface", "output", "server", "password", "area", "uri", "shape", "object", "contract", "offset", "host", "config", "location", "channel", "context", "ip", "Address", "addr", "reference", "pointer", "target", "index", "type", "device", "p", "port", "absolute", "entry", "ace", "database", "array"], "rw": ["wh", "ru", "route", "func", "rs", "raw", "rh", "wr", "rt", "work", "wb", "password", "access", "iw", "ro", "resource", "wp", "rf", "rack", "lr", "hw", "rr", "rc", "wx", "rb", "rss", "slave", "ww", "rx", "wl", "sw", "RW", "row", "fw", "src", "w", "rl", "tty", "rn", "nw", "r", "wn", "sth"], "is_user": [" is_bug", "is_public", " is_force", "iswebuse", "is_users", "is24users", " is_use", "is_bug", "islandbug", "is_force", "is24user", " is_public", "iswebuser", "is24force", "islanduser", " is_users", "iswebbug", "islandpublic", "is24use", "is_use", "iswebpublic", "islanduse"], "is_softmmu": ["is_softpmcu", "is_hardmmou", "is_softpmu", "is_softmcus", "is_softmlus", "is_softmmcu", "is_hardmmi", "is_softmci", "is_softmlu", "is_hardmmus", "is_softpmou", "is_softmcu", "is_hardmmu", "is_softmmou", "is_softpmi", "is_softmlou", "is_softmlcu", "is_softmmi", "is_softmccu", "is_softmmus", "is_softpmus", "is_hardmmcu"], "physical": ["binary", "prefix", "virtual", "optional", "route", "tmp", "temp", "phys", "data", "primary", "nt", "resp", "external", "secondary", "phone", "local", "network", "server", "password", "ocol", "pg", "protected", "sp", "api", "php", "config", "proc", "host", "channel", "net", "np", "boot", "http", "pointer", "info", "reference", "hard", "p", "rx", "sb", "buffer", "stat", "remote", "relative", "ref", "native", "number"], "prot": ["fp", "phy", "prefix", "gt", "virtual", "phys", "reset", "txt", "resp", "primary", "secondary", "pos", "plain", "eth", "format", "rt", "att", "server", "password", "uri", "rf", "protected", "offset", "tell", "len", "response", "seq", "fun", "ptr", "php", "config", "got", "notes", "pointer", "addr", "ext", "reference", "status", "cli", "Prot", "prop", "port", "transfer", "stat", "bit", "platform", "ret", "ref", "conn", "alt", "pro", "rot"], "access_type": ["playingtype", "accessingcode", "access_level", " access_level", "action_class", "accessfullvalue", "action_type", "access_method", "accessalrole", "accessfullcode", "accessingtype", "action_types", " access_size", "access_style", "accessalltypes", "accessalset", "access_code", "access_value", "play_role", "accessaltoken", "access_name", " access_code", "accessalinfo", "play_type", "accessalcode", "accessingtypes", "playingrole", "accessingclass", " access_name", "accessingrole", "access_types", "playingcode", "actioningmethod", "accessencode", "actioningclass", " access_token", "accessallcode", "access_set", "accessfulltype", "accessallstyle", "actioningtype", "play_code", "access_info", "accessingmethod", "access_key", " access_set", "access_role", "accessalname", "access_class", "accessenname", "accessaltype", "access_size", "accessentoken", " access_key", "accessallevel", "access_token", "accessentype", " access_value", "action_method", "actioningtypes", "accessfullkey", " access_style", " access_info", " access_types", "accessalltype"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n", "idx": 14942, "substitutes": {"buffer": ["binary", "document", "batch", "iter", "file", "FFER", "material", "position", "reader", "texture", "source", "image", "result", "container", "length", "size", "server", "writer", "header", "border", "uffer", "queue", "surface", "slice", "comment", "program", "url", "bridge", "player", "audio", "view", "buff", "cache", "seek", "memory", "reference", "window", "Buffer", "table", "manager", "loader", "transfer", "buf", "filename", "database"], "height": ["wall", "d", "gap", "my", "ty", "flow", "high", "deep", "distance", "volume", "image", "three", "direction", "head", "length", "size", "style", "above", "Height", "depth", "rows", "level", "shape", "header", "padding", "lat", "border", "dim", "resolution", "tight", "density", "capacity", "id", "han", "center", "x", "h", "bottom", "history", "window", "input", "layout", "crop", "upper", "third", "thin", "stroke", "row", "name", "w", "rank", "inches", "hang"], "stride": ["stade", " strride", "arrid", "STRride", "tride", "grid", "drride", "striride", "grend", "striided", " strid", "trride", "Strade", "stide", "drine", "dride", "striine", "striide", "Stride", "strade", "strine", "STRid", "grade", "gride", "trade", "drone", "strid", "stend", "arrade", "strided", "STRide", "arrone", "Strided", " strance", "trance", "stided", "arrided", "Strine", " strade", "Strance", "Strride", "arride", "arrend", "strend", "STRine", "strride", "drided", "Strid", "grided", " strine", "strance", "grone", "drid", "drend", "strone"], "y": ["ya", "o", "ay", "ky", "ty", "yn", "yo", "ys", "ry", "yt", "yr", "year", "l", "ny", "by", "ady", "zy", "xy", "ym", "vy", "z", "yd", "ch", "id", "ey", "yer", "ish", "x", "i", "h", "yah", "p", "col", "yu", "b", "cy", "hy", "w", "Y", "yy", "dy", "oy", "ye", "j", "sy", "py", "t", "sky", "yi", "gy", "yl"], "b0": ["br0", "bb2", "f2", "f1", "br2", "p05", "bb1", "p4", "bb5", "p0", "f4", "b5", "b05", "B2", " b4", "f3", "br05", "B3", "bb4", "f0", "B4", "f05", "B0", "f5", "p3", " b5", "bb3", "b4", "bb0", "p2", "p1", "br1"], "b1": ["p11", "f2", "bb2", "f1", "a1", "a0", "a2", "bb1", "f11", "b11", "B1", " bone", "B2", "f3", "B3", "f0", "bone", "B0", "bbone", "a3", "p3", "bb3", " b11", "bb0", "p2", "p1", "fone"], "b2": ["B6", "b6", "sb2", "bb32", "bbb", "bufftwo", "sb3", "bb2", "f2", "l2", "f1", "bb1", "sb0", "b32", " bb", "B1", " b32", "btwo", "buff1", "buff0", " btwo", "B2", "f3", "buff2", "f0", "l1", "f32", "bb", "bb6", "B0", "l0", "sbb", "l3", "bb3", " b6", "bb0", "bbtwo"], "b3": ["b6", "wthree", " b33", "b4", "fThree", "abb6", "f2", "bb2", "f8", "f33", "bthree", " bthree", "l2", "f1", "l4", "b33", "bb1", "f4", "emb3", "bb33", "embThree", "embThird", "abbThree", "f3", "bb4", "f0", "fthree", "emb6", "w3", "l1", "l8", "abb3", "embthree", "b8", "bThird", "l0", " bThree", " b8", "bbthree", "wThree", "bThree", " bThird", "l3", " b6", "abbThird", "bb3", "bb0", "emb1", "w1"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14951, "substitutes": {"bs": ["fs", "ins", "rs", "cs", "sa", "bc", "ts", "outs", "fb", "ds", "blocks", "ss", "bos", "bt", "BS", "gs", "lb", "obs", "bh", "es", "rb", "os", "iss", "bi", "bits", "vs", "ns", "bb", "b", "sb", "as", "ses", "ms", "js", "gb", "ls", "cms", "pb"], "offset": ["fp", "prefix", "part", "o", "address", "alloc", "af", "fee", "shift", "position", "seed", "reset", "data", "pos", "length", "size", "base", "delay", "timeout", "slot", "padding", "limit", "ptr", "error", "num", "location", "id", "pointer", "bytes", "addr", "range", "off", "index", "start", "enabled", "port", "adjusted", "Offset", "alpha", "loc", "len", "number", "oa"], "s": ["ps", "storage", "fs", "sync", "d", "o", "session", "ins", "rs", "site", "t", "v", "cs", "sa", "e", "ts", "its", "l", "ds", "states", "sys", "si", "ss", "in", "ssl", "service", "uns", "sq", "gs", "xs", "g", "es", "ks", "os", "spec", "stats", "is", "c", "su", "i", "ns", "p", "qs", "b", "sl", "sets", "aws", "f", "sb", "ses", "sis", "js", "ms", "settings", "ls", "sym", "services", "S", "r", "conf", "ops"], "ret": ["et", "en", "ft", "fin", "af", "success", "hash", "data", "nt", "resp", "bf", "result", "obj", "rt", "cb", "base", "att", "val", "res", "db", "rf", "det", "len", "al", "fun", "url", "rc", "reg", "rets", "id", "mt", "addr", "ext", " result", "lit", "arr", "sr", "re", "out", "RET", "flag", "red", "lf", "back", "bit", "r", "pass", "ref", "conn", "alt", "Ret", "code"], "fd": ["fp", "fm", "fail", "fs", "d", "bd", "ft", "fin", "dt", "fa", "fee", "fi", "nd", "bf", "md", "resp", "draft", "ld", "rd", "result", "fn", "ff", "fl", "cf", "fe", "cb", "wd", "fb", "dir", "hd", "cd", "end", "nil", "wb", "fat", "db", "dc", "pd", "sf", "fun", "dl", "df", "cond", "fr", "handler", "id", "feed", "fc", "fed", "dd", "fx", "f", "lf", "FD", "wat", "dy", "buf", " fid"], "datalen": ["davalang", " datalang", "Davalan", "dmaln", " datallen", "Davalen", " dotalen", "dalanength", "daclen", "dotalenc", "datalenc", "daln", "dalan", "diline", "Datalen", "dotallen", "dmalens", "davalength", "dmalen", "dotaline", " dalength", "dalen", "dacline", " datalength", "datalens", "davaln", "dilen", "dotalen", "dillen", " dalun", "dalanun", "dmalan", "datalun", "datalang", "datalan", "datalength", "Davalens", "dalanang", "davalens", " dotallen", "dilenc", "davalun", " dalang", " datalenc", "Datalan", "dalength", "dacllen", "Datalens", "dalens", "Davaln", " dalen", "dataline", "datallen", "daclenc", " dotalenc", " dataline", "dalang", "Dataln", " datalun", "dalanen", " dotaline", "dalun", "dataln", "davalen", "davalan"]}}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int rndis_parse(USBNetState *s, uint8_t *data, int length)\n\n{\n\n    uint32_t msg_type;\n\n    le32 *tmp = (le32 *) data;\n\n\n\n    msg_type = le32_to_cpup(tmp);\n\n\n\n    switch (msg_type) {\n\n    case RNDIS_INITIALIZE_MSG:\n\n        s->rndis_state = RNDIS_INITIALIZED;\n\n        return rndis_init_response(s, (rndis_init_msg_type *) data);\n\n\n\n    case RNDIS_HALT_MSG:\n\n        s->rndis_state = RNDIS_UNINITIALIZED;\n\n        return 0;\n\n\n\n    case RNDIS_QUERY_MSG:\n\n        return rndis_query_response(s, (rndis_query_msg_type *) data, length);\n\n\n\n    case RNDIS_SET_MSG:\n\n        return rndis_set_response(s, (rndis_set_msg_type *) data, length);\n\n\n\n    case RNDIS_RESET_MSG:\n\n        rndis_clear_responsequeue(s);\n\n        s->out_ptr = s->in_ptr = s->in_len = 0;\n\n        return rndis_reset_response(s, (rndis_reset_msg_type *) data);\n\n\n\n    case RNDIS_KEEPALIVE_MSG:\n\n        /* For USB: host does this every 5 seconds */\n\n        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);\n\n    }\n\n\n\n    return USB_RET_STALL;\n\n}\n", "idx": 14982, "substitutes": {"s": ["ps", "comments", "fs", "sync", "d", "us", "o", "storage", "sites", "site", "south", "v", "secondary", "private", "cs", "e", "u", "ts", "l", "ds", "states", "sys", "si", "ss", "ssl", "service", "m", "se", "an", "state", "this", "conf", "gs", "a", "g", "es", "sports", "sup", "self", "os", "spec", "is", "side", "http", "c", "su", "i", "sg", "info", "p", "ns", "status", "b", "sl", "sets", "aws", "f", "sb", "ses", "js", "settings", "r", "services", "sym", "S", "ls", "socket", "native", "ops"], "data": ["done", "body", "part", "d", "di", "address", "session", "o", "shift", "raw", "multi", "results", "media", "e", "result", "events", "message", "package", "size", "dat", "ds", "timeout", "pad", "partial", "ata", "ui", "state", "slice", "api", "len", "response", "a", "error", "config", "da", "ada", "cache", "input", "args", "i", "bytes", "window", "p", "missing", "Data", "dd", "device", "type", "start", "load", "msg", "DATA", "xxx", "buffer", "sample", "buf", "alpha", "database", "array", "ad"], "length": ["en", "failed", "address", "number", "position", "impl", "count", "match", "message", "Length", "l", "duration", "size", "style", " Length", "shape", "path", "full", "padding", "limit", "slice", "form", "maximum", "id", "ength", "p", "type", "load", "angle", "len", "ENGTH", "pack", "sequence"], "msg_type": ["msgtypetypes", " msg_info", " msg_name", "Msg_type", "msg_types", "Msg_key", "msg_name", " msg_path", " msg_types", "msgtypename", "msgtypetype", "msg_info", "msg_path", "msg_Type", "msgtypepath", " msg_id", "msg_id", "Msg_id", "msg_key", "Msg_Type"], "tmp": ["fp", "binary", "storage", "mp", "stuff", "cpp", "tp", "temp", "uf", "txt", "tc", "obj", "array", "cb", "fb", "wb", "copy", "m", "attr", "slice", "mo", "fd", "ptr", "rb", "sup", "np", "handler", "mem", "buff", "bp", "input", "su", "b", "bag", "metadata", "msg", "buffer", "buf", "text", "img", "var"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int sap_write_header(AVFormatContext *s)\n\n{\n\n    struct SAPState *sap = s->priv_data;\n\n    char host[1024], path[1024], url[1024], announce_addr[50] = \"\";\n\n    char *option_list;\n\n    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;\n\n    AVFormatContext **contexts = NULL;\n\n    int ret = 0;\n\n    struct sockaddr_storage localaddr;\n\n    socklen_t addrlen = sizeof(localaddr);\n\n    int udp_fd;\n\n    AVDictionaryEntry* title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n\n\n    if (!ff_network_init())\n\n        return AVERROR(EIO);\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,\n\n                 path, sizeof(path), s->filename);\n\n    if (base_port < 0)\n\n        base_port = 5004;\n\n\n\n    /* search for options */\n\n    option_list = strrchr(path, '?');\n\n    if (option_list) {\n\n        char buf[50];\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_port\", option_list)) {\n\n            port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"same_port\", option_list)) {\n\n            same_port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"ttl\", option_list)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_addr\", option_list)) {\n\n            av_strlcpy(announce_addr, buf, sizeof(announce_addr));\n\n        }\n\n    }\n\n\n\n    if (!announce_addr[0]) {\n\n        struct addrinfo hints = { 0 }, *ai = NULL;\n\n        hints.ai_family = AF_UNSPEC;\n\n        if (getaddrinfo(host, NULL, &hints, &ai)) {\n\n            av_log(s, AV_LOG_ERROR, \"Unable to resolve %s\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        if (ai->ai_family == AF_INET) {\n\n            /* Also known as sap.mcast.net */\n\n            av_strlcpy(announce_addr, \"224.2.127.254\", sizeof(announce_addr));\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        } else if (ai->ai_family == AF_INET6) {\n\n            /* With IPv6, you can use the same destination in many different\n\n             * multicast subnets, to choose how far you want it routed.\n\n             * This one is intended to be routed globally. */\n\n            av_strlcpy(announce_addr, \"ff0e::2:7ffe\", sizeof(announce_addr));\n\n#endif\n\n        } else {\n\n            freeaddrinfo(ai);\n\n            av_log(s, AV_LOG_ERROR, \"Host %s resolved to unsupported \"\n\n                                    \"address family\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        freeaddrinfo(ai);\n\n    }\n\n\n\n    sap->protocols = ffurl_get_protocols(NULL, NULL);\n\n    if (!sap->protocols) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    contexts = av_mallocz(sizeof(AVFormatContext*) * s->nb_streams);\n\n    if (!contexts) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    s->start_time_realtime = av_gettime();\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        URLContext *fd;\n\n\n\n        ff_url_join(url, sizeof(url), \"rtp\", NULL, host, base_port,\n\n                    \"?ttl=%d\", ttl);\n\n        if (!same_port)\n\n            base_port += 2;\n\n        ret = ffurl_open(&fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL,\n\n                         sap->protocols);\n\n        if (ret) {\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        ret = ff_rtp_chain_mux_open(&contexts[i], s, s->streams[i], fd, 0, i);\n\n        if (ret < 0)\n\n            goto fail;\n\n        s->streams[i]->priv_data = contexts[i];\n\n        s->streams[i]->time_base = contexts[i]->streams[0]->time_base;\n\n        av_strlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename));\n\n    }\n\n\n\n    if (s->nb_streams > 0 && title)\n\n        av_dict_set(&contexts[0]->metadata, \"title\", title->value, 0);\n\n\n\n    ff_url_join(url, sizeof(url), \"udp\", NULL, announce_addr, port,\n\n                \"?ttl=%d&connect=1\", ttl);\n\n    ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,\n\n                     &s->interrupt_callback, NULL, sap->protocols);\n\n    if (ret) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    udp_fd = ffurl_get_file_handle(sap->ann_fd);\n\n    if (getsockname(udp_fd, (struct sockaddr*) &localaddr, &addrlen)) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    if (localaddr.ss_family != AF_INET\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        && localaddr.ss_family != AF_INET6\n\n#endif\n\n        ) {\n\n        av_log(s, AV_LOG_ERROR, \"Unsupported protocol family\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann_size = 8192;\n\n    sap->ann = av_mallocz(sap->ann_size);\n\n    if (!sap->ann) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann[pos] = (1 << 5);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    if (localaddr.ss_family == AF_INET6)\n\n        sap->ann[pos] |= 0x10;\n\n#endif\n\n    pos++;\n\n    sap->ann[pos++] = 0; /* Authentication length */\n\n    AV_WB16(&sap->ann[pos], av_get_random_seed());\n\n    pos += 2;\n\n    if (localaddr.ss_family == AF_INET) {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr,\n\n               sizeof(struct in_addr));\n\n        pos += sizeof(struct in_addr);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    } else {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr,\n\n               sizeof(struct in6_addr));\n\n        pos += sizeof(struct in6_addr);\n\n#endif\n\n    }\n\n\n\n    av_strlcpy(&sap->ann[pos], \"application/sdp\", sap->ann_size - pos);\n\n    pos += strlen(&sap->ann[pos]) + 1;\n\n\n\n    if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos],\n\n                      sap->ann_size - pos)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    av_freep(&contexts);\n\n    av_log(s, AV_LOG_VERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]);\n\n    pos += strlen(&sap->ann[pos]);\n\n    sap->ann_size = pos;\n\n\n\n    if (sap->ann_size > sap->ann_fd->max_packet_size) {\n\n        av_log(s, AV_LOG_ERROR, \"Announcement too large to send in one \"\n\n                                \"packet\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_free(contexts);\n\n    sap_write_close(s);\n\n    return ret;\n\n}\n", "idx": 15001, "substitutes": {"s": ["comments", "storage", "fs", "sync", "d", "sv", "o", "session", "rs", "south", "v", "sc", "cs", "e", "sa", "u", "ts", "parts", "server", "ds", "params", "sys", "si", "ss", "types", "ssl", "service", "m", "conf", "sq", "gs", "a", "g", "es", "sports", "n", "os", "spec", "stats", "is", "c", "args", "sg", "p", "ns", "qs", "b", "aws", "sets", "sl", "f", "sb", "js", "ses", "settings", "ls", "services", "sym", "S", "r", "t", "ops"], "sap": ["ssaps", "ssap", "Saps", "sAP", "SAP", " sAP", "saps", " saps", "Sap", "ssAP"], "host": ["prefix", "client", "auth", "address", "file", "hop", "hub", "Host", "connection", "proxy", "arch", "localhost", "source", "dir", "container", "eth", "format", "cmd", "server", "uri", "header", "domain", "hw", "config", "location", "method", "ac", "node", "home", "context", "http", "h", "ip", "addr", "target", "type", "component", "src", "name", "port", "loc", "connect", "conn", "driver", "code"], "path": ["prefix", "enc", "part", "file", "route", "content", "data", "Path", "user", "source", "image", "dir", "container", "pattern", "cmd", "length", "uri", "resource", "alias", "root", "time", "str", "config", "method", "location", "key", "id", "PATH", "node", "home", "context", "http", "c", "h", "cache", "pointer", "p", "ath", "prop", "name", "port", "request", "value", "text", "loc", "ref", "code"], "url": ["address", "file", "route", "proxy", "source", "image", "server", "uri", "resource", "ssl", "api", "URL", "config", "channel", "method", "href", "cache", "ip", "http", "sl", "mount", "stream", "text", "loc", "ref"], "announce_addr": ["announce1host", "announce_dr", "announce_tag", "announced_address", "announceingdata", "announced_addr", "announceappdata", "announceingcoord", "announce2tag", "announceappaddress", "announceingaddress", "announce1tag", "announce_address", "announceappcoord", "announce2address", "announceingdr", "announceinghost", "announce_host", "announce1addr", "announceappaddr", "announce2addr", "announced_coord", "announce1address", "announce_coord", "announce_data", "announceingaddr", "announce2host", "announced_data"], "option_list": ["optionadList", "option6stack", "opt_name", "option_listed", "option9list", "option_array", "option_type", " option_stack", "optionadcoll", "option_la", "option_string", "optionPlist", "optionaylisted", "optionklist", "option_keep", "optionPla", "optionerlist", "option9stack", "optionadlisted", "optionaycoll", "options_type", "options_list", "option6keep", "option9keep", " option_array", "option_name", "optionadlist", "optionaylist", "option_card", "option_coll", "optionknot", "option_List", "option_stack", " option_keep", " option_test", " option_listed", "option_test", "optionkList", " option_string", " option_List", "opt_la", "optionernot", "optionPname", " option_not", "optionktest", "option_not", "option6list", "optionayList", " option_name", "optionerList", "optionertest", " option_card", "options_List", " option_coll", "opt_list"], "i": ["us", "iu", "position", "multi", "u", "inner", "end", "pi", "uri", "loc", "a", "net", "n", "io", "id", "is", "ip", "c", "http", "h", "info", "p", "cli", "index", "r", "I"], "contexts": ["contextu", "configu", "Contextu", "Contexts", "methodi", "methodn", "confign", "methods", "Contextn", "contextn", "contexti", "configi", "methodu", "Contexti", "configs"], "localaddr": ["Localaddress", " localconn", " localAddress", " locallen", "localhost", "remoteaddress", "Localaddr", "locallen", "remotehost", " localaddress", " localhost", "Localhost", "alconn", "LocalAddress", "aladdress", "aladdr", "localconn", "localaddress", "remoteAddress", "allen", "Locallen", "localAddress", "Localconn", "remoteaddr"], "udp_fd": ["udp_fc", "udf_fd", "udf_resp", "udf_fc", "udp_stream", "udf_stream", "udp_resp"], "title": ["content", " metadata", "data", " desc", "desc", "alias", "def", "doc", "header", "meta", "seq", "config", " meta", "details", "id", "version", "description", "type", " description", "metadata", "name", " msg", "msg", "port", "entry", "text"], "buf": ["fp", "exc", "uf", "pkg", "bed", " buffer", "cb", "fb", "seq", "rb", "utf", "box", "src", "msg", "uint", "font", "array", "prefix", "loop", "cmd", "header", "queue", "pool", "num", "block", "cache", "context", "off", "buffer", "cas", "null", "ru", "grab", "la", "bc", "feat", "wb", "bin", "bus", "padding", "runner", "rc", "bh", "buff", "home", "conv", "lit", "coll", "hal", "text", "ha", "alloc", "dr", "br", "pad", "vec", "uc", "ptr", "config", "proc", "nat", "ctx", "feed", "extra", "su", "b", "bag", "prop", "port", "console", "loc", "img", "cv"], "ai": ["aud", "asi", "ba", "di", "ay", "afi", "umi", "aii", "sa", "AI", "pi", "si", "oci", "an", "agi", "api", "iri", "iam", "a", "ae", "ti", "hai", "ac", "ci", "ia", "pa", "am", "bi", "qi", "pai", "iat", "ni", "ait", "ca", "au", "ais", "asm", "ace", "aa", "aaa", "wa"], "pos": ["position", "mode", "pt", "val", "def", "post", "pid", "offset", "seq", "unit", "nat", "neg", "os", "opt", "id", "ip", "cp", "p", "index", "col", "type", "prop", "err", "r", "loc", "ref", "len"]}}
{"project": "FFmpeg", "commit_id": "ef23bd939d955f53bc58696bbb68960784066894", "target": 1, "func": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n\n                                int nPbW, int nPbH,\n\n                                int log2_cb_size, int partIdx, int idx)\n\n{\n\n#define POS(c_idx, x, y)                                                              \\\n\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int merge_idx = 0;\n\n    struct MvField current_mv = {{{ 0 }}};\n\n\n\n    int min_pu_width = s->sps->min_pu_width;\n\n\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n\n    RefPicList  *refPicList = s->ref->refPicList;\n\n    HEVCFrame *ref0, *ref1;\n\n    uint8_t *dst0 = POS(0, x0, y0);\n\n    uint8_t *dst1 = POS(1, x0, y0);\n\n    uint8_t *dst2 = POS(2, x0, y0);\n\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n\n    int min_cb_width     = s->sps->min_cb_width;\n\n    int x_cb             = x0 >> log2_min_cb_size;\n\n    int y_cb             = y0 >> log2_min_cb_size;\n\n    int x_pu, y_pu;\n\n    int i, j;\n\n\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n\n\n    if (!skip_flag)\n\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n\n\n    if (skip_flag || lc->pu.merge_flag) {\n\n        if (s->sh.max_num_merge_cand > 1)\n\n            merge_idx = ff_hevc_merge_idx_decode(s);\n\n        else\n\n            merge_idx = 0;\n\n\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                   partIdx, merge_idx, &current_mv);\n\n    } else {\n\n        hevc_luma_mv_mpv_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                              partIdx, merge_idx, &current_mv);\n\n    }\n\n\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n\n\n    if (current_mv.pred_flag & PF_L0) {\n\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n\n        if (!ref0)\n\n            return;\n\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n\n    }\n\n    if (current_mv.pred_flag & PF_L1) {\n\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n        if (!ref1)\n\n            return;\n\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n\n    }\n\n\n\n    if (current_mv.pred_flag == PF_L0) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                    &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n\n                    s->sh.luma_offset_l0[current_mv.ref_idx[0]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);\n\n    } else if (current_mv.pred_flag == PF_L1) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,\n\n                    &current_mv.mv[1], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n\n                    s->sh.luma_offset_l1[current_mv.ref_idx[1]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);\n\n\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);\n\n    } else if (current_mv.pred_flag == PF_BI) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                   &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                   ref1->frame, &current_mv.mv[1], &current_mv);\n\n\n\n        chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);\n\n\n\n        chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);\n\n    }\n\n}\n", "idx": 15002, "substitutes": {"s": ["ps", "storage", "sync", "comments", "d", "us", "session", "rs", "site", "south", "styles", "secondary", "sc", "cs", "e", "u", "ts", "its", "l", "features", "ds", "sys", "si", "y", "ss", "ssl", "service", "m", "se", "conf", "sq", "slice", "gs", "plugins", "xs", "a", "g", "es", "n", "os", "spec", "stats", "is", "c", "su", "sg", "args", "ns", "p", "qs", "set", "b", "sets", "f", "sb", "sie", "sis", "ses", "js", "settings", "request", "r", "services", "sym", "S", "ls", "t", "less", "ops", "single"], "x0": ["X2", "y000", "w0", "y00", "x25", "x1", "px00", "X00", "y2", "y1", "px1", "w00", "Xfe", " x00", "yfe", " xee", " xfe", "x2", " x1", "xfe", "x000", "y25", "px000", "yee", "X25", "px0", "X0", "x00", "Xee", " x25", " x2", "xee", "w000", "w1", "X1"], "y0": ["ym00", "y00", " y1", " y50", "ry1", "Y00", "sy80", "x1", " yi", "ry25", "y2", "y90", "sy0", "y1", " y5", " y80", "Y0", "x8", "dy80", "dy0", "x90", " y8", "ry0", "Y90", "x2", "Y1", "ymi", "sy00", "dy50", "Y8", "y5", "Y25", "Y2", " y00", "y25", " y2", "sy50", "ym1", "y80", "dy00", "y8", "y50", "ym0", "ry5", "Y5", " y90", "yi", "Yi", " y25"], "nPbW": ["nPcW", "nPbWidth", "nPcWh", "nNbWh", "nPbWh", "nNbW", "nPmW", "nPbX", "nNcW", "nPkWh", "nNbX", "nPmWh", "nPkW", "nNcX", "nNcWh", "nPmX", "nNcWidth", "nPcWidth", "nPkWidth", "nPkX", "nNbWidth", "nPcX", "nPmWidth"], "nPbH": ["nPcSH", "nPcW", "nHmW", "nHbh", "nPbh", "nHmh", "nHbW", "nPfh", "nHbSH", "nPcH", "nPch", "nPfW", "nPmH", "nPmSH", "nHmH", "nPmW", "nHbH", "nPfSH", "nPmh", "nPfH", "nHmSH", "nPbSH"], "log2_cb_size": ["log2_cb2size", "log2_cb2sum", "log2_cb2SIZE", "log2_cv_SIZE", "log2_cb2len", "log2_cv_len", "log2_cb64sum", "log2_cb64size", "log2_cb64SIZE", "log2_cb_len", "log2_cv_size", "log2_cb_sum", "log2_cb64len", "log2_cv_sum", "log2_cb_SIZE"], "partIdx": ["partidx", "partidcode", "partIdy", "partIdxs", " partIdxs", "partIDy", "partIDx", "partIdcode", " partIdcode", "partLenxs", "partidxs", "partidy", " partidy", "partLeny", " partidx", "partLenx", "partLencode", " partIdy", "partIDxs", " partidxs", "partIDcode", " partidcode"], "idx": ["idz", "Idx", "idX", "IDX", "Idz", " idX", "IDx", "idv", " idv", "IDz", " idz", "Idv", "IdX", "IDv"], "lc": ["fp", "fs", "kl", "cn", "cm", "tc", "sc", "cs", "nc", "bc", "sci", "pc", "l", "lt", "si", "gc", "lu", "ec", "cc", "cmp", "dc", "lr", "lb", "rc", "dl", "LC", "lp", "LCS", "ci", "ctx", "ln", "fc", "acs", "c", "wl", "lib", "cli", "cl", "ctrl", "lv", "sb", "lf", "mc", "wcs", "gb", "ls", "loc"], "tab_mvf": ["tab_mwf", "tab_mqc", "tab_mavf", "tab_mvc", "tab_Mwf", "tab_mqfs", "tab_mwfs", "tab_mavcf", "tab_Mvfs", "tab_Mvcf", "tab_mavc", "tab_Mwc", "tab_Mwfc", "tab_Mvf", "tab_mwc", "tab_mvmfc", "tab_mvfc", "tab_mvcf", "tab_mwcf", "tab_mqf", "tab_mwfc", "tab_mvmc", "tab_mavfs", "tab_mavfc", "tab_Mvfc", "tab_Mvc", "tab_mvfs", "tab_mvmfs", "tab_mvmf", "tab_Mwfs", "tab_Mwcf", "tab_mqcf"], "refPicList": ["refPicOrder", "refCompList", "refPictureOrder", "refPicName", "RefPictureOrder", "refCompTable", "RefPictureList", "refObjEx", "RefPictureName", "refPictureEx", "refCompSet", "refPixelOrder", "refCompName", "refCaptTable", "RefPicEx", "refPicEx", "refPixelSet", "refCaptName", "RefPicList", "refPictureName", "refPictureTable", "refPixelList", "RefPicTable", "RefPicName", "refPictureList", "refPicSet", "RefPictureSet", "refPictureSet", "refCaptSet", "RefPicSet", "RefPicOrder", "refObjList", "refPixelEx", "RefPictureEx", "refObjSet", "refCaptList", "refObjOrder", "RefPictureTable", "refPicTable"], "ref0": [" ref2", "ref2", "reference2", "source0", " ref00", "reference0", "ref00", "source00", "source2", "reference00"], "ref1": ["ref2", " ref2", "reference2", "Ref2", "Ref1", "reference1", "Ref0", "reference0"], "dst0": ["nbl2", "dbl00", "dbl0", "nst00", "dst3", "dpt2", "dpt3", "dsp00", "dsp0", "nst3", "nst2", "dst00", "nbl00", "nst0", "nbl0", "dpt00", "dpt0", "dsp2", "dbl2", "dsp3", "dbl3", "nbl3"], "dst1": ["dste0", " dsp1", "dst3", "dST2", "dsp1", "dST1", "dsp0", "dste1", "dste2", " dsp2", "dST3", " dsp0", "dsp2", "dste3", " dsp3", "dsp3", "dST0", " dst3"], "dst2": [" dst4", " dsp1", "dsts5", "dbl1", "dsp1", " dsp2", " dst5", " dsp5", "dbl4", "dst4", "dsp5", "dsp2", " dsp4", "dbl2", "dst5", "dsp4", "dbl5", "dsts2", "dsts4", "dsts1"], "x_pu": ["x_cb", "x_cpu", " x_np", " x_cpu", "x_np", " x_cb"], "y_pu": ["y2api", "vy_pu", "y_api", "y2cache", "y2cp", "vy_cache", "y_cache", "y_cp", "y2pu", "vy_api", "vy_cp"], "i": ["it", "d", "v", "li", "e", "l", "pi", "y", "in", "ai", "m", "z", "k", "n", "ci", "id", "io", "ip", "x", "c", "h", "p", "b", "f", "r", "ii", "I"], "j": ["it", "adj", "o", "J", "jp", "v", "jl", "obj", "l", "job", "note", "y", "m", "offset", "k", "z", "jj", "n", "kj", "axis", "q", "ji", "p", "b", "jump", "t"]}}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlockReq *req;\n\n    MultiReqBuffer mrb = {};\n\n\n\n    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start\n\n     * dataplane here instead of waiting for .set_status().\n\n     */\n\n    if (s->dataplane) {\n\n        virtio_blk_data_plane_start(s->dataplane);\n\n        return;\n\n    }\n\n\n\n    blk_io_plug(s->blk);\n\n\n\n    while ((req = virtio_blk_get_request(s))) {\n\n        virtio_blk_handle_request(req, &mrb);\n\n    }\n\n\n\n    if (mrb.num_reqs) {\n\n        virtio_blk_submit_multireq(s->blk, &mrb);\n\n    }\n\n\n\n    blk_io_unplug(s->blk);\n\n}\n", "idx": 15016, "substitutes": {"vdev": ["ldi", "Vdevice", "wdev", " vde", "mdev", "vdiv", " vdevice", "ldevice", "wdiv", "ldev", " vdi", "mde", "vdef", "wdevice", "Vdev", "ldef", "wdef", "lde", "mdevice", "Vdef", "mdi", "vdi", "vde", "vdevice", "Vdiv"], "vq": ["valq", "vcw", " vw", "vqi", "vcqi", "valquest", "valw", " vqi", "vquest", "valqi", "vcq", " vquest", "vcquest", "vw"], "s": ["comments", "ps", "sync", "fs", "d", "us", "o", "session", "sv", "ops", "ins", "south", "v", "e", "u", "cs", "its", "l", "parts", "params", "ds", "si", "ions", "ss", "full", "ssl", "se", "m", "service", "an", "new", "sq", "uns", "gs", "a", "g", "es", "ks", "self", "n", "os", "spec", "rss", "is", "current", "c", "http", "su", "i", "sg", "p", "ns", "b", "sl", "aws", "f", "sb", "as", "ses", "w", "js", "r", "services", "sym", "S", "ls", "t", "sk"], "req": ["ru", "require", "rs", "exec", "pull", "requ", "resp", "ry", "iq", "desc", "cb", "qt", "def", "res", "rf", "sq", "sem", "seq", "rr", "proc", "reg", "sub", "rec", "progress", "fr", "ch", "quest", "spec", "cur", "hr", "cache", "http", "q", "rx", "input", "ext", "p", "ver", "crit", "ir", "Request", "w", "load", "dq", "call", "err", "request", "ind", "r", "gr", "ref", "conf", "comp", "wa"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 15051, "substitutes": {"pix": ["fixel", " pixel", "spik", " pixels", " prc", " pik", "Prc", "fix", "frc", "pixel", "Pip", "mixel", "fixels", "mix", "pip", "Pix", " pip", "prc", "spix", "sprc", "pik", "Pixel", "Pixels", "fik", "pixels", "mixels", "mip", "spixels"], "stride": ["bride", "slid", "strad", "strice", "tride", "drides", " strid", "stide", "divided", "dride", "divad", "shrided", "stider", "slide", "shrice", " strider", "divider", "strid", "slides", "slider", " strad", "strided", "drice", "shrides", "trided", "divide", "strides", "stides", "brided", " strided", "trider", "shride", "drided", "brides", "strider", " strides", "brice", "stid", "trad"], "bS": ["rbV", " bEs", "lEs", " bSS", "basDS", " bWS", "xS", "basSocket", "fTS", "cC", "rbSi", "bSocket", "fSi", "bSi", "basCS", "cS", "fs", "partJS", " bIS", "pEs", " bDS", "bCS", "bWS", "pS", "bP", "bTS", " bV", "bIS", " bDs", " bC", "lDs", "fSS", "aC", " bSocket", "bJS", "pDs", "barSocket", "xJS", " bTS", "bSS", "fIS", "bEs", "partWS", "lS", " bP", "rbs", "partS", "bC", "bDs", "barS", "barDS", "aP", "aS", "xWS", "fV", "rbS", " bs", "barCS", "bs", "bDS", "bV", "fS", " bCS", " bJS", " bSi", "cP", "basS"], "qp": ["dqc", "QP", "sqP", "sqc", "quP", "qP", "quu", "dqP", "squ", "Qc", "dqp", "qu", "fxn", "qc", "sqp", "dqpr", "fxp", "qpr", "fxu", "qun", "Qtp", "qutp", "qtp", "Qpr", "sqtp", "fxc", "quc", "Qp", "sqn", "qup", "qn", "sqpr"], "h": ["hs", "eh", "d", "ha", "hub", "x", "v", "e", "u", "uh", "oh", "rh", "hess", "l", "hd", "conn", "ht", "ih", "hm", "m", "hh", "gh", "he", "html", "hw", "hp", "host", "hl", "g", "bh", "self", "n", "ch", "han", "ctx", "hr", "sh", "c", "H", "q", "ah", "http", "s", "p", "hi", "ph", "history", "b", "f", "w", "zh", "r", "t"], "tc": ["binary", "uca", "cu", "tmp", "temp", "acc", "sc", "cs", "nc", "bc", "pc", "cb", "cum", "icc", "toc", "ec", "cc", "dc", "ui", "tm", "uc", "ta", "cases", "tf", "lc", "rc", "config", "TC", "cus", "ac", "tt", "ci", "asc", "tk", "ctx", "Beta", "fc", "cache", "gam", "c", "ticket", "ul", " TC", "bb", "index", "type", "ic", "ctrl", "tx", "mc", "ca", "tu", "gb", "term", "beta", "xc", "loc", "t", "cas", "pb", "css"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "static void realize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char link_name[256];\n\n    gchar *child_name;\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_realize(spapr_drc_index(drc));\n\n    /* NOTE: we do this as part of realize/unrealize due to the fact\n\n     * that the guest will communicate with the DRC via RTAS calls\n\n     * referencing the global DRC index. By unlinking the DRC\n\n     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it\n\n     * inaccessible by the guest, since lookups rely on this path\n\n     * existing in the composition tree\n\n     */\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(link_name, sizeof(link_name), \"%x\", spapr_drc_index(drc));\n\n    child_name = object_get_canonical_path_component(OBJECT(drc));\n\n    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);\n\n    object_property_add_alias(root_container, link_name,\n\n                              drc->owner, child_name, &err);\n\n    g_free(child_name);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,\n\n                     drc);\n\n    qemu_register_reset(drc_reset, drc);\n\n    trace_spapr_drc_realize_complete(spapr_drc_index(drc));\n\n}\n", "idx": 15055, "substitutes": {"d": ["bd", "o", "di", "dt", "dr", "dom", "dos", "data", "md", "e", "ld", "l", "dat", "did", "dc", "m", "fd", "xd", "dh", " D", "sd", "c", "i", "dict", "p", "b", "f", "dm", "dp", "w", "D", "r", "gd", "t", "driver", "ad"], "errp": [" erpre", "errpy", "rrpre", "errpc", " erp", " erpy", " errpre", "erpy", " errpy", "erpc", " errpc", "erpre", "rrp", " errP", "errpre", "rrpc", "erP", "rrP", "errP", "erp", " erP"], "drc": ["ldsc", "crec", "edource", "odsrc", "dRC", "dbource", " drec", "DRC", "idroc", "pdrac", " dRC", "tource", "ldRC", " dsrc", "dsync", "lsrc", " dirc", "droc", "circ", "zrc", " droc", " dpc", "idync", "Dsrc", "Dpc", "sduc", "eirc", "madRC", "eRC", "madirc", "crc", "idsc", "dbrc", "dbirc", "dsrc", "pdrec", "zrec", "sdpc", "ldrc", "zource", "lrc", "idrec", " dource", "odource", " duc", "dpc", "bdrc", "edrec", "ndsrc", "dsc", "sdRC", "pRC", "dource", "trc", "idrc", "pdrc", "odrec", "Duc", "csrc", "erc", "duc", "pdource", "bdsc", "eource", "sdsrc", "psrc", "ndirc", "Dirc", "edrac", "sdrec", "tirc", "odRC", "zrac", "ldrec", "drac", "madrt", "ldsrc", "dbsc", "odync", "dsource", "idsrc", "dync", "ldroc", "prec", "dirc", "drec", "Drt", "edrc", "Drc", "dsrec", "distrt", "lRC", "sdrc", "drt", "ndrc", "ndrec", "bdource", "madrc", "idource", "bdirc", "tRC", "prc", "distirc", "Dource", "lrec", "Drec", "distrc", "distRC", "odrc", " dsc"], "root_container": ["parent_entry", "rtercomponent", " root_class", "parent_container", "rt_path", " root_path", "rooterpath", "rootercomponent", "rootsroot", "rooterroot", "root_root", "root64entry", "root64path", "rootercontainer", "rootscontainer", "rterpath", "rterroot", "parent_path", "rt_root", "rt_component", "root_class", "rootscomponent", "rt_container", "root_path", "root_component", "root64container", "rootspath", "root_entry", "rtercontainer"], "link_name": ["linkFvalue", "codeFnumber", "link_address", "codeFvalue", "link_id", "codeFname", "link2no", "code_name", "linkFname", "link2name", "linkpvalue", "parent_name", "link_type", "link_path", "linkFnumber", "parent_path", "key_address", "key_name", "code_number", "link_number", "link_no", "parent_type", "link_value", "link_names", "link2names", " link_no", "linkpname", "linkpnumber", " link_names", "key_id", "code_value"], "child_name": ["child_named", "childWlink", "childspath", " child_names", "link_size", "childsname", "childNname", "child_count", "linksName", "childTagpath", "childNaddress", "childNclass", "parent_value", "imageingaddress", "linksname", "linkssize", " child_id", "childingaddress", "childsnames", "parent_name", "linkslink", "childingnamed", "childingclass", "child_id", "image_class", "imageingclass", "childWname", "parent_path", "childOclass", "imageingname", "child_path", "childingpath", "childsName", "childOaddress", "child_address", "childslink", "childTagcount", "childsid", "child_names", "childWName", "link_link", "image_address", "childOname", " child_path", "childOnamed", "childTagname", "imageingnamed", "child_class", " child_Name", "childNnamed", "childingvalue", "child_value", "child_size", "childTagName", "child_Name", "image_named", "childssize", "link_Name", "childWsize", "childingname", "child_link", "image_name", " child_count"], "err": ["ctr", "iter", "oe", "eor", "bug", "ev", "dr", "der", "rs", "fee", "ar", "fi", "exc", "resp", "e", "cr", "result", "rh", "fy", "cb", "finder", "kr", "erer", "ise", "runner", "nr", "lr", "str", "rr", "error", "rage", "pr", "g", "fr", "ln", "hr", "ah", "rx", "ler", "gz", "orr", "req", "order", "mr", "ver", "Er", "arr", "ir", "aster", "msg", "acer", "ind", "orer", "ner", "er", "Error", "or", "r", "ace", "gr", "var"]}}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 15061, "substitutes": {"dc": ["d", "ct", "dt", "cgi", "oc", "cm", "tc", "nc", "bc", "pc", "cit", "cf", "cd", "cb", "icc", "ds", "ec", "cc", "db", "uc", "fd", "cdn", "rc", "lc", "cca", "cot", "config", "ac", "DC", "ctx", "fc", "cache", "context", "c", " DC", "dm", "dp", "mc", "conn", "jc"], "dst": ["dssts", "dsts", "ldst", "sdste", "ldsc", "Dsta", "ldost", " dcr", "idsc", "bST", "Dsc", "Dst", "Dost", " dste", "dcr", "dssta", "dste", "Dsts", " dST", "DST", " dost", "ldST", "idcr", "idst", "bsta", "dost", "bst", "sdst", "dsst", "sdcr", "idste", "dST", "sdsc", "dsta", "bsts", "dsc", " dsc", "dsST"], "addr": ["ha", "address", "dr", "afi", "arch", "anne", "func", "ord", "amd", "ar", "data", "amp", "la", "adr", "pkg", "wd", "work", "align", "pad", "attr", "grad", "offset", "nr", "str", "ptr", "player", "url", "host", "sta", "ada", "osi", "add", "ip", "context", "mac", "ast", "layer", "coord", "ack", "src", "au", "vr", "asm", "ace", "arm", "ann", "oa"], "insn": [" insr", "alsnb", "insnl", "insl", "idsn", "intsr", "alsize", "idsnb", "insr", "insize", "alsnl", "idsnl", "ainsn", "insnb", "insc", "INSl", "intsn", "INSn", "alsn", "ainsnb", "ainsize", "idsize", "intsl", " insc", "ainsnl", "INSr", "INSc", " insl", "intsc"], "size": ["large", "sync", "en", "enc", "storage", "address", "send", "fee", "Size", "sc", "speed", "use", "align", "si", "shape", "eng", "grade", "sn", "small", "scale", "g", "sized", "six", "capacity", "sd", "sh", "core", "name", "SIZE", "esc", "sum", "ize", "security"], "sign": ["enc", "save", "shift", "draw", "raw", "sc", "sa", "act", "SIGN", "align", "Sign", "round", "pad", "shape", "space", "rap", "se", "form", "parse", "scale", "strength", "spec", "id", "plus", "ign", "push", " signs", "inc", "sw", "sl", "name", "min", "load", "carry", "pass", "sum", "ize", "pack"], "r_asi": [" r_aii", "rMadr", "nr_asi", "r__asi", "r_ai", "r0isa", " r_asa", "r_osi", "r_aii", " r_azi", "rMasi", "r0ai", "r_assi", "r_zi", "r__asin", "r_isa", "rplasi", "nr_asin", " r_ati", " r_assi", "rplta", "r_adr", "r_asin", " r_isa", " r_adr", "r__isa", " r_osi", "r_ta", "rMosi", "r0asi", "r0asin", "rpladr", " r_zi", "r_asa", "r__ai", " r_ta", "r_ati", "rplosi", "r_azi", "nr_isa", "rMta", "nr_ai"], "r_size": ["r_care", "rb_size", "nr_sign", "r_slice", "nr_asi", "r_loc", "r___score", "dr_sign", "rg_ize", "rb_si", "rb___score", "r_capacity", "r_si", "rg_ica", "r_score", "rb___size", "rg_size", "r_fee", "rb_capacity", "dr_ize", "rb_score", "rg_si", "rb_loc", "nr_size", "nr_scale", "r___care", "r_scale", "dr_fee", "rb_care", "rb_slice", "r___size", "rb___care", "dr_size", "rb___si", "r___si", "r_ize", "r_ica"], "r_sign": ["r_clean", "rhPlength", "rr_SIGN", "mr_size", "r_form", "r9sign", "rr64SIGN", "r64SIGN", " r_sa", "rr_sign", "r___sa", "rh_clean", "r___sign", "rr64sign", "r_length", "r_keep", "rPclean", "mr_sign", "r64signed", "rh_sign", "rPlength", "mr_min", "r9clean", "r64sign", "rr64like", "r9length", "rh_space", "r_sa", "rPsign", "r9form", "rh_length", " r_keep", "rr_like", "rhPsign", "r_min", "r___keep", "r_SIGN", "rhPclean", "mr_err", "r_err", "r___size", "r_signed", "r64like", "rr_signed", "r_like", "rhPform", "r_space", "rr64signed", "rPform", "rh_form"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "substitutes": {"i": ["it", "d", "ie", "di", "o", "gi", "ini", "iu", "t", "li", "e", "xi", "u", "l", "pi", "val", "si", "vi", "ai", "ui", "ig", "m", "a", "ti", "ix", "k", "n", "ik", "ci", "bi", "is", "phi", "c", "qi", "h", "oi", "x", "p", "index", "ri", "b", "ic", "f", "j", "r", "ii", "I"], "v": ["d", "sv", "o", "ev", "data", "vm", "e", "u", "V", "l", "ov", "val", "vi", "tv", "m", "vt", "g", "k", "n", "vd", "iv", "nv", "vs", "x", "c", "q", "uv", "p", "ver", "vals", "va", "f", "lv", "w", "av", "vp", "j", "value", "vv", "t", "var"]}}
{"project": "qemu", "commit_id": "23dceda62a3643f734b7aa474fa6052593ae1a70", "target": 0, "func": "int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf)\n\n{\n\n    int i, oi, oi_next, num_insns;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        int n;\n\n\n\n        n = s->gen_last_op_idx + 1;\n\n        s->op_count += n;\n\n        if (n > s->op_count_max) {\n\n            s->op_count_max = n;\n\n        }\n\n\n\n        n = s->nb_temps;\n\n        s->temp_count += n;\n\n        if (n > s->temp_count_max) {\n\n            s->temp_count_max = n;\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time -= profile_getclock();\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time += profile_getclock();\n\n    s->la_time -= profile_getclock();\n\n#endif\n\n\n\n    tcg_liveness_analysis(s);\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->la_time += profile_getclock();\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) {\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = gen_code_buf;\n\n    s->code_ptr = gen_code_buf;\n\n\n\n    tcg_out_tb_init(s);\n\n\n\n    num_insns = -1;\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        uint16_t dead_args = s->op_dead_args[oi];\n\n        uint8_t sync_args = s->op_sync_args[oi];\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        tcg_table_op_count[opc]++;\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, def, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            if (num_insns >= 0) {\n\n                s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n            }\n\n            num_insns++;\n\n            for (i = 0; i < TARGET_INSN_START_WORDS; ++i) {\n\n                target_ulong a;\n\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n\n                a = ((target_ulong)args[i * 2 + 1] << 32) | args[i * 2];\n\n#else\n\n                a = args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n    tcg_out_tb_finalize(s);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n", "idx": 15067, "substitutes": {"s": ["hs", "session", "options", "site", "v", "u", "ts", "its", "states", "sys", "si", "in", "m", "ims", "plugins", "xs", "self", "spec", "h", "set", "qs", "sb", "js", "services", "t", "rates", "ps", "sync", "fs", "o", "ins", "e", "cs", "parts", "ions", "ss", "rows", "ssl", "new", "sq", "gs", "sf", "ges", "is", "c", "sg", "ns", "lines", "settings", "storage", "us", "sites", "l", "ds", "ans", "service", "this", "stats", "http", "ses", "sym", "S", "ops", "comments", "d", "rs", "south", "results", "features", "server", "params", "full", "g", "es", "ks", "ments", "os", "su", "p", "tests", "b", "sets", "f", "w", "groups", "ings", "request", "ls", "r", "conf"], "gen_code_buf": ["gen_codepbuffer", "gen_call_buffer", "gen_codelbuff", "gen_code_queue", "gen_const_uf", "gen_codelbuf", "gen_call_buff", "gen_const_buffer", "gen_map_tab", "gen_call_buf", "gen_const_buf", "gen_codelbuffer", "gen_codeltab", "gen_map_buff", "gen_map_buf", "gen_codepqueue", "gen_code_buff", "gen_codepbuff", "gen_code_uf", "gen_const_buff", "gen_codepbuf", "gen_map_buffer", "gen_call_queue", "gen_code_tab", "gen_code_buffer"], "i": ["it", "d", "o", "e", "pi", "si", "ui", "ti", "num", "ci", "io", "bi", "ip", "c", "phi", "x", "p", "index", "b", "ni", "f", "start", "j", "ii", "I"], "oi": ["obo", "adi", "odi", "ie", "oe", "o", "asi", " bi", "ini", "jc", "oda", "oid", "xi", "ois", "oko", "pi", "ei", "uri", "isi", "si", "iw", "oci", "ai", "ui", "elo", "agi", "ilo", "api", "ti", "edi", "ani", "osi", "eni", "oji", "ik", "ci", "ahi", "uci", "bi", "qi", "phi", "ami", "igi", "imi", "ji", "ki", "flo", "ogi", "nu", "ni", "zi", "ski", "ori", "oni", "ii", "yi", "oa"], "oi_next": ["ci_current", "oi_later", "oi_last", "oi_current", "ci_next", "ci_last", "oi_start", "ci_later", "ci_start", "ci_first", "oi_first"], "num_insns": ["num_insn", "num_inxs", "num_outns", "num_outxs", "num_inn", "num_wincs", "num_incs", "num_inccs", "num_outn", "num_winn", "num_pinns", "num_outnas", "num_inns", "num_incls", "num_insnas", "num_insls", "num_winns", "num_insxs", "num_pinn", "num_incn", "num_inscs", "num_pinnas", "num_pinxs", "num_inls", "num_innas", "num_incns", "num_winls"], "n": ["not", "en", "ne", "d", "o", "adj", "nn", "nor", "cn", "pn", "ng", "v", "nt", "count", "e", "nc", "pos", "fn", "l", "conn", "nin", "nil", "na", "y", "an", "m", "mn", "sn", "dn", "nat", "num", "un", "k", "net", "z", "nb", "ln", "c", "max", "N", "no", "ns", "p", "syn", "x", "none", "b", "on", "nu", "ni", "f", "min", "name", "w", "non", "j", "r", "t", "len", "number", "span", "nan"], "op": ["Op", "omp", "oper", "hop", "oc", "data", "obj", "expr", "OP", "sp", "ype", "prev", "proc", "up", "num", "block", "operation", "id", "opt", "init", "node", "ip", "ode", "one", "oop", "name", "option", "ops"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n    int ret;\n\n    uint32_t i, j, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            qemu_sglist_init(&ehci->isgl, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = USB_RET_NODEV;\n\n            for (j = 0; j < NB_PORTS; j++) {\n\n                port = &ehci->ports[j];\n\n                dev = port->dev;\n\n\n\n                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {\n\n                    continue;\n\n                }\n\n\n\n                ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 15077, "substitutes": {"ehci": ["ehli", "ahli", "ehcin", "ehc", "ahdi", "hessli", "ahki", "evdi", "ehki", "ohci", "ohc", "evci", "ekli", "ihdi", "ecc", "evki", "ahcin", "hessCI", "ohco", "ihco", "ekCI", "evc", "ahci", "ohcu", "ohcin", "ecci", "ecdi", "ehcu", "ihci", "ahc", "ihcin", "ehco", "hessci", "ahco", "ekci", "ihcu", "ohdi", "ehCI", "hesscu", "ekcu", "ahCI", "ihc", "ehdi", "ahcu", "ecki"], "itd": ["itdd", "ITd", "ITe", "ctdj", "mitds", "ittingD", "itsl", "itds", " itl", "pitd", "ipds", "idds", "pitD", "mitl", "ithl", "ipD", "ittingd", "idl", "iterdj", "itl", "ITdd", "itsdn", "editl", "ITdat", " itds", "ipl", "ctdn", "itsD", "iterd", "ctl", "ipd", "ittingds", "ctds", "ittingdn", "mitD", "itD", "pitds", "ithdd", "iterds", "ite", "editd", "ithd", "idD", "itdat", "ctD", " itD", "iddat", " ite", "ide", "itsds", "mitd", "iterD", "ITds", "ITdj", "pitl", "ITl", "itsd", "ithds", "itdn", "idd", "editds", "itsdd", " itdat", "ITD", "ctd", "itdj"], "port": ["test", "ports", "Port", "apter", "op", "pos", "pt", "rest", "tun", "pc", "pp", "post", "wp", "host", "proc", "config", "iv", "ip", "ort", "http", "cp", "type", "dp", "ind", "gp", "select", "plugin"], "dev": ["debug", "app", "ev", "cam", " priv", "priv", " device", "dist", "plug", "pkg", "disk", "pub", "conn", "def", "pad", "grad", "Dev", "proc", "reg", "gu", "device", "ver", "w", "diff", "conf", "pro", "ad"], "ret": [" resp", "mi", "all", "resp", "nt", "count", "result", "eth", "val", "res", " RET", "_", "rc", "proc", "mem", "no", " result", "lit", "re", "out", "RET", " reply", "conn", "Ret", "code"], "i": ["adi", "it", "ie", "di", "o", "gi", "chi", "ini", "iu", "mi", "fi", "x", "t", "multi", "v", "li", "e", "xi", "u", "inner", "l", "pi", "uri", "si", "y", "in", "ai", "ui", "ti", "ix", "ani", "k", "n", "ci", "io", "id", "iv", "bi", "is", "ip", "phi", "c", "qi", "oi", "ji", "ki", "p", "cli", "index", "ri", "b", "uli", "ni", "zi", "ind", "info", "ori", "ii", "I", "yi"], "j": ["it", "sync", "adj", "en", "uni", "jp", "li", "pos", "pi", "rel", "delay", "job", "ai", "vision", "slice", "pri", "aj", "eni", "ami", "slave", "ji", "index", "ni", "ind", "ori", "ii", "loc", "r"], "len": ["en", "lan", "le", "fin", "nn", "bl", "all", "la", "nt", "li", "ll", "Len", "pos", "fl", "count", "ld", "fn", "l", "length", "size", "lt", "den", "val", "lon", "lu", "fat", "full", "el", "limit", "elt", "valid", "lin", "fun", "lc", "dl", "url", "vert", "un", "lim", "n", "rev", "ln", "line", "ell", "ler", "lib", "lit", "coll", "sl", "il", "min", "lf", "f", "lang", "non", "loc", "span", "ann"], "pid": ["di", "vid", "ini", "mi", "pn", "po", "mode", "pos", "pc", "pm", "pi", "pp", "delay", "pad", "path", "ai", "uid", "pri", "proc", "pu", "ix", "id", "pa", "ip", "cp", "ni", "ind", "ori"], "dir": ["prefix", "part", "d", "iter", "di", "dr", "der", "md", "Dir", "mode", "dist", "pos", "pkg", "direction", "desc", "wd", "rel", "path", "level", "doc", "dep", "grad", "det", "fd", "mod", "dim", "dn", "ref", "req", "order", "sl", "direct", "ind", "diff", "dy", "loc", "orient", "dest"], "devaddr": ["evaddress", "evaddr", "devAddress", "veraddr", " devaddress", "devdr", "veraddress", "evAddress", "verdr", " devAddress", "deviceAddress", "devptr", "devaddress", "evptr", "deviceaddress", " devptr", " devdr", "deviceaddr", "verptr", "testptr", "testaddr", "deviceptr", "testdr", "testaddress"], "endp": ["endedpc", "endedpoint", "startf", "webpoint", " endf", "endvp", "webp", "startpoint", "endedf", "webpc", "startp", "endf", "endpc", " endpoint", "idpc", "webvp", " endpc", "startpc", "idp", "idvp", "endedp", " endvp", "idpoint", "endpoint"], "pg": ["ps", "ss", "ha", "ct", "mp", "pe", "pn", "eg", "ng", "ager", "pt", "pkg", "ff", "pc", "pub", "cmd", "ht", "og", "pp", "peg", "post", "qa", "pad", "mag", "wp", "db", "rog", "cc", "tag", "ig", "gh", "sq", "quad", "xp", "seq", "pool", "config", "pu", "reg", "g", "k", "jj", "org", "neg", "pa", "ww", "PG", "cp", "pse", "kk", "p", "ph", "col", "bb", "gn", "gg", "gen", "mb", "tg", "pl", "round", "ijk", "gp", "rg", "ag", "conn", "mg", "pb"], "off": ["o", "Off", "own", "shift", "oc", "front", "ord", "opp", "down", "raw", "md", "pull", "ng", "mode", "op", "pos", "ask", "pt", "ff", "offer", "end", "cmd", "output", "length", "open", "style", "online", "alt", "def", "post", "lon", "anon", "offset", "num", "block", "low", "id", "over", "ip", "slave", "rol", "art", "addr", "now", "no", "type", "on", "half", "offs", "start", "out", "load", "diff", "option", "value", "OFF", "non", "oa"], "ptr1": ["pointer01", "ptone", "pointer1", "ptrone", "padn", "pointer3", "pointerU", "padU", " ptr01", "pad3", "pointer100", "len2", "ptr100", "pad2", "pad1", "len1", "pt100", "pt01", "pointer2", "ptr01", "len3", " ptr100", "ptrn", "pointern", "pt1", "ptr3", " ptrone", "ptrU", " ptrn", " ptrU", "pointerone"], "ptr2": ["plug2", " ptr5", "ptrTwo", " ptr4", "ptr182", " ptrb", "pt2", "ptr52", "plugTwo", "pointer52", " ptr182", "req52", "pointer62", "ptr5", "reqtwo", "pointer182", "pointer4", "ptr62", "pt4", "ptrtwo", " ptrL", "pointerTwo", "ptrL", "sth2", "ptL", "pointerb", "pointer2", "sth182", "sthb", "sth5", "ptrb", "reqTwo", " ptr62", "plug52", "ptr4", "pointer5", "pointerL", "req2", "pointertwo", "plugtwo", "pt62"], "max": ["part", "wh", "height", "patch", "po", "dist", "count", "pos", "comb", "con", "end", "length", "size", "strip", "def", "pad", "total", "depth", "post", "Max", "limit", "mod", "only", "num", "parent", "scale", "k", "last", "n", "id", "opt", "cache", "x", "q", "c", "no", "p", "ax", "cl", "MAX", "on", "order", "none", "range", "cat", "col", "ph", "min", "name", "ver", "w", "out", "r", "pass", "sum", "conf"], "mult": ["prefix", "part", "wh", "gap", "batch", "dom", "temp", "mut", "multi", "patch", "pull", "per", "mode", "dist", "count", "comb", "mu", "util", "mun", "length", "pair", "delay", "pad", "lat", "zip", "grad", "quant", "phase", "mod", "pool", "seq", "fun", "parent", "vert", "man", "low", "cur", "compl", "ul", "Mult", "req", "mot", "common", "coll", "multipl", "ver", "pl", "mount", "master", "diff", "sum", "multiple"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n", "idx": 15082, "substitutes": {"v": ["sv", "o", "vm", "e", "u", "V", "l", "ov", "val", "vi", "m", "vt", "hw", "volt", "k", "inv", "self", "n", "vc", "iv", "vd", "x", "q", "vs", "i", "vu", "uv", "c", "p", "f", "lv", "vim", "vp", "j", "vv", "t", "vis"], "obj": ["o", "func", "office", "jp", "data", "txt", "po", "nt", "pt", "fn", "act", "pos", "op", "ov", "abi", "ob", "val", "object", "objects", "api", "inst", "ant", "n", "org", "os", "ctx", "opt", "node", "so", "x", "art", "ns", "p", "lib", "Obj", "w", "bj", "js", "j", "ref", "oa"], "qiv": ["quiv", "qivable", "requivist", "qsiv", "qoc", "ziv", "viewriv", " qivist", "qtIV", "Qoc", "viewivist", " qIV", "Qiv", "qoi", "qivist", "requerv", "requivable", " qriv", "zerv", "qtivist", "qsoc", " qoc", "qtriv", "Qivist", "qIV", "Qoi", "qriv", "quivist", "qsoi", "zivist", "qtiv", "qsivist", "qerv", "zivable", "quivable", " qoi", "viewiv", "requiv", "querv", "viewIV"], "tos": [" tobi", " tis", "ttotes", "xtos", "Tis", "Totes", "ptos", "tops", "Tobi", " tops", "ptobi", "xtOS", "pto", "To", "ttros", "tros", "ptros", "ttos", "tobi", "tOS", "ptoss", "toS", "ptotes", "tis", "xto", "Toss", "toss", "to", "Tos", "ToS", "ttoss", "ttoS", "ptis", "Tros", "TOS", "ttops", "tto", "xtoS", "Tops", "ptops", "ttOS", "totes"]}}
{"project": "FFmpeg", "commit_id": "a443a2530d00b7019269202ac0f5ca8ba0a021c7", "target": 1, "func": "static int vmd_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVStream *st;\n\n    unsigned int toc_offset;\n\n    unsigned char *raw_frame_table;\n\n    int raw_frame_table_size;\n\n    offset_t current_offset;\n\n    int i, j;\n\n    unsigned int total_frames;\n\n    int64_t video_pts_inc = 0;\n\n    int64_t current_video_pts = 0;\n\n    unsigned char chunk[BYTES_PER_FRAME_RECORD];\n\n    int lastframe = 0;\n\n\n\n    /* fetch the main header, including the 2 header length bytes */\n\n    url_fseek(pb, 0, SEEK_SET);\n\n    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n\n        return AVERROR_IO;\n\n\n\n    vmd->audio_sample_counter = 0;\n\n    vmd->audio_frame_divisor = 1;\n\n    vmd->audio_block_align = 1;\n\n\n\n    /* start up the decoders */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR_NOMEM;\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    vmd->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_VMDVIDEO;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = LE_16(&vmd->vmd_header[12]);\n\n    st->codec->height = LE_16(&vmd->vmd_header[14]);\n\n    st->codec->time_base.num = 1;\n\n    st->codec->time_base.den = 10;\n\n    st->codec->extradata_size = VMD_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n\n\n\n    /* if sample rate is 0, assume no audio */\n\n    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);\n\n    if (vmd->sample_rate) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR_NOMEM;\n\n        av_set_pts_info(st, 33, 1, 90000);\n\n        vmd->audio_stream_index = st->index;\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n        st->codec->codec_id = CODEC_ID_VMDAUDIO;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;\n\n        st->codec->sample_rate = vmd->sample_rate;\n\n        st->codec->block_align = vmd->audio_block_align =\n\n            LE_16(&vmd->vmd_header[806]);\n\n        if (st->codec->block_align & 0x8000) {\n\n            st->codec->bits_per_sample = 16;\n\n            st->codec->block_align = -(st->codec->block_align - 0x10000);\n\n            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);\n\n        } else {\n\n            st->codec->bits_per_sample = 8;\n\n\n        st->codec->bit_rate = st->codec->sample_rate *\n\n            st->codec->bits_per_sample * st->codec->channels;\n\n\n\n        /* for calculating pts */\n\n        vmd->audio_frame_divisor = st->codec->channels;\n\n\n\n        video_pts_inc = 90000;\n\n        video_pts_inc *= st->codec->block_align;\n\n        video_pts_inc /= st->codec->sample_rate;\n\n        video_pts_inc /= st->codec->channels;\n\n    } else {\n\n        /* if no audio, assume 10 frames/second */\n\n        video_pts_inc = 90000 / 10;\n\n\n\n\n    toc_offset = LE_32(&vmd->vmd_header[812]);\n\n    vmd->frame_count = LE_16(&vmd->vmd_header[6]);\n\n    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);\n\n    url_fseek(pb, toc_offset, SEEK_SET);\n\n\n\n    raw_frame_table = NULL;\n\n    vmd->frame_table = NULL;\n\n    raw_frame_table_size = vmd->frame_count * 6;\n\n    raw_frame_table = av_malloc(raw_frame_table_size);\n\n\n\n\n\n    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));\n\n    if (!raw_frame_table || !vmd->frame_table) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_NOMEM;\n\n\n    if (get_buffer(pb, raw_frame_table, raw_frame_table_size) !=\n\n        raw_frame_table_size) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_IO;\n\n\n\n\n    total_frames = 0;\n\n    for (i = 0; i < vmd->frame_count; i++) {\n\n\n\n        current_offset = LE_32(&raw_frame_table[6 * i + 2]);\n\n\n\n        /* handle each entry in index block */\n\n        for (j = 0; j < vmd->frames_per_block; j++) {\n\n            int type;\n\n            uint32_t size;\n\n\n\n            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);\n\n            type = chunk[0];\n\n            size = LE_32(&chunk[2]);\n\n            if(!size)\n\n                continue;\n\n            switch(type) {\n\n            case 1: /* Audio Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                total_frames++;\n\n                break;\n\n            case 2: /* Video Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                vmd->frame_table[total_frames].pts = current_video_pts;\n\n                if (lastframe) {\n\n                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;\n\n\n                lastframe = total_frames;\n\n                total_frames++;\n\n                break;\n\n\n            current_offset += size;\n\n\n        current_video_pts += video_pts_inc;\n\n\n\n\n    av_free(raw_frame_table);\n\n\n\n    vmd->current_frame = 0;\n\n    vmd->frame_count = total_frames;\n\n\n\n    return 0;\n", "idx": 15094, "substitutes": {"s": ["ps", "fs", "rs", "v", "sc", "cs", "sa", "e", "ts", "ds", "sys", "si", "ss", "ssl", "an", "m", "sp", "service", "se", "sq", "gs", "sec", "a", "bs", "g", "es", "ks", "sts", "os", "spec", "ctx", "sd", "c", "su", "sg", "ns", "p", "qs", "b", "sl", "f", "sb", "ses", "ls", "services", "S"], "ap": ["mp", "AP", "ar", "tp", "jp", "amp", "op", "att", "pac", "pi", "pp", "cap", "wp", "attr", "sp", "al", " p", "ac", "np", "am", "pa", "bp", "cp", "aps", "ams", "as", "pl", "au", "arp"], "vmd": ["vmad", "gmand", "evmd", "vda", "svmm", "svmad", "ivda", "evdm", "ldd", "lcmd", "vcdoc", "nmt", "Vdm", "ivmd", "ncmd", "svmd", "evmm", " vMD", "vdoc", "ervmd", "gcd", "ivMD", "Vmd", "tmad", "vvmd", "nmd", "varicmd", "varidm", "svda", " vmm", "VMD", "vmt", " vmand", "Vdi", "evMD", "tmd", "ndoc", "vdi", "ervdoc", "ivmad", "Vdd", "Vmad", "gmd", "svdm", "ldi", "vmand", "svMD", "nmad", "ervcmd", "vcmad", " vdi", " vmad", " vdd", "vMD", "vvcmd", "svcmd", " vcmd", "vmm", "vvmand", "varimm", " vdm", "lmm", "vcmd", " vmt", "Vmm", " vcd", "gcmd", "ldm", "Vcmd", "ervmm", "tcmd", "varimd", "evcmd", "vvcd", "vccmd", "ivmm", "tmt", "ervmad", "ervda", "vdd", "lMD", "vdm", "lmd", "vcd"], "pb": ["fp", "prot", "bm", "ba", "mp", "cpp", "hub", "tmp", "uf", "bf", "bc", "pc", "pm", "cb", "fb", "ib", "wb", "pp", "orb", "rob", "ob", "summary", "pg", "db", "wp", "PB", "uc", "lb", "sf", "bs", "bh", "rb", "lp", "ctx", "pa", "fc", "bp", "ppa", "cp", "p", "bps", "b", "lab", "mb", "sb", "pl", "dp", "ab", "abb", "eb", "ub", "buffer", "parser", "asm", "buf", "gb", "platform"], "st": ["ST", "stress", "sc", "St", "obj", "ts", "stim", "gest", "se", "bt", "sec", "sta", "sd", "sh", "set", "sr", "src", "sb", "start", "cr", "t", "stack", "ct", "nt", "rt", "lt", "stand", "ss", "inst", "sf", "str", "sts", "mt", "sw", "ist", "th", "et", "ft", "bl", "nd", "sa", "rd", "rest", "end", "l", "ste", "sn", "tt", "fr", "est", "stage", "art", "put", "ast", "sl", "stream", "td", "ost", "sth", "std", "irst", "d", "dr", "ust", "ld", "pt", "post", "sp", "sett", "stable", "cl", "kt"], "toc_offset": ["toc_address", " orig_address", "tocamsource", "toc_slice", "toc67address", " orig_slice", " orig_source", "tocamaddress", "toc67source", "toc67slice", "toc67offset", "tocamoffset", "tocamslice", " orig_offset", "toc_source"], "raw_frame_table": ["raw_frames_count", "raw_frame_count", "raw_frame_size", "raw_frames_buffer", "raw_frame_buffer", "raw_frames_table", "raw_frames_size"], "raw_frame_table_size": ["raw_frame_table_SIZE", "raw_frame_family_size", "raw_frame_table_len", "raw_frame_family_SIZE", "raw_frame_family_len"], "current_offset": ["current_object", "loadaloffset", "load_position", "currentalposition", "loadaltable", "loadalposition", "loadalobject", "load_table", "currentaloffset", "currentaltable", "current_table", "currentalobject", "load_object", "load_offset", "current_position"], "i": ["d", "mi", "e", "u", "l", "pi", "y", "in", "ai", "m", "ui", "z", "n", "ci", "io", "x", "c", "h", "p", "index", "b", "f", "start", "ind", "ii", "I"], "j": ["adj", "o", "step", "J", "position", "jp", "v", "pos", "obj", "l", "m", "aj", "k", "z", "n", "ij", "q", "ji", "p", "col", "b", "f", "jump", "ind", "r", "ii"], "total_frames": ["total_flows", " total_cycles", "total_fps", " total_flows", "total_cycles", " total_fps"], "chunk": ["characket", "charblock", "chunks", "Chunks", "chblock", "charunk", " chunkacket", " chunkblock", " chunkunks", " chunkunk", "chacket", "Chacket", "Chblock", "charunks", "Chunk"]}}
{"project": "FFmpeg", "commit_id": "99e5a9d1ea2a61ac9429427431e5b9c2fefb76a5", "target": 0, "func": "void dsputil_init_arm(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    int idct_algo= avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = c->put_pixels_clamped;\n\n    ff_add_pixels_clamped = c->add_pixels_clamped;\n\n\n\n    if (avctx->lowres == 0) {\n\n        if(idct_algo == FF_IDCT_AUTO){\n\n#if   HAVE_IPP\n\n            idct_algo = FF_IDCT_IPP;\n\n#elif HAVE_NEON\n\n            idct_algo = FF_IDCT_SIMPLENEON;\n\n#elif HAVE_ARMV6\n\n            idct_algo = FF_IDCT_SIMPLEARMV6;\n\n#elif HAVE_ARMV5TE\n\n            idct_algo = FF_IDCT_SIMPLEARMV5TE;\n\n#else\n\n            idct_algo = FF_IDCT_ARM;\n\n#endif\n\n        }\n\n\n\n        if(idct_algo==FF_IDCT_ARM){\n\n            c->idct_put= j_rev_dct_ARM_put;\n\n            c->idct_add= j_rev_dct_ARM_add;\n\n            c->idct    = j_rev_dct_ARM;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARM){\n\n            c->idct_put= simple_idct_ARM_put;\n\n            c->idct_add= simple_idct_ARM_add;\n\n            c->idct    = simple_idct_ARM;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#if HAVE_ARMV6\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV6){\n\n            c->idct_put= ff_simple_idct_put_armv6;\n\n            c->idct_add= ff_simple_idct_add_armv6;\n\n            c->idct    = ff_simple_idct_armv6;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n#endif\n\n#if HAVE_ARMV5TE\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV5TE){\n\n            c->idct_put= simple_idct_put_armv5te;\n\n            c->idct_add= simple_idct_add_armv5te;\n\n            c->idct    = simple_idct_armv5te;\n\n            c->idct_permutation_type = FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_IPP\n\n        } else if (idct_algo==FF_IDCT_IPP){\n\n            c->idct_put= simple_idct_ipp_put;\n\n            c->idct_add= simple_idct_ipp_add;\n\n            c->idct    = simple_idct_ipp;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_NEON\n\n        } else if (idct_algo==FF_IDCT_SIMPLENEON){\n\n            c->idct_put= ff_simple_idct_put_neon;\n\n            c->idct_add= ff_simple_idct_add_neon;\n\n            c->idct    = ff_simple_idct_neon;\n\n            c->idct_permutation_type = FF_PARTTRANS_IDCT_PERM;\n\n        } else if ((CONFIG_VP3_DECODER || CONFIG_VP5_DECODER || CONFIG_VP6_DECODER || CONFIG_THEORA_DECODER) &&\n\n                   idct_algo==FF_IDCT_VP3){\n\n            c->idct_put= ff_vp3_idct_put_neon;\n\n            c->idct_add= ff_vp3_idct_add_neon;\n\n            c->idct    = ff_vp3_idct_neon;\n\n            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n#endif\n\n        }\n\n    }\n\n\n\n    c->put_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_arm;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_arm;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_arm;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_arm;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_arm;\n\n    c->put_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_pixels_tab[1][1] = put_pixels8_x2_arm;\n\n    c->put_pixels_tab[1][2] = put_pixels8_y2_arm;\n\n    c->put_pixels_tab[1][3] = put_pixels8_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_arm;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_arm;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels8_xy2_arm;\n\n\n\n#if HAVE_ARMV5TE\n\n    c->prefetch = ff_prefetch_arm;\n\n#endif\n\n\n\n#if HAVE_IWMMXT\n\n    dsputil_init_iwmmxt(c, avctx);\n\n#endif\n\n#if HAVE_ARMVFP\n\n    ff_float_init_arm_vfp(c, avctx);\n\n#endif\n\n#if HAVE_NEON\n\n    ff_dsputil_init_neon(c, avctx);\n\n#endif\n\n}\n", "idx": 15106, "substitutes": {"c": ["enc", "d", "ct", "cu", "com", "cont", "t", "v", "cm", "tc", "sc", "cs", "con", "bc", "C", "nc", "e", "cf", "pc", "cit", "cd", "l", "u", "ec", "cc", "dc", "conf", "cmp", "uc", "lc", "rc", "config", "g", "cus", "k", "z", "rec", "ac", "vc", "ch", "ce", "ctx", "cur", "ci", "can", "cache", "context", "fc", "h", "cp", "p", "cl", "cy", "coll", "co", "ctrl", "ic", "f", "cr", "ca", "mc", "call", "r", "conn", "cv"], "avctx": ["avcmp", "vercmp", "afcontext", "AVcontext", "Avcontext", "avcca", " avcontext", "AVctrl", " avctrl", "Avctx", "AVcmp", "navctx", "abcmp", " avconn", "abctx", "navcca", "verctx", "afconn", "afcmp", "afctx", "navcmp", "AVctx", "abcontext", "avctrl", "afcca", "Avctrl", "Avconn", "verconn", "vercontext", "AVcca", "navcontext", "avconn", "avcontext", "AVconn", "abconn"]}}
{"project": "FFmpeg", "commit_id": "7a4f74eed51f914e9bbfebaffd4a92ac6791f819", "target": 0, "func": "av_cold void ff_h264_free_context(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    ff_h264_free_tables(h);\n\n\n\n    if (h->DPB) {\n\n        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n\n            ff_h264_unref_picture(h, &h->DPB[i]);\n\n        av_freep(&h->DPB);\n\n    }\n\n\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        av_freep(&h->slice_ctx[i].rbsp_buffer);\n\n    av_freep(&h->slice_ctx);\n\n    h->nb_slice_ctx = 0;\n\n\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n\n        av_freep(h->sps_buffers + i);\n\n\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n\n        av_freep(h->pps_buffers + i);\n\n}\n", "idx": 15108, "substitutes": {"h": ["hs", "eh", "ha", "d", "o", "ssh", "v", "e", "u", "oh", "uh", "rh", "l", "ht", "hd", "work", "ih", "hist", "header", "hm", "m", "hh", "this", "gh", "q", "beh", "he", "html", "hw", "hp", "hl", "host", "g", "bh", "k", "n", "adh", "ch", "ctx", "hr", "home", "sh", "ah", "H", "c", "hi", "context", "x", "p", "FH", "ph", "him", "b", "http", "f", "w", "r", "t"], "i": ["it", "d", "ie", "di", "o", "gi", "available", "ini", "iu", "fi", "mi", "x", "t", "v", "multi", "li", "e", "u", "xi", "mu", "l", "pi", "abi", "uri", "si", "vi", "in", "y", "ai", "ui", "m", "slice", "lc", "ti", "g", "k", "ix", "z", "n", "eni", "ci", "io", "id", "bi", "init", "qi", "ip", "oi", "phi", "c", "info", "ji", "hi", "p", "index", "ri", "b", "cli", "ni", "f", "zi", "j", "r", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 15115, "substitutes": {"ctx": ["client", "sync", "ct", "ctr", "connection", "cn", "cu", "cgi", "git", "exec", "cm", "tc", "sc", "cs", "nc", "bc", "pkg", "sci", "pc", "cf", "cmd", "cfg", "cb", "cd", "kb", "qt", "qa", "anc", "Context", "cc", "cmp", "dc", "cdn", "hw", "xs", "lc", "config", "cca", "ck", "cus", "vc", "ci", "ce", "handler", "ch", "context", "c", "conv", "cp", "cli", "scope", "component", "pai", "req", "cl", "kw", "ctrl", "tx", "src", "kt", "acl", "ca", "cr", "utils", "section", "xc", "loc", "conn", "css", "cas", "cv"], "blocking": ["binary", "sync", "checking", "boxing", "consuming", "prefix", "period", "locking", "using", "writing", "moving", "regular", "loop", "calling", "testing", "bc", "training", "ocking", "random", "always", "working", "locked", "length", "quiet", "starting", "blocks", "balanced", "full", "ssl", "rolling", "broad", "padding", "queue", "pool", "channel", "block", "latest", "lock", "ing", "rising", "poll", "complete", "binding", "cli", "interrupted", "negative", "killing", "joining", "forcing", "holding", "buffer", "loading", "clock", "remote", "background", "running", "linear", "changing"], "node": ["client", "sync", "part", "document", "enc", "native", "route", "nn", "null", "connection", "hub", "edge", "content", "global", "local", "tree", "source", "fn", "worker", "package", "cmd", "server", "query", "post", "path", "callback", "full", "object", "root", "leaf", "cdn", "host", "parent", "config", "num", "view", "self", "n", "handler", "id", "context", "slave", "peer", "index", "component", "missing", "instance", "plugin", "name", "child", "master", "load", "loader", "call", "remote", "nw", "event", "ref", "none", "live", "Node"], "i": ["it", "part", "ie", "di", "o", "gi", "my", "ini", "mi", "iu", "fi", "t", "v", "li", "e", "xi", "image", "inner", "end", "l", "pi", "abi", "uri", "val", "si", "you", "in", "y", "ai", "ui", "m", "ti", "ix", "k", "eni", "n", "ci", "id", "io", "bi", "qi", "ip", "x", "phi", "h", "oi", "hi", "c", "p", "index", "ri", "b", "ni", "f", "start", "out", "ind", "j", "ii", "I"], "ret": ["part", "ft", "success", "hash", "resp", "nt", "pat", "count", "pt", "result", "feat", "obj", "ut", "rt", "att", "val", "job", "def", "res", "full", "grad", "det", "reply", "len", "error", "rc", "fun", "num", "reg", "rets", "arg", "lock", "rev", "mem", "bot", "status", "cat", "lit", "rep", "sr", "arr", "re", "RET", "flag", "err", "back", "bit", "pass", "xt", "ref", "alt", "Ret"], "progress": ["done", "debug", "update", "part", "step", " error", "live", "file", "success", "exec", "action", "content", "data", "track", "resp", "results", "dist", "mode", "act", "result", "process", "val", "path", "callback", " success", "grade", "queue", "partial", "sort", "grad", "state", "bar", "full", "reply", "recent", "error", "rc", "proc", "skip", " status", "current", "complete", "push", "addr", "close", "status", "active", "p", " result", "wait", "quick", "Progress", "call", "err", "remote", "stat", "move", "event", "forward", "len", "show"], "timeout": ["client", "sync", "period", "function", "span", "connection", "all", "temp", "nt", "tc", "command", "range", "until", "cycle", "always", "duration", "size", "server", "delay", "length", "val", "slot", "nil", "course", "qt", "never", "ssl", "service", "limit", "offset", "reply", "len", "Timeout", "time", "unit", "error", "pool", "parent", "block", "lock", "io", "cache", "poll", "timer", "window", "target", "none", "interrupted", "missing", "wait", "sleep", "scroll", "type", "table", "out", "confirmed", "disabled", "call", "option", "term", "cookie", "socket", "remote", "event", "conn", "alt", "live", "security"], "walking_handlers": ["walking_handlerers", "walking_hostlers", "walking_handries", "walking_countries", "walking_handlerl", "walking_hostries", "walking_handlerlers", "walking_handlelers", "walking_countler", "walking_childles", "walking_handleles", "walking_handleler", "walking_handles", "walking_childler", "walking_handlerler", "walking_handl", "walking_handlerles", "walking_hosters", "walking_counters", "walking_handler", "walking_childlers", "walking_handlel", "walking_handlerries", "walking_handers", "walking_childl", "walking_hostler", "walking_countlers"], "epoll_handler": ["eprot_handle", "epollinghandle", "epoll_object", "epolledconnection", "epoll_function", "epollerhandler", "eprot_manager", "epoll_pointer", "epolledmanager", "epollo_child", "epollingfunction", "eprot_pointer", "epolledpointer", "epoll_child", "eprot_connection", "epole_folder", "epollerhand", "epollo_handle", "epoll_hand", "epole_function", "epoll_handle", "epollingchild", "epoll_manager", "eprot_handler", "epollo_function", "epole_handler", "epoll_connection", "epollermanager", "epollo_handler", "epollinghandler", "epole_object", "eprot_hand", "epollerhandle", "epolledhandler", "epoll_folder"]}}
{"project": "FFmpeg", "commit_id": "252c0bfdc014c1fb6ad4fe06242c7beca58a6b41", "target": 1, "func": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}", "idx": 15124, "substitutes": {"s": ["fs", "caps", "d", "o", "session", "v", "e", "cs", "ts", "ss", "ssl", "m", "g", "n", "c", "i", "p", "ns", "b", "f", "js", "ses", "ms", "w", "r", "services", "S", "t"], "pic": ["fs", "o", "cons", "Pic", "oc", "mi", "fi", "image", " fn", "fn", "pc", " pc", "in", "pins", "proc", " p", "arg", "ac", "pa", "avi", "fc", "mac", "p", "pict", "ic", "pin", "img"]}}
{"project": "FFmpeg", "commit_id": "d1a58afb95f68c5375b4a7556317d835108509ed", "target": 1, "func": "static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    PutBitContext bs;\n\n    int i, len;\n\n    uint8_t loas_header[] = \"\\x56\\xe0\\x00\";\n\n    uint8_t *buf = NULL;\n\n\n\n    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)\n\n        return ff_raw_write_packet(s, pkt);\n\n\n\n    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {\n\n        av_log(s, AV_LOG_ERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (pkt->size > 0x1fff)\n\n        goto too_large;\n\n\n\n    buf = av_malloc(pkt->size+1024);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    init_put_bits(&bs, buf, pkt->size+1024);\n\n\n\n    latm_write_frame_header(s, &bs);\n\n\n\n    /* PayloadLengthInfo() */\n\n    for (i = 0; i <= pkt->size-255; i+=255)\n\n        put_bits(&bs, 8, 255);\n\n\n\n    put_bits(&bs, 8, pkt->size-i);\n\n\n\n    /* The LATM payload is written unaligned */\n\n\n\n    /* PayloadMux() */\n\n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n\n        // Convert byte-aligned DSE to non-aligned.\n\n        // Due to the input format encoding we know that\n\n        // it is naturally byte-aligned in the input stream,\n\n        // so there are no padding bits to account for.\n\n        // To avoid having to add padding bits and rearrange\n\n        // the whole stream we just remove the byte-align flag.\n\n        // This allows us to remux our FATE AAC samples into latm\n\n        // files that are still playable with minimal effort.\n\n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n\n    } else\n\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n\n\n\n    avpriv_align_put_bits(&bs);\n\n    flush_put_bits(&bs);\n\n\n\n    len = put_bits_count(&bs) >> 3;\n\n\n\n    if (len > 0x1fff)\n\n        goto too_large;\n\n\n\n    loas_header[1] |= (len >> 8) & 0x1f;\n\n    loas_header[2] |= len & 0xff;\n\n\n\n    avio_write(pb, loas_header, 3);\n\n    avio_write(pb, buf, len);\n\n\n\n    av_free(buf);\n\n\n\n    return 0;\n\n\n\ntoo_large:\n\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n\n    av_free(buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 15125, "substitutes": {"s": ["ps", "client", "fs", "sync", "d", "ops", "sv", "o", "us", "session", "south", "data", "v", "sc", "cs", "e", "sa", "u", "sci", "fts", "ts", "server", "ds", "bis", "sys", "si", "ss", "space", "ssl", "service", "conf", "sq", "gs", "sf", "plugins", "xs", "g", "ks", "self", "ubs", "n", "os", "spec", "stats", "is", "ches", "c", "http", "su", "sg", "p", "ns", "qs", "b", "sl", "sets", "aws", "f", "sb", "ses", "js", "w", "ls", "services", "socket", "S", "r", "t", "sym", "support"], "pkt": ["chkt", "tpkt", "pwk", "hacket", "Pcht", "cpacket", "npet", "pkg", "fkt", "tpet", " pcht", "psth", " pwk", "perkt", "Pkg", "backet", "npacket", "ppelt", "mkt", "fant", "ppkt", "spwk", "pnt", "Pnt", " pqt", " pnt", "pett", "peracket", "cpkt", "perwk", "bet", "qkt", "chet", "fet", "chacket", " pkg", "pqt", "spelt", "fsth", "spkt", "pet", "qacket", "ppcht", "ipacket", "melt", "spct", "ipet", "chcht", "bqt", "het", "met", "ipkt", "pct", "tpacket", " pett", "pelt", "bkt", "Piece", "psdt", "pskt", "periece", "Pant", " pdt", "Pett", "Pwk", " piece", " psth", "psacket", "pcht", " pant", "Pkt", "Pelt", "psct", "cpet", "jcht", "spacket", " pelt", "qcht", "ppacket", "macket", "spnt", "Pdt", " packet", "ipcht", "tpelt", "Pct", "fnt", " pet", "hkt", "npkt", "packet", "qant", "jkt", "cpkg", "hett", "piece", "jacket", "Psth", "Packet", "pdt", "Pet", "pant", "npelt", "jelt", "facket", "cpant", "Pqt", " pct"], "pb": ["fp", "prot", "bm", "ps", "mp", "cpp", "tp", "jp", "uf", "tc", "bc", "obj", "pc", "pm", "cb", "fb", "wb", "wp", "summary", "db", "pg", "PB", "pd", "lb", "plugins", "typ", "lc", "proc", "bh", "rb", "lp", "np", "ctx", "pa", "fc", "bp", "ppa", "p", "bps", "sb", "pl", "dp", "ab", "ses", "ub", "gb", "vp", "py", "platform", "pro", "cv"], "bs": ["boxes", "pos", "ts", "its", "cb", "fb", " bc", "Bs", "lb", "nos", "bits", "bytes", "qs", "sb", "js", " cx", "bid", "BT", "ps", "fs", "ins", "bf", "cs", "pc", "outs", "ss", "bos", "BS", "gs", "BC", "iss", "bi", "ns", "bps", "vals", "tx", "lines", "bis", "us", "bl", "bas", "bc", "bu", "ds", "bes", "blocks", "bus", "obs", "ubs", "bp", "vs", "cks", "bugs", "ses", "las", "lbs", " bos", "bn", "br", "base", "lins", "g", "ros", "ks", "os", "ctx", " fs", " ss", "b", "gb", "ls", "css"], "i": ["adi", "ie", "di", "gi", "field", "ini", "mi", "iu", "x", "fi", "multi", "li", "count", "e", "xi", "u", "pi", "base", "abi", "uri", "phi", "si", "in", "y", "ai", "ui", "hi", "c", "ti", "inf", "ix", "z", "ci", "id", "mini", "io", "is", "ip", "qi", "ami", "line", "info", "ji", "ki", "p", "index", "type", "col", "ri", "b", "ni", "f", "start", "zi", "ind", "j", "ii", "I"], "len": ["body", "part", "en", "lan", "le", "fin", "list", "all", "lif", "split", "la", "nt", "li", "count", "Len", "ld", "fl", "fn", "pos", "ll", "l", "length", "lt", "size", "val", "bin", "lon", "lu", "fat", "el", "limit", "vec", "elt", "lin", "fun", "lc", "dl", "lim", "num", "z", "n", "low", "rev", "ln", "ler", "line", "lit", "sl", "ni", "il", "min", "lf", "lang", "dy", "non", "span", "ann"], "loas_header": ["loas2headers", "loac_gender", "loam_layer", "loas2header", "loam_header", "loas___gender", "all", "loas_headers", "loas__layer", "loac_layer", "_", "loac_headers", "loas_table", "loas___headers", "loac_master", "loas__master", "loam_dr", "end", "loas___layer", "loam_data", "loas___header", "loas_dr", "loas2gender", "loas_data", "loac_table", "loac_header", "loas__table", "loas__header", "loas_gender", "loas_layer", "loas_master", "r", "loas2layer", "at"], "buf": ["fp", "aux", "batch", "alloc", "bl", "bn", "data", "uf", "v", "br", "pkg", "bc", "feat", "fl", "cf", "ff", "cb", "cmd", "fb", "wb", "queue", "vec", "uc", "fd", "pool", "seq", "rc", "config", "rb", "block", "ctx", "cur", "buff", "cache", "home", "box", "Buffer", "bb", "lit", "b", "bag", "src", "bo", "port", "Buff", "buffer", "text", "loc", "fw", "bid", "cv"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 15132, "substitutes": {"opaque": ["Opaque", "OPacre", "ipacity", "opac", "opaques", "copacre", " opaques", "ipaque", "copac", "obacity", "obatile", "copaques", "obaques", " opacity", "obaque", "OPac", "opacity", "Opaques", "opatile", "copaque", "Opac", "ipaques", " opatile", "Opacre", "ipatile", "opacre", "OPaques", "OPaque"], "ret": ["gt", "ft", "fin", " Ret", "try", "nt", "pat", "pt", "result", "rt", "desc", "sur", "val", "res", " RET", "det", "reply", "len", "pret", "fun", "rc", "num", "reg", "rets", "id", "rev", "cur", "mem", "mt", "ext", "lit", "sr", "re", "RET", "red", "flag", "inter", "back", "xt", "ref", "t", "alt", "Ret", "rot"], "ctx": ["fp", "cu", "cn", "exec", "git", "sc", "command", "pkg", "obj", "cf", "cb", "sys", "cc", "parent", "cv", "np", "lib", "component", "scope", "kw", "instance", "conn", "client", "prefix", "sync", "tc", "pc", "cmd", "gpu", "gc", "path", "sq", "hw", "lc", "cus", "handler", "context", "c", "cpu", "tx", "crit", "ca", "wcs", "cas", "jp", "bc", "fn", "cfg", "qt", "qa", "anc", "wp", "Context", "cmp", "general", "wx", "six", " context", "conv", "unc", "que", "alloc", "qq", "cam", "connection", "cgi", "cm", "nc", "sci", "kb", "grad", "config", "cca", "vc", "ci", "fc", "rx", "cp", "p", "cli", "cl", "ctrl", "utils", "cci", "xc", "loc", "fw", "support", "css"], "t2": ["t4", "p2", "dt8", "p8", "T1", "t0", "t8", "t62", "p0", "t1", " t62", " t8", "dt62", " t4", "p1", "T2", "T8", "d0", "dt1", "dt4", " t1", "T0", "d2", " t6", "d8", "T6", "T62", "T4", " t0", "t6", "dt2", "d1", "dt6"], "cmp_buf": ["comp_buf", "mp_cb", "comp_uf", "mp_buffer", "cmp_cap", "mp_buff", "comp_buff", "comp_buffer", "mp_rb", "cmp2buf", "cmp_cb", "mp_buf", "cmp_bc", "cmp_uf", "cmp2uf", "cmp2cap", "cmp_buffer", "cmp2buffer", "mp_uf", "cmp_rb", "comp_cap", "cmp_buff", "comp_bc"]}}
{"project": "FFmpeg", "commit_id": "3a54c221d574ec944db1eddf9df895808f32bf9e", "target": 1, "func": "static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 15133, "substitutes": {"buf": ["fp", "binary", "brace", "bd", "orig", "img", "func", "tmp", "fi", "data", "uf", "br", "bc", "bu", "bed", "result", "ff", "fe", "cb", "fb", "output", "wb", "cmd", "cf", "bind", "header", "db", "queue", "vec", "bt", "fd", "runner", "offset", "bg", "seq", "rc", "config", "bh", "rb", "ctx", "cur", "feed", "buff", "cache", "context", "input", "conv", "Buffer", "cat", "b", "bag", "f", "src", "sb", "ab", "msg", "port", "Buff", "buffer", "font", "text", "cas", "pb", "cv"], "ts_start": ["ts_cur", "tspreend", "ts_stop", "ts_base", "ats_get", "tsprecur", "tsprestart", "tsxnext", "tsxstart", "ts_size", "tsprenext", "times_end", "times_max", "ats_start", "ts__size", "times_cur", "ats_end", "times_size", "times_base", "tsxbase", "ts_get", "tsxend", "ts_max", "times_next", "ts__max", "times_start", "ats_stop", "ts__start", "ts_next", "ts__end"], "ts_end": ["tsacstart", "ats_start", "ts___send", "tips_start", "ts___start", "ts_send", "tsacending", "ts_max", "tsacstop", "ts_offset", "ts___end", "ts___offset", "ats_ending", "ts_order", "times_end", "ats_end", "tsacend", "times_offset", "ts_ending", " ts_ends", "times_start", " ts_ending", "ts_ends", "tips_max", "ts_stop", "tips_order", "times_send", "ats_stop", "tips_end"], "x1": ["y0", "X2", "x4", "w0", "w4", "y4", "w2", " x4", "x0", " x0", "X0", "w1", "X1"], "y1": ["y0", "x4", "y3", " y3", "y4", " y4", " y0", "Y0", "Y4", "x0", "x3", "Y1", "Y2", "Y3"], "x2": ["x4", "X2", "X5", "y3", "y4", "xtwo", " xtwo", " x4", "x5", "x3", "ytwo", "ix3", "y5", " x5", "X4", "ix2", "ix1", " x3", "ixtwo", "X1"], "y2": ["y0", "y3", " y3", "ya1", " y0", "vy1", "Y0", "x0", "vy2", "x3", "Y1", "vy5", "Y2", "y5", "ya5", "Y3", "ya2", "Y5"], "i": ["it", "d", "ie", "o", "di", "gi", "chi", "ini", "iu", "mi", "t", "v", "li", "count", "e", "u", "xi", "l", "pi", "si", "in", "ai", "m", "ui", "ti", "ix", "n", "eni", "ci", "id", "bi", "init", "qi", "phi", "c", "x", "ami", "oi", "ji", "hi", "p", "index", "ri", "info", "b", "ni", "start", "f", "zi", "ind", "j", "ii", "I"], "hs": ["ps", "wh", "ens", "hop", "rs", "hem", "ys", "his", "cs", "hess", "ts", "hops", "ht", "ds", "hm", "hh", "ims", "sq", "hel", "gs", "xs", "hp", "ks", "her", "His", "sh", "vs", "h", "hi", "s", "ns", "ph", "qs", "ems", "ls", "hes", "HS", "css"], "ms": ["ps", "mm", "us", "rs", "mi", "MS", "ys", "md", "cs", "pos", "ts", "ds", "si", "ans", "mys", "m", "ims", "mn", "mes", "sem", "ks", "ips", "les", "sh", "vs", "ns", "s", "ma", "mc", "Ms", "js", "ses", "ems", "ls"], "ss": ["ps", "mm", "us", "SS", "ass", "rs", "sc", "cs", "st", "hess", "pos", "ts", "ds", "si", "mys", "sp", "sq", "sf", "mes", "sem", "bs", "es", "ks", "iss", "ess", "rss", "sh", "vs", "s", "ns", "ses", "sy", "ls", "css"], "he": ["wh", "ha", "en", "ale", "le", "xe", "she", "pe", "hee", "hem", "hen", "ge", "his", "e", "hess", "fe", "be", "spe", "ih", "ste", "He", "you", "hu", "gh", "ke", "HE", "self", "het", "her", "han", "che", "so", "sh", "h", "hi", "s", "we", "hea", "hy", "here", "hes", "ee"], "me": ["ps", "mm", "oe", "my", "ale", "le", "pe", "mi", "hem", "md", "ge", "e", "pos", "fe", "mu", "sle", "mer", "si", "m", "sp", "mis", "Me", "meg", "mes", "em", "sem", "ke", "ae", "self", "sh", "ma", "we", "ph", "min", "sea", "ME", "mor", "te", "ye", "ee"], "se": ["ps", "ne", "le", "she", "pe", "ese", "ge", "sc", "e", "sa", "fe", "ser", "be", "sle", "sel", "spe", "SE", "ste", "si", "see", "sp", "sq", "sem", "ke", "ae", "ase", "ce", "so", "sh", "ze", "su", "h", "s", "ph", "sw", "sl", "th", "sea", "ses", "te", "ee"]}}
{"project": "qemu", "commit_id": "3f2cbf0d1a1340bed4a63e05b044c46df93f4768", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            /* test virtual address sign extension */\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            /* 2 MB page */\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n", "idx": 15136, "substitutes": {"env": ["enc", "en", "et", "engine", "ne", "environment", "ev", "dt", "site", "edge", "exc", "vm", "txt", "global", "e", "nc", "obj", "fg", "enter", "eye", "conn", "server", "output", "qt", "qa", "eng", "ec", "db", "ou", "pg", "el", "state", "ef", "assets", "hell", "config", "emb", "ea", "eu", "eni", "cv", "event", "np", "her", " environment", "ctx", "init", "cache", "context", "vs", "shell", "code", "dict", "viron", "ext", "args", "core", "cal", "manager", "loader", "que", "err", "console", "forge", "equ", "conf", "Environment", "oa"], "addr": ["en", "ha", "address", "atom", "hop", "dr", "nn", "aug", "route", "anne", "amd", "ord", "ar", "hash", "amp", "adr", "eth", "rt", "conn", "align", "pad", "db", "cmp", "attr", "grad", "offset", "state", "adder", "az", "nr", "xp", "ptr", "seq", "bridge", "host", "config", "url", "rr", "add", "arg", "node", "ip", "memory", "art", "Address", "ast", "layer", "ode", "od", "order", "arr", "src", "inter", "er", "asm", "ost", "ridge", "ace", "rg", "arm", "len", "ad", "oa"], "pde_addr": ["pda_addr", "pda__address", "pde__addr", "pdc_ace", "pdc_addr", "pde_layer", "pde_ace", "pdu_hop", "pda__oa", "pde_address", "pdu_amd", "pdc_ord", "pde_hop", "pde__oa", "pda_ord", "pda_address", "pde_amd", "pda__ord", "pde__ord", "pdu_layer", "pda_oa", "pdu_addr", "pde_oa", "pde__address", "pda__addr", "pde_ord"], "pte_addr": ["ptee_address", "pte_device", "ptee_device", "pte_address", "ptee_addr", "pte_amd", "ptee_amd"], "pte": ["aptE", "aptd", "cte", "ctE", "apte", "PTee", "ctee", "ptd", "aptee", "PTE", "PTe", "ptE", "ptee", "ctd", "PTd"], "paddr": ["pcode", "pnode", "vpaddr", "vpaddress", "vpnode", "vpcode", "pcaddr", "tpaddr", "pcnode", "pcaddress", "tpcode", "paddress", "tpaddress", "pccode", "tpnode"], "page_offset": [" page_reset", "page_number", "page\u00b7reset", "page2reset", "page2size", "page\u00b7number", "page2number", "page\u00b7offset", "page_reset", "page2offset", " page_number", "page\u00b7size"], "page_size": [" page_len", "page64offset", "page64size", "page64len", "page_len"], "pdpe_addr": ["pdke__address", "pdke__orig", "pdke__addr", "pdpe__lan", "pdke_orig", "pdpe_int", "pdpo_ord", "pdpe__ord", "pdke_addr", "pdpo_address", "pdpe_lan", "pdpe__cmd", "pdpe_layer", "pdque_hop", "pdke_address", "pdfe_lan", "pdpo_addr", "pdfe_cmd", "pdpe_ord", "pdpe_conn", "pdpe__orig", "pdpe__address", "pdque_addr", "pdque_layer", "pdfe_hop", "pdfe_int", "pdque_conn", "pdpe__hop", "pdpe_orig", "pdpe_cmd", "pdfe_addr", "pdke_hop", "pdpe__addr", "pdpe_address", "pdke__hop", "pdfe_address", "pdpe_hop"], "pde": ["copda", "lpnode", "gdo", " pdc", "ddu", "pne", " pnode", " pda", "Pda", "copdec", "hde", "copne", " pdes", "pdec", "gdu", " pne", "gdes", "lpde", "lpdu", "dde", "Pne", "hdu", "pdc", "pdu", "pdo", " pdec", "ddo", "copde", "lpdc", "pnode", "hnode", " pdo", " pdu", "Pdec", "gde", "hdc", "Pde", "pda", "pdes", "ddes"], "pdpe": ["padple", "padpes", "ddoe", "ldque", "pdde", "hdde", "sdpe", "padpe", "tdte", "eddpe", "eddper", "pcper", "pdfe", "ldple", "pdque", "drame", "hdple", "sdque", "drape", "ddpe", "sdper", "pdpes", "drate", "dste", "pdoe", "pdche", "pcke", "ldoe", "tdpes", "dpe", "pdte", "pdke", "tdde", "hdche", "tdper", "hdfe", "hdte", "dpes", "ldke", "hdme", "ddche", "hdpes", "hdper", "dke", "tdple", "hdke", "ddple", "sdke", "pcque", "tdpe", "pdme", "hdoe", "ldpe", "dper", "dte", "dfe", "eddfe", "ldper", "dsper", "draper", "eddte", "dspe", "padde", "hdpe", "tdke", "tdfe", "pdple", "ldche", "dsme", "pcpe", "pdper"], "pml4e_addr": ["pml4e_host", "pml4e_loc", "pml4ee_len", "pml4e_conn", "pml4e_offset", "pml4exaddr", "pml4exconn", "pml4e_hop", "pml4er_addr", "pml4e__hop", "pml4exlen", "pml4e_address", "pml4e__address", "pml4exloc", "pml4er_address", "pml4er_loc", "pml4ee_loc", "pml4e__offset", "pml4e_len", "pml4e_func", "pml4e__addr", "pml4er_offset", "pml4ee_addr", "pml4er_func", "pml4ee_conn", "pml4er_hop", "pml4er_host"], "pml4e": ["pml04b", "pml004c", "pazel4e", "pml6ee", "pazel04er", "pwl12er", "pwl4e", "pwl4er", "pml7ee", "pmlfoure", "pml8e", "pml12x", "pwl12x", "pml4f", "pml004er", "pwl12E", "pml5E", "pml12E", "pml4E", "pwl12c", "pwl4c", "pazel4b", "pmlfourpe", "pml12pe", "pml8b", "pml8er", "pml5pe", "pml6f", "pml8ee", "pml5c", "pml4pe", "pazel04ee", "pwl12e", "pml12er", "pwl4pe", "pazel4ee", "pmal6ee", "pml004E", "pazel04e", "pml12e", "pmlfourer", "pazel4er", "pmal4ee", "pwl12pe", "pml004e", "pmal6b", "pml4x", "pmal4f", "pml04e", "pmal4e", "pmal6f", "pmlfourx", "pml6e", "pml7f", "pml5e", "pml6er", "pml7b", "pml4c", "pwl4x", "pml4er", "pmal4b", "pwl4E", "pml8f", "pml5x", "pml04er", "pmal6e", "pml12c", "pml04ee", "pml4b", "pml5er", "pml4ee", "pml6b", "pml7e", "pazel04b"], "sext": ["psect", "sexp", "pseXT", "seXT", "SEct", "sect", "psext", "tetxt", "netxt", " sept", "seft", " select", "selex", "SExt", "teXT", "teft", "pelect", "setxt", " seext", "pexp", " sexp", "SEext", "inext", "texp", "psept", " selex", "SEpt", "pselex", "tect", "inexp", "SExp", "SElex", "ineXT", "pext", " seft", "pseext", "peXT", "nept", " seXT", "SEXT", "sept", "psexp", "select", "tept", "seext", "text", " setxt", "next", "inelect", "neft"]}}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n", "idx": 15147, "substitutes": {}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_sec_rs_finalize(SocketReadState *sec_rs)\n\n{\n\n    CompareState *s = container_of(sec_rs, CompareState, sec_rs);\n\n\n\n    if (packet_enqueue(s, SECONDARY_IN)) {\n\n        trace_colo_compare_main(\"secondary: unsupported packet in\");\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n", "idx": 15173, "substitutes": {"sec_rs": ["sec_ras", "sec_cs", "secJRS", "sec_rys", " sec_rss", "secJras", "sec_ros", "secJrys", " sec_ros", " sec_RS", "secJrs", "sec_rss", " sec_cs", "sec_RS", " sec_rys", " sec_ras"], "s": ["ps", "https", "fs", "sync", "d", "o", "session", "rs", "south", "e", "u", "cs", "ts", "ds", "states", "sys", "si", "ss", "ssl", "service", "m", "new", "se", "sq", "gs", "sf", "sec", "xs", "g", "self", "os", "spec", "stats", "is", "submit", "c", "side", "args", "i", "sg", "p", "ns", "b", "sl", "f", "src", "sb", "ses", "js", "groups", "ls", "r", "socket", "S", "services", "sym", "ops"]}}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n", "idx": 15201, "substitutes": {"fds": ["dsts", " fd", "dds", "cfrs", "qrs", "qds", "cds", "lnas", "qdd", "lns", "fsk", "forks", "qys", " fdd", "cfds", "ld", "cDS", "frs", "fts", "fordd", "cd", "qks", "lDS", "fdd", " fdds", " fks", "pds", "forts", "qda", "qts", " fns", " fda", "fd", " fsts", " fnas", "qsk", "cfys", " frs", "cdds", " fys", "fsts", " fDS", "fda", "pDS", "fdds", "dDS", "qns", "fys", "fords", "dks", "fks", "pks", "qnas", "lda", " fsk", "cfsk", "lds", "psts", "ldds", " fts", "fDS", "fns", "fnas"], "dev": ["debug", "serv", "d", "di", "app", "bug", " Dev", "ev", "ve", "priv", " device", "temp", "data", "user", "v", "DEV", "pub", "end", "wd", "conn", "server", "def", "develop", "bus", "die", "ow", "ready", "grad", "mod", "valid", "error", "Dev", "host", "df", "ani", "self", "rad", "de", "gu", "sd", "info", "dem", "req", "device", "od", "dd", "ver", "prop", "w", "diff", "adv", "err", "conf", "driver", "var", "ad", "kind"]}}
{"project": "FFmpeg", "commit_id": "c571424c7f6276a6374e1784ce2a33d4b6a4292d", "target": 1, "func": "static int asf_read_picture(AVFormatContext *s, int len)\n\n{\n\n    ASFContext *asf       = s->priv_data;\n\n    AVPacket pkt          = { 0 };\n\n    const CodecMime *mime = ff_id3v2_mime_tags;\n\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n\n    char mimetype[64];\n\n    uint8_t  *desc = NULL;\n\n    AVStream   *st = NULL;\n\n    int ret, type, picsize, desc_len;\n\n    ASFStream *asf_st;\n\n\n\n    /* type + picsize + mime + desc */\n\n    if (len < 1 + 4 + 2 + 2) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture type */\n\n    type = avio_r8(s->pb);\n\n    len--;\n\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n\n        type = 0;\n\n    }\n\n\n\n    /* picture data size */\n\n    picsize = avio_rl32(s->pb);\n\n    len    -= 4;\n\n\n\n    /* picture MIME type */\n\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n\n               mimetype);\n\n        return 0;\n\n    }\n\n\n\n    if (picsize >= len) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n\n               picsize, len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture description */\n\n    desc_len = (len - picsize) * 2 + 1;\n\n    desc     = av_malloc(desc_len);\n\n    if (!desc)\n\n        return AVERROR(ENOMEM);\n\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    st  = avformat_new_stream(s, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n\n    asf_st = asf->asf_st[asf->nb_streams];\n\n    if (!asf_st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id           = id;\n\n    st->attached_pic              = pkt;\n\n    st->attached_pic.stream_index = asf_st->index = st->index;\n\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n\n\n    asf->nb_streams++;\n\n\n\n    if (*desc) {\n\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    } else\n\n        av_freep(&desc);\n\n\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&desc);\n\n    av_free_packet(&pkt);\n\n    return ret;\n\n}\n", "idx": 15206, "substitutes": {"s": ["hs", "session", "v", "sc", "u", "ts", "its", "sys", "si", "an", "se", "m", "xs", "self", "sup", "spec", "submit", "h", "qs", "sb", "js", "services", "fs", "sync", "your", "ins", "sim", "cs", "e", "ss", "ssl", "sq", "gs", "a", "is", "c", "sg", "ns", "lines", "settings", "less", "storage", "us", "sites", "sa", "ds", "service", "obs", "stats", "http", "ses", "S", "ops", "comments", "sv", "rs", "south", "private", "secondary", "sci", "server", "space", "full", "uns", "g", "es", "ks", "os", "ctx", "su", "p", "b", "sign", "aws", "sets", "f", "request", "ls", "r", "conf"], "len": ["enc", "resp", "pos", "val", "limit", "seq", "n", "rev", "lib", "syn", "ni", "gen", "min", "pl", "conn", "alt", "part", "en", "fin", "all", "split", "li", "fl", "format", "lt", "den", "fat", "str", "lc", "lim", "num", "lvl", "lang", "span", "iter", "bl", "data", "la", "ll", "count", "fn", "end", "l", "size", "lon", "html", "fun", "dl", "pre", "lp", "ln", "lit", "sl", "il", "name", "lf", "ann", "body", "Len", "ld", "length", "base", "lic", "sp", "el", "elt", "lin", "url", "hl", "net", "mem", "ell", "err", "ls", "loc"], "asf": ["AScf", "Ascf", " asc", "ASfs", "asc", "Asf", "ASc", "ascf", "Asfs", "ASf", "asfs", " asfs", " ascf", "Asc"], "mime": ["mise", "imimes", "mide", "cmimes", "cmode", "mimes", " mIME", "pise", "Mimage", " mise", " mich", "pimes", "Mime", " mimage", "mode", "Mise", "smime", "pmimes", "Mimes", "smize", "Mide", " mize", "pich", "pmode", "MIME", "imich", "pmip", "cmip", "amimes", "amise", "amIME", "mize", "amime", " mide", "pime", "pIME", "Mize", "mich", " mip", "pmime", "smIME", "imime", "mimage", " mimes", "pimage", "cmime", "imise", " mode", "mip", "smise", "pide", "mIME"], "mimetype": ["mimearpe", "mockeycape", "mimeyPE", "mimeypes", "mimileape", "moyetyope", "mocketype", "moyetyype", "mimestpes", "mimileme", "mimeyype", "mameype", "mimetypes", "mimencyape", "mignetyme", "mignetyape", "mimenamero", "mimeryope", "mimearpes", "mimestpe", "moyetrype", "mimeryype", "mimellyplate", "mumipepe", "mimenamepes", "mimetyype", "mimerype", "mametype", "mametyro", "moyetype", "mimencycape", "mimencyplate", "mameyype", "mimetypress", "mimenametype", "moyetryope", "mimeytype", "mocketyplate", "mimityape", "mametyme", "mimestype", "mimestro", "moyetypes", "mimellype", "mametypes", "mockeyope", "mimipePE", "mimetrype", "mimenameype", "mimeycape", "mametyype", "mameyro", "mumetytype", "mimetyme", "mimerypes", "mimetyape", "moyetryype", "mimearope", "mimetycape", "mimencyope", "mimellycape", "mignetypress", "mimencypress", "mimearype", "mimitytype", "mamitytype", "mimilepe", "mimetyope", "mumetype", "mumetypes", "mumipetype", "mimeyplate", "mimeyope", "mimeryPE", "mignitype", "mimipetype", "mimilepress", "mamityme", "mimellyope", "mimenameme", "mimencype", "mockeype", "mimetrypes", "mimipepe", "mumipePE", "mimityme", "mimitypes", "mimitype", "mignetype", "mimeyro", "mametytype", "mumipepes", "mimipepes", "mimerytype", "mamitype", "mumetyPE", "mignitypress", "mimeype", "mignityme", "mamitypes", "moyetrypes", "mimetyplate", "mimetryope", "mimitypress", "mimetyro", "mignityape", "mimeryme", "mimetyPE", "mimenamepe", "mockeyplate", "mocketycape", "mimetryype", "mimetytype", "mocketyope", "mimencyme", "mameypes"], "desc": ["enc", "aux", "cont", "content", "md", "sc", "dist", "dir", "bc", "def", "path", "doc", "summary", "dc", "uc", "Desc", "label", "meta", "sec", "seq", "str", "comment", "rc", "fun", "sub", "rec", "de", "asc", "id", "cur", "description", "ext", "info", "lit", "src", "name", "des", "diff", "esc", "text", "loc", "ref", "dest", "prev", "code"], "st": ["ct", "ST", "bl", "sc", "St", "sa", "rd", "rest", "ste", "stim", "ss", "se", "sp", "inst", "sn", "sta", "sts", "est", "sh", "ast", "sw", "sl", "ist", "sb", "ost", "sth", "std"], "ret": [" flags", " resp", "ID", " seq", " orig", " base", " gen", " alt", " ID", " field", " ord", " ref", " sent", " val", "id", " ext", "Id", " url", " clen", " flag", " wid", " def", " code", " lib", " res", " lang", " pos", " arg"], "type": ["part", "o", "ty", "pe", "single", "count", "op", "pos", "year", "format", "length", "area", "size", "style", "rel", "token", "val", "total", "shape", "y", "types", "sort", "ype", "tag", "state", "by", "offset", "sp", "TYPE", "time", "comment", "typ", "unit", "error", "sub", "key", "class", "block", "like", "id", "spec", "version", "Type", "weight", "code", "http", "info", "p", "index", "order", "name", "min", "py", "sy", "value", "loc", "ref", "t", "number", "span", "null", "kind"], "picsize": ["picizer", "pipssize", "Picksizing", "picsrate", "Picsizes", "picsizing", "Picsize", "picIZE", "pixizer", "piciz", "pisiz", "picsiz", "pnicizes", "nicsze", "nicssize", "picssize", "Picssize", " policIZE", "pixize", " picize", "pnicsize", "pipsiz", " pipssize", "picalsize", "policsize", "pixiz", " pipsize", " picizer", "Picksize", "niciz", "nicze", " policiz", "picksrate", " piciz", "policIZE", "Pickssize", "parsizing", " picsiz", "picrate", "nicsize", "picsIZE", " picsizes", "policiz", " picrate", "picsizes", "picze", "picksize", " policize", "pisize", "picalrate", "parsizes", "pnicize", "picsizer", " pipsiz", "picsze", "picizes", "picalize", "picksizing", " picsIZE", "picize", "picksze", "picksiz", "parssize", "picksIZE", "picaliz", "picksizes", "pixsize", "nicize", " policsize", "pisze", "policize", "pissize", "picksizer", " picssize", "pnicizing", "pipsize", " pipsizes", "nicsiz", " picsrate", "parsize", "pipsizes", "pickssize", "Picksizes", "Picsizing", " picsizer"], "desc_len": ["desc_val", "desc_lf", "description2lon", " desc2len", "desc_Len", "desc_dl", "desc_lon", "desc___lon", "desc_den", "description_num", "desc2Len", "descqdl", "distdlf", "dist_den", "desc___Len", "description2Len", "desc_lin", " desc2lon", "description_len", "desc___len", "descqval", "descqlen", "desc_num", " desc_lon", "desc2lon", "descdnum", "desc2dl", "desc2ln", "desc2len", "distdden", "description_ln", "distdnum", " desc_val", "dist_len", "desc___ln", " desc2dl", " desc2val", "desc2val", " desc_dl", "dist_lf", "description2ln", "description_Len", "description_lin", "descdlf", "distdlen", "descqlon", "descdden", "dist_num", "description2len", "description_lon", "desc_ln", "descdlen"], "asf_st": ["asb__St", "asb_st", "asf__ST", "asb_sl", "asb_St", "asf_St", "asb__ST", "asf__sl", "asb__sl", "asb__st", "asf_ST", "asf_sl", "asb_ST", "asf__St", "asf__st"]}}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209, "substitutes": {"env": ["visor", "enc", "en", "serv", "app", "environment", "ini", "priv", "exec", "fi", "exc", "vm", "txt", "v", "erv", "e", "nc", "bc", "cf", "server", "qt", "eng", "ec", "conf", "db", "gui", "ep", "config", "ea", "eu", "me", "net", "eni", "iv", "np", "ctx", "iss", "cache", "context", "vs", "viron", "prov", "him", "scope", "virt", "here", "gr", "que", "console", "err", "entry", "ridge", "enable", "equ", "conn", "oa"], "rip": ["serv", "ru", "app", "rw", "route", "rs", "trip", "jp", "ipp", "op", "rh", "rt", "strip", "ipe", "tri", "cap", "rap", "rc", "raped", "ix", "ips", "rib", "rin", "region", "ip", "rup", "rx", "ick", "tx", "sr", "pin", "rn", "rg", "rub", "arp", "ris", "RI"], "syndrome": ["Syntroma", "syundchrome", "cyntrom", "syntrom", "syundrome", "cyntroma", "cyntrome", "syntroma", "Syndroma", "syntchrome", "syntrome", "cyndrom", "sydchrome", "cyndroma", "syndrom", "Syntrom", "cyntchrome", "cyndrome", "cyndchrome", "syndchrome", "syindrom", "syindrome", "syundroma", "syindroma", "sydroma", "syindchrome", "Syntchrome", "Syndchrome", "syundrom", "syndroma", "Syntrome", "Syndrome", "Syndrom", "sydrome", "sydrom"], "ri": ["di", "gi", "rid", "ini", "mi", "ry", "rd", "xi", "rt", "pi", "uri", "ro", "vi", "si", "mir", "tri", "ai", "iri", "ra", "rc", "ti", "ani", "stri", "rin", "eni", " RI", "ci", "io", "iv", "rm", "ip", "i", "rx", "ki", "ni", "rio", "sr", "ir", "ski", "ori", "RI", "ris"]}}
{"project": "qemu", "commit_id": "b7c8c35f0afb62efcacd18a64067fe164e3206b6", "target": 1, "func": "static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n", "idx": 15239, "substitutes": {"dev": ["debug", "di", " Dev", "app", "ev", "der", "ve", "dom", "data", "user", "v", "md", "dist", "del", "DEV", "pub", "ds", "def", "conf", "die", "dc", "mod", "comment", "dim", "Dev", "self", "de", "rad", "block", "development", "dem", "info", "req", "device", "dd", "ver", "w", "diff", "err", "gd", "conn", "ad"], "d": ["bd", "di", "dt", "dr", "nd", "dom", "dos", "data", "md", "e", "ld", "del", "u", "cd", "l", "wd", "dat", "ds", "in", "did", "dad", "dc", "m", "die", "db", "fd", "pd", "dn", "a", "dim", "dl", "g", "ded", "n", "vd", "dh", "sd", "c", "h", "i", "s", "p", "od", "dd", "b", "f", "dm", "w", "diff", "D", "std", "gd", "t", "da", "ad"], "hba": ["phb", "hrbe", "hraba", "hhbe", "hsba", "hlpa", " hda", "phba", " hbas", "hbe", "hbas", "hlbe", "hada", "ahb", "ahva", "hhda", " hpa", "hsbo", "hlna", "hsbc", "hhpa", "hlba", "Hba", "hna", "hrbc", "hpa", "ahba", "phpa", "Hda", " hbc", "hrba", "Hna", "hlaba", "hhada", "hrda", "Hbas", "hlbas", "hhbas", "ahpa", "Hga", "Hva", "Hpa", "hhba", "hga", "hrbo", "Hada", "hhga", "hsda", " hna", " hva", "hrna", " hga", "hbo", "hlada", "hb", " hbo", " hb", "hda", "haba", "hva", "hhaba", "phva", "Hbo", "hrva", "hhna", "hbc"], "id": ["it", "ids", "part", "en", "vid", "ID", "rid", "file", "null", "sid", "data", "mad", "oid", "hid", "act", "end", "length", "val", "def", "alias", "path", "in", "and", "iden", "uid", "pid", "api", "kid", "lin", "url", "error", "parent", "channel", "key", "like", "Id", "version", "ide", "ip", "c", "i", "h", "info", "code", "ident", "aid", "p", "type", "index", "one", "lit", "start", "gen", "name", "f", "mid", "bit", "ref", "bid", "ad", "kind"]}}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static int eval_lpc_coeffs(const float *in, float *tgt, int n)\n\n{\n\n    int x, y;\n\n    double f0, f1, f2;\n\n\n\n    if (in[n] == 0)\n\n        return 0;\n\n\n\n    if ((f0 = *in) <= 0)\n\n        return 0;\n\n\n\n    in--; // To avoid a -1 subtraction in the inner loop\n\n\n\n    for (x=1; x <= n; x++) {\n\n        f1 = in[x+1];\n\n\n\n        for (y=0; y < x - 1; y++)\n\n            f1 += in[x-y]*tgt[y];\n\n\n\n        tgt[x-1] = f2 = -f1/f0;\n\n        for (y=0; y < x >> 1; y++) {\n\n            float temp = tgt[y] + tgt[x-y-2]*f2;\n\n            tgt[x-y-2] += tgt[y]*f2;\n\n            tgt[y] = temp;\n\n        }\n\n        if ((f0 += f1*f2) < 0)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15249, "substitutes": {"in": ["update", "it", "IN", "part", "o", "din", "ins", "nn", "ini", "source", "con", "image", "inner", "isin", "line", "nin", "bin", "token", "inside", "login", "new", "m", "In", "lin", "up", "rin", "ac", "rec", "id", "win", "init", "input", "i", "c", "scan", "p", "index", "ax", "ex", "inc", "on", "arr", "f", "circ", "min", "out", "again", "inn", "pin", "pass", "old", "conn", "inf"], "tgt": ["Ttarget", "qtgt", "atlt", " tgat", "plt", "wnt", "atwd", "tga", "fwd", "ktgat", "tft", "Tgt", " tlt", " tgen", "wtwd", "pgz", "ygt", "Targ", "wlt", "parg", "Tnt", " ttarget", "tgat", "dgt", "ywd", " tkt", "ktgt", "ktlt", "fnt", " twd", "qtga", "tgz", "Tgz", "ttarget", " tnt", "fft", "dft", "twd", "tkt", "ynt", "atgen", "ktga", "wtgen", " tft", "wtnt", "fgt", "Tft", "pnt", "dkt", "ptarget", " targ", "dwd", "wwd", "wgt", "wtgt", "tnt", "dgz", "qtlt", "tgen", "atgt", "dlt", " tga", "qtgat", " tgz", "dnt", "tlt", "atnt", "ykt", "attarget", "pgt", "targ"], "n": ["d", "o", "nn", "all", "v", "nt", "e", "nc", "u", "network", "l", "size", "m", "sn", "num", "g", "z", "k", "net", "nb", "N", "c", "i", "h", "ns", "p", "s", "b", "ni", "f", "name", "out", "w", "r", "j", "nl", "t", "span", "nan"], "x": ["v", "u", "work", "yx", "m", "xs", "ix", "cross", "i", "h", "one", "sex", "fx", "min", "xxx", "j", "any", "X", "t", "o", "my", "e", "image", "wy", "xy", "time", "a", "num", "id", "ip", "c", "ww", "max", "ax", "on", "tx", "dy", "xa", "l", "dx", "mix", "xx", "wx", "key", "ex", "name", "wa", "code", "d", "step", "ty", "xi", "full", "lex", "g", "px", "z", "k", "plus", "no", "rx", "s", "p", "index", "b", "f", "w", "xc", "xt"], "y": ["ya", "iny", "d", "o", "ay", "ky", "ty", "yo", "v", "ys", "ry", "iy", "xi", "yt", "year", "yr", "e", "yx", "ny", "wy", "m", "xy", "ady", "zy", "uy", "ym", "vy", "xx", "isy", "z", "key", "yd", "ci", "id", "ey", "ish", "c", "i", "p", "type", "b", "cy", "hy", "f", "w", "Y", "yy", "j", "dy", "sy", "ye", "oy", "py", "t", "sky", "yi", "gy", "yl"], "f0": ["e0", "F00", " f00", "F0", "cf0", "F2", "F1", "rf1", "F3", "e1", "p0", "f6", "e2", "rf2", "e3", "f3", "rf00", " f3", "c0", " f6", "rf0", "c1", "cf1", "f00", "c2", "cf6", "cf2", "F6", "p2", "p1"], "f1": ["v5", "cf7", "df1", " f4", "F4", "F0", "f7", " fone", "F2", "sf0", "F1", "v1", "of1", "sf2", "F5", " f64", "df64", " f7", "f64", "cf4", "of0", "sf1", "f4", "Fone", "cf64", "v2", "cf0", "ofone", "sfone", "df7", "v0", "cf1", " f5", "of2", "f5", "cf2", "df2", "fone"], "f2": ["e0", " f8", "Fb", " f4", "F4", "F0", "sf0", "f8", "F2", "e8", "F1", "F8", "f02", "v1", "sf02", "sf2", "e1", "fb", "p0", "sf1", "f4", "e2", "v2", "v8", "e4", "F02", "v0", " f02", " fb", "p2", "p1", "pb"]}}
{"project": "FFmpeg", "commit_id": "71a1f76d3cc937fc1a47f501fc4866f95b74d0b0", "target": 0, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    free_temp(&s->dither);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n    swri_rematrix_free(s);\n\n\n\n    s->flushed = 0;\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested input sample format %d is invalid\\n\", s->in_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested output sample format %d is invalid\\n\", s->out_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==AV_SAMPLE_FMT_S16P){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16P;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLTP;\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, S16/S32/FLT is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    set_audiodata_fmt(&s-> in, s-> in_sample_fmt);\n\n    set_audiodata_fmt(&s->out, s->out_sample_fmt);\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(    s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_FLTP\n\n        && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0 ||\n\n                 s->rematrix_custom;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    if(!s-> in.ch_count){\n\n        av_assert0(!s->in_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if ((!s->out_ch_layout || !s->in_ch_layout) && s->used_ch_count != s->out.ch_count && !s->rematrix_custom) {\n\n        av_log(s, AV_LOG_ERROR, \"Rematrix is needed but there is not enough information to do it\\n\");\n\n        return -1;\n\n    }\n\n\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s->in_buffer= s->in;\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count= s->used_ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    set_audiodata_fmt(&s->postin, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->preout, s->int_sample_fmt);\n\n\n\n    if(s->resample){\n\n        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);\n\n    }\n\n\n\n    s->dither = s->preout;\n\n\n\n    if(s->rematrix || s->dither_method)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 15252, "substitutes": {"s": ["hs", "session", "site", "u", "ts", "its", "sys", "si", "in", "an", "m", "xs", "sup", "self", "n", "spec", "submit", "i", "h", "qs", "scope", "sb", "js", "services", "t", "native", "ps", "sync", "fs", "serv", "o", "ins", "e", "cs", "parts", "ions", "ss", "rows", "ssl", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "settings", "less", "us", "changes", "user", "l", "ds", "service", "this", "php", "http", "ses", "ms", "sym", "S", "ops", "comments", "d", "rs", "south", "features", "server", "params", "full", "g", "es", "ks", "os", "ments", "side", "args", "su", "p", "b", "sign", "sets", "f", "groups", "request", "ls", "r", "conf"]}}
{"project": "qemu", "commit_id": "8de433cb0820dc1f387a2d580d255744aacd60cc", "target": 1, "func": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);", "idx": 15260, "substitutes": {"id": ["ids", "d", "address", "ID", "rid", "sid", "data", "h", "count", "image", "oid", "cd", "end", "length", "size", "base", "val", "post", "path", "in", "did", "pid", "uid", "kid", "url", "num", "parent", "key", "Id", "ide", "ip", "c", "i", "pointer", "info", "ident", "x", "p", "index", "type", "aid", "start", "f", "name", "mid", "max", "ref", "number", "bid", "ad", "code"], "errp": ["ererpre", " errcp", "interp", "Erpre", " errfp", "ercp", "errorcp", "errcp", "eorpre", "errps", "ererp", "errpb", "acerp", "erlp", "errlp", "Erpb", "erc", "ererpb", "errr", "iterp", "erpa", "erps", "ererpart", "acerpa", "errfp", "eorpart", "errorP", " errP", "errpre", "errc", "iterpa", "interP", " errc", "eorp", "eorpb", "erP", "interlp", "erfp", "errpa", "errorp", "iterr", "errpart", "errP", "Erpart", " errlp", "err", "erp", "acerps", "errorc", "interfp", "Erp", "acerr", "iterps"], "icc_bridge": ["icc__server", "fc_server", "icc__version", "iccacswitch", "icc_link", "icc_server", "fc_switch", "icc_gb", "ci_ridge", "icc_switch", "pc_switch", "iccaclink", "fc_bridge", "ci_Bridge", "pc_bridge", "ci_brid", "icc_brid", "iccacgb", "ci_bridge", "icc__Bridge", "icc_Bridge", "pc_link", "icc__bridge", "icc__brid", "icc__switch", "icc_version", "icc__ridge", "pc_gb", "fc_version", "iccacbridge", "icc_ridge"]}}
{"project": "qemu", "commit_id": "5b4a047fbe8ceb68ad1a78d51f0fadbe2bb12af7", "target": 1, "func": "static void xlnx_ep108_init(MachineState *machine)\n\n{\n\n    XlnxEP108 *s = g_new0(XlnxEP108, 1);\n\n    Error *err = NULL;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    if (machine->ram_size > EP108_MAX_RAM_SIZE) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %llx\", machine->ram_size, EP108_MAX_RAM_SIZE);\n\n        machine->ram_size = EP108_MAX_RAM_SIZE;\n\n    }\n\n\n\n    if (machine->ram_size <= 0x08000000) {\n\n        qemu_log(\"WARNING: RAM size \" RAM_ADDR_FMT \" is small for EP108\",\n\n                 machine->ram_size);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ddr_ram, NULL, \"ddr-ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);\n\n\n\n    xlnx_ep108_binfo.ram_size = machine->ram_size;\n\n    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;\n\n    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;\n\n    xlnx_ep108_binfo.loader_start = 0;\n\n    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);\n\n}\n", "idx": 15288, "substitutes": {"machine": ["normal", "module", "session", "menu", "address", "field", "link", "sc", "sm", "sys", "m", "group", "parent", "man", "channel", "boot", "slave", "mac", "component", "instance", "controller", "template", "part", "o", "sim", "e", "image", "match", "interface", "processor", "element", "error", "block", "handler", "node", "cache", "c", "memory", "rule", "manager", "database", "engine", "di", "computer", "oper", "vm", "user", "message", "model", "service", "object", "state", "comment", "parse", "ch", "home", "Machine", "mc", "sample", "game", "app", "connection", "mi", "mode", "project", "volume", "process", "base", "server", "note", "alias", "space", "sp", "tm", "by", "M", "config", "proc", "host", "motion", "hard", "cp", "info", "p", "core", "mot", "device", "b", "f", "loader"], "s": ["ps", "fs", "serv", "sync", "session", "rs", "south", "t", "sim", "sc", "e", "sm", "cs", "sa", "l", "server", "ds", "params", "sys", "si", "ss", "space", "service", "ssl", "m", "sp", "sq", "gs", "sf", "a", "g", "es", "sup", "self", "n", "sch", "os", "spec", "details", "is", "side", "c", "su", "args", "sg", "h", "p", "ns", "scope", "b", "sl", "f", "sb", "ses", "js", "sample", "ls", "services", "sym", "S", "game", "conf", "less", "r"], "err": ["orig", "iter", "bug", "eor", "ev", "dr", "der", "fee", "rs", "ar", "fi", "icer", "rar", "nor", "txt", "resp", "br", "e", "result", "rh", "cfg", "cb", "kr", "y", "doc", "res", "m", "lr", "nr", "rr", "a", "error", "str", "g", "pr", "n", "fr", "ah", "ler", "orr", "req", "order", "mr", "Er", "arr", "sr", "ir", "cr", "msg", "acer", "aster", "ind", "er", "Error", "rn", "r", "ace", "gr", "aaa", "conf", "var"]}}
{"project": "FFmpeg", "commit_id": "00b3ca3c7a779e3b062d6ef0c5067c60c8f8a357", "target": 1, "func": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n\n                        AVFilterInOut **open_outputs, AVClass *log_ctx)\n\n{\n\n    int pad = 0;\n\n\n\n    while (**buf == '[') {\n\n        char *name = parse_link_name(buf, log_ctx);\n\n        AVFilterInOut *match;\n\n\n\n        if (!name)\n\n            return AVERROR(EINVAL);\n\n\n\n        /* First check if the label is not in the open_outputs list */\n\n        match = extract_inout(name, open_outputs);\n\n\n\n        if (match) {\n\n            av_free(name);\n\n        } else {\n\n            /* Not in the list, so add it as an input */\n\n            match = av_mallocz(sizeof(AVFilterInOut));\n\n            match->name    = name;\n\n            match->pad_idx = pad;\n\n        }\n\n\n\n        insert_inout(curr_inputs, match);\n\n\n\n        *buf += strspn(*buf, WHITESPACES);\n\n        pad++;\n\n    }\n\n\n\n    return pad;\n\n}\n", "idx": 15290, "substitutes": {"buf": ["fp", "prefix", "brace", "batch", "pause", "func", "tmp", "grab", "data", "uf", "la", "tab", "br", "bc", "bu", "ff", "comb", "cf", "cb", "fb", "cmd", "cas", "wb", "path", "cap", "queue", "vec", "uc", "pool", "ptr", "seq", "rc", "bridge", "proc", "bh", "rb", "ucc", "feed", "buff", "home", "context", "conv", "ref", "cat", "b", "bag", "prop", "src", "sb", "abb", "mount", "ab", "fam", "Buff", "buffer", "auc", "gb", "text", "bound", "img", "cv"], "curr_inputs": ["curr_outputs", "curr_pulles", "curr_contexts", "curr_connectd", "curr_refs", "curr_contextd", "curr_pulld", "curr_inputd", "curr_refd", "curr_refds", "curr_pulls", "curr_pullb", "curr_outputds", "curr_connects", "curr_outputes", "curr_contextes", "curr_outputd", "curr_outputb", "curr_connectds", "curr_inputes", "curr_inputds", "curr_inputb", "curr_contextb", "curr_refes", "curr_connectes"], "open_outputs": ["open_outputts", "open_configors", "open_connectts", "open_configes", "open_inputes", "open_inputors", "open_controlts", "open_controls", "open_controlsets", "open_connectes", "open_connects", "open_configs", "open_inputs", "open_outputes", "open_configsets", "open_outputors", "open_controles", "open_configts", "open_outputsets", "open_inputts", "open_inputsets", "open_connectors"], "log_ctx": ["Log_c", "log_c", "logingcontext", "Log_lc", "log_cb", "log_tx", "Log_context", "log_lc", "Log_tx", "logingcb", "logingctx", "Log_ctx", "logingc", "logingtx", "loginglc", "Log_cb", "log_context"], "name": ["prefix", "part", "address", "connection", "action", "data", "nam", "search", "known", "e", "image", "base", "size", "alias", "path", "space", "cap", "resource", "m", "group", "Name", "new", "label", "comment", "a", "url", "num", "parent", "channel", "key", "word", "self", "ame", "n", "like", "id", "NAME", "version", "change", "x", "no", "ident", "coord", "index", "type", "member", "start", "call", "names", "nm", "value", "number", "code"], "match": ["update", "address", "catch", "test", "live", "field", "route", "mp", "data", "track", "link", "patch", "apply", "search", "ge", "same", "result", "image", "Match", "use", "sum", "be", "model", "message", "copy", "query", "play", "pair", "mat", "alias", "include", "see", "cmp", "m", "tag", "map", "group", "comment", "player", "url", "find", "parse", "scale", "key", "me", "add", "replace", "fire", "cache", "change", "push", "info", "target", "index", "cat", "member", "meet", "pin", "get", "mor", "call", "select", "handle", "rule", "matched", "comp", "help"], "pad": ["prefix", "done", "gap", "address", "bug", "shift", "reset", "patch", "amp", "count", "adr", "pos", "pc", "end", "length", "size", "base", "align", "delay", "style", " padding", "space", "padding", "offset", "ady", "help", "adder", "quad", "ptr", "scale", "ada", "Pad", "add", "adding", " padd", "push", "pointer", "addr", "ping", "paste", "pend", "p", "type", "index", "crop", "start", "stroke", "port", "buffer", "adjust", "ace", "pick", "number", "span", "ad", "pod"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,\n\n                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,\n\n                   int block_w, int block_h, int width, int height, int linesize,\n\n                   vp8_mc_func mc_func[3][3])\n\n{\n\n    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];\n\n\n\n    if (AV_RN32A(mv)) {\n\n        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];\n\n        int my = mv->y&7, my_idx = subpel_idx[0][my];\n\n\n\n        x_off += mv->x >> 3;\n\n        y_off += mv->y >> 3;\n\n\n\n        // edge emulation\n\n        src1 += y_off * linesize + x_off;\n\n        src2 += y_off * linesize + x_off;\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);\n\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        } else {\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        }\n\n    } else {\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);\n\n        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n    }\n\n}\n", "idx": 15301, "substitutes": {"s": ["ps", "fs", "d", "session", "rs", "sim", "cs", "e", "ts", "ds", "si", "ss", "service", "ssl", "se", "sp", "m", "sq", "gs", "g", "self", "n", "os", "spec", "c", "sg", "ns", "p", "b", "sl", "f", "sb", "ses", "js", "w", "ls", "services", "S", "t"], "td": ["d", "ad", "ft", "dt", "cz", "tmp", "nd", "TD", "t", "amp", "md", "tc", "ld", "rd", "ts", "pc", "cd", "ht", "hd", "dc", "tm", "fd", "pd", "sf", "tf", "dl", "sd", "fc", "input", "dd", "tl", "table", "lv", "sb", "lf", "gb", "tif", "img", "pb", "BT"], "dst1": ["dstb", "drc1", "dstsOne", "dsc0", "Dst0", "dst0", " dsc2", " dscOne", "dsp1", "dspb", "dsts0", "Drc2", "dsp0", "drcOne", "dsts1", "dstOne", "Dst1", "dsc1", "Dst2", "Drc1", "drcb", "drc2", " dsc0", "dsp2", "dscOne", "dsc2", "Drc0", "drc0", "Drcb", "Dstb", " dst0", "dsts2", " dstOne", " dsc1", "dscb"], "dst2": [" dST2", "dsrc1", " dST4", " dst4", "dstb", "drc1", "dST2", "dSTb", " dstb", " dST1", "dST1", "dsrc2", "dst4", "drcb", "dST4", " dSTb", "drc2", "dsrcb", "drc4", "dsrc4"], "ref": ["af", "aff", "null", "REF", "bf", "thread", "e", "obj", "Ref", "fe", "pc", "fab", "cb", "ib", "rel", "ob", "def", "db", "rf", "el", "rc", "config", "proc", "reg", "pre", "parent", "rb", "fr", "ctx", "mem", "cache", "buff", "info", "reference", "p", "cl", "req", "bb", "lib", "cal", "f", "re", "lf", "ab", "inter", "buffer", "remote", "r", "conf", "inf", "pb"], "mv": ["mnw", "mf", "mvs", "pf", "Mvp", "Mvs", "smv", " mvp", "mp", "Mq", "nvin", "mnv", "Mvc", "smvp", "dw", "pmv", "dov", "Mf", " mvs", "smvc", "dv", "mq", "pp", " mx", " mh", "dx", "nx", " mov", "Mp", "amov", "pmf", "mvin", "Mv", "bmq", " mq", "mx", "pmq", "mh", "pv", " mp", "Mh", "mw", " mvin", "nv", "bmf", "bmvs", "pmx", "ph", "mnvin", "mov", "amx", "mnx", "Mx", " mw", "mvp", " mvc", " mf", "mvc", "nw", "bmv", "smf", "amw", "amv"], "x_off": ["x_down", "x_load", " x_load", "rx_over", "mx00load", "y_offs", "x55non", "xFnum", "x67offset", "mx_offset", "x__off", "x55off", "rx_off", "xFdown", " x_on", "y_down", "x00load", "y_only", "x00OFF", "x66over", "mx00offset", "xFonly", "x67OFF", "y_num", "x_over", "x_offset", "mx00off", "x67load", " x_orig", "x00offset", "mx_load", "rx_load", "x67out", " x_non", "x_num", "x__OFF", "xFoff", "mx_OFF", "x_non", "x67off", "mx_off", "x_offs", "x55load", "x_orig", "x67orig", "x66off", "x66offset", " x_out", "x_OFF", "x_out", "x_on", "x66load", "rx_offset", "xFoffs", "y_OFF", "x_only", "x67on", "x00off", "mx00OFF"], "y_off": ["x_down", "y_shift", "y67of", " y_now", "y44length", "x_online", "y_length", "i67offset", " y_non", "hop_online", "hop_offset", "y68now", "y_offs", "y68ON", "y44offs", "hop_ON", " y_of", "y67no", "i_offset", "y67length", "y_oa", " y_offs", "y_down", "y44off", "y_now", "hop68offset", "i67off", "hop68online", "hop68ON", " y67off", "i_offs", "y_no", "y_online", " y_shift", "y_non", "y_dev", "i67length", " y_no", "y_ON", "hop68off", "yacnow", "y67off", "yacoff", "y67now", "yl_off", "i67offs", "hop_off", "x_dev", "yacno", "y_offset", "y_on", "y68off", "x_offs", "y_of", " y_down", "yacof", " y67of", "i_length", "y67offset", "y68online", "y68no", "y67offs", "x_OFF", " y67no", "y68of", "yl_ON", "i_off", "y68offset", "y44offset", " y67now", "x_on", " y_OFF", " y_oa", "y_OFF", "yl_on"], "block_w": ["blockablew", "block__wt", " block_wo", "block67i", "block__h", "block67w", "block_wl", "block00h", "Block_wl", "block00width", "Block_w", "Block_wt", "block_wo", "blockablen", "block67wo", "block_wt", "block__w", "block_n", "block__wl", "block00wo", "block67width", "blockablei", "blockJwl", "Block_n", "Block_i", "blockJh", "block00w", "block67n", "blockJwt", "blockableh", "block_i", "block_width", "Block_h", "blockJw", "block67h", " block_width"], "block_h": ["block_hs", "lock_ih", "blockNw", "blocklexhs", "block_c", "blockingh", "block_oh", "blocklexoh", "block__sh", "block00w", "blockableh", "blockrictw", "blockingoh", " block_wh", "blockNhi", "block_ih", "blocklexwh", "block_hi", "blockablew", "blocklexw", " block_hs", "block__hs", "blockrictah", "blocklexh", "lock_w", "block00history", "block_wh", "blockingwh", "blockNh", "blockrictih", "blocklexhz", "block00h", "block__hz", "blocklexsh", " block_history", "block_hz", "blockableih", " block_hz", "blockNc", "block_history", " block_c", "block__h", "lock_h", " block_hi", "block_ah", "lock_ah", "blockricth", "block_sh", " block_sh", "block00sh", "blockingw", "blockableah", " block_oh"], "height": ["quality", "gap", "ty", "deep", "pull", "distance", "volume", "direction", "holes", "length", "size", "above", "style", "Height", "depth", "shape", "y", "level", " Height", "padding", "gh", "images", "dim", "hold", "resolution", "tight", "density", "h", "history", "window", "bottom", "layout", "crop", "missing", "upper", "thin", "stroke", "row", "th", "grow", "w", " heights", "dy", "build", "alpha", "inches", "hang"], "linesize": ["linesization", " linesizing", "linesizable", "linersize", " linesizable", "vertsiz", "linersizing", "framesize", "lesize", "runsIZE", "worksIZE", "filesize", "linesIZE", "lesization", "lesIZE", "linesizing", "timesize", "filesIZE", "facesize", "codesizer", "pagesized", "framesiz", "timesization", "linersiz", "netsizable", "pagesize", "opensized", "opensiz", "codesized", "runsizer", "runsization", "filesizable", "filesization", "linsizer", "worksizer", "linersafe", "posization", "timesIZE", "linesiz", "posizing", " linesiz", "vertsize", "runsize", "facesiz", "facesIZE", "linsized", "elinesizing", "codesize", "netsize", "netsization", "framesizing", "posize", " linesization", "worksization", "linesafe", "netsIZE", "elinesiz", "codesiz", " linesizer", "facesizing", "lesizing", "linsiz", "vertsization", "posIZE", "opensizer", "framesized", "linsize", " linesIZE", "facesafe", "elinesize", "linesizer", " linesized", "pagesizing", "timesizing", "facesization", "pagesiz", "elinesization", "opensize", "linesized", "linsizing", "linsafe", "worksize", "vertsizing"], "mc_func": ["MC2func", " mc_unc", " mc2func", "MC2function", "mc_callback", "mc2func", " mc_function", "mc_function", " mc_cc", "mc__func", "MC_func", "mc2unc", "mc_unc", "mc2cc", "MC_function", " mc2cc", " mc2unc", " mc2function", "mc2callback", "mc__function", "mc__callback", "mc2function", "mc_cc", "MC2callback", "MC_callback"], "src1": ["gl01", "bufpre", "gl1", "seqOne", "source1", " srcOne", "rc2", "sourcex", "rc1", "source2", "glpre", " srcx", "sourcepre", "imgone", "seqx", "srcone", "loc0", "seq2", "buf01", "srcx", "srcOne", "loc2", "rcone", "src0", "img2", "sourceOne", "source01", "buf1", "img1", " src0", "srcpre", "img0", "src01", " srcone", "seq1", "rc0", "loc1"], "src2": ["srctwo", "rc4", "rctwo", "source1", "rc2", " src02", "config2", "rc1", "src4", "source2", " src4", "src02", "config0", "src0", "source0", " srctwo", " src0", "configtwo", "rc02", "config4", "rc0", "source02"]}}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,\n\n                             int width, int height)\n\n{\n\n    int src_wrap, x, y;\n\n    int r, g, b;\n\n    uint8_t *lum, *cb, *cr;\n\n    const uint8_t *p;\n\n\n\n    lum = dst->data[0];\n\n    cb = dst->data[1];\n\n    cr = dst->data[2];\n\n\n\n    src_wrap = src->linesize[0] - width * BPP;\n\n    p = src->data[0];\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            RGB_IN(r, g, b, p);\n\n            lum[0] = RGB_TO_Y_CCIR(r, g, b);\n\n            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);\n\n            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);\n\n            cb++;\n\n            cr++;\n\n            lum++;\n\n        }\n\n        p += src_wrap;\n\n        lum += dst->linesize[0] - width;\n\n        cb += dst->linesize[1] - width;\n\n        cr += dst->linesize[2] - width;\n\n    }\n\n}\n", "idx": 15321, "substitutes": {"dst": [" dest", "idgest", "Dsc", "idST", "tbl", "lbl", " dST", "fput", "lsts", "sost", "fst", "adst", "fsts", "tost", "drc", "stsc", "lgest", "tsc", "dstd", "dnd", "adsc", "dput", "dsts", "tst", "delbl", "Dsts", " dgest", "delsc", "tcast", " dtd", " dnd", "lost", "adrc", "sst", " dstd", "idsts", "dsc", "delst", "dtd", "lnd", " dsts", "delcast", "lST", "sttd", "stst", "dgest", "ssts", " dput", "idst", "lcast", "fest", "ltd", "adsts", "stest", "dST", "lest", "dbl", "Drc", "dest", "sstd", "Dst", "idput", " drc", "idest", " dost", "dost", "lsc", "dcast", " dsc", "lst", "tnd"], "src": ["rs", "tmp", "source", "sc", "st", "dist", "ruby", "sel", "rob", "sur", "ssl", "grad", "slice", "uc", "inst", "sn", "url", "rc", "config", "sub", "rb", "sup", "spec", "ctx", "rss", "gz", "s", "sl", "sr", "sb", "rl", "gb", "stat", "loc", "img", "dest", "support", "cv"], "height": ["wall", "d", "flow", "pull", "direction", "length", "work", "size", "ht", "Height", "depth", "shape", "level", "wp", "rows", "padding", "gh", "resolution", "z", "density", "center", "h", "bottom", "margin", "window", "layout", "crop", "s", "thin", "kw", "row", "grow", "w", "dy", "build", "inches", "hang"], "src_wrap": ["src_break", "src_wrapper", "srclexwork", "src_scroll", "src_work", " src_break", "rc_wrap", "rc_wrapper", "srclexwrap", " src_wrapper", "srclexwrapper", "rc_margin", "rc_scroll", "src_margin", " src_work"], "x": ["ya", "d", "t", "v", "e", "u", "pos", "image", "l", "yx", "in", "wy", "m", "dx", "el", "xy", "ady", "px", "z", "ix", "n", "id", "c", "rx", "i", "h", "s", "index", "ax", "ph", "on", "f", "w", "dy", "X"], "y": ["ya", "d", "o", "ay", "ty", "yo", "v", "ry", "e", "u", "yr", "l", "ny", "wy", "xy", "ym", "vy", "z", "n", "id", "ey", "c", "i", "h", "type", "cy", "f", "w", "Y", "dy", "yy", "j", "py", "oy", "sy", "ye", "t", "gy", "yl"], "r": [" w", "d", "ru", "o", "dr", "rs", "R", "v", "ur", "br", "e", "u", "rh", "l", "ro", "m", "nr", "ra", "a", "rr", "rc", "usr", "pr", "tr", "rb", "n", "fr", "hr", "c", "i", "rx", "h", "s", "ri", "f", "sr", "re", "w", "rl", "er", "err", "rg"], "g": ["d", "gi", "v", "ge", "gm", "e", "u", "cfg", "l", "group", "m", "ig", "gs", "bg", "G", "z", "k", "go", "n", "c", "h", "i", "sg", "q", "s", "gg", "gen", "f", "w", "rg", "j", "gr", "gn"], "b": ["d", "o", "v", "e", "u", "be", "l", "fb", "base", "wb", "B", "db", "m", "lb", "a", "bs", "bh", "rb", "n", "boot", "nb", "bi", "c", "i", "pb", "h", "bp", "s", "f", "sb", "ab", "w", "j", "t", "eb"], "lum": ["lub", "ulub", " lup", "luf", "Luf", " luf", "bluf", "blam", "lul", "slum", "ylam", "llam", "ylul", "slums", " lumb", "llup", "jlums", " lumption", "jlub", "lumption", "plum", "lam", "plumb", "llum", "Lam", " lul", "ulums", "plam", "ulumption", "lums", "plums", "Lumb", "slam", " lub", "ulum", "Lul", "llums", "jlum", "ylum", " lums", "slumb", " lam", "Lup", "ylumb", "blum", "lup", "blumb", "Lums", "jlumption", "Lum", "lumb"], "cb": ["bm", "bd", "ctr", "ba", "cpp", "cn", "cu", "bf", "CB", "bc", "nc", "ff", "cd", "cf", "fb", "ob", "db", "cc", "cmp", "dc", "rf", "uc", "lb", "rc", "lc", "rb", "rib", "ci", "cor", "nv", "cur", "c", "cp", "kk", "bb", "core", "lab", "co", "ctrl", "gg", "mb", "sb", "abb", "ca", "ab", "ub", "eb", "gb", "abc", "buf", "xc", "conf", "pb", "cv"], "cr": ["ct", "ctr", "dr", "pe", "CR", "ar", "v", "sc", "br", "bc", "rh", "pc", "cd", "cf", "kr", "wp", "cc", "db", "sp", "cro", "nr", "rr", "rc", "lc", "pre", "pr", "tr", "rb", "ch", "ci", "cor", "cur", "rm", "c", "rx", "cp", "core", "ph", "cat", "cy", "sr", "Cr", "ca", "err", "ref", "pb", "cv"], "p": ["ps", "fp", "d", "o", "pe", "tp", "ar", "jp", "v", "po", "per", "e", "pt", "pos", "u", "pc", "pm", "l", "pi", "P", "pp", "m", "sp", "api", "pre", "pr", "z", "lp", "par", "n", "np", "pa", "cache", "c", "i", "h", "q", "bp", "f", "w", "pin", "py", "j", "t", "pb"]}}
{"project": "qemu", "commit_id": "a5cf8262e4eb9c4646434e2c6211ef8608db3233", "target": 0, "func": "static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n", "idx": 15341, "substitutes": {"dev": ["debug", "di", "ev", "der", "priv", "dom", "ve", "exec", "data", "user", "nd", "md", "v", "dist", "wd", "conn", "def", "die", "prom", "dc", "mod", "inst", "Dev", "g", "self", "rad", "de", "block", "id", "sd", "dem", "info", "req", "device", "dd", "ver", "ind", "w", "diff", "err", "r", "gd", "conf", "ad"], "d": ["done", "bd", "dt", "nd", "dom", "mad", "md", "e", "ld", "cd", "l", "dat", "ds", "did", "db", "dc", "m", "fd", "pd", "dn", "dl", "g", "ded", "df", "id", "dh", "sd", "c", "s", "p", "device", "od", "b", "dd", "f", "dm", "w", "D", "td", "dy", "gd", "t", "da", "ad"], "path": [" node", "prefix", "enc", "part", "test", " child", "append", "route", "file", "content", "Path", "data", "txt", "link", "image", "dir", "fn", "inner", "end", " parent", "desc", "cmd", "wd", "open", " data", "work", "pattern", "base", "anc", "full", "an", "root", "str", "url", "config", "parent", "method", "key", "n", "cross", "progress", "id", "PATH", "node", "home", "c", "line", "pointer", "clean", "p", "ath", " description", " text", "out", "child", "request", "value", "text", " Path", "loc", "pass", "ref", " index", "code"], "name": ["prefix", "part", "all", "data", "nam", "image", "desc", "package", "size", "alias", "new", "Name", "time", "a", "url", "parent", "key", "word", "block", "n", "self", "ame", "id", "NAME", "version", "node", "x", "no", "info", "type", "device", "f", "out", "w", "names", "nm", "day"], "off": ["how", "o", "Off", "own", "test", "original", "ord", "flow", "all", "data", "down", "raw", "opp", "pos", "obj", "offer", "ff", "end", "ov", "length", "open", " on", "online", "def", "and", "ow", "new", "offset", "of", "error", "fun", "only", "num", "self", "block", "needed", " OFF", "now", "no", "line", "art", "unknown", "on", "offs", "out", "ave", "load", "buf", "OFF", "len", "oa"]}}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n\n                                                       const char *key,\n\n                                                       Error **errp)\n\n{\n\n    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];\n\n    char *accept = NULL, *response = NULL;\n\n    size_t responselen;\n\n\n\n    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,\n\n              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,\n\n                            combined_key,\n\n                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                            QIO_CHANNEL_WEBSOCK_GUID_LEN,\n\n                            &accept,\n\n                            errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n\n    responselen = strlen(response);\n\n    buffer_reserve(&ioc->encoutput, responselen);\n\n    buffer_append(&ioc->encoutput, response, responselen);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    return 0;\n\n}\n", "idx": 15368, "substitutes": {"ioc": ["iou", " iosc", "atiob", "tioca", "tiow", "audiocom", "uoc", "ioow", "iiow", "tioc", "iooc", "riou", "uob", "rioc", "iiou", " ioca", "iioc", "iaosc", "iosc", "iiog", "audiocol", "ioou", "iaow", "uocom", "iocom", "atiocol", "ioca", "atiocom", "iaoc", "tiosc", "iob", "ioog", "iaoca", "uocol", "audiob", "riow", "iog", "riog", "audioc", "atioc", " iow", "iocol", "iow"], "key": ["client", "keys", "cert", "fee", "connection", "seed", "data", "source", "base", "server", "password", "pair", "resource", "error", "KEY", "Key", "channel", "k", "block", "id", "ctx", "phrase", "ip", "x", "input", "secret", "type", "sign", "name", "call", "request", "value", "socket", "text", "conn", "code"], "errp": ["nerc", "errorpe", "errpe", " errpe", "erpe", "derp", " errr", " errf", "errr", "errorr", "nerP", "errf", "errorP", "derc", " errP", "errc", " errc", "nerf", "erP", "errorp", "errP", "derP", "err", "erp", "nerp", "derf"], "combined_key": ["combined_mode", "combosen_secret", "combmented_mode", "combided_id", "combiner_Key", "combinedFprefix", "combined_id", "combined_Key", "combined_secret", "combmented_value", "combined_k", "combided_k", "combosen_prefix", "combided_pair", "combined_pair", "combmented_secret", "combiner_key", "combined_value", "combinedFsecret", "combined_prefix", "combmented_key", "combosen_key", "combided_key", "combosen_Key", "combinedFkey", "combiner_value", "combinedFKey"], "accept": ["update", "enc", "en", "json", "iter", "address", "send", "success", "oc", "received", "content", "xml", "data", "acc", "reflect", "Accept", "image", "result", "message", "length", "adapt", "open", "output", "sel", "exclusive", "hello", "answer", "lex", "respond", "pport", "uc", "valid", "host", "release", "bec", "view", "rec", "ac", "event", "opt", "feed", "input", "control", "close", "other", "agree", "escape", "sign", "reason", "sex", "ack", "name", "crit", "select", "call", "request", "entry", "allow", "esc", "pass", "loc", "connect", "none", "support"], "response": ["body", "en", "json", "o", "success", "received", "xml", "content", "data", "ception", "v", "resp", "results", "onse", "offer", "result", "image", "message", "output", "params", "server", "write", "hello", "resource", "answer", "res", "partial", "respond", "api", "reply", "valid", "wave", "error", "view", " responses", "version", "feed", "http", "application", "secret", "description", "su", "reason", "example", "name", "Response", "request", "value", "respons", "array", "code"], "responselen": ["responselend", "responfllen", "respunselen", "resprongellen", "responsellen", "respongelenc", "respoenselenc", "responcilun", "responcellen", "responnellen", "responselon", "responselleng", "responsella", "responsleng", "respongeleng", "respongelend", "respunselength", "respoenseleng", "responsila", "responclEN", "respunselleng", "respongellen", "responsilen", "responflen", "respronseleng", "responclun", "responcelun", "respongela", "respoensilenc", "responcilen", "responfleng", "responselenc", "responslen", "responcelength", "responnellon", "responcelen", "responseleng", "respunsellz", "responcelEN", "respongelen", "respoenselen", "respunselun", "responclen", "resprongelend", "responselz", "respunselEN", "respoensilen", "responcelend", "respunselon", "respuncilen", "responflend", "respronsellen", "resprongeleng", "responselength", "responcilength", "resprongelen", "responnelleng", "respuncilun", "responsela", "respuncilEN", "responnellz", "responcilEN", "responslz", "responclength", "responsilenc", "respronselen", "respronselend", "responsellenc", "respoensileng", "respunsellen", "respoensila", "respuncilength", "responsileng", "responslon", "responceleng", "respunselz", "respunsellon", "responselun", "respoensela", "responsellon", "respunseleng", "responselEN", "responsellz"]}}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 15373, "substitutes": {"con": ["client", "enc", "en", "cons", "connection", "cn", "com", "exec", "dom", "cm", "bc", "nc", "pc", "anon", "anc", "ec", "login", "an", "conf", "dc", "cc", "uc", "canon", "lic", "dn", "rc", "config", "parent", "channel", "class", "can", "win", "ln", "fc", "ctx", "current", "c", "cache", "conv", "control", "close", "syn", "cl", "col", "core", "inc", "cal", "coll", "co", "ctrl", "Con", "common", "type", "cr", "unc", "mc", "ca", "public", "lang", "CON", "ocon", "connect", "conn"], "src_x": ["src_my", "src00y", "src00xi", "src_rx", "src01x", "src_xi", " src_orig", " src_xi", " src_my", "src01rx", "src00orig", " src_rx", "src00x", "src01y", "src01my", "src_orig"], "src_y": ["src_Y", " src_oy", "src_ny", " src_Y", "src_ya", " src_ny", "src_oy", " src_ya"], "dst_x": ["drc_index", "drc_w", "dsta_xs", "dst_X", "dsts_ix", "dsts_x", "dst_index", "dst_ix", "dst_xs", "dsta_y", "dst_xi", "dst_w", "dsts_X", "dsta_X", "dsts_y", "dsta_x", "drc_x", "drc_xi"], "dst_y": ["dst_dy", "dst_vy", "dst_Y", "dbl_x", "dest_vy", "dbl_y", "dest_y", "dest_i", "dbl_Y", "dest_dy", "dst_bar", "dbl_z", "dst_z", "dst_i", "dest_bar", "dest_x"], "w": ["en", "d", "ew", "o", "wh", "v", "e", "l", "work", "wb", "iw", "y", "ow", "m", "W", "new", "a", " W", "g", "wx", "z", "n", "win", "x", "c", "weight", "ww", "wt", "p", "q", "we", "b", "sw", "f", "r", "fw", "t", "wa"], "h": ["hs", "en", "ha", "o", "height", "v", "e", "uh", "rh", "end", "l", "work", "ih", "y", "hm", "m", "W", "hh", "gh", "hw", "time", "g", "z", "k", "n", "ch", "hr", "sh", "c", "H", "x", "hi", "q", "i", "p", "ph", "b", "f", "r", "t", "help"], "s": ["ps", "sync", "o", "session", "rs", "sc", "cs", "sa", "e", "l", "ds", "sys", "si", "ss", "ssl", "se", "new", "sq", "sn", "g", "self", "n", "os", "spec", "is", "c", "ns", "p", "syn", "b", "sl", "f", "sb", "acl", "ses", "ls", "S", "conn"], "dcl": ["ncl", " dfc", "tcl", "dlf", "tbl", "tlc", "ldCL", "dsl", "ldwl", "idcl", "dhell", "adcel", "fCL", "dwl", "dssl", " dscl", "dacl", "dlcl", "ddfl", "idlc", "dpl", "cdCL", "dlwl", "adcl", " dlc", "ddCL", "dCL", "dsCL", "fscl", "ldfl", "cdcel", "ldscl", "idpl", " dbc", " dsl", "ldbl", "dlfl", "idlf", "dlpl", "adfl", "fcl", "sdcl", "Dlf", "lpl", "sdcel", " dacl", " dbl", "dscl", "cdfl", "lcl", "sdfl", "dsbl", "Dpl", "dcel", "nCL", " dlf", " dCL", "dfl", "lfl", " dcel", "ddcel", "ldsl", "dbc", "dbl", "lacl", "idbc", "cdcl", "Dbc", "idfc", "ldacl", "tfl", "fpl", "idfl", "ddcl", "tfc", "Dcl", "dfc", "ldpl", "tcel", "npl", " dhell", "nscl", " dfl", "ldcl", "tscl", "adCL", " dwl", "sdhell", " dpl", "dlc", "thell"]}}
{"project": "qemu", "commit_id": "3c94193e0bbdd855bcbedabd27e3cbe1e6bc6242", "target": 1, "func": "static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n                                    TCGArg *args, TCGOpDef *tcg_op_defs)\n{\n    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;\n    TCGOpcode op;\n    const TCGOpDef *def;\n    TCGArg *gen_args;\n    TCGArg tmp;\n    TCGCond cond;\n    /* Array VALS has an element for each temp.\n       If this temp holds a constant then its value is kept in VALS' element.\n       If this temp is a copy of other ones then the other copies are\n       available through the doubly linked circular list. */\n    nb_temps = s->nb_temps;\n    nb_globals = s->nb_globals;\n    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n    nb_ops = tcg_opc_ptr - gen_opc_buf;\n    gen_args = args;\n    for (op_index = 0; op_index < nb_ops; op_index++) {\n        op = gen_opc_buf[op_index];\n        def = &tcg_op_defs[op];\n        /* Do copy propagation */\n        if (op == INDEX_op_call) {\n            int nb_oargs = args[0] >> 16;\n            int nb_iargs = args[0] & 0xffff;\n            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        } else {\n            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        /* For commutative operations make constant second argument */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state != TCG_TEMP_CONST) {\n                tmp = args[0];\n                args[0] = args[1];\n                args[1] = tmp;\n                args[2] = tcg_swap_cond(args[2]);\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                args[3] = tcg_swap_cond(args[3]);\n        CASE_OP_32_64(movcond):\n            cond = args[5];\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                cond = tcg_swap_cond(cond);\n            /* For movcond, we canonicalize the \"false\" input reg to match\n               the destination reg so that the tcg backend can implement\n               a \"move if true\" operation.  */\n            if (args[0] == args[3]) {\n                tmp = args[3];\n                args[3] = args[4];\n                args[4] = tmp;\n                cond = tcg_invert_cond(cond);\n            args[5] = cond;\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[1]].val == 0) {\n        /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(or):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                /* Proceed with possible constant folding. */\n            if (temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0) {\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(mul):\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0)) {\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Propagate constants through copy operations and do constant\n           folding.  Constants will be substituted to arguments by register\n           allocator where needed and possible.  Also detect copies. */\n        CASE_OP_32_64(mov):\n            if (temps_are_copies(args[0], args[1])) {\n                args += 2;\n                gen_opc_buf[op_index] = INDEX_op_nop;\n            if (temps[args[1]].state != TCG_TEMP_CONST) {\n                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n                args += 2;\n            /* Source argument is constant.  Rewrite the operation and\n               let movi case handle it. */\n            op = op_to_movi(op);\n            gen_opc_buf[op_index] = op;\n            args[1] = temps[args[1]].val;\n            /* fallthrough */\n        CASE_OP_32_64(movi):\n            tcg_opt_gen_movi(gen_args, args[0], args[1]);\n            args += 2;\n        CASE_OP_32_64(not):\n        CASE_OP_32_64(neg):\n        CASE_OP_32_64(ext8s):\n        CASE_OP_32_64(ext8u):\n        CASE_OP_32_64(ext16s):\n        CASE_OP_32_64(ext16u):\n        case INDEX_op_ext32s_i64:\n        case INDEX_op_ext32u_i64:\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val, 0);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n            args += 2;\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(andc):\n        CASE_OP_32_64(orc):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val,\n                                          temps[args[2]].val);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args += 3;\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[3]);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state == TCG_TEMP_CONST) {\n                if (do_constant_folding_cond(op, temps[args[0]].val,\n                                             temps[args[1]].val, args[2])) {\n                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                    gen_opc_buf[op_index] = INDEX_op_br;\n                    gen_args[0] = args[3];\n                    gen_args += 1;\n                } else {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n            } else {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(movcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[5]);\n                if (temps_are_copies(args[0], args[4-tmp])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {\n                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;", "idx": 15388, "substitutes": {"tcg_constant_folding": ["tcg_constant_buffling", "tcg_constant_consting", "tcg_constant_creatings", "tcg_constant_creatling", "tcg_constant_buffings", "tcg_constant_foldings", "tcg_constant_constings", "tcg_constant_foldoring", "tcg_constant_constling", "tcg_constant_creatoring", "tcg_constant_foldling", "tcg_constant_creating", "tcg_constant_bufforing", "tcg_constant_constoring", "tcg_constant_buffing"], "TCGContext": ["TCCGContext", "TCGPModule", "TCGIConfig", "TCGIModule", "tcCGModule", "tcGContext", "TCGComp", "TCCGConfig", "TCGModule", "TCGPComp", "TCCGModule", "tcGModule", "TCGPConfig", "tcCGComp", "tcGConfig", "tcCGContext", "TCGIContext", "TCGConfig", "TCCGComp", "tcGComp", "tcCGConfig", "TCGIComp", "TCGPContext"], "s": ["storage", "fs", "sync", "d", "sv", "session", "o", "south", "sim", "private", "e", "u", "sci", "sys", "si", "ss", "space", "ssl", "service", "m", "se", "conf", "sq", "sf", "xs", "g", "self", "sup", "n", "os", "spec", "is", "c", "http", "su", "sg", "p", "cli", "ns", "b", "sets", "f", "sb", "ses", "js", "r", "services", "setup", "S", "sym", "t"], "uint16_t": ["uint16_type", "uint8_T", "uint8_t", "uint16_p", "uint16_T", "uint8_type", "uint8_p"], "tcg_opc_ptr": ["tcg_opc_buf", "tcg_opcs_pointer", "tcg_opc2buf", "tcg_opc2alloc", "tcg_opcs_alloc", "tcg_opcs_ptr", "tcg_opcs_buf", "tcg_opc_pointer", "tcg_opc2ptr", "tcg_opc_alloc", "tcg_opc2pointer"], "TCGArg": ["TCGIOpt", "UCGVArg", "UCGVarg", "TCGCarg", "PCGUArg", "TCGOp", "TCgArg", "TCGVArg", "PCGUOpt", "UCGVVal", "UCGVal", "TCGVar", " TCGVar", "TCLGarg", "TCGUVal", "TCGDArg", "TCMArg", "TCgVar", "UCGVArgs", "PCGArg", "TCgParam", "UCGArgs", "TCGDOpt", "TCGParam", "TCGVarg", "TCGIarg", "PCGUarg", "TCLGVar", "TCLGParam", "TCGUArg", "TCGUParam", "TCGCVar", "TCGIArg", "PCGUOp", " TCLGParam", "TCGDParam", "TCGCVal", "TCGOpt", "PCGUParam", "TCMOp", "TCGUArgs", "TCGVal", " TCGParam", "TCMarg", "TCGCParam", "UCGarg", "PCGParam", "TCGIParam", "TCgarg", "TCGCArg", "TCLGArg", "PCGOp", "TCGUarg", "TCGUOp", "PCGarg", "TCGVVal", "PCGOpt", "TCGArgs", " TCGarg", "TCGVArgs", "TCGDarg", " TCLGArg", "TCGCArgs", "TCGarg", " TCLGarg", "TCgOp", " TCLGVar", "UCGArg", "TCGUOpt"], "args": ["enc", "module", "keys", "options", "headers", "ras", "pos", "gas", "dat", "states", "ims", "xs", "spec", "init", "bytes", "atts", "gen", "frames", "flags", "as", "msg", "js", "ics", "names", "uments", "ps", "ins", "ports", "all", "cs", "parts", "pack", "ig", "gs", "a", "arg", "iss", "cache", "is", "ns", "lines", "vals", "ams", "arr", "ants", "help", "ids", "cats", "ars", "data", "empty", "size", "ds", "items", "parse", "stats", "vs", "pres", "ms", "call", "members", "argument", "fields", "py", "alls", "body", "mm", "actions", "ass", "Args", "strings", "grades", "params", "style", " arguments", "doc", "sp", "bs", "config", "g", "ks", "extra", "p", "aws", "groups", "apps", "orders", "words"], "TCGOpDef": ["TCGopcEx", "TCGOcRef", "TCGOpcDef", "TCGopRef", "TCGOpRef", "TCGOpDEF", "TCGOopDef", "TCGopDef", "TCGOpDesc", "TCGopcDef", "TCGOgDef", "TCGopEx", "TCGopcdef", "TCGOpdef", "TCGopcDesc", "TCGOpcDEF", "TCGOpcdef", "TCGOcDef", "TCGOcdef", "TCGOppRef", "TCGOpcRef", "TCGOcEx", "TCGOopDesc", "TCGopcRef", "TCGopcDEF", "TCGOgdef", "TCGOpEx", "TCGOgDesc", "TCGOgDEF", "TCGOppDef", "TCGopDesc", "TCGOppdef", "TCGOpcDesc", "TCGOopDEF", "TCGOpcEx", "TCGopdef", "TCGOopdef", "TCGOppEx", "TCGopDEF"], "tcg_op_defs": ["tcg_op_definitions", "tcg_op2defgs", "tcg_op_defps", "tcg_op_efinitions", "tcg_op2decls", "tcg_op2declinitions", "tcg_op_dfp", "tcg_op_refs", "tcg_op2defs", "tcg_op_defaultp", "tcg_op_dfs", "tcg_op_refgs", "tcg_op_efp", "tcg_op2definitions", "tcg_op_decles", "tcg_op_declps", "tcg_op_efgs", "tcg_op2declp", "tcg_op_declinitions", "tcg_op_defaultps", "tcg_op_refp", "tcg_op2declgs", "tcg_op_dfes", "tcg_op_defaultes", "tcg_op_declp", "tcg_op_efs", "tcg_op_defaults", "tcg_op_dfps", "tcg_op_defes", "tcg_op_declgs", "tcg_op_defp", "tcg_op2defp", "tcg_op_defgs", "tcg_op_decls", "tcg_op_refinitions"], "i": ["it", "ie", "d", "di", "o", "gi", "ini", "iu", "mi", "fi", "v", "iv", "li", "multi", "xi", "e", "u", "mu", "inner", "l", "pi", "uri", "isi", "si", "in", "y", "ai", "ui", "sp", "m", "api", "a", "lc", "ti", "k", "ix", "z", "eni", "n", "ik", "io", "id", "opt", "ci", "init", "bi", "qi", "ip", "x", "mini", "phi", "info", "oi", "hi", "p", "index", "type", "cli", "ri", "ji", "b", "ni", "f", "start", "zi", "ind", "j", "ori", "ii", "I", "yi"], "nb_ops": ["nb_OPS", "nn_ops", "nn_items", "nn_alls", "NB_oops", "nb__hops", "nb__oops", "nn_oops", "nn67eps", "NB_ops", "NB_hops", "nb_alls", "nn_OPS", "nb_eps", "nn67oops", "nb67eps", "NB_OPS", "nb_hops", "nb_oops", "nb_steps", "nb67ops", "nb__OPS", "nb__ops", "nn67items", "nb67items", "nn_steps", "nb67oops", "nn_eps", "nb_items", "nn67ops"], "op_index": ["copxid", "ipop_ind", "op_thread", "cp_index", "gen_inc", "opworkloc", "cop_number", "cop_ind", "ipopworksource", "op_context", "ipop_loc", "op_span", "opxid", "opxindex", "op_number", "gen_context", "op2index", "wp_span", "wp_index", "genalinc", "cp_action", "op2ind", "opalinc", "wp_offset", "gen_index", "op_inc", "op2id", "op_offset", "cop_id", "genalindex", "opxind", "opali", "ipop_source", "opworksource", "copxind", "op_source", "wp_number", "opworkind", "genalcontext", "cop_index", "copxindex", "op_loc", "opxnumber", "opworkindex", "op_i", "cp_thread", "op_degree", "copxnumber", "op_id", "opalindex", "ipopworkind", "op_ind", "op2number", "op_action", "genali", "ipopworkloc", "ipop_index", "ipopworkindex", "cp_degree", "opalcontext", "gen_i"], "nb_temps": ["nb_tempers", "nb_Tempps", "nb_comps", "nb_tempos", "nb_Temp", "nb_tups", "nb__templates", "nb_timplates", "nb_termpoints", "nb__stemples", "nb_termpps", "nb_tuppers", "nb_comples", "nb__stemps", "nb_tupos", "nb_stempps", "nb_tmpps", "nb_timpos", "nb_mempoints", "nb__temps", "nb_stempers", "nb_temples", "nb_termps", "nb_temppers", "nb__tempers", "nb_tmp", "nb_memps", "nb_stemplates", "nb__temples", "nb_stemps", "nb_stemppers", "nb_tempoints", "nb_memples", "nb_timpoints", "nb_Temples", "nb__stempers", "nb_mempers", "nb_tempps", "nb_tuplates", "nb_termplates", "nb_compers", "nb_memplates", "nb_stemp", "nb_temp", "nb_Temps", "nb_timps", "nb_timpps", "nb_tmps", "nb_tmples", "nb_stempos", "nb_stemples", "nb__stemplates", "nb_mempps", "nb_templates", "nb_timppers", "nb_complates"], "nb_globals": ["nb_GLobials", "nb_glocals", "nb_globalobales", "nb_glocations", "nb_glossals", "nb_Glocals", "nb_glocales", "nb_gllocales", "nb_Globations", "nb_GLobales", "nb_Globalls", "nb_GLlocales", "nb_Glocales", "nb_Glocations", "nb_globales", "nb_GLoballs", "nb_globalobals", "nb_GLlocials", "nb_Globales", "nb_GLlocals", "nb_gllocalf", "nb_GLobals", "nb_GLlocalls", "nb_glossalf", "nb_globalls", "nb_glovalls", "nb_glogals", "nb_glovals", "nb_glogials", "nb_glogales", "nb_glovales", "nb_glogations", "nb_glocalls", "nb_globalobalf", "nb_glossalls", "nb_Globals", "nb_gllocals", "nb_glogalls", "nb_gllocalls", "nb_globials", "nb_glovials", "nb_globations", "nb_globalf", "nb_Glocalls", "nb_glossales", "nb_globaloballs", "nb_gllocials"], "nb_call_args": ["nb_callalarg", "nb_all_arg", "nb_call_arg", "nb_callalflags", "nb_all_args", "nb_callerarg", "nb_callerargs", "nb_callalargs", "nb_all_flags", "nb_call_flags", "nb_callerflags"], "op": ["it", "Op", "o", "omp", "oper", "app", "hop", "mp", "oc", "opp", "pos", "obj", "cop", "expr", "open", " pop", "pp", "OP", "post", "root", "cmp", "sp", " ops", "mod", "parent", "proc", "operator", "num", "key", " operation", "arg", "pop", "operation", "opt", "init", "node", "ip", "push", "ext", "top", "p", " operator", "type", "cat", "prop", "oop", "f", "gen", "option", "loc", "opus", "comp", "ops", "code"], "def": ["aux", "dr", "amd", "exec", "decl", "dom", "data", "DEF", "du", "md", "uf", "eval", "del", "obj", "pos", "defined", "desc", "cmd", "definition", "post", "doc", "dep", "new", "grad", "gh", "Def", "ef", "proc", "parent", "df", "sup", "block", "arg", "de", "spec", "id", "init", "dev", "define", "push", "info", "req", "missing", "lit", "gen", "f", "pred", "diff", "adv", "call", "ref", "conf", "da", "comp", "pro", "prev"], "gen_args": ["gen_arg", "gen__abs", "gen_abs", "gen__extra", "gen_parts", "gen___Args", " gen_parts", "gen__params", "gen_params", "gen_Args", "gen___args", "gener_args", "gen__args", " gen_arg", "gener_params", "gen___parts", "gen___arg", "gen_extra", "gen___params", "gener__params", "gen___extra", "gen___abs", "gener_abs", "gener__abs", " gen_Args", "gener_extra", "gener__extra", "gener__args"], "tmp": [" dummy", " arr", " dest", " var", " disp", " orig", " params", " sup", " cat", " obj", "obj", " rc", " ans", " parent", " app", " coord", "proc", "self", " co", " dev", " dup", " accum", " proc", " alloc", " temp", " param", " img"], "cond": ["led", "ered", "ed", "rans", "rier", "ry", "act", "ory", "ress", "ra", "less", "parent", "roll", "ependent", "ainer", "lock", "ort", "ect", "line", "ext", "emon", "rupt", "cle", "load", "irect", "roller", "Cond", "rol"], "state": ["body", "part", "pe", "private", "media", "match", "use", "open", "style", "states", "State", "resource", "post", "new", "inst", "shadow", "str", "parent", "STATE", "un", "are", "power", "pointer", "color", "type", "stroke", "start", "statement", "out", "port", "back", "sy", "rule", "conn", "code"], "nb_oargs": ["nb_oparams", "nb_ioyrs", "nb_iarg", "nb_oavals", "nb_doarg", "nb_offcats", "nb_oworkers", "nb_taxis", "nb_targs", "nb_oitems", "nb_doaux", "nb_oyrs", "nb_inlineargs", "nb_woargs", "nb_ogs", "nb_oaargs", "nb_bargs", "nb_oags", "nb_oigs", "nb_ouworkers", "nb_inlinejobs", "nb_offparams", "nb_oaxis", "nb_tatts", "nb_iaux", "nb_oaux", "nb_ioitems", "nb_ovals", "nb_woworkers", "nb_iargs", "nb_oaarg", "nb_oiaxis", "nb_iitems", "nb_tgs", "nb_oucats", "nb_oaaxis", "nb_woparams", "nb_ioarg", "nb_iojobs", "nb_ojobs", "nb_iobytes", "nb_offargs", "nb_ocats", "nb_iovals", "nb_oiargs", "nb_inlineyrs", "nb_ivals", "nb_oarg", "nb_oatts", "nb_dovals", "nb_ouparams", "nb_oiatts", "nb_uyrs", "nb_ouargs", "nb_oaitems", "nb_inlinebytes", "nb_ubytes", "nb_oaatts", "nb_wocats", "nb_ioargs", "nb_doargs", "nb_ujobs", "nb_bvals", "nb_baux", "nb_barg", "nb_uargs", "nb_obytes", "nb_offworkers"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "substitutes": {"vd": ["uds", "bd", "d", "sv", "vid", "ud", "di", "library", "dr", "dt", "ve", "nd", "vm", "VD", "v", "md", "ld", "cd", "rt", "ov", "hd", "wd", "ds", "vision", "vt", "pd", "fd", "dn", "dl", "df", "ant", "vc", "xd", "nv", "sd", "od", "dd", "va", "lv", "vo", "vg", "td", "vp", "vr", "gb", "gd", "vv", "help", "ad", "cover"], "csock": ["dsOCK", "ksink", "Csocket", "dsink", "ciock", "cocks", "cksocked", "ssocket", "ksocker", "vsock", "ksocked", "bsock", "csink", "cssock", "psink", "csocked", "gsock", "rsocker", " csink", "ciink", "csick", "vsody", "cksick", "ciocket", "gsink", "dsock", "ssocked", "csocks", "cusocket", "vsocker", "dsocker", "Csocker", "dsocks", "csocket", "resOCK", "rsocked", "ksock", "codesock", "bsOCK", "ssocker", "Csink", " csick", "gsick", "psock", "bsink", "jsock", "resocket", "gsody", "ciorp", "jsocket", "vsink", "psorp", " csocket", "vsorp", "cssocket", "cusick", "cksock", "cssOCK", "vsocket", "wsock", "rsock", "dsocket", "ssock", "jsocked", "resink", "csOCK", "wsOCK", "rsocket", " csocker", "jsick", "ksocket", "vsick", "wsocket", "csody", "codesocket", "codesOCK", "cock", "Csock", "resock", "ksocks", "bsocket", " csody", "cocked", "cocket", "codesink", "csorp", "cksocket", "csocker", "wsink", "psocket", "cusocked", "dsocked", "cusock", "cssink"], "skipauth": ["missingacl", "copyuth", "skipacl", " skiputh", "missingauth", "allowauthent", " skipacl", "SkipAuth", "skipAuth", "skipauthent", "missingauthent", "copyauthent", " skipauthent", "Skipauth", "Skiputh", "copyacl", "allowauth", " skipAuth", "Skipauthent", "allowuth", "skiputh", "allowAuth", "copyauth", "missinguth"], "websocket": ["reasocket", "weasockets", "shecksocket", "webswitch", "pebscript", "pesscript", "webset", "weversock", "weversocket", "websock", "webersockets", "wessite", "weaspace", "shebsockets", "shebsock", " wecksite", "wecsite", "hessystem", "weblogystem", "weaswitch", "shebswitch", "wecksockets", " wecksockets", "hessource", " website", "hebsystem", "shecksockets", "rebsocket", "weblogock", "websource", "wecksock", "wecksystem", "websystem", "pessession", "weckswitch", "wealsock", "hebsocket", "wealscript", "webspace", "reaswitch", "pebsession", "wecksite", "wessource", "weckset", "wesscript", "rebspace", "shebsocket", "wealswitch", "reasockets", "wessocket", "pessockets", "wecset", " webset", "websession", "websockets", "wecsocket", "wessock", "rebswitch", "hebsource", "weverswitch", "rebsockets", "website", "wesset", "wecksocket", "wecsockets", "weblogource", "webersocket", "wesspace", "sheckswitch", "webersession", "pebsockets", " websockets", "hessock", "wesswitch", "pebsocket", "weckspace", "wealsession", "webscript", "weasocket", "wealsockets", "weberscript", " wecksocket", "reaspace", "wessession", "hessocket", "pessocket", "wessockets", "weversockets", "hebsock", "wecksource", "wealsocket", "weblogocket", "wessystem", "shecksock", " weckset"], "vs": ["hs", "nav", "v", "pos", "ts", "its", "ov", "vi", "xs", "values", "cv", "qs", "views", "vg", "vas", "flags", "as", "js", "services", "var", "nets", "ps", "fs", "vid", "ins", "ports", "cs", "events", "asts", "ss", "res", "vers", "gs", "sts", "iv", "nv", "ns", "eps", "vals", "lines", "VS", "vr", "Vs", "changes", "verts", "vm", "fg", "ds", "wp", "pg", "state", "vt", "obs", "ils", "pages", "stats", "http", "versions", "blogs", "ms", "las", "env", "alls", "ops", "sk", "sv", "rs", "otes", "ups", "ves", "bs", "es", "ks", "net", "vc", "os", "ums", "s", "va", "vp", "ls", "vv", "css"], "i": ["it", "d", "o", "di", "gi", "iu", "fi", "t", "multi", "v", "li", "e", "xi", "u", "mu", "l", "pi", "base", "abi", "si", "vi", "ai", "ui", "gui", "a", "ti", "ix", "z", "n", "eni", "io", "id", "ci", "bi", "qi", "ip", "c", "x", "phi", "hi", "q", "oi", "p", "index", "ri", "b", "uli", "ni", "f", "zi", "j", "r", "ii", "I", "yi"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 15401, "substitutes": {"s": ["ps", "fs", "sync", "d", "us", "o", "session", "your", "sites", "rs", "ssh", "south", "data", "secondary", "cs", "e", "ts", "server", "ds", "ss", "ssl", "service", "m", "conf", "new", "sq", "gs", "sf", "a", "g", "es", "is", "c", "http", "p", "ns", "b", "aws", "sets", "f", "sb", "ses", "js", "r", "services", "opens", "S", "socket", "t", "sym", "ops"], "res": ["ps", "ids", "enc", "ries", "rs", "Res", "reset", "resp", "results", "ras", "cs", "result", "rest", "rh", "params", "resource", "blocks", "ons", "rows", "ress", "root", "reply", "response", "RE", "error", "rc", "resolution", "reg", "es", "ros", "nos", "pre", "rec", "os", "details", "rev", "rss", "complete", "pres", "rx", "args", "range", "req", "ri", "ver", "vals", "rep", "arr", "ris", "re", "des", "lines", "RES", "ms", "rez", "row", "err", "request", "remote", "r", "opens", "ret", "gr", "rem", "rus", "prev"], "start": ["part", "ie", "step", "ad", "first", "address", "started", "check", "send", "empty", "count", "pos", "rest", "use", "length", "work", "open", "style", "size", "starting", "line", "space", "sp", "offset", "len", "parse", "error", "pre", "like", "id", "Start", "init", "stop", "change", "ish", "x", "max", "art", "info", "set", "range", "index", "p", "none", "min", "name", "mid", "ind", "get", "r", "next", "from"], "end": ["enc", "address", "append", "send", "reset", "patch", "u", "pos", "open", "limit", "api", "stop", "set", "one", "END", "entry", "value", "part", "en", "all", "edge", "e", "use", "End", "path", "ended", "offset", "vert", "last", "id", "x", "max", "c", "close", "pend", "event", "ad", "update", "nd", "after", "rest", "size", "object", "est", "dev", "complete", "order", "name", "code", "ion", "length", "post", "grade", "url", "z", "change", "range", "index", "p", "core", "ending", "begin", "w", "r", "old", "next"], "i": ["it", "d", "ie", "di", "o", "gi", "ini", "mi", "iu", "shift", "reset", "t", "multi", "v", "li", "e", "xi", "u", "l", "pi", "uri", "si", "in", "y", "ai", "ui", "slice", "api", "iii", "ti", "ix", "n", "eni", "io", "id", "ci", "bi", "qi", "ip", "x", "c", "oi", "phi", "p", "cli", "ri", "index", "b", "ni", "f", "zi", "ind", "diff", "j", "r", "ii", "next", "I", "code"], "command": ["execute", "prefix", "clear", "send", "exec", "action", "content", "data", "attribute", "mode", "process", "message", "pattern", "cmd", "script", "package", "password", "query", "uri", "exclusive", "resource", "timeout", "directory", "comment", "response", "resolution", "method", "operation", "escape", "type", "name", "request", "remote", "Command", "function", "sequence", "code"], "pwd_codes": ["pwdpcode", "pwd_desc", "pwdpcod", "pwd_cod", "pwd_code", "pwd2desc", "pwdpdesc", "pwd2code", "pwd2codes", "pw_keys", "pw_codes", "pw_code", "pwdpcodes", "pwd_keys", "pwd2cod", "pw_desc", "pw_cod"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n", "idx": 15411, "substitutes": {"opts": [" optters", " optt", "ott", "copms", " opttt", "copter", " opks", " opls", " optments", "opter", "optips", " optcons", "optt", "opcons", " opter", "otms", " opms", " opttips", "otts", "opttt", "copters", "optts", " opcons", "otters", "opments", " optips", " opters", "otks", "optments", "opttips", "opls", "optls", "optcons", "operter", " optts", "opks", "operters", " opps", "opters", "operps", "opps", "optter", "copts", "optters", "optks", " opments", "operts", "otls", "optps", "opms", "otter"], "dummy": ["dumper", "tucky", "Dumper", "ducky", " dumper", "tumper", "Ducky", "Doo", " doo", "tummy", " ducky", "too", "Dummy", "doo"], "opt": ["json", "iter", "step", "ott", "oper", "hop", "append", "options", "null", "ord", "temp", "txt", "nt", "loop", "pot", "op", "pos", "obj", "expr", "open", "qt", "timeout", "OP", "object", "dot", "oss", "grad", "error", "config", "parent", "vert", "num", "go", "skip", "item", "id", "optim", "init", "Opt", "info", "ext", "p", "cat", "inter", "select", "err", "option", "term", "text", "alt", "dest", "prev"]}}
{"project": "FFmpeg", "commit_id": "fe448cd28d674c3eff3072552eae366d0b659ce9", "target": 0, "func": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n\n                                AVFrame *picture)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y;\n\n\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkno = 0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n\n                    band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        if (codsty->transform == FF_DWT97)\n\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n\n                        else\n\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        /* inverse DWT */\n\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->cdef[0] < 0) {\n\n        for (x = 0; x < s->ncomponents; x++)\n\n            s->cdef[x] = x + 1;\n\n        if ((s->ncomponents & 1) == 0)\n\n            s->cdef[s->ncomponents-1] = 0;\n\n    }\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = picture->data[plane] + y * picture->linesize[plane];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * pixelsize + compno*!planar;\n\n\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                line += picture->linesize[plane];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            uint16_t *linel;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = linel + (x * pixelsize + compno*!planar);\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                linel += picture->linesize[plane] >> 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 15420, "substitutes": {"s": ["ops", "fs", "d", "sync", "o", "session", "sv", "site", "com", "e", "cs", "u", "ts", "l", "ds", "bis", "sys", "si", "space", "ssl", "lex", "m", "service", "sq", "gs", "sf", "sec", "g", "es", "sports", "self", "n", "os", "spec", "c", "i", "sg", "p", "ns", "scope", "cli", "sl", "sets", "f", "sb", "ses", "js", "ls", "sky", "services", "t", "sk"], "tile": ["phy", "ie", "chip", "ile", "file", "dt", "site", "txt", "texture", "ge", "e", "image", "Tile", "tle", "style", "tri", "pixel", "ele", "slice", "frame", "tf", "scale", "audio", "rice", "node", "so", "layer", "cli", "component", "device", "tto", "coll", "sl", "metadata", "kt", "tg", "ski", "port", "tu", "sample", "te", "setup", "cell", "tif", "video", "t", "ole", "img", "sk"], "picture": ["fm", "document", " image", "pic", "iframe", "cam", " frame", "fi", "movie", "media", "image", "feature", "rame", "fram", "fb", "play", "mpeg", " pic", "audio", "fps", "avi", " f", "mac", "ref", " Frame", " img", "video", "img"], "compno": ["collpos", "domno", "collna", "compnu", "compeno", " compna", "componentlo", "domnon", " complo", " compeno", "hostyes", "compnumber", "cmpno", "proplo", " compnumber", "playnu", "comporno", " comporno", "collno", "configcho", "componentnumber", "collnumber", "zipnu", "propnumber", "compna", "playna", "confignon", "zipyes", "componentno", "zipno", "comppos", "Compno", "compnon", "playno", "hostorno", "zipna", "zipcho", " compnu", "playnumber", "propna", "Compyes", "Compnum", "hostpos", "componentpos", "hostnum", "proppos", "cmporno", "compnum", "compyes", "compcho", "zipnon", "cmpyes", "Compeno", "propno", "configyes", "hostnumber", " compnum", "hostna", " comppos", "domyes", "zipnumber", "hostno", "domcho", "hosteno", "complo", "cmpna", " compyes", "configno"], "reslevelno": ["reslevelnt", "rezstagenumber", "rusdayname", "reslayernumber", "reslayerorno", "rezlevelnumber", "rescolllo", "resstagenos", "resallnum", " reslayerorno", "resslevelnt", " reslayerno", "reslayername", "preslayernum", "reslevelsorno", "reslayern", "resslevelnos", "resfullno", "resstagenon", "rescolnumber", "reslevelsnum", "reslevelnos", "reslevelnon", "rezstageno", "resscolnumber", "resday1", "rusdayno", "ressletternumber", "resscolno", "resall1", "resslevelnum", "reslevelsno", "resfullnumber", "resletterno", "ressleveln", "resallno", "preslevello", "resslevelno", "ressletternum", "rescollno", "reslayernum", "reslevelnumber", " reslayernumber", "resalllo", "resfullnon", "resslettern", "resscolnt", "resallnos", "rescolno", "rezlevelno", "resfullnos", "reslettern", "reslvlnos", "reslvlnt", "rezlevelnos", "preslevelnum", "rezstagenos", "rescolnos", "reslevelsnumber", "reslayernon", "rescollnum", "resletternumber", "reslvlno", "reslayernt", "ruslevel1", "resletternum", "resmodelno", "resmodeln", "reslevelnum", "resstageno", "preslayernos", "resdayno", "preslevelnos", "reslayer1", "reslayerlo", "resstageorno", "preslayerno", "reslayernos", "reslevelorno", "ruslevelname", "resdayname", " reslevelorno", "reslevello", "reslvlnumber", "ruslevelno", "preslayerlo", " reslayernum", " reslevelnum", "reslayerno", "resmodelnum", "resleveln", "rusday1", "resmodelnumber", " reslevelnumber", "reslevelname", "preslevelno", "resscolnos", "rescollnos", "resallname", "resslevelnumber", "resstagenum", "rezstagenon", "rezlevelnon", "rescolnt", "reslevel1", "ressletterno", "resstagenumber"], "bandno": ["fieldnode", "bandnon", "bandeno", "tagorno", " bandnumber", "diskno", "fieldko", "bootpos", "blockyes", "roadno", "bandsn", "blockNo", "tagyes", "cellko", "bandpo", "bandnumber", "bootlo", "disksn", "bandyes", "roadlo", "portNo", " bandeno", "cellNo", "bandNo", "bandnos", "patchno", "tagnos", "bootpo", " bandnos", " bandorno", "cellpos", "bootnum", "compnode", "bootko", "bandna", " bandNo", " bandnu", "bandko", "bandorno", "porteno", "tagna", "patchnos", "tagno", "bandnu", " bandnum", "cellnon", " bandko", "tagNo", "patchna", "disklo", "fieldno", "fieldnumber", "roadpo", "blockno", "diskpo", "bandlo", "celleno", " bandyes", "portno", "cellno", "compnumber", "bandnum", " bandna", " bandnon", "patchnu", "compko", "blockorno", "bootsn", "bandnode", "tagnu", "bootno", " bandnode", "portnon", "cellnum", "roadsn"], "x": ["d", "o", "height", "t", "v", "e", "pos", "u", "image", "l", "val", "yx", "m", "dx", "xy", "yl", "xx", "a", "wx", "z", "ix", "n", "ip", "c", "h", "i", "rx", "p", "index", "ax", "ex", "b", "on", "f", "name", "w", "xxx", "Y", "X", "code"], "y": ["ya", "d", "o", "ay", "all", "yo", "ry", "e", "yt", "obj", "year", "l", "lon", "m", "this", "ym", "vy", "_", "g", "z", "n", "id", "ey", "q", "i", "h", "p", "index", "type", "col", "b", "f", "w", "buffer", "Y", "yy", "dy", "oy", "sy", "j", "r", "t", "yi", "yl"], "line": ["LINE", "data", "Line", "link", "record", "source", "mode", "e", "l", "output", "style", "val", "frame", "time", "lin", "unit", "block", "lay", "layer", "cpu", "coll", "lines", "out", "buffer", "cell", "len", "code"], "t1": ["t4", "Tone", "m3", "f2", " tone", " t2", "T3", "t3", "f1", "tone", "m1", "T1", "m2", "m4", "c3", "c4", "t2", "T2", "f3", " t3", "c1", "c2", "T4", "fone"], "comp": ["omp", "oper", "app", "hop", "imp", "Component", "chrom", "com", "pro", "op", "con", "project", "comb", "cop", "prof", "def", "pixel", "cc", "cmp", "dep", "mod", "Comp", "om", "sec", "seq", "unit", "lc", "config", "supp", "cond", "par", "comm", "ch", "spec", "ctx", "c", "mac", "cp", "coord", "p", "company", "component", "col", "b", "cl", "coll", "lib", "common", "clip", "prop", "crit", "cel", "prep", "cell", "loc", "ref", "pack"], "codsty": ["compty", " codty", "compgy", "cmdestyle", "codesty", "codsym", "codgy", "codpoly", "Codsty", "Codst", "compsty", "codedst", "codstal", "codestyle", "cmdsys", "cbsty", "codedsty", "Codety", "cbpoly", "codedstal", " codsys", "chemgy", "codty", "cdst", "cdstal", "comppoly", "chemsty", "compsym", "cmdstyle", "cdsty", " codsym", "codeestyle", "cmdsym", " codstyle", "chemty", "codsys", "cdety", "codety", "cmdsty", "codesys", "codst", "compsys", "chempoly", "Codstal", "codstyle", " codestyle", "codedety", "cbgy", "cbty", "cmdty"], "rlevel": ["arlevel", " rletter", " rcoll", "lcl", "srinc", "prpe", "prflow", "srcl", "brvel", " rcomp", "Rlevels", "rlevels", "llevels", "Rpe", "lcoll", "rcl", " rflow", "llevel", "rinc", "rsync", "Rflow", "srlevels", "bletter", "clevel", "bsync", " rlevels", "brLevel", "prlevel", "rpe", "blevel", "srlevel", "clevels", "rflow", "arvel", "Rlevel", "brlevels", " rinc", "lLevel", "ccoll", "rcomp", " rsync", " rpe", "prlevels", " rLevel", "linc", "bvel", "rvel", "lcomp", "arsync", "arletter", " rvel", " rcl", "ccomp", "brlevel", "lvel", "rletter", "rcoll", "rLevel"], "nb_precincts": ["nb_precribute", "nb_precuncting", "nb_precresss", "nb_preCinctes", "nb_precruptes", "nb_precrited", "nb_precinctors", "nb_precressing", "nb_prercinctions", "nb_preCuncts", "nb_precincting", "nb_precruptions", "nb_precrits", "nb_preCunctes", "nb_prercruptors", "nb_precinctions", "nb_precuncts", "nb_precributors", "nb_preCincted", "nb_preCunctions", "nb_precractions", "nb_precrupte", "nb_preCrites", "nb_precritions", "nb_prercruptions", "nb_precinds", "nb_precindions", "nb_precrupted", "nb_precrupts", "nb_precinding", "nb_precindes", "nb_precractes", "nb_precincted", "nb_precracted", "nb_precressions", "nb_precunctes", "nb_preCincting", "nb_precrites", "nb_precruptors", "nb_prercrupte", "nb_precracts", "nb_precresses", "nb_preCritions", "nb_preCuncting", "nb_preCrited", "nb_precinctes", "nb_prercrupts", "nb_precrite", "nb_prercinctors", "nb_precritors", "nb_prercincts", "nb_precributs", "nb_preCinctions", "nb_preCrits", "nb_prercincte", "nb_precunctions", "nb_precributions", "nb_preCincts", "nb_precincte"], "precno": ["prefnone", " prepcNo", " prerecnone", "prefeno", " prepceno", "precpo", "prefauto", "prepceno", " prerecNo", "prefNo", "prebyes", "perfNo", "procno", "prekno", "prerecauto", "preacNo", "propno", "preacauto", "percnone", "prepcNo", "prepnos", " prepcindex", "percyes", "precyes", "prefindex", " prepcno", "prepyes", "precatpo", "prekyes", "perfnone", "prechnone", " prerecno", "precatnos", "precatyes", " prerecmo", "precnum", "precnos", "prefnum", "percauto", "prercNo", "procnos", "prebpo", "preppo", "prechno", "precindex", "prerecnone", "precatnone", " precmo", "perfno", "precauto", "percnum", "procyes", "prerceno", "prefno", "precNo", "propnos", "propyes", "precatNo", "perfauto", "proppo", " preceno", "preacno", "precmo", "prebno", "prefyes", "prefmo", "percNo", " precNo", "prebnos", "prerecNo", " precnone", "prechmo", "preacnum", "perfnum", "prerecno", "prechNo", "prerecmo", "prerecnum", "prercindex", " precindex", "procpo", "perfyes", "prepcindex", "precnone", "preknone", "prepno", "prekNo", "percno", "prepcno", "preceno", "precatno", "prercno"], "band": ["output", "work", "group", "channel", "boot", "bb", "component", "brand", "song", "back", "part", "batch", "guide", "position", "flow", "amp", "loop", "Band", "camp", "cmd", "play", "db", "tag", "audio", "word", "now", "event", "contact", "gap", "plane", "ball", "bass", "pp", "bin", "bus", "book", "service", "phase", "dev", "stage", "ph", "lab", "coll", "bit", "bands", "cell", "bound", "code", "bd", "d", "app", "connection", "board", "ground", "mode", "project", "direction", "length", "style", "pair", "bind", "broad", "bridge", "host", "low", "version", "product", "coord", "layer", "range", "core", "device", "b", "co", "f", "gb", "plugin", "function"], "bandpos": ["bandpo", "bandPos", "cellno", "bandloc", "groundPos", "Bandno", "cellpo", "groundloc", "bandposition", " bandPos", "boardposition", "groundposition", "groundpos", "bootpo", "Bandpos", "bootpos", "cellpos", "bitpos", " bandloc", "bitPos", "Bandpo", "bitposition", "bootposition", "boardpos", "BandPos", "bitloc", " bandposition", " bandpo", "cellPos", "boardpo"], "prec": ["Preci", "perc", "Pref", " prek", "prb", "Preb", "precs", "precu", "pere", "perf", "prof", "prh", " pref", "prk", "percs", "perci", "arecs", "pec", " pree", "pecs", "aref", "preh", "procu", "percu", "proc", "pev", "perv", "pre", "cale", "calc", "proci", "Precu", "prek", "pef", "perh", "Preh", "prc", "perb", "preci", "prf", "Prec", "pree", "arev", "calcu", "arec", "calf", "pref", "prcu", "preb", "prev", "perk"], "cblkno": ["cblkknumber", "cplqcho", "cblcinfo", "cblkidno", "cblktNO", "cplkNO", "cblechpos", "cmlfnum", "cblikNO", "cplkyes", "cblnnum", "cbakna", "cblkcho", "cblekpos", "cmlknum", "cblkidyes", "cblqno", "cplqNO", "cblchno", "cblkpos", "cblkNO", "cblfno", "cblmknum", "cblkidna", "cblnno", "cblkeorno", "cblcno", "cmlkno", "cblktpos", "cbakidno", "cblkidnor", "cblkidNO", "cblikna", "cblcnumber", "cblkyes", "cblekno", "cblkenor", "cbakidna", "cblechnor", "cblkkno", "cblknor", "cblmknumber", "cblpyes", "cblchpos", "cplkno", "cplkcho", "cblchnor", "cblqyes", "cplqno", "cbakpos", "cbakidNO", "cblmkno", "cblfeno", "cblkepos", "cblkseno", "cblpno", "cblchorno", "cblkeno", "cblechorno", "cblekorno", "cblksno", "cblmkinfo", "cmlfno", "cmlfeno", "cblfnum", "cblksnum", "cbakNO", "cblikno", "cplqyes", "cblechno", "cblktno", "cblknum", "cmlkeno", "cblikpos", "cbakidpos", "cblkorno", "cblcnum", "cblktna", "cblqcho", "cblkidcho", "cblknumber", "cblneno", "cblkidpos", "cblkknum", "cbleknor", "cblkinfo", "cblpcho", "cblkna", "cblpNO", "cbakno", "cblqNO", "cblkkinfo", "cblkidorno"], "cblk": ["crelke", "cbrkin", "Cblks", "cablkin", "cbrc", "cbalkin", "csynkk", "cplke", "crenak", "cplk", "crelsk", "cablk", "callkt", "cBlke", "dblkh", "scablsk", "crelc", "cBlc", "cglk", "cplsk", "dblke", "cblkt", "ecblkid", "dmlck", "crelk", "ecblck", "scblak", "cplks", "dblck", "CBlk", " cblb", "cronkin", "scblk", " crelke", "cablsk", "cablak", "cmlck", "cbalck", "cllk", "cllc", "cllok", "cllck", " crelok", " cblkin", "cblb", "Cblk", "cblkid", "cmlke", "ecglkid", " crelb", "Cblkin", " cablkin", "crensk", "ecblk", "ecglkin", "cronk", "cblok", " cblkk", " cblks", "cglkin", "scablk", "CBlks", "csynk", "CBlkin", "crelok", "cllks", "crelb", "cwnc", "dmlk", "Cblc", "scblkt", "cmlk", "cbalke", " cblc", "cblkk", "cblck", "cBlk", "csynkin", "cmlkh", "cmlkin", "dmlkin", " cablsk", "dblk", "scblsk", "cblks", "cblkh", "cablkk", " crelc", " crelk", "callak", "callk", "dmlke", "cllkin", "dmlkh", "cBlsk", "cglkid", "cblkin", "cwnk", "scablak", "cllkid", "ecblkin", "cbrk", "crenkt", "cbrks", "cglck", "crelks", "cBlks", "cllb", "CBlc", "csynsk", " cblsk", "ecglck", "ecglk", "cBlkin", " crelsk", " crelks", "cbalk", "cblak", "cblsk", "cwnok", "crenk", "cblke", " cblok", "cronsk", " cablkk", "cronkk", "cwnb", "callsk", "cblc", "dblkin", "cablkt", "scablkt", " cablk", " cblke"]}}
{"project": "qemu", "commit_id": "158fd3ce98afd21f2e2639600f6414ea703a9121", "target": 0, "func": "void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n", "idx": 15434, "substitutes": {}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n\n                                           struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    xendev = xen_be_find_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    /* init new xendev */\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",\n\n             xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n", "idx": 15449, "substitutes": {"type": ["part", "module", "app", "ty", "pe", "site", "user", "mode", "op", "year", "base", "model", "size", "style", "rel", "length", "server", "y", "types", "loc", "domain", "ype", "attr", "TYPE", "time", "typ", "error", "unit", "pre", "role", "sub", "key", "class", "block", "like", "parent", "id", "version", "home", "Type", "code", "family", "company", "device", "col", "mon", "ver", "prop", "name", "py", "platform", "plugin", "var", "null", "kind"], "dom": ["debug", "module", "d", "di", "bug", "DOM", "Dom", "data", "deep", "md", "du", "user", "mode", "dist", "dir", "cmd", "model", "def", "depth", "path", "db", "dc", "domain", "root", "mod", "ym", "om", "time", "dim", "fun", "url", "host", "num", "typ", "class", "block", "low", "id", "mem", "node", "product", "home", "version", "dem", "coord", "device", "mon", "virt", " domain", "rom", "ver", "prop", "dm", "name", "mid", " dyn", "dy", " dim", "code"], "dev": ["debug", "d", "engine", "di", "bug", "app", "ev", "der", "priv", " device", "data", "user", "dist", "mode", "DEV", "pub", "rel", "serial", "def", "depth", "dis", " devs", "dc", "prom", "mod", "inst", "valid", "dim", "fun", "comment", "Dev", "rad", "block", "de", "id", "mem", "version", "development", "dem", " def", "info", "req", "device", "dd", "virt", "ver", "name", "des", "diff", "adv", "err", "conf", " dim", "var", "kind"], "ops": ["ps", "o", "oper", "app", "hop", "options", "rs", "opp", "loop", "cs", "op", "obj", "ups", "pos", "ts", "cop", "outs", "errors", "params", "ds", "ob", "ro", "OP", "opers", "root", "inst", "plugins", "OPS", "obs", "scripts", "proc", "operator", "pps", "ips", "os", "operation", "Ops", "opt", "boot", "bits", "ip", "vs", "http", "oops", "ns", "lib", "eps", "scope", "aps", "tx", "uts", "oop", "flags", "utils", "ms", "js", "apps", "ents", "opens", "trans", "opus", "alls", "img"], "xendev": [" xenev", "xlineef", "xestep", " xendiev", "xndef", "xentep", "xndee", "axchangeev", "axendev", "xxentdev", "xenew", "xadddev", "xendeddev", "xxentev", " xndever", "xestever", "xxenderv", "xendeng", "xenapter", "wxendederv", "xaddef", "axenddev", "wxendeddev", "exendeng", " xstartdev", "xendapter", "exndek", " xendedee", "xadexp", "xendsew", " xendeddev", "exndevin", "xendexp", "xenee", " xndov", "xenderevin", "xenev", "axchangeiev", "exendov", "xadeever", "xendederv", "exenew", "xendsev", "xestov", "xesterv", "xaddee", " xendedev", " xstartruction", "rxendek", "xedgeev", "xstartef", "xenderv", "xendew", "xentee", "exenek", "rxentapter", "xendedever", "xendiv", "xendek", "xndeng", " xstartever", "xxendev", "rxendapter", "xlineev", "xchangeev", " xstartef", "xnderv", "xenterr", "xestek", "exendew", "xentapter", "rxendev", "exndev", "xendsere", "xestdev", "rxendedever", " xendov", "exendiev", "xenever", "axchangeov", " xendef", "xestef", "xentere", "xendingerv", " xendedek", "Xendeddev", "exenere", "wxendedef", "xlineiev", "wxendederr", "xenek", " xndev", "xendedek", " xndee", "wxendiv", "exndef", " xstartiev", "xendever", "wxendev", "wxendef", "wxendedek", " xendee", " xenov", " xenee", "exndever", "wxenddev", "exenduv", "axchangedev", "xenerv", "exendek", "xstartiev", "wxenderr", "xndov", " xenderv", "xedgeov", "xendedev", "xxentov", "xentiev", "xadek", " xenerv", "xendiev", "xentdev", "Xendedever", "xadeef", "wxenderv", "xxendov", "exendexp", "exenep", "xendsdev", "rxenterv", "xlinedev", "xenterv", "xeniev", "xaddek", "xstartev", "xendeduv", "rxentev", " xenddev", "xendedef", "xchangedev", "rxenderv", "Xendever", "rxendever", "exenev", "xestiev", "exenef", "exndov", " xendek", "exenuv", "rxenddev", "xstartee", "xchangeiev", "Xendov", "xndek", "xadev", "Xendedef", "xentef", "wxendek", "xentek", "xadef", "Xendef", " xenef", "xnderr", "xentev", "xentevin", "xndev", "xaddever", "rxendedek", "xendedee", "xstartek", "xenep", "exndeng", "xentov", "exndexp", "xedgeiev", "xenderr", "xnddev", "axendiev", " xstartev", "xendevin", "xendov", "xxenddev", "xndevin", "rxendedev", "xendediv", "xadeev", "xendedruction", "xenef", "xendederr", "xxenterv", "exendev", "xenteng", "xendruction", "xenddev", "xenuv", "xndiv", "xadever", " xnddev", "axendov", "xenere", "exendep", "xenderdev", "wxendediv", "xendedexp", "exendef", "exendevin", "xstartov", "rxendeddev", "xendereng", "xenduv", "Xendedov", "xendingapter", "xendee", "exenddev", "xendef", "Xendedev", "Xenddev", "xaddev", " xndek", "xchangeov", "xndep", "xendingev", "exndiev", "xenderev", "xstartdev", "xstartruction", "xentruction", "xendep", "xentew", "xestee", " xendever", "xstartever", "xendingef", "xadeiev", " xstartee", "xendere", "wxendedev", "xenov", "xndever", "xeniv", "Xendev", "exendever", "xendedov", "exnddev", "xadov", "rxentdev", "xendingdev", "xadderv", "xndiev", "xendinguv", "xedgedev", "xndexp", "xestev", " xendruction", "exendere"]}}
{"project": "qemu", "commit_id": "c54616608af442edf4cfb7397a1909c2653efba0", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 15457, "substitutes": {"lexer": ["lexeder", "codter", "lege", "codec", "lexe", "legers", " lexeder", " lexter", "Lexers", "lexec", "leger", "linter", "callers", "Lexeder", "callter", "linec", "coder", " lexe", "line", "Lexter", " lexers", "liner", "lexter", "legeder", "Lexer", "lexers", "calle", "caller", "Lexe", "Lexec", "code"], "token": ["prefix", "document", "json", "iter", "o", "atom", "field", "number", "language", "xml", "ok", "seed", "data", "reader", "Token", "txt", "author", "tree", "source", "message", "random", "element", "uri", "note", "writer", "header", "lex", "tag", "str", "sn", "parse", "comment", "config", "channel", "key", "word", "tick", "item", "id", "node", "input", "i", "info", "wt", "layer", "KEN", "name", "template", "call", "er", "yy", "option", "translation", "text", "socket", "event", "argument", "rule", "oken"], "type": ["part", "o", "ty", "field", "pe", "action", "data", "link", "e", "op", "format", "direction", "length", "rel", "size", "style", "post", "level", "types", "kind", "path", "tag", "state", "api", "TYPE", "time", "typ", "error", "pre", "parent", "method", "key", "class", "like", "block", "lock", "handler", "id", "spec", "version", "Type", "no", "i", "info", "set", "complete", "p", "name", "or", "call", "py", "value", "t", "none", "number", "ping", "code"], "x": ["d", "position", "X", "v", "e", "pos", "l", "length", "in", "m", "xx", "xs", "z", "ix", "key", "k", "n", "id", "c", "i", "h", "p", "index", "ex", "on", "b", "f", "name", "w", "t", "number", "code"], "y": ["ya", "o", "ay", "yo", "e", "year", "size", "ny", "m", "zy", "vy", "xx", "z", "key", "k", "n", "id", "ey", "c", "i", "s", "p", "index", "b", "f", "start", "w", "Y", "yy", "dy", "sy", "oy", "j", "py", "sky", "t", "yi"], "parser": ["Parser", "test", "list", "jack", "pillar", "command", "above", "writer", "parent", "operator", "man", "self", "spec", "scan", "upper", "instance", "template", "master", "value", "driver", "client", "part", "xml", "arser", "seed", "author", "local", "magic", "worker", "ser", "winner", "processor", "builder", "header", "slice", "block", "handler", "node", "now", "context", "input", "ler", "missing", "ger", "ner", "buffer", "event", "rule", "manager", "database", "json", "iter", "file", "ars", "data", "message", "script", "enter", "wp", "book", "root", "this", "comment", "parse", "general", "php", "lp", "oder", "http", "argument", "document", "der", "reader", "tree", "inner", "server", "pair", "post", "lex", "super", "player", "config", "args", "layer", "p", "python", "loader", "er", "plugin", "pack"], "dict": ["module", "auth", "d", "json", "di", "document", "session", "bug", "sync", "dr", "file", "der", "list", "hash", "data", "patch", "pillar", "record", "po", "tree", "dir", "result", "obj", "pkg", "model", "copy", "pair", "style", "def", "doc", "db", "object", "dot", "map", "state", "slice", "str", "parse", "response", "config", "parent", "df", "key", "ict", "cache", "clean", "info", "set", "dd", "cat", "coll", "table", "arr", "gen", "diff", "build", "pass", "sum", "conf", "database", "array", "code"], "brace_count": ["plateaccount", "stroke_key", "stroke_count", "braceacindex", "brace64cond", "plateacindex", "braceaccount", "brace_width", "repeat_count", "open_count", "repeat_cond", "brace\u00b7key", "repeat_length", "open_key", "stroke_time", "plate_width", "plate_match", "plateacwidth", "brace\u00b7count", "brace_cond", "brace_key", "brace64found", "braceacwidth", "plate_count", "bracePoolcond", "brace_depth", "brace64length", "brace_size", "brace_code", "line_size", "brace_catch", "stroke_length", "brace_field", "brace64count", "iron_field", "line_catch", "brace\u00b7start", "braceboardkey", "brace\u00b7depth", "iron_count", "braceacmatch", "brace\u00b7cond", "brace_length", "repeat_found", "line_count", "braceboardcount", "brace\u00b7length", "braceboardlength", "brace_time", "bracePoolcount", "bracePoolsize", "braceboardtime", "line_cond", "brace\u00b7code", "brace_index", "iron_depth", "plate_index", "brace\u00b7catch", "brace_found", "open_length", "brace\u00b7field", "brace\u00b7size", "brace_match", "plateacmatch", "iron_code", "brace_start", "bracePoolcatch", "open_start"], "bracket_count": ["branch_count", "brace_group", "bracket_length", "bracketlesscount", "bracket_type", "branch_flag", "bracket\u00b7group", "bracket_sum", "bracket_len", "branch_size", "bracket_age", "brace_depth", "brace_size", "bracket\u00b7len", "bracket_size", "brace_path", "bracket_depth", "brace_length", "brword_number", "bracket_default", "bracket_flag", "brword_count", "brace_type", "bracket\u00b7count", "bracketlesssize", "brace_age", "brace_default", "bracket_group", "brace_len", "brace_sum", "bracketlessflag", "bracket_number", "brword_size", "brword_length", "bracket_path"]}}
{"project": "qemu", "commit_id": "076b35b5a56bca57c4aa41044ed304fe9c45d6c5", "target": 0, "func": "static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)\n\n{\n\n    uint64_t sz;\n\n    const char *mem_str;\n\n    const char *maxmem_str, *slots_str;\n\n    const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *\n\n                                        1024 * 1024;\n\n    QemuOpts *opts = qemu_find_opts_singleton(\"memory\");\n\n\n\n    sz = 0;\n\n    mem_str = qemu_opt_get(opts, \"size\");\n\n    if (mem_str) {\n\n        if (!*mem_str) {\n\n            error_report(\"missing 'size' option value\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        sz = qemu_opt_get_size(opts, \"size\", ram_size);\n\n\n\n        /* Fix up legacy suffix-less format */\n\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n\n            uint64_t overflow_check = sz;\n\n\n\n            sz <<= 20;\n\n            if ((sz >> 20) != overflow_check) {\n\n                error_report(\"too large 'size' option value\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* backward compatibility behaviour for case \"-m 0\" */\n\n    if (sz == 0) {\n\n        sz = default_ram_size;\n\n    }\n\n\n\n    sz = QEMU_ALIGN_UP(sz, 8192);\n\n    ram_size = sz;\n\n    if (ram_size != sz) {\n\n        error_report(\"ram size too large\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* store value for the future use */\n\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n\n    *maxram_size = ram_size;\n\n\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n\n    slots_str = qemu_opt_get(opts, \"slots\");\n\n    if (maxmem_str && slots_str) {\n\n        uint64_t slots;\n\n\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n\n        if (sz < ram_size) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n\n                         sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        } else if (sz > ram_size) {\n\n            if (!slots) {\n\n                error_report(\"invalid value of -m option: maxmem was \"\n\n                             \"specified, but no hotplug slots were specified\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        } else if (slots) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"memory slots were specified but maximum memory size \"\n\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        *maxram_size = sz;\n\n        *ram_slots = slots;\n\n    } else if ((!maxmem_str && slots_str) ||\n\n            (maxmem_str && !slots_str)) {\n\n        error_report(\"invalid -m option value: missing \"\n\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 15482, "substitutes": {"ram_slots": ["ram_lots", "ram_lashes", "ram_slops", "ram_Slashes", "ram_flops", "ram_lops", "ram_lot", "ram_Slots", "ram_slot", "ram_Slops", "ram_slashes", "ram_flot", "ram_flots", "ram_flashes", "ram_Slot"], "maxram_size": ["maxram_scale", "maxram_SIZE", "maxmem_address", "maxmem_SIZE", "maxram_str", "maxmem_scale", "maxmem_size", "maxram_address"], "sz": ["confzen", "sinz", "setsiz", "esze", " sce", "Szh", "wsz", "Siz", "sce", " sza", "setszy", " sbl", " szi", "dszen", "asza", "gsz", "Szip", "confiz", "tq", "pszn", "siz", "sgz", "psce", "tz", "psz", "gsiz", "sze", "pszi", "psze", "tzip", "aszy", "dsce", "szn", "Szen", "confce", "sq", "asgz", " sze", "szi", "asz", "eszy", "pszip", " szy", "szh", " szn", "szip", "wsq", "pszen", "gszip", "dsbl", "Szy", " szip", "szy", "setsz", " szh", "sbl", "wszip", " sq", "dszi", "esz", "sinzh", "dszip", "setszen", "confz", "wszh", "psq", " sgz", "asiz", "dsza", "Sce", "dsgz", "dsiz", "gsza", "psiz", "sinze", "Szi", "szen", "dsz", " siz", "dsze", "tzen", "Sz", "sza", "pszh", " szen", "eszip", "Sze", "sinzn", "aszen"], "mem_str": ["mem_br", "ram_inner", "accessksource", "memkcur", "memkstr", "accesskcur", "memPStr", "mem_sr", "gram_sr", "gram_Str", "mem_struct", "mem_dr", "mem_cur", "mem___st", "accesskdr", "ram_dr", "memFdr", "gram_st", "mem___sr", "mem___str", "ram_sta", " mem_string", "mem_st", "ram_str", "mem_string", " mem_text", "memPbr", "memPstr", "mem_text", "gram_str", "accesskstr", "ram_Str", "memksource", "mem_sta", "ram_br", "memFcur", "memkdr", "mem_STR", "access_source", "mem___Str", "mem_source", "memFsource", "memPstruct", "access_cur", "mem_inner", " mem_STR", "memFstr", "access_str", "ram_struct", "access_dr", "mem_Str"], "maxmem_str": ["maxmemenstr", "maxmemenst", "maxram_str", "maxram_st", "maxram_string", "maxram_Str", "maxmemensize", "maxmem_br", "maxmem_st", "maxmemenarr", "maxram_arr", "maxmem_arr", "maxmem_size", "maxmem_Str", "maxmem_string", "maxram_br"], "slots_str": ["slores_Str", "slows_str", "slows_string", "slots_Str", "slows_arr", "slores_br", "slots_err", "slots_st", "slores_st", "slots_br", "slot_Str", "slots_string", "slores_str", "slot_str", "slows_err", "slot_string", "slots_arr"], "opts": ["OPments", " opttics", "OPuts", "optouts", "experte", "opercs", "oputs", " opttc", " opends", "OPted", "opments", " optpt", "optr", " opters", "opouts", "depters", "operouts", "opte", "optc", "operts", "appted", "oppt", "oplets", "operte", "experters", " optc", " optrs", "OPends", "experlets", "optts", "depts", "opends", " opted", " optr", " optlets", "roptics", "experts", "appters", " optts", "opters", "OPtr", "OPters", "opert", "oprs", " optters", "optt", "OPte", "appts", "optics", "ropts", "optcs", "operted", "opt", "operters", " opments", "OPcs", "apputs", "operrs", " opttr", "operments", "experpt", "OPts", "operuts", "deptr", "opcs", " opte", " opt", "optrs", "OPt", "roplets", " optouts", "depted", "experends", "optuts", "optters", "expertics", "opted", "roppt", "OPtc"], "slots": ["slows", "lops", "lows", " slops", "lips", " slows", "slops", "Slots", "klips", "Slops", "klans", "Slows", "lots", "klops", "Slips", "slips", "klots", "slans", " slips", "lans", " slans"]}}
{"project": "qemu", "commit_id": "b9f7855a50a7cbf04454fa84e9d1f333151f2259", "target": 0, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 15486, "substitutes": {"bs": ["ps", "fs", "sync", "bd", "us", "ba", "ins", "bl", "bas", "rs", "bn", "bf", "cs", "bc", "ts", "outs", "fb", "base", "cb", "bes", "sels", "blocks", "blog", "ss", "bos", "bt", "BS", "gs", "lb", "BC", "obs", "bh", "ros", "ubs", "ks", "os", "iss", "ums", "bits", "vs", "http", "bytes", "ns", "bb", "s", "qs", "bps", "b", "cks", "aws", "sb", "js", "gb", "las", "abc", "ls", "lbs", "uss", "bis", "pb", "css"], "errp": ["rfp", "erfp", "errr", "errfp", "errP", " errfp", "rP", "err", "erp", " errP", " errr", "rp", "erP", "rr"], "iscsilun": ["iscselken", "iscilaon", "iscisluna", "sicsilken", "isccomplund", "micillunt", "iscselur", "iscSilur", "iscsellut", "ISClituna", "iscsilune", "iscillu", "iscoblmun", "iscryptfun", "iacsilund", "iscselu", "isciryuna", "ircielun", "iscielunion", "iscielune", "uscsilren", "isclassuna", "wicillun", "iscpirmun", "iscivalmun", "isclituna", "iscvalemun", "uscsilan", "iscislune", "iscsilurn", "iscvaleul", "isclitun", "isciryun", "uscslu", "iscsellund", "iscsilmun", "isecsilun", "iscoblken", "ircslunt", "iscslfun", "iscsylvoun", "iscalunin", "iscvaleunt", "uscsilon", "uscielun", "isclitan", "sicsilen", "iscslur", "miscsilunt", "iscinelmun", "isclitunin", "ecsilul", "iscslren", "iscslune", "isclassunt", "ircslu", "iscsilcon", "iscillken", "isecsilund", "iscilon", "ircsilun", "iscsiluna", "miscilaun", "misclitur", "misclituna", "iscilaoun", "iscryptuna", "ircsiluno", "isclitunion", "iscilsuna", "iscielul", "ISCsilun", "iscilun", "uscslren", "iscsilfun", "iscsilur", "isclustuna", "uscslon", "iscielund", "iscillun", "isclassun", "wicillken", "micillun", "iscsilken", "iscillut", "misclitunt", "iscselluno", "iscivaluna", "iscislurn", "ircsilmun", "iscilber", "iscsellken", "wicsilken", "iscilloren", "iacsellmun", "miscsilune", "iscsilren", "iscvalean", "eclitul", "isclesiunt", "eclitun", "iscilan", "iscislund", "uscilunt", "isecsilken", "ircielul", "isecisluna", "uscslut", "iscsilund", "iscmilur", "isecsiluna", "iscselun", "iscsellune", "iscsiloren", "isclesiut", "uscielcon", "iscvirtunin", "ISClitunt", "iscaluna", "isculinund", "ircsiluna", "isccomplun", "ecsilber", "uscilun", "iscpirunt", "iscsluno", "ISCsiluna", "iscslu", "ecsilun", "iscielunt", "iscsilber", "uscsilun", "uscsilfun", "iscillren", "ircieluna", "iacsilun", "ircsilul", "iscilauna", "sicinelmun", "isclitcon", "isclassren", "isculinuna", "uscslunin", "iscalu", "iscslun", "micsilun", "uscsilune", "sicsilun", "miscsiluna", "isculinmun", "iscilluna", "iscislmun", "iscsilunt", "iscpirun", "iscilaun", "isclustmun", "wicillunt", "iscivalund", "iscilaunt", "iscslon", "iscilmun", "iscvaleuna", "uscielune", "iscsilan", "iscsilut", "iscinelken", "iacsilmun", "iscilaren", "iscirymun", "uscslun", "iscselund", "micsiluna", "iscillunin", "iscislut", "iscielu", "iscvaleken", "isecsellu", "ircslmun", "iacsellun", "wicsilunt", "uscsilut", "sicinelun", "isecsilurn", "isccompluna", "ircslune", "isclitber", "ircslur", "ecsilan", "iscsylvunt", "iscvalecon", "iscSiluna", "iscsilen", "iscslunin", "iacselluna", "isccomplurn", "iscsilunion", "miscilaunt", "isculinuno", "iacsiluna", "iscvaleun", "iscilsun", "miscsilur", "iscSilu", "sicinelen", "iscielmun", "isciryund", "iscillune", "uscsluna", "uscsilmun", "iscsilul", "iscsiluno", "uscsilunin", "isecsellun", "iscryptun", "iscsluna", "iscelligunt", "isclustul", "iscvaleber", "ISClitun", "iscinelun", "wicsilun", "ircielmun", "iscilul", "iscelligken", "iscslan", "iscielcon", "eclitber", "uscslan", "ircsilunt", "iscvirtune", "wicilluna", "miscilaune", "isecislurn", "iscslunt", "iscivalun", "micsilunin", "ircsilund", "iscilaune", "misclitun", "iscslund", "uscsilcon", "iscselluna", "iscsloren", "ircsilune", "ircsilu", "ISClitunion", "isecsellund", "iscvirtuna", "iscsiloun", "uscslunt", "iscillan", "wicsiluna", "ircsilur", "isclitur", "ISCsilunion", "iscilren", "ISCsilunt", "iscsellmun", "iscmiluna", "isclustun", "iscalun", "micillunin", "iscmilun", "isclitul", "ircsluna", "uscsilunt", "iscseluna", "isclesiune", "iscoblun", "iscvirtun", "isecislun", "eclitan", "iscelliguna", "ircsloren", "isclitunt", "isculinunt", "sicinelken", "iscslmun", "uscsiluna", "isculinun", "micsilunt", "iscielken", "iscslut", "ircslut", "miscsiloun", "iscsylvun", "iscmilunt", "iscSilun", "iscillunion", "iscelligun", "iscielun", "iacsellund", "iscsilunin", "iscilsune", "iscilsunin", "iscilunt", "iscielunin", "iscisloun", "ircsiloren", "micilluna", "iscsylvune", "ircsluno", "uscilmun", "isecislund", "isclesioren", "ircslun", "miscsilun", "sicsilmun", "ircslund", "miscilaoun", "iscillunt", "uscielunin", "isclesiun", "iscsellun", "iscsilu", "uscielunt", "uscieluna", "iscryptunin", "ircsilut", "isclitfun", "usciluna", "iscvaleen", "uscsilu", "isecsellken", "isclesiuna", "iscieluna", "iscsilon", "isecsilu", "iscpiruna", "iscsellu", "iscoblen", "iscislun", "uscslfun", "iscinelen", "isciluna", "iscislunt"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n", "idx": 15492, "substitutes": {"env": ["enc", "en", "environment", "ev", "esp", "priv", "impl", "exc", "vm", "v", "e", "ov", "cb", "conn", "style", "ec", "esm", "state", "ef", "config", "ea", "eu", "eni", "np", "iv", "ctx", "iss", "context", "vs", "args", "viron", "code", "uv", "core", "scope", "loader", "que", "err", "er", "enable", "nw", "conf", "enh", "cv"], "m": ["fm", "module", "d", "o", "address", "mi", "vm", "v", "md", "cm", "mobile", "gm", "e", "sm", "l", "machine", "hm", "tm", "M", "g", "mx", "k", "man", "n", "am", "x", "c", "i", "h", "p", "b", "f", "dm", "mc", "ms", "bm"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf;\n\n\n\n    buf = s->io_buffer;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 15495, "substitutes": {"s": ["session", "site", "v", "u", "ts", "its", "states", "sys", "si", "in", "an", "se", "m", "plugins", "xs", "self", "n", "spec", "qs", "sb", "des", "js", "services", "t", "ps", "client", "fs", "sync", "o", "your", "cs", "e", "ions", "ss", "y", "ssl", "new", "sq", "gs", "a", "sports", "is", "c", "sg", "ns", "sie", "sis", "settings", "bis", "less", "us", "sites", "l", "ds", "service", "state", "this", "stats", "http", "stage", "sl", "ses", "sym", "S", "comments", "d", "rs", "south", "params", "server", "bs", "g", "es", "uploads", "os", "args", "su", "p", "b", "sets", "f", "w", "ls", "r", "opens", "conf"], "buf": ["fp", "aux", "bd", "alloc", "func", "tmp", "flow", "grab", "data", "uf", "br", "bc", "obj", "result", "cf", "fab", "cmd", "fb", "cb", "wb", "pad", "cap", "db", "queue", "vec", "uc", "fd", "runner", "pool", "seq", "bs", "rc", "rb", "block", "ctx", "cur", "feed", "buff", "mem", "context", "box", "args", "Buffer", "b", "bag", "f", "src", "sb", "ab", "bo", "Buff", "buffer", "ref", "img", "pb", "cv"], "i": ["d", "o", "di", "gi", "chi", "ini", "mi", "iu", "fi", "v", "multi", "li", "count", "e", "xi", "u", "l", "pi", "length", "abi", "uri", "si", "ai", "ui", "m", "a", "ti", "z", "key", "k", "ix", "n", "io", "id", "ci", "bi", "qi", "ip", "x", "oi", "h", "hi", "info", "phi", "p", "index", "ri", "ni", "f", "zi", "j", "r", "ii", "I"]}}
{"project": "FFmpeg", "commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "target": 1, "func": "void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,\n\n                                int nPbH, int log2_cb_size, int part_idx,\n\n                                int merge_idx, MvField *mv)\n\n{\n\n    int singleMCLFlag = 0;\n\n    int nCS = 1 << log2_cb_size;\n\n    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);\n\n    int nPbW2 = nPbW;\n\n    int nPbH2 = nPbH;\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n\n\n    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));\n\n\n\n    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {\n\n        singleMCLFlag = 1;\n\n        x0            = lc->cu.x;\n\n        y0            = lc->cu.y;\n\n        nPbW          = nCS;\n\n        nPbH          = nCS;\n\n        part_idx      = 0;\n\n    }\n\n\n\n    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n\n    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                    singleMCLFlag, part_idx,\n\n                                    merge_idx, mergecand_list);\n\n\n\n    if (mergecand_list[merge_idx].pred_flag[0] == 1 &&\n\n        mergecand_list[merge_idx].pred_flag[1] == 1 &&\n\n        (nPbW2 + nPbH2) == 12) {\n\n        mergecand_list[merge_idx].ref_idx[1]   = -1;\n\n        mergecand_list[merge_idx].pred_flag[1] = 0;\n\n    }\n\n\n\n    *mv = mergecand_list[merge_idx];\n\n}\n", "idx": 15515, "substitutes": {"s": ["ps", "storage", "fs", "sync", "us", "o", "session", "site", "v", "sc", "cs", "e", "sa", "ts", "l", "server", "ds", "bis", "sys", "si", "ions", "ss", "ssl", "service", "sq", "cases", "gs", "sf", "plugins", "xs", "g", "es", "self", "n", "os", "spec", "ctx", "acs", "is", "c", "sg", "p", "ns", "qs", "b", "sets", "f", "sb", "ses", "sis", "js", "groups", "settings", "r", "services", "ls", "S", "t", "ops"], "x0": ["X2", "y00", "X90", "x1", "y2", "ex2", "y1", "ex0", " x90", " x00", "ax90", "ax1", "x90", "ax2", "x2", " x1", "ex00", "ex1", "X0", "x00", "ax0", " x2", "X1"], "y0": ["y00", " y1", "ye0", " y50", "Y00", "ye1", "vy00", "Y80", "y2", " y80", "sy0", "y1", "Y0", "idy0", "idy8", "ey0", " y8", "ye80", " y25", "sy2", "vy8", "Y1", "ey50", "sy25", "ey25", "Y2", "sy50", " y00", " y2", "y25", "idy00", "y80", "dy00", "ey2", "dy1", "y8", "y50", "vy0", "dy0", "dy2"], "nPbW": ["nPkGW", "nPbhG", "nPdEng", "nTkGW", "nNbWe", "nPcW", "nPfWe", "nPbhEng", "nPnG", "nPnWh", "nNcL", "nPcGW", "nCdG", "nPfGW", "nCdEng", "nPnL", "nPpL", "nPkH", "nTkH", "nPdL", "nPbhW", "nCbG", "nNcWe", "nPpW", "nPcWh", "nPbhL", "nPfL", "nPcH", "nCbEng", "nNbG", "nNbWh", "nPbWh", "nCdW", "nNbW", "nCdL", "nPfW", "nPcL", "nNbH", "nPcWe", "nCbL", "nPcEng", "nNcW", "nPbWe", "nTbGW", "nPkWe", "nTbH", "nPnWe", "nPbG", "nPdWh", "nNdW", "nPpWh", "nPdW", "nPbGW", "nPkW", "nTkW", "nCbW", "nNdL", "nPkL", "nNcWh", "nPnW", "nPcG", "nPbEng", "nPfH", "nPbL", "nNcH", "nTbL", "nNbL", "nNdWh", "nTkL", "nPdG", "nTbW", "nPpWe", "nNdG"], "nPbH": ["nPebH", "nPcW", "nPbY", "nPbaHi", "nPdH", "nQmbY", "nPpS", "nPbaY", "nPbHH", "nNch", "nPdS", "nQbS", "nPvSH", "nQdH", "nQmbW", "nPfH", "nPbrW", "nPmbG", "nPbrH", "nQmbH", "nPbh", "nPfY", "nPcRH", "nFcH", "nPpW", "nPcH", "nQmbHi", "nPebS", "nPpHH", "nNbH", "nPfHi", "nPbaH", "nNcW", "nNbHP", "nQbHi", "nFbM", "nPvRH", "nNbh", "nFcM", "nPdSH", "nPendHP", "nPbrSH", "nPdG", "nQbHH", "nPcSH", "nQdW", "nPendh", "nFcSH", "nPmbSH", "nPbM", "nPbbH", "nNbW", "nPpH", "nQdHH", "nPbG", "nPcHP", "nNdW", "nPdW", "nPmbH", "nPbbM", "nNcHP", "nPcM", "nPbaW", "nPmbY", "nPbSH", "nPendH", "nPyH", "nQbY", "nPebHH", "nPvH", "nPbS", "nPbRH", "nPyh", "nQbW", "nPbbSH", "nFbRH", "nPbHi", "nFbSH", "nNbG", "nPdHH", "nNdH", "nPyHP", "nNdSH", "nQbH", "nPch", "nPvM", "nPfW", "nPmbW", "nPbbRH", "nFcRH", "nPmbHi", "nPbHP", "nFbH", "nNbSH", "nNcH", "nPebW", "nPendW", "nPbrG", "nQdS", "nPyW", "nNdG"], "log2_cb_size": ["log2_cb2size", "log2_cv_sec", "log2_db_small", "log2_cv_scale", "log2_cb2SIZE", "log2_cb_sec", "log2_cb2scale", "log2_cb_small", "log2_cv_SIZE", "log2_cv2scale", "log2_cb2len", "log2_cb2sec", "log2_cv_len", "log2_cv2SIZE", "log2_cv2size", "log2_db_sec", "log2_db_size", "log2_cb_len", "log2_cv_size", "log2_cb_SIZE", "log2_cb_scale"], "part_idx": ["part_idxs", "part_Idxs", "part_IdX", "part_IDX", "part_IDxs", "part_idxes", "part_idn", "part_Idxe", "part_idX", "part_ridz", "part_Idxes", "part_ridxs", "part_Idn", "part_idxe", "part_ridx", "part_IDn", "part_idz", "part_ridX", "part_Idz", "part_IDx", "part_ridxes", "part_ridxe", "part_Idx"], "merge_idx": ["merge__Idxb", "merge_idex", "merge__IdX", "merge_indexX", "merge_Idc", "merge_idz", "merge_ilcent", "merge__idxb", "merge_Idxb", "merge_ridn", "merge_Idxs", "merge_idxe", "merge_Idy", "merge_idc", "merge_ridx", "merge_Idz", "merge_idxs", "merge_idsz", "merge_idcent", "merge_endz", "merge__Idx", "merge_idsxs", "merge_ridc", "merge_IDx", "merge_kidcy", "merge_IDc", "merge__Idxs", "merge_IDy", "merge_Idcy", "merge_idy", "merge_Idx", "merge_IDxe", "merge_indexx", "merge_idey", "merge_idxb", "merge_ilz", "merge_endy", "merge_idX", "merge__idx", "merge_endxs", "merge__idX", "merge_ridz", "merge_kidx", "merge_idec", "merge_ilx", "merge_kidy", "merge_ridxs", "merge_endx", "merge_iden", "merge_IdX", "merge__idxs", "merge_indexxs", "merge_kidz", "merge_Idcent", "merge_ridy", "merge_idsy", "merge_indexxb", "merge_idsx", "merge_idcy", "merge_idn", "merge_ilc", "merge_Idxe"], "mv": ["mf", "cmf", "cmc", "Mb", " mc", "pc", "Mf", "pw", "mw", "Mv", "pv", "cmw", "Mc", " mb", "mb", "mc", "Mw", " mf", "cmv", " mw", "pb"], "lc": ["kl", "cu", "cn", "cm", "li", "tc", "cs", "ld", "bc", "nc", "pc", "l", "icc", "lu", "lic", "dc", "cc", "oci", "uc", "lr", "lb", "rc", "dl", "cus", "LC", "lp", "vc", "ci", "uci", "ctx", "ln", "ku", "fc", "acs", "c", "cli", "lv", "acl", "cci", "ls", "loc", "jc"]}}
{"project": "qemu", "commit_id": "5f706fdc164b20b48254eadf7bd413edace34499", "target": 1, "func": "int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n", "idx": 15517, "substitutes": {"f": ["fp", "fm", "fs", "d", "fi", "bf", "e", "fe", "fn", "cf", "l", "fb", "interface", "rf", "m", "fd", "sf", "tf", "proc", "g", "fen", "df", "n", "fr", "xf", "fc", "c", "h", "p", "b", "fx", "fo", "F", "framework", "fac", "t", "function"], "cs": ["ps", "fs", "ows", "cons", "Cs", "rs", "sc", "nc", "pc", "ds", "CS", "ec", "cow", "cc", "dc", "lc", "ks", "cus", "ips", "ix", "ac", "os", "ce", "ctx", "spec", "cache", "acs", "c", "vs", "args", "cp", "s", "ns", "core", "mc", "ics", "ace", "ls", "cas", "css"], "cpuid": ["epupid", "epUID", "cpaid", "puid", " tcpuid", "ppupid", "cpUID", "pid", " tcpuu", " cpupid", " cpid", " tcpaid", "ppUID", "cpuu", "cpid", "epid", " cpUID", "puu", " cpaid", "ppid", "epuid", " tcpid", " cpuu", "ppuid", "paid", "cpupid"], "opaque": ["oopaque", "ospaque", "oopacity", "opsaque", "oopaques", "opaques", "operace", "operaques", "opque", " opacity", "operaque", "oopque", "opec", " opace", " opec", "opacity", "ospacity", "opsacity", "operque", "ospaques", "opsace", "operacity", "ospque", "opsec", "opace", "operec"], "cpu": ["fp", "phy", "fs", "performance", "GPU", "cu", "proxy", "vm", "CPU", "pc", "cf", "gpu", "processor", "bench", "ec", "cow", "pool", "lc", "pu", "proc", "linux", " CPU", "uci", "io", "os", "ctx", " cp", "fc", "cache", "c", "cp", "core", "clock", "platform", "conn", "css"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_clnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno)\n\n{\n\n    int y0, x, y, mask = 1 << (bpno + NMSEDEC_FRACBITS);\n\n    for (y0 = 0; y0 < height; y0 += 4)\n\n        for (x = 0; x < width; x++){\n\n            if (y0 + 3 < height && !(\n\n            (t1->flags[y0+1][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+2][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+3][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+4][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG))))\n\n            {\n\n                // aggregation mode\n\n                int rlen;\n\n                for (rlen = 0; rlen < 4; rlen++)\n\n                    if (t1->data[y0+rlen][x] & mask)\n\n                        break;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL, rlen != 4);\n\n                if (rlen == 4)\n\n                    continue;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen >> 1);\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen & 1);\n\n                for (y = y0 + rlen; y < y0 + 4; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        if (y > y0 + rlen)\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            } else{\n\n                for (y = y0; y < y0 + 4 && y < height; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            }\n\n        }\n\n}\n", "idx": 15520, "substitutes": {"t1": ["port1", "tt1", "ttapp", "the81", " t9", "attae", " t2", "tup", "port31", "retra", "T1", "untus", "templateah", "t121", "y100", "atached", "templateae", "retOne", "t31", "the1", "tus", "antself", "itae", "attra", "it1", "template100", "ttah", "tau", "unt1", "portae", " tOne", "tron", "the01", "t81", "templateOne", "yau", "T3", "tt100", "at121", "y1", "tsup", "retron", " t100", "y01", "ttra", "template121", "itOne", "att31", "T61", "ts2", "template01", "yah", "ttOne", "tself", "tsca", "p3", " tself", "yus", "tae", "p2", "p1", "t61", "Tone", "attOne", "templateapp", " tone", "yca", "ts81", "template61", "tone", "at01", "tOne", "ta1", "yapp", "tah", "template1", "taself", "t2", " tached", "att1", "untca", "ts01", " t3", "t01", "tt61", "yself", "at1", "tsae", "tapp", "atae", "t9", "ts1", "tsus", "tached", "ta6", "yOne", " tup", "it31", "ant100", "ret1", "portOne", "tt81", "tca", "at81", "attron", "antau", "T9", "ts9", " t01", "t3", "ts100", "ttup", "t100", "ttself", "tra", " tau", "pone", "ttau", "ts121", "templateau", "ant1", " t81", "taOne", "T2", "theached", "unt01", "ttron", "y61", "ts61", " t6", "tt6", "t6", " t61"], "height": ["d", "gap", "high", "data", "volume", "image", "three", "direction", "length", "size", "above", "style", "head", "Height", "depth", "shape", "level", "pad", "padding", "dim", "resolution", "view", "density", "id", "win", "h", "bottom", "window", "input", "crop", "layout", "thin", "row", "w", "angle", "alpha", "fw", "inches"], "bandno": [" bcno", "bandnumber", "bandNo", " bcNo", "bpnumber", "cbno", "bpNo", "cbnum", " bcnum", "bandnum", "cbNo", "bpnum", " bcnumber", "cbnumber"], "nmsedec": ["nmshedec", "nmsedsef", "nmsedEC", "nmmedEC", "nmshedef", "nmsedsEC", "nmshedEC", "nmsledec", "nmsedsec", "nmmhedisc", "nmmedec", "nmsledisc", "nmmhedec", "nmmhedEC", "nmsedisc", "nmsedef", "nmsledEC", "nmmedisc", "nmshedisc", "nmsedsisc", "nmmedef", "nmsledef", "nmmhedef"], "bpno": ["npnumber", "cpNO", "pbno", "bpeno", "BPno", "cpnumber", "bpnos", "BPnumber", "BPNO", "pbNO", "BPnos", "npnos", "cpno", "npNO", "pbeno", "npno", "BPeno", "pbnumber", "bpnumber", "bpNO", "cpnos", "cpeno"], "y0": ["y00", " y50", "x192", "syee", "y2", "y90", "ye250", "ry80", "gy00", "x0", "ye180", "y100", "x2", "sy00", "dy50", "ry100", "Y192", "ay150", "gy8", " y100", "syku", " yee", "ry00", "ry90", "y180", "dy8", "ky100", "ye0", "ry1", "yt0", "all", "gy50", "y250", "y1", "ky180", "sy8", "y050", "ey0", "_", "ry0", "num", "ey080", "x050", "yt050", "y192", "vy6", "x100", " y080", "y80", "yku", "dy0", "sy192", "eyku", "y6", "yt80", "ya50", "ya0", " y150", "ya00", "ey1", "ry080", "ey180", "ye100", "vy90", " y050", "ey250", "sy2", "ey100", "y150", "ey00", "ey50", "yt00", "Y2", "ya050", "sy50", " y00", "ry050", "ey90", "ay0", "dy00", "sy1", "y8", "y50", "vy150", " y90", "ey6", " y1", "sy050", "sy80", "x1", "ky250", "sy0", "Y0", "gy0", " yku", "g", "Y1", "ay6", "ey050", "yee", "s", "eyee", "ky0", "x00", "ay90", "ey150", "sy150", "vy0", "y080"], "x": ["d", "ct", "pe", "X", "v", "e", "u", "pos", "xi", "image", "l", "yx", "lat", "full", "in", "m", "dx", "el", "xy", "ady", "time", "xs", "xx", "xp", "num", "px", "wx", "z", "ix", "g", "n", "id", "ctx", "win", "plus", "c", "i", "h", "rx", "ww", "s", "p", "index", "ax", "ex", "b", "on", "sex", "fx", "tx", "f", "name", "w", "python", "bit", "j", "xc", "any", "event", "value", "t", "day", "wa"], "y": ["ya", "d", "ay", "ty", "hop", "say", "v", "iy", "yt", "year", "ny", "m", "xy", "zy", "ady", "uy", "ym", "vy", "z", "n", "ey", "yer", "c", "i", "h", "bot", "p", "index", "type", "col", "b", "cy", "f", "name", "w", "Y", "dy", "j", "yy", "py", "sky", "sy", "t", "yi", "gy", "yl"], "rlen": ["erlen", "plen", "rlength", " rlength", "rLen", "rtler", "drdl", "rrLen", "plon", "rrlim", "rli", "mlen", "rtden", "Rlon", "crlen", "erler", "rrlon", "drsplit", "rbl", "nrlen", "hlength", " rval", "rdl", " rLen", "mLen", "rln", "rrval", "rlim", "prfin", "errden", "drden", "srlength", "prsplit", "Rln", "nrlon", "mli", "srli", "crval", "rlin", "hbl", "Rbl", "crLen", "errler", "hden", "rrbl", "rtlen", "Rval", "srLen", "arLen", "rrsplit", "hval", "rden", "rsplit", "prlim", "rtdl", "Rlin", "errdl", "arlin", "arlen", "crlon", "arlon", "rler", "erdl", "srval", "drlength", "Rlength", "drlim", "rfin", "hLen", "crlength", "nrlength", "Rli", "Rlen", "erden", "srlen", "pLen", "nrval", "hdl", "rlon", "plin", "rrdl", "errlen", "drlen", "prlen", "hlen", "rrfin", "srln", "mln", "rval", "rrden", "RLen", "rrlen", "rrlength", "nrLen", "drfin"]}}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,\n\n                                       target_ulong *pte1p,\n\n                                       int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & HPTE64_R_R)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= HPTE64_R_R;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & HPTE64_R_C)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= HPTE64_R_C;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 15521, "substitutes": {"ctx": ["client", "sync", "prefix", "alloc", "qq", "cn", "exec", "jp", "nt", "cm", "sc", "pkg", "cf", "cb", "cmd", "kb", "gpu", "gc", "qa", "cc", "cmp", "grad", "sq", "sem", "rc", "config", "proc", "cca", "lc", "ci", "cache", "context", "c", "mac", "comp", "cp", "conv", "ctrl", "tx", "ca", "msg", "xc", "loc", "conn", "cas", "cv"], "pte1p": ["pte2f", "pte2b", "ptse6r", "pte3b", "pte11a", "pte11p", "pte0r", "ptea8f", "pte18pe", "pte1b", "ptque121p", "ptque1p", "pte121pe", "pte8n", "ptea1f", "ptea8i", "ptee2p", "ptque121d", "ptee2pc", "pte1post", "pte1a", "ptc1f", "ptea1p", "pte121d", "ptee1p", "ptse6pc", "pte1pe", "pte4d", "pte01r", "ptque1pe", "pte1j", "pte1n", "ptc1p", "pte121p", "pte11f", "pte01j", "pte6pc", "pte11pc", "pte9n", "pte1d", "pte1pc", "ptee1d", "pte9i", "pte11b", "pte121post", "ptea1n", "pte8p", "pte1f", "pte4p", "ptse6p", "pte8f", "pte9f", "ptc2a", "pte4post", "pte3pc", "pte1r", "pte6n", "pte11d", "pte6p", "pte0p", "pte3d", "pte9p", "pte1i", "pte18d", "ptse1j", "ptc1a", "ptc2f", "ptque1post", "pte0pc", "ptee2b", "ptea8p", "pte0j", "pte01pc", "ptea8n", "ptee2d", "pte18p", "pte4pe", "pte2d", "pte9a", "pte6f", "pte2pc", "ptse1r", "pte8i", "ptse1pc", "ptc2pc", "ptse1p", "ptee1b", "ptque121pe", "ptee1pc", "ptc2p", "pte9pc", "ptse6j", "ptque1d", "pte2a", "pte01p", "ptque121post", "pte2p", "pte6r", "pte3p", "pte6i", "pte6j", "pte18post", "ptc1pc", "ptea1i"], "ret": ["session", "ft", "route", "success", "reset", "pat", "resp", "nt", "match", "result", "store", "pub", "rt", "att", "sur", "val", "def", "res", "rf", "protected", "offset", "reply", "len", "sec", "reg", "last", "rets", "secret", "arr", "protect", "re", "RET", "flag", "back", "entry", "ref", "alt", "Ret"], "rw": ["ctr", "wit", "dr", "route", "rh", "wr", "rest", "rt", "raf", "wb", "our", "rf", "rack", "lr", "ride", "rr", "rc", "usr", "wx", "rb", "rue", "rss", "ww", "rx", "req", "sw", "RW", "kw", "sr", "w", "rl", "vr", "rn", "nw", "rg", "fw", "wrap", "wk", "wa"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n", "idx": 15524, "substitutes": {"bs": ["ps", "fs", "bd", "ba", "bas", "rs", "cs", "bc", "obj", "base", "fb", "ds", "bes", "ob", "sys", "ss", "db", "bos", "BS", "Bs", "lb", "obs", "bh", "os", "iss", "bi", "vs", "bp", "ns", "bb", "s", "qs", "bps", "b", "sb", "as", "js", "ses", "ls", "pb"], "sg": ["storage", "irs", "ys", "gm", "cs", "sa", "sc", "cfg", "fg", "ds", "si", "gc", "ss", "pg", "ssl", "ga", "db", "sq", "gs", "sf", "g", "rb", "spec", "sd", "su", "s", "GS", "isu", "sr", "sb", "tg", "ses", "sis", "gp", "std", "gb", "ls", "rg", "gd", "sk"], "sector": ["fp", "storage", "address", " sectors", "proxy", "ector", "tier", "mode", "sa", "bc", "ser", "server", "sys", "si", "db", "queue", "offset", "state", "sf", "sec", "config", "channel", "ipher", "region", "io", "context", "slave", "pointer", "termin", "sb", "series", "port", "buffer", "transfer", "section", "buf", "tty", "socket", "conn", "driver"], "cb": ["done", "fp", "ctr", "func", "bf", "CB", "bc", "cf", "pc", "fb", "orb", "obb", "rob", "ob", "callback", "db", "cmp", "dc", "seq", "fun", "rb", "cor", "ctx", "cur", " callback", "buff", "c", "cp", "bb", "cod", "ctrl", "src", "sb", "abb", "eb", "abc", "buf", "pb", "cv"], "opaque": ["uppca", "ipacity", "opac", "uppaques", " opca", " opac", "opaques", "paques", " opque", "iopacity", "iopque", " opaques", "ipaque", "pac", "operaques", "pque", "opque", " opacity", "operaque", "iopaques", "operac", "OPque", "uppacity", "opacity", "iopaque", "uppaque", "paque", "operque", "ipca", "OPca", "iopca", "opca", "ipque", "OPaque", "OPacity"]}}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n            case QCOW2_CLUSTER_UNALLOCATED:\n\n                if (full_discard || !bs->backing_hd) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_ZERO:\n\n                if (!full_discard) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_NORMAL:\n\n            case QCOW2_CLUSTER_COMPRESSED:\n\n                break;\n\n\n\n            default:\n\n                abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 15530, "substitutes": {"bs": ["ps", "fs", "bm", "sync", "ins", "bl", "bas", "als", "bn", "cs", "bc", "ts", "cb", "base", "fb", "outs", "ds", "bes", "abi", "sys", "ss", "db", "bos", "BS", "gs", "lb", "plugins", "obs", "bh", "os", "iss", "bi", "stats", "bits", "vs", "bytes", "ns", "bb", "bps", "b", "sb", "ses", "js", "eb", "gb", "las", "banks", "ls", "lbs", "bis", "pb", "css"], "offset": ["fp", "prefix", "part", "o", "address", "alloc", "position", "seed", "reset", "inet", "pos", "length", "size", "base", "align", "online", "timeout", "slot", "alias", "padding", "slice", "seq", "config", "location", "nb", "cache", "pointer", "info", "reference", "addr", "off", "index", "table", "start", "Offset", "entry", "ref", "len", "rot"], "nb_clusters": ["nb__clards", "nb_blusters", "nb_clicas", "nb_oclores", "nbofcollients", "nb_collibraries", "nb_clancers", "nb_CLers", "nb_CLuster", "nb_collodes", "nb_llibraries", "nb_sclumers", "nbofclibraries", "nb_coancers", "nb__collards", "nbofclards", "nb__clodes", "nb_llards", "nb_chusters", "nb_plusters", "nbJclancers", "nbofcollusters", "nb_clients", "nb_plers", "nb_shumers", "nb_clodes", "nb_clumers", "nb_collusters", "nbJcoancers", "nb_chroups", "nb_chumers", "nb_pluster", "nb_blards", "nb_clibraries", "nb_ocluster", "nb_clards", "nbJclroups", "nb__collusters", "nb_collops", "nb_sclusters", "nb_shgroups", "nb_labusters", "nb_oclgroups", "nbofcollibraries", "nb_CLores", "nb_sclancers", "nb_clgroups", "nb_oclumers", "nb_labops", "nb_coumers", "nb_cousters", "nb_oclusters", "nb_plores", "nb__collodes", "nb_oclicas", "nb_CLusters", "nb_plumers", "nb_plgroups", "nb_collients", "nb_clores", "nb_sclroups", "nb_shicas", "nb_labodes", "nb_blops", "nb__clops", "nb__clusters", "nb_Clibraries", "nb_Clients", "nbofclusters", "nb_llients", "nb_blodes", "nbJclusters", "nb_collards", "nb_shusters", "nbJcoroups", "nb_coroups", "nbJcousters", "nbJcoumers", "nbofcollards", "nbofclients", "nb_plicas", "nb_oclers", "nb_Clusters", "nb_cluster", "nb_llusters", "nbJclumers", "nb_clops", "nb_clroups", "nb__collops", "nb_labards", "nb_Clards", "nb_clers", "nb_chancers"], "type": ["ct", "o", "ty", "pe", "single", "op", "e", "obj", "format", "base", "style", "val", "sys", "slot", "y", "kind", "types", "sp", "TYPE", "typ", "error", "unit", "parent", "method", "class", "block", "id", "change", "Type", "info", "p", "off", "unknown", "name", "out", "port", "rule", "t", "none", "pb", "code"], "full_discard": ["full_diskarded", "full_badard", "full_disard", "full_drart", "full_drair", "full_Discarded", "full_Discair", "full_Discards", "full_declore", "full_discards", "full_recARD", "full_badarding", "full_Discore", "full_scair", "full_DiscARD", "full_diskard", "full_drore", "full_badord", "full_recarded", "full_diskarding", "full_declign", "full_diards", "full_drard", "full_discart", "full_Discign", "full_diard", "full_discarding", "full_discign", "full_diARD", "full_disign", "full_declard", "full_diskord", "full_diarded", "full_disarding", "full_discore", "full_disord", "full_discord", "full_scart", "full_scard", "full_discair", "full_discARD", "full_disarded", "full_score", "full_Discard", "full_Discart", "full_recards", "full_discarded", "full_declarded", "full_disore", "full_recard", "full_badarded"], "s": ["ps", "sync", "us", "sv", "session", "rs", "site", "cs", "sa", "ts", "parts", "ds", "states", "sys", "si", "ss", "space", "service", "ssl", "se", "state", "sq", "gs", "g", "ks", "self", "os", "spec", "stats", "is", "c", "su", "p", "ns", "status", "b", "sl", "sets", "f", "sb", "sie", "js", "ses", "utils", "settings", "stat", "ls", "socket", "services", "S", "sym", "t"], "l2_table": ["l2fbody", "ltwotcache", "l2pindex", "l2_session", "ltwottable", "l2paddress", "l2_component", "l2ftable", "l2_course", "l1_component", "l2_address", "l2btable", "l1_count", "l2__course", "l2tcache", "l2jcomponent", "l2jkey", "l2_count", "l2__table", "l2baddress", "l2_machine", "l2ptable", "ltwo_tree", "l4_table", "l1_cache", "l1_key", "l4_body", "l4_stable", "l2___table", "l1_session", "l2___tree", "l4_course", "l2pentry", "l2jcache", "l2_stable", "l2tmachine", "l2bentry", "ltwo_table", "l2___machine", "l2bindex", "l1_entry", "l1_index", "l2fstable", "l2_tree", "l2ttree", "l2jtable", "ltwottree", "l2__body", "l1_table", "l2_entry", "l2_body", "l4_cache", "ltwo_cache", "l2ttable", "l1_address", "l2___cache", "l2_cache", "ltwo_machine", "l2__cache", "ltwotmachine", "l2_key", "l2fcache"], "l2_index": ["l2_offset", "l2xexit", "l6_size", "l2_header", "l2xheader", "l22_entry", "l22_path", "l0xindex", "l0xaddress", "l2eraddress", "l2_align", "l2xindex", "l2_size", "lbf_style", "l2roffset", "l2rindex", "l2_byte", "l2_address", "l1_offset", "l2Pposition", "l2_path", "l2Jindex", "l2erexit", "lbf_position", "l2_site", "l2erheader", "l2Jsecondary", "l6_cache", "l2Jsite", "l6_index", "lbf_index", "l1_size", "l2lexindex", "l2rsize", "l0_header", "lbfPindex", "l2erindex", "lDB_index", "l2_secondary", "lbf_align", "lbfPposition", "l2Pstyle", "l0_index", "l2Pindex", "lbfPalign", "lDB_secondary", "l2Jbyte", "l2Pheader", "l0xheader", "l2Palign", "l2_style", "l0_exit", "lDB_byte", "l2lexposition", "lDB_site", "l6_position", "l1_index", "l2xaddress", "lbfPstyle", "l2Paddress", "l2_position", "l22_index", "l0_address", "l2lexstyle", "l2lexalign", "l22_size", "l0xexit", "l2Pexit", "l2_exit", "l2_entry", "l2_cache"], "ret": ["en", "gt", "iter", "ft", "fin", "mi", "success", "fi", " Ret", "try", "nt", "bf", "ry", "match", "result", "obj", "rt", "att", "ib", "val", "alt", "def", "res", "det", "reply", "lb", "al", "fun", "rc", "pre", "reg", "num", "last", "rets", "bad", "cur", "mt", "info", "ext", "status", "let", "b", "lit", "arr", "f", "re", "out", "RET", "flag", "ind", "inter", "get", "rl", "back", "xt", "ref", "t", "len", "Ret", "code"], "i": ["it", "ie", "iter", "di", "gi", "chi", "ini", "iu", "mi", "fi", "reset", "multi", "v", "li", "count", "e", "xi", "result", "mu", "u", "l", "pi", "abi", "uri", "val", "si", "in", "y", "ai", "ui", "dim", "ti", "ix", "z", "eni", "n", "ci", "id", "io", "bi", "qi", "ip", "x", "c", "info", "ji", "p", "index", "ri", "b", "ni", "f", "start", "out", "ind", "j", "r", "ii", "t", "len", "I"], "old_l2_entry": ["old_l2Jentry", "old_l2_name", "old_l3_entry", "old_l2actable", "old_l2_module", "old_l2_index", "old_l2Oname", "old_l4_entry", "old_l3_table", "old_l3_cell", "old_l2__module", "old_l4_element", "old_l2Mtable", "old_l1_slot", "old_l2acmodule", "old_l2acentry", "old_l4_table", "old_l2_Entry", "old_l2accell", "old_l1_Entry", "old_l2Melement", "old_l2Jsession", "old_l2Mslot", "old_l2_element", "old_l1_session", "old_l2Mentry", "old_l2_cell", "old_l2__entry", "old_l2Mindex", "old_l2_table", "old_l2__table", "old_l2Mname", "old_l2_slot", "old_l3_module", "old_l1_entry", "old_l2__cell", "old_l1_name", "old_l4_index", "old_l2JEntry", "old_l2_session", "old_l2Oslot", "old_l2Oentry"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n", "idx": 15534, "substitutes": {"bs": ["ps", "fs", "ba", "ins", "bl", "bas", "rs", "cs", "bc", "obj", "ts", "fb", "ds", "blocks", "ss", "bos", "bt", "BS", "lb", "obs", "bh", "ks", "ubs", "os", "iss", "bits", "bytes", "ns", "bb", "qs", "b", "sb", "ses", "buf", "ls", "bis", "pb"], "ret": ["part", "en", "af", "success", "fi", " Ret", "data", "bf", "nt", "result", "ut", "obj", "rt", "desc", "base", "val", "def", "gc", "res", "pet", "full", "det", "reply", "len", "fun", "reg", "rets", "arg", "rev", "opt", "mem", "info", "ext", "addr", "cat", "lit", "re", "out", "RET", "flag", "std", "final", "bit", "value", "pass", "xt", "ref", "alt", "Ret"], "s": ["ps", "d", "o", "session", "e", "sa", "cs", "u", "parts", "ds", "states", "sys", "service", "ssl", "state", "gs", "a", "g", "ks", "os", "spec", "stats", "is", "c", "i", "p", "status", "ns", "b", "sl", "sb", "as", "js", "ses", "ls", "services", "S", "bis", "ops"]}}
{"project": "qemu", "commit_id": "47445c80fb57035331574ac1ac0bcee67fb84aeb", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPRMachineState *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,\n\n                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);\n\n    if (!pdev || !object_dynamic_cast(OBJECT(pdev), \"vfio-pci\")) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15535, "substitutes": {"cpu": ["computer", "GPU", "proxy", "vm", "CPU", "process", "pc", "gpu", "processor", "nic", "cmp", "pid", "pool", "config", "pu", "proc", "linux", "fps", "ips", " CPU", "boot", "mem", "node", "cp", "apple", "cli", "gp", "conn"], "spapr": ["spaperp", "spappr", "scappr", "SPapc", "spaperb", "spapb", "sprapc", "spajr", "spappner", "SPapr", "spappp", "scapb", "SPraprs", "scappb", "scapr", "scappner", "spapp", "sprapr", "scapner", "scapp", "SPaprs", "spajp", "spajb", "spaperner", "spapsc", "SPrapc", "spaperr", "SPaprb", "spappb", "spaprb", "spapsr", "spapsrs", "spapc", "spajner", "spraprb", "spaprs", "SPrapr", "scappp", "spapsrb", "SPraprb", "spapner", "spraprs"], "token": ["auth", "func", "ok", "resp", "util", "random", "timeout", "total", "callback", "reply", "response", "seq", "nat", "reg", "proc", "cost", "next", "win", "opt", "mac", "flag", "call", "socket", "conn", "native", "oken"], "nargs": ["numargs", "utarget", "uret", "numtarget", "lret", "uargs", "nfun", "numret", "numfun", "numflags", "lArgs", "lfun", "nArgs", "nattarget", " nfun", "uflags", "natret", " nArgs", "largs", "ntarget", "nflags", "natflags", "numArgs", "natargs"], "args": ["ids", "days", "yrs", "bug", "func", "Args", "rs", "changes", "data", "resp", "results", "cs", "match", "alls", "grades", "ras", "use", "cmd", "features", "parts", "params", "states", "links", "grad", "reply", "gs", "frame", "arms", "sec", "parse", "config", "values", "next", "arg", "details", "mac", "bytes", "active", "qs", "atts", "lines", "arr", "ams", "vals", "ait", "flags", "flag", "msg", "ms", "call", "members", "asm", "argument", "fields", "opens", "py", "conn", "len", "pack"], "nret": ["nrows", "Nrest", "lsuccess", " nrows", "lret", " nresult", " nrest", "cret", " nrets", " nRet", " nsuccess", "noret", "nRet", "nresult", "crets", "lrets", "noresult", "cRet", "Nret", "csuccess", "norows", "Nresult", "nrets", "Nrows", "nsuccess", "nrest", "lRet", "norest"], "rets": ["ures", "ids", "aux", "uds", "fs", "ries", "ints", "ins", "rs", "changes", "strings", "als", "fits", "nt", "results", "pillar", "store", "ts", "desc", "outs", "features", "errors", "ds", "ails", "def", "rows", "res", "acks", "uns", "reply", "len", "sec", "seq", "fun", "nas", "proc", "reg", "ips", "ils", "details", "mem", "bits", "secret", "ats", "tests", "ns", "vals", "uts", "des", "flags", "utils", "buffer", "fields", "ls", "opens", "runs", "alt", "ops"], "sphb": ["scfbi", "dsppbb", "smphb", "sclc", "sshb", "inshpb", "shpc", "sephp", "psphb", "sPhf", "sphprb", "sPhr", "sppbb", "sphbase", "pPha", "pPhb", "sshm", "sphab", "inshpa", "ppha", "sclb", "smphsb", "sphabi", "sPhpb", "sshf", "inspha", "schm", "dsphsb", "pPhbi", "pphr", "sphsb", "dspha", "pschm", "scff", "sephc", "sphaa", "inshpbase", "sphpf", "psphf", "schf", "sphaf", "sPHa", "dsppsb", "sphc", "sphpb", "pschb", "sshd", "scfa", "psphrb", "sppb", "smphbb", "sPha", "dsppa", "sphf", "pschf", "sPHbase", "sphd", "insphb", "insphbase", "sphp", " sphc", "sshc", "sshp", "pschrb", "sPhbi", "pphbi", "scppb", "sphbb", "pphf", " sphp", " sshc", "dsphb", "sphbi", "sphm", "pphb", "scpr", "smpha", "sphr", " sshp", "sephd", " sshd", "sPHb", "dsphbb", "inshpc", "shpbase", "pphpb", "sPhb", " sphd", "sPHc", "scld", "pPhf", "sphrb", "sshrb", "schrb", "sclp", "sppa", "sppsb", "schb", "psphm", "scpb", "scfb", "spha", "scpa", "sephb", "sphpm", "shpb", "dsppb", " sshb", "insphc", "shpa"], "spc": ["ppc", "SPci", "Sph", "epf", "epd", "ppf", " sph", " spd", "Spci", "epc", "SPcs", "ppci", "SPf", "SPc", "sph", "Spcs", "spci", "ppd", " spci", "spcs", "epci", "spf", "Spc", " spcs", "spd", "SPh", " spf", "Spf"], "pdev": [" pmod", "tdevice", "pdi", "tdi", " ppriv", "ndevice", " pdi", "pdiv", " pdiv", "ipdev", "pmod", "pcdev", "vdiv", "ndef", "tdev", "ppriv", " ppad", " pdef", "pcpad", "pcdevice", "cerror", "ppad", "cdiv", "ndi", "ndev", "pdef", "vmod", "ippad", "cdevice", "cmod", "tdef", "pdevice", "vdev", "ippriv", "pcerror", "cdev", "vdevice", " pdevice", "cpad", "ipdevice", "cpriv"], "addr": ["prefix", "enc", "part", "address", "hop", "afi", "route", "options", "dr", "amd", "ord", "ar", "data", "amp", "md", "adr", "pos", "pkg", "cmd", "access", "align", "alias", "pad", "loc", "attr", "grad", "offset", "cmp", "adder", "rr", "seq", "ptr", "url", "host", "config", "rc", "arg", "add", "id", "opt", "node", "mt", "ip", "ext", "layer", "active", "device", "dd", "order", "ack", "arr", "name", "acl", "advert", "ace", "ref", "arm", "alt", "array", "ad", "oa"], "option": ["o", "address", "optional", "options", "route", "connection", "position", "mode", "op", "adr", "image", "offer", "cho", "direction", "package", "style", "alias", "resource", "object", "attr", "tag", "offset", "error", "config", "Option", "arg", "replace", "operation", "opt", "version", "ip", "other", "type", "name", "pin", "section", "entry", "value", "term", "event", "ption", "array", "custom"], "buid": ["auid", "uuID", "auiden", "suID", " bukid", "suids", "uuId", "buiden", "auids", " buids", "basids", "buId", " buiden", "uuids", "bookkid", " buID", "bookID", "ruID", "rukid", "ruids", "ruid", "basId", "suId", "auID", "bookids", "buids", "uuiden", "uuid", "bukid", "buID", "suid", "basID", "basid", "bookid"], "ret": ["fail", "gt", "success", " Ret", "nt", "resp", "pat", "match", "result", "sat", "rt", "val", "alt", "res", "det", "reply", "fun", "rc", "num", "reg", "arg", "rec", "opt", "mt", "ext", "cat", "run", "rep", "arr", "re", "out", "RET", "flag", "red", "inter", "err", "back", "bit", "pass", "ref", "len", "Ret", "code"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 15537, "substitutes": {"acl": ["client", "enc", "abl", "kl", "afi", "af", "oc", "exec", "ar", "filter", "la", "acc", "bc", "container", "ocl", "l", "access", "anon", "qa", "anc", "ec", "lic", "el", "api", "lc", "cca", "aml", "ant", "ac", "asc", "am", "fc", "acs", "cache", "wl", "mac", "rol", "lib", "cl", "coll", "ic", "ctrl", "sl", "cel", "abc", "ace", "aa", "alpha", "oa"], "match": ["test", "field", "filter", "content", "data", "link", "patch", "apply", "search", "mode", "im", "mask", "image", "pat", "Match", "message", "pattern", "use", "access", "mat", "path", "m", "tag", "map", "parse", "find", "reg", "key", "like", "lock", "replace", "id", "change", "info", "ext", "email", "target", "p", "member", "re", "name", "get", "quote", "allow", "text", "guard", "rule", "matched", "atch", "code"], "entry": ["ries", "ie", "enc", "first", "route", "card", "connection", "reader", "Entry", "try", "ge", "search", "ry", "e", "image", "nt", "inner", "end", "enter", "server", "element", "page", "si", "se", "zip", "ent", "sec", "parse", "comment", "lc", "parent", "sub", "key", "ant", "item", "id", "feed", "li", "archive", "info", "index", "escape", "cat", "inc", "start", "row", "name", "cel", "sea", "or", "inter", "child", "cell", "next", "prev"], "i": ["it", "o", "di", "gi", "ini", "v", "multi", "li", "u", "xi", "l", "pi", "uri", "si", "ai", "ui", "m", "offset", "k", "n", "eni", "ci", "id", "mini", "bi", "init", "ip", "x", "phi", "c", "oi", "hi", "p", "index", "ri", "col", "b", "ni", "start", "f", "ind", "j", "ori", "ii", "I", "code"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */\n\n\n\n    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      /* pcists pci status rwc, ro */\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      /* rid revision ro */\n\n    c[0x09] = 0x00;      /* pi programming interface ro */\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */\n\n\n\n    c[0x10] = 0x01;      /* nabmar native audio mixer base\n\n                            address rw */\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      /* nabmbar native audio bus mastering\n\n                            base address rw */\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      /* sid subsystem id rwo */\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */\n\n    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n", "idx": 15549, "substitutes": {"dev": ["debug", "engine", "di", " Dev", "test", "app", "ev", "cam", "der", "ve", "dom", "priv", " device", "data", "var", "v", "md", "raw", "link", "dist", "br", "DEV", "end", "pub", "desc", "DE", "conn", "dat", "serial", "def", "die", "grad", "mod", "hw", "comment", "error", "Dev", "config", "reg", "roll", "tr", "rad", "de", "gu", "DC", "block", "ch", "mem", "development", "dem", "info", "device", "dd", "ver", "load", "w", "diff", "adv", "loader", "err", "conf", "pack", "ad"], "d": ["bd", "di", "dr", "dt", "nd", "dom", "dos", "data", "md", "e", "ld", "del", "cd", "l", "dat", "ds", "did", "db", "dc", "m", "dad", "pd", "dn", "dl", "ded", "g", "z", "n", "id", "dh", "sd", "i", "dict", "p", "dd", "b", "f", "dm", "D", "dy", "r", "gd", "t", "da", "ad"], "s": ["fs", "o", "session", "rs", "south", "v", "sc", "cs", "sa", "e", "l", "ds", "sys", "si", "ss", "y", "conf", "ssl", "m", "service", "sed", "state", "sq", "gs", "a", "g", "z", "n", "os", "spec", "sd", "args", "sg", "p", "ns", "b", "sw", "sl", "f", "sb", "w", "ses", "settings", "r", "services", "S", "t"], "c": ["enc", "ct", "o", "cu", "cn", "cont", "v", "cm", "tc", "sc", "cs", "e", "con", "nc", "C", "u", "cf", "l", "bc", "pc", "y", "ec", "cc", "dc", "m", "conf", "uc", "a", "lc", "config", "rc", "g", "k", "z", "n", "ch", "ci", "ce", "spec", "cur", "cache", "fc", "x", "i", "h", "cp", "q", "p", "cl", "col", "b", "inc", "arc", "ic", "co", "coll", "f", "ctrl", "cr", "ca", "mc", "w", "call", "err", "r", "xc", "chain", "loc", "t", "code"]}}
{"project": "FFmpeg", "commit_id": "68900bf16bb4dda35cf5f2801ce72c15056f1939", "target": 0, "func": "static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    CookParseContext *s = s1->priv_data;\n\n\n\n    if (s->duration)\n\n        s1->duration = s->duration;\n\n    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)\n\n        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;\n\n\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only setting packet duration */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 15552, "substitutes": {"s1": ["sg1", "S1", "sg11", "S2", "c11", "sg2", "wsone", "ws2", "s4", "ares1", "p4", "pone", "p0", "s11", " s4", "ares11", "s2", " s2", "ws4", "S0", "c0", "c1", "cone", "c2", "Sone", "ws1", "s0", "ares2", " sone", "p2", "p1", "sone"], "avctx": ["avelc", "ajctrl", "avcmp", " avcf", "afcontext", "AVcontext", "aulc", "aucmp", "auxc", "avcache", " avcontext", "AVlc", "AVctrl", "afcdn", "afcache", "AVcmp", "afctrl", "afcv", "auctx", " avcdn", "afpkg", "avepkg", "afcf", "abcmp", "avcf", "avectx", "abctx", " avcv", "abcache", "avpkg", "aucontext", " avcache", "AVxc", "afcmp", "afctx", "abcontext", "AVctx", "avlc", "avctrl", " avlc", "avcv", "aupkg", "abcdn", "aflc", "avecmp", "avcdn", "abcf", "ajcmp", "avxc", "afxc", "ajcontext", " avcmp", "avecv", "avecontext", "avcontext", "ajctx"], "poutbuf": ["poutsbag", "piocmd", "pOutcmd", "pOutbag", "pinbuff", "pOutbuff", "pantbuff", "poutsbuf", "Poutqueue", " poutcmd", "poutbag", "pantbuf", "pinbuf", "poutsqueue", "Pinbuff", " poutsqueue", "Poutbuff", "poutqueue", "Poutbuf", " poutsbag", "poutbuff", "Pinbuf", " poutsbuf", " poutscmd", "pOutqueue", "piobuf", "piobag", "pioqueue", "Pinqueue", "poutscmd", " poutqueue", "pinqueue", "pOutbuf", "poutcmd", "pantqueue", " poutbag"], "poutbuf_size": ["poutbuf_scale", "poutqueue_size", "poutbuf_count", "poutqueue_length", "poutbuf__size", "poutqueue_count", "poutbuf_Size", "poutbuf__count", "poutbuf_length", "poutbuf__length"], "buf": ["fp", "aux", "batch", "alloc", "tmp", "data", "uf", "bf", "bc", "result", "cb", "fb", "cmd", "wb", "pad", "cap", "queue", "vec", "uc", "offset", "seq", "config", "rb", "ctx", "foo", "buff", "context", "window", "Buffer", "b", "bag", "src", "ab", "buffer", "pb", "cv"], "buf_size": ["buff67desc", "buf5index", "buf67desc", "buff_sized", "uf_size", "buf67sized", "uf_scale", " buf_index", "buf5offset", "buf_offset", " buf_offset", "buf_sized", "buf67size", "buf_desc", "buff_desc", "buf_scale", "buf_index", "buf5size", "buff67size", "buf_Size", "buff67sized", "uf_Size", "buff_size"], "s": ["ps", "hs", "fs", "d", "session", "rs", "data", "e", "u", "sa", "cs", "ts", "params", "ds", "sys", "ans", "ssl", "service", "m", "new", "sq", "gs", "sf", "sec", "a", "g", "es", "self", "n", "os", "spec", "ctx", "context", "c", "i", "su", "sg", "args", "p", "ns", "qs", "b", "aws", "f", "sb", "ses", "js", "settings", "r", "services", "ls", "S", "t", "ops"]}}
{"project": "FFmpeg", "commit_id": "2f4233614a7fbe176b81de0ef14bf38bad8e6693", "target": 0, "func": "static void add_codec(FFServerStream *stream, AVCodecContext *av,\n\n                      FFServerConfig *config)\n\n{\n\n    AVStream *st;\n\n    AVDictionary **opts, *recommended = NULL;\n\n    char *enc_config;\n\n\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n\n        return;\n\n\n\n    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?\n\n           &config->audio_opts : &config->video_opts;\n\n    av_dict_copy(&recommended, *opts, 0);\n\n    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);\n\n    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);\n\n    if (av_dict_count(*opts))\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"Something is wrong, %d options are not set!\\n\", av_dict_count(*opts));\n\n\n\n    if (config->stream_use_defaults) {\n\n    //TODO: reident\n\n    /* compute default parameters */\n\n    switch(av->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"ab\", av->bit_rate, 0);\n\n        }\n\n        if (av->sample_rate == 0) {\n\n            av->sample_rate = 22050;\n\n            av_dict_set_int(&recommended, \"ar\", av->sample_rate, 0);\n\n        }\n\n        if (av->channels == 0) {\n\n            av->channels = 1;\n\n            av_dict_set_int(&recommended, \"ac\", av->channels, 0);\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"b\", av->bit_rate, 0);\n\n        }\n\n        if (av->time_base.num == 0){\n\n            av->time_base.den = 5;\n\n            av->time_base.num = 1;\n\n            av_dict_set(&recommended, \"time_base\", \"1/5\", 0);\n\n        }\n\n        if (av->width == 0 || av->height == 0) {\n\n            av->width = 160;\n\n            av->height = 128;\n\n            av_dict_set(&recommended, \"video_size\", \"160x128\", 0);\n\n        }\n\n        /* Bitrate tolerance is less for streaming */\n\n        if (av->bit_rate_tolerance == 0) {\n\n            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n\n                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);\n\n            av_dict_set_int(&recommended, \"bt\", av->bit_rate_tolerance, 0);\n\n        }\n\n\n\n        if (!av->rc_eq) {\n\n            av->rc_eq = av_strdup(\"tex^qComp\");\n\n            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);\n\n        }\n\n        if (!av->rc_max_rate) {\n\n            av->rc_max_rate = av->bit_rate * 2;\n\n            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);\n\n        }\n\n\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n\n            av->rc_buffer_size = av->rc_max_rate;\n\n            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    } else {\n\n        switch(av->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (av->bit_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio bit rate is not set\\n\");\n\n            if (av->sample_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio sample rate is not set\\n\");\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (av->width == 0 || av->height == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"video size is not set\\n\");\n\n            break;\n\n        default:\n\n            av_assert0(0);\n\n        }\n\n    }\n\n\n\n    st = av_mallocz(sizeof(AVStream));\n\n    if (!st)\n\n        return;\n\n    av_dict_get_string(recommended, &enc_config, '=', ',');\n\n    av_dict_free(&recommended);\n\n    av_stream_set_recommended_encoder_configuration(st, enc_config);\n\n    st->codec = av;\n\n    stream->streams[stream->nb_streams++] = st;\n\n}\n", "idx": 15555, "substitutes": {"stream": ["client", "AV", "sv", "oper", "data", "v", "raw", "record", "loop", "media", "image", "iver", "model", "server", "upload", "path", "transform", "object", "m", "uc", "form", "wave", "url", "REAM", "parent", "audio", "view", "channel", "ream", "Stream", "iv", "spec", "feed", "http", "input", "archive", "sw", "coll", "sl", "ack", "instance", "f", "src", "wav", "port", "video", "cv"], "av": ["nav", "oc", "uf", "v", "act", "ap", "ov", "api", "ra", "aver", "man", "ac", "am", "avi", "bb", "ver", "lv", "ave", "auc", "array", "var", "auth", "aim", "um", "record", "li", "media", "image", "aval", "a", "audio", "iv", "off", "sav", "buf", "ad", "aut", "aw", "aux", "AV", "af", "com", "data", "user", "att", "cap", "ai", "attr", "aj", "bh", "aph", "dev", "http", "art", "ak", "aps", "raft", "ack", "au", "ann", "aud", "sv", "app", "ev", "acc", "air", "raf", "uc", "capt", "tr", "archive", "ab", "wav", "port", "aa", "cv"], "config": ["client", "aux", "ct", "app", "nav", "options", "exec", "data", "acc", "sc", "con", "bc", "image", "cfg", "cf", "server", "Config", "path", "cap", "conf", "db", "sec", "capt", "rc", "lc", "reg", "man", "ch", "spec", "ctx", "cache", "context", "c", "input", "control", "ext", "FIG", "fig", "cal", "ctrl", "ca", "manager", "settings", "allow", "text", "design", "conn", "driver", "img", "support"], "st": ["ct", "ru", "ST", "amp", "sc", "St", "sa", "rest", "ste", "ss", "se", "inst", "sn", "sta", "capt", "str", "est", "stage", "art", "ast", "sw", "sl", "src", "sb", "ost", "sth", "std", "ad"], "opts": ["operta", " optes", " optt", "OPments", " optx", "optouts", "optTS", " opter", " opttes", "operfs", "opertx", "opments", " ops", " opets", " opty", "optr", "opouts", "opte", "optets", " optd", "opTS", "operts", "optd", "opttx", "OPty", " optrs", "OPfs", "opttr", " optfs", "otts", " optty", "opertr", "optts", "opta", "optx", "optte", "opals", " oprs", " optr", " optts", "opths", "opert", "oprs", "opfs", " optter", "optt", "optes", "otTS", "ots", "OPte", "operals", "opets", "opt", "opertd", "opty", " opments", "OPta", " optals", " opTS", "ops", "opttd", "opter", "opttes", "OPts", " opouts", " opals", " opt", " opte", "optrs", " optths", "OPt", "OPths", " optouts", "optments", " optta", " opths", " opfs", "operter", "otets"], "recommended": ["suspended", "pretributed", "navended", "recommend", "advertension", "extened", "recommened", "advertending", "dependended", "recommributed", "pretension", "recommENDED", "navending", "pretened", "depending", "shortended", "navened", "pretended", "depend", "pretENDED", "depened", "suspending", "shortension", "suspension", "suspend", "advertended", "dependending", "extend", "extending", "depension", "extended", "depENDED", "advertend", "pretending", "extension", "shortending", "depended", "dependened", "shortened", "advertened", "extributed", "dependension", "pretend", "suspened", "recommending", "recommension", "navributed", "advertENDED"], "enc_config": ["enc_length", "encodercontext", "sec_config", "encoderconfig", "enc7length", "enc7content", "sec_content", "sec7config", "encoderlength", "sec7content", "encodercontent", "enc_content", "sec7context", "sec7length", "sec_length", "enc_context", "enc__context", "enc__content", "enc__length", "enc__config", "sec_context", "enc7context", "enc7config"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n", "idx": 15582, "substitutes": {"v": ["d", "o", "sv", "vm", "e", "u", "V", "l", "val", "vi", "tv", "m", "vt", "volt", "g", "k", "self", "inv", "iv", "version", "c", "q", "i", "x", "vs", "uv", "p", "b", "f", "lv", "w", "vim", "vp", "r", "j", "t", "vis"], "errp": ["errpb", "nerpb", "errr", "nerr", " errpc", "rrp", "rrr", "nerp", "errpc", "nerpc", "rrpc", " errpb", "rrpb", " errr"], "qov": ["ayovy", " qovo", "quov", "qou", "quove", "quoh", " qoh", "ayov", "qove", "qoh", "qovo", " qou", "Qou", "Qov", "quovy", " qovy", "qovy", "ayove", "aqou", "ayoh", "Qovy", "aqov", " qove", "aqovy", "aqovo", "Qovo"], "value": ["module", "document", "xml", "content", "data", "expression", "image", "result", "feature", "message", "format", "output", "model", "style", "VALUE", "element", "val", "object", "anything", "m", "comment", "response", "values", "parent", "key", "node", "p", "type", "member", "name", "python", "w", "Value", "section", "entry", "any", "function", "null"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n", "idx": 15589, "substitutes": {"s": ["fs", "d", "o", "sv", "session", "south", "v", "sc", "cs", "e", "u", "l", "scl", "bis", "space", "ssl", "service", "se", "m", "sq", "gs", "sf", "a", "g", "self", "n", "spec", "su", "p", "ns", "b", "sl", "sets", "f", "support", "sb", "ses", "js", "settings", "r", "services", "sky", "S", "setup", "t", "sk"], "main_data": ["mainacdata", "main_body", "mainacline", "min_body", "mainaclane", "all_module", "all_line", "main\u00b7line", "main\u00b7data", "all_shape", "main\u00b7shape", "min_line", "min_lane", "min_data", "mainacbody", "all_data", "main_shape", "main_lane", "main\u00b7module", "main_module"], "main_linesizes": ["main_limitsiz", "main_linesites", "main_linsize", "main_linsizes", "main_lineizes", "main\u00b7limitsiz", "main_linesenses", "main_lineiz", "main_planesizes", "main_linesiz", "main_linesize", "main_linersize", "main_linersinks", "main_lineinks", "main_planesize", "main\u00b7limitsizes", "main_limitsizes", "main_linersenses", "main\u00b7limitsites", "main_lineenses", "main_lineites", "main_linsenses", "main_lineize", "main\u00b7linesizes", "main_limitsites", "main\u00b7linesize", "main_linsinks", "main_linersizes", "main\u00b7limitsize", "main_limitsize", "main_linesinks", "main\u00b7linesites", "main_planesites", "main\u00b7linesiz", "main_planesiz"], "ref_data": ["ref_lines", "ref_message", "reference_frame", "reference_info", "reference_message", "ref_frame", "reference_data", "ref_info", "ref1message", "reference_line", "ref1data", "ref1line", "reference_lines", "ref1info"], "ref_linesizes": ["ref_linersizes", "ref_filesizes", "ref_lineys", "ref_linersizing", "ref_linizes", "ref_linesys", "ref_lineize", "ref_linesizable", "ref_linersys", "ref_linersites", "ref_linesizing", "ref_lineizes", "ref_linersize", "ref_linizing", "ref_lineites", "ref_filesizable", "ref_lineizing", "ref_linize", "ref_linesize", "ref_filesites", "ref_lineizable", "ref_filesize", "ref_linersizable", "ref_linesites", "ref_linys"], "w": ["d", "wh", "v", "e", "u", "l", "wd", "wb", "y", "m", "W", "a", "aw", "z", "n", "win", "x", "q", "p", "we", "b", "f", "r", "fw", "wa"], "h": ["hs", "v", "e", "u", "rh", "l", "ht", "ih", "y", "hm", "hh", "gh", "he", "bh", "g", "z", "ch", "sh", "x", "H", "q", "hi", "p", "ph", "b", "f", "th"], "mse": ["nmse", "nmde", "nse", "mte", " mne", "dmde", " mde", "nmne", "nSE", "pSE", " mze", "nze", "mce", "mde", "pte", "mne", "dmse", "pse", " mte", "mSE", "mze", "pze", "nmce", "dmce", " mce", "nte", "dmne", " mSE"], "i": ["it", "d", "ie", "o", "di", "gi", "uni", "chi", "ini", "iu", "mi", "fi", "v", "li", "e", "u", "xi", "l", "pi", "uri", "si", "vi", "y", "ai", "m", "ui", "ti", "g", "z", "k", "ani", "ix", "n", "eni", "ci", "io", "bi", "qi", "phi", "x", "ami", "oi", "ji", "ki", "p", "ri", "b", "ni", "f", "zi", "ind", "r", "ii", "I", "yi"], "c": ["d", "ct", "cu", "cn", "v", "cm", "count", "e", "u", "cs", "C", "nc", "cf", "cit", "l", "pc", "cycle", "y", "ec", "cc", "dc", "m", "uc", "a", "lc", "config", "g", "z", "k", "n", "ac", "ch", "ci", "ce", "vc", "cor", "cur", "fc", "cache", "x", "cp", "p", "cl", "col", "cat", "b", "cy", "coll", "co", "f", "cr", "ca", "mc", "call", "r", "t", "jc", "code"], "j": ["it", "adj", "d", "ie", "o", "di", "dj", "J", "jp", "v", "li", "jl", "br", "e", "u", "pos", "l", "si", "y", "m", "el", "jo", "str", "aj", "g", "pr", "k", "z", "jj", "n", "fr", "ch", "qi", "x", "ij", "ji", "p", "b", "ni", "f", "ind", "js", "bj", "oj", "uj", "je", "r", "ii", "next", "ja", "jc"], "main_line": ["ref_lines", "ref__frame", "main_lines", "mainjlines", "ref__lines", "ref_plane", " main_slice", "main__plane", "main_side", "main_code", "ref_pin", "ref_frame", "mainjpin", "main__line", "main__lines", "main_slice", "main_frame", "ref__plane", "main__frame", "ref__line", " main_side", "main_plane", "main_pin", "mainjframe", " main_code", "mainjline"], "ref_line": ["ref_lines", "main_lines", "reference_layer", " ref_lane", "reference_name", "ref_layer", "ref_name", "ref___lines", "main_scale", "reference_line", " ref_lines", "reference_lines", "ref___line", "ref_scale", "ref___scale", "ref_lane"]}}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594, "substitutes": {"sum": ["loss", "um", "ass", "fee", "hash", "user", "acc", "count", "sa", "match", "result", "pos", "size", "average", "style", "val", "si", "total", "fat", "doc", "summary", "dot", "comment", "parse", "num", "g", "scale", "cost", "skip", "ac", "add", "mem", "cache", "sh", "weight", "ul", "gram", "Sum", "vol", "cal", "sign", "pal", "out", "aa", "mean", "alpha"]}}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 15615, "substitutes": {"env": ["enc", "dt", "site", "priv", "exec", "exc", "v", "erv", "obj", "dat", "ec", "fen", "ea", "np", "her", "h", "req", "here", "esc", "enable", "conn", "en", "ne", "esp", "edge", "global", "po", "txt", "e", "eng", "eni", "iv", "context", "ah", "shell", "c", "tx", "buf", "event", "chal", "done", "engine", "environment", "vm", "end", "ench", "kn", "qa", "pg", "state", "this", "opt", "dev", "vs", "stage", "viron", "ex", "que", "py", "enh", "ev", "nc", "server", "gui", "el", "export", "config", "eu", "net", "ctx", "ext", "core", "w", "energy", "loader", "err", "console", "er", "equ", "conf", "Environment", "cv"], "r1": ["srOne", "R01", "nr1", "rc4", "v6", "arOne", "r16", "v3", "rc2", "sr1", "R2", "v1", "rc1", "R6", "ar2", "R4", "sr4", "r81", "r01", " r4", " r2", " r16", "R16", "R3", " rOne", "nr81", "v2", "rOne", "r6", " r6", "R81", "nr3", " r81", "r4", "nr16", "r2", " r01", "p01", "ar1", "ar4", "rc3", "p3", "sr2", "p2", "p1", "R1"], "a2": [" a72", "as2", "alpha2", "A8", "A1", " a0", "va4", "a1", "a0", "alpha3", "A0", "A4", "a72", "a8", "alpha1", "va3", "A3", " a8", "as8", "a4", "A2", "va1", "a3", "as0", "A72", "as72", "alpha4", "va2"], "r3": ["ar63", "rb83", "r63", "rar3", "Rthree", " r2003", "rb2", "rcThree", "r83", " r03", "dr9", " r53", "p03", "rThree", "a9", "R2", "rbthree", "rarThird", "R6", "dr03", "rar2", "r03", "rb03", "r9", "rr3", "ar6", "rarThree", "er3", " r2", "ar3", "rb53", "r53", "er83", "r2003", "a53", "rar2003", "er03", "rc03", "arThree", "p53", "rrthree", "rarthree", "r6", "R53", " r6", "dr53", "rthree", "r2", "ar53", "p83", "rThird", "dr3", "rr2", "rr2003", "ar1", "rar03", "a3", "rc3", "er53", "rbThird", "p3", " rthree", " r9", "rc63", "rar63", " rThird", "ar03", "R3", "rb3", "rr1", "a03", "R1"], "src": ["https", "sync", "ctr", "rw", "source", "sc", "dist", "st", "bc", "ruby", "rt", "desc", "sel", "cb", "server", "uri", "rob", "sur", "access", "ssl", "cc", "sq", "uc", "inst", "slice", "sn", "origin", "url", "rc", "config", "supp", "sub", "proc", "RC", "rb", "rib", "sup", "spec", "cur", "sh", "comp", "addr", "syn", "req", "target", "range", "b", "sl", "ource", "sr", "sb", "ub", "ape", "gb", "trans", "text", "loc", "img"], "dest": ["d", "ru", "di", "rw", "route", "tmp", "ord", "decl", "cont", "data", "priv", "txt", "source", "dist", "sc", "dir", "comb", "rest", "desc", "wd", "wb", "dat", "ds", "sur", "access", "dc", "dep", "uc", "cdn", "ptr", "rc", "config", "sub", "go", "rb", "sup", "de", "rec", "asc", "dev", "home", "coord", "ident", "target", "tx", "gen", "Dest", "trans", "text", "loc", "conn", "da"], "destlen": ["Destli", "srcli", "destpos", " destli", "srcl", "desclength", "sourcelen", "Destlength", "DestLen", "routelen", "distl", " destl", "destel", "sourcelength", "srcpos", "descl", "sourcepos", "descel", "targetLen", "targetlength", " destpos", "srcel", "routelength", " destlength", "targetlen", "distlen", "destcount", "destlength", "destl", "targetcount", "destLen", "desclen", "routeLen", "srclength", "Destl", "descLen", "distel", "distLen", "Destcount", "srcLen", " destLen", "desccount", "destli", "descli", "Destlen", "sourceLen"], "srclen": ["vraclen", "srblenc", "srclon", "srclan", "srglan", "srcline", "hrllenn", "srsclener", "srclense", "hrclen", "hrclend", "yrslense", "sracline", "sercleng", "srslen", "vrclenn", "srciler", "nrclenn", "srglened", "srclend", "srcelenn", "srslhen", "srClense", "hrcline", "hrllener", "srlcenn", "serslhen", "krslun", "srlcen", "vraclenn", "yrcleni", "srclener", "krslan", "serclhen", "srflon", "srblen", "srcler", "srcilenn", "krslened", "srcilen", "hrflen", "srseler", "srblener", "hrllen", "serclen", "srslense", "srfleng", "srllenn", "yrclen", "srslan", "srslun", "srsclenn", "krclened", "nrcelenn", "srlcaren", "srselon", "krclun", "srclaren", "hrclenn", "nrclon", "srflener", "srClenc", "srglen", "srlline", "srcelen", "srcilun", "srflena", "hrclon", "hrflend", "srglun", "srblend", "hrclener", "srslenc", "yrslenc", "srflen", "srsclaren", "vrclaren", "srclun", "vrclener", "nrcler", "srlcener", "srcleni", "krslen", "srselenn", "sersleng", "srclhen", "srsclen", "srselen", "yrsleni", "nrceler", "srCleng", "sraclen", "yrclenc", "srclenc", "srclened", "hrflener", "srblense", "srclenn", "srcilon", "srslener", "vrclen", "srClen", "srslena", "srslened", "srsleni", "krclen", "srglenn", "nrcelon", "srceler", "nrclen", "serclena", "srslon", "vraclener", "srCleni", "yrclense", "srllen", "vraclaren", "srclena", "srgline", "srllener", "srslend", "srblon", "hrlline", "yrslen", "krclan", "serslena", "hrflon", "srsleng", "sraclaren", "nrcelen", "sraclener", "srClena", "sraclenn", "srClhen", "srflhen", "srglener", "srcelon", "srflend", "srcleng", "srbleni", "srcilened", "srcilan", "serslen"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void *bios_linker_loader_cleanup(GArray *linker)\n\n{\n\n    return g_array_free(linker, false);\n\n}\n", "idx": 15634, "substitutes": {"linker": ["layner", "linkler", "loadter", " linkner", "marker", "loadener", " linkener", "Linkener", " linkter", "linkener", "loadner", "markner", "markter", "Linkler", "layler", "markener", "layer", " linkler", "layener", "linkner", "loader", "Linkner", "linkter", "Linker"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n", "idx": 15644, "substitutes": {"cpu": ["phy", "sync", "performance", "chip", "module", "computer", "GPU", "cn", "connection", "vm", "jp", "CPU", "loop", "u", "process", "pc", "gpu", "processor", "bench", "intel", "gc", "lu", "nic", "cow", "cmp", "hu", "uc", "prem", "hw", "pool", "program", "lc", "config", "pu", "proc", "linux", "kernel", "eni", "uci", "np", "boot", "drm", " CPU", "mem", "cache", "node", "colo", "c", "cp", "lib", "cli", "component", "core", "device", "instance", "ctrl", "gru", "roc", "loader", "gp", "clock", "platform", "conn"], "ptex": ["ptrz", "ctex", "ptlex", "iptix", "PTEx", "PTix", "ptes", "PTex", "PTlex", "ptEx", "iptz", "petes", "PTz", "iptex", "iptEx", "ptix", "ptrEx", "mintEx", "iptx", "ctrex", "ptx", " ptexp", "PTes", "ptrix", "ctx", "mintx", " ptes", "mintex", "petexp", " ptlex", "PTexp", "petex", "ptexp", "mintrex", "ctEx", "iptrex", "ptrex", "ptz", "petlex"], "n": ["en", "d", "ne", "o", "nor", "cn", "pn", " N", "v", "e", "u", "nc", "fn", "network", "l", "m", "sn", "a", "num", "g", "un", "k", "z", "nb", "node", "N", "c", "i", "h", "x", "ns", "p", "s", "none", "b", "f", "name", "w", "nm", "r", "j", "nl", "t", "len", "number"], "hptes": ["hiptends", " hPTes", "hPTies", "hpetes", "hnthes", " hipties", "hiptses", "hPTses", "hcte", "Hapts", "haptets", "hsptions", " hptises", "hpses", "hportES", "hspethes", " hptES", "hptions", "hiptizes", "hpss", "Hptets", "hctses", " hpts", "hapte", "hptises", "hpse", " hPTies", "hppises", "hspetions", "hctes", "hspthes", "hntizes", "hports", "hpsets", "hpetions", "hctES", "hctets", "hporte", " hptses", "hipties", " hptends", " hiptes", "hppes", "hipthes", " hPTends", "hptizes", "hntions", "hPTes", "hpts", "hpties", "hptses", "hpethes", " haptes", "hpte", " hiptises", "haptises", "hportes", " hPTses", "hctends", "hntes", "hptES", " haptES", "hspetizes", "hppe", "hapties", "Haptes", "hiptises", "hppies", "Haptets", "hPTe", "hspetes", "hcts", "haptES", "hsptes", " hpte", "hiptions", "Hapte", "haptes", "hsptizes", "Hptes", "hipte", " hpties", "hapts", "hpetizes", " hapts", "hptends", "hpthes", " hipte", " hapte", " hPTe", "haptses", "hPTends", "hiptes", "Hpts", "hptets", "Hpte"]}}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 15653, "substitutes": {"env": ["enc", "en", "engine", "eve", "ne", "environment", "ass", "ev", "dt", "esp", "exec", "impl", "exc", "txt", "erv", "e", "ench", "ov", "skin", "enter", "oa", "eng", "ec", "db", "el", "ef", "export", "vel", "config", "emb", "fen", "eu", "ea", "profile", "eni", "iv", "np", "iss", "cur", "context", "shell", "viron", "dict", "ext", "core", "req", "press", "energy", "loader", "que", "err", "er", "forge", "equ", "conf", "enh", "Environment", "cv"], "mmu_idx": ["mmu_idv", "mmu_idsx", "mmu_idsy", "mmu_idX", "mmu_idsX", "mmu_ridxc", "mmu_idy", "mmu_ridx", "mmu_Idx", "mmu_idxc", "mmu_midxe", "mmu_sidc", "mmu_ridb", "mmu_midxc", "mmu_idex", "mmu_ridX", "mmu_Idv", "mmu_sidy", "mmu_idexc", "mmu_Idb", "mmu_idsc", "mmu_idc", "mmu_idev", "mmu_sidxe", "mmu_sidx", "mmu_idb", "mmu_sidX", "mmu_Idxc", "mmu_idexe", "mmu_Idc", "mmu_IdX", "mmu_midx", "mmu_sidxc", "mmu_idxe", "mmu_Idxe", "mmu_midy"]}}
{"project": "qemu", "commit_id": "2adba0a18a7950d14827e82d8068c1142ee87789", "target": 0, "func": "static void build_processor_devices(Aml *sb_scope, unsigned acpi_cpus,\n\n                                    AcpiCpuInfo *cpu, AcpiPmInfo *pm)\n\n{\n\n    int i;\n\n    Aml *dev;\n\n    Aml *crs;\n\n    Aml *pkg;\n\n    Aml *field;\n\n    Aml *ifctx;\n\n    Aml *method;\n\n\n\n    /* The current AML generator can cover the APIC ID range [0..255],\n\n     * inclusive, for VCPU hotplug. */\n\n    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);\n\n    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */\n\n    dev = aml_device(\"PCI0.\" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A06\")));\n\n    aml_append(dev,\n\n        aml_name_decl(\"_UID\", aml_string(\"CPU Hotplug resources\"))\n\n    );\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,\n\n               pm->cpu_hp_io_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(sb_scope, dev);\n\n    /* declare CPU hotplug MMIO region and PRS field to access it */\n\n    aml_append(sb_scope, aml_operation_region(\n\n        \"PRST\", AML_SYSTEM_IO, aml_int(pm->cpu_hp_io_base), pm->cpu_hp_io_len));\n\n    field = aml_field(\"PRST\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n    aml_append(field, aml_named_field(\"PRS\", 256));\n\n    aml_append(sb_scope, field);\n\n\n\n    /* build Processor object for each processor */\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        dev = aml_processor(i, 0, 0, \"CP%.02X\", i);\n\n\n\n        method = aml_method(\"_MAT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_MAT_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_STA\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_STATUS_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_EJ0\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(i), aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = Processor ID = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));\n\n        aml_append(ifctx,\n\n            aml_notify(aml_name(\"CP%.02X\", i), aml_arg(1))\n\n        );\n\n        aml_append(method, ifctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :\n\n                             aml_varpackage(acpi_cpus);\n\n\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n        aml_append(pkg, aml_int(b));\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n}\n", "idx": 15654, "substitutes": {"sb_scope": ["sb_context", "storagejmode", "storagejcontext", "sbjscope", "sbJrule", "stabJscope", "SB_scope", "storage_scope", "storage_mode", "sb_rule", "storage_depth", "sbjdepth", "sb_root", "sb_code", "SB_source", "bg_theme", "sbJroot", "bg_code", "bg_rule", "sb_slice", "sb_depth", "stabJslice", "storagejscope", "sbjmode", "bg_scope", "stab_scope", "sb_private", "sb_scale", "stab_slice", "sbJcode", "sbJtheme", "SB_scale", "sb_mode", "SB_root", "sbJscope", "storagejdepth", "storage_context", "sb_theme", "sbjcontext", "stabJprivate", "stabJroot", "sbJprivate", "stab_private", "sbJslice", "stab_root", "sb_source"], "acpi_cpus": ["acpi_hpuses", "acpi_gpus", "acpi_cpuses", "acpi__mpos", "acpi_copis", "acpi__cpis", "acpi__cpos", "acpi_hpums", "acpi__mpus", "acpi_mpums", "acpi_mpubes", "acpi_hpus", "acpi_orpubes", "acpi_cpis", "acpi_copus", "acpi_orpis", "acpi_orpos", "acpi_mpos", "acpi_mpus", "acpi_orpus", "acpi_copuses", "acpi_gpuses", "acpi_cpuis", "acpi_cpuors", "acpi_hpis", "acpi_gpos", "acpi_copors", "acpi_mpis", "acpi_cpors", "acpi_gpis", "acpi_cpubes", "acpi__cpubes", "acpi_cpuuses", "acpi_mpuses", "acpi__mpis", "acpi_cpums", "acpi_gpums", "acpi_gpubes", "acpi__cpus", "acpi_cpuus", "acpi_gpors", "acpi__mpubes", "acpi_cpos"], "cpu": ["amd", "fi", "vm", "CPU", "nc", "pc", "gpu", "processor", "cmp", "prem", "hw", "lc", "pu", "proc", "mx", "uci", "mem", "cache", "rpm", "cp", "cli", "core", "vidia", "mc", "loader", "gp", "conn"], "pm": ["fm", "bm", "mm", "module", "mp", "PM", "gem", "mi", "umi", "imm", "vm", "im", "cm", "param", "gm", "pc", "pi", "model", "wm", "pg", "hm", "m", "tm", "pd", "prem", "ym", "iam", "dim", "em", "pool", "px", "am", "pa", "rm", "rpm", "dem", "p", "cli", "mr", "ram", "dm", "lv", "mc", "vim", "gp", "gb", "nm", "vp", "plugin", "manager", "km", "pb"], "i": ["adi", "ie", "d", "di", "gi", "chi", "ini", "iu", "fi", "x", "v", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "uri", "si", "ui", "m", "ti", "k", "ani", "ix", "key", "n", "gu", "ci", "id", "mini", "io", "bi", "qi", "ip", "phi", "ami", "oi", "c", "ji", "ki", "p", "cli", "ri", "index", "b", "uli", "hi", "type", "ni", "f", "name", "zi", "ind", "ski", "j", "r", "ii", "I", "yi"], "dev": ["debug", "d", "engine", "di", "app", "test", "bug", "ev", "der", "priv", "dom", "ve", "temp", "data", "user", "v", "dist", "project", "pos", "DEV", "feature", "pub", "package", "wd", "model", "serial", "def", "develop", "pack", "service", "dep", "die", "prom", "valid", "comment", "dn", "error", "dim", "Dev", "pu", "proc", "go", "self", "de", "block", "gu", "spec", "node", "home", "development", "push", "info", "dem", "clean", "prov", "device", "dd", "ver", "dm", "diff", "adv", "av", "err", "env", "conf", "driver", "var"], "crs": ["prd", "Cri", "cRS", "scri", "rcrs", "acrc", "crc", "rcras", "cri", "pras", "Cros", "grs", "gros", "gri", "gsr", "scsr", "pRS", "cros", "grc", "acrs", "prs", "rcRS", "acras", " cros", "rcrc", " csr", "scrc", "acRS", "acrd", " crc", "scrs", " cRS", " cras", "grd", " cri", "csr", "Crs", "crd", " crd", "cras", "Crd"], "pkg": ["fp", "prefix", "module", "app", "priv", "param", "util", "package", "cmd", "ssl", "cmp", "attr", "api", "hw", "pool", "proc", "spec", "ctx", "cache", "cp", "lib", "core", "gp", "kg", "loader", "install", "plugin", "comp", "pack"], "field": ["update", "engine", "file", "bl", "FIELD", "attribute", "bf", "force", "match", "ff", "message", "package", "model", "style", "round", "def", "condition", "post", "group", "attr", "tag", "label", "comment", "time", "ignore", "key", "block", "add", "lock", "id", "change", "fc", "box", "input", "layer", "off", "type", "dd", "Field", "f", "row", "name", "lf", "mount", "diff", "option", "term", "value", "cell", "rule", "manager", "len", "function"], "ifctx": ["fctx", "libdef", "ifdef", "ifcb", "libcb", "libctx", "libcontext", "ifcontext", "fcb", "IFcb", "IFctx", "IFdef", "IFcontext", "fdef", "fcontext"], "method": ["module", "engine", "session", "send", "user", "record", "source", "image", "fl", "util", "fn", "message", "end", "package", "each", "process", "model", "round", "path", "full", "service", "sort", "attr", "school", "Method", "label", "comment", "time", "url", "fun", "self", "block", "version", "ul", "description", "type", "sign", "METHOD", "instance", "member", "name", "effect", "call", "option", "term", "value", "text", "plugin", "manager", "function"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n", "idx": 15655, "substitutes": {"s": ["fs", "sync", "o", "session", "south", "v", "secondary", "e", "server", "copy", "ds", "states", "si", "ss", "service", "ssl", "m", "state", "sq", "sf", "a", "ips", "n", "spec", "is", "c", "i", "h", "p", "status", "scope", "f", "sb", "ses", "settings", "sym", "socket", "S", "array", "ops"]}}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n", "idx": 15664, "substitutes": {"s": ["comments", "client", "fs", "sync", "d", "us", "sv", "session", "o", "storage", "your", "site", "sid", "rs", "same", "v", "private", "secondary", "e", "u", "cs", "l", "server", "ds", "states", "sys", "si", "ss", "ssl", "service", "m", "new", "an", "se", "sq", "gs", "g", "es", "self", "sup", "n", "os", "spec", "stats", "is", "submit", "c", "http", "i", "h", "sg", "su", "p", "ns", "tests", "qs", "b", "aws", "f", "support", "sb", "ses", "w", "js", "request", "r", "services", "sym", "S", "t", "ops"], "recv": ["discsv", "Recf", "recf", "Recov", "discv", "recvd", "incv", "convd", "rcve", "Recceive", "recev", "rcV", " recf", "Recvar", "Recv", " recvd", "incvert", "ucv", "recV", "discq", " recsv", " recvert", "rcov", "rcvs", "rcsv", "recvs", " recvar", "ucV", "conve", "Recvd", "recq", "discV", " recq", "recve", "ucf", "recvert", "incvm", "recvm", "conceive", "recov", "conv", "Recvs", " recov", "produvert", "rcceive", "incf", "rcv", "recceive", "recsv", "rcf", " recve", "produvm", "conov", " recvs", " recev", "ucvar", "conq", "recvar", "produv", " recvm", "conV", " recV", "Recev", "produf", "conev", "conf", "rcq", "RecV"], "len": ["en", "d", "ie", "lan", "le", "fin", "bl", "all", "data", "v", "li", "ll", "e", "Len", "fl", "pos", "count", "ld", "l", "length", "base", "L", "val", "lon", "el", "offset", "zen", "str", "seq", "lin", "dl", "num", "z", "net", "lp", "n", "id", "ln", "ler", "line", "lib", "sl", "il", "f", "min", "lf", "El", "err", "lang", "dy", "span"]}}
{"project": "FFmpeg", "commit_id": "17dc7c7a60798d3e1f78bad97423fb49c8dc1c1d", "target": 0, "func": "void ff_h264_pred_init_x86(H264PredContext *h, int codec_id)\n\n{\n\n    mm_flags = mm_support();\n\n\n\n#if HAVE_YASM\n\n    if (mm_flags & FF_MM_MMX) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_mmx;\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmx;\n\n        h->pred8x8  [VERT_PRED8x8] = ff_pred8x8_vertical_mmx;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmx;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmx;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmx;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmx;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_MMX2) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmxext;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_mmxext;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmxext;\n\n        h->pred4x4  [DC_PRED     ] = ff_pred4x4_dc_mmxext;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmxext;\n\n            h->pred8x8  [DC_PRED8x8   ] = ff_pred8x8_dc_rv40_mmxext;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmxext;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmxext;\n\n            h->pred4x4  [VERT_PRED    ] = ff_pred4x4_vertical_vp8_mmxext;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_sse;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse;\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE2) {\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse2;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_sse2;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_sse2;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSSE3) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_ssse3;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_ssse3;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_ssse3;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_ssse3;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_ssse3;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 15679, "substitutes": {"h": ["hs", "eh", "ha", "auth", "x", "hash", "ssh", "t", "uh", "oh", "rh", "l", "ht", "hd", "ih", "hist", "y", "hm", "m", "hh", "gh", "q", "he", "hw", "hp", "host", "hl", "g", "bh", "k", "z", "ch", "hr", "sh", "ah", "H", "c", "hi", "http", "hhh", "p", "history", "him", "ph", "cl", "f", "th", "w", "r", "conn"], "codec_id": ["codec_pid", "codisc_name", "codec_vid", "coduc_name", "codec_type", "codisc_type", "codric_ids", "codecFstatus", "coduc_ids", "codec_status", "codecFvid", "coduc_id", "codecFids", "codric_id", "codecFid", "codec_name", "codric_vid", "codric_status", "codec_ids", "coduc_pid", "codisc_ids", "codisc_id"]}}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n", "idx": 15690, "substitutes": {"host_ts": ["host_ims", "host_tr", "target_ims", " host_fs", "host_times", "host_cs", "target_ports", "host_ports", " hostingfs", "target_times", " hostingts", "hostingcs", "hostingts", "target_cs", "host_fs", "hostingtimes", " host_cs", "hostingfs", " hostingcs", " host_times", "target_tr", " hostingtimes"], "target_addr": ["target_host", " target_nr", "target_address", "target_ord", " target_ptr", " target_address", "target_ptr", " target_host", "target_nr", " target_ord"], "target_ts": ["targetedts", "host_struct", "host_times", " target_times", "targetedds", " target_cs", "targeteduts", "target_ds", "targetedcs", " target_t", "target_TS", " target_TS", "target_stats", "target_t", " target_ds", "target_struct", "target_Ts", "target_tests", "targetablecs", "targetablews", "target_cs", "target_ws", "target_tt", " target_ws", " target_Ts", " target_uts", "target_uts", " target_tt", " target_tests", "targetablets", "target_times", "host_stats", "targetablett"]}}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)\n\n{\n\n}\n", "idx": 15696, "substitutes": {"high_page_enable": [" cpu_page_open", " cpu_page_enable", " cpu_page_enabled", " cpu_page_disable"], "cpu_request_exit": ["cpu_requestpreexit", "cpu_requestprepass", "cpu_request_enable", "cpu_requestpreenable", "cpu_page_enable", "cpu_page_pass", "cpu_page_close", "cpu_page_exit", "cpu_request_pass", "cpu_requestpreclose", "cpu_request_close"]}}
{"project": "FFmpeg", "commit_id": "51a1c1c6ac98d1d0d0a654f066782707af092fed", "target": 0, "func": "static void decode_delta_l(uint8_t *dst,\n\n                           const uint8_t *buf, const uint8_t *buf_end,\n\n                           int w, int flag, int bpp, int dst_size)\n\n{\n\n    GetByteContext off0, off1, dgb, ogb;\n\n    PutByteContext pb;\n\n    unsigned poff0, poff1;\n\n    int i, k, dstpitch;\n\n    int planepitch_byte = (w + 7) / 8;\n\n    int planepitch = ((w + 15) / 16) * 2;\n\n    int pitch = planepitch * bpp;\n\n\n\n    if (buf_end - buf <= 64)\n\n        return;\n\n\n\n    bytestream2_init(&off0, buf, buf_end - buf);\n\n    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));\n\n    bytestream2_init_writer(&pb, dst, dst_size);\n\n\n\n    dstpitch = flag ? (((w + 7) / 8) * bpp): 2;\n\n\n\n    for (k = 0; k < bpp; k++) {\n\n        poff0 = bytestream2_get_be32(&off0);\n\n        poff1 = bytestream2_get_be32(&off1);\n\n\n\n        if (!poff0)\n\n            continue;\n\n\n\n        if (2LL * poff0 >= buf_end - buf)\n\n            return;\n\n\n\n        if (2LL * poff1 >= buf_end - buf)\n\n            return;\n\n\n\n        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));\n\n        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));\n\n\n\n        while ((bytestream2_peek_be16(&ogb)) != 0xFFFF) {\n\n            uint32_t offset = bytestream2_get_be16(&ogb);\n\n            int16_t cnt = bytestream2_get_be16(&ogb);\n\n            uint16_t data;\n\n\n\n            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;\n\n            if (cnt < 0) {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                cnt = -cnt;\n\n                data = bytestream2_get_be16(&dgb);\n\n                for (i = 0; i < cnt; i++) {\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            } else {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                for (i = 0; i < cnt; i++) {\n\n                    data = bytestream2_get_be16(&dgb);\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15723, "substitutes": {"dst": ["Dsrc", " dbl", "dsts", "idsc", "Dsc", "Dst", "dsrc", "adsrc", "adbl", "Dsts", "idst", "adst", " dsrc", "idbl", "idsts", "Dbl", "dbl", "dsc", " dsc", " dsts", "adsc"], "buf": ["fp", "large", "hum", "orig", "uf", "pkg", "cb", "fb", "seq", "rb", "cur", "utf", "box", "h", "window", "src", "uint", "len", "client", "batch", "aka", "um", "pub", "cmd", "path", "header", "queue", "pool", "lim", "num", "block", "c", "off", "buffer", "filename", "cas", "ru", "ctr", "bl", "bc", "feat", "ff", "wb", "cap", "rc", "buff", "home", "http", "conv", "ph", "av", "Buff", "text", "ref", "dest", "ha", "br", "comb", "desc", "length", "vec", "uc", "config", "proc", "ctx", "cp", "coord", "cli", "b", "begin", "ctrl", "bag", "ab", "wav", "port", "loc", "fw", "img", "cv"], "buf_end": ["buf2start", "bufipopen", "pkg_stop", "buf2clean", "bufMexit", "fbMclean", " buf_ending", "fb_end", "buf_id", "buffer_start", "buf2size", "pkg_end", "bufsstart", "buf67end", "buf_ends", "uf_ends", "buf2ends", " buf_edge", "bufipfor", "buf67clean", "fbMend", "buf67ends", "fb_ends", " buf_ended", "uf_start", "buf2ending", "buffer_size", "bufsbegin", "buf_stop", "buffer_id", "bufMends", "buf2begin", " buf_begin", "buffer_end", "buf2edge", "pkg_open", "pkg_start", "buf2exit", "buf_clean", "buf_open", "fb_exit", "uf_ender", "buf_ending", "uf_open", "buf2ender", "bufipend", "uf_for", "buf_start", "buf67exit", "fbMends", "bufsend", "buf_size", "buf_edge", "bufsending", "buf2end", "uf_ize", "buf_ize", "buf2id", "buf_exit", "buf2ended", "buffer2size", "buffer2id", "uf_ending", "buf_for", "buf_ended", "buffer2end", "fb_clean", "uf_end", "buf_ender", "fbMexit", "bufipstart", "bufMclean", "buf_begin", "buffer2start", "bufMend", " buf_start"], "w": ["wall", "d", "wh", "ew", "rw", "tw", "v", "wal", "l", "wd", "work", "wb", "iw", "wed", "ow", "W", "wave", "hw", "wo", "aw", "wx", "num", "word", "g", "wid", "n", "win", "x", "ww", "h", "c", "wl", "wt", "window", "p", "we", "max", "sw", "b", "wei", "kw", "wcs", "web", "fw", "wa"], "flag": ["FLAG", "binary", "debug", "sync", "big", "field", "empty", "v", "count", "Flag", "nc", "bc", "mask", "ff", "band", "cb", "ag", "bin", "pad", "ui", "group", "offset", "wave", "bg", "xp", "byte", "z", "win", "fc", "q", "info", "f", "start", "flags", "lf", "pin", "bit", "nl", "len", "lag"], "bpp": ["bcp", "sbpe", "sbpp", "bff", "lpp", "fbpe", "ppps", "sbcp", "hsp", "fbpp", "lbcp", "sbpush", "lbpo", "bupp", " bff", "fbpo", "bpps", "bsp", "bpe", "lbpp", "pff", " bcp", "bcpp", "fff", "lpe", "lbcpp", "hcpp", "pupp", "hpp", "fpp", "pps", "fps", "hpps", " bupp", "lcp", "psp", "lpo", "bpush", "fbcp", " bpe", " bpush", "bpo", "bps", "lbsp", "lbpe", "fupp", "lbpps", " bps", "lbpush", "ppp", "pcpp"], "dst_size": ["dst_name", "dbl_addr", "dstblockaddr", "dbl_size", "dst_addr", "dstblockname", "dst_Size", "dbl_name", "dstblocksize"], "off0": ["Off02", "eff02", " offZero", "flow0", "offer0", "offer1", "Off0", "flow1", "offer8", "ff02", "OffZero", "ff0", "eff0", "eff1", "offset1", "off02", "ff00", "flow8", "flow12", "Off12", "off00", "offsetZero", "offZero", "ff1", "off12", "Off00", "offset0", "Off1", "eff00", "off8", "offer12", "Off8"], "off1": ["off2", "OFF2", " off2", " offone", "OFFOne", "offer1", "offer0", "Off0", "Off4", "out1", "off4", "OFF0", "Off2", " offOne", "offer2", "OFF1", "offOne", "OFFone", "offone", "out4", "OffOne", "Off1", "offerone", "out0", "offer4"], "dgb": [" dbm", "madGB", "xdgg", "madbm", "dGB", "xdgl", "bdgg", "dgg", "xdgb", "pdbm", "adgl", "madgb", "xdGB", "dgl", " dGB", "pdgz", "adGB", " dgz", "dbm", "bdGB", "adgg", "bdgb", "dgz", "adgb", "pdgb", "pdGB", "madgz", "bdgl"], "ogb": ["orgl", "OGf", "OGc", "ugb", "agB", "agb", "ogp", "oggc", "ocd", "odr", "ocl", "odc", "ugf", "ogB", "ugc", "occ", "ogc", "agc", "ongl", "ogf", "ocf", "orgc", "OGB", "ogr", "ongv", "orgb", "ogd", "oggf", "orgr", "odp", "orgv", "ongr", "ocv", "ongb", "OGb", "agf", "ongc", "ocb", "odb", "oggB", "odl", "ogv", "ocp", "oggb", "agd", "odf", "oggp", "ogl", "ugd"], "pb": ["fp", "bm", "rw", "cpp", "tmp", "tp", "jp", "bf", "tc", "bc", "pc", "cb", "fb", "wb", "kb", "wp", "pg", "db", "PB", "pd", "lb", "typ", "bh", "rb", "lp", "fc", "bp", "cp", "p", "bb", "tx", "src", "sb", "dp", "ab", "eb", "ub", " PB", "xb", " subp"], "poff0": ["poff13", "qoffer90", "poff86", " pOff1", "POff0", "poffset0", "poff3", "pOff1", "poffs3", "pout0", "qofferNe", " pout0", "peff1", "pinfoee", "pnum1", "Poff0", "perrorNe", "poffer0", "pOff06", " poff13", "Poff4", "pofferee", " poff20", "pdef1", "qoffe", "pdef0", "pinfo20", " pOff0", "poffe", "poff90", "poffsee", " pout20", " poffee", "pdef86", "pOff0", " poffs1", "poffset1", "qoff0", "poffs0", "peff00", "POff1", "pdefe", "pnum86", "peff0", "qoffNe", "pnum4", "puff1", "poffs1", " poffs0", "pout13", "POff06", " poff3", "poff20", "poffsetee", "pdefNe", "pofferNe", " pOff00", "Poff1", "poffee", " poffs3", "Poff06", "pnum0", "qoffer0", " poutee", "puff06", " poffsee", "perror90", "qoffere", "poffer20", "pinfo0", "perror0", "pdef90", "perrore", "poffere", "pinfo13", " poff00", "pout20", "poff00", "pOff00", "poffer90", "Poff86", "pdef4", "poutee", "poff4", "poffer13", "poffNe", "qoff90", "poffset3", "puff0", "poff06", " pout13"], "poff1": ["poff2", "POff0", " poffn", "poffset0", " pOFFn", " pOFF0", "pOff1", "POff81", "poffb", "Poff0", "pforn", "pdef1", "PoffOne", "pdef0", "pOFF0", "pOff0", "poffset1", "poffs0", "POff1", "pload1", "Poff81", "pOFFb", "poffs1", "pdef2", "poffs81", " poff2", " pload2", "pload0", "Poff1", " poffb", "poffsetOne", "pOFF1", " pOFFb", "pOffn", " pload0", "pOff81", "poffn", "poffsetb", "pload2", "pOffOne", "poffsetn", "pOFFn", "poff81", "pfor1", "poffOne", "pfor0", "poffsn", "poffset81", "POffn", "Poffn", " pload1", " pOFF1", "POffOne", "poffsOne"], "i": ["it", "d", "o", "v", "e", "u", "l", "pi", "m", "ui", "g", "z", "n", "ik", "io", "ip", "c", "x", "info", "p", "index", "b", "f", "ind", "j", "ii", "I"], "k": ["d", "o", "ky", "ok", "v", "kin", "kick", "e", "u", "kat", "work", "kn", "y", "m", "dk", "unk", "kid", "ke", "g", "ck", "ks", "z", "n", "ik", "ku", "kj", "K", "x", "q", "c", "h", "uk", "kk", "p", "ki", "ak", "b", "kw", "f", "kh", "ko", "j", "r", "ek", "km", "sk"], "dstpitch": ["destpitching", "dostpiece", "dstwpitch", "dostpose", "dstPiece", "dstepITCH", "dstepitch", "dstpitching", "dostpITCH", "dstPitch", "destpose", "dstPose", "dstwpitching", "dostPITCH", "dostPiece", "dstpiece", "dstpatch", "destnpitching", "dstnpatch", "destnpitch", "dstnpITCH", "dstpose", "dostPitch", "dstnpitching", "dstnpiece", "dstPitching", "dstPITCH", "dstwpatch", "destnpose", "destnpatch", "dstepiece", "dstpITCH", "dostPose", "dstepose", "dstnpitch", "dostpitch", "destpatch", "dstnpose", "destpitch", "dstwpose", "dstPatch"], "data": ["body", "batch", "shift", "raw", "pos", "align", "bin", "val", "pad", "total", "partial", "valid", "next", "block", "extra", "complete", "bytes", "info", "index", "Data", "start", "DATA", "buffer", "aa", "len"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n", "idx": 15728, "substitutes": {"opaque": ["Opaque", "opaques", "Opdc", "ipopaque", "oprc", " opdc", "oppity", "Opec", "opdc", "OPity", "oppaques", "ipopity", "ipopaques", "OPrc", "opec", " opec", "opacity", "OPec", "ipopacity", "OPdc", " oprc", "opity", "oppaque", "oppacity", "OPaques", "Oprc", "OPaque", "OPacity"], "addr": ["prefix", "enc", "address", "dr", "ord", "amd", "data", "mode", "adr", "pos", "pc", "rt", "align", "pad", "attr", "grad", "offset", "state", "fd", "nr", "xp", "ptr", "rc", "config", "host", "point", "arg", "x", "mac", "pointer", "coord", "index", "device", "src", "ind", "inter", "ace", "ref", "arm", "alt", "ad"], "val": ["VAL", "bl", "data", "v", "eval", "pt", "sel", "base", "slot", "loc", "el", "grad", "offset", "valid", "al", "unit", "Val", "cond", "arg", "x", "index", "vol", "b", "lit", "vals", "arr", "buf", "value", "ret", "ref", "len"], "d": ["bd", "o", "di", "ade", "dt", "dom", "data", "md", "ld", "e", "cd", "l", "dat", "ds", "db", "dc", "m", "state", "fd", "g", "ded", "z", "k", "id", "dh", "sd", "c", "i", "p", "od", "b", "f", "ind", "D", "r", "gd", "t", "da", "ad"], "reg": ["enc", "debug", "bl", "exec", "acc", "ld", "pc", "REG", "dat", "eg", "res", "pg", "ig", "tag", "grad", "mod", "sec", "config", "g", "rec", "arg", "ac", "win", "mem", "Reg", "arr", "re", "red", "ind", "stat", "r", "rg", "loc", "conn", "ad"]}}
{"project": "qemu", "commit_id": "1a29cc8f5ebd657e159dbe4be340102595846d42", "target": 0, "func": "void serial_realize_core(SerialState *s, Error **errp)\n\n{\n\n    if (!qemu_chr_fe_backend_connected(&s->chr)) {\n\n        error_setg(errp, \"Can't create serial device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    qemu_register_reset(serial_reset, s);\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,\n\n                             serial_event, NULL, s, NULL, true);\n\n    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);\n\n    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);\n\n    serial_reset(s);\n\n}\n", "idx": 15775, "substitutes": {"s": ["session", "site", "v", "u", "ts", "states", "sys", "si", "m", "plugins", "sec", "xs", "self", "n", "spec", "i", "set", "qs", "sb", "js", "services", "t", "ps", "client", "sync", "fs", "serv", "o", "cs", "e", "ss", "ssl", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "settings", "socket", "l", "ds", "service", "stats", "http", "sl", "ses", "sym", "S", "ops", "d", "rs", "south", "secondary", "server", "g", "es", "ks", "os", "side", "su", "secure", "p", "b", "aws", "sets", "f", "w", "ls", "r", "conf"], "errp": ["errpe", "rrpre", " errpe", "erpe", "errpc", " errr", " errpre", "errr", "rrr", "erpc", " errpc", "erpre", "rrp", " errP", "errpre", "frpe", "frpre", "erP", "rrP", "frp", "errP", "frpc", "err", "erp"]}}
{"project": "qemu", "commit_id": "44bc910794eff956ceba0030f0751a26bed748b5", "target": 0, "func": "static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            /* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  */\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            /* No address translation.  */\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 15779, "substitutes": {"env": ["enc", "dt", "site", "exec", "exc", "v", "erv", "pos", "obj", "act", "dat", "chn", "ec", "ea", "np", "spec", "cur", "init", "scope", "esi", "lv", "conn", "en", "ne", "qv", "esp", "txt", "global", "e", "eng", "db", "hw", "lc", "eni", "org", "osc", "iss", "cache", "context", "c", "shell", "cal", "event", "chal", "oa", "et", "engine", "environment", "fi", "vm", "qt", "kn", "dep", "cdn", "dev", "vs", "viron", "que", "enh", "ev", "nc", "util", "server", "ou", "config", "eu", "net", "inv", "cli", "energy", "console", "equ", "conf", "Environment", "cv"], "ctx": ["fp", "client", "enc", "sync", "ct", "environment", "cu", "cn", "exec", "git", "exc", "jp", "sc", "nc", "bc", "obj", "sci", "pkg", "cf", "cb", "qt", "qa", "conf", "cmp", "state", "inst", "hw", "sem", "rc", "config", "proc", "lc", "linux", "vc", "np", "tk", "ci", "ch", "context", "c", "conv", "gz", "lib", "cli", "qs", "cl", "kw", "ctrl", "tx", "src", "kt", "ca", "utils", "wcs", "que", "xc", "loc", "fw", "conn", "cas", "cv"], "eaddr": ["reamdr", "reamder", "efdr", "eghr", "eedDR", "egder", "oadder", "aydress", "eydr", "adybr", "cehr", "eedder", "ealdr", "asyfr", "egbr", "asydr", "eadfr", "egfr", "adyfr", "eadDr", "eadDR", "ecder", "ellder", "adydr", "asyhr", "eyDR", "reamDR", "ewayDr", "cedr", "cefr", "elldr", "eyhr", "oadhr", "ealder", "efDR", "asyDR", "oadric", "ceDR", "ewayDR", "efder", "eeddr", "egdr", "ellDR", "egdress", "ayhr", "ellfr", "ayder", "ealDR", "efDr", "eybr", "ewaydr", "ecDR", "eedfr", "aydr", "ayDR", "ayfr", "adyDR", "egDR", "eadric", "ayric", "ellhr", "ecdr", "ewayder", "oaddr", "ecDr", "eadhr", "reamric", "asyder", "eaddress", "oadDR", "adyhr", "eadder", "ealdress", "eadbr"], "rw": ["wh", "ru", "ew", "nor", "tw", "war", "raw", "wal", "resp", "rh", "worker", "wr", "wu", "wd", "work", "wb", "iw", "writer", "wp", "rf", "rack", "lr", "rew", "hw", "rr", "wo", "usr", "wx", "rb", "vc", "wer", "ww", "rx", "wl", "wt", "sw", "RW", "kw", "lv", "row", "dra", "sr", "w", "wcs", "rl", "vr", "ring", "wn", "rg", "nw", "fw", "r", "rn", "wk", "wa"], "access_type": ["accessallength", "accessenmodel", "accesstypelevel", "accessingcode", "access_level", " access_level", "accessentime", " access_TYPE", " access_time", "accessalrole", "access_length", "accessingtype", "access_ver", " access_field", " access_role", "accessabletype", "access_style", "access_code", "access_address", "access_value", " access_class", "accessabletypes", " access_rel", "access_time", " access_code", "access_block", "accessetvalue", "accesstypeaddress", "accessXlevel", "access_field", "access_types", " access_block", " access_model", "accessablelevel", "access_site", "accessalblock", " access_site", "accessXtype", " access_ver", "access_key", "access_role", "access_class", " access_types", " access_address", "access_model", "accessaltype", "accessXmodel", " access_key", "accessingkey", " access_length", "accessettype", "accessallevel", "accesstypetype", "access_TYPE", "accessalkey", "accessingTYPE", "accessentype", "access_rel", "accessetclass", " access_value", " access_style", "accesstypetypes", "accessableaddress"], "ret": ["part", "gt", "ft", "aug", "success", "resp", "nt", "bf", "match", "result", "ut", "feat", "obj", "rt", "att", "lt", "val", "alt", "job", "def", "res", "db", "pet", " RET", "det", "fit", "reply", "fun", "rc", "url", "num", "reg", "error", "rets", "arg", "id", "rev", "opt", "mem", "cur", "mt", "art", "info", "ext", "status", "let", "lit", "cat", "arr", "re", "RET", "flag", "std", "rl", "back", "err", "bit", "pass", "ref", "len", "Ret"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n", "idx": 15788, "substitutes": {}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "static void blockdev_do_action(int kind, void *data, Error **errp)\n\n{\n\n    TransactionAction action;\n\n    TransactionActionList list;\n\n\n\n    action.kind = kind;\n\n    action.data = data;\n\n    list.value = &action;\n\n    list.next = NULL;\n\n    qmp_transaction(&list, errp);\n\n}\n", "idx": 15791, "substitutes": {"kind": ["part", "good", "func", "sid", "nd", "decl", "kick", "mode", "Kind", "dir", "feat", "end", "cycle", "cmd", "head", "need", "direction", "style", "def", "depth", "path", "shape", "in", "concept", "kid", "ke", "method", "k", "class", "tick", "spec", "id", "init", "context", "IND", "code", "type", "lit", "plugin", "prop", "start", "name", "th", "kt", "ind", "mid", "brand", "sth", "std", "dest"], "data": ["done", "body", "d", "batch", "actions", "options", "exec", "draw", "raw", "multi", "results", "record", "primary", "media", "image", "result", "base", "parts", "dat", "params", "val", "post", "resource", "database", "object", "new", "state", "api", "response", "a", "values", "parent", "key", "next", "progress", "input", "args", "missing", "Data", "dd", "index", "type", "device", "arr", "start", "name", "load", "DATA", "entry", "value", "alpha", "da", "array", "function"], "errp": ["derpe", " errfp", "errpe", " errpe", "arrp", "derlp", "errpc", "derp", "errap", "arrpc", "errlp", "erap", "arrpe", "rrfp", "erpc", " errpc", "errfp", "rrp", "rrap", "rrpc", "derpc", "erfp", " errap", " errlp", "erp", "arrlp"], "action": ["sync", "ction", "save", "step", "actions", "ass", "all", "Action", "actor", "act", "result", "l", "base", "element", "commit", "val", "bin", "account", "sort", "root", "this", "api", "export", "response", "a", "error", "parent", "edit", "self", "block", "ac", "item", "admin", "init", "version", "change", "current", "stage", "ACTION", "active", "index", "type", "ack", "tx", "out", "load", "before", "call", "option", "section", "entry", "event", "next", "array", "function"], "list": ["part", "sync", "LIST", "batch", "test", "null", "all", "filter", "li", "record", "loop", "e", "act", "result", "join", "l", "base", "L", "val", "plan", "object", "List", "view", "self", "class", "block", "n", "lock", "add", "item", "change", "set", "p", "cl", "type", "index", "coll", "arr", "out", "load", "call", "entry", "value", "show", "tail", "chain", "array", "sequence", "code"]}}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)\n\n{\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n\n        const int strength = ff_h263_loop_filter_strength[qscale];\n\n        DECLARE_ALIGNED(8, uint64_t, temp)[4];\n\n        uint8_t *btemp = (uint8_t*)temp;\n\n\n\n        src -= 2;\n\n\n\n        transpose4x4(btemp,     src,              8, stride);\n\n        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);\n\n        __asm__ volatile (\n\n            H263_LOOP_FILTER // 5 3 4 6\n\n\n\n            : \"+m\"(temp[0]),\n\n              \"+m\"(temp[1]),\n\n              \"+m\"(temp[2]),\n\n              \"+m\"(temp[3])\n\n            : \"g\"(2 * strength), \"m\"(ff_pb_FC)\n\n            );\n\n\n\n        __asm__ volatile (\n\n            \"movq      %%mm5, %%mm1         \\n\\t\"\n\n            \"movq      %%mm4, %%mm0         \\n\\t\"\n\n            \"punpcklbw %%mm3, %%mm5         \\n\\t\"\n\n            \"punpcklbw %%mm6, %%mm4         \\n\\t\"\n\n            \"punpckhbw %%mm3, %%mm1         \\n\\t\"\n\n            \"punpckhbw %%mm6, %%mm0         \\n\\t\"\n\n            \"movq      %%mm5, %%mm3         \\n\\t\"\n\n            \"movq      %%mm1, %%mm6         \\n\\t\"\n\n            \"punpcklwd %%mm4, %%mm5         \\n\\t\"\n\n            \"punpcklwd %%mm0, %%mm1         \\n\\t\"\n\n            \"punpckhwd %%mm4, %%mm3         \\n\\t\"\n\n            \"punpckhwd %%mm0, %%mm6         \\n\\t\"\n\n            \"movd      %%mm5, (%0)          \\n\\t\"\n\n            \"punpckhdq %%mm5, %%mm5         \\n\\t\"\n\n            \"movd      %%mm5, (%0, %2)      \\n\\t\"\n\n            \"movd      %%mm3, (%0, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm3, %%mm3         \\n\\t\"\n\n            \"movd      %%mm3, (%0, %3)      \\n\\t\"\n\n            \"movd      %%mm1, (%1)          \\n\\t\"\n\n            \"punpckhdq %%mm1, %%mm1         \\n\\t\"\n\n            \"movd      %%mm1, (%1, %2)      \\n\\t\"\n\n            \"movd      %%mm6, (%1, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm6, %%mm6         \\n\\t\"\n\n            \"movd      %%mm6, (%1, %3)      \\n\\t\"\n\n            :: \"r\"(src),\n\n               \"r\"(src + 4 * stride),\n\n               \"r\"((x86_reg)stride),\n\n               \"r\"((x86_reg)(3 * stride))\n\n            );\n\n    }\n\n}\n", "idx": 15804, "substitutes": {"src": ["upp", "send", "sc", "fe", "cb", "sur", "sec", "seq", "scale", "RC", "rb", "sup", "spec", "cur", "sr", "start", "ind", "stack", "sync", "tmp", "shift", "temp", "seed", "split", "sil", "scl", "transform", "ssl", "slice", "sq", "inst", "supp", "rib", "iv", "input", "buf", "filename", "bis", "ctr", "bc", "fn", "feat", "sel", "size", "shape", "bg", "rc", "conv", "lit", "sl", "name", "stream", "chrom", "inf", "comp", "dest", "gl", "source", "dist", "length", "uri", "grad", "ptr", "url", "small", "config", "low", "ctx", "fc", "gz", "secure", "s", "gb", "loc", "img"], "stride": ["bride", "stade", "tride", "traine", "staade", " stridi", "brade", " strIDE", "stode", "variided", " strision", "striden", "staine", "Strade", "stide", "colliden", "straine", "stine", "Stride", "strade", "stider", "strIDE", "strine", "strision", " strider", "trade", "prividen", "staide", "trIDE", "staider", "strided", "collide", "prividi", "strode", "Straine", "brIDE", "Strided", "shrade", "variIDE", "variider", "trided", "stided", "stIDE", "Strode", " strade", "Strine", "privide", "collidi", "brided", "variide", " strided", "stridi", " strode", "trider", "shride", "shraine", "collided", "strider", " strine", "staaine", "shrision", " straine", "braine", "privided", " striden", "Strision"], "qscale": ["dqgrade", "dqcast", "qcast", "dqscale", "qtransform", "qdi", "qmode", " qmode", "dqtransform", "dqmode", " qgrade", "qutransform", "dqdi", "sqtransform", "Qmode", "sqcast", "qgrade", "Qcale", "Qscale", "qcale", "sqdi", "qudi", "dqcale", "quscale", " qcale", "Qgrade", "qucast", "sqscale"], "btemp": ["wbtemp", "bemp", "wbconst", "vtemp", "rtem", "remp", "bconst", "Btemp", "wbemp", "rbfake", "sbtemp", "sbbase", "BTemp", "bfake", "rtemp", "sbfake", "bdest", " bdest", "rbconst", "Bconst", "lbtemp", "vconst", "rbdest", "rconst", "lbfake", "wbtem", "Bdest", "vtem", "bbase", "rbbase", "vemp", " bconst", "sbdest", "lbdest", "rbTemp", "rbtemp", "bTemp", " bTemp", "lbbase", "btem"], "H263_LOOP_FILTER": ["H263_LOOP_IFTER", "H263_LOOP_FTE", "H263_LOOP_FNER", "H263_LOOPINGFILER", "H263_LOOP_AFTE", "H263_LOOP_AFER", "H263_LOOPINGIFNER", "H263_LOOP_AFTER", "H263_LOOPINGIFER", "H263_LOOP_FER", "H263_LOOPINGFILNER", "H263_LOOP_IFER", "H263_LOOP_FILNER", "H263_LOOP_AFNER", "H263_LOOPINGFILTER", "H263_LOOPINGIFTER", "H263_LOOPINGIFTE", "H263_LOOP_IFNER", "H263_LOOPINGFILTE", "H263_LOOP_IFTE", "H263_LOOP_FTER", "H263_LOOP_FILER", "H263_LOOP_FILTE"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void bootp_reply(struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp->bp_vend, DHCP_OPT_LEN, &dhcp_msg_type);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\\n\", bp->bp_op, dhcp_msg_type);\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n    new_addr:\n\n        bc = get_new_addr(&daddr.sin_addr);\n\n        if (!bc) {\n\n            dprintf(\"no address left\\n\");\n\n            return;\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    if (bootp_filename)\n\n        snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                 bootp_filename);\n\n\n\n    dprintf(\"offered addr=%08x\\n\", ntohl(daddr.sin_addr.s_addr));\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPOFFER;\n\n    } else if (dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPACK;\n\n    }\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER ||\n\n        dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 15811, "substitutes": {"bp": ["fp", "prefix", "bm", "batch", "mp", "cpp", "bitcoin", "tp", "git", "jp", "bf", "pkg", "ap", "pc", "pm", "cb", "fb", "ib", "kb", "pp", "wb", "orb", "wp", "pg", "db", "sp", "bt", "lb", "hp", "proc", "bh", "lp", "BP", "np", "nb", "ctx", "cp", "p", "bb", "cli", "b", "plugin", "sb", "gp", "eb", "gb", "vp", "arp", "pb"], "bc": ["sync", "ha", "bd", "CBC", "cgi", "bn", "oc", "ok", "exc", "cm", "tc", "bf", "sc", "br", "nc", "pc", "cf", "cb", "fb", "gc", "anc", "ou", "ec", "cc", "dc", "db", "cmp", "lic", "uc", "lb", "BC", "bg", "sec", "lc", "rc", "cca", "config", "bs", "ac", "vc", "ci", "bi", "fc", "cache", "c", "cp", "bb", "lib", "core", "cl", "b", "ctrl", "sb", "acl", "mc", "ca", "bo", "msg", "cr", "abc", "web", "xc", "loc", "ref", "conn", "cms", "jc", "pb", "code"], "m": ["fm", "module", "d", "mm", "o", "um", "vm", "t", "v", "md", "cm", "mad", "gm", "e", "sm", "media", "u", "mu", "im", "l", "y", "wm", "hm", "machine", "tm", "mn", "mo", "M", "ym", "om", "em", "g", "man", "n", "am", "mt", "rm", "c", "h", "i", "ma", "p", "b", "mr", "f", "dm", "mc", "msg", "ms", "r", "j", "sym", "manager", "bm"], "rbp": ["rfm", "rdP", "crP", "erbp", "cbP", "fbpe", "rcpp", "RBtp", "crc", "erbvp", "dbpr", "cbc", "dbp", "sbvp", "rfp", "rbvp", "RBpr", "rbpe", "rrpr", "rdvp", "rlpg", "cbpe", "rbpa", "erbP", "rfpe", "dbpg", "robm", "rltp", "rrpp", "rbP", "rbpp", "robp", "rbpg", "sbP", "rbpr", "erbc", "fbc", "dbtp", "fbp", "rrp", "nrp", "erbpe", "rlpr", "rcpa", "rfc", "rbtp", "rcpr", "sbc", "cbp", "rbm", "rlp", "nrpr", "RBpg", "erbm", "sbp", "crp", "fbP", "rcp", "rdp", "rrpa", "RBp", "robc", "rbc", "robpe", "nrpp", "rdc", "crpe", "nrpa"], "saddr": ["dsaddress", "fhost", "dptr", "Saddress", " serg", "southaddress", "hptr", " shost", "grt", "ghost", "saddress", "Srt", "hhop", "srt", "sarr", "Saddr", "dsaddr", "fhop", "shost", " saddress", "sptr", "dhost", "shop", " sarr", "southarr", "southaddr", "fptr", "haddr", "gaddress", "dserg", "Shost", "serg", "dsarr", "faddr", "hhost", "southerg", "gaddr", " srt", "dhop"], "daddr": [" daug", "dorig", "adarr", "dptr", "sdaddr", " dalign", "daddress", "sadd", "darr", "adaddress", "saddress", "adadr", "sorder", "sdaddress", "pdaddress", "sadr", " darr", " dorder", "sarr", "diaddress", "sdarr", "sdorder", " dorig", "daug", "dorder", "sdorig", " dadd", "saug", "pdorig", "sptr", " dptr", " dadr", "diadd", "pdalign", "pdaddr", "sdaug", "dadr", "sdadr", " daddress", "dadd", "sdalign", "adaddr", "dalign", "diptr", "diaddr"], "dns_addr": ["dnet_address", "dnsipaddress", "dnsipserver", "dns_error", "dnsiperror", "dnsipaddr", "dnet_addr", "dns_server", "dns_address", "dnet_server", "dnet_error"], "dhcp_msg_type": ["dhcp_message_types", "dhcp_msg4value", "dhcp_msg_id", "dhcp_msg_style", "dhcp_message_style", "dhcp_message_info", "dhcp_msg4type", "dhcp_message_no", "dhcp_message_class", "dhcp_message_id", "dhcp_message_Type", "dhcp_message_set", "dhcp_msgxno", "dhcp_msg_Type", "dhcp_msg_set", "dhcp_msg2type", "dhcp_msg4style", "dhcp_msg2types", "dhcp_msg4id", "dhcp_msg_types", "dhcp_msg_key", "dhcp_msgxtype", "dhcp_msg2set", "dhcp_msgxkey", "dhcp_msg2id", "dhcp_msgxid", "dhcp_message_type", "dhcp_message_name", "dhcp_msg_no", "dhcp_msg_class", "dhcp_msg_name", "dhcp_msg_info", "dhcp_msg_value", "dhcp_message_key", "dhcp_message_value"], "val": ["enc", "fee", "data", "v", "resp", "eval", "sel", "timeout", "slot", "offset", "valid", "al", "sec", "seq", "num", "byte", "key", "mem", "x", "vals", "msg", "bit", "value", "buf", "ret", "ref", "len"], "q": ["quality", "required", "qq", "Q", "v", "iq", "P", "query", "qt", "qa", "quant", "sq", "seq", "config", "num", "g", "k", "key", "c", "req", "f", "w", "dq", "buffer", "bit", "eq", "r"]}}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "func": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 15818, "substitutes": {"drc": [" dfc", "dRC", " drec", "adsrc", "pfc", "DRC", "dspc", "pduc", "fsrc", "tcc", " dRC", " dsrc", "ldpc", "dsuc", " dirc", "droc", "pirc", " droc", " dpc", "pdsrc", "Dsrc", "ddroc", "sduc", "dsrc", "fcc", "ddconfig", "ldrc", "tsrc", "lrc", "dsroc", "ddrc", " duc", "dpc", " dbc", "adrc", "dssrc", "sdRC", "dconfig", "trc", "pdrc", " dconfig", "Droc", "Duc", "frc", "duc", "pdroc", "sdsrc", "psrc", "Dirc", "dsirc", "fbc", "dcc", "dbc", "ldsrc", "dirc", "drec", "sdcc", "Drc", "Dbc", "fRC", "lRC", "sdbc", "sdrc", "adirc", "Dconfig", "dfc", "adfc", "lirc", "sdirc", "tRC", "prc", "ldirc", "lrec", "Drec", "ddirc"]}}
{"project": "qemu", "commit_id": "2e6a64cb8d7506ad27d3b6c8000bc8d773936932", "target": 0, "func": "static void input_linux_event_mouse(void *opaque)\n\n{\n\n    InputLinux *il = opaque;\n\n    struct input_event event;\n\n    int rc;\n\n\n\n    for (;;) {\n\n        rc = read(il->fd, &event, sizeof(event));\n\n        if (rc != sizeof(event)) {\n\n            if (rc < 0 && errno != EAGAIN) {\n\n                fprintf(stderr, \"%s: read: %s\\n\", __func__, strerror(errno));\n\n                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);\n\n                close(il->fd);\n\n            }\n\n            break;\n\n        }\n\n\n\n        input_linux_handle_mouse(il, &event);\n\n    }\n\n}\n", "idx": 15823, "substitutes": {"opaque": ["ospacle", "ospaque", "cpity", "ipacity", "ospity", "opac", "popac", "opaques", "cpaques", " opaques", "ipaque", " opity", "cpacle", "opacity", "appacity", "ospaques", "ipac", "cpaque", "ipaques", "appaques", "opity", "appac", "popaque", "popacity", " opacle", "appaque", "opacle", "popaques"], "il": ["fp", "IL", "iu", "kel", "inet", "li", "ol", "ill", "ll", "fl", "util", "sil", "ipl", "l", "sel", "ml", "nil", "intel", "isl", "loc", "el", "ilo", "lb", "al", "lin", "dl", "hl", "lp", "ils", "owl", "mil", "iel", "fc", "ilk", "ul", "wl", "ail", "fil", "syn", "iol", "sl", "oll", "ir", "pl", "acl", "cel", "rl", "nl"], "event": ["large", "update", "address", "bug", "test", "ev", "xml", "exec", "content", "data", "actual", "raw", "reader", "exc", "source", "pull", "e", "image", "events", "container", "vent", "message", "feature", "inner", " Event", "element", "server", "resource", "ec", "object", "irc", "comment", "error", "url", "byte", "Event", "view", "channel", "handler", "cue", "ce", "context", "x", "input", "rx", "pointer", "date", "type", "ex", "ack", "f", "row", "name", "load", "stream", "entry", "esc", "text", "ee", "code"], "rc": ["ct", "oc", "ok", " src", " RC", "nt", "sc", "nc", "result", "bc", "ffff", "rh", "pc", "cb", "rt", "ec", "cc", "irc", "dc", "rr", "error", "hl", "lc", "ck", "RC", "rb", "rec", "ac", "cv", "vc", "cur", "fc", "c", "rx", "bb", "inc", "co", "src", "cr", "row", "roc", "err", "rl", "abc", "rn", "auc", "sth", "rg", "loc", "xc", "ref", "code"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 15833, "substitutes": {"a": ["aux", "d", "ba", "o", "af", "ar", "la", "e", "sa", "u", "ap", "l", "area", "y", "an", "ga", "ai", "m", "ae", "aj", "ea", "g", "ac", "n", "ia", "pa", "am", "c", "x", "i", "art", "ama", "p", "ma", "b", "A", "f", "va", "ao", "as", "ca", "ab", "au", "aa", "alpha", "at", "aaa", "da", "ad", "aw"], "STATUS_PARAM": ["STATUS_VAM", "STATUS_PAR", "STATUS_STATAR", "STATUS_PARAR", "STATUS_PAME", "STATUS_PAM", "STATUS_PARM", "STATUS_STATAM", "STATUS_STATARM", "STATUS_STATAME", "STATUS_VAR", "STATUS_PARAME", "STATUS_VAME", "STATUS_PARARM", "STATUS_VARM"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_cmp(TCGCond cond,\n\n                                  int ra, int rb, int rc,\n\n                                  int islit, uint8_t lit)\n\n{\n\n    int l1, l2;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n    return;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_mov_i64(tmp, cpu_ir[ra]);\n\n    } else\n\n        tmp = tcg_const_i64(0);\n\n    if (islit)\n\n        tcg_gen_brcondi_i64(cond, tmp, lit, l1);\n\n    else\n\n        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);\n\n\n\n    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_ir[rc], 1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 15840, "substitutes": {"cond": ["bug", "temp", "cont", "la", "resp", "bf", "count", "pos", "bc", "act", "cd", "def", "condition", "race", "cmp", "dc", "fd", "sec", "unit", "lc", "config", "proc", "reg", "pre", "ac", "lock", "fc", "c", "ond", "rol", "lib", "lab", "co", "prop", "circ", "pl", "red", "ind", "diff", "xc", "loc", "ref", "Cond", "comp", "code"], "ra": ["ror", "ru", "ha", "ica", "ar", "rar", "la", "rd", "ras", "sa", "ria", "rt", "raf", "area", "ro", "qa", "in", "rap", "ta", "Ra", "meta", "a", "rr", "da", "RC", "star", "rad", "sha", "spec", "RA", "rup", "stage", "range", "ara", "ri", "rac", "dra", "ir", "cr", "ca", "r", "alpha", "ran", "asa", "ora", "wa"], "rb": ["ru", "ril", "rid", "rar", "bf", "br", "rd", "rh", "ruby", "raf", "rt", "cb", "fb", "rob", "RB", "rf", "db", "lr", "reb", "lb", "nr", "rr", "lc", "rad", "rm", "bb", "ri", "b", "src", "sb", "cr", "ab", "rl", "gb", "vr", "abc", "r", "rg", "rn", "pb"], "rc": ["ru", "ctr", "ril", "rar", "la", "sc", "rd", "ras", "bc", "rh", "pc", "rt", "cb", "irc", "rog", "dc", "rf", "uc", "lr", "rr", "error", "hl", "lc", "reg", "RC", "rec", "ac", "rad", "spec", "cur", "fc", "c", "rx", "ref", "inc", "rac", "arc", "src", "cr", "row", "roc", "rl", "rn", "r", "xc", "rg", "loc", "rank", "alpha", "cv"], "islit": ["implitted", "flIT", "islitted", "flitting", "implitting", "isolitting", "islitting", "islIT", "cilitting", "isolite", "implit", "iplit", "flitted", "implIT", "ilit", "flit", "cilit", "cilIT", "ilite", "islite", "cilitted", "iplIT", "iplitting", "isolit", "ilIT", "iplite", "ilitting", "isolIT"], "lit": ["it", "ie", "iter", "fi", "split", "la", "pos", "lo", "l", "base", "lt", "val", "alt", "lite", "lat", "lic", "len", "lb", "lin", "sec", "unit", "lc", "lim", "nat", "lib", "lab", "sl", "il", "src", "late", "lv", "pl", "prop", "lang", "stat", "loc", "ref", "inf"], "l1": ["el2", "L4", "l100", "L3", "il100", "l4", "ml1", " l8", "il2", "el1", "ml3", " l3", "dl3", "dl8", "el4", "L2", "dl2", "L60", "el3", " l4", " l100", "L1", "L8", "l8", "el8", "L100", "ml60", "il3", "il1", "l60", "ml2", " l60", "l3", "dl1"], "l2": ["sltwo", "el2", "L4", "sl0", "v3", "sl4", "L3", " ltwo", "l4", "eltwo", "v1", "l02", "el1", " l02", " l3", "el4", "L2", " l0", "L0", "el3", "el02", " l4", "v2", "L1", "v0", "sl2", "ltwo", "el0", "L02", "l3", "l0"], "tmp": ["fp", "storage", "mp", "stuff", "cpp", "temp", "etc", "data", "vm", "txt", "cm", "bf", "pot", "tab", "tc", "nt", "obj", "result", "ff", "bc", "cop", "cb", "fb", "output", "cmp", "bt", "api", "cro", "tf", "ptr", "lc", "config", "cca", "proc", "lp", "sup", "EMP", "np", "acc", "nb", "ctx", "cache", "buff", "jp", "phi", "comp", "cp", "ref", "kk", "bb", "lab", "prop", "src", "sb", "abb", "buf", "beta", "xc", "loc", "emp", "img", "pb"]}}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 15846, "substitutes": {"qdev": [" qdd", "qdom", "wdebug", "qDev", "sqdevice", "wdev", "qdevice", "Qdom", "qdd", "qudev", "qver", "questdef", " qver", "qqdev", "QDev", "qqDev", "qudevice", "sqdebug", "questdom", "sqdev", "wdd", "iqdiv", "wdevice", "qqver", "sqdd", "qdef", " qdevice", "qdebug", " qdevelopment", "questdev", "Qdef", "wdevelopment", "questdiv", "qudebug", "qude", "iqdom", " qdiv", "sqdevelopment", "qdevelopment", "qde", "sqde", "qdiv", "Qver", " qDev", "iqdev", "Qdev", "qqdiv", "iqdef", "Qdiv", "wde"], "s": ["ps", "fs", "o", "sv", "rs", "v", "e", "cs", "ts", "si", "ss", "service", "ssl", "state", "sq", "sf", "sn", "g", "ks", "self", "os", "spec", "iss", "is", "c", "su", "ns", "p", "qs", "b", "sl", "f", "sr", "sb", "ses", "ms", "settings", "ls", "services", "S", "sk"], "vs": ["ps", "hs", "fs", "sv", "Vs", "gi", "rs", "vm", "v", "cs", "ov", "ds", "si", "ss", "vers", "vt", "gs", "bs", "ks", "fps", "ips", "vc", "os", "stats", "ns", "va", "lv", "vg", "sb", "ms", "VS", "vp", "ls", "vr", "services", "alls", "sk"]}}
{"project": "qemu", "commit_id": "7d6e771f49c36f4388798ce25bde1dede40cda74", "target": 0, "func": "static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n", "idx": 15879, "substitutes": {"dev": ["phy", "debug", "d", "di", "app", "ev", "cam", "der", "ve", "dom", " device", "data", "t", "v", "md", "DEV", "pub", "ds", "serial", "def", "conf", "die", "dc", "grad", "mod", "hw", "comment", "Dev", "self", "rad", "de", "gu", "ch", "sd", "sh", "development", "info", "device", "dd", "ver", "dm", "w", "diff", "conn", "driver", "devices", "pro", "ad"], "s": ["ps", "fs", "sync", "d", "us", "sv", "session", "o", "t", "v", "e", "cs", "u", "ts", "l", "server", "ds", "sys", "si", "ss", "ssl", "service", "m", "sp", "state", "sq", "gs", "sf", "a", "g", "self", "n", "os", "spec", "is", "side", "c", "http", "su", "args", "sg", "p", "ns", "b", "sl", "aws", "f", "sb", "ses", "js", "w", "r", "services", "ls", "S", "conf", "ops"], "bus": ["sync", "us", "o", "bug", "ass", "proxy", "front", "board", "data", "loop", "plug", "bc", "lo", "use", "cb", "base", "l", "serial", "db", "service", "book", "ride", "bridge", "config", "class", "Bus", "BUS", "block", "os", "boot", "io", "usb", "feed", "cache", "is", "x", "c", "http", "p", "lib", "device", "cat", "b", "plugin", "f", "port", "pass", "bis", "driver"], "i": ["d", "ie", "o", "di", "gi", "chi", "ini", "mi", "fi", "iu", "v", "multi", "li", "count", "e", "xi", "u", "mu", "l", "pi", "base", "abi", "uri", "si", "level", "y", "in", "ai", "ui", "m", "ti", "k", "key", "z", "eni", "n", "ci", "bi", "qi", "phi", "ip", "x", "oi", "hi", "info", "c", "p", "index", "ri", "b", "ni", "min", "zi", "j", "r", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "feced894fb6c474eb56daeb2b2d1f99bae87677f", "target": 0, "func": "static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n", "idx": 15883, "substitutes": {"obj": ["enc", "sync", "o", "tmp", "office", "data", "po", "br", "e", "fn", "orb", "obb", "cb", "Object", "ob", "object", "objects", "emb", "g", "bh", "self", "rb", "n", "lock", "os", "io", "nb", "ctx", "node", "so", "buff", "archive", "p", "Obj", "f", "src", "sb", "bo", "bj", "j", "bis", "img", "bm"], "filename": ["fp", "prefix", "binary", "required", "enc", "json", "lace", "kl", "files", "file", "ename", "original", "position", "initial", "Filename", "title", "txt", "data", "gender", "source", "fn", "message", "download", "package", "l", "length", "size", "fb", "password", "uri", "property", "username", "nil", "kn", "path", "token", "directory", "fd", "license", "url", "location", "method", "word", "maximum", "sheet", "sequence", "dll", "utf", "phrase", "provided", "description", "fil", "f", "name", "loader", "sound", "final", "brush", "subject", "folder"], "errp": ["nerpr", "lerlp", "lrps", "errps", "erlp", "errlp", "lrpr", "lerp", "erps", "cerp", "nerps", "errpr", "nerP", "erpr", "lrp", "cerP", "erP", "lrP", "cerps", "errP", "lerps", "erp", "nerp", "cerlp", "lerP"], "b": ["bd", "d", "o", "ba", "bf", "e", "bc", "be", "l", "fb", "ib", "wb", "B", "ob", "y", "db", "m", "bt", "bg", "a", "bs", "bh", "rb", "n", "boot", "nb", "usb", "c", "h", "p", "bb", "f", "mb", "sb", "ab", "gb", "xb", "r", "j", "bm"], "s": ["hs", "sync", "fs", "d", "o", "sv", "ins", "v", "e", "sa", "cs", "ts", "its", "l", "params", "ds", "sys", "si", "ss", "y", "ssl", "se", "service", "sp", "new", "gs", "sf", "sn", "bs", "g", "es", "self", "n", "os", "c", "su", "sg", "p", "ns", "qs", "sl", "aws", "f", "sb", "w", "ses", "js", "r", "ls", "services", "S"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPRMachineState *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    if (!spapr_phb_eeh_available(sphb)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = spapr_pci_find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15885, "substitutes": {"cpu": ["computer", "GPU", "proxy", "vm", "CPU", "process", "gpu", "processor", "nic", "cmp", "pid", "pool", "config", "pu", "proc", "linux", "ips", " CPU", "boot", "mem", "node", "cp", "cli", "vidia", "gp", "loader", "clock", "conn"], "spapr": ["scapstr", "scapsb", "spappr", "spaped", "scappr", "spapb", "spapsb", "Spapm", "scapspr", "scapsrs", "spapstr", "Spapd", "spappd", "Spapr", "spapeb", "spacd", "spapm", "scapb", "spacr", "scapr", "Spappr", "spapepr", "spappm", "spAPr", "spapd", "spippr", "spacb", "spapsrc", "scapsrc", "spaxtr", "spAPb", "spaperc", "Spapb", "scaprc", "spAPtr", "spipppr", "spappb", "spapsr", "spapsrs", "spipprs", "spaxr", "Spappb", "spapem", "scapsr", "spapers", "spipprc", "spaprs", "Spappm", "spaxb", "spacm", "scaprs", "spaptr", "Spappd", "scaptr", "spapspr", "spaprc", "spaper"], "token": ["prot", "auth", "ok", "match", "util", "random", "password", "serial", "timeout", "total", "callback", "reply", "response", "seq", "nat", "proc", "opt", "win", "init", "mac", "secret", "target", "flag", "call", "socket", "event", "conn"], "nargs": ["bflags", " nflags", "numargs", "nparams", "fparams", "ncargs", " nresult", "nresult", "numparams", "pret", "bret", "nArgs", "ncArgs", "pargs", "fArgs", "numresult", "ncparams", "presult", "pflags", "fresult", "ncresult", "nflags", "bresult", "numArgs", "fargs", "bargs"], "args": ["ids", "module", "bug", "options", "func", "Args", "amd", "data", "cs", "match", "grades", "result", "ras", "use", "cmd", "features", "conn", "params", "parts", "states", "res", "ig", "limits", "reply", "frame", "gs", "arms", "sec", "parse", "config", "linux", "arg", "boot", "spec", "details", "init", "bits", "is", "extra", "stats", "bytes", "active", "atts", "lines", "arr", "vals", "ait", "flags", "msg", "flag", "call", "asm", "argument", "py", "fields", "ret", "opens", "alls", "len"], "nret": ["ntret", "tret", "ntrets", "tRet", "numlen", "lret", " nRet", "numret", "nreturn", "Nlen", "nRet", "lrets", "numexit", "NRet", "Nexit", "treturn", "Nret", "lreturn", "numRet", "trets", " nexit", "nexit", "ntRet", " nlen", "nrets", "nlen", "ntreturn", "lRet"], "rets": ["expected", "aux", "uds", "fs", "urs", "ints", "archives", "tracks", "rs", "strings", "als", "verts", "fits", "nt", "results", "ras", "reads", "grades", "store", "fts", "ts", "its", "checks", "features", "outs", "errors", "nuts", "ails", "def", "rows", "res", "types", "acks", "uns", "vers", "reply", "nas", "seq", "proc", "reg", "dies", "ils", "details", "mem", "bits", " secrets", "secret", "bytes", "ats", "info", "tests", "ns", "lines", "uts", "vals", "flags", "RET", "utils", "groups", "fields", "ls", "opens", "ret", "runs", "alt", "roots"], "sphb": ["saphl", "sephl", "sophl", "smphb", "Saphl", "sephp", "ssPhab", "sPhr", "sPhp", "ssPhb", "ssPhl", "sophb", "Saphr", "sopha", "sephr", " sPhl", "sphab", "sphobj", "smphbs", "Sphr", " sghb", "saphb", " sghd", "ssphl", " sghr", "Saphb", "ssphb", "sPhobj", "saphr", "Sphbs", "sghd", "shpobj", "shpl", " spha", "smphr", "sphl", " sPhobj", " sPhb", "sPhd", "sghb", "sPha", "shpr", "ssPhr", " sphobj", " sphr", "sphd", "sphp", "sPhbs", " sphl", "Sphb", "sPhab", " sphp", "smphl", "saphbs", " sPha", "Saphbs", "sephab", "sphr", "sephd", " sghp", "sophobj", "shpab", "sPhb", "ssphr", " sphd", "sghp", "sphbs", "sPhl", "ssphab", "sghr", "spha", "sephb", "shpb", "Sphl", "shpa"], "pdev": ["cconn", "spdevice", " ppriv", "fppriv", "pprov", " pdiff", "rdev", "mdiff", "mdev", "spdev", "fdevice", "prconn", "fdev", "sppriv", "Pdef", "rpriv", "bapp", "fdiff", "ppriv", "pdiff", "Papp", " pdef", "fpdevice", "papp", "fpdiff", "spdiff", "fpdev", "fpriv", "rdiff", "cprov", "bpriv", "bdev", "Pdev", "mdevice", "prdev", "pdef", "bdef", "cdevice", "Ppriv", " papp", "pdevice", " pprov", "prprov", "mpriv", "rdevice", "cdev", "pconn", " pconn", "prdevice", " pdevice"], "addr": ["prefix", "address", "hop", "dr", "afi", "route", "amd", "edge", "data", "amp", "md", "mode", "adr", "pos", "rt", "cmd", "alias", "pad", "ann", "attr", "grad", "adder", "rr", "seq", "host", "config", "arg", "ac", "id", "opt", "ip", "mac", "ret", "layer", "type", "dd", "ack", "arr", "src", "name", "advert", "ace", "r", "loc", "arm", "alt", "ad"], "option": ["o", "options", "route", "connection", "position", "action", "mode", "adr", "op", "result", "image", "cho", "direction", "package", "offer", "project", "style", "pair", "resource", "timeout", "OP", "object", "tag", "error", "config", "Option", "method", "key", "block", "arg", "lock", "operation", "id", "opt", "version", "ip", "weight", "range", "other", "device", "type", "prop", "name", "pin", "or", "section", "value", "ption", "number", "function"], "buid": ["auid", "bakid", "guID", "bufids", "suID", "aukid", " bukid", "suids", "bgid", "buip", "bufID", " buids", "auids", "buId", "gukid", " buId", " buID", "baip", "guids", "auip", " buip", "appids", "baids", "bgids", "bgID", "guId", "suId", "baid", "bgkid", "buids", "bufId", "bufid", "bukid", "buID", "suid", "appId", "appid", "guid", "appID"]}}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 15890, "substitutes": {"s": ["ps", "hs", "fs", "sync", "d", "o", "sv", "rs", "south", "secondary", "cs", "u", "e", "ts", "ds", "states", "sys", "si", "ss", "ssl", "an", "m", "state", "sq", "gs", "plugins", "xs", "a", "es", "os", "spec", "stats", "is", "submit", "c", "args", "sg", "ns", "p", "qs", "status", "aws", "sets", "f", "sb", "ses", "ms", "js", "settings", "ls", "services", "sym", "S", "t", "less"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_adds_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZVC);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t/* Size can only be qi or hi.  */\n\n\tt_gen_sext(t0, cpu_R[dc->op1], size);\n\n\tcris_alu(dc, CC_OP_ADD,\n\n\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 15897, "substitutes": {"dc": ["enc", "ct", "d", "di", "dr", "dt", "exec", "draw", "cm", "tc", "sc", "nc", "bc", "cd", "cf", "pc", "enter", "cb", "cmd", "dat", "ds", "desc", "gc", "doc", "ec", "cc", "disc", "gui", "db", "ga", "uc", "fd", "cdn", "loc", "rc", "lc", "cca", "config", "ea", "RC", "df", "ac", "DC", "vc", "spec", "ctx", "fc", "context", "c", "input", " DC", "mac", "dm", "dp", "cr", "mc", "design", "std", "conn", "da", "jc"], "t0": ["it0", "t4", "T100", "it100", "tt1", "c8", "t20", " t00", "tii", " t2", "f1", "dt0", " t20", "T1", "c6", "t100", "t8", " tii", "tt4", " t5", "dt00", "pt00", "et100", "t1", "Tii", "pt0", "f4", "at0", "atii", "et0", " t8", "t000", "tt000", " t4", "t2", "dt5", "t5", "tt8", "T2", "f0", "et1", "c0", "T0", " t1", "pt20", "c1", "f000", " t6", "tt6", "it1", "at2", "pt5", "t00", "dt20", " t000", "t6", "tt0"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static void create_map(vorbis_context *vc, unsigned floor_number)\n\n{\n\n    vorbis_floor *floors = vc->floors;\n\n    vorbis_floor0 *vf;\n\n    int idx;\n\n    int blockflag, n;\n\n    int32_t *map;\n\n\n\n    for (blockflag = 0; blockflag < 2; ++blockflag) {\n\n        n = vc->blocksize[blockflag] / 2;\n\n        floors[floor_number].data.t0.map[blockflag] =\n\n            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel\n\n\n\n        map =  floors[floor_number].data.t0.map[blockflag];\n\n        vf  = &floors[floor_number].data.t0;\n\n\n\n        for (idx = 0; idx < n; ++idx) {\n\n            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *\n\n                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));\n\n            if (vf->bark_map_size-1 < map[idx])\n\n                map[idx] = vf->bark_map_size - 1;\n\n        }\n\n        map[n] = -1;\n\n        vf->map_size[blockflag] = n;\n\n    }\n\n\n\n    for (idx = 0; idx <= n; ++idx) {\n\n        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);\n\n    }\n\n}\n", "idx": 15906, "substitutes": {"vc": ["VC", "fp", "ct", "CV", "sv", "cu", "oc", "v", "ll", "cs", "nc", "bc", "util", "cf", "rt", "cb", "voc", "cit", "cc", "dc", "vt", "cdn", "hw", "lc", "rc", "wx", "ant", "ci", "vd", "nv", "ctx", "fc", "c", "vs", "uv", "bb", "ic", "ctrl", "lv", "circ", "vp", "vr", "fw", "vv", "cv"], "floor_number": ["flooramespan", " floor_span", "future_document", "floorfullnumber", "floor_token", "floor_document", "floor_source", "floor_zero", "floorallnumber", "flooringsource", "flooramemoney", "futureishdocument", "floorfullnumbered", " floor_numbered", "flooringfactor", "flooringnumber", "floor_no", "floorallzero", "floorishnr", "floor2span", "future_zero", "flooringnumbered", "floor_numbered", "flooramenumbered", "floorfullno", "floorishnumber", "futureishnumber", "flooritydocument", " floor_no", "floorxnumber", " floor_money", "floorxfactor", "floor_nr", "floorfulltoken", " floor_factor", "floor2numbered", "future_number", "futureishnr", "floorxsource", "futureishzero", "flooritynumber", "floor2number", "future_nr", "floor_factor", "floorishdocument", " floor_source", "flooramenumber", "floor2money", "floor_span", "floor_money", "floorxnumbered", "flooralldocument", "floorishzero", "floorallnr", "floorityzero", " floor_token", "flooritynr"], "floors": ["Floors", "colorers", "boor", "factons", "flovers", "boore", "colvers", "boors", "colores", "flops", "boores", " floops", "colors", "Floor", "factor", "floons", "flores", "floos", "Floores", "flore", "floore", "flvers", "factors", "flos", "feor", "fevers", "flors", "Floons", "color", "feors", "feores", "flor", "boons", "factores", " floorers", "floops", "boos", "florers", " floores", " floos", " floore", "Floops", "floorers", "floores"], "vf": ["vb", " vfe", "fcf", "avph", "vcf", " vph", " vsf", "avcf", "vcph", "svbf", "avn", " vrf", "vfen", "Vbf", "Vfs", " vfs", " vb", "tvfen", "svsf", "svf", "tvfc", "vph", " vbf", "vfs", "svfs", "vfc", "avfc", "vrf", " vfc", "evfs", "svfc", "tvrf", "tvfs", "evf", "avv", "vv", "svfe", "vprf", "evfc", " vv", "tvf", "fv", "vpb", "ff", "antfs", "Vf", "vsf", "vfe", "vcn", "vccf", "vpfc", "evfen", "avsf", "ffc", "evfe", " vn", "antfe", "vn", "vbf", "tvfe", "antf", "avc", " vfen", " vcf", "antcf", "svrf", "Vfe", "svc", "vpf", "svb", "evcf", "svcf", "tvcf", "evrf", "avf"], "idx": ["idco", "itxx", " idxb", "idn", "ipx", "indxx", "pidxs", "idxx", "indax", "pidX", "Idc", "ipc", "IdX", "idxb", "idcl", " idxc", "idex", "indxa", " idxs", "idax", "ideX", " idco", "itx", "indy", "itxs", " idp", "ideax", " idX", "itz", "vidy", "idy", "pidcl", "ridxs", "ipxx", "pidx", "idez", "idxc", "idc", "indcl", "vidx", "ridX", "indnex", " idnex", "indco", "Idxc", "Idxx", "idxs", "idp", " idxes", "indz", "ridz", "idxes", " idcl", "itxes", " idax", "Idy", "Idnex", "idnex", "ipy", "Idxa", "itxb", "ridy", "idX", " idz", " idy", "indx", "idxa", "itX", "idey", "vidco", "Idx", "Idp", "Idz", "vidxs", " idn", "pidn", "ity", "ridxb", "itxc", "indxs", "ridx", "itn", "indX", "Idxes", "indp", "itxa", "pidy", "indc", "idz"], "blockflag": ["bitinfo", "rowcount", "Blockflags", "blockaddr", "packflag", "rowguard", "errorcount", "packcode", "ackletter", "baninfo", "keyflag", "keycode", "blockcount", "blstyle", "blockstyle", "rowflags", "rowlag", "blockinfo", " blockguard", "Blockfield", " blockcode", "objectforce", " blockstyle", " blockforce", " blockaddr", " blockf", "packstyle", "ackbit", "blockletter", "Blockcount", " blocktag", "blockcode", " blockbit", "broadf", "bitstyle", "bitfeat", "packtag", " blocklag", " blockletter", "bltag", "Blockstyle", "bitflag", "blockf", "Blockflag", "banfeat", "wallcode", "blockflags", " blockinfo", "errorflag", " blockfield", "broadstyle", "keyaddr", "blockfield", "errorguard", "broadforce", "typestyle", "wallflags", "Blocklag", "ackflag", "banflag", "blockbit", "blockfeat", "errorbit", "rowletter", "rowflag", "blockguard", "objectflag", "blocktag", "typeflag", "rowbit", "objectstyle", "wallflag", " blockflags", "walladdr", "blocklag", "blcode", "typecount", "broadflag", " blockfeat", "ackflags", " blockcount", "blflag", "objectf", "keyflags", "typefield", "banstyle", "blockforce"], "n": ["en", "d", "ne", "o", "nn", "cn", "v", "nt", "e", "nc", "u", "fn", "network", "l", "conn", "size", "na", "y", "m", "mn", "nr", "sn", "dn", "num", "g", "un", "k", "z", "net", "nb", "node", "N", "x", "c", "i", "no", "ns", "p", "s", "b", "nu", "ni", "f", "name", "w", "j", "r", "nl", "t", "len", "number", "nan"], "map": ["module", "address", "list", "ge", "pos", "ap", "open", "group", "m", "Map", "meta", "parent", "scale", "up", "dict", "set", "scope", "msg", "master", "maps", "array", "move", "mp", "down", "record", "match", "use", "copy", "view", "block", "cache", "node", "max", "top", "mate", "arr", "rate", "buffer", "share", "MAP", "cover", "file", "data", "mask", "result", "model", "shape", "cap", "apper", "pre", "key", "where", "lock", "replace", "type", "table", "name", "code", "app", "comb", "pad", "space", "wave", "bridge", "config", "mx", "place", "mem", "change", "p", "co", "port", "pack"]}}
{"project": "qemu", "commit_id": "b6866fee58bc25b01485dcfcf8be44a915c5f573", "target": 0, "func": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,\n\n                                  VirtIOSCSIReq *req)\n\n{\n\n    assert(req->elem.out_num && req->elem.in_num);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    req->req.buf = req->elem.out_sg[0].iov_base;\n\n    req->resp.buf = req->elem.in_sg[0].iov_base;\n\n\n\n    if (req->elem.out_num > 1) {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],\n\n                               &req->elem.out_addr[1],\n\n                               req->elem.out_num - 1);\n\n    } else {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],\n\n                               &req->elem.in_addr[1],\n\n                               req->elem.in_num - 1);\n\n    }\n\n}\n", "idx": 15911, "substitutes": {"s": ["ps", "d", "o", "session", "v", "cs", "e", "u", "server", "ds", "sys", "si", "y", "ss", "ssl", "service", "sp", "gs", "a", "g", "es", "os", "spec", "dev", "c", "q", "i", "sg", "ns", "p", "qs", "f", "sb", "ses", "js", "w", "r", "services", "S", "t"], "vq": ["fiq", "gqq", "uQ", "zq", "uq", " viq", "pqs", "vqs", "pp", "gq", "jq", "cQ", "zque", "fQ", "pque", " vQ", "pQ", "viq", "fq", "fqq", "cq", "up", "jqueue", " vqq", "vqq", "uque", "cp", "gQ", "giq", "zqs", "pqueue", "vQ", "vque", "zqueue", "pq", "vqueue", "vp", "jqs", "cque", "jque"], "req": ["test", "hop", "exec", "war", "requ", "resp", "per", "cf", "cb", "query", "ec", "rf", "tar", "cook", "response", "seq", "ae", "spec", "cur", "hr", "ver", "cr", "msg", "diff", "conn", "client", "serv", "required", "cmd", "resource", "res", "respond", "sq", "pri", "str", "org", "input", "crit", "load", "dq", "prep", "ru", "ctr", "require", "task", "com", "data", "jp", "ry", "rd", "rh", "qt", "qa", "sem", "rr", "pr", "rec", "fr", "comm", "quest", "ce", "dev", "http", "q", "art", "urg", "ir", "get", "call", "ref", "comp", "wa", "app", "ev", "qq", "cgi", "fer", "pull", "desc", "ro", "def", "grad", "form", "url", "config", "proc", "sub", "tr", "rx", "ext", "core", "inc", "f", "err", "request", "r", "gr", "conf", "pro"]}}
{"project": "qemu", "commit_id": "5eb6d9e3ef1fac096ab5b3f5c14e1f4079dd7367", "target": 0, "func": "static void usb_uas_task(UASDevice *uas, uas_ui *ui)\n\n{\n\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n\n    uint64_t lun64 = be64_to_cpu(ui->task.lun);\n\n    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);\n\n    int lun = usb_uas_get_lun(lun64);\n\n    UASRequest *req;\n\n    uint16_t task_tag;\n\n\n\n    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));\n\n    if (req) {\n\n        goto overlapped_tag;\n\n    }\n\n\n\n    switch (ui->task.function) {\n\n    case UAS_TMF_ABORT_TASK:\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n        }\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n    }\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nbad_target:\n\n    /* FIXME: correct?  [see long comment in usb_uas_command()] */\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n\n}\n", "idx": 15924, "substitutes": {"uas": ["tuaks", "ruaks", "ruase", "luas", "ruacs", "uuain", "uast", "ruams", "huases", "uiams", "suas", "ruases", "puas", "ruasp", "cuasha", " uasha", "uraser", "uacs", "urach", "uuases", "uans", "uase", "luases", "huams", "nuasp", "nuase", "ruain", "huaser", "uras", "huacs", "tuacs", "uams", "urasa", "urases", "euase", "uiasp", "luast", "euas", "cuas", "uaks", "huas", "uuase", "uasse", "uasa", "luams", "huast", "uuaks", "uases", "cuasa", "suasse", "uiase", "huase", "cuacs", "luase", "uuas", " uasse", "suases", "uuacs", "luasp", " uams", "tuain", "uach", "uased", "uuased", "puams", "luach", "euams", "urans", "puase", "cuases", "nuas", "suased", "cuase", "urase", "uasha", "tuas", "euasha", "uuach", "uuasse", "luaser", "uasp", "uain", " uases", " uase", "huans", "huasa", " uased", "uias", "cuans", "ruas", "cuams", "nuams", "urast", "huasp", "uaser", "puasp"], "ui": ["us", "uni", "um", "menu", "iu", "umi", "cu", "li", "fu", "u", "util", "mu", "bu", "sci", "abi", "ei", "uri", "usa", "vi", "si", "lu", "ou", "ai", "gui", "hu", "uu", "api", "ilo", "ti", "pu", "eu", "uci", "ci", "io", "una", "usb", "bi", "ul", "i", "su", "ki", "cli", "isu", "gnu", "UI", "wei", "nu", "gru", "tu", "uda", "ii", "ku"], "dev": ["module", "own", "test", "priv", "exec", "link", "ov", "Dev", "reg", "self", "rad", "spec", "ver", "nov", "start", "diff", "conn", "driver", "var", "client", "serv", "debug", "flow", "temp", "nt", "pub", "cmd", "serial", "pack", "prom", "tag", "mod", "hw", "error", "block", "id", "cache", "push", "off", "dd", "di", "bug", "dom", "data", "user", "md", "plug", "DEV", "end", "develop", "dep", "root", "gh", "valid", "deb", "comment", "ch", "dem", "od", "name", "adv", "game", "sk", "code", "d", "app", "ev", "good", "dist", "br", "def", "grad", "de", "gu", "mem", "info", "p", "device", "vol", "err", "conf", "pro"], "req": ["test", "hop", "check", "exec", "raq", "war", "patch", "requ", "resp", "per", "pkg", "cb", "rf", "tar", "cook", "sec", "seq", "reg", "spec", "cur", "hr", "ver", "cr", "min", "ind", "conn", "required", "rw", "iq", "worker", "rt", "cmd", "res", "tag", "sq", "pri", "str", "rib", "org", "id", "cache", "ah", "push", "crit", "load", "dq", "ru", "ctr", "bug", "require", "task", "grab", "jp", "ry", "plug", "rh", "need", "qt", "cmp", "zip", "dep", "rr", "sem", "pr", "rec", "par", "fr", "quest", "http", "q", "order", "mr", "get", "call", "ref", "comp", "app", "ev", "qq", "rs", "fer", "pull", "desc", "ro", "def", "grad", "config", "proc", "tr", "rx", "ext", "loader", "err", "request", "r", "gr", "pro"], "task_tag": ["task2TAG", "task_id", "ask_bug", " task_length", " task_num", "task_target", "track_ag", " task_TAG", "taskencat", "tasklogtask", " task_cat", "taskxtag", "task_bit", "task_bug", " task_token", "task_task", "taskenreg", " task_task", "taskxcat", "trackentarget", "taskingbit", "task2length", "trackenreg", "track_reg", "tasklogtag", "taskingtoken", "task_cat", "track_tag", "task_TAG", "trackentag", "track_target", "task_length", " task_target", "taskingtag", "taskentarget", "task2token", "taskingbug", "ask_bit", "task_reg", "ask_token", "taskenag", "task_num", "task_ag", "taskentoken", "taskentag", "task_token", "trackenag", " task_id", "taskxtarget", "tasklogid", "ask_tag", "tasklognum", "task2tag", "taskxtoken"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n", "idx": 15929, "substitutes": {"qdev": ["Qdiff", " qdata", "qdevelop", " qde", "reqdist", "sqdevice", " qbus", "qdevice", "wdev", "qadevelop", "qdiff", "Qvar", "reqdie", "pdata", "qudev", "dqdata", "pdiv", "qudie", "dqde", "qadev", "kapp", "kdevice", "qudevice", " qpack", "qdem", "qudem", "qdist", " qdef", "dqdiv", "kdev", "sqdev", "qdie", "wdevice", "qabus", "qadevice", "qdef", " qdevice", "wbus", "kpack", "qvar", "reqdef", "dqdevice", "Qdef", "pdev", "qapp", "qude", " qdiv", "qdata", "sqpack", " qdem", "qde", " qdiff", " qapp", "dqvar", "reqvar", "qbus", "qdiv", "dqdev", "pdevice", "wdevelop", " qdevelop", "Qdev", " qdist", "qudist", " qdie", " qvar", "qpack", "sqapp", "reqdev", "reqdem", "quvar", "reqdiff"], "base": ["normal", "prefix", "fs", "bas", "data", "kit", "fab", "area", "builder", "db", "root", "api", "error", "config", "block", "iso", "io", "id", "init", "cache", "home", "extra", "bot", "http", "i", "stable", "lib", "cli", "b", "f", "name", "buffer", "Base", "build", "ref", "conf"], "dev": ["client", "debug", "fail", "d", "di", "ad", "app", "bug", "test", "ev", "ve", "priv", "temp", "data", "user", "v", "md", "dist", "project", "plug", "DEV", "result", "cd", "pub", "end", "wd", "conn", "model", "serial", "def", "pack", "dc", "die", "mod", "api", "valid", "comment", "dim", "error", "Dev", "config", "go", "de", "rad", "vc", "gu", "ch", "id", "init", "block", "sh", "slave", "development", "dem", "lib", "device", "dd", "ver", "w", "diff", "adv", "conf", "driver", "var", "sk"], "info": ["module", "di", "app", "bug", "fi", "data", "tech", "link", "user", "li", "source", "dist", " inf", "inner", "end", "desc", "pi", "si", "def", "service", "machine", "ui", "state", "api", "meta", "parse", "error", "config", "block", "io", "id", "init", "Info", "extra", "http", "cache", "i", "home", "hi", "family", "is", "type", "thin", "fo", "f", "gen", "name", "start", "INFO", "diff", "py", "ref", "conf", "inf", "show"], "bus": ["d", "us", "di", "bug", "hub", "proxy", "fi", "front", "board", "data", "local", "loop", "plug", "pos", "bc", "band", "use", "cop", "serial", "def", "service", "machine", "die", "comment", "unit", "bridge", "config", "host", "self", "BUS", "Bus", "lock", "block", "io", "boot", "usb", "feed", "cache", "bi", "http", "home", "lib", "device", "cat", "b", "plugin", "mount", "controller", "diff", "pass", "conf", "driver"]}}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_ori(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (type == TCG_TYPE_I32) {\n\n            /* All 32-bit ORs can be performed with 1 48-bit insn.  */\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* Look for negative values.  These are best to load with LGHI.  */\n\n    if (val < 0) {\n\n        if (val == (int16_t)val) {\n\n            return 0;\n\n        }\n\n        if (facilities & FACILITY_EXT_IMM) {\n\n            if (val == (int32_t)val) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15943, "substitutes": {"type": ["ty", "pe", "link", "op", "e", "base", "size", "model", "style", "y", "types", "object", "ype", "tag", "state", "by", "TYPE", "typ", "unit", "parent", "pre", "key", "class", "like", "block", "id", "is", "Type", "i", "info", "set", "p", "target", "col", "name", "call", "py", "value", "rule", "t", "var", "code"], "val": ["VAL", " value", "bl", "data", "split", "v", "bal", "ol", "eval", "count", "pt", "l", "sel", "base", "rel", "def", "alt", "slot", "fat", "aval", "el", "grad", "elt", "valid", "al", "str", "unit", "Val", "num", "pre", " Val", "vert", "key", "arg", "pol", "dev", "x", "ref", "vol", "lit", "ver", "sl", "vals", "cal", "il", "min", "pl", "pal", "ind", "value", "isal", "loc", "rule", "len", "ee"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_addq_EDI_T0(void)\n\n{\n\n    EDI = (EDI + T0);\n\n}\n", "idx": 15962, "substitutes": {}}
{"project": "qemu", "commit_id": "af08a58f0ca338eafee855921859a8c1ace0175b", "target": 0, "func": "static void hypercall_register_types(void)\n\n{\n\n    /* hcall-pft */\n\n    spapr_register_hypercall(H_ENTER, h_enter);\n\n    spapr_register_hypercall(H_REMOVE, h_remove);\n\n    spapr_register_hypercall(H_PROTECT, h_protect);\n\n    spapr_register_hypercall(H_READ, h_read);\n\n\n\n    /* hcall-bulk */\n\n    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);\n\n\n\n    /* hcall-dabr */\n\n    spapr_register_hypercall(H_SET_DABR, h_set_dabr);\n\n\n\n    /* hcall-splpar */\n\n    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);\n\n    spapr_register_hypercall(H_CEDE, h_cede);\n\n\n\n    /* processor register resource access h-calls */\n\n    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);\n\n    spapr_register_hypercall(H_SET_MODE, h_set_mode);\n\n\n\n    /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate\n\n     * here between the \"CI\" and the \"CACHE\" variants, they will use whatever\n\n     * mapping attributes qemu is using. When using KVM, the kernel will\n\n     * enforce the attributes more strongly\n\n     */\n\n    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);\n\n    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);\n\n    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);\n\n\n\n    /* qemu/KVM-PPC specific hcalls */\n\n    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);\n\n\n\n    /* ibm,client-architecture-support support */\n\n    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);\n\n}\n", "idx": 15965, "substitutes": {}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    BlockConf *conf = &s->conf.conf;\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int blk_size = conf->logical_block_size;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    /*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     */\n\n    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n", "idx": 15977, "substitutes": {"vdev": ["vrvalid", " vpu", "bprof", "krad", " vver", "svdev", "kgd", " vmod", "wdev", " vrad", "bdes", "vdiv", "vpack", "bgd", " vdevice", "hde", "hver", "vserial", "vpu", "ldd", "bver", "lprof", "wvalid", "bdevelopment", "vmod", "svdd", "bserial", " vdes", "vde", "nrad", "hdevice", "bmod", "hvalid", "lgd", "vdes", "hprof", "svdevice", "ndevice", "hdiv", "vdevelopment", "hdev", "hrad", "nvdev", "svgd", "vver", "vrdevice", "bdevice", "hpu", "vvalid", "vgd", "brad", "hdes", " vserial", "vprof", " vpack", "nconn", "fdev", " vdevelopment", "bdd", "wdevice", "bdiv", "fconn", "kpack", "bdev", "ndev", "svrad", " vconn", " vgd", "vdevice", "svpu", "vrad", "nvserial", "fdevice", "ldevice", "nvdevelopment", "nvmod", "ldev", "kdev", "vrdev", "bpack", "vrde", "frad", "vdd", "vconn", "wde"], "config": ["gate", "address", "fee", "ini", "fi", "exec", "data", "v", "cm", "param", "sc", "image", "con", "bc", "cfg", "cf", "def", "Config", "dc", "m", "sec", "rc", "proc", "sub", "Conf", "ci", "spec", "ctx", "init", "cache", "c", "info", "cl", "fig", "f", "pl", "ca", "settings", "conn", "inf"], "s": ["ps", "fs", "sync", "d", "serv", "o", "session", "us", "sites", "rs", "t", "v", "sc", "e", "cs", "con", "ts", "ds", "states", "sys", "si", "ions", "ss", "service", "ssl", "m", "an", "sq", "gs", "sf", "a", "bs", "g", "sub", "ks", "sup", "n", "sch", "os", "spec", "c", "h", "i", "sg", "ns", "p", "qs", "b", "sets", "f", "ses", "w", "js", "ls", "services", "sym", "S", "sum", "r", "sk"], "conf": ["client", "module", "cons", "app", "bug", "cz", "aff", "cn", "fi", "impl", "exec", "com", "global", "cm", "param", "sc", "cs", "con", "bc", "sum", "cfg", "cf", "cb", "pub", "def", "cc", "cmp", "comment", "lc", "host", "sub", "Conf", "self", "block", "lock", "ch", "spec", "ctx", "init", "cache", "dev", "c", "conv", "info", "cp", "cl", "core", "req", "vol", "cal", "ver", "co", "cli", "f", "cr", "ca", "confirmed", "fam", "sche", "cell", "ref", "conn", "inf", "css"], "blkcfg": ["blakconfig", "plkgz", "blkwcfg", "blqcgi", "bldgc", "blckcfg", "blkcmd", "plkdc", "blkgen", "blkcb", "blddc", "plbconfig", "blkwgz", "plckdc", "blkgc", "blickconfig", "blckscale", "blgconfig", "blechecfg", "plkcb", "blqconf", "plkscale", " blkgc", "blksconf", "blckcb", "blckconf", "BLqfg", "blakconf", "blskfg", " bldgc", "blcheini", "blksconfig", "blckgz", "blkconfig", "blckcmd", "bldcf", " blkfg", "BLkfg", "blijkfg", " bldcfg", "blkcgi", "bldcfg", "blkconn", "cldfg", "blkinit", "blakfg", "blchfg", "plbcfg", "plkinit", "blbfg", "plkcfg", "blckgen", "blkwconfig", "plkconfig", "blkscale", "blickcfg", "blchedefinition", "blginit", "blickfg", "plckcfg", "plckconfig", "blgcfg", " blqconn", "blqfg", "blqgz", "blijkconfig", "bldgate", "blckfg", "blkgate", "blworkinit", "blickcmd", "blekconfig", "blworkconfig", "blkegate", "plkconn", "plkconf", " bldcmd", "plbconf", "blqcmd", "plbcf", "blkconf", " blqcfg", "blchgc", "blckinit", "blekdefinition", "cldconfig", "blksconn", "plkgate", "blijkini", "blbconfig", "blkscfg", "plkfg", "BLkconf", "blkfg", "plckconn", "blecheini", "BLqconn", " blkconfig", "blijkdefinition", "blckdc", " bldfg", "blskcfg", "cldconn", "blckcgi", " blckcmd", "blskdc", "BLqconf", "blworkgen", "blcheconfig", " blqconfig", "blkargs", " blkcmd", "plckcf", "plckcb", "blckconn", "bldfg", "blkecb", "plkcf", "plckconf", "blqconn", "blkeconn", "bldconf", "blchecfg", "blkini", "blkcf", "blqcfg", "blckargs", "blekcfg", "plckinit", "plkgen", "plckgz", "blckconfig", "blskscale", "clkconfig", "plckgate", "blkdc", "plkargs", "bldcmd", "blckgc", "blckcf", "plckfg", "blkeargs", "bldconn", "blkgz", "blkdefinition", "blbconf", " blckfg", "blechedefinition", " bldconfig", "blkecfg", "plckgen", "BLkconn", "blskcmd", "blbcfg", "clkcfg", "plkcgi", "blggen", "blksfg", "blckgate", "plckcgi", "blekini", "plckscale", "blijkcgi", "blskconfig", "blqconfig", "bldscale", "blijkcfg", "blkscf", "bldconfig", "clkconn", " blkconn", "bldcb", " blckcfg", "plckargs", "blbconn", "clkfg", "blakcfg", "blchcfg", "BLkcfg", " blqfg", "blecheconfig", "blkeconfig", "blckdefinition", "blkwfg", "BLqcfg", "blworkcfg", "blchconfig", "cldcfg", "bldargs", " blckconfig", "blbcf", "blckini"], "capacity": ["large", "storage", "performance", "charge", "address", "alloc", "connection", "position", "flow", "content", "usage", "count", "volume", "bc", "network", "demand", "length", "size", "definition", "acity", "shape", "space", "cap", "cc", "dc", "limit", "pool", "largest", "scale", "lc", "maximum", "density", "n", "spec", "power", "growth", "cache", "c", "max", "memory", "p", "core", "instance", "acl", "buffer", "SIZE", "carry"]}}
{"project": "qemu", "commit_id": "aea14095ea91f792ee43ee52fe6032cd8cdd7190", "target": 0, "func": "static void decode_opc (CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        int l1 = gen_new_label();\n\n\n\n        MIPS_DEBUG(\"blikely condition (\" TARGET_FMT_lx \")\", ctx->pc + 4);\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            MIPS_DEBUG(\"dahi %s, %04x\", regnames[rs], imm);\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            MIPS_DEBUG(\"dati %s, %04x\", regnames[rs], imm);\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LWL: /* Load and stores */\n\n    case OPC_LWR:\n\n    case OPC_LL:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP1(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_MFHC1:\n\n            case OPC_MTHC1:\n\n                check_insn(ctx, ISA_MIPS32R2);\n\n            case OPC_MFC1:\n\n            case OPC_CFC1:\n\n            case OPC_MTC1:\n\n            case OPC_CTC1:\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case OPC_DMFC1:\n\n            case OPC_DMTC1:\n\n                check_insn(ctx, ISA_MIPS3);\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#endif\n\n            case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    /* OPC_BC1EQZ */\n\n                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                    rt, imm << 2);\n\n                } else {\n\n                    /* OPC_BC1ANY2 */\n\n                    check_cop1x(ctx);\n\n                    check_insn(ctx, ASE_MIPS3D);\n\n                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                }\n\n                break;\n\n            case OPC_BC1NEZ:\n\n                check_insn(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                rt, imm << 2);\n\n                break;\n\n            case OPC_BC1ANY4:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                /* fall through */\n\n            case OPC_BC1:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                break;\n\n            case OPC_PS_FMT:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            case OPC_S_FMT:\n\n            case OPC_D_FMT:\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n                break;\n\n            case OPC_W_FMT:\n\n            case OPC_L_FMT:\n\n            {\n\n                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    switch (r6_op) {\n\n                    case R6_OPC_CMP_AF_S:\n\n                    case R6_OPC_CMP_UN_S:\n\n                    case R6_OPC_CMP_EQ_S:\n\n                    case R6_OPC_CMP_UEQ_S:\n\n                    case R6_OPC_CMP_LT_S:\n\n                    case R6_OPC_CMP_ULT_S:\n\n                    case R6_OPC_CMP_LE_S:\n\n                    case R6_OPC_CMP_ULE_S:\n\n                    case R6_OPC_CMP_SAF_S:\n\n                    case R6_OPC_CMP_SUN_S:\n\n                    case R6_OPC_CMP_SEQ_S:\n\n                    case R6_OPC_CMP_SEUQ_S:\n\n                    case R6_OPC_CMP_SLT_S:\n\n                    case R6_OPC_CMP_SULT_S:\n\n                    case R6_OPC_CMP_SLE_S:\n\n                    case R6_OPC_CMP_SULE_S:\n\n                    case R6_OPC_CMP_OR_S:\n\n                    case R6_OPC_CMP_UNE_S:\n\n                    case R6_OPC_CMP_NE_S:\n\n                    case R6_OPC_CMP_SOR_S:\n\n                    case R6_OPC_CMP_SUNE_S:\n\n                    case R6_OPC_CMP_SNE_S:\n\n                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    case R6_OPC_CMP_AF_D:\n\n                    case R6_OPC_CMP_UN_D:\n\n                    case R6_OPC_CMP_EQ_D:\n\n                    case R6_OPC_CMP_UEQ_D:\n\n                    case R6_OPC_CMP_LT_D:\n\n                    case R6_OPC_CMP_ULT_D:\n\n                    case R6_OPC_CMP_LE_D:\n\n                    case R6_OPC_CMP_ULE_D:\n\n                    case R6_OPC_CMP_SAF_D:\n\n                    case R6_OPC_CMP_SUN_D:\n\n                    case R6_OPC_CMP_SEQ_D:\n\n                    case R6_OPC_CMP_SEUQ_D:\n\n                    case R6_OPC_CMP_SLT_D:\n\n                    case R6_OPC_CMP_SULT_D:\n\n                    case R6_OPC_CMP_SLE_D:\n\n                    case R6_OPC_CMP_SULE_D:\n\n                    case R6_OPC_CMP_OR_D:\n\n                    case R6_OPC_CMP_UNE_D:\n\n                    case R6_OPC_CMP_NE_D:\n\n                    case R6_OPC_CMP_SOR_D:\n\n                    case R6_OPC_CMP_SUNE_D:\n\n                    case R6_OPC_CMP_SNE_D:\n\n                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    default:\n\n                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                                                       (imm >> 8) & 0x7);\n\n                        break;\n\n                    }\n\n                } else {\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                               (imm >> 8) & 0x7);\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                MIPS_INVAL(\"cp1\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_LUXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n            case OPC_SUXC1:\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 15980, "substitutes": {"env": ["prefix", "enc", "en", "et", "environment", "ev", "priv", "fi", "exec", "exc", "vm", "txt", "erv", "e", "obj", "pkg", "util", "oa", "conn", "qt", "qa", "kn", "pec", "ec", "db", "queue", "vt", "inst", "ep", "bg", "hw", "config", "proc", "ea", "eu", "np", "ce", "init", "dev", "context", "vs", "code", "dict", "viron", "info", "req", "scope", "cli", "cal", "esi", "tx", "ocr", "loader", "que", "err", "console", "buf", "loc", "conf", "Environment", "cv"], "ctx": ["fp", "cz", "cn", "cu", "exec", "sc", "obj", "pkg", "cf", "sys", "pec", "cc", "chan", "np", "scope", "cy", "kw", "src", "conn", "cms", "prefix", "sync", "client", "ct", "cpp", "txt", "tc", "cs", "pc", "cmd", "scl", "gpu", "anon", "na", "sq", "hw", "lc", "cus", "context", "c", "tx", "ca", "wcs", "cas", "jp", "bc", "fn", "voc", "qa", "anc", "wp", "Context", "cmp", "cases", "xp", "rc", "wx", "ck", " context", "bp", "conv", "std", "qq", "cm", "nc", "util", "sci", "kb", "grad", "config", "cca", "linux", "vc", "ci", "fc", "cp", "history", "cli", "cl", "ctrl", "kt", "acl", "utils", "console", "xc", "loc", "fw", "support", "cv"], "offset": ["fp", "prefix", "hop", "alloc", "pos", "oid", "ff", "ffff", "base", "align", "seq", "origin", "ptr", "error", "num", "skip", "ip", "no", "top", "src", "Offset", "bit", "loc", "len", "rot"], "rs": ["ps", "hs", "hop", "dr", "ins", "ars", "agg", "cs", "ds", "rows", "res", "ims", " RS", "xs", "rr", "rc", "pps", "pr", "reg", "RC", "ips", "rb", "os", "vs", "rx", "ns", "RS", "aps", "rep", "ms", "Rs", "rl", "r", "rg", "ls", "ops"], "rt": ["ru", "dr", "nt", "ur", "br", "adr", "pt", "rh", "rel", "rob", "rit", "rf", "attr", "rr", "ptr", "apt", "rc", "pr", "tr", "rb", "NT", "rec", "mt", "rm", "rx", "wt", "rat", "irt", "cat", "sr", "err", "rl", "rn", "r", "RT", "ann", "rot"], "rd": ["ru", "d", "bd", "rw", "dr", "rid", "md", "adr", "ld", "rh", "ds", "rob", "rf", "dc", "attr", "lr", "rr", "RD", "ra", "rc", "nas", "rb", "rss", "hr", "rm", "rx", "addr", "ri", "dd", "dra", "as", "lda", "rl", "rn", "r", "rg", "da"], "sa": ["ba", "ain", "ras", "sm", "ds", "si", "ans", "na", "ity", "ssl", "ga", "Sa", "sq", "ta", "sf", "ra", "sta", "sam", "a", "da", "sha", "pa", "sg", "s", "ama", "ma", "va", "sr", "sb", "as", "ca", "au", "asm", "aa", "asa", "SA", "ann", "asi"], "op": ["Op", "o", "omp", "oper", "app", "hop", "upp", "oc", "opp", "ipp", "ipop", "pos", "oid", "cop", "expr", "pp", "OP", "post", "cmp", "sp", "mod", "api", "vert", "operator", "ant", "pop", "opt", "pol", "ip", " Op", "set", "off", "p", "type", "cat", "ic", "prop", "oop", "option", "bit", "loc", "opus", "comp", "ops", "rot"], "op1": ["opt3", "OP0", " op3", "hop1", "OPn", "opt2", "op0", "oper2", "OP2", "opt1", "opername", "oper1", " op0", "optname", "hop3", "op3", "opn", "hop2", "opname", "OP1", " opname", "optn", "opt0", " opn"], "imm": ["fm", "serv", "bm", "mm", "aim", "lig", "imp", "mi", "umi", "lif", "sim", "im", "cm", "gm", "sm", "fl", "ism", "mun", "pm", "Imm", "umm", "si", "attr", "tm", "mit", "lamm", "orm", "dim", "lim", "mitt", "cond", "mem", "mt", "rm", "imi", "amm", "imet", "ann"]}}
{"project": "qemu", "commit_id": "8f3a73bc57ea83e5b3930d14fc596ea51859987a", "target": 0, "func": "bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n", "idx": 15985, "substitutes": {"blk": ["relk", "belk", "belq", " blke", "flb", "blq", "belks", "blck", "blunk", "belb", "blastk", "clb", "plck", "plkt", " blq", "plk", "slb", " blkt", "relck", "BLke", "blb", "BLk", "slk", "blkt", "flks", "flkt", "blsk", "relsk", "slks", "BLks", " blb", " blck", "BLb", "clck", "flk", "plb", "BLq", "slke", " blsk", "plks", "blastck", " blunk", "blke", " blks", "clsk", "blks", "blastsk", "clk", "plsk", "relunk", "blastunk"]}}
{"project": "FFmpeg", "commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "target": 1, "func": "static av_cold int tdsc_init(AVCodecContext *avctx)\n\n{\n\n    TDSCContext *ctx = avctx->priv_data;\n\n    const AVCodec *codec;\n\n    int ret;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n\n\n    /* These needs to be set to estimate buffer and frame size */\n\n    if (!(avctx->width && avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Video size not set.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* This value should be large enough for a RAW-only frame plus headers */\n\n    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);\n\n    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Allocate reference and JPEG frame */\n\n    ctx->refframe = av_frame_alloc();\n\n    ctx->jpgframe = av_frame_alloc();\n\n    if (!ctx->refframe || !ctx->jpgframe)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* Prepare everything needed for JPEG decoding */\n\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n\n    if (!codec)\n\n        return AVERROR_BUG;\n\n    ctx->jpeg_avctx = avcodec_alloc_context3(codec);\n\n    if (!ctx->jpeg_avctx)\n\n        return AVERROR(ENOMEM);\n\n    ctx->jpeg_avctx->flags = avctx->flags;\n\n    ctx->jpeg_avctx->flags2 = avctx->flags2;\n\n    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;\n\n    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;\n\n    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Set the output pixel format on the reference frame */\n\n    ctx->refframe->format = avctx->pix_fmt;\n\n\n\n    return 0;\n\n}\n", "idx": 15987, "substitutes": {"avctx": ["afconfig", "aveconfig", "ajwcs", "varcas", "avercmp", "auctx", "avkb", "varcci", "ajcu", "verctx", "avecas", "avcci", "vertx", "afctx", "avercontext", "afcas", "avtx", " avhw", "auwcs", "afcmd", "avercmd", "ajctx", "AVconn", "vercmp", "afcontext", "afca", "AVcmp", "varctx", "navctx", "avectx", "varcu", "avalwcs", " avca", "avecci", "aukw", "AVhw", "AVctx", "airctx", "navkb", "ajcas", " avcas", "AVcmd", "avecmp", "varcontext", "avhw", "afkb", "aucpu", " avcontext", "ajcv", "aircas", "avalcpu", "AVkb", "avkw", "aircontext", "afhw", "avalkw", "avcu", "afconn", "navconn", "afcmp", "aircmp", "aftx", "AVconfig", "afcu", "AVtx", "navcontext", "avconn", " avcmp", "AVcas", "avcmp", "avalctx", "avcmd", "averctx", "AVcontext", "avcpu", "varconn", "varcmp", "avconfig", "aveconn", "avecu", "ajkw", "avca", "ajcpu", "avwcs", "avehw", "varcv", "avcv", "aveca", "afcci", "vercontext", "avcas", "avecontext", "avecv", "avcontext"], "ctx": ["client", "aux", "sync", "cam", "alloc", "connection", "cu", "cn", "exec", "git", "data", "cm", "tc", "cs", "nc", "bc", "pkg", "sci", "cf", "pc", "cmd", "cb", "cfg", "kb", "sys", "qa", "anc", "gc", "wp", "Context", "cc", "cmp", "uc", "cdn", "hw", "lc", "config", "cca", "wx", "ck", "cus", "vc", "ci", "np", "fc", "context", "c", "conv", "cp", "cli", "component", "cat", "coll", "kw", "ctrl", "tx", "co", "css", "ca", "wcs", "xc", "loc", "fw", "conn", "cms", "cas", "cv"], "codec": ["cmdect", "codenc", "openc", "odac", "preduc", " codect", "predec", "Codac", "codeenc", "Codesc", " codac", "codeect", "coduc", "coddec", "opc", " codc", "cmdcode", "codecode", "predesc", "codc", "odc", "dbdec", " codek", "predac", "codect", " codenc", "cdec", "codeec", " codcode", "codesc", " codesc", "odep", "odec", "odesc", "codeus", "opec", " codep", "codek", "cmdenc", "codep", " coddec", "odenc", "cedec", "cduc", "Codec", "cdesc", "dbek", "dbeus", " codeus", "codac", "opep", "ceddec", "dbec", "cedek", "cdac", "cmdec", "codcode", "cedeus", " coduc", "Codenc"], "ret": ["gt", "success", "pat", "val", "rf", "det", "reg", "rb", "rev", " pat", "aid", "sb", "flag", " reply", "back", "alt", " arg", "len", "en", "fin", "all", "nt", "bf", "ur", "rt", "lt", "res", "pet", "str", "error", "num", "last", "arg", " fun", "mt", "off", "cat", "red", "pass", "Ret", "et", " len", " resp", "ft", "iter", "result", "feat", "end", "att", " alt", "fun", "usr", "rets", "art", "lit", "run", "re", "out", "ard", "bit", "let", "std", "ref", "code", "fail", "pt", "def", " success", "reply", "url", " result", "RET", "err", "r"]}}
{"project": "qemu", "commit_id": "3010460fb99776bdf0a8b170555f2ab076382f9c", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999, "substitutes": {"cpu": ["uno", "module", "chip", "cn", "cu", "pkg", "cf", "hu", "uu", "ilo", "lb", "hp", "pu", "fen", "np", "boot", "mac", "pty", "component", "instance", "lua", "auc", "conn", "prefix", "performance", "cpp", "image", "consumer", "worker", "pc", "gpu", "processor", "bench", "gc", "queue", "prem", "pool", "lc", "eni", " CPU", "cache", "node", "c", "rpm", "pai", "gru", "computer", "vm", "CPU", "cfg", "nic", "cmp", "runner", "program", "profile", "ck", "fps", "uci", "home", "roc", "que", "GPU", "cm", "nc", "process", "intel", "fork", "config", "proc", "px", "linux", "kernel", "host", "ctx", "colo", "fc", "product", "cp", "core", "cli", "device", "python", "utils", "loader", "console", "clock", "platform", "css"], "x86_cpu": ["xea_CPU", "x86_conn", "x54_cpu", "xea_cpu", "x54_CPU", "x54_conn", "x86Jcpu", "xea_gpu", "x54_gpu", "x86_processor", "xea_processor", "x86_gpu", "x86JCPU", "x86Jprocessor", "x86Jgpu", "x86_CPU"], "env": ["estate", "enc", "en", "ne", "environment", "file", "ev", "esp", "priv", "exc", "global", "inet", "e", "worker", "cfg", "fg", "skin", "style", "path", "eng", "ec", "db", "conf", "gui", "dep", "el", "api", "ep", "export", "config", "profile", "ea", "eu", "net", "exe", "fen", "eni", "np", "opt", "properties", " environment", "cache", "dev", "context", "extra", "args", "egg", "ext", "cli", "scope", "ex", "console", "agent", "err", "enable", "esc", "equ", "conn", "stack", "Environment"]}}
{"project": "FFmpeg", "commit_id": "332f9ac4e31ce5e6d0c42ac9e0229d7d1b2b4d60", "target": 0, "func": "int intel_h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format;\n\n\n\n    /* picture header */\n\n    if (get_bits_long(&s->gb, 22) != 0x20) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n\n        return -1;\n\n    }\n\n    s->picture_number = get_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n\n        return -1;\t/* marker */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n\n        return -1;\t/* h263 id */\n\n    }\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n    if (format != 7) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Intel H263 free format not supported\\n\");\n\n        return -1;\n\n    }\n\n    s->h263_plus = 0;\n\n\n\n    s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n    \n\n    s->unrestricted_mv = get_bits1(&s->gb); \n\n    s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"SAC not supported\\n\");\n\n        return -1;\t/* SAC: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        s->obmc= 1;\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Advanced Prediction Mode not supported\\n\");\n\n//        return -1;\t/* advanced prediction mode: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"PB frame mode no supported\\n\");\n\n        return -1;\t/* PB frame mode */\n\n    }\n\n\n\n    /* skip unknown header garbage */\n\n    skip_bits(&s->gb, 41);\n\n\n\n    s->qscale = get_bits(&s->gb, 5);\n\n    skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n\n\n    s->y_dc_scale_table=\n\n    s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n\n\n    return 0;\n\n}\n", "idx": 16020, "substitutes": {"s": ["session", "site", "v", "u", "ts", "its", "states", "sys", "si", "in", "m", "plugins", "xs", "self", "n", "spec", "i", "h", "set", "qs", "as", "js", "services", "t", "native", "ps", "fs", "o", "ins", "cs", "e", "parts", "ss", "y", "ssl", "new", "sq", "gs", "sf", "a", "is", "sg", "ns", "settings", "us", "data", "l", "ds", "service", "this", "stats", "http", "ses", "ms", "sym", "S", "ops", "comments", "d", "rs", "full", "g", "es", "ks", "os", "side", "args", "su", "p", "b", "sets", "f", "ls", "r", "conf"], "format": ["fp", "prefix", "quality", "et", "gap", "frequency", "language", "position", "filter", "data", "mode", "magic", "act", "fn", "feat", "package", "MAT", "length", "base", "size", "style", "pi", "qt", " fmt", "transform", "lat", "zip", "offset", "fd", "form", "frame", "unit", "scale", "nat", "method", "ant", "flat", "version", "feed", "stage", "ats", "layout", "type", "cat", " formats", "f", "name", "template", "category", "Format", "at", "t", "len", "function"]}}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n", "idx": 16047, "substitutes": {"bs": ["ps", "fs", "sync", "ins", "bl", "bas", "rs", "cs", "bc", "obj", "bu", "cb", "fb", "base", "outs", "ds", "bes", "abi", "blocks", "ss", "bos", "bt", "BS", "gs", "lb", "plugins", "obs", "ubs", "rb", "fps", "os", "iss", "bi", "bits", "vs", "bytes", "ns", "s", "bps", "b", "sb", "js", "eb", "las", "abc", "banks", "ls", "lbs", "bis", "bid", "pb", "css"], "offset": ["fp", "prefix", "part", "et", "o", "address", "shift", "position", "initial", "data", "reset", "attribute", "count", "pos", "image", "length", "base", "size", "area", "online", "align", "timeout", "slot", "root", "padding", "phase", "seq", "ptr", "error", "config", "location", "operation", "boot", "pointer", "addr", "reference", "set", "off", "bytes", "index", "layer", "type", "ref", "order", "start", "port", "absolute", "Offset", "loc", "bound"], "buf1": ["bagone", " bufone", "bag1", " bufed", "bufferone", "buf2", "buffername", "buffer2", "seq2", " buf2", "seqone", "buff1", "bagname", "buff2", "bufone", "buffer1", "bufname", "bag2", "bufed", " bufname", "seqed", "seq1", "buffname", "buffered"], "count1": ["part2", "Count1", "sum1", "count6", " count6", "condone", "condOne", "baseone", "cacheone", "CountOne", "countOne", " count8", " count2", "sumone", "length2", "length1", "cache1", "lengthOne", "cond1", "base8", "countone", "part1", "sum8", "cache2", "part6", "Count6", "lengthone", "cond2", " countOne", "base1", "partOne", "count8", " countone", "count2", "Count2"], "drv": ["Drp", "drib", "DRf", " drp", "irtvr", " drV", "hrf", "drvr", "hrv", "DRc", "Drf", "hrb", "Drv", "drV", "irtb", "hrvr", " drvr", "srv", " drc", "drivr", "drif", "drp", "DRb", "hrV", "DRV", " drb", "DrV", "irtv", "Drvr", "Drb", " drf", "srf", "drc", "DRp", "src", "irtf", "drf", "drb", "DRv", "driv", "srV"]}}
{"project": "qemu", "commit_id": "ac125d993b461d4dee4d6df4d93ac3f2eb959d1d", "target": 1, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 16057, "substitutes": {"ctx": ["fp", "client", "sync", "fi", "exec", "cm", "tc", "sc", "cs", "bc", "pkg", "sci", "cf", "kb", "gc", "anc", "Context", "cmp", "hw", "lc", "config", "rc", "cca", "cache", "context", "c", "conv", "cp", "window", "cli", "scope", "coll", "ctrl", "tx", "ca", "gb", "xc", "loc", "fw", "conn", "driver", "cas", "cv"], "fs_path": ["fs_project", "fsblockproject", "fs67case", "fsblockcase", "fs_ath", " fs_ath", "gs67case", "gs_case", "fs_case", "gs_location", "gs67path", "fs67project", " fs_node", "fs_node", "fs_name", "fsblocklocation", "fsblockpath", "gs_project", "fs67path", " fs_name", "gs_path", "gs67project", "fs_location", "gs67location", "fs67location"], "size": ["large", "sync", "en", "address", "izes", "fee", "shift", "Size", "empty", "data", "e", "end", "length", "timeout", "offset", "ise", "form", "str", "sn", "sec", "small", "izer", "g", "scale", "six", "complete", "max", "args", "bytes", "name", "grow", "SIZE", "esc", "any", "ize", "len", "from", "code"], "buffer": ["binary", "fp", "prefix", "batch", "iter", "file", "FFER", "seed", "data", "texture", "reader", "source", "count", "result", "message", "base", "length", "output", "bin", "resource", "writer", "header", "border", "uffer", "queue", "slice", "pool", "response", "comment", "ptr", "url", "rb", "block", "feed", "buff", "cache", "context", "read", "input", "pointer", "window", "reference", "Buffer", "b", "f", "port", "transfer", "buf", "ref", "code"], "ret": ["done", "part", "gt", "iter", "ft", " Ret", "success", "data", "nt", "bf", "after", "count", "match", "result", "obj", "rt", "base", "val", "def", "offset", "limit", "reply", "len", "str", "fun", "reg", "rets", "replace", "mem", "read", "complete", "no", "info", "ext", "status", "active", "lit", "re", "RET", "flag", "get", "final", "bit", "pass", "xt", "ref", "alt", "Ret"], "path": ["enc", "content", "Path", "data", "raw", "txt", "image", "dir", "rh", "pattern", "base", "length", "area", "builder", "space", "anc", "root", "url", "parent", "location", "key", "self", "node", "cache", "context", "c", "pointer", "clean", "p", "ath", "name", "port", "loader", "buf", "entry", "text", "loc", "folder"]}}
{"project": "qemu", "commit_id": "8ba2aae32c40f544def6be7ae82be9bcb781e01d", "target": 0, "func": "void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n", "idx": 16068, "substitutes": {"uu": ["hum", "ru", "zero", "uni", "universal", "cu", "UU", "uf", "empty", "du", "acc", "user", "iq", "uh", "u", "bu", "ubuntu", "ucl", "unique", "username", "usa", "lu", "ou", "uid", "uc", "fff", "iii", "uy", "valid", "seq", "mult", "num", "up", "eu", "un", "uum", "ull", "gu", "una", "ucc", "utf", "UID", "ul", "su", "input", "uv", "kk", "ug", " u", "unc", "flu", "tu", "uint", "gb", "buf", "U", "vv", "pack", "null", "oa"], "out": ["prefix", "OUT", "temp", "data", "down", "v", "user", "Out", "outs", "output", "base", "write", "pad", "in", "doc", "m", "dot", "this", "str", "pool", "error", "parent", "up", "self", "point", "key", "ac", "word", "c", "input", "line", "dump", "escape", "ex", "b", "inc", "name", "again", "w", "buffer", "err", "at", "conn", "array", "code"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n", "idx": 16083, "substitutes": {"opaque": ["ospaque", "opasma", "infaque", "opaques", " oponymous", "oponymous", "obacity", "osponymous", "obaques", "infonymous", "operaques", "opque", "operaque", "infasma", "obaque", "OPque", "obque", "opacity", "operque", " opasma", "ospasma", "operacity", "OPaques", "OPaque", "OPacity"], "s": ["sync", "o", "session", "send", "rs", "south", "secondary", "e", "sa", "u", "server", "ds", "states", "sys", "si", "ss", "an", "se", "m", "ssl", "service", "state", "sq", "new", "sf", "sec", "a", "g", "es", "self", "n", "spec", "is", "c", "http", "su", "p", "status", "ns", "b", "sl", "sb", "sie", "ses", "stat", "r", "services", "sym", "S", "socket", "ops"]}}
{"project": "qemu", "commit_id": "75f27498220e6ff6f78bf08fbe2cc662ec76ba89", "target": 0, "func": "void acpi_memory_unplug_cb(MemHotplugState *mem_st,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    /* nvdimm device hot unplug is not supported yet. */\n\n    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));\n\n    mdev->is_enabled = false;\n\n    mdev->dimm = NULL;\n\n}\n", "idx": 16089, "substitutes": {"mem_st": ["mem1start", "mem_start", "mem1ST", "mem_sta", "mem_inst", "mem_fr", "mem1st", " mem_inst", "mem_ST", "mem1sta", " mem_start", " mem_fr", " mem_ST", " mem_sta"], "dev": [" dw", "debug", "d", "bd", "bug", "ev", "der", "priv", " device", "data", "user", "md", "pos", "DEV", "obj", "wd", "conn", "serial", "def", "prom", "grad", "mod", "valid", "comment", "error", "Dev", "proc", "rad", "de", "fr", "gu", "spec", "mem", "sd", "development", "dem", "info", " def", "device", "od", "sk", "ver", "w", "diff", "adv", " sd", "err", "gd", "conf", "var", "ad"], "errp": [" errfp", "errpc", " errr", " errf", "errr", "errorr", "erf", "errf", "erpc", " errpc", "errfp", "errorP", "errorf", "errorpc", " errP", "erP", "erfp", "errorp", "errP", "err", "erp", "errorfp"], "mdev": ["fmdd", "pdi", " mrad", "mrad", "mvalid", "amvalid", "ndevice", "nev", "pdiv", " mtr", "fmdev", " mver", "amdev", "amdevice", "mev", " mvalid", "nvalid", "dmdevice", " mdi", "fmev", " mdiv", "dmdiv", "maddev", "ptr", "pev", "amtr", "pdev", "ndi", "ndev", "mdevice", "mver", " mev", " mdevice", "mtr", "madev", "mdd", "dmdev", "amver", "madrad", "mdi", "mdiv", "pdevice", "prad", "amdiv", "fmdevice", " mdd", "dmver", "pvalid", "ndd", "maddiv"]}}
{"project": "qemu", "commit_id": "a7824a886ed50eb4fe3c6fcd6afd8814a6973583", "target": 0, "func": "alloc_f(int argc, char **argv)\n\n{\n\n\tint64_t offset;\n\n\tint nb_sectors;\n\n\tchar s1[64];\n\n\tint num;\n\n\tint ret;\n\n\tconst char *retstr;\n\n\n\n\toffset = cvtnum(argv[1]);\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (argc == 3)\n\n\t\tnb_sectors = cvtnum(argv[2]);\n\n\telse\n\n\t\tnb_sectors = 1;\n\n\n\n\tret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n\n\n\n\tcvtstr(offset, s1, sizeof(s1));\n\n\n\n\tretstr = ret ? \"allocated\" : \"not allocated\";\n\n\tif (nb_sectors == 1)\n\n\t\tprintf(\"sector %s at offset %s\\n\", retstr, s1);\n\n\telse\n\n\t\tprintf(\"%d/%d sectors %s at offset %s\\n\",\n\n\t\t\tnum, nb_sectors, retstr, s1);\n\n\treturn 0;\n\n}\n", "idx": 16090, "substitutes": {"argv": ["argumentv", " argvals", "passu", "tagc", "argu", "argvals", "argumentc", "tagu", "Argc", "argumentp", "Argu", "passp", "Argp", "passv", "argc", "tagv", "axv", "passc", "Argv", "axc", " argp", "axvals", " argu", "axp", " argc", "argp", "tagp", "argumentvals"], "offset": ["fp", "prefix", "part", "et", "gap", "o", "address", "append", "olerance", "alloc", "number", "af", "fee", "shift", "position", "seed", "reset", "data", "count", "pos", "sum", "end", "length", "base", "size", "align", "delay", "annot", "timeout", "slot", "uple", "alias", "padding", "limit", "slice", "ptr", "error", "seq", "config", "url", "location", "origin", "skip", "stop", "pointer", "addr", "set", "off", "index", "type", "range", "missing", "layout", "start", "acl", "buffer", "Offset", "alpha", "loc", "ref", "len", "array", "elta", "rot"], "nb_sectors": ["nb2SEgments", "nb_sections", "nb__sector", "nb2SEctors", "nb_sercs", "nb_vections", "nb_veivers", "nb__sectors", "nb2sections", "nb_secctors", "nb_Sectors", "nb_serarers", "nb_segments", "nb_vectors", "nb_sgments", "nb_veapters", "nb__SEctor", "nb_secs", "nb_secctor", "nb_partctor", "nb_speccs", "nb_seors", "nb2SEctor", "nb_partivers", "nb_Sevec", "nb_vector", "nb_serapters", "nb2SEctions", "nb_servec", "nb_seivers", "nb_SEors", "nb_sersections", "nb_SEivers", "nb_serlements", "nb_secsections", "nb_sctions", "nb_vesections", "nb_secctions", "nb_SEctions", "nb_desvec", "nb_vegments", "nb__seivers", "nb_sctors", "nb_sesections", "nb_sevec", "nb_secgments", "nb_seapters", "nb_sergments", "nb2sectors", "nb_secapters", "nb_scs", "nb2sector", "nb_selements", "nb_partors", "nb_specctions", "nb_veors", "nb_SEgments", "nb_desctors", "nb_seccs", "nb_specctors", "nb_searers", "nb_serctions", "nb_SEcs", "nb_serctors", "nb_Searers", "nb_desctions", "nb_seclements", "nb__SEctors", "nb_Sections", "nb_desarers", "nb__SEors", "nb_SEctors", "nb__seors", "nb_partctors", "nb_speclements", "nb__SEivers", "nb2segments", "nb_sector", "nb_SEctor"], "s1": ["fp", " s0", "ses1", "f2", "f1", "ps1", "ps5", " s5", "pp", "pone", "p0", "p5", "ps0", "sp", "s2", " s2", "p1", " sp", "f0", "psp", "sesone", "s5", "s0", " sone", "p2", "ses2", "sone"], "num": ["en", "uni", "um", "nn", "umi", "temp", "split", "nt", "con", "result", "fn", "util", "sum", "end", "bin", "loc", "Num", "NUM", "valid", "nr", "unit", "un", "n", "np", "id", "nb", "init", "node", "no", "ul", "info", "off", "index", "on", "begin", "nu", "f", "unc", "name", "nm", "old", "ref", "len", "number"], "ret": ["done", "et", "en", " len", "iter", "fin", "success", "nt", "bf", "repl", "match", "result", "pub", "rt", "att", " alt", " mem", "val", "def", "res", "det", "fit", " fut", "len", "valid", "reply", "pret", "fun", "rc", "reg", "tr", "rets", "arg", "rev", " fun", "art", "info", "ext", " result", "lit", "re", "RET", "flag", "final", "bit", "xt", "ref", "alt", "Ret"], "retstr": ["retr", "resultstr", "Retr", " retStr", "retst", "pretr", "replystri", "returnStr", "returnstr", " rettext", "pretstri", " retstring", "RetSTR", "retstruct", " retstri", "pretstr", "refStr", "returnr", "rettext", "replystr", "retstri", "RetStr", "refSTR", "pretstruct", "altst", "resultstring", "alttext", "revtext", " retSTR", " retr", "replyr", "refr", "retSTR", "resultStr", " retstruct", "returnstring", "retstring", "revstr", "retStr", "Retstr", "revst", " retst", "refstr", "replystruct", "resultr", "altstr"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n", "idx": 16093, "substitutes": {"opaque": ["OPaya", "ospaque", "ospaya", " opatile", "opacity", "ospacity", "opaya", "OPatile", "OPaque", "opatile", " opacity", "ospatile", "OPacity", " opaya"], "err": ["done", "orig", "ctr", "iter", "bug", "test", " error", "eor", "ev", "dr", "ar", "ok", "rar", "reader", "e", "result", "fe", "rh", "end", "cb", "errors", "finder", "callback", "cmp", "ise", "lr", "str", "rr", "error", "rc", "ptr", "rage", "rb", "init", "gz", "core", "req", "Er", "arr", "acer", "or", "Error", "er", "r", "raise", "ace", "gr", "arm"]}}
{"project": "qemu", "commit_id": "36fef36b91f7ec0435215860f1458b5342ce2811", "target": 1, "func": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n\n    struct mfi_ctrl_info info;\n\n    size_t dcmd_size = sizeof(info);\n\n    BusChild *kid;\n\n    int num_pd_disks = 0;\n\n\n\n    memset(&info, 0x0, cmd->iov_size);\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n\n\n    /*\n\n     * For some reason the firmware supports\n\n     * only up to 8 device ports.\n\n     * Despite supporting a far larger number\n\n     * of devices for the physical devices.\n\n     * So just display the first 8 devices\n\n     * in the device port list, independent\n\n     * of how many logical devices are actually\n\n     * present.\n\n     */\n\n    info.host.type = MFI_INFO_HOST_PCIE;\n\n    info.device.type = MFI_INFO_DEV_SAS3G;\n\n    info.device.port_count = 8;\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        uint16_t pd_id;\n\n\n\n        if (num_pd_disks < 8) {\n\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n\n            info.device.port_addr[num_pd_disks] =\n\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n        }\n\n        num_pd_disks++;\n\n    }\n\n\n\n    memcpy(info.product_name, base_class->product_name, 24);\n\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n\n    memcpy(info.image_component[0].name, \"APP\", 3);\n\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n\n             base_class->product_version);\n\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n\n    info.image_component_count = 1;\n\n    if (pci_dev->has_rom) {\n\n        uint8_t biosver[32];\n\n        uint8_t *ptr;\n\n\n\n        ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n\n        memcpy(biosver, ptr + 0x41, 31);\n\n        memcpy(info.image_component[1].name, \"BIOS\", 4);\n\n        memcpy(info.image_component[1].version, biosver,\n\n               strlen((const char *)biosver));\n\n        info.image_component_count++;\n\n    }\n\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n\n    info.max_arms = 32;\n\n    info.max_spans = 8;\n\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n\n    info.max_lds = MFI_MAX_LD;\n\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n\n    if (!megasas_is_jbod(s))\n\n        info.lds_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n\n                                   MFI_INFO_HW_MEM |\n\n                                   MFI_INFO_HW_FLASH);\n\n    info.memory_size = cpu_to_le16(512);\n\n    info.nvram_size = cpu_to_le16(32);\n\n    info.flash_size = cpu_to_le16(16);\n\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n\n                               MFI_INFO_LDOPS_IO_POLICY |\n\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n\n                               MFI_INFO_LDOPS_READ_POLICY);\n\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n\n    info.stripe_sz_ops.min = 3;\n\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n\n    info.properties.rebuild_rate = 30;\n\n    info.properties.patrol_read_rate = 30;\n\n    info.properties.bgi_rate = 30;\n\n    info.properties.cc_rate = 30;\n\n    info.properties.recon_rate = 30;\n\n    info.properties.cache_flush_interval = 4;\n\n    info.properties.spinup_drv_cnt = 2;\n\n    info.properties.spinup_delay = 6;\n\n    info.properties.ecc_bucket_size = 15;\n\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n\n    info.properties.expose_encl_devices = 1;\n\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n\n                                       MFI_INFO_PDMIX_SATA |\n\n                                       MFI_INFO_PDMIX_LD);\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 16112, "substitutes": {"s": ["client", "fs", "serv", "d", "sync", "o", "session", "south", "v", "secondary", "e", "cs", "server", "sys", "si", "ss", "ssl", "service", "m", "new", "state", "sq", "gs", "sf", "sec", "a", "g", "es", "k", "n", "os", "spec", "stats", "is", "side", "c", "http", "i", "current", "sg", "ns", "p", "b", "f", "start", "sb", "ses", "sis", "js", "request", "settings", "r", "services", "setup", "S", "sym", "conf", "j", "ops"], "cmd": ["client", "module", "qq", "dom", "cm", "md", "command", "cs", "nc", "pkg", "mode", "cfg", "cd", "ctl", "cf", "Cmd", "cb", "def", "cc", "cmp", "conf", "dc", "config", "host", "method", "ck", "comm", "id", "ctx", "init", "c", "q", "mac", "args", "cp", "input", "target", "cod", "cli", "req", "device", "ctrl", "metadata", "name", "msg", "dq", "request", "setup", "event", "conn", "cms", "code"], "pci_dev": ["pcu_device", "pci__de", "pcm_de", "pciacclass", "pcu_dev", "pci_spec", "pciacspec", "pci_ev", "pciacdev", "pcm_ev", "pciacdevice", "pcm_dev", "pcm_device", "pci__ev", "pci__device", "pci_device", "pci_de", "pci__dev", "pcu_class", "pcu_spec"], "pci_class": ["pcixspec", "pccinclass", "ppi67class", "pcixclass", "pdi_bin", "pcioutbus", "pccinspec", "pci__comp", "pci_type", "pcli_comp", "pii_class", "pcinclass", "pcixline", "pci__type", "pcci_num", "pci67spec", "pcioutbin", "pcixtype", "pcioutclass", "pci__spec", "pci67type", "pci__line", "pci67class", "pcinmodel", "pii_system", "pci_model", "pci_num", "pcixsession", "pci_lab", "pdi_bus", "ppi67lab", "pcixsystem", "ppi_lab", "ppi_class", "pcli_class", "pii_spec", "pcci_class", "pdi_classes", "pcli_type", "pci_bin", "pci_bus", "pdi_class", "pcixcomp", "ppi_type", "pci_line", "ppi67spec", "pcioutclasses", "pci67lab", "pci_session", "ppi_spec", "pcci_spec", "pcinspec", "pci__class", "pii_session", "ppi67type", "pci_comp", "pci_spec", "pci__lab", "pcci_model", "pcinnum", "pcli_line", "pci_system", "pccinmodel", "pccinnum", "pci_classes"], "base_class": ["base_type", "base_name", "base2name", "base2class", "cache_name", "cache_class", "cache_type", "base2type"], "info": ["options", "command", "obj", "si", "ui", "api", "init", "Info", "i", "h", "about", "start", "diff", "setup", "ii", "conn", "shared", "fs", "debug", "afi", "image", "die", "slice", "error", "id", "node", "now", "off", "fo", "metadata", "support", "INFO", "ret", "event", "help", "update", "json", "gi", "bug", "fi", "ok", "data", "result", "end", "zip", "state", "comment", "iso", "ch", "buff", "home", "http", "ami", "type", "name", "get", "py", "inf", "app", "inner", "base", "alias", "def", "frame", "config", "kernel", "linux", "ctx", "extra", "ext", "index", "cli", "f", "build", "fw", "conf", "show"], "kid": ["ids", "kie", "ad", "bug", "chid", "sid", "seed", "idy", "kick", "du", "iq", " kids", "cb", "need", "kb", "kids", "anc", "iden", "die", "dk", "pid", "uid", "quad", "ke", "wife", "ck", "k", "key", "id", "ce", "node", "Kid", "kk", "sk", "start", "gen", "kt", "nice", "ski", "child", "dq", "kg", "ko", "cookie", "ku", "dad", "da", "wk", "kind"], "sdev": ["setsdev", "setsdiv", "ssdevice", "ssdiv", "jsvar", "jsdevice", "svar", "cvar", "spack", " sconn", "jsdev", " sdiv", "sconn", "ssvar", "Sdiv", " svar", "sdevice", "tspack", "sdiv", "Spack", "cdiv", "Sdev", "Sconn", " sdevice", "cdevice", "setsvar", "setsdevice", "tsdiv", "tsdev", "jsdiv", "cdev", "ssdev", "tsconn", " spack"], "pd_id": ["pd_kid", "pdappids", "pd_ids", "pdIPID", "pd2ids", "vdIPID", "pc_name", "pa_id", "pd_ID", "paappids", "pd_name", "pdIPkid", "pdIPid", "vd_db", "pd_len", "pdappid", "pd_db", "vd_kid", "vd_ID", "vdIPid", "paappid", "pc_ids", "pd2id", "pc_sid", "pdIPdb", "paapplen", "pa_len", "vd_id", "pdapplen", "pd2name", "vdIPdb", "pd2sid", "pa_ids", "pc_id", "pd_sid", "vdIPkid"], "num_pd_disks": ["num_pdvdisck", "num_pdvdevks", "num_pd_discs", "num_pd_deks", "num_pd2DIScs", "num_pd_devps", "num_pd_duck", "num_pd_DISds", "num_pd_diske", "num_pd_duq", "num_pdvdisq", "num_pd_DIScs", "num_pd_sdps", "num_pd2discs", "num_pd_deds", "num_pd_disds", "num_pd2DISks", "num_pd_freps", "num_pd_deck", "num_pdvsdk", "num_pd_hardks", "num_pd_devck", "num_pd_devq", "num_pdvdisk", "num_pd_decs", "num_pd_DISks", "num_pdvdevck", "num_pd_ducs", "num_pd2DISds", "num_pd_frek", "num_pd2disds", "num_pd_hardps", "num_pd2disks", "num_pd_sdks", "num_pdvsdke", "num_pd_disk", "num_pdvdisks", "num_pd_freke", "num_pdvdiske", "num_pdvsdks", "num_pd_hardk", "num_pd_duds", "num_pd_sdk", "num_pd_devks", "num_pd_dups", "num_pd_freq", "num_pd_sdke", "num_pd_hardke", "num_pd_DISck", "num_pd_freck", "num_pdvdisps", "num_pd_duks", "num_pd_disq", "num_pd_freks", "num_pd_disck", "num_pd2disck", "num_pd_disps", "num_pdvdevps", "num_pdvsdps", "num_pd2DISck", "num_pdvdevq"]}}
{"project": "FFmpeg", "commit_id": "f4aaf987a588fcf5978e636edf2193df35b3e83b", "target": 1, "func": "int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    Task task;\n\n    int ret;\n\n\n\n    av_assert1(!*got_packet_ptr);\n\n\n\n    if(frame){\n\n        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){\n\n            AVFrame *new = avcodec_alloc_frame();\n\n            if(!new)\n\n                return AVERROR(ENOMEM);\n\n            pthread_mutex_lock(&c->buffer_mutex);\n\n            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);\n\n            pthread_mutex_unlock(&c->buffer_mutex);\n\n            if(ret<0)\n\n                return ret;\n\n            new->pts = frame->pts;\n\n            new->quality = frame->quality;\n\n            new->pict_type = frame->pict_type;\n\n            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,\n\n                          avctx->pix_fmt, avctx->width, avctx->height);\n\n            frame = new;\n\n        }\n\n\n\n        task.index = c->task_index;\n\n        task.indata = (void*)frame;\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_cond_signal(&c->task_fifo_cond);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n        c->task_index = (c->task_index+1) % BUFFER_SIZE;\n\n\n\n        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)\n\n            return 0;\n\n    }\n\n\n\n    if(c->task_index == c->finished_task_index)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->finished_task_mutex);\n\n    while (!c->finished_tasks[c->finished_task_index].outdata) {\n\n        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);\n\n    }\n\n    task = c->finished_tasks[c->finished_task_index];\n\n    *pkt = *(AVPacket*)(task.outdata);\n\n    av_freep(&c->finished_tasks[c->finished_task_index].outdata);\n\n    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;\n\n    pthread_mutex_unlock(&c->finished_task_mutex);\n\n\n\n    *got_packet_ptr = 1;\n\n\n\n    return task.return_code;\n\n}\n", "idx": 16135, "substitutes": {"avctx": ["avlib", "akloc", "avcmp", "avcmd", "afcontext", "AVcontext", "Avcontext", "averctx", "afkb", "akctx", " avcontext", "afconfig", "aveconfig", "akcontext", "aflib", "Avctx", "AVcmp", "avconfig", "aveconn", "afloc", "AVkb", "avkb", "avcb", "navctx", "avctl", "avloc", "avectx", "averlib", " avconn", "navcmd", "Avcb", "ajcci", "avecci", "afconn", "Avloc", "AVcci", "avcci", "afcmp", "afctx", "AVctx", "avecmd", "avercontext", "AVconfig", "afctl", "averctl", "avelib", "avectl", "avecmp", "ajcmp", "navcontext", "avconn", "AVconn", "ajcontext", "avecontext", "navconfig", "afcb", "afcmd", "avcontext", "ajctx", " avkb", "akcb"], "pkt": ["Pdu", "pct", "opdu", " pdu", "pqt", "Pkt", " pqt", "opct", "opkt", "pdu", "opqt", "Pqt", " pct", "Pct"], "frame": ["fp", "module", "session", "draw", "force", "obj", "fe", "cf", "cb", "fb", "callback", "m", "Frame", "parent", "up", "channel", "create", "window", "scope", "frames", "setup", "none", "part", "iframe", "flow", "position", "bf", "e", "image", "element", "slice", "time", "view", "figure", "block", "node", "now", "line", "buffer", "remote", "event", "live", "update", "file", "fi", "data", "fram", "message", "cfg", "cycle", "model", "definition", "shape", "object", "state", "parse", "fake", "coll", "call", "game", "document", "connection", "thread", "source", "rame", "feature", "base", "style", "config", "point", "motion", "info", "zone", "p", "target", "f", "old", "video", "next", "function"], "got_packet_ptr": ["got_packet64tr", "got_packet__pointer", "got_packet_thread", "got_packacket_ptr", "got_packet64handle", "got_packet_addr", "got_packet__ptr", "got_packet64ptr", "got_packet_handle", "got_packet__thread", "got_packacket_pointer", "got_packacket_tr", "got_packet__addr", "got_packet_pointer", "got_packet64pointer", "got_packacket_thread", "got_packacket_addr", "got_packet_tr", "got_packacket_handle"], "c": ["d", "ct", "cn", "cu", "oc", "exec", "v", "cm", "tc", "sc", "cs", "e", "con", "C", "bc", "u", "cf", "container", "l", "pc", "conn", "icc", "course", "ec", "cc", "dc", "m", "conf", "this", "uc", "lc", "rc", "config", "g", "k", "rec", "n", "ac", "vc", "ch", "can", "ctx", "ci", "ce", "center", "cache", "cur", "fc", "h", "cp", "i", "s", "p", "cl", "cat", "b", "cy", "coll", "co", "ctrl", "ic", "f", "arc", "cr", "ca", "mc", "w", "call", "r", "t", "nc"], "task": ["module", "sync", "batch", "session", "test", "nn", "func", "exec", "data", "empty", "patch", "thread", "tc", "project", "image", "result", "ask", "worker", "process", "container", "message", "work", "job", "Task", "course", "resource", "object", "service", "tag", "queue", "tf", "error", "config", "parent", "proc", "channel", "key", "class", "block", "node", "piece", "complete", "slave", "layer", "target", "kk", "device", "instance", "ack", "tx", "table", "manager", "child", "master", "transfer", "remote", "game", "event", "t", "next", "pack"], "ret": ["part", "en", "gt", "fail", "ft", "fin", "file", "success", " Ret", "data", "nt", "resp", "bf", "br", "result", "rt", "att", "val", "alt", "res", " RET", "det", "reply", "_", "al", "fun", "rot", "url", "num", "reg", "error", "rc", "rb", "rets", "replace", "rev", "mem", "mt", "art", "lit", "run", "sr", "re", "out", "RET", "flag", "back", "bit", "ref", "len", "Ret", "code"], "new": ["large", "NEW", "v", "fresh", "join", "later", "ec", "m", "create", "self", "n", "box", "mac", "one", "gen", "msg", "or", "j", "array", "another", "client", "raw", "e", "image", "copy", "resource", "word", "block", "node", "now", "missing", "found", "remote", "null", "update", "ew", "first", "func", "data", "same", "more", "user", "existing", "message", "l", "and", "root", "this", "valid", "news", "replace", "to", "other", "again", "name", " New", "game", "make", "d", "content", "package", "unique", "full", "el", "small", "g", "add", "current", "extra", "p", "inc", "unknown", "f", "child", "w", "New", "r", "old", "next"]}}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n", "idx": 16147, "substitutes": {"f": ["fp", "fm", "fs", "d", "o", "file", "af", "fa", "func", "uf", "v", "e", "elf", "fe", "fn", "ff", "raf", "cf", "l", "fb", "rf", "m", "this", "fd", "form", "sf", "tf", "fen", "g", "df", "self", "fr", "handler", "xf", "feed", "buff", "fc", "c", "info", "h", "fed", "p", "b", "fx", "fo", "lf", "F", "framework", "conf", "inf"], "vmsd": [" vmsdo", "vmesdb", "vmssd", "vomsd", " vMSds", "vssdc", "vmsdc", "svatsds", "vmsdd", "vmmsd", "fmsdy", "vmsdb", " vmsdb", " vmesds", " vMSdy", "vamsdm", "vmsp", "vamsdt", "vmpds", "enventsdos", "vmsdos", "vamsdd", "vmmd", "vamsdb", "vvsds", "vMSde", "fpsds", "vnsdal", "svatsdal", " vmpp", "vmsz", "vnsdc", "vvsd", " vamsd", "vcsd", "vpsz", "varmsdb", "ventsd", " vMSdt", "fmsd", "svmsds", "vmasdt", "vmasdy", "svmsdc", "vpssd", " vmesd", "fcsds", " vmsdy", "vopsd", "vmesdo", "envmsdos", "vssd", "vomsdm", " vmpds", "vnsds", "fcsd", "vcsdn", "vssdy", "vopsdn", "vopsds", "ventsds", "vmescd", "vmesD", "svatsd", "varmsdo", "vcsdal", "vopsz", "vpsd", "vmsdy", "vmsds", "vmsdn", "envmsd", "fcsdn", "vmpdc", "vamscd", " vmesD", "vatsdal", "vcsde", "vmsD", "varmsdy", "ventssd", "enventsds", "vcsdc", "vopsdy", " vmsdm", "svatsdc", " vmpd", "vmsdt", "vomsdd", "vMSD", "vatsdc", " vmscd", "vicsd", "vssds", "vcsds", " vmsds", "vmscd", "vmsdal", "vicsdt", "vatsd", "svmsdal", "svmsd", "vvsbd", " vamscd", "vssdt", "vopsbd", "vssp", "vmpd", "vmasd", "enventssd", "vMSd", "vmesdc", "varmscd", "vnsd", " vamsdo", " vamsdd", " vamsdt", " vmsdd", "envmsds", "vicsdd", "vcsD", " vamsdm", "vatsds", "varmsdn", "vmesp", "enventsd", " vmsp", " vmsD", "envmssd", "vicsdm", "vmsdo", "vpsbd", "vpsdos", " vamsdb", "vcsdy", " vMSd", " vmsdt", "ventsdos", "fmsds", "vmesde", "fpsd", "vmsde", "vpsds", "vmasds", "vmpp", "vmsdm", "varmsd", "fmsz", "vMSdt", "vmesd", "vmesds", "vamsdo", "vvsz", "varmsds", " vmsdc", "vmmdos", " vmsde", "fcsdy", "fpsz", "vmsbd", "vomsdt", "fmsdn", "vMSds", "fpsbd", " vmpdc", " vmesde", "vMSdy", "vamsd", "fmsbd", "vmmds"], "opaque": ["copacity", "ospacle", "ospaque", "iopacle", "opsaque", "ipacity", "opac", " opac", "iopacity", "opaques", " opque", "opula", "copica", "oppula", "operula", "opane", "opica", "ipaque", "oponymous", "operonymous", " opica", "osponymous", "pac", "copaques", "opsane", "opque", "pula", " opacity", "operaque", "iopaques", "oppac", "operac", "operica", "opacity", "iopaque", "ospacity", "paque", "opsacity", "ioponymous", "operque", "ipac", "copaque", "pacity", "iopane", "copque", "oppaque", "oppacity", "operacity", "opsaques", "ipque", "opacle", "copane", "operacle"], "version_id": ["ver_ids", "version0ids", "versioningId", " version_Id", "version0name", "creation_id", "version_ID", "version_Id", "version_ide", " version_name", "versioningsid", "version_kind", "versionxoffset", "versionxids", " version_i", "package_kind", "version_uid", "version0kind", "instanceinglike", "version11vid", "install_ide", " version_offset", "package_id", "versioningvid", "version_sid", "install_uid", "version_size", "ver_name", "instance_like", " version_sid", "version11id", "creation_ident", "version_i", "install_ids", "versioningi", "version_ids", "install_id", "package_name", "instanceingvid", "version0ident", "versionxsize", "version_offset", "instanceingis", " version_ids", "instance_id", "creation_ID", " version_size", "version0info", "ver_id", "version0ID", "version_name", "versioningis", "versioninglike", "instance_is", "versionxid", "instanceingid", "version_is", "ver_type", "versioningid", "version_ident", "version_type", "instance_vid", "version0id", "version_like", " version_count", "version_vid", "version11is", "package_info", "version_info", "creation_ids", "version_count", "version11like"], "field": ["module", "list", "force", "open", "condition", "group", "label", "man", "box", "window", "flag", "diff", "back", "entry", "value", "um", "record", "loop", "match", "holder", "element", "machine", "slice", "error", "lc", "method", "word", "block", "handler", "line", "off", "wire", "Field", "load", "option", "event", "rule", "manager", "file", "FIELD", "data", "attribute", "after", "message", "end", "model", "and", "object", "service", "comment", "key", "type", "member", "name", "lf", "cell", "ref", "document", "feature", "fix", "package", "style", "post", "form", "player", "layer", "index", "ield", "row", "child", "er", "section", "term", "plugin", "number", "function"], "base_addr": ["base_point", "base_offset", "base_name", "base_coord", " base_address", " base_coord", " base_name", " base_url", "base_url", " base_ptr", " base_offset", "base_pos", " base_point", "base_address", "base_ptr", " base_pos"], "ret": ["et", "en", "ft", "success", "fi", "data", "pat", "bf", "nt", "count", "match", "result", "obj", "feat", "end", "rt", "att", "val", "def", "job", "res", "pet", " RET", "det", "reply", "len", "str", "fun", "rc", "url", "num", "reg", "error", "rets", "arg", "rev", "mem", " fun", "info", " def", " result", "cat", "lit", "rep", "re", "RET", "flag", "red", "get", "err", " reply", "back", "bit", "Ret", "r", "value", "ref", "alt", " arg", " success"], "i": ["it", "ie", "di", "gi", "ini", "iu", "mi", "fi", "v", "multi", "li", "e", "u", "xi", "l", "pi", "ib", "abi", "uri", "si", "ai", "ig", "ui", "ti", "ix", "key", "z", "k", "arg", "eni", "ci", "id", "qi", "ip", "ami", "c", "x", "info", "phi", "hi", "p", "index", "ri", "b", "ni", "start", "zi", "ind", "j", "r", "ii", "inf", "I"], "addr": ["prefix", "part", "address", "hop", "dr", "route", "afi", "amd", "ord", "ar", "amp", "la", "adr", "pos", "pkg", "result", "area", "work", "align", "uri", "alias", "pad", " address", "offset", "slice", "ptr", "url", "rc", "host", "ix", "osi", "id", "ip", "x", "rx", "pointer", "coord", "layer", "p", "index", "arr", "ace", "r", "loc", "ref", "ad"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,\n\n                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)\n\n{\n\n    TCGReg tmp0 = TCG_TMP0;\n\n    TCGReg tmp1 = ret;\n\n\n\n    assert(ret != TCG_TMP0);\n\n    if (ret == ah || ret == bh) {\n\n        assert(ret != TCG_TMP1);\n\n        tmp1 = TCG_TMP1;\n\n    }\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n    case TCG_COND_NE:\n\n        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);\n\n        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);\n\n        break;\n\n\n\n    default:\n\n        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);\n\n        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);\n\n        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);\n\n        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);\n\n        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);\n\n        break;\n\n    }\n\n}\n", "idx": 16155, "substitutes": {"s": ["hs", "sync", "d", "sv", "session", "site", "rs", "south", "private", "e", "u", "l", "server", "ds", "bis", "sys", "si", "ions", "ss", "states", "ssl", "service", "m", "se", "y", "sq", "gs", "sf", "sing", "xs", "g", "es", "self", "sup", "os", "spec", "ctx", "side", "c", "http", "su", "sg", "secure", "p", "ns", "scope", "b", "sets", "f", "sb", "ses", "js", "groups", "r", "services", "setup", "S", "sym", "t", "native"], "cond": ["fail", "ct", "cont", "resp", "fact", "contin", "con", "bc", "obj", "pos", "cho", "fn", "desc", "cmd", "act", "cb", "cas", "val", "condition", "lic", "cmp", "conf", "det", "fd", "comb", "sec", "unit", "lc", "fun", "pre", "reg", "config", "fc", "change", "no", "code", "cl", "col", "type", "rupt", "sign", "reason", "co", "ic", "prop", "crit", "red", "ound", "pred", "diff", "term", "cell", "loc", "ref", "eff", "Cond", "comp", "day", "null", "rol"], "ret": ["ru", "ne", "ft", "fin", "rem", "success", "alg", "fi", "pat", "resp", "repl", "ry", "ben", "match", "result", "obj", "sil", "rt", "ib", "rel", "att", "sel", "val", "alt", "def", "res", "pet", "det", "reply", "pret", "seq", "fun", "rc", "reg", "ert", "tr", "rets", "arg", "id", "rev", "cur", "mem", "cache", "mt", "ort", "hard", "ext", "active", "lit", "alf", "rep", "sr", "re", "sb", "RET", "flag", "red", "back", "py", "bit", "r", "final", "ref", "len", "Ret"], "al": ["en", "ial", "ay", "ale", "ral", "af", "alist", "ar", "all", "als", "mal", "bal", "ill", "ll", "ap", "Al", "l", "rel", "val", "fal", "ai", "el", "eal", "gal", "a", "ae", "alog", "ali", "ia", "am", "sh", "ul", "ell", "ail", "p", "b", "hal", "sl", "alf", "il", "f", "AL", "pal", "pl", "ab", "au", "eb", "isal", "ag", "nl", "alt", "bel", "ad"], "ah": ["en", "ha", "eh", "ay", "ev", "af", "ach", "cz", "arch", "ar", "jp", "la", "br", "uh", "oh", "sa", "ap", "rh", "eth", "cf", "ff", "anch", "ib", "area", "ih", "lah", "ang", "ec", "ai", "ig", "loc", "el", "az", "gh", "ef", "a", "aj", "ae", "aph", "z", "ahi", "adh", "ch", "am", "ey", "sh", "c", "h", "q", "yah", "p", "ph", "ak", "sl", "ab", "av", "au", "nah", "abc", "ag", "ref", "ee", "eb"], "bl": ["bm", "bd", "ba", "af", "bf", "amb", "Ub", "ll", "ld", "br", "ill", "li", "fl", "l", "ib", "val", "Bl", "db", "el", "lb", "bg", "BL", "lam", "bs", "hl", "z", "ch", "sh", "p", "cl", "b", "lab", "sl", "il", "mb", "sb", "pl", "lf", "ab", "ub", "nl", "ref", "eb"], "bh": ["ha", "bf", "amb", "br", "uh", "oh", "bc", "fl", "rh", "cb", "ib", "ht", "l", "ih", "ob", "db", "hh", "bt", "gh", "sq", "lb", "deb", "bg", "bs", "hl", "aph", "rb", "adh", "ch", "nb", "bi", "sh", "bah", "h", "pb", "yah", "bb", "p", "ph", "cl", "b", "lab", "sl", "sb", "pl", "kh", "ab", "bj", "zh", "nah", "nl", "loc", "ref", "eb"]}}
{"project": "qemu", "commit_id": "28f4a7083dcca084243e313ab18fcdb20d60334e", "target": 0, "func": "static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n", "idx": 16163, "substitutes": {"dcl": ["ldacl", "ndll", "dcel", "pdcc", "dCL", " dll", "Dcl", "Dacl", "pdcl", "ldcel", " dCL", "pdll", "ndCL", "ldCL", " dcc", "sdll", "ndcl", "pdCL", "dll", " dcel", "dcc", "sdCL", "DCL", "ldcl", "dacl", "sdcl", "sdcc", "ndacl", "Dll", " dacl"], "c": ["client", "enc", "d", "ct", "o", "cu", "oc", "v", "cm", "cs", "e", "u", "C", "nc", "con", "pc", "cf", "l", "anc", "ec", "cc", "dc", "m", "lc", "g", "k", "cus", "n", "ac", "ch", "ci", "vc", "ctx", "ce", "cur", "fc", "cache", "x", "i", "pointer", "cp", "s", "p", "cl", "col", "b", "cy", "coll", "ic", "f", "unc", "cr", "mc", "ca", "w", "r", "chain", "loc", "t"], "ssd": ["cssdl", "rssdl", "ossd", "arsd", "esssd", "hesssd", "wsd", "arsdc", "rsss", "ossdad", "amsd", "msdn", "essd", "csssd", "ussad", "nsd", "arsdl", " ssds", "wsdc", "tsds", "cssdn", "cssad", "cusds", "csss", "essdc", "hesshd", "ussdl", "ssdc", "essl", "essdb", "ssl", "ussds", "nss", "sssd", "ssdl", " sssd", "rssl", "amsdad", "SSds", "ossds", "msd", "sshd", "SShd", "wsds", "wsdk", "hessd", "ssds", "cssdb", "ssdk", "rssdc", "osss", "amsds", "issd", "tsdl", "hessl", "msdc", "cssds", "cusdl", "essdk", "SSd", "ssdb", "issdb", "cusdc", "cssl", "issds", "nsdc", "psd", "ssdn", "tsad", "ussd", "cssd", "psdc", "cssdk", "essdl", " sshd", "cssdad", "ssad", "ssdad", "cusd", "SSsd", "amss", "psdl", "nsds", "msds", "essds", "arsds", "rssds", "tsd", "essdn", "cssdc", "psds", "rssd", "psl", "issdc", "sss", "hessds"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline void stw_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr, val, 2);\n\n    } else {\n\n        unsigned long addr1;\n\n        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stw_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stw_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stw_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 2);\n\n    }\n\n}\n", "idx": 16164, "substitutes": {"addr": ["module", "address", "hop", "dr", "route", "nn", "ord", "amd", "ar", "data", "v", "amp", "md", "mode", "adr", "pos", "ld", "rt", "work", "size", "align", "pair", "access", "pad", "ann", "attr", "offset", "nr", "rr", "url", "rc", "config", "usr", "host", "point", "add", "id", "ctx", "node", "mt", "rm", "x", "pointer", "coord", "layer", "ext", "index", "dd", "mr", "arr", "tx", "src", "name", "ind", "vr", "r", "ace", "nm", "loc", "at", "ref", "arm", "len", "ad", "code"], "val": ["update", "part", "VAL", "test", "bl", "fee", "all", "data", "v", "ol", "eval", "count", "pt", "pos", "fe", "fl", "pc", "sel", "base", "alt", "slot", "ival", "loc", "aval", "pid", "el", "slice", "elt", "valid", "al", "seq", "unit", "Val", "pre", "key", "cond", "arg", "mem", "x", "p", "vol", "cal", "lit", "sl", "vals", "tx", "arr", "pal", "cr", "ind", "py", "value", "ret", "ref", "len", "null", "rot"], "endian": ["engendor", " endendor", "startian", " endorian", "engian", "enIAN", "endednic", "ndorian", "endians", "endiant", "entrian", "ndian", "endrian", "entendor", "Endien", "endnic", "endedian", "Endiant", "startIAN", "endendor", " endnic", "Endian", "endedrian", "eniant", "startrian", " endric", "endien", "endedorian", "endedien", " endrian", "EndIAN", "startnic", " endIAN", "endedians", "endorian", "endIAN", "entric", " endians", "engrian", "enian", "endediant", "entian", "engric", "ndIAN", "endric", "endedIAN", "enien", "ndians"], "ptr": ["trace", "ctr", "address", "dr", "pe", "fi", "data", "v", "br", "adr", "Ptr", "pt", "pos", "eth", "eval", "plug", "rt", "pc", "length", "pair", "nil", "pad", "slot", "attr", "grad", "offset", "slice", "fd", "inst", "str", "dim", "rot", "Val", "pr", "tr", "point", "ctx", "pointer", "p", "index", "type", "vol", "lit", "arr", "tx", "src", "pl", "mount", "ind", "port", "td", "py", "buf", "ace", "loc", "code"], "section": ["large", "module", "ECTION", "session", "address", "pe", "site", "patch", "sc", "account", "se", "group", "sec", "parent", "channel", "region", "character", "description", "lib", "component", "ment", "sections", "entry", "array", "part", "ie", "element", "job", "fat", "slice", "shadow", "lc", "Section", "option", "setting", "socket", "storage", "environment", "data", "sa", "script", "area", "sel", "service", "comment", "rc", "journal", "sl", "member", "division", "sector", "connection", "ion", "sect", "feature", "package", "server", "pair", "loc", "vision", "small", "config", "sub", "version", "ext", "layout", "core", "index", "row", "child", "plugin", "function"], "addr1": ["ptrone", "addr0", "align0", " addrone", "adr9", "alignone", "valone", "ampone", "ptr2", "address6", "addr9", "addrone", "addr6", "arm9", "adr1", "aceone", "adr6", "drone", " addr0", "dr1", " addr2", "align2", "ace0", "ace1", "dr2", "arm6", "val1", "amp1", "align1", "arm1", "addressone", "address9", "ptr0", "address0", "ptr1", "address2", "addr2", "ace2", "dr0", "address1"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3], \n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n    \n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now \n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 63;\n\n            }\n\n            \n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\", \n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n        \n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        \n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, \n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 16177, "substitutes": {"scale_code": [" scale_codes", "scale2code", "scale_codes", "scale2const", "scale_function", " scale_function", "scale_const", "scale2function", "scale2codes", " scale_const"], "scale_factors": ["scale_factores", "scale_factories", "scale_factoros", "scale_factorores", "scale_actos", "scale_fores", "scale_actories", "scale_formores", "scale_factoror", "scale_actores", "scale_formions", "scale_factorories", "scale_formors", "scale_factorions", "scale_fors", "scale_for", "scale_formos", "scale_actors", "scale_factor", "scale_factions", "scale_fories", "scale_actor", "scale_factorors", "scale_factos", "scale_actions"], "sb_samples": ["sb_salls", "sb_sitesamples", "sb_nores", "sb_nipes", "sb_tamples", "sb_examples", "sb_lales", "sb_sances", "sb_tores", "sb_lalls", "sb_namples", "sb_scales", "sb_sitesances", "sb_scamples", "sb_sales", "sb_sipes", "sb_namps", "sb_sitesales", "sb_exipes", "sb_tamps", "sb_samps", "sb_sores", "sb_sitesalls", "sb_scalls", "sb_examps", "sb_exores", "sb_lamples", "sb_scances", "sb_lances", "sb_tipes"], "sblimit": ["sbllimite", "sbllimIT", "sbllimit", "sblimited", "sblIMit", "sblimiter", "splIMite", "sblrimIT", "splimIT", "sclimite", "splimit", "splIMit", "splIMIT", "sclIMit", "sclIMite", "sblrimite", "sblIMite", "sblrimit", "sblimsIT", "sblIMIT", "splimite", "sblimite", "sclimIT", "sblimsiter", "sclIMiter", "sclimit", "sblrimiter", "sblimsited", "sclimiter", "sblimIT", "sblIMiter", "sblimsit", "sclIMIT", "sblimsite", "splimited", "sbllimited", "splIMited", "sblIMited"], "p": ["ps", "d", "pe", "tp", "pn", "jp", "po", "patch", "per", "e", "pt", "ap", "u", "pc", "l", "pi", "P", "pp", "y", "m", "sp", "api", "a", "pr", "g", "z", "lp", "point", "np", "pa", "ip", "bp", "q", "h", "cp", "c", "s", "x", "b", "f", "w", "port", "py", "r", "t"], "vmax": ["vmad", "vctotal", "valparent", "svlast", "valmin", "vdiv", "lmin", "valrange", "Vdev", "vparent", " vdiv", "jtotal", "Vax", "jmax", "jc", "lax", " vMax", "vlast", "vMax", "vvdev", "lvmin", "svax", " vc", "llast", "lMax", "jax", " vdev", "Vmin", "lvcl", "Vdiv", "lmax", "valmax", "lcl", "vcmax", "vvMax", "nvmax", " vtotal", "vvc", "lvparent", "lvmax", "svMax", "svmin", "vvcl", "vrange", "svmax", "vcmad", "Vc", "jmad", " vmad", "VMax", "Vlast", " vax", "vtotal", "vvmax", "lvMax", "vdev", "nvrange", "vmin", "jMax", "lvrange", "vcax", " vmin", "jdiv", "vcl", "nvmin", "vax", "vc", "Vmax", "vvmin", "nvparent", " vlast"], "v": ["d", "sv", "ev", "ve", "u", "V", "l", "ov", "val", "vi", "y", "tv", "m", "api", "g", "z", "iv", "nv", "x", "max", "q", "conv", "uv", "c", "h", "vs", "vol", "b", "ver", "va", "f", "lv", "w", "av", "vp", "value", "vv", "t", "cv"], "n": ["en", "d", "o", "nn", "cn", "pn", "ng", "e", "u", "nc", "network", "l", "size", "ny", "y", "na", "m", "mn", "sn", "a", "dn", "num", "g", "z", "net", "np", "nb", "x", "N", "c", "max", "ns", "b", "ni", "f", "min", "ind", "w", "r", "t", "len"], "i": ["it", "d", "ie", "o", "di", "ini", "iu", "mi", "jp", "t", "li", "e", "u", "xi", "l", "pi", "si", "y", "in", "ai", "m", "ui", "api", "ix", "key", "z", "eni", "ik", "io", "ci", "id", "bi", "qi", "ip", "x", "c", "phi", "ji", "s", "b", "ni", "f", "ind", "r", "ii", "ori", "I", "yi"], "j": ["it", "d", "o", "J", "jp", "li", "jl", "e", "u", "pos", "l", "si", "y", "m", "jo", "g", "z", "jj", "jet", "key", "x", "ij", "h", "c", "ji", "q", "b", "f", "start", "ind", "js", "w", "r", "ii", "t", "ja", "jc"], "k": ["o", "ok", "u", "l", "kn", "y", "an", "m", "dk", "ke", "g", "z", "ks", "key", "ik", "ch", "id", "K", "x", "q", "c", "h", "uk", "ki", "kk", "ak", "ph", "b", "s", "kw", "w", "ko", "r", "ek", "mk", "t", "sk"], "code": ["ne", "charge", "test", "func", "content", "data", "count", "nc", "result", "fe", "match", "message", "end", "cycle", "length", "size", "use", "desc", "pair", "condition", "cc", "Code", "zip", "offset", "slice", "state", "comb", "xx", "comment", "error", "unit", "key", "sequence", "ci", "id", "change", "c", "line", "info", "close", "cod", "type", "start", "example", "name", "ind", "call", "xxx", "entry", "text", "loc", "catch", "function", "codes"], "index": ["address", "test", "nn", "ini", "list", "ng", "fe", "network", "output", "online", "val", "si", "condition", "in", "find", "ix", "date", "example", "start", "ind", "diff", "xxx", "value", "none", "sync", "part", "ne", "position", "expression", "Index", "loop", "match", "element", "path", "offset", "slice", "error", "num", "id", "node", "x", "input", "c", "option", "update", "iter", "original", "end", "size", "shape", "comment", "key", "pointer", "type", "member", "name", "alpha", "degree", "body", "d", "zero", "connection", "ion", "action", "thread", "search", "xi", "length", "style", "page", "see", "insert", "version", "second", "current", "weight", "no", "info", "inc", "f", "loc", "old", "number"], "d1": ["cd1", "f2", "f7", "D0", "fOne", "t3", "f1", " d7", "j1", "j7", "cdOne", "D1", "tOne", "t1", " dOne", "D3", "j2", "d0", "f3", "f0", "d7", " d3", "D2", " d0", "dOne", "d3", "cd3", "jOne"], "d2": ["dc5", " dtwo", "ld2", "p2", " dii", "dii", "day82", " d82", " d5", "daytwo", " d02", "ldtwo", "p4", "dctwo", "p5", "ctwo", "dc02", "c4", "day6", "d5", "dc4", "ld82", "d4", "dc2", "day2", "dtwo", "ld6", "pii", "c02", "dcii", "c2", "d6", "d82", " d6", " d4", "d02"], "sf": ["fp", "fm", "fs", "isf", "sv", "ft", "ffield", "fee", "tp", "fi", "uf", "split", "bf", "dist", "sm", "fe", "fn", "fts", "ff", "cf", "eph", "prof", "fb", "result", "iw", "si", "models", "stab", "wm", "rf", "ssl", "sp", "hh", "sq", "fd", "fit", "hw", "tf", "xs", "fen", "df", "lp", "fr", "gif", "cv", "xf", "sd", "fc", "ze", "ppa", "su", "cp", "flo", "sw", "sl", "fx", "f", "lv", "sb", "lf", "support", "diff", "gp", "ffe", "gb", "vp", "settings", "ls", "SF", "fw", "tif", "pb", "tta"]}}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "static void opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else assert(0);\n\n}\n", "idx": 16183, "substitutes": {"opt": ["o", "ott", "oper", "mp", "hop", "test", "options", "ok", "txt", "pot", "op", "obj", "fn", "feat", "cho", "token", "path", "attr", "tag", "str", "error", "config", "usr", "spec", "optim", "init", "ort", "Opt", "ext", "p", "off", "type", "cat", "color", "prop", "crit", "ocr", "option", "text", "loc", "eff"], "arg": ["enc", "alloc", "ar", "ok", "op", "obj", "val", "path", "doc", "ig", "tag", "parse", "config", "proc", "Arg", "args", "ext", "lib", "ax", "cat", "arc", "prop", "or", "call", "option", "argument", "loc"], "oc": ["enc", "o", "oca", "hop", "alloc", "soc", "cu", "exec", "aco", "oco", "acc", "mic", "op", "oid", "bc", "pc", "voc", "og", "output", "toc", "ocol", "anc", "ec", "oci", "irc", "cc", "uc", "orc", "AC", "ac", "org", "iv", "ucc", "fc", "c", "OC", "isc", " alloc", "ic", "unc", "ir", "mc", "roc", "ocr", "auc", "abc", "ogg", "loc"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int srcStride)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 16190, "substitutes": {"src": ["gl", "hub", "rs", "tmp", "sit", "obl", "jpg", "source", "sc", "dist", "bc", "sci", "sil", "ruby", "sel", "scl", "rob", "sys", "ssl", "gal", "sq", "inst", "cdn", "sec", "url", "rc", "config", "sub", "RC", "rb", "rib", "iv", "spec", "ctx", "cur", "rect", "gz", "lib", "sl", "sr", "sb", "sound", "rl", "gb", "stat", "loc", "filename", "img", "dest"], "ydst": ["ydST", "hdrest", "hdost", "ydstr", "xdst", "dyrest", "dyst", "iddbl", "ydost", "ydrest", "ydest", "xdstr", "eyrest", "iddST", "dyest", "hdest", "dystr", "ynsta", "ecdST", "dysta", "ecdst", "hdstr", "eyest", "hdst", "ydbl", "hdsta", "ecdstr", "ynst", "iddstr", "ynost", "ecdbl", "eystr", "eyst", "ynSt", "ydSt", "xdbl", "dyost", "hdSt", "dySt", "ydsta", "xdST", "iddst"], "udst": ["udbl", "hdost", "vdST", "ddast", "ddst", "vdast", "hdST", "UDost", "hdast", "UDbl", "udST", "ddST", "UDST", "hdst", "ddbl", "udast", "vdbl", "vdost", "udost", "ddost", "UDst"], "vdst": ["iddset", "hdost", "iddost", "xdst", "vdST", "hdST", "vdest", "iddST", "xdest", "hdsrc", "hdest", "iddsrc", "udsrc", "hdst", "hdset", "iddest", "vdsrc", "xdset", "udest", "vdset", "vdost", "udost", "xdST", "iddst"], "height": ["d", "ty", "holes", "length", "size", "style", "def", "Height", "depth", "level", "shape", "rows", "ensions", "padding", "images", "dim", "resolution", "density", "max", "h", "bottom", "x", "window", "crop", "layout", "thin", "stroke", "th", "w", "diff"], "lumStride": ["lumCride", "lUMPrite", "lumSTride", "lumStuse", "lumShride", "lumsStrict", "lUMPerve", "lumStr", "lumShuse", "lumPr", "lumsterve", "lumPride", "lUMStrite", "lumSTrite", "lumsCrict", "lumStrict", "lumsCuse", "lUMSterve", "lumPerve", "lumSterve", "lUMStride", "lumsCride", "lumSTerve", "lumStrite", "lumsCrite", "lumSTr", "lumCrict", "lUMPride", "lumPrite", "lumsStrite", "lumsStride", "lumCuse", "lumstrite", "lumCrite", "lUMPr", "lumstride", "lumShrite", "lumsStuse", "lumShrict", "lumstr", "lUMStr"], "chromStride": ["romStride", "chromStrip", "chromstipe", "chromScrite", "chromContride", "chromstrite", "chromContrip", "romStrite", "romstrip", "chromStrite", "chromStipe", "chromScrip", "chromContipe", "romStipe", "chromstrip", "chromstride", "chromScride", "romstipe", "romStrip", "chromContrite", "chromScipe", "romstrite", "romstride"], "srcStride": ["srcSlrite", "srcStructure", "sourceStride", "srcstructure", "srcStrite", "srcEstride", "srcSTrite", "srcStrate", " srcStri", " srcStructure", "srcSlrate", "srcStrict", "srcstri", "srcSTrate", "sourceStrate", "srcStri", "srcBlride", "srcSTrict", "srcBlrite", "srcEstri", " srcstride", "srcEstructure", "srcSlride", "sourceStrict", "srcSlrict", "sourceStrite", "srcBlructure", "srcSTride", " srcStrite", " srcstructure", " srcstrite", "srcBlri", "srcstrite", " srcstri", "srcEstrite", "srcstride"], "y": ["ya", "d", "my", "ay", "ty", "ky", "yn", "yo", "ys", " cy", "ry", "yt", "yr", "year", "ny", "wy", "xy", "zy", "ady", "ym", "vy", "z", "n", "yd", "ey", "x", "c", " Y", "h", "p", "col", "cy", "hy", "f", "w", "Y", "yy", "sy", "dy", "oy", "ye", "py", "j", "t", "sky", "yi", "yl"]}}
{"project": "FFmpeg", "commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "target": 1, "func": "static int huf_uncompress(GetByteContext *gb,\n\n                          uint16_t *dst, int dst_size)\n\n{\n\n    int32_t src_size, im, iM;\n\n    uint32_t nBits;\n\n    uint64_t *freq;\n\n    HufDec *hdec;\n\n    int ret, i;\n\n\n\n    src_size = bytestream2_get_le32(gb);\n\n    im = bytestream2_get_le32(gb);\n\n    iM = bytestream2_get_le32(gb);\n\n    bytestream2_skip(gb, 4);\n\n    nBits = bytestream2_get_le32(gb);\n\n    if (im < 0 || im >= HUF_ENCSIZE ||\n\n        iM < 0 || iM >= HUF_ENCSIZE ||\n\n        src_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    bytestream2_skip(gb, 4);\n\n\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n\n    if (!freq || !hdec) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n\n        goto fail;\n\n\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n\n        goto fail;\n\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\n\n\nfail:\n\n    for (i = 0; i < HUF_DECSIZE; i++) {\n\n        if (hdec[i].p)\n\n            av_freep(&hdec[i].p);\n\n    }\n\n\n\n    av_free(freq);\n\n    av_free(hdec);\n\n\n\n    return ret;\n\n}\n", "idx": 16197, "substitutes": {"gb": ["storage", "bm", "binary", "gt", "sync", "hub", "cgi", "jpg", "du", "cm", "bf", "ge", "gm", "bc", "pc", "cfg", "cb", "hd", "kb", "gc", "GB", "db", "ga", "gio", "gal", "tm", "gs", "bg", "rc", "gin", "g", "go", "rb", "gam", "ctx", "usb", "gz", "gram", "gom", "cod", "cli", "gnu", "bb", "b", "gg", "mb", "sb", "src", "gru", "gp", "eb", "ko", "py", "game", "rg", "gd", "gy"], "dst": ["dstore", "dsts", " dstore", "brest", "fdstore", "pdst", "bST", "sdsts", " dST", "fdsts", "pdstore", "fdst", " dost", "drest", "dost", "sdrest", "bst", "sdst", "pdsts", " drest", "sdST", "dST", "bsts", "fdost", "pdost", " dsts"], "dst_size": ["dst_name", "dsc_SIZE", "dst_len", "dsts_capacity", "dsts_size", "dsc_name", "dst_capacity", "dsts_len", "dsc_size", "dst_SIZE"], "src_size": [" src_speed", "src_Size", "src_ize", "rss_size", "rss_ize", "rss_Size", "src_speed", " src_ize", " src_Size", "src_capacity", " src_capacity"], "im": ["fm", "mm", "ie", "ru", "aim", "um", "imp", "hub", "mi", "umi", "imm", "iu", "sim", "cm", "ima", "gm", "image", "u", "pm", "ib", "size", "model", "Im", "ai", "m", "ims", "ym", "em", "sem", "dim", "iam", "om", "lim", "iv", "ci", "am", "rm", "ip", "imi", "ext", "dm", "nm", "imet", "loc", " unim", "img", "IM"], "iM": [" iN", "iD", "iniM", "oD", "uG", "um", " iL", " iB", "qiMQ", "siP", "qiM", "oiM", "oim", "piM", "iT", "tiN", "iMQ", "piC", "uAM", "siN", "siD", " iC", "iI", "iB", "siL", "uD", " iD", "iC", " iG", "siM", "oM", "tiT", "qiN", "iP", "iniP", "iG", "oiN", "piB", "uM", "tiL", "oiD", "uC", "iniN", "uMQ", "uI", "uN", "iL", " iP", " iT", " iMQ", "siAM", "siB", "iAM", "piN", " iI", "siT", "uB", "tiM", " iAM", "iN", "qiD", "oG", "oI", "iniB"], "nBits": ["nCBbits", "nBats", "nNBITS", "nFitches", "nLimit", "nBsITS", " nMBis", "nWats", "nFITS", "nBins", "nWands", "nDBITS", "nBITS", "nBis", "nLits", "nBsists", "nBbits", "nLats", " nBITS", "nCBit", "nFands", "nMBats", " nBins", " nBands", "nMBists", " nMBats", "nLITS", "nDBis", "nFats", "nMBis", "nBists", "nCBitches", " nMBITS", " nBis", "nBitches", "nMBits", " nBbits", "nLimbits", " nBats", " nFats", " nFITS", "nBands", " nFbits", "nLimits", "nFit", "nBit", "nMBins", "nWits", " nFits", "nNBists", "nLis", "nLands", " nFands", "nLimitches", " nBitches", "nBsits", " nMBits", "nDBits", "nFits", " nMBists", " nBists", " nFitches", "nNBats", "nBsats", " nMBins", "nCBits", " nBit", " nFit", "nFbits", "nMBITS", "nLins", "nNBits", "nDBins", "nWITS"], "freq": ["frequal", " freqs", "feeqs", "frequencyq", "Fredq", " frece", " fredq", "frequencyQ", "frequality", "frece", "offdq", " freQ", " frep", "speqs", "Freck", "luqs", "offqs", "Frece", "Freqi", "Freiq", "freiq", " freqq", "Freqq", "luq", "freck", " freque", "frep", "frequencyque", "luck", "speiq", "frequencyquality", "freqs", "offiq", "fredq", "speq", "speqq", "feeQ", "Freq", " freiq", "frec", "funq", " frec", "Frec", "funqual", "frequencyce", "greq", "greque", "greqs", " freqi", "feep", "Frep", " frequality", "Freqs", "freqi", "Frequal", "grequal", "freque", "Freque", "offq", " freck", "Frequality", "funqs", "freqq", "FreQ", "feeq", "freQ", "funque", "frequencyqi", "feec"], "hdec": ["Hsec", "hdesc", "ihdec", "hrec", "henc", "hdisc", " hdata", "bhenc", "bhdecl", " henc", "hdeg", "pdec", "ahseq", "shrec", "hydec", "hseq", "hldig", "hlenc", "hmrec", "herdeg", "wdec", " hdeg", " hsec", "hmdata", " hdecl", "hec", "hmdec", "phseq", "Hdata", " hdes", "phrec", "hldata", "hdiv", "hdig", "shdiv", "pdisc", "hsec", "bhdec", "hldisc", "rhdata", "hdecl", "pdesc", "phdec", "phdig", " hdiv", "shseq", "hdes", "herdec", "hlrec", "hydel", "hdata", "fdec", "hdel", "wec", "hldec", "shdig", "fseq", "shdec", "hmDec", "ahdec", "ihdecl", "HDec", "Hdec", "hldes", "hlseq", "ihdata", " hec", " hdel", "ahdata", " hDec", "hmdecl", "herec", "shdecl", " hdesc", "herdecl", "bhdes", "hydecl", "rhenc", "rhdec", "ihrec", "fdata", "Hrec", "ahdecl", "fdecl", " hdisc", "hmsec", "bhdata", "hldesc", "Hseq", "wdecl", "rhdecl", "wdeg", "Hdecl", " hrec", "hydiv", "hDec", "shdel"], "ret": ["part", "gt", "ft", "fin", "success", "fi", "data", "resp", "nt", "pat", "match", "result", "ut", "feat", "obj", "format", "rt", "att", "val", "def", "res", "pet", "db", "det", "fit", "valid", "len", "str", "al", "fun", "reply", "num", "reg", "rets", "arg", "id", "rev", "opt", "mem", "mt", "bot", "info", "ext", "status", "cat", "lit", "let", "rep", "re", "out", "RET", "flag", "back", "bit", "j", "ref", "alt", "Ret", "code"], "i": ["it", "part", "ie", "di", "gi", "chi", "ini", "iu", "mi", "fi", "multi", "li", "e", "xi", "u", "mu", "l", "pi", "abi", "uri", "si", "y", "ai", "ui", "ti", "g", "ix", "ani", "eni", "ci", "io", "mini", "bi", "qi", "ip", "ami", "oi", "phi", "x", "info", "ki", "p", "index", "ri", "ni", "f", "zi", "ind", "j", "ori", "ii", "I"]}}
{"project": "FFmpeg", "commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "target": 1, "func": "static int hevc_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}", "idx": 16203, "substitutes": {"s": ["session", "site", "tp", "v", "u", "ts", "its", "sys", "si", "in", "se", "m", "ims", "xs", "self", "n", "spec", "i", "qs", "sb", "as", "js", "services", "t", "ps", "sync", "fs", "o", "cs", "e", "parts", "ss", "y", "ssl", "new", "sq", "gs", "sf", "a", "is", "c", "sg", "ns", "lines", "settings", "bis", "less", "us", "sites", "l", "ds", "service", "this", "comm", "http", "sl", "ses", "ms", "sym", "S", "comments", "d", "rs", "south", "secondary", "full", "g", "es", "ks", "os", "ments", "ctx", "args", "p", "tests", "b", "aws", "sets", "f", "w", "r", "ls", "conf"], "lc": ["kl", "cn", "cm", "tc", "sc", "cs", "ld", "bc", "nc", "pc", "l", "cb", "si", "lu", "cc", "lex", "lr", "lb", "dl", "cus", "LC", "lp", "ci", "ctx", "ln", "fc", "acs", "c", "wl", "ns", "cli", "cl", "coll", "sl", "lv", "sb", "lf", "mc", "acl", "gb", "ls", "loc", "conn"], "ret": ["gt", "success", "reset", "resp", "pat", "sur", "val", "rf", "det", "reg", "rev", "flag", "back", "alt", "len", "part", " Ret", "nt", "match", "sat", "rt", "lt", "res", "pet", "db", " RET", "str", "error", "num", "arg", "mt", "cat", "arr", "red", "pass", "Ret", "ft", "data", "count", "result", "feat", "end", "att", "fit", "valid", "html", "al", "fun", "usr", "rets", "art", "lit", "run", "rep", "re", "py", "bit", "let", "ref", "code", "try", "pt", "base", "def", "reply", "mem", "bot", "no", "info", "RET", "rl", "err"]}}
{"project": "qemu", "commit_id": "4ed7b2c3a78f785a1bcbe575e08c379b166723e3", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char *buffer;\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 16204, "substitutes": {"fs_ctx": ["fs__ctx", "fs_local", "sf_cu", "irs__ctx", "FS_spec", "fs32cm", "sfMlc", "fs__tx", "fs_spec", "flows_cm", "fsMlocal", "FS_tx", "fs___ctx", "fs_cms", "fsMlc", "FS_conn", "sfdefctrl", "sfMctx", "fsMctx", "fs_lc", "sfdefcu", "sfMscope", "fs_cm", "irs__lc", "flows_ctx", "fs_sci", "irs_conn", "fs_xc", "fsMloc", "flows_xc", "fs___cu", "fsdefconn", "flows_tx", "fs_context", "ds_cms", "vs_local", "FS_cm", "fs_tx", "irs_ctx", "fs_cu", "irs__anc", "fsdefcu", "FS_context", "fs_gz", "fs___ctrl", "sf_ctx", "sfdefctx", "fsvalspec", "vs_wcs", "fs__anc", "fsvalcm", "fs_scope", "fsMwcs", "fsvalctx", "vs_ctx", "fs_ctrl", "fs32ctx", "fs__conn", "sf_ctrl", "irs__conn", "fs32tx", "fsdefctx", "fsvalcontext", "fs_conn", "fsdefctrl", "fs___conn", "fs_wcs", "sfMsci", "sf_conn", "sfdefconn", "fs__gz", "irs_anc", "fs__cms", "vs_loc", "fsMsci", "fsMscope", "fs__lc", "fs_loc", "fs_anc", "fs32xc", "ds_tx", "FS_ctx", "ds_gz", "irs_lc", "sf_scope", "sf_sci", "sf_lc", "ds_ctx"], "dir_path": ["dirallpath", "dir_pointer", " dir_pointer", " dir_ctx", "dirallfn", "dir_name", " dir_fn", " dir_context", "dir_ctx", "dir_context", "dirallctx", "dir_fn", "dirallcontext", " dir_name"], "name": ["prefix", "part", "file", " prefix", "content", "data", "image", "base", "size", "length", "alias", "space", "Name", "time", "comment", "url", "host", "parent", "ix", "key", "word", "block", "n", "id", "NAME", "home", "x", "info", "ext", "type", "f", "names", "filename"], "flags": ["FLAG", "prot", "ints", "includes", "files", "ports", "options", "fee", "locks", "xml", "FL", "Flags", "rules", "reads", "mask", "fl", "fts", "feat", "format", "util", "features", "ffff", "parts", "errors", "ds", "nil", "types", "links", "items", "plugins", "faces", "linux", "fps", "ips", "ils", "details", "feed", "bits", "stats", "args", "bytes", "s", "status", "tails", "lines", "vals", "frames", "lf", "flag", "utils", "xxx", "settings", "fields", "opens", "lag", "ops"], "credp": [" creditpo", "cannedu", "creds", "lcreditsv", "Credp", "Creditsp", "credm", "creditspa", "cribf", "creditpi", "crds", "cRedp", "cessp", "crdvp", "lcredpm", "cprivp", "crcs", "Crdp", "ccrowdf", "credvp", "credc", "lcrdpc", "lcreditspm", " credpo", "creditsv", "creditpo", "cannedp", "crdi", "lcredm", "ccredpa", "ccrowdpa", "Crdf", "credf", "crdpc", "cribp", "lcrdv", "cribpo", " cprivvp", "creedm", "crimf", "credi", "crdpo", "cprivpo", "cdefp", "crdp", "crimp", "creditso", "lcrdm", "lcredc", "cprivvp", " creditpi", "creedp", "credpc", " cprivp", "crcp", "creditsc", "crdpm", "lcredpc", "crowdpc", "creditspm", "creditspc", "ccedp", "cRedu", "creedc", "ccedc", "crdm", "Credf", "lcrdp", " credf", "Crds", "crsi", "cdefpc", "creedi", "cribpc", "lcredi", "crder", "lcrdc", "lcreditsc", "Crder", "cessv", "credpi", "cannedo", "ccredp", "caredc", "crowdpa", "cessc", "cesspc", "credpo", "cdefv", "cdefc", "cRedo", "credpa", "crsp", "ccredf", "creditp", "Creditsu", "crimpo", "crcf", " credpi", "cribpi", "crcer", "ccrowdp", "ccredpc", "creder", "Creds", " credc", "ccedv", "crdc", "creditsp", "Credu", "ccrowdpc", "Creditso", "creditsf", "lcrdi", " cprivpo", " creditp", "crowdp", " credvp", "Creder", "lcreditsp", "lcredp", "crowdf", "caredpo", "lcredv", "creditf", "credv", "caredvp", "crdf", "credo", "cprivc", "crsc", "Credo", " cprivc", " creditf", "credu", "crdv", "ccedpm", "cribpa", "crimpi", "credpm", "crsm", "caredp", "creditsu"], "fs": ["fp", "sync", "FS", "files", "irs", "rs", "cs", "ts", "cf", "fb", "states", "sys", "Fs", "sec", "os", "feed", "cache", "fc", "stats", "acs", "ns", "vals", "f", "settings", "ls", "fw"], "path": ["prefix", "enc", "file", "route", "content", "temp", "Path", "data", "user", "source", "mode", "draft", "image", "dir", "fn", "inner", "pattern", "length", "size", "password", "uri", "alias", "resource", "transform", "object", "root", "directory", "time", "url", "config", "parent", "host", "location", "channel", "key", "method", "self", "id", "PATH", "cache", "feed", "context", "home", "node", "pointer", "c", "p", "ath", "mount", "child", "port", "loader", "stream", "buf", "entry", "text", "pass", "loc", "code"], "fullname": ["fullName", "flatword", "fullpath", "fullyname", "shortsize", "fullkey", "flattext", "Fullname", "Fullsize", "flatstart", "shortName", "fullykey", "fullypath", " fullpath", "flatpath", "FullName", " fullsize", "fullnumber", "fullstart", "fullystart", "fullynumber", "shortpath", "Fullpath", "fullyword", "flatname", "fultext", "fulltext", "flatkey", "shortname", "fulkey", " fullName", " fullstart", "fulname", "fullword", "flatnumber", " fullnumber", "fullytext", "fullsize", "fulword"], "buffer": ["fp", "address", "uf", "cb", "flash", "token", "writer", "callback", "limit", "channel", "seek", "window", "reference", "Buffer", "entry", "stack", "batch", "available", "position", "seed", "image", "copy", "delay", "resource", "timeout", "header", "queue", "offset", "slice", "fd", "pool", "handler", "cache", "shell", "input", "memory", "buf", "filename", "binary", "iter", "file", "FFER", "data", "result", "message", "area", "size", "bin", "uffer", "attr", "bar", "comment", "byte", "profile", "fr", "buff", "table", "stream", "text", "document", "reader", "texture", "source", "base", "length", "server", "page", "pad", "wave", "ptr", "url", "player", "feed", "layer", "device", "b", "f", "port", "loader", "transfer", "function"]}}
{"project": "FFmpeg", "commit_id": "63d6a6b91e4997737905bbd2cf5970ad90a31869", "target": 1, "func": "static void fix_coding_method_array (int sb, int channels, sb_int8_array coding_method)\n\n{\n\n    int j,k;\n\n    int ch;\n\n    int run, case_val;\n\n    int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4};\n\n\n\n    for (ch = 0; ch < channels; ch++) {\n\n        for (j = 0; j < 64; ) {\n\n            if((coding_method[ch][sb][j] - 8) > 22) {\n\n                run = 1;\n\n                case_val = 8;\n\n            } else {\n\n                switch (switchtable[coding_method[ch][sb][j]]) {\n\n                    case 0: run = 10; case_val = 10; break;\n\n                    case 1: run = 1; case_val = 16; break;\n\n                    case 2: run = 5; case_val = 24; break;\n\n                    case 3: run = 3; case_val = 30; break;\n\n                    case 4: run = 1; case_val = 30; break;\n\n                    case 5: run = 1; case_val = 8; break;\n\n                    default: run = 1; case_val = 8; break;\n\n                }\n\n            }\n\n            for (k = 0; k < run; k++)\n\n                if (j + k < 128)\n\n                    if (coding_method[ch][sb + (j + k) / 64][(j + k) % 64] > coding_method[ch][sb][j])\n\n                        if (k > 0) {\n\n                           SAMPLES_NEEDED\n\n                            //not debugged, almost never used\n\n                            memset(&coding_method[ch][sb][j + k], case_val, k * sizeof(int8_t));\n\n                            memset(&coding_method[ch][sb][j + k], case_val, 3 * sizeof(int8_t));\n\n                        }\n\n            j += run;\n\n        }\n\n    }\n\n}\n", "idx": 16205, "substitutes": {"sb": ["binary", "bm", "sv", "nn", "jam", "cn", "zb", "sit", "phys", "jp", "cm", "sc", "obj", "bc", "cb", "ib", "fb", "obb", "ob", "sys", "stab", "si", "SB", "kr", "java", "db", "machine", "inst", "sf", "lb", "hw", "sn", "sem", "frame", "ym", "config", "bh", "g", "shop", "rb", "fr", "nb", "usb", "buff", "sh", "bp", "cp", "uv", "s", "bb", "cod", "component", "b", "sk", "src", "abb", "bj", "zh", "eb", "ub", "buffer", "gb", "sth", "conn", "array", "jc", "codes", "code"], "channels": ["chores", "schannels", "cannels", "Chords", "schunks", "echannels", "Chapters", "canes", "echapters", " chunks", "schores", "chunks", " chores", "Channels", "schanes", "chords", " chanes", "chapters", " chapters", "echords", "cunks", "cores", " chords", "chanes"], "coding_method": ["coder_method", "coding_round", "coding2function", "code_table", "coding2array", "coder_record", "coding_condition", "coder_format", "coding___function", "coding_array", "coder_code", "coding_format", "coding_table", "coding_record", "code_round", "coding2model", "coder_function", "coding___num", "coder_condition", "coding_call", "codingbookformat", "coding_function", "codingbookfunction", "coding2round", "coding2method", "coding_code", "coder_array", "code_array", "coding_model", "codingbookmethod", "coder_model", "coder_call", "coding___method", "codingbookarray", "coder_num", "coding2table", "coding_num", "coding___code", "code_method"], "j": ["it", "adj", "d", "ie", "o", "dj", "jam", "J", "jan", "jp", "v", "li", "jl", "br", "e", "obj", "l", "ock", "job", "note", "y", "m", "vision", "el", "jo", "jen", "aj", "pr", "un", "z", "jj", "jet", "n", "fr", "ik", "block", "ju", "boot", "kj", "qi", "x", "c", "i", "q", "h", "ji", "ij", "p", "jon", "b", "f", "ind", "bj", "js", "oj", "uj", "jit", "ja", "jc", "key", "code"], "k": ["d", "o", "ky", "ok", "v", "kin", "kick", "e", "u", "kat", "l", "work", "kn", "kr", "y", "m", "dk", "ek", "unk", "kid", "ke", "g", "ck", "key", "z", "ks", "n", "ik", "K", "c", "q", "i", "x", "uk", "h", "ki", "p", "kk", "ak", "km", "b", "kw", "ack", "f", "row", "w", "kg", "ko", "r", "ku", "mk", "ka", "sk"], "ch": ["chip", "chart", "v", "cf", "cb", "cher", "chn", "chan", "channel", "un", "n", "cham", "che", "sh", "h", "i", "col", "cy", "ver", "chu", "conn", "batch", "arch", "cmd", "ht", "chy", "y", "machine", "inst", "_", "hw", "ich", "cor", "c", "cod", "th", "chal", "jp", "count", "ry", "con", "cho", "l", "gh", "bh", "buff", "q", "ph", "zh", "cht", "cell", "sk", "code", "ach", "chi", "cm", "br", "el", "form", "cha", "sch", "ci", "ctx", "change", "Ch", "cand", "cp", "p", "core", "range", "b", "f", "conf"], "run": ["ain", "month", "exec", "kin", "pos", "work", "race", "in", "group", "m", "reg", "un", "man", "n", "boot", "start", "min", "cr", "len", "move", "sync", "batch", "Run", "record", "loop", "match", "use", "play", "job", "db", "tag", "mod", "num", "view", "block", "id", "node", "x", "c", "pass", "ran", "rule", "runs", "ru", "route", "end", "head", "model", "round", "runner", "mix", "unit", "fun", "rc", "rain", "key", "lock", "win", "q", "clean", "type", "order", "name", "call", "day", "ann", "d", "step", "thread", "ro", "config", "g", "ron", "read", "no", "index", "core", "inc", "row", "kg", "r", "rank", "loc", "running"], "case_val": ["caseFel", "ase_value", "case_VAL", "case__key", "case_aval", "ase_cal", "case___value", "caseevol", "case__val", "caseFvals", "case_bal", " case_eval", "choice_val", "case_key", "case_la", "ase_label", "case___la", "case7val", "case7vals", "choice___value", "choice___la", "ase_val", "case7aval", "case_label", " case_value", "case67label", "case_vals", "case__el", "case__vals", " case_aval", "case_cal", "caseerval", "case67vals", " case_VAL", " case_vals", "ase_vals", "case_eval", " case_rot", "choice___eval", "caseFval", "choice_value", "case_vol", "ase_eval", "caseevalue", " case_bal", "choice_eval", "case_value", "caseecal", "caseeval", " case_el", "caseervals", "case_el", "caseerrot", "case67value", "choice___val", "case67val", " case_key", "case_pos", "caseerVAL", "ase_vol", "case___eval", "choice_la", "case_rot", " case_pos", "caseFkey", "case7eval", "case___val"], "switchtable": ["switchrule", " switchrule", "callarray", "callTable", "changetable", "callinterface", "changeTable", "caseTable", "changeinterface", "jumprule", "jumpTable", "casetable", "switchTable", "testarray", "testTable", "testinterface", "switcharray", "testtable", "jumptable", "changearray", " switchTable", "caserule", "switchinterface", "calltable"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 16207, "substitutes": {"ctx": ["fp", "client", "sync", "ct", "cn", "cgi", "exec", "cu", "jp", "la", "cm", "sc", "cs", "nc", "bc", "obj", "sci", "pkg", "cf", "pc", "cmd", "gpu", "qa", "anc", "gc", "Context", "cc", "ga", "cmp", "hw", "lc", "config", "rc", "cca", "ck", "cus", "wx", "vc", "ci", "ch", "np", "fc", "context", "c", "cp", "cli", "cl", "component", "cpu", "ctrl", "tx", "src", "cr", "crit", "ca", "css", "gru", "wcs", "que", "xc", "loc", "conn", "cms", "cas", "cv"]}}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "substitutes": {"p": ["ps", "d", "o", "pe", "tp", "jp", "data", "v", "patch", "po", "per", "pat", "e", "u", "ap", "op", "process", "pc", "l", "pi", "P", "pp", "post", "wp", "m", "sp", "a", "proc", "pr", "g", "pre", "lp", "point", "n", "parent", "pa", "c", "bp", "q", "cp", "b", "f", "port", "j", "r", "t", "pb"], "sgl": ["chesgb", "sGL", "ansgb", "opsdl", "wsdl", "wsplay", "sysgl", "chesgel", "sglobal", "sgn", "fsgel", "sslu", "sysdl", "chesgl", " splay", "anslu", "cheslam", "fsgb", "splay", " sGl", " sbl", " sglobal", "ssl", "sbl", "sGl", "sysplay", "opsbl", " sgn", "fslam", " ssl", "sgb", "sysGL", "opsgl", " slam", "ansgl", " slu", "wsGL", "fsgl", " sGL", "ansbl", "slam", "pssl", "sgel", "psGl", "ssgl", "sdl", "wsgl", " sdl", " sgb", " sgel", "psglobal", "ssbl", "slu", "ssgb", "psgl", "opsgn"], "len": ["part", "en", "ie", "lan", "le", "fin", "afi", " length", "bl", "fi", "lif", "data", "split", "la", "li", "ll", "Len", "pos", "fl", "ld", "count", "del", "l", "length", "base", "size", "den", "val", "lon", "lu", "cap", "lic", "lex", "el", "limit", "label", "str", "seq", "lin", "lc", "lim", "num", "dl", "fun", "z", "n", "lock", "low", "id", "rev", "ln", "ell", "ler", "line", "lib", "lit", "il", " l", "f", "ni", "lf", "min", "name", "pl", "gen", "err", "lang", "non"], "mem": ["mm", "mp", "le", "alloc", "mi", "fi", "temp", "lif", "data", "vm", "la", "Mem", "med", "l", "base", "size", "val", "job", "bin", "lex", "m", "sp", "el", "mob", "mo", "em", "hw", "pool", "fun", "lim", "num", "g", "reg", "me", "cache", "buff", "ip", "rm", "memory", " Mem", "home", "dem", "mac", "cpu", "device", "f", "ram", "name", "lf", "mb", "mor", "buffer", "nm", "buf", "loc", "ref", "conn", "ann", "wa"], "i": ["it", "ini", "v", "u", "pi", "val", "si", "in", "m", "ui", "limit", "api", "ix", "n", "ni", "j", "ii", "t", "I", "adi", "en", "ie", "o", "all", "li", "e", "mu", "abi", "y", "ti", "eni", "iv", "id", "bi", "qi", "ip", "x", "c", "phi", "hi", "ri", "ori", "yi", "di", "gi", "fi", "multi", "l", "ai", "io", "ami", "zi", "d", "iu", "mi", "xi", "base", "uri", "el", "z", "ci", "oi", "info", "ki", "index", "s", "cli", "b", "f", "err", "r"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n", "idx": 16216, "substitutes": {"ibs": ["iamS", "ipn", "IBs", "ibds", "ipin", "iws", "pubo", "ipds", "ipo", "iwm", " ibm", "iwin", "bbs", "bbsys", "iamds", "ibsys", "pubs", "iwn", "ibo", "IBS", "IBo", "iams", "bbS", "ipsys", "ips", "bbds", "ibn", " ibin", "ipS", "ipm", "ibin", "ibm", " ibn", "iamsys", "pubS", "ibS"], "cmd": ["pipe", "client", "module", "route", "nd", "dom", "md", "count", "mode", "command", "force", "op", "pkg", "cd", "cfg", "cb", "cf", "Cmd", "bind", "path", "dc", "grad", "frame", "seq", "config", "chan", "ck", "comm", "id", "ctx", "init", "c", "input", "args", "dict", "mac", "cp", "clean", "cod", "req", "cl", "cat", "ctrl", "MD", "gen", "crit", "msg", "ind", "kg", "buf", "conn", "gn", "code"], "cmd_len": ["cmd2val", " cmd_l", "cmdslen", "cmdslength", " cmd_length", "cmd2l", " cmdsval", "cmd_val", " cmdslength", "cmdsl", "cmd2length", "cmd_length", "cmd2len", " cmdsl", "cmd_l", " cmd_val", "cmdsval", " cmdslen"], "rsp": [" rpc", " resp", "srsc", "Rp", "rst", "resp", " rserv", "rpc", "Rsp", "rrst", " rp", "rrsp", "srsp", "rrserv", "rresp", "srp", "srserv", "rserv", " rst", "sresp", "srst", "Rsc", "Rpc", " rsc", "rp", "srpc", "rsc"], "rsp_len": ["rsc_Len", "rsc_len", "rsp_Len", "rsp_limit", "rsc_length", "rsc_limit", "rsp_length"], "max_rsp_len": ["max_rsp_l", "max_rsc_count", "max_rsc_l", "max_rsp_length", "max_rsc_len", "max_rsc_length", "max_rsp_count"], "sens": ["denses", "Senses", "pents", "tensor", "pigs", "fensor", "foss", "sents", "tents", "Sens", " sets", "fENS", "syncensor", "fenses", "dets", "tens", "fens", "slener", "tets", "serENS", "slets", "serens", " sENS", "dENS", "slENS", "symENS", "senses", "sigs", " sps", "pENS", "symensor", "symener", "sENS", " sents", "Sensor", "sensor", "tener", "senders", "gener", "densor", "gENS", "slenses", "syncens", "syncENS", " sensor", "gents", "dens", "pens", "sps", "pets", "serigs", "pener", "dents", " senses", "Soss", "Sents", "serener", "sets", " soss", "tENS", "sener", "genders", "gps", "sligs", "gensor", "soss", "fents", "Sps", "syncenders", " senders", "symens", "gens", "slens"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])\n\n{\n\n    int i;\n\n    if (s->chroma_format == CHROMA_444) {\n\n        encode_block(s, block[0], 0);\n\n        encode_block(s, block[2], 2);\n\n        encode_block(s, block[4], 4);\n\n        encode_block(s, block[8], 8);\n\n        encode_block(s, block[5], 5);\n\n        encode_block(s, block[9], 9);\n\n\n\n        if (16*s->mb_x+8 < s->width) {\n\n            encode_block(s, block[1], 1);\n\n            encode_block(s, block[3], 3);\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[10], 10);\n\n            encode_block(s, block[7], 7);\n\n            encode_block(s, block[11], 11);\n\n        }\n\n    } else {\n\n        for(i=0;i<5;i++) {\n\n            encode_block(s, block[i], i);\n\n        }\n\n        if (s->chroma_format == CHROMA_420) {\n\n            encode_block(s, block[5], 5);\n\n        } else {\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[5], 5);\n\n            encode_block(s, block[7], 7);\n\n        }\n\n    }\n\n}\n", "idx": 16227, "substitutes": {"s": ["enc", "session", "site", "v", "u", "ts", "its", "states", "sys", "si", "an", "se", "m", "ui", "plugins", "xs", "self", "sup", "n", "spec", "sh", "qs", "sb", "as", "js", "services", "t", "ps", "sync", "fs", "en", "o", "cs", "e", "ions", "ss", "y", "ssl", "sq", "gs", "sf", "a", "is", "c", "x", "sg", "ns", "lines", "settings", "stat", "bis", "less", "us", "sites", "com", "styles", "l", "ds", "service", "this", "http", "ses", "ms", "S", "ops", "d", "rs", "south", "params", "bs", "g", "es", "ks", "k", "os", "su", "info", "p", "b", "aws", "sets", "f", "w", "ls", "r", "conf", "support"], "block": ["module", "month", "check", "list", "filter", "link", "patch", "pos", "obj", "join", "work", "val", "group", "map", "label", "seq", "box", "bytes", "set", "none", "sync", "batch", "um", "shift", "record", "image", "str", "error", "num", "view", "word", "keep", "id", "ip", "line", "off", "arr", "buffer", "chain", " Block", "bl", "data", "model", "bin", "blocks", "shape", "cap", "object", "mix", "comment", "unit", "byte", "pre", "key", "lock", "clean", "ban", "type", "plugin", "name", "bit", "panel", "pull", "base", "style", "page", "def", "post", "full", "frame", "point", "Block", "tick", "no", "cl", "index", "row", "loc", "number", "pack"], "i": ["it", "d", "o", "di", "gi", "ini", "iu", "mi", "fi", "split", "multi", "h", "li", "v", "e", "xi", "u", "mu", "l", "pi", "abi", "uri", "si", "y", "in", "ai", "ui", "q", "a", "ti", "k", "ix", "z", "n", "io", "ci", "id", "bi", "init", "is", "ip", "c", "qi", "ami", "info", "ji", "phi", "x", "oi", "ri", "hi", "b", "p", "index", "ni", "f", "zi", "j", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 16237, "substitutes": {"ctx": ["client", "sync", "qq", "cn", "exec", "jp", "cm", "sc", "cs", "pkg", "bc", "sci", "obj", "cf", "cmd", "cb", "qa", "cc", "cmp", "grad", "sq", "hw", "sem", "rc", "config", "cca", "ci", "context", "c", "mac", "comp", "cp", "ctrl", "tx", "src", "ca", "std", "xc", "loc", "conn", "cas", "cv"], "pte1p": ["pte2f", "ptee1point", "pte2b", "ptee3s", "ptee1c", "pte11p", "ptee1f", "pte001p", "pte1b", "pte2c", "pte0c", "ptee2p", "ptec6p", "ptee3f", "pte2point", "pte01f", "ptea001p", "pte001point", "ptea1p", "ptee1p", "pte6c", "pte001c", "pte6s", "pte6fp", "ptee3c", "pte1c", "pte0l", "ptee2point", "pte11f", "pte5fp", "ptee3p", "pte6sp", "pte3c", "pte1e", "ptec1fp", "ptee1s", "ptec1sp", "pte11b", "ptea001c", "pte01point", "pte6e", "pte3l", "pte1s", "pte1f", "pte3point", "ptec6sp", "pte5f", "pte2s", "ptea1point", "pte6p", "pte251p", "pte3s", "ptec6e", "pte0p", "pte1fp", "pte3f", "pte001l", "ptee2c", "pte5c", "pteonef", "ptee2b", "pte5sp", "ptec1p", "ptec1e", "ptec6fp", "pteoneb", "pte251e", "ptea1c", "pte5p", "pte251sp", "pte6f", "ptea1l", "pte251fp", "pte0point", "pte01c", "ptee1b", "pte1point", "pte1l", "pteonep", "pte1sp", "pte01p", "ptee2f", "pte5point", "pte2p", "pte3p", "ptea001point", "pte5e", "ptea001l"], "ret": ["gt", "ft", "route", "success", "pat", "resp", "nt", "ry", "match", "result", "store", "rest", "feat", "rt", "att", "sur", "val", "def", "pet", "rf", " RET", "offset", "reply", "nat", "reg", "rets", "ext", "re", "RET", "flag", "rl", "back", "bit", "ref", "alt", "Ret"], "rw": ["route", "rd", "adr", "feat", "rh", "raf", "rt", "wb", "our", "ro", "rf", "attr", "rack", "lr", "reply", "ride", "rr", "rc", "usr", "wx", "rb", "rec", "rue", "rss", "rx", "sw", "RW", "sr", "w", "rl", "rn", "rg", "nw", "fw", "wrap", "rus", "wk"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n", "idx": 16246, "substitutes": {"s": ["sync", "fs", "o", "session", "rs", "ssh", "south", "private", "secondary", "e", "server", "ds", "sys", "ss", "ssl", "service", "sq", "sf", "g", "stats", "c", "http", "ns", "p", "b", "f", "sb", "ses", "js", "port", "settings", "stat", "services", "sym", "S", "t", "ops"], "bsel": ["bbsel", "cbsell", "bbsell", "fbsel", " bsl", "lbsel", "cbsl", " bsell", "lbsl", "bbsels", "bsl", "fbsell", "bbsl", "cbsels", "bsell", "cbsel", "lbsell", "fbsl", "fbsels", "bsels", "lbsels", " bsels"], "slot": ["not", "serv", "lot", "session", "hide", "shot", "pot", "loop", "nit", "token", "spot", "pixel", "service", "offset", "slice", "sec", "rot", " slots", "role", "zo", "boot", "second", "trial", "zone", "layout", "vol", "sl", "hole", "antine", " Slot", "disabled", "option", "bit", "socket", "sector", "lo", "Slot", "rol"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n", "idx": 16255, "substitutes": {"dst": ["Dsrc", "sdrc", "Dsc", "Dst", "dsrc", " drc", "sdsrc", " dsp", "fdst", "fdsp", "fdsrc", "Dsp", "sdst", " dsrc", "drc", "fdrc", "sdsc", "dsc", " dsc", "Drc", "dsp"], "src": ["sync", "d", "source", "sc", "dist", "st", "ffff", "use", "cb", "sel", "sur", "slice", "inst", "bg", "sec", "url", "rc", "config", "supp", "sub", "rb", "sup", "rec", "low", "cur", "fc", "i", "b", "sl", "sr", "sb", "rate", "gb", "r", "loc", "img", "dest"], "stride": ["bride", "tride", "Strd", "brade", "arrode", "hrd", "divided", "dride", " strd", " str8", "Stride", "strade", "str8", "Strides", " strider", "arrade", "dr8", "strided", "strode", "hride", "hrided", "trside", "Strided", "arrided", "strd", "trided", "divide", "strides", "trides", " strade", "brode", "arride", "brided", "Strider", " strided", " strode", "drided", "strside", "strider", " strides", "drade", "div8", "hrider", "Strside", "divade", " strside"]}}
{"project": "FFmpeg", "commit_id": "6221e2478c593a0ce1183eed929cb2101dbf5265", "target": 0, "func": "int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,\n\n                   void *log_ctx)\n\n{\n\n    char *tail, color_string2[128];\n\n    const ColorEntry *entry;\n\n    int len, hex_offset = 0;\n\n\n\n    if (color_string[0] == '#') {\n\n        hex_offset = 1;\n\n    } else if (!strncmp(color_string, \"0x\", 2))\n\n        hex_offset = 2;\n\n\n\n    if (slen < 0)\n\n        slen = strlen(color_string);\n\n    av_strlcpy(color_string2, color_string + hex_offset,\n\n               FFMIN(slen-hex_offset+1, sizeof(color_string2)));\n\n    if ((tail = strchr(color_string2, ALPHA_SEP)))\n\n        *tail++ = 0;\n\n    len = strlen(color_string2);\n\n    rgba_color[3] = 255;\n\n\n\n    if (!av_strcasecmp(color_string2, \"random\") || !av_strcasecmp(color_string2, \"bikeshed\")) {\n\n        int rgba = av_get_random_seed();\n\n        rgba_color[0] = rgba >> 24;\n\n        rgba_color[1] = rgba >> 16;\n\n        rgba_color[2] = rgba >> 8;\n\n        rgba_color[3] = rgba;\n\n    } else if (hex_offset ||\n\n               strspn(color_string2, \"0123456789ABCDEFabcdef\") == len) {\n\n        char *tail;\n\n        unsigned int rgba = strtoul(color_string2, &tail, 16);\n\n\n\n        if (*tail || (len != 6 && len != 8)) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid 0xRRGGBB[AA] color string: '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if (len == 8) {\n\n            rgba_color[3] = rgba;\n\n            rgba >>= 8;\n\n        }\n\n        rgba_color[0] = rgba >> 16;\n\n        rgba_color[1] = rgba >> 8;\n\n        rgba_color[2] = rgba;\n\n    } else {\n\n        entry = bsearch(color_string2,\n\n                        color_table,\n\n                        FF_ARRAY_ELEMS(color_table),\n\n                        sizeof(ColorEntry),\n\n                        color_table_compare);\n\n        if (!entry) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Cannot find color '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        memcpy(rgba_color, entry->rgb_color, 3);\n\n    }\n\n\n\n    if (tail) {\n\n        unsigned long int alpha;\n\n        const char *alpha_string = tail;\n\n        if (!strncmp(alpha_string, \"0x\", 2)) {\n\n            alpha = strtoul(alpha_string, &tail, 16);\n\n        } else {\n\n            alpha = 255 * strtod(alpha_string, &tail);\n\n        }\n\n\n\n        if (tail == alpha_string || *tail || alpha > 255) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid alpha value specifier '%s' in '%s'\\n\",\n\n                   alpha_string, color_string);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        rgba_color[3] = alpha;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16256, "substitutes": {"rgba_color": ["rgba_style", "rgba__parent", "rgaba_token", "rgbo_color", "rgbon_with", "rgba2color", "rgba64colour", "rgga_colour", "rgba__color", "rgba4pixel", "rgba_private", "rgva_private", "rgba_size", "rgpa_blue", "rgba4or", "rgbon4with", "rgba_blue", "rgbo2source", "rgba_pixel", "rgba2or", "rgva_or", "rgba2number", "rgaba_parent", "rgba_number", "rgba4color", "rgba_token", "rgva_colour", "rgba__pixel", "rgbon_or", "rgva_option", "rgva_size", "rgba_option", "rgba_parent", "rgpa_size", "rgba4with", "rgaba_color", "rgba2pixel", "rgba_string", "rgbo_size", "rgbo2line", "rgba_or", "rgba2line", "rgva_style", "rgba_source", "rgama_white", "rgba64color", "rgama_or", "rgama_color", "rgbo2number", "rgba64number", "rgga_token", "rgpa_string", "rgba64size", "rgga_author", "rgba_author", "rgga_color", "rgba2white", "rgva_color", "rgba_colour", "rgpa_color", "rgba__token", "rgbon4color", "rgba_with", "rgba_white", "rgbon_pixel", "rgba2size", "rgba2colour", "rgaba_pixel", "rgbon4or", "rgbo_source", "rgba_line", "rgbo2color", "rgbon4pixel", "rgbo_line", "rgbo_number", "rgama_colour", "rgbo_colour", "rgva_pixel", "rgbon_color", "rgba2source"], "color_string": ["color2section", "colorablestring", "colour_format", "colorgformat", "color_text", "coloringclass", "color_section", " color_class", " color_section", "color_space", "colorgstring", "colorableclass", "colour2string", "coloringstr", "color2str", "color_class", "coloringstrings", "color_str", " color_uri", "coloracstring", "color_number", "color_uri", "colour_str", "colour_section", "colour_string", "colour_length", "colour2section", " color_strings", "colorablestrings", "color_format", "color_letter", "coloringsection", "colorqsection", "colour2str", " color_number", "coloracletter", "color_length", "colorqstr", "colorglength", "colorablesection", "color2length", "coloringlength", "colorgtext", "coloracspace", "color2string", "coloracstrings", "coloringstring", "colorqstring", "colorqlength", "color_strings", " color_letter", "colour_text", "colour2length", " color_space"], "slen": ["clend", "swen", "lEN", "splEN", "lain", " slatten", "clenn", " sllen", "clen", "slens", "lenc", "sslatten", " slz", "selenn", "sslz", "slot", " slain", "splen", "silen", "slenn", "clz", "slend", "mlen", "sllen", "silot", "silenn", "selen", "sslens", " slEN", "lens", "mllen", "swens", "swenc", "slain", "spllen", "slEN", "sslen", "slz", " slens", "slatten", "swlen", "silend", "llen", "selot", "clot", "splain", "clatten", "mlens", "clens", "slenc", "mlenc", "selend"], "log_ctx": ["log_loc", "logvalsection", " log_scope", "logFdata", "loglogctx", " log_section", "log_section", "logvalctx", "log_scope", "error_loc", "loglogscope", "logFctx", "error_ctx", "logFcontext", "error_context", "loglogcontext", "loglogsection", "logFloc", "logvalcontext", "logvalscope", " log_context", "log_data", "log_context", "error_data"], "tail": ["body", "prefix", "test", "lead", "pull", "letter", "thread", "li", "ill", "ll", "tc", "match", "split", "rest", "end", "pattern", "head", "length", "size", "align", "style", "nil", "timeout", "alt", "token", "fat", "tag", "padding", "limit", "offset", "det", "comment", "tip", "ignore", "unit", "lc", "lock", "stop", "weight", "ul", "wl", "margin", "ail", "target", "index", "color", "col", "sign", "tails", "foot", "run", "suff", "wrap", "start", "name", "il", "ind", "term", "conn"], "color_string2": ["color_section4", "color_pair2", "color_array1", "color_text1", "color_section2002", "color_object1", "color_name2", "color_strings2002", "color_array4", "color_strings0", "color_function8", "color_number0", "color_stream2002", "color_int2", "color_str2", "color_stringsII", "color_object2", "color_section2", "color_string1", "color_stream1", "color_nameTwo", "color_name1", "color_strings1", "color_letterTwo", "color_strSecond", "color_letterDB", "color_seriesTwo", "color_string4", "color_text2", "color_seriescopy", "color_strings2", "color_config1", "color_string2002", "color_stringsDB", "color_stringsSecond", "color_series2", "color_pair8", "color_version2", "color_string0", "color_int1", "color_strings4", "color_result1", "color_string20", "color_version1", "color_string6", "color_seriesDB", "color_stringscopy", "color_version20", "color_letter2", "color_number4", "color_str20", "color_intII", "color_stringcopy", "color_str1", "color_array2", "color_function1", "color_sectionTwo", "color_letter1", "color_pair1", "color_function6", "color_series1", "color_result2", "color_stream2", "color_versionSecond", "color_numberTwo", "color_strings6", "color_objectcopy", "color_stringTwo", "color_stringsTwo", "color_string8", "color_stringDB", "color_config2", "color_sourceTwo", "color_streamTwo", "color_strings20", "color_source2", "color_pair6", "color_number1", "color_stringSecond", "color_source1", "color_function2", "color_section1", "color_pair4", "color_stringII", "color_number2", "color_pair0", "color_configII", "color_strings8"], "entry": ["ries", "ie", "dr", "card", "data", "letter", "try", "Entry", "la", "ge", "ry", "count", "match", "image", "result", "expr", "mer", "si", "tri", "ent", "insert", "quad", "import", "parse", "parent", "sub", "her", "id", "feed", "line", "info", "set", "ident", "color", "cat", "member", "row", "name", "or", "term", "value", "cell", "array", "code"], "len": ["en", "ie", "lan", "le", "fin", "all", "split", "nt", "li", "ll", "Len", "pos", "fl", "fn", "count", "end", "l", "length", "rel", "size", "lt", "val", "lon", "el", "limit", "offset", "elt", "lin", "lc", "lim", "dl", "z", "n", "ln", "line", "ler", "lit", "sl", "il", "name", "min", "lf", "ind", "inn", "dy", "non", "loc", "span"]}}
{"project": "qemu", "commit_id": "22d5cd82e98b61b1dbd791fab9f4ae0f77c0ed14", "target": 0, "func": "static int raw_inactivate(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    uint64_t perm = 0;\n\n    uint64_t shared = BLK_PERM_ALL;\n\n\n\n    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);\n\n    return 0;\n\n}\n", "idx": 16274, "substitutes": {"bs": ["fs", "sync", "ba", "ocks", "ins", "bl", "rs", "cs", "sa", "bc", "obj", "cb", "base", "ds", "bes", "blocks", "ss", "ec", "bos", "BS", "gs", "bh", "ks", "ubs", "fps", "os", "iss", "bits", "vs", "s", "bb", "ns", "qs", "bps", "b", "src", "sb", "ses", "js", "las", "gb", "ls", "lbs", "bis", "pb", "css"], "ret": ["en", "ft", "fin", "af", " Ret", "success", "tmp", "data", "nt", "bf", "pat", "repl", "match", "result", "rt", "fab", "base", "att", "val", "alt", "def", "res", "pet", "det", "reply", "valid", "fun", "rc", "pre", "reg", "rets", "id", "rev", "cur", "art", "ext", "active", "req", "cat", "lit", "re", "out", "RET", "flag", "red", "pred", "std", "back", "bit", "xt", "ref", "len", "Ret", "code"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n", "idx": 16276, "substitutes": {"v": ["d", "sv", "o", "ev", "var", "e", "u", "V", "l", "vi", "tv", "m", "vt", "volt", "g", "k", "inv", "gu", "iv", "c", "q", "i", "x", "vs", "uv", "p", "b", "va", "f", "lv", "w", "vim", "vp", "j", "r", "value", "env", "t", "vis"], "name": ["prefix", "part", "o", "data", "named", "nam", "base", "style", "alias", "path", "object", "attr", "Name", "label", "time", "comment", "parent", "key", "word", "self", "n", "ame", "id", "NAME", "x", "info", "ext", "type", "f", "w", "names", "nm", "j", "filename", "none", "null"], "obj": ["obo", "prefix", "part", "adj", "o", "nn", "tmp", "office", "data", "po", "pos", "fn", "pt", "oa", "orb", "output", "obb", "cb", "Object", "ob", "val", "object", "objects", "attr", "api", "inst", "elt", "bs", "aj", "emb", "pr", "n", "os", "ctx", "nb", "so", "x", "art", "args", "ext", "b", "Obj", "arr", "sb", "bj", "js", "otype", "j", "ref", "eff", "alt", "ops", "code"], "errp": ["erfp", "erpo", "rrfp", "errfp", "rrp", "nerpo", "rrpo", "erp", "errpo", "nerfp", "nerp"], "qov": ["ckov", "quov", " qOV", "ckvo", "qoyer", "ckob", "Qvo", "qove", "qOV", "qob", "Qoo", "ckove", "quOV", "Qov", "qoo", "Qove", "quoo", " qvo", " qoyer", " qove", "qvo", " qob", " qoo", "QOV", "quoyer", "Qob", "Qoyer"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static int setup_sigcontext(struct target_sigcontext *sc,\n\n                            CPUSH4State *regs, unsigned long mask)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n#define COPY(x)         __put_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[0]); COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __put_user(regs->fpscr, &sc->sc_fpscr);\n\n    __put_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    /* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n\n\n    return err;\n\n}\n", "idx": 16281, "substitutes": {"sc": ["enc", "sync", "usc", "com", "oc", "exec", "cont", "tc", "cs", "nc", "bc", "sci", "pc", "desc", "cf", "scl", "anc", "ec", "cc", "dc", "ga", "uc", " Sc", "sec", "Sc", "rc", "lc", "cca", "sub", "cus", "go", "org", "ch", "asc", "osc", "spec", "cur", "sh", "c", "SC", "cl", "scope", "cli", "sw", "inc", "isc", "src", "cr", "pl", "ca", "esc", "sche", "loc", "cv"], "regs": ["regis", "regS", "registersb", "regqs", "gregsi", "rogss", "gramis", "aggs", "REGstates", "regss", "grams", "regns", "regsets", "registerqs", "accountsb", " regqs", "accountns", "rogns", "REGs", " regstates", "aggqs", "accounts", "gregs", " regS", "logsets", "REGS", "rogs", "registers", "logs", "gramp", "aggsets", " regsets", "gregis", "gramss", "regsb", "regsi", "rogsb", "gregss", "logqs", "rogp", "registerns", "gregstates", "regp", "REGsi", "rogis", "accountqs", "gregp", "gregS", " regsi", "rogqs", "regstates"], "mask": ["gate", "prefix", "clear", "bug", "arch", "filter", "patch", "match", "ask", "fix", "pattern", "work", "delay", "Mask", "alias", "pad", " Mask", "depth", "root", "map", "comment", "scale", "ix", "skip", "lock", "ch", "bits", "weight", "mac", "scan", "ban", "ma", "wait", "flags", "flag", "diff", "bit", "pass", "sum", "conf", "sk"], "i": ["it", "part", "d", "ie", "di", "o", "gi", "my", "chi", "ini", "mi", "fi", "iu", "x", "v", "li", "count", "e", "xi", "result", "ip", "u", "mu", "l", "pi", "abi", "uri", "si", "in", "counter", "y", "ai", "m", "ui", "a", "error", "ti", "ix", "z", "k", "n", "eni", "io", "id", "mini", "ci", "init", "bi", "is", "qi", "c", "ami", "oi", "hi", "ji", "phi", "p", "index", "info", "ri", "b", "ver", "ni", "f", " err", "zi", "r", "j", "ii", "I", "yi"]}}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293, "substitutes": {"vdev": ["bprof", "vdraft", " vver", "svdev", "wdev", "vserver", " vrad", "vdiv", "vpack", " vdevice", "hver", "svev", "Vdev", "ldd", "bver", "svdb", "svserver", "nvdb", "verror", "vdb", " vvar", "svpub", "svdraft", "wpub", "vde", "lrad", " vde", "nvev", "wdiv", "svver", "lvdevelopment", "vdevelopment", "lev", "hdev", "vapp", "wdd", "nverror", "nvdev", "ivde", "svneg", "vver", "hev", "svdevelopment", "sverror", "nvserver", "Vserv", "svvar", "varserver", "Vdiv", "ivgd", "vgd", "svpack", "ivdev", "vprof", " vpack", "hneg", " vdevelopment", " vapp", "bvar", "vev", "wdevice", "ivdevice", " vdd", "ldb", "bdev", "varerror", "wgd", "evdev", "evneg", " vgd", "vdevice", "svdiv", "wrad", "vpub", "wserv", "Vpub", "lvdev", " vprof", "evev", "svapp", "vrad", "svprof", "vardraft", "lvpack", "ldevice", "ldev", "vardev", "lserver", "vserv", "vdd", "vneg", "lvapp", "evver", "vvar", "nvdraft", "svserv", "wde"], "nr": ["ru", "ctr", "rid", "nn", "nor", "ng", "nt", "br", "adr", "nc", "NR", "yr", "wr", "nom", "our", "kr", "rf", "lr", "runner", "sn", "rr", "rc", "num", "inv", "rb", "rin", "n", "eni", "np", "nb", "no", "range", "mr", "nu", "ni", "sr", "nov", "name", "ner", "err", "nm", "rn", "r", "nl", "nw", "rg", "number"], "bar": ["ha", "batch", "gap", "bug", "app", "grid", "card", "ar", "war", "user", "tab", "br", "project", "feature", "worker", "array", "area", "work", "Bar", "server", "google", "job", "page", "usa", "border", "db", "arrow", "group", "ga", "broad", "aer", "car", "this", "bg", "comment", "error", "bridge", "star", "block", "par", "progress", "gar", "bars", "item", "cor", "can", "org", "bad", "home", "cur", "ban", "far", "cat", "b", "order", "bag", "way", "table", "row", "ebin", "ca", "ab", "buffer", "er", "request", "r", "allow", "browser", "cart", "var", "show"]}}
{"project": "qemu", "commit_id": "babfa20ca4721e950d8096f32b1dc091763a8837", "target": 0, "func": "static bool ept_emulation_fault(uint64_t ept_qual)\n\n{\n\n    int read, write;\n\n\n\n    /* EPT fault on an instruction fetch doesn't make sense here */\n\n    if (ept_qual & EPT_VIOLATION_INST_FETCH) {\n\n        return false;\n\n    }\n\n\n\n    /* EPT fault must be a read fault or a write fault */\n\n    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;\n\n    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;\n\n    if ((read | write) == 0) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * The EPT violation must have been caused by accessing a\n\n     * guest-physical address that is a translation of a guest-linear\n\n     * address.\n\n     */\n\n    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||\n\n        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16318, "substitutes": {"ept_qual": ["apt_quant", "ester_qual", "ep2component", "ep2quant", "ept1quality", "ept_quality", "ester_quality", "ep_quality", "apt_qual", "eff_quality", "ept2qual", "apt_cert", "eff_quick", "ept__cert", "ept_quick", "ept_component", "ept2quality", "apt_quick", "ept1qual", "ept_qualified", "ept1component", "ep_quant", "ep2qual", "apt_quality", "ester_deep", "eff_qual", "ept_cert", "ep2quality", "ep_qual", "ept__quality", "ept__quick", "apt_qualified", "ept_equal", "ept1quant", "ept_deep", "eptalcert", "apt_equal", "ept_ident", "eptalqualified", "ept_quant", "eptalquality", "apt_ident", "ept2component", "eptalqual", "eff_cert", "ept__qual", "ester_quant", "ep_component", "ept2quant"], "read": ["update", "sync", "check", "send", "data", "reader", "raw", "count", "use", "length", "work", "size", "access", "pair", "play", "resource", "open", "reading", "level", "lex", "ride", "time", "view", "create", "Read", "add", "io", "boot", "id", "feed", "ip", "seek", "i", "x", "scan", "READ", "type", "index", "run", "start", "name", "load", "w", "child", "allow", "pass"], "write": ["update", "pipe", "sync", "fail", "want", "append", "writing", "send", "flow", "written", "data", "force", "network", "use", "end", "output", "size", "note", "writer", "unit", "vert", "key", "n", "writ", "lock", "change", "memory", "put", "Write", "drive", "index", "other", "wait", "name", "out", "w", "allow", "text", "enable"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,\n\n                       const int32_t **lumSrc, int lumFilterSize,\n\n                       const int16_t *chrFilter, const int32_t **chrUSrc,\n\n                       const int32_t **chrVSrc, int chrFilterSize,\n\n                       const int32_t **alpSrc, uint16_t *dest, int dstW,\n\n                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int j;\n\n        int Y  = -0x40000000;\n\n        int U  = -128 << 23; // 19\n\n        int V  = -128 << 23;\n\n        int R, G, B;\n\n\n\n        for (j = 0; j < lumFilterSize; j++) {\n\n            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];\n\n        }\n\n        for (j = 0; j < chrFilterSize; j++) {;\n\n            U += chrUSrc[j][i] * (unsigned)chrFilter[j];\n\n            V += chrVSrc[j][i] * (unsigned)chrFilter[j];\n\n        }\n\n\n\n        if (hasAlpha) {\n\n            A = -0x40000000;\n\n            for (j = 0; j < lumFilterSize; j++) {\n\n                A += alpSrc[j][i] * (unsigned)lumFilter[j];\n\n            }\n\n            A >>= 1;\n\n            A += 0x20002000;\n\n        }\n\n\n\n        // 8bit: 12+15=27; 16-bit: 12+19=31\n\n        Y  >>= 14; // 10\n\n        Y += 0x10000;\n\n        U  >>= 14;\n\n        V  >>= 14;\n\n\n\n        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit\n\n        Y -= c->yuv2rgb_y_offset;\n\n        Y *= c->yuv2rgb_y_coeff;\n\n        Y += 1 << 13; // 21\n\n        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n            dest += 4;\n\n        } else {\n\n            dest += 3;\n\n        }\n\n    }\n\n}\n", "idx": 16335, "substitutes": {"i": ["it", "d", "ie", "o", "di", "gi", "ij", "ini", "mi", "iu", "fi", "jc", "v", "li", "e", "u", "xi", "l", "pi", "oi", "uri", "ei", "si", "y", "ai", "m", "ui", "api", "q", "a", "ti", "z", "k", "ix", "n", "eni", "ik", "io", "id", "ci", "iv", "bi", "init", "qi", "phi", "x", "c", "h", "ami", "info", "ji", "p", "ip", "ri", "ki", "b", "ni", "f", "ir", "zi", "w", "r", "ii", "ori", "is", "I", "yi"], "j": ["it", "not", "adj", "ie", "d", "o", "json", "di", "dj", "jam", "J", "jp", "v", "li", "jl", "br", "e", "u", "obj", "l", "job", "si", "y", "m", "ui", "el", "jo", "jen", "aj", "g", "z", "k", "Ja", "jet", "n", "jj", "key", "ch", "fr", "ix", "block", "qi", "x", "ij", "h", "q", "ji", "p", "syn", "we", "b", "f", "js", "oj", "uj", "r", "je", "ii", "er", "jit", "t", "next", "ja", "jc"], "R": ["E", "T", "J", "Q", "AR", "C", "V", "P", "GR", "L", "GB", "W", "M", "SR", "K", "RA", "N", "H", "UR", "A", "O", "D", "Y", "U", "r", "F", "RR", "S", "X", "I"], "G": ["RG", "BG", "E", "J", "Q", "GG", "C", "V", "Gs", "P", "GR", "L", "GB", "GV", "GE", "W", "M", "GD", "g", "SG", "K", "N", "H", "A", "D", "LG", "Y", "GL", "U", "F", "S", "VG", "I"], "B": ["MB", "AB", "E", "T", "J", "AR", "OB", "C", "WB", "V", "Bi", "P", "L", "GB", "BB", "SB", "W", "PB", "BA", "Bs", "M", "BI", "BC", "BS", "BL", "NB", "H", "b", "DB", "BO", "O", "D", "Y", "U", "F", "UB"]}}
